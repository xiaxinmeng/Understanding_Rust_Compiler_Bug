{"sha": "7aa413d59206fd511137728df3d9e0fd377429bd", "node_id": "C_kwDOAAsO6NoAKDdhYTQxM2Q1OTIwNmZkNTExMTM3NzI4ZGYzZDllMGZkMzc3NDI5YmQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-19T18:17:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-19T18:17:26Z"}, "message": "Auto merge of #107921 - cjgillot:codegen-overflow-check, r=tmiasko\n\nMake codegen choose whether to emit overflow checks\n\nConstProp and DataflowConstProp currently have a specific code path not to propagate constants when they overflow. This is meant to have the correct behaviour when inlining from a crate with overflow checks (like `core`) into a crate compiled without.\n\nThis PR shifts the behaviour change to the `Assert(Overflow*)` MIR terminators: if the crate is compiled without overflow checks, just skip emitting the assertions. This is already what happens with `OverflowNeg`.\n\nThis allows ConstProp and DataflowConstProp to transform `CheckedBinaryOp(Add, u8::MAX, 1)` into `const (0, true)`, and let codegen ignore the `true`.\n\n The interpreter is modified to conform to this behaviour.\n\nFixes #35310", "tree": {"sha": "a65a0c418211c9e35c42d07245bbf42d5f1469c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a65a0c418211c9e35c42d07245bbf42d5f1469c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7aa413d59206fd511137728df3d9e0fd377429bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7aa413d59206fd511137728df3d9e0fd377429bd", "html_url": "https://github.com/rust-lang/rust/commit/7aa413d59206fd511137728df3d9e0fd377429bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7aa413d59206fd511137728df3d9e0fd377429bd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc89a803d64fb6172c8406996831353bee18c3a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc89a803d64fb6172c8406996831353bee18c3a7", "html_url": "https://github.com/rust-lang/rust/commit/dc89a803d64fb6172c8406996831353bee18c3a7"}, {"sha": "9f6c1df8723504d7d468c87af02670dd0067cc7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f6c1df8723504d7d468c87af02670dd0067cc7b", "html_url": "https://github.com/rust-lang/rust/commit/9f6c1df8723504d7d468c87af02670dd0067cc7b"}], "stats": {"total": 467, "additions": 250, "deletions": 217}, "files": [{"sha": "7f857528c7c5c4ca8c1018827f0a504d5cb00a20", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7aa413d59206fd511137728df3d9e0fd377429bd/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa413d59206fd511137728df3d9e0fd377429bd/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=7aa413d59206fd511137728df3d9e0fd377429bd", "patch": "@@ -347,7 +347,12 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n             }\n             TerminatorKind::Assert { cond, expected, msg, target, cleanup: _ } => {\n                 if !fx.tcx.sess.overflow_checks() {\n-                    if let mir::AssertKind::OverflowNeg(_) = *msg {\n+                    let overflow_not_to_check = match msg {\n+                        AssertKind::OverflowNeg(..) => true,\n+                        AssertKind::Overflow(op, ..) => op.is_checkable(),\n+                        _ => false,\n+                    };\n+                    if overflow_not_to_check {\n                         let target = fx.get_block(*target);\n                         fx.bcx.ins().jump(target, &[]);\n                         continue;\n@@ -567,15 +572,7 @@ fn codegen_stmt<'tcx>(\n                     let lhs = codegen_operand(fx, &lhs_rhs.0);\n                     let rhs = codegen_operand(fx, &lhs_rhs.1);\n \n-                    let res = if !fx.tcx.sess.overflow_checks() {\n-                        let val =\n-                            crate::num::codegen_int_binop(fx, bin_op, lhs, rhs).load_scalar(fx);\n-                        let is_overflow = fx.bcx.ins().iconst(types::I8, 0);\n-                        CValue::by_val_pair(val, is_overflow, lval.layout())\n-                    } else {\n-                        crate::num::codegen_checked_int_binop(fx, bin_op, lhs, rhs)\n-                    };\n-\n+                    let res = crate::num::codegen_checked_int_binop(fx, bin_op, lhs, rhs);\n                     lval.write_cvalue(fx, res);\n                 }\n                 Rvalue::UnaryOp(un_op, ref operand) => {"}, {"sha": "6feb3a7732e1295c8f65bb573b57cadca0ccda5c", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7aa413d59206fd511137728df3d9e0fd377429bd/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa413d59206fd511137728df3d9e0fd377429bd/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=7aa413d59206fd511137728df3d9e0fd377429bd", "patch": "@@ -493,20 +493,6 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             let res = crate::num::codegen_int_binop(fx, bin_op, x, y);\n             ret.write_cvalue(fx, res);\n         }\n-        sym::add_with_overflow | sym::sub_with_overflow | sym::mul_with_overflow => {\n-            intrinsic_args!(fx, args => (x, y); intrinsic);\n-\n-            assert_eq!(x.layout().ty, y.layout().ty);\n-            let bin_op = match intrinsic {\n-                sym::add_with_overflow => BinOp::Add,\n-                sym::sub_with_overflow => BinOp::Sub,\n-                sym::mul_with_overflow => BinOp::Mul,\n-                _ => unreachable!(),\n-            };\n-\n-            let res = crate::num::codegen_checked_int_binop(fx, bin_op, x, y);\n-            ret.write_cvalue(fx, res);\n-        }\n         sym::saturating_add | sym::saturating_sub => {\n             intrinsic_args!(fx, args => (lhs, rhs); intrinsic);\n "}, {"sha": "e105322a0b426eca9dcbae136b80fe9d6947e939", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7aa413d59206fd511137728df3d9e0fd377429bd/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa413d59206fd511137728df3d9e0fd377429bd/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=7aa413d59206fd511137728df3d9e0fd377429bd", "patch": "@@ -563,11 +563,13 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // with #[rustc_inherit_overflow_checks] and inlined from\n         // another crate (mostly core::num generic/#[inline] fns),\n         // while the current crate doesn't use overflow checks.\n-        // NOTE: Unlike binops, negation doesn't have its own\n-        // checked operation, just a comparison with the minimum\n-        // value, so we have to check for the assert message.\n-        if !bx.check_overflow() {\n-            if let AssertKind::OverflowNeg(_) = *msg {\n+        if !bx.cx().check_overflow() {\n+            let overflow_not_to_check = match msg {\n+                AssertKind::OverflowNeg(..) => true,\n+                AssertKind::Overflow(op, ..) => op.is_checkable(),\n+                _ => false,\n+            };\n+            if overflow_not_to_check {\n                 const_cond = Some(expected);\n             }\n         }"}, {"sha": "7af7fc92dbce2e0d3906927516d355d5231a5bf3", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7aa413d59206fd511137728df3d9e0fd377429bd/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa413d59206fd511137728df3d9e0fd377429bd/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=7aa413d59206fd511137728df3d9e0fd377429bd", "patch": "@@ -218,9 +218,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 args[1].val.unaligned_volatile_store(bx, dst);\n                 return;\n             }\n-            sym::add_with_overflow\n-            | sym::sub_with_overflow\n-            | sym::mul_with_overflow\n             | sym::unchecked_div\n             | sym::unchecked_rem\n             | sym::unchecked_shl\n@@ -232,28 +229,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let ty = arg_tys[0];\n                 match int_type_width_signed(ty, bx.tcx()) {\n                     Some((_width, signed)) => match name {\n-                        sym::add_with_overflow\n-                        | sym::sub_with_overflow\n-                        | sym::mul_with_overflow => {\n-                            let op = match name {\n-                                sym::add_with_overflow => OverflowOp::Add,\n-                                sym::sub_with_overflow => OverflowOp::Sub,\n-                                sym::mul_with_overflow => OverflowOp::Mul,\n-                                _ => bug!(),\n-                            };\n-                            let (val, overflow) =\n-                                bx.checked_binop(op, ty, args[0].immediate(), args[1].immediate());\n-                            // Convert `i1` to a `bool`, and write it to the out parameter\n-                            let val = bx.from_immediate(val);\n-                            let overflow = bx.from_immediate(overflow);\n-\n-                            let dest = result.project_field(bx, 0);\n-                            bx.store(val, dest.llval, dest.align);\n-                            let dest = result.project_field(bx, 1);\n-                            bx.store(overflow, dest.llval, dest.align);\n-\n-                            return;\n-                        }\n                         sym::exact_div => {\n                             if signed {\n                                 bx.exactsdiv(args[0].immediate(), args[1].immediate())"}, {"sha": "41cd1c09a4e70e637aa1adea65c58e33699b23d1", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7aa413d59206fd511137728df3d9e0fd377429bd/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa413d59206fd511137728df3d9e0fd377429bd/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=7aa413d59206fd511137728df3d9e0fd377429bd", "patch": "@@ -652,15 +652,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         rhs: Bx::Value,\n         input_ty: Ty<'tcx>,\n     ) -> OperandValue<Bx::Value> {\n-        // This case can currently arise only from functions marked\n-        // with #[rustc_inherit_overflow_checks] and inlined from\n-        // another crate (mostly core::num generic/#[inline] fns),\n-        // while the current crate doesn't use overflow checks.\n-        if !bx.cx().check_overflow() {\n-            let val = self.codegen_scalar_binop(bx, op, lhs, rhs, input_ty);\n-            return OperandValue::Pair(val, bx.cx().const_bool(false));\n-        }\n-\n         let (val, of) = match op {\n             // These are checked using intrinsics\n             mir::BinOp::Add | mir::BinOp::Sub | mir::BinOp::Mul => {"}, {"sha": "c5d558aeb6ccda0e5b20392fd9edf508fa101a47", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7aa413d59206fd511137728df3d9e0fd377429bd/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa413d59206fd511137728df3d9e0fd377429bd/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=7aa413d59206fd511137728df3d9e0fd377429bd", "patch": "@@ -210,19 +210,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let out_val = numeric_intrinsic(intrinsic_name, bits, kind);\n                 self.write_scalar(out_val, dest)?;\n             }\n-            sym::add_with_overflow | sym::sub_with_overflow | sym::mul_with_overflow => {\n-                let lhs = self.read_immediate(&args[0])?;\n-                let rhs = self.read_immediate(&args[1])?;\n-                let bin_op = match intrinsic_name {\n-                    sym::add_with_overflow => BinOp::Add,\n-                    sym::sub_with_overflow => BinOp::Sub,\n-                    sym::mul_with_overflow => BinOp::Mul,\n-                    _ => bug!(),\n-                };\n-                self.binop_with_overflow(\n-                    bin_op, /*force_overflow_checks*/ true, &lhs, &rhs, dest,\n-                )?;\n-            }\n             sym::saturating_add | sym::saturating_sub => {\n                 let l = self.read_immediate(&args[0])?;\n                 let r = self.read_immediate(&args[1])?;"}, {"sha": "450488315ef01d19b50963ca68fa79fd07614ed0", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7aa413d59206fd511137728df3d9e0fd377429bd/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa413d59206fd511137728df3d9e0fd377429bd/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=7aa413d59206fd511137728df3d9e0fd377429bd", "patch": "@@ -147,8 +147,9 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         true\n     }\n \n-    /// Whether CheckedBinOp MIR statements should actually check for overflow.\n-    fn checked_binop_checks_overflow(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n+    /// Whether Assert(OverflowNeg) and Assert(Overflow) MIR terminators should actually\n+    /// check for overflow.\n+    fn ignore_checkable_overflow_assertions(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n \n     /// Entry point for obtaining the MIR of anything that should get evaluated.\n     /// So not just functions and shims, but also const/static initializers, anonymous\n@@ -466,8 +467,8 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     }\n \n     #[inline(always)]\n-    fn checked_binop_checks_overflow(_ecx: &InterpCx<$mir, $tcx, Self>) -> bool {\n-        true\n+    fn ignore_checkable_overflow_assertions(_ecx: &InterpCx<$mir, $tcx, Self>) -> bool {\n+        false\n     }\n \n     #[inline(always)]"}, {"sha": "422120084d3182e3f692486bda7a351bcc30b482", "filename": "compiler/rustc_const_eval/src/interpret/operator.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7aa413d59206fd511137728df3d9e0fd377429bd/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa413d59206fd511137728df3d9e0fd377429bd/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs?ref=7aa413d59206fd511137728df3d9e0fd377429bd", "patch": "@@ -10,13 +10,9 @@ use super::{ImmTy, Immediate, InterpCx, Machine, PlaceTy};\n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Applies the binary operation `op` to the two operands and writes a tuple of the result\n     /// and a boolean signifying the potential overflow to the destination.\n-    ///\n-    /// `force_overflow_checks` indicates whether overflow checks should be done even when\n-    /// `tcx.sess.overflow_checks()` is `false`.\n     pub fn binop_with_overflow(\n         &mut self,\n         op: mir::BinOp,\n-        force_overflow_checks: bool,\n         left: &ImmTy<'tcx, M::Provenance>,\n         right: &ImmTy<'tcx, M::Provenance>,\n         dest: &PlaceTy<'tcx, M::Provenance>,\n@@ -28,10 +24,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             \"type mismatch for result of {:?}\",\n             op,\n         );\n-        // As per https://github.com/rust-lang/rust/pull/98738, we always return `false` in the 2nd\n-        // component when overflow checking is disabled.\n-        let overflowed =\n-            overflowed && (force_overflow_checks || M::checked_binop_checks_overflow(self));\n         // Write the result to `dest`.\n         if let Abi::ScalarPair(..) = dest.layout.abi {\n             // We can use the optimized path and avoid `place_field` (which might do"}, {"sha": "6863435e5087813d315084abbf4c4221d9e165bd", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aa413d59206fd511137728df3d9e0fd377429bd/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa413d59206fd511137728df3d9e0fd377429bd/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=7aa413d59206fd511137728df3d9e0fd377429bd", "patch": "@@ -185,9 +185,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let left = self.read_immediate(&self.eval_operand(left, None)?)?;\n                 let layout = binop_right_homogeneous(bin_op).then_some(left.layout);\n                 let right = self.read_immediate(&self.eval_operand(right, layout)?)?;\n-                self.binop_with_overflow(\n-                    bin_op, /*force_overflow_checks*/ false, &left, &right, &dest,\n-                )?;\n+                self.binop_with_overflow(bin_op, &left, &right, &dest)?;\n             }\n \n             UnaryOp(un_op, ref operand) => {"}, {"sha": "294bd35c13ee1529ba09c9a07dfaeb42b1b750dd", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7aa413d59206fd511137728df3d9e0fd377429bd/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa413d59206fd511137728df3d9e0fd377429bd/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=7aa413d59206fd511137728df3d9e0fd377429bd", "patch": "@@ -137,8 +137,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             Assert { ref cond, expected, ref msg, target, cleanup } => {\n+                let ignored = M::ignore_checkable_overflow_assertions(self)\n+                    && match msg {\n+                        mir::AssertKind::OverflowNeg(..) => true,\n+                        mir::AssertKind::Overflow(op, ..) => op.is_checkable(),\n+                        _ => false,\n+                    };\n                 let cond_val = self.read_scalar(&self.eval_operand(cond, None)?)?.to_bool()?;\n-                if expected == cond_val {\n+                if ignored || expected == cond_val {\n                     self.go_to_block(target);\n                 } else {\n                     M::assert_panic(self, msg, cleanup)?;"}, {"sha": "ae09562a85e987e5102654fbb154252a34ccd7cb", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7aa413d59206fd511137728df3d9e0fd377429bd/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa413d59206fd511137728df3d9e0fd377429bd/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=7aa413d59206fd511137728df3d9e0fd377429bd", "patch": "@@ -671,6 +671,12 @@ pub enum TerminatorKind<'tcx> {\n     /// as parameters, and `None` for the destination. Keep in mind that the `cleanup` path is not\n     /// necessarily executed even in the case of a panic, for example in `-C panic=abort`. If the\n     /// assertion does not fail, execution continues at the specified basic block.\n+    ///\n+    /// When overflow checking is disabled and this is run-time MIR (as opposed to compile-time MIR\n+    /// that is used for CTFE), the following variants of this terminator behave as `goto target`:\n+    /// - `OverflowNeg(..)`,\n+    /// - `Overflow(op, ..)` if op is a \"checkable\" operation (add, sub, mul, shl, shr, but NOT\n+    /// div or rem).\n     Assert {\n         cond: Operand<'tcx>,\n         expected: bool,\n@@ -1103,10 +1109,6 @@ pub enum Rvalue<'tcx> {\n \n     /// Same as `BinaryOp`, but yields `(T, bool)` with a `bool` indicating an error condition.\n     ///\n-    /// When overflow checking is disabled and we are generating run-time code, the error condition\n-    /// is false. Otherwise, and always during CTFE, the error condition is determined as described\n-    /// below.\n-    ///\n     /// For addition, subtraction, and multiplication on integers the error condition is set when\n     /// the infinite precision result would be unequal to the actual result.\n     ///"}, {"sha": "33ee90ffc119dc132114f1fbd749e54364690004", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 15, "deletions": 96, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/7aa413d59206fd511137728df3d9e0fd377429bd/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa413d59206fd511137728df3d9e0fd377429bd/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=7aa413d59206fd511137728df3d9e0fd377429bd", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::mir::visit::{\n };\n use rustc_middle::mir::{\n     BasicBlock, BinOp, Body, Constant, ConstantKind, Local, LocalDecl, LocalKind, Location,\n-    Operand, Place, Rvalue, SourceInfo, Statement, StatementKind, Terminator, TerminatorKind, UnOp,\n+    Operand, Place, Rvalue, SourceInfo, Statement, StatementKind, Terminator, TerminatorKind,\n     RETURN_PLACE,\n };\n use rustc_middle::ty::layout::{LayoutError, LayoutOf, LayoutOfHelpers, TyAndLayout};\n@@ -503,55 +503,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n     }\n \n-    fn check_unary_op(&mut self, op: UnOp, arg: &Operand<'tcx>) -> Option<()> {\n-        if self.use_ecx(|this| {\n-            let val = this.ecx.read_immediate(&this.ecx.eval_operand(arg, None)?)?;\n-            let (_res, overflow, _ty) = this.ecx.overflowing_unary_op(op, &val)?;\n-            Ok(overflow)\n-        })? {\n-            // `AssertKind` only has an `OverflowNeg` variant, so make sure that is\n-            // appropriate to use.\n-            assert_eq!(op, UnOp::Neg, \"Neg is the only UnOp that can overflow\");\n-            return None;\n-        }\n-\n-        Some(())\n-    }\n-\n-    fn check_binary_op(\n-        &mut self,\n-        op: BinOp,\n-        left: &Operand<'tcx>,\n-        right: &Operand<'tcx>,\n-    ) -> Option<()> {\n-        let r = self.use_ecx(|this| this.ecx.read_immediate(&this.ecx.eval_operand(right, None)?));\n-        let l = self.use_ecx(|this| this.ecx.read_immediate(&this.ecx.eval_operand(left, None)?));\n-        // Check for exceeding shifts *even if* we cannot evaluate the LHS.\n-        if matches!(op, BinOp::Shr | BinOp::Shl) {\n-            let r = r.clone()?;\n-            // We need the type of the LHS. We cannot use `place_layout` as that is the type\n-            // of the result, which for checked binops is not the same!\n-            let left_ty = left.ty(self.local_decls, self.tcx);\n-            let left_size = self.ecx.layout_of(left_ty).ok()?.size;\n-            let right_size = r.layout.size;\n-            let r_bits = r.to_scalar().to_bits(right_size).ok();\n-            if r_bits.map_or(false, |b| b >= left_size.bits() as u128) {\n-                return None;\n-            }\n-        }\n-\n-        if let (Some(l), Some(r)) = (&l, &r) {\n-            // The remaining operators are handled through `overflowing_binary_op`.\n-            if self.use_ecx(|this| {\n-                let (_res, overflow, _ty) = this.ecx.overflowing_binary_op(op, l, r)?;\n-                Ok(overflow)\n-            })? {\n-                return None;\n-            }\n-        }\n-        Some(())\n-    }\n-\n     fn propagate_operand(&mut self, operand: &mut Operand<'tcx>) {\n         match *operand {\n             Operand::Copy(l) | Operand::Move(l) => {\n@@ -587,28 +538,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         //   2. Working around bugs in other parts of the compiler\n         //        - In this case, we'll return `None` from this function to stop evaluation.\n         match rvalue {\n-            // Additional checking: give lints to the user if an overflow would occur.\n-            // We do this here and not in the `Assert` terminator as that terminator is\n-            // only sometimes emitted (overflow checks can be disabled), but we want to always\n-            // lint.\n-            Rvalue::UnaryOp(op, arg) => {\n-                trace!(\"checking UnaryOp(op = {:?}, arg = {:?})\", op, arg);\n-                self.check_unary_op(*op, arg)?;\n-            }\n-            Rvalue::BinaryOp(op, box (left, right)) => {\n-                trace!(\"checking BinaryOp(op = {:?}, left = {:?}, right = {:?})\", op, left, right);\n-                self.check_binary_op(*op, left, right)?;\n-            }\n-            Rvalue::CheckedBinaryOp(op, box (left, right)) => {\n-                trace!(\n-                    \"checking CheckedBinaryOp(op = {:?}, left = {:?}, right = {:?})\",\n-                    op,\n-                    left,\n-                    right\n-                );\n-                self.check_binary_op(*op, left, right)?;\n-            }\n-\n             // Do not try creating references (#67862)\n             Rvalue::AddressOf(_, place) | Rvalue::Ref(_, _, place) => {\n                 trace!(\"skipping AddressOf | Ref for {:?}\", place);\n@@ -638,7 +567,10 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             | Rvalue::Cast(..)\n             | Rvalue::ShallowInitBox(..)\n             | Rvalue::Discriminant(..)\n-            | Rvalue::NullaryOp(..) => {}\n+            | Rvalue::NullaryOp(..)\n+            | Rvalue::UnaryOp(..)\n+            | Rvalue::BinaryOp(..)\n+            | Rvalue::CheckedBinaryOp(..) => {}\n         }\n \n         // FIXME we need to revisit this for #67176\n@@ -1079,31 +1011,18 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n         // Do NOT early return in this function, it does some crucial fixup of the state at the end!\n         match &mut terminator.kind {\n             TerminatorKind::Assert { expected, ref mut cond, .. } => {\n-                if let Some(ref value) = self.eval_operand(&cond) {\n-                    trace!(\"assertion on {:?} should be {:?}\", value, expected);\n-                    let expected = Scalar::from_bool(*expected);\n+                if let Some(ref value) = self.eval_operand(&cond)\n                     // FIXME should be used use_ecx rather than a local match... but we have\n                     // quite a few of these read_scalar/read_immediate that need fixing.\n-                    if let Ok(value_const) = self.ecx.read_scalar(&value) {\n-                        if expected != value_const {\n-                            // Poison all places this operand references so that further code\n-                            // doesn't use the invalid value\n-                            match cond {\n-                                Operand::Move(ref place) | Operand::Copy(ref place) => {\n-                                    Self::remove_const(&mut self.ecx, place.local);\n-                                }\n-                                Operand::Constant(_) => {}\n-                            }\n-                        } else {\n-                            if self.should_const_prop(value) {\n-                                *cond = self.operand_from_scalar(\n-                                    value_const,\n-                                    self.tcx.types.bool,\n-                                    source_info.span,\n-                                );\n-                            }\n-                        }\n-                    }\n+                    && let Ok(value_const) = self.ecx.read_scalar(&value)\n+                    && self.should_const_prop(value)\n+                {\n+                    trace!(\"assertion on {:?} should be {:?}\", value, expected);\n+                    *cond = self.operand_from_scalar(\n+                        value_const,\n+                        self.tcx.types.bool,\n+                        source_info.span,\n+                    );\n                 }\n             }\n             TerminatorKind::SwitchInt { ref mut discr, .. } => {"}, {"sha": "19019e3ef744aa8cd7121ef89da72eb654656b8a", "filename": "compiler/rustc_mir_transform/src/dataflow_const_prop.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7aa413d59206fd511137728df3d9e0fd377429bd/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa413d59206fd511137728df3d9e0fd377429bd/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs?ref=7aa413d59206fd511137728df3d9e0fd377429bd", "patch": "@@ -180,12 +180,7 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'_, 'tcx> {\n                         let overflow = match overflow {\n                             FlatSet::Top => FlatSet::Top,\n                             FlatSet::Elem(overflow) => {\n-                                if overflow {\n-                                    // Overflow cannot be reliably propagated. See: https://github.com/rust-lang/rust/pull/101168#issuecomment-1288091446\n-                                    FlatSet::Top\n-                                } else {\n-                                    self.wrap_scalar(Scalar::from_bool(false), self.tcx.types.bool)\n-                                }\n+                                self.wrap_scalar(Scalar::from_bool(overflow), self.tcx.types.bool)\n                             }\n                             FlatSet::Bottom => FlatSet::Bottom,\n                         };"}, {"sha": "f596cc1808fa2b491fc8b82170df85d88f75eef6", "filename": "compiler/rustc_mir_transform/src/lower_intrinsics.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7aa413d59206fd511137728df3d9e0fd377429bd/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa413d59206fd511137728df3d9e0fd377429bd/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs?ref=7aa413d59206fd511137728df3d9e0fd377429bd", "patch": "@@ -107,9 +107,29 @@ impl<'tcx> MirPass<'tcx> for LowerIntrinsics {\n                         }\n                     }\n                     sym::add_with_overflow | sym::sub_with_overflow | sym::mul_with_overflow => {\n-                        // The checked binary operations are not suitable target for lowering here,\n-                        // since their semantics depend on the value of overflow-checks flag used\n-                        // during codegen. Issue #35310.\n+                        if let Some(target) = *target {\n+                            let lhs;\n+                            let rhs;\n+                            {\n+                                let mut args = args.drain(..);\n+                                lhs = args.next().unwrap();\n+                                rhs = args.next().unwrap();\n+                            }\n+                            let bin_op = match intrinsic_name {\n+                                sym::add_with_overflow => BinOp::Add,\n+                                sym::sub_with_overflow => BinOp::Sub,\n+                                sym::mul_with_overflow => BinOp::Mul,\n+                                _ => bug!(\"unexpected intrinsic\"),\n+                            };\n+                            block.statements.push(Statement {\n+                                source_info: terminator.source_info,\n+                                kind: StatementKind::Assign(Box::new((\n+                                    *destination,\n+                                    Rvalue::CheckedBinaryOp(bin_op, Box::new((lhs, rhs))),\n+                                ))),\n+                            });\n+                            terminator.kind = TerminatorKind::Goto { target };\n+                        }\n                     }\n                     sym::size_of | sym::min_align_of => {\n                         if let Some(target) = *target {"}, {"sha": "8bd1e802f8a52e4e64106675dde340d302d7cdd0", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aa413d59206fd511137728df3d9e0fd377429bd/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa413d59206fd511137728df3d9e0fd377429bd/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=7aa413d59206fd511137728df3d9e0fd377429bd", "patch": "@@ -815,8 +815,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n     }\n \n     #[inline(always)]\n-    fn checked_binop_checks_overflow(ecx: &MiriInterpCx<'mir, 'tcx>) -> bool {\n-        ecx.tcx.sess.overflow_checks()\n+    fn ignore_checkable_overflow_assertions(ecx: &MiriInterpCx<'mir, 'tcx>) -> bool {\n+        !ecx.tcx.sess.overflow_checks()\n     }\n \n     #[inline(always)]"}, {"sha": "0b0b890b2c99a0343c495c35b78e11742defee2f", "filename": "tests/codegen/inherit_overflow.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7aa413d59206fd511137728df3d9e0fd377429bd/tests%2Fcodegen%2Finherit_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa413d59206fd511137728df3d9e0fd377429bd/tests%2Fcodegen%2Finherit_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Finherit_overflow.rs?ref=7aa413d59206fd511137728df3d9e0fd377429bd", "patch": "@@ -0,0 +1,14 @@\n+// compile-flags: -Zmir-enable-passes=+Inline,+ConstProp --crate-type lib\n+// revisions: ASSERT NOASSERT\n+//[ASSERT] compile-flags: -Coverflow-checks=on\n+//[NOASSERT] compile-flags: -Coverflow-checks=off\n+\n+// CHECK-LABEL: define{{.*}} @assertion\n+// ASSERT: call void @_ZN4core9panicking5panic17h\n+// NOASSERT: ret i8 0\n+#[no_mangle]\n+pub fn assertion() -> u8 {\n+    // Optimized MIR will replace this `CheckedBinaryOp` by `const (0, true)`.\n+    // Verify that codegen does or does not emit the panic.\n+    <u8 as std::ops::Add>::add(255, 1)\n+}"}, {"sha": "900061a484b3884b85d103d4c532b93ba6ac05d5", "filename": "tests/mir-opt/const_prop/bad_op_div_by_zero.main.ConstProp.diff", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7aa413d59206fd511137728df3d9e0fd377429bd/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_div_by_zero.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7aa413d59206fd511137728df3d9e0fd377429bd/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_div_by_zero.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_div_by_zero.main.ConstProp.diff?ref=7aa413d59206fd511137728df3d9e0fd377429bd", "patch": "@@ -24,9 +24,10 @@\n           StorageLive(_3);                 // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:18: +2:19\n -         _3 = _1;                         // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:18: +2:19\n -         _4 = Eq(_3, const 0_i32);        // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:14: +2:19\n+-         assert(!move _4, \"attempt to divide `{}` by zero\", const 1_i32) -> bb1; // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:14: +2:19\n +         _3 = const 0_i32;                // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:18: +2:19\n +         _4 = const true;                 // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:14: +2:19\n-          assert(!move _4, \"attempt to divide `{}` by zero\", const 1_i32) -> bb1; // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:14: +2:19\n++         assert(!const true, \"attempt to divide `{}` by zero\", const 1_i32) -> bb1; // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:14: +2:19\n       }\n   \n       bb1: {"}, {"sha": "d03c23a3fb56c1893155f6bab9c589ba2f15bb7c", "filename": "tests/mir-opt/const_prop/inherit_overflow.main.ConstProp.diff", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7aa413d59206fd511137728df3d9e0fd377429bd/tests%2Fmir-opt%2Fconst_prop%2Finherit_overflow.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7aa413d59206fd511137728df3d9e0fd377429bd/tests%2Fmir-opt%2Fconst_prop%2Finherit_overflow.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Finherit_overflow.main.ConstProp.diff?ref=7aa413d59206fd511137728df3d9e0fd377429bd", "patch": "@@ -0,0 +1,39 @@\n+- // MIR for `main` before ConstProp\n++ // MIR for `main` after ConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/inherit_overflow.rs:+0:11: +0:11\n+      let mut _1: u8;                      // in scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+      let mut _2: u8;                      // in scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+      let mut _3: u8;                      // in scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+      scope 1 {\n+      }\n+      scope 2 (inlined <u8 as Add>::add) { // at $DIR/inherit_overflow.rs:8:13: 8:47\n+          debug self => _2;                // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          debug other => _3;               // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          let mut _4: (u8, bool);          // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          StorageLive(_2);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          _2 = const u8::MAX;              // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          StorageLive(_3);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          _3 = const 1_u8;                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+-         _4 = CheckedAdd(_2, _3);         // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+-         assert(!move (_4.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, _3) -> bb1; // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n++         _4 = const (0_u8, true);         // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n++         assert(!const true, \"attempt to compute `{} + {}`, which would overflow\", _2, _3) -> bb1; // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+      }\n+  \n+      bb1: {\n+-         _1 = move (_4.0: u8);            // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n++         _1 = const 0_u8;                 // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          StorageDead(_3);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          StorageDead(_2);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          StorageDead(_1);                 // scope 0 at $DIR/inherit_overflow.rs:+3:47: +3:48\n+          _0 = const ();                   // scope 0 at $DIR/inherit_overflow.rs:+0:11: +4:2\n+          return;                          // scope 0 at $DIR/inherit_overflow.rs:+4:2: +4:2\n+      }\n+  }\n+  "}, {"sha": "541a8c5c3af28779366e6b21334e5681c5497933", "filename": "tests/mir-opt/const_prop/inherit_overflow.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7aa413d59206fd511137728df3d9e0fd377429bd/tests%2Fmir-opt%2Fconst_prop%2Finherit_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa413d59206fd511137728df3d9e0fd377429bd/tests%2Fmir-opt%2Fconst_prop%2Finherit_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Finherit_overflow.rs?ref=7aa413d59206fd511137728df3d9e0fd377429bd", "patch": "@@ -0,0 +1,9 @@\n+// unit-test: ConstProp\n+// compile-flags: -Zmir-enable-passes=+Inline\n+\n+// EMIT_MIR inherit_overflow.main.ConstProp.diff\n+fn main() {\n+    // After inlining, this will contain a `CheckedBinaryOp`.\n+    // Propagating the overflow is ok as codegen will just skip emitting the panic.\n+    let _ = <u8 as std::ops::Add>::add(255, 1);\n+}"}, {"sha": "944afed8f465abd701e2c10dc3f59997cfc1364e", "filename": "tests/mir-opt/dataflow-const-prop/checked.main.DataflowConstProp.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aa413d59206fd511137728df3d9e0fd377429bd/tests%2Fmir-opt%2Fdataflow-const-prop%2Fchecked.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7aa413d59206fd511137728df3d9e0fd377429bd/tests%2Fmir-opt%2Fdataflow-const-prop%2Fchecked.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdataflow-const-prop%2Fchecked.main.DataflowConstProp.diff?ref=7aa413d59206fd511137728df3d9e0fd377429bd", "patch": "@@ -61,7 +61,7 @@\n -         assert(!move (_10.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _9, const 1_i32) -> bb2; // scope 4 at $DIR/checked.rs:+6:13: +6:18\n +         _9 = const i32::MAX;             // scope 4 at $DIR/checked.rs:+6:13: +6:14\n +         _10 = CheckedAdd(const i32::MAX, const 1_i32); // scope 4 at $DIR/checked.rs:+6:13: +6:18\n-+         assert(!move (_10.1: bool), \"attempt to compute `{} + {}`, which would overflow\", const i32::MAX, const 1_i32) -> bb2; // scope 4 at $DIR/checked.rs:+6:13: +6:18\n++         assert(!const true, \"attempt to compute `{} + {}`, which would overflow\", const i32::MAX, const 1_i32) -> bb2; // scope 4 at $DIR/checked.rs:+6:13: +6:18\n       }\n   \n       bb2: {"}, {"sha": "29781e9ce18866feb12327d4f7c7378fcbce7e6f", "filename": "tests/mir-opt/dataflow-const-prop/inherit_overflow.main.DataflowConstProp.diff", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7aa413d59206fd511137728df3d9e0fd377429bd/tests%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7aa413d59206fd511137728df3d9e0fd377429bd/tests%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.main.DataflowConstProp.diff?ref=7aa413d59206fd511137728df3d9e0fd377429bd", "patch": "@@ -5,26 +5,34 @@\n       let mut _0: ();                      // return place in scope 0 at $DIR/inherit_overflow.rs:+0:11: +0:11\n       let mut _1: u8;                      // in scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n       let mut _2: u8;                      // in scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+      let mut _3: u8;                      // in scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n       scope 1 {\n       }\n-      scope 2 (inlined <u8 as Add>::add) { // at $DIR/inherit_overflow.rs:7:13: 7:47\n-          debug self => _1;                // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-          debug other => _2;               // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-          let mut _3: (u8, bool);          // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+      scope 2 (inlined <u8 as Add>::add) { // at $DIR/inherit_overflow.rs:8:13: 8:47\n+          debug self => _2;                // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          debug other => _3;               // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          let mut _4: (u8, bool);          // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n       }\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n-          _1 = const u8::MAX;              // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n           StorageLive(_2);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n-          _2 = const 1_u8;                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n-          _3 = CheckedAdd(const u8::MAX, const 1_u8); // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-          assert(!move (_3.1: bool), \"attempt to compute `{} + {}`, which would overflow\", const u8::MAX, const 1_u8) -> bb1; // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          _2 = const u8::MAX;              // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          StorageLive(_3);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          _3 = const 1_u8;                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+-         _4 = CheckedAdd(_2, _3);         // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+-         assert(!move (_4.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, _3) -> bb1; // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n++         _4 = CheckedAdd(const u8::MAX, const 1_u8); // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n++         assert(!const true, \"attempt to compute `{} + {}`, which would overflow\", const u8::MAX, const 1_u8) -> bb1; // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n       }\n   \n       bb1: {\n+-         _1 = move (_4.0: u8);            // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n++         _1 = const 0_u8;                 // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          StorageDead(_3);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n           StorageDead(_2);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n-          StorageDead(_1);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          StorageDead(_1);                 // scope 0 at $DIR/inherit_overflow.rs:+3:47: +3:48\n+          _0 = const ();                   // scope 0 at $DIR/inherit_overflow.rs:+0:11: +4:2\n           return;                          // scope 0 at $DIR/inherit_overflow.rs:+4:2: +4:2\n       }\n   }"}, {"sha": "f4aba60f0c801666dc9a4b0031d85d781cd63111", "filename": "tests/mir-opt/dataflow-const-prop/inherit_overflow.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7aa413d59206fd511137728df3d9e0fd377429bd/tests%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa413d59206fd511137728df3d9e0fd377429bd/tests%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.rs?ref=7aa413d59206fd511137728df3d9e0fd377429bd", "patch": "@@ -1,8 +1,9 @@\n-// compile-flags: -Zunsound-mir-opts\n+// unit-test: DataflowConstProp\n+// compile-flags: -Zmir-enable-passes=+Inline\n \n // EMIT_MIR inherit_overflow.main.DataflowConstProp.diff\n fn main() {\n-    // After inlining, this will contain a `CheckedBinaryOp`. The overflow\n-    // must be ignored by the constant propagation to avoid triggering a panic.\n+    // After inlining, this will contain a `CheckedBinaryOp`.\n+    // Propagating the overflow is ok as codegen will just skip emitting the panic.\n     let _ = <u8 as std::ops::Add>::add(255, 1);\n }"}, {"sha": "7147be43ca5e36eb180f456633abdf25a9c082e7", "filename": "tests/mir-opt/lower_intrinsics.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7aa413d59206fd511137728df3d9e0fd377429bd/tests%2Fmir-opt%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa413d59206fd511137728df3d9e0fd377429bd/tests%2Fmir-opt%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.rs?ref=7aa413d59206fd511137728df3d9e0fd377429bd", "patch": "@@ -72,3 +72,10 @@ pub fn assume() {\n         std::intrinsics::assume(true);\n     }\n }\n+\n+// EMIT_MIR lower_intrinsics.with_overflow.LowerIntrinsics.diff\n+pub fn with_overflow(a: i32, b: i32) {\n+    let _x = core::intrinsics::add_with_overflow(a, b);\n+    let _y = core::intrinsics::sub_with_overflow(a, b);\n+    let _z = core::intrinsics::mul_with_overflow(a, b);\n+}"}, {"sha": "9870a70dec5eed17801559be9e1c7980d0ea588a", "filename": "tests/mir-opt/lower_intrinsics.with_overflow.LowerIntrinsics.diff", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/7aa413d59206fd511137728df3d9e0fd377429bd/tests%2Fmir-opt%2Flower_intrinsics.with_overflow.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7aa413d59206fd511137728df3d9e0fd377429bd/tests%2Fmir-opt%2Flower_intrinsics.with_overflow.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.with_overflow.LowerIntrinsics.diff?ref=7aa413d59206fd511137728df3d9e0fd377429bd", "patch": "@@ -0,0 +1,83 @@\n+- // MIR for `with_overflow` before LowerIntrinsics\n++ // MIR for `with_overflow` after LowerIntrinsics\n+  \n+  fn with_overflow(_1: i32, _2: i32) -> () {\n+      debug a => _1;                       // in scope 0 at $DIR/lower_intrinsics.rs:+0:22: +0:23\n+      debug b => _2;                       // in scope 0 at $DIR/lower_intrinsics.rs:+0:30: +0:31\n+      let mut _0: ();                      // return place in scope 0 at $DIR/lower_intrinsics.rs:+0:38: +0:38\n+      let _3: (i32, bool);                 // in scope 0 at $DIR/lower_intrinsics.rs:+1:9: +1:11\n+      let mut _4: i32;                     // in scope 0 at $DIR/lower_intrinsics.rs:+1:50: +1:51\n+      let mut _5: i32;                     // in scope 0 at $DIR/lower_intrinsics.rs:+1:53: +1:54\n+      let mut _7: i32;                     // in scope 0 at $DIR/lower_intrinsics.rs:+2:50: +2:51\n+      let mut _8: i32;                     // in scope 0 at $DIR/lower_intrinsics.rs:+2:53: +2:54\n+      let mut _10: i32;                    // in scope 0 at $DIR/lower_intrinsics.rs:+3:50: +3:51\n+      let mut _11: i32;                    // in scope 0 at $DIR/lower_intrinsics.rs:+3:53: +3:54\n+      scope 1 {\n+          debug _x => _3;                  // in scope 1 at $DIR/lower_intrinsics.rs:+1:9: +1:11\n+          let _6: (i32, bool);             // in scope 1 at $DIR/lower_intrinsics.rs:+2:9: +2:11\n+          scope 2 {\n+              debug _y => _6;              // in scope 2 at $DIR/lower_intrinsics.rs:+2:9: +2:11\n+              let _9: (i32, bool);         // in scope 2 at $DIR/lower_intrinsics.rs:+3:9: +3:11\n+              scope 3 {\n+                  debug _z => _9;          // in scope 3 at $DIR/lower_intrinsics.rs:+3:9: +3:11\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_3);                 // scope 0 at $DIR/lower_intrinsics.rs:+1:9: +1:11\n+          StorageLive(_4);                 // scope 0 at $DIR/lower_intrinsics.rs:+1:50: +1:51\n+          _4 = _1;                         // scope 0 at $DIR/lower_intrinsics.rs:+1:50: +1:51\n+          StorageLive(_5);                 // scope 0 at $DIR/lower_intrinsics.rs:+1:53: +1:54\n+          _5 = _2;                         // scope 0 at $DIR/lower_intrinsics.rs:+1:53: +1:54\n+-         _3 = add_with_overflow::<i32>(move _4, move _5) -> bb1; // scope 0 at $DIR/lower_intrinsics.rs:+1:14: +1:55\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/lower_intrinsics.rs:78:14: 78:49\n+-                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> (i32, bool) {add_with_overflow::<i32>}, val: Value(<ZST>) }\n++         _3 = CheckedAdd(move _4, move _5); // scope 0 at $DIR/lower_intrinsics.rs:+1:14: +1:55\n++         goto -> bb1;                     // scope 0 at $DIR/lower_intrinsics.rs:+1:14: +1:55\n+      }\n+  \n+      bb1: {\n+          StorageDead(_5);                 // scope 0 at $DIR/lower_intrinsics.rs:+1:54: +1:55\n+          StorageDead(_4);                 // scope 0 at $DIR/lower_intrinsics.rs:+1:54: +1:55\n+          StorageLive(_6);                 // scope 1 at $DIR/lower_intrinsics.rs:+2:9: +2:11\n+          StorageLive(_7);                 // scope 1 at $DIR/lower_intrinsics.rs:+2:50: +2:51\n+          _7 = _1;                         // scope 1 at $DIR/lower_intrinsics.rs:+2:50: +2:51\n+          StorageLive(_8);                 // scope 1 at $DIR/lower_intrinsics.rs:+2:53: +2:54\n+          _8 = _2;                         // scope 1 at $DIR/lower_intrinsics.rs:+2:53: +2:54\n+-         _6 = sub_with_overflow::<i32>(move _7, move _8) -> bb2; // scope 1 at $DIR/lower_intrinsics.rs:+2:14: +2:55\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/lower_intrinsics.rs:79:14: 79:49\n+-                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> (i32, bool) {sub_with_overflow::<i32>}, val: Value(<ZST>) }\n++         _6 = CheckedSub(move _7, move _8); // scope 1 at $DIR/lower_intrinsics.rs:+2:14: +2:55\n++         goto -> bb2;                     // scope 1 at $DIR/lower_intrinsics.rs:+2:14: +2:55\n+      }\n+  \n+      bb2: {\n+          StorageDead(_8);                 // scope 1 at $DIR/lower_intrinsics.rs:+2:54: +2:55\n+          StorageDead(_7);                 // scope 1 at $DIR/lower_intrinsics.rs:+2:54: +2:55\n+          StorageLive(_9);                 // scope 2 at $DIR/lower_intrinsics.rs:+3:9: +3:11\n+          StorageLive(_10);                // scope 2 at $DIR/lower_intrinsics.rs:+3:50: +3:51\n+          _10 = _1;                        // scope 2 at $DIR/lower_intrinsics.rs:+3:50: +3:51\n+          StorageLive(_11);                // scope 2 at $DIR/lower_intrinsics.rs:+3:53: +3:54\n+          _11 = _2;                        // scope 2 at $DIR/lower_intrinsics.rs:+3:53: +3:54\n+-         _9 = mul_with_overflow::<i32>(move _10, move _11) -> bb3; // scope 2 at $DIR/lower_intrinsics.rs:+3:14: +3:55\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/lower_intrinsics.rs:80:14: 80:49\n+-                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> (i32, bool) {mul_with_overflow::<i32>}, val: Value(<ZST>) }\n++         _9 = CheckedMul(move _10, move _11); // scope 2 at $DIR/lower_intrinsics.rs:+3:14: +3:55\n++         goto -> bb3;                     // scope 2 at $DIR/lower_intrinsics.rs:+3:14: +3:55\n+      }\n+  \n+      bb3: {\n+          StorageDead(_11);                // scope 2 at $DIR/lower_intrinsics.rs:+3:54: +3:55\n+          StorageDead(_10);                // scope 2 at $DIR/lower_intrinsics.rs:+3:54: +3:55\n+          _0 = const ();                   // scope 0 at $DIR/lower_intrinsics.rs:+0:38: +4:2\n+          StorageDead(_9);                 // scope 2 at $DIR/lower_intrinsics.rs:+4:1: +4:2\n+          StorageDead(_6);                 // scope 1 at $DIR/lower_intrinsics.rs:+4:1: +4:2\n+          StorageDead(_3);                 // scope 0 at $DIR/lower_intrinsics.rs:+4:1: +4:2\n+          return;                          // scope 0 at $DIR/lower_intrinsics.rs:+4:2: +4:2\n+      }\n+  }\n+  "}]}