{"sha": "2f847b81a0d8633f200f2c2269c1c43fe9e7def3", "node_id": "C_kwDOAAsO6NoAKDJmODQ3YjgxYTBkODYzM2YyMDBmMmMyMjY5YzFjNDNmZTllN2RlZjM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-29T09:57:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-29T09:57:44Z"}, "message": "Auto merge of #99892 - JohnTitor:rollup-qi4fem8, r=JohnTitor\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #99686 (add suggestion when there is a impl of external trait on pointer with wrong coherence rules)\n - #99760 (doc/rustc: describe the uefi target platforms)\n - #99766 (Htmldocck: Substitute the doc channel when blessing)\n - #99781 (Use String::from_utf8_lossy in CStr demo)\n - #99803 (Update mentions to `rustc_metadata::rmeta::Lazy`)\n - #99845 (Remove `$` prefix for bash scripts in doc)\n - #99850 (rustdoc: Remove more Clean trait implementations)\n - #99872 (Clone the `src/llvm-project` submodule if profiling is enabled)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "c3e1a436a3c47079cbaa9ad7d15567550f2161d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3e1a436a3c47079cbaa9ad7d15567550f2161d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f847b81a0d8633f200f2c2269c1c43fe9e7def3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f847b81a0d8633f200f2c2269c1c43fe9e7def3", "html_url": "https://github.com/rust-lang/rust/commit/2f847b81a0d8633f200f2c2269c1c43fe9e7def3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7dfdd64433b07239fbac50b8227b6e03a0ba8f30", "url": "https://api.github.com/repos/rust-lang/rust/commits/7dfdd64433b07239fbac50b8227b6e03a0ba8f30", "html_url": "https://github.com/rust-lang/rust/commit/7dfdd64433b07239fbac50b8227b6e03a0ba8f30"}, {"sha": "a8f77ade97342ea0d4ed5198be9eb6505adde42c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8f77ade97342ea0d4ed5198be9eb6505adde42c", "html_url": "https://github.com/rust-lang/rust/commit/a8f77ade97342ea0d4ed5198be9eb6505adde42c"}], "stats": {"total": 448, "additions": 398, "deletions": 50}, "files": [{"sha": "6b0b5ac7da9a18d2d5d0611c9652ef16b9601a02", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=2f847b81a0d8633f200f2c2269c1c43fe9e7def3", "patch": "@@ -83,7 +83,7 @@ pub(crate) struct CrateMetadata {\n \n     // --- Some data pre-decoded from the metadata blob, usually for performance ---\n     /// NOTE(eddyb) we pass `'static` to a `'tcx` parameter because this\n-    /// lifetime is only used behind `Lazy`, and therefore acts like a\n+    /// lifetime is only used behind `LazyValue`, `LazyArray`, or `LazyTable`, and therefore acts like a\n     /// universal (`for<'tcx>`), that is paired up with whichever `TyCtxt`\n     /// is being used to decode those values.\n     root: CrateRoot,"}, {"sha": "23198a8536933ef5e0a08213752b55669ec75174", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=2f847b81a0d8633f200f2c2269c1c43fe9e7def3", "patch": "@@ -66,13 +66,13 @@ pub const METADATA_HEADER: &[u8] = &[b'r', b'u', b's', b't', 0, 0, 0, METADATA_V\n ///\n /// Metadata is effective a tree, encoded in post-order,\n /// and with the root's position written next to the header.\n-/// That means every single `Lazy` points to some previous\n+/// That means every single `LazyValue` points to some previous\n /// location in the metadata and is part of a larger node.\n ///\n-/// The first `Lazy` in a node is encoded as the backwards\n+/// The first `LazyValue` in a node is encoded as the backwards\n /// distance from the position where the containing node\n-/// starts and where the `Lazy` points to, while the rest\n-/// use the forward distance from the previous `Lazy`.\n+/// starts and where the `LazyValue` points to, while the rest\n+/// use the forward distance from the previous `LazyValue`.\n /// Distances start at 1, as 0-byte nodes are invalid.\n /// Also invalid are nodes being referred in a different\n /// order than they were encoded in.\n@@ -94,12 +94,12 @@ impl<T> LazyValue<T> {\n \n /// A list of lazily-decoded values.\n ///\n-/// Unlike `Lazy<Vec<T>>`, the length is encoded next to the\n+/// Unlike `LazyValue<Vec<T>>`, the length is encoded next to the\n /// position, not at the position, which means that the length\n /// doesn't need to be known before encoding all the elements.\n ///\n /// If the length is 0, no position is encoded, but otherwise,\n-/// the encoding is that of `Lazy`, with the distinction that\n+/// the encoding is that of `LazyArray`, with the distinction that\n /// the minimal distance the length of the sequence, i.e.\n /// it's assumed there's no 0-byte element in the sequence.\n struct LazyArray<T> {\n@@ -167,17 +167,17 @@ impl<I, T> Clone for LazyTable<I, T> {\n     }\n }\n \n-/// Encoding / decoding state for `Lazy`.\n+/// Encoding / decoding state for `Lazy`s (`LazyValue`, `LazyArray`, and `LazyTable`).\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum LazyState {\n     /// Outside of a metadata node.\n     NoNode,\n \n-    /// Inside a metadata node, and before any `Lazy`.\n+    /// Inside a metadata node, and before any `Lazy`s.\n     /// The position is that of the node itself.\n     NodeStart(NonZeroUsize),\n \n-    /// Inside a metadata node, with a previous `Lazy`.\n+    /// Inside a metadata node, with a previous `Lazy`s.\n     /// The position is where that previous `Lazy` would start.\n     Previous(NonZeroUsize),\n }"}, {"sha": "21841ae2532a7b913f1da7b901c1417ae091cc84", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=2f847b81a0d8633f200f2c2269c1c43fe9e7def3", "patch": "@@ -141,7 +141,7 @@ fixed_size_enum! {\n     }\n }\n \n-// We directly encode `DefPathHash` because a `Lazy` would encur a 25% cost.\n+// We directly encode `DefPathHash` because a `LazyValue` would incur a 25% cost.\n impl FixedSizeEncoding for Option<DefPathHash> {\n     type ByteArray = [u8; 16];\n \n@@ -159,7 +159,7 @@ impl FixedSizeEncoding for Option<DefPathHash> {\n     }\n }\n \n-// We directly encode RawDefId because using a `Lazy` would incur a 50% overhead in the worst case.\n+// We directly encode RawDefId because using a `LazyValue` would incur a 50% overhead in the worst case.\n impl FixedSizeEncoding for Option<RawDefId> {\n     type ByteArray = [u8; 8];\n "}, {"sha": "1608550aa6ae42f9e0c1cbefc41405eacaeac7e2", "filename": "compiler/rustc_typeck/src/coherence/orphan.rs", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs?ref=2f847b81a0d8633f200f2c2269c1c43fe9e7def3", "patch": "@@ -3,7 +3,7 @@\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n-use rustc_errors::ErrorGuaranteed;\n+use rustc_errors::{Diagnostic, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::ty::subst::GenericArgKind;\n@@ -107,6 +107,7 @@ fn do_orphan_check_impl<'tcx>(\n         Err(err) => emit_orphan_check_error(\n             tcx,\n             sp,\n+            item.span,\n             tr.path.span,\n             trait_ref.self_ty(),\n             impl_.self_ty.span,\n@@ -207,6 +208,7 @@ fn do_orphan_check_impl<'tcx>(\n fn emit_orphan_check_error<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     sp: Span,\n+    full_impl_span: Span,\n     trait_span: Span,\n     self_ty: Ty<'tcx>,\n     self_ty_span: Span,\n@@ -247,8 +249,20 @@ fn emit_orphan_check_error<'tcx>(\n                     ty::Slice(_) => (this, \" because slices are always foreign\"),\n                     ty::Array(..) => (this, \" because arrays are always foreign\"),\n                     ty::Tuple(..) => (this, \" because tuples are always foreign\"),\n+                    ty::RawPtr(ptr_ty) => {\n+                        emit_newtype_suggestion_for_raw_ptr(\n+                            full_impl_span,\n+                            self_ty,\n+                            self_ty_span,\n+                            ptr_ty,\n+                            &mut err,\n+                        );\n+\n+                        (format!(\"`{}`\", ty), \" because raw pointers are always foreign\")\n+                    }\n                     _ => (format!(\"`{}`\", ty), \"\"),\n                 };\n+\n                 let msg = format!(\"{} is not defined in the current crate{}\", ty, postfix);\n                 if *is_target_ty {\n                     // Point at `D<A>` in `impl<A, B> for C<B> in D<A>`\n@@ -330,6 +344,27 @@ fn emit_orphan_check_error<'tcx>(\n     })\n }\n \n+fn emit_newtype_suggestion_for_raw_ptr(\n+    full_impl_span: Span,\n+    self_ty: Ty<'_>,\n+    self_ty_span: Span,\n+    ptr_ty: &ty::TypeAndMut<'_>,\n+    diag: &mut Diagnostic,\n+) {\n+    if !self_ty.needs_subst() {\n+        let mut_key = if ptr_ty.mutbl == rustc_middle::mir::Mutability::Mut { \"mut \" } else { \"\" };\n+        let msg_sugg = \"consider introducing a new wrapper type\".to_owned();\n+        let sugg = vec![\n+            (\n+                full_impl_span.shrink_to_lo(),\n+                format!(\"struct WrapperType(*{}{});\\n\\n\", mut_key, ptr_ty.ty),\n+            ),\n+            (self_ty_span, \"WrapperType\".to_owned()),\n+        ];\n+        diag.multipart_suggestion(msg_sugg, sugg, rustc_errors::Applicability::MaybeIncorrect);\n+    }\n+}\n+\n /// Lint impls of auto traits if they are likely to have\n /// unsound or surprising effects on auto impls.\n fn lint_auto_trait_impl<'tcx>("}, {"sha": "59066a33c965eecce361b9869e2b593d3b7a775a", "filename": "library/core/src/ffi/c_str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs?ref=2f847b81a0d8633f200f2c2269c1c43fe9e7def3", "patch": "@@ -65,9 +65,9 @@ use crate::str;\n /// extern \"C\" { fn my_string() -> *const c_char; }\n ///\n /// fn my_string_safe() -> String {\n-///     unsafe {\n-///         CStr::from_ptr(my_string()).to_string_lossy().into_owned()\n-///     }\n+///     let cstr = unsafe { CStr::from_ptr(my_string()) };\n+///     // Get copy-on-write Cow<'_, str>, then guarantee a freshly-owned String allocation\n+///     String::from_utf8_lossy(cstr.to_bytes()).to_string()\n /// }\n ///\n /// println!(\"string: {}\", my_string_safe());"}, {"sha": "dd2b9d59366eab0b5bfc38dfe20a116a8381afca", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=2f847b81a0d8633f200f2c2269c1c43fe9e7def3", "patch": "@@ -111,6 +111,11 @@ impl Step for Std {\n \n         builder.update_submodule(&Path::new(\"library\").join(\"stdarch\"));\n \n+        // Profiler information requires LLVM's compiler-rt\n+        if builder.config.profiler {\n+            builder.update_submodule(&Path::new(\"src/llvm-project\"));\n+        }\n+\n         let mut target_deps = builder.ensure(StartupObjects { compiler, target });\n \n         let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);"}, {"sha": "736c30694cddb8ee5fe906d1378b572851fd2263", "filename": "src/doc/rustc/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md?ref=2f847b81a0d8633f200f2c2269c1c43fe9e7def3", "patch": "@@ -28,6 +28,7 @@\n     - [riscv32imac-unknown-xous-elf](platform-support/riscv32imac-unknown-xous-elf.md)\n     - [*-pc-windows-gnullvm](platform-support/pc-windows-gnullvm.md)\n     - [*-unknown-openbsd](platform-support/openbsd.md)\n+    - [\\*-unknown-uefi](platform-support/unknown-uefi.md)\n     - [wasm64-unknown-unknown](platform-support/wasm64-unknown-unknown.md)\n     - [x86_64-unknown-none](platform-support/x86_64-unknown-none.md)\n - [Targets](targets/index.md)"}, {"sha": "8f90d9c7453d0a81e479f4ed8eb473cc5e028a4c", "filename": "src/doc/rustc/src/platform-support/unknown-uefi.md", "status": "added", "additions": 254, "deletions": 0, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Funknown-uefi.md", "raw_url": "https://github.com/rust-lang/rust/raw/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Funknown-uefi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Funknown-uefi.md?ref=2f847b81a0d8633f200f2c2269c1c43fe9e7def3", "patch": "@@ -0,0 +1,254 @@\n+# `*-unknown-uefi`\n+\n+**Tier: 3**\n+\n+Unified Extensible Firmware Interface (UEFI) targets for application, driver,\n+and core UEFI binaries.\n+\n+Available targets:\n+\n+- `aarch64-unknown-uefi`\n+- `i686-unknown-uefi`\n+- `x86_64-unknown-uefi`\n+\n+## Target maintainers\n+\n+- David Rheinsberg ([@dvdhrm](https://github.com/dvdhrm))\n+- Nicholas Bishop ([@nicholasbishop](https://github.com/nicholasbishop))\n+\n+## Requirements\n+\n+All UEFI targets can be used as `no-std` environments via cross-compilation.\n+Support for `std` is missing, but actively worked on. `alloc` is supported if\n+an allocator is provided by the user. No host tools are supported.\n+\n+The UEFI environment resembles the environment for Microsoft Windows, with some\n+minor differences. Therefore, cross-compiling for UEFI works with the same\n+tools as cross-compiling for Windows. The target binaries are PE32+ encoded,\n+the calling convention is different for each architecture, but matches what\n+Windows uses (if the architecture is supported by Windows). The special\n+`efiapi` Rust calling-convention chooses the right ABI for the target platform\n+(`extern \"C\"` is incorrect on Intel targets at least). The specification has an\n+elaborate section on the different supported calling-conventions, if more\n+details are desired.\n+\n+MMX, SSE, and other FP-units are disabled by default, to allow for compilation\n+of core UEFI code that runs before they are set up. This can be overridden for\n+individual compilations via rustc command-line flags. Not all firmwares\n+correctly configure those units, though, so careful inspection is required.\n+\n+As native to PE32+, binaries are position-dependent, but can be relocated at\n+runtime if their desired location is unavailable. The code must be statically\n+linked. Dynamic linking is not supported. Code is shared via UEFI interfaces,\n+rather than dynamic linking. Additionally, UEFI forbids running code on\n+anything but the boot CPU/thread, nor is interrupt-usage allowed (apart from\n+the timer interrupt). Device drivers are required to use polling methods.\n+\n+UEFI uses a single address-space to run all code in. Multiple applications can\n+be loaded simultaneously and are dispatched via cooperative multitasking on a\n+single stack.\n+\n+By default, the UEFI targets use the `link`-flavor of the LLVM linker `lld` to\n+link binaries into the final PE32+ file suffixed with `*.efi`. The PE subsystem\n+is set to `EFI_APPLICATION`, but can be modified by passing `/subsystem:<...>`\n+to the linker. Similarly, the entry-point is to to `efi_main` but can be\n+changed via `/entry:<...>`. The panic-strategy is set to `abort`,\n+\n+The UEFI specification is available online for free:\n+[UEFI Specification Directory](https://uefi.org/specifications)\n+\n+## Building rust for UEFI targets\n+\n+Rust can be built for the UEFI targets by enabling them in the `rustc` build\n+configuration. Note that you can only build the standard libraries. The\n+compiler and host tools currently cannot be compiled for UEFI targets. A sample\n+configuration would be:\n+\n+```toml\n+[build]\n+build-stage = 1\n+target = [\"x86_64-unknown-uefi\"]\n+```\n+\n+## Building Rust programs\n+\n+Rust does not yet ship pre-compiled artifacts for this target. To compile for\n+this target, you will either need to build Rust with the target enabled (see\n+\"Building rust for UEFI targets\" above), or build your own copy of `core` by\n+using `build-std`, `cargo-buildx`, or similar.\n+\n+A native build with the unstable `build-std`-feature can be achieved via:\n+\n+```sh\n+cargo +nightly build \\\n+    -Zbuild-std=core,compiler_builtins \\\n+    -Zbuild-std-features=compiler-builtins-mem \\\n+    --target x86_64-unknown-uefi\n+```\n+\n+Alternatively, you can install `cargo-xbuild` via\n+`cargo install --force cargo-xbuild` and build for the UEFI targets via:\n+\n+```sh\n+cargo \\\n+    +nightly \\\n+    xbuild \\\n+    --target x86_64-unknown-uefi\n+```\n+\n+## Testing\n+\n+UEFI applications can be copied into the ESP on any UEFI system and executed\n+via the firmware boot menu. The qemu suite allows emulating UEFI systems and\n+executing UEFI applications as well. See its documentation for details.\n+\n+The [uefi-run](https://github.com/Richard-W/uefi-run) rust tool is a simple\n+wrapper around `qemu` that can spawn UEFI applications in qemu. You can install\n+it via `cargo install uefi-run` and execute qemu applications as\n+`uefi-run ./application.efi`.\n+\n+## Cross-compilation toolchains and C code\n+\n+There are 3 common ways to compile native C code for UEFI targets:\n+\n+- Use the official SDK by Intel:\n+  [Tianocore/EDK2](https://github.com/tianocore/edk2). This supports a\n+  multitude of platforms, comes with the full specification transposed into C,\n+  lots of examples and build-system integrations. This is also the only\n+  officially supported platform by Intel, and is used by many major firmware\n+  implementations. Any code compiled via the SDK is compatible to rust binaries\n+  compiled for the UEFI targets. You can link them directly into your rust\n+  binaries, or call into each other via UEFI protocols.\n+- Use the **GNU-EFI** suite. This approach is used by many UEFI applications\n+  in the Linux/OSS ecosystem. The GCC compiler is used to compile ELF binaries,\n+  and linked with a pre-loader that converts the ELF binary to PE32+\n+  **at runtime**. You can combine such binaries with the rust UEFI targets only\n+  via UEFI protocols. Linking both into the same executable will fail, since\n+  one is an ELF executable, and one a PE32+. If linking to **GNU-EFI**\n+  executables is desired, you must compile your rust code natively for the same\n+  GNU target as **GNU-EFI** and use their pre-loader. This requires careful\n+  consideration about which calling-convention to use when calling into native\n+  UEFI protocols, or calling into linked **GNU-EFI** code (similar to how these\n+  differences need to be accounted for when writing **GNU-EFI** C code).\n+- Use native Windows targets. This means compiling your C code for the Windows\n+  platform as if it was the UEFI platform. This works for static libraries, but\n+  needs adjustments when linking into an UEFI executable. You can, however,\n+  link such static libraries seemlessly into rust code compiled for UEFI\n+  targets. Be wary of any includes that are not specifically suitable for UEFI\n+  targets (especially the C standard library includes are not always\n+  compatible). Freestanding compilations are recommended to avoid\n+  incompatibilites.\n+\n+## Ecosystem\n+\n+The rust language has a long history of supporting UEFI targets. Many crates\n+have been developed to provide access to UEFI protocols and make UEFI\n+programming more ergonomic in rust. The following list is a short overview (in\n+alphabetical ordering):\n+\n+- **efi**: *Ergonomic Rust bindings for writing UEFI applications*. Provides\n+  _rustified_ access to UEFI protocols, implements allocators and a safe\n+  environment to write UEFI applications.\n+- **r-efi**: *UEFI Reference Specification Protocol Constants and Definitions*.\n+  A pure transpose of the UEFI specification into rust. This provides the raw\n+  definitions from the specification, without any extended helpers or\n+  _rustification_. It serves as baseline to implement any more elaborate rust\n+  UEFI layers.\n+- **uefi-rs**: *Safe and easy-to-use wrapper for building UEFI apps*. An\n+  elaborate library providing safe abstractions for UEFI protocols and\n+  features. It implements allocators and provides an execution environment to\n+  UEFI applications written in rust.\n+- **uefi-run**: *Run UEFI applications*. A small wrapper around _qemu_ to spawn\n+  UEFI applications in an emulated `x86_64` machine.\n+\n+## Example: Freestanding\n+\n+The following code is a valid UEFI application returning immediately upon\n+execution with an exit code of 0. A panic handler is provided. This is executed\n+by rust on panic. For simplicity, we simply end up in an infinite loop.\n+\n+Note that as of rust-1.31.0, all features used here are stabilized. No unstable\n+features are required, nor do we rely on nightly compilers. However, if you do\n+not compile rustc for the UEFI targets, you need a nightly compiler to support\n+the `-Z build-std` flag.\n+\n+This example can be compiled as binary crate via `cargo`:\n+\n+```sh\n+cargo +nightly build \\\n+    -Zbuild-std=core,compiler_builtins \\\n+    -Zbuild-std-features=compiler-builtins-mem \\\n+    --target x86_64-unknown-uefi\n+```\n+\n+```rust,ignore (platform-specific,eh-personality-is-unstable)\n+#![no_main]\n+#![no_std]\n+\n+#[panic_handler]\n+fn panic_handler(_info: &core::panic::PanicInfo) -> ! {\n+    loop {}\n+}\n+\n+#[export_name = \"efi_main\"]\n+pub extern \"C\" fn main(_h: *mut core::ffi::c_void, _st: *mut core::ffi::c_void) -> usize {\n+    0\n+}\n+```\n+\n+## Example: Hello World\n+\n+This is an example UEFI application that prints \"Hello World!\", then waits for\n+key input before it exits. It serves as base example how to write UEFI\n+applications without any helper modules other than the standalone UEFI protocol\n+definitions provided by the `r-efi` crate.\n+\n+This extends the \"Freestanding\" example and builds upon its setup. See there\n+for instruction how to compile this as binary crate.\n+\n+Note that UEFI uses UTF-16 strings. Since rust literals are UTF-8, we have to\n+use an open-coded, zero-terminated, UTF-16 array as argument to\n+`output_string()`. Similarly to the panic handler, real applications should\n+rather use UTF-16 modules.\n+\n+```rust,ignore (platform-specific,eh-personality-is-unstable)\n+#![no_main]\n+#![no_std]\n+\n+use r_efi::efi;\n+\n+#[panic_handler]\n+fn panic_handler(_info: &core::panic::PanicInfo) -> ! {\n+    loop {}\n+}\n+\n+#[export_name = \"efi_main\"]\n+pub extern \"C\" fn main(_h: efi::Handle, st: *mut efi::SystemTable) -> efi::Status {\n+    let s = [\n+        0x0048u16, 0x0065u16, 0x006cu16, 0x006cu16, 0x006fu16, // \"Hello\"\n+        0x0020u16, //                                             \" \"\n+        0x0057u16, 0x006fu16, 0x0072u16, 0x006cu16, 0x0064u16, // \"World\"\n+        0x0021u16, //                                             \"!\"\n+        0x000au16, //                                             \"\\n\"\n+        0x0000u16, //                                             NUL\n+    ];\n+\n+    // Print \"Hello World!\".\n+    let r =\n+        unsafe { ((*(*st).con_out).output_string)((*st).con_out, s.as_ptr() as *mut efi::Char16) };\n+    if r.is_error() {\n+        return r;\n+    }\n+\n+    // Wait for key input, by waiting on the `wait_for_key` event hook.\n+    let r = unsafe {\n+        let mut x: usize = 0;\n+        ((*(*st).boot_services).wait_for_event)(1, &mut (*(*st).con_in).wait_for_key, &mut x)\n+    };\n+    if r.is_error() {\n+        return r;\n+    }\n+\n+    efi::Status::SUCCESS\n+}\n+```"}, {"sha": "27ef2f49eee58611d6516bf90887d440141d2e85", "filename": "src/doc/rustc/src/targets/custom.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Fcustom.md", "raw_url": "https://github.com/rust-lang/rust/raw/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Fcustom.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Fcustom.md?ref=2f847b81a0d8633f200f2c2269c1c43fe9e7def3", "patch": "@@ -5,13 +5,13 @@ If you'd like to build for a target that is not yet supported by `rustc`, you ca\n are JSON. To see the JSON for the host target, you can run:\n \n ```bash\n-$ rustc +nightly -Z unstable-options --print target-spec-json\n+rustc +nightly -Z unstable-options --print target-spec-json\n ```\n \n To see it for a different target, add the `--target` flag:\n \n ```bash\n-$ rustc +nightly -Z unstable-options --target=wasm32-unknown-unknown --print target-spec-json\n+rustc +nightly -Z unstable-options --target=wasm32-unknown-unknown --print target-spec-json\n ```\n \n To use a custom target, see the (unstable) [`build-std` feature](https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#build-std) of `cargo`."}, {"sha": "d02ac9d9c0ab7adb8d3092e6209250e95e87db38", "filename": "src/etc/htmldocck.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/src%2Fetc%2Fhtmldocck.py", "raw_url": "https://github.com/rust-lang/rust/raw/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/src%2Fetc%2Fhtmldocck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fhtmldocck.py?ref=2f847b81a0d8633f200f2c2269c1c43fe9e7def3", "patch": "@@ -440,6 +440,7 @@ def check_snapshot(snapshot_name, actual_tree, normalize_to_text):\n \n         if bless:\n             with open(snapshot_path, 'w') as snapshot_file:\n+                actual_str = actual_str.replace(channel, \"{{channel}}\")\n                 snapshot_file.write(actual_str)\n         else:\n             print('--- expected ---\\n')"}, {"sha": "731d8766686c8be1ba70ecfe1a0da79afbab5bb5", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=2f847b81a0d8633f200f2c2269c1c43fe9e7def3", "patch": "@@ -17,7 +17,8 @@ use rustc_span::symbol::{kw, sym, Symbol};\n \n use crate::clean::{\n     self, clean_fn_decl_from_did_and_sig, clean_middle_field, clean_middle_ty, clean_ty,\n-    clean_ty_generics, utils, Attributes, AttributesExt, Clean, ImplKind, ItemId, Type, Visibility,\n+    clean_ty_generics, clean_visibility, utils, Attributes, AttributesExt, Clean, ImplKind, ItemId,\n+    Type, Visibility,\n };\n use crate::core::DocContext;\n use crate::formats::item_type::ItemType;\n@@ -134,7 +135,7 @@ pub(crate) fn try_inline(\n     );\n     if let Some(import_def_id) = import_def_id {\n         // The visibility needs to reflect the one from the reexport and not from the \"source\" DefId.\n-        item.visibility = cx.tcx.visibility(import_def_id).clean(cx);\n+        item.visibility = clean_visibility(cx.tcx.visibility(import_def_id));\n     }\n     ret.push(item);\n     Some(ret)\n@@ -599,7 +600,7 @@ fn build_macro(\n     match CStore::from_tcx(cx.tcx).load_macro_untracked(def_id, cx.sess()) {\n         LoadedMacro::MacroDef(item_def, _) => {\n             if let ast::ItemKind::MacroDef(ref def) = item_def.kind {\n-                let vis = cx.tcx.visibility(import_def_id.unwrap_or(def_id)).clean(cx);\n+                let vis = clean_visibility(cx.tcx.visibility(import_def_id.unwrap_or(def_id)));\n                 clean::MacroItem(clean::Macro {\n                     source: utils::display_macro_source(cx, name, def, def_id, vis),\n                 })"}, {"sha": "624eec57e832488f1f13e079a1e0bd04da111e18", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=2f847b81a0d8633f200f2c2269c1c43fe9e7def3", "patch": "@@ -1812,32 +1812,25 @@ fn is_field_vis_inherited(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Visibility> for ty::Visibility {\n-    fn clean(&self, _cx: &mut DocContext<'_>) -> Visibility {\n-        match *self {\n-            ty::Visibility::Public => Visibility::Public,\n-            // NOTE: this is not quite right: `ty` uses `Invisible` to mean 'private',\n-            // while rustdoc really does mean inherited. That means that for enum variants, such as\n-            // `pub enum E { V }`, `V` will be marked as `Public` by `ty`, but as `Inherited` by rustdoc.\n-            // Various parts of clean override `tcx.visibility` explicitly to make sure this distinction is captured.\n-            ty::Visibility::Invisible => Visibility::Inherited,\n-            ty::Visibility::Restricted(module) => Visibility::Restricted(module),\n-        }\n-    }\n-}\n-\n-impl<'tcx> Clean<'tcx, VariantStruct> for rustc_hir::VariantData<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> VariantStruct {\n-        VariantStruct {\n-            struct_type: CtorKind::from_hir(self),\n-            fields: self.fields().iter().map(|x| clean_field(x, cx)).collect(),\n-        }\n+pub(crate) fn clean_visibility(vis: ty::Visibility) -> Visibility {\n+    match vis {\n+        ty::Visibility::Public => Visibility::Public,\n+        // NOTE: this is not quite right: `ty` uses `Invisible` to mean 'private',\n+        // while rustdoc really does mean inherited. That means that for enum variants, such as\n+        // `pub enum E { V }`, `V` will be marked as `Public` by `ty`, but as `Inherited` by rustdoc.\n+        // Various parts of clean override `tcx.visibility` explicitly to make sure this distinction is captured.\n+        ty::Visibility::Invisible => Visibility::Inherited,\n+        ty::Visibility::Restricted(module) => Visibility::Restricted(module),\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Vec<Item>> for hir::VariantData<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Vec<Item> {\n-        self.fields().iter().map(|x| clean_field(x, cx)).collect()\n+fn clean_variant_data<'tcx>(\n+    variant: &hir::VariantData<'tcx>,\n+    cx: &mut DocContext<'tcx>,\n+) -> VariantStruct {\n+    VariantStruct {\n+        struct_type: CtorKind::from_hir(variant),\n+        fields: variant.fields().iter().map(|x| clean_field(x, cx)).collect(),\n     }\n }\n \n@@ -1863,8 +1856,10 @@ impl<'tcx> Clean<'tcx, Item> for ty::VariantDef {\n impl<'tcx> Clean<'tcx, Variant> for hir::VariantData<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> Variant {\n         match self {\n-            hir::VariantData::Struct(..) => Variant::Struct(self.clean(cx)),\n-            hir::VariantData::Tuple(..) => Variant::Tuple(self.clean(cx)),\n+            hir::VariantData::Struct(..) => Variant::Struct(clean_variant_data(self, cx)),\n+            hir::VariantData::Tuple(..) => {\n+                Variant::Tuple(self.fields().iter().map(|x| clean_field(x, cx)).collect())\n+            }\n             hir::VariantData::Unit(..) => Variant::CLike,\n         }\n     }\n@@ -1983,7 +1978,7 @@ fn clean_maybe_renamed_item<'tcx>(\n                 clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n             }\n             ItemKind::Macro(ref macro_def, _) => {\n-                let ty_vis = cx.tcx.visibility(def_id).clean(cx);\n+                let ty_vis = clean_visibility(cx.tcx.visibility(def_id));\n                 MacroItem(Macro {\n                     source: display_macro_source(cx, name, macro_def, def_id, ty_vis),\n                 })\n@@ -2112,7 +2107,7 @@ fn clean_extern_crate<'tcx>(\n         name: Some(name),\n         attrs: Box::new(attrs.clean(cx)),\n         item_id: crate_def_id.into(),\n-        visibility: ty_vis.clean(cx),\n+        visibility: clean_visibility(ty_vis),\n         kind: box ExternCrateItem { src: orig_name },\n         cfg: attrs.cfg(cx.tcx, &cx.cache.hidden_cfg),\n     }]"}, {"sha": "a5d27a940341a2be5c85de2fcd67bcba09b0b65f", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=2f847b81a0d8633f200f2c2269c1c43fe9e7def3", "patch": "@@ -37,7 +37,7 @@ use crate::clean::cfg::Cfg;\n use crate::clean::external_path;\n use crate::clean::inline::{self, print_inlined_const};\n use crate::clean::utils::{is_literal_expr, print_const_expr, print_evaluated_const};\n-use crate::clean::Clean;\n+use crate::clean::{clean_visibility, Clean};\n use crate::core::DocContext;\n use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n@@ -499,7 +499,7 @@ impl Item {\n         let visibility = if matches!(&kind, ItemKind::KeywordItem | ItemKind::PrimitiveItem(..)) {\n             Visibility::Public\n         } else {\n-            cx.tcx.visibility(def_id).clean(cx)\n+            clean_visibility(cx.tcx.visibility(def_id))\n         };\n \n         Item { item_id: def_id.into(), kind: box kind, name, attrs, visibility, cfg }"}, {"sha": "272c6bd3fb782bf1af04d343dc2d853fe062275c", "filename": "src/test/ui/errors/issue-99572-impl-trait-on-pointer.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/src%2Ftest%2Fui%2Ferrors%2Fissue-99572-impl-trait-on-pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/src%2Ftest%2Fui%2Ferrors%2Fissue-99572-impl-trait-on-pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferrors%2Fissue-99572-impl-trait-on-pointer.rs?ref=2f847b81a0d8633f200f2c2269c1c43fe9e7def3", "patch": "@@ -0,0 +1,25 @@\n+// Emit additional suggestion to correct the trait implementation\n+// on a pointer\n+use std::{fmt, marker};\n+\n+struct LocalType;\n+\n+impl fmt::Display for *mut LocalType {\n+//~^ ERROR only traits defined in the current crate can be implemented for arbitrary types\n+//~| NOTE impl doesn't use only types from inside the current crate\n+//~| NOTE `*mut LocalType` is not defined in the current crate because raw pointers are always foreign\n+//~| NOTE define and implement a trait or new type instead\n+//~| HELP consider introducing a new wrapper type\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"This not compile\")\n+    }\n+}\n+\n+impl<T> marker::Copy for *mut T {\n+//~^ ERROR only traits defined in the current crate can be implemented for arbitrary types\n+//~| NOTE impl doesn't use only types from inside the current crate\n+//~| NOTE `*mut T` is not defined in the current crate because raw pointers are always foreign\n+//~| NOTE define and implement a trait or new type instead\n+}\n+\n+fn main() {}"}, {"sha": "78d7a47deaac3be3fb9886ff8bcc0ed2edbe2c56", "filename": "src/test/ui/errors/issue-99572-impl-trait-on-pointer.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/src%2Ftest%2Fui%2Ferrors%2Fissue-99572-impl-trait-on-pointer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f847b81a0d8633f200f2c2269c1c43fe9e7def3/src%2Ftest%2Fui%2Ferrors%2Fissue-99572-impl-trait-on-pointer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferrors%2Fissue-99572-impl-trait-on-pointer.stderr?ref=2f847b81a0d8633f200f2c2269c1c43fe9e7def3", "patch": "@@ -0,0 +1,31 @@\n+error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n+  --> $DIR/issue-99572-impl-trait-on-pointer.rs:7:1\n+   |\n+LL | impl fmt::Display for *mut LocalType {\n+   | ^^^^^^^^^^^^^^^^^^^^^^--------------\n+   | |                     |\n+   | |                     `*mut LocalType` is not defined in the current crate because raw pointers are always foreign\n+   | impl doesn't use only types from inside the current crate\n+   |\n+   = note: define and implement a trait or new type instead\n+help: consider introducing a new wrapper type\n+   |\n+LL + struct WrapperType(*mut LocalType);\n+LL + \n+LL ~ impl fmt::Display for WrapperType {\n+   |\n+\n+error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n+  --> $DIR/issue-99572-impl-trait-on-pointer.rs:18:1\n+   |\n+LL | impl<T> marker::Copy for *mut T {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^------\n+   | |                        |\n+   | |                        `*mut T` is not defined in the current crate because raw pointers are always foreign\n+   | impl doesn't use only types from inside the current crate\n+   |\n+   = note: define and implement a trait or new type instead\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0117`."}]}