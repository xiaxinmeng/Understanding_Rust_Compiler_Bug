{"sha": "02d6135b5fc26ebb3fa35b138b181d64cc3e3e29", "node_id": "C_kwDOAAsO6NoAKDAyZDYxMzViNWZjMjZlYmIzZmEzNWIxMzhiMTgxZDY0Y2MzZTNlMjk", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-10-19T08:35:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-19T08:35:53Z"}, "message": "Rollup merge of #103182 - Nilstrieb:query-desc-cleanup, r=oli-obk\n\nClean up query descriptions\n\nUse the same tense everywhere and prefer display over debug, as these descriptions are user facing.", "tree": {"sha": "8eff899f665c18da1ca952f2bbabf9675ff08fdf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8eff899f665c18da1ca952f2bbabf9675ff08fdf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02d6135b5fc26ebb3fa35b138b181d64cc3e3e29", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjT7bpCRBK7hj4Ov3rIwAA3C4IADRnOvZepdr50ipOJe7lpMzn\n15sPiUl2QVM5cxWV06/CV5oGa8hAo1ve/wzQ1iZMYBp+DEhyhCk/dimYq+7oxHFx\n/NsgRWFy5kB9Ga3almfZ62gHF0HZHkusGN7mmebh8XFpbCvoq/uOS7tDNY/CEUZp\nu5Kc++4xnVPKhf5pA6xgzBbdPT8GfLtRU9KwuOAHLsyuAFudg7rmLR+S0tY3E2fZ\nTdpZcYXKWcNb933iA2TC7K+4eRgypnS2/gUoZeEQ6K4CdLynhMjMKJr3p+LJlwjg\nuzNzyCWFm14beR/FUVX2OCJJqzT7zc0TurktMb/Cl8ys/bE/pp7Y+mPOr1vy8rI=\n=Hmbf\n-----END PGP SIGNATURE-----\n", "payload": "tree 8eff899f665c18da1ca952f2bbabf9675ff08fdf\nparent d056ea8828b2b589ffe58caa3b539320309f9379\nparent 4ed834523e9ae3640011e0e214d17966d6dae844\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1666168553 +0530\ncommitter GitHub <noreply@github.com> 1666168553 +0530\n\nRollup merge of #103182 - Nilstrieb:query-desc-cleanup, r=oli-obk\n\nClean up query descriptions\n\nUse the same tense everywhere and prefer display over debug, as these descriptions are user facing.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02d6135b5fc26ebb3fa35b138b181d64cc3e3e29", "html_url": "https://github.com/rust-lang/rust/commit/02d6135b5fc26ebb3fa35b138b181d64cc3e3e29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02d6135b5fc26ebb3fa35b138b181d64cc3e3e29/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d056ea8828b2b589ffe58caa3b539320309f9379", "url": "https://api.github.com/repos/rust-lang/rust/commits/d056ea8828b2b589ffe58caa3b539320309f9379", "html_url": "https://github.com/rust-lang/rust/commit/d056ea8828b2b589ffe58caa3b539320309f9379"}, {"sha": "4ed834523e9ae3640011e0e214d17966d6dae844", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ed834523e9ae3640011e0e214d17966d6dae844", "html_url": "https://github.com/rust-lang/rust/commit/4ed834523e9ae3640011e0e214d17966d6dae844"}], "stats": {"total": 205, "additions": 104, "deletions": 101}, "files": [{"sha": "ef2c7a003fafad373a8d6f5a408b20a12baea667", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 92, "deletions": 89, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/02d6135b5fc26ebb3fa35b138b181d64cc3e3e29/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02d6135b5fc26ebb3fa35b138b181d64cc3e3e29/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=02d6135b5fc26ebb3fa35b138b181d64cc3e3e29", "patch": "@@ -20,27 +20,27 @@ use rustc_span::def_id::LOCAL_CRATE;\n // as they will raise an fatal error on query cycles instead.\n rustc_queries! {\n     query trigger_delay_span_bug(key: DefId) -> () {\n-        desc { \"trigger a delay span bug\" }\n+        desc { \"triggering a delay span bug\" }\n     }\n \n     query resolutions(_: ()) -> &'tcx ty::ResolverOutputs {\n         eval_always\n         no_hash\n-        desc { \"get the resolver outputs\" }\n+        desc { \"getting the resolver outputs\" }\n     }\n \n     query resolver_for_lowering(_: ()) -> &'tcx Steal<ty::ResolverAstLowering> {\n         eval_always\n         no_hash\n-        desc { \"get the resolver for lowering\" }\n+        desc { \"getting the resolver for lowering\" }\n     }\n \n     /// Return the span for a definition.\n     /// Contrary to `def_span` below, this query returns the full absolute span of the definition.\n     /// This span is meant for dep-tracking rather than diagnostics. It should not be used outside\n     /// of rustc_middle::hir::source_map.\n     query source_span(key: LocalDefId) -> Span {\n-        desc { \"get the source span\" }\n+        desc { \"getting the source span\" }\n     }\n \n     /// Represents crate as a whole (as distinct from the top-level crate module).\n@@ -52,14 +52,14 @@ rustc_queries! {\n     query hir_crate(key: ()) -> Crate<'tcx> {\n         arena_cache\n         eval_always\n-        desc { \"get the crate HIR\" }\n+        desc { \"getting the crate HIR\" }\n     }\n \n     /// All items in the crate.\n     query hir_crate_items(_: ()) -> rustc_middle::hir::ModuleItems {\n         arena_cache\n         eval_always\n-        desc { \"get HIR crate items\" }\n+        desc { \"getting HIR crate items\" }\n     }\n \n     /// The items in a module.\n@@ -68,7 +68,7 @@ rustc_queries! {\n     /// Avoid calling this query directly.\n     query hir_module_items(key: LocalDefId) -> rustc_middle::hir::ModuleItems {\n         arena_cache\n-        desc { |tcx| \"HIR module items in `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        desc { |tcx| \"getting HIR module items in `{}`\", tcx.def_path_str(key.to_def_id()) }\n         cache_on_disk_if { true }\n     }\n \n@@ -77,39 +77,39 @@ rustc_queries! {\n     /// This can be conveniently accessed by methods on `tcx.hir()`.\n     /// Avoid calling this query directly.\n     query hir_owner(key: hir::OwnerId) -> Option<crate::hir::Owner<'tcx>> {\n-        desc { |tcx| \"HIR owner of `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        desc { |tcx| \"getting HIR owner of `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n     /// Gives access to the HIR ID for the given `LocalDefId` owner `key`.\n     ///\n     /// This can be conveniently accessed by methods on `tcx.hir()`.\n     /// Avoid calling this query directly.\n     query local_def_id_to_hir_id(key: LocalDefId) -> hir::HirId {\n-        desc { |tcx| \"HIR ID of `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        desc { |tcx| \"getting HIR ID of `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n     /// Gives access to the HIR node's parent for the HIR owner `key`.\n     ///\n     /// This can be conveniently accessed by methods on `tcx.hir()`.\n     /// Avoid calling this query directly.\n     query hir_owner_parent(key: hir::OwnerId) -> hir::HirId {\n-        desc { |tcx| \"HIR parent of `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        desc { |tcx| \"getting HIR parent of `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n     /// Gives access to the HIR nodes and bodies inside the HIR owner `key`.\n     ///\n     /// This can be conveniently accessed by methods on `tcx.hir()`.\n     /// Avoid calling this query directly.\n     query hir_owner_nodes(key: hir::OwnerId) -> hir::MaybeOwner<&'tcx hir::OwnerNodes<'tcx>> {\n-        desc { |tcx| \"HIR owner items in `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        desc { |tcx| \"getting HIR owner items in `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n     /// Gives access to the HIR attributes inside the HIR owner `key`.\n     ///\n     /// This can be conveniently accessed by methods on `tcx.hir()`.\n     /// Avoid calling this query directly.\n     query hir_attrs(key: hir::OwnerId) -> &'tcx hir::AttributeMap<'tcx> {\n-        desc { |tcx| \"HIR owner attributes in `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        desc { |tcx| \"getting HIR owner attributes in `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n     /// Computes the `DefId` of the corresponding const parameter in case the `key` is a\n@@ -138,7 +138,7 @@ rustc_queries! {\n     /// Given the def_id of a const-generic parameter, computes the associated default const\n     /// parameter. e.g. `fn example<const N: usize=3>` called on `N` would return `3`.\n     query const_param_default(param: DefId) -> ty::Const<'tcx> {\n-        desc { |tcx| \"compute const default for a given parameter `{}`\", tcx.def_path_str(param)  }\n+        desc { |tcx| \"computing const default for a given parameter `{}`\", tcx.def_path_str(param)  }\n         cache_on_disk_if { param.is_local() }\n         separate_provide_extern\n     }\n@@ -167,7 +167,7 @@ rustc_queries! {\n     query collect_trait_impl_trait_tys(key: DefId)\n         -> Result<&'tcx FxHashMap<DefId, Ty<'tcx>>, ErrorGuaranteed>\n     {\n-        desc { \"compare an impl and trait method signature, inferring any hidden `impl Trait` types in the process\" }\n+        desc { \"comparing an impl and trait method signature, inferring any hidden `impl Trait` types in the process\" }\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern\n     }\n@@ -290,11 +290,11 @@ rustc_queries! {\n \n     query parent_module_from_def_id(key: LocalDefId) -> LocalDefId {\n         eval_always\n-        desc { |tcx| \"parent module of `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        desc { |tcx| \"getting the parent module of `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n     query expn_that_defined(key: DefId) -> rustc_span::ExpnId {\n-        desc { |tcx| \"expansion that defined `{}`\", tcx.def_path_str(key) }\n+        desc { |tcx| \"getting the expansion that defined `{}`\", tcx.def_path_str(key) }\n         separate_provide_extern\n     }\n \n@@ -306,7 +306,7 @@ rustc_queries! {\n \n     /// Checks whether a type is representable or infinitely sized\n     query representability(_: LocalDefId) -> rustc_middle::ty::Representability {\n-        desc { \"checking if {:?} is representable\", tcx.def_path_str(key.to_def_id()) }\n+        desc { \"checking if `{}` is representable\", tcx.def_path_str(key.to_def_id()) }\n         // infinitely sized types will cause a cycle\n         cycle_delay_bug\n         // we don't want recursive representability calls to be forced with\n@@ -317,7 +317,7 @@ rustc_queries! {\n \n     /// An implementation detail for the `representability` query\n     query representability_adt_ty(_: Ty<'tcx>) -> rustc_middle::ty::Representability {\n-        desc { \"checking if {:?} is representable\", key }\n+        desc { \"checking if `{}` is representable\", key }\n         cycle_delay_bug\n         anon\n     }\n@@ -383,7 +383,7 @@ rustc_queries! {\n     /// See the README for the `mir` module for details.\n     query mir_const(key: ty::WithOptConstParam<LocalDefId>) -> &'tcx Steal<mir::Body<'tcx>> {\n         desc {\n-            |tcx| \"processing MIR for {}`{}`\",\n+            |tcx| \"preparing {}`{}` for borrow checking\",\n             if key.const_param_did.is_some() { \"the const argument \" } else { \"\" },\n             tcx.def_path_str(key.did.to_def_id()),\n         }\n@@ -395,7 +395,7 @@ rustc_queries! {\n         key: DefId\n     ) -> Result<Option<&'tcx [ty::abstract_const::Node<'tcx>]>, ErrorGuaranteed> {\n         desc {\n-            |tcx| \"building an abstract representation for {}\", tcx.def_path_str(key),\n+            |tcx| \"building an abstract representation for `{}`\", tcx.def_path_str(key),\n         }\n         separate_provide_extern\n     }\n@@ -405,7 +405,7 @@ rustc_queries! {\n     ) -> Result<Option<&'tcx [ty::abstract_const::Node<'tcx>]>, ErrorGuaranteed> {\n         desc {\n             |tcx|\n-            \"building an abstract representation for the const argument {}\",\n+            \"building an abstract representation for the const argument `{}`\",\n             tcx.def_path_str(key.0.to_def_id()),\n         }\n     }\n@@ -414,7 +414,7 @@ rustc_queries! {\n         ty::ParamEnvAnd<'tcx, (ty::UnevaluatedConst<'tcx>, ty::UnevaluatedConst<'tcx>\n     )>) -> bool {\n         desc {\n-            |tcx| \"trying to unify the generic constants {} and {}\",\n+            |tcx| \"trying to unify the generic constants `{}` and `{}`\",\n             tcx.def_path_str(key.value.0.def.did), tcx.def_path_str(key.value.1.def.did)\n         }\n     }\n@@ -436,7 +436,7 @@ rustc_queries! {\n \n     query mir_for_ctfe_of_const_arg(key: (LocalDefId, DefId)) -> &'tcx mir::Body<'tcx> {\n         desc {\n-            |tcx| \"MIR for CTFE of the const argument `{}`\",\n+            |tcx| \"caching MIR for CTFE of the const argument `{}`\",\n             tcx.def_path_str(key.0.to_def_id())\n         }\n     }\n@@ -448,7 +448,7 @@ rustc_queries! {\n         ) {\n         no_hash\n         desc {\n-            |tcx| \"processing {}`{}`\",\n+            |tcx| \"processing MIR for {}`{}`\",\n             if key.const_param_did.is_some() { \"the const argument \" } else { \"\" },\n             tcx.def_path_str(key.did.to_def_id()),\n         }\n@@ -459,7 +459,7 @@ rustc_queries! {\n     ) -> Vec<rustc_span::Symbol> {\n         arena_cache\n         desc {\n-            |tcx| \"symbols for captures of closure `{}` in `{}`\",\n+            |tcx| \"finding symbols for captures of closure `{}` in `{}`\",\n             tcx.def_path_str(key.1.to_def_id()),\n             tcx.def_path_str(key.0.to_def_id())\n         }\n@@ -521,12 +521,12 @@ rustc_queries! {\n         // queries). Making it anonymous avoids hashing the result, which\n         // may save a bit of time.\n         anon\n-        desc { \"erasing regions from `{:?}`\", ty }\n+        desc { \"erasing regions from `{}`\", ty }\n     }\n \n     query wasm_import_module_map(_: CrateNum) -> FxHashMap<DefId, String> {\n         arena_cache\n-        desc { \"wasm import module map\" }\n+        desc { \"getting wasm import module map\" }\n     }\n \n     /// Maps from the `DefId` of an item (trait/struct/enum/fn) to the\n@@ -706,7 +706,7 @@ rustc_queries! {\n     /// Collects the associated items defined on a trait or impl.\n     query associated_items(key: DefId) -> ty::AssocItems<'tcx> {\n         arena_cache\n-        desc { |tcx| \"collecting associated items of {}\", tcx.def_path_str(key) }\n+        desc { |tcx| \"collecting associated items of `{}`\", tcx.def_path_str(key) }\n     }\n \n     /// Maps from associated items on a trait to the corresponding associated\n@@ -732,7 +732,7 @@ rustc_queries! {\n     ///`{ trait_f: impl_f, trait_g: impl_g }`\n     query impl_item_implementor_ids(impl_id: DefId) -> FxHashMap<DefId, DefId> {\n         arena_cache\n-        desc { |tcx| \"comparing impl items against trait for {}\", tcx.def_path_str(impl_id) }\n+        desc { |tcx| \"comparing impl items against trait for `{}`\", tcx.def_path_str(impl_id) }\n     }\n \n     /// Given an `impl_id`, return the trait it implements.\n@@ -804,7 +804,7 @@ rustc_queries! {\n     /// Note that we've liberated the late bound regions of function signatures, so\n     /// this can not be used to check whether these types are well formed.\n     query assumed_wf_types(key: DefId) -> &'tcx ty::List<Ty<'tcx>> {\n-        desc { |tcx| \"computing the implied bounds of {}\", tcx.def_path_str(key) }\n+        desc { |tcx| \"computing the implied bounds of `{}`\", tcx.def_path_str(key) }\n     }\n \n     /// Computes the signature of the function.\n@@ -853,7 +853,7 @@ rustc_queries! {\n     }\n \n     query check_liveness(key: DefId) {\n-        desc { |tcx| \"checking liveness of variables in {}\", tcx.def_path_str(key) }\n+        desc { |tcx| \"checking liveness of variables in `{}`\", tcx.def_path_str(key) }\n     }\n \n     /// Return the live symbols in the crate for dead code check.\n@@ -865,7 +865,7 @@ rustc_queries! {\n         FxHashMap<LocalDefId, Vec<(DefId, DefId)>>\n     ) {\n         arena_cache\n-        desc { \"find live symbols in crate\" }\n+        desc { \"finding live symbols in crate\" }\n     }\n \n     query check_mod_deathness(key: LocalDefId) -> () {\n@@ -913,7 +913,7 @@ rustc_queries! {\n     }\n \n     query used_trait_imports(key: LocalDefId) -> &'tcx FxHashSet<LocalDefId> {\n-        desc { |tcx| \"used_trait_imports `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        desc { |tcx| \"finding used_trait_imports `{}`\", tcx.def_path_str(key.to_def_id()) }\n         cache_on_disk_if { true }\n     }\n \n@@ -942,7 +942,7 @@ rustc_queries! {\n     /// Not meant to be used directly outside of coherence.\n     query crate_inherent_impls(k: ()) -> CrateInherentImpls {\n         arena_cache\n-        desc { \"all inherent impls defined in crate\" }\n+        desc { \"finding all inherent impls defined in crate\" }\n     }\n \n     /// Checks all types in the crate for overlap in their inherent impls. Reports errors.\n@@ -1032,7 +1032,7 @@ rustc_queries! {\n     query try_destructure_mir_constant(\n         key: ty::ParamEnvAnd<'tcx, mir::ConstantKind<'tcx>>\n     ) -> Option<mir::DestructuredConstant<'tcx>> {\n-        desc { \"destructuring mir constant\"}\n+        desc { \"destructuring MIR constant\"}\n         remap_env_constness\n     }\n \n@@ -1041,12 +1041,12 @@ rustc_queries! {\n     query deref_mir_constant(\n         key: ty::ParamEnvAnd<'tcx, mir::ConstantKind<'tcx>>\n     ) -> mir::ConstantKind<'tcx> {\n-        desc { \"dereferencing mir constant\" }\n+        desc { \"dereferencing MIR constant\" }\n         remap_env_constness\n     }\n \n     query const_caller_location(key: (rustc_span::Symbol, u32, u32)) -> ConstValue<'tcx> {\n-        desc { \"get a &core::panic::Location referring to a span\" }\n+        desc { \"getting a &core::panic::Location referring to a span\" }\n     }\n \n     // FIXME get rid of this with valtrees\n@@ -1068,7 +1068,7 @@ rustc_queries! {\n     /// Performs part of the privacy check and computes \"access levels\".\n     query privacy_access_levels(_: ()) -> &'tcx AccessLevels {\n         eval_always\n-        desc { \"privacy access levels\" }\n+        desc { \"checking privacy access levels\" }\n     }\n     query check_private_in_public(_: ()) -> () {\n         eval_always\n@@ -1196,29 +1196,29 @@ rustc_queries! {\n     }\n \n     query is_ctfe_mir_available(key: DefId) -> bool {\n-        desc { |tcx| \"checking if item has ctfe mir available: `{}`\", tcx.def_path_str(key) }\n+        desc { |tcx| \"checking if item has CTFE MIR available: `{}`\", tcx.def_path_str(key) }\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern\n     }\n     query is_mir_available(key: DefId) -> bool {\n-        desc { |tcx| \"checking if item has mir available: `{}`\", tcx.def_path_str(key) }\n+        desc { |tcx| \"checking if item has MIR available: `{}`\", tcx.def_path_str(key) }\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern\n     }\n \n     query own_existential_vtable_entries(\n         key: ty::PolyExistentialTraitRef<'tcx>\n     ) -> &'tcx [DefId] {\n-        desc { |tcx| \"finding all existential vtable entries for trait {}\", tcx.def_path_str(key.def_id()) }\n+        desc { |tcx| \"finding all existential vtable entries for trait `{}`\", tcx.def_path_str(key.def_id()) }\n     }\n \n     query vtable_entries(key: ty::PolyTraitRef<'tcx>)\n                         -> &'tcx [ty::VtblEntry<'tcx>] {\n-        desc { |tcx| \"finding all vtable entries for trait {}\", tcx.def_path_str(key.def_id()) }\n+        desc { |tcx| \"finding all vtable entries for trait `{}`\", tcx.def_path_str(key.def_id()) }\n     }\n \n     query vtable_trait_upcasting_coercion_new_vptr_slot(key: (Ty<'tcx>, Ty<'tcx>)) -> Option<usize> {\n-        desc { |tcx| \"finding the slot within vtable for trait object {} vtable ptr during trait upcasting coercion from {} vtable\",\n+        desc { |tcx| \"finding the slot within vtable for trait object `{}` vtable ptr during trait upcasting coercion from `{}` vtable\",\n             key.1, key.0 }\n     }\n \n@@ -1238,13 +1238,13 @@ rustc_queries! {\n \n     /// Return all `impl` blocks in the current crate.\n     query all_local_trait_impls(_: ()) -> &'tcx rustc_data_structures::fx::FxIndexMap<DefId, Vec<LocalDefId>> {\n-        desc { \"local trait impls\" }\n+        desc { \"finding local trait impls\" }\n     }\n \n     /// Given a trait `trait_id`, return all known `impl` blocks.\n     query trait_impls_of(trait_id: DefId) -> ty::trait_def::TraitImpls {\n         arena_cache\n-        desc { |tcx| \"trait impls of `{}`\", tcx.def_path_str(trait_id) }\n+        desc { |tcx| \"finding trait impls of `{}`\", tcx.def_path_str(trait_id) }\n     }\n \n     query specialization_graph_of(trait_id: DefId) -> specialization_graph::Graph {\n@@ -1253,7 +1253,7 @@ rustc_queries! {\n         cache_on_disk_if { true }\n     }\n     query object_safety_violations(trait_id: DefId) -> &'tcx [traits::ObjectSafetyViolation] {\n-        desc { |tcx| \"determine object safety of trait `{}`\", tcx.def_path_str(trait_id) }\n+        desc { |tcx| \"determining object safety of trait `{}`\", tcx.def_path_str(trait_id) }\n     }\n \n     /// Gets the ParameterEnvironment for a given item; this environment\n@@ -1311,7 +1311,7 @@ rustc_queries! {\n     /// correctly.\n     query has_structural_eq_impls(ty: Ty<'tcx>) -> bool {\n         desc {\n-            \"computing whether `{:?}` implements `PartialStructuralEq` and `StructuralEq`\",\n+            \"computing whether `{}` implements `PartialStructuralEq` and `StructuralEq`\",\n             ty\n         }\n     }\n@@ -1370,13 +1370,13 @@ rustc_queries! {\n \n     query dylib_dependency_formats(_: CrateNum)\n                                     -> &'tcx [(CrateNum, LinkagePreference)] {\n-        desc { \"dylib dependency formats of crate\" }\n+        desc { \"getting dylib dependency formats of crate\" }\n         separate_provide_extern\n     }\n \n     query dependency_formats(_: ()) -> Lrc<crate::middle::dependency_format::Dependencies> {\n         arena_cache\n-        desc { \"get the linkage format of all dependencies\" }\n+        desc { \"getting the linkage format of all dependencies\" }\n     }\n \n     query is_compiler_builtins(_: CrateNum) -> bool {\n@@ -1398,31 +1398,31 @@ rustc_queries! {\n     }\n     query is_profiler_runtime(_: CrateNum) -> bool {\n         fatal_cycle\n-        desc { \"query a crate is `#![profiler_runtime]`\" }\n+        desc { \"checking if a crate is `#![profiler_runtime]`\" }\n         separate_provide_extern\n     }\n     query has_ffi_unwind_calls(key: LocalDefId) -> bool {\n-        desc { |tcx| \"check if `{}` contains FFI-unwind calls\", tcx.def_path_str(key.to_def_id()) }\n+        desc { |tcx| \"checking if `{}` contains FFI-unwind calls\", tcx.def_path_str(key.to_def_id()) }\n         cache_on_disk_if { true }\n     }\n     query required_panic_strategy(_: CrateNum) -> Option<PanicStrategy> {\n         fatal_cycle\n-        desc { \"query a crate's required panic strategy\" }\n+        desc { \"getting a crate's required panic strategy\" }\n         separate_provide_extern\n     }\n     query panic_in_drop_strategy(_: CrateNum) -> PanicStrategy {\n         fatal_cycle\n-        desc { \"query a crate's configured panic-in-drop strategy\" }\n+        desc { \"getting a crate's configured panic-in-drop strategy\" }\n         separate_provide_extern\n     }\n     query is_no_builtins(_: CrateNum) -> bool {\n         fatal_cycle\n-        desc { \"test whether a crate has `#![no_builtins]`\" }\n+        desc { \"getting whether a crate has `#![no_builtins]`\" }\n         separate_provide_extern\n     }\n     query symbol_mangling_version(_: CrateNum) -> SymbolManglingVersion {\n         fatal_cycle\n-        desc { \"query a crate's symbol mangling version\" }\n+        desc { \"getting a crate's symbol mangling version\" }\n         separate_provide_extern\n     }\n \n@@ -1437,7 +1437,7 @@ rustc_queries! {\n     }\n     query in_scope_traits_map(_: hir::OwnerId)\n         -> Option<&'tcx FxHashMap<ItemLocalId, Box<[TraitCandidate]>>> {\n-        desc { \"traits in scope at a block\" }\n+        desc { \"getting traits in scope at a block\" }\n     }\n \n     query module_reexports(def_id: LocalDefId) -> Option<&'tcx [ModChild]> {\n@@ -1588,17 +1588,17 @@ rustc_queries! {\n     }\n \n     query is_dllimport_foreign_item(def_id: DefId) -> bool {\n-        desc { |tcx| \"is_dllimport_foreign_item({})\", tcx.def_path_str(def_id) }\n+        desc { |tcx| \"checking if `{}` is a a dylib\", tcx.def_path_str(def_id) }\n     }\n     query is_statically_included_foreign_item(def_id: DefId) -> bool {\n-        desc { |tcx| \"is_statically_included_foreign_item({})\", tcx.def_path_str(def_id) }\n+        desc { |tcx| \"checking if `{}` is a staticlib\", tcx.def_path_str(def_id) }\n     }\n     query native_library_kind(def_id: DefId)\n         -> Option<NativeLibKind> {\n-        desc { |tcx| \"native_library_kind({})\", tcx.def_path_str(def_id) }\n+        desc { |tcx| \"getting the native library kind of `{}`\", tcx.def_path_str(def_id) }\n     }\n     query native_library(def_id: DefId) -> Option<&'tcx NativeLib> {\n-        desc { |tcx| \"native_library({})\", tcx.def_path_str(def_id) }\n+        desc { |tcx| \"getting the native library for `{}`\", tcx.def_path_str(def_id) }\n     }\n \n     /// Does lifetime resolution, but does not descend into trait items. This\n@@ -1659,7 +1659,7 @@ rustc_queries! {\n     query type_uninhabited_from(\n         key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>\n     ) -> ty::inhabitedness::DefIdForest<'tcx> {\n-        desc { \"computing the inhabitedness of `{:?}`\", key }\n+        desc { \"computing the inhabitedness of `{}`\", key.value }\n         remap_env_constness\n     }\n \n@@ -1698,7 +1698,7 @@ rustc_queries! {\n     }\n     /// Whether the function is an intrinsic\n     query is_intrinsic(def_id: DefId) -> bool {\n-        desc { |tcx| \"is_intrinsic({})\", tcx.def_path_str(def_id) }\n+        desc { |tcx| \"checking whether `{}` is an intrinsic\", tcx.def_path_str(def_id) }\n         separate_provide_extern\n     }\n     /// Returns the lang items defined in another crate by loading it from metadata.\n@@ -1765,12 +1765,12 @@ rustc_queries! {\n     /// is marked as a private dependency\n     query is_private_dep(c: CrateNum) -> bool {\n         eval_always\n-        desc { \"check whether crate {} is a private dependency\", c }\n+        desc { \"checking whether crate `{}` is a private dependency\", c }\n         separate_provide_extern\n     }\n     query allocator_kind(_: ()) -> Option<AllocatorKind> {\n         eval_always\n-        desc { \"allocator kind for the current crate\" }\n+        desc { \"getting the allocator kind for the current crate\" }\n     }\n \n     query upvars_mentioned(def_id: DefId) -> Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>> {\n@@ -1783,7 +1783,7 @@ rustc_queries! {\n         desc { \"looking up all possibly unused extern crates\" }\n     }\n     query names_imported_by_glob_use(def_id: LocalDefId) -> &'tcx FxHashSet<Symbol> {\n-        desc { |tcx| \"names_imported_by_glob_use for `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n+        desc { |tcx| \"finding names imported by glob use for `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n     }\n \n     query stability_index(_: ()) -> stability::Index {\n@@ -1809,7 +1809,7 @@ rustc_queries! {\n     ///   correspond to a publicly visible symbol in `cnum` machine code.\n     /// - The `exported_symbols` sets of different crates do not intersect.\n     query exported_symbols(cnum: CrateNum) -> &'tcx [(ExportedSymbol<'tcx>, SymbolExportInfo)] {\n-        desc { \"exported_symbols\" }\n+        desc { \"collecting exported symbols for crate `{}`\", cnum}\n         cache_on_disk_if { *cnum == LOCAL_CRATE }\n         separate_provide_extern\n     }\n@@ -1818,19 +1818,21 @@ rustc_queries! {\n         eval_always\n         desc { \"collect_and_partition_mono_items\" }\n     }\n+\n     query is_codegened_item(def_id: DefId) -> bool {\n         desc { |tcx| \"determining whether `{}` needs codegen\", tcx.def_path_str(def_id) }\n     }\n \n     /// All items participating in code generation together with items inlined into them.\n     query codegened_and_inlined_items(_: ()) -> &'tcx DefIdSet {\n         eval_always\n-       desc { \"codegened_and_inlined_items\" }\n+        desc { \"collecting codegened and inlined items\" }\n     }\n \n-    query codegen_unit(_: Symbol) -> &'tcx CodegenUnit<'tcx> {\n-        desc { \"codegen_unit\" }\n+    query codegen_unit(sym: Symbol) -> &'tcx CodegenUnit<'tcx> {\n+        desc { \"getting codegen unit `{sym}`\" }\n     }\n+\n     query unused_generic_params(key: ty::InstanceDef<'tcx>) -> FiniteBitSet<u32> {\n         cache_on_disk_if { key.def_id().is_local() }\n         desc {\n@@ -1839,6 +1841,7 @@ rustc_queries! {\n         }\n         separate_provide_extern\n     }\n+\n     query backend_optimization_level(_: ()) -> OptLevel {\n         desc { \"optimization level used by backend\" }\n     }\n@@ -1849,7 +1852,7 @@ rustc_queries! {\n     /// has been destroyed.\n     query output_filenames(_: ()) -> &'tcx Arc<OutputFilenames> {\n         eval_always\n-        desc { \"output_filenames\" }\n+        desc { \"getting output filenames\" }\n     }\n \n     /// Do not call this query directly: invoke `normalize` instead.\n@@ -1859,7 +1862,7 @@ rustc_queries! {\n         &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, NormalizationResult<'tcx>>>,\n         NoSolution,\n     > {\n-        desc { \"normalizing `{:?}`\", goal }\n+        desc { \"normalizing `{}`\", goal.value.value }\n         remap_env_constness\n     }\n \n@@ -1877,7 +1880,7 @@ rustc_queries! {\n         &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, Vec<OutlivesBound<'tcx>>>>,\n         NoSolution,\n     > {\n-        desc { \"computing implied outlives bounds for `{:?}`\", goal }\n+        desc { \"computing implied outlives bounds for `{}`\", goal.value.value }\n         remap_env_constness\n     }\n \n@@ -1889,7 +1892,7 @@ rustc_queries! {\n         &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, DropckOutlivesResult<'tcx>>>,\n         NoSolution,\n     > {\n-        desc { \"computing dropck types for `{:?}`\", goal }\n+        desc { \"computing dropck types for `{}`\", goal.value.value }\n         remap_env_constness\n     }\n \n@@ -1917,7 +1920,7 @@ rustc_queries! {\n         &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>,\n         NoSolution,\n     > {\n-        desc { \"evaluating `type_op_ascribe_user_type` `{:?}`\", goal }\n+        desc { \"evaluating `type_op_ascribe_user_type` `{:?}`\", goal.value.value }\n         remap_env_constness\n     }\n \n@@ -1928,7 +1931,7 @@ rustc_queries! {\n         &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>,\n         NoSolution,\n     > {\n-        desc { \"evaluating `type_op_eq` `{:?}`\", goal }\n+        desc { \"evaluating `type_op_eq` `{:?}`\", goal.value.value }\n         remap_env_constness\n     }\n \n@@ -1939,7 +1942,7 @@ rustc_queries! {\n         &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>,\n         NoSolution,\n     > {\n-        desc { \"evaluating `type_op_subtype` `{:?}`\", goal }\n+        desc { \"evaluating `type_op_subtype` `{:?}`\", goal.value.value }\n         remap_env_constness\n     }\n \n@@ -1950,7 +1953,7 @@ rustc_queries! {\n         &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>,\n         NoSolution,\n     > {\n-        desc { \"evaluating `type_op_prove_predicate` `{:?}`\", goal }\n+        desc { \"evaluating `type_op_prove_predicate` `{:?}`\", goal.value.value }\n     }\n \n     /// Do not call this query directly: part of the `Normalize` type-op\n@@ -1960,7 +1963,7 @@ rustc_queries! {\n         &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, Ty<'tcx>>>,\n         NoSolution,\n     > {\n-        desc { \"normalizing `{:?}`\", goal }\n+        desc { \"normalizing `{}`\", goal.value.value.value }\n         remap_env_constness\n     }\n \n@@ -1971,7 +1974,7 @@ rustc_queries! {\n         &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ty::Predicate<'tcx>>>,\n         NoSolution,\n     > {\n-        desc { \"normalizing `{:?}`\", goal }\n+        desc { \"normalizing `{:?}`\", goal.value.value.value }\n         remap_env_constness\n     }\n \n@@ -1982,7 +1985,7 @@ rustc_queries! {\n         &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ty::PolyFnSig<'tcx>>>,\n         NoSolution,\n     > {\n-        desc { \"normalizing `{:?}`\", goal }\n+        desc { \"normalizing `{:?}`\", goal.value.value.value }\n         remap_env_constness\n     }\n \n@@ -1993,20 +1996,20 @@ rustc_queries! {\n         &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ty::FnSig<'tcx>>>,\n         NoSolution,\n     > {\n-        desc { \"normalizing `{:?}`\", goal }\n+        desc { \"normalizing `{:?}`\", goal.value.value.value }\n         remap_env_constness\n     }\n \n     query subst_and_check_impossible_predicates(key: (DefId, SubstsRef<'tcx>)) -> bool {\n         desc { |tcx|\n-            \"impossible substituted predicates:`{}`\",\n+            \"checking impossible substituted predicates: `{}`\",\n             tcx.def_path_str(key.0)\n         }\n     }\n \n     query is_impossible_method(key: (DefId, DefId)) -> bool {\n         desc { |tcx|\n-            \"checking if {} is impossible to call within {}\",\n+            \"checking if `{}` is impossible to call within `{}`\",\n             tcx.def_path_str(key.1),\n             tcx.def_path_str(key.0),\n         }\n@@ -2015,7 +2018,7 @@ rustc_queries! {\n     query method_autoderef_steps(\n         goal: CanonicalTyGoal<'tcx>\n     ) -> MethodAutoderefStepsResult<'tcx> {\n-        desc { \"computing autoderef types for `{:?}`\", goal }\n+        desc { \"computing autoderef types for `{}`\", goal.value.value }\n         remap_env_constness\n     }\n \n@@ -2063,7 +2066,7 @@ rustc_queries! {\n     }\n \n     query normalize_opaque_types(key: &'tcx ty::List<ty::Predicate<'tcx>>) -> &'tcx ty::List<ty::Predicate<'tcx>> {\n-        desc { \"normalizing opaque types in {:?}\", key }\n+        desc { \"normalizing opaque types in `{:?}`\", key }\n     }\n \n     /// Checks whether a type is definitely uninhabited. This is\n@@ -2073,7 +2076,7 @@ rustc_queries! {\n     /// will be `Abi::Uninhabited`. (Note that uninhabited types may have nonzero\n     /// size, to account for partial initialisation. See #49298 for details.)\n     query conservative_is_privately_uninhabited(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-        desc { \"conservatively checking if {:?} is privately uninhabited\", key }\n+        desc { \"conservatively checking if `{}` is privately uninhabited\", key.value }\n         remap_env_constness\n     }\n \n@@ -2093,7 +2096,7 @@ rustc_queries! {\n         arena_cache\n         eval_always\n         no_hash\n-        desc { \"performing HIR wf-checking for predicate {:?} at item {:?}\", key.0, key.1 }\n+        desc { \"performing HIR wf-checking for predicate `{:?}` at item `{:?}`\", key.0, key.1 }\n     }\n \n \n@@ -2112,11 +2115,11 @@ rustc_queries! {\n     }\n \n     query permits_uninit_init(key: TyAndLayout<'tcx>) -> bool {\n-        desc { \"checking to see if {:?} permits being left uninit\", key.ty }\n+        desc { \"checking to see if `{}` permits being left uninit\", key.ty }\n     }\n \n     query permits_zero_init(key: TyAndLayout<'tcx>) -> bool {\n-        desc { \"checking to see if {:?} permits being left zeroed\", key.ty }\n+        desc { \"checking to see if `{}` permits being left zeroed\", key.ty }\n     }\n \n     query compare_assoc_const_impl_item_with_trait_item("}, {"sha": "c5bd520aaea0d98c95938cb75ceb05288cdc19cc", "filename": "src/test/ui/async-await/no-const-async.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02d6135b5fc26ebb3fa35b138b181d64cc3e3e29/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02d6135b5fc26ebb3fa35b138b181d64cc3e3e29/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr?ref=02d6135b5fc26ebb3fa35b138b181d64cc3e3e29", "patch": "@@ -18,7 +18,7 @@ note: ...which requires borrow-checking `x`...\n    |\n LL | pub const async fn x() {}\n    | ^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `x`...\n+note: ...which requires processing MIR for `x`...\n   --> $DIR/no-const-async.rs:4:1\n    |\n LL | pub const async fn x() {}"}, {"sha": "a7d891d77908c15f1e626428513ec49395b6295e", "filename": "src/test/ui/const-generics/generic_const_exprs/closures.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02d6135b5fc26ebb3fa35b138b181d64cc3e3e29/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fclosures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02d6135b5fc26ebb3fa35b138b181d64cc3e3e29/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fclosures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fclosures.stderr?ref=02d6135b5fc26ebb3fa35b138b181d64cc3e3e29", "patch": "@@ -1,4 +1,4 @@\n-error[E0391]: cycle detected when building an abstract representation for test::{constant#0}\n+error[E0391]: cycle detected when building an abstract representation for `test::{constant#0}`\n   --> $DIR/closures.rs:3:35\n    |\n LL | fn test<const N: usize>() -> [u8; N + (|| 42)()] {}\n@@ -14,7 +14,7 @@ note: ...which requires type-checking `test::{constant#0}`...\n    |\n LL | fn test<const N: usize>() -> [u8; N + (|| 42)()] {}\n    |                                   ^^^^^^^^^^^^^\n-   = note: ...which again requires building an abstract representation for test::{constant#0}, completing the cycle\n+   = note: ...which again requires building an abstract representation for `test::{constant#0}`, completing the cycle\n note: cycle used when checking that `test` is well-formed\n   --> $DIR/closures.rs:3:1\n    |"}, {"sha": "feedfc40aaf4944a747f2add2a0d05a6f78a1a24", "filename": "src/test/ui/impl-trait/auto-trait-leak.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02d6135b5fc26ebb3fa35b138b181d64cc3e3e29/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02d6135b5fc26ebb3fa35b138b181d64cc3e3e29/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr?ref=02d6135b5fc26ebb3fa35b138b181d64cc3e3e29", "patch": "@@ -9,12 +9,12 @@ note: ...which requires borrow-checking `cycle1`...\n    |\n LL | fn cycle1() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `cycle1`...\n+note: ...which requires processing MIR for `cycle1`...\n   --> $DIR/auto-trait-leak.rs:12:1\n    |\n LL | fn cycle1() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing MIR for `cycle1`...\n+note: ...which requires preparing `cycle1` for borrow checking...\n   --> $DIR/auto-trait-leak.rs:12:1\n    |\n LL | fn cycle1() -> impl Clone {\n@@ -50,12 +50,12 @@ note: ...which requires borrow-checking `cycle2`...\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `cycle2`...\n+note: ...which requires processing MIR for `cycle2`...\n   --> $DIR/auto-trait-leak.rs:19:1\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing MIR for `cycle2`...\n+note: ...which requires preparing `cycle2` for borrow checking...\n   --> $DIR/auto-trait-leak.rs:19:1\n    |\n LL | fn cycle2() -> impl Clone {"}, {"sha": "038fdfb2d51b2a4fd5258fe7cc7104e51c8f86f3", "filename": "src/test/ui/parser/fn-header-semantic-fail.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02d6135b5fc26ebb3fa35b138b181d64cc3e3e29/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02d6135b5fc26ebb3fa35b138b181d64cc3e3e29/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr?ref=02d6135b5fc26ebb3fa35b138b181d64cc3e3e29", "patch": "@@ -199,7 +199,7 @@ note: ...which requires borrow-checking `main::ff5`...\n    |\n LL |     const async unsafe extern \"C\" fn ff5() {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `main::ff5`...\n+note: ...which requires processing MIR for `main::ff5`...\n   --> $DIR/fn-header-semantic-fail.rs:12:5\n    |\n LL |     const async unsafe extern \"C\" fn ff5() {}\n@@ -235,7 +235,7 @@ note: ...which requires borrow-checking `main::<impl at $DIR/fn-header-semantic-\n    |\n LL |         const async unsafe extern \"C\" fn ft5() {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `main::<impl at $DIR/fn-header-semantic-fail.rs:28:5: 28:17>::ft5`...\n+note: ...which requires processing MIR for `main::<impl at $DIR/fn-header-semantic-fail.rs:28:5: 28:17>::ft5`...\n   --> $DIR/fn-header-semantic-fail.rs:33:9\n    |\n LL |         const async unsafe extern \"C\" fn ft5() {}\n@@ -271,7 +271,7 @@ note: ...which requires borrow-checking `main::<impl at $DIR/fn-header-semantic-\n    |\n LL |         const async unsafe extern \"C\" fn fi5() {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `main::<impl at $DIR/fn-header-semantic-fail.rs:40:5: 40:11>::fi5`...\n+note: ...which requires processing MIR for `main::<impl at $DIR/fn-header-semantic-fail.rs:40:5: 40:11>::fi5`...\n   --> $DIR/fn-header-semantic-fail.rs:45:9\n    |\n LL |         const async unsafe extern \"C\" fn fi5() {}"}, {"sha": "832afddf89147d68058a7b73853551d9042d0df6", "filename": "src/test/ui/treat-err-as-bug/delay_span_bug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02d6135b5fc26ebb3fa35b138b181d64cc3e3e29/src%2Ftest%2Fui%2Ftreat-err-as-bug%2Fdelay_span_bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02d6135b5fc26ebb3fa35b138b181d64cc3e3e29/src%2Ftest%2Fui%2Ftreat-err-as-bug%2Fdelay_span_bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftreat-err-as-bug%2Fdelay_span_bug.rs?ref=02d6135b5fc26ebb3fa35b138b181d64cc3e3e29", "patch": "@@ -1,7 +1,7 @@\n // compile-flags: -Ztreat-err-as-bug\n // failure-status: 101\n // error-pattern: aborting due to `-Z treat-err-as-bug=1`\n-// error-pattern: [trigger_delay_span_bug] trigger a delay span bug\n+// error-pattern: [trigger_delay_span_bug] triggering a delay span bug\n // normalize-stderr-test \"note: .*\\n\\n\" -> \"\"\n // normalize-stderr-test \"thread 'rustc' panicked.*\\n\" -> \"\"\n // rustc-env:RUST_BACKTRACE=0"}, {"sha": "e9457c8faff4d349bad987563af0f9862c163cbc", "filename": "src/test/ui/treat-err-as-bug/delay_span_bug.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02d6135b5fc26ebb3fa35b138b181d64cc3e3e29/src%2Ftest%2Fui%2Ftreat-err-as-bug%2Fdelay_span_bug.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02d6135b5fc26ebb3fa35b138b181d64cc3e3e29/src%2Ftest%2Fui%2Ftreat-err-as-bug%2Fdelay_span_bug.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftreat-err-as-bug%2Fdelay_span_bug.stderr?ref=02d6135b5fc26ebb3fa35b138b181d64cc3e3e29", "patch": "@@ -7,5 +7,5 @@ LL | fn main() {}\n error: internal compiler error: unexpected panic\n \n query stack during panic:\n-#0 [trigger_delay_span_bug] trigger a delay span bug\n+#0 [trigger_delay_span_bug] triggering a delay span bug\n end of query stack"}]}