{"sha": "9a6a72b81837bed367de38297479ad554537d70c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhNmE3MmI4MTgzN2JlZDM2N2RlMzgyOTc0NzlhZDU1NDUzN2Q3MGM=", "commit": {"author": {"name": "Glyne J. Gittens", "email": "Jgit121@gmail.com", "date": "2017-02-19T22:32:21Z"}, "committer": {"name": "Glyne J. Gittens", "email": "Jgit121@gmail.com", "date": "2017-02-19T22:32:21Z"}, "message": "Merge branch 'master' of https://github.com/rust-lang/rust", "tree": {"sha": "a9fc17869c699ea448d458d2194dec241e410099", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9fc17869c699ea448d458d2194dec241e410099"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a6a72b81837bed367de38297479ad554537d70c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a6a72b81837bed367de38297479ad554537d70c", "html_url": "https://github.com/rust-lang/rust/commit/9a6a72b81837bed367de38297479ad554537d70c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a6a72b81837bed367de38297479ad554537d70c/comments", "author": {"login": "ArtBears", "id": 4316945, "node_id": "MDQ6VXNlcjQzMTY5NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/4316945?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArtBears", "html_url": "https://github.com/ArtBears", "followers_url": "https://api.github.com/users/ArtBears/followers", "following_url": "https://api.github.com/users/ArtBears/following{/other_user}", "gists_url": "https://api.github.com/users/ArtBears/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArtBears/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArtBears/subscriptions", "organizations_url": "https://api.github.com/users/ArtBears/orgs", "repos_url": "https://api.github.com/users/ArtBears/repos", "events_url": "https://api.github.com/users/ArtBears/events{/privacy}", "received_events_url": "https://api.github.com/users/ArtBears/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ArtBears", "id": 4316945, "node_id": "MDQ6VXNlcjQzMTY5NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/4316945?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArtBears", "html_url": "https://github.com/ArtBears", "followers_url": "https://api.github.com/users/ArtBears/followers", "following_url": "https://api.github.com/users/ArtBears/following{/other_user}", "gists_url": "https://api.github.com/users/ArtBears/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArtBears/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArtBears/subscriptions", "organizations_url": "https://api.github.com/users/ArtBears/orgs", "repos_url": "https://api.github.com/users/ArtBears/repos", "events_url": "https://api.github.com/users/ArtBears/events{/privacy}", "received_events_url": "https://api.github.com/users/ArtBears/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3f61ce538862e58d4d3cb02960fe6e9a8ccc4e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3f61ce538862e58d4d3cb02960fe6e9a8ccc4e4", "html_url": "https://github.com/rust-lang/rust/commit/b3f61ce538862e58d4d3cb02960fe6e9a8ccc4e4"}, {"sha": "0e77277950aafd38ce3e52b7b1cd9bcc6664de3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e77277950aafd38ce3e52b7b1cd9bcc6664de3c", "html_url": "https://github.com/rust-lang/rust/commit/0e77277950aafd38ce3e52b7b1cd9bcc6664de3c"}], "stats": {"total": 614, "additions": 391, "deletions": 223}, "files": [{"sha": "62e476bd737d3f62c02d59de2cc168021392b640", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -205,6 +205,11 @@ fn main() {\n                 }\n             }\n         }\n+\n+        if target.contains(\"pc-windows-msvc\") {\n+            cmd.arg(\"-Z\").arg(\"unstable-options\");\n+            cmd.arg(\"-C\").arg(\"target-feature=+crt-static\");\n+        }\n     }\n \n     if verbose > 1 {"}, {"sha": "7ca7ef4bd720c2f8ab8a119af8bbe3c6d52b2390", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -173,6 +173,8 @@ def download_stage0(self):\n             if not os.path.exists(tarball):\n                 get(\"{}/{}\".format(url, filename), tarball, verbose=self.verbose)\n             unpack(tarball, self.bin_root(), match=\"rustc\", verbose=self.verbose)\n+            self.fix_executable(self.bin_root() + \"/bin/rustc\")\n+            self.fix_executable(self.bin_root() + \"/bin/rustdoc\")\n             with open(self.rustc_stamp(), 'w') as f:\n                 f.write(self.stage0_rustc_date())\n \n@@ -185,9 +187,63 @@ def download_stage0(self):\n             if not os.path.exists(tarball):\n                 get(\"{}/{}\".format(url, filename), tarball, verbose=self.verbose)\n             unpack(tarball, self.bin_root(), match=\"cargo\", verbose=self.verbose)\n+            self.fix_executable(self.bin_root() + \"/bin/cargo\")\n             with open(self.cargo_stamp(), 'w') as f:\n                 f.write(self.stage0_cargo_rev())\n \n+    def fix_executable(self, fname):\n+        # If we're on NixOS we need to change the path to the dynamic loader\n+\n+        default_encoding = sys.getdefaultencoding()\n+        try:\n+            ostype = subprocess.check_output(['uname', '-s']).strip().decode(default_encoding)\n+        except (subprocess.CalledProcessError, WindowsError):\n+            return\n+\n+        if ostype != \"Linux\":\n+            return\n+\n+        if not os.path.exists(\"/etc/NIXOS\"):\n+            return\n+        if os.path.exists(\"/lib\"):\n+            return\n+\n+        # At this point we're pretty sure the user is running NixOS\n+        print(\"info: you seem to be running NixOS. Attempting to patch \" + fname)\n+\n+        try:\n+            interpreter = subprocess.check_output([\"patchelf\", \"--print-interpreter\", fname])\n+            interpreter = interpreter.strip().decode(default_encoding)\n+        except subprocess.CalledProcessError as e:\n+            print(\"warning: failed to call patchelf: %s\" % e)\n+            return\n+\n+        loader = interpreter.split(\"/\")[-1]\n+\n+        try:\n+            ldd_output = subprocess.check_output(['ldd', '/run/current-system/sw/bin/sh'])\n+            ldd_output = ldd_output.strip().decode(default_encoding)\n+        except subprocess.CalledProcessError as e:\n+            print(\"warning: unable to call ldd: %s\" % e)\n+            return\n+\n+        for line in ldd_output.splitlines():\n+            libname = line.split()[0]\n+            if libname.endswith(loader):\n+                loader_path = libname[:len(libname) - len(loader)]\n+                break\n+        else:\n+            print(\"warning: unable to find the path to the dynamic linker\")\n+            return\n+\n+        correct_interpreter = loader_path + loader\n+\n+        try:\n+            subprocess.check_output([\"patchelf\", \"--set-interpreter\", correct_interpreter, fname])\n+        except subprocess.CalledProcessError as e:\n+            print(\"warning: failed to call patchelf: %s\" % e)\n+            return\n+\n     def stage0_cargo_rev(self):\n         return self._cargo_rev\n "}, {"sha": "f16fc2092f6161d639c7cca890f0cd87d93cba8b", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -99,6 +99,12 @@ pub fn llvm(build: &Build, target: &str) {\n        .define(\"LLVM_TARGET_ARCH\", target.split('-').next().unwrap())\n        .define(\"LLVM_DEFAULT_TARGET_TRIPLE\", target);\n \n+    if target.contains(\"msvc\") {\n+        cfg.define(\"LLVM_USE_CRT_DEBUG\", \"MT\");\n+        cfg.define(\"LLVM_USE_CRT_RELEASE\", \"MT\");\n+        cfg.define(\"LLVM_USE_CRT_RELWITHDEBINFO\", \"MT\");\n+    }\n+\n     if target.starts_with(\"i686\") {\n         cfg.define(\"LLVM_BUILD_32_BITS\", \"ON\");\n     }"}, {"sha": "079324d56d1e662ea82e280f2415155f902452b4", "filename": "src/doc/book/src/procedural-macros.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Fdoc%2Fbook%2Fsrc%2Fprocedural-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Fdoc%2Fbook%2Fsrc%2Fprocedural-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fprocedural-macros.md?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -169,7 +169,7 @@ So this is where quotes comes in. The `ast` argument is a struct that gives us\n a representation of our type (which can be either a `struct` or an `enum`).\n Check out the [docs](https://docs.rs/syn/0.10.5/syn/struct.MacroInput.html),\n there is some useful information there. We are able to get the name of the\n-type using `ast.ident`. The `quote!` macro let's us write up the Rust code\n+type using `ast.ident`. The `quote!` macro lets us write up the Rust code\n that we wish to return and convert it into `Tokens`. `quote!` let's us use some\n really cool templating mechanics; we simply write `#name` and `quote!` will\n replace it with the variable named `name`. You can even do some repetition"}, {"sha": "e92eb4ff7bdd4b565b4a81543e09b366d9230dae", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -1250,17 +1250,17 @@ impl String {\n         self.len() == 0\n     }\n \n-    /// Divide one string into two at an index.\n+    /// Splits the string into two at the given index.\n     ///\n-    /// The argument, `mid`, should be a byte offset from the start of the string. It must also\n-    /// be on the boundary of a UTF-8 code point.\n+    /// Returns a newly allocated `String`. `self` contains bytes `[0, at)`, and\n+    /// the returned `String` contains bytes `[at, len)`. `at` must be on the\n+    /// boundary of a UTF-8 code point.\n     ///\n-    /// The two strings returned go from the start of the string to `mid`, and from `mid` to the end\n-    /// of the string.\n+    /// Note that the capacity of `self` does not change.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `mid` is not on a `UTF-8` code point boundary, or if it is beyond the last\n+    /// Panics if `at` is not on a `UTF-8` code point boundary, or if it is beyond the last\n     /// code point of the string.\n     ///\n     /// # Examples\n@@ -1275,9 +1275,9 @@ impl String {\n     /// ```\n     #[inline]\n     #[stable(feature = \"string_split_off\", since = \"1.16.0\")]\n-    pub fn split_off(&mut self, mid: usize) -> String {\n-        assert!(self.is_char_boundary(mid));\n-        let other = self.vec.split_off(mid);\n+    pub fn split_off(&mut self, at: usize) -> String {\n+        assert!(self.is_char_boundary(at));\n+        let other = self.vec.split_off(at);\n         unsafe { String::from_utf8_unchecked(other) }\n     }\n "}, {"sha": "3785bbe9bb0e42ad3c5853daf46ae55a8ffad902", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -1603,12 +1603,12 @@ pub trait Iterator {\n         let mut i = self.len();\n \n         while let Some(v) = self.next_back() {\n-            if predicate(v) {\n-                return Some(i - 1);\n-            }\n             // No need for an overflow check here, because `ExactSizeIterator`\n             // implies that the number of elements fits into a `usize`.\n             i -= 1;\n+            if predicate(v) {\n+                return Some(i);\n+            }\n         }\n         None\n     }"}, {"sha": "7a3754f2bb5e65eb39adacb189c3626173032177", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -1 +1 @@\n-Subproject commit 8d8264b967a31a1a8cebe2a05110564106b6e909\n+Subproject commit 7a3754f2bb5e65eb39adacb189c3626173032177"}, {"sha": "96d1a925425e8d322a283e9bc4ffc6a716b1eb52", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 42, "deletions": 4, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -131,7 +131,37 @@ pub enum DepNode<D: Clone + Debug> {\n     // which would yield an overly conservative dep-graph.\n     TraitItems(D),\n     ReprHints(D),\n-    TraitSelect(Vec<D>),\n+\n+    // Trait selection cache is a little funny. Given a trait\n+    // reference like `Foo: SomeTrait<Bar>`, there could be\n+    // arbitrarily many def-ids to map on in there (e.g., `Foo`,\n+    // `SomeTrait`, `Bar`). We could have a vector of them, but it\n+    // requires heap-allocation, and trait sel in general can be a\n+    // surprisingly hot path. So instead we pick two def-ids: the\n+    // trait def-id, and the first def-id in the input types. If there\n+    // is no def-id in the input types, then we use the trait def-id\n+    // again. So for example:\n+    //\n+    // - `i32: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: Clone }`\n+    // - `u32: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: Clone }`\n+    // - `Clone: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: Clone }`\n+    // - `Vec<i32>: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: Vec }`\n+    // - `String: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: String }`\n+    // - `Foo: Trait<Bar>` -> `TraitSelect { trait_def_id: Trait, self_def_id: Foo }`\n+    // - `Foo: Trait<i32>` -> `TraitSelect { trait_def_id: Trait, self_def_id: Foo }`\n+    // - `(Foo, Bar): Trait` -> `TraitSelect { trait_def_id: Trait, self_def_id: Foo }`\n+    // - `i32: Trait<Foo>` -> `TraitSelect { trait_def_id: Trait, self_def_id: Foo }`\n+    //\n+    // You can see that we map many trait refs to the same\n+    // trait-select node.  This is not a problem, it just means\n+    // imprecision in our dep-graph tracking.  The important thing is\n+    // that for any given trait-ref, we always map to the **same**\n+    // trait-select node.\n+    TraitSelect { trait_def_id: D, input_def_id: D },\n+\n+    // For proj. cache, we just keep a list of all def-ids, since it is\n+    // not a hotspot.\n+    ProjectionCache { def_ids: Vec<D> },\n }\n \n impl<D: Clone + Debug> DepNode<D> {\n@@ -236,9 +266,17 @@ impl<D: Clone + Debug> DepNode<D> {\n             TraitImpls(ref d) => op(d).map(TraitImpls),\n             TraitItems(ref d) => op(d).map(TraitItems),\n             ReprHints(ref d) => op(d).map(ReprHints),\n-            TraitSelect(ref type_ds) => {\n-                let type_ds = try_opt!(type_ds.iter().map(|d| op(d)).collect());\n-                Some(TraitSelect(type_ds))\n+            TraitSelect { ref trait_def_id, ref input_def_id } => {\n+                op(trait_def_id).and_then(|trait_def_id| {\n+                    op(input_def_id).and_then(|input_def_id| {\n+                        Some(TraitSelect { trait_def_id: trait_def_id,\n+                                           input_def_id: input_def_id })\n+                    })\n+                })\n+            }\n+            ProjectionCache { ref def_ids } => {\n+                let def_ids: Option<Vec<E>> = def_ids.iter().map(op).collect();\n+                def_ids.map(|d| ProjectionCache { def_ids: d })\n             }\n         }\n     }"}, {"sha": "53b7be74f85037dcaea5d9e7c362f0413d41447b", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -59,32 +59,45 @@ pub enum Def {\n     Err,\n }\n \n-/// The result of resolving a path.\n-/// Before type checking completes, `depth` represents the number of\n-/// trailing segments which are yet unresolved. Afterwards, if there\n-/// were no errors, all paths should be fully resolved, with `depth`\n-/// set to `0` and `base_def` representing the final resolution.\n-///\n+/// The result of resolving a path before lowering to HIR.\n+/// `base_def` is definition of resolved part of the\n+/// path, `unresolved_segments` is the number of unresolved\n+/// segments.\n ///     module::Type::AssocX::AssocY::MethodOrAssocType\n ///     ^~~~~~~~~~~~  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-///     base_def      depth = 3\n+///     base_def      unresolved_segments = 3\n ///\n ///     <T as Trait>::AssocX::AssocY::MethodOrAssocType\n ///           ^~~~~~~~~~~~~~  ^~~~~~~~~~~~~~~~~~~~~~~~~\n-///           base_def        depth = 2\n+///           base_def        unresolved_segments = 2\n #[derive(Copy, Clone, Debug)]\n pub struct PathResolution {\n-    pub base_def: Def,\n-    pub depth: usize\n+    base_def: Def,\n+    unresolved_segments: usize,\n }\n \n impl PathResolution {\n-    pub fn new(def: Def) -> PathResolution {\n-        PathResolution { base_def: def, depth: 0 }\n+    pub fn new(def: Def) -> Self {\n+        PathResolution { base_def: def, unresolved_segments: 0 }\n+    }\n+\n+    pub fn with_unresolved_segments(def: Def, mut unresolved_segments: usize) -> Self {\n+        if def == Def::Err { unresolved_segments = 0 }\n+        PathResolution { base_def: def, unresolved_segments: unresolved_segments }\n+    }\n+\n+    #[inline]\n+    pub fn base_def(&self) -> Def {\n+        self.base_def\n+    }\n+\n+    #[inline]\n+    pub fn unresolved_segments(&self) -> usize {\n+        self.unresolved_segments\n     }\n \n     pub fn kind_name(&self) -> &'static str {\n-        if self.depth != 0 {\n+        if self.unresolved_segments != 0 {\n             \"associated item\"\n         } else {\n             self.base_def.kind_name()"}, {"sha": "c87ce6505fcd505e81bff483904cec8e691ff254", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -217,10 +217,10 @@ impl<'a> LoweringContext<'a> {\n \n     fn expect_full_def(&mut self, id: NodeId) -> Def {\n         self.resolver.get_resolution(id).map_or(Def::Err, |pr| {\n-            if pr.depth != 0 {\n+            if pr.unresolved_segments() != 0 {\n                 bug!(\"path not fully resolved: {:?}\", pr);\n             }\n-            pr.base_def\n+            pr.base_def()\n         })\n     }\n \n@@ -421,9 +421,9 @@ impl<'a> LoweringContext<'a> {\n         let resolution = self.resolver.get_resolution(id)\n                                       .unwrap_or(PathResolution::new(Def::Err));\n \n-        let proj_start = p.segments.len() - resolution.depth;\n+        let proj_start = p.segments.len() - resolution.unresolved_segments();\n         let path = P(hir::Path {\n-            def: resolution.base_def,\n+            def: resolution.base_def(),\n             segments: p.segments[..proj_start].iter().enumerate().map(|(i, segment)| {\n                 let param_mode = match (qself_position, param_mode) {\n                     (Some(j), ParamMode::Optional) if i < j => {\n@@ -443,7 +443,7 @@ impl<'a> LoweringContext<'a> {\n                         index: this.def_key(def_id).parent.expect(\"missing parent\")\n                     }\n                 };\n-                let type_def_id = match resolution.base_def {\n+                let type_def_id = match resolution.base_def() {\n                     Def::AssociatedTy(def_id) if i + 2 == proj_start => {\n                         Some(parent_def_id(self, def_id))\n                     }\n@@ -474,7 +474,7 @@ impl<'a> LoweringContext<'a> {\n \n         // Simple case, either no projections, or only fully-qualified.\n         // E.g. `std::mem::size_of` or `<I as Iterator>::Item`.\n-        if resolution.depth == 0 {\n+        if resolution.unresolved_segments() == 0 {\n             return hir::QPath::Resolved(qself, path);\n         }\n \n@@ -749,7 +749,7 @@ impl<'a> LoweringContext<'a> {\n                                        bound_pred.bound_lifetimes.is_empty() => {\n                                 if let Some(Def::TyParam(def_id)) =\n                                         self.resolver.get_resolution(bound_pred.bounded_ty.id)\n-                                                     .map(|d| d.base_def) {\n+                                                     .map(|d| d.base_def()) {\n                                     if let Some(node_id) =\n                                             self.resolver.definitions().as_local_node_id(def_id) {\n                                         for ty_param in &g.ty_params {\n@@ -1295,7 +1295,7 @@ impl<'a> LoweringContext<'a> {\n                 PatKind::Wild => hir::PatKind::Wild,\n                 PatKind::Ident(ref binding_mode, pth1, ref sub) => {\n                     self.with_parent_def(p.id, |this| {\n-                        match this.resolver.get_resolution(p.id).map(|d| d.base_def) {\n+                        match this.resolver.get_resolution(p.id).map(|d| d.base_def()) {\n                             // `None` can occur in body-less function signatures\n                             def @ None | def @ Some(Def::Local(_)) => {\n                                 let def_id = def.map(|d| d.def_id()).unwrap_or_else(|| {"}, {"sha": "3403cf0477450005d7156bd027b4dd746608e029", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -777,6 +777,12 @@ pub enum StatementKind<'tcx> {\n     /// End the current live range for the storage of the local.\n     StorageDead(Lvalue<'tcx>),\n \n+    InlineAsm {\n+        asm: InlineAsm,\n+        outputs: Vec<Lvalue<'tcx>>,\n+        inputs: Vec<Operand<'tcx>>\n+    },\n+\n     /// No-op. Useful for deleting instructions without affecting statement indices.\n     Nop,\n }\n@@ -790,7 +796,10 @@ impl<'tcx> Debug for Statement<'tcx> {\n             StorageDead(ref lv) => write!(fmt, \"StorageDead({:?})\", lv),\n             SetDiscriminant{lvalue: ref lv, variant_index: index} => {\n                 write!(fmt, \"discriminant({:?}) = {:?}\", lv, index)\n-            }\n+            },\n+            InlineAsm { ref asm, ref outputs, ref inputs } => {\n+                write!(fmt, \"asm!({:?} : {:?} : {:?})\", asm, outputs, inputs)\n+            },\n             Nop => write!(fmt, \"nop\"),\n         }\n     }\n@@ -1004,12 +1013,6 @@ pub enum Rvalue<'tcx> {\n     /// that `Foo` has a destructor. These rvalues can be optimized\n     /// away after type-checking and before lowering.\n     Aggregate(AggregateKind<'tcx>, Vec<Operand<'tcx>>),\n-\n-    InlineAsm {\n-        asm: InlineAsm,\n-        outputs: Vec<Lvalue<'tcx>>,\n-        inputs: Vec<Operand<'tcx>>\n-    }\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n@@ -1111,10 +1114,6 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n             UnaryOp(ref op, ref a) => write!(fmt, \"{:?}({:?})\", op, a),\n             Discriminant(ref lval) => write!(fmt, \"discriminant({:?})\", lval),\n             Box(ref t) => write!(fmt, \"Box({:?})\", t),\n-            InlineAsm { ref asm, ref outputs, ref inputs } => {\n-                write!(fmt, \"asm!({:?} : {:?} : {:?})\", asm, outputs, inputs)\n-            }\n-\n             Ref(_, borrow_kind, ref lv) => {\n                 let kind_str = match borrow_kind {\n                     BorrowKind::Shared => \"\","}, {"sha": "5c8d031caf60dafc365bcba535d7fb41a204b4fe", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -207,7 +207,6 @@ impl<'tcx> Rvalue<'tcx> {\n                     }\n                 }\n             }\n-            Rvalue::InlineAsm { .. } => None\n         }\n     }\n }"}, {"sha": "7cdbd5cae061fc0f8b7100ae1ec9a2cbffab6fee", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -333,6 +333,16 @@ macro_rules! make_mir_visitor {\n                     StatementKind::StorageDead(ref $($mutability)* lvalue) => {\n                         self.visit_lvalue(lvalue, LvalueContext::StorageDead, location);\n                     }\n+                    StatementKind::InlineAsm { ref $($mutability)* outputs,\n+                                               ref $($mutability)* inputs,\n+                                               asm: _ } => {\n+                        for output in & $($mutability)* outputs[..] {\n+                            self.visit_lvalue(output, LvalueContext::Store, location);\n+                        }\n+                        for input in & $($mutability)* inputs[..] {\n+                            self.visit_operand(input, location);\n+                        }\n+                    }\n                     StatementKind::Nop => {}\n                 }\n             }\n@@ -526,17 +536,6 @@ macro_rules! make_mir_visitor {\n                             self.visit_operand(operand, location);\n                         }\n                     }\n-\n-                    Rvalue::InlineAsm { ref $($mutability)* outputs,\n-                                        ref $($mutability)* inputs,\n-                                        asm: _ } => {\n-                        for output in & $($mutability)* outputs[..] {\n-                            self.visit_lvalue(output, LvalueContext::Store, location);\n-                        }\n-                        for input in & $($mutability)* inputs[..] {\n-                            self.visit_operand(input, location);\n-                        }\n-                    }\n                 }\n             }\n "}, {"sha": "58ab713ef27308e220dd15cfe15ff5f6734dbf4f", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -628,6 +628,11 @@ pub fn get_vtable_methods<'a, 'tcx>(\n                                           |_, _| tcx.mk_region(ty::ReErased),\n                                           |def, _| trait_ref.substs().type_for_def(def));\n \n+            // the trait type may have higher-ranked lifetimes in it;\n+            // so erase them if they appear, so that we get the type\n+            // at some particular call site\n+            let substs = tcx.erase_late_bound_regions_and_normalize(&ty::Binder(substs));\n+\n             // It's possible that the method relies on where clauses that\n             // do not hold for this particular set of type parameters.\n             // Note that this method could then never be called, so we"}, {"sha": "40c62762c3cf3eab68a442ac242e0e59f8680331", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -2547,7 +2547,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 // TyError and ensure they do not affect any other fields.\n                 // This could be checked after type collection for any struct\n                 // with a potentially unsized trailing field.\n-                let params = substs_a.params().iter().enumerate().map(|(i, &k)| {\n+                let params = substs_a.iter().enumerate().map(|(i, &k)| {\n                     if ty_params.contains(i) {\n                         Kind::from(tcx.types.err)\n                     } else {\n@@ -2567,7 +2567,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n                 // Check that the source structure with the target's\n                 // type parameters is a subtype of the target.\n-                let params = substs_a.params().iter().enumerate().map(|(i, &k)| {\n+                let params = substs_a.iter().enumerate().map(|(i, &k)| {\n                     if ty_params.contains(i) {\n                         Kind::from(substs_b.type_at(i))\n                     } else {"}, {"sha": "7937d2ccfe46da45d4c6e5d5524a6599986a7590", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -34,7 +34,6 @@ use serialize::{self, Encodable, Encoder};\n use std::borrow::Cow;\n use std::cell::{Cell, RefCell, Ref};\n use std::hash::{Hash, Hasher};\n-use std::iter;\n use std::ops::Deref;\n use std::rc::Rc;\n use std::slice;\n@@ -843,27 +842,22 @@ impl<'tcx> TraitPredicate<'tcx> {\n \n     /// Creates the dep-node for selecting/evaluating this trait reference.\n     fn dep_node(&self) -> DepNode<DefId> {\n-        // Ideally, the dep-node would just have all the input types\n-        // in it.  But they are limited to including def-ids. So as an\n-        // approximation we include the def-ids for all nominal types\n-        // found somewhere. This means that we will e.g. conflate the\n-        // dep-nodes for `u32: SomeTrait` and `u64: SomeTrait`, but we\n-        // would have distinct dep-nodes for `Vec<u32>: SomeTrait`,\n-        // `Rc<u32>: SomeTrait`, and `(Vec<u32>, Rc<u32>): SomeTrait`.\n-        // Note that it's always sound to conflate dep-nodes, it just\n-        // leads to more recompilation.\n-        let def_ids: Vec<_> =\n+        // Extact the trait-def and first def-id from inputs.  See the\n+        // docs for `DepNode::TraitSelect` for more information.\n+        let trait_def_id = self.def_id();\n+        let input_def_id =\n             self.input_types()\n                 .flat_map(|t| t.walk())\n                 .filter_map(|t| match t.sty {\n-                    ty::TyAdt(adt_def, _) =>\n-                        Some(adt_def.did),\n-                    _ =>\n-                        None\n+                    ty::TyAdt(adt_def, _) => Some(adt_def.did),\n+                    _ => None\n                 })\n-                .chain(iter::once(self.def_id()))\n-                .collect();\n-        DepNode::TraitSelect(def_ids)\n+                .next()\n+                .unwrap_or(trait_def_id);\n+        DepNode::TraitSelect {\n+            trait_def_id: trait_def_id,\n+            input_def_id: input_def_id\n+        }\n     }\n \n     pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {"}, {"sha": "2e3009b4ed6dba72b0c814a700ae28dd40cb2475", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -143,7 +143,7 @@ pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n {\n     let tcx = relation.tcx();\n \n-    let params = a_subst.params().iter().zip(b_subst.params()).enumerate().map(|(i, (a, b))| {\n+    let params = a_subst.iter().zip(b_subst).enumerate().map(|(i, (a, b))| {\n         let variance = variances.map_or(ty::Invariant, |v| v[i]);\n         if let (Some(a_ty), Some(b_ty)) = (a.as_type(), b.as_type()) {\n             Ok(Kind::from(relation.relate_with_variance(variance, &a_ty, &b_ty)?))"}, {"sha": "c0a529b936b0fbde258a5aa22aadc5e93c06e92a", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -254,12 +254,6 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n         self.is_empty()\n     }\n \n-    #[inline]\n-    pub fn params(&self) -> &[Kind<'tcx>] {\n-        // FIXME (dikaiosune) this should be removed, and corresponding compilation errors fixed\n-        self\n-    }\n-\n     #[inline]\n     pub fn types(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n         self.iter().filter_map(|k| k.as_type())"}, {"sha": "7888a56d39dfbd5a5b3757160009e73acf2d7e61", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -473,6 +473,7 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n             }\n             mir::StatementKind::StorageLive(_) |\n             mir::StatementKind::StorageDead(_) |\n+            mir::StatementKind::InlineAsm { .. } |\n             mir::StatementKind::Nop => {}\n         }\n     }"}, {"sha": "940dd5433a0d9ee3846f762c9a8da678293be009", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/sanity_check.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -104,6 +104,7 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n             mir::StatementKind::StorageLive(_) |\n             mir::StatementKind::StorageDead(_) |\n+            mir::StatementKind::InlineAsm { .. } |\n             mir::StatementKind::Nop => continue,\n             mir::StatementKind::SetDiscriminant{ .. } =>\n                 span_bug!(stmt.source_info.span,"}, {"sha": "35ace6628cfed4d7f244443a4feda936e20555c3", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -412,6 +412,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n                 span_bug!(stmt.source_info.span,\n                           \"SetDiscriminant should not exist during borrowck\");\n             }\n+            StatementKind::InlineAsm { .. } |\n             StatementKind::Nop => {}\n         }\n     }\n@@ -436,8 +437,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n             }\n             Rvalue::Ref(..) |\n             Rvalue::Discriminant(..) |\n-            Rvalue::Len(..) |\n-            Rvalue::InlineAsm { .. } => {}\n+            Rvalue::Len(..) => {}\n             Rvalue::Box(..) => {\n                 // This returns an rvalue with uninitialized contents. We can't\n                 // move out of it here because it is an rvalue - assignments always"}, {"sha": "d9283e7037f50f2dc851af5ec9cb53737709f837", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -378,6 +378,7 @@ fn drop_flag_effects_for_location<'a, 'tcx, F>(\n             }\n             mir::StatementKind::StorageLive(_) |\n             mir::StatementKind::StorageDead(_) |\n+            mir::StatementKind::InlineAsm { .. } |\n             mir::StatementKind::Nop => {}\n         },\n         None => {"}, {"sha": "7adcc0e730b15710425c9ead59b7586b2048fc87", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -49,21 +49,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Scope { extent, value } => {\n                 this.in_scope(extent, block, |this| this.as_rvalue(block, value))\n             }\n-            ExprKind::InlineAsm { asm, outputs, inputs } => {\n-                let outputs = outputs.into_iter().map(|output| {\n-                    unpack!(block = this.as_lvalue(block, output))\n-                }).collect();\n-\n-                let inputs = inputs.into_iter().map(|input| {\n-                    unpack!(block = this.as_operand(block, input))\n-                }).collect();\n-\n-                block.and(Rvalue::InlineAsm {\n-                    asm: asm.clone(),\n-                    outputs: outputs,\n-                    inputs: inputs\n-                })\n-            }\n             ExprKind::Repeat { value, count } => {\n                 let value_operand = unpack!(block = this.as_operand(block, value));\n                 block.and(Rvalue::Repeat(value_operand, count))\n@@ -238,6 +223,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Break { .. } |\n             ExprKind::Continue { .. } |\n             ExprKind::Return { .. } |\n+            ExprKind::InlineAsm { .. } |\n             ExprKind::StaticRef { .. } => {\n                 // these do not have corresponding `Rvalue` variants,\n                 // so make an operand and then return that"}, {"sha": "e66f2b4e2bfc0a018df4f4e1927beac6ca80f58f", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -232,6 +232,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::AssignOp { .. } |\n             ExprKind::Continue { .. } |\n             ExprKind::Break { .. } |\n+            ExprKind::InlineAsm { .. } |\n             ExprKind::Return {.. } => {\n                 this.stmt_expr(block, expr)\n             }\n@@ -257,7 +258,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Index { .. } |\n             ExprKind::Deref { .. } |\n             ExprKind::Literal { .. } |\n-            ExprKind::InlineAsm { .. } |\n             ExprKind::Field { .. } => {\n                 debug_assert!(match Category::of(&expr.kind).unwrap() {\n                     Category::Rvalue(RvalueFunc::Into) => false,"}, {"sha": "c577aab40dbeb4a9729e23600f8db7e955325ceb", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -117,6 +117,23 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 this.exit_scope(expr_span, extent, block, return_block);\n                 this.cfg.start_new_block().unit()\n             }\n+            ExprKind::InlineAsm { asm, outputs, inputs } => {\n+                let outputs = outputs.into_iter().map(|output| {\n+                    unpack!(block = this.as_lvalue(block, output))\n+                }).collect();\n+                let inputs = inputs.into_iter().map(|input| {\n+                    unpack!(block = this.as_operand(block, input))\n+                }).collect();\n+                this.cfg.push(block, Statement {\n+                    source_info: source_info,\n+                    kind: StatementKind::InlineAsm {\n+                        asm: asm.clone(),\n+                        outputs: outputs,\n+                        inputs: inputs\n+                    },\n+                });\n+                block.unit()\n+            }\n             _ => {\n                 let expr_ty = expr.ty;\n                 let temp = this.temp(expr.ty.clone());"}, {"sha": "4459142cfb2746dcc0ead02355fe2079bf99b9c7", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -774,10 +774,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     }\n                 }\n             }\n-\n-            Rvalue::InlineAsm {..} => {\n-                self.not_const();\n-            }\n         }\n     }\n \n@@ -933,6 +929,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 StatementKind::SetDiscriminant { .. } |\n                 StatementKind::StorageLive(_) |\n                 StatementKind::StorageDead(_) |\n+                StatementKind::InlineAsm {..} |\n                 StatementKind::Nop => {}\n             }\n         });"}, {"sha": "8d108815e0f3c8e44439b29efc80794b95bc2d58", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -361,9 +361,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         span_mirbug!(self, stmt, \"bad assignment ({:?} = {:?}): {:?}\",\n                                      lv_ty, rv_ty, terr);\n                     }\n-                // FIXME: rvalue with undeterminable type - e.g. inline\n-                // asm.\n                 }\n+                // FIXME: rvalue with undeterminable type - e.g. AggregateKind::Array branch that\n+                // returns `None`.\n             }\n             StatementKind::SetDiscriminant{ ref lvalue, variant_index } => {\n                 let lvalue_type = lvalue.ty(mir, tcx).to_ty(tcx);\n@@ -392,6 +392,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n+            StatementKind::InlineAsm { .. } |\n             StatementKind::Nop => {}\n         }\n     }"}, {"sha": "33b7089c38214543759808153fc3f52520bef57e", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -128,6 +128,7 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n             StatementKind::SetDiscriminant { .. } => \"StatementKind::SetDiscriminant\",\n             StatementKind::StorageLive(..) => \"StatementKind::StorageLive\",\n             StatementKind::StorageDead(..) => \"StatementKind::StorageDead\",\n+            StatementKind::InlineAsm { .. } => \"StatementKind::InlineAsm\",\n             StatementKind::Nop => \"StatementKind::Nop\",\n         }, &statement.kind);\n         self.super_statement(block, statement, location);\n@@ -198,7 +199,6 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n \n                 \"Rvalue::Aggregate\"\n             }\n-            Rvalue::InlineAsm { .. } => \"Rvalue::InlineAsm\",\n         };\n         self.record(rvalue_kind, rvalue);\n         self.super_rvalue(rvalue, location);"}, {"sha": "c9e870188aaeccb36199b4d13a3d4178ff4961da", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 37, "deletions": 42, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -1195,7 +1195,8 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n         let path: Vec<_> = segments.iter().map(|seg| Ident::with_empty_ctxt(seg.name)).collect();\n         match self.resolve_path(&path, Some(namespace), Some(span)) {\n             PathResult::Module(module) => *def = module.def().unwrap(),\n-            PathResult::NonModule(path_res) if path_res.depth == 0 => *def = path_res.base_def,\n+            PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 =>\n+                *def = path_res.base_def(),\n             PathResult::NonModule(..) => match self.resolve_path(&path, None, Some(span)) {\n                 PathResult::Failed(msg, _) => {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n@@ -1718,7 +1719,7 @@ impl<'a> Resolver<'a> {\n         let mut new_id = None;\n         if let Some(trait_ref) = opt_trait_ref {\n             let def = self.smart_resolve_path(trait_ref.ref_id, None,\n-                                              &trait_ref.path, PathSource::Trait).base_def;\n+                                              &trait_ref.path, PathSource::Trait).base_def();\n             if def != Def::Err {\n                 new_val = Some((def.def_id(), trait_ref.clone()));\n                 new_id = Some(def.def_id());\n@@ -1849,8 +1850,8 @@ impl<'a> Resolver<'a> {\n \n         pat.walk(&mut |pat| {\n             if let PatKind::Ident(binding_mode, ident, ref sub_pat) = pat.node {\n-                if sub_pat.is_some() || match self.def_map.get(&pat.id) {\n-                    Some(&PathResolution { base_def: Def::Local(..), .. }) => true,\n+                if sub_pat.is_some() || match self.def_map.get(&pat.id).map(|res| res.base_def()) {\n+                    Some(Def::Local(..)) => true,\n                     _ => false,\n                 } {\n                     let binding_info = BindingInfo { span: ident.span, binding_mode: binding_mode };\n@@ -2248,14 +2249,14 @@ impl<'a> Resolver<'a> {\n         let resolution = match self.resolve_qpath_anywhere(id, qself, path, ns, span,\n                                                            source.defer_to_typeck(),\n                                                            source.global_by_default()) {\n-            Some(resolution) if resolution.depth == 0 => {\n-                if is_expected(resolution.base_def) || resolution.base_def == Def::Err {\n+            Some(resolution) if resolution.unresolved_segments() == 0 => {\n+                if is_expected(resolution.base_def()) || resolution.base_def() == Def::Err {\n                     resolution\n                 } else {\n                     // Add a temporary hack to smooth the transition to new struct ctor\n                     // visibility rules. See #38932 for more details.\n                     let mut res = None;\n-                    if let Def::Struct(def_id) = resolution.base_def {\n+                    if let Def::Struct(def_id) = resolution.base_def() {\n                         if let Some((ctor_def, ctor_vis))\n                                 = self.struct_constructors.get(&def_id).cloned() {\n                             if is_expected(ctor_def) && self.is_accessible(ctor_vis) {\n@@ -2268,7 +2269,7 @@ impl<'a> Resolver<'a> {\n                         }\n                     }\n \n-                    res.unwrap_or_else(|| report_errors(self, Some(resolution.base_def)))\n+                    res.unwrap_or_else(|| report_errors(self, Some(resolution.base_def())))\n                 }\n             }\n             Some(resolution) if source.defer_to_typeck() => {\n@@ -2321,7 +2322,8 @@ impl<'a> Resolver<'a> {\n                 match self.resolve_qpath(id, qself, path, ns, span, global_by_default) {\n                     // If defer_to_typeck, then resolution > no resolution,\n                     // otherwise full resolution > partial resolution > no resolution.\n-                    Some(res) if res.depth == 0 || defer_to_typeck => return Some(res),\n+                    Some(res) if res.unresolved_segments() == 0 || defer_to_typeck =>\n+                        return Some(res),\n                     res => if fin_res.is_none() { fin_res = res },\n                 };\n             }\n@@ -2346,19 +2348,17 @@ impl<'a> Resolver<'a> {\n         if let Some(qself) = qself {\n             if qself.position == 0 {\n                 // FIXME: Create some fake resolution that can't possibly be a type.\n-                return Some(PathResolution {\n-                    base_def: Def::Mod(DefId::local(CRATE_DEF_INDEX)),\n-                    depth: path.len(),\n-                });\n+                return Some(PathResolution::with_unresolved_segments(\n+                    Def::Mod(DefId::local(CRATE_DEF_INDEX)), path.len()\n+                ));\n             }\n             // Make sure `A::B` in `<T as A>::B::C` is a trait item.\n             let ns = if qself.position + 1 == path.len() { ns } else { TypeNS };\n-            let mut res = self.smart_resolve_path_fragment(id, None, &path[..qself.position + 1],\n-                                                           span, PathSource::TraitItem(ns));\n-            if res.base_def != Def::Err {\n-                res.depth += path.len() - qself.position - 1;\n-            }\n-            return Some(res);\n+            let res = self.smart_resolve_path_fragment(id, None, &path[..qself.position + 1],\n+                                                       span, PathSource::TraitItem(ns));\n+            return Some(PathResolution::with_unresolved_segments(\n+                res.base_def(), res.unresolved_segments() + path.len() - qself.position - 1\n+            ));\n         }\n \n         let result = match self.resolve_path(&path, Some(ns), Some(span)) {\n@@ -2393,10 +2393,7 @@ impl<'a> Resolver<'a> {\n                     }\n                     _ => {}\n                 }\n-                PathResolution {\n-                    base_def: Def::PrimTy(prim),\n-                    depth: path.len() - 1,\n-                }\n+                PathResolution::with_unresolved_segments(Def::PrimTy(prim), path.len() - 1)\n             }\n             PathResult::Module(module) => PathResolution::new(module.def().unwrap()),\n             PathResult::Failed(msg, false) => {\n@@ -2407,16 +2404,16 @@ impl<'a> Resolver<'a> {\n             PathResult::Indeterminate => bug!(\"indetermined path result in resolve_qpath\"),\n         };\n \n-        if path.len() > 1 && !global_by_default && result.base_def != Def::Err &&\n+        if path.len() > 1 && !global_by_default && result.base_def() != Def::Err &&\n            path[0].name != keywords::CrateRoot.name() && path[0].name != \"$crate\" {\n             let unqualified_result = {\n                 match self.resolve_path(&[*path.last().unwrap()], Some(ns), None) {\n-                    PathResult::NonModule(path_res) => path_res.base_def,\n+                    PathResult::NonModule(path_res) => path_res.base_def(),\n                     PathResult::Module(module) => module.def().unwrap(),\n                     _ => return Some(result),\n                 }\n             };\n-            if result.base_def == unqualified_result {\n+            if result.base_def() == unqualified_result {\n                 let lint = lint::builtin::UNUSED_QUALIFICATIONS;\n                 self.session.add_lint(lint, id, span, \"unnecessary qualification\".to_string());\n             }\n@@ -2470,10 +2467,9 @@ impl<'a> Resolver<'a> {\n                     Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n                     Some(LexicalScopeBinding::Def(def))\n                             if opt_ns == Some(TypeNS) || opt_ns == Some(ValueNS) => {\n-                        return PathResult::NonModule(PathResolution {\n-                            base_def: def,\n-                            depth: path.len() - 1,\n-                        });\n+                        return PathResult::NonModule(PathResolution::with_unresolved_segments(\n+                            def, path.len() - 1\n+                        ));\n                     }\n                     _ => Err(if record_used.is_some() { Determined } else { Undetermined }),\n                 }\n@@ -2488,10 +2484,9 @@ impl<'a> Resolver<'a> {\n                     } else if def == Def::Err {\n                         return PathResult::NonModule(err_path_resolution());\n                     } else if opt_ns.is_some() && (is_last || maybe_assoc) {\n-                        return PathResult::NonModule(PathResolution {\n-                            base_def: def,\n-                            depth: path.len() - i - 1,\n-                        });\n+                        return PathResult::NonModule(PathResolution::with_unresolved_segments(\n+                            def, path.len() - i - 1\n+                        ));\n                     } else {\n                         return PathResult::Failed(format!(\"Not a module `{}`\", ident), is_last);\n                     }\n@@ -2500,10 +2495,9 @@ impl<'a> Resolver<'a> {\n                 Err(Determined) => {\n                     if let Some(module) = module {\n                         if opt_ns.is_some() && !module.is_normal() {\n-                            return PathResult::NonModule(PathResolution {\n-                                base_def: module.def().unwrap(),\n-                                depth: path.len() - i,\n-                            });\n+                            return PathResult::NonModule(PathResolution::with_unresolved_segments(\n+                                module.def().unwrap(), path.len() - i\n+                            ));\n                         }\n                     }\n                     let msg = if module.and_then(ModuleData::def) == self.graph_root.def() {\n@@ -2672,8 +2666,9 @@ impl<'a> Resolver<'a> {\n             if let Some(node_id) = self.current_self_type.as_ref().and_then(extract_node_id) {\n                 // Look for a field with the same name in the current self_type.\n                 if let Some(resolution) = self.def_map.get(&node_id) {\n-                    match resolution.base_def {\n-                        Def::Struct(did) | Def::Union(did) if resolution.depth == 0 => {\n+                    match resolution.base_def() {\n+                        Def::Struct(did) | Def::Union(did)\n+                                if resolution.unresolved_segments() == 0 => {\n                             if let Some(field_names) = self.field_names.get(&did) {\n                                 if field_names.iter().any(|&field_name| name == field_name) {\n                                     return Some(AssocSuggestion::Field);\n@@ -3057,7 +3052,6 @@ impl<'a> Resolver<'a> {\n \n     fn record_def(&mut self, node_id: NodeId, resolution: PathResolution) {\n         debug!(\"(recording def) recording {:?} for {}\", resolution, node_id);\n-        assert!(resolution.depth == 0 || resolution.base_def != Def::Err);\n         if let Some(prev_res) = self.def_map.insert(node_id, resolution) {\n             panic!(\"path resolved multiple times ({:?} before, {:?} now)\", prev_res, resolution);\n         }\n@@ -3071,7 +3065,8 @@ impl<'a> Resolver<'a> {\n                 ty::Visibility::Restricted(self.current_module.normal_ancestor_id)\n             }\n             ast::Visibility::Restricted { ref path, id } => {\n-                let def = self.smart_resolve_path(id, None, path, PathSource::Visibility).base_def;\n+                let def = self.smart_resolve_path(id, None, path,\n+                                                  PathSource::Visibility).base_def();\n                 if def == Def::Err {\n                     ty::Visibility::Public\n                 } else {"}, {"sha": "8d563d20549c3b8e78108d75231941ce3b54e358", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -262,7 +262,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n             }\n \n             let ext = match self.resolve_path(&path, Some(MacroNS), None) {\n-                PathResult::NonModule(path_res) => match path_res.base_def {\n+                PathResult::NonModule(path_res) => match path_res.base_def() {\n                     Def::Err => Err(Determinacy::Determined),\n                     def @ _ => Ok(self.get_macro(def)),\n                 },"}, {"sha": "b5f948442b774d486aa95075981eab3ec1b827e1", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -1090,13 +1090,16 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a,\n                                                    trait_ty: ty::Ty<'tcx>,\n                                                    impl_ty: ty::Ty<'tcx>,\n                                                    output: &mut Vec<TransItem<'tcx>>) {\n-    assert!(!trait_ty.needs_subst() && !impl_ty.needs_subst());\n+    assert!(!trait_ty.needs_subst() && !trait_ty.has_escaping_regions() &&\n+            !impl_ty.needs_subst() && !impl_ty.has_escaping_regions());\n \n     if let ty::TyDynamic(ref trait_ty, ..) = trait_ty.sty {\n         if let Some(principal) = trait_ty.principal() {\n             let poly_trait_ref = principal.with_self_ty(scx.tcx(), impl_ty);\n             let param_substs = scx.tcx().intern_substs(&[]);\n \n+            assert!(!poly_trait_ref.has_escaping_regions());\n+\n             // Walk all methods of the trait, including those of its supertraits\n             let methods = traits::get_vtable_methods(scx.tcx(), poly_trait_ref);\n             let methods = methods.filter_map(|method| method)"}, {"sha": "799f502aadbfa97cd4f844eb6e596a22119e4d40", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -208,7 +208,8 @@ impl<'gcx> DepTrackingMapConfig for ProjectionCache<'gcx> {\n                    _ => None,\n                })\n                .collect();\n-        DepNode::TraitSelect(def_ids)\n+\n+        DepNode::ProjectionCache { def_ids: def_ids }\n     }\n }\n "}, {"sha": "7e17ae5f1d389ceeb15bd713976391c2b87b9c21", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -287,8 +287,9 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     mir::StatementKind::StorageLive(_) |\n                     mir::StatementKind::StorageDead(_) |\n                     mir::StatementKind::Nop => {}\n+                    mir::StatementKind::InlineAsm { .. } |\n                     mir::StatementKind::SetDiscriminant{ .. } => {\n-                        span_bug!(span, \"SetDiscriminant should not appear in constants?\");\n+                        span_bug!(span, \"{:?} should not appear in constants?\", statement.kind);\n                     }\n                 }\n             }"}, {"sha": "7d4f542addbb1aa4494b5e3342deead7c262e6fe", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -16,7 +16,6 @@ use rustc::mir::tcx::LvalueTy;\n use rustc::mir;\n use middle::lang_items::ExchangeMallocFnLangItem;\n \n-use asm;\n use base;\n use builder::Builder;\n use callee::Callee;\n@@ -156,20 +155,6 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 bcx\n             }\n \n-            mir::Rvalue::InlineAsm { ref asm, ref outputs, ref inputs } => {\n-                let outputs = outputs.iter().map(|output| {\n-                    let lvalue = self.trans_lvalue(&bcx, output);\n-                    (lvalue.llval, lvalue.ty.to_ty(bcx.tcx()))\n-                }).collect();\n-\n-                let input_vals = inputs.iter().map(|input| {\n-                    self.trans_operand(&bcx, input).immediate()\n-                }).collect();\n-\n-                asm::trans_inline_asm(&bcx, asm, outputs, input_vals);\n-                bcx\n-            }\n-\n             _ => {\n                 assert!(rvalue_creates_operand(rvalue));\n                 let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n@@ -468,8 +453,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 (bcx, operand)\n             }\n             mir::Rvalue::Repeat(..) |\n-            mir::Rvalue::Aggregate(..) |\n-            mir::Rvalue::InlineAsm { .. } => {\n+            mir::Rvalue::Aggregate(..) => {\n                 bug!(\"cannot generate operand from rvalue {:?}\", rvalue);\n \n             }\n@@ -669,8 +653,7 @@ pub fn rvalue_creates_operand(rvalue: &mir::Rvalue) -> bool {\n         mir::Rvalue::Use(..) =>\n             true,\n         mir::Rvalue::Repeat(..) |\n-        mir::Rvalue::Aggregate(..) |\n-        mir::Rvalue::InlineAsm { .. } =>\n+        mir::Rvalue::Aggregate(..) =>\n             false,\n     }\n "}, {"sha": "29a0648c8f8f8d48a6c95b1d4aa9570bd123ea24", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -11,6 +11,7 @@\n use rustc::mir;\n \n use base;\n+use asm;\n use common;\n use builder::Builder;\n \n@@ -73,6 +74,19 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::StatementKind::StorageDead(ref lvalue) => {\n                 self.trans_storage_liveness(bcx, lvalue, base::Lifetime::End)\n             }\n+            mir::StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {\n+                let outputs = outputs.iter().map(|output| {\n+                    let lvalue = self.trans_lvalue(&bcx, output);\n+                    (lvalue.llval, lvalue.ty.to_ty(bcx.tcx()))\n+                }).collect();\n+\n+                let input_vals = inputs.iter().map(|input| {\n+                    self.trans_operand(&bcx, input).immediate()\n+                }).collect();\n+\n+                asm::trans_inline_asm(&bcx, asm, outputs, input_vals);\n+                bcx\n+            }\n             mir::StatementKind::Nop => bcx,\n         }\n     }"}, {"sha": "ab1897101eb6ffe683c7b1d69f4be3a956d8b147", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -918,7 +918,19 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             (_, Def::SelfTy(Some(_), Some(impl_def_id))) => {\n                 // `Self` in an impl of a trait - we have a concrete self type and a\n                 // trait reference.\n-                let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+                // FIXME: Self type is not always computed when we are here because type parameter\n+                // bounds may affect Self type and have to be converted before it.\n+                let trait_ref = if impl_def_id.is_local() {\n+                    tcx.impl_trait_refs.borrow().get(&impl_def_id).cloned().and_then(|x| x)\n+                } else {\n+                    tcx.impl_trait_ref(impl_def_id)\n+                };\n+                let trait_ref = if let Some(trait_ref) = trait_ref {\n+                    trait_ref\n+                } else {\n+                    tcx.sess.span_err(span, \"`Self` type is used before it's determined\");\n+                    return (tcx.types.err, Def::Err);\n+                };\n                 let trait_ref = if let Some(free_substs) = self.get_free_substs() {\n                     trait_ref.subst(tcx, free_substs)\n                 } else {"}, {"sha": "2d90394025d21ad909d2116e3d1a28dd923bea89", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -309,17 +309,17 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // parameters from the type and those from the method.\n         //\n         // FIXME -- permit users to manually specify lifetimes\n-        let supplied_start = substs.params().len() + method_generics.regions.len();\n+        let supplied_start = substs.len() + method_generics.regions.len();\n         Substs::for_item(self.tcx, pick.item.def_id, |def, _| {\n             let i = def.index as usize;\n-            if i < substs.params().len() {\n+            if i < substs.len() {\n                 substs.region_at(i)\n             } else {\n                 self.region_var_for_def(self.span, def)\n             }\n         }, |def, cur_substs| {\n             let i = def.index as usize;\n-            if i < substs.params().len() {\n+            if i < substs.len() {\n                 substs.type_at(i)\n             } else if supplied_method_types.is_empty() {\n                 self.type_var_for_def(self.span, def, cur_substs)"}, {"sha": "fd29ff0be43b44910d5f7860cd1727bd169ec289", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -1326,7 +1326,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         } else {\n             let substs = Substs::for_item(self.tcx, method, |def, _| {\n                 let i = def.index as usize;\n-                if i < substs.params().len() {\n+                if i < substs.len() {\n                     substs.region_at(i)\n                 } else {\n                     // In general, during probe we erase regions. See\n@@ -1335,7 +1335,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 }\n             }, |def, cur_substs| {\n                 let i = def.index as usize;\n-                if i < substs.params().len() {\n+                if i < substs.len() {\n                     substs.type_at(i)\n                 } else {\n                     self.type_var_for_def(self.span, def, cur_substs)"}, {"sha": "a2922270583796ba54520c48a6710315167328dc", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -100,7 +100,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n         let gcx = fcx.tcx.global_tcx();\n         let free_substs = fcx.parameter_environment.free_substs;\n-        for (i, k) in free_substs.params().iter().enumerate() {\n+        for (i, k) in free_substs.iter().enumerate() {\n             let r = if let Some(r) = k.as_region() {\n                 r\n             } else {"}, {"sha": "dd4f1ff4f5ed7318c33850b9f341848fed948837", "filename": "src/libstd/env.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -96,7 +96,9 @@ pub struct VarsOs { inner: os_imp::Env }\n ///\n /// While iterating, the returned iterator will panic if any key or value in the\n /// environment is not valid unicode. If this is not desired, consider using the\n-/// `env::vars_os` function.\n+/// [`env::vars_os`] function.\n+///\n+/// [`env::vars_os`]: fn.vars_os.html\n ///\n /// # Examples\n ///\n@@ -171,9 +173,12 @@ impl fmt::Debug for VarsOs {\n \n /// Fetches the environment variable `key` from the current process.\n ///\n-/// The returned result is `Ok(s)` if the environment variable is present and is\n+/// The returned result is [`Ok(s)`] if the environment variable is present and is\n /// valid unicode. If the environment variable is not present, or it is not\n-/// valid unicode, then `Err` will be returned.\n+/// valid unicode, then [`Err`] will be returned.\n+///\n+/// [`Ok(s)`]: ../result/enum.Result.html#variant.Ok\n+/// [`Err`]: ../result/enum.Result.html#variant.Err\n ///\n /// # Examples\n ///\n@@ -199,7 +204,9 @@ fn _var(key: &OsStr) -> Result<String, VarError> {\n }\n \n /// Fetches the environment variable `key` from the current process, returning\n-/// `None` if the variable isn't set.\n+/// [`None`] if the variable isn't set.\n+///\n+/// [`None`]: ../option/enum.Option.html#variant.None\n ///\n /// # Examples\n ///"}, {"sha": "1e7394c0b09e7e88f9b52fb9e2f0f57efe702b9c", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -316,7 +316,7 @@ impl Once {\n                         }\n \n                         // Once we've enqueued ourselves, wait in a loop.\n-                        // Aftewards reload the state and continue with what we\n+                        // Afterwards reload the state and continue with what we\n                         // were doing from before.\n                         while !node.signaled.load(Ordering::SeqCst) {\n                             thread::park();"}, {"sha": "e78928c266792adb7006cab1b1857ac318aab0e8", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 9, "deletions": 29, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -483,41 +483,21 @@ pub fn home_dir() -> Option<PathBuf> {\n                   target_os = \"nacl\",\n                   target_os = \"emscripten\")))]\n     unsafe fn fallback() -> Option<OsString> {\n-        #[cfg(not(target_os = \"solaris\"))]\n-        unsafe fn getpwduid_r(me: libc::uid_t, passwd: &mut libc::passwd,\n-                              buf: &mut Vec<c_char>) -> Option<()> {\n-            let mut result = ptr::null_mut();\n-            match libc::getpwuid_r(me, passwd, buf.as_mut_ptr(),\n-                                   buf.capacity(),\n-                                   &mut result) {\n-                0 if !result.is_null() => Some(()),\n-                _ => None\n-            }\n-        }\n-\n-        #[cfg(target_os = \"solaris\")]\n-        unsafe fn getpwduid_r(me: libc::uid_t, passwd: &mut libc::passwd,\n-                              buf: &mut Vec<c_char>) -> Option<()> {\n-            // getpwuid_r semantics is different on Illumos/Solaris:\n-            // http://illumos.org/man/3c/getpwuid_r\n-            let result = libc::getpwuid_r(me, passwd, buf.as_mut_ptr(),\n-                                          buf.capacity());\n-            if result.is_null() { None } else { Some(()) }\n-        }\n-\n         let amt = match libc::sysconf(libc::_SC_GETPW_R_SIZE_MAX) {\n             n if n < 0 => 512 as usize,\n             n => n as usize,\n         };\n         let mut buf = Vec::with_capacity(amt);\n         let mut passwd: libc::passwd = mem::zeroed();\n-\n-        if getpwduid_r(libc::getuid(), &mut passwd, &mut buf).is_some() {\n-            let ptr = passwd.pw_dir as *const _;\n-            let bytes = CStr::from_ptr(ptr).to_bytes().to_vec();\n-            Some(OsStringExt::from_vec(bytes))\n-        } else {\n-            None\n+        let mut result = ptr::null_mut();\n+        match libc::getpwuid_r(libc::getuid(), &mut passwd, buf.as_mut_ptr(),\n+                               buf.capacity(), &mut result) {\n+            0 if !result.is_null() => {\n+                let ptr = passwd.pw_dir as *const _;\n+                let bytes = CStr::from_ptr(ptr).to_bytes().to_vec();\n+                Some(OsStringExt::from_vec(bytes))\n+            },\n+            _ => None,\n         }\n     }\n }"}, {"sha": "66f09a7069c130969b65a3c170c6b9f2ce64b08f", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -28,8 +28,8 @@ use mem;\n /// # Initialization and Destruction\n ///\n /// Initialization is dynamically performed on the first call to `with()`\n-/// within a thread, and values support destructors which will be run when a\n-/// thread exits.\n+/// within a thread, and values that implement `Drop` get destructed when a\n+/// thread exits. Some caveats apply, which are explained below.\n ///\n /// # Examples\n ///"}, {"sha": "ab36e9a2c2b20f0ee888b56b9e929d9637ca126a", "filename": "src/rustllvm/llvm-auto-clean-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Frustllvm%2Fllvm-auto-clean-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Frustllvm%2Fllvm-auto-clean-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-auto-clean-trigger?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be forcibly cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2016-12-19\n+2017-02-15"}, {"sha": "a56a5e8548944d01f8f7850cf4d9ccd00f53e079", "filename": "src/test/compile-fail/issue-39559.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Dim {\n+    fn dim() -> usize;\n+}\n+\n+enum Dim3 {}\n+\n+impl Dim for Dim3 {\n+    fn dim() -> usize {\n+        3\n+    }\n+}\n+\n+pub struct Vector<T, D: Dim> {\n+    entries: [T; D::dim()]\n+    //~^ ERROR cannot use an outer type parameter in this context\n+    //~| ERROR constant evaluation error\n+}\n+\n+fn main() {\n+    let array: [usize; Dim3::dim()] = [0; Dim3::dim()];\n+}"}, {"sha": "04f98c7ab329faa751bddadfe4598d3ac6974b39", "filename": "src/test/compile-fail/resolve-self-in-impl.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Ftest%2Fcompile-fail%2Fresolve-self-in-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Ftest%2Fcompile-fail%2Fresolve-self-in-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-self-in-impl.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -18,9 +18,12 @@ impl<T: Tr<Self>> Tr<T> for S {} //~ ERROR `Self` type is used before it's deter\n impl<T = Self> Tr<T> for S {} //~ ERROR `Self` type is used before it's determined\n impl Tr for S where Self: Copy {} //~ ERROR `Self` type is used before it's determined\n impl Tr for S where S<Self>: Copy {} //~ ERROR `Self` type is used before it's determined\n+impl Tr for S where Self::Assoc: Copy {} //~ ERROR `Self` type is used before it's determined\n+                                         //~^ ERROR `Self` type is used before it's determined\n impl Tr for Self {} //~ ERROR `Self` type is used before it's determined\n impl Tr for S<Self> {} //~ ERROR `Self` type is used before it's determined\n impl Self {} //~ ERROR `Self` type is used before it's determined\n impl S<Self> {} //~ ERROR `Self` type is used before it's determined\n+impl Tr<Self::Assoc> for S {} //~ ERROR `Self` type is used before it's determined\n \n fn main() {}"}, {"sha": "dc2b21f3470e8c22e42dbffe22b4a89ded89a724", "filename": "src/test/run-pass/issue-39292.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9a6a72b81837bed367de38297479ad554537d70c/src%2Ftest%2Frun-pass%2Fissue-39292.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6a72b81837bed367de38297479ad554537d70c/src%2Ftest%2Frun-pass%2Fissue-39292.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-39292.rs?ref=9a6a72b81837bed367de38297479ad554537d70c", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for issue #39292. The object vtable was being\n+// incorrectly left with a null pointer.\n+\n+trait Foo<T> {\n+    fn print<'a>(&'a self) where T: 'a { println!(\"foo\"); }\n+}\n+\n+impl<'a> Foo<&'a ()> for () { }\n+\n+trait Bar: for<'a> Foo<&'a ()> { }\n+\n+impl Bar for () {}\n+\n+fn main() {\n+    (&() as &Bar).print(); // Segfault\n+}"}]}