{"sha": "fe531d5a5f1404281e3fb237daaf87b8180bd13d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlNTMxZDVhNWYxNDA0MjgxZTNmYjIzN2RhYWY4N2I4MTgwYmQxM2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-11T21:32:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-11T21:32:50Z"}, "message": "Auto merge of #79012 - tgnottingham:span_data_to_lines_and_cols, r=estebank\n\nrustc_span: add span_data_to_lines_and_cols to caching source map view", "tree": {"sha": "4262687b80126dd9f2012656db4e205df95acbb8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4262687b80126dd9f2012656db4e205df95acbb8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe531d5a5f1404281e3fb237daaf87b8180bd13d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe531d5a5f1404281e3fb237daaf87b8180bd13d", "html_url": "https://github.com/rust-lang/rust/commit/fe531d5a5f1404281e3fb237daaf87b8180bd13d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe531d5a5f1404281e3fb237daaf87b8180bd13d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5eae562935922f712edec56a45591bc2f8ded1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5eae562935922f712edec56a45591bc2f8ded1c", "html_url": "https://github.com/rust-lang/rust/commit/c5eae562935922f712edec56a45591bc2f8ded1c"}, {"sha": "75de8286c04af256762804ee96b08a68d2aba279", "url": "https://api.github.com/repos/rust-lang/rust/commits/75de8286c04af256762804ee96b08a68d2aba279", "html_url": "https://github.com/rust-lang/rust/commit/75de8286c04af256762804ee96b08a68d2aba279"}], "stats": {"total": 278, "additions": 222, "deletions": 56}, "files": [{"sha": "addcb7a14e3a6cc5b6c7a6f218c46f966f9a763b", "filename": "compiler/rustc_middle/src/ich/hcx.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe531d5a5f1404281e3fb237daaf87b8180bd13d/compiler%2Frustc_middle%2Fsrc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe531d5a5f1404281e3fb237daaf87b8180bd13d/compiler%2Frustc_middle%2Fsrc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fich%2Fhcx.rs?ref=fe531d5a5f1404281e3fb237daaf87b8180bd13d", "patch": "@@ -12,7 +12,7 @@ use rustc_hir::definitions::{DefPathHash, Definitions};\n use rustc_session::Session;\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::Symbol;\n-use rustc_span::{BytePos, CachingSourceMapView, SourceFile};\n+use rustc_span::{BytePos, CachingSourceMapView, SourceFile, SpanData};\n \n use rustc_span::def_id::{CrateNum, CRATE_DEF_INDEX};\n use smallvec::SmallVec;\n@@ -248,6 +248,13 @@ impl<'a> rustc_span::HashStableContext for StableHashingContext<'a> {\n     ) -> Option<(Lrc<SourceFile>, usize, BytePos)> {\n         self.source_map().byte_pos_to_line_and_col(byte)\n     }\n+\n+    fn span_data_to_lines_and_cols(\n+        &mut self,\n+        span: &SpanData,\n+    ) -> Option<(Lrc<SourceFile>, usize, BytePos, usize, BytePos)> {\n+        self.source_map().span_data_to_lines_and_cols(span)\n+    }\n }\n \n pub fn hash_stable_trait_impls<'a>("}, {"sha": "8e21b9ff44a1b267d67a4c6f24cd07e49f1b4787", "filename": "compiler/rustc_span/src/caching_source_map_view.rs", "status": "modified", "additions": 207, "deletions": 38, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/fe531d5a5f1404281e3fb237daaf87b8180bd13d/compiler%2Frustc_span%2Fsrc%2Fcaching_source_map_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe531d5a5f1404281e3fb237daaf87b8180bd13d/compiler%2Frustc_span%2Fsrc%2Fcaching_source_map_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fcaching_source_map_view.rs?ref=fe531d5a5f1404281e3fb237daaf87b8180bd13d", "patch": "@@ -1,5 +1,5 @@\n use crate::source_map::SourceMap;\n-use crate::{BytePos, SourceFile};\n+use crate::{BytePos, SourceFile, SpanData};\n use rustc_data_structures::sync::Lrc;\n use std::ops::Range;\n \n@@ -24,6 +24,32 @@ struct CacheEntry {\n     file_index: usize,\n }\n \n+impl CacheEntry {\n+    #[inline]\n+    fn update(\n+        &mut self,\n+        new_file_and_idx: Option<(Lrc<SourceFile>, usize)>,\n+        pos: BytePos,\n+        time_stamp: usize,\n+    ) {\n+        if let Some((file, file_idx)) = new_file_and_idx {\n+            self.file = file;\n+            self.file_index = file_idx;\n+        }\n+\n+        let line_index = self.file.lookup_line(pos).unwrap();\n+        let line_bounds = self.file.line_bounds(line_index);\n+        self.line_number = line_index + 1;\n+        self.line = line_bounds;\n+        self.touch(time_stamp);\n+    }\n+\n+    #[inline]\n+    fn touch(&mut self, time_stamp: usize) {\n+        self.time_stamp = time_stamp;\n+    }\n+}\n+\n #[derive(Clone)]\n pub struct CachingSourceMapView<'sm> {\n     source_map: &'sm SourceMap,\n@@ -57,59 +83,202 @@ impl<'sm> CachingSourceMapView<'sm> {\n         self.time_stamp += 1;\n \n         // Check if the position is in one of the cached lines\n-        for cache_entry in self.line_cache.iter_mut() {\n-            if cache_entry.line.contains(&pos) {\n-                cache_entry.time_stamp = self.time_stamp;\n+        let cache_idx = self.cache_entry_index(pos);\n+        if cache_idx != -1 {\n+            let cache_entry = &mut self.line_cache[cache_idx as usize];\n+            cache_entry.touch(self.time_stamp);\n \n-                return Some((\n-                    cache_entry.file.clone(),\n-                    cache_entry.line_number,\n-                    pos - cache_entry.line.start,\n-                ));\n-            }\n+            return Some((\n+                cache_entry.file.clone(),\n+                cache_entry.line_number,\n+                pos - cache_entry.line.start,\n+            ));\n         }\n \n         // No cache hit ...\n-        let mut oldest = 0;\n-        for index in 1..self.line_cache.len() {\n-            if self.line_cache[index].time_stamp < self.line_cache[oldest].time_stamp {\n-                oldest = index;\n-            }\n-        }\n+        let oldest = self.oldest_cache_entry_index();\n+\n+        // If the entry doesn't point to the correct file, get the new file and index.\n+        let new_file_and_idx = if !file_contains(&self.line_cache[oldest].file, pos) {\n+            Some(self.file_for_position(pos)?)\n+        } else {\n+            None\n+        };\n \n         let cache_entry = &mut self.line_cache[oldest];\n+        cache_entry.update(new_file_and_idx, pos, self.time_stamp);\n \n-        // If the entry doesn't point to the correct file, fix it up\n-        if !file_contains(&cache_entry.file, pos) {\n-            let file_valid;\n-            if self.source_map.files().len() > 0 {\n-                let file_index = self.source_map.lookup_source_file_idx(pos);\n-                let file = self.source_map.files()[file_index].clone();\n-\n-                if file_contains(&file, pos) {\n-                    cache_entry.file = file;\n-                    cache_entry.file_index = file_index;\n-                    file_valid = true;\n-                } else {\n-                    file_valid = false;\n+        Some((cache_entry.file.clone(), cache_entry.line_number, pos - cache_entry.line.start))\n+    }\n+\n+    pub fn span_data_to_lines_and_cols(\n+        &mut self,\n+        span_data: &SpanData,\n+    ) -> Option<(Lrc<SourceFile>, usize, BytePos, usize, BytePos)> {\n+        self.time_stamp += 1;\n+\n+        // Check if lo and hi are in the cached lines.\n+        let lo_cache_idx = self.cache_entry_index(span_data.lo);\n+        let hi_cache_idx = self.cache_entry_index(span_data.hi);\n+\n+        if lo_cache_idx != -1 && hi_cache_idx != -1 {\n+            // Cache hit for span lo and hi. Check if they belong to the same file.\n+            let result = {\n+                let lo = &self.line_cache[lo_cache_idx as usize];\n+                let hi = &self.line_cache[hi_cache_idx as usize];\n+\n+                if lo.file_index != hi.file_index {\n+                    return None;\n                 }\n-            } else {\n-                file_valid = false;\n+\n+                (\n+                    lo.file.clone(),\n+                    lo.line_number,\n+                    span_data.lo - lo.line.start,\n+                    hi.line_number,\n+                    span_data.hi - hi.line.start,\n+                )\n+            };\n+\n+            self.line_cache[lo_cache_idx as usize].touch(self.time_stamp);\n+            self.line_cache[hi_cache_idx as usize].touch(self.time_stamp);\n+\n+            return Some(result);\n+        }\n+\n+        // No cache hit or cache hit for only one of span lo and hi.\n+        let oldest = if lo_cache_idx != -1 || hi_cache_idx != -1 {\n+            let avoid_idx = if lo_cache_idx != -1 { lo_cache_idx } else { hi_cache_idx };\n+            self.oldest_cache_entry_index_avoid(avoid_idx as usize)\n+        } else {\n+            self.oldest_cache_entry_index()\n+        };\n+\n+        // If the entry doesn't point to the correct file, get the new file and index.\n+        // Return early if the file containing beginning of span doesn't contain end of span.\n+        let new_file_and_idx = if !file_contains(&self.line_cache[oldest].file, span_data.lo) {\n+            let new_file_and_idx = self.file_for_position(span_data.lo)?;\n+            if !file_contains(&new_file_and_idx.0, span_data.hi) {\n+                return None;\n             }\n \n-            if !file_valid {\n+            Some(new_file_and_idx)\n+        } else {\n+            let file = &self.line_cache[oldest].file;\n+            if !file_contains(&file, span_data.hi) {\n                 return None;\n             }\n+\n+            None\n+        };\n+\n+        // Update the cache entries.\n+        let (lo_idx, hi_idx) = match (lo_cache_idx, hi_cache_idx) {\n+            // Oldest cache entry is for span_data.lo line.\n+            (-1, -1) => {\n+                let lo = &mut self.line_cache[oldest];\n+                lo.update(new_file_and_idx, span_data.lo, self.time_stamp);\n+\n+                if !lo.line.contains(&span_data.hi) {\n+                    let new_file_and_idx = Some((lo.file.clone(), lo.file_index));\n+                    let next_oldest = self.oldest_cache_entry_index_avoid(oldest);\n+                    let hi = &mut self.line_cache[next_oldest];\n+                    hi.update(new_file_and_idx, span_data.hi, self.time_stamp);\n+                    (oldest, next_oldest)\n+                } else {\n+                    (oldest, oldest)\n+                }\n+            }\n+            // Oldest cache entry is for span_data.lo line.\n+            (-1, _) => {\n+                let lo = &mut self.line_cache[oldest];\n+                lo.update(new_file_and_idx, span_data.lo, self.time_stamp);\n+                let hi = &mut self.line_cache[hi_cache_idx as usize];\n+                hi.touch(self.time_stamp);\n+                (oldest, hi_cache_idx as usize)\n+            }\n+            // Oldest cache entry is for span_data.hi line.\n+            (_, -1) => {\n+                let hi = &mut self.line_cache[oldest];\n+                hi.update(new_file_and_idx, span_data.hi, self.time_stamp);\n+                let lo = &mut self.line_cache[lo_cache_idx as usize];\n+                lo.touch(self.time_stamp);\n+                (lo_cache_idx as usize, oldest)\n+            }\n+            _ => {\n+                panic!();\n+            }\n+        };\n+\n+        let lo = &self.line_cache[lo_idx];\n+        let hi = &self.line_cache[hi_idx];\n+\n+        // Span lo and hi may equal line end when last line doesn't\n+        // end in newline, hence the inclusive upper bounds below.\n+        debug_assert!(span_data.lo >= lo.line.start);\n+        debug_assert!(span_data.lo <= lo.line.end);\n+        debug_assert!(span_data.hi >= hi.line.start);\n+        debug_assert!(span_data.hi <= hi.line.end);\n+        debug_assert!(lo.file.contains(span_data.lo));\n+        debug_assert!(lo.file.contains(span_data.hi));\n+        debug_assert_eq!(lo.file_index, hi.file_index);\n+\n+        Some((\n+            lo.file.clone(),\n+            lo.line_number,\n+            span_data.lo - lo.line.start,\n+            hi.line_number,\n+            span_data.hi - hi.line.start,\n+        ))\n+    }\n+\n+    fn cache_entry_index(&self, pos: BytePos) -> isize {\n+        for (idx, cache_entry) in self.line_cache.iter().enumerate() {\n+            if cache_entry.line.contains(&pos) {\n+                return idx as isize;\n+            }\n+        }\n+\n+        -1\n+    }\n+\n+    fn oldest_cache_entry_index(&self) -> usize {\n+        let mut oldest = 0;\n+\n+        for idx in 1..self.line_cache.len() {\n+            if self.line_cache[idx].time_stamp < self.line_cache[oldest].time_stamp {\n+                oldest = idx;\n+            }\n         }\n \n-        let line_index = cache_entry.file.lookup_line(pos).unwrap();\n-        let line_bounds = cache_entry.file.line_bounds(line_index);\n+        oldest\n+    }\n \n-        cache_entry.line_number = line_index + 1;\n-        cache_entry.line = line_bounds;\n-        cache_entry.time_stamp = self.time_stamp;\n+    fn oldest_cache_entry_index_avoid(&self, avoid_idx: usize) -> usize {\n+        let mut oldest = if avoid_idx != 0 { 0 } else { 1 };\n \n-        Some((cache_entry.file.clone(), cache_entry.line_number, pos - cache_entry.line.start))\n+        for idx in 0..self.line_cache.len() {\n+            if idx != avoid_idx\n+                && self.line_cache[idx].time_stamp < self.line_cache[oldest].time_stamp\n+            {\n+                oldest = idx;\n+            }\n+        }\n+\n+        oldest\n+    }\n+\n+    fn file_for_position(&self, pos: BytePos) -> Option<(Lrc<SourceFile>, usize)> {\n+        if !self.source_map.files().is_empty() {\n+            let file_idx = self.source_map.lookup_source_file_idx(pos);\n+            let file = &self.source_map.files()[file_idx];\n+\n+            if file_contains(file, pos) {\n+                return Some((file.clone(), file_idx));\n+            }\n+        }\n+\n+        None\n     }\n }\n "}, {"sha": "f0f9f940446db3582161a73c2d9f28438076b160", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fe531d5a5f1404281e3fb237daaf87b8180bd13d/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe531d5a5f1404281e3fb237daaf87b8180bd13d/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=fe531d5a5f1404281e3fb237daaf87b8180bd13d", "patch": "@@ -1871,6 +1871,10 @@ pub trait HashStableContext {\n         &mut self,\n         byte: BytePos,\n     ) -> Option<(Lrc<SourceFile>, usize, BytePos)>;\n+    fn span_data_to_lines_and_cols(\n+        &mut self,\n+        span: &SpanData,\n+    ) -> Option<(Lrc<SourceFile>, usize, BytePos, usize, BytePos)>;\n }\n \n impl<CTX> HashStable<CTX> for Span\n@@ -1904,22 +1908,8 @@ where\n         // position that belongs to it, as opposed to hashing the first\n         // position past it.\n         let span = self.data();\n-        let (file_lo, line_lo, col_lo) = match ctx.byte_pos_to_line_and_col(span.lo) {\n-            Some(pos) => pos,\n-            None => {\n-                Hash::hash(&TAG_INVALID_SPAN, hasher);\n-                span.ctxt.hash_stable(ctx, hasher);\n-                return;\n-            }\n-        };\n-\n-        if !file_lo.contains(span.hi) {\n-            Hash::hash(&TAG_INVALID_SPAN, hasher);\n-            span.ctxt.hash_stable(ctx, hasher);\n-            return;\n-        }\n-\n-        let (_, line_hi, col_hi) = match ctx.byte_pos_to_line_and_col(span.hi) {\n+        let (file, line_lo, col_lo, line_hi, col_hi) = match ctx.span_data_to_lines_and_cols(&span)\n+        {\n             Some(pos) => pos,\n             None => {\n                 Hash::hash(&TAG_INVALID_SPAN, hasher);\n@@ -1931,7 +1921,7 @@ where\n         Hash::hash(&TAG_VALID_SPAN, hasher);\n         // We truncate the stable ID hash and line and column numbers. The chances\n         // of causing a collision this way should be minimal.\n-        Hash::hash(&(file_lo.name_hash as u64), hasher);\n+        Hash::hash(&(file.name_hash as u64), hasher);\n \n         // Hash both the length and the end location (line/column) of a span. If we\n         // hash only the length, for example, then two otherwise equal spans with"}]}