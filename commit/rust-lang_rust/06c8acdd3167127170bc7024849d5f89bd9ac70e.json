{"sha": "06c8acdd3167127170bc7024849d5f89bd9ac70e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2YzhhY2RkMzE2NzEyNzE3MGJjNzAyNDg0OWQ1Zjg5YmQ5YWM3MGU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-08T20:53:35Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-14T01:30:07Z"}, "message": "fixup serialize_variant", "tree": {"sha": "9fe50c31c204b807bea11d2693f84115631e1bfe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fe50c31c204b807bea11d2693f84115631e1bfe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06c8acdd3167127170bc7024849d5f89bd9ac70e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06c8acdd3167127170bc7024849d5f89bd9ac70e", "html_url": "https://github.com/rust-lang/rust/commit/06c8acdd3167127170bc7024849d5f89bd9ac70e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06c8acdd3167127170bc7024849d5f89bd9ac70e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdd0c9387bb10e0db01c00dcd47ea3e6bc343e45", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdd0c9387bb10e0db01c00dcd47ea3e6bc343e45", "html_url": "https://github.com/rust-lang/rust/commit/bdd0c9387bb10e0db01c00dcd47ea3e6bc343e45"}], "stats": {"total": 244, "additions": 210, "deletions": 34}, "files": [{"sha": "5f1fa8cb37905f7ec957ea83cc472b58e3c47291", "filename": "src/rustc/syntax/ext/auto_serialize.rs", "status": "renamed", "additions": 210, "deletions": 34, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/06c8acdd3167127170bc7024849d5f89bd9ac70e/src%2Frustc%2Fsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c8acdd3167127170bc7024849d5f89bd9ac70e/src%2Frustc%2Fsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fext%2Fauto_serialize.rs?ref=06c8acdd3167127170bc7024849d5f89bd9ac70e", "patch": "@@ -70,6 +70,13 @@ deserializer `d`.\n \n TODO--Hygiene. Search for \"__\" strings.\n \n+Misc notes:\n+-----------\n+\n+I use move mode arguments for ast nodes that will get inserted as is\n+into the tree.  This is intended to prevent us from inserting the same\n+node twice.\n+\n */\n import base::*;\n import driver::session::session;\n@@ -85,12 +92,12 @@ enum ser_cx = {\n \n fn expand_auto_serialize(cx: ext_ctxt,\n                          span: span,\n-                         mitem: ast::meta_item,\n+                         _mitem: ast::meta_item,\n                          in_items: [@ast::item]) -> [@ast::item] {\n     vec::flat_map(in_items) {|in_item|\n         alt in_item.node {\n           ast::item_ty(ty, tps) {\n-            [in_item, ty_module(cx, in_item.ident, ty, tps)]\n+            [in_item, ty_module(cx, in_item.ident, copy ty, tps)]\n           }\n \n           ast::item_enum(variants, tps) {\n@@ -107,9 +114,7 @@ fn expand_auto_serialize(cx: ext_ctxt,\n     }\n }\n \n-impl helpers for ser_cx {\n-    fn session() -> session { self.ext_cx.session() }\n-\n+impl helpers for ext_ctxt {\n     fn next_id() -> ast::node_id { self.session().next_node_id() }\n \n     fn path(span: span, strs: [str]) -> @ast::path {\n@@ -119,14 +124,25 @@ impl helpers for ser_cx {\n           span: span}\n     }\n \n-    fn expr(span: span, node: ast::expr_) -> @ast::expr {\n-        @{id: self.next_id(), node: node, span: span}\n-    }\n-\n     fn ty_path(span: span, strs: [str]) -> @ast::ty {\n         @{node: ast::ty_path(self.path(span, strs), self.next_id()),\n           span: span}\n     }\n+}\n+\n+impl helpers for ser_cx {\n+    fn session() -> session { self.ext_cx.session() }\n+    fn next_id() -> ast::node_id { self.ext_cx.next_id() }\n+    fn path(span: span, strs: [str]) -> @ast::path {\n+        self.ext_cx.path(span, strs)\n+    }\n+    fn ty_path(span: span, strs: [str]) -> @ast::ty {\n+        self.ext_cx.ty_path(span, strs)\n+    }\n+\n+    fn expr(span: span, node: ast::expr_) -> @ast::expr {\n+        @{id: self.next_id(), node: node, span: span}\n+    }\n \n     fn var_ref(span: span, name: str) -> @ast::expr {\n         self.expr(span, ast::expr_path(self.path(span, [name])))\n@@ -163,6 +179,27 @@ impl helpers for ser_cx {\n                 ast::expr_alt(v, arms, ast::alt_exhaustive)))\n     }\n \n+    fn lit_str(span: span, s: str) -> @ast::expr {\n+        self.expr(\n+            span,\n+            ast::expr_lit(\n+                @{node: ast::lit_str(s),\n+                  span: span}))\n+    }\n+\n+    fn lit_uint(span: span, i: uint) -> @ast::expr {\n+        self.expr(\n+            span,\n+            ast::expr_lit(\n+                @{node: ast::lit_uint(i as u64, ast::ty_u),\n+                  span: span}))\n+    }\n+\n+    fn lambda(-blk: @ast::blk) -> @ast::expr {\n+        let blk_e = cx.expr(blk.span, expr_block(blk));\n+        #ast(expr){{|| $(blk_e) }}\n+    }\n+\n     fn clone(v: @ast::expr) -> @ast::expr {\n         let fld = fold::make_fold({\n             new_id: {|_id| self.next_id()}\n@@ -197,7 +234,8 @@ impl helpers for ser_cx {\n     }\n }\n \n-fn serialize_path(cx: ser_cx, path: @ast::path, -s: @ast::expr, -v: @ast::expr)\n+fn serialize_path(cx: ser_cx, path: @ast::path,\n+                  -s: @ast::expr, -v: @ast::expr)\n     -> [@ast::stmt] {\n     let ext_cx = cx.ext_cx;\n \n@@ -225,17 +263,28 @@ fn serialize_variant(cx: ser_cx,\n                      tys: [@ast::ty],\n                      span: span,\n                      -s: @ast::expr,\n-                     pfn: fn([@ast::pat]) -> ast::pat_) -> ast::arm {\n+                     pfn: fn([@ast::pat]) -> ast::pat_,\n+                     bodyfn: fn(-@ast::expr, @ast::blk) -> @ast::expr,\n+                     argfn: fn(-@ast::expr, uint, @ast::blk) -> @ast::expr)\n+    -> ast::arm {\n     let vnames = vec::init_fn(vec::len(tys)) {|i| #fmt[\"__v%u\", i]};\n     let pats = vec::init_fn(vec::len(tys)) {|i|\n         cx.binder_pat(tys[i].span, vnames[i])\n     };\n     let pat: @ast::pat = @{id: cx.next_id(), node: pfn(pats), span: span};\n     let stmts = vec::init_fn(vec::len(tys)) {|i|\n         let v = cx.var_ref(span, vnames[i]);\n-        serialize_ty(cx, tys[i], cx.clone(s), v)\n+        let arg_blk =\n+            cx.blk(\n+                span,\n+                serialize_ty(cx, tys[i], cx.clone(s), v));\n+        cx.stmt(argfn(cx.clone(s), i, arg_blk))\n     };\n-    {pats: [pat], guard: none, body: cx.blk(span, vec::concat(stmts))}\n+\n+    let body_blk = cx.blk(span, vec::concat(stmts));\n+    let body = cx.blk(span, [cx.stmt(bodyfn(s, body_blk))]);\n+\n+    {pats: [pat], guard: none, body: body}\n }\n \n fn serialize_ty(cx: ser_cx, ty: @ast::ty, -s: @ast::expr, -v: @ast::expr)\n@@ -278,8 +327,30 @@ fn serialize_ty(cx: ser_cx, ty: @ast::ty, -s: @ast::expr, -v: @ast::expr)\n         // };\n \n         let arms = [\n-            serialize_variant(cx, tys, ty.span, s,\n-                              {|pats| ast::pat_tup(pats)})\n+            serialize_variant(\n+\n+                cx, tys, ty.span, s,\n+\n+                // Generate pattern (v1, v2, v3)\n+                {|pats| ast::pat_tup(pats)},\n+\n+                // Generate body s.emit_tup(3, {|| blk })\n+                {|-s, -blk|\n+                    let sz = cx.lit_uint(ty.span, vec::len(tys));\n+                    let body = cx.lambda(blk);\n+                    #ast[expr]{\n+                        $(s).emit_tup($(sz), $(body))\n+                    }\n+                },\n+\n+                // Generate s.emit_tup_elt(i, {|| blk })\n+                {|-s, i, -blk|\n+                    let idx = cx.lit_uint(ty.span, i);\n+                    let body = cx.lambda(blk);\n+                    #ast[expr]{\n+                        $(s).emit_tup_elt($(idx), $(body))\n+                    }\n+                })\n         ];\n         [cx.alt_stmt(arms, ty.span, v)]\n       }\n@@ -318,7 +389,7 @@ fn serialize_ty(cx: ser_cx, ty: @ast::ty, -s: @ast::expr, -v: @ast::expr)\n         let ser_e =\n             cx.expr(\n                 ty.span,\n-                expr_block(\n+                ast::expr_block(\n                     cx.blk(\n                         ty.span,\n                         serialize_ty(\n@@ -327,46 +398,71 @@ fn serialize_ty(cx: ser_cx, ty: @ast::ty, -s: @ast::expr, -v: @ast::expr)\n                             cx.at(\n                                 ty.span,\n                                 #ast(expr){__e})))));\n-        [#ast(stmt){ $(s).emit_from_vec($(v), {|__e| $(ser_e) }) }]\n+\n+        [cx.stmt(\n+            cx.expr(\n+                ty.span,\n+                ast::expr_call(\n+                    #ast(expr){$(s).emit_from_vec},\n+                    [#ast(expr){{|__e| $(ser_e)}}],\n+                    false)))]\n       }\n     }\n }\n \n-fn ty_module(ext_cx: ext_ctxt, name: str, -ty: @ast::ty, tps: [ast::ty_param])\n+fn mk_ser_fn(ext_cx: ext_ctxt, span: span,\n+             -v_ty: @ast::ty, tps: [ast::ty_param],\n+             f: fn(ser_cx, @ast::ty, -@ast::expr, -@ast::expr) -> [@ast::stmt])\n     -> @ast::item {\n \n     let cx = ser_cx({ext_cx: ext_cx, tps: map::new_str_hash()});\n \n+    let tp_inputs =\n+        vec::map(tps, {|tp|\n+            {mode: ast::expl(ast::by_ref),\n+             ty: cx.ty_path(span, [tp.ident]),\n+             ident: \"__s\" + tp.ident,\n+             id: cx.next_id()}});\n+\n     let ser_inputs: [ast::arg] =\n         [{mode: ast::expl(ast::by_ref),\n-          ty: cx.ty_path(ty.span, [\"__S\"]),\n+          ty: cx.ty_path(span, [\"__S\"]),\n           ident: \"__s\",\n           id: cx.next_id()},\n          {mode: ast::expl(ast::by_ref),\n-          ty: ty,\n+          ty: v_ty,\n           ident: \"__v\",\n-          id: cx.next_id()}] +\n-        vec::map(tps, {|tp|\n-            {mode: ast::expl(ast::by_ref),\n-             ty: cx.ty_path(ty.span, [tp.ident]),\n-             ident: \"__v\",\n-             id: cx.next_id()}});\n+          id: cx.next_id()}]\n+        + tp_inputs;\n+\n+    vec::iter2(tps, ser_inputs) {|tp, arg|\n+        let arg_ident = arg.ident;\n+        cx.tps.insert(\n+            tp.ident,\n+            fn@(v: @ast::expr) -> [@ast::stmt] {\n+                let f = cx.var_ref(span, arg_ident);\n+                [cx.stmt(\n+                    cx.expr(\n+                        span,\n+                        ast::expr_call(f, [v], false)))]\n+            });\n+    }\n \n-    let ser_bnds = @[ast::bound_iface(cx.ty_path(ty.span,\n+    let ser_bnds = @[ast::bound_iface(cx.ty_path(span,\n                                                  [\"__std\", \"serialization\",\n                                                   \"serializer\"]))];\n+\n     let ser_tps: [ast::ty_param] =\n         [{ident: \"__S\",\n           id: cx.next_id(),\n           bounds: ser_bnds}] +\n         vec::map(tps) {|tp| cx.clone_ty_param(tp) };\n \n     let ser_output: @ast::ty = @{node: ast::ty_nil,\n-                                 span: ty.span};\n+                                 span: span};\n \n-    let ser_blk = cx.blk(ty.span,\n-                         serialize_ty(cx, ty,\n-                                      #ast(expr){\"__s\"}, #ast(expr){\"__v\"}));\n+    let ser_blk = cx.blk(span,\n+                         f(cx, v_ty, #ast(expr){\"__s\"}, #ast(expr){\"__v\"}));\n \n     @{ident: \"serialize\",\n       attrs: [],\n@@ -378,11 +474,91 @@ fn ty_module(ext_cx: ext_ctxt, name: str, -ty: @ast::ty, tps: [ast::ty_param])\n                           constraints: []},\n                          ser_tps,\n                          ser_blk),\n-      span: ty.span}\n+      span: span}\n+}\n+\n+fn ty_module(ext_cx: ext_ctxt, name: str, -ty: @ast::ty, tps: [ast::ty_param])\n+    -> @ast::item {\n+\n+    let span = ty.span;\n+    let ser_fn = mk_ser_fn(ext_cx, span, ty, tps, serialize_ty);\n+\n+    // Return a module containing the serialization and deserialization\n+    // functions:\n+    @{ident: name,\n+      attrs: [],\n+      id: ext_cx.session().next_node_id(),\n+      node: ast::item_mod({view_items: [],\n+                           items: [ser_fn]}),\n+      span: span}\n }\n \n-fn enum_module(cx: ext_ctxt, name: str,\n+fn enum_module(ext_cx: ext_ctxt, name: str, span: span,\n                variants: [ast::variant], tps: [ast::ty_param])\n     -> @ast::item {\n \n-}\n\\ No newline at end of file\n+    let span = ty.span;\n+    let ty = ext_cx.ty_path(span, [name]);\n+    let ser_fn = mk_ser_fn(ext_cx, span, ty, tps) {|cx, ty, s, v|\n+        let arms = vec::init_fn(vec::len(variants)) {|vidx|\n+            let variant = variants[vidx];\n+\n+            if vec::is_empty(variant.args) {\n+                // degenerate case.\n+                let pat = {id: cx.next_id(),\n+                           node: ast::pat_ident(cx.path(variant.ident), none),\n+                           Span: variant.span};\n+                //#ast(expr){\n+                //    $(s).emit_enum_variant(X, Y, SZ) {||\n+                //    };\n+                //}\n+            }\n+\n+            let variant_tys = vec::map(variant.args) {|a| a.ty };\n+\n+            serialize_variant(\n+                cx, variant_tys, variant.span, cx.clone(s),\n+\n+                // Generate pattern var(v1, v2, v3)\n+                {|pats|\n+                    let pat = {id: cx.next_id(),\n+                               node: ast::pat_enum(cx.path(variant.ident)),\n+                               span: variant.span};\n+\n+                    {id: cx.next_id(),\n+                     node: expr_call(s, [v_name,\n+                                         v_id,\n+                                         sz,\n+                                         f], false),\n+                     span: variant.span}\n+                },\n+\n+                // Generate body s.emit_enum_variant(\"foo\", 0u, 3u, {|| blk })\n+                {|-s, -blk|\n+                    let v_name = cx.lit_str(variant.span, variant.ident);\n+                    let v_id = cx.lit_uint(variant.span, vidx);\n+                    let sz = cx.lit_uint(variant.span, vec::len(variant_tys));\n+                    let body = cx.lambda(blk);\n+                    #ast[expr]{\n+                        $(s).emit_enum_variant($(v_name), $(v_id), $(sz), $(body))\n+                    }\n+                },\n+\n+                // Generate s.emit_enum_variant_arg(i, {|| blk })\n+                {|-s, i, -blk|\n+                    let idx = cx.lit_uint(i);\n+                    let body = cx.lambda(blk);\n+                    #ast[expr]{\n+                        $(s).emit_enum_variant_arg($(idx), $(body))\n+                    }\n+                })\n+        };\n+    };\n+\n+    @{ident: name,\n+      attrs: [],\n+      id: ext_cx.session().next_node_id(),\n+      node: ast::item_mod({view_items: [],\n+                           items: [ser_fn]}),\n+      span: span}\n+}", "previous_filename": "src/comp/syntax/ext/auto_serialize.rs"}]}