{"sha": "86ce3a2f7c1b9bcd342f5a0212383e5b2711f5f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2Y2UzYTJmN2MxYjliY2QzNDJmNWEwMjEyMzgzZTViMjcxMWY1ZjY=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-12-23T08:05:41Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2016-12-30T14:19:50Z"}, "message": "Further and hopefully final Windows fixes", "tree": {"sha": "05d848e4e3bda3acd9b0b8e01f6aa53ae7af0c7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05d848e4e3bda3acd9b0b8e01f6aa53ae7af0c7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86ce3a2f7c1b9bcd342f5a0212383e5b2711f5f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86ce3a2f7c1b9bcd342f5a0212383e5b2711f5f6", "html_url": "https://github.com/rust-lang/rust/commit/86ce3a2f7c1b9bcd342f5a0212383e5b2711f5f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86ce3a2f7c1b9bcd342f5a0212383e5b2711f5f6/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee6256b1ffd213d1e07390e4d66f57e6e463020f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee6256b1ffd213d1e07390e4d66f57e6e463020f", "html_url": "https://github.com/rust-lang/rust/commit/ee6256b1ffd213d1e07390e4d66f57e6e463020f"}], "stats": {"total": 379, "additions": 199, "deletions": 180}, "files": [{"sha": "e9094a2ef32a1d4e9976315160407d366b5fa050", "filename": "src/libcompiler_builtins/lib.rs", "status": "modified", "additions": 148, "deletions": 177, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/86ce3a2f7c1b9bcd342f5a0212383e5b2711f5f6/src%2Flibcompiler_builtins%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ce3a2f7c1b9bcd342f5a0212383e5b2711f5f6/src%2Flibcompiler_builtins%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2Flib.rs?ref=86ce3a2f7c1b9bcd342f5a0212383e5b2711f5f6", "patch": "@@ -19,11 +19,12 @@\n #![feature(staged_api)]\n #![cfg_attr(any(target_pointer_width=\"32\", target_pointer_width=\"16\", target_os=\"windows\",\n             target_arch=\"mips64\"),\n-            feature(core_intrinsics, core_float, repr_simd))]\n+            feature(core_intrinsics, repr_simd))]\n #![feature(associated_consts)]\n-#![cfg_attr(not(stage0), feature(i128_type))]\n+#![cfg_attr(not(stage0), feature(i128_type, core_float, abi_unadjusted))]\n \n-#![allow(non_camel_case_types, unused_variables)]\n+#![allow(non_camel_case_types, unused_variables, unused_imports)]\n+#![cfg_attr(stage0, allow(dead_code))]\n \n #[cfg(any(target_pointer_width=\"32\", target_pointer_width=\"16\", target_os=\"windows\",\n           target_arch=\"mips64\"))]\n@@ -46,29 +47,6 @@ pub mod reimpls {\n     #[cfg(not(stage0))]\n     type i128_ = i128;\n \n-    // Unfortunately, every tool on Windows expects different\n-    // calling conventions to be met for int128. We need to\n-    // match here what LLVM expects from us. This is only\n-    // required for the return type!\n-    #[cfg(not(stage0))]\n-    #[cfg(all(windows, target_pointer_width=\"64\"))]\n-    #[repr(simd)]\n-    pub struct u64x2(u64, u64);\n-\n-    #[cfg(not(stage0))]\n-    #[cfg(all(windows, target_pointer_width=\"64\"))]\n-    type u128ret = u64x2;\n-\n-    #[cfg(any(not(all(windows, target_pointer_width=\"64\")),stage0))]\n-    type u128ret = u128_;\n-\n-    #[cfg(not(stage0))]\n-    #[cfg(all(windows, target_pointer_width=\"64\"))]\n-    type i128ret = u64x2;\n-\n-    #[cfg(any(not(all(windows, target_pointer_width=\"64\")),stage0))]\n-    type i128ret = i128_;\n-\n     macro_rules! ashl {\n         ($a:expr, $b:expr, $ty:ty) => {{\n             let (a, b) = ($a, $b);\n@@ -137,27 +115,22 @@ pub mod reimpls {\n \n \n     #[export_name=\"__lshrti3\"]\n-    pub extern \"C\" fn lshr(a: u128_, b: u128_) -> u128ret {\n-        lshr!(a, b, u128_).to_ret()\n-    }\n-\n-    #[export_name=\"__udivmodti4\"]\n-    pub extern \"C\" fn u128_div_mod_export(n: u128_, d: u128_, rem: *mut u128_) -> u128ret {\n-        u128_div_mod(n, d, rem).to_ret()\n+    pub extern \"C\" fn lshr(a: u128_, b: u128_) -> u128_ {\n+        lshr!(a, b, u128_)\n     }\n \n     #[cfg(stage0)]\n-    pub extern \"C\" fn u128_div_mod(n: u128_, d: u128_, rem: *mut u128_) -> u128ret {\n+    pub extern \"C\" fn u128_div_mod(n: u128_, d: u128_, rem: *mut u128_) -> u128_ {\n         unsafe {\n         if !rem.is_null() {\n             *rem = unchecked_rem(n, d);\n         }\n-        unchecked_div(n, d).to_ret()\n+        unchecked_div(n, d)\n         }\n     }\n \n     #[cfg(not(stage0))]\n-    pub extern \"C\" fn u128_div_mod(n: u128_, d: u128_, rem: *mut u128_) -> u128 {\n+    pub extern \"C\" fn u128_div_mod(n: u128_, d: u128_, rem: *mut u128_) -> u128_ {\n         // Translated from Figure 3-40 of The PowerPC Compiler Writer's Guide\n         unsafe {\n         // special cases, X is unknown, K != 0\n@@ -322,29 +295,18 @@ pub mod reimpls {\n         }\n     }\n \n-    #[export_name=\"__umodti3\"]\n-    pub extern \"C\" fn u128_mod(a: u128_, b: u128_) -> u128ret {\n-        unsafe {\n-            let mut r = ::core::mem::zeroed();\n-            u128_div_mod(a, b, &mut r);\n-            r.to_ret()\n-        }\n-    }\n-\n-    #[export_name=\"__modti3\"]\n-    pub extern \"C\" fn i128_mod(a: i128_, b: i128_) -> i128ret {\n+    fn i128_mod(a: i128_, b: i128_) -> i128_ {\n         let b = b.uabs();\n         let sa = a.signum();\n         let a = a.uabs();\n-        (unsafe {\n+        unsafe {\n             let mut r = ::core::mem::zeroed();\n             u128_div_mod(a, b, &mut r);\n             if sa == -1 { (r as i128_).unchecked_neg() } else { r as i128_ }\n-        }).to_ret()\n+        }\n     }\n \n-    #[export_name=\"__divti3\"]\n-    pub extern \"C\" fn i128_div(a: i128_, b: i128_) -> i128ret {\n+    fn i128_div(a: i128_, b: i128_) -> i128_ {\n         let sa = a.signum();\n         let sb = b.signum();\n         let a = a.uabs();\n@@ -354,19 +316,13 @@ pub mod reimpls {\n             (u128_div_mod(a, b, ptr::null_mut()) as i128_).unchecked_neg()\n         } else {\n             u128_div_mod(a, b, ptr::null_mut()) as i128_\n-        }).to_ret()\n+        })\n     }\n \n     #[cfg(stage0)]\n     #[export_name=\"__udivti3\"]\n-    pub extern \"C\" fn u128_div(a: u128_, b: u128_) -> u128ret {\n-        (a / b).to_ret()\n-    }\n-\n-    #[cfg(not(stage0))]\n-    #[export_name=\"__udivti3\"]\n-    pub extern \"C\" fn u128_div(a: u128_, b: u128_) -> u128ret {\n-        u128_div_mod(a, b, ptr::null_mut()).to_ret()\n+    pub extern \"C\" fn u128_div(a: u128_, b: u128_) -> u128_ {\n+        (a / b)\n     }\n \n     macro_rules! mulo {\n@@ -394,7 +350,6 @@ pub mod reimpls {\n             if abs_a < 2 || abs_b < 2 {\n                 return result;\n             }\n-            unsafe {\n             if sa == sb {\n                 if abs_a > unchecked_div(<$ty>::max_value(), abs_b) {\n                     *overflow = 1;\n@@ -404,32 +359,21 @@ pub mod reimpls {\n                     *overflow = 1;\n                 }\n             }\n-            }\n             result\n         }}\n     }\n \n-    // FIXME: i32 here should be c_int.\n-    #[cfg_attr(not(all(windows, target_pointer_width=\"64\", not(stage0))),\n-               export_name=\"__muloti4\")]\n-    pub extern \"C\" fn i128_mul_oflow(a: i128_, b: i128_, o: &mut i32) -> i128 {\n-        mulo!(a, b, o, i128_)\n-    }\n-\n     pub trait LargeInt {\n         type LowHalf;\n         type HighHalf;\n-        type Ret;\n \n         fn low(self) -> Self::LowHalf;\n         fn high(self) -> Self::HighHalf;\n         fn from_parts(low: Self::LowHalf, high: Self::HighHalf) -> Self;\n-        fn to_ret(self) -> Self::Ret;\n     }\n     impl LargeInt for u64 {\n         type LowHalf = u32;\n         type HighHalf = u32;\n-        type Ret = u64;\n \n         fn low(self) -> u32 {\n             self as u32\n@@ -440,14 +384,10 @@ pub mod reimpls {\n         fn from_parts(low: u32, high: u32) -> u64 {\n             low as u64 | (high as u64).wrapping_shl(32)\n         }\n-        fn to_ret(self) -> u64 {\n-            self\n-        }\n     }\n     impl LargeInt for i64 {\n         type LowHalf = u32;\n         type HighHalf = i32;\n-        type Ret = i64;\n \n         fn low(self) -> u32 {\n             self as u32\n@@ -458,15 +398,11 @@ pub mod reimpls {\n         fn from_parts(low: u32, high: i32) -> i64 {\n             low as i64 | (high as i64).wrapping_shl(32)\n         }\n-        fn to_ret(self) -> i64 {\n-            self\n-        }\n     }\n     #[cfg(not(stage0))]\n     impl LargeInt for u128 {\n         type LowHalf = u64;\n         type HighHalf = u64;\n-        type Ret = u128ret;\n \n         fn low(self) -> u64 {\n             self as u64\n@@ -478,20 +414,11 @@ pub mod reimpls {\n             #[repr(C, packed)] struct Parts(u64, u64);\n             unsafe { ::core::mem::transmute(Parts(low, high)) }\n         }\n-        #[cfg(not(all(windows, target_pointer_width=\"64\")))]\n-        fn to_ret(self) -> u128ret {\n-            self\n-        }\n-        #[cfg(all(windows, target_pointer_width=\"64\"))]\n-        fn to_ret(self) -> u128ret {\n-            u64x2(self.low(), self.high())\n-        }\n     }\n     #[cfg(not(stage0))]\n     impl LargeInt for i128 {\n         type LowHalf = u64;\n         type HighHalf = i64;\n-        type Ret = i128ret;\n \n         fn low(self) -> u64 {\n             self as u64\n@@ -502,14 +429,6 @@ pub mod reimpls {\n         fn from_parts(low: u64, high: i64) -> i128 {\n             u128::from_parts(low, high as u64) as i128\n         }\n-        #[cfg(not(all(windows, target_pointer_width=\"64\")))]\n-        fn to_ret(self) -> i128ret {\n-            self\n-        }\n-        #[cfg(all(windows, target_pointer_width=\"64\"))]\n-        fn to_ret(self) -> i128ret {\n-            u64x2(self.low(), self.high() as u64)\n-        }\n     }\n \n     macro_rules! mul {\n@@ -543,14 +462,14 @@ pub mod reimpls {\n \n     #[cfg(stage0)]\n     #[export_name=\"__multi3\"]\n-    pub extern \"C\" fn u128_mul(a: i128_, b: i128_) -> i128ret {\n-        ((a as i64).wrapping_mul(b as i64) as i128_).to_ret()\n+    pub extern \"C\" fn u128_mul(a: i128_, b: i128_) -> i128_ {\n+        ((a as i64).wrapping_mul(b as i64) as i128_)\n     }\n \n     #[cfg(not(stage0))]\n     #[export_name=\"__multi3\"]\n-    pub extern \"C\" fn u128_mul(a: i128_, b: i128_) -> i128ret {\n-        mul!(a, b, i128_, i64).to_ret()\n+    pub extern \"C\" fn u128_mul(a: i128_, b: i128_) -> i128_ {\n+        mul!(a, b, i128_, i64)\n     }\n \n     trait AbsExt: Sized {\n@@ -628,9 +547,9 @@ pub mod reimpls {\n             let exponent = $from.get_exponent();\n             let mantissa_fraction = repr & <$fromty as FloatStuff>::MANTISSA_MASK;\n             let mantissa = mantissa_fraction | <$fromty as FloatStuff>::MANTISSA_LEAD_BIT;\n-            if sign == -1.0 || exponent < 0 { return (0 as u128_).to_ret(); }\n+            if sign == -1.0 || exponent < 0 { return 0 as u128_; }\n             if exponent > ::core::mem::size_of::<$outty>() as i32 * 8 {\n-                return (!(0 as u128_)).to_ret();\n+                return !(0 as u128_);\n             }\n             (if exponent < (<$fromty as FloatStuff>::MANTISSA_BITS) as i32 {\n                 (mantissa as $outty)\n@@ -640,20 +559,10 @@ pub mod reimpls {\n                 (mantissa as $outty)\n                     .wrapping_shl(exponent.wrapping_sub(\n                         <$fromty as FloatStuff>::MANTISSA_BITS as i32) as u32)\n-            }).to_ret()\n+            })\n         } }\n     }\n \n-    #[export_name=\"__fixunsdfti\"]\n-    pub extern \"C\" fn f64_as_u128(a: f64) -> u128ret {\n-        float_as_unsigned!(a, f64, u128_)\n-    }\n-\n-    #[export_name=\"__fixunssfti\"]\n-    pub extern \"C\" fn f32_as_u128(a: f32) -> u128ret {\n-        float_as_unsigned!(a, f32, u128_)\n-    }\n-\n     macro_rules! float_as_signed {\n         ($from: expr, $fromty: ty, $outty: ty) => {{\n             use core::num::Float;\n@@ -663,10 +572,10 @@ pub mod reimpls {\n             let mantissa_fraction = repr & <$fromty as FloatStuff>::MANTISSA_MASK;\n             let mantissa = mantissa_fraction | <$fromty as FloatStuff>::MANTISSA_LEAD_BIT;\n \n-            if exponent < 0 { return (0 as i128_).to_ret(); }\n+            if exponent < 0 { return 0 as i128_; }\n             if exponent > ::core::mem::size_of::<$outty>() as i32 * 8 {\n                 let ret = if sign > 0.0 { <$outty>::max_value() } else { <$outty>::min_value() };\n-                return ret.to_ret();\n+                return ret\n             }\n             let r = if exponent < (<$fromty as FloatStuff>::MANTISSA_BITS) as i32 {\n                 (mantissa as $outty)\n@@ -677,82 +586,28 @@ pub mod reimpls {\n                     .wrapping_shl(exponent.wrapping_sub(\n                         <$fromty as FloatStuff>::MANTISSA_BITS as i32) as u32)\n             };\n-            (if sign >= 0.0 { r } else { r.unchecked_neg() }).to_ret()\n+            (if sign >= 0.0 { r } else { r.unchecked_neg() })\n         }}\n     }\n \n-    #[export_name=\"__fixdfti\"]\n-    pub extern \"C\" fn f64_as_i128(a: f64) -> i128ret {\n-        float_as_signed!(a, f64, i128_)\n-    }\n \n-    #[export_name=\"__fixsfti\"]\n-    pub extern \"C\" fn f32_as_i128(a: f32) -> i128ret {\n-        float_as_signed!(a, f32, i128_)\n-    }\n-\n-    // LLVM expectations for ABI on windows are pure madness.\n-\n-    #[cfg(not(stage0))]\n-    #[cfg(all(windows, target_pointer_width=\"64\"))]\n-    mod windows_64_workarounds {\n-        use super::{i128_, u128_, LargeInt};\n-        use super::{i128_as_f64, i128_as_f32, u128_as_f64, u128_as_f32, i128_mul_oflow};\n-\n-        #[export_name=\"__muloti4\"]\n-        pub extern \"C\" fn i128_mul_oflow_win(alow: u64, ahigh: i64,\n-                                             blow: u64, bhigh: i64, o: &mut i32) -> i128 {\n-            i128_mul_oflow(i128_::from_parts(alow, ahigh), i128_::from_parts(blow, bhigh), o)\n-        }\n-\n-        #[export_name=\"__floattidf\"]\n-        pub extern \"C\" fn i128_as_f64_win(alow: u64, ahigh: i64) -> f64 {\n-            i128_as_f64(i128_::from_parts(alow, ahigh))\n-        }\n-\n-        #[export_name=\"__floattisf\"]\n-        pub extern \"C\" fn i128_as_f32_win(alow: u64, ahigh: i64) -> f32 {\n-            i128_as_f32(i128_::from_parts(alow, ahigh))\n-        }\n-\n-        #[export_name=\"__floatuntidf\"]\n-        pub extern \"C\" fn u128_as_f64_win(alow: u64, ahigh: u64) -> f64 {\n-            u128_as_f64(u128_::from_parts(alow, ahigh))\n-        }\n-\n-        #[export_name=\"__floatuntisf\"]\n-        pub extern \"C\" fn u128_as_f32_win(alow: u64, ahigh: u64) -> f32 {\n-            u128_as_f32(u128_::from_parts(alow, ahigh))\n-        }\n-    }\n-    #[cfg(not(stage0))]\n-    #[cfg(all(windows, target_pointer_width=\"64\"))]\n-    pub use self::windows_64_workarounds::*;\n-\n-\n-    #[cfg_attr(not(all(windows, target_pointer_width=\"64\", not(stage0))),\n-               export_name=\"__floattidf\")]\n-    pub extern \"C\" fn i128_as_f64(a: i128_) -> f64 {\n+    fn i128_as_f64(a: i128_) -> f64 {\n         match a.signum() {\n             1 => u128_as_f64(a.uabs()),\n             0 => 0.0,\n             _ => -u128_as_f64(a.uabs()),\n         }\n     }\n \n-    #[cfg_attr(not(all(windows, target_pointer_width=\"64\", not(stage0))),\n-               export_name=\"__floattisf\")]\n-    pub extern \"C\" fn i128_as_f32(a: i128_) -> f32 {\n+    fn i128_as_f32(a: i128_) -> f32 {\n         match a.signum() {\n             1 => u128_as_f32(a.uabs()),\n             0 => 0.0,\n             _ => -u128_as_f32(a.uabs()),\n         }\n     }\n \n-    #[cfg_attr(not(all(windows, target_pointer_width=\"64\", not(stage0))),\n-               export_name=\"__floatuntidf\")]\n-    pub extern \"C\" fn u128_as_f64(mut a: u128_) -> f64 {\n+    fn u128_as_f64(mut a: u128_) -> f64 {\n         use ::core::f64::MANTISSA_DIGITS;\n         if a == 0 { return 0.0; }\n         let sd = 128u32.wrapping_sub(a.leading_zeros());\n@@ -787,9 +642,7 @@ pub mod reimpls {\n         }\n     }\n \n-    #[cfg_attr(not(all(windows, target_pointer_width=\"64\", not(stage0))),\n-               export_name=\"__floatuntisf\")]\n-    pub extern \"C\" fn u128_as_f32(mut a: u128_) -> f32 {\n+    fn u128_as_f32(mut a: u128_) -> f32 {\n         use ::core::f32::MANTISSA_DIGITS;\n         if a == 0 { return 0.0; }\n         let sd = 128u32.wrapping_sub(a.leading_zeros());\n@@ -823,4 +676,122 @@ pub mod reimpls {\n                                    | (a as u32 & 0x007f_ffff))\n         }\n     }\n+\n+\n+    macro_rules! why_are_abi_strings_checked_by_parser { ($cret:ty, $conv:expr, $unadj:tt) => {\n+    mod imp {\n+        use super::{i128_, u128_, LargeInt, FloatStuff, NegExt, AbsExt};\n+        use super::{i128_as_f64, i128_as_f32, u128_as_f64, u128_as_f32,\n+                    i128_div, i128_mod, u128_div_mod, unchecked_div, ptr};\n+        // For x64\n+        // rdx:rcx, r9:r8, stack -> rdx:rax\n+        // aka.\n+        // define i128 @__muloti4(i128, i128, i32*)\n+        #[export_name=\"__muloti4\"]\n+        pub unsafe extern $unadj fn i128_mul_oflow(a: i128_, b: i128_, o: *mut i32) -> i128_ {\n+            mulo!(a, b, o, i128_)\n+        }\n+\n+        // For x64\n+        // rdx:rax -> xmm0\n+        // aka.\n+        // define double @__muloti4(i128)\n+        #[export_name=\"__floattidf\"]\n+        pub extern $unadj fn i128_as_f64_(a: i128_) -> f64 {\n+            i128_as_f64(a)\n+        }\n+        #[export_name=\"__floattisf\"]\n+        pub extern $unadj fn i128_as_f32_(a: i128_) -> f32 {\n+            i128_as_f32(a)\n+        }\n+        #[export_name=\"__floatuntidf\"]\n+        pub extern $unadj fn u128_as_f64_(a: u128_) -> f64 {\n+            u128_as_f64(a)\n+        }\n+        #[export_name=\"__floatuntisf\"]\n+        pub extern $unadj fn u128_as_f32_(a: u128_) -> f32 {\n+            u128_as_f32(a)\n+        }\n+\n+        // For x64\n+        // xmm0 -> rdx:rax\n+        // aka.\n+        // define i128 @stuff(double)\n+        #[export_name=\"__fixunsdfti\"]\n+        pub extern $unadj fn f64_as_u128(a: f64) -> u128_ {\n+            float_as_unsigned!(a, f64, u128_)\n+        }\n+\n+        #[export_name=\"__fixunssfti\"]\n+        pub extern \"unadjusted\" fn f32_as_u128(a: f32) -> u128_ {\n+            float_as_unsigned!(a, f32, u128_)\n+        }\n+\n+        #[export_name=\"__fixdfti\"]\n+        pub extern \"unadjusted\" fn f64_as_i128(a: f64) -> i128_ {\n+            float_as_signed!(a, f64, i128_)\n+        }\n+\n+        #[export_name=\"__fixsfti\"]\n+        pub extern \"unadjusted\" fn f32_as_i128(a: f32) -> i128_ {\n+            float_as_signed!(a, f32, i128_)\n+        }\n+\n+        #[repr(simd)]\n+        pub struct u64x2(u64, u64);\n+\n+        // For x64\n+        // pointers -> xmm0\n+        // aka.\n+        // define <2 x u64> @stuff(i128*, i128*, i128*)\n+        //\n+        // That almost matches the C ABI, so we simply use the C ABI\n+        #[export_name=\"__udivmodti4\"]\n+        pub extern \"C\" fn u128_div_mod_(n: u128_, d: u128_, rem: *mut u128_) -> $cret {\n+            let x = u128_div_mod(n, d, rem);\n+            ($conv)(x)\n+        }\n+\n+        #[export_name=\"__udivti3\"]\n+        pub extern \"C\" fn u128_div_(a: u128_, b: u128_) -> $cret {\n+            let x = u128_div_mod(a, b, ptr::null_mut());\n+            ($conv)(x)\n+        }\n+\n+        #[export_name=\"__umodti3\"]\n+        pub extern \"C\" fn u128_mod_(a: u128_, b: u128_) -> $cret {\n+            unsafe {\n+                let mut r = ::core::mem::zeroed();\n+                u128_div_mod(a, b, &mut r);\n+                ($conv)(r)\n+            }\n+        }\n+\n+        #[export_name=\"__divti3\"]\n+        pub extern \"C\" fn i128_div_(a: i128_, b: i128_) -> $cret {\n+            let x = i128_div(a, b);\n+            ($conv)(x as u128_)\n+        }\n+\n+        #[export_name=\"__modti3\"]\n+        pub extern \"C\" fn i128_mod_(a: i128_, b: i128_) -> $cret {\n+            let x = i128_mod(a, b);\n+            ($conv)(x as u128_)\n+        }\n+    }\n+    } }\n+\n+    // LLVM expectations for ABI on windows x64 are pure madness.\n+    #[cfg(not(stage0))]\n+    #[cfg(all(windows, target_pointer_width=\"64\"))]\n+    why_are_abi_strings_checked_by_parser!(u64x2,\n+                                           |i: u128_| u64x2(i.low(), i.high()),\n+                                           \"unadjusted\");\n+\n+    #[cfg(not(stage0))]\n+    #[cfg(not(all(windows, target_pointer_width=\"64\")))]\n+    why_are_abi_strings_checked_by_parser!(u128_, |i|{ i }, \"C\");\n+\n+    #[cfg(not(stage0))]\n+    pub use self::imp::*;\n }"}, {"sha": "3fba75bc253cd1496f3ba51c78d32508457954bb", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/86ce3a2f7c1b9bcd342f5a0212383e5b2711f5f6/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ce3a2f7c1b9bcd342f5a0212383e5b2711f5f6/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=86ce3a2f7c1b9bcd342f5a0212383e5b2711f5f6", "patch": "@@ -352,6 +352,7 @@ impl FnType {\n             Fastcall => llvm::X86FastcallCallConv,\n             Vectorcall => llvm::X86_VectorCall,\n             C => llvm::CCallConv,\n+            Unadjusted => llvm::CCallConv,\n             Win64 => llvm::X86_64_Win64,\n             SysV64 => llvm::X86_64_SysV,\n             Aapcs => llvm::ArmAapcsCallConv,\n@@ -528,6 +529,8 @@ impl FnType {\n                                     ccx: &CrateContext<'a, 'tcx>,\n                                     abi: Abi,\n                                     sig: &ty::FnSig<'tcx>) {\n+        if abi == Abi::Unadjusted { return }\n+\n         if abi == Abi::Rust || abi == Abi::RustCall ||\n            abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n             let fixup = |arg: &mut ArgType| {"}, {"sha": "75554f20effeea2bda313212ce18d4c923b9111f", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86ce3a2f7c1b9bcd342f5a0212383e5b2711f5f6/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ce3a2f7c1b9bcd342f5a0212383e5b2711f5f6/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=86ce3a2f7c1b9bcd342f5a0212383e5b2711f5f6", "patch": "@@ -50,6 +50,7 @@ pub enum Abi {\n     RustIntrinsic,\n     RustCall,\n     PlatformIntrinsic,\n+    Unadjusted\n }\n \n #[allow(non_camel_case_types)]\n@@ -92,6 +93,7 @@ const AbiDatas: &'static [AbiData] = &[\n     AbiData {abi: Abi::RustIntrinsic, name: \"rust-intrinsic\", generic: true },\n     AbiData {abi: Abi::RustCall, name: \"rust-call\", generic: true },\n     AbiData {abi: Abi::PlatformIntrinsic, name: \"platform-intrinsic\", generic: true },\n+    AbiData {abi: Abi::Unadjusted, name: \"unadjusted\", generic: true },\n ];\n \n /// Returns the ABI with the given name (if any)."}, {"sha": "e7df454cf6a50220783c7c533d8934a8ff5250b3", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/86ce3a2f7c1b9bcd342f5a0212383e5b2711f5f6/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ce3a2f7c1b9bcd342f5a0212383e5b2711f5f6/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=86ce3a2f7c1b9bcd342f5a0212383e5b2711f5f6", "patch": "@@ -324,6 +324,9 @@ declare_features! (\n \n     // The `i128` type\n     (active, i128_type, \"1.16.0\", Some(35118)),\n+\n+    // The `unadjusted` ABI. Perma unstable.\n+    (active, abi_unadjusted, \"1.16.0\", None),\n );\n \n declare_features! (\n@@ -995,7 +998,11 @@ impl<'a> PostExpansionVisitor<'a> {\n             Abi::PtxKernel => {\n                 gate_feature_post!(&self, abi_ptx, span,\n                                    \"PTX ABIs are experimental and subject to change\");\n-            }\n+            },\n+            Abi::Unadjusted => {\n+                gate_feature_post!(&self, abi_unadjusted, span,\n+                                   \"unadjusted ABI is an implementation detail and perma-unstable\");\n+            },\n             // Stable\n             Abi::Cdecl |\n             Abi::Stdcall |"}, {"sha": "71d3e6491cbadaa2f033b42b7fa02a9bcaa4d528", "filename": "src/test/run-pass/i128.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/86ce3a2f7c1b9bcd342f5a0212383e5b2711f5f6/src%2Ftest%2Frun-pass%2Fi128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ce3a2f7c1b9bcd342f5a0212383e5b2711f5f6/src%2Ftest%2Frun-pass%2Fi128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fi128.rs?ref=86ce3a2f7c1b9bcd342f5a0212383e5b2711f5f6", "patch": "@@ -10,7 +10,10 @@\n \n // ignore-stage0\n // ignore-stage1\n-#![feature(i128_type)]\n+#![feature(i128_type, test)]\n+\n+extern crate test;\n+use test::black_box as b;\n \n fn main() {\n     let x: i128 = -1;\n@@ -45,6 +48,39 @@ fn main() {\n     assert_eq!((-z as f32) as i128, -z);\n     assert_eq!((-z as f64 * 16.0) as i128, -z * 16);\n     assert_eq!((-z as f32 * 16.0) as i128, -z * 16);\n+    // Same stuff as above, but blackboxed, to force use of intrinsics\n+    let x: i128 = b(-1);\n+    assert_eq!(0, !x);\n+    let y: i128 = b(-2);\n+    assert_eq!(!1, y);\n+    let z: i128 = b(0xABCD_EF);\n+    assert_eq!(z * z, 0x734C_C2F2_A521);\n+    assert_eq!(z * z * z * z, 0x33EE_0E2A_54E2_59DA_A0E7_8E41);\n+    assert_eq!(-z * -z, 0x734C_C2F2_A521);\n+    assert_eq!(-z * -z * -z * -z, 0x33EE_0E2A_54E2_59DA_A0E7_8E41);\n+    assert_eq!(-z + -z + -z + -z, -0x2AF3_7BC);\n+    let k: i128 = b(-0x1234_5678_9ABC_DEFF_EDCB_A987_6543_210);\n+    assert_eq!(k + k, -0x2468_ACF1_3579_BDFF_DB97_530E_CA86_420);\n+    assert_eq!(0, k - k);\n+    assert_eq!(-0x1234_5678_9ABC_DEFF_EDCB_A987_5A86_421, k + z);\n+    assert_eq!(-0x1000_0000_0000_0000_0000_0000_0000_000,\n+               k + 0x234_5678_9ABC_DEFF_EDCB_A987_6543_210);\n+    assert_eq!(-0x6EF5_DE4C_D3BC_2AAA_3BB4_CC5D_D6EE_8, k / 42);\n+    assert_eq!(-k, k / -1);\n+    assert_eq!(-0x91A2_B3C4_D5E6_F8, k >> 65);\n+    assert_eq!(-0xFDB9_7530_ECA8_6420_0000_0000_0000_0000, k << 65);\n+    assert!(k < z);\n+    assert!(y > k);\n+    assert!(y < x);\n+    assert_eq!(x as i64, -1);\n+    assert_eq!(z as i64, 0xABCD_EF);\n+    assert_eq!(k as i64, -0xFEDC_BA98_7654_3210);\n+    assert_eq!(k as u128, 0xFEDC_BA98_7654_3210_0123_4567_89AB_CDF0);\n+    assert_eq!(-k as u128, 0x1234_5678_9ABC_DEFF_EDCB_A987_6543_210);\n+    assert_eq!((-z as f64) as i128, -z);\n+    assert_eq!((-z as f32) as i128, -z);\n+    assert_eq!((-z as f64 * 16.0) as i128, -z * 16);\n+    assert_eq!((-z as f32 * 16.0) as i128, -z * 16);\n     // formatting\n     let j: i128 = -(1 << 67);\n     assert_eq!(\"-147573952589676412928\", format!(\"{}\", j));"}, {"sha": "f71ef126b64d9556914558d4ffb6c2b9316b0d6b", "filename": "src/test/ui/codemap_tests/unicode.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86ce3a2f7c1b9bcd342f5a0212383e5b2711f5f6/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/86ce3a2f7c1b9bcd342f5a0212383e5b2711f5f6/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr?ref=86ce3a2f7c1b9bcd342f5a0212383e5b2711f5f6", "patch": "@@ -1,4 +1,4 @@\n-error: invalid ABI: expected one of [cdecl, stdcall, fastcall, vectorcall, aapcs, win64, sysv64, ptx-kernel, Rust, C, system, rust-intrinsic, rust-call, platform-intrinsic], found `\u8def\u6feb\u72fc\u00e1\u0301\u0301`\n+error: invalid ABI: expected one of [cdecl, stdcall, fastcall, vectorcall, aapcs, win64, sysv64, ptx-kernel, Rust, C, system, rust-intrinsic, rust-call, platform-intrinsic, unadjusted], found `\u8def\u6feb\u72fc\u00e1\u0301\u0301`\n   --> $DIR/unicode.rs:11:8\n    |\n 11 | extern \"\u8def\u6feb\u72fc\u00e1\u0301\u0301\" fn foo() {}"}]}