{"sha": "77c1b9650f055932bcad5983b9847517eba6c516", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3YzFiOTY1MGYwNTU5MzJiY2FkNTk4M2I5ODQ3NTE3ZWJhNmM1MTY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-09T07:30:46Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-09T11:08:39Z"}, "message": "Some more workarounds to please the alias checker\n\nSome of the vec utilities now only work on immutable vecs, since they\nwould have to be rewritten to do a lot more copying to be alias-safe.\n\nSome forced copying was added to map.rs, showing a weakness in the\nalias checker (or maybe the alias system): when fn args are passed\ninto a function, calling them must assume all aliases that are not\nimmutably rooted (directly connected to a local or temporary without\nany mutable edges) become invalid. This will be a drag on functional\nprogramming in Rust.\n\nWork around alias issues in the stdlib", "tree": {"sha": "d78212cf747ca34a2b93512d036470cc49dfc212", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d78212cf747ca34a2b93512d036470cc49dfc212"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77c1b9650f055932bcad5983b9847517eba6c516", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77c1b9650f055932bcad5983b9847517eba6c516", "html_url": "https://github.com/rust-lang/rust/commit/77c1b9650f055932bcad5983b9847517eba6c516", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77c1b9650f055932bcad5983b9847517eba6c516/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd90c7a3cbf470b50857a84e2e8407b7ebed7ce2", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd90c7a3cbf470b50857a84e2e8407b7ebed7ce2", "html_url": "https://github.com/rust-lang/rust/commit/bd90c7a3cbf470b50857a84e2e8407b7ebed7ce2"}], "stats": {"total": 47, "additions": 27, "deletions": 20}, "files": [{"sha": "81c0f5a265a15a1609a0e7c501bbc81247e5a09c", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/77c1b9650f055932bcad5983b9847517eba6c516/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77c1b9650f055932bcad5983b9847517eba6c516/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=77c1b9650f055932bcad5983b9847517eba6c516", "patch": "@@ -339,7 +339,8 @@ fn crate_meta_extras_hash(sha1 sha, &ast::crate crate) -> str {\n     }\n     sort::quick_sort(lteq, v);\n     sha.reset();\n-    for (@ast::meta_item m in v) {\n+    for (@ast::meta_item m_ in v) {\n+        auto m = m_;\n         sha.input_str(len_and_str(m.node.name));\n         sha.input_str(len_and_str(m.node.value));\n     }"}, {"sha": "396835bc1d6935306c2d4b8a7b9c358117e63bb2", "filename": "src/lib/map.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/77c1b9650f055932bcad5983b9847517eba6c516/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77c1b9650f055932bcad5983b9847517eba6c516/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=77c1b9650f055932bcad5983b9847517eba6c516", "patch": "@@ -76,8 +76,10 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n                 let uint j = hash(h, nbkts, i);\n                 alt (bkts.(j)) {\n                     case (some(?k, _)) {\n-                        if (eqer(key, k)) {\n-                            bkts.(j) = some[K, V](k, val);\n+                        // Copy key to please alias analysis.\n+                        auto k_ = k;\n+                        if (eqer(key, k_)) {\n+                            bkts.(j) = some[K, V](k_, val);\n                             ret false;\n                         }\n                         i += 1u;\n@@ -104,8 +106,11 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n                 let uint j = (hash(h, nbkts, i));\n                 alt (bkts.(j)) {\n                     case (some(?k, ?v)) {\n-                        if (eqer(key, k)) {\n-                            ret option::some[V](v);\n+                        // Copy to please alias analysis.\n+                        auto k_ = k;\n+                        auto v_ = v;\n+                        if (eqer(key, k_)) {\n+                            ret option::some[V](v_);\n                         }\n                     }\n                     case (nil) {\n@@ -190,10 +195,11 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n                     let uint j = (hash(h, nbkts, i));\n                     alt (bkts.(j)) {\n                         case (some(?k, ?v)) {\n-                            if (eqer(key, k)) {\n+                            auto k_ = k; auto vo = option::some(v);\n+                            if (eqer(key, k_)) {\n                                 bkts.(j) = deleted[K, V];\n                                 nelts -= 1u;\n-                                ret option::some[V](v);\n+                                ret vo;\n                             }\n                         }\n                         case (deleted) { }"}, {"sha": "8a16c1858becb4b8f2fda5038c01dc37c18e3fb1", "filename": "src/lib/sort.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/77c1b9650f055932bcad5983b9847517eba6c516/src%2Flib%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77c1b9650f055932bcad5983b9847517eba6c516/src%2Flib%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsort.rs?ref=77c1b9650f055932bcad5983b9847517eba6c516", "patch": "@@ -58,7 +58,7 @@ fn part[T](lteq[T] compare_func, vec[mutable T] arr, uint left,\n     let uint storage_index = left;\n     let uint i = left;\n     while (i<right) {\n-        if (compare_func(arr.(i), pivot_value)) {\n+        if (compare_func({arr.(i)}, pivot_value)) {\n            swap[T](arr, i, storage_index);\n            storage_index += 1u;\n         }\n@@ -97,7 +97,7 @@ fn quick_sort[T](lteq[T] compare_func, vec[mutable T] arr) {\n // 'randomly ordered keys, abstract compare' & 'small number of key values'\n \n fn qsort3[T](lteq[T] compare_func_lt, lteq[T] compare_func_eq,\n-        vec[mutable T] arr, int left, int right) {\n+             vec[mutable T] arr, int left, int right) {\n \n     if (right <= left) {\n         ret;\n@@ -111,11 +111,11 @@ fn qsort3[T](lteq[T] compare_func_lt, lteq[T] compare_func_eq,\n \n     while (true) {\n         i += 1;\n-        while (compare_func_lt(arr.(i), v)) {\n+        while (compare_func_lt({arr.(i)}, v)) {\n             i += 1;\n         }\n         j -= 1;\n-        while (compare_func_lt(v, arr.(j))) {\n+        while (compare_func_lt(v, {arr.(j)})) {\n             if (j == left) {\n                 break;\n             }\n@@ -125,11 +125,11 @@ fn qsort3[T](lteq[T] compare_func_lt, lteq[T] compare_func_eq,\n             break;\n         }\n         swap[T](arr, i as uint, j as uint);\n-        if (compare_func_eq(arr.(i), v)) {\n+        if (compare_func_eq({arr.(i)}, v)) {\n             p += 1;\n             swap[T](arr, p as uint, i as uint);\n         }\n-        if (compare_func_eq(v, arr.(j))) {\n+        if (compare_func_eq(v, {arr.(j)})) {\n             q -= 1;\n             swap[T](arr, j as uint, q as uint);\n         }"}, {"sha": "2d81be65e2ebd36fc30132e5054c3324c5718e6a", "filename": "src/lib/ufind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77c1b9650f055932bcad5983b9847517eba6c516/src%2Flib%2Fufind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77c1b9650f055932bcad5983b9847517eba6c516/src%2Flib%2Fufind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fufind.rs?ref=77c1b9650f055932bcad5983b9847517eba6c516", "patch": "@@ -29,7 +29,7 @@ fn grow(&ufind ufnd, uint n) {\n fn find(&ufind ufnd, uint n) -> uint {\n     alt (ufnd.nodes.(n)) {\n         case (none) { ret n; }\n-        case (some(?m)) { be find(ufnd, m); }\n+        case (some(?m)) { auto m_ = m; be find(ufnd, m_); }\n     }\n }\n "}, {"sha": "3cc4db83b5498211243b94be31a188902b32d0e6", "filename": "src/lib/vec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/77c1b9650f055932bcad5983b9847517eba6c516/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77c1b9650f055932bcad5983b9847517eba6c516/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=77c1b9650f055932bcad5983b9847517eba6c516", "patch": "@@ -241,16 +241,16 @@ fn grow_init_fn_set[T](&array[T] v, uint index, fn()->T init_fn, &T val) {\n }\n \n \n-fn map[T, U](&fn(&T) -> U f, &array[T] v) -> vec[U] {\n+fn map[T, U](&fn(&T) -> U f, &vec[T] v) -> vec[U] {\n     let vec[U] res = alloc[U](len[T](v));\n     for (T ve in v) {\n         res += [f(ve)];\n     }\n     ret res;\n }\n \n-fn filter_map[T, U](&fn(&T) -> option::t[U] f, &array[T] v) -> vec[U] {\n-    let vec[U] res = []; //TODO does this work these days?\n+fn filter_map[T, U](&fn(&T) -> option::t[U] f, &vec[T] v) -> vec[U] {\n+    let vec[U] res = [];\n     for(T ve in v) {\n         alt(f(ve)) {\n             case (some(?elt)) { res += [elt]; }\n@@ -260,7 +260,7 @@ fn filter_map[T, U](&fn(&T) -> option::t[U] f, &array[T] v) -> vec[U] {\n     ret res;\n }\n \n-fn map2[T,U,V](&operator2[T,U,V] f, &array[T] v0, &array[U] v1) -> vec[V] {\n+fn map2[T,U,V](&operator2[T,U,V] f, &vec[T] v0, &vec[U] v1) -> vec[V] {\n     auto v0_len = len[T](v0);\n     if (v0_len != len[U](v1)) {\n         fail;\n@@ -269,14 +269,14 @@ fn map2[T,U,V](&operator2[T,U,V] f, &array[T] v0, &array[U] v1) -> vec[V] {\n     let vec[V] u = alloc[V](v0_len);\n     auto i = 0u;\n     while (i < v0_len) {\n-        u += [f(v0.(i), v1.(i))];\n+        u += [f({v0.(i)}, {v1.(i)})];\n         i += 1u;\n     }\n \n     ret u;\n }\n \n-fn find[T](fn (&T) -> bool f, &array[T] v) -> option::t[T] {\n+fn find[T](fn (&T) -> bool f, &vec[T] v) -> option::t[T] {\n     for (T elt in v) {\n         if (f(elt)) {\n             ret some[T](elt);"}]}