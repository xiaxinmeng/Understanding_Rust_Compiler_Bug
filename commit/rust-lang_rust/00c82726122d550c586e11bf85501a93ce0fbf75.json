{"sha": "00c82726122d550c586e11bf85501a93ce0fbf75", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwYzgyNzI2MTIyZDU1MGM1ODZlMTFiZjg1NTAxYTkzY2UwZmJmNzU=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-01-14T02:27:42Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-01-16T17:49:13Z"}, "message": "Split `librustc/traits/error_reporting.rs`", "tree": {"sha": "852697a485f9092cc60752341f7fd1608692a26b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/852697a485f9092cc60752341f7fd1608692a26b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00c82726122d550c586e11bf85501a93ce0fbf75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00c82726122d550c586e11bf85501a93ce0fbf75", "html_url": "https://github.com/rust-lang/rust/commit/00c82726122d550c586e11bf85501a93ce0fbf75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00c82726122d550c586e11bf85501a93ce0fbf75/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c13d2555c4535516eb00dd0221c9d158b91e31c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c13d2555c4535516eb00dd0221c9d158b91e31c", "html_url": "https://github.com/rust-lang/rust/commit/4c13d2555c4535516eb00dd0221c9d158b91e31c"}], "stats": {"total": 3198, "additions": 1667, "deletions": 1531}, "files": [{"sha": "f8329124851b0a3be7b19497e1971b878d4ffa0c", "filename": "src/librustc/traits/error_reporting/mod.rs", "status": "added", "additions": 1442, "deletions": 0, "changes": 1442, "blob_url": "https://github.com/rust-lang/rust/blob/00c82726122d550c586e11bf85501a93ce0fbf75/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c82726122d550c586e11bf85501a93ce0fbf75/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=00c82726122d550c586e11bf85501a93ce0fbf75", "patch": "@@ -0,0 +1,1442 @@\n+pub mod on_unimplemented;\n+pub mod suggestions;\n+\n+use super::{\n+    ConstEvalFailure, EvaluationResult, FulfillmentError, FulfillmentErrorCode,\n+    MismatchedProjectionTypes, ObjectSafetyViolation, Obligation, ObligationCause,\n+    ObligationCauseCode, OnUnimplementedDirective, OnUnimplementedNote,\n+    OutputTypeParameterMismatch, Overflow, PredicateObligation, SelectionContext, SelectionError,\n+    TraitNotObjectSafe,\n+};\n+\n+use crate::infer::error_reporting::{TyCategory, TypeAnnotationNeeded as ErrorCode};\n+use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use crate::infer::{self, InferCtxt};\n+use crate::mir::interpret::ErrorHandled;\n+use crate::session::DiagnosticMessageId;\n+use crate::traits::object_safety_violations;\n+use crate::ty::error::ExpectedFound;\n+use crate::ty::fast_reject;\n+use crate::ty::fold::TypeFolder;\n+use crate::ty::SubtypePredicate;\n+use crate::ty::{self, AdtKind, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable};\n+\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_hir as hir;\n+use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::intravisit::Visitor;\n+use rustc_span::source_map::SourceMap;\n+use rustc_span::{ExpnKind, Span, DUMMY_SP};\n+use std::fmt;\n+use syntax::ast;\n+\n+use rustc_error_codes::*;\n+\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    pub fn report_fulfillment_errors(\n+        &self,\n+        errors: &[FulfillmentError<'tcx>],\n+        body_id: Option<hir::BodyId>,\n+        fallback_has_occurred: bool,\n+    ) {\n+        #[derive(Debug)]\n+        struct ErrorDescriptor<'tcx> {\n+            predicate: ty::Predicate<'tcx>,\n+            index: Option<usize>, // None if this is an old error\n+        }\n+\n+        let mut error_map: FxHashMap<_, Vec<_>> = self\n+            .reported_trait_errors\n+            .borrow()\n+            .iter()\n+            .map(|(&span, predicates)| {\n+                (\n+                    span,\n+                    predicates\n+                        .iter()\n+                        .map(|predicate| ErrorDescriptor {\n+                            predicate: predicate.clone(),\n+                            index: None,\n+                        })\n+                        .collect(),\n+                )\n+            })\n+            .collect();\n+\n+        for (index, error) in errors.iter().enumerate() {\n+            // We want to ignore desugarings here: spans are equivalent even\n+            // if one is the result of a desugaring and the other is not.\n+            let mut span = error.obligation.cause.span;\n+            let expn_data = span.ctxt().outer_expn_data();\n+            if let ExpnKind::Desugaring(_) = expn_data.kind {\n+                span = expn_data.call_site;\n+            }\n+\n+            error_map.entry(span).or_default().push(ErrorDescriptor {\n+                predicate: error.obligation.predicate.clone(),\n+                index: Some(index),\n+            });\n+\n+            self.reported_trait_errors\n+                .borrow_mut()\n+                .entry(span)\n+                .or_default()\n+                .push(error.obligation.predicate.clone());\n+        }\n+\n+        // We do this in 2 passes because we want to display errors in order, though\n+        // maybe it *is* better to sort errors by span or something.\n+        let mut is_suppressed = vec![false; errors.len()];\n+        for (_, error_set) in error_map.iter() {\n+            // We want to suppress \"duplicate\" errors with the same span.\n+            for error in error_set {\n+                if let Some(index) = error.index {\n+                    // Suppress errors that are either:\n+                    // 1) strictly implied by another error.\n+                    // 2) implied by an error with a smaller index.\n+                    for error2 in error_set {\n+                        if error2.index.map_or(false, |index2| is_suppressed[index2]) {\n+                            // Avoid errors being suppressed by already-suppressed\n+                            // errors, to prevent all errors from being suppressed\n+                            // at once.\n+                            continue;\n+                        }\n+\n+                        if self.error_implies(&error2.predicate, &error.predicate)\n+                            && !(error2.index >= error.index\n+                                && self.error_implies(&error.predicate, &error2.predicate))\n+                        {\n+                            info!(\"skipping {:?} (implied by {:?})\", error, error2);\n+                            is_suppressed[index] = true;\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        for (error, suppressed) in errors.iter().zip(is_suppressed) {\n+            if !suppressed {\n+                self.report_fulfillment_error(error, body_id, fallback_has_occurred);\n+            }\n+        }\n+    }\n+\n+    // returns if `cond` not occurring implies that `error` does not occur - i.e., that\n+    // `error` occurring implies that `cond` occurs.\n+    fn error_implies(&self, cond: &ty::Predicate<'tcx>, error: &ty::Predicate<'tcx>) -> bool {\n+        if cond == error {\n+            return true;\n+        }\n+\n+        let (cond, error) = match (cond, error) {\n+            (&ty::Predicate::Trait(..), &ty::Predicate::Trait(ref error)) => (cond, error),\n+            _ => {\n+                // FIXME: make this work in other cases too.\n+                return false;\n+            }\n+        };\n+\n+        for implication in super::elaborate_predicates(self.tcx, vec![cond.clone()]) {\n+            if let ty::Predicate::Trait(implication) = implication {\n+                let error = error.to_poly_trait_ref();\n+                let implication = implication.to_poly_trait_ref();\n+                // FIXME: I'm just not taking associated types at all here.\n+                // Eventually I'll need to implement param-env-aware\n+                // `\u0393\u2081 \u22a6 \u03c6\u2081 => \u0393\u2082 \u22a6 \u03c6\u2082` logic.\n+                let param_env = ty::ParamEnv::empty();\n+                if self.can_sub(param_env, error, implication).is_ok() {\n+                    debug!(\"error_implies: {:?} -> {:?} -> {:?}\", cond, error, implication);\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        false\n+    }\n+\n+    fn report_fulfillment_error(\n+        &self,\n+        error: &FulfillmentError<'tcx>,\n+        body_id: Option<hir::BodyId>,\n+        fallback_has_occurred: bool,\n+    ) {\n+        debug!(\"report_fulfillment_error({:?})\", error);\n+        match error.code {\n+            FulfillmentErrorCode::CodeSelectionError(ref selection_error) => {\n+                self.report_selection_error(\n+                    &error.obligation,\n+                    selection_error,\n+                    fallback_has_occurred,\n+                    error.points_at_arg_span,\n+                );\n+            }\n+            FulfillmentErrorCode::CodeProjectionError(ref e) => {\n+                self.report_projection_error(&error.obligation, e);\n+            }\n+            FulfillmentErrorCode::CodeAmbiguity => {\n+                self.maybe_report_ambiguity(&error.obligation, body_id);\n+            }\n+            FulfillmentErrorCode::CodeSubtypeError(ref expected_found, ref err) => {\n+                self.report_mismatched_types(\n+                    &error.obligation.cause,\n+                    expected_found.expected,\n+                    expected_found.found,\n+                    err.clone(),\n+                )\n+                .emit();\n+            }\n+        }\n+    }\n+\n+    fn report_projection_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        error: &MismatchedProjectionTypes<'tcx>,\n+    ) {\n+        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n+\n+        if predicate.references_error() {\n+            return;\n+        }\n+\n+        self.probe(|_| {\n+            let err_buf;\n+            let mut err = &error.err;\n+            let mut values = None;\n+\n+            // try to find the mismatched types to report the error with.\n+            //\n+            // this can fail if the problem was higher-ranked, in which\n+            // cause I have no idea for a good error message.\n+            if let ty::Predicate::Projection(ref data) = predicate {\n+                let mut selcx = SelectionContext::new(self);\n+                let (data, _) = self.replace_bound_vars_with_fresh_vars(\n+                    obligation.cause.span,\n+                    infer::LateBoundRegionConversionTime::HigherRankedType,\n+                    data,\n+                );\n+                let mut obligations = vec![];\n+                let normalized_ty = super::normalize_projection_type(\n+                    &mut selcx,\n+                    obligation.param_env,\n+                    data.projection_ty,\n+                    obligation.cause.clone(),\n+                    0,\n+                    &mut obligations,\n+                );\n+\n+                debug!(\n+                    \"report_projection_error obligation.cause={:?} obligation.param_env={:?}\",\n+                    obligation.cause, obligation.param_env\n+                );\n+\n+                debug!(\n+                    \"report_projection_error normalized_ty={:?} data.ty={:?}\",\n+                    normalized_ty, data.ty\n+                );\n+\n+                let is_normalized_ty_expected = match &obligation.cause.code {\n+                    ObligationCauseCode::ItemObligation(_)\n+                    | ObligationCauseCode::BindingObligation(_, _)\n+                    | ObligationCauseCode::ObjectCastObligation(_) => false,\n+                    _ => true,\n+                };\n+\n+                if let Err(error) = self.at(&obligation.cause, obligation.param_env).eq_exp(\n+                    is_normalized_ty_expected,\n+                    normalized_ty,\n+                    data.ty,\n+                ) {\n+                    values = Some(infer::ValuePairs::Types(ExpectedFound::new(\n+                        is_normalized_ty_expected,\n+                        normalized_ty,\n+                        data.ty,\n+                    )));\n+\n+                    err_buf = error;\n+                    err = &err_buf;\n+                }\n+            }\n+\n+            let msg = format!(\"type mismatch resolving `{}`\", predicate);\n+            let error_id = (DiagnosticMessageId::ErrorId(271), Some(obligation.cause.span), msg);\n+            let fresh = self.tcx.sess.one_time_diagnostics.borrow_mut().insert(error_id);\n+            if fresh {\n+                let mut diag = struct_span_err!(\n+                    self.tcx.sess,\n+                    obligation.cause.span,\n+                    E0271,\n+                    \"type mismatch resolving `{}`\",\n+                    predicate\n+                );\n+                self.note_type_err(&mut diag, &obligation.cause, None, values, err);\n+                self.note_obligation_cause(&mut diag, obligation);\n+                diag.emit();\n+            }\n+        });\n+    }\n+\n+    fn fuzzy_match_tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n+        /// returns the fuzzy category of a given type, or None\n+        /// if the type can be equated to any type.\n+        fn type_category(t: Ty<'_>) -> Option<u32> {\n+            match t.kind {\n+                ty::Bool => Some(0),\n+                ty::Char => Some(1),\n+                ty::Str => Some(2),\n+                ty::Int(..) | ty::Uint(..) | ty::Infer(ty::IntVar(..)) => Some(3),\n+                ty::Float(..) | ty::Infer(ty::FloatVar(..)) => Some(4),\n+                ty::Ref(..) | ty::RawPtr(..) => Some(5),\n+                ty::Array(..) | ty::Slice(..) => Some(6),\n+                ty::FnDef(..) | ty::FnPtr(..) => Some(7),\n+                ty::Dynamic(..) => Some(8),\n+                ty::Closure(..) => Some(9),\n+                ty::Tuple(..) => Some(10),\n+                ty::Projection(..) => Some(11),\n+                ty::Param(..) => Some(12),\n+                ty::Opaque(..) => Some(13),\n+                ty::Never => Some(14),\n+                ty::Adt(adt, ..) => match adt.adt_kind() {\n+                    AdtKind::Struct => Some(15),\n+                    AdtKind::Union => Some(16),\n+                    AdtKind::Enum => Some(17),\n+                },\n+                ty::Generator(..) => Some(18),\n+                ty::Foreign(..) => Some(19),\n+                ty::GeneratorWitness(..) => Some(20),\n+                ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) | ty::Error => None,\n+                ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n+            }\n+        }\n+\n+        match (type_category(a), type_category(b)) {\n+            (Some(cat_a), Some(cat_b)) => match (&a.kind, &b.kind) {\n+                (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => def_a == def_b,\n+                _ => cat_a == cat_b,\n+            },\n+            // infer and error can be equated to all types\n+            _ => true,\n+        }\n+    }\n+\n+    fn describe_generator(&self, body_id: hir::BodyId) -> Option<&'static str> {\n+        self.tcx.hir().body(body_id).generator_kind.map(|gen_kind| match gen_kind {\n+            hir::GeneratorKind::Gen => \"a generator\",\n+            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block) => \"an async block\",\n+            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Fn) => \"an async function\",\n+            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Closure) => \"an async closure\",\n+        })\n+    }\n+\n+    fn find_similar_impl_candidates(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+    ) -> Vec<ty::TraitRef<'tcx>> {\n+        let simp = fast_reject::simplify_type(self.tcx, trait_ref.skip_binder().self_ty(), true);\n+        let all_impls = self.tcx.all_impls(trait_ref.def_id());\n+\n+        match simp {\n+            Some(simp) => all_impls\n+                .iter()\n+                .filter_map(|&def_id| {\n+                    let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n+                    let imp_simp = fast_reject::simplify_type(self.tcx, imp.self_ty(), true);\n+                    if let Some(imp_simp) = imp_simp {\n+                        if simp != imp_simp {\n+                            return None;\n+                        }\n+                    }\n+\n+                    Some(imp)\n+                })\n+                .collect(),\n+            None => {\n+                all_impls.iter().map(|&def_id| self.tcx.impl_trait_ref(def_id).unwrap()).collect()\n+            }\n+        }\n+    }\n+\n+    fn report_similar_impl_candidates(\n+        &self,\n+        impl_candidates: Vec<ty::TraitRef<'tcx>>,\n+        err: &mut DiagnosticBuilder<'_>,\n+    ) {\n+        if impl_candidates.is_empty() {\n+            return;\n+        }\n+\n+        let len = impl_candidates.len();\n+        let end = if impl_candidates.len() <= 5 { impl_candidates.len() } else { 4 };\n+\n+        let normalize = |candidate| {\n+            self.tcx.infer_ctxt().enter(|ref infcx| {\n+                let normalized = infcx\n+                    .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n+                    .normalize(candidate)\n+                    .ok();\n+                match normalized {\n+                    Some(normalized) => format!(\"\\n  {:?}\", normalized.value),\n+                    None => format!(\"\\n  {:?}\", candidate),\n+                }\n+            })\n+        };\n+\n+        // Sort impl candidates so that ordering is consistent for UI tests.\n+        let mut normalized_impl_candidates =\n+            impl_candidates.iter().map(normalize).collect::<Vec<String>>();\n+\n+        // Sort before taking the `..end` range,\n+        // because the ordering of `impl_candidates` may not be deterministic:\n+        // https://github.com/rust-lang/rust/pull/57475#issuecomment-455519507\n+        normalized_impl_candidates.sort();\n+\n+        err.help(&format!(\n+            \"the following implementations were found:{}{}\",\n+            normalized_impl_candidates[..end].join(\"\"),\n+            if len > 5 { format!(\"\\nand {} others\", len - 4) } else { String::new() }\n+        ));\n+    }\n+\n+    /// Reports that an overflow has occurred and halts compilation. We\n+    /// halt compilation unconditionally because it is important that\n+    /// overflows never be masked -- they basically represent computations\n+    /// whose result could not be truly determined and thus we can't say\n+    /// if the program type checks or not -- and they are unusual\n+    /// occurrences in any case.\n+    pub fn report_overflow_error<T>(\n+        &self,\n+        obligation: &Obligation<'tcx, T>,\n+        suggest_increasing_limit: bool,\n+    ) -> !\n+    where\n+        T: fmt::Display + TypeFoldable<'tcx>,\n+    {\n+        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            obligation.cause.span,\n+            E0275,\n+            \"overflow evaluating the requirement `{}`\",\n+            predicate\n+        );\n+\n+        if suggest_increasing_limit {\n+            self.suggest_new_overflow_limit(&mut err);\n+        }\n+\n+        self.note_obligation_cause_code(\n+            &mut err,\n+            &obligation.predicate,\n+            &obligation.cause.code,\n+            &mut vec![],\n+        );\n+\n+        err.emit();\n+        self.tcx.sess.abort_if_errors();\n+        bug!();\n+    }\n+\n+    /// Reports that a cycle was detected which led to overflow and halts\n+    /// compilation. This is equivalent to `report_overflow_error` except\n+    /// that we can give a more helpful error message (and, in particular,\n+    /// we do not suggest increasing the overflow limit, which is not\n+    /// going to help).\n+    pub fn report_overflow_error_cycle(&self, cycle: &[PredicateObligation<'tcx>]) -> ! {\n+        let cycle = self.resolve_vars_if_possible(&cycle.to_owned());\n+        assert!(cycle.len() > 0);\n+\n+        debug!(\"report_overflow_error_cycle: cycle={:?}\", cycle);\n+\n+        self.report_overflow_error(&cycle[0], false);\n+    }\n+\n+    pub fn report_extra_impl_obligation(\n+        &self,\n+        error_span: Span,\n+        item_name: ast::Name,\n+        _impl_item_def_id: DefId,\n+        trait_item_def_id: DefId,\n+        requirement: &dyn fmt::Display,\n+    ) -> DiagnosticBuilder<'tcx> {\n+        let msg = \"impl has stricter requirements than trait\";\n+        let sp = self.tcx.sess.source_map().def_span(error_span);\n+\n+        let mut err = struct_span_err!(self.tcx.sess, sp, E0276, \"{}\", msg);\n+\n+        if let Some(trait_item_span) = self.tcx.hir().span_if_local(trait_item_def_id) {\n+            let span = self.tcx.sess.source_map().def_span(trait_item_span);\n+            err.span_label(span, format!(\"definition of `{}` from trait\", item_name));\n+        }\n+\n+        err.span_label(sp, format!(\"impl has extra requirement {}\", requirement));\n+\n+        err\n+    }\n+\n+    /// Gets the parent trait chain start\n+    fn get_parent_trait_ref(\n+        &self,\n+        code: &ObligationCauseCode<'tcx>,\n+    ) -> Option<(String, Option<Span>)> {\n+        match code {\n+            &ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n+                let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n+                match self.get_parent_trait_ref(&data.parent_code) {\n+                    Some(t) => Some(t),\n+                    None => {\n+                        let ty = parent_trait_ref.skip_binder().self_ty();\n+                        let span =\n+                            TyCategory::from_ty(ty).map(|(_, def_id)| self.tcx.def_span(def_id));\n+                        Some((ty.to_string(), span))\n+                    }\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn report_selection_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        error: &SelectionError<'tcx>,\n+        fallback_has_occurred: bool,\n+        points_at_arg: bool,\n+    ) {\n+        let tcx = self.tcx;\n+        let span = obligation.cause.span;\n+\n+        let mut err = match *error {\n+            SelectionError::Unimplemented => {\n+                if let ObligationCauseCode::CompareImplMethodObligation {\n+                    item_name,\n+                    impl_item_def_id,\n+                    trait_item_def_id,\n+                }\n+                | ObligationCauseCode::CompareImplTypeObligation {\n+                    item_name,\n+                    impl_item_def_id,\n+                    trait_item_def_id,\n+                } = obligation.cause.code\n+                {\n+                    self.report_extra_impl_obligation(\n+                        span,\n+                        item_name,\n+                        impl_item_def_id,\n+                        trait_item_def_id,\n+                        &format!(\"`{}`\", obligation.predicate),\n+                    )\n+                    .emit();\n+                    return;\n+                }\n+                match obligation.predicate {\n+                    ty::Predicate::Trait(ref trait_predicate) => {\n+                        let trait_predicate = self.resolve_vars_if_possible(trait_predicate);\n+\n+                        if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n+                            return;\n+                        }\n+                        let trait_ref = trait_predicate.to_poly_trait_ref();\n+                        let (post_message, pre_message, type_def) = self\n+                            .get_parent_trait_ref(&obligation.cause.code)\n+                            .map(|(t, s)| {\n+                                (\n+                                    format!(\" in `{}`\", t),\n+                                    format!(\"within `{}`, \", t),\n+                                    s.map(|s| (format!(\"within this `{}`\", t), s)),\n+                                )\n+                            })\n+                            .unwrap_or_default();\n+\n+                        let OnUnimplementedNote { message, label, note, enclosing_scope } =\n+                            self.on_unimplemented_note(trait_ref, obligation);\n+                        let have_alt_message = message.is_some() || label.is_some();\n+                        let is_try = self\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .span_to_snippet(span)\n+                            .map(|s| &s == \"?\")\n+                            .unwrap_or(false);\n+                        let is_from = format!(\"{}\", trait_ref.print_only_trait_path())\n+                            .starts_with(\"std::convert::From<\");\n+                        let (message, note) = if is_try && is_from {\n+                            (\n+                                Some(format!(\n+                                    \"`?` couldn't convert the error to `{}`\",\n+                                    trait_ref.self_ty(),\n+                                )),\n+                                Some(\n+                                    \"the question mark operation (`?`) implicitly performs a \\\n+                                     conversion on the error value using the `From` trait\"\n+                                        .to_owned(),\n+                                ),\n+                            )\n+                        } else {\n+                            (message, note)\n+                        };\n+\n+                        let mut err = struct_span_err!(\n+                            self.tcx.sess,\n+                            span,\n+                            E0277,\n+                            \"{}\",\n+                            message.unwrap_or_else(|| format!(\n+                                \"the trait bound `{}` is not satisfied{}\",\n+                                trait_ref.to_predicate(),\n+                                post_message,\n+                            ))\n+                        );\n+\n+                        let explanation =\n+                            if obligation.cause.code == ObligationCauseCode::MainFunctionType {\n+                                \"consider using `()`, or a `Result`\".to_owned()\n+                            } else {\n+                                format!(\n+                                    \"{}the trait `{}` is not implemented for `{}`\",\n+                                    pre_message,\n+                                    trait_ref.print_only_trait_path(),\n+                                    trait_ref.self_ty(),\n+                                )\n+                            };\n+\n+                        if self.suggest_add_reference_to_arg(\n+                            &obligation,\n+                            &mut err,\n+                            &trait_ref,\n+                            points_at_arg,\n+                            have_alt_message,\n+                        ) {\n+                            self.note_obligation_cause(&mut err, obligation);\n+                            err.emit();\n+                            return;\n+                        }\n+                        if let Some(ref s) = label {\n+                            // If it has a custom `#[rustc_on_unimplemented]`\n+                            // error message, let's display it as the label!\n+                            err.span_label(span, s.as_str());\n+                            err.help(&explanation);\n+                        } else {\n+                            err.span_label(span, explanation);\n+                        }\n+                        if let Some((msg, span)) = type_def {\n+                            err.span_label(span, &msg);\n+                        }\n+                        if let Some(ref s) = note {\n+                            // If it has a custom `#[rustc_on_unimplemented]` note, let's display it\n+                            err.note(s.as_str());\n+                        }\n+                        if let Some(ref s) = enclosing_scope {\n+                            let enclosing_scope_span = tcx.def_span(\n+                                tcx.hir()\n+                                    .opt_local_def_id(obligation.cause.body_id)\n+                                    .unwrap_or_else(|| {\n+                                        tcx.hir().body_owner_def_id(hir::BodyId {\n+                                            hir_id: obligation.cause.body_id,\n+                                        })\n+                                    }),\n+                            );\n+\n+                            err.span_label(enclosing_scope_span, s.as_str());\n+                        }\n+\n+                        self.suggest_borrow_on_unsized_slice(&obligation.cause.code, &mut err);\n+                        self.suggest_fn_call(&obligation, &mut err, &trait_ref, points_at_arg);\n+                        self.suggest_remove_reference(&obligation, &mut err, &trait_ref);\n+                        self.suggest_semicolon_removal(&obligation, &mut err, span, &trait_ref);\n+                        self.note_version_mismatch(&mut err, &trait_ref);\n+                        if self.suggest_impl_trait(&mut err, span, &obligation, &trait_ref) {\n+                            err.emit();\n+                            return;\n+                        }\n+\n+                        // Try to report a help message\n+                        if !trait_ref.has_infer_types()\n+                            && self.predicate_can_apply(obligation.param_env, trait_ref)\n+                        {\n+                            // If a where-clause may be useful, remind the\n+                            // user that they can add it.\n+                            //\n+                            // don't display an on-unimplemented note, as\n+                            // these notes will often be of the form\n+                            //     \"the type `T` can't be frobnicated\"\n+                            // which is somewhat confusing.\n+                            self.suggest_restricting_param_bound(\n+                                &mut err,\n+                                &trait_ref,\n+                                obligation.cause.body_id,\n+                            );\n+                        } else {\n+                            if !have_alt_message {\n+                                // Can't show anything else useful, try to find similar impls.\n+                                let impl_candidates = self.find_similar_impl_candidates(trait_ref);\n+                                self.report_similar_impl_candidates(impl_candidates, &mut err);\n+                            }\n+                            self.suggest_change_mut(\n+                                &obligation,\n+                                &mut err,\n+                                &trait_ref,\n+                                points_at_arg,\n+                            );\n+                        }\n+\n+                        // If this error is due to `!: Trait` not implemented but `(): Trait` is\n+                        // implemented, and fallback has occurred, then it could be due to a\n+                        // variable that used to fallback to `()` now falling back to `!`. Issue a\n+                        // note informing about the change in behaviour.\n+                        if trait_predicate.skip_binder().self_ty().is_never()\n+                            && fallback_has_occurred\n+                        {\n+                            let predicate = trait_predicate.map_bound(|mut trait_pred| {\n+                                trait_pred.trait_ref.substs = self.tcx.mk_substs_trait(\n+                                    self.tcx.mk_unit(),\n+                                    &trait_pred.trait_ref.substs[1..],\n+                                );\n+                                trait_pred\n+                            });\n+                            let unit_obligation = Obligation {\n+                                predicate: ty::Predicate::Trait(predicate),\n+                                ..obligation.clone()\n+                            };\n+                            if self.predicate_may_hold(&unit_obligation) {\n+                                err.note(\n+                                    \"the trait is implemented for `()`. \\\n+                                         Possibly this error has been caused by changes to \\\n+                                         Rust's type-inference algorithm \\\n+                                         (see: https://github.com/rust-lang/rust/issues/48950 \\\n+                                         for more info). Consider whether you meant to use the \\\n+                                         type `()` here instead.\",\n+                                );\n+                            }\n+                        }\n+\n+                        err\n+                    }\n+\n+                    ty::Predicate::Subtype(ref predicate) => {\n+                        // Errors for Subtype predicates show up as\n+                        // `FulfillmentErrorCode::CodeSubtypeError`,\n+                        // not selection error.\n+                        span_bug!(span, \"subtype requirement gave wrong error: `{:?}`\", predicate)\n+                    }\n+\n+                    ty::Predicate::RegionOutlives(ref predicate) => {\n+                        let predicate = self.resolve_vars_if_possible(predicate);\n+                        let err = self\n+                            .region_outlives_predicate(&obligation.cause, &predicate)\n+                            .err()\n+                            .unwrap();\n+                        struct_span_err!(\n+                            self.tcx.sess,\n+                            span,\n+                            E0279,\n+                            \"the requirement `{}` is not satisfied (`{}`)\",\n+                            predicate,\n+                            err,\n+                        )\n+                    }\n+\n+                    ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n+                        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n+                        struct_span_err!(\n+                            self.tcx.sess,\n+                            span,\n+                            E0280,\n+                            \"the requirement `{}` is not satisfied\",\n+                            predicate\n+                        )\n+                    }\n+\n+                    ty::Predicate::ObjectSafe(trait_def_id) => {\n+                        let violations = object_safety_violations(self.tcx, trait_def_id);\n+                        report_object_safety_error(self.tcx, span, trait_def_id, violations)\n+                    }\n+\n+                    ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n+                        let found_kind = self.closure_kind(closure_def_id, closure_substs).unwrap();\n+                        let closure_span = self\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .def_span(self.tcx.hir().span_if_local(closure_def_id).unwrap());\n+                        let hir_id = self.tcx.hir().as_local_hir_id(closure_def_id).unwrap();\n+                        let mut err = struct_span_err!(\n+                            self.tcx.sess,\n+                            closure_span,\n+                            E0525,\n+                            \"expected a closure that implements the `{}` trait, \\\n+                             but this closure only implements `{}`\",\n+                            kind,\n+                            found_kind\n+                        );\n+\n+                        err.span_label(\n+                            closure_span,\n+                            format!(\"this closure implements `{}`, not `{}`\", found_kind, kind),\n+                        );\n+                        err.span_label(\n+                            obligation.cause.span,\n+                            format!(\"the requirement to implement `{}` derives from here\", kind),\n+                        );\n+\n+                        // Additional context information explaining why the closure only implements\n+                        // a particular trait.\n+                        if let Some(tables) = self.in_progress_tables {\n+                            let tables = tables.borrow();\n+                            match (found_kind, tables.closure_kind_origins().get(hir_id)) {\n+                                (ty::ClosureKind::FnOnce, Some((span, name))) => {\n+                                    err.span_label(\n+                                        *span,\n+                                        format!(\n+                                            \"closure is `FnOnce` because it moves the \\\n+                                         variable `{}` out of its environment\",\n+                                            name\n+                                        ),\n+                                    );\n+                                }\n+                                (ty::ClosureKind::FnMut, Some((span, name))) => {\n+                                    err.span_label(\n+                                        *span,\n+                                        format!(\n+                                            \"closure is `FnMut` because it mutates the \\\n+                                         variable `{}` here\",\n+                                            name\n+                                        ),\n+                                    );\n+                                }\n+                                _ => {}\n+                            }\n+                        }\n+\n+                        err.emit();\n+                        return;\n+                    }\n+\n+                    ty::Predicate::WellFormed(ty) => {\n+                        if !self.tcx.sess.opts.debugging_opts.chalk {\n+                            // WF predicates cannot themselves make\n+                            // errors. They can only block due to\n+                            // ambiguity; otherwise, they always\n+                            // degenerate into other obligations\n+                            // (which may fail).\n+                            span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n+                        } else {\n+                            // FIXME: we'll need a better message which takes into account\n+                            // which bounds actually failed to hold.\n+                            self.tcx.sess.struct_span_err(\n+                                span,\n+                                &format!(\"the type `{}` is not well-formed (chalk)\", ty),\n+                            )\n+                        }\n+                    }\n+\n+                    ty::Predicate::ConstEvaluatable(..) => {\n+                        // Errors for `ConstEvaluatable` predicates show up as\n+                        // `SelectionError::ConstEvalFailure`,\n+                        // not `Unimplemented`.\n+                        span_bug!(\n+                            span,\n+                            \"const-evaluatable requirement gave wrong error: `{:?}`\",\n+                            obligation\n+                        )\n+                    }\n+                }\n+            }\n+\n+            OutputTypeParameterMismatch(ref found_trait_ref, ref expected_trait_ref, _) => {\n+                let found_trait_ref = self.resolve_vars_if_possible(&*found_trait_ref);\n+                let expected_trait_ref = self.resolve_vars_if_possible(&*expected_trait_ref);\n+\n+                if expected_trait_ref.self_ty().references_error() {\n+                    return;\n+                }\n+\n+                let found_trait_ty = found_trait_ref.self_ty();\n+\n+                let found_did = match found_trait_ty.kind {\n+                    ty::Closure(did, _) | ty::Foreign(did) | ty::FnDef(did, _) => Some(did),\n+                    ty::Adt(def, _) => Some(def.did),\n+                    _ => None,\n+                };\n+\n+                let found_span = found_did\n+                    .and_then(|did| self.tcx.hir().span_if_local(did))\n+                    .map(|sp| self.tcx.sess.source_map().def_span(sp)); // the sp could be an fn def\n+\n+                if self.reported_closure_mismatch.borrow().contains(&(span, found_span)) {\n+                    // We check closures twice, with obligations flowing in different directions,\n+                    // but we want to complain about them only once.\n+                    return;\n+                }\n+\n+                self.reported_closure_mismatch.borrow_mut().insert((span, found_span));\n+\n+                let found = match found_trait_ref.skip_binder().substs.type_at(1).kind {\n+                    ty::Tuple(ref tys) => vec![ArgKind::empty(); tys.len()],\n+                    _ => vec![ArgKind::empty()],\n+                };\n+\n+                let expected_ty = expected_trait_ref.skip_binder().substs.type_at(1);\n+                let expected = match expected_ty.kind {\n+                    ty::Tuple(ref tys) => tys\n+                        .iter()\n+                        .map(|t| ArgKind::from_expected_ty(t.expect_ty(), Some(span)))\n+                        .collect(),\n+                    _ => vec![ArgKind::Arg(\"_\".to_owned(), expected_ty.to_string())],\n+                };\n+\n+                if found.len() == expected.len() {\n+                    self.report_closure_arg_mismatch(\n+                        span,\n+                        found_span,\n+                        found_trait_ref,\n+                        expected_trait_ref,\n+                    )\n+                } else {\n+                    let (closure_span, found) = found_did\n+                        .and_then(|did| self.tcx.hir().get_if_local(did))\n+                        .map(|node| {\n+                            let (found_span, found) = self.get_fn_like_arguments(node);\n+                            (Some(found_span), found)\n+                        })\n+                        .unwrap_or((found_span, found));\n+\n+                    self.report_arg_count_mismatch(\n+                        span,\n+                        closure_span,\n+                        expected,\n+                        found,\n+                        found_trait_ty.is_closure(),\n+                    )\n+                }\n+            }\n+\n+            TraitNotObjectSafe(did) => {\n+                let violations = object_safety_violations(self.tcx, did);\n+                report_object_safety_error(self.tcx, span, did, violations)\n+            }\n+\n+            // already reported in the query\n+            ConstEvalFailure(err) => {\n+                if let ErrorHandled::TooGeneric = err {\n+                    // Silence this error, as it can be produced during intermediate steps\n+                    // when a constant is not yet able to be evaluated (but will be later).\n+                    return;\n+                }\n+                self.tcx.sess.delay_span_bug(\n+                    span,\n+                    &format!(\"constant in type had an ignored error: {:?}\", err),\n+                );\n+                return;\n+            }\n+\n+            Overflow => {\n+                bug!(\"overflow should be handled before the `report_selection_error` path\");\n+            }\n+        };\n+\n+        self.note_obligation_cause(&mut err, obligation);\n+        self.point_at_returns_when_relevant(&mut err, &obligation);\n+\n+        err.emit();\n+    }\n+\n+    /// If the `Self` type of the unsatisfied trait `trait_ref` implements a trait\n+    /// with the same path as `trait_ref`, a help message about\n+    /// a probable version mismatch is added to `err`\n+    fn note_version_mismatch(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        trait_ref: &ty::PolyTraitRef<'tcx>,\n+    ) {\n+        let get_trait_impl = |trait_def_id| {\n+            let mut trait_impl = None;\n+            self.tcx.for_each_relevant_impl(trait_def_id, trait_ref.self_ty(), |impl_def_id| {\n+                if trait_impl.is_none() {\n+                    trait_impl = Some(impl_def_id);\n+                }\n+            });\n+            trait_impl\n+        };\n+        let required_trait_path = self.tcx.def_path_str(trait_ref.def_id());\n+        let all_traits = self.tcx.all_traits(LOCAL_CRATE);\n+        let traits_with_same_path: std::collections::BTreeSet<_> = all_traits\n+            .iter()\n+            .filter(|trait_def_id| **trait_def_id != trait_ref.def_id())\n+            .filter(|trait_def_id| self.tcx.def_path_str(**trait_def_id) == required_trait_path)\n+            .collect();\n+        for trait_with_same_path in traits_with_same_path {\n+            if let Some(impl_def_id) = get_trait_impl(*trait_with_same_path) {\n+                let impl_span = self.tcx.def_span(impl_def_id);\n+                err.span_help(impl_span, \"trait impl with same name found\");\n+                let trait_crate = self.tcx.crate_name(trait_with_same_path.krate);\n+                let crate_msg = format!(\n+                    \"perhaps two different versions of crate `{}` are being used?\",\n+                    trait_crate\n+                );\n+                err.note(&crate_msg);\n+            }\n+        }\n+    }\n+\n+    fn mk_obligation_for_def_id(\n+        &self,\n+        def_id: DefId,\n+        output_ty: Ty<'tcx>,\n+        cause: ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> PredicateObligation<'tcx> {\n+        let new_trait_ref =\n+            ty::TraitRef { def_id, substs: self.tcx.mk_substs_trait(output_ty, &[]) };\n+        Obligation::new(cause, param_env, new_trait_ref.to_predicate())\n+    }\n+}\n+\n+pub fn recursive_type_with_infinite_size_error(\n+    tcx: TyCtxt<'tcx>,\n+    type_def_id: DefId,\n+) -> DiagnosticBuilder<'tcx> {\n+    assert!(type_def_id.is_local());\n+    let span = tcx.hir().span_if_local(type_def_id).unwrap();\n+    let span = tcx.sess.source_map().def_span(span);\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        span,\n+        E0072,\n+        \"recursive type `{}` has infinite size\",\n+        tcx.def_path_str(type_def_id)\n+    );\n+    err.span_label(span, \"recursive type has infinite size\");\n+    err.help(&format!(\n+        \"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n+                           at some point to make `{}` representable\",\n+        tcx.def_path_str(type_def_id)\n+    ));\n+    err\n+}\n+\n+pub fn report_object_safety_error(\n+    tcx: TyCtxt<'tcx>,\n+    span: Span,\n+    trait_def_id: DefId,\n+    violations: Vec<ObjectSafetyViolation>,\n+) -> DiagnosticBuilder<'tcx> {\n+    let trait_str = tcx.def_path_str(trait_def_id);\n+    let span = tcx.sess.source_map().def_span(span);\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        span,\n+        E0038,\n+        \"the trait `{}` cannot be made into an object\",\n+        trait_str\n+    );\n+    err.span_label(span, format!(\"the trait `{}` cannot be made into an object\", trait_str));\n+\n+    let mut reported_violations = FxHashSet::default();\n+    for violation in violations {\n+        if reported_violations.insert(violation.clone()) {\n+            match violation.span() {\n+                Some(span) => err.span_label(span, violation.error_msg()),\n+                None => err.note(&violation.error_msg()),\n+            };\n+        }\n+    }\n+\n+    if tcx.sess.trait_methods_not_found.borrow().contains(&span) {\n+        // Avoid emitting error caused by non-existing method (#58734)\n+        err.cancel();\n+    }\n+\n+    err\n+}\n+\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    fn maybe_report_ambiguity(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        body_id: Option<hir::BodyId>,\n+    ) {\n+        // Unable to successfully determine, probably means\n+        // insufficient type information, but could mean\n+        // ambiguous impls. The latter *ought* to be a\n+        // coherence violation, so we don't report it here.\n+\n+        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n+        let span = obligation.cause.span;\n+\n+        debug!(\n+            \"maybe_report_ambiguity(predicate={:?}, obligation={:?} body_id={:?}, code={:?})\",\n+            predicate, obligation, body_id, obligation.cause.code,\n+        );\n+\n+        // Ambiguity errors are often caused as fallout from earlier\n+        // errors. So just ignore them if this infcx is tainted.\n+        if self.is_tainted_by_errors() {\n+            return;\n+        }\n+\n+        let mut err = match predicate {\n+            ty::Predicate::Trait(ref data) => {\n+                let trait_ref = data.to_poly_trait_ref();\n+                let self_ty = trait_ref.self_ty();\n+                debug!(\"self_ty {:?} {:?} trait_ref {:?}\", self_ty, self_ty.kind, trait_ref);\n+\n+                if predicate.references_error() {\n+                    return;\n+                }\n+                // Typically, this ambiguity should only happen if\n+                // there are unresolved type inference variables\n+                // (otherwise it would suggest a coherence\n+                // failure). But given #21974 that is not necessarily\n+                // the case -- we can have multiple where clauses that\n+                // are only distinguished by a region, which results\n+                // in an ambiguity even when all types are fully\n+                // known, since we don't dispatch based on region\n+                // relationships.\n+\n+                // This is kind of a hack: it frequently happens that some earlier\n+                // error prevents types from being fully inferred, and then we get\n+                // a bunch of uninteresting errors saying something like \"<generic\n+                // #0> doesn't implement Sized\".  It may even be true that we\n+                // could just skip over all checks where the self-ty is an\n+                // inference variable, but I was afraid that there might be an\n+                // inference variable created, registered as an obligation, and\n+                // then never forced by writeback, and hence by skipping here we'd\n+                // be ignoring the fact that we don't KNOW the type works\n+                // out. Though even that would probably be harmless, given that\n+                // we're only talking about builtin traits, which are known to be\n+                // inhabited. We used to check for `self.tcx.sess.has_errors()` to\n+                // avoid inundating the user with unnecessary errors, but we now\n+                // check upstream for type errors and dont add the obligations to\n+                // begin with in those cases.\n+                if self\n+                    .tcx\n+                    .lang_items()\n+                    .sized_trait()\n+                    .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n+                {\n+                    self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0282).emit();\n+                    return;\n+                }\n+                let mut err = self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0283);\n+                err.note(&format!(\"cannot resolve `{}`\", predicate));\n+                if let ObligationCauseCode::ItemObligation(def_id) = obligation.cause.code {\n+                    self.suggest_fully_qualified_path(&mut err, def_id, span, trait_ref.def_id());\n+                } else if let (\n+                    Ok(ref snippet),\n+                    ObligationCauseCode::BindingObligation(ref def_id, _),\n+                ) =\n+                    (self.tcx.sess.source_map().span_to_snippet(span), &obligation.cause.code)\n+                {\n+                    let generics = self.tcx.generics_of(*def_id);\n+                    if !generics.params.is_empty() && !snippet.ends_with('>') {\n+                        // FIXME: To avoid spurious suggestions in functions where type arguments\n+                        // where already supplied, we check the snippet to make sure it doesn't\n+                        // end with a turbofish. Ideally we would have access to a `PathSegment`\n+                        // instead. Otherwise we would produce the following output:\n+                        //\n+                        // error[E0283]: type annotations needed\n+                        //   --> $DIR/issue-54954.rs:3:24\n+                        //    |\n+                        // LL | const ARR_LEN: usize = Tt::const_val::<[i8; 123]>();\n+                        //    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+                        //    |                        |\n+                        //    |                        cannot infer type\n+                        //    |                        help: consider specifying the type argument\n+                        //    |                        in the function call:\n+                        //    |                        `Tt::const_val::<[i8; 123]>::<T>`\n+                        // ...\n+                        // LL |     const fn const_val<T: Sized>() -> usize {\n+                        //    |              --------- - required by this bound in `Tt::const_val`\n+                        //    |\n+                        //    = note: cannot resolve `_: Tt`\n+\n+                        err.span_suggestion(\n+                            span,\n+                            &format!(\n+                                \"consider specifying the type argument{} in the function call\",\n+                                if generics.params.len() > 1 { \"s\" } else { \"\" },\n+                            ),\n+                            format!(\n+                                \"{}::<{}>\",\n+                                snippet,\n+                                generics\n+                                    .params\n+                                    .iter()\n+                                    .map(|p| p.name.to_string())\n+                                    .collect::<Vec<String>>()\n+                                    .join(\", \")\n+                            ),\n+                            Applicability::HasPlaceholders,\n+                        );\n+                    }\n+                }\n+                err\n+            }\n+\n+            ty::Predicate::WellFormed(ty) => {\n+                // Same hacky approach as above to avoid deluging user\n+                // with error messages.\n+                if ty.references_error() || self.tcx.sess.has_errors() {\n+                    return;\n+                }\n+                self.need_type_info_err(body_id, span, ty, ErrorCode::E0282)\n+            }\n+\n+            ty::Predicate::Subtype(ref data) => {\n+                if data.references_error() || self.tcx.sess.has_errors() {\n+                    // no need to overload user in such cases\n+                    return;\n+                }\n+                let &SubtypePredicate { a_is_expected: _, a, b } = data.skip_binder();\n+                // both must be type variables, or the other would've been instantiated\n+                assert!(a.is_ty_var() && b.is_ty_var());\n+                self.need_type_info_err(body_id, span, a, ErrorCode::E0282)\n+            }\n+            ty::Predicate::Projection(ref data) => {\n+                let trait_ref = data.to_poly_trait_ref(self.tcx);\n+                let self_ty = trait_ref.self_ty();\n+                if predicate.references_error() {\n+                    return;\n+                }\n+                let mut err = self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0284);\n+                err.note(&format!(\"cannot resolve `{}`\", predicate));\n+                err\n+            }\n+\n+            _ => {\n+                if self.tcx.sess.has_errors() {\n+                    return;\n+                }\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0284,\n+                    \"type annotations needed: cannot resolve `{}`\",\n+                    predicate,\n+                );\n+                err.span_label(span, &format!(\"cannot resolve `{}`\", predicate));\n+                err\n+            }\n+        };\n+        self.note_obligation_cause(&mut err, obligation);\n+        err.emit();\n+    }\n+\n+    /// Returns `true` if the trait predicate may apply for *some* assignment\n+    /// to the type parameters.\n+    fn predicate_can_apply(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        pred: ty::PolyTraitRef<'tcx>,\n+    ) -> bool {\n+        struct ParamToVarFolder<'a, 'tcx> {\n+            infcx: &'a InferCtxt<'a, 'tcx>,\n+            var_map: FxHashMap<Ty<'tcx>, Ty<'tcx>>,\n+        }\n+\n+        impl<'a, 'tcx> TypeFolder<'tcx> for ParamToVarFolder<'a, 'tcx> {\n+            fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n+                self.infcx.tcx\n+            }\n+\n+            fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+                if let ty::Param(ty::ParamTy { name, .. }) = ty.kind {\n+                    let infcx = self.infcx;\n+                    self.var_map.entry(ty).or_insert_with(|| {\n+                        infcx.next_ty_var(TypeVariableOrigin {\n+                            kind: TypeVariableOriginKind::TypeParameterDefinition(name, None),\n+                            span: DUMMY_SP,\n+                        })\n+                    })\n+                } else {\n+                    ty.super_fold_with(self)\n+                }\n+            }\n+        }\n+\n+        self.probe(|_| {\n+            let mut selcx = SelectionContext::new(self);\n+\n+            let cleaned_pred =\n+                pred.fold_with(&mut ParamToVarFolder { infcx: self, var_map: Default::default() });\n+\n+            let cleaned_pred = super::project::normalize(\n+                &mut selcx,\n+                param_env,\n+                ObligationCause::dummy(),\n+                &cleaned_pred,\n+            )\n+            .value;\n+\n+            let obligation =\n+                Obligation::new(ObligationCause::dummy(), param_env, cleaned_pred.to_predicate());\n+\n+            self.predicate_may_hold(&obligation)\n+        })\n+    }\n+\n+    fn note_obligation_cause(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) {\n+        // First, attempt to add note to this error with an async-await-specific\n+        // message, and fall back to regular note otherwise.\n+        if !self.maybe_note_obligation_cause_for_async_await(err, obligation) {\n+            self.note_obligation_cause_code(\n+                err,\n+                &obligation.predicate,\n+                &obligation.cause.code,\n+                &mut vec![],\n+            );\n+        }\n+    }\n+\n+    fn is_recursive_obligation(\n+        &self,\n+        obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n+        cause_code: &ObligationCauseCode<'tcx>,\n+    ) -> bool {\n+        if let ObligationCauseCode::BuiltinDerivedObligation(ref data) = cause_code {\n+            let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n+\n+            if obligated_types.iter().any(|ot| ot == &parent_trait_ref.skip_binder().self_ty()) {\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+}\n+\n+/// Summarizes information\n+#[derive(Clone)]\n+pub enum ArgKind {\n+    /// An argument of non-tuple type. Parameters are (name, ty)\n+    Arg(String, String),\n+\n+    /// An argument of tuple type. For a \"found\" argument, the span is\n+    /// the locationo in the source of the pattern. For a \"expected\"\n+    /// argument, it will be None. The vector is a list of (name, ty)\n+    /// strings for the components of the tuple.\n+    Tuple(Option<Span>, Vec<(String, String)>),\n+}\n+\n+impl ArgKind {\n+    fn empty() -> ArgKind {\n+        ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned())\n+    }\n+\n+    /// Creates an `ArgKind` from the expected type of an\n+    /// argument. It has no name (`_`) and an optional source span.\n+    pub fn from_expected_ty(t: Ty<'_>, span: Option<Span>) -> ArgKind {\n+        match t.kind {\n+            ty::Tuple(ref tys) => ArgKind::Tuple(\n+                span,\n+                tys.iter().map(|ty| (\"_\".to_owned(), ty.to_string())).collect::<Vec<_>>(),\n+            ),\n+            _ => ArgKind::Arg(\"_\".to_owned(), t.to_string()),\n+        }\n+    }\n+}\n+\n+/// Suggest restricting a type param with a new bound.\n+pub fn suggest_constraining_type_param(\n+    generics: &hir::Generics<'_>,\n+    err: &mut DiagnosticBuilder<'_>,\n+    param_name: &str,\n+    constraint: &str,\n+    source_map: &SourceMap,\n+    span: Span,\n+) -> bool {\n+    let restrict_msg = \"consider further restricting this bound\";\n+    if let Some(param) =\n+        generics.params.iter().filter(|p| p.name.ident().as_str() == param_name).next()\n+    {\n+        if param_name.starts_with(\"impl \") {\n+            // `impl Trait` in argument:\n+            // `fn foo(x: impl Trait) {}` \u2192 `fn foo(t: impl Trait + Trait2) {}`\n+            err.span_suggestion(\n+                param.span,\n+                restrict_msg,\n+                // `impl CurrentTrait + MissingTrait`\n+                format!(\"{} + {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if generics.where_clause.predicates.is_empty() && param.bounds.is_empty() {\n+            // If there are no bounds whatsoever, suggest adding a constraint\n+            // to the type parameter:\n+            // `fn foo<T>(t: T) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n+            err.span_suggestion(\n+                param.span,\n+                \"consider restricting this bound\",\n+                format!(\"{}: {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if !generics.where_clause.predicates.is_empty() {\n+            // There is a `where` clause, so suggest expanding it:\n+            // `fn foo<T>(t: T) where T: Debug {}` \u2192\n+            // `fn foo<T>(t: T) where T: Debug, T: Trait {}`\n+            err.span_suggestion(\n+                generics.where_clause.span().unwrap().shrink_to_hi(),\n+                &format!(\"consider further restricting type parameter `{}`\", param_name),\n+                format!(\", {}: {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else {\n+            // If there is no `where` clause lean towards constraining to the\n+            // type parameter:\n+            // `fn foo<X: Bar, T>(t: T, x: X) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n+            // `fn foo<T: Bar>(t: T) {}` \u2192 `fn foo<T: Bar + Trait>(t: T) {}`\n+            let sp = param.span.with_hi(span.hi());\n+            let span = source_map.span_through_char(sp, ':');\n+            if sp != param.span && sp != span {\n+                // Only suggest if we have high certainty that the span\n+                // covers the colon in `foo<T: Trait>`.\n+                err.span_suggestion(\n+                    span,\n+                    restrict_msg,\n+                    format!(\"{}: {} + \", param_name, constraint),\n+                    Applicability::MachineApplicable,\n+                );\n+            } else {\n+                err.span_label(\n+                    param.span,\n+                    &format!(\"consider adding a `where {}: {}` bound\", param_name, constraint),\n+                );\n+            }\n+        }\n+        return true;\n+    }\n+    false\n+}\n+\n+struct ReturnsVisitor<'v>(Vec<&'v hir::Expr<'v>>);\n+\n+impl<'v> Visitor<'v> for ReturnsVisitor<'v> {\n+    type Map = rustc::hir::map::Map<'v>;\n+\n+    fn nested_visit_map(&mut self) -> hir::intravisit::NestedVisitorMap<'_, Self::Map> {\n+        hir::intravisit::NestedVisitorMap::None\n+    }\n+\n+    fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n+        match ex.kind {\n+            hir::ExprKind::Ret(Some(ex)) => self.0.push(ex),\n+            _ => {}\n+        }\n+        hir::intravisit::walk_expr(self, ex);\n+    }\n+\n+    fn visit_body(&mut self, body: &'v hir::Body<'v>) {\n+        if body.generator_kind().is_none() {\n+            if let hir::ExprKind::Block(block, None) = body.value.kind {\n+                if let Some(expr) = block.expr {\n+                    self.0.push(expr);\n+                }\n+            }\n+        }\n+        hir::intravisit::walk_body(self, body);\n+    }\n+}"}, {"sha": "9f3fc91548b218e4c5378f0a31ec8fe559396172", "filename": "src/librustc/traits/error_reporting/on_unimplemented.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/00c82726122d550c586e11bf85501a93ce0fbf75/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c82726122d550c586e11bf85501a93ce0fbf75/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=00c82726122d550c586e11bf85501a93ce0fbf75", "patch": "@@ -0,0 +1,199 @@\n+use super::{\n+    ObligationCauseCode, OnUnimplementedDirective, OnUnimplementedNote, PredicateObligation,\n+};\n+use crate::infer::InferCtxt;\n+use crate::ty::subst::Subst;\n+use crate::ty::{self, GenericParamDefKind};\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_span::symbol::sym;\n+\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    fn impl_similar_to(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> Option<DefId> {\n+        let tcx = self.tcx;\n+        let param_env = obligation.param_env;\n+        let trait_ref = tcx.erase_late_bound_regions(&trait_ref);\n+        let trait_self_ty = trait_ref.self_ty();\n+\n+        let mut self_match_impls = vec![];\n+        let mut fuzzy_match_impls = vec![];\n+\n+        self.tcx.for_each_relevant_impl(trait_ref.def_id, trait_self_ty, |def_id| {\n+            let impl_substs = self.fresh_substs_for_item(obligation.cause.span, def_id);\n+            let impl_trait_ref = tcx.impl_trait_ref(def_id).unwrap().subst(tcx, impl_substs);\n+\n+            let impl_self_ty = impl_trait_ref.self_ty();\n+\n+            if let Ok(..) = self.can_eq(param_env, trait_self_ty, impl_self_ty) {\n+                self_match_impls.push(def_id);\n+\n+                if trait_ref\n+                    .substs\n+                    .types()\n+                    .skip(1)\n+                    .zip(impl_trait_ref.substs.types().skip(1))\n+                    .all(|(u, v)| self.fuzzy_match_tys(u, v))\n+                {\n+                    fuzzy_match_impls.push(def_id);\n+                }\n+            }\n+        });\n+\n+        let impl_def_id = if self_match_impls.len() == 1 {\n+            self_match_impls[0]\n+        } else if fuzzy_match_impls.len() == 1 {\n+            fuzzy_match_impls[0]\n+        } else {\n+            return None;\n+        };\n+\n+        tcx.has_attr(impl_def_id, sym::rustc_on_unimplemented).then_some(impl_def_id)\n+    }\n+\n+    /// Used to set on_unimplemented's `ItemContext`\n+    /// to be the enclosing (async) block/function/closure\n+    fn describe_enclosure(&self, hir_id: hir::HirId) -> Option<&'static str> {\n+        let hir = &self.tcx.hir();\n+        let node = hir.find(hir_id)?;\n+        if let hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(sig, _, body_id), .. }) = &node {\n+            self.describe_generator(*body_id).or_else(|| {\n+                Some(if let hir::FnHeader { asyncness: hir::IsAsync::Async, .. } = sig.header {\n+                    \"an async function\"\n+                } else {\n+                    \"a function\"\n+                })\n+            })\n+        } else if let hir::Node::Expr(hir::Expr {\n+            kind: hir::ExprKind::Closure(_is_move, _, body_id, _, gen_movability),\n+            ..\n+        }) = &node\n+        {\n+            self.describe_generator(*body_id).or_else(|| {\n+                Some(if gen_movability.is_some() { \"an async closure\" } else { \"a closure\" })\n+            })\n+        } else if let hir::Node::Expr(hir::Expr { .. }) = &node {\n+            let parent_hid = hir.get_parent_node(hir_id);\n+            if parent_hid != hir_id {\n+                return self.describe_enclosure(parent_hid);\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    crate fn on_unimplemented_note(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> OnUnimplementedNote {\n+        let def_id =\n+            self.impl_similar_to(trait_ref, obligation).unwrap_or_else(|| trait_ref.def_id());\n+        let trait_ref = *trait_ref.skip_binder();\n+\n+        let mut flags = vec![];\n+        flags.push((\n+            sym::item_context,\n+            self.describe_enclosure(obligation.cause.body_id).map(|s| s.to_owned()),\n+        ));\n+\n+        match obligation.cause.code {\n+            ObligationCauseCode::BuiltinDerivedObligation(..)\n+            | ObligationCauseCode::ImplDerivedObligation(..) => {}\n+            _ => {\n+                // this is a \"direct\", user-specified, rather than derived,\n+                // obligation.\n+                flags.push((sym::direct, None));\n+            }\n+        }\n+\n+        if let ObligationCauseCode::ItemObligation(item) = obligation.cause.code {\n+            // FIXME: maybe also have some way of handling methods\n+            // from other traits? That would require name resolution,\n+            // which we might want to be some sort of hygienic.\n+            //\n+            // Currently I'm leaving it for what I need for `try`.\n+            if self.tcx.trait_of_item(item) == Some(trait_ref.def_id) {\n+                let method = self.tcx.item_name(item);\n+                flags.push((sym::from_method, None));\n+                flags.push((sym::from_method, Some(method.to_string())));\n+            }\n+        }\n+        if let Some((t, _)) = self.get_parent_trait_ref(&obligation.cause.code) {\n+            flags.push((sym::parent_trait, Some(t)));\n+        }\n+\n+        if let Some(k) = obligation.cause.span.desugaring_kind() {\n+            flags.push((sym::from_desugaring, None));\n+            flags.push((sym::from_desugaring, Some(format!(\"{:?}\", k))));\n+        }\n+        let generics = self.tcx.generics_of(def_id);\n+        let self_ty = trait_ref.self_ty();\n+        // This is also included through the generics list as `Self`,\n+        // but the parser won't allow you to use it\n+        flags.push((sym::_Self, Some(self_ty.to_string())));\n+        if let Some(def) = self_ty.ty_adt_def() {\n+            // We also want to be able to select self's original\n+            // signature with no type arguments resolved\n+            flags.push((sym::_Self, Some(self.tcx.type_of(def.did).to_string())));\n+        }\n+\n+        for param in generics.params.iter() {\n+            let value = match param.kind {\n+                GenericParamDefKind::Type { .. } | GenericParamDefKind::Const => {\n+                    trait_ref.substs[param.index as usize].to_string()\n+                }\n+                GenericParamDefKind::Lifetime => continue,\n+            };\n+            let name = param.name;\n+            flags.push((name, Some(value)));\n+        }\n+\n+        if let Some(true) = self_ty.ty_adt_def().map(|def| def.did.is_local()) {\n+            flags.push((sym::crate_local, None));\n+        }\n+\n+        // Allow targeting all integers using `{integral}`, even if the exact type was resolved\n+        if self_ty.is_integral() {\n+            flags.push((sym::_Self, Some(\"{integral}\".to_owned())));\n+        }\n+\n+        if let ty::Array(aty, len) = self_ty.kind {\n+            flags.push((sym::_Self, Some(\"[]\".to_owned())));\n+            flags.push((sym::_Self, Some(format!(\"[{}]\", aty))));\n+            if let Some(def) = aty.ty_adt_def() {\n+                // We also want to be able to select the array's type's original\n+                // signature with no type arguments resolved\n+                flags.push((\n+                    sym::_Self,\n+                    Some(format!(\"[{}]\", self.tcx.type_of(def.did).to_string())),\n+                ));\n+                let tcx = self.tcx;\n+                if let Some(len) = len.try_eval_usize(tcx, ty::ParamEnv::empty()) {\n+                    flags.push((\n+                        sym::_Self,\n+                        Some(format!(\"[{}; {}]\", self.tcx.type_of(def.did).to_string(), len)),\n+                    ));\n+                } else {\n+                    flags.push((\n+                        sym::_Self,\n+                        Some(format!(\"[{}; _]\", self.tcx.type_of(def.did).to_string())),\n+                    ));\n+                }\n+            }\n+        }\n+\n+        if let Ok(Some(command)) =\n+            OnUnimplementedDirective::of_item(self.tcx, trait_ref.def_id, def_id)\n+        {\n+            command.evaluate(self.tcx, trait_ref, &flags[..])\n+        } else {\n+            OnUnimplementedNote::default()\n+        }\n+    }\n+}"}, {"sha": "389edfa0717942bd85c359566d3d6555c81d919b", "filename": "src/librustc/traits/error_reporting/suggestions.rs", "status": "renamed", "additions": 26, "deletions": 1531, "changes": 1557, "blob_url": "https://github.com/rust-lang/rust/blob/00c82726122d550c586e11bf85501a93ce0fbf75/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c82726122d550c586e11bf85501a93ce0fbf75/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=00c82726122d550c586e11bf85501a93ce0fbf75", "patch": "@@ -1,1178 +1,28 @@\n-// ignore-tidy-filelength\n use super::{\n-    ConstEvalFailure, EvaluationResult, FulfillmentError, FulfillmentErrorCode,\n-    MismatchedProjectionTypes, ObjectSafetyViolation, Obligation, ObligationCause,\n-    ObligationCauseCode, OnUnimplementedDirective, OnUnimplementedNote,\n-    OutputTypeParameterMismatch, Overflow, PredicateObligation, SelectionContext, SelectionError,\n-    TraitNotObjectSafe,\n+    ArgKind, EvaluationResult, Obligation, ObligationCause, ObligationCauseCode,\n+    PredicateObligation,\n };\n \n-use crate::infer::error_reporting::{TyCategory, TypeAnnotationNeeded as ErrorCode};\n-use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use crate::infer::{self, InferCtxt};\n-use crate::mir::interpret::ErrorHandled;\n-use crate::session::DiagnosticMessageId;\n-use crate::traits::object_safety_violations;\n-use crate::ty::error::ExpectedFound;\n-use crate::ty::fast_reject;\n-use crate::ty::fold::TypeFolder;\n-use crate::ty::subst::Subst;\n-use crate::ty::GenericParamDefKind;\n-use crate::ty::SubtypePredicate;\n+use crate::infer::InferCtxt;\n use crate::ty::TypeckTables;\n-use crate::ty::{self, AdtKind, DefIdTree, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::{self, AdtKind, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable};\n \n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{\n     error_code, pluralize, struct_span_err, Applicability, DiagnosticBuilder, Style,\n };\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::Node;\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym};\n-use rustc_span::{ExpnKind, MultiSpan, Span, DUMMY_SP};\n+use rustc_span::{MultiSpan, Span, DUMMY_SP};\n use std::fmt;\n-use syntax::ast;\n \n use rustc_error_codes::*;\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    pub fn report_fulfillment_errors(\n-        &self,\n-        errors: &[FulfillmentError<'tcx>],\n-        body_id: Option<hir::BodyId>,\n-        fallback_has_occurred: bool,\n-    ) {\n-        #[derive(Debug)]\n-        struct ErrorDescriptor<'tcx> {\n-            predicate: ty::Predicate<'tcx>,\n-            index: Option<usize>, // None if this is an old error\n-        }\n-\n-        let mut error_map: FxHashMap<_, Vec<_>> = self\n-            .reported_trait_errors\n-            .borrow()\n-            .iter()\n-            .map(|(&span, predicates)| {\n-                (\n-                    span,\n-                    predicates\n-                        .iter()\n-                        .map(|predicate| ErrorDescriptor {\n-                            predicate: predicate.clone(),\n-                            index: None,\n-                        })\n-                        .collect(),\n-                )\n-            })\n-            .collect();\n-\n-        for (index, error) in errors.iter().enumerate() {\n-            // We want to ignore desugarings here: spans are equivalent even\n-            // if one is the result of a desugaring and the other is not.\n-            let mut span = error.obligation.cause.span;\n-            let expn_data = span.ctxt().outer_expn_data();\n-            if let ExpnKind::Desugaring(_) = expn_data.kind {\n-                span = expn_data.call_site;\n-            }\n-\n-            error_map.entry(span).or_default().push(ErrorDescriptor {\n-                predicate: error.obligation.predicate.clone(),\n-                index: Some(index),\n-            });\n-\n-            self.reported_trait_errors\n-                .borrow_mut()\n-                .entry(span)\n-                .or_default()\n-                .push(error.obligation.predicate.clone());\n-        }\n-\n-        // We do this in 2 passes because we want to display errors in order, though\n-        // maybe it *is* better to sort errors by span or something.\n-        let mut is_suppressed = vec![false; errors.len()];\n-        for (_, error_set) in error_map.iter() {\n-            // We want to suppress \"duplicate\" errors with the same span.\n-            for error in error_set {\n-                if let Some(index) = error.index {\n-                    // Suppress errors that are either:\n-                    // 1) strictly implied by another error.\n-                    // 2) implied by an error with a smaller index.\n-                    for error2 in error_set {\n-                        if error2.index.map_or(false, |index2| is_suppressed[index2]) {\n-                            // Avoid errors being suppressed by already-suppressed\n-                            // errors, to prevent all errors from being suppressed\n-                            // at once.\n-                            continue;\n-                        }\n-\n-                        if self.error_implies(&error2.predicate, &error.predicate)\n-                            && !(error2.index >= error.index\n-                                && self.error_implies(&error.predicate, &error2.predicate))\n-                        {\n-                            info!(\"skipping {:?} (implied by {:?})\", error, error2);\n-                            is_suppressed[index] = true;\n-                            break;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        for (error, suppressed) in errors.iter().zip(is_suppressed) {\n-            if !suppressed {\n-                self.report_fulfillment_error(error, body_id, fallback_has_occurred);\n-            }\n-        }\n-    }\n-\n-    // returns if `cond` not occurring implies that `error` does not occur - i.e., that\n-    // `error` occurring implies that `cond` occurs.\n-    fn error_implies(&self, cond: &ty::Predicate<'tcx>, error: &ty::Predicate<'tcx>) -> bool {\n-        if cond == error {\n-            return true;\n-        }\n-\n-        let (cond, error) = match (cond, error) {\n-            (&ty::Predicate::Trait(..), &ty::Predicate::Trait(ref error)) => (cond, error),\n-            _ => {\n-                // FIXME: make this work in other cases too.\n-                return false;\n-            }\n-        };\n-\n-        for implication in super::elaborate_predicates(self.tcx, vec![cond.clone()]) {\n-            if let ty::Predicate::Trait(implication) = implication {\n-                let error = error.to_poly_trait_ref();\n-                let implication = implication.to_poly_trait_ref();\n-                // FIXME: I'm just not taking associated types at all here.\n-                // Eventually I'll need to implement param-env-aware\n-                // `\u0393\u2081 \u22a6 \u03c6\u2081 => \u0393\u2082 \u22a6 \u03c6\u2082` logic.\n-                let param_env = ty::ParamEnv::empty();\n-                if self.can_sub(param_env, error, implication).is_ok() {\n-                    debug!(\"error_implies: {:?} -> {:?} -> {:?}\", cond, error, implication);\n-                    return true;\n-                }\n-            }\n-        }\n-\n-        false\n-    }\n-\n-    fn report_fulfillment_error(\n-        &self,\n-        error: &FulfillmentError<'tcx>,\n-        body_id: Option<hir::BodyId>,\n-        fallback_has_occurred: bool,\n-    ) {\n-        debug!(\"report_fulfillment_error({:?})\", error);\n-        match error.code {\n-            FulfillmentErrorCode::CodeSelectionError(ref selection_error) => {\n-                self.report_selection_error(\n-                    &error.obligation,\n-                    selection_error,\n-                    fallback_has_occurred,\n-                    error.points_at_arg_span,\n-                );\n-            }\n-            FulfillmentErrorCode::CodeProjectionError(ref e) => {\n-                self.report_projection_error(&error.obligation, e);\n-            }\n-            FulfillmentErrorCode::CodeAmbiguity => {\n-                self.maybe_report_ambiguity(&error.obligation, body_id);\n-            }\n-            FulfillmentErrorCode::CodeSubtypeError(ref expected_found, ref err) => {\n-                self.report_mismatched_types(\n-                    &error.obligation.cause,\n-                    expected_found.expected,\n-                    expected_found.found,\n-                    err.clone(),\n-                )\n-                .emit();\n-            }\n-        }\n-    }\n-\n-    fn report_projection_error(\n-        &self,\n-        obligation: &PredicateObligation<'tcx>,\n-        error: &MismatchedProjectionTypes<'tcx>,\n-    ) {\n-        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n-\n-        if predicate.references_error() {\n-            return;\n-        }\n-\n-        self.probe(|_| {\n-            let err_buf;\n-            let mut err = &error.err;\n-            let mut values = None;\n-\n-            // try to find the mismatched types to report the error with.\n-            //\n-            // this can fail if the problem was higher-ranked, in which\n-            // cause I have no idea for a good error message.\n-            if let ty::Predicate::Projection(ref data) = predicate {\n-                let mut selcx = SelectionContext::new(self);\n-                let (data, _) = self.replace_bound_vars_with_fresh_vars(\n-                    obligation.cause.span,\n-                    infer::LateBoundRegionConversionTime::HigherRankedType,\n-                    data,\n-                );\n-                let mut obligations = vec![];\n-                let normalized_ty = super::normalize_projection_type(\n-                    &mut selcx,\n-                    obligation.param_env,\n-                    data.projection_ty,\n-                    obligation.cause.clone(),\n-                    0,\n-                    &mut obligations,\n-                );\n-\n-                debug!(\n-                    \"report_projection_error obligation.cause={:?} obligation.param_env={:?}\",\n-                    obligation.cause, obligation.param_env\n-                );\n-\n-                debug!(\n-                    \"report_projection_error normalized_ty={:?} data.ty={:?}\",\n-                    normalized_ty, data.ty\n-                );\n-\n-                let is_normalized_ty_expected = match &obligation.cause.code {\n-                    ObligationCauseCode::ItemObligation(_)\n-                    | ObligationCauseCode::BindingObligation(_, _)\n-                    | ObligationCauseCode::ObjectCastObligation(_) => false,\n-                    _ => true,\n-                };\n-\n-                if let Err(error) = self.at(&obligation.cause, obligation.param_env).eq_exp(\n-                    is_normalized_ty_expected,\n-                    normalized_ty,\n-                    data.ty,\n-                ) {\n-                    values = Some(infer::ValuePairs::Types(ExpectedFound::new(\n-                        is_normalized_ty_expected,\n-                        normalized_ty,\n-                        data.ty,\n-                    )));\n-\n-                    err_buf = error;\n-                    err = &err_buf;\n-                }\n-            }\n-\n-            let msg = format!(\"type mismatch resolving `{}`\", predicate);\n-            let error_id = (DiagnosticMessageId::ErrorId(271), Some(obligation.cause.span), msg);\n-            let fresh = self.tcx.sess.one_time_diagnostics.borrow_mut().insert(error_id);\n-            if fresh {\n-                let mut diag = struct_span_err!(\n-                    self.tcx.sess,\n-                    obligation.cause.span,\n-                    E0271,\n-                    \"type mismatch resolving `{}`\",\n-                    predicate\n-                );\n-                self.note_type_err(&mut diag, &obligation.cause, None, values, err);\n-                self.note_obligation_cause(&mut diag, obligation);\n-                diag.emit();\n-            }\n-        });\n-    }\n-\n-    fn fuzzy_match_tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-        /// returns the fuzzy category of a given type, or None\n-        /// if the type can be equated to any type.\n-        fn type_category(t: Ty<'_>) -> Option<u32> {\n-            match t.kind {\n-                ty::Bool => Some(0),\n-                ty::Char => Some(1),\n-                ty::Str => Some(2),\n-                ty::Int(..) | ty::Uint(..) | ty::Infer(ty::IntVar(..)) => Some(3),\n-                ty::Float(..) | ty::Infer(ty::FloatVar(..)) => Some(4),\n-                ty::Ref(..) | ty::RawPtr(..) => Some(5),\n-                ty::Array(..) | ty::Slice(..) => Some(6),\n-                ty::FnDef(..) | ty::FnPtr(..) => Some(7),\n-                ty::Dynamic(..) => Some(8),\n-                ty::Closure(..) => Some(9),\n-                ty::Tuple(..) => Some(10),\n-                ty::Projection(..) => Some(11),\n-                ty::Param(..) => Some(12),\n-                ty::Opaque(..) => Some(13),\n-                ty::Never => Some(14),\n-                ty::Adt(adt, ..) => match adt.adt_kind() {\n-                    AdtKind::Struct => Some(15),\n-                    AdtKind::Union => Some(16),\n-                    AdtKind::Enum => Some(17),\n-                },\n-                ty::Generator(..) => Some(18),\n-                ty::Foreign(..) => Some(19),\n-                ty::GeneratorWitness(..) => Some(20),\n-                ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) | ty::Error => None,\n-                ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n-            }\n-        }\n-\n-        match (type_category(a), type_category(b)) {\n-            (Some(cat_a), Some(cat_b)) => match (&a.kind, &b.kind) {\n-                (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => def_a == def_b,\n-                _ => cat_a == cat_b,\n-            },\n-            // infer and error can be equated to all types\n-            _ => true,\n-        }\n-    }\n-\n-    fn impl_similar_to(\n-        &self,\n-        trait_ref: ty::PolyTraitRef<'tcx>,\n-        obligation: &PredicateObligation<'tcx>,\n-    ) -> Option<DefId> {\n-        let tcx = self.tcx;\n-        let param_env = obligation.param_env;\n-        let trait_ref = tcx.erase_late_bound_regions(&trait_ref);\n-        let trait_self_ty = trait_ref.self_ty();\n-\n-        let mut self_match_impls = vec![];\n-        let mut fuzzy_match_impls = vec![];\n-\n-        self.tcx.for_each_relevant_impl(trait_ref.def_id, trait_self_ty, |def_id| {\n-            let impl_substs = self.fresh_substs_for_item(obligation.cause.span, def_id);\n-            let impl_trait_ref = tcx.impl_trait_ref(def_id).unwrap().subst(tcx, impl_substs);\n-\n-            let impl_self_ty = impl_trait_ref.self_ty();\n-\n-            if let Ok(..) = self.can_eq(param_env, trait_self_ty, impl_self_ty) {\n-                self_match_impls.push(def_id);\n-\n-                if trait_ref\n-                    .substs\n-                    .types()\n-                    .skip(1)\n-                    .zip(impl_trait_ref.substs.types().skip(1))\n-                    .all(|(u, v)| self.fuzzy_match_tys(u, v))\n-                {\n-                    fuzzy_match_impls.push(def_id);\n-                }\n-            }\n-        });\n-\n-        let impl_def_id = if self_match_impls.len() == 1 {\n-            self_match_impls[0]\n-        } else if fuzzy_match_impls.len() == 1 {\n-            fuzzy_match_impls[0]\n-        } else {\n-            return None;\n-        };\n-\n-        tcx.has_attr(impl_def_id, sym::rustc_on_unimplemented).then_some(impl_def_id)\n-    }\n-\n-    fn describe_generator(&self, body_id: hir::BodyId) -> Option<&'static str> {\n-        self.tcx.hir().body(body_id).generator_kind.map(|gen_kind| match gen_kind {\n-            hir::GeneratorKind::Gen => \"a generator\",\n-            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block) => \"an async block\",\n-            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Fn) => \"an async function\",\n-            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Closure) => \"an async closure\",\n-        })\n-    }\n-\n-    /// Used to set on_unimplemented's `ItemContext`\n-    /// to be the enclosing (async) block/function/closure\n-    fn describe_enclosure(&self, hir_id: hir::HirId) -> Option<&'static str> {\n-        let hir = &self.tcx.hir();\n-        let node = hir.find(hir_id)?;\n-        if let hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(sig, _, body_id), .. }) = &node {\n-            self.describe_generator(*body_id).or_else(|| {\n-                Some(if let hir::FnHeader { asyncness: hir::IsAsync::Async, .. } = sig.header {\n-                    \"an async function\"\n-                } else {\n-                    \"a function\"\n-                })\n-            })\n-        } else if let hir::Node::Expr(hir::Expr {\n-            kind: hir::ExprKind::Closure(_is_move, _, body_id, _, gen_movability),\n-            ..\n-        }) = &node\n-        {\n-            self.describe_generator(*body_id).or_else(|| {\n-                Some(if gen_movability.is_some() { \"an async closure\" } else { \"a closure\" })\n-            })\n-        } else if let hir::Node::Expr(hir::Expr { .. }) = &node {\n-            let parent_hid = hir.get_parent_node(hir_id);\n-            if parent_hid != hir_id {\n-                return self.describe_enclosure(parent_hid);\n-            } else {\n-                None\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    fn on_unimplemented_note(\n-        &self,\n-        trait_ref: ty::PolyTraitRef<'tcx>,\n-        obligation: &PredicateObligation<'tcx>,\n-    ) -> OnUnimplementedNote {\n-        let def_id =\n-            self.impl_similar_to(trait_ref, obligation).unwrap_or_else(|| trait_ref.def_id());\n-        let trait_ref = *trait_ref.skip_binder();\n-\n-        let mut flags = vec![];\n-        flags.push((\n-            sym::item_context,\n-            self.describe_enclosure(obligation.cause.body_id).map(|s| s.to_owned()),\n-        ));\n-\n-        match obligation.cause.code {\n-            ObligationCauseCode::BuiltinDerivedObligation(..)\n-            | ObligationCauseCode::ImplDerivedObligation(..) => {}\n-            _ => {\n-                // this is a \"direct\", user-specified, rather than derived,\n-                // obligation.\n-                flags.push((sym::direct, None));\n-            }\n-        }\n-\n-        if let ObligationCauseCode::ItemObligation(item) = obligation.cause.code {\n-            // FIXME: maybe also have some way of handling methods\n-            // from other traits? That would require name resolution,\n-            // which we might want to be some sort of hygienic.\n-            //\n-            // Currently I'm leaving it for what I need for `try`.\n-            if self.tcx.trait_of_item(item) == Some(trait_ref.def_id) {\n-                let method = self.tcx.item_name(item);\n-                flags.push((sym::from_method, None));\n-                flags.push((sym::from_method, Some(method.to_string())));\n-            }\n-        }\n-        if let Some((t, _)) = self.get_parent_trait_ref(&obligation.cause.code) {\n-            flags.push((sym::parent_trait, Some(t)));\n-        }\n-\n-        if let Some(k) = obligation.cause.span.desugaring_kind() {\n-            flags.push((sym::from_desugaring, None));\n-            flags.push((sym::from_desugaring, Some(format!(\"{:?}\", k))));\n-        }\n-        let generics = self.tcx.generics_of(def_id);\n-        let self_ty = trait_ref.self_ty();\n-        // This is also included through the generics list as `Self`,\n-        // but the parser won't allow you to use it\n-        flags.push((sym::_Self, Some(self_ty.to_string())));\n-        if let Some(def) = self_ty.ty_adt_def() {\n-            // We also want to be able to select self's original\n-            // signature with no type arguments resolved\n-            flags.push((sym::_Self, Some(self.tcx.type_of(def.did).to_string())));\n-        }\n-\n-        for param in generics.params.iter() {\n-            let value = match param.kind {\n-                GenericParamDefKind::Type { .. } | GenericParamDefKind::Const => {\n-                    trait_ref.substs[param.index as usize].to_string()\n-                }\n-                GenericParamDefKind::Lifetime => continue,\n-            };\n-            let name = param.name;\n-            flags.push((name, Some(value)));\n-        }\n-\n-        if let Some(true) = self_ty.ty_adt_def().map(|def| def.did.is_local()) {\n-            flags.push((sym::crate_local, None));\n-        }\n-\n-        // Allow targeting all integers using `{integral}`, even if the exact type was resolved\n-        if self_ty.is_integral() {\n-            flags.push((sym::_Self, Some(\"{integral}\".to_owned())));\n-        }\n-\n-        if let ty::Array(aty, len) = self_ty.kind {\n-            flags.push((sym::_Self, Some(\"[]\".to_owned())));\n-            flags.push((sym::_Self, Some(format!(\"[{}]\", aty))));\n-            if let Some(def) = aty.ty_adt_def() {\n-                // We also want to be able to select the array's type's original\n-                // signature with no type arguments resolved\n-                flags.push((\n-                    sym::_Self,\n-                    Some(format!(\"[{}]\", self.tcx.type_of(def.did).to_string())),\n-                ));\n-                let tcx = self.tcx;\n-                if let Some(len) = len.try_eval_usize(tcx, ty::ParamEnv::empty()) {\n-                    flags.push((\n-                        sym::_Self,\n-                        Some(format!(\"[{}; {}]\", self.tcx.type_of(def.did).to_string(), len)),\n-                    ));\n-                } else {\n-                    flags.push((\n-                        sym::_Self,\n-                        Some(format!(\"[{}; _]\", self.tcx.type_of(def.did).to_string())),\n-                    ));\n-                }\n-            }\n-        }\n-\n-        if let Ok(Some(command)) =\n-            OnUnimplementedDirective::of_item(self.tcx, trait_ref.def_id, def_id)\n-        {\n-            command.evaluate(self.tcx, trait_ref, &flags[..])\n-        } else {\n-            OnUnimplementedNote::default()\n-        }\n-    }\n-\n-    fn find_similar_impl_candidates(\n-        &self,\n-        trait_ref: ty::PolyTraitRef<'tcx>,\n-    ) -> Vec<ty::TraitRef<'tcx>> {\n-        let simp = fast_reject::simplify_type(self.tcx, trait_ref.skip_binder().self_ty(), true);\n-        let all_impls = self.tcx.all_impls(trait_ref.def_id());\n-\n-        match simp {\n-            Some(simp) => all_impls\n-                .iter()\n-                .filter_map(|&def_id| {\n-                    let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n-                    let imp_simp = fast_reject::simplify_type(self.tcx, imp.self_ty(), true);\n-                    if let Some(imp_simp) = imp_simp {\n-                        if simp != imp_simp {\n-                            return None;\n-                        }\n-                    }\n-\n-                    Some(imp)\n-                })\n-                .collect(),\n-            None => {\n-                all_impls.iter().map(|&def_id| self.tcx.impl_trait_ref(def_id).unwrap()).collect()\n-            }\n-        }\n-    }\n-\n-    fn report_similar_impl_candidates(\n-        &self,\n-        impl_candidates: Vec<ty::TraitRef<'tcx>>,\n-        err: &mut DiagnosticBuilder<'_>,\n-    ) {\n-        if impl_candidates.is_empty() {\n-            return;\n-        }\n-\n-        let len = impl_candidates.len();\n-        let end = if impl_candidates.len() <= 5 { impl_candidates.len() } else { 4 };\n-\n-        let normalize = |candidate| {\n-            self.tcx.infer_ctxt().enter(|ref infcx| {\n-                let normalized = infcx\n-                    .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n-                    .normalize(candidate)\n-                    .ok();\n-                match normalized {\n-                    Some(normalized) => format!(\"\\n  {:?}\", normalized.value),\n-                    None => format!(\"\\n  {:?}\", candidate),\n-                }\n-            })\n-        };\n-\n-        // Sort impl candidates so that ordering is consistent for UI tests.\n-        let mut normalized_impl_candidates =\n-            impl_candidates.iter().map(normalize).collect::<Vec<String>>();\n-\n-        // Sort before taking the `..end` range,\n-        // because the ordering of `impl_candidates` may not be deterministic:\n-        // https://github.com/rust-lang/rust/pull/57475#issuecomment-455519507\n-        normalized_impl_candidates.sort();\n-\n-        err.help(&format!(\n-            \"the following implementations were found:{}{}\",\n-            normalized_impl_candidates[..end].join(\"\"),\n-            if len > 5 { format!(\"\\nand {} others\", len - 4) } else { String::new() }\n-        ));\n-    }\n-\n-    /// Reports that an overflow has occurred and halts compilation. We\n-    /// halt compilation unconditionally because it is important that\n-    /// overflows never be masked -- they basically represent computations\n-    /// whose result could not be truly determined and thus we can't say\n-    /// if the program type checks or not -- and they are unusual\n-    /// occurrences in any case.\n-    pub fn report_overflow_error<T>(\n-        &self,\n-        obligation: &Obligation<'tcx, T>,\n-        suggest_increasing_limit: bool,\n-    ) -> !\n-    where\n-        T: fmt::Display + TypeFoldable<'tcx>,\n-    {\n-        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n-        let mut err = struct_span_err!(\n-            self.tcx.sess,\n-            obligation.cause.span,\n-            E0275,\n-            \"overflow evaluating the requirement `{}`\",\n-            predicate\n-        );\n-\n-        if suggest_increasing_limit {\n-            self.suggest_new_overflow_limit(&mut err);\n-        }\n-\n-        self.note_obligation_cause_code(\n-            &mut err,\n-            &obligation.predicate,\n-            &obligation.cause.code,\n-            &mut vec![],\n-        );\n-\n-        err.emit();\n-        self.tcx.sess.abort_if_errors();\n-        bug!();\n-    }\n-\n-    /// Reports that a cycle was detected which led to overflow and halts\n-    /// compilation. This is equivalent to `report_overflow_error` except\n-    /// that we can give a more helpful error message (and, in particular,\n-    /// we do not suggest increasing the overflow limit, which is not\n-    /// going to help).\n-    pub fn report_overflow_error_cycle(&self, cycle: &[PredicateObligation<'tcx>]) -> ! {\n-        let cycle = self.resolve_vars_if_possible(&cycle.to_owned());\n-        assert!(cycle.len() > 0);\n-\n-        debug!(\"report_overflow_error_cycle: cycle={:?}\", cycle);\n-\n-        self.report_overflow_error(&cycle[0], false);\n-    }\n-\n-    pub fn report_extra_impl_obligation(\n-        &self,\n-        error_span: Span,\n-        item_name: ast::Name,\n-        _impl_item_def_id: DefId,\n-        trait_item_def_id: DefId,\n-        requirement: &dyn fmt::Display,\n-    ) -> DiagnosticBuilder<'tcx> {\n-        let msg = \"impl has stricter requirements than trait\";\n-        let sp = self.tcx.sess.source_map().def_span(error_span);\n-\n-        let mut err = struct_span_err!(self.tcx.sess, sp, E0276, \"{}\", msg);\n-\n-        if let Some(trait_item_span) = self.tcx.hir().span_if_local(trait_item_def_id) {\n-            let span = self.tcx.sess.source_map().def_span(trait_item_span);\n-            err.span_label(span, format!(\"definition of `{}` from trait\", item_name));\n-        }\n-\n-        err.span_label(sp, format!(\"impl has extra requirement {}\", requirement));\n-\n-        err\n-    }\n-\n-    /// Gets the parent trait chain start\n-    fn get_parent_trait_ref(\n-        &self,\n-        code: &ObligationCauseCode<'tcx>,\n-    ) -> Option<(String, Option<Span>)> {\n-        match code {\n-            &ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n-                let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n-                match self.get_parent_trait_ref(&data.parent_code) {\n-                    Some(t) => Some(t),\n-                    None => {\n-                        let ty = parent_trait_ref.skip_binder().self_ty();\n-                        let span =\n-                            TyCategory::from_ty(ty).map(|(_, def_id)| self.tcx.def_span(def_id));\n-                        Some((ty.to_string(), span))\n-                    }\n-                }\n-            }\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn report_selection_error(\n-        &self,\n-        obligation: &PredicateObligation<'tcx>,\n-        error: &SelectionError<'tcx>,\n-        fallback_has_occurred: bool,\n-        points_at_arg: bool,\n-    ) {\n-        let tcx = self.tcx;\n-        let span = obligation.cause.span;\n-\n-        let mut err = match *error {\n-            SelectionError::Unimplemented => {\n-                if let ObligationCauseCode::CompareImplMethodObligation {\n-                    item_name,\n-                    impl_item_def_id,\n-                    trait_item_def_id,\n-                }\n-                | ObligationCauseCode::CompareImplTypeObligation {\n-                    item_name,\n-                    impl_item_def_id,\n-                    trait_item_def_id,\n-                } = obligation.cause.code\n-                {\n-                    self.report_extra_impl_obligation(\n-                        span,\n-                        item_name,\n-                        impl_item_def_id,\n-                        trait_item_def_id,\n-                        &format!(\"`{}`\", obligation.predicate),\n-                    )\n-                    .emit();\n-                    return;\n-                }\n-                match obligation.predicate {\n-                    ty::Predicate::Trait(ref trait_predicate) => {\n-                        let trait_predicate = self.resolve_vars_if_possible(trait_predicate);\n-\n-                        if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n-                            return;\n-                        }\n-                        let trait_ref = trait_predicate.to_poly_trait_ref();\n-                        let (post_message, pre_message, type_def) = self\n-                            .get_parent_trait_ref(&obligation.cause.code)\n-                            .map(|(t, s)| {\n-                                (\n-                                    format!(\" in `{}`\", t),\n-                                    format!(\"within `{}`, \", t),\n-                                    s.map(|s| (format!(\"within this `{}`\", t), s)),\n-                                )\n-                            })\n-                            .unwrap_or_default();\n-\n-                        let OnUnimplementedNote { message, label, note, enclosing_scope } =\n-                            self.on_unimplemented_note(trait_ref, obligation);\n-                        let have_alt_message = message.is_some() || label.is_some();\n-                        let is_try = self\n-                            .tcx\n-                            .sess\n-                            .source_map()\n-                            .span_to_snippet(span)\n-                            .map(|s| &s == \"?\")\n-                            .unwrap_or(false);\n-                        let is_from = format!(\"{}\", trait_ref.print_only_trait_path())\n-                            .starts_with(\"std::convert::From<\");\n-                        let (message, note) = if is_try && is_from {\n-                            (\n-                                Some(format!(\n-                                    \"`?` couldn't convert the error to `{}`\",\n-                                    trait_ref.self_ty(),\n-                                )),\n-                                Some(\n-                                    \"the question mark operation (`?`) implicitly performs a \\\n-                                     conversion on the error value using the `From` trait\"\n-                                        .to_owned(),\n-                                ),\n-                            )\n-                        } else {\n-                            (message, note)\n-                        };\n-\n-                        let mut err = struct_span_err!(\n-                            self.tcx.sess,\n-                            span,\n-                            E0277,\n-                            \"{}\",\n-                            message.unwrap_or_else(|| format!(\n-                                \"the trait bound `{}` is not satisfied{}\",\n-                                trait_ref.to_predicate(),\n-                                post_message,\n-                            ))\n-                        );\n-\n-                        let explanation =\n-                            if obligation.cause.code == ObligationCauseCode::MainFunctionType {\n-                                \"consider using `()`, or a `Result`\".to_owned()\n-                            } else {\n-                                format!(\n-                                    \"{}the trait `{}` is not implemented for `{}`\",\n-                                    pre_message,\n-                                    trait_ref.print_only_trait_path(),\n-                                    trait_ref.self_ty(),\n-                                )\n-                            };\n-\n-                        if self.suggest_add_reference_to_arg(\n-                            &obligation,\n-                            &mut err,\n-                            &trait_ref,\n-                            points_at_arg,\n-                            have_alt_message,\n-                        ) {\n-                            self.note_obligation_cause(&mut err, obligation);\n-                            err.emit();\n-                            return;\n-                        }\n-                        if let Some(ref s) = label {\n-                            // If it has a custom `#[rustc_on_unimplemented]`\n-                            // error message, let's display it as the label!\n-                            err.span_label(span, s.as_str());\n-                            err.help(&explanation);\n-                        } else {\n-                            err.span_label(span, explanation);\n-                        }\n-                        if let Some((msg, span)) = type_def {\n-                            err.span_label(span, &msg);\n-                        }\n-                        if let Some(ref s) = note {\n-                            // If it has a custom `#[rustc_on_unimplemented]` note, let's display it\n-                            err.note(s.as_str());\n-                        }\n-                        if let Some(ref s) = enclosing_scope {\n-                            let enclosing_scope_span = tcx.def_span(\n-                                tcx.hir()\n-                                    .opt_local_def_id(obligation.cause.body_id)\n-                                    .unwrap_or_else(|| {\n-                                        tcx.hir().body_owner_def_id(hir::BodyId {\n-                                            hir_id: obligation.cause.body_id,\n-                                        })\n-                                    }),\n-                            );\n-\n-                            err.span_label(enclosing_scope_span, s.as_str());\n-                        }\n-\n-                        self.suggest_borrow_on_unsized_slice(&obligation.cause.code, &mut err);\n-                        self.suggest_fn_call(&obligation, &mut err, &trait_ref, points_at_arg);\n-                        self.suggest_remove_reference(&obligation, &mut err, &trait_ref);\n-                        self.suggest_semicolon_removal(&obligation, &mut err, span, &trait_ref);\n-                        self.note_version_mismatch(&mut err, &trait_ref);\n-                        if self.suggest_impl_trait(&mut err, span, &obligation, &trait_ref) {\n-                            err.emit();\n-                            return;\n-                        }\n-\n-                        // Try to report a help message\n-                        if !trait_ref.has_infer_types()\n-                            && self.predicate_can_apply(obligation.param_env, trait_ref)\n-                        {\n-                            // If a where-clause may be useful, remind the\n-                            // user that they can add it.\n-                            //\n-                            // don't display an on-unimplemented note, as\n-                            // these notes will often be of the form\n-                            //     \"the type `T` can't be frobnicated\"\n-                            // which is somewhat confusing.\n-                            self.suggest_restricting_param_bound(\n-                                &mut err,\n-                                &trait_ref,\n-                                obligation.cause.body_id,\n-                            );\n-                        } else {\n-                            if !have_alt_message {\n-                                // Can't show anything else useful, try to find similar impls.\n-                                let impl_candidates = self.find_similar_impl_candidates(trait_ref);\n-                                self.report_similar_impl_candidates(impl_candidates, &mut err);\n-                            }\n-                            self.suggest_change_mut(\n-                                &obligation,\n-                                &mut err,\n-                                &trait_ref,\n-                                points_at_arg,\n-                            );\n-                        }\n-\n-                        // If this error is due to `!: Trait` not implemented but `(): Trait` is\n-                        // implemented, and fallback has occurred, then it could be due to a\n-                        // variable that used to fallback to `()` now falling back to `!`. Issue a\n-                        // note informing about the change in behaviour.\n-                        if trait_predicate.skip_binder().self_ty().is_never()\n-                            && fallback_has_occurred\n-                        {\n-                            let predicate = trait_predicate.map_bound(|mut trait_pred| {\n-                                trait_pred.trait_ref.substs = self.tcx.mk_substs_trait(\n-                                    self.tcx.mk_unit(),\n-                                    &trait_pred.trait_ref.substs[1..],\n-                                );\n-                                trait_pred\n-                            });\n-                            let unit_obligation = Obligation {\n-                                predicate: ty::Predicate::Trait(predicate),\n-                                ..obligation.clone()\n-                            };\n-                            if self.predicate_may_hold(&unit_obligation) {\n-                                err.note(\n-                                    \"the trait is implemented for `()`. \\\n-                                         Possibly this error has been caused by changes to \\\n-                                         Rust's type-inference algorithm \\\n-                                         (see: https://github.com/rust-lang/rust/issues/48950 \\\n-                                         for more info). Consider whether you meant to use the \\\n-                                         type `()` here instead.\",\n-                                );\n-                            }\n-                        }\n-\n-                        err\n-                    }\n-\n-                    ty::Predicate::Subtype(ref predicate) => {\n-                        // Errors for Subtype predicates show up as\n-                        // `FulfillmentErrorCode::CodeSubtypeError`,\n-                        // not selection error.\n-                        span_bug!(span, \"subtype requirement gave wrong error: `{:?}`\", predicate)\n-                    }\n-\n-                    ty::Predicate::RegionOutlives(ref predicate) => {\n-                        let predicate = self.resolve_vars_if_possible(predicate);\n-                        let err = self\n-                            .region_outlives_predicate(&obligation.cause, &predicate)\n-                            .err()\n-                            .unwrap();\n-                        struct_span_err!(\n-                            self.tcx.sess,\n-                            span,\n-                            E0279,\n-                            \"the requirement `{}` is not satisfied (`{}`)\",\n-                            predicate,\n-                            err,\n-                        )\n-                    }\n-\n-                    ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n-                        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n-                        struct_span_err!(\n-                            self.tcx.sess,\n-                            span,\n-                            E0280,\n-                            \"the requirement `{}` is not satisfied\",\n-                            predicate\n-                        )\n-                    }\n-\n-                    ty::Predicate::ObjectSafe(trait_def_id) => {\n-                        let violations = object_safety_violations(self.tcx, trait_def_id);\n-                        report_object_safety_error(self.tcx, span, trait_def_id, violations)\n-                    }\n-\n-                    ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n-                        let found_kind = self.closure_kind(closure_def_id, closure_substs).unwrap();\n-                        let closure_span = self\n-                            .tcx\n-                            .sess\n-                            .source_map()\n-                            .def_span(self.tcx.hir().span_if_local(closure_def_id).unwrap());\n-                        let hir_id = self.tcx.hir().as_local_hir_id(closure_def_id).unwrap();\n-                        let mut err = struct_span_err!(\n-                            self.tcx.sess,\n-                            closure_span,\n-                            E0525,\n-                            \"expected a closure that implements the `{}` trait, \\\n-                             but this closure only implements `{}`\",\n-                            kind,\n-                            found_kind\n-                        );\n-\n-                        err.span_label(\n-                            closure_span,\n-                            format!(\"this closure implements `{}`, not `{}`\", found_kind, kind),\n-                        );\n-                        err.span_label(\n-                            obligation.cause.span,\n-                            format!(\"the requirement to implement `{}` derives from here\", kind),\n-                        );\n-\n-                        // Additional context information explaining why the closure only implements\n-                        // a particular trait.\n-                        if let Some(tables) = self.in_progress_tables {\n-                            let tables = tables.borrow();\n-                            match (found_kind, tables.closure_kind_origins().get(hir_id)) {\n-                                (ty::ClosureKind::FnOnce, Some((span, name))) => {\n-                                    err.span_label(\n-                                        *span,\n-                                        format!(\n-                                            \"closure is `FnOnce` because it moves the \\\n-                                         variable `{}` out of its environment\",\n-                                            name\n-                                        ),\n-                                    );\n-                                }\n-                                (ty::ClosureKind::FnMut, Some((span, name))) => {\n-                                    err.span_label(\n-                                        *span,\n-                                        format!(\n-                                            \"closure is `FnMut` because it mutates the \\\n-                                         variable `{}` here\",\n-                                            name\n-                                        ),\n-                                    );\n-                                }\n-                                _ => {}\n-                            }\n-                        }\n-\n-                        err.emit();\n-                        return;\n-                    }\n-\n-                    ty::Predicate::WellFormed(ty) => {\n-                        if !self.tcx.sess.opts.debugging_opts.chalk {\n-                            // WF predicates cannot themselves make\n-                            // errors. They can only block due to\n-                            // ambiguity; otherwise, they always\n-                            // degenerate into other obligations\n-                            // (which may fail).\n-                            span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n-                        } else {\n-                            // FIXME: we'll need a better message which takes into account\n-                            // which bounds actually failed to hold.\n-                            self.tcx.sess.struct_span_err(\n-                                span,\n-                                &format!(\"the type `{}` is not well-formed (chalk)\", ty),\n-                            )\n-                        }\n-                    }\n-\n-                    ty::Predicate::ConstEvaluatable(..) => {\n-                        // Errors for `ConstEvaluatable` predicates show up as\n-                        // `SelectionError::ConstEvalFailure`,\n-                        // not `Unimplemented`.\n-                        span_bug!(\n-                            span,\n-                            \"const-evaluatable requirement gave wrong error: `{:?}`\",\n-                            obligation\n-                        )\n-                    }\n-                }\n-            }\n-\n-            OutputTypeParameterMismatch(ref found_trait_ref, ref expected_trait_ref, _) => {\n-                let found_trait_ref = self.resolve_vars_if_possible(&*found_trait_ref);\n-                let expected_trait_ref = self.resolve_vars_if_possible(&*expected_trait_ref);\n-\n-                if expected_trait_ref.self_ty().references_error() {\n-                    return;\n-                }\n-\n-                let found_trait_ty = found_trait_ref.self_ty();\n-\n-                let found_did = match found_trait_ty.kind {\n-                    ty::Closure(did, _) | ty::Foreign(did) | ty::FnDef(did, _) => Some(did),\n-                    ty::Adt(def, _) => Some(def.did),\n-                    _ => None,\n-                };\n-\n-                let found_span = found_did\n-                    .and_then(|did| self.tcx.hir().span_if_local(did))\n-                    .map(|sp| self.tcx.sess.source_map().def_span(sp)); // the sp could be an fn def\n-\n-                if self.reported_closure_mismatch.borrow().contains(&(span, found_span)) {\n-                    // We check closures twice, with obligations flowing in different directions,\n-                    // but we want to complain about them only once.\n-                    return;\n-                }\n-\n-                self.reported_closure_mismatch.borrow_mut().insert((span, found_span));\n-\n-                let found = match found_trait_ref.skip_binder().substs.type_at(1).kind {\n-                    ty::Tuple(ref tys) => vec![ArgKind::empty(); tys.len()],\n-                    _ => vec![ArgKind::empty()],\n-                };\n-\n-                let expected_ty = expected_trait_ref.skip_binder().substs.type_at(1);\n-                let expected = match expected_ty.kind {\n-                    ty::Tuple(ref tys) => tys\n-                        .iter()\n-                        .map(|t| ArgKind::from_expected_ty(t.expect_ty(), Some(span)))\n-                        .collect(),\n-                    _ => vec![ArgKind::Arg(\"_\".to_owned(), expected_ty.to_string())],\n-                };\n-\n-                if found.len() == expected.len() {\n-                    self.report_closure_arg_mismatch(\n-                        span,\n-                        found_span,\n-                        found_trait_ref,\n-                        expected_trait_ref,\n-                    )\n-                } else {\n-                    let (closure_span, found) = found_did\n-                        .and_then(|did| self.tcx.hir().get_if_local(did))\n-                        .map(|node| {\n-                            let (found_span, found) = self.get_fn_like_arguments(node);\n-                            (Some(found_span), found)\n-                        })\n-                        .unwrap_or((found_span, found));\n-\n-                    self.report_arg_count_mismatch(\n-                        span,\n-                        closure_span,\n-                        expected,\n-                        found,\n-                        found_trait_ty.is_closure(),\n-                    )\n-                }\n-            }\n-\n-            TraitNotObjectSafe(did) => {\n-                let violations = object_safety_violations(self.tcx, did);\n-                report_object_safety_error(self.tcx, span, did, violations)\n-            }\n-\n-            // already reported in the query\n-            ConstEvalFailure(err) => {\n-                if let ErrorHandled::TooGeneric = err {\n-                    // Silence this error, as it can be produced during intermediate steps\n-                    // when a constant is not yet able to be evaluated (but will be later).\n-                    return;\n-                }\n-                self.tcx.sess.delay_span_bug(\n-                    span,\n-                    &format!(\"constant in type had an ignored error: {:?}\", err),\n-                );\n-                return;\n-            }\n-\n-            Overflow => {\n-                bug!(\"overflow should be handled before the `report_selection_error` path\");\n-            }\n-        };\n-\n-        self.note_obligation_cause(&mut err, obligation);\n-        self.point_at_returns_when_relevant(&mut err, &obligation);\n-\n-        err.emit();\n-    }\n-\n-    /// If the `Self` type of the unsatisfied trait `trait_ref` implements a trait\n-    /// with the same path as `trait_ref`, a help message about\n-    /// a probable version mismatch is added to `err`\n-    fn note_version_mismatch(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: &ty::PolyTraitRef<'tcx>,\n-    ) {\n-        let get_trait_impl = |trait_def_id| {\n-            let mut trait_impl = None;\n-            self.tcx.for_each_relevant_impl(trait_def_id, trait_ref.self_ty(), |impl_def_id| {\n-                if trait_impl.is_none() {\n-                    trait_impl = Some(impl_def_id);\n-                }\n-            });\n-            trait_impl\n-        };\n-        let required_trait_path = self.tcx.def_path_str(trait_ref.def_id());\n-        let all_traits = self.tcx.all_traits(LOCAL_CRATE);\n-        let traits_with_same_path: std::collections::BTreeSet<_> = all_traits\n-            .iter()\n-            .filter(|trait_def_id| **trait_def_id != trait_ref.def_id())\n-            .filter(|trait_def_id| self.tcx.def_path_str(**trait_def_id) == required_trait_path)\n-            .collect();\n-        for trait_with_same_path in traits_with_same_path {\n-            if let Some(impl_def_id) = get_trait_impl(*trait_with_same_path) {\n-                let impl_span = self.tcx.def_span(impl_def_id);\n-                err.span_help(impl_span, \"trait impl with same name found\");\n-                let trait_crate = self.tcx.crate_name(trait_with_same_path.krate);\n-                let crate_msg = format!(\n-                    \"perhaps two different versions of crate `{}` are being used?\",\n-                    trait_crate\n-                );\n-                err.note(&crate_msg);\n-            }\n-        }\n-    }\n-    fn suggest_restricting_param_bound(\n+    crate fn suggest_restricting_param_bound(\n         &self,\n         mut err: &mut DiagnosticBuilder<'_>,\n         trait_ref: &ty::PolyTraitRef<'_>,\n@@ -1318,7 +168,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     /// When encountering an assignment of an unsized trait, like `let x = \"\"[..];`, provide a\n     /// suggestion to borrow the initializer in order to use have a slice instead.\n-    fn suggest_borrow_on_unsized_slice(\n+    crate fn suggest_borrow_on_unsized_slice(\n         &self,\n         code: &ObligationCauseCode<'tcx>,\n         err: &mut DiagnosticBuilder<'tcx>,\n@@ -1342,22 +192,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn mk_obligation_for_def_id(\n-        &self,\n-        def_id: DefId,\n-        output_ty: Ty<'tcx>,\n-        cause: ObligationCause<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> PredicateObligation<'tcx> {\n-        let new_trait_ref =\n-            ty::TraitRef { def_id, substs: self.tcx.mk_substs_trait(output_ty, &[]) };\n-        Obligation::new(cause, param_env, new_trait_ref.to_predicate())\n-    }\n-\n     /// Given a closure's `DefId`, return the given name of the closure.\n     ///\n     /// This doesn't account for reassignments, but it's only used for suggestions.\n-    fn get_closure_name(\n+    crate fn get_closure_name(\n         &self,\n         def_id: DefId,\n         err: &mut DiagnosticBuilder<'_>,\n@@ -1395,7 +233,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// We tried to apply the bound to an `fn` or closure. Check whether calling it would\n     /// evaluate to a type that *would* satisfy the trait binding. If it would, suggest calling\n     /// it: `bar(foo)` \u2192 `bar(foo())`. This case is *very* likely to be hit if `foo` is `async`.\n-    fn suggest_fn_call(\n+    crate fn suggest_fn_call(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n@@ -1479,7 +317,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn suggest_add_reference_to_arg(\n+    crate fn suggest_add_reference_to_arg(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'tcx>,\n@@ -1548,7 +386,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     /// Whenever references are used by mistake, like `for (i, e) in &vec.iter().enumerate()`,\n     /// suggest removing these references until we reach a type that implements the trait.\n-    fn suggest_remove_reference(\n+    crate fn suggest_remove_reference(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'tcx>,\n@@ -1608,7 +446,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     /// Check if the trait bound is implemented for a different mutability and note it in the\n     /// final error.\n-    fn suggest_change_mut(\n+    crate fn suggest_change_mut(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'tcx>,\n@@ -1672,7 +510,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn suggest_semicolon_removal(\n+    crate fn suggest_semicolon_removal(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'tcx>,\n@@ -1705,7 +543,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn suggest_impl_trait(\n+    crate fn suggest_impl_trait(\n         &self,\n         err: &mut DiagnosticBuilder<'tcx>,\n         span: Span,\n@@ -1865,7 +703,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         false\n     }\n \n-    fn point_at_returns_when_relevant(\n+    crate fn point_at_returns_when_relevant(\n         &self,\n         err: &mut DiagnosticBuilder<'tcx>,\n         obligation: &PredicateObligation<'tcx>,\n@@ -2110,14 +948,17 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         err\n     }\n \n-    fn report_closure_arg_mismatch(\n+    crate fn report_closure_arg_mismatch(\n         &self,\n         span: Span,\n         found_span: Option<Span>,\n         expected_ref: ty::PolyTraitRef<'tcx>,\n         found: ty::PolyTraitRef<'tcx>,\n     ) -> DiagnosticBuilder<'tcx> {\n-        fn build_fn_sig_string<'tcx>(tcx: TyCtxt<'tcx>, trait_ref: &ty::TraitRef<'tcx>) -> String {\n+        crate fn build_fn_sig_string<'tcx>(\n+            tcx: TyCtxt<'tcx>,\n+            trait_ref: &ty::TraitRef<'tcx>,\n+        ) -> String {\n             let inputs = trait_ref.substs.type_at(1);\n             let sig = if let ty::Tuple(inputs) = inputs.kind {\n                 tcx.mk_fn_sig(\n@@ -2165,238 +1006,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn recursive_type_with_infinite_size_error(\n-    tcx: TyCtxt<'tcx>,\n-    type_def_id: DefId,\n-) -> DiagnosticBuilder<'tcx> {\n-    assert!(type_def_id.is_local());\n-    let span = tcx.hir().span_if_local(type_def_id).unwrap();\n-    let span = tcx.sess.source_map().def_span(span);\n-    let mut err = struct_span_err!(\n-        tcx.sess,\n-        span,\n-        E0072,\n-        \"recursive type `{}` has infinite size\",\n-        tcx.def_path_str(type_def_id)\n-    );\n-    err.span_label(span, \"recursive type has infinite size\");\n-    err.help(&format!(\n-        \"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n-                           at some point to make `{}` representable\",\n-        tcx.def_path_str(type_def_id)\n-    ));\n-    err\n-}\n-\n-pub fn report_object_safety_error(\n-    tcx: TyCtxt<'tcx>,\n-    span: Span,\n-    trait_def_id: DefId,\n-    violations: Vec<ObjectSafetyViolation>,\n-) -> DiagnosticBuilder<'tcx> {\n-    let trait_str = tcx.def_path_str(trait_def_id);\n-    let span = tcx.sess.source_map().def_span(span);\n-    let mut err = struct_span_err!(\n-        tcx.sess,\n-        span,\n-        E0038,\n-        \"the trait `{}` cannot be made into an object\",\n-        trait_str\n-    );\n-    err.span_label(span, format!(\"the trait `{}` cannot be made into an object\", trait_str));\n-\n-    let mut reported_violations = FxHashSet::default();\n-    for violation in violations {\n-        if reported_violations.insert(violation.clone()) {\n-            match violation.span() {\n-                Some(span) => err.span_label(span, violation.error_msg()),\n-                None => err.note(&violation.error_msg()),\n-            };\n-        }\n-    }\n-\n-    if tcx.sess.trait_methods_not_found.borrow().contains(&span) {\n-        // Avoid emitting error caused by non-existing method (#58734)\n-        err.cancel();\n-    }\n-\n-    err\n-}\n-\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    fn maybe_report_ambiguity(\n-        &self,\n-        obligation: &PredicateObligation<'tcx>,\n-        body_id: Option<hir::BodyId>,\n-    ) {\n-        // Unable to successfully determine, probably means\n-        // insufficient type information, but could mean\n-        // ambiguous impls. The latter *ought* to be a\n-        // coherence violation, so we don't report it here.\n-\n-        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n-        let span = obligation.cause.span;\n-\n-        debug!(\n-            \"maybe_report_ambiguity(predicate={:?}, obligation={:?} body_id={:?}, code={:?})\",\n-            predicate, obligation, body_id, obligation.cause.code,\n-        );\n-\n-        // Ambiguity errors are often caused as fallout from earlier\n-        // errors. So just ignore them if this infcx is tainted.\n-        if self.is_tainted_by_errors() {\n-            return;\n-        }\n-\n-        let mut err = match predicate {\n-            ty::Predicate::Trait(ref data) => {\n-                let trait_ref = data.to_poly_trait_ref();\n-                let self_ty = trait_ref.self_ty();\n-                debug!(\"self_ty {:?} {:?} trait_ref {:?}\", self_ty, self_ty.kind, trait_ref);\n-\n-                if predicate.references_error() {\n-                    return;\n-                }\n-                // Typically, this ambiguity should only happen if\n-                // there are unresolved type inference variables\n-                // (otherwise it would suggest a coherence\n-                // failure). But given #21974 that is not necessarily\n-                // the case -- we can have multiple where clauses that\n-                // are only distinguished by a region, which results\n-                // in an ambiguity even when all types are fully\n-                // known, since we don't dispatch based on region\n-                // relationships.\n-\n-                // This is kind of a hack: it frequently happens that some earlier\n-                // error prevents types from being fully inferred, and then we get\n-                // a bunch of uninteresting errors saying something like \"<generic\n-                // #0> doesn't implement Sized\".  It may even be true that we\n-                // could just skip over all checks where the self-ty is an\n-                // inference variable, but I was afraid that there might be an\n-                // inference variable created, registered as an obligation, and\n-                // then never forced by writeback, and hence by skipping here we'd\n-                // be ignoring the fact that we don't KNOW the type works\n-                // out. Though even that would probably be harmless, given that\n-                // we're only talking about builtin traits, which are known to be\n-                // inhabited. We used to check for `self.tcx.sess.has_errors()` to\n-                // avoid inundating the user with unnecessary errors, but we now\n-                // check upstream for type errors and dont add the obligations to\n-                // begin with in those cases.\n-                if self\n-                    .tcx\n-                    .lang_items()\n-                    .sized_trait()\n-                    .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n-                {\n-                    self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0282).emit();\n-                    return;\n-                }\n-                let mut err = self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0283);\n-                err.note(&format!(\"cannot resolve `{}`\", predicate));\n-                if let ObligationCauseCode::ItemObligation(def_id) = obligation.cause.code {\n-                    self.suggest_fully_qualified_path(&mut err, def_id, span, trait_ref.def_id());\n-                } else if let (\n-                    Ok(ref snippet),\n-                    ObligationCauseCode::BindingObligation(ref def_id, _),\n-                ) =\n-                    (self.tcx.sess.source_map().span_to_snippet(span), &obligation.cause.code)\n-                {\n-                    let generics = self.tcx.generics_of(*def_id);\n-                    if !generics.params.is_empty() && !snippet.ends_with('>') {\n-                        // FIXME: To avoid spurious suggestions in functions where type arguments\n-                        // where already supplied, we check the snippet to make sure it doesn't\n-                        // end with a turbofish. Ideally we would have access to a `PathSegment`\n-                        // instead. Otherwise we would produce the following output:\n-                        //\n-                        // error[E0283]: type annotations needed\n-                        //   --> $DIR/issue-54954.rs:3:24\n-                        //    |\n-                        // LL | const ARR_LEN: usize = Tt::const_val::<[i8; 123]>();\n-                        //    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-                        //    |                        |\n-                        //    |                        cannot infer type\n-                        //    |                        help: consider specifying the type argument\n-                        //    |                        in the function call:\n-                        //    |                        `Tt::const_val::<[i8; 123]>::<T>`\n-                        // ...\n-                        // LL |     const fn const_val<T: Sized>() -> usize {\n-                        //    |              --------- - required by this bound in `Tt::const_val`\n-                        //    |\n-                        //    = note: cannot resolve `_: Tt`\n-\n-                        err.span_suggestion(\n-                            span,\n-                            &format!(\n-                                \"consider specifying the type argument{} in the function call\",\n-                                if generics.params.len() > 1 { \"s\" } else { \"\" },\n-                            ),\n-                            format!(\n-                                \"{}::<{}>\",\n-                                snippet,\n-                                generics\n-                                    .params\n-                                    .iter()\n-                                    .map(|p| p.name.to_string())\n-                                    .collect::<Vec<String>>()\n-                                    .join(\", \")\n-                            ),\n-                            Applicability::HasPlaceholders,\n-                        );\n-                    }\n-                }\n-                err\n-            }\n-\n-            ty::Predicate::WellFormed(ty) => {\n-                // Same hacky approach as above to avoid deluging user\n-                // with error messages.\n-                if ty.references_error() || self.tcx.sess.has_errors() {\n-                    return;\n-                }\n-                self.need_type_info_err(body_id, span, ty, ErrorCode::E0282)\n-            }\n-\n-            ty::Predicate::Subtype(ref data) => {\n-                if data.references_error() || self.tcx.sess.has_errors() {\n-                    // no need to overload user in such cases\n-                    return;\n-                }\n-                let &SubtypePredicate { a_is_expected: _, a, b } = data.skip_binder();\n-                // both must be type variables, or the other would've been instantiated\n-                assert!(a.is_ty_var() && b.is_ty_var());\n-                self.need_type_info_err(body_id, span, a, ErrorCode::E0282)\n-            }\n-            ty::Predicate::Projection(ref data) => {\n-                let trait_ref = data.to_poly_trait_ref(self.tcx);\n-                let self_ty = trait_ref.self_ty();\n-                if predicate.references_error() {\n-                    return;\n-                }\n-                let mut err = self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0284);\n-                err.note(&format!(\"cannot resolve `{}`\", predicate));\n-                err\n-            }\n-\n-            _ => {\n-                if self.tcx.sess.has_errors() {\n-                    return;\n-                }\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0284,\n-                    \"type annotations needed: cannot resolve `{}`\",\n-                    predicate,\n-                );\n-                err.span_label(span, &format!(\"cannot resolve `{}`\", predicate));\n-                err\n-            }\n-        };\n-        self.note_obligation_cause(&mut err, obligation);\n-        err.emit();\n-    }\n-\n-    fn suggest_fully_qualified_path(\n+    crate fn suggest_fully_qualified_path(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         def_id: DefId,\n@@ -2420,76 +1031,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    /// Returns `true` if the trait predicate may apply for *some* assignment\n-    /// to the type parameters.\n-    fn predicate_can_apply(\n-        &self,\n-        param_env: ty::ParamEnv<'tcx>,\n-        pred: ty::PolyTraitRef<'tcx>,\n-    ) -> bool {\n-        struct ParamToVarFolder<'a, 'tcx> {\n-            infcx: &'a InferCtxt<'a, 'tcx>,\n-            var_map: FxHashMap<Ty<'tcx>, Ty<'tcx>>,\n-        }\n-\n-        impl<'a, 'tcx> TypeFolder<'tcx> for ParamToVarFolder<'a, 'tcx> {\n-            fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n-                self.infcx.tcx\n-            }\n-\n-            fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-                if let ty::Param(ty::ParamTy { name, .. }) = ty.kind {\n-                    let infcx = self.infcx;\n-                    self.var_map.entry(ty).or_insert_with(|| {\n-                        infcx.next_ty_var(TypeVariableOrigin {\n-                            kind: TypeVariableOriginKind::TypeParameterDefinition(name, None),\n-                            span: DUMMY_SP,\n-                        })\n-                    })\n-                } else {\n-                    ty.super_fold_with(self)\n-                }\n-            }\n-        }\n-\n-        self.probe(|_| {\n-            let mut selcx = SelectionContext::new(self);\n-\n-            let cleaned_pred =\n-                pred.fold_with(&mut ParamToVarFolder { infcx: self, var_map: Default::default() });\n-\n-            let cleaned_pred = super::project::normalize(\n-                &mut selcx,\n-                param_env,\n-                ObligationCause::dummy(),\n-                &cleaned_pred,\n-            )\n-            .value;\n-\n-            let obligation =\n-                Obligation::new(ObligationCause::dummy(), param_env, cleaned_pred.to_predicate());\n-\n-            self.predicate_may_hold(&obligation)\n-        })\n-    }\n-\n-    fn note_obligation_cause(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        obligation: &PredicateObligation<'tcx>,\n-    ) {\n-        // First, attempt to add note to this error with an async-await-specific\n-        // message, and fall back to regular note otherwise.\n-        if !self.maybe_note_obligation_cause_for_async_await(err, obligation) {\n-            self.note_obligation_cause_code(\n-                err,\n-                &obligation.predicate,\n-                &obligation.cause.code,\n-                &mut vec![],\n-            );\n-        }\n-    }\n-\n     /// Adds an async-await specific note to the diagnostic when the future does not implement\n     /// an auto trait because of a captured type.\n     ///\n@@ -2532,7 +1073,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// ```\n     ///\n     /// Returns `true` if an async-await specific note was added to the diagnostic.\n-    fn maybe_note_obligation_cause_for_async_await(\n+    crate fn maybe_note_obligation_cause_for_async_await(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         obligation: &PredicateObligation<'tcx>,\n@@ -2712,7 +1253,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     /// Unconditionally adds the diagnostic note described in\n     /// `maybe_note_obligation_cause_for_async_await`'s documentation comment.\n-    fn note_obligation_cause_for_async_await(\n+    crate fn note_obligation_cause_for_async_await(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         target_span: Span,\n@@ -2838,7 +1379,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         );\n     }\n \n-    fn note_obligation_cause_code<T>(\n+    crate fn note_obligation_cause_code<T>(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         predicate: &T,\n@@ -3053,60 +1594,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn suggest_new_overflow_limit(&self, err: &mut DiagnosticBuilder<'_>) {\n+    crate fn suggest_new_overflow_limit(&self, err: &mut DiagnosticBuilder<'_>) {\n         let current_limit = self.tcx.sess.recursion_limit.get();\n         let suggested_limit = current_limit * 2;\n         err.help(&format!(\n             \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n             suggested_limit\n         ));\n     }\n-\n-    fn is_recursive_obligation(\n-        &self,\n-        obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n-        cause_code: &ObligationCauseCode<'tcx>,\n-    ) -> bool {\n-        if let ObligationCauseCode::BuiltinDerivedObligation(ref data) = cause_code {\n-            let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n-\n-            if obligated_types.iter().any(|ot| ot == &parent_trait_ref.skip_binder().self_ty()) {\n-                return true;\n-            }\n-        }\n-        false\n-    }\n-}\n-\n-/// Summarizes information\n-#[derive(Clone)]\n-pub enum ArgKind {\n-    /// An argument of non-tuple type. Parameters are (name, ty)\n-    Arg(String, String),\n-\n-    /// An argument of tuple type. For a \"found\" argument, the span is\n-    /// the locationo in the source of the pattern. For a \"expected\"\n-    /// argument, it will be None. The vector is a list of (name, ty)\n-    /// strings for the components of the tuple.\n-    Tuple(Option<Span>, Vec<(String, String)>),\n-}\n-\n-impl ArgKind {\n-    fn empty() -> ArgKind {\n-        ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned())\n-    }\n-\n-    /// Creates an `ArgKind` from the expected type of an\n-    /// argument. It has no name (`_`) and an optional source span.\n-    pub fn from_expected_ty(t: Ty<'_>, span: Option<Span>) -> ArgKind {\n-        match t.kind {\n-            ty::Tuple(ref tys) => ArgKind::Tuple(\n-                span,\n-                tys.iter().map(|ty| (\"_\".to_owned(), ty.to_string())).collect::<Vec<_>>(),\n-            ),\n-            _ => ArgKind::Arg(\"_\".to_owned(), t.to_string()),\n-        }\n-    }\n }\n \n /// Suggest restricting a type param with a new bound.", "previous_filename": "src/librustc/traits/error_reporting.rs"}]}