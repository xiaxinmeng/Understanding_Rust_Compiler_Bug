{"sha": "0004b3b984b19646c1f78b09ba497b7bd6e882c1", "node_id": "C_kwDOAAsO6NoAKDAwMDRiM2I5ODRiMTk2NDZjMWY3OGIwOWJhNDk3YjdiZDZlODgyYzE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-25T22:04:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-25T22:04:33Z"}, "message": "Auto merge of #111960 - compiler-errors:rollup-onka2dl, r=compiler-errors\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #107522 (Add Median of Medians fallback to introselect)\n - #111152 (update `pulldown-cmark` to `0.9.3`)\n - #111757 (Consider lint check attributes on match arms)\n - #111831 (Always capture slice when pattern requires checking the length)\n - #111929 (Don't print newlines in APITs)\n - #111945 (Migrate GUI colors test to original CSS color format)\n - #111950 (Remove ExpnKind::Inlined.)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "255ebd85d7c30ba43616a673bf014d19be47c1f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/255ebd85d7c30ba43616a673bf014d19be47c1f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0004b3b984b19646c1f78b09ba497b7bd6e882c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0004b3b984b19646c1f78b09ba497b7bd6e882c1", "html_url": "https://github.com/rust-lang/rust/commit/0004b3b984b19646c1f78b09ba497b7bd6e882c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0004b3b984b19646c1f78b09ba497b7bd6e882c1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2b1646c597329d0a25efa3889b66650f65de1de", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2b1646c597329d0a25efa3889b66650f65de1de", "html_url": "https://github.com/rust-lang/rust/commit/a2b1646c597329d0a25efa3889b66650f65de1de"}, {"sha": "c2e3521bfbef47939d858a0c9d11e08b71bc80c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2e3521bfbef47939d858a0c9d11e08b71bc80c0", "html_url": "https://github.com/rust-lang/rust/commit/c2e3521bfbef47939d858a0c9d11e08b71bc80c0"}], "stats": {"total": 1267, "additions": 856, "deletions": 411}, "files": [{"sha": "0369442f11cf6b2a9e270ee095dd44e529c7afe9", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -2779,9 +2779,9 @@ dependencies = [\n \n [[package]]\n name = \"pulldown-cmark\"\n-version = \"0.9.2\"\n+version = \"0.9.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2d9cc634bc78768157b5cbfe988ffcd1dcba95cd2b2f03a88316c08c6d00ed63\"\n+checksum = \"77a1a2f1f0a7ecff9c31abbe177637be0e97a0aef46cf8738ece09327985d998\"\n dependencies = [\n  \"bitflags\",\n  \"memchr\","}, {"sha": "8d4f96639efbd0d64a6553311d72b385bf900a88", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -1425,7 +1425,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             DefPathData::ImplTrait,\n                             span,\n                         );\n-                        let ident = Ident::from_str_and_span(&pprust::ty_to_string(t), span);\n+\n+                        // HACK: pprust breaks strings with newlines when the type\n+                        // gets too long. We don't want these to show up in compiler\n+                        // output or built artifacts, so replace them here...\n+                        // Perhaps we should instead format APITs more robustly.\n+                        let ident = Ident::from_str_and_span(\n+                            &pprust::ty_to_string(t).replace('\\n', \" \"),\n+                            span,\n+                        );\n+\n                         let (param, bounds, path) = self.lower_universal_param_and_bounds(\n                             *def_node_id,\n                             span,"}, {"sha": "5eaa988dd09298d0236ac93cf3a7a025dd3ad159", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -413,11 +413,7 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n \n     // Note: must be kept in sync with get_caller_location from cg_ssa\n     pub(crate) fn get_caller_location(&mut self, mut source_info: mir::SourceInfo) -> CValue<'tcx> {\n-        let span_to_caller_location = |fx: &mut FunctionCx<'_, '_, 'tcx>, mut span: Span| {\n-            // Remove `Inlined` marks as they pollute `expansion_cause`.\n-            while span.is_inlined() {\n-                span.remove_mark();\n-            }\n+        let span_to_caller_location = |fx: &mut FunctionCx<'_, '_, 'tcx>, span: Span| {\n             let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n             let caller = fx.tcx.sess.source_map().lookup_char_pos(topmost.lo());\n             let const_loc = fx.tcx.const_caller_location(("}, {"sha": "d516ac4ebb749aea478937d443439f605d1233ac", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -1450,11 +1450,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     ) -> OperandRef<'tcx, Bx::Value> {\n         let tcx = bx.tcx();\n \n-        let mut span_to_caller_location = |mut span: Span| {\n-            // Remove `Inlined` marks as they pollute `expansion_cause`.\n-            while span.is_inlined() {\n-                span.remove_mark();\n-            }\n+        let mut span_to_caller_location = |span: Span| {\n             let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n             let caller = tcx.sess.source_map().lookup_char_pos(topmost.lo());\n             let const_loc = tcx.const_caller_location(("}, {"sha": "7e94578003ebfc13159f14c17f5e949348041a3c", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -949,7 +949,20 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // This deliberately does *not* honor `requires_caller_location` since it is used for much\n         // more than just panics.\n         for frame in stack.iter().rev() {\n-            let span = frame.current_span();\n+            let span = match frame.loc {\n+                Left(loc) => {\n+                    // If the stacktrace passes through MIR-inlined source scopes, add them.\n+                    let mir::SourceInfo { mut span, scope } = *frame.body.source_info(loc);\n+                    let mut scope_data = &frame.body.source_scopes[scope];\n+                    while let Some((instance, call_span)) = scope_data.inlined {\n+                        frames.push(FrameInfo { span, instance });\n+                        span = call_span;\n+                        scope_data = &frame.body.source_scopes[scope_data.parent_scope.unwrap()];\n+                    }\n+                    span\n+                }\n+                Right(span) => span,\n+            };\n             frames.push(FrameInfo { span, instance: frame.instance });\n         }\n         trace!(\"generate stacktrace: {:#?}\", frames);"}, {"sha": "df5b581000b7d155242e9282b535ba56d31730bf", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -111,11 +111,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         location\n     }\n \n-    pub(crate) fn location_triple_for_span(&self, mut span: Span) -> (Symbol, u32, u32) {\n-        // Remove `Inlined` marks as they pollute `expansion_cause`.\n-        while span.is_inlined() {\n-            span.remove_mark();\n-        }\n+    pub(crate) fn location_triple_for_span(&self, span: Span) -> (Symbol, u32, u32) {\n         let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n         let caller = self.tcx.sess.source_map().lookup_char_pos(topmost.lo());\n         ("}, {"sha": "e8cd7eaa60f1acb02a3dcacb2b9290ce77dc0236", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -332,7 +332,7 @@ pub trait Emitter: Translate {\n \n                     // Skip past non-macro entries, just in case there\n                     // are some which do actually involve macros.\n-                    ExpnKind::Inlined | ExpnKind::Desugaring(..) | ExpnKind::AstPass(..) => None,\n+                    ExpnKind::Desugaring(..) | ExpnKind::AstPass(..) => None,\n \n                     ExpnKind::Macro(macro_kind, name) => Some((macro_kind, name)),\n                 }\n@@ -403,7 +403,7 @@ pub trait Emitter: Translate {\n                     continue;\n                 }\n \n-                if always_backtrace && !matches!(trace.kind, ExpnKind::Inlined) {\n+                if always_backtrace {\n                     new_labels.push((\n                         trace.def_site,\n                         format!(\n@@ -442,7 +442,6 @@ pub trait Emitter: Translate {\n                             \"this derive macro expansion\".into()\n                         }\n                         ExpnKind::Macro(MacroKind::Bang, _) => \"this macro invocation\".into(),\n-                        ExpnKind::Inlined => \"this inlined function call\".into(),\n                         ExpnKind::Root => \"the crate root\".into(),\n                         ExpnKind::AstPass(kind) => kind.descr().into(),\n                         ExpnKind::Desugaring(kind) => {"}, {"sha": "e14e8ac2ce0007fe4ff53c2f83cdedebcfc2f1cb", "filename": "compiler/rustc_hir_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -438,12 +438,19 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                         // to borrow discr.\n                         needs_to_be_read = true;\n                     }\n-                    PatKind::Or(_)\n-                    | PatKind::Box(_)\n-                    | PatKind::Slice(..)\n-                    | PatKind::Ref(..)\n-                    | PatKind::Wild => {\n-                        // If the PatKind is Or, Box, Slice or Ref, the decision is made later\n+                    PatKind::Slice(lhs, wild, rhs) => {\n+                        // We don't need to test the length if the pattern is `[..]`\n+                        if matches!((lhs, wild, rhs), (&[], Some(_), &[]))\n+                            // Arrays have a statically known size, so\n+                            // there is no need to read their length\n+                            || discr_place.place.base_ty.is_array()\n+                        {\n+                        } else {\n+                            needs_to_be_read = true;\n+                        }\n+                    }\n+                    PatKind::Or(_) | PatKind::Box(_) | PatKind::Ref(..) | PatKind::Wild => {\n+                        // If the PatKind is Or, Box, or Ref, the decision is made later\n                         // as these patterns contains subpatterns\n                         // If the PatKind is Wild, the decision is made based on the other patterns being\n                         // examined"}, {"sha": "8a4a451f8a837377ff2f6fa4e9d2a442937b3541", "filename": "compiler/rustc_lint/src/late.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flate.rs?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -240,8 +240,10 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n     }\n \n     fn visit_arm(&mut self, a: &'tcx hir::Arm<'tcx>) {\n-        lint_callback!(self, check_arm, a);\n-        hir_visit::walk_arm(self, a);\n+        self.with_lint_attrs(a.hir_id, |cx| {\n+            lint_callback!(cx, check_arm, a);\n+            hir_visit::walk_arm(cx, a);\n+        })\n     }\n \n     fn visit_generic_param(&mut self, p: &'tcx hir::GenericParam<'tcx>) {"}, {"sha": "14343ac1108b2dfb1269e57b61aa616d6d2c0e2e", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -468,8 +468,7 @@ pub fn struct_lint_level(\n pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n     let expn_data = span.ctxt().outer_expn_data();\n     match expn_data.kind {\n-        ExpnKind::Inlined\n-        | ExpnKind::Root\n+        ExpnKind::Root\n         | ExpnKind::Desugaring(\n             DesugaringKind::ForLoop | DesugaringKind::WhileLoop | DesugaringKind::OpaqueTy,\n         ) => false,"}, {"sha": "a8d0dca37ff99e43049d3409db9306c435083402", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -2488,9 +2488,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             && if self.features().collapse_debuginfo {\n                 span.in_macro_expansion_with_collapse_debuginfo()\n             } else {\n-                // Inlined spans should not be collapsed as that leads to all of the\n-                // inlined code being attributed to the inline callsite.\n-                span.from_expansion() && !span.is_inlined()\n+                span.from_expansion()\n             }\n     }\n "}, {"sha": "c11a4f7229dac4df4445d1b981580ef40ae489c7", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 35, "deletions": 23, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -90,35 +90,34 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for MatchVisitor<'a, '_, 'tcx> {\n \n     #[instrument(level = \"trace\", skip(self))]\n     fn visit_arm(&mut self, arm: &Arm<'tcx>) {\n-        match arm.guard {\n-            Some(Guard::If(expr)) => {\n-                self.with_let_source(LetSource::IfLetGuard, |this| {\n-                    this.visit_expr(&this.thir[expr])\n-                });\n-            }\n-            Some(Guard::IfLet(ref pat, expr)) => {\n-                self.with_let_source(LetSource::IfLetGuard, |this| {\n-                    this.check_let(pat, expr, LetSource::IfLetGuard, pat.span);\n-                    this.visit_pat(pat);\n-                    this.visit_expr(&this.thir[expr]);\n-                });\n+        self.with_lint_level(arm.lint_level, |this| {\n+            match arm.guard {\n+                Some(Guard::If(expr)) => {\n+                    this.with_let_source(LetSource::IfLetGuard, |this| {\n+                        this.visit_expr(&this.thir[expr])\n+                    });\n+                }\n+                Some(Guard::IfLet(ref pat, expr)) => {\n+                    this.with_let_source(LetSource::IfLetGuard, |this| {\n+                        this.check_let(pat, expr, LetSource::IfLetGuard, pat.span);\n+                        this.visit_pat(pat);\n+                        this.visit_expr(&this.thir[expr]);\n+                    });\n+                }\n+                None => {}\n             }\n-            None => {}\n-        }\n-        self.visit_pat(&arm.pattern);\n-        self.visit_expr(&self.thir[arm.body]);\n+            this.visit_pat(&arm.pattern);\n+            this.visit_expr(&self.thir[arm.body]);\n+        });\n     }\n \n     #[instrument(level = \"trace\", skip(self))]\n     fn visit_expr(&mut self, ex: &Expr<'tcx>) {\n         match ex.kind {\n             ExprKind::Scope { value, lint_level, .. } => {\n-                let old_lint_level = self.lint_level;\n-                if let LintLevel::Explicit(hir_id) = lint_level {\n-                    self.lint_level = hir_id;\n-                }\n-                self.visit_expr(&self.thir[value]);\n-                self.lint_level = old_lint_level;\n+                self.with_lint_level(lint_level, |this| {\n+                    this.visit_expr(&this.thir[value]);\n+                });\n                 return;\n             }\n             ExprKind::If { cond, then, else_opt, if_then_scope: _ } => {\n@@ -190,6 +189,17 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n         self.let_source = old_let_source;\n     }\n \n+    fn with_lint_level(&mut self, new_lint_level: LintLevel, f: impl FnOnce(&mut Self)) {\n+        if let LintLevel::Explicit(hir_id) = new_lint_level {\n+            let old_lint_level = self.lint_level;\n+            self.lint_level = hir_id;\n+            f(self);\n+            self.lint_level = old_lint_level;\n+        } else {\n+            f(self);\n+        }\n+    }\n+\n     fn check_patterns(&self, pat: &Pat<'tcx>, rf: RefutableFlag) {\n         pat.walk_always(|pat| check_borrow_conflicts_in_at_patterns(self, pat));\n         check_for_bindings_named_same_as_variants(self, pat, rf);\n@@ -236,7 +246,9 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n         for &arm in arms {\n             // Check the arm for some things unrelated to exhaustiveness.\n             let arm = &self.thir.arms[arm];\n-            self.check_patterns(&arm.pattern, Refutable);\n+            self.with_lint_level(arm.lint_level, |this| {\n+                this.check_patterns(&arm.pattern, Refutable);\n+            });\n         }\n \n         let tarms: Vec<_> = arms"}, {"sha": "1748b1bf4a02a513184523f163637bcd8f7c8890", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -10,7 +10,6 @@ use rustc_middle::mir::*;\n use rustc_middle::ty::TypeVisitableExt;\n use rustc_middle::ty::{self, Instance, InstanceDef, ParamEnv, Ty, TyCtxt};\n use rustc_session::config::OptLevel;\n-use rustc_span::{hygiene::ExpnKind, ExpnData, LocalExpnId, Span};\n use rustc_target::abi::{FieldIdx, FIRST_VARIANT};\n use rustc_target::spec::abi::Abi;\n \n@@ -551,16 +550,6 @@ impl<'tcx> Inliner<'tcx> {\n                 // Copy the arguments if needed.\n                 let args: Vec<_> = self.make_call_args(args, &callsite, caller_body, &callee_body);\n \n-                let mut expn_data = ExpnData::default(\n-                    ExpnKind::Inlined,\n-                    callsite.source_info.span,\n-                    self.tcx.sess.edition(),\n-                    None,\n-                    None,\n-                );\n-                expn_data.def_site = callee_body.span;\n-                let expn_data =\n-                    self.tcx.with_stable_hashing_context(|hcx| LocalExpnId::fresh(expn_data, hcx));\n                 let mut integrator = Integrator {\n                     args: &args,\n                     new_locals: Local::new(caller_body.local_decls.len())..,\n@@ -572,7 +561,6 @@ impl<'tcx> Inliner<'tcx> {\n                     cleanup_block: unwind,\n                     in_cleanup_block: false,\n                     tcx: self.tcx,\n-                    expn_data,\n                     always_live_locals: BitSet::new_filled(callee_body.local_decls.len()),\n                 };\n \n@@ -956,7 +944,6 @@ struct Integrator<'a, 'tcx> {\n     cleanup_block: UnwindAction,\n     in_cleanup_block: bool,\n     tcx: TyCtxt<'tcx>,\n-    expn_data: LocalExpnId,\n     always_live_locals: BitSet<Local>,\n }\n \n@@ -1042,11 +1029,6 @@ impl<'tcx> MutVisitor<'tcx> for Integrator<'_, 'tcx> {\n         *scope = self.map_scope(*scope);\n     }\n \n-    fn visit_span(&mut self, span: &mut Span) {\n-        // Make sure that all spans track the fact that they were inlined.\n-        *span = span.fresh_expansion(self.expn_data);\n-    }\n-\n     fn visit_basic_block_data(&mut self, block: BasicBlock, data: &mut BasicBlockData<'tcx>) {\n         self.in_cleanup_block = data.is_cleanup;\n         self.super_basic_block_data(block, data);"}, {"sha": "46da0aa2853ef1fc10068fa9a57de016bf7d9791", "filename": "compiler/rustc_resolve/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_resolve%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_resolve%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2FCargo.toml?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -7,7 +7,7 @@ edition = \"2021\"\n \n [dependencies]\n bitflags = \"1.2.1\"\n-pulldown-cmark = { version = \"0.9.2\", default-features = false }\n+pulldown-cmark = { version = \"0.9.3\", default-features = false }\n rustc_arena = { path = \"../rustc_arena\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }"}, {"sha": "6755657c7276eb54fc5161e02f174ff7d0c68b93", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -320,7 +320,6 @@ impl ExpnId {\n             // Stop going up the backtrace once include! is encountered\n             if expn_data.is_root()\n                 || expn_data.kind == ExpnKind::Macro(MacroKind::Bang, sym::include)\n-                || expn_data.kind == ExpnKind::Inlined\n             {\n                 break;\n             }\n@@ -1058,8 +1057,6 @@ pub enum ExpnKind {\n     AstPass(AstPass),\n     /// Desugaring done by the compiler during HIR lowering.\n     Desugaring(DesugaringKind),\n-    /// MIR inlining\n-    Inlined,\n }\n \n impl ExpnKind {\n@@ -1073,7 +1070,6 @@ impl ExpnKind {\n             },\n             ExpnKind::AstPass(kind) => kind.descr().to_string(),\n             ExpnKind::Desugaring(kind) => format!(\"desugaring of {}\", kind.descr()),\n-            ExpnKind::Inlined => \"inlined source\".to_string(),\n         }\n     }\n }"}, {"sha": "eae3f0fa041dd1cd19ec750518d2e08eb9227e6b", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -594,12 +594,6 @@ impl Span {\n         matches!(outer_expn.kind, ExpnKind::Macro(..)) && outer_expn.collapse_debuginfo\n     }\n \n-    /// Returns `true` if this span comes from MIR inlining.\n-    pub fn is_inlined(self) -> bool {\n-        let outer_expn = self.ctxt().outer_expn_data();\n-        matches!(outer_expn.kind, ExpnKind::Inlined)\n-    }\n-\n     /// Returns `true` if `span` originates in a derive-macro's expansion.\n     pub fn in_derive_expansion(self) -> bool {\n         matches!(self.ctxt().outer_expn_data().kind, ExpnKind::Macro(MacroKind::Derive, _))"}, {"sha": "bd1b16e8d73ed64ba33beeae533269aa685cb4c2", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -42,6 +42,7 @@ mod index;\n mod iter;\n mod raw;\n mod rotate;\n+mod select;\n mod specialize;\n \n #[unstable(feature = \"str_internals\", issue = \"none\")]\n@@ -3034,7 +3035,7 @@ impl<T> [T] {\n     where\n         T: Ord,\n     {\n-        sort::partition_at_index(self, index, T::lt)\n+        select::partition_at_index(self, index, T::lt)\n     }\n \n     /// Reorder the slice with a comparator function such that the element at `index` is at its\n@@ -3089,7 +3090,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T, &T) -> Ordering,\n     {\n-        sort::partition_at_index(self, index, |a: &T, b: &T| compare(a, b) == Less)\n+        select::partition_at_index(self, index, |a: &T, b: &T| compare(a, b) == Less)\n     }\n \n     /// Reorder the slice with a key extraction function such that the element at `index` is at its\n@@ -3145,7 +3146,7 @@ impl<T> [T] {\n         F: FnMut(&T) -> K,\n         K: Ord,\n     {\n-        sort::partition_at_index(self, index, |a: &T, b: &T| f(a).lt(&f(b)))\n+        select::partition_at_index(self, index, |a: &T, b: &T| f(a).lt(&f(b)))\n     }\n \n     /// Moves all consecutive repeated elements to the end of the slice according to the"}, {"sha": "ffc193578e075cebcbe9fd0e24c0b89237cbed49", "filename": "library/core/src/slice/select.rs", "status": "added", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/library%2Fcore%2Fsrc%2Fslice%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/library%2Fcore%2Fsrc%2Fslice%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fselect.rs?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -0,0 +1,302 @@\n+//! Slice selection\n+//!\n+//! This module contains the implementation for `slice::select_nth_unstable`.\n+//! It uses an introselect algorithm based on Orson Peters' pattern-defeating quicksort,\n+//! published at: <https://github.com/orlp/pdqsort>\n+//!\n+//! The fallback algorithm used for introselect is Median of Medians using Tukey's Ninther\n+//! for pivot selection. Using this as a fallback ensures O(n) worst case running time with\n+//! better performance than one would get using heapsort as fallback.\n+\n+use crate::cmp;\n+use crate::mem::{self, SizedTypeProperties};\n+use crate::slice::sort::{\n+    break_patterns, choose_pivot, insertion_sort_shift_left, partition, partition_equal,\n+};\n+\n+// For slices of up to this length it's probably faster to simply sort them.\n+// Defined at the module scope because it's used in multiple functions.\n+const MAX_INSERTION: usize = 10;\n+\n+fn partition_at_index_loop<'a, T, F>(\n+    mut v: &'a mut [T],\n+    mut index: usize,\n+    is_less: &mut F,\n+    mut pred: Option<&'a T>,\n+) where\n+    F: FnMut(&T, &T) -> bool,\n+{\n+    // Limit the amount of iterations and fall back to fast deterministic selection\n+    // to ensure O(n) worst case running time. This limit needs to be constant, because\n+    // using `ilog2(len)` like in `sort` would result in O(n log n) time complexity.\n+    // The exact value of the limit is chosen somewhat arbitrarily, but for most inputs bad pivot\n+    // selections should be relatively rare, so the limit usually shouldn't be reached\n+    // anyways.\n+    let mut limit = 16;\n+\n+    // True if the last partitioning was reasonably balanced.\n+    let mut was_balanced = true;\n+\n+    loop {\n+        if v.len() <= MAX_INSERTION {\n+            if v.len() > 1 {\n+                insertion_sort_shift_left(v, 1, is_less);\n+            }\n+            return;\n+        }\n+\n+        if limit == 0 {\n+            median_of_medians(v, is_less, index);\n+            return;\n+        }\n+\n+        // If the last partitioning was imbalanced, try breaking patterns in the slice by shuffling\n+        // some elements around. Hopefully we'll choose a better pivot this time.\n+        if !was_balanced {\n+            break_patterns(v);\n+            limit -= 1;\n+        }\n+\n+        // Choose a pivot\n+        let (pivot, _) = choose_pivot(v, is_less);\n+\n+        // If the chosen pivot is equal to the predecessor, then it's the smallest element in the\n+        // slice. Partition the slice into elements equal to and elements greater than the pivot.\n+        // This case is usually hit when the slice contains many duplicate elements.\n+        if let Some(p) = pred {\n+            if !is_less(p, &v[pivot]) {\n+                let mid = partition_equal(v, pivot, is_less);\n+\n+                // If we've passed our index, then we're good.\n+                if mid > index {\n+                    return;\n+                }\n+\n+                // Otherwise, continue sorting elements greater than the pivot.\n+                v = &mut v[mid..];\n+                index = index - mid;\n+                pred = None;\n+                continue;\n+            }\n+        }\n+\n+        let (mid, _) = partition(v, pivot, is_less);\n+        was_balanced = cmp::min(mid, v.len() - mid) >= v.len() / 8;\n+\n+        // Split the slice into `left`, `pivot`, and `right`.\n+        let (left, right) = v.split_at_mut(mid);\n+        let (pivot, right) = right.split_at_mut(1);\n+        let pivot = &pivot[0];\n+\n+        if mid < index {\n+            v = right;\n+            index = index - mid - 1;\n+            pred = Some(pivot);\n+        } else if mid > index {\n+            v = left;\n+        } else {\n+            // If mid == index, then we're done, since partition() guaranteed that all elements\n+            // after mid are greater than or equal to mid.\n+            return;\n+        }\n+    }\n+}\n+\n+/// Helper function that returns the index of the minimum element in the slice using the given\n+/// comparator function\n+fn min_index<T, F: FnMut(&T, &T) -> bool>(slice: &[T], is_less: &mut F) -> Option<usize> {\n+    slice\n+        .iter()\n+        .enumerate()\n+        .reduce(|acc, t| if is_less(t.1, acc.1) { t } else { acc })\n+        .map(|(i, _)| i)\n+}\n+\n+/// Helper function that returns the index of the maximum element in the slice using the given\n+/// comparator function\n+fn max_index<T, F: FnMut(&T, &T) -> bool>(slice: &[T], is_less: &mut F) -> Option<usize> {\n+    slice\n+        .iter()\n+        .enumerate()\n+        .reduce(|acc, t| if is_less(acc.1, t.1) { t } else { acc })\n+        .map(|(i, _)| i)\n+}\n+\n+/// Reorder the slice such that the element at `index` is at its final sorted position.\n+pub fn partition_at_index<T, F>(\n+    v: &mut [T],\n+    index: usize,\n+    mut is_less: F,\n+) -> (&mut [T], &mut T, &mut [T])\n+where\n+    F: FnMut(&T, &T) -> bool,\n+{\n+    if index >= v.len() {\n+        panic!(\"partition_at_index index {} greater than length of slice {}\", index, v.len());\n+    }\n+\n+    if T::IS_ZST {\n+        // Sorting has no meaningful behavior on zero-sized types. Do nothing.\n+    } else if index == v.len() - 1 {\n+        // Find max element and place it in the last position of the array. We're free to use\n+        // `unwrap()` here because we know v must not be empty.\n+        let max_idx = max_index(v, &mut is_less).unwrap();\n+        v.swap(max_idx, index);\n+    } else if index == 0 {\n+        // Find min element and place it in the first position of the array. We're free to use\n+        // `unwrap()` here because we know v must not be empty.\n+        let min_idx = min_index(v, &mut is_less).unwrap();\n+        v.swap(min_idx, index);\n+    } else {\n+        partition_at_index_loop(v, index, &mut is_less, None);\n+    }\n+\n+    let (left, right) = v.split_at_mut(index);\n+    let (pivot, right) = right.split_at_mut(1);\n+    let pivot = &mut pivot[0];\n+    (left, pivot, right)\n+}\n+\n+/// Selection algorithm to select the k-th element from the slice in guaranteed O(n) time.\n+/// This is essentially a quickselect that uses Tukey's Ninther for pivot selection\n+fn median_of_medians<T, F: FnMut(&T, &T) -> bool>(mut v: &mut [T], is_less: &mut F, mut k: usize) {\n+    // Since this function isn't public, it should never be called with an out-of-bounds index.\n+    debug_assert!(k < v.len());\n+\n+    // If T is as ZST, `partition_at_index` will already return early.\n+    debug_assert!(!T::IS_ZST);\n+\n+    // We now know that `k < v.len() <= isize::MAX`\n+    loop {\n+        if v.len() <= MAX_INSERTION {\n+            if v.len() > 1 {\n+                insertion_sort_shift_left(v, 1, is_less);\n+            }\n+            return;\n+        }\n+\n+        // `median_of_{minima,maxima}` can't handle the extreme cases of the first/last element,\n+        // so we catch them here and just do a linear search.\n+        if k == v.len() - 1 {\n+            // Find max element and place it in the last position of the array. We're free to use\n+            // `unwrap()` here because we know v must not be empty.\n+            let max_idx = max_index(v, is_less).unwrap();\n+            v.swap(max_idx, k);\n+            return;\n+        } else if k == 0 {\n+            // Find min element and place it in the first position of the array. We're free to use\n+            // `unwrap()` here because we know v must not be empty.\n+            let min_idx = min_index(v, is_less).unwrap();\n+            v.swap(min_idx, k);\n+            return;\n+        }\n+\n+        let p = median_of_ninthers(v, is_less);\n+\n+        if p == k {\n+            return;\n+        } else if p > k {\n+            v = &mut v[..p];\n+        } else {\n+            // Since `p < k < v.len()`, `p + 1` doesn't overflow and is\n+            // a valid index into the slice.\n+            v = &mut v[p + 1..];\n+            k -= p + 1;\n+        }\n+    }\n+}\n+\n+// Optimized for when `k` lies somewhere in the middle of the slice. Selects a pivot\n+// as close as possible to the median of the slice. For more details on how the algorithm\n+// operates, refer to the paper <https://drops.dagstuhl.de/opus/volltexte/2017/7612/pdf/LIPIcs-SEA-2017-24.pdf>.\n+fn median_of_ninthers<T, F: FnMut(&T, &T) -> bool>(v: &mut [T], is_less: &mut F) -> usize {\n+    // use `saturating_mul` so the multiplication doesn't overflow on 16-bit platforms.\n+    let frac = if v.len() <= 1024 {\n+        v.len() / 12\n+    } else if v.len() <= 128_usize.saturating_mul(1024) {\n+        v.len() / 64\n+    } else {\n+        v.len() / 1024\n+    };\n+\n+    let pivot = frac / 2;\n+    let lo = v.len() / 2 - pivot;\n+    let hi = frac + lo;\n+    let gap = (v.len() - 9 * frac) / 4;\n+    let mut a = lo - 4 * frac - gap;\n+    let mut b = hi + gap;\n+    for i in lo..hi {\n+        ninther(v, is_less, a, i - frac, b, a + 1, i, b + 1, a + 2, i + frac, b + 2);\n+        a += 3;\n+        b += 3;\n+    }\n+\n+    median_of_medians(&mut v[lo..lo + frac], is_less, pivot);\n+    partition(v, lo + pivot, is_less).0\n+}\n+\n+/// Moves around the 9 elements at the indices a..i, such that\n+/// `v[d]` contains the median of the 9 elements and the other\n+/// elements are partitioned around it.\n+fn ninther<T, F: FnMut(&T, &T) -> bool>(\n+    v: &mut [T],\n+    is_less: &mut F,\n+    a: usize,\n+    mut b: usize,\n+    c: usize,\n+    mut d: usize,\n+    e: usize,\n+    mut f: usize,\n+    g: usize,\n+    mut h: usize,\n+    i: usize,\n+) {\n+    b = median_idx(v, is_less, a, b, c);\n+    h = median_idx(v, is_less, g, h, i);\n+    if is_less(&v[h], &v[b]) {\n+        mem::swap(&mut b, &mut h);\n+    }\n+    if is_less(&v[f], &v[d]) {\n+        mem::swap(&mut d, &mut f);\n+    }\n+    if is_less(&v[e], &v[d]) {\n+        // do nothing\n+    } else if is_less(&v[f], &v[e]) {\n+        d = f;\n+    } else {\n+        if is_less(&v[e], &v[b]) {\n+            v.swap(e, b);\n+        } else if is_less(&v[h], &v[e]) {\n+            v.swap(e, h);\n+        }\n+        return;\n+    }\n+    if is_less(&v[d], &v[b]) {\n+        d = b;\n+    } else if is_less(&v[h], &v[d]) {\n+        d = h;\n+    }\n+\n+    v.swap(d, e);\n+}\n+\n+/// returns the index pointing to the median of the 3\n+/// elements `v[a]`, `v[b]` and `v[c]`\n+fn median_idx<T, F: FnMut(&T, &T) -> bool>(\n+    v: &[T],\n+    is_less: &mut F,\n+    mut a: usize,\n+    b: usize,\n+    mut c: usize,\n+) -> usize {\n+    if is_less(&v[c], &v[a]) {\n+        mem::swap(&mut a, &mut c);\n+    }\n+    if is_less(&v[c], &v[b]) {\n+        return c;\n+    }\n+    if is_less(&v[b], &v[a]) {\n+        return a;\n+    }\n+    b\n+}"}, {"sha": "db76d26257aac8d7d416d1e25613c9e11c1b3351", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 5, "deletions": 137, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -145,7 +145,7 @@ where\n /// Never inline this function to avoid code bloat. It still optimizes nicely and has practically no\n /// performance impact. Even improving performance in some cases.\n #[inline(never)]\n-fn insertion_sort_shift_left<T, F>(v: &mut [T], offset: usize, is_less: &mut F)\n+pub(super) fn insertion_sort_shift_left<T, F>(v: &mut [T], offset: usize, is_less: &mut F)\n where\n     F: FnMut(&T, &T) -> bool,\n {\n@@ -557,7 +557,7 @@ where\n ///\n /// 1. Number of elements smaller than `v[pivot]`.\n /// 2. True if `v` was already partitioned.\n-fn partition<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> (usize, bool)\n+pub(super) fn partition<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> (usize, bool)\n where\n     F: FnMut(&T, &T) -> bool,\n {\n@@ -612,7 +612,7 @@ where\n ///\n /// Returns the number of elements equal to the pivot. It is assumed that `v` does not contain\n /// elements smaller than the pivot.\n-fn partition_equal<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> usize\n+pub(super) fn partition_equal<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> usize\n where\n     F: FnMut(&T, &T) -> bool,\n {\n@@ -670,7 +670,7 @@ where\n /// Scatters some elements around in an attempt to break patterns that might cause imbalanced\n /// partitions in quicksort.\n #[cold]\n-fn break_patterns<T>(v: &mut [T]) {\n+pub(super) fn break_patterns<T>(v: &mut [T]) {\n     let len = v.len();\n     if len >= 8 {\n         let mut seed = len;\n@@ -719,7 +719,7 @@ fn break_patterns<T>(v: &mut [T]) {\n /// Chooses a pivot in `v` and returns the index and `true` if the slice is likely already sorted.\n ///\n /// Elements in `v` might be reordered in the process.\n-fn choose_pivot<T, F>(v: &mut [T], is_less: &mut F) -> (usize, bool)\n+pub(super) fn choose_pivot<T, F>(v: &mut [T], is_less: &mut F) -> (usize, bool)\n where\n     F: FnMut(&T, &T) -> bool,\n {\n@@ -897,138 +897,6 @@ where\n     recurse(v, &mut is_less, None, limit);\n }\n \n-fn partition_at_index_loop<'a, T, F>(\n-    mut v: &'a mut [T],\n-    mut index: usize,\n-    is_less: &mut F,\n-    mut pred: Option<&'a T>,\n-) where\n-    F: FnMut(&T, &T) -> bool,\n-{\n-    // Limit the amount of iterations and fall back to heapsort, similarly to `slice::sort_unstable`.\n-    // This lowers the worst case running time from O(n^2) to O(n log n).\n-    // FIXME: Investigate whether it would be better to use something like Median of Medians\n-    // or Fast Deterministic Selection to guarantee O(n) worst case.\n-    let mut limit = usize::BITS - v.len().leading_zeros();\n-\n-    // True if the last partitioning was reasonably balanced.\n-    let mut was_balanced = true;\n-\n-    loop {\n-        let len = v.len();\n-\n-        // For slices of up to this length it's probably faster to simply sort them.\n-        const MAX_INSERTION: usize = 10;\n-        if len <= MAX_INSERTION {\n-            if len >= 2 {\n-                insertion_sort_shift_left(v, 1, is_less);\n-            }\n-            return;\n-        }\n-\n-        if limit == 0 {\n-            heapsort(v, is_less);\n-            return;\n-        }\n-\n-        // If the last partitioning was imbalanced, try breaking patterns in the slice by shuffling\n-        // some elements around. Hopefully we'll choose a better pivot this time.\n-        if !was_balanced {\n-            break_patterns(v);\n-            limit -= 1;\n-        }\n-\n-        // Choose a pivot\n-        let (pivot, _) = choose_pivot(v, is_less);\n-\n-        // If the chosen pivot is equal to the predecessor, then it's the smallest element in the\n-        // slice. Partition the slice into elements equal to and elements greater than the pivot.\n-        // This case is usually hit when the slice contains many duplicate elements.\n-        if let Some(p) = pred {\n-            if !is_less(p, &v[pivot]) {\n-                let mid = partition_equal(v, pivot, is_less);\n-\n-                // If we've passed our index, then we're good.\n-                if mid > index {\n-                    return;\n-                }\n-\n-                // Otherwise, continue sorting elements greater than the pivot.\n-                v = &mut v[mid..];\n-                index = index - mid;\n-                pred = None;\n-                continue;\n-            }\n-        }\n-\n-        let (mid, _) = partition(v, pivot, is_less);\n-        was_balanced = cmp::min(mid, len - mid) >= len / 8;\n-\n-        // Split the slice into `left`, `pivot`, and `right`.\n-        let (left, right) = v.split_at_mut(mid);\n-        let (pivot, right) = right.split_at_mut(1);\n-        let pivot = &pivot[0];\n-\n-        if mid < index {\n-            v = right;\n-            index = index - mid - 1;\n-            pred = Some(pivot);\n-        } else if mid > index {\n-            v = left;\n-        } else {\n-            // If mid == index, then we're done, since partition() guaranteed that all elements\n-            // after mid are greater than or equal to mid.\n-            return;\n-        }\n-    }\n-}\n-\n-/// Reorder the slice such that the element at `index` is at its final sorted position.\n-pub fn partition_at_index<T, F>(\n-    v: &mut [T],\n-    index: usize,\n-    mut is_less: F,\n-) -> (&mut [T], &mut T, &mut [T])\n-where\n-    F: FnMut(&T, &T) -> bool,\n-{\n-    use cmp::Ordering::Greater;\n-    use cmp::Ordering::Less;\n-\n-    if index >= v.len() {\n-        panic!(\"partition_at_index index {} greater than length of slice {}\", index, v.len());\n-    }\n-\n-    if T::IS_ZST {\n-        // Sorting has no meaningful behavior on zero-sized types. Do nothing.\n-    } else if index == v.len() - 1 {\n-        // Find max element and place it in the last position of the array. We're free to use\n-        // `unwrap()` here because we know v must not be empty.\n-        let (max_index, _) = v\n-            .iter()\n-            .enumerate()\n-            .max_by(|&(_, x), &(_, y)| if is_less(x, y) { Less } else { Greater })\n-            .unwrap();\n-        v.swap(max_index, index);\n-    } else if index == 0 {\n-        // Find min element and place it in the first position of the array. We're free to use\n-        // `unwrap()` here because we know v must not be empty.\n-        let (min_index, _) = v\n-            .iter()\n-            .enumerate()\n-            .min_by(|&(_, x), &(_, y)| if is_less(x, y) { Less } else { Greater })\n-            .unwrap();\n-        v.swap(min_index, index);\n-    } else {\n-        partition_at_index_loop(v, index, &mut is_less, None);\n-    }\n-\n-    let (left, right) = v.split_at_mut(index);\n-    let (pivot, right) = right.split_at_mut(1);\n-    let pivot = &mut pivot[0];\n-    (left, pivot, right)\n-}\n-\n /// Merges non-decreasing runs `v[..mid]` and `v[mid..]` using `buf` as temporary storage, and\n /// stores the result into `v[..]`.\n ///"}, {"sha": "1fa9f81447607bd725acaaf71b3070810331a526", "filename": "src/doc/rustdoc/src/how-to-write-documentation.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/src%2Fdoc%2Frustdoc%2Fsrc%2Fhow-to-write-documentation.md", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/src%2Fdoc%2Frustdoc%2Fsrc%2Fhow-to-write-documentation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fhow-to-write-documentation.md?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -165,15 +165,15 @@ extensions:\n ### Strikethrough\n \n Text may be rendered with a horizontal line through the center by wrapping the\n-text with two tilde characters on each side:\n+text with one or two tilde characters on each side:\n \n ```text\n-An example of ~~strikethrough text~~.\n+An example of ~~strikethrough text~~. You can also use ~single tildes~.\n ```\n \n This example will render as:\n \n-> An example of ~~strikethrough text~~.\n+> An example of ~~strikethrough text~~. You can also use ~single tildes~.\n \n This follows the [GitHub Strikethrough extension][strikethrough].\n "}, {"sha": "b9199cff079e79096a03ab5bd28478be56e94dcc", "filename": "src/tools/miri/tests/fail/terminate-terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fterminate-terminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fterminate-terminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fterminate-terminator.rs?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -12,13 +12,13 @@ impl Drop for Foo {\n \n #[inline(always)]\n fn has_cleanup() {\n+    //~^ ERROR: panic in a function that cannot unwind\n     let _f = Foo;\n     panic!();\n }\n \n extern \"C\" fn panic_abort() {\n     has_cleanup();\n-    //~^ ERROR: panic in a function that cannot unwind\n }\n \n fn main() {"}, {"sha": "d73e23a53d0d9d74230d9d6bbca9e57beba2b0f5", "filename": "src/tools/miri/tests/fail/terminate-terminator.stderr", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fterminate-terminator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fterminate-terminator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fterminate-terminator.stderr?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -6,15 +6,18 @@ error: abnormal termination: panic in a function that cannot unwind\n   --> $DIR/terminate-terminator.rs:LL:CC\n    |\n LL | / fn has_cleanup() {\n+LL | |\n LL | |     let _f = Foo;\n LL | |     panic!();\n LL | | }\n    | |_^ panic in a function that cannot unwind\n-...\n-LL |       has_cleanup();\n-   |       ------------- in this inlined function call\n    |\n-   = note: inside `panic_abort` at $DIR/terminate-terminator.rs:LL:CC\n+   = note: inside `has_cleanup` at $DIR/terminate-terminator.rs:LL:CC\n+note: inside `panic_abort`\n+  --> $DIR/terminate-terminator.rs:LL:CC\n+   |\n+LL |     has_cleanup();\n+   |     ^^^^^^^^^^^^^\n note: inside `main`\n   --> $DIR/terminate-terminator.rs:LL:CC\n    |"}, {"sha": "d162674fa6976501470269850de30627afdfaa6f", "filename": "tests/rustdoc-gui/highlight-colors.goml", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/tests%2Frustdoc-gui%2Fhighlight-colors.goml", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/tests%2Frustdoc-gui%2Fhighlight-colors.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fhighlight-colors.goml?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -43,52 +43,52 @@ define-function: (\n \n call-function: (\"check-colors\", {\n     \"theme\": \"ayu\",\n-    \"kw\": \"rgb(255, 119, 51)\",\n-    \"kw2\": \"rgb(255, 119, 51)\",\n-    \"prelude_ty\": \"rgb(105, 242, 223)\",\n-    \"prelude_val\": \"rgb(255, 119, 51)\",\n-    \"lifetime\": \"rgb(255, 119, 51)\",\n-    \"number\": \"rgb(184, 204, 82)\",\n-    \"string\": \"rgb(184, 204, 82)\",\n-    \"bool_val\": \"rgb(255, 119, 51)\",\n-    \"self\": \"rgb(54, 163, 217)\",\n-    \"attr\": \"rgb(230, 225, 207)\",\n-    \"macro\": \"rgb(163, 122, 204)\",\n-    \"question_mark\": \"rgb(255, 144, 17)\",\n-    \"comment\": \"rgb(120, 135, 151)\",\n-    \"doc_comment\": \"rgb(161, 172, 136)\",\n+    \"kw\": \"#ff7733\",\n+    \"kw2\": \"#ff7733\",\n+    \"prelude_ty\": \"#69f2df\",\n+    \"prelude_val\": \"#ff7733\",\n+    \"lifetime\": \"#ff7733\",\n+    \"number\": \"#b8cc52\",\n+    \"string\": \"#b8cc52\",\n+    \"bool_val\": \"#ff7733\",\n+    \"self\": \"#36a3d9\",\n+    \"attr\": \"#e6e1cf\",\n+    \"macro\": \"#a37acc\",\n+    \"question_mark\": \"#ff9011\",\n+    \"comment\": \"#788797\",\n+    \"doc_comment\": \"#a1ac88\",\n })\n call-function: (\"check-colors\", {\n     \"theme\": \"dark\",\n-    \"kw\": \"rgb(171, 138, 193)\",\n-    \"kw2\": \"rgb(118, 154, 203)\",\n-    \"prelude_ty\": \"rgb(118, 154, 203)\",\n-    \"prelude_val\": \"rgb(238, 104, 104)\",\n-    \"lifetime\": \"rgb(217, 127, 38)\",\n-    \"number\": \"rgb(131, 163, 0)\",\n-    \"string\": \"rgb(131, 163, 0)\",\n-    \"bool_val\": \"rgb(238, 104, 104)\",\n-    \"self\": \"rgb(238, 104, 104)\",\n-    \"attr\": \"rgb(238, 104, 104)\",\n-    \"macro\": \"rgb(62, 153, 159)\",\n-    \"question_mark\": \"rgb(255, 144, 17)\",\n-    \"comment\": \"rgb(141, 141, 139)\",\n-    \"doc_comment\": \"rgb(140, 163, 117)\",\n+    \"kw\": \"#ab8ac1\",\n+    \"kw2\": \"#769acb\",\n+    \"prelude_ty\": \"#769acb\",\n+    \"prelude_val\": \"#ee6868\",\n+    \"lifetime\": \"#d97f26\",\n+    \"number\": \"#83a300\",\n+    \"string\": \"#83a300\",\n+    \"bool_val\": \"#ee6868\",\n+    \"self\": \"#ee6868\",\n+    \"attr\": \"#ee6868\",\n+    \"macro\": \"#3e999f\",\n+    \"question_mark\": \"#ff9011\",\n+    \"comment\": \"#8d8d8b\",\n+    \"doc_comment\": \"#8ca375\",\n })\n call-function: (\"check-colors\", {\n     \"theme\": \"light\",\n-    \"kw\": \"rgb(137, 89, 168)\",\n-    \"kw2\": \"rgb(66, 113, 174)\",\n-    \"prelude_ty\": \"rgb(66, 113, 174)\",\n-    \"prelude_val\": \"rgb(200, 40, 41)\",\n-    \"lifetime\": \"rgb(183, 101, 20)\",\n-    \"number\": \"rgb(113, 140, 0)\",\n-    \"string\": \"rgb(113, 140, 0)\",\n-    \"bool_val\": \"rgb(200, 40, 41)\",\n-    \"self\": \"rgb(200, 40, 41)\",\n-    \"attr\": \"rgb(200, 40, 41)\",\n-    \"macro\": \"rgb(62, 153, 159)\",\n-    \"question_mark\": \"rgb(255, 144, 17)\",\n-    \"comment\": \"rgb(142, 144, 140)\",\n-    \"doc_comment\": \"rgb(77, 77, 76)\",\n+    \"kw\": \"#8959a8\",\n+    \"kw2\": \"#4271ae\",\n+    \"prelude_ty\": \"#4271ae\",\n+    \"prelude_val\": \"#c82829\",\n+    \"lifetime\": \"#b76514\",\n+    \"number\": \"#718c00\",\n+    \"string\": \"#718c00\",\n+    \"bool_val\": \"#c82829\",\n+    \"self\": \"#c82829\",\n+    \"attr\": \"#c82829\",\n+    \"macro\": \"#3e999f\",\n+    \"question_mark\": \"#ff9011\",\n+    \"comment\": \"#8e908c\",\n+    \"doc_comment\": \"#4d4d4c\",\n })"}, {"sha": "e99cd1f3d58ff0232f541d0b69b7c89ab45f2fb2", "filename": "tests/rustdoc-ui/unescaped_backticks.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/tests%2Frustdoc-ui%2Funescaped_backticks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/tests%2Frustdoc-ui%2Funescaped_backticks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Funescaped_backticks.rs?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -340,3 +340,15 @@ id! {\n     /// level changes.\n     pub mod tracing_macro {}\n }\n+\n+/// Regression test for <https://github.com/rust-lang/rust/issues/111117>\n+pub mod trillium_server_common {\n+    /// One-indexed, because the first CloneCounter is included. If you don't\n+    /// want the original to count, construct a [``CloneCounterObserver`]\n+    /// instead and use [`CloneCounterObserver::counter`] to increment.\n+    //~^ ERROR unescaped backtick\n+    pub struct CloneCounter;\n+\n+    /// This is used by the above.\n+    pub struct CloneCounterObserver;\n+}"}, {"sha": "bf1f18889c40f7af9321bc53ca2cd01c0d492d1f", "filename": "tests/rustdoc-ui/unescaped_backticks.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/tests%2Frustdoc-ui%2Funescaped_backticks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/tests%2Frustdoc-ui%2Funescaped_backticks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Funescaped_backticks.stderr?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -341,6 +341,18 @@ LL | |     /// level changes.\n             change: [`rebuild_interest_cache`][rebuild] is called after the value of the max\n            to this: [`rebuild_interest_cache\\`][rebuild] is called after the value of the max\n \n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:348:56\n+   |\n+LL |     /// instead and use [`CloneCounterObserver::counter`] to increment.\n+   |                                                        ^\n+   |\n+   = help: the opening or closing backtick of an inline code may be missing\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL |     /// instead and use [`CloneCounterObserver::counter\\`] to increment.\n+   |                                                        +\n+\n error: unescaped backtick\n   --> $DIR/unescaped_backticks.rs:11:5\n    |\n@@ -955,5 +967,5 @@ help: if you meant to use a literal backtick, escape it\n LL | /// | table`( | )\\`body |\n    |                  +\n \n-error: aborting due to 63 previous errors\n+error: aborting due to 64 previous errors\n "}, {"sha": "cb6cd0e7ba64deed2a08c718925435c1c579c81d", "filename": "tests/rustdoc/strikethrough-in-summary.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a2b1646c597329d0a25efa3889b66650f65de1de/tests%2Frustdoc%2Fstrikethrough-in-summary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b1646c597329d0a25efa3889b66650f65de1de/tests%2Frustdoc%2Fstrikethrough-in-summary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fstrikethrough-in-summary.rs?ref=a2b1646c597329d0a25efa3889b66650f65de1de", "patch": "@@ -1,6 +0,0 @@\n-#![crate_name = \"foo\"]\n-\n-// @has foo/index.html '//del' 'strike'\n-\n-/// ~~strike~~\n-pub fn strike() {}"}, {"sha": "58162153b9e49a63412fe5666bb62107ff4fb697", "filename": "tests/rustdoc/test-strikethrough.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/tests%2Frustdoc%2Ftest-strikethrough.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/tests%2Frustdoc%2Ftest-strikethrough.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Ftest-strikethrough.rs?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -1,6 +1,13 @@\n #![crate_name = \"foo\"]\n \n-// @has foo/fn.f.html\n-// @has - //del \"Y\"\n-/// ~~Y~~\n+// Test that strikethrough works with single and double tildes and that it shows up on\n+// the item's dedicated page as well as the parent module's summary of items.\n+\n+// @has foo/index.html //del 'strike'\n+// @has foo/index.html //del 'through'\n+\n+// @has foo/fn.f.html //del 'strike'\n+// @has foo/fn.f.html //del 'through'\n+\n+/// ~~strike~~ ~through~\n pub fn f() {}"}, {"sha": "41b09ba03702b69909cba21681ce4106ab33a74b", "filename": "tests/ui/closures/2229_closure_analysis/match/patterns-capture-analysis.rs", "status": "modified", "additions": 59, "deletions": 13, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmatch%2Fpatterns-capture-analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmatch%2Fpatterns-capture-analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmatch%2Fpatterns-capture-analysis.rs?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -1,16 +1,14 @@\n // edition:2021\n \n #![feature(rustc_attrs)]\n+#![feature(stmt_expr_attributes)]\n \n // Should capture the discriminant since a variant of a multivariant enum is\n // mentioned in the match arm; the discriminant is captured by the closure regardless\n // of if it creates a binding\n fn test_1_should_capture() {\n     let variant = Some(2229);\n     let c =  #[rustc_capture_analysis]\n-    //~^ ERROR: attributes on expressions are experimental\n-    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n-\n     || {\n     //~^ First Pass analysis includes:\n     //~| Min Capture analysis includes:\n@@ -29,8 +27,6 @@ fn test_1_should_capture() {\n fn test_2_should_not_capture() {\n     let variant = Some(2229);\n     let c =  #[rustc_capture_analysis]\n-    //~^ ERROR: attributes on expressions are experimental\n-    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n     || {\n     //~^ First Pass analysis includes:\n         match variant {\n@@ -50,8 +46,6 @@ enum SingleVariant {\n fn test_3_should_not_capture_single_variant() {\n     let variant = SingleVariant::Points(1);\n     let c =  #[rustc_capture_analysis]\n-    //~^ ERROR: attributes on expressions are experimental\n-    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n     || {\n     //~^ First Pass analysis includes:\n         match variant {\n@@ -66,8 +60,6 @@ fn test_3_should_not_capture_single_variant() {\n fn test_6_should_capture_single_variant() {\n     let variant = SingleVariant::Points(1);\n     let c =  #[rustc_capture_analysis]\n-    //~^ ERROR: attributes on expressions are experimental\n-    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n     || {\n     //~^ First Pass analysis includes:\n     //~| Min Capture analysis includes:\n@@ -88,8 +80,6 @@ fn test_6_should_capture_single_variant() {\n fn test_4_should_not_capture_array() {\n     let array: [i32; 3] = [0; 3];\n     let c =  #[rustc_capture_analysis]\n-    //~^ ERROR: attributes on expressions are experimental\n-    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n     || {\n     //~^ First Pass analysis includes:\n         match array {\n@@ -112,8 +102,6 @@ enum MVariant {\n fn test_5_should_capture_multi_variant() {\n     let variant = MVariant::A;\n     let c =  #[rustc_capture_analysis]\n-    //~^ ERROR: attributes on expressions are experimental\n-    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n     || {\n     //~^ First Pass analysis includes:\n     //~| Min Capture analysis includes:\n@@ -127,11 +115,69 @@ fn test_5_should_capture_multi_variant() {\n     c();\n }\n \n+// Even though all patterns are wild, we need to read the discriminant\n+// in order to test the slice length\n+fn test_7_should_capture_slice_len() {\n+    let slice: &[i32] = &[1, 2, 3];\n+    let c =  #[rustc_capture_analysis]\n+    || {\n+    //~^ First Pass analysis includes:\n+    //~| Min Capture analysis includes:\n+        match slice {\n+            //~^ NOTE: Capturing slice[] -> ImmBorrow\n+            //~| NOTE: Min Capture slice[] -> ImmBorrow\n+            [_,_,_] => {},\n+            _ => {}\n+        }\n+    };\n+    c();\n+    let c =  #[rustc_capture_analysis]\n+    || {\n+    //~^ First Pass analysis includes:\n+    //~| Min Capture analysis includes:\n+        match slice {\n+            //~^ NOTE: Capturing slice[] -> ImmBorrow\n+            //~| NOTE: Min Capture slice[] -> ImmBorrow\n+            [] => {},\n+            _ => {}\n+        }\n+    };\n+    c();\n+    let c =  #[rustc_capture_analysis]\n+    || {\n+    //~^ First Pass analysis includes:\n+    //~| Min Capture analysis includes:\n+        match slice {\n+            //~^ NOTE: Capturing slice[] -> ImmBorrow\n+            //~| NOTE: Min Capture slice[] -> ImmBorrow\n+            [_, .. ,_] => {},\n+            _ => {}\n+        }\n+    };\n+    c();\n+}\n+\n+// Wild pattern that doesn't bind, so no capture\n+fn test_8_capture_slice_wild() {\n+    let slice: &[i32] = &[1, 2, 3];\n+    let c =  #[rustc_capture_analysis]\n+    || {\n+    //~^ First Pass analysis includes:\n+        match slice {\n+            [..] => {},\n+            _ => {}\n+        }\n+    };\n+    c();\n+}\n+\n fn main() {\n     test_1_should_capture();\n     test_2_should_not_capture();\n     test_3_should_not_capture_single_variant();\n     test_6_should_capture_single_variant();\n     test_4_should_not_capture_array();\n     test_5_should_capture_multi_variant();\n+    test_7_should_capture_slice_len();\n+    test_8_capture_slice_wild();\n }"}, {"sha": "e137af1a0bd4080175b2f95ecdf66a46b7bf8de2", "filename": "tests/ui/closures/2229_closure_analysis/match/patterns-capture-analysis.stderr", "status": "modified", "additions": 137, "deletions": 72, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmatch%2Fpatterns-capture-analysis.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmatch%2Fpatterns-capture-analysis.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmatch%2Fpatterns-capture-analysis.stderr?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -1,59 +1,5 @@\n-error[E0658]: attributes on expressions are experimental\n-  --> $DIR/patterns-capture-analysis.rs:10:14\n-   |\n-LL |     let c =  #[rustc_capture_analysis]\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n-   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n-\n-error[E0658]: attributes on expressions are experimental\n-  --> $DIR/patterns-capture-analysis.rs:31:14\n-   |\n-LL |     let c =  #[rustc_capture_analysis]\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n-   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n-\n-error[E0658]: attributes on expressions are experimental\n-  --> $DIR/patterns-capture-analysis.rs:52:14\n-   |\n-LL |     let c =  #[rustc_capture_analysis]\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n-   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n-\n-error[E0658]: attributes on expressions are experimental\n-  --> $DIR/patterns-capture-analysis.rs:68:14\n-   |\n-LL |     let c =  #[rustc_capture_analysis]\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n-   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n-\n-error[E0658]: attributes on expressions are experimental\n-  --> $DIR/patterns-capture-analysis.rs:90:14\n-   |\n-LL |     let c =  #[rustc_capture_analysis]\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n-   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n-\n-error[E0658]: attributes on expressions are experimental\n-  --> $DIR/patterns-capture-analysis.rs:114:14\n-   |\n-LL |     let c =  #[rustc_capture_analysis]\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n-   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n-\n error: First Pass analysis includes:\n-  --> $DIR/patterns-capture-analysis.rs:14:5\n+  --> $DIR/patterns-capture-analysis.rs:12:5\n    |\n LL | /     || {\n LL | |\n@@ -65,13 +11,13 @@ LL | |     };\n    | |_____^\n    |\n note: Capturing variant[] -> ImmBorrow\n-  --> $DIR/patterns-capture-analysis.rs:17:15\n+  --> $DIR/patterns-capture-analysis.rs:15:15\n    |\n LL |         match variant {\n    |               ^^^^^^^\n \n error: Min Capture analysis includes:\n-  --> $DIR/patterns-capture-analysis.rs:14:5\n+  --> $DIR/patterns-capture-analysis.rs:12:5\n    |\n LL | /     || {\n LL | |\n@@ -83,13 +29,13 @@ LL | |     };\n    | |_____^\n    |\n note: Min Capture variant[] -> ImmBorrow\n-  --> $DIR/patterns-capture-analysis.rs:17:15\n+  --> $DIR/patterns-capture-analysis.rs:15:15\n    |\n LL |         match variant {\n    |               ^^^^^^^\n \n error: First Pass analysis includes:\n-  --> $DIR/patterns-capture-analysis.rs:34:5\n+  --> $DIR/patterns-capture-analysis.rs:30:5\n    |\n LL | /     || {\n LL | |\n@@ -100,7 +46,7 @@ LL | |     };\n    | |_____^\n \n error: First Pass analysis includes:\n-  --> $DIR/patterns-capture-analysis.rs:55:5\n+  --> $DIR/patterns-capture-analysis.rs:49:5\n    |\n LL | /     || {\n LL | |\n@@ -111,7 +57,7 @@ LL | |     };\n    | |_____^\n \n error: First Pass analysis includes:\n-  --> $DIR/patterns-capture-analysis.rs:71:5\n+  --> $DIR/patterns-capture-analysis.rs:63:5\n    |\n LL | /     || {\n LL | |\n@@ -123,18 +69,18 @@ LL | |     };\n    | |_____^\n    |\n note: Capturing variant[] -> ImmBorrow\n-  --> $DIR/patterns-capture-analysis.rs:74:15\n+  --> $DIR/patterns-capture-analysis.rs:66:15\n    |\n LL |         match variant {\n    |               ^^^^^^^\n note: Capturing variant[(0, 0)] -> ImmBorrow\n-  --> $DIR/patterns-capture-analysis.rs:74:15\n+  --> $DIR/patterns-capture-analysis.rs:66:15\n    |\n LL |         match variant {\n    |               ^^^^^^^\n \n error: Min Capture analysis includes:\n-  --> $DIR/patterns-capture-analysis.rs:71:5\n+  --> $DIR/patterns-capture-analysis.rs:63:5\n    |\n LL | /     || {\n LL | |\n@@ -146,13 +92,13 @@ LL | |     };\n    | |_____^\n    |\n note: Min Capture variant[] -> ImmBorrow\n-  --> $DIR/patterns-capture-analysis.rs:74:15\n+  --> $DIR/patterns-capture-analysis.rs:66:15\n    |\n LL |         match variant {\n    |               ^^^^^^^\n \n error: First Pass analysis includes:\n-  --> $DIR/patterns-capture-analysis.rs:93:5\n+  --> $DIR/patterns-capture-analysis.rs:83:5\n    |\n LL | /     || {\n LL | |\n@@ -163,7 +109,7 @@ LL | |     };\n    | |_____^\n \n error: First Pass analysis includes:\n-  --> $DIR/patterns-capture-analysis.rs:117:5\n+  --> $DIR/patterns-capture-analysis.rs:105:5\n    |\n LL | /     || {\n LL | |\n@@ -175,13 +121,13 @@ LL | |     };\n    | |_____^\n    |\n note: Capturing variant[] -> ImmBorrow\n-  --> $DIR/patterns-capture-analysis.rs:120:15\n+  --> $DIR/patterns-capture-analysis.rs:108:15\n    |\n LL |         match variant {\n    |               ^^^^^^^\n \n error: Min Capture analysis includes:\n-  --> $DIR/patterns-capture-analysis.rs:117:5\n+  --> $DIR/patterns-capture-analysis.rs:105:5\n    |\n LL | /     || {\n LL | |\n@@ -193,11 +139,130 @@ LL | |     };\n    | |_____^\n    |\n note: Min Capture variant[] -> ImmBorrow\n-  --> $DIR/patterns-capture-analysis.rs:120:15\n+  --> $DIR/patterns-capture-analysis.rs:108:15\n    |\n LL |         match variant {\n    |               ^^^^^^^\n \n-error: aborting due to 15 previous errors\n+error: First Pass analysis includes:\n+  --> $DIR/patterns-capture-analysis.rs:123:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         match slice {\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing slice[] -> ImmBorrow\n+  --> $DIR/patterns-capture-analysis.rs:126:15\n+   |\n+LL |         match slice {\n+   |               ^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/patterns-capture-analysis.rs:123:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         match slice {\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture slice[] -> ImmBorrow\n+  --> $DIR/patterns-capture-analysis.rs:126:15\n+   |\n+LL |         match slice {\n+   |               ^^^^^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/patterns-capture-analysis.rs:135:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         match slice {\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing slice[] -> ImmBorrow\n+  --> $DIR/patterns-capture-analysis.rs:138:15\n+   |\n+LL |         match slice {\n+   |               ^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/patterns-capture-analysis.rs:135:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         match slice {\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture slice[] -> ImmBorrow\n+  --> $DIR/patterns-capture-analysis.rs:138:15\n+   |\n+LL |         match slice {\n+   |               ^^^^^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/patterns-capture-analysis.rs:147:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         match slice {\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing slice[] -> ImmBorrow\n+  --> $DIR/patterns-capture-analysis.rs:150:15\n+   |\n+LL |         match slice {\n+   |               ^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/patterns-capture-analysis.rs:147:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         match slice {\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture slice[] -> ImmBorrow\n+  --> $DIR/patterns-capture-analysis.rs:150:15\n+   |\n+LL |         match slice {\n+   |               ^^^^^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/patterns-capture-analysis.rs:164:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |         match slice {\n+LL | |             [..] => {},\n+LL | |             _ => {}\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+\n+error: aborting due to 16 previous errors\n \n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "8ef9281c9d3d76d0df0b5e006c1f4355a406bfdc", "filename": "tests/ui/impl-trait/arg-position-impl-trait-too-long.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/tests%2Fui%2Fimpl-trait%2Farg-position-impl-trait-too-long.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/tests%2Fui%2Fimpl-trait%2Farg-position-impl-trait-too-long.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Farg-position-impl-trait-too-long.rs?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -0,0 +1,22 @@\n+struct Header;\n+struct EntryMetadata;\n+struct Entry<A, B>(A, B);\n+\n+trait Tr {\n+    type EncodedKey;\n+    type EncodedValue;\n+}\n+\n+fn test<C: Tr, R>(\n+    // This APIT is long, however we shouldn't render the type name with a newline in it.\n+    y: impl FnOnce(\n+        &mut Header,\n+        &mut [EntryMetadata],\n+        &mut [Entry<C::EncodedKey, C::EncodedValue>]\n+    ) -> R,\n+) {\n+    let () = y;\n+    //~^ ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "40446a3d339a7222ea8ae2c6bb5c2f42768a7995", "filename": "tests/ui/impl-trait/arg-position-impl-trait-too-long.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/tests%2Fui%2Fimpl-trait%2Farg-position-impl-trait-too-long.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/tests%2Fui%2Fimpl-trait%2Farg-position-impl-trait-too-long.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Farg-position-impl-trait-too-long.stderr?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -0,0 +1,22 @@\n+error[E0308]: mismatched types\n+  --> $DIR/arg-position-impl-trait-too-long.rs:18:9\n+   |\n+LL |       y: impl FnOnce(\n+   |  ________-\n+LL | |         &mut Header,\n+LL | |         &mut [EntryMetadata],\n+LL | |         &mut [Entry<C::EncodedKey, C::EncodedValue>]\n+LL | |     ) -> R,\n+   | |__________- this type parameter\n+LL |   ) {\n+LL |       let () = y;\n+   |           ^^   - this expression has type `impl FnOnce(&mut Header, &mut [EntryMetadata], &mut [Entry<C::EncodedKey, C::EncodedValue>]) -> R`\n+   |           |\n+   |           expected type parameter `impl FnOnce(&mut Header, &mut [EntryMetadata], &mut [Entry<C::EncodedKey, C::EncodedValue>]) -> R`, found `()`\n+   |\n+   = note: expected type parameter `impl FnOnce(&mut Header, &mut [EntryMetadata], &mut [Entry<C::EncodedKey, C::EncodedValue>]) -> R`\n+                   found unit type `()`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "0c820ef9a29a9a83db048c970244f80dd3196760", "filename": "tests/ui/lint/lint-attr-everywhere-early.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/tests%2Fui%2Flint%2Flint-attr-everywhere-early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/tests%2Fui%2Flint%2Flint-attr-everywhere-early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Flint-attr-everywhere-early.rs?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -134,6 +134,14 @@ fn expressions() {\n         }\n     }\n \n+    match f {\n+        #[deny(ellipsis_inclusive_range_patterns)]\n+        Match{f1: 0...100} => {}\n+        //~^ ERROR range patterns are deprecated\n+        //~| WARNING this is accepted in the current edition\n+        _ => {}\n+    }\n+\n     // Statement Block\n     {\n         #![deny(unsafe_code)]"}, {"sha": "fac0eb4faff827d315f845d69389a1d0dd642111", "filename": "tests/ui/lint/lint-attr-everywhere-early.stderr", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/tests%2Fui%2Flint%2Flint-attr-everywhere-early.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/tests%2Fui%2Flint%2Flint-attr-everywhere-early.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Flint-attr-everywhere-early.stderr?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -384,103 +384,117 @@ note: the lint level is defined here\n LL |         #[deny(while_true)]\n    |                ^^^^^^^^^^\n \n+error: `...` range patterns are deprecated\n+  --> $DIR/lint-attr-everywhere-early.rs:139:20\n+   |\n+LL |         Match{f1: 0...100} => {}\n+   |                    ^^^ help: use `..=` for an inclusive range\n+   |\n+   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n+   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-early.rs:138:16\n+   |\n+LL |         #[deny(ellipsis_inclusive_range_patterns)]\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error: usage of an `unsafe` block\n-  --> $DIR/lint-attr-everywhere-early.rs:140:9\n+  --> $DIR/lint-attr-everywhere-early.rs:148:9\n    |\n LL |         unsafe {}\n    |         ^^^^^^^^^\n    |\n note: the lint level is defined here\n-  --> $DIR/lint-attr-everywhere-early.rs:139:17\n+  --> $DIR/lint-attr-everywhere-early.rs:147:17\n    |\n LL |         #![deny(unsafe_code)]\n    |                 ^^^^^^^^^^^\n \n error: usage of an `unsafe` block\n-  --> $DIR/lint-attr-everywhere-early.rs:144:9\n+  --> $DIR/lint-attr-everywhere-early.rs:152:9\n    |\n LL |         unsafe {}\n    |         ^^^^^^^^^\n    |\n note: the lint level is defined here\n-  --> $DIR/lint-attr-everywhere-early.rs:143:16\n+  --> $DIR/lint-attr-everywhere-early.rs:151:16\n    |\n LL |         #[deny(unsafe_code)]\n    |                ^^^^^^^^^^^\n \n error: usage of an `unsafe` block\n-  --> $DIR/lint-attr-everywhere-early.rs:149:5\n+  --> $DIR/lint-attr-everywhere-early.rs:157:5\n    |\n LL |     unsafe {};\n    |     ^^^^^^^^^\n    |\n note: the lint level is defined here\n-  --> $DIR/lint-attr-everywhere-early.rs:148:12\n+  --> $DIR/lint-attr-everywhere-early.rs:156:12\n    |\n LL |     #[deny(unsafe_code)]\n    |            ^^^^^^^^^^^\n \n error: usage of an `unsafe` block\n-  --> $DIR/lint-attr-everywhere-early.rs:151:27\n+  --> $DIR/lint-attr-everywhere-early.rs:159:27\n    |\n LL |     [#[deny(unsafe_code)] unsafe {123}];\n    |                           ^^^^^^^^^^^^\n    |\n note: the lint level is defined here\n-  --> $DIR/lint-attr-everywhere-early.rs:151:13\n+  --> $DIR/lint-attr-everywhere-early.rs:159:13\n    |\n LL |     [#[deny(unsafe_code)] unsafe {123}];\n    |             ^^^^^^^^^^^\n \n error: usage of an `unsafe` block\n-  --> $DIR/lint-attr-everywhere-early.rs:152:27\n+  --> $DIR/lint-attr-everywhere-early.rs:160:27\n    |\n LL |     (#[deny(unsafe_code)] unsafe {123},);\n    |                           ^^^^^^^^^^^^\n    |\n note: the lint level is defined here\n-  --> $DIR/lint-attr-everywhere-early.rs:152:13\n+  --> $DIR/lint-attr-everywhere-early.rs:160:13\n    |\n LL |     (#[deny(unsafe_code)] unsafe {123},);\n    |             ^^^^^^^^^^^\n \n error: usage of an `unsafe` block\n-  --> $DIR/lint-attr-everywhere-early.rs:154:31\n+  --> $DIR/lint-attr-everywhere-early.rs:162:31\n    |\n LL |     call(#[deny(unsafe_code)] unsafe {123});\n    |                               ^^^^^^^^^^^^\n    |\n note: the lint level is defined here\n-  --> $DIR/lint-attr-everywhere-early.rs:154:17\n+  --> $DIR/lint-attr-everywhere-early.rs:162:17\n    |\n LL |     call(#[deny(unsafe_code)] unsafe {123});\n    |                 ^^^^^^^^^^^\n \n error: usage of an `unsafe` block\n-  --> $DIR/lint-attr-everywhere-early.rs:156:38\n+  --> $DIR/lint-attr-everywhere-early.rs:164:38\n    |\n LL |     TupleStruct(#[deny(unsafe_code)] unsafe {123});\n    |                                      ^^^^^^^^^^^^\n    |\n note: the lint level is defined here\n-  --> $DIR/lint-attr-everywhere-early.rs:156:24\n+  --> $DIR/lint-attr-everywhere-early.rs:164:24\n    |\n LL |     TupleStruct(#[deny(unsafe_code)] unsafe {123});\n    |                        ^^^^^^^^^^^\n \n error: `...` range patterns are deprecated\n-  --> $DIR/lint-attr-everywhere-early.rs:167:18\n+  --> $DIR/lint-attr-everywhere-early.rs:175:18\n    |\n LL |             f1: 0...100,\n    |                  ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n note: the lint level is defined here\n-  --> $DIR/lint-attr-everywhere-early.rs:166:20\n+  --> $DIR/lint-attr-everywhere-early.rs:174:20\n    |\n LL |             #[deny(ellipsis_inclusive_range_patterns)]\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 36 previous errors\n+error: aborting due to 37 previous errors\n "}, {"sha": "a24355babb63e61f26d2fb04cb04d1450dfb41fb", "filename": "tests/ui/lint/lint-attr-everywhere-late.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/tests%2Fui%2Flint%2Flint-attr-everywhere-late.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/tests%2Fui%2Flint%2Flint-attr-everywhere-late.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Flint-attr-everywhere-late.rs?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -162,6 +162,11 @@ fn expressions() {\n         }\n     }\n \n+    match 123 {\n+        #[deny(non_snake_case)]\n+        ARM_VAR => {} //~ ERROR variable `ARM_VAR` should have a snake case name\n+    }\n+\n     // Statement Block\n     {\n         #![deny(enum_intrinsics_non_enums)]"}, {"sha": "9587556b0c150e31bc62f75b72a383b91f5588b7", "filename": "tests/ui/lint/lint-attr-everywhere-late.stderr", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/tests%2Fui%2Flint%2Flint-attr-everywhere-late.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/tests%2Fui%2Flint%2Flint-attr-everywhere-late.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Flint-attr-everywhere-late.stderr?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -305,124 +305,136 @@ note: the lint level is defined here\n LL |         #[deny(enum_intrinsics_non_enums)]\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n+error: variable `ARM_VAR` should have a snake case name\n+  --> $DIR/lint-attr-everywhere-late.rs:167:9\n+   |\n+LL |         ARM_VAR => {}\n+   |         ^^^^^^^ help: convert the identifier to snake case: `arm_var`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:166:16\n+   |\n+LL |         #[deny(non_snake_case)]\n+   |                ^^^^^^^^^^^^^^\n+\n error: the return value of `mem::discriminant` is unspecified when called with a non-enum type\n-  --> $DIR/lint-attr-everywhere-late.rs:168:9\n+  --> $DIR/lint-attr-everywhere-late.rs:173:9\n    |\n LL |         discriminant::<i32>(&123);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: the argument to `discriminant` should be a reference to an enum, but it was passed a reference to a `i32`, which is not an enum.\n-  --> $DIR/lint-attr-everywhere-late.rs:168:29\n+  --> $DIR/lint-attr-everywhere-late.rs:173:29\n    |\n LL |         discriminant::<i32>(&123);\n    |                             ^^^^\n note: the lint level is defined here\n-  --> $DIR/lint-attr-everywhere-late.rs:167:17\n+  --> $DIR/lint-attr-everywhere-late.rs:172:17\n    |\n LL |         #![deny(enum_intrinsics_non_enums)]\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the return value of `mem::discriminant` is unspecified when called with a non-enum type\n-  --> $DIR/lint-attr-everywhere-late.rs:172:9\n+  --> $DIR/lint-attr-everywhere-late.rs:177:9\n    |\n LL |         discriminant::<i32>(&123);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: the argument to `discriminant` should be a reference to an enum, but it was passed a reference to a `i32`, which is not an enum.\n-  --> $DIR/lint-attr-everywhere-late.rs:172:29\n+  --> $DIR/lint-attr-everywhere-late.rs:177:29\n    |\n LL |         discriminant::<i32>(&123);\n    |                             ^^^^\n note: the lint level is defined here\n-  --> $DIR/lint-attr-everywhere-late.rs:171:16\n+  --> $DIR/lint-attr-everywhere-late.rs:176:16\n    |\n LL |         #[deny(enum_intrinsics_non_enums)]\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the return value of `mem::discriminant` is unspecified when called with a non-enum type\n-  --> $DIR/lint-attr-everywhere-late.rs:177:5\n+  --> $DIR/lint-attr-everywhere-late.rs:182:5\n    |\n LL |     discriminant::<i32>(&123);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: the argument to `discriminant` should be a reference to an enum, but it was passed a reference to a `i32`, which is not an enum.\n-  --> $DIR/lint-attr-everywhere-late.rs:177:25\n+  --> $DIR/lint-attr-everywhere-late.rs:182:25\n    |\n LL |     discriminant::<i32>(&123);\n    |                         ^^^^\n note: the lint level is defined here\n-  --> $DIR/lint-attr-everywhere-late.rs:176:12\n+  --> $DIR/lint-attr-everywhere-late.rs:181:12\n    |\n LL |     #[deny(enum_intrinsics_non_enums)]\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the return value of `mem::discriminant` is unspecified when called with a non-enum type\n-  --> $DIR/lint-attr-everywhere-late.rs:179:41\n+  --> $DIR/lint-attr-everywhere-late.rs:184:41\n    |\n LL |     [#[deny(enum_intrinsics_non_enums)] discriminant::<i32>(&123)];\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: the argument to `discriminant` should be a reference to an enum, but it was passed a reference to a `i32`, which is not an enum.\n-  --> $DIR/lint-attr-everywhere-late.rs:179:61\n+  --> $DIR/lint-attr-everywhere-late.rs:184:61\n    |\n LL |     [#[deny(enum_intrinsics_non_enums)] discriminant::<i32>(&123)];\n    |                                                             ^^^^\n note: the lint level is defined here\n-  --> $DIR/lint-attr-everywhere-late.rs:179:13\n+  --> $DIR/lint-attr-everywhere-late.rs:184:13\n    |\n LL |     [#[deny(enum_intrinsics_non_enums)] discriminant::<i32>(&123)];\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the return value of `mem::discriminant` is unspecified when called with a non-enum type\n-  --> $DIR/lint-attr-everywhere-late.rs:180:41\n+  --> $DIR/lint-attr-everywhere-late.rs:185:41\n    |\n LL |     (#[deny(enum_intrinsics_non_enums)] discriminant::<i32>(&123),);\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: the argument to `discriminant` should be a reference to an enum, but it was passed a reference to a `i32`, which is not an enum.\n-  --> $DIR/lint-attr-everywhere-late.rs:180:61\n+  --> $DIR/lint-attr-everywhere-late.rs:185:61\n    |\n LL |     (#[deny(enum_intrinsics_non_enums)] discriminant::<i32>(&123),);\n    |                                                             ^^^^\n note: the lint level is defined here\n-  --> $DIR/lint-attr-everywhere-late.rs:180:13\n+  --> $DIR/lint-attr-everywhere-late.rs:185:13\n    |\n LL |     (#[deny(enum_intrinsics_non_enums)] discriminant::<i32>(&123),);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the return value of `mem::discriminant` is unspecified when called with a non-enum type\n-  --> $DIR/lint-attr-everywhere-late.rs:182:45\n+  --> $DIR/lint-attr-everywhere-late.rs:187:45\n    |\n LL |     call(#[deny(enum_intrinsics_non_enums)] discriminant::<i32>(&123));\n    |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: the argument to `discriminant` should be a reference to an enum, but it was passed a reference to a `i32`, which is not an enum.\n-  --> $DIR/lint-attr-everywhere-late.rs:182:65\n+  --> $DIR/lint-attr-everywhere-late.rs:187:65\n    |\n LL |     call(#[deny(enum_intrinsics_non_enums)] discriminant::<i32>(&123));\n    |                                                                 ^^^^\n note: the lint level is defined here\n-  --> $DIR/lint-attr-everywhere-late.rs:182:17\n+  --> $DIR/lint-attr-everywhere-late.rs:187:17\n    |\n LL |     call(#[deny(enum_intrinsics_non_enums)] discriminant::<i32>(&123));\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the return value of `mem::discriminant` is unspecified when called with a non-enum type\n-  --> $DIR/lint-attr-everywhere-late.rs:184:52\n+  --> $DIR/lint-attr-everywhere-late.rs:189:52\n    |\n LL |     TupleStruct(#[deny(enum_intrinsics_non_enums)] discriminant::<i32>(&123));\n    |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: the argument to `discriminant` should be a reference to an enum, but it was passed a reference to a `i32`, which is not an enum.\n-  --> $DIR/lint-attr-everywhere-late.rs:184:72\n+  --> $DIR/lint-attr-everywhere-late.rs:189:72\n    |\n LL |     TupleStruct(#[deny(enum_intrinsics_non_enums)] discriminant::<i32>(&123));\n    |                                                                        ^^^^\n note: the lint level is defined here\n-  --> $DIR/lint-attr-everywhere-late.rs:184:24\n+  --> $DIR/lint-attr-everywhere-late.rs:189:24\n    |\n LL |     TupleStruct(#[deny(enum_intrinsics_non_enums)] discriminant::<i32>(&123));\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 31 previous errors\n+error: aborting due to 32 previous errors\n "}, {"sha": "0c1146339c45fe7cd8c0ba4b5df4eb4f34753515", "filename": "tests/ui/lint/lint-match-arms-2.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/tests%2Fui%2Flint%2Flint-match-arms-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/tests%2Fui%2Flint%2Flint-match-arms-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Flint-match-arms-2.rs?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -0,0 +1,24 @@\n+#![feature(if_let_guard)]\n+#![allow(unused, non_snake_case)]\n+\n+enum E {\n+    A,\n+}\n+\n+#[allow(bindings_with_variant_name, irrefutable_let_patterns)]\n+fn foo() {\n+    match E::A {\n+        #[deny(bindings_with_variant_name)]\n+        A => {}\n+    //~^ ERROR pattern binding `A` is named the same as one of the variants of the type `E`\n+    }\n+\n+    match &E::A {\n+        #[deny(irrefutable_let_patterns)]\n+        a if let b = a => {}\n+    //~^ ERROR irrefutable `if let` guard pattern\n+        _ => {}\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "062d5c12e9610f2068fb57069fa99b00518536c1", "filename": "tests/ui/lint/lint-match-arms-2.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0004b3b984b19646c1f78b09ba497b7bd6e882c1/tests%2Fui%2Flint%2Flint-match-arms-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0004b3b984b19646c1f78b09ba497b7bd6e882c1/tests%2Fui%2Flint%2Flint-match-arms-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Flint-match-arms-2.stderr?ref=0004b3b984b19646c1f78b09ba497b7bd6e882c1", "patch": "@@ -0,0 +1,29 @@\n+error[E0170]: pattern binding `A` is named the same as one of the variants of the type `E`\n+  --> $DIR/lint-match-arms-2.rs:12:9\n+   |\n+LL |         A => {}\n+   |         ^ help: to match on the variant, qualify the path: `E::A`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-match-arms-2.rs:11:16\n+   |\n+LL |         #[deny(bindings_with_variant_name)]\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: irrefutable `if let` guard pattern\n+  --> $DIR/lint-match-arms-2.rs:18:18\n+   |\n+LL |         a if let b = a => {}\n+   |                  ^\n+   |\n+   = note: this pattern will always match, so the guard is useless\n+   = help: consider removing the guard and adding a `let` inside the match arm\n+note: the lint level is defined here\n+  --> $DIR/lint-match-arms-2.rs:17:16\n+   |\n+LL |         #[deny(irrefutable_let_patterns)]\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0170`."}]}