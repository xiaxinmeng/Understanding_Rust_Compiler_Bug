{"sha": "1883b8d715d91c65cb25fc8a2e7258c9fc704c16", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4ODNiOGQ3MTVkOTFjNjVjYjI1ZmM4YTJlNzI1OGM5ZmM3MDRjMTY=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-04-16T18:19:24Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-04-25T19:38:39Z"}, "message": "privacy: Rename and cleanup PrivacyVisitor", "tree": {"sha": "4f7a1711d9dc44047c397ecb52f5627158c28647", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f7a1711d9dc44047c397ecb52f5627158c28647"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1883b8d715d91c65cb25fc8a2e7258c9fc704c16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1883b8d715d91c65cb25fc8a2e7258c9fc704c16", "html_url": "https://github.com/rust-lang/rust/commit/1883b8d715d91c65cb25fc8a2e7258c9fc704c16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1883b8d715d91c65cb25fc8a2e7258c9fc704c16/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82e030322bd47d0ac3d1639cabf93e24dbdc1779", "url": "https://api.github.com/repos/rust-lang/rust/commits/82e030322bd47d0ac3d1639cabf93e24dbdc1779", "html_url": "https://github.com/rust-lang/rust/commit/82e030322bd47d0ac3d1639cabf93e24dbdc1779"}], "stats": {"total": 112, "additions": 40, "deletions": 72}, "files": [{"sha": "f7155f219a828a78b1dbc4929b0dd46cf0ab1ed0", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 38, "deletions": 70, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/1883b8d715d91c65cb25fc8a2e7258c9fc704c16/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1883b8d715d91c65cb25fc8a2e7258c9fc704c16/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=1883b8d715d91c65cb25fc8a2e7258c9fc704c16", "patch": "@@ -13,8 +13,8 @@\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-      html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-      html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![deny(warnings)]\n \n #![feature(rustc_diagnostic_macros)]\n@@ -30,7 +30,6 @@ use rustc::hir::def::Def;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefId};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::DeepVisitor;\n-use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::lint;\n use rustc::middle::privacy::{AccessLevel, AccessLevels};\n use rustc::ty::{self, TyCtxt, Ty, TypeFoldable};\n@@ -415,70 +414,69 @@ impl<'b, 'a, 'tcx> TypeVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b\n     }\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n-/// The privacy visitor, where privacy checks take place (violations reported)\n-////////////////////////////////////////////////////////////////////////////////\n+//////////////////////////////////////////////////////////////////////////////////////\n+/// Name privacy visitor, checks privacy and reports violations.\n+/// Most of name privacy checks are performed during the main resolution phase,\n+/// or later in type checking when field accesses and associated items are resolved.\n+/// This pass performs remaining checks for fields in struct expressions and patterns.\n+//////////////////////////////////////////////////////////////////////////////////////\n \n-struct PrivacyVisitor<'a, 'tcx: 'a> {\n+struct NamePrivacyVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    curitem: DefId,\n-    in_foreign: bool,\n     tables: &'a ty::TypeckTables<'tcx>,\n+    current_item: DefId,\n }\n \n-impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n-    // Checks that a field is in scope.\n+impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n+    // Checks that a field is accessible.\n     fn check_field(&mut self, span: Span, def: &'tcx ty::AdtDef, field: &'tcx ty::FieldDef) {\n-        if !def.is_enum() && !field.vis.is_accessible_from(self.curitem, self.tcx) {\n+        if !def.is_enum() && !field.vis.is_accessible_from(self.current_item, self.tcx) {\n             struct_span_err!(self.tcx.sess, span, E0451, \"field `{}` of {} `{}` is private\",\n-                      field.name, def.variant_descr(), self.tcx.item_path_str(def.did))\n+                             field.name, def.variant_descr(), self.tcx.item_path_str(def.did))\n                 .span_label(span, &format!(\"field `{}` is private\", field.name))\n                 .emit();\n         }\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::All(&self.tcx.hir)\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let old_tables = self.tables;\n-        self.tables = self.tcx.body_tables(body);\n+        let orig_tables = replace(&mut self.tables, self.tcx.body_tables(body));\n         let body = self.tcx.hir.body(body);\n         self.visit_body(body);\n-        self.tables = old_tables;\n+        self.tables = orig_tables;\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let orig_curitem = replace(&mut self.curitem, self.tcx.hir.local_def_id(item.id));\n+        let orig_current_item = replace(&mut self.current_item, self.tcx.hir.local_def_id(item.id));\n         intravisit::walk_item(self, item);\n-        self.curitem = orig_curitem;\n+        self.current_item = orig_current_item;\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n-            hir::ExprStruct(ref qpath, ref expr_fields, _) => {\n+            hir::ExprStruct(ref qpath, ref fields, ref base) => {\n                 let def = self.tables.qpath_def(qpath, expr.id);\n                 let adt = self.tables.expr_ty(expr).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(def);\n-                // RFC 736: ensure all unmentioned fields are visible.\n-                // Rather than computing the set of unmentioned fields\n-                // (i.e. `all_fields - fields`), just check them all,\n-                // unless the ADT is a union, then unmentioned fields\n-                // are not checked.\n-                if adt.is_union() {\n-                    for expr_field in expr_fields {\n-                        self.check_field(expr.span, adt, variant.field_named(expr_field.name.node));\n+                if let Some(ref base) = *base {\n+                    // If the expression uses FRU we need to make sure all the unmentioned fields\n+                    // are checked for privacy (RFC 736). Rather than computing the set of\n+                    // unmentioned fields, just check them all.\n+                    for variant_field in &variant.fields {\n+                        let field = fields.iter().find(|f| f.name.node == variant_field.name);\n+                        let span = if let Some(f) = field { f.span } else { base.span };\n+                        self.check_field(span, adt, variant_field);\n                     }\n                 } else {\n-                    for field in &variant.fields {\n-                        let expr_field = expr_fields.iter().find(|f| f.name.node == field.name);\n-                        let span = if let Some(f) = expr_field { f.span } else { expr.span };\n-                        self.check_field(span, adt, field);\n+                    for field in fields {\n+                        self.check_field(field.span, adt, variant.field_named(field.name.node));\n                     }\n                 }\n             }\n@@ -488,47 +486,20 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n         intravisit::walk_expr(self, expr);\n     }\n \n-    fn visit_pat(&mut self, pattern: &'tcx hir::Pat) {\n-        // Foreign functions do not have their patterns mapped in the def_map,\n-        // and there's nothing really relevant there anyway, so don't bother\n-        // checking privacy. If you can name the type then you can pass it to an\n-        // external C function anyway.\n-        if self.in_foreign { return }\n-\n-        match pattern.node {\n+    fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n+        match pat.node {\n             PatKind::Struct(ref qpath, ref fields, _) => {\n-                let def = self.tables.qpath_def(qpath, pattern.id);\n-                let adt = self.tables.pat_ty(pattern).ty_adt_def().unwrap();\n+                let def = self.tables.qpath_def(qpath, pat.id);\n+                let adt = self.tables.pat_ty(pat).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(def);\n                 for field in fields {\n                     self.check_field(field.span, adt, variant.field_named(field.node.name));\n                 }\n             }\n-            PatKind::TupleStruct(_, ref fields, ddpos) => {\n-                match self.tables.pat_ty(pattern).sty {\n-                    // enum fields have no privacy at this time\n-                    ty::TyAdt(def, _) if !def.is_enum() => {\n-                        let expected_len = def.struct_variant().fields.len();\n-                        for (i, field) in fields.iter().enumerate_and_adjust(expected_len, ddpos) {\n-                            if let PatKind::Wild = field.node {\n-                                continue\n-                            }\n-                            self.check_field(field.span, def, &def.struct_variant().fields[i]);\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n             _ => {}\n         }\n \n-        intravisit::walk_pat(self, pattern);\n-    }\n-\n-    fn visit_foreign_item(&mut self, fi: &'tcx hir::ForeignItem) {\n-        self.in_foreign = true;\n-        intravisit::walk_foreign_item(self, fi);\n-        self.in_foreign = false;\n+        intravisit::walk_pat(self, pat);\n     }\n }\n \n@@ -1206,17 +1177,14 @@ fn privacy_access_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let krate = tcx.hir.krate();\n \n-    // Use the parent map to check the privacy of everything\n-    let mut visitor = PrivacyVisitor {\n-        curitem: DefId::local(CRATE_DEF_INDEX),\n-        in_foreign: false,\n+    // Check privacy of names not checked in previous compilation stages.\n+    let mut visitor = NamePrivacyVisitor {\n         tcx: tcx,\n         tables: &ty::TypeckTables::empty(),\n+        current_item: DefId::local(CRATE_DEF_INDEX),\n     };\n     intravisit::walk_crate(&mut visitor, krate);\n \n-    tcx.sess.abort_if_errors();\n-\n     // Build up a set of all exported items in the AST. This is a set of all\n     // items which are reachable from external crates based on visibility.\n     let mut visitor = EmbargoVisitor {"}, {"sha": "807be619f6c5f6ee71bfac6ffe4076ea7198d3b3", "filename": "src/test/compile-fail/privacy/union-field-privacy-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1883b8d715d91c65cb25fc8a2e7258c9fc704c16/src%2Ftest%2Fcompile-fail%2Fprivacy%2Funion-field-privacy-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1883b8d715d91c65cb25fc8a2e7258c9fc704c16/src%2Ftest%2Fcompile-fail%2Fprivacy%2Funion-field-privacy-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy%2Funion-field-privacy-1.rs?ref=1883b8d715d91c65cb25fc8a2e7258c9fc704c16", "patch": "@@ -18,12 +18,12 @@ mod m {\n     }\n }\n \n-fn main() {\n+fn main() { unsafe {\n     let u = m::U { a: 0 }; // OK\n     let u = m::U { b: 0 }; // OK\n     let u = m::U { c: 0 }; //~ ERROR field `c` of union `m::U` is private\n \n     let m::U { a } = u; // OK\n     let m::U { b } = u; // OK\n     let m::U { c } = u; //~ ERROR field `c` of union `m::U` is private\n-}\n+}}"}]}