{"sha": "4005d437653fc09b47cd3176bb65323c52cccd47", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwMDVkNDM3NjUzZmMwOWI0N2NkMzE3NmJiNjUzMjNjNTJjY2NkNDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-09T04:22:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-09T04:22:05Z"}, "message": "Auto merge of #30245 - Aatch:dynamic-align-dst, r=pnkfelix\n\nFixes #26403\n\nThis adjusts the pointer, if needed, to the correct alignment by using the alignment information in the vtable.\n\nHandling zero might not be necessary, as it shouldn't actually occur. I've left it as it's own commit so it can be removed fairly easily if people don't think it's worth doing. The way it's handled though means that there shouldn't be much impact on performance.", "tree": {"sha": "2708e9f2a98cacd29219d955d69e832eba87bc7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2708e9f2a98cacd29219d955d69e832eba87bc7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4005d437653fc09b47cd3176bb65323c52cccd47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4005d437653fc09b47cd3176bb65323c52cccd47", "html_url": "https://github.com/rust-lang/rust/commit/4005d437653fc09b47cd3176bb65323c52cccd47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4005d437653fc09b47cd3176bb65323c52cccd47/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56a1f51ef0b26acb0d6eb2a7dbe9336f5e942061", "url": "https://api.github.com/repos/rust-lang/rust/commits/56a1f51ef0b26acb0d6eb2a7dbe9336f5e942061", "html_url": "https://github.com/rust-lang/rust/commit/56a1f51ef0b26acb0d6eb2a7dbe9336f5e942061"}, {"sha": "d6eb063fe8c60ff7cbd83c7a27ba4bc6a24bd174", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6eb063fe8c60ff7cbd83c7a27ba4bc6a24bd174", "html_url": "https://github.com/rust-lang/rust/commit/d6eb063fe8c60ff7cbd83c7a27ba4bc6a24bd174"}], "stats": {"total": 428, "additions": 365, "deletions": 63}, "files": [{"sha": "0e09a15492a891ae3bafb659f4f4d9601196c441", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 57, "deletions": 15, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/4005d437653fc09b47cd3176bb65323c52cccd47/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4005d437653fc09b47cd3176bb65323c52cccd47/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=4005d437653fc09b47cd3176bb65323c52cccd47", "patch": "@@ -708,8 +708,10 @@ fn extract_variant_args<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     val: MatchInput)\n                                     -> ExtractedBlock<'blk, 'tcx> {\n     let _icx = push_ctxt(\"match::extract_variant_args\");\n+    // Assume enums are always sized for now.\n+    let val = adt::MaybeSizedValue::sized(val.val);\n     let args = (0..adt::num_args(repr, disr_val)).map(|i| {\n-        adt::trans_field_ptr(bcx, repr, val.val, disr_val, i)\n+        adt::trans_field_ptr(bcx, repr, val, disr_val, i)\n     }).collect();\n \n     ExtractedBlock { vals: args, bcx: bcx }\n@@ -1198,7 +1200,8 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             (arg_count - 1, Load(bcx, expr::get_dataptr(bcx, val.val)))\n         };\n         let mut field_vals: Vec<ValueRef> = (0..arg_count).map(|ix|\n-            adt::trans_field_ptr(bcx, &*repr, struct_val, 0, ix)\n+            // By definition, these are all sized\n+            adt::trans_field_ptr(bcx, &*repr, adt::MaybeSizedValue::sized(struct_val), 0, ix)\n         ).collect();\n \n         match left_ty.sty {\n@@ -1210,10 +1213,13 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                     monomorphize::field_ty(bcx.tcx(), substs, field)\n                 }).unwrap();\n                 let scratch = alloc_ty(bcx, unsized_ty, \"__struct_field_fat_ptr\");\n+\n+                let meta = Load(bcx, expr::get_meta(bcx, val.val));\n+                let struct_val = adt::MaybeSizedValue::unsized_(struct_val, meta);\n+\n                 let data = adt::trans_field_ptr(bcx, &*repr, struct_val, 0, arg_count);\n-                let len = Load(bcx, expr::get_meta(bcx, val.val));\n                 Store(bcx, data, expr::get_dataptr(bcx, scratch));\n-                Store(bcx, len, expr::get_meta(bcx, scratch));\n+                Store(bcx, meta, expr::get_meta(bcx, scratch));\n                 field_vals.push(scratch);\n             }\n             _ => {}\n@@ -1784,9 +1790,10 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     val: MatchInput,\n                                     cleanup_scope: cleanup::ScopeId)\n                                     -> Block<'blk, 'tcx> {\n-    debug!(\"bind_irrefutable_pat(bcx={}, pat={:?})\",\n+    debug!(\"bind_irrefutable_pat(bcx={}, pat={:?}, val={})\",\n            bcx.to_str(),\n-           pat);\n+           pat,\n+           bcx.val_to_string(val.val));\n \n     if bcx.sess().asm_comments() {\n         add_comment(bcx, &format!(\"bind_irrefutable_pat(pat={:?})\",\n@@ -1865,9 +1872,10 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         Some(ref elems) => {\n                             // This is the tuple struct case.\n                             let repr = adt::represent_node(bcx, pat.id);\n+                            let val = adt::MaybeSizedValue::sized(val.val);\n                             for (i, elem) in elems.iter().enumerate() {\n                                 let fldptr = adt::trans_field_ptr(bcx, &*repr,\n-                                                                  val.val, 0, i);\n+                                                                  val, 0, i);\n                                 bcx = bind_irrefutable_pat(\n                                     bcx,\n                                     &**elem,\n@@ -1887,14 +1895,35 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let pat_ty = node_id_type(bcx, pat.id);\n             let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n             let pat_v = VariantInfo::of_node(tcx, pat_ty, pat.id);\n+\n+            let val = if type_is_sized(tcx, pat_ty) {\n+                adt::MaybeSizedValue::sized(val.val)\n+            } else {\n+                let data = Load(bcx, expr::get_dataptr(bcx, val.val));\n+                let meta = Load(bcx, expr::get_meta(bcx, val.val));\n+                adt::MaybeSizedValue::unsized_(data, meta)\n+            };\n+\n             for f in fields {\n                 let name = f.node.name;\n-                let fldptr = adt::trans_field_ptr(\n+                let field_idx = pat_v.field_index(name);\n+                let mut fldptr = adt::trans_field_ptr(\n                     bcx,\n                     &*pat_repr,\n-                    val.val,\n+                    val,\n                     pat_v.discr,\n-                    pat_v.field_index(name));\n+                    field_idx);\n+\n+                let fty = pat_v.fields[field_idx].1;\n+                // If it's not sized, then construct a fat pointer instead of\n+                // a regular one\n+                if !type_is_sized(tcx, fty) {\n+                    let scratch = alloc_ty(bcx, fty, \"__struct_field_fat_ptr\");\n+                    debug!(\"Creating fat pointer {}\", bcx.val_to_string(scratch));\n+                    Store(bcx, fldptr, expr::get_dataptr(bcx, scratch));\n+                    Store(bcx, val.meta, expr::get_meta(bcx, scratch));\n+                    fldptr = scratch;\n+                }\n                 bcx = bind_irrefutable_pat(bcx,\n                                            &*f.node.pat,\n                                            MatchInput::from_val(fldptr),\n@@ -1903,8 +1932,9 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         hir::PatTup(ref elems) => {\n             let repr = adt::represent_node(bcx, pat.id);\n+            let val = adt::MaybeSizedValue::sized(val.val);\n             for (i, elem) in elems.iter().enumerate() {\n-                let fldptr = adt::trans_field_ptr(bcx, &*repr, val.val, 0, i);\n+                let fldptr = adt::trans_field_ptr(bcx, &*repr, val, 0, i);\n                 bcx = bind_irrefutable_pat(\n                     bcx,\n                     &**elem,\n@@ -1913,16 +1943,28 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         hir::PatBox(ref inner) => {\n-            let llbox = Load(bcx, val.val);\n+            let pat_ty = node_id_type(bcx, inner.id);\n+            // Don't load DSTs, instead pass along a fat ptr\n+            let val = if type_is_sized(tcx, pat_ty) {\n+                Load(bcx, val.val)\n+            } else {\n+                val.val\n+            };\n             bcx = bind_irrefutable_pat(\n-                bcx, &**inner, MatchInput::from_val(llbox), cleanup_scope);\n+                bcx, &**inner, MatchInput::from_val(val), cleanup_scope);\n         }\n         hir::PatRegion(ref inner, _) => {\n-            let loaded_val = Load(bcx, val.val);\n+            let pat_ty = node_id_type(bcx, inner.id);\n+            // Don't load DSTs, instead pass along a fat ptr\n+            let val = if type_is_sized(tcx, pat_ty) {\n+                Load(bcx, val.val)\n+            } else {\n+                val.val\n+            };\n             bcx = bind_irrefutable_pat(\n                 bcx,\n                 &**inner,\n-                MatchInput::from_val(loaded_val),\n+                MatchInput::from_val(val),\n                 cleanup_scope);\n         }\n         hir::PatVec(ref before, ref slice, ref after) => {"}, {"sha": "f6f1918fd074168ec94ea82befa3bddae3e59b1b", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 128, "deletions": 13, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/4005d437653fc09b47cd3176bb65323c52cccd47/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4005d437653fc09b47cd3176bb65323c52cccd47/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=4005d437653fc09b47cd3176bb65323c52cccd47", "patch": "@@ -43,6 +43,7 @@\n \n pub use self::Repr::*;\n \n+use std;\n use std::rc::Rc;\n \n use llvm::{ValueRef, True, IntEQ, IntNE};\n@@ -60,6 +61,7 @@ use trans::cleanup::CleanupMethods;\n use trans::common::*;\n use trans::datum;\n use trans::debuginfo::DebugLoc;\n+use trans::glue;\n use trans::machine;\n use trans::monomorphize;\n use trans::type_::Type;\n@@ -153,6 +155,32 @@ pub struct Struct<'tcx> {\n     pub fields: Vec<Ty<'tcx>>,\n }\n \n+#[derive(Copy, Clone)]\n+pub struct MaybeSizedValue {\n+    pub value: ValueRef,\n+    pub meta: ValueRef,\n+}\n+\n+impl MaybeSizedValue {\n+    pub fn sized(value: ValueRef) -> MaybeSizedValue {\n+        MaybeSizedValue {\n+            value: value,\n+            meta: std::ptr::null_mut()\n+        }\n+    }\n+\n+    pub fn unsized_(value: ValueRef, meta: ValueRef) -> MaybeSizedValue {\n+        MaybeSizedValue {\n+            value: value,\n+            meta: meta\n+        }\n+    }\n+\n+    pub fn has_meta(&self) -> bool {\n+        !self.meta.is_null()\n+    }\n+}\n+\n /// Convenience for `represent_type`.  There should probably be more or\n /// these, for places in trans where the `Ty` isn't directly\n /// available.\n@@ -247,7 +275,11 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 monomorphize::field_ty(cx.tcx(), substs, field)\n             }).collect::<Vec<_>>();\n             let packed = cx.tcx().lookup_packed(def.did);\n-            let dtor = def.dtor_kind().has_drop_flag();\n+            // FIXME(16758) don't add a drop flag to unsized structs, as it\n+            // won't actually be in the location we say it is because it'll be after\n+            // the unsized field. Several other pieces of code assume that the unsized\n+            // field is definitely the last one.\n+            let dtor = def.dtor_kind().has_drop_flag() && type_is_sized(cx.tcx(), t);\n             if dtor {\n                 ftys.push(cx.tcx().dtor_type());\n             }\n@@ -976,7 +1008,7 @@ pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n         }\n         General(ity, ref cases, dtor) => {\n             if dtor_active(dtor) {\n-                let ptr = trans_field_ptr(bcx, r, val, discr,\n+                let ptr = trans_field_ptr(bcx, r, MaybeSizedValue::sized(val), discr,\n                                           cases[discr as usize].fields.len() - 2);\n                 Store(bcx, C_u8(bcx.ccx(), DTOR_NEEDED), ptr);\n             }\n@@ -1037,7 +1069,7 @@ pub fn num_args(r: &Repr, discr: Disr) -> usize {\n \n /// Access a field, at a point when the value's case is known.\n pub fn trans_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n-                                   val: ValueRef, discr: Disr, ix: usize) -> ValueRef {\n+                                   val: MaybeSizedValue, discr: Disr, ix: usize) -> ValueRef {\n     // Note: if this ever needs to generate conditionals (e.g., if we\n     // decide to do some kind of cdr-coding-like non-unique repr\n     // someday), it will need to return a possibly-new bcx as well.\n@@ -1060,13 +1092,13 @@ pub fn trans_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n             assert_eq!(machine::llsize_of_alloc(bcx.ccx(), ty), 0);\n             // The contents of memory at this pointer can't matter, but use\n             // the value that's \"reasonable\" in case of pointer comparison.\n-            PointerCast(bcx, val, ty.ptr_to())\n+            PointerCast(bcx, val.value, ty.ptr_to())\n         }\n         RawNullablePointer { nndiscr, nnty, .. } => {\n             assert_eq!(ix, 0);\n             assert_eq!(discr, nndiscr);\n             let ty = type_of::type_of(bcx.ccx(), nnty);\n-            PointerCast(bcx, val, ty.ptr_to())\n+            PointerCast(bcx, val.value, ty.ptr_to())\n         }\n         StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n             assert_eq!(discr, nndiscr);\n@@ -1075,18 +1107,100 @@ pub fn trans_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n     }\n }\n \n-pub fn struct_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, st: &Struct<'tcx>, val: ValueRef,\n+pub fn struct_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, st: &Struct<'tcx>, val: MaybeSizedValue,\n                                     ix: usize, needs_cast: bool) -> ValueRef {\n-    let val = if needs_cast {\n-        let ccx = bcx.ccx();\n-        let fields = st.fields.iter().map(|&ty| type_of::type_of(ccx, ty)).collect::<Vec<_>>();\n+    let ccx = bcx.ccx();\n+    let ptr_val = if needs_cast {\n+        let fields = st.fields.iter().map(|&ty| {\n+            type_of::in_memory_type_of(ccx, ty)\n+        }).collect::<Vec<_>>();\n         let real_ty = Type::struct_(ccx, &fields[..], st.packed);\n-        PointerCast(bcx, val, real_ty.ptr_to())\n+        PointerCast(bcx, val.value, real_ty.ptr_to())\n     } else {\n-        val\n+        val.value\n     };\n \n-    StructGEP(bcx, val, ix)\n+    let fty = st.fields[ix];\n+    // Simple case - we can just GEP the field\n+    //   * First field - Always aligned properly\n+    //   * Packed struct - There is no alignment padding\n+    //   * Field is sized - pointer is properly aligned already\n+    if ix == 0 || st.packed || type_is_sized(bcx.tcx(), fty) {\n+        return StructGEP(bcx, ptr_val, ix);\n+    }\n+\n+    // If the type of the last field is [T] or str, then we don't need to do\n+    // any adjusments\n+    match fty.sty {\n+        ty::TySlice(..) | ty::TyStr => {\n+            return StructGEP(bcx, ptr_val, ix);\n+        }\n+        _ => ()\n+    }\n+\n+    // There's no metadata available, log the case and just do the GEP.\n+    if !val.has_meta() {\n+        debug!(\"Unsized field `{}`, of `{}` has no metadata for adjustment\",\n+               ix,\n+               bcx.val_to_string(ptr_val));\n+        return StructGEP(bcx, ptr_val, ix);\n+    }\n+\n+    let dbloc = DebugLoc::None;\n+\n+    // We need to get the pointer manually now.\n+    // We do this by casting to a *i8, then offsetting it by the appropriate amount.\n+    // We do this instead of, say, simply adjusting the pointer from the result of a GEP\n+    // because the field may have an arbitrary alignment in the LLVM representation\n+    // anyway.\n+    //\n+    // To demonstrate:\n+    //   struct Foo<T: ?Sized> {\n+    //      x: u16,\n+    //      y: T\n+    //   }\n+    //\n+    // The type Foo<Foo<Trait>> is represented in LLVM as { u16, { u16, u8 }}, meaning that\n+    // the `y` field has 16-bit alignment.\n+\n+    let meta = val.meta;\n+\n+    // Calculate the unaligned offset of the the unsized field.\n+    let mut offset = 0;\n+    for &ty in &st.fields[0..ix] {\n+        let llty = type_of::sizing_type_of(ccx, ty);\n+        let type_align = type_of::align_of(ccx, ty);\n+        offset = roundup(offset, type_align);\n+        offset += machine::llsize_of_alloc(ccx, llty);\n+    }\n+    let unaligned_offset = C_uint(bcx.ccx(), offset);\n+\n+    // Get the alignment of the field\n+    let (_, align) = glue::size_and_align_of_dst(bcx, fty, meta);\n+\n+    // Bump the unaligned offset up to the appropriate alignment using the\n+    // following expression:\n+    //\n+    //   (unaligned offset + (align - 1)) & -align\n+\n+    // Calculate offset\n+    let align_sub_1 = Sub(bcx, align, C_uint(bcx.ccx(), 1u64), dbloc);\n+    let offset = And(bcx,\n+                     Add(bcx, unaligned_offset, align_sub_1, dbloc),\n+                     Neg(bcx, align, dbloc),\n+                     dbloc);\n+\n+    debug!(\"struct_field_ptr: DST field offset: {}\",\n+           bcx.val_to_string(offset));\n+\n+    // Cast and adjust pointer\n+    let byte_ptr = PointerCast(bcx, ptr_val, Type::i8p(bcx.ccx()));\n+    let byte_ptr = GEP(bcx, byte_ptr, &[offset]);\n+\n+    // Finally, cast back to the type expected\n+    let ll_fty = type_of::in_memory_type_of(bcx.ccx(), fty);\n+    debug!(\"struct_field_ptr: Field type is {}\", ll_fty.to_string());\n+    PointerCast(bcx, byte_ptr, ll_fty.ptr_to())\n }\n \n pub fn fold_variants<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n@@ -1168,7 +1282,8 @@ pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 cleanup::CustomScope(custom_cleanup_scope), (), |_, bcx, _| bcx\n             ));\n             bcx = fold_variants(bcx, r, val, |variant_cx, st, value| {\n-                let ptr = struct_field_ptr(variant_cx, st, value, (st.fields.len() - 1), false);\n+                let ptr = struct_field_ptr(variant_cx, st, MaybeSizedValue::sized(value),\n+                                           (st.fields.len() - 1), false);\n                 datum::Datum::new(ptr, ptr_ty, datum::Lvalue::new(\"adt::trans_drop_flag_ptr\"))\n                     .store_to(variant_cx, scratch.val)\n             });"}, {"sha": "dde6e3935b25d2add160fe5bf4812a71a1d49e09", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4005d437653fc09b47cd3176bb65323c52cccd47/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4005d437653fc09b47cd3176bb65323c52cccd47/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=4005d437653fc09b47cd3176bb65323c52cccd47", "patch": "@@ -472,7 +472,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n \n     fn iter_variant<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                                    repr: &adt::Repr<'tcx>,\n-                                   av: ValueRef,\n+                                   av: adt::MaybeSizedValue,\n                                    variant: ty::VariantDef<'tcx>,\n                                    substs: &Substs<'tcx>,\n                                    f: &mut F)\n@@ -492,12 +492,12 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n         return cx;\n     }\n \n-    let (data_ptr, info) = if common::type_is_sized(cx.tcx(), t) {\n-        (av, None)\n+    let value = if common::type_is_sized(cx.tcx(), t) {\n+        adt::MaybeSizedValue::sized(av)\n     } else {\n-        let data = expr::get_dataptr(cx, av);\n-        let info = expr::get_meta(cx, av);\n-        (Load(cx, data), Some(Load(cx, info)))\n+        let data = Load(cx, expr::get_dataptr(cx, av));\n+        let info = Load(cx, expr::get_meta(cx, av));\n+        adt::MaybeSizedValue::unsized_(data, info)\n     };\n \n     let mut cx = cx;\n@@ -506,14 +506,14 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n             let repr = adt::represent_type(cx.ccx(), t);\n             let VariantInfo { fields, discr } = VariantInfo::from_ty(cx.tcx(), t, None);\n             for (i, &Field(_, field_ty)) in fields.iter().enumerate() {\n-                let llfld_a = adt::trans_field_ptr(cx, &*repr, data_ptr, discr, i);\n+                let llfld_a = adt::trans_field_ptr(cx, &*repr, value, discr, i);\n \n                 let val = if common::type_is_sized(cx.tcx(), field_ty) {\n                     llfld_a\n                 } else {\n                     let scratch = datum::rvalue_scratch_datum(cx, field_ty, \"__fat_ptr_iter\");\n                     Store(cx, llfld_a, expr::get_dataptr(cx, scratch.val));\n-                    Store(cx, info.unwrap(), expr::get_meta(cx, scratch.val));\n+                    Store(cx, value.meta, expr::get_meta(cx, scratch.val));\n                     scratch.val\n                 };\n                 cx = f(cx, val, field_ty);\n@@ -522,23 +522,23 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n         ty::TyClosure(_, ref substs) => {\n             let repr = adt::represent_type(cx.ccx(), t);\n             for (i, upvar_ty) in substs.upvar_tys.iter().enumerate() {\n-                let llupvar = adt::trans_field_ptr(cx, &*repr, data_ptr, 0, i);\n+                let llupvar = adt::trans_field_ptr(cx, &*repr, value, 0, i);\n                 cx = f(cx, llupvar, upvar_ty);\n             }\n         }\n         ty::TyArray(_, n) => {\n-            let (base, len) = tvec::get_fixed_base_and_len(cx, data_ptr, n);\n+            let (base, len) = tvec::get_fixed_base_and_len(cx, value.value, n);\n             let unit_ty = t.sequence_element_type(cx.tcx());\n             cx = tvec::iter_vec_raw(cx, base, unit_ty, len, f);\n         }\n         ty::TySlice(_) | ty::TyStr => {\n             let unit_ty = t.sequence_element_type(cx.tcx());\n-            cx = tvec::iter_vec_raw(cx, data_ptr, unit_ty, info.unwrap(), f);\n+            cx = tvec::iter_vec_raw(cx, value.value, unit_ty, value.meta, f);\n         }\n         ty::TyTuple(ref args) => {\n             let repr = adt::represent_type(cx.ccx(), t);\n             for (i, arg) in args.iter().enumerate() {\n-                let llfld_a = adt::trans_field_ptr(cx, &*repr, data_ptr, 0, i);\n+                let llfld_a = adt::trans_field_ptr(cx, &*repr, value, 0, i);\n                 cx = f(cx, llfld_a, *arg);\n             }\n         }\n@@ -556,7 +556,8 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                 (_match::Single, None) => {\n                     if n_variants != 0 {\n                         assert!(n_variants == 1);\n-                        cx = iter_variant(cx, &*repr, av, &en.variants[0], substs, &mut f);\n+                        cx = iter_variant(cx, &*repr, adt::MaybeSizedValue::sized(av),\n+                                          &en.variants[0], substs, &mut f);\n                     }\n                 }\n                 (_match::Switch, Some(lldiscrim_a)) => {\n@@ -588,7 +589,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                         AddCase(llswitch, case_val, variant_cx.llbb);\n                         let variant_cx = iter_variant(variant_cx,\n                                                       &*repr,\n-                                                      data_ptr,\n+                                                      value,\n                                                       variant,\n                                                       substs,\n                                                       &mut f);\n@@ -707,6 +708,9 @@ pub fn coerce_unsized_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 _ => bcx.sess().bug(\"struct has non-univariant repr\"),\n             };\n \n+            let src = adt::MaybeSizedValue::sized(src);\n+            let dst = adt::MaybeSizedValue::sized(dst);\n+\n             let iter = src_fields.iter().zip(dst_fields).enumerate();\n             for (i, (src_fty, dst_fty)) in iter {\n                 if type_is_zero_size(bcx.ccx(), dst_fty) {\n@@ -2105,10 +2109,11 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n \n     if !type_is_zero_size(fcx.ccx, result_ty.unwrap()) {\n         let dest = fcx.get_ret_slot(bcx, result_ty, \"eret_slot\");\n+        let dest_val = adt::MaybeSizedValue::sized(dest); // Can return unsized value\n         let repr = adt::represent_type(ccx, result_ty.unwrap());\n         let mut llarg_idx = fcx.arg_offset() as c_uint;\n         for (i, arg_ty) in arg_tys.into_iter().enumerate() {\n-            let lldestptr = adt::trans_field_ptr(bcx, &*repr, dest, disr, i);\n+            let lldestptr = adt::trans_field_ptr(bcx, &*repr, dest_val, disr, i);\n             if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n                 Store(bcx,\n                       get_param(fcx.llfn, llarg_idx),"}, {"sha": "be4028e37d7182a52e85f47abba5bb443741302f", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4005d437653fc09b47cd3176bb65323c52cccd47/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4005d437653fc09b47cd3176bb65323c52cccd47/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=4005d437653fc09b47cd3176bb65323c52cccd47", "patch": "@@ -811,6 +811,32 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                    .collect::<Vec<String>>()\n                    .join(\", \"));\n \n+        let mut fn_ty = val_ty(llfn);\n+        // Strip off pointers\n+        while fn_ty.kind() == llvm::TypeKind::Pointer {\n+            fn_ty = fn_ty.element_type();\n+        }\n+\n+        assert!(fn_ty.kind() == llvm::TypeKind::Function,\n+                \"builder::call not passed a function\");\n+\n+        let param_tys = fn_ty.func_params();\n+\n+        let iter = param_tys.into_iter()\n+            .zip(args.iter().map(|&v| val_ty(v)));\n+        for (i, (expected_ty, actual_ty)) in iter.enumerate() {\n+            if expected_ty != actual_ty {\n+                self.ccx.sess().bug(\n+                    &format!(\n+                        \"Type mismatch in function call of {}.  Expected {} for param {}, got {}\",\n+                        self.ccx.tn().val_to_string(llfn),\n+                        self.ccx.tn().type_to_string(expected_ty),\n+                        i,\n+                        self.ccx.tn().type_to_string(actual_ty)));\n+\n+            }\n+        }\n+\n         unsafe {\n             let v = llvm::LLVMBuildCall(self.llbuilder, llfn, args.as_ptr(),\n                                         args.len() as c_uint, noname());"}, {"sha": "c125ba30a51e8ca685c4a608f1d41173ca1d9d43", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4005d437653fc09b47cd3176bb65323c52cccd47/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4005d437653fc09b47cd3176bb65323c52cccd47/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=4005d437653fc09b47cd3176bb65323c52cccd47", "patch": "@@ -239,7 +239,8 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     // Create the closure.\n     for (i, freevar) in freevars.iter().enumerate() {\n         let datum = expr::trans_local_var(bcx, freevar.def);\n-        let upvar_slot_dest = adt::trans_field_ptr(bcx, &*repr, dest_addr, 0, i);\n+        let upvar_slot_dest = adt::trans_field_ptr(\n+            bcx, &*repr, adt::MaybeSizedValue::sized(dest_addr), 0, i);\n         let upvar_id = ty::UpvarId { var_id: freevar.def.var_id(),\n                                      closure_expr_id: id };\n         match tcx.upvar_capture(upvar_id).unwrap() {"}, {"sha": "418ff4c8337e7f27dd48da0a72d0ef98c34400fd", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4005d437653fc09b47cd3176bb65323c52cccd47/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4005d437653fc09b47cd3176bb65323c52cccd47/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=4005d437653fc09b47cd3176bb65323c52cccd47", "patch": "@@ -655,12 +655,16 @@ impl<'tcx> Datum<'tcx, Lvalue> {\n     pub fn get_element<'blk, F>(&self, bcx: Block<'blk, 'tcx>, ty: Ty<'tcx>,\n                                 gep: F)\n                                 -> Datum<'tcx, Lvalue> where\n-        F: FnOnce(ValueRef) -> ValueRef,\n+        F: FnOnce(adt::MaybeSizedValue) -> ValueRef,\n     {\n         let val = if type_is_sized(bcx.tcx(), self.ty) {\n-            gep(self.val)\n+            let val = adt::MaybeSizedValue::sized(self.val);\n+            gep(val)\n         } else {\n-            gep(Load(bcx, expr::get_dataptr(bcx, self.val)))\n+            let val = adt::MaybeSizedValue::unsized_(\n+                Load(bcx, expr::get_dataptr(bcx, self.val)),\n+                Load(bcx, expr::get_meta(bcx, self.val)));\n+            gep(val)\n         };\n         Datum {\n             val: val,"}, {"sha": "0fb26d420f8d97e3df8b10c3df419c076a4cabf7", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4005d437653fc09b47cd3176bb65323c52cccd47/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4005d437653fc09b47cd3176bb65323c52cccd47/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=4005d437653fc09b47cd3176bb65323c52cccd47", "patch": "@@ -542,10 +542,13 @@ fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             };\n             assert!(coerce_index < src_fields.len() && src_fields.len() == target_fields.len());\n \n+            let source_val = adt::MaybeSizedValue::sized(source.val);\n+            let target_val = adt::MaybeSizedValue::sized(target.val);\n+\n             let iter = src_fields.iter().zip(target_fields).enumerate();\n             for (i, (src_ty, target_ty)) in iter {\n-                let ll_source = adt::trans_field_ptr(bcx, &repr_source, source.val, 0, i);\n-                let ll_target = adt::trans_field_ptr(bcx, &repr_target, target.val, 0, i);\n+                let ll_source = adt::trans_field_ptr(bcx, &repr_source, source_val, 0, i);\n+                let ll_target = adt::trans_field_ptr(bcx, &repr_target, target_val, 0, i);\n \n                 // If this is the field we need to coerce, recurse on it.\n                 if i == coerce_index {\n@@ -737,7 +740,9 @@ fn trans_field<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     let d = base_datum.get_element(\n         bcx,\n         vinfo.fields[ix].1,\n-        |srcval| adt::trans_field_ptr(bcx, &*repr, srcval, vinfo.discr, ix));\n+        |srcval| {\n+            adt::trans_field_ptr(bcx, &*repr, srcval, vinfo.discr, ix)\n+        });\n \n     if type_is_sized(bcx.tcx(), d.ty) {\n         DatumBlock { datum: d.to_expr_datum(), bcx: bcx }\n@@ -1512,9 +1517,10 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         // Second, trans the base to the dest.\n         assert_eq!(discr, 0);\n \n+        let addr = adt::MaybeSizedValue::sized(addr);\n         match expr_kind(bcx.tcx(), &*base.expr) {\n             ExprKind::RvalueDps | ExprKind::RvalueDatum if !bcx.fcx.type_needs_drop(ty) => {\n-                bcx = trans_into(bcx, &*base.expr, SaveIn(addr));\n+                bcx = trans_into(bcx, &*base.expr, SaveIn(addr.value));\n             },\n             ExprKind::RvalueStmt => {\n                 bcx.tcx().sess.bug(\"unexpected expr kind for struct base expr\")\n@@ -1538,6 +1544,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n     } else {\n         // No base means we can write all fields directly in place.\n+        let addr = adt::MaybeSizedValue::sized(addr);\n         for &(i, ref e) in fields {\n             let dest = adt::trans_field_ptr(bcx, &*repr, addr, discr, i);\n             let e_ty = expr_ty_adjusted(bcx, &**e);"}, {"sha": "3fc9bc0d66d3d48d7834cf6ea4807f03adfd1be9", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4005d437653fc09b47cd3176bb65323c52cccd47/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4005d437653fc09b47cd3176bb65323c52cccd47/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=4005d437653fc09b47cd3176bb65323c52cccd47", "patch": "@@ -12,6 +12,7 @@\n //\n // Code relating to drop glue.\n \n+use std;\n \n use back::link::*;\n use llvm;\n@@ -433,14 +434,21 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n \n             // Choose max of two known alignments (combined value must\n             // be aligned according to more restrictive of the two).\n-            let align = Select(bcx,\n-                               ICmp(bcx,\n-                                    llvm::IntUGT,\n-                                    sized_align,\n-                                    unsized_align,\n-                                    dbloc),\n-                               sized_align,\n-                               unsized_align);\n+            let align = match (const_to_opt_uint(sized_align), const_to_opt_uint(unsized_align)) {\n+                (Some(sized_align), Some(unsized_align)) => {\n+                    // If both alignments are constant, (the sized_align should always be), then\n+                    // pick the correct alignment statically.\n+                    C_uint(ccx, std::cmp::max(sized_align, unsized_align))\n+                }\n+                _ => Select(bcx,\n+                            ICmp(bcx,\n+                                 llvm::IntUGT,\n+                                 sized_align,\n+                                 unsized_align,\n+                                 dbloc),\n+                            sized_align,\n+                            unsized_align)\n+            };\n \n             // Issue #27023: must add any necessary padding to `size`\n             // (to make it a multiple of `align`) before returning it.\n@@ -451,7 +459,7 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n             //\n             // emulated via the semi-standard fast bit trick:\n             //\n-            //   `(size + (align-1)) & !align`\n+            //   `(size + (align-1)) & -align`\n \n             let addend = Sub(bcx, align, C_uint(bcx.ccx(), 1_u64), dbloc);\n             let size = And("}, {"sha": "27f5e31eaaf7cc3e7070f580dbe9963b1eb7292a", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4005d437653fc09b47cd3176bb65323c52cccd47/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4005d437653fc09b47cd3176bb65323c52cccd47/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=4005d437653fc09b47cd3176bb65323c52cccd47", "patch": "@@ -845,9 +845,10 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n                         let repr = adt::represent_type(bcx.ccx(), arg_type);\n                         let repr_ptr = &*repr;\n+                        let arg = adt::MaybeSizedValue::sized(llarg);\n                         (0..contents.len())\n                             .map(|i| {\n-                                Load(bcx, adt::trans_field_ptr(bcx, repr_ptr, llarg, 0, i))\n+                                Load(bcx, adt::trans_field_ptr(bcx, repr_ptr, arg, 0, i))\n                             })\n                             .collect()\n                     }"}, {"sha": "f3c2c3459796ac634f5e71418d20e664bccf1781", "filename": "src/librustc_trans/trans/mir/lvalue.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4005d437653fc09b47cd3176bb65323c52cccd47/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4005d437653fc09b47cd3176bb65323c52cccd47/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs?ref=4005d437653fc09b47cd3176bb65323c52cccd47", "patch": "@@ -116,8 +116,14 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             LvalueTy::Downcast { adt_def: _, substs: _, variant_index: v } => v,\n                         };\n                         let discr = discr as u64;\n-                        (adt::trans_field_ptr(bcx, &base_repr, tr_base.llval, discr, field.index()),\n-                         if common::type_is_sized(tcx, projected_ty.to_ty(tcx)) {\n+                        let is_sized = common::type_is_sized(tcx, projected_ty.to_ty(tcx));\n+                        let base = if is_sized {\n+                            adt::MaybeSizedValue::sized(tr_base.llval)\n+                        } else {\n+                            adt::MaybeSizedValue::unsized_(tr_base.llval, tr_base.llextra)\n+                        };\n+                        (adt::trans_field_ptr(bcx, &base_repr, base, discr, field.index()),\n+                         if is_sized {\n                              ptr::null_mut()\n                          } else {\n                              tr_base.llextra"}, {"sha": "cf2acfe986c2155b4276613b65882ece9bf5770d", "filename": "src/test/run-pass/dst-field-align.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/4005d437653fc09b47cd3176bb65323c52cccd47/src%2Ftest%2Frun-pass%2Fdst-field-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4005d437653fc09b47cd3176bb65323c52cccd47/src%2Ftest%2Frun-pass%2Fdst-field-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-field-align.rs?ref=4005d437653fc09b47cd3176bb65323c52cccd47", "patch": "@@ -0,0 +1,87 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo<T: ?Sized> {\n+    a: u16,\n+    b: T\n+}\n+\n+trait Bar {\n+    fn get(&self) -> usize;\n+}\n+\n+impl Bar for usize {\n+    fn get(&self) -> usize { *self }\n+}\n+\n+struct Baz<T: ?Sized> {\n+    a: T\n+}\n+\n+#[repr(packed)]\n+struct Packed<T: ?Sized> {\n+    a: u8,\n+    b: T\n+}\n+\n+struct HasDrop<T: ?Sized> {\n+    ptr: Box<usize>,\n+    data: T\n+}\n+\n+fn main() {\n+    // Test that zero-offset works properly\n+    let b : Baz<usize> = Baz { a: 7 };\n+    assert_eq!(b.a.get(), 7);\n+    let b : &Baz<Bar> = &b;\n+    assert_eq!(b.a.get(), 7);\n+\n+    // Test that the field is aligned properly\n+    let f : Foo<usize> = Foo { a: 0, b: 11 };\n+    assert_eq!(f.b.get(), 11);\n+    let ptr1 : *const u8 = &f.b as *const _ as *const u8;\n+\n+    let f : &Foo<Bar> = &f;\n+    let ptr2 : *const u8 = &f.b as *const _ as *const u8;\n+    assert_eq!(f.b.get(), 11);\n+\n+    // The pointers should be the same\n+    assert_eq!(ptr1, ptr2);\n+\n+    // Test that packed structs are handled correctly\n+    let p : Packed<usize> = Packed { a: 0, b: 13 };\n+    assert_eq!(p.b.get(), 13);\n+    let p : &Packed<Bar> = &p;\n+    assert_eq!(p.b.get(), 13);\n+\n+    // Test that nested DSTs work properly\n+    let f : Foo<Foo<usize>> = Foo { a: 0, b: Foo { a: 1, b: 17 }};\n+    assert_eq!(f.b.b.get(), 17);\n+    let f : &Foo<Foo<Bar>> = &f;\n+    assert_eq!(f.b.b.get(), 17);\n+\n+    // Test that get the pointer via destructuring works\n+\n+    let f : Foo<usize> = Foo { a: 0, b: 11 };\n+    let f : &Foo<Bar> = &f;\n+    let &Foo { a: _, b: ref bar } = f;\n+    assert_eq!(bar.get(), 11);\n+\n+    // Make sure that drop flags don't screw things up\n+\n+    let d : HasDrop<Baz<[i32; 4]>> = HasDrop {\n+        ptr: Box::new(0),\n+        data: Baz { a: [1,2,3,4] }\n+    };\n+    assert_eq!([1,2,3,4], d.data.a);\n+\n+    let d : &HasDrop<Baz<[i32]>> = &d;\n+    assert_eq!(&[1,2,3,4], &d.data.a);\n+}"}]}