{"sha": "9b9ffd5b4196d409dd76c224442ee0fee91fd9e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliOWZmZDViNDE5NmQ0MDlkZDc2YzIyNDQ0MmVlMGZlZTkxZmQ5ZTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-12T04:12:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-12T04:12:43Z"}, "message": "auto merge of #5304 : jld/rust/const-adjustments, r=graydon\n\nThese changes make const translation use adjustments (autodereference, autoreference, bare-fn-to-closure), like normal code does, replacing some ad-hoc logic that wasn't always right.\r\n\r\nAs a convenient side-effect, explicit dereference (both of pointers and of newtypes) is also supported in const expressions.\r\n\r\nThere is also a \u201cbonus fix\u201d for a bug in the pretty-printer exposed by one of the added tests.", "tree": {"sha": "7539a8b5ccee75ed63ea57e822ddde4f8033f650", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7539a8b5ccee75ed63ea57e822ddde4f8033f650"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b9ffd5b4196d409dd76c224442ee0fee91fd9e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b9ffd5b4196d409dd76c224442ee0fee91fd9e4", "html_url": "https://github.com/rust-lang/rust/commit/9b9ffd5b4196d409dd76c224442ee0fee91fd9e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b9ffd5b4196d409dd76c224442ee0fee91fd9e4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3", "html_url": "https://github.com/rust-lang/rust/commit/48cb9a8ac0b95408a142ea7bc9767414eba2cbb3"}, {"sha": "1df0a0ba0f04e15d74307088dd3c952dd61f2183", "url": "https://api.github.com/repos/rust-lang/rust/commits/1df0a0ba0f04e15d74307088dd3c952dd61f2183", "html_url": "https://github.com/rust-lang/rust/commit/1df0a0ba0f04e15d74307088dd3c952dd61f2183"}], "stats": {"total": 246, "additions": 193, "deletions": 53}, "files": [{"sha": "7d228f7687147f3bc7897ffadde4b9d50ae62228", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ffd5b4196d409dd76c224442ee0fee91fd9e4/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ffd5b4196d409dd76c224442ee0fee91fd9e4/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=9b9ffd5b4196d409dd76c224442ee0fee91fd9e4", "patch": "@@ -91,8 +91,8 @@ pub fn check_expr(sess: Session,\n                   v: visit::vt<bool>) {\n     if is_const {\n         match e.node {\n-          expr_unary(box(_), _) | expr_unary(uniq(_), _) |\n-          expr_unary(deref, _) => {\n+          expr_unary(deref, _) => { }\n+          expr_unary(box(_), _) | expr_unary(uniq(_), _) => {\n             sess.span_err(e.span,\n                           ~\"disallowed operator in constant expression\");\n             return;"}, {"sha": "1d1fb13db0c6f49897ba3596ce3533225a06caae", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 112, "deletions": 51, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ffd5b4196d409dd76c224442ee0fee91fd9e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ffd5b4196d409dd76c224442ee0fee91fd9e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=9b9ffd5b4196d409dd76c224442ee0fee91fd9e4", "patch": "@@ -10,6 +10,7 @@\n \n use core::prelude::*;\n \n+use back::abi;\n use lib::llvm::{llvm, ValueRef, TypeRef, Bool, True, False};\n use metadata::csearch;\n use middle::const_eval;\n@@ -94,30 +95,56 @@ pub fn const_vec(cx: @CrateContext, e: @ast::expr, es: &[@ast::expr])\n     }\n }\n \n-pub fn const_deref(cx: @CrateContext, v: ValueRef) -> ValueRef {\n+fn const_addr_of(cx: @CrateContext, cv: ValueRef) -> ValueRef {\n     unsafe {\n-        let v = match cx.const_globals.find(&(v as int)) {\n-            Some(v) => v,\n-            None => v\n+        let gv = do str::as_c_str(\"const\") |name| {\n+            llvm::LLVMAddGlobal(cx.llmod, val_ty(cv), name)\n         };\n+        llvm::LLVMSetInitializer(gv, cv);\n+        llvm::LLVMSetGlobalConstant(gv, True);\n+        gv\n+    }\n+}\n+\n+fn const_deref_ptr(cx: @CrateContext, v: ValueRef) -> ValueRef {\n+    let v = match cx.const_globals.find(&(v as int)) {\n+        Some(v) => v,\n+        None => v\n+    };\n+    unsafe {\n         fail_unless!(llvm::LLVMIsGlobalConstant(v) == True);\n-        let v = llvm::LLVMGetInitializer(v);\n-        v\n+        llvm::LLVMGetInitializer(v)\n     }\n }\n \n-pub fn const_autoderef(cx: @CrateContext, ty: ty::t, v: ValueRef)\n-    -> (ty::t, ValueRef) {\n-    let mut t1 = ty;\n-    let mut v1 = v;\n-    loop {\n-        // Only rptrs can be autoderef'ed in a const context.\n-        match ty::get(t1).sty {\n-            ty::ty_rptr(_, mt) => {\n-                t1 = mt.ty;\n-                v1 = const_deref(cx, v1);\n-            }\n-            _ => return (t1,v1)\n+fn const_deref_newtype(cx: @CrateContext, v: ValueRef, t: ty::t)\n+    -> ValueRef {\n+    let repr = adt::represent_type(cx, t);\n+    adt::const_get_field(cx, repr, v, 0, 0)\n+}\n+\n+fn const_deref(cx: @CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n+    -> (ValueRef, ty::t) {\n+    match ty::deref(cx.tcx, t, explicit) {\n+        Some(ref mt) => {\n+            fail_unless!(mt.mutbl != ast::m_mutbl);\n+            let dv = match ty::get(t).sty {\n+                ty::ty_ptr(*) | ty::ty_rptr(*) => {\n+                     const_deref_ptr(cx, v)\n+                }\n+                ty::ty_enum(*) | ty::ty_struct(*) => {\n+                    const_deref_newtype(cx, v, t)\n+                }\n+                _ => {\n+                    cx.sess.bug(fmt!(\"Unexpected dereferenceable type %s\",\n+                                     ty_to_str(cx.tcx, t)))\n+                }\n+            };\n+            (dv, mt.ty)\n+        }\n+        None => {\n+            cx.sess.bug(fmt!(\"Can't dereference const of type %s\",\n+                             ty_to_str(cx.tcx, t)))\n         }\n     }\n }\n@@ -142,15 +169,68 @@ pub fn get_const_val(cx: @CrateContext, def_id: ast::def_id) -> ValueRef {\n }\n \n pub fn const_expr(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n-    let ety = ty::expr_ty_adjusted(cx.tcx, e);\n-    let llty = type_of::sizing_type_of(cx, ety);\n-    let llconst = const_expr_unchecked(cx, e);\n+    let mut llconst = const_expr_unadjusted(cx, e);\n+    let ety = ty::expr_ty(cx.tcx, e);\n+    match cx.tcx.adjustments.find(&e.id) {\n+        None => { }\n+        Some(@ty::AutoAddEnv(ty::re_static, ast::BorrowedSigil)) => {\n+            llconst = C_struct(~[llconst, C_null(T_opaque_box_ptr(cx))])\n+        }\n+        Some(@ty::AutoAddEnv(ref r, ref s)) => {\n+            cx.sess.span_bug(e.span, fmt!(\"unexpected const function: \\\n+                                           region %? sigil %?\", *r, *s))\n+        }\n+        Some(@ty::AutoDerefRef(ref adj)) => {\n+            let mut ty = ety;\n+            let mut maybe_ptr = None;\n+            for adj.autoderefs.times {\n+                let (dv, dt) = const_deref(cx, llconst, ty, false);\n+                maybe_ptr = Some(llconst);\n+                llconst = dv;\n+                ty = dt;\n+            }\n+\n+            match adj.autoref {\n+                None => { }\n+                Some(ref autoref) => {\n+                    fail_unless!(autoref.region == ty::re_static);\n+                    fail_unless!(autoref.mutbl != ast::m_mutbl);\n+                    // Don't copy data to do a deref+ref.\n+                    let llptr = match maybe_ptr {\n+                        Some(ptr) => ptr,\n+                        None => const_addr_of(cx, llconst)\n+                    };\n+                    match autoref.kind {\n+                        ty::AutoPtr => {\n+                            llconst = llptr;\n+                        }\n+                        ty::AutoBorrowVec => {\n+                            let size = machine::llsize_of(cx,\n+                                                          val_ty(llconst));\n+                            fail_unless!(abi::slice_elt_base == 0);\n+                            fail_unless!(abi::slice_elt_len == 1);\n+                            llconst = C_struct(~[llptr, size]);\n+                        }\n+                        _ => {\n+                            cx.sess.span_bug(e.span,\n+                                             fmt!(\"unimplemented const \\\n+                                                   autoref %?\", autoref))\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    let ety_adjusted = ty::expr_ty_adjusted(cx.tcx, e);\n+    let llty = type_of::sizing_type_of(cx, ety_adjusted);\n     let csize = machine::llsize_of_alloc(cx, val_ty(llconst));\n     let tsize = machine::llsize_of_alloc(cx, llty);\n     if csize != tsize {\n         unsafe {\n+            // XXX these values could use some context\n             llvm::LLVMDumpValue(llconst);\n-            llvm::LLVMDumpValue(C_null(llty));\n+            llvm::LLVMDumpValue(C_undef(llty));\n         }\n         cx.sess.bug(fmt!(\"const %s of type %s has size %u instead of %u\",\n                          expr_repr(cx.tcx, e), ty_to_str(cx.tcx, ety),\n@@ -159,7 +239,7 @@ pub fn const_expr(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n     llconst\n }\n \n-fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n+fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n     unsafe {\n         let _icx = cx.insn_ctxt(\"const_expr\");\n         return match /*bad*/copy e.node {\n@@ -223,7 +303,10 @@ fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n             return match u {\n               ast::box(_)  |\n               ast::uniq(_) |\n-              ast::deref  => const_deref(cx, te),\n+              ast::deref  => {\n+                let (dv, _dt) = const_deref(cx, te, ty, true);\n+                dv\n+              }\n               ast::not    => {\n                 match ty::get(ty).sty {\n                     ty::ty_bool => {\n@@ -243,20 +326,18 @@ fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n             }\n           }\n           ast::expr_field(base, field, _) => {\n-              let bt = ty::expr_ty(cx.tcx, base);\n+              let bt = ty::expr_ty_adjusted(cx.tcx, base);\n               let brepr = adt::represent_type(cx, bt);\n               let bv = const_expr(cx, base);\n-              let (bt, bv) = const_autoderef(cx, bt, bv);\n               do expr::with_field_tys(cx.tcx, bt, None) |discr, field_tys| {\n                   let ix = ty::field_idx_strict(cx.tcx, field, field_tys);\n                   adt::const_get_field(cx, brepr, bv, discr, ix)\n               }\n           }\n \n           ast::expr_index(base, index) => {\n-              let bt = ty::expr_ty(cx.tcx, base);\n+              let bt = ty::expr_ty_adjusted(cx.tcx, base);\n               let bv = const_expr(cx, base);\n-              let (bt, bv) = const_autoderef(cx, bt, bv);\n               let iv = match const_eval::eval_const_expr(cx.tcx, index) {\n                   const_eval::const_int(i) => i as u64,\n                   const_eval::const_uint(u) => u,\n@@ -275,7 +356,7 @@ fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                           let llunitty = type_of::type_of(cx, unit_ty);\n                           let unit_sz = machine::llsize_of(cx, llunitty);\n \n-                          (const_deref(cx, const_get_elt(cx, bv, [0])),\n+                          (const_deref_ptr(cx, const_get_elt(cx, bv, [0])),\n                            llvm::LLVMConstUDiv(const_get_elt(cx, bv, [1]),\n                                                unit_sz))\n                       },\n@@ -355,13 +436,7 @@ fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n             }\n           }\n           ast::expr_addr_of(ast::m_imm, sub) => {\n-            let cv = const_expr(cx, sub);\n-            let gv = do str::as_c_str(\"const\") |name| {\n-                llvm::LLVMAddGlobal(cx.llmod, val_ty(cv), name)\n-            };\n-            llvm::LLVMSetInitializer(gv, cv);\n-            llvm::LLVMSetGlobalConstant(gv, True);\n-            gv\n+              const_addr_of(cx, const_expr(cx, sub))\n           }\n           ast::expr_tup(es) => {\n               let ety = ty::expr_ty(cx.tcx, e);\n@@ -420,26 +495,12 @@ fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n             fail_unless!(pth.types.len() == 0);\n             match cx.tcx.def_map.find(&e.id) {\n                 Some(ast::def_fn(def_id, _purity)) => {\n-                    let f = if !ast_util::is_local(def_id) {\n+                    if !ast_util::is_local(def_id) {\n                         let ty = csearch::get_type(cx.tcx, def_id).ty;\n                         base::trans_external_path(cx, def_id, ty)\n                     } else {\n                         fail_unless!(ast_util::is_local(def_id));\n                         base::get_item_val(cx, def_id.node)\n-                    };\n-                    let ety = ty::expr_ty_adjusted(cx.tcx, e);\n-                    match ty::get(ety).sty {\n-                        ty::ty_bare_fn(*) | ty::ty_ptr(*) => {\n-                            llvm::LLVMConstPointerCast(f, T_ptr(T_i8()))\n-                        }\n-                        ty::ty_closure(*) => {\n-                            C_struct(~[f, C_null(T_opaque_box_ptr(cx))])\n-                        }\n-                        _ => {\n-                            cx.sess.span_bug(e.span, fmt!(\n-                                \"unexpected const fn type: %s\",\n-                                ty_to_str(cx.tcx, ety)))\n-                        }\n                     }\n                 }\n                 Some(ast::def_const(def_id)) => {"}, {"sha": "62f593f15c18698c3e742f6795eb662b98603a9a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ffd5b4196d409dd76c224442ee0fee91fd9e4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ffd5b4196d409dd76c224442ee0fee91fd9e4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9b9ffd5b4196d409dd76c224442ee0fee91fd9e4", "patch": "@@ -1192,6 +1192,11 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n       ast::expr_addr_of(m, expr) => {\n         word(s.s, ~\"&\");\n         print_mutability(s, m);\n+        // Avoid `& &e` => `&&e`.\n+        match (m, &expr.node) {\n+            (ast::m_imm, &ast::expr_addr_of(*)) => space(s.s),\n+            _ => { }\n+        }\n         print_expr(s, expr);\n       }\n       ast::expr_lit(lit) => print_literal(s, lit),"}, {"sha": "cb56ab363356599829612484237ae627e865f58c", "filename": "src/test/run-pass/const-autoderef-newtype.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ffd5b4196d409dd76c224442ee0fee91fd9e4/src%2Ftest%2Frun-pass%2Fconst-autoderef-newtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ffd5b4196d409dd76c224442ee0fee91fd9e4/src%2Ftest%2Frun-pass%2Fconst-autoderef-newtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-autoderef-newtype.rs?ref=9b9ffd5b4196d409dd76c224442ee0fee91fd9e4", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S(&'static [int]);\n+const C0: S = S([3]);\n+const C1: int = C0[0];\n+\n+pub fn main() {\n+    fail_unless!(C1 == 3);\n+}"}, {"sha": "9fb6c4aa0dbd971eef0118d65bec5df4181a8936", "filename": "src/test/run-pass/const-autoderef.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ffd5b4196d409dd76c224442ee0fee91fd9e4/src%2Ftest%2Frun-pass%2Fconst-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ffd5b4196d409dd76c224442ee0fee91fd9e4/src%2Ftest%2Frun-pass%2Fconst-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-autoderef.rs?ref=9b9ffd5b4196d409dd76c224442ee0fee91fd9e4", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const A: [u8 * 1] = ['h' as u8];\n+const B: u8 = (&A)[0];\n+const C: &'static &'static &'static &'static [u8 * 1] = & & & &A;\n+const D: u8 = (&C)[0];\n+\n+pub fn main() {\n+    fail_unless!(B == A[0]);\n+    fail_unless!(D == A[0]);\n+}"}, {"sha": "71ae273aaa3b25b614dcee97ea5273468ba055ec", "filename": "src/test/run-pass/const-deref.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ffd5b4196d409dd76c224442ee0fee91fd9e4/src%2Ftest%2Frun-pass%2Fconst-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ffd5b4196d409dd76c224442ee0fee91fd9e4/src%2Ftest%2Frun-pass%2Fconst-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-deref.rs?ref=9b9ffd5b4196d409dd76c224442ee0fee91fd9e4", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const C: &'static int = &1000;\n+const D: int = *C;\n+struct S(&'static int);\n+const E: &'static S = &S(C);\n+const F: int = ***E;\n+\n+pub fn main() {\n+    fail_unless!(D == 1000);\n+    fail_unless!(F == 1000);\n+}"}, {"sha": "ac0bbfda20d9b26ea0bcccc3946313a027b9a6cb", "filename": "src/test/run-pass/const-enum-cast.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ffd5b4196d409dd76c224442ee0fee91fd9e4/src%2Ftest%2Frun-pass%2Fconst-enum-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ffd5b4196d409dd76c224442ee0fee91fd9e4/src%2Ftest%2Frun-pass%2Fconst-enum-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-cast.rs?ref=9b9ffd5b4196d409dd76c224442ee0fee91fd9e4", "previous_filename": "src/test/run-pass/enum-cast.rs"}, {"sha": "078ae7661cff4ea6ea78d6e178152fb85062788c", "filename": "src/test/run-pass/const-region-ptrs-noncopy.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ffd5b4196d409dd76c224442ee0fee91fd9e4/src%2Ftest%2Frun-pass%2Fconst-region-ptrs-noncopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ffd5b4196d409dd76c224442ee0fee91fd9e4/src%2Ftest%2Frun-pass%2Fconst-region-ptrs-noncopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-region-ptrs-noncopy.rs?ref=9b9ffd5b4196d409dd76c224442ee0fee91fd9e4", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+type Big = [u64 * 8];\n+struct Pair { a: int, b: &'self Big }\n+const x: &'static Big = &([13, 14, 10, 13, 11, 14, 14, 15]);\n+const y: &'static Pair<'static> = &Pair {a: 15, b: x};\n+\n+pub fn main() {\n+    fail_unless!(ptr::addr_of(x) == ptr::addr_of(y.b));\n+}"}]}