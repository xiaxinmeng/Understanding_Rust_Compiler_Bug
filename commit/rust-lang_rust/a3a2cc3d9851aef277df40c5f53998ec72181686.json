{"sha": "a3a2cc3d9851aef277df40c5f53998ec72181686", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzYTJjYzNkOTg1MWFlZjI3N2RmNDBjNWY1Mzk5OGVjNzIxODE2ODY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-27T22:30:17Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-27T23:30:27Z"}, "message": "Extract metadata::tydecode from metadata::creader", "tree": {"sha": "6ca00518c735e2138f06a6943b8416c428117d6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ca00518c735e2138f06a6943b8416c428117d6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3a2cc3d9851aef277df40c5f53998ec72181686", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3a2cc3d9851aef277df40c5f53998ec72181686", "html_url": "https://github.com/rust-lang/rust/commit/a3a2cc3d9851aef277df40c5f53998ec72181686", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3a2cc3d9851aef277df40c5f53998ec72181686/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33294c7293f101d3a0fd02aeb8976751e343f46f", "url": "https://api.github.com/repos/rust-lang/rust/commits/33294c7293f101d3a0fd02aeb8976751e343f46f", "html_url": "https://github.com/rust-lang/rust/commit/33294c7293f101d3a0fd02aeb8976751e343f46f"}], "stats": {"total": 787, "additions": 400, "deletions": 387}, "files": [{"sha": "7763b7b73d9e09ea8f760fce05551894b620d9c0", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 22, "deletions": 387, "changes": 409, "blob_url": "https://github.com/rust-lang/rust/blob/a3a2cc3d9851aef277df40c5f53998ec72181686/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a2cc3d9851aef277df40c5f53998ec72181686/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=a3a2cc3d9851aef277df40c5f53998ec72181686", "patch": "@@ -14,11 +14,6 @@ import middle::trans;\n import middle::ty;\n import back::x86;\n import util::common;\n-import util::common::span;\n-import util::common::respan;\n-import util::common::a_bang;\n-import util::common::a_ty;\n-import util::common::may_begin_ident;\n import std::str;\n import std::uint;\n import std::vec;\n@@ -31,6 +26,8 @@ import std::option::some;\n import std::os;\n import std::map::hashmap;\n import defs::*;\n+import tydecode::parse_def_id;\n+import tydecode::parse_ty_data;\n \n export get_symbol;\n export get_tag_variants;\n@@ -40,368 +37,6 @@ export lookup_defs;\n export get_type;\n export list_file_metadata;\n \n-// Type decoding\n-\n-// Compact string representation for ty::t values. API ty_str & parse_from_str\n-// (The second has to be authed pure.) Extra parameters are for converting\n-// to/from def_ids in the data buffer. Whatever format you choose should not\n-// contain pipe characters.\n-\n-// Callback to translate defs to strs or back:\n-type str_def = fn(str) -> ast::def_id ;\n-\n-type pstate =\n-    rec(vec[u8] data, int crate, mutable uint pos, uint len, ty::ctxt tcx);\n-\n-type ty_or_bang = util::common::ty_or_bang[ty::t];\n-\n-fn peek(@pstate st) -> u8 { ret st.data.(st.pos); }\n-\n-fn next(@pstate st) -> u8 {\n-    auto ch = st.data.(st.pos);\n-    st.pos = st.pos + 1u;\n-    ret ch;\n-}\n-\n-fn parse_ident(@pstate st, str_def sd, char last) -> ast::ident {\n-    fn is_last(char b, char c) -> bool {\n-        ret c == b;\n-    }\n-    ret parse_ident_(st, sd, bind is_last(last, _));\n-}\n-\n-fn parse_ident_(@pstate st, str_def sd, fn(char) -> bool is_last)\n-    -> ast::ident {\n-    auto rslt = \"\";\n-    while (! is_last(peek(st) as char)) {\n-        rslt += str::unsafe_from_byte(next(st));\n-    }\n-    ret rslt;\n-}\n-\n-\n-fn parse_ty_data(vec[u8] data, int crate_num, uint pos, uint len, str_def sd,\n-                 ty::ctxt tcx) -> ty::t {\n-    auto st =\n-        @rec(data=data, crate=crate_num, mutable pos=pos, len=len, tcx=tcx);\n-    auto result = parse_ty(st, sd);\n-    ret result;\n-}\n-\n-fn parse_ty_or_bang(@pstate st, str_def sd) -> ty_or_bang {\n-    alt (peek(st) as char) {\n-        case ('!') { auto ignore = next(st); ret a_bang[ty::t]; }\n-        case (_) { ret a_ty[ty::t](parse_ty(st, sd)); }\n-    }\n-}\n-\n-fn parse_constrs(@pstate st, str_def sd) -> vec[@ty::constr_def] {\n-    let vec[@ty::constr_def] rslt = [];\n-    alt (peek(st) as char) {\n-        case (':') {\n-            do  {\n-                auto ignore = next(st);\n-                vec::push(rslt, parse_constr(st, sd));\n-            } while (peek(st) as char == ';')\n-        }\n-        case (_) { }\n-    }\n-    ret rslt;\n-}\n-\n-fn parse_path(@pstate st, str_def sd) -> ast::path {\n-    let vec[ast::ident] idents = [];\n-    fn is_last(char c) -> bool {\n-        ret (c == '(' || c == ':');\n-    }\n-    idents += [parse_ident_(st, sd, is_last)];\n-    while (true) {\n-        alt (peek(st) as char) {\n-            case (':') {\n-                auto ignore = next(st);\n-                ignore = next(st);\n-            }\n-            case (?c) {\n-                if (c == '(') {\n-                    ret respan(rec(lo=0u, hi=0u),\n-                               rec(idents=idents, types=[]));\n-                }\n-                else {\n-                    idents += [parse_ident_(st, sd, is_last)];\n-                }\n-            }\n-        }\n-    }\n-    fail \"parse_path: ill-formed path\";\n-}\n-\n-fn parse_constr(@pstate st, str_def sd) -> @ty::constr_def {\n-    let vec[@ast::constr_arg] args = [];\n-    auto sp = rec(lo=0u,hi=0u); // FIXME: use a real span\n-    let ast::path pth = parse_path(st, sd);\n-    let char ignore = next(st) as char;\n-    assert(ignore as char == '(');\n-    auto def = parse_def(st, sd);\n-    do {\n-        alt (peek(st) as char) {\n-            case ('*') {\n-                st.pos += 1u;\n-                args += [@respan(sp, ast::carg_base)];\n-            }\n-            case (?c) {\n-                /* how will we disambiguate between\n-                 an arg index and a lit argument? */\n-                if (c >= '0' && c <= '9') {\n-                    // FIXME\n-                    args += [@respan(sp, ast::carg_ident((c as uint) - 48u))];\n-                    ignore = next(st) as char;\n-                }\n-                else {\n-                    log_err(\"Lit args are unimplemented\");\n-                    fail; // FIXME\n-                }\n-                /*\n-                else {\n-                    auto lit = parse_lit(st, sd, ',');\n-                    args += [respan(st.span, ast::carg_lit(lit))];\n-                }\n-                */\n-            }\n-        }\n-        ignore = next(st) as char;\n-    } while (ignore == ';');\n-    assert(ignore == ')');\n-    ret @respan(sp, rec(path=pth, args=args, id=def));\n-}\n-\n-fn parse_ty(@pstate st, str_def sd) -> ty::t {\n-    alt (next(st) as char) {\n-        case ('n') { ret ty::mk_nil(st.tcx); }\n-        case ('z') { ret ty::mk_bot(st.tcx); }\n-        case ('b') { ret ty::mk_bool(st.tcx); }\n-        case ('i') { ret ty::mk_int(st.tcx); }\n-        case ('u') { ret ty::mk_uint(st.tcx); }\n-        case ('l') { ret ty::mk_float(st.tcx); }\n-        case ('M') {\n-            alt (next(st) as char) {\n-                case ('b') { ret ty::mk_mach(st.tcx, common::ty_u8); }\n-                case ('w') { ret ty::mk_mach(st.tcx, common::ty_u16); }\n-                case ('l') { ret ty::mk_mach(st.tcx, common::ty_u32); }\n-                case ('d') { ret ty::mk_mach(st.tcx, common::ty_u64); }\n-                case ('B') { ret ty::mk_mach(st.tcx, common::ty_i8); }\n-                case ('W') { ret ty::mk_mach(st.tcx, common::ty_i16); }\n-                case ('L') { ret ty::mk_mach(st.tcx, common::ty_i32); }\n-                case ('D') { ret ty::mk_mach(st.tcx, common::ty_i64); }\n-                case ('f') { ret ty::mk_mach(st.tcx, common::ty_f32); }\n-                case ('F') { ret ty::mk_mach(st.tcx, common::ty_f64); }\n-            }\n-        }\n-        case ('c') { ret ty::mk_char(st.tcx); }\n-        case ('s') { ret ty::mk_str(st.tcx); }\n-        case ('S') { ret ty::mk_istr(st.tcx); }\n-        case ('t') {\n-            assert (next(st) as char == '[');\n-            auto def = parse_def(st, sd);\n-            let vec[ty::t] params = [];\n-            while (peek(st) as char != ']') { params += [parse_ty(st, sd)]; }\n-            st.pos = st.pos + 1u;\n-            ret ty::mk_tag(st.tcx, def, params);\n-        }\n-        case ('p') { ret ty::mk_param(st.tcx, parse_int(st) as uint); }\n-        case ('@') { ret ty::mk_box(st.tcx, parse_mt(st, sd)); }\n-        case ('*') { ret ty::mk_ptr(st.tcx, parse_mt(st, sd)); }\n-        case ('V') { ret ty::mk_vec(st.tcx, parse_mt(st, sd)); }\n-        case ('I') { ret ty::mk_ivec(st.tcx, parse_mt(st, sd)); }\n-        case ('a') { ret ty::mk_task(st.tcx); }\n-        case ('P') { ret ty::mk_port(st.tcx, parse_ty(st, sd)); }\n-        case ('C') { ret ty::mk_chan(st.tcx, parse_ty(st, sd)); }\n-        case ('T') {\n-            assert (next(st) as char == '[');\n-            let vec[ty::mt] params = [];\n-            while (peek(st) as char != ']') { params += [parse_mt(st, sd)]; }\n-            st.pos = st.pos + 1u;\n-            ret ty::mk_tup(st.tcx, params);\n-        }\n-        case ('R') {\n-            assert (next(st) as char == '[');\n-            let vec[ty::field] fields = [];\n-            while (peek(st) as char != ']') {\n-                auto name = \"\";\n-                while (peek(st) as char != '=') {\n-                    name += str::unsafe_from_byte(next(st));\n-                }\n-                st.pos = st.pos + 1u;\n-                fields += [rec(ident=name, mt=parse_mt(st, sd))];\n-            }\n-            st.pos = st.pos + 1u;\n-            ret ty::mk_rec(st.tcx, fields);\n-        }\n-        case ('F') {\n-            auto func = parse_ty_fn(st, sd);\n-            ret ty::mk_fn(st.tcx, ast::proto_fn, func._0, func._1, func._2,\n-                          func._3);\n-        }\n-        case ('W') {\n-            auto func = parse_ty_fn(st, sd);\n-            ret ty::mk_fn(st.tcx, ast::proto_iter, func._0, func._1, func._2,\n-                          func._3);\n-        }\n-        case ('N') {\n-            auto abi;\n-            alt (next(st) as char) {\n-                case ('r') { abi = ast::native_abi_rust; }\n-                case ('i') { abi = ast::native_abi_rust_intrinsic; }\n-                case ('c') { abi = ast::native_abi_cdecl; }\n-                case ('l') { abi = ast::native_abi_llvm; }\n-            }\n-            auto func = parse_ty_fn(st, sd);\n-            ret ty::mk_native_fn(st.tcx, abi, func._0, func._1);\n-        }\n-        case ('O') {\n-            assert (next(st) as char == '[');\n-            let vec[ty::method] methods = [];\n-            while (peek(st) as char != ']') {\n-                auto proto;\n-                alt (next(st) as char) {\n-                    case ('W') { proto = ast::proto_iter; }\n-                    case ('F') { proto = ast::proto_fn; }\n-                }\n-                auto name = \"\";\n-                while (peek(st) as char != '[') {\n-                    name += str::unsafe_from_byte(next(st));\n-                }\n-                auto func = parse_ty_fn(st, sd);\n-                methods +=\n-                    [rec(proto=proto,\n-                         ident=name,\n-                         inputs=func._0,\n-                         output=func._1,\n-                         cf=func._2,\n-                         constrs=func._3)];\n-            }\n-            st.pos += 1u;\n-            ret ty::mk_obj(st.tcx, methods);\n-        }\n-        case ('r') {\n-            auto def = parse_def(st, sd);\n-            auto inner = parse_ty(st, sd);\n-            ret ty::mk_res(st.tcx, def, inner);\n-        }\n-        case ('X') { ret ty::mk_var(st.tcx, parse_int(st)); }\n-        case ('E') { ret ty::mk_native(st.tcx); }\n-        case ('Y') { ret ty::mk_type(st.tcx); }\n-        case ('#') {\n-            auto pos = parse_hex(st);\n-            assert (next(st) as char == ':');\n-            auto len = parse_hex(st);\n-            assert (next(st) as char == '#');\n-            alt (st.tcx.rcache.find(tup(st.crate, pos, len))) {\n-                case (some(?tt)) { ret tt; }\n-                case (none) {\n-                    auto ps = @rec(pos=pos, len=len with *st);\n-                    auto tt = parse_ty(ps, sd);\n-                    st.tcx.rcache.insert(tup(st.crate, pos, len), tt);\n-                    ret tt;\n-                }\n-            }\n-        }\n-        case (?c) {\n-            log_err \"unexpected char in type string: \";\n-            log_err c;\n-            fail;\n-        }\n-    }\n-}\n-\n-fn parse_mt(@pstate st, str_def sd) -> ty::mt {\n-    auto mut;\n-    alt (peek(st) as char) {\n-        case ('m') { next(st); mut = ast::mut; }\n-        case ('?') { next(st); mut = ast::maybe_mut; }\n-        case (_) { mut = ast::imm; }\n-    }\n-    ret rec(ty=parse_ty(st, sd), mut=mut);\n-}\n-\n-fn parse_def(@pstate st, str_def sd) -> ast::def_id {\n-    auto def = \"\";\n-    while (peek(st) as char != '|') {\n-        def += str::unsafe_from_byte(next(st));\n-    }\n-    st.pos = st.pos + 1u;\n-    ret sd(def);\n-}\n-\n-fn parse_int(@pstate st) -> int {\n-    auto n = 0;\n-    while (true) {\n-        auto cur = peek(st) as char;\n-        if (cur < '0' || cur > '9') { break; }\n-        st.pos = st.pos + 1u;\n-        n *= 10;\n-        n += (cur as int) - ('0' as int);\n-    }\n-    ret n;\n-}\n-\n-fn parse_hex(@pstate st) -> uint {\n-    auto n = 0u;\n-    while (true) {\n-        auto cur = peek(st) as char;\n-        if ((cur < '0' || cur > '9') && (cur < 'a' || cur > 'f')) { break; }\n-        st.pos = st.pos + 1u;\n-        n *= 16u;\n-        if ('0' <= cur && cur <= '9') {\n-            n += (cur as uint) - ('0' as uint);\n-        } else { n += 10u + (cur as uint) - ('a' as uint); }\n-    }\n-    ret n;\n-}\n-\n-fn parse_ty_fn(@pstate st, str_def sd) ->\n-   tup(vec[ty::arg], ty::t, ast::controlflow, vec[@ty::constr_def]) {\n-    assert (next(st) as char == '[');\n-    let vec[ty::arg] inputs = [];\n-    while (peek(st) as char != ']') {\n-        auto mode = ty::mo_val;\n-        if (peek(st) as char == '&') {\n-            mode = ty::mo_alias(false);\n-            st.pos += 1u;\n-            if (peek(st) as char == 'm') {\n-                mode = ty::mo_alias(true);\n-                st.pos += 1u;\n-            }\n-        }\n-        inputs += [rec(mode=mode, ty=parse_ty(st, sd))];\n-    }\n-    st.pos += 1u; // eat the ']'\n-    auto cs = parse_constrs(st, sd);\n-    alt (parse_ty_or_bang(st, sd)) {\n-        case (a_bang) {\n-            ret tup(inputs, ty::mk_bot(st.tcx), ast::noreturn, cs);\n-        }\n-        case (a_ty(?t)) { ret tup(inputs, t, ast::return, cs); }\n-    }\n-}\n-\n-\n-// Rust metadata parsing\n-fn parse_def_id(vec[u8] buf) -> ast::def_id {\n-    auto colon_idx = 0u;\n-    auto len = vec::len[u8](buf);\n-    while (colon_idx < len && buf.(colon_idx) != ':' as u8) {\n-        colon_idx += 1u;\n-    }\n-    if (colon_idx == len) {\n-        log_err \"didn't find ':' when parsing def id\";\n-        fail;\n-    }\n-    auto crate_part = vec::slice[u8](buf, 0u, colon_idx);\n-    auto def_part = vec::slice[u8](buf, colon_idx + 1u, len);\n-    auto crate_num = uint::parse_buf(crate_part, 10u) as int;\n-    auto def_id = uint::parse_buf(def_part, 10u) as int;\n-    ret tup(crate_num, def_id);\n-}\n \n fn lookup_hash(&ebml::doc d, fn(vec[u8]) -> bool  eq_fn, uint hash) ->\n    vec[ebml::doc] {\n@@ -516,26 +151,6 @@ fn tag_variant_ids(&ebml::doc item, int this_cnum) -> vec[ast::def_id] {\n     ret ids;\n }\n \n-fn get_metadata_section(str filename) -> option::t[vec[u8]] {\n-    auto b = str::buf(filename);\n-    auto mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(b);\n-    if (mb as int == 0) { ret option::none[vec[u8]]; }\n-    auto of = mk_object_file(mb);\n-    auto si = mk_section_iter(of.llof);\n-    while (llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False) {\n-        auto name_buf = llvm::LLVMGetSectionName(si.llsi);\n-        auto name = str::str_from_cstr(name_buf);\n-        if (str::eq(name, x86::get_meta_sect_name())) {\n-            auto cbuf = llvm::LLVMGetSectionContents(si.llsi);\n-            auto csz = llvm::LLVMGetSectionSize(si.llsi);\n-            auto cvbuf = cbuf as vec::vbuf;\n-            ret option::some[vec[u8]](vec::vec_from_vbuf[u8](cvbuf, csz));\n-        }\n-        llvm::LLVMMoveToNextSection(si.llsi);\n-    }\n-    ret option::none[vec[u8]];\n-}\n-\n fn get_exported_metadata(&session::session sess, &str path, &vec[u8] data) ->\n    hashmap[str, str] {\n     auto meta_items =\n@@ -653,6 +268,26 @@ fn find_library_crate(&session::session sess, &ast::ident ident,\n     ret none;\n }\n \n+fn get_metadata_section(str filename) -> option::t[vec[u8]] {\n+    auto b = str::buf(filename);\n+    auto mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(b);\n+    if (mb as int == 0) { ret option::none[vec[u8]]; }\n+    auto of = mk_object_file(mb);\n+    auto si = mk_section_iter(of.llof);\n+    while (llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False) {\n+        auto name_buf = llvm::LLVMGetSectionName(si.llsi);\n+        auto name = str::str_from_cstr(name_buf);\n+        if (str::eq(name, x86::get_meta_sect_name())) {\n+            auto cbuf = llvm::LLVMGetSectionContents(si.llsi);\n+            auto csz = llvm::LLVMGetSectionSize(si.llsi);\n+            auto cvbuf = cbuf as vec::vbuf;\n+            ret option::some[vec[u8]](vec::vec_from_vbuf[u8](cvbuf, csz));\n+        }\n+        llvm::LLVMMoveToNextSection(si.llsi);\n+    }\n+    ret option::none[vec[u8]];\n+}\n+\n fn load_library_crate(&session::session sess, int cnum, &ast::ident ident,\n                       &vec[@ast::meta_item] metas,\n                       &vec[str] library_search_paths) {"}, {"sha": "2627459e2972a125386a41e5a4af1be21923fa13", "filename": "src/comp/metadata/tydecode.rs", "status": "added", "additions": 377, "deletions": 0, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/a3a2cc3d9851aef277df40c5f53998ec72181686/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a2cc3d9851aef277df40c5f53998ec72181686/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=a3a2cc3d9851aef277df40c5f53998ec72181686", "patch": "@@ -0,0 +1,377 @@\n+// Type decoding\n+import std::str;\n+import std::vec;\n+import std::uint;\n+import std::option;\n+import std::option::none;\n+import std::option::some;\n+import front::ast;\n+import middle::ty;\n+import util::common;\n+import util::common::respan;\n+import util::common::a_ty;\n+import util::common::a_bang;\n+\n+export parse_def_id;\n+export parse_ty_data;\n+\n+// Compact string representation for ty::t values. API ty_str & parse_from_str\n+// (The second has to be authed pure.) Extra parameters are for converting\n+// to/from def_ids in the data buffer. Whatever format you choose should not\n+// contain pipe characters.\n+\n+// Callback to translate defs to strs or back:\n+type str_def = fn(str) -> ast::def_id ;\n+\n+type pstate =\n+    rec(vec[u8] data, int crate, mutable uint pos, uint len, ty::ctxt tcx);\n+\n+type ty_or_bang = util::common::ty_or_bang[ty::t];\n+\n+fn peek(@pstate st) -> u8 { ret st.data.(st.pos); }\n+\n+fn next(@pstate st) -> u8 {\n+    auto ch = st.data.(st.pos);\n+    st.pos = st.pos + 1u;\n+    ret ch;\n+}\n+\n+fn parse_ident(@pstate st, str_def sd, char last) -> ast::ident {\n+    fn is_last(char b, char c) -> bool {\n+        ret c == b;\n+    }\n+    ret parse_ident_(st, sd, bind is_last(last, _));\n+}\n+\n+fn parse_ident_(@pstate st, str_def sd, fn(char) -> bool is_last)\n+    -> ast::ident {\n+    auto rslt = \"\";\n+    while (! is_last(peek(st) as char)) {\n+        rslt += str::unsafe_from_byte(next(st));\n+    }\n+    ret rslt;\n+}\n+\n+\n+fn parse_ty_data(vec[u8] data, int crate_num, uint pos, uint len, str_def sd,\n+                 ty::ctxt tcx) -> ty::t {\n+    auto st =\n+        @rec(data=data, crate=crate_num, mutable pos=pos, len=len, tcx=tcx);\n+    auto result = parse_ty(st, sd);\n+    ret result;\n+}\n+\n+fn parse_ty_or_bang(@pstate st, str_def sd) -> ty_or_bang {\n+    alt (peek(st) as char) {\n+        case ('!') { auto ignore = next(st); ret a_bang[ty::t]; }\n+        case (_) { ret a_ty[ty::t](parse_ty(st, sd)); }\n+    }\n+}\n+\n+fn parse_constrs(@pstate st, str_def sd) -> vec[@ty::constr_def] {\n+    let vec[@ty::constr_def] rslt = [];\n+    alt (peek(st) as char) {\n+        case (':') {\n+            do  {\n+                auto ignore = next(st);\n+                vec::push(rslt, parse_constr(st, sd));\n+            } while (peek(st) as char == ';')\n+        }\n+        case (_) { }\n+    }\n+    ret rslt;\n+}\n+\n+fn parse_path(@pstate st, str_def sd) -> ast::path {\n+    let vec[ast::ident] idents = [];\n+    fn is_last(char c) -> bool {\n+        ret (c == '(' || c == ':');\n+    }\n+    idents += [parse_ident_(st, sd, is_last)];\n+    while (true) {\n+        alt (peek(st) as char) {\n+            case (':') {\n+                auto ignore = next(st);\n+                ignore = next(st);\n+            }\n+            case (?c) {\n+                if (c == '(') {\n+                    ret respan(rec(lo=0u, hi=0u),\n+                               rec(idents=idents, types=[]));\n+                }\n+                else {\n+                    idents += [parse_ident_(st, sd, is_last)];\n+                }\n+            }\n+        }\n+    }\n+    fail \"parse_path: ill-formed path\";\n+}\n+\n+fn parse_constr(@pstate st, str_def sd) -> @ty::constr_def {\n+    let vec[@ast::constr_arg] args = [];\n+    auto sp = rec(lo=0u,hi=0u); // FIXME: use a real span\n+    let ast::path pth = parse_path(st, sd);\n+    let char ignore = next(st) as char;\n+    assert(ignore as char == '(');\n+    auto def = parse_def(st, sd);\n+    do {\n+        alt (peek(st) as char) {\n+            case ('*') {\n+                st.pos += 1u;\n+                args += [@respan(sp, ast::carg_base)];\n+            }\n+            case (?c) {\n+                /* how will we disambiguate between\n+                 an arg index and a lit argument? */\n+                if (c >= '0' && c <= '9') {\n+                    // FIXME\n+                    args += [@respan(sp, ast::carg_ident((c as uint) - 48u))];\n+                    ignore = next(st) as char;\n+                }\n+                else {\n+                    log_err(\"Lit args are unimplemented\");\n+                    fail; // FIXME\n+                }\n+                /*\n+                else {\n+                    auto lit = parse_lit(st, sd, ',');\n+                    args += [respan(st.span, ast::carg_lit(lit))];\n+                }\n+                */\n+            }\n+        }\n+        ignore = next(st) as char;\n+    } while (ignore == ';');\n+    assert(ignore == ')');\n+    ret @respan(sp, rec(path=pth, args=args, id=def));\n+}\n+\n+fn parse_ty(@pstate st, str_def sd) -> ty::t {\n+    alt (next(st) as char) {\n+        case ('n') { ret ty::mk_nil(st.tcx); }\n+        case ('z') { ret ty::mk_bot(st.tcx); }\n+        case ('b') { ret ty::mk_bool(st.tcx); }\n+        case ('i') { ret ty::mk_int(st.tcx); }\n+        case ('u') { ret ty::mk_uint(st.tcx); }\n+        case ('l') { ret ty::mk_float(st.tcx); }\n+        case ('M') {\n+            alt (next(st) as char) {\n+                case ('b') { ret ty::mk_mach(st.tcx, common::ty_u8); }\n+                case ('w') { ret ty::mk_mach(st.tcx, common::ty_u16); }\n+                case ('l') { ret ty::mk_mach(st.tcx, common::ty_u32); }\n+                case ('d') { ret ty::mk_mach(st.tcx, common::ty_u64); }\n+                case ('B') { ret ty::mk_mach(st.tcx, common::ty_i8); }\n+                case ('W') { ret ty::mk_mach(st.tcx, common::ty_i16); }\n+                case ('L') { ret ty::mk_mach(st.tcx, common::ty_i32); }\n+                case ('D') { ret ty::mk_mach(st.tcx, common::ty_i64); }\n+                case ('f') { ret ty::mk_mach(st.tcx, common::ty_f32); }\n+                case ('F') { ret ty::mk_mach(st.tcx, common::ty_f64); }\n+            }\n+        }\n+        case ('c') { ret ty::mk_char(st.tcx); }\n+        case ('s') { ret ty::mk_str(st.tcx); }\n+        case ('S') { ret ty::mk_istr(st.tcx); }\n+        case ('t') {\n+            assert (next(st) as char == '[');\n+            auto def = parse_def(st, sd);\n+            let vec[ty::t] params = [];\n+            while (peek(st) as char != ']') { params += [parse_ty(st, sd)]; }\n+            st.pos = st.pos + 1u;\n+            ret ty::mk_tag(st.tcx, def, params);\n+        }\n+        case ('p') { ret ty::mk_param(st.tcx, parse_int(st) as uint); }\n+        case ('@') { ret ty::mk_box(st.tcx, parse_mt(st, sd)); }\n+        case ('*') { ret ty::mk_ptr(st.tcx, parse_mt(st, sd)); }\n+        case ('V') { ret ty::mk_vec(st.tcx, parse_mt(st, sd)); }\n+        case ('I') { ret ty::mk_ivec(st.tcx, parse_mt(st, sd)); }\n+        case ('a') { ret ty::mk_task(st.tcx); }\n+        case ('P') { ret ty::mk_port(st.tcx, parse_ty(st, sd)); }\n+        case ('C') { ret ty::mk_chan(st.tcx, parse_ty(st, sd)); }\n+        case ('T') {\n+            assert (next(st) as char == '[');\n+            let vec[ty::mt] params = [];\n+            while (peek(st) as char != ']') { params += [parse_mt(st, sd)]; }\n+            st.pos = st.pos + 1u;\n+            ret ty::mk_tup(st.tcx, params);\n+        }\n+        case ('R') {\n+            assert (next(st) as char == '[');\n+            let vec[ty::field] fields = [];\n+            while (peek(st) as char != ']') {\n+                auto name = \"\";\n+                while (peek(st) as char != '=') {\n+                    name += str::unsafe_from_byte(next(st));\n+                }\n+                st.pos = st.pos + 1u;\n+                fields += [rec(ident=name, mt=parse_mt(st, sd))];\n+            }\n+            st.pos = st.pos + 1u;\n+            ret ty::mk_rec(st.tcx, fields);\n+        }\n+        case ('F') {\n+            auto func = parse_ty_fn(st, sd);\n+            ret ty::mk_fn(st.tcx, ast::proto_fn, func._0, func._1, func._2,\n+                          func._3);\n+        }\n+        case ('W') {\n+            auto func = parse_ty_fn(st, sd);\n+            ret ty::mk_fn(st.tcx, ast::proto_iter, func._0, func._1, func._2,\n+                          func._3);\n+        }\n+        case ('N') {\n+            auto abi;\n+            alt (next(st) as char) {\n+                case ('r') { abi = ast::native_abi_rust; }\n+                case ('i') { abi = ast::native_abi_rust_intrinsic; }\n+                case ('c') { abi = ast::native_abi_cdecl; }\n+                case ('l') { abi = ast::native_abi_llvm; }\n+            }\n+            auto func = parse_ty_fn(st, sd);\n+            ret ty::mk_native_fn(st.tcx, abi, func._0, func._1);\n+        }\n+        case ('O') {\n+            assert (next(st) as char == '[');\n+            let vec[ty::method] methods = [];\n+            while (peek(st) as char != ']') {\n+                auto proto;\n+                alt (next(st) as char) {\n+                    case ('W') { proto = ast::proto_iter; }\n+                    case ('F') { proto = ast::proto_fn; }\n+                }\n+                auto name = \"\";\n+                while (peek(st) as char != '[') {\n+                    name += str::unsafe_from_byte(next(st));\n+                }\n+                auto func = parse_ty_fn(st, sd);\n+                methods +=\n+                    [rec(proto=proto,\n+                         ident=name,\n+                         inputs=func._0,\n+                         output=func._1,\n+                         cf=func._2,\n+                         constrs=func._3)];\n+            }\n+            st.pos += 1u;\n+            ret ty::mk_obj(st.tcx, methods);\n+        }\n+        case ('r') {\n+            auto def = parse_def(st, sd);\n+            auto inner = parse_ty(st, sd);\n+            ret ty::mk_res(st.tcx, def, inner);\n+        }\n+        case ('X') { ret ty::mk_var(st.tcx, parse_int(st)); }\n+        case ('E') { ret ty::mk_native(st.tcx); }\n+        case ('Y') { ret ty::mk_type(st.tcx); }\n+        case ('#') {\n+            auto pos = parse_hex(st);\n+            assert (next(st) as char == ':');\n+            auto len = parse_hex(st);\n+            assert (next(st) as char == '#');\n+            alt (st.tcx.rcache.find(tup(st.crate, pos, len))) {\n+                case (some(?tt)) { ret tt; }\n+                case (none) {\n+                    auto ps = @rec(pos=pos, len=len with *st);\n+                    auto tt = parse_ty(ps, sd);\n+                    st.tcx.rcache.insert(tup(st.crate, pos, len), tt);\n+                    ret tt;\n+                }\n+            }\n+        }\n+        case (?c) {\n+            log_err \"unexpected char in type string: \";\n+            log_err c;\n+            fail;\n+        }\n+    }\n+}\n+\n+fn parse_mt(@pstate st, str_def sd) -> ty::mt {\n+    auto mut;\n+    alt (peek(st) as char) {\n+        case ('m') { next(st); mut = ast::mut; }\n+        case ('?') { next(st); mut = ast::maybe_mut; }\n+        case (_) { mut = ast::imm; }\n+    }\n+    ret rec(ty=parse_ty(st, sd), mut=mut);\n+}\n+\n+fn parse_def(@pstate st, str_def sd) -> ast::def_id {\n+    auto def = \"\";\n+    while (peek(st) as char != '|') {\n+        def += str::unsafe_from_byte(next(st));\n+    }\n+    st.pos = st.pos + 1u;\n+    ret sd(def);\n+}\n+\n+fn parse_int(@pstate st) -> int {\n+    auto n = 0;\n+    while (true) {\n+        auto cur = peek(st) as char;\n+        if (cur < '0' || cur > '9') { break; }\n+        st.pos = st.pos + 1u;\n+        n *= 10;\n+        n += (cur as int) - ('0' as int);\n+    }\n+    ret n;\n+}\n+\n+fn parse_hex(@pstate st) -> uint {\n+    auto n = 0u;\n+    while (true) {\n+        auto cur = peek(st) as char;\n+        if ((cur < '0' || cur > '9') && (cur < 'a' || cur > 'f')) { break; }\n+        st.pos = st.pos + 1u;\n+        n *= 16u;\n+        if ('0' <= cur && cur <= '9') {\n+            n += (cur as uint) - ('0' as uint);\n+        } else { n += 10u + (cur as uint) - ('a' as uint); }\n+    }\n+    ret n;\n+}\n+\n+fn parse_ty_fn(@pstate st, str_def sd) ->\n+   tup(vec[ty::arg], ty::t, ast::controlflow, vec[@ty::constr_def]) {\n+    assert (next(st) as char == '[');\n+    let vec[ty::arg] inputs = [];\n+    while (peek(st) as char != ']') {\n+        auto mode = ty::mo_val;\n+        if (peek(st) as char == '&') {\n+            mode = ty::mo_alias(false);\n+            st.pos += 1u;\n+            if (peek(st) as char == 'm') {\n+                mode = ty::mo_alias(true);\n+                st.pos += 1u;\n+            }\n+        }\n+        inputs += [rec(mode=mode, ty=parse_ty(st, sd))];\n+    }\n+    st.pos += 1u; // eat the ']'\n+    auto cs = parse_constrs(st, sd);\n+    alt (parse_ty_or_bang(st, sd)) {\n+        case (a_bang) {\n+            ret tup(inputs, ty::mk_bot(st.tcx), ast::noreturn, cs);\n+        }\n+        case (a_ty(?t)) { ret tup(inputs, t, ast::return, cs); }\n+    }\n+}\n+\n+\n+// Rust metadata parsing\n+fn parse_def_id(vec[u8] buf) -> ast::def_id {\n+    auto colon_idx = 0u;\n+    auto len = vec::len[u8](buf);\n+    while (colon_idx < len && buf.(colon_idx) != ':' as u8) {\n+        colon_idx += 1u;\n+    }\n+    if (colon_idx == len) {\n+        log_err \"didn't find ':' when parsing def id\";\n+        fail;\n+    }\n+    auto crate_part = vec::slice[u8](buf, 0u, colon_idx);\n+    auto def_part = vec::slice[u8](buf, colon_idx + 1u, len);\n+    auto crate_num = uint::parse_buf(crate_part, 10u) as int;\n+    auto def_id = uint::parse_buf(def_part, 10u) as int;\n+    ret tup(crate_num, def_id);\n+}"}, {"sha": "f00dd877ebf8e0546efc738ee4a5a84b0c58d0cb", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3a2cc3d9851aef277df40c5f53998ec72181686/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a3a2cc3d9851aef277df40c5f53998ec72181686/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=a3a2cc3d9851aef277df40c5f53998ec72181686", "patch": "@@ -65,6 +65,7 @@ mod back {\n mod metadata {\n     mod defs;\n     mod tyencode;\n+    mod tydecode;\n     mod encoder;\n     mod creader;\n     mod cwriter;"}]}