{"sha": "03b0d995564b26a2ca9ccf0ded8a6fd375dd9412", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzYjBkOTk1NTY0YjI2YTJjYTljY2YwZGVkOGE2ZmQzNzVkZDk0MTI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-04-13T18:27:35Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-04-13T18:27:35Z"}, "message": "rustc_typeck: consolidate adjustment composition\n\nFixes #41213.", "tree": {"sha": "ad8a51481ca98745321b8e0fa2b9dd6c199b340f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad8a51481ca98745321b8e0fa2b9dd6c199b340f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03b0d995564b26a2ca9ccf0ded8a6fd375dd9412", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03b0d995564b26a2ca9ccf0ded8a6fd375dd9412", "html_url": "https://github.com/rust-lang/rust/commit/03b0d995564b26a2ca9ccf0ded8a6fd375dd9412", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03b0d995564b26a2ca9ccf0ded8a6fd375dd9412/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c58c928e658d2e45f816fd05796a964aa83759da", "url": "https://api.github.com/repos/rust-lang/rust/commits/c58c928e658d2e45f816fd05796a964aa83759da", "html_url": "https://github.com/rust-lang/rust/commit/c58c928e658d2e45f816fd05796a964aa83759da"}], "stats": {"total": 139, "additions": 92, "deletions": 47}, "files": [{"sha": "1d7100a7a4e445d9e3bace044c2fa3fc93ea4488", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03b0d995564b26a2ca9ccf0ded8a6fd375dd9412/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b0d995564b26a2ca9ccf0ded8a6fd375dd9412/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=03b0d995564b26a2ca9ccf0ded8a6fd375dd9412", "patch": "@@ -33,7 +33,7 @@ pub enum Adjust<'tcx> {\n     /// Go from a safe fn pointer to an unsafe fn pointer.\n     UnsafeFnPointer,\n \n-    // Go from a non-capturing closure to an fn pointer.\n+    /// Go from a non-capturing closure to an fn pointer.\n     ClosureFnPointer,\n \n     /// Go from a mut raw pointer to a const raw pointer."}, {"sha": "9c5870c12aad450d5da70494c16e8ecb573d8fca", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03b0d995564b26a2ca9ccf0ded8a6fd375dd9412/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b0d995564b26a2ca9ccf0ded8a6fd375dd9412/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=03b0d995564b26a2ca9ccf0ded8a6fd375dd9412", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // If the callee is a bare function or a closure, then we're all set.\n         match self.structurally_resolved_type(callee_expr.span, adjusted_ty).sty {\n             ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n-                self.write_autoderef_adjustment(callee_expr.id, autoderefs, adjusted_ty);\n+                self.apply_autoderef_adjustment(callee_expr.id, autoderefs, adjusted_ty);\n                 return Some(CallStep::Builtin);\n             }\n "}, {"sha": "de7a579ba10eda439ea9542afef92523129b679f", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 11, "deletions": 27, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/03b0d995564b26a2ca9ccf0ded8a6fd375dd9412/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b0d995564b26a2ca9ccf0ded8a6fd375dd9412/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=03b0d995564b26a2ca9ccf0ded8a6fd375dd9412", "patch": "@@ -712,13 +712,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.commit_if_ok(|_| {\n             let ok = coerce.coerce(&[expr], source, target)?;\n             let adjustment = self.register_infer_ok_obligations(ok);\n-            if !adjustment.is_identity() {\n-                debug!(\"Success, coerced with {:?}\", adjustment);\n-                if self.tables.borrow().adjustments.get(&expr.id).is_some() {\n-                    bug!(\"expr already has an adjustment on it!\");\n-                }\n-                self.write_adjustment(expr.id, adjustment);\n-            }\n+            self.apply_adjustment(expr.id, adjustment);\n \n             // We should now have added sufficient adjustments etc to\n             // ensure that the type of expression, post-adjustment, is\n@@ -780,9 +774,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // Reify both sides and return the reified fn pointer type.\n                 let fn_ptr = self.tcx.mk_fn_ptr(fty);\n                 for expr in exprs.iter().map(|e| e.as_coercion_site()).chain(Some(new)) {\n-                    // No adjustments can produce a fn item, so this should never trip.\n-                    assert!(!self.tables.borrow().adjustments.contains_key(&expr.id));\n-                    self.write_adjustment(expr.id, Adjustment {\n+                    // The only adjustment that can produce an fn item is\n+                    // `NeverToAny`, so this should always be valid.\n+                    self.apply_adjustment(expr.id, Adjustment {\n                         kind: Adjust::ReifyFnPointer,\n                         target: fn_ptr\n                     });\n@@ -803,9 +797,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             match result {\n                 Ok(ok) => {\n                     let adjustment = self.register_infer_ok_obligations(ok);\n-                    if !adjustment.is_identity() {\n-                        self.write_adjustment(new.id, adjustment);\n-                    }\n+                    self.apply_adjustment(new.id, adjustment);\n                     return Ok(adjustment.target);\n                 }\n                 Err(e) => first_error = Some(e),\n@@ -825,7 +817,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }) => {\n                     match self.node_ty(expr.id).sty {\n                         ty::TyRef(_, mt_orig) => {\n-                            // Reborrow that we can safely ignore.\n+                            // Reborrow that we can safely ignore, because\n+                            // the next adjustment can only be a DerefRef\n+                            // which will be merged into it.\n                             mutbl_adj == mt_orig.mutbl\n                         }\n                         _ => false,\n@@ -858,19 +852,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n             Ok(ok) => {\n                 let adjustment = self.register_infer_ok_obligations(ok);\n-                if !adjustment.is_identity() {\n-                    let mut tables = self.tables.borrow_mut();\n-                    for expr in exprs {\n-                        let expr = expr.as_coercion_site();\n-                        if let Some(&mut Adjustment {\n-                            kind: Adjust::NeverToAny,\n-                            ref mut target\n-                        }) = tables.adjustments.get_mut(&expr.id) {\n-                            *target = adjustment.target;\n-                            continue;\n-                        }\n-                        tables.adjustments.insert(expr.id, adjustment);\n-                    }\n+                for expr in exprs {\n+                    let expr = expr.as_coercion_site();\n+                    self.apply_adjustment(expr.id, adjustment);\n                 }\n                 Ok(adjustment.target)\n             }"}, {"sha": "28ac335cf195a12a29da60f5f62baefafd6513a9", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/03b0d995564b26a2ca9ccf0ded8a6fd375dd9412/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b0d995564b26a2ca9ccf0ded8a6fd375dd9412/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=03b0d995564b26a2ca9ccf0ded8a6fd375dd9412", "patch": "@@ -143,7 +143,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         let target = target.adjust_for_autoref(self.tcx, autoref);\n \n         // Write out the final adjustment.\n-        self.write_adjustment(self.self_expr.id, Adjustment {\n+        self.apply_adjustment(self.self_expr.id, Adjustment {\n             kind: Adjust::DerefRef {\n                 autoderefs: pick.autoderefs,\n                 autoref: autoref,\n@@ -433,7 +433,8 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         for (i, &expr) in exprs.iter().rev().enumerate() {\n             debug!(\"convert_lvalue_derefs_to_mutable: i={} expr={:?}\", i, expr);\n \n-            // Count autoderefs.\n+            // Count autoderefs. We don't need to fix up the autoref - the parent\n+            // expression will fix them up for us.\n             let adjustment = self.tables.borrow().adjustments.get(&expr.id).cloned();\n             match adjustment {\n                 Some(Adjustment { kind: Adjust::DerefRef { autoderefs, .. }, .. }) => {\n@@ -464,7 +465,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                     // expects. This is annoying and horrible. We\n                     // ought to recode this routine so it doesn't\n                     // (ab)use the normal type checking paths.\n-                    let adj = self.tables.borrow().adjustments.get(&base_expr.id).cloned();\n+                    let adj = self.tables.borrow_mut().adjustments.remove(&base_expr.id);\n                     let (autoderefs, unsize, adjusted_base_ty) = match adj {\n                         Some(Adjustment {\n                             kind: Adjust::DerefRef { autoderefs, autoref, unsize },\n@@ -537,6 +538,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                     // a preference for mut\n                     let method_call = ty::MethodCall::expr(expr.id);\n                     if self.tables.borrow().method_map.contains_key(&method_call) {\n+                        self.tables.borrow_mut().adjustments.remove(&base_expr.id);\n                         let method = self.try_overloaded_deref(expr.span,\n                                                                Some(&base_expr),\n                                                                self.node_ty(base_expr.id),"}, {"sha": "9ecf0ffa71ebd65500ff8a3dc70744b6214efddc", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03b0d995564b26a2ca9ccf0ded8a6fd375dd9412/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b0d995564b26a2ca9ccf0ded8a6fd375dd9412/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=03b0d995564b26a2ca9ccf0ded8a6fd375dd9412", "patch": "@@ -299,7 +299,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             };\n \n-            self.write_adjustment(self_expr.id, Adjustment {\n+            self.apply_adjustment(self_expr.id, Adjustment {\n                 kind: Adjust::DerefRef {\n                     autoderefs: autoderefs,\n                     autoref: autoref,"}, {"sha": "dc221a93f134289c65722e10d1c58e2f556f4e38", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 41, "deletions": 14, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/03b0d995564b26a2ca9ccf0ded8a6fd375dd9412/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b0d995564b26a2ca9ccf0ded8a6fd375dd9412/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=03b0d995564b26a2ca9ccf0ded8a6fd375dd9412", "patch": "@@ -95,7 +95,7 @@ use rustc::ty::{ParamTy, ParameterEnvironment};\n use rustc::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n use rustc::ty::{self, Ty, TyCtxt, Visibility};\n use rustc::ty::{MethodCall, MethodCallee};\n-use rustc::ty::adjustment;\n+use rustc::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n use rustc::ty::fold::{BottomUpFolder, TypeFoldable};\n use rustc::ty::maps::Providers;\n use rustc::ty::util::{Representability, IntTypeExt};\n@@ -108,6 +108,7 @@ use util::common::{ErrorReported, indenter};\n use util::nodemap::{DefIdMap, FxHashMap, FxHashSet, NodeMap};\n \n use std::cell::{Cell, RefCell};\n+use std::collections::hash_map::Entry;\n use std::cmp;\n use std::mem::replace;\n use std::ops::{self, Deref};\n@@ -1637,12 +1638,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn write_autoderef_adjustment(&self,\n+    pub fn apply_autoderef_adjustment(&self,\n                                       node_id: ast::NodeId,\n                                       derefs: usize,\n                                       adjusted_ty: Ty<'tcx>) {\n-        self.write_adjustment(node_id, adjustment::Adjustment {\n-            kind: adjustment::Adjust::DerefRef {\n+        self.apply_adjustment(node_id, Adjustment {\n+            kind: Adjust::DerefRef {\n                 autoderefs: derefs,\n                 autoref: None,\n                 unsize: false\n@@ -1651,16 +1652,42 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         });\n     }\n \n-    pub fn write_adjustment(&self,\n-                            node_id: ast::NodeId,\n-                            adj: adjustment::Adjustment<'tcx>) {\n-        debug!(\"write_adjustment(node_id={}, adj={:?})\", node_id, adj);\n+    pub fn apply_adjustment(&self, node_id: ast::NodeId, adj: Adjustment<'tcx>) {\n+        debug!(\"apply_adjustment(node_id={}, adj={:?})\", node_id, adj);\n \n         if adj.is_identity() {\n             return;\n         }\n \n-        self.tables.borrow_mut().adjustments.insert(node_id, adj);\n+        match self.tables.borrow_mut().adjustments.entry(node_id) {\n+            Entry::Vacant(entry) => { entry.insert(adj); },\n+            Entry::Occupied(mut entry) => {\n+                debug!(\" - composing on top of {:?}\", entry.get());\n+                let composed_kind = match (entry.get().kind, adj.kind) {\n+                    // Applying any adjustment on top of a NeverToAny\n+                    // is a valid NeverToAny adjustment, because it can't\n+                    // be reached.\n+                    (Adjust::NeverToAny, _) => Adjust::NeverToAny,\n+                    (Adjust::DerefRef {\n+                        autoderefs: 1,\n+                        autoref: Some(AutoBorrow::Ref(..)),\n+                        unsize: false\n+                    }, Adjust::DerefRef { autoderefs, .. }) if autoderefs > 0 => {\n+                        // A reborrow has no effect before a dereference.\n+                        adj.kind\n+                    }\n+                    // FIXME: currently we never try to compose autoderefs\n+                    // and ReifyFnPointer/UnsafeFnPointer, but we could.\n+                    _ =>\n+                        bug!(\"while adjusting {}, can't compose {:?} and {:?}\",\n+                             node_id, entry.get(), adj)\n+                };\n+                *entry.get_mut() = Adjustment {\n+                    kind: composed_kind,\n+                    target: adj.target\n+                };\n+            }\n+        }\n     }\n \n     /// Basically whenever we are converting from a type scheme into\n@@ -2302,7 +2329,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 debug!(\"try_index_step: success, using built-in indexing\");\n                 // If we had `[T; N]`, we should've caught it before unsizing to `[T]`.\n                 assert!(!unsize);\n-                self.write_autoderef_adjustment(base_expr.id, autoderefs, adjusted_ty);\n+                self.apply_autoderef_adjustment(base_expr.id, autoderefs, adjusted_ty);\n                 return Some((tcx.types.usize, ty));\n             }\n             _ => {}\n@@ -2685,8 +2712,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     \"expression with never type wound up being adjusted\");\n             let adj_ty = self.next_diverging_ty_var(\n                 TypeVariableOrigin::AdjustmentType(expr.span));\n-            self.write_adjustment(expr.id, adjustment::Adjustment {\n-                kind: adjustment::Adjust::NeverToAny,\n+            self.apply_adjustment(expr.id, Adjustment {\n+                kind: Adjust::NeverToAny,\n                 target: adj_ty\n             });\n             ty = adj_ty;\n@@ -2917,7 +2944,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         let field_ty = self.field_ty(expr.span, field, substs);\n                         if self.tcx.vis_is_accessible_from(field.vis, self.body_id) {\n                             autoderef.finalize(lvalue_pref, &[base]);\n-                            self.write_autoderef_adjustment(base.id, autoderefs, base_t);\n+                            self.apply_autoderef_adjustment(base.id, autoderefs, base_t);\n \n                             self.tcx.check_stability(field.did, expr.id, expr.span);\n \n@@ -3041,7 +3068,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             if let Some(field_ty) = field {\n                 autoderef.finalize(lvalue_pref, &[base]);\n-                self.write_autoderef_adjustment(base.id, autoderefs, base_t);\n+                self.apply_autoderef_adjustment(base.id, autoderefs, base_t);\n                 return field_ty;\n             }\n         }"}, {"sha": "d4755020fef22cb533a56664a6bf24d2b256b1a2", "filename": "src/test/run-pass/issue-41213.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/03b0d995564b26a2ca9ccf0ded8a6fd375dd9412/src%2Ftest%2Frun-pass%2Fissue-41213.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b0d995564b26a2ca9ccf0ded8a6fd375dd9412/src%2Ftest%2Frun-pass%2Fissue-41213.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-41213.rs?ref=03b0d995564b26a2ca9ccf0ded8a6fd375dd9412", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum A {\n+    A1,\n+    A2,\n+    A3,\n+}\n+\n+enum B {\n+    B1(String, String),\n+    B2(String, String),\n+}\n+\n+fn main() {\n+    let a = A::A1;\n+    loop {\n+        let _ctor = match a {\n+            A::A3 => break,\n+            A::A1 => B::B1,\n+            A::A2 => B::B2,\n+        };\n+        break;\n+    }\n+}"}]}