{"sha": "26d1500e133d50727dfea10043d194a5b9f3761f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2ZDE1MDBlMTMzZDUwNzI3ZGZlYTEwMDQzZDE5NGE1YjlmMzc2MWY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-11-09T21:45:26Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-11-16T18:57:47Z"}, "message": "add a `nested_visit_map` method\n\nThis allows you to enable *all* nested visits in a future-compatible\nsort of way. Moreover, if you choose to override the `visit_nested`\nmethods yourself, you can \"future-proof\" against omissions by overriding\n`nested_visit_map` to panic.", "tree": {"sha": "0a8e26739e19fd6042c8f6573c99727a5068eaa1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a8e26739e19fd6042c8f6573c99727a5068eaa1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26d1500e133d50727dfea10043d194a5b9f3761f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26d1500e133d50727dfea10043d194a5b9f3761f", "html_url": "https://github.com/rust-lang/rust/commit/26d1500e133d50727dfea10043d194a5b9f3761f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26d1500e133d50727dfea10043d194a5b9f3761f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4df5288971b9908b77c0c785885a59d91e546a4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4df5288971b9908b77c0c785885a59d91e546a4d", "html_url": "https://github.com/rust-lang/rust/commit/4df5288971b9908b77c0c785885a59d91e546a4d"}], "stats": {"total": 363, "additions": 181, "deletions": 182}, "files": [{"sha": "0b83a8bc9222f27d7a54b0891d5ac0ad3dee15a2", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 41, "deletions": 11, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/26d1500e133d50727dfea10043d194a5b9f3761f/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26d1500e133d50727dfea10043d194a5b9f3761f/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=26d1500e133d50727dfea10043d194a5b9f3761f", "patch": "@@ -38,6 +38,7 @@ use syntax::ast::{NodeId, CRATE_NODE_ID, Name, Attribute};\n use syntax::codemap::Spanned;\n use syntax_pos::Span;\n use hir::*;\n+use hir::map::Map;\n use super::itemlikevisit::DeepVisitor;\n \n use std::cmp;\n@@ -85,23 +86,52 @@ pub trait Visitor<'v> : Sized {\n     ///////////////////////////////////////////////////////////////////////////\n     // Nested items.\n \n-    /// Invoked when a nested item is encountered. By default, does\n-    /// nothing. If you want a deep walk, you need to override to\n-    /// fetch the item contents. But most of the time, it is easier to\n-    /// use either the \"shallow\" or \"deep\" visit patterns described on\n-    /// `itemlikevisit::ItemLikeVisitor`.\n+    /// The default versions of the `visit_nested_XXX` routines invoke\n+    /// this method to get a map to use; if they get back `None`, they\n+    /// just skip nested things. Otherwise, they will lookup the\n+    /// nested item-like things in the map and visit it. So the best\n+    /// way to implement a nested visitor is to override this method\n+    /// to return a `Map`; one advantage of this is that if we add\n+    /// more types of nested things in the future, they will\n+    /// automatically work.\n+    ///\n+    /// **If for some reason you want the nested behavior, but don't\n+    /// have a `Map` are your disposal:** then you should override the\n+    /// `visit_nested_XXX` methods, and override this method to\n+    /// `panic!()`. This way, if a new `visit_nested_XXX` variant is\n+    /// added in the future, we will see the panic in your code and\n+    /// fix it appropriately.\n+    fn nested_visit_map(&mut self) -> Option<&Map<'v>> {\n+        None\n+    }\n+\n+    /// Invoked when a nested item is encountered. By default does\n+    /// nothing unless you override `nested_visit_map` to return\n+    /// `Some(_)`, in which case it will walk the item. **You probably\n+    /// don't want to override this method** -- instead, override\n+    /// `nested_visit_map` or use the \"shallow\" or \"deep\" visit\n+    /// patterns described on `itemlikevisit::ItemLikeVisitor`. The only\n+    /// reason to override this method is if you want a nested pattern\n+    /// but cannot supply a `Map`; see `nested_visit_map` for advice.\n     #[allow(unused_variables)]\n     fn visit_nested_item(&mut self, id: ItemId) {\n+        let opt_item = self.nested_visit_map()\n+                           .map(|map| map.expect_item(id.id));\n+        if let Some(item) = opt_item {\n+            self.visit_item(item);\n+        }\n     }\n \n-    /// Invoked when a nested impl item is encountered. By default, does\n-    /// nothing. If you want a deep walk, you need to override to\n-    /// fetch the item contents. But most of the time, it is easier\n-    /// (and better) to invoke `Crate::visit_all_item_likes`, which visits\n-    /// all items in the crate in some order (but doesn't respect\n-    /// nesting).\n+    /// Like `visit_nested_item()`, but for impl items. See\n+    /// `visit_nested_item()` for advice on when to override this\n+    /// method.\n     #[allow(unused_variables)]\n     fn visit_nested_impl_item(&mut self, id: ImplItemId) {\n+        let opt_item = self.nested_visit_map()\n+                           .map(|map| map.impl_item(id));\n+        if let Some(item) = opt_item {\n+            self.visit_impl_item(item);\n+        }\n     }\n \n     /// Visit the top-level item and (optionally) nested items / impl items. See"}, {"sha": "5fd0839affef99b80410e83ed5d84035b9ca6e29", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/26d1500e133d50727dfea10043d194a5b9f3761f/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26d1500e133d50727dfea10043d194a5b9f3761f/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=26d1500e133d50727dfea10043d194a5b9f3761f", "patch": "@@ -92,6 +92,11 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     /// Because we want to track parent items and so forth, enable\n     /// deep walking so that we walk nested items in the context of\n     /// their outer items.\n+\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'v>> {\n+        panic!(\"visit_nested_xxx must be manually implemented in this visitor\")\n+    }\n+\n     fn visit_nested_item(&mut self, item: ItemId) {\n         debug!(\"visit_nested_item: {:?}\", item);\n         if !self.ignore_nested_items {"}, {"sha": "a490b58964a71f04c67a589e018ff61faf7bd0d4", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 31, "deletions": 35, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/26d1500e133d50727dfea10043d194a5b9f3761f/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26d1500e133d50727dfea10043d194a5b9f3761f/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=26d1500e133d50727dfea10043d194a5b9f3761f", "patch": "@@ -792,21 +792,15 @@ impl<'a> LintContext for EarlyContext<'a> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n+impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     /// Because lints are scoped lexically, we want to walk nested\n     /// items in the context of the outer item, so enable\n     /// deep-walking.\n-    fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        let item = self.tcx.map.expect_item(item.id);\n-        self.visit_item(item)\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n+        Some(&self.tcx.map)\n     }\n \n-    fn visit_nested_impl_item(&mut self, item_id: hir::ImplItemId) {\n-        let impl_item = self.tcx.map.impl_item(item_id);\n-        self.visit_impl_item(impl_item)\n-    }\n-\n-    fn visit_item(&mut self, it: &hir::Item) {\n+    fn visit_item(&mut self, it: &'tcx hir::Item) {\n         self.with_lint_attrs(&it.attrs, |cx| {\n             run_lints!(cx, check_item, late_passes, it);\n             cx.visit_ids(|v| v.visit_item(it));\n@@ -815,27 +809,27 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n         })\n     }\n \n-    fn visit_foreign_item(&mut self, it: &hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem) {\n         self.with_lint_attrs(&it.attrs, |cx| {\n             run_lints!(cx, check_foreign_item, late_passes, it);\n             hir_visit::walk_foreign_item(cx, it);\n             run_lints!(cx, check_foreign_item_post, late_passes, it);\n         })\n     }\n \n-    fn visit_pat(&mut self, p: &hir::Pat) {\n+    fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n         run_lints!(self, check_pat, late_passes, p);\n         hir_visit::walk_pat(self, p);\n     }\n \n-    fn visit_expr(&mut self, e: &hir::Expr) {\n+    fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n         self.with_lint_attrs(&e.attrs, |cx| {\n             run_lints!(cx, check_expr, late_passes, e);\n             hir_visit::walk_expr(cx, e);\n         })\n     }\n \n-    fn visit_stmt(&mut self, s: &hir::Stmt) {\n+    fn visit_stmt(&mut self, s: &'tcx hir::Stmt) {\n         // statement attributes are actually just attributes on one of\n         // - item\n         // - local\n@@ -845,40 +839,43 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n         hir_visit::walk_stmt(self, s);\n     }\n \n-    fn visit_fn(&mut self, fk: hir_visit::FnKind<'v>, decl: &'v hir::FnDecl,\n-                body: &'v hir::Expr, span: Span, id: ast::NodeId) {\n+    fn visit_fn(&mut self, fk: hir_visit::FnKind<'tcx>, decl: &'tcx hir::FnDecl,\n+                body: &'tcx hir::Expr, span: Span, id: ast::NodeId) {\n         run_lints!(self, check_fn, late_passes, fk, decl, body, span, id);\n         hir_visit::walk_fn(self, fk, decl, body, span, id);\n         run_lints!(self, check_fn_post, late_passes, fk, decl, body, span, id);\n     }\n \n     fn visit_variant_data(&mut self,\n-                        s: &hir::VariantData,\n+                        s: &'tcx hir::VariantData,\n                         name: ast::Name,\n-                        g: &hir::Generics,\n+                        g: &'tcx hir::Generics,\n                         item_id: ast::NodeId,\n                         _: Span) {\n         run_lints!(self, check_struct_def, late_passes, s, name, g, item_id);\n         hir_visit::walk_struct_def(self, s);\n         run_lints!(self, check_struct_def_post, late_passes, s, name, g, item_id);\n     }\n \n-    fn visit_struct_field(&mut self, s: &hir::StructField) {\n+    fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n         self.with_lint_attrs(&s.attrs, |cx| {\n             run_lints!(cx, check_struct_field, late_passes, s);\n             hir_visit::walk_struct_field(cx, s);\n         })\n     }\n \n-    fn visit_variant(&mut self, v: &hir::Variant, g: &hir::Generics, item_id: ast::NodeId) {\n+    fn visit_variant(&mut self,\n+                     v: &'tcx hir::Variant,\n+                     g: &'tcx hir::Generics,\n+                     item_id: ast::NodeId) {\n         self.with_lint_attrs(&v.node.attrs, |cx| {\n             run_lints!(cx, check_variant, late_passes, v, g);\n             hir_visit::walk_variant(cx, v, g, item_id);\n             run_lints!(cx, check_variant_post, late_passes, v, g);\n         })\n     }\n \n-    fn visit_ty(&mut self, t: &hir::Ty) {\n+    fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n         run_lints!(self, check_ty, late_passes, t);\n         hir_visit::walk_ty(self, t);\n     }\n@@ -887,45 +884,45 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n         run_lints!(self, check_name, late_passes, sp, name);\n     }\n \n-    fn visit_mod(&mut self, m: &hir::Mod, s: Span, n: ast::NodeId) {\n+    fn visit_mod(&mut self, m: &'tcx hir::Mod, s: Span, n: ast::NodeId) {\n         run_lints!(self, check_mod, late_passes, m, s, n);\n         hir_visit::walk_mod(self, m, n);\n         run_lints!(self, check_mod_post, late_passes, m, s, n);\n     }\n \n-    fn visit_local(&mut self, l: &hir::Local) {\n+    fn visit_local(&mut self, l: &'tcx hir::Local) {\n         self.with_lint_attrs(&l.attrs, |cx| {\n             run_lints!(cx, check_local, late_passes, l);\n             hir_visit::walk_local(cx, l);\n         })\n     }\n \n-    fn visit_block(&mut self, b: &hir::Block) {\n+    fn visit_block(&mut self, b: &'tcx hir::Block) {\n         run_lints!(self, check_block, late_passes, b);\n         hir_visit::walk_block(self, b);\n         run_lints!(self, check_block_post, late_passes, b);\n     }\n \n-    fn visit_arm(&mut self, a: &hir::Arm) {\n+    fn visit_arm(&mut self, a: &'tcx hir::Arm) {\n         run_lints!(self, check_arm, late_passes, a);\n         hir_visit::walk_arm(self, a);\n     }\n \n-    fn visit_decl(&mut self, d: &hir::Decl) {\n+    fn visit_decl(&mut self, d: &'tcx hir::Decl) {\n         run_lints!(self, check_decl, late_passes, d);\n         hir_visit::walk_decl(self, d);\n     }\n \n-    fn visit_expr_post(&mut self, e: &hir::Expr) {\n+    fn visit_expr_post(&mut self, e: &'tcx hir::Expr) {\n         run_lints!(self, check_expr_post, late_passes, e);\n     }\n \n-    fn visit_generics(&mut self, g: &hir::Generics) {\n+    fn visit_generics(&mut self, g: &'tcx hir::Generics) {\n         run_lints!(self, check_generics, late_passes, g);\n         hir_visit::walk_generics(self, g);\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         self.with_lint_attrs(&trait_item.attrs, |cx| {\n             run_lints!(cx, check_trait_item, late_passes, trait_item);\n             cx.visit_ids(|v| hir_visit::walk_trait_item(v, trait_item));\n@@ -934,7 +931,7 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n         });\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         self.with_lint_attrs(&impl_item.attrs, |cx| {\n             run_lints!(cx, check_impl_item, late_passes, impl_item);\n             cx.visit_ids(|v| hir_visit::walk_impl_item(v, impl_item));\n@@ -943,20 +940,20 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n         });\n     }\n \n-    fn visit_lifetime(&mut self, lt: &hir::Lifetime) {\n+    fn visit_lifetime(&mut self, lt: &'tcx hir::Lifetime) {\n         run_lints!(self, check_lifetime, late_passes, lt);\n     }\n \n-    fn visit_lifetime_def(&mut self, lt: &hir::LifetimeDef) {\n+    fn visit_lifetime_def(&mut self, lt: &'tcx hir::LifetimeDef) {\n         run_lints!(self, check_lifetime_def, late_passes, lt);\n     }\n \n-    fn visit_path(&mut self, p: &hir::Path, id: ast::NodeId) {\n+    fn visit_path(&mut self, p: &'tcx hir::Path, id: ast::NodeId) {\n         run_lints!(self, check_path, late_passes, p, id);\n         hir_visit::walk_path(self, p);\n     }\n \n-    fn visit_path_list_item(&mut self, prefix: &hir::Path, item: &hir::PathListItem) {\n+    fn visit_path_list_item(&mut self, prefix: &'tcx hir::Path, item: &'tcx hir::PathListItem) {\n         run_lints!(self, check_path_list_item, late_passes, item);\n         hir_visit::walk_path_list_item(self, prefix, item);\n     }\n@@ -1121,7 +1118,6 @@ struct IdVisitor<'a, 'b: 'a, 'tcx: 'a+'b> {\n \n // Output any lints that were previously added to the session.\n impl<'a, 'b, 'tcx, 'v> hir_visit::Visitor<'v> for IdVisitor<'a, 'b, 'tcx> {\n-\n     fn visit_id(&mut self, id: ast::NodeId) {\n         if let Some(lints) = self.cx.sess().lints.borrow_mut().remove(&id) {\n             debug!(\"LateContext::visit_id: id={:?} lints={:?}\", id, lints);"}, {"sha": "e6722661223e67db7b0c56dcbcbeb7ebb1380b82", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/26d1500e133d50727dfea10043d194a5b9f3761f/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26d1500e133d50727dfea10043d194a5b9f3761f/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=26d1500e133d50727dfea10043d194a5b9f3761f", "patch": "@@ -511,22 +511,16 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n     /// Walk nested items in place so that we don't report dead-code\n     /// on inner functions when the outer function is already getting\n     /// an error. We could do this also by checking the parents, but\n     /// this is how the code is setup and it seems harmless enough.\n-    fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        let item = self.tcx.map.expect_item(item.id);\n-        self.visit_item(item)\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n+        Some(&self.tcx.map)\n     }\n \n-    fn visit_nested_impl_item(&mut self, item_id: hir::ImplItemId) {\n-        let impl_item = self.tcx.map.impl_item(item_id);\n-        self.visit_impl_item(impl_item)\n-    }\n-\n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n         if self.should_warn_about_item(item) {\n             self.warn_dead_code(\n                 item.id,\n@@ -540,7 +534,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_variant(&mut self, variant: &hir::Variant, g: &hir::Generics, id: ast::NodeId) {\n+    fn visit_variant(&mut self,\n+                     variant: &'tcx hir::Variant,\n+                     g: &'tcx hir::Generics,\n+                     id: ast::NodeId) {\n         if self.should_warn_about_variant(&variant.node) {\n             self.warn_dead_code(variant.node.data.id(), variant.span,\n                                 variant.node.name, \"variant\");\n@@ -549,14 +546,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_foreign_item(&mut self, fi: &hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, fi: &'tcx hir::ForeignItem) {\n         if !self.symbol_is_live(fi.id, None) {\n             self.warn_dead_code(fi.id, fi.span, fi.name, fi.node.descriptive_variant());\n         }\n         intravisit::walk_foreign_item(self, fi);\n     }\n \n-    fn visit_struct_field(&mut self, field: &hir::StructField) {\n+    fn visit_struct_field(&mut self, field: &'tcx hir::StructField) {\n         if self.should_warn_about_field(&field) {\n             self.warn_dead_code(field.id, field.span,\n                                 field.name, \"field\");\n@@ -565,7 +562,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n         intravisit::walk_struct_field(self, field);\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         match impl_item.node {\n             hir::ImplItemKind::Const(_, ref expr) => {\n                 if !self.symbol_is_live(impl_item.id, None) {\n@@ -586,7 +583,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n     }\n \n     // Overwrite so that we don't warn the trait item itself.\n-    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         match trait_item.node {\n             hir::ConstTraitItem(_, Some(ref body))|\n             hir::MethodTraitItem(_, Some(ref body)) => {"}, {"sha": "f682dfbf1be9526550bed9b052bb611d154549be", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 32, "deletions": 34, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/26d1500e133d50727dfea10043d194a5b9f3761f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26d1500e133d50727dfea10043d194a5b9f3761f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=26d1500e133d50727dfea10043d194a5b9f3761f", "patch": "@@ -132,21 +132,14 @@ pub fn krate(sess: &Session,\n     Ok(map)\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     // Override the nested functions -- lifetimes follow lexical scope,\n     // so it's convenient to walk the tree in lexical order.\n-\n-    fn visit_nested_item(&mut self, id: hir::ItemId) {\n-        let item = self.hir_map.expect_item(id.id);\n-        self.visit_item(item)\n-    }\n-\n-    fn visit_nested_impl_item(&mut self, id: hir::ImplItemId) {\n-        let impl_item = self.hir_map.impl_item(id);\n-        self.visit_impl_item(impl_item)\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n+        Some(&self.hir_map)\n     }\n \n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n         // Save labels for nested items.\n         let saved_labels_in_fn = replace(&mut self.labels_in_fn, vec![]);\n \n@@ -192,7 +185,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n         self.labels_in_fn = saved_labels_in_fn;\n     }\n \n-    fn visit_foreign_item(&mut self, item: &hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem) {\n         // Items save/restore the set of labels. This way inner items\n         // can freely reuse names, be they loop labels or lifetimes.\n         let saved = replace(&mut self.labels_in_fn, vec![]);\n@@ -215,8 +208,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n         replace(&mut self.labels_in_fn, saved);\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'v>, decl: &'v hir::FnDecl,\n-                b: &'v hir::Expr, s: Span, fn_id: ast::NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'tcx>, decl: &'tcx hir::FnDecl,\n+                b: &'tcx hir::Expr, s: Span, fn_id: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(_, generics, ..) => {\n                 self.visit_early_late(fn_id,decl, generics, |this| {\n@@ -241,7 +234,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_ty(&mut self, ty: &hir::Ty) {\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         match ty.node {\n             hir::TyBareFn(ref c) => {\n                 self.with(LateScope(&c.lifetimes, self.scope), |old_scope, this| {\n@@ -271,7 +264,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         // We reset the labels on every trait item, so that different\n         // methods in an impl can reuse label names.\n         let saved = replace(&mut self.labels_in_fn, vec![]);\n@@ -288,15 +281,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n         replace(&mut self.labels_in_fn, saved);\n     }\n \n-    fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n+    fn visit_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n         if lifetime_ref.name == keywords::StaticLifetime.name() {\n             self.insert_lifetime(lifetime_ref, DefStaticRegion);\n             return;\n         }\n         self.resolve_lifetime_ref(lifetime_ref);\n     }\n \n-    fn visit_generics(&mut self, generics: &hir::Generics) {\n+    fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n         for ty_param in generics.ty_params.iter() {\n             walk_list!(self, visit_ty_param_bound, &ty_param.bounds);\n             if let Some(ref ty) = ty_param.default {\n@@ -345,8 +338,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_poly_trait_ref(&mut self,\n-                            trait_ref: &hir::PolyTraitRef,\n-                            _modifier: &hir::TraitBoundModifier) {\n+                            trait_ref: &'tcx hir::PolyTraitRef,\n+                            _modifier: &'tcx hir::TraitBoundModifier) {\n         debug!(\"visit_poly_trait_ref trait_ref={:?}\", trait_ref);\n \n         if !self.trait_ref_hack || !trait_ref.bound_lifetimes.is_empty() {\n@@ -504,13 +497,12 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: &hir::Expr) {\n }\n \n impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n-    fn add_scope_and_walk_fn<'b>(&mut self,\n-                                 fk: FnKind,\n-                                 fd: &hir::FnDecl,\n-                                 fb: &'b hir::Expr,\n-                                 _span: Span,\n-                                 fn_id: ast::NodeId) {\n-\n+    fn add_scope_and_walk_fn(&mut self,\n+                             fk: FnKind<'tcx>,\n+                             fd: &'tcx hir::FnDecl,\n+                             fb: &'tcx hir::Expr,\n+                             _span: Span,\n+                             fn_id: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(_, generics, ..) => {\n                 intravisit::walk_fn_decl(self, fd);\n@@ -533,8 +525,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                   |_old_scope, this| this.visit_expr(fb))\n     }\n \n+    // FIXME(#37666) this works around a limitation in the region inferencer\n+    fn hack<F>(&mut self, f: F) where\n+        F: for<'b> FnOnce(&mut LifetimeContext<'b, 'tcx>),\n+    {\n+        f(self)\n+    }\n+\n     fn with<F>(&mut self, wrap_scope: ScopeChain, f: F) where\n-        F: FnOnce(Scope, &mut LifetimeContext),\n+        F: for<'b> FnOnce(Scope, &mut LifetimeContext<'b, 'tcx>),\n     {\n         let LifetimeContext {sess, hir_map, ref mut map, ..} = *self;\n         let mut this = LifetimeContext {\n@@ -571,10 +570,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// ordering is not important there.\n     fn visit_early_late<F>(&mut self,\n                            fn_id: ast::NodeId,\n-                           decl: &hir::FnDecl,\n-                           generics: &hir::Generics,\n+                           decl: &'tcx hir::FnDecl,\n+                           generics: &'tcx hir::Generics,\n                            walk: F) where\n-        F: FnOnce(&mut LifetimeContext),\n+        F: for<'b, 'c> FnOnce(&'b mut LifetimeContext<'c, 'tcx>),\n     {\n         let fn_def_id = self.hir_map.local_def_id(fn_id);\n         insert_late_bound_lifetimes(self.map,\n@@ -604,11 +603,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         }\n \n-        let this = self;\n-        this.with(EarlyScope(&early, start as u32, this.scope), move |old_scope, this| {\n+        self.with(EarlyScope(&early, start as u32, self.scope), move |old_scope, this| {\n             this.with(LateScope(&late, this.scope), move |_, this| {\n                 this.check_lifetime_defs(old_scope, &generics.lifetimes);\n-                walk(this);\n+                this.hack(walk); // FIXME(#37666) workaround in place of `walk(this)`\n             });\n         });\n     }"}, {"sha": "239aaa6bb75f1785a7a430aeea9c9f8927b8af6a", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/26d1500e133d50727dfea10043d194a5b9f3761f/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26d1500e133d50727dfea10043d194a5b9f3761f/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=26d1500e133d50727dfea10043d194a5b9f3761f", "patch": "@@ -120,7 +120,7 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n     // stability. The stability is recorded in the index and used as the parent.\n     fn annotate<F>(&mut self, id: NodeId, attrs: &[Attribute],\n                    item_sp: Span, kind: AnnotationKind, visit_children: F)\n-        where F: FnOnce(&mut Annotator)\n+        where F: FnOnce(&mut Self)\n     {\n         if self.index.staged_api[&LOCAL_CRATE] && self.tcx.sess.features.borrow().staged_api {\n             debug!(\"annotate(id = {:?}, attrs = {:?})\", id, attrs);\n@@ -234,21 +234,15 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     /// Because stability levels are scoped lexically, we want to walk\n     /// nested items in the context of the outer item, so enable\n     /// deep-walking.\n-    fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        let item = self.tcx.map.expect_item(item.id);\n-        self.visit_item(item)\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n+        Some(&self.tcx.map)\n     }\n \n-    fn visit_nested_impl_item(&mut self, item_id: hir::ImplItemId) {\n-        let impl_item = self.tcx.map.impl_item(item_id);\n-        self.visit_impl_item(impl_item)\n-    }\n-\n-    fn visit_item(&mut self, i: &Item) {\n+    fn visit_item(&mut self, i: &'tcx Item) {\n         let orig_in_trait_impl = self.in_trait_impl;\n         let mut kind = AnnotationKind::Required;\n         match i.node {\n@@ -277,13 +271,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n         self.in_trait_impl = orig_in_trait_impl;\n     }\n \n-    fn visit_trait_item(&mut self, ti: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n         self.annotate(ti.id, &ti.attrs, ti.span, AnnotationKind::Required, |v| {\n             intravisit::walk_trait_item(v, ti);\n         });\n     }\n \n-    fn visit_impl_item(&mut self, ii: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n         let kind = if self.in_trait_impl {\n             AnnotationKind::Prohibited\n         } else {\n@@ -294,25 +288,25 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n         });\n     }\n \n-    fn visit_variant(&mut self, var: &Variant, g: &'v Generics, item_id: NodeId) {\n+    fn visit_variant(&mut self, var: &'tcx Variant, g: &'tcx Generics, item_id: NodeId) {\n         self.annotate(var.node.data.id(), &var.node.attrs, var.span, AnnotationKind::Required, |v| {\n             intravisit::walk_variant(v, var, g, item_id);\n         })\n     }\n \n-    fn visit_struct_field(&mut self, s: &StructField) {\n+    fn visit_struct_field(&mut self, s: &'tcx StructField) {\n         self.annotate(s.id, &s.attrs, s.span, AnnotationKind::Required, |v| {\n             intravisit::walk_struct_field(v, s);\n         });\n     }\n \n-    fn visit_foreign_item(&mut self, i: &hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem) {\n         self.annotate(i.id, &i.attrs, i.span, AnnotationKind::Required, |v| {\n             intravisit::walk_foreign_item(v, i);\n         });\n     }\n \n-    fn visit_macro_def(&mut self, md: &'v hir::MacroDef) {\n+    fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n         if md.imported_from.is_none() {\n             self.annotate(md.id, &md.attrs, md.span, AnnotationKind::Required, |_| {});\n         }\n@@ -449,21 +443,15 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n     /// Because stability levels are scoped lexically, we want to walk\n     /// nested items in the context of the outer item, so enable\n     /// deep-walking.\n-    fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        let item = self.tcx.map.expect_item(item.id);\n-        self.visit_item(item)\n-    }\n-\n-    fn visit_nested_impl_item(&mut self, item_id: hir::ImplItemId) {\n-        let impl_item = self.tcx.map.impl_item(item_id);\n-        self.visit_impl_item(impl_item)\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n+        Some(&self.tcx.map)\n     }\n \n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n         // When compiling with --test we don't enforce stability on the\n         // compiler-generated test module, demarcated with `DUMMY_SP` plus the\n         // name `__test`\n@@ -474,31 +462,31 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n         intravisit::walk_item(self, item);\n     }\n \n-    fn visit_expr(&mut self, ex: &hir::Expr) {\n+    fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n         check_expr(self.tcx, ex,\n                    &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n         intravisit::walk_expr(self, ex);\n     }\n \n-    fn visit_path(&mut self, path: &hir::Path, id: ast::NodeId) {\n+    fn visit_path(&mut self, path: &'tcx hir::Path, id: ast::NodeId) {\n         check_path(self.tcx, path, id,\n                    &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n         intravisit::walk_path(self, path)\n     }\n \n-    fn visit_path_list_item(&mut self, prefix: &hir::Path, item: &hir::PathListItem) {\n+    fn visit_path_list_item(&mut self, prefix: &'tcx hir::Path, item: &'tcx hir::PathListItem) {\n         check_path_list_item(self.tcx, item,\n                    &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n         intravisit::walk_path_list_item(self, prefix, item)\n     }\n \n-    fn visit_pat(&mut self, pat: &hir::Pat) {\n+    fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n         check_pat(self.tcx, pat,\n                   &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n         intravisit::walk_pat(self, pat)\n     }\n \n-    fn visit_block(&mut self, b: &hir::Block) {\n+    fn visit_block(&mut self, b: &'tcx hir::Block) {\n         let old_skip_count = self.in_skip_block;\n         match b.rules {\n             hir::BlockCheckMode::PushUnstableBlock => {"}, {"sha": "318cc83d9ad4c3a5d47d76f2dde233d0b99ffaf0", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26d1500e133d50727dfea10043d194a5b9f3761f/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26d1500e133d50727dfea10043d194a5b9f3761f/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=26d1500e133d50727dfea10043d194a5b9f3761f", "patch": "@@ -499,14 +499,6 @@ macro_rules! hash_span {\n }\n \n impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n-    fn visit_nested_item(&mut self, _: ItemId) {\n-        // Each item is hashed independently; ignore nested items.\n-    }\n-\n-    fn visit_nested_impl_item(&mut self, _: ImplItemId) {\n-        // Impl items are hashed independently; ignore nested impl items.\n-    }\n-\n     fn visit_variant_data(&mut self,\n                           s: &'tcx VariantData,\n                           name: Name,"}, {"sha": "3bdaf276b40cef489bc43a4514b63f07847186e6", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26d1500e133d50727dfea10043d194a5b9f3761f/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26d1500e133d50727dfea10043d194a5b9f3761f/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=26d1500e133d50727dfea10043d194a5b9f3761f", "patch": "@@ -106,12 +106,20 @@ impl<'k> StatCollector<'k> {\n }\n \n impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'v>> {\n+        panic!(\"visit_nested_xxx must be manually implemented in this visitor\")\n+    }\n \n     fn visit_nested_item(&mut self, id: hir::ItemId) {\n         let nested_item = self.krate.unwrap().item(id.id);\n         self.visit_item(nested_item)\n     }\n \n+    fn visit_nested_impl_item(&mut self, impl_item_id: hir::ImplItemId) {\n+        let nested_impl_item = self.krate.unwrap().impl_item(impl_item_id);\n+        self.visit_impl_item(nested_impl_item)\n+    }\n+\n     fn visit_item(&mut self, i: &'v hir::Item) {\n         self.record(\"Item\", Id::Node(i.id), i);\n         hir_visit::walk_item(self, i)"}, {"sha": "9cbf4c8a615436aaead38a78a6cdc77bf20b9b88", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 32, "deletions": 47, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/26d1500e133d50727dfea10043d194a5b9f3761f/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26d1500e133d50727dfea10043d194a5b9f3761f/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=26d1500e133d50727dfea10043d194a5b9f3761f", "patch": "@@ -116,20 +116,14 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n-    fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        let tcx = self.tcx;\n-        self.visit_item(tcx.map.expect_item(item.id))\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n+        Some(&self.tcx.map)\n     }\n \n-    fn visit_nested_impl_item(&mut self, item_id: hir::ImplItemId) {\n-        let impl_item = self.tcx.map.impl_item(item_id);\n-        self.visit_impl_item(impl_item)\n-    }\n-\n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let inherited_item_level = match item.node {\n             // Impls inherit level from their types and traits\n             hir::ItemImpl(.., None, ref ty, _) => {\n@@ -278,7 +272,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         self.prev_level = orig_level;\n     }\n \n-    fn visit_block(&mut self, b: &'v hir::Block) {\n+    fn visit_block(&mut self, b: &'tcx hir::Block) {\n         let orig_level = replace(&mut self.prev_level, None);\n \n         // Blocks can have public items, for example impls, but they always\n@@ -289,7 +283,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         self.prev_level = orig_level;\n     }\n \n-    fn visit_mod(&mut self, m: &hir::Mod, _sp: Span, id: ast::NodeId) {\n+    fn visit_mod(&mut self, m: &'tcx hir::Mod, _sp: Span, id: ast::NodeId) {\n         // This code is here instead of in visit_item so that the\n         // crate module gets processed as well.\n         if self.prev_level.is_some() {\n@@ -305,14 +299,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         intravisit::walk_mod(self, m, id);\n     }\n \n-    fn visit_macro_def(&mut self, md: &'v hir::MacroDef) {\n+    fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n         self.update(md.id, Some(AccessLevel::Public));\n     }\n }\n \n impl<'b, 'a, 'tcx: 'a> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n     // Make the type hidden under a type alias reachable\n-    fn reach_aliased_type(&mut self, item: &hir::Item, path: &hir::Path) {\n+    fn reach_aliased_type(&mut self, item: &'tcx hir::Item, path: &'tcx hir::Path) {\n         if let hir::ItemTy(ref ty, ref generics) = item.node {\n             // See `fn is_public_type_alias` for details\n             self.visit_ty(ty);\n@@ -326,14 +320,14 @@ impl<'b, 'a, 'tcx: 'a> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n     }\n }\n \n-impl<'b, 'a, 'tcx: 'a, 'v> Visitor<'v> for ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n+impl<'b, 'a, 'tcx: 'a> Visitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n     fn visit_nested_impl_item(&mut self, item_id: hir::ImplItemId) {\n         // when we visit an impl, its methods and items are part of its \"interface\"\n         let impl_item = self.ev.tcx.map.impl_item(item_id);\n         self.visit_impl_item(impl_item)\n     }\n \n-    fn visit_ty(&mut self, ty: &hir::Ty) {\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         if let hir::TyPath(_, ref path) = ty.node {\n             let def = self.ev.tcx.expect_def(ty.id);\n             match def {\n@@ -365,7 +359,7 @@ impl<'b, 'a, 'tcx: 'a, 'v> Visitor<'v> for ReachEverythingInTheInterfaceVisitor<\n         intravisit::walk_ty(self, ty);\n     }\n \n-    fn visit_trait_ref(&mut self, trait_ref: &hir::TraitRef) {\n+    fn visit_trait_ref(&mut self, trait_ref: &'tcx hir::TraitRef) {\n         let def_id = self.ev.tcx.expect_def(trait_ref.ref_id).def_id();\n         if let Some(node_id) = self.ev.tcx.map.as_local_node_id(def_id) {\n             let item = self.ev.tcx.map.expect_item(node_id);\n@@ -427,26 +421,20 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n-    fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        let tcx = self.tcx;\n-        self.visit_item(tcx.map.expect_item(item.id))\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n+        Some(&self.tcx.map)\n     }\n \n-    fn visit_nested_impl_item(&mut self, item_id: hir::ImplItemId) {\n-        let impl_item = self.tcx.map.impl_item(item_id);\n-        self.visit_impl_item(impl_item)\n-    }\n-\n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let orig_curitem = replace(&mut self.curitem, item.id);\n         intravisit::walk_item(self, item);\n         self.curitem = orig_curitem;\n     }\n \n-    fn visit_expr(&mut self, expr: &hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n@@ -506,7 +494,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n         intravisit::walk_expr(self, expr);\n     }\n \n-    fn visit_pat(&mut self, pattern: &hir::Pat) {\n+    fn visit_pat(&mut self, pattern: &'tcx hir::Pat) {\n         // Foreign functions do not have their patterns mapped in the def_map,\n         // and there's nothing really relevant there anyway, so don't bother\n         // checking privacy. If you can name the type then you can pass it to an\n@@ -542,7 +530,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n         intravisit::walk_pat(self, pattern);\n     }\n \n-    fn visit_foreign_item(&mut self, fi: &hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, fi: &'tcx hir::ForeignItem) {\n         self.in_foreign = true;\n         intravisit::walk_foreign_item(self, fi);\n         self.in_foreign = false;\n@@ -636,20 +624,14 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for ObsoleteCheckTypeForPrivatenessVisitor<'a\n     fn visit_expr(&mut self, _: &hir::Expr) {}\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n-    fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        let tcx = self.tcx;\n-        self.visit_item(tcx.map.expect_item(item.id))\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n+        Some(&self.tcx.map)\n     }\n \n-    fn visit_nested_impl_item(&mut self, item_id: hir::ImplItemId) {\n-        let impl_item = self.tcx.map.impl_item(item_id);\n-        self.visit_impl_item(impl_item)\n-    }\n-\n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n             // contents of a private mod can be reexported, so we need\n             // to check internals.\n@@ -834,7 +816,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n         intravisit::walk_item(self, item);\n     }\n \n-    fn visit_generics(&mut self, generics: &hir::Generics) {\n+    fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n         for ty_param in generics.ty_params.iter() {\n             for bound in ty_param.bounds.iter() {\n                 self.check_ty_param_bound(bound)\n@@ -855,13 +837,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n         }\n     }\n \n-    fn visit_foreign_item(&mut self, item: &hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem) {\n         if self.access_levels.is_reachable(item.id) {\n             intravisit::walk_foreign_item(self, item)\n         }\n     }\n \n-    fn visit_ty(&mut self, t: &hir::Ty) {\n+    fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n         if let hir::TyPath(..) = t.node {\n             if self.path_is_private_type(t.id) {\n                 self.old_error_set.insert(t.id);\n@@ -870,15 +852,18 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n         intravisit::walk_ty(self, t)\n     }\n \n-    fn visit_variant(&mut self, v: &hir::Variant, g: &hir::Generics, item_id: ast::NodeId) {\n+    fn visit_variant(&mut self,\n+                     v: &'tcx hir::Variant,\n+                     g: &'tcx hir::Generics,\n+                     item_id: ast::NodeId) {\n         if self.access_levels.is_reachable(v.node.data.id()) {\n             self.in_variant = true;\n             intravisit::walk_variant(self, v, g, item_id);\n             self.in_variant = false;\n         }\n     }\n \n-    fn visit_struct_field(&mut self, s: &hir::StructField) {\n+    fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n         if s.vis == hir::Public || self.in_variant {\n             intravisit::walk_struct_field(self, s);\n         }\n@@ -888,8 +873,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n     // expression/block context can't possibly contain exported things.\n     // (Making them no-ops stops us from traversing the whole AST without\n     // having to be super careful about our `walk_...` calls above.)\n-    fn visit_block(&mut self, _: &hir::Block) {}\n-    fn visit_expr(&mut self, _: &hir::Expr) {}\n+    fn visit_block(&mut self, _: &'tcx hir::Block) {}\n+    fn visit_expr(&mut self, _: &'tcx hir::Expr) {}\n }\n \n ///////////////////////////////////////////////////////////////////////////////"}]}