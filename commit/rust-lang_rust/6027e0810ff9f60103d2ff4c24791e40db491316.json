{"sha": "6027e0810ff9f60103d2ff4c24791e40db491316", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwMjdlMDgxMGZmOWY2MDEwM2QyZmY0YzI0NzkxZTQwZGI0OTEzMTY=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-11-10T23:52:20Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-11-18T11:05:19Z"}, "message": "Only handle ReVar regions in NLL borrowck\n\nNow that lexical MIR borrowck is gone, there's no need to store Regions\nunnecessarily.", "tree": {"sha": "294af1eb8d949e6d374cb797b4ae6b9de6c7a024", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/294af1eb8d949e6d374cb797b4ae6b9de6c7a024"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6027e0810ff9f60103d2ff4c24791e40db491316", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6027e0810ff9f60103d2ff4c24791e40db491316", "html_url": "https://github.com/rust-lang/rust/commit/6027e0810ff9f60103d2ff4c24791e40db491316", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6027e0810ff9f60103d2ff4c24791e40db491316/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b16985a3546844e14842b9c15ddc50aff9f1adda", "url": "https://api.github.com/repos/rust-lang/rust/commits/b16985a3546844e14842b9c15ddc50aff9f1adda", "html_url": "https://github.com/rust-lang/rust/commit/b16985a3546844e14842b9c15ddc50aff9f1adda"}], "stats": {"total": 128, "additions": 23, "deletions": 105}, "files": [{"sha": "fd7dc7fc4bd3af11d80d221fd86101b15bcbc9aa", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6027e0810ff9f60103d2ff4c24791e40db491316/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6027e0810ff9f60103d2ff4c24791e40db491316/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=6027e0810ff9f60103d2ff4c24791e40db491316", "patch": "@@ -9,14 +9,15 @@\n // except according to those terms.\n \n use borrow_check::place_ext::PlaceExt;\n+use borrow_check::nll::ToRegionVid;\n use dataflow::indexes::BorrowIndex;\n use dataflow::move_paths::MoveData;\n use rustc::mir::traversal;\n use rustc::mir::visit::{\n     PlaceContext, Visitor, NonUseContext, MutatingUseContext, NonMutatingUseContext\n };\n use rustc::mir::{self, Location, Mir, Place, Local};\n-use rustc::ty::{Region, TyCtxt};\n+use rustc::ty::{RegionVid, TyCtxt};\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::bit_set::BitSet;\n@@ -42,7 +43,7 @@ crate struct BorrowSet<'tcx> {\n \n     /// Every borrow has a region; this maps each such regions back to\n     /// its borrow-indexes.\n-    crate region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n+    crate region_map: FxHashMap<RegionVid, FxHashSet<BorrowIndex>>,\n \n     /// Map from local to all the borrows on that local\n     crate local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n@@ -77,7 +78,7 @@ crate struct BorrowData<'tcx> {\n     /// What kind of borrow this is\n     crate kind: mir::BorrowKind,\n     /// The region for which this borrow is live\n-    crate region: Region<'tcx>,\n+    crate region: RegionVid,\n     /// Place from which we are borrowing\n     crate borrowed_place: mir::Place<'tcx>,\n     /// Place to which the borrow was stored\n@@ -92,13 +93,7 @@ impl<'tcx> fmt::Display for BorrowData<'tcx> {\n             mir::BorrowKind::Unique => \"uniq \",\n             mir::BorrowKind::Mut { .. } => \"mut \",\n         };\n-        let region = self.region.to_string();\n-        let separator = if !region.is_empty() {\n-            \" \"\n-        } else {\n-            \"\"\n-        };\n-        write!(w, \"&{}{}{}{:?}\", region, separator, kind, self.borrowed_place)\n+        write!(w, \"&{:?} {}{:?}\", self.region, kind, self.borrowed_place)\n     }\n }\n \n@@ -189,7 +184,7 @@ struct GatherBorrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     idx_vec: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n     location_map: FxHashMap<Location, BorrowIndex>,\n     activation_map: FxHashMap<Location, Vec<BorrowIndex>>,\n-    region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n+    region_map: FxHashMap<RegionVid, FxHashSet<BorrowIndex>>,\n     local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n \n     /// When we encounter a 2-phase borrow statement, it will always\n@@ -219,6 +214,8 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n                 return;\n             }\n \n+            let region = region.to_region_vid();\n+\n             let borrow = BorrowData {\n                 kind,\n                 region,\n@@ -230,7 +227,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n             let idx = self.idx_vec.push(borrow);\n             self.location_map.insert(location, idx);\n \n-            self.insert_as_pending_if_two_phase(location, &assigned_place, region, kind, idx);\n+            self.insert_as_pending_if_two_phase(location, &assigned_place, kind, idx);\n \n             self.region_map.entry(region).or_default().insert(idx);\n             if let Some(local) = borrowed_place.root_local() {\n@@ -314,7 +311,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n             let borrow_data = &self.idx_vec[borrow_index];\n             assert_eq!(borrow_data.reserve_location, location);\n             assert_eq!(borrow_data.kind, kind);\n-            assert_eq!(borrow_data.region, region);\n+            assert_eq!(borrow_data.region, region.to_region_vid());\n             assert_eq!(borrow_data.borrowed_place, *place);\n         }\n \n@@ -347,13 +344,12 @@ impl<'a, 'gcx, 'tcx> GatherBorrows<'a, 'gcx, 'tcx> {\n         &mut self,\n         start_location: Location,\n         assigned_place: &mir::Place<'tcx>,\n-        region: Region<'tcx>,\n         kind: mir::BorrowKind,\n         borrow_index: BorrowIndex,\n     ) {\n         debug!(\n-            \"Borrows::insert_as_pending_if_two_phase({:?}, {:?}, {:?}, {:?})\",\n-            start_location, assigned_place, region, borrow_index,\n+            \"Borrows::insert_as_pending_if_two_phase({:?}, {:?}, {:?})\",\n+            start_location, assigned_place, borrow_index,\n         );\n \n         if !self.allow_two_phase_borrow(kind) {"}, {"sha": "76ba6ae5de6ee99e8586faa2e070b473b5d18a40", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6027e0810ff9f60103d2ff4c24791e40db491316/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6027e0810ff9f60103d2ff4c24791e40db491316/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=6027e0810ff9f60103d2ff4c24791e40db491316", "patch": "@@ -14,7 +14,6 @@ use borrow_check::nll::region_infer::RegionInferenceContext;\n use rustc::hir;\n use rustc::hir::Node;\n use rustc::hir::def_id::DefId;\n-use rustc::hir::map::definitions::DefPathData;\n use rustc::infer::InferCtxt;\n use rustc::lint::builtin::UNUSED_MUT;\n use rustc::middle::borrowck::SignalledError;\n@@ -162,10 +161,6 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         move_data: move_data,\n         param_env: param_env,\n     };\n-    let body_id = match tcx.def_key(def_id).disambiguated_data.data {\n-        DefPathData::StructCtor | DefPathData::EnumVariant(_) => None,\n-        _ => Some(tcx.hir.body_owned_by(id)),\n-    };\n \n     let dead_unwinds = BitSet::new_empty(mir.basic_blocks().len());\n     let mut flow_inits = FlowAtLocation::new(do_dataflow(\n@@ -212,7 +207,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         id,\n         &attributes,\n         &dead_unwinds,\n-        Borrows::new(tcx, mir, regioncx.clone(), def_id, body_id, &borrow_set),\n+        Borrows::new(tcx, mir, regioncx.clone(), &borrow_set),\n         |rs, i| DebugFormatted::new(&rs.location(i)),\n     ));\n     let flow_uninits = FlowAtLocation::new(do_dataflow("}, {"sha": "bb9a29b055b7f849188d76fb44343ad8fa19bfdf", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6027e0810ff9f60103d2ff4c24791e40db491316/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6027e0810ff9f60103d2ff4c24791e40db491316/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=6027e0810ff9f60103d2ff4c24791e40db491316", "patch": "@@ -206,7 +206,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let mir = self.mir;\n         let tcx = self.infcx.tcx;\n \n-        let borrow_region_vid = regioncx.to_region_vid(borrow.region);\n+        let borrow_region_vid = borrow.region;\n         debug!(\n             \"explain_why_borrow_contains_point: borrow_region_vid={:?}\",\n             borrow_region_vid"}, {"sha": "27bc28ac81d8404ba30a42e3a65f62d4670716ae", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 9, "deletions": 82, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/6027e0810ff9f60103d2ff4c24791e40db491316/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6027e0810ff9f60103d2ff4c24791e40db491316/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=6027e0810ff9f60103d2ff4c24791e40db491316", "patch": "@@ -12,18 +12,13 @@ use borrow_check::borrow_set::{BorrowSet, BorrowData};\n use borrow_check::place_ext::PlaceExt;\n \n use rustc;\n-use rustc::hir;\n-use rustc::hir::def_id::DefId;\n-use rustc::middle::region;\n use rustc::mir::{self, Location, Place, Mir};\n use rustc::ty::TyCtxt;\n-use rustc::ty::{RegionKind, RegionVid};\n-use rustc::ty::RegionKind::ReScope;\n+use rustc::ty::RegionVid;\n \n use rustc_data_structures::bit_set::{BitSet, BitSetOperator};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use rustc_data_structures::sync::Lrc;\n \n use dataflow::{BitDenotation, BlockSets, InitialFlow};\n pub use dataflow::indexes::BorrowIndex;\n@@ -42,8 +37,6 @@ use std::rc::Rc;\n pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n-    scope_tree: Lrc<region::ScopeTree>,\n-    root_scope: Option<region::Scope>,\n \n     borrow_set: Rc<BorrowSet<'tcx>>,\n     borrows_out_of_scope_at_location: FxHashMap<Location, Vec<BorrowIndex>>,\n@@ -150,18 +143,8 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         mir: &'a Mir<'tcx>,\n         nonlexical_regioncx: Rc<RegionInferenceContext<'tcx>>,\n-        def_id: DefId,\n-        body_id: Option<hir::BodyId>,\n         borrow_set: &Rc<BorrowSet<'tcx>>,\n     ) -> Self {\n-        let scope_tree = tcx.region_scope_tree(def_id);\n-        let root_scope = body_id.map(|body_id| {\n-            region::Scope {\n-                id: tcx.hir.body(body_id).value.hir_id.local_id,\n-                data: region::ScopeData::CallSite\n-            }\n-        });\n-\n         let mut borrows_out_of_scope_at_location = FxHashMap::default();\n         for (borrow_index, borrow_data) in borrow_set.borrows.iter_enumerated() {\n             let borrow_region = borrow_data.region.to_region_vid();\n@@ -177,8 +160,6 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             mir: mir,\n             borrow_set: borrow_set.clone(),\n             borrows_out_of_scope_at_location,\n-            scope_tree,\n-            root_scope,\n             _nonlexical_regioncx: nonlexical_regioncx,\n         }\n     }\n@@ -277,22 +258,13 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                         panic!(\"could not find BorrowIndex for location {:?}\", location);\n                     });\n \n-                    if let RegionKind::ReEmpty = region {\n-                        // If the borrowed value dies before the borrow is used, the region for\n-                        // the borrow can be empty. Don't track the borrow in that case.\n-                        debug!(\"Borrows::statement_effect_on_borrows \\\n-                                location: {:?} stmt: {:?} has empty region, killing {:?}\",\n-                               location, stmt.kind, index);\n-                        sets.kill(*index);\n-                        return\n-                    } else {\n-                        debug!(\"Borrows::statement_effect_on_borrows location: {:?} stmt: {:?}\",\n-                               location, stmt.kind);\n-                    }\n-\n-                    assert!(self.borrow_set.region_map.get(region).unwrap_or_else(|| {\n-                        panic!(\"could not find BorrowIndexs for region {:?}\", region);\n-                    }).contains(&index));\n+                    assert!(self.borrow_set.region_map\n+                        .get(&region.to_region_vid())\n+                        .unwrap_or_else(|| {\n+                            panic!(\"could not find BorrowIndexs for RegionVid {:?}\", region);\n+                        })\n+                        .contains(&index)\n+                    );\n                     sets.gen(*index);\n \n                     // Issue #46746: Two-phase borrows handles\n@@ -349,52 +321,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n         self.kill_loans_out_of_scope_at_location(sets, location);\n     }\n \n-    fn terminator_effect(&self, sets: &mut BlockSets<BorrowIndex>, location: Location) {\n-        debug!(\"Borrows::terminator_effect sets: {:?} location: {:?}\", sets, location);\n-\n-        let block = &self.mir.basic_blocks().get(location.block).unwrap_or_else(|| {\n-            panic!(\"could not find block at location {:?}\", location);\n-        });\n-\n-        let term = block.terminator();\n-        match term.kind {\n-            mir::TerminatorKind::Resume |\n-            mir::TerminatorKind::Return |\n-            mir::TerminatorKind::GeneratorDrop => {\n-                // When we return from the function, then all `ReScope`-style regions\n-                // are guaranteed to have ended.\n-                // Normally, there would be `EndRegion` statements that come before,\n-                // and hence most of these loans will already be dead -- but, in some cases\n-                // like unwind paths, we do not always emit `EndRegion` statements, so we\n-                // add some kills here as a \"backup\" and to avoid spurious error messages.\n-                for (borrow_index, borrow_data) in self.borrow_set.borrows.iter_enumerated() {\n-                    if let ReScope(scope) = borrow_data.region {\n-                        // Check that the scope is not actually a scope from a function that is\n-                        // a parent of our closure. Note that the CallSite scope itself is\n-                        // *outside* of the closure, for some weird reason.\n-                        if let Some(root_scope) = self.root_scope {\n-                            if *scope != root_scope &&\n-                                self.scope_tree.is_subscope_of(*scope, root_scope)\n-                            {\n-                                sets.kill(borrow_index);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            mir::TerminatorKind::Abort |\n-            mir::TerminatorKind::SwitchInt {..} |\n-            mir::TerminatorKind::Drop {..} |\n-            mir::TerminatorKind::DropAndReplace {..} |\n-            mir::TerminatorKind::Call {..} |\n-            mir::TerminatorKind::Assert {..} |\n-            mir::TerminatorKind::Yield {..} |\n-            mir::TerminatorKind::Goto {..} |\n-            mir::TerminatorKind::FalseEdges {..} |\n-            mir::TerminatorKind::FalseUnwind {..} |\n-            mir::TerminatorKind::Unreachable => {}\n-        }\n-    }\n+    fn terminator_effect(&self, _: &mut BlockSets<BorrowIndex>, _: Location) {}\n \n     fn propagate_call_return(&self,\n                              _in_out: &mut BitSet<BorrowIndex>,"}]}