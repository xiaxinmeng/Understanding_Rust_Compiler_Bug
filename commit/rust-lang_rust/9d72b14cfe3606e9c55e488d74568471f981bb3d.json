{"sha": "9d72b14cfe3606e9c55e488d74568471f981bb3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkNzJiMTRjZmUzNjA2ZTljNTVlNDg4ZDc0NTY4NDcxZjk4MWJiM2Q=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-08-11T11:52:34Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-08-12T19:43:00Z"}, "message": "Normalize assoc types in more places", "tree": {"sha": "52cbccdc40e22adbd9de1e37e0b32f55b1ae887f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52cbccdc40e22adbd9de1e37e0b32f55b1ae887f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d72b14cfe3606e9c55e488d74568471f981bb3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d72b14cfe3606e9c55e488d74568471f981bb3d", "html_url": "https://github.com/rust-lang/rust/commit/9d72b14cfe3606e9c55e488d74568471f981bb3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d72b14cfe3606e9c55e488d74568471f981bb3d/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11b9845afd1daa845ac9d541fd22f1fdf53436c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/11b9845afd1daa845ac9d541fd22f1fdf53436c8", "html_url": "https://github.com/rust-lang/rust/commit/11b9845afd1daa845ac9d541fd22f1fdf53436c8"}], "stats": {"total": 39, "additions": 27, "deletions": 12}, "files": [{"sha": "675df4a22f40afe72aeb8a3f7bee2fb66e23ea18", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9d72b14cfe3606e9c55e488d74568471f981bb3d/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d72b14cfe3606e9c55e488d74568471f981bb3d/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=9d72b14cfe3606e9c55e488d74568471f981bb3d", "patch": "@@ -412,11 +412,18 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         ty\n     }\n \n+    /// Recurses through the given type, normalizing associated types mentioned\n+    /// in it by replacing them by type variables and registering obligations to\n+    /// resolve later. This should be done once for every type we get from some\n+    /// type annotation (e.g. from a let type annotation, field type or function\n+    /// call). `make_ty` handles this already, but e.g. for field types we need\n+    /// to do it as well.\n     fn normalize_associated_types_in(&mut self, ty: Ty) -> Ty {\n+        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n         ty.fold(&mut |ty| match ty {\n             Ty::Projection(proj_ty) => self.normalize_projection_ty(proj_ty),\n             Ty::UnselectedProjection(proj_ty) => {\n-                // FIXME\n+                // FIXME use Chalk's unselected projection support\n                 Ty::UnselectedProjection(proj_ty)\n             }\n             _ => ty,\n@@ -569,6 +576,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let substs = Ty::substs_from_path(self.db, &self.resolver, path, typable);\n                 let ty = ty.subst(&substs);\n                 let ty = self.insert_type_vars(ty);\n+                let ty = self.normalize_associated_types_in(ty);\n                 Some(ty)\n             }\n             Resolution::LocalBinding(pat) => {\n@@ -690,6 +698,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 .and_then(|d| d.field(self.db, &Name::tuple_field_name(i)))\n                 .map_or(Ty::Unknown, |field| field.ty(self.db))\n                 .subst(&substs);\n+            let expected_ty = self.normalize_associated_types_in(expected_ty);\n             self.infer_pat(subpat, &expected_ty, default_bm);\n         }\n \n@@ -717,6 +726,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             let matching_field = def.and_then(|it| it.field(self.db, &subpat.name));\n             let expected_ty =\n                 matching_field.map_or(Ty::Unknown, |field| field.ty(self.db)).subst(&substs);\n+            let expected_ty = self.normalize_associated_types_in(expected_ty);\n             self.infer_pat(subpat.pat, &expected_ty, default_bm);\n         }\n \n@@ -947,9 +957,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.unify(&expected_receiver_ty, &actual_receiver_ty);\n \n         let param_iter = param_tys.into_iter().chain(repeat(Ty::Unknown));\n-        for (arg, param) in args.iter().zip(param_iter) {\n-            self.infer_expr(*arg, &Expectation::has_type(param));\n+        for (arg, param_ty) in args.iter().zip(param_iter) {\n+            let param_ty = self.normalize_associated_types_in(param_ty);\n+            self.infer_expr(*arg, &Expectation::has_type(param_ty));\n         }\n+        let ret_ty = self.normalize_associated_types_in(ret_ty);\n         ret_ty\n     }\n \n@@ -1040,9 +1052,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 };\n                 self.register_obligations_for_call(&callee_ty);\n                 let param_iter = param_tys.into_iter().chain(repeat(Ty::Unknown));\n-                for (arg, param) in args.iter().zip(param_iter) {\n-                    self.infer_expr(*arg, &Expectation::has_type(param));\n+                for (arg, param_ty) in args.iter().zip(param_iter) {\n+                    let param_ty = self.normalize_associated_types_in(param_ty);\n+                    self.infer_expr(*arg, &Expectation::has_type(param_ty));\n                 }\n+                let ret_ty = self.normalize_associated_types_in(ret_ty);\n                 ret_ty\n             }\n             Expr::MethodCall { receiver, args, method_name, generic_args } => self\n@@ -1140,7 +1154,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     _ => None,\n                 })\n                 .unwrap_or(Ty::Unknown);\n-                self.insert_type_vars(ty)\n+                let ty = self.insert_type_vars(ty);\n+                self.normalize_associated_types_in(ty)\n             }\n             Expr::Await { expr } => {\n                 let inner_ty = self.infer_expr(*expr, &Expectation::none());"}, {"sha": "e6a09cc6738cd65e90c8aa17f2a0acc54bb3c089", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9d72b14cfe3606e9c55e488d74568471f981bb3d/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d72b14cfe3606e9c55e488d74568471f981bb3d/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=9d72b14cfe3606e9c55e488d74568471f981bb3d", "patch": "@@ -2515,10 +2515,10 @@ fn test<T: Iterable>() {\n         @r###\"\n    \u22ee\n    \u22ee[108; 227) '{     ...ter; }': ()\n-   \u22ee[118; 119) 'x': <S as Iterable>::Item\n-   \u22ee[145; 146) '1': <S as Iterable>::Item\n-   \u22ee[156; 157) 'y': <T as Iterable>::Item\n-   \u22ee[183; 192) 'no_matter': <T as Iterable>::Item\n+   \u22ee[118; 119) 'x': u32\n+   \u22ee[145; 146) '1': u32\n+   \u22ee[156; 157) 'y': {unknown}\n+   \u22ee[183; 192) 'no_matter': {unknown}\n    \u22ee[202; 203) 'z': {unknown}\n    \u22ee[215; 224) 'no_matter': {unknown}\n     \"###\n@@ -2552,9 +2552,9 @@ fn test() {\n    \u22ee[205; 209) 'foo1': fn foo1<S>(T) -> {unknown}\n    \u22ee[205; 212) 'foo1(S)': {unknown}\n    \u22ee[210; 211) 'S': S\n-   \u22ee[222; 223) 'y': <S as Iterable>::Item\n+   \u22ee[222; 223) 'y': u32\n    \u22ee[226; 230) 'foo2': fn foo2<S>(T) -> <T as Iterable>::Item\n-   \u22ee[226; 233) 'foo2(S)': <S as Iterable>::Item\n+   \u22ee[226; 233) 'foo2(S)': u32\n    \u22ee[231; 232) 'S': S\n     \"###\n     );"}]}