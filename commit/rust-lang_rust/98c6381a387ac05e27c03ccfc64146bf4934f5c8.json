{"sha": "98c6381a387ac05e27c03ccfc64146bf4934f5c8", "node_id": "C_kwDOAAsO6NoAKDk4YzYzODFhMzg3YWMwNWUyN2MwM2NjZmM2NDE0NmJmNDkzNGY1Yzg", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2022-01-06T15:31:38Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2022-01-28T22:02:43Z"}, "message": "Factor out single_segment_path", "tree": {"sha": "a99b7fb0997cf7be9fead5c029b5217595d5370f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a99b7fb0997cf7be9fead5c029b5217595d5370f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98c6381a387ac05e27c03ccfc64146bf4934f5c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98c6381a387ac05e27c03ccfc64146bf4934f5c8", "html_url": "https://github.com/rust-lang/rust/commit/98c6381a387ac05e27c03ccfc64146bf4934f5c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98c6381a387ac05e27c03ccfc64146bf4934f5c8/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "deadc255883a726abee105564bc9a0f65f01e62b", "url": "https://api.github.com/repos/rust-lang/rust/commits/deadc255883a726abee105564bc9a0f65f01e62b", "html_url": "https://github.com/rust-lang/rust/commit/deadc255883a726abee105564bc9a0f65f01e62b"}], "stats": {"total": 86, "additions": 29, "deletions": 57}, "files": [{"sha": "36ecd83f7d643734e0f0f2df0977cd63f3c5ea70", "filename": "clippy_lints/src/loops/single_element_loop.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/98c6381a387ac05e27c03ccfc64146bf4934f5c8/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c6381a387ac05e27c03ccfc64146bf4934f5c8/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs?ref=98c6381a387ac05e27c03ccfc64146bf4934f5c8", "patch": "@@ -1,10 +1,9 @@\n use super::SINGLE_ELEMENT_LOOP;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::single_segment_path;\n-use clippy_utils::source::{indent_of, snippet};\n+use clippy_utils::source::{indent_of, snippet_with_applicability};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{BorrowKind, Expr, ExprKind, Pat, PatKind};\n+use rustc_hir::{BorrowKind, Expr, ExprKind, Pat};\n use rustc_lint::LateContext;\n \n pub(super) fn check<'tcx>(\n@@ -16,33 +15,30 @@ pub(super) fn check<'tcx>(\n ) {\n     let arg_expr = match arg.kind {\n         ExprKind::AddrOf(BorrowKind::Ref, _, ref_arg) => ref_arg,\n-        ExprKind::MethodCall(method, args, _) if args.len() == 1 && method.ident.name == rustc_span::sym::iter => {\n-            &args[0]\n-        },\n+        ExprKind::MethodCall(method, [arg], _) if method.ident.name == rustc_span::sym::iter => arg,\n         _ => return,\n     };\n     if_chain! {\n-        if let PatKind::Binding(.., target, _) = pat.kind;\n         if let ExprKind::Array([arg_expression]) = arg_expr.kind;\n-        if let ExprKind::Path(ref list_item) = arg_expression.kind;\n-        if let Some(list_item_name) = single_segment_path(list_item).map(|ps| ps.ident.name);\n         if let ExprKind::Block(block, _) = body.kind;\n         if !block.stmts.is_empty();\n-\n         then {\n-            let mut block_str = snippet(cx, block.span, \"..\").into_owned();\n+            let mut applicability = Applicability::MachineApplicable;\n+            let pat_snip = snippet_with_applicability(cx, pat.span, \"..\", &mut applicability);\n+            let arg_snip = snippet_with_applicability(cx, arg_expression.span, \"..\", &mut applicability);\n+            let mut block_str = snippet_with_applicability(cx, block.span, \"..\", &mut applicability).into_owned();\n             block_str.remove(0);\n             block_str.pop();\n-\n+            let indent = \" \".repeat(indent_of(cx, block.stmts[0].span).unwrap_or(0));\n \n             span_lint_and_sugg(\n                 cx,\n                 SINGLE_ELEMENT_LOOP,\n                 expr.span,\n                 \"for loop over a single element\",\n                 \"try\",\n-                format!(\"{{\\n{}let {} = &{};{}}}\", \" \".repeat(indent_of(cx, block.stmts[0].span).unwrap_or(0)), target.name, list_item_name, block_str),\n-                Applicability::MachineApplicable\n+                format!(\"{{\\n{}let {} = &{};{}}}\", indent, pat_snip, arg_snip, block_str),\n+                applicability,\n             )\n         }\n     }"}, {"sha": "2cf2c5641bf10654e37c51cfb31171ce62bce223", "filename": "clippy_lints/src/methods/chars_cmp.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/98c6381a387ac05e27c03ccfc64146bf4934f5c8/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c6381a387ac05e27c03ccfc64146bf4934f5c8/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs?ref=98c6381a387ac05e27c03ccfc64146bf4934f5c8", "patch": "@@ -1,13 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{method_chain_args, single_segment_path};\n+use clippy_utils::{method_chain_args, path_def_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_lint::Lint;\n-use rustc_middle::ty;\n-use rustc_span::sym;\n+use rustc_middle::ty::{self, DefIdTree};\n \n /// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints.\n pub(super) fn check(\n@@ -19,11 +18,9 @@ pub(super) fn check(\n ) -> bool {\n     if_chain! {\n         if let Some(args) = method_chain_args(info.chain, chain_methods);\n-        if let hir::ExprKind::Call(fun, arg_char) = info.other.kind;\n-        if arg_char.len() == 1;\n-        if let hir::ExprKind::Path(ref qpath) = fun.kind;\n-        if let Some(segment) = single_segment_path(qpath);\n-        if segment.ident.name == sym::Some;\n+        if let hir::ExprKind::Call(fun, [arg_char]) = info.other.kind;\n+        if let Some(id) = path_def_id(cx, fun).and_then(|ctor_id| cx.tcx.parent(ctor_id));\n+        if Some(id) == cx.tcx.lang_items().option_some_variant();\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n             let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0][0]).peel_refs();\n@@ -42,7 +39,7 @@ pub(super) fn check(\n                         if info.eq { \"\" } else { \"!\" },\n                         snippet_with_applicability(cx, args[0][0].span, \"..\", &mut applicability),\n                         suggest,\n-                        snippet_with_applicability(cx, arg_char[0].span, \"..\", &mut applicability)),\n+                        snippet_with_applicability(cx, arg_char.span, \"..\", &mut applicability)),\n                 applicability,\n             );\n "}, {"sha": "bdf8cea120739f63b1092dc88cafc352cfb0f741", "filename": "clippy_lints/src/methods/option_map_or_none.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/98c6381a387ac05e27c03ccfc64146bf4934f5c8/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c6381a387ac05e27c03ccfc64146bf4934f5c8/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs?ref=98c6381a387ac05e27c03ccfc64146bf4934f5c8", "patch": "@@ -1,11 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_lang_ctor, single_segment_path};\n+use clippy_utils::{is_lang_ctor, path_def_id};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_lint::LateContext;\n+use rustc_middle::ty::DefIdTree;\n use rustc_span::symbol::sym;\n \n use super::OPTION_MAP_OR_NONE;\n@@ -76,13 +77,11 @@ pub(super) fn check<'tcx>(\n         if let hir::ExprKind::Closure(_, _, id, span, _) = map_arg.kind;\n             let arg_snippet = snippet(cx, span, \"..\");\n             let body = cx.tcx.hir().body(id);\n-                if let Some((func, arg_char)) = reduce_unit_expression(cx, &body.value);\n-                if arg_char.len() == 1;\n-                if let hir::ExprKind::Path(ref qpath) = func.kind;\n-                if let Some(segment) = single_segment_path(qpath);\n-                if segment.ident.name == sym::Some;\n+                if let Some((func, [arg_char])) = reduce_unit_expression(cx, &body.value);\n+                if let Some(id) = path_def_id(cx, func).and_then(|ctor_id| cx.tcx.parent(ctor_id));\n+                if Some(id) == cx.tcx.lang_items().option_some_variant();\n                 then {\n-                    let func_snippet = snippet(cx, arg_char[0].span, \"..\");\n+                    let func_snippet = snippet(cx, arg_char.span, \"..\");\n                     let msg = \"called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling \\\n                        `map(..)` instead\";\n                     return span_lint_and_sugg("}, {"sha": "e213c208794c1d4d0dd43c6a995de040b99bfa9a", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/98c6381a387ac05e27c03ccfc64146bf4934f5c8/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c6381a387ac05e27c03ccfc64146bf4934f5c8/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=98c6381a387ac05e27c03ccfc64146bf4934f5c8", "patch": "@@ -2,19 +2,18 @@ use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::{snippet, snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::{get_parent_expr, in_constant, is_integer_const, meets_msrv, msrvs, single_segment_path};\n+use clippy_utils::{get_parent_expr, in_constant, is_integer_const, meets_msrv, msrvs, path_to_local};\n use clippy_utils::{higher, SpanlessEq};\n use if_chain::if_chain;\n use rustc_ast::ast::RangeLimits;\n use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Expr, ExprKind, PathSegment, QPath};\n+use rustc_hir::{BinOpKind, Expr, ExprKind, HirId, PathSegment, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::{Span, Spanned};\n use rustc_span::sym;\n-use rustc_span::symbol::Ident;\n use std::cmp::Ordering;\n \n declare_clippy_lint! {\n@@ -220,12 +219,12 @@ fn check_possible_range_contains(cx: &LateContext<'_>, op: BinOpKind, l: &Expr<'\n         _ => return,\n     };\n     // value, name, order (higher/lower), inclusiveness\n-    if let (Some((lval, lname, name_span, lval_span, lord, linc)), Some((rval, rname, _, rval_span, rord, rinc))) =\n+    if let (Some((lval, lid, name_span, lval_span, lord, linc)), Some((rval, rid, _, rval_span, rord, rinc))) =\n         (check_range_bounds(cx, l), check_range_bounds(cx, r))\n     {\n         // we only lint comparisons on the same name and with different\n         // direction\n-        if lname != rname || lord == rord {\n+        if lid != rid || lord == rord {\n             return;\n         }\n         let ord = Constant::partial_cmp(cx.tcx, cx.typeck_results().expr_ty(l), &lval, &rval);\n@@ -293,7 +292,7 @@ fn check_possible_range_contains(cx: &LateContext<'_>, op: BinOpKind, l: &Expr<'\n     }\n }\n \n-fn check_range_bounds(cx: &LateContext<'_>, ex: &Expr<'_>) -> Option<(Constant, Ident, Span, Span, Ordering, bool)> {\n+fn check_range_bounds(cx: &LateContext<'_>, ex: &Expr<'_>) -> Option<(Constant, HirId, Span, Span, Ordering, bool)> {\n     if let ExprKind::Binary(ref op, l, r) = ex.kind {\n         let (inclusive, ordering) = match op.node {\n             BinOpKind::Gt => (false, Ordering::Greater),\n@@ -302,11 +301,11 @@ fn check_range_bounds(cx: &LateContext<'_>, ex: &Expr<'_>) -> Option<(Constant,\n             BinOpKind::Le => (true, Ordering::Less),\n             _ => return None,\n         };\n-        if let Some(id) = match_ident(l) {\n+        if let Some(id) = path_to_local(l) {\n             if let Some((c, _)) = constant(cx, cx.typeck_results(), r) {\n                 return Some((c, id, l.span, r.span, ordering, inclusive));\n             }\n-        } else if let Some(id) = match_ident(r) {\n+        } else if let Some(id) = path_to_local(r) {\n             if let Some((c, _)) = constant(cx, cx.typeck_results(), l) {\n                 return Some((c, id, r.span, l.span, ordering.reverse(), inclusive));\n             }\n@@ -315,17 +314,6 @@ fn check_range_bounds(cx: &LateContext<'_>, ex: &Expr<'_>) -> Option<(Constant,\n     None\n }\n \n-fn match_ident(e: &Expr<'_>) -> Option<Ident> {\n-    if let ExprKind::Path(ref qpath) = e.kind {\n-        if let Some(seg) = single_segment_path(qpath) {\n-            if seg.args.is_none() {\n-                return Some(seg.ident);\n-            }\n-        }\n-    }\n-    None\n-}\n-\n fn check_range_zip_with_len(cx: &LateContext<'_>, path: &PathSegment<'_>, args: &[Expr<'_>], span: Span) {\n     if_chain! {\n         if path.ident.as_str() == \"zip\";"}, {"sha": "3df7af601cf7ff937464d497dcbe806ed26ae339", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/98c6381a387ac05e27c03ccfc64146bf4934f5c8/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c6381a387ac05e27c03ccfc64146bf4934f5c8/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=98c6381a387ac05e27c03ccfc64146bf4934f5c8", "patch": "@@ -326,14 +326,6 @@ pub fn qpath_generic_tys<'tcx>(qpath: &QPath<'tcx>) -> impl Iterator<Item = &'tc\n         })\n }\n \n-pub fn single_segment_path<'tcx>(path: &QPath<'tcx>) -> Option<&'tcx PathSegment<'tcx>> {\n-    match *path {\n-        QPath::Resolved(_, path) => path.segments.get(0),\n-        QPath::TypeRelative(_, seg) => Some(seg),\n-        QPath::LangItem(..) => None,\n-    }\n-}\n-\n /// THIS METHOD IS DEPRECATED and will eventually be removed since it does not match against the\n /// entire path or resolved `DefId`. Prefer using `match_def_path`. Consider getting a `DefId` from\n /// `QPath::Resolved.1.res.opt_def_id()`."}]}