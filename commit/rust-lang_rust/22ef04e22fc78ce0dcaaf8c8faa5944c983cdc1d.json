{"sha": "22ef04e22fc78ce0dcaaf8c8faa5944c983cdc1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyZWYwNGUyMmZjNzhjZTBkY2FhZjhjOGZhYTU5NDRjOTgzY2RjMWQ=", "commit": {"author": {"name": "jackh726", "email": "jack.huey@umassmed.edu", "date": "2021-08-15T08:17:36Z"}, "committer": {"name": "jackh726", "email": "jack.huey@umassmed.edu", "date": "2021-09-07T22:25:57Z"}, "message": "A bit of cleanup to astconv", "tree": {"sha": "9d734e51862656f47ca0d6ad15a56e74ec30351b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d734e51862656f47ca0d6ad15a56e74ec30351b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22ef04e22fc78ce0dcaaf8c8faa5944c983cdc1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22ef04e22fc78ce0dcaaf8c8faa5944c983cdc1d", "html_url": "https://github.com/rust-lang/rust/commit/22ef04e22fc78ce0dcaaf8c8faa5944c983cdc1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22ef04e22fc78ce0dcaaf8c8faa5944c983cdc1d/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "216906fb75a7211f7905d3b37274c6b6ec331295", "url": "https://api.github.com/repos/rust-lang/rust/commits/216906fb75a7211f7905d3b37274c6b6ec331295", "html_url": "https://github.com/rust-lang/rust/commit/216906fb75a7211f7905d3b37274c6b6ec331295"}], "stats": {"total": 415, "additions": 181, "deletions": 234}, "files": [{"sha": "51bb09e4c54ba29bebcf1a8356bb01a9a6fc9587", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 118, "deletions": 87, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/22ef04e22fc78ce0dcaaf8c8faa5944c983cdc1d/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ef04e22fc78ce0dcaaf8c8faa5944c983cdc1d/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=22ef04e22fc78ce0dcaaf8c8faa5944c983cdc1d", "patch": "@@ -693,6 +693,61 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         )\n     }\n \n+    fn instantiate_poly_trait_ref_inner(\n+        &self,\n+        hir_id: hir::HirId,\n+        span: Span,\n+        binding_span: Option<Span>,\n+        constness: ty::BoundConstness,\n+        bounds: &mut Bounds<'tcx>,\n+        speculative: bool,\n+        trait_ref_span: Span,\n+        trait_def_id: DefId,\n+        trait_segment: &hir::PathSegment<'_>,\n+        args: &GenericArgs<'_>,\n+        infer_args: bool,\n+        self_ty: Ty<'tcx>,\n+    ) -> GenericArgCountResult {\n+        let (substs, arg_count) = self.create_substs_for_ast_path(\n+            trait_ref_span,\n+            trait_def_id,\n+            &[],\n+            trait_segment,\n+            args,\n+            infer_args,\n+            Some(self_ty),\n+        );\n+\n+        let tcx = self.tcx();\n+        let bound_vars = tcx.late_bound_vars(hir_id);\n+        debug!(?bound_vars);\n+\n+        let assoc_bindings = self.create_assoc_bindings_for_generic_args(args);\n+\n+        let poly_trait_ref =\n+            ty::Binder::bind_with_vars(ty::TraitRef::new(trait_def_id, substs), bound_vars);\n+\n+        debug!(?poly_trait_ref, ?assoc_bindings);\n+        bounds.trait_bounds.push((poly_trait_ref, span, constness));\n+\n+        let mut dup_bindings = FxHashMap::default();\n+        for binding in &assoc_bindings {\n+            // Specify type to assert that error was already reported in `Err` case.\n+            let _: Result<_, ErrorReported> = self.add_predicates_for_ast_type_binding(\n+                hir_id,\n+                poly_trait_ref,\n+                binding,\n+                bounds,\n+                speculative,\n+                &mut dup_bindings,\n+                binding_span.unwrap_or(binding.span),\n+            );\n+            // Okay to ignore `Err` because of `ErrorReported` (see above).\n+        }\n+\n+        arg_count\n+    }\n+\n     /// Given a trait bound like `Debug`, applies that trait bound the given self-type to construct\n     /// a full trait reference. The resulting trait reference is returned. This may also generate\n     /// auxiliary bounds, which are added to `bounds`.\n@@ -713,7 +768,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// `Bar<'a>`. The returned poly-trait-ref will have this binder instantiated explicitly,\n     /// however.\n     #[tracing::instrument(level = \"debug\", skip(self, span, constness, bounds, speculative))]\n-    pub fn instantiate_poly_trait_ref(\n+    pub(crate) fn instantiate_poly_trait_ref(\n         &self,\n         trait_ref: &hir::TraitRef<'_>,\n         span: Span,\n@@ -722,48 +777,34 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         bounds: &mut Bounds<'tcx>,\n         speculative: bool,\n     ) -> GenericArgCountResult {\n+        let hir_id = trait_ref.hir_ref_id;\n+        let binding_span = None;\n+        let trait_ref_span = trait_ref.path.span;\n         let trait_def_id = trait_ref.trait_def_id().unwrap_or_else(|| FatalError.raise());\n+        let trait_segment = trait_ref.path.segments.last().unwrap();\n+        let args = trait_segment.args();\n+        let infer_args = trait_segment.infer_args;\n \n         self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1);\n+        self.complain_about_internal_fn_trait(span, trait_def_id, trait_segment);\n \n-        let tcx = self.tcx();\n-        let bound_vars = tcx.late_bound_vars(trait_ref.hir_ref_id);\n-        debug!(?bound_vars);\n-\n-        let (substs, arg_count) = self.create_substs_for_ast_trait_ref(\n-            trait_ref.path.span,\n+        self.instantiate_poly_trait_ref_inner(\n+            hir_id,\n+            span,\n+            binding_span,\n+            constness,\n+            bounds,\n+            speculative,\n+            trait_ref_span,\n             trait_def_id,\n+            trait_segment,\n+            args,\n+            infer_args,\n             self_ty,\n-            trait_ref.path.segments.last().unwrap(),\n-        );\n-        let assoc_bindings = self\n-            .create_assoc_bindings_for_generic_args(trait_ref.path.segments.last().unwrap().args());\n-\n-        let poly_trait_ref =\n-            ty::Binder::bind_with_vars(ty::TraitRef::new(trait_def_id, substs), bound_vars);\n-\n-        debug!(?poly_trait_ref, ?assoc_bindings);\n-        bounds.trait_bounds.push((poly_trait_ref, span, constness));\n-\n-        let mut dup_bindings = FxHashMap::default();\n-        for binding in &assoc_bindings {\n-            // Specify type to assert that error was already reported in `Err` case.\n-            let _: Result<_, ErrorReported> = self.add_predicates_for_ast_type_binding(\n-                trait_ref.hir_ref_id,\n-                poly_trait_ref,\n-                binding,\n-                bounds,\n-                speculative,\n-                &mut dup_bindings,\n-                binding.span,\n-            );\n-            // Okay to ignore `Err` because of `ErrorReported` (see above).\n-        }\n-\n-        arg_count\n+        )\n     }\n \n-    pub fn instantiate_lang_item_trait_ref(\n+    pub(crate) fn instantiate_lang_item_trait_ref(\n         &self,\n         lang_item: hir::LangItem,\n         span: Span,\n@@ -772,36 +813,28 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self_ty: Ty<'tcx>,\n         bounds: &mut Bounds<'tcx>,\n     ) {\n+        let binding_span = Some(span);\n+        let constness = ty::BoundConstness::NotConst;\n+        let speculative = false;\n+        let trait_ref_span = span;\n         let trait_def_id = self.tcx().require_lang_item(lang_item, Some(span));\n+        let trait_segment = &hir::PathSegment::invalid();\n+        let infer_args = false;\n \n-        let (substs, _) = self.create_substs_for_ast_path(\n+        self.instantiate_poly_trait_ref_inner(\n+            hir_id,\n             span,\n+            binding_span,\n+            constness,\n+            bounds,\n+            speculative,\n+            trait_ref_span,\n             trait_def_id,\n-            &[],\n-            &hir::PathSegment::invalid(),\n+            trait_segment,\n             args,\n-            false,\n-            Some(self_ty),\n+            infer_args,\n+            self_ty,\n         );\n-        let assoc_bindings = self.create_assoc_bindings_for_generic_args(args);\n-        let tcx = self.tcx();\n-        let bound_vars = tcx.late_bound_vars(hir_id);\n-        let poly_trait_ref =\n-            ty::Binder::bind_with_vars(ty::TraitRef::new(trait_def_id, substs), bound_vars);\n-        bounds.trait_bounds.push((poly_trait_ref, span, ty::BoundConstness::NotConst));\n-\n-        let mut dup_bindings = FxHashMap::default();\n-        for binding in assoc_bindings {\n-            let _: Result<_, ErrorReported> = self.add_predicates_for_ast_type_binding(\n-                hir_id,\n-                poly_trait_ref,\n-                &binding,\n-                bounds,\n-                false,\n-                &mut dup_bindings,\n-                span,\n-            );\n-        }\n     }\n \n     fn ast_path_to_mono_trait_ref(\n@@ -935,45 +968,43 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// **A note on binders:** there is an implied binder around\n     /// `param_ty` and `ast_bounds`. See `instantiate_poly_trait_ref`\n     /// for more details.\n-    #[tracing::instrument(level = \"debug\", skip(self, bounds))]\n-    fn add_bounds(\n+    #[tracing::instrument(level = \"debug\", skip(self, ast_bounds, bounds))]\n+    pub(crate) fn add_bounds<'hir, I: Iterator<Item = &'hir hir::GenericBound<'hir>>>(\n         &self,\n         param_ty: Ty<'tcx>,\n-        ast_bounds: &[hir::GenericBound<'_>],\n+        ast_bounds: I,\n         bounds: &mut Bounds<'tcx>,\n         bound_vars: &'tcx ty::List<ty::BoundVariableKind>,\n     ) {\n         for ast_bound in ast_bounds {\n-            match *ast_bound {\n-                hir::GenericBound::Trait(ref b, hir::TraitBoundModifier::None) => {\n-                    self.instantiate_poly_trait_ref(\n-                        &b.trait_ref,\n-                        b.span,\n-                        ty::BoundConstness::NotConst,\n+            match ast_bound {\n+                hir::GenericBound::Trait(poly_trait_ref, modifier) => {\n+                    let constness = match modifier {\n+                        hir::TraitBoundModifier::MaybeConst => ty::BoundConstness::ConstIfConst,\n+                        hir::TraitBoundModifier::None => ty::BoundConstness::NotConst,\n+                        hir::TraitBoundModifier::Maybe => continue,\n+                    };\n+\n+                    let _ = self.instantiate_poly_trait_ref(\n+                        &poly_trait_ref.trait_ref,\n+                        poly_trait_ref.span,\n+                        constness,\n                         param_ty,\n                         bounds,\n                         false,\n                     );\n                 }\n-                hir::GenericBound::Trait(ref b, hir::TraitBoundModifier::MaybeConst) => {\n-                    self.instantiate_poly_trait_ref(\n-                        &b.trait_ref,\n-                        b.span,\n-                        ty::BoundConstness::ConstIfConst,\n-                        param_ty,\n-                        bounds,\n-                        false,\n+                &hir::GenericBound::LangItemTrait(lang_item, span, hir_id, args) => {\n+                    self.instantiate_lang_item_trait_ref(\n+                        lang_item, span, hir_id, args, param_ty, bounds,\n                     );\n                 }\n-                hir::GenericBound::Trait(_, hir::TraitBoundModifier::Maybe) => {}\n-                hir::GenericBound::LangItemTrait(lang_item, span, hir_id, args) => self\n-                    .instantiate_lang_item_trait_ref(\n-                        lang_item, span, hir_id, args, param_ty, bounds,\n-                    ),\n-                hir::GenericBound::Outlives(ref l) => bounds.region_bounds.push((\n-                    ty::Binder::bind_with_vars(self.ast_region_to_region(l, None), bound_vars),\n-                    l.span,\n-                )),\n+                hir::GenericBound::Outlives(lifetime) => {\n+                    let region = self.ast_region_to_region(lifetime, None);\n+                    bounds\n+                        .region_bounds\n+                        .push((ty::Binder::bind_with_vars(region, bound_vars), lifetime.span));\n+                }\n             }\n         }\n     }\n@@ -1032,7 +1063,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     ) -> Bounds<'tcx> {\n         let mut bounds = Bounds::default();\n \n-        self.add_bounds(param_ty, ast_bounds, &mut bounds, ty::List::empty());\n+        self.add_bounds(param_ty, ast_bounds.iter(), &mut bounds, ty::List::empty());\n \n         bounds\n     }\n@@ -1224,7 +1255,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // Calling `skip_binder` is okay, because `add_bounds` expects the `param_ty`\n                 // parameter to have a skipped binder.\n                 let param_ty = tcx.mk_ty(ty::Projection(projection_ty.skip_binder()));\n-                self.add_bounds(param_ty, ast_bounds, bounds, candidate.bound_vars());\n+                self.add_bounds(param_ty, ast_bounds.iter(), bounds, candidate.bound_vars());\n             }\n         }\n         Ok(())"}, {"sha": "3688fa05e038eb2948da4152ded88e55e01aabd5", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 17, "deletions": 94, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/22ef04e22fc78ce0dcaaf8c8faa5944c983cdc1d/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ef04e22fc78ce0dcaaf8c8faa5944c983cdc1d/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=22ef04e22fc78ce0dcaaf8c8faa5944c983cdc1d", "patch": "@@ -2220,62 +2220,15 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                     }\n                 }\n \n-                for bound in bound_pred.bounds.iter() {\n-                    match bound {\n-                        hir::GenericBound::Trait(poly_trait_ref, modifier) => {\n-                            let constness = match modifier {\n-                                hir::TraitBoundModifier::None => ty::BoundConstness::NotConst,\n-                                hir::TraitBoundModifier::MaybeConst => {\n-                                    ty::BoundConstness::ConstIfConst\n-                                }\n-                                // We ignore `where T: ?Sized`, it is already part of\n-                                // type parameter `T`.\n-                                hir::TraitBoundModifier::Maybe => continue,\n-                            };\n-\n-                            let mut bounds = Bounds::default();\n-                            let _ = <dyn AstConv<'_>>::instantiate_poly_trait_ref(\n-                                &icx,\n-                                &poly_trait_ref.trait_ref,\n-                                poly_trait_ref.span,\n-                                constness,\n-                                ty,\n-                                &mut bounds,\n-                                false,\n-                            );\n-                            predicates.extend(bounds.predicates(tcx, ty));\n-                        }\n-\n-                        &hir::GenericBound::LangItemTrait(lang_item, span, hir_id, args) => {\n-                            let mut bounds = Bounds::default();\n-                            <dyn AstConv<'_>>::instantiate_lang_item_trait_ref(\n-                                &icx,\n-                                lang_item,\n-                                span,\n-                                hir_id,\n-                                args,\n-                                ty,\n-                                &mut bounds,\n-                            );\n-                            predicates.extend(bounds.predicates(tcx, ty));\n-                        }\n-\n-                        hir::GenericBound::Outlives(lifetime) => {\n-                            let region =\n-                                <dyn AstConv<'_>>::ast_region_to_region(&icx, lifetime, None);\n-                            predicates.insert((\n-                                ty::Binder::bind_with_vars(\n-                                    ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n-                                        ty, region,\n-                                    )),\n-                                    bound_vars,\n-                                )\n-                                .to_predicate(tcx),\n-                                lifetime.span,\n-                            ));\n-                        }\n-                    }\n-                }\n+                let mut bounds = Bounds::default();\n+                <dyn AstConv<'_>>::add_bounds(\n+                    &icx,\n+                    ty,\n+                    bound_pred.bounds.iter(),\n+                    &mut bounds,\n+                    bound_vars,\n+                );\n+                predicates.extend(bounds.predicates(tcx, ty));\n             }\n \n             hir::WherePredicate::RegionPredicate(region_pred) => {\n@@ -2489,44 +2442,14 @@ fn predicates_from_bound<'tcx>(\n     param_ty: Ty<'tcx>,\n     bound: &'tcx hir::GenericBound<'tcx>,\n ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n-    match *bound {\n-        hir::GenericBound::Trait(ref tr, modifier) => {\n-            let constness = match modifier {\n-                hir::TraitBoundModifier::Maybe => return vec![],\n-                hir::TraitBoundModifier::MaybeConst => ty::BoundConstness::ConstIfConst,\n-                hir::TraitBoundModifier::None => ty::BoundConstness::NotConst,\n-            };\n-\n-            let mut bounds = Bounds::default();\n-            let _ = astconv.instantiate_poly_trait_ref(\n-                &tr.trait_ref,\n-                tr.span,\n-                constness,\n-                param_ty,\n-                &mut bounds,\n-                false,\n-            );\n-            bounds.predicates(astconv.tcx(), param_ty)\n-        }\n-        hir::GenericBound::LangItemTrait(lang_item, span, hir_id, args) => {\n-            let mut bounds = Bounds::default();\n-            astconv.instantiate_lang_item_trait_ref(\n-                lang_item,\n-                span,\n-                hir_id,\n-                args,\n-                param_ty,\n-                &mut bounds,\n-            );\n-            bounds.predicates(astconv.tcx(), param_ty)\n-        }\n-        hir::GenericBound::Outlives(ref lifetime) => {\n-            let region = astconv.ast_region_to_region(lifetime, None);\n-            let pred = ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(param_ty, region))\n-                .to_predicate(astconv.tcx());\n-            vec![(pred, lifetime.span)]\n-        }\n-    }\n+    let mut bounds = Bounds::default();\n+    astconv.add_bounds(\n+        param_ty,\n+        std::array::IntoIter::new([bound]),\n+        &mut bounds,\n+        ty::List::empty(),\n+    );\n+    bounds.predicates(astconv.tcx(), param_ty)\n }\n \n fn compute_sig_of_foreign_fn_decl<'tcx>("}, {"sha": "a95300217ab75edab1c4d3125bbf9d70dff6f95f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/22ef04e22fc78ce0dcaaf8c8faa5944c983cdc1d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ef04e22fc78ce0dcaaf8c8faa5944c983cdc1d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=22ef04e22fc78ce0dcaaf8c8faa5944c983cdc1d", "patch": "@@ -129,7 +129,6 @@ impl Clean<GenericBound> for hir::GenericBound<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> GenericBound {\n         match *self {\n             hir::GenericBound::Outlives(lt) => GenericBound::Outlives(lt.clean(cx)),\n-            hir::GenericBound::Unsized(_) => GenericBound::maybe_sized(cx),\n             hir::GenericBound::LangItemTrait(lang_item, span, _, generic_args) => {\n                 let def_id = cx.tcx.require_lang_item(lang_item, Some(span));\n \n@@ -557,19 +556,13 @@ impl Clean<Generics> for hir::Generics<'_> {\n                 WherePredicate::BoundPredicate {\n                     ty: Generic(ref name), ref mut bounds, ..\n                 } => {\n-                    if let [] | [GenericBound::TraitBound(_, hir::TraitBoundModifier::Maybe)] =\n-                        &bounds[..]\n-                    {\n+                    if bounds.is_empty() {\n                         for param in &mut generics.params {\n                             match param.kind {\n                                 GenericParamDefKind::Lifetime { .. } => {}\n                                 GenericParamDefKind::Type { bounds: ref mut ty_bounds, .. } => {\n                                     if &param.name == name {\n                                         mem::swap(bounds, ty_bounds);\n-                                        // We now keep track of `?Sized` obligations in the HIR.\n-                                        // If we don't clear `ty_bounds` we end up with\n-                                        // `fn foo<X: ?Sized>(_: X) where X: ?Sized`.\n-                                        ty_bounds.clear();\n                                         break;\n                                     }\n                                 }"}, {"sha": "6a1a502749a75eb1e58320688e8f369b15c60768", "filename": "src/test/ui/error-codes/e0119/complex-impl.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22ef04e22fc78ce0dcaaf8c8faa5944c983cdc1d/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fcomplex-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22ef04e22fc78ce0dcaaf8c8faa5944c983cdc1d/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fcomplex-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fcomplex-impl.stderr?ref=22ef04e22fc78ce0dcaaf8c8faa5944c983cdc1d", "patch": "@@ -6,7 +6,7 @@ LL | impl<R> External for (Q, R) {}\n    |\n    = note: conflicting implementation in crate `complex_impl_support`:\n            - impl<'a, 'b, 'c, T, U, V, W> External for (T, M<'a, 'b, 'c, Box<U>, V, W>)\n-             where <U as FnOnce<(T,)>>::Output == V, <V as Iterator>::Item == T, 'b: 'a, T: 'a, U: FnOnce<(T,)>, U: 'static, V: Iterator, V: Clone, W: Add, <W as Add>::Output: Copy;\n+             where <U as FnOnce<(T,)>>::Output == V, <V as Iterator>::Item == T, 'b: 'a, T: 'a, U: 'static, U: FnOnce<(T,)>, V: Iterator, V: Clone, W: Add, <W as Add>::Output: Copy;\n \n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n   --> $DIR/complex-impl.rs:9:1"}, {"sha": "22da0dffbf29eb87cf51d02eafa70ea5f6766338", "filename": "src/test/ui/generics/wrong-number-of-args.stderr", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/22ef04e22fc78ce0dcaaf8c8faa5944c983cdc1d/src%2Ftest%2Fui%2Fgenerics%2Fwrong-number-of-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22ef04e22fc78ce0dcaaf8c8faa5944c983cdc1d/src%2Ftest%2Fui%2Fgenerics%2Fwrong-number-of-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerics%2Fwrong-number-of-args.stderr?ref=22ef04e22fc78ce0dcaaf8c8faa5944c983cdc1d", "patch": "@@ -440,17 +440,6 @@ note: trait defined here, with 1 lifetime parameter: `'a`\n LL |         trait GenericLifetimeAT<'a> {\n    |               ^^^^^^^^^^^^^^^^^ --\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/wrong-number-of-args.rs:169:44\n-   |\n-LL |         type C = Box<dyn GenericLifetimeAT<(), AssocTy=()>>;\n-   |                                            ^ expected named lifetime parameter\n-   |\n-help: consider introducing a named lifetime parameter\n-   |\n-LL |         type C<'a> = Box<dyn GenericLifetimeAT<'a, (), AssocTy=()>>;\n-   |               ++++                             +++\n-\n error[E0107]: this trait takes 0 generic arguments but 1 generic argument was supplied\n   --> $DIR/wrong-number-of-args.rs:169:26\n    |\n@@ -465,6 +454,17 @@ note: trait defined here, with 0 generic parameters\n LL |         trait GenericLifetimeAT<'a> {\n    |               ^^^^^^^^^^^^^^^^^\n \n+error[E0106]: missing lifetime specifier\n+  --> $DIR/wrong-number-of-args.rs:169:44\n+   |\n+LL |         type C = Box<dyn GenericLifetimeAT<(), AssocTy=()>>;\n+   |                                            ^ expected named lifetime parameter\n+   |\n+help: consider introducing a named lifetime parameter\n+   |\n+LL |         type C<'a> = Box<dyn GenericLifetimeAT<'a, (), AssocTy=()>>;\n+   |               ++++                             +++\n+\n error[E0107]: this trait takes 1 generic argument but 0 generic arguments were supplied\n   --> $DIR/wrong-number-of-args.rs:181:26\n    |\n@@ -525,17 +525,6 @@ help: add missing generic argument\n LL |         type C = Box<dyn GenericTypeAT<'static, A, AssocTy=()>>;\n    |                                               +++\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/wrong-number-of-args.rs:201:48\n-   |\n-LL |         type A = Box<dyn GenericLifetimeTypeAT<AssocTy=()>>;\n-   |                                                ^ expected named lifetime parameter\n-   |\n-help: consider introducing a named lifetime parameter\n-   |\n-LL |         type A<'a> = Box<dyn GenericLifetimeTypeAT<'a, AssocTy=()>>;\n-   |               ++++                                 +++\n-\n error[E0107]: this trait takes 1 generic argument but 0 generic arguments were supplied\n   --> $DIR/wrong-number-of-args.rs:201:26\n    |\n@@ -552,6 +541,17 @@ help: add missing generic argument\n LL |         type A = Box<dyn GenericLifetimeTypeAT<A, AssocTy=()>>;\n    |                                                ++\n \n+error[E0106]: missing lifetime specifier\n+  --> $DIR/wrong-number-of-args.rs:201:48\n+   |\n+LL |         type A = Box<dyn GenericLifetimeTypeAT<AssocTy=()>>;\n+   |                                                ^ expected named lifetime parameter\n+   |\n+help: consider introducing a named lifetime parameter\n+   |\n+LL |         type A<'a> = Box<dyn GenericLifetimeTypeAT<'a, AssocTy=()>>;\n+   |               ++++                                 +++\n+\n error[E0107]: this trait takes 1 generic argument but 0 generic arguments were supplied\n   --> $DIR/wrong-number-of-args.rs:207:26\n    |\n@@ -609,17 +609,6 @@ help: consider introducing a named lifetime parameter\n LL |         type D<'a> = Box<dyn GenericLifetimeTypeAT<'a, (), AssocTy=()>>;\n    |               ++++                                 +++\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/wrong-number-of-args.rs:221:48\n-   |\n-LL |         type E = Box<dyn GenericLifetimeTypeAT<(), (), AssocTy=()>>;\n-   |                                                ^ expected named lifetime parameter\n-   |\n-help: consider introducing a named lifetime parameter\n-   |\n-LL |         type E<'a> = Box<dyn GenericLifetimeTypeAT<'a, (), (), AssocTy=()>>;\n-   |               ++++                                 +++\n-\n error[E0107]: this trait takes 1 generic argument but 2 generic arguments were supplied\n   --> $DIR/wrong-number-of-args.rs:221:26\n    |\n@@ -634,6 +623,17 @@ note: trait defined here, with 1 generic parameter: `A`\n LL |         trait GenericLifetimeTypeAT<'a, A> {\n    |               ^^^^^^^^^^^^^^^^^^^^^     -\n \n+error[E0106]: missing lifetime specifier\n+  --> $DIR/wrong-number-of-args.rs:221:48\n+   |\n+LL |         type E = Box<dyn GenericLifetimeTypeAT<(), (), AssocTy=()>>;\n+   |                                                ^ expected named lifetime parameter\n+   |\n+help: consider introducing a named lifetime parameter\n+   |\n+LL |         type E<'a> = Box<dyn GenericLifetimeTypeAT<'a, (), (), AssocTy=()>>;\n+   |               ++++                                 +++\n+\n error[E0107]: this trait takes 1 lifetime argument but 2 lifetime arguments were supplied\n   --> $DIR/wrong-number-of-args.rs:227:26\n    |\n@@ -767,17 +767,6 @@ help: add missing lifetime argument\n LL |         type B = Box<dyn GenericLifetimeLifetimeAT<'static, 'b, AssocTy=()>>;\n    |                                                           ++++\n \n-error[E0106]: missing lifetime specifiers\n-  --> $DIR/wrong-number-of-args.rs:279:56\n-   |\n-LL |         type A = Box<dyn GenericLifetimeLifetimeTypeAT<AssocTy=()>>;\n-   |                                                        ^ expected 2 lifetime parameters\n-   |\n-help: consider introducing a named lifetime parameter\n-   |\n-LL |         type A<'a> = Box<dyn GenericLifetimeLifetimeTypeAT<'a, 'a, AssocTy=()>>;\n-   |               ++++                                         +++++++\n-\n error[E0107]: this trait takes 1 generic argument but 0 generic arguments were supplied\n   --> $DIR/wrong-number-of-args.rs:279:26\n    |\n@@ -794,6 +783,17 @@ help: add missing generic argument\n LL |         type A = Box<dyn GenericLifetimeLifetimeTypeAT<A, AssocTy=()>>;\n    |                                                        ++\n \n+error[E0106]: missing lifetime specifiers\n+  --> $DIR/wrong-number-of-args.rs:279:56\n+   |\n+LL |         type A = Box<dyn GenericLifetimeLifetimeTypeAT<AssocTy=()>>;\n+   |                                                        ^ expected 2 lifetime parameters\n+   |\n+help: consider introducing a named lifetime parameter\n+   |\n+LL |         type A<'a> = Box<dyn GenericLifetimeLifetimeTypeAT<'a, 'a, AssocTy=()>>;\n+   |               ++++                                         +++++++\n+\n error[E0107]: this trait takes 2 lifetime arguments but 1 lifetime argument was supplied\n   --> $DIR/wrong-number-of-args.rs:285:26\n    |"}]}