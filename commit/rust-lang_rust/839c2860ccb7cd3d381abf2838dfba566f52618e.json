{"sha": "839c2860ccb7cd3d381abf2838dfba566f52618e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzOWMyODYwY2NiN2NkM2QzODFhYmYyODM4ZGZiYTU2NmY1MjYxOGU=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-03-08T23:13:35Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-03-14T04:39:21Z"}, "message": "Liberalize attributes.", "tree": {"sha": "de9b57f15703328322a174cb820ba1e97bd29bba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de9b57f15703328322a174cb820ba1e97bd29bba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/839c2860ccb7cd3d381abf2838dfba566f52618e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/839c2860ccb7cd3d381abf2838dfba566f52618e", "html_url": "https://github.com/rust-lang/rust/commit/839c2860ccb7cd3d381abf2838dfba566f52618e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/839c2860ccb7cd3d381abf2838dfba566f52618e/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68c1cc68b44bb987ec57251bc457a55292515d1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/68c1cc68b44bb987ec57251bc457a55292515d1d", "html_url": "https://github.com/rust-lang/rust/commit/68c1cc68b44bb987ec57251bc457a55292515d1d"}], "stats": {"total": 429, "additions": 257, "deletions": 172}, "files": [{"sha": "bf7115abd4edd230fd7bc624431745c557ed6ce6", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=839c2860ccb7cd3d381abf2838dfba566f52618e", "patch": "@@ -1165,6 +1165,7 @@ pub struct Resolver<'a> {\n \n     privacy_errors: Vec<PrivacyError<'a>>,\n     ambiguity_errors: Vec<AmbiguityError<'a>>,\n+    gated_errors: FxHashSet<Span>,\n     disallowed_shadowing: Vec<&'a LegacyBinding<'a>>,\n \n     arenas: &'a ResolverArenas<'a>,\n@@ -1355,6 +1356,7 @@ impl<'a> Resolver<'a> {\n \n             privacy_errors: Vec::new(),\n             ambiguity_errors: Vec::new(),\n+            gated_errors: FxHashSet(),\n             disallowed_shadowing: Vec::new(),\n \n             arenas: arenas,"}, {"sha": "67ce24efb3b1f4baa5ad55f4c112d2003cb886ad", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 38, "deletions": 16, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=839c2860ccb7cd3d381abf2838dfba566f52618e", "patch": "@@ -28,9 +28,11 @@ use syntax::ext::placeholders::placeholder;\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{self, emit_feature_err, GateIssue};\n use syntax::fold::{self, Folder};\n+use syntax::parse::parser::PathStyle;\n+use syntax::parse::token::{self, Token};\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, keywords};\n-use syntax::tokenstream::TokenStream;\n+use syntax::tokenstream::{TokenStream, TokenTree, Delimited};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{Span, DUMMY_SP};\n \n@@ -200,16 +202,22 @@ impl<'a> base::Resolver for Resolver<'a> {\n             let name = unwrap_or!(attrs[i].name(), continue);\n \n             if name == \"derive\" {\n-                let mut traits = match attrs[i].meta_item_list() {\n-                    Some(traits) => traits,\n-                    _ => continue,\n+                let result = attrs[i].parse_list(&self.session.parse_sess,\n+                                                 |parser| parser.parse_path(PathStyle::Mod));\n+                let mut traits = match result {\n+                    Ok(traits) => traits,\n+                    Err(mut e) => {\n+                        e.cancel();\n+                        continue\n+                    }\n                 };\n \n                 for j in 0..traits.len() {\n-                    let legacy_name = Symbol::intern(&match traits[j].word() {\n-                        Some(..) => format!(\"derive_{}\", traits[j].name().unwrap()),\n-                        None => continue,\n-                    });\n+                    if traits[j].segments.len() > 1 {\n+                        continue\n+                    }\n+                    let trait_name = traits[j].segments[0].identifier.name;\n+                    let legacy_name = Symbol::intern(&format!(\"derive_{}\", trait_name));\n                     if !self.builtin_macros.contains_key(&legacy_name) {\n                         continue\n                     }\n@@ -218,7 +226,23 @@ impl<'a> base::Resolver for Resolver<'a> {\n                     if traits.is_empty() {\n                         attrs.remove(i);\n                     } else {\n-                        attrs[i].tokens = ast::MetaItemKind::List(traits).tokens(attrs[i].span);\n+                        let mut tokens = Vec::new();\n+                        for (i, path) in traits.iter().enumerate() {\n+                            if i > 0 {\n+                                tokens.push(TokenTree::Token(attrs[i].span, Token::Comma).into());\n+                            }\n+                            for (j, segment) in path.segments.iter().enumerate() {\n+                                if j > 0 {\n+                                    tokens.push(TokenTree::Token(path.span, Token::ModSep).into());\n+                                }\n+                                let tok = Token::Ident(segment.identifier);\n+                                tokens.push(TokenTree::Token(path.span, tok).into());\n+                            }\n+                        }\n+                        attrs[i].tokens = TokenTree::Delimited(attrs[i].span, Delimited {\n+                            delim: token::Paren,\n+                            tts: TokenStream::concat(tokens).into(),\n+                        }).into();\n                     }\n                     return Some(ast::Attribute {\n                         path: ast::Path::from_ident(span, Ident::with_empty_ctxt(legacy_name)),\n@@ -262,9 +286,8 @@ impl<'a> Resolver<'a> {\n             InvocationKind::Bang { ref mac, .. } => {\n                 return self.resolve_macro_to_def(scope, &mac.node.path, MacroKind::Bang, force);\n             }\n-            InvocationKind::Derive { name, span, .. } => {\n-                let path = ast::Path::from_ident(span, Ident::with_empty_ctxt(name));\n-                return self.resolve_macro_to_def(scope, &path, MacroKind::Derive, force);\n+            InvocationKind::Derive { ref path, .. } => {\n+                return self.resolve_macro_to_def(scope, path, MacroKind::Derive, force);\n             }\n         };\n \n@@ -282,9 +305,8 @@ impl<'a> Resolver<'a> {\n             1 => path.segments[0].identifier.name,\n             _ => return Err(determinacy),\n         };\n-        for &(name, span) in traits {\n-            let path = ast::Path::from_ident(span, Ident::with_empty_ctxt(name));\n-            match self.resolve_macro(scope, &path, MacroKind::Derive, force) {\n+        for path in traits {\n+            match self.resolve_macro(scope, path, MacroKind::Derive, force) {\n                 Ok(ext) => if let SyntaxExtension::ProcMacroDerive(_, ref inert_attrs) = *ext {\n                     if inert_attrs.contains(&attr_name) {\n                         // FIXME(jseyfried) Avoid `mem::replace` here.\n@@ -327,7 +349,7 @@ impl<'a> Resolver<'a> {\n         self.current_module = invocation.module.get();\n \n         if path.len() > 1 {\n-            if !self.use_extern_macros {\n+            if !self.use_extern_macros && self.gated_errors.insert(span) {\n                 let msg = \"non-ident macro paths are experimental\";\n                 let feature = \"use_extern_macros\";\n                 emit_feature_err(&self.session.parse_sess, feature, span, GateIssue::Language, msg);"}, {"sha": "2f1efd6ad00ee07672483cb8a7139de0ee714304", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 44, "deletions": 2, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=839c2860ccb7cd3d381abf2838dfba566f52618e", "patch": "@@ -17,7 +17,7 @@ pub use self::IntType::*;\n use ast;\n use ast::{AttrId, Attribute, Name, Ident};\n use ast::{MetaItem, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n-use ast::{Lit, LitKind, Expr, Item, Local, Stmt, StmtKind};\n+use ast::{Lit, LitKind, Expr, ExprKind, Item, Local, Stmt, StmtKind};\n use codemap::{Spanned, spanned, dummy_spanned, mk_sp};\n use syntax_pos::{Span, BytePos, DUMMY_SP};\n use errors::Handler;\n@@ -299,14 +299,45 @@ impl Attribute {\n         })\n     }\n \n+    pub fn parse<'a, T, F>(&self, sess: &'a ParseSess, mut f: F) -> PResult<'a, T>\n+        where F: FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n+    {\n+        let mut parser = Parser::new(sess, self.tokens.clone(), None, false);\n+        let result = f(&mut parser)?;\n+        if parser.token != token::Eof {\n+            parser.unexpected()?;\n+        }\n+        Ok(result)\n+    }\n+\n+    pub fn parse_list<'a, T, F>(&self, sess: &'a ParseSess, mut f: F) -> PResult<'a, Vec<T>>\n+        where F: FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n+    {\n+        if self.tokens.is_empty() {\n+            return Ok(Vec::new());\n+        }\n+        self.parse(sess, |parser| {\n+            parser.expect(&token::OpenDelim(token::Paren))?;\n+            let mut list = Vec::new();\n+            while !parser.eat(&token::CloseDelim(token::Paren)) {\n+                list.push(f(parser)?);\n+                if !parser.eat(&token::Comma) {\n+                   parser.expect(&token::CloseDelim(token::Paren))?;\n+                    break\n+                }\n+            }\n+            Ok(list)\n+        })\n+    }\n+\n     pub fn parse_meta<'a>(&self, sess: &'a ParseSess) -> PResult<'a, MetaItem> {\n         if self.path.segments.len() > 1 {\n             sess.span_diagnostic.span_err(self.path.span, \"expected ident, found path\");\n         }\n \n         Ok(MetaItem {\n             name: self.path.segments.last().unwrap().identifier.name,\n-            node: Parser::new(sess, self.tokens.clone(), None, false).parse_meta_item_kind()?,\n+            node: self.parse(sess, |parser| parser.parse_meta_item_kind())?,\n             span: self.span,\n         })\n     }\n@@ -985,6 +1016,10 @@ impl MetaItem {\n     {\n         let (mut span, name) = match tokens.next() {\n             Some(TokenTree::Token(span, Token::Ident(ident))) => (span, ident.name),\n+            Some(TokenTree::Token(_, Token::Interpolated(ref nt))) => return match **nt {\n+                token::Nonterminal::NtMeta(ref meta) => Some(meta.clone()),\n+                _ => None,\n+            },\n             _ => return None,\n         };\n         let node = match MetaItemKind::from_tokens(tokens) {\n@@ -1151,6 +1186,13 @@ impl LitKind {\n         match token {\n             Token::Ident(ident) if ident.name == \"true\" => Some(LitKind::Bool(true)),\n             Token::Ident(ident) if ident.name == \"false\" => Some(LitKind::Bool(false)),\n+            Token::Interpolated(ref nt) => match **nt {\n+                token::NtExpr(ref v) => match v.node {\n+                    ExprKind::Lit(ref lit) => Some(lit.node.clone()),\n+                    _ => None,\n+                },\n+                _ => None,\n+            },\n             Token::Literal(lit, suf) => {\n                 let (suffix_illegal, result) = parse::lit_token(lit, suf, None);\n                 if suffix_illegal && suf.is_some() {"}, {"sha": "ede8a33df6546db821b3681f93758aa362e43a29", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 32, "deletions": 40, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=839c2860ccb7cd3d381abf2838dfba566f52618e", "patch": "@@ -13,9 +13,10 @@ use feature_gate::{feature_err, EXPLAIN_STMT_ATTR_SYNTAX, Features, get_features\n use {fold, attr};\n use ast;\n use codemap::Spanned;\n-use parse::ParseSess;\n-use ptr::P;\n+use parse::{token, ParseSess};\n+use syntax_pos::Span;\n \n+use ptr::P;\n use util::small_vector::SmallVector;\n \n /// A folder that strips out items that do not belong in the current configuration.\n@@ -84,44 +85,33 @@ impl<'a> StripUnconfigured<'a> {\n             return Some(attr);\n         }\n \n-        let attr_list = match attr.meta_item_list() {\n-            Some(attr_list) => attr_list,\n-            None => {\n-                let msg = \"expected `#[cfg_attr(<cfg pattern>, <attr>)]`\";\n-                self.sess.span_diagnostic.span_err(attr.span, msg);\n-                return None;\n-            }\n-        };\n-\n-        let (cfg, mi) = match (attr_list.len(), attr_list.get(0), attr_list.get(1)) {\n-            (2, Some(cfg), Some(mi)) => (cfg, mi),\n-            _ => {\n-                let msg = \"expected `#[cfg_attr(<cfg pattern>, <attr>)]`\";\n-                self.sess.span_diagnostic.span_err(attr.span, msg);\n+        let (cfg, path, tokens, span) = match attr.parse(self.sess, |parser| {\n+            parser.expect(&token::OpenDelim(token::Paren))?;\n+            let cfg = parser.parse_meta_item()?;\n+            parser.expect(&token::Comma)?;\n+            let lo = parser.span.lo;\n+            let (path, tokens) = parser.parse_path_and_tokens()?;\n+            parser.expect(&token::CloseDelim(token::Paren))?;\n+            Ok((cfg, path, tokens, Span { lo: lo, ..parser.prev_span }))\n+        }) {\n+            Ok(result) => result,\n+            Err(mut e) => {\n+                e.emit();\n                 return None;\n             }\n         };\n \n-        use attr::cfg_matches;\n-        match (cfg.meta_item(), mi.meta_item()) {\n-            (Some(cfg), Some(mi)) =>\n-                if cfg_matches(&cfg, self.sess, self.features) {\n-                    self.process_cfg_attr(ast::Attribute {\n-                        id: attr::mk_attr_id(),\n-                        style: attr.style,\n-                        path: ast::Path::from_ident(mi.span, ast::Ident::with_empty_ctxt(mi.name)),\n-                        tokens: mi.node.tokens(mi.span),\n-                        is_sugared_doc: false,\n-                        span: mi.span,\n-                    })\n-                } else {\n-                    None\n-                },\n-            _ => {\n-                let msg = \"unexpected literal(s) in `#[cfg_attr(<cfg pattern>, <attr>)]`\";\n-                self.sess.span_diagnostic.span_err(attr.span, msg);\n-                None\n-            }\n+        if attr::cfg_matches(&cfg, self.sess, self.features) {\n+            self.process_cfg_attr(ast::Attribute {\n+                id: attr::mk_attr_id(),\n+                style: attr.style,\n+                path: path,\n+                tokens: tokens,\n+                is_sugared_doc: false,\n+                span: span,\n+            })\n+        } else {\n+            None\n         }\n     }\n \n@@ -133,10 +123,12 @@ impl<'a> StripUnconfigured<'a> {\n                 return false;\n             }\n \n-            let mis = attr.meta_item_list();\n-            let mis = match mis {\n-                Some(ref mis) if is_cfg(&attr) => mis,\n-                _ => return true\n+            let mis = if !is_cfg(&attr) {\n+                return true;\n+            } else if let Some(mis) = attr.meta_item_list() {\n+                mis\n+            } else {\n+                return true;\n             };\n \n             if mis.len() != 1 {"}, {"sha": "1569d9f540b8ebf679eb69b92f14d750d77545f3", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=839c2860ccb7cd3d381abf2838dfba566f52618e", "patch": "@@ -12,36 +12,31 @@ use attr::HasAttrs;\n use {ast, codemap};\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n+use parse::parser::PathStyle;\n use symbol::Symbol;\n use syntax_pos::Span;\n \n-pub fn collect_derives(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>) -> Vec<(Symbol, Span)> {\n+pub fn collect_derives(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>) -> Vec<ast::Path> {\n     let mut result = Vec::new();\n     attrs.retain(|attr| {\n         if attr.path != \"derive\" {\n             return true;\n         }\n \n-        if attr.value_str().is_some() {\n-            cx.span_err(attr.span, \"unexpected value in `derive`\");\n-            return false;\n-        }\n-\n-        let traits = attr.meta_item_list().unwrap_or_else(Vec::new);\n-        if traits.is_empty() {\n-            cx.span_warn(attr.span, \"empty trait list in `derive`\");\n-            return false;\n-        }\n-\n-        for titem in traits {\n-            if titem.word().is_none() {\n-                cx.span_err(titem.span, \"malformed `derive` entry\");\n-                return false;\n+        match attr.parse_list(cx.parse_sess, |parser| parser.parse_path(PathStyle::Mod)) {\n+            Ok(ref traits) if traits.is_empty() => {\n+                cx.span_warn(attr.span, \"empty trait list in `derive`\");\n+                false\n+            }\n+            Ok(traits) => {\n+                result.extend(traits);\n+                true\n+            }\n+            Err(mut e) => {\n+                e.emit();\n+                false\n             }\n-            result.push((titem.name().unwrap(), titem.span));\n         }\n-\n-        true\n     });\n     result\n }\n@@ -60,21 +55,21 @@ fn allow_unstable(cx: &mut ExtCtxt, span: Span, attr_name: &str) -> Span {\n     }\n }\n \n-pub fn add_derived_markers<T: HasAttrs>(cx: &mut ExtCtxt, traits: &[(Symbol, Span)], item: T) -> T {\n+pub fn add_derived_markers<T: HasAttrs>(cx: &mut ExtCtxt, traits: &[ast::Path], item: T) -> T {\n     let span = match traits.get(0) {\n-        Some(&(_, span)) => span,\n+        Some(path) => path.span,\n         None => return item,\n     };\n \n     item.map_attrs(|mut attrs| {\n-        if traits.iter().any(|&(name, _)| name == \"PartialEq\") &&\n-           traits.iter().any(|&(name, _)| name == \"Eq\") {\n+        if traits.iter().any(|path| *path == \"PartialEq\") &&\n+           traits.iter().any(|path| *path == \"Eq\") {\n             let span = allow_unstable(cx, span, \"derive(PartialEq, Eq)\");\n             let meta = cx.meta_word(span, Symbol::intern(\"structural_match\"));\n             attrs.push(cx.attribute(span, meta));\n         }\n-        if traits.iter().any(|&(name, _)| name == \"Copy\") &&\n-           traits.iter().any(|&(name, _)| name == \"Clone\") {\n+        if traits.iter().any(|path| *path == \"Copy\") &&\n+           traits.iter().any(|path| *path == \"Clone\") {\n             let span = allow_unstable(cx, span, \"derive(Copy, Clone)\");\n             let meta = cx.meta_word(span, Symbol::intern(\"rustc_copy_clone_marker\"));\n             attrs.push(cx.attribute(span, meta));"}, {"sha": "c1816582bc6ca2418c8bc361f841d4c77b35a17a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 49, "deletions": 45, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=839c2860ccb7cd3d381abf2838dfba566f52618e", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{self, Block, Ident, PatKind};\n-use ast::{Name, MacStmtStyle, StmtKind, ItemKind};\n+use ast::{self, Block, Ident, PatKind, Path};\n+use ast::{MacStmtStyle, StmtKind, ItemKind};\n use attr::{self, HasAttrs};\n use codemap::{ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n use config::{is_test_or_bench, StripUnconfigured};\n@@ -27,7 +27,7 @@ use ptr::P;\n use std_inject;\n use symbol::Symbol;\n use symbol::keywords;\n-use syntax_pos::{self, Span, ExpnId};\n+use syntax_pos::{Span, ExpnId, DUMMY_SP};\n use tokenstream::TokenStream;\n use util::small_vector::SmallVector;\n use visit::Visitor;\n@@ -165,12 +165,11 @@ pub enum InvocationKind {\n     },\n     Attr {\n         attr: Option<ast::Attribute>,\n-        traits: Vec<(Symbol, Span)>,\n+        traits: Vec<Path>,\n         item: Annotatable,\n     },\n     Derive {\n-        name: Symbol,\n-        span: Span,\n+        path: Path,\n         item: Annotatable,\n     },\n }\n@@ -180,8 +179,8 @@ impl Invocation {\n         match self.kind {\n             InvocationKind::Bang { span, .. } => span,\n             InvocationKind::Attr { attr: Some(ref attr), .. } => attr.span,\n-            InvocationKind::Attr { attr: None, .. } => syntax_pos::DUMMY_SP,\n-            InvocationKind::Derive { span, .. } => span,\n+            InvocationKind::Attr { attr: None, .. } => DUMMY_SP,\n+            InvocationKind::Derive { ref path, .. } => path.span,\n         }\n     }\n }\n@@ -277,20 +276,19 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         add_derived_markers(&mut self.cx, &traits, item.clone());\n                     let derives = derives.entry(invoc.expansion_data.mark).or_insert_with(Vec::new);\n \n-                    for &(name, span) in &traits {\n+                    for path in &traits {\n                         let mark = Mark::fresh();\n                         derives.push(mark);\n-                        let path = ast::Path::from_ident(span, Ident::with_empty_ctxt(name));\n                         let item = match self.cx.resolver.resolve_macro(\n-                                Mark::root(), &path, MacroKind::Derive, false) {\n+                                Mark::root(), path, MacroKind::Derive, false) {\n                             Ok(ext) => match *ext {\n                                 SyntaxExtension::BuiltinDerive(..) => item_with_markers.clone(),\n                                 _ => item.clone(),\n                             },\n                             _ => item.clone(),\n                         };\n                         invocations.push(Invocation {\n-                            kind: InvocationKind::Derive { name: name, span: span, item: item },\n+                            kind: InvocationKind::Derive { path: path.clone(), item: item },\n                             expansion_kind: invoc.expansion_kind,\n                             expansion_data: ExpansionData {\n                                 mark: mark,\n@@ -380,11 +378,10 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         };\n \n         attr::mark_used(&attr);\n-        let name = attr.path.segments[0].identifier.name;\n         self.cx.bt_push(ExpnInfo {\n             call_site: attr.span,\n             callee: NameAndSpan {\n-                format: MacroAttribute(name),\n+                format: MacroAttribute(Symbol::intern(&format!(\"{}\", attr.path))),\n                 span: Some(attr.span),\n                 allow_internal_unstable: false,\n             }\n@@ -419,14 +416,14 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 };\n \n                 let tok_result = mac.expand(self.cx, attr.span, attr.tokens.clone(), item_toks);\n-                self.parse_expansion(tok_result, kind, name, span)\n+                self.parse_expansion(tok_result, kind, &attr.path, span)\n             }\n             SyntaxExtension::ProcMacroDerive(..) | SyntaxExtension::BuiltinDerive(..) => {\n-                self.cx.span_err(attr.span, &format!(\"`{}` is a derive mode\", name));\n+                self.cx.span_err(attr.span, &format!(\"`{}` is a derive mode\", attr.path));\n                 kind.dummy(attr.span)\n             }\n             _ => {\n-                let msg = &format!(\"macro `{}` may not be used in attributes\", name);\n+                let msg = &format!(\"macro `{}` may not be used in attributes\", attr.path);\n                 self.cx.span_err(attr.span, &msg);\n                 kind.dummy(attr.span)\n             }\n@@ -442,23 +439,22 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         };\n         let path = &mac.node.path;\n \n-        let extname = path.segments.last().unwrap().identifier.name;\n         let ident = ident.unwrap_or(keywords::Invalid.ident());\n         let marked_tts =\n             noop_fold_tts(mac.node.stream(), &mut Marker { mark: mark, expn_id: None });\n         let opt_expanded = match *ext {\n             NormalTT(ref expandfun, exp_span, allow_internal_unstable) => {\n                 if ident.name != keywords::Invalid.name() {\n                     let msg =\n-                        format!(\"macro {}! expects no ident argument, given '{}'\", extname, ident);\n+                        format!(\"macro {}! expects no ident argument, given '{}'\", path, ident);\n                     self.cx.span_err(path.span, &msg);\n                     return kind.dummy(span);\n                 }\n \n                 self.cx.bt_push(ExpnInfo {\n                     call_site: span,\n                     callee: NameAndSpan {\n-                        format: MacroBang(extname),\n+                        format: MacroBang(Symbol::intern(&format!(\"{}\", path))),\n                         span: exp_span,\n                         allow_internal_unstable: allow_internal_unstable,\n                     },\n@@ -470,14 +466,14 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             IdentTT(ref expander, tt_span, allow_internal_unstable) => {\n                 if ident.name == keywords::Invalid.name() {\n                     self.cx.span_err(path.span,\n-                                    &format!(\"macro {}! expects an ident argument\", extname));\n+                                    &format!(\"macro {}! expects an ident argument\", path));\n                     return kind.dummy(span);\n                 };\n \n                 self.cx.bt_push(ExpnInfo {\n                     call_site: span,\n                     callee: NameAndSpan {\n-                        format: MacroBang(extname),\n+                        format: MacroBang(Symbol::intern(&format!(\"{}\", path))),\n                         span: tt_span,\n                         allow_internal_unstable: allow_internal_unstable,\n                     }\n@@ -489,27 +485,27 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n             MultiDecorator(..) | MultiModifier(..) | SyntaxExtension::AttrProcMacro(..) => {\n                 self.cx.span_err(path.span,\n-                                 &format!(\"`{}` can only be used in attributes\", extname));\n+                                 &format!(\"`{}` can only be used in attributes\", path));\n                 return kind.dummy(span);\n             }\n \n             SyntaxExtension::ProcMacroDerive(..) | SyntaxExtension::BuiltinDerive(..) => {\n-                self.cx.span_err(path.span, &format!(\"`{}` is a derive mode\", extname));\n+                self.cx.span_err(path.span, &format!(\"`{}` is a derive mode\", path));\n                 return kind.dummy(span);\n             }\n \n             SyntaxExtension::ProcMacro(ref expandfun) => {\n                 if ident.name != keywords::Invalid.name() {\n                     let msg =\n-                        format!(\"macro {}! expects no ident argument, given '{}'\", extname, ident);\n+                        format!(\"macro {}! expects no ident argument, given '{}'\", path, ident);\n                     self.cx.span_err(path.span, &msg);\n                     return kind.dummy(span);\n                 }\n \n                 self.cx.bt_push(ExpnInfo {\n                     call_site: span,\n                     callee: NameAndSpan {\n-                        format: MacroBang(extname),\n+                        format: MacroBang(Symbol::intern(&format!(\"{}\", path))),\n                         // FIXME procedural macros do not have proper span info\n                         // yet, when they do, we should use it here.\n                         span: None,\n@@ -519,7 +515,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 });\n \n                 let tok_result = expandfun.expand(self.cx, span, marked_tts);\n-                Some(self.parse_expansion(tok_result, kind, extname, span))\n+                Some(self.parse_expansion(tok_result, kind, path, span))\n             }\n         };\n \n@@ -541,19 +537,24 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     /// Expand a derive invocation. Returns the result of expansion.\n     fn expand_derive_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n         let Invocation { expansion_kind: kind, .. } = invoc;\n-        let (name, span, item) = match invoc.kind {\n-            InvocationKind::Derive { name, span, item } => (name, span, item),\n+        let (path, item) = match invoc.kind {\n+            InvocationKind::Derive { path, item } => (path, item),\n             _ => unreachable!(),\n         };\n \n-        let mitem = ast::MetaItem { name: name, span: span, node: ast::MetaItemKind::Word };\n-        let pretty_name = Symbol::intern(&format!(\"derive({})\", name));\n+        let pretty_name = Symbol::intern(&format!(\"derive({})\", path));\n+        let span = path.span;\n+        let attr = ast::Attribute {\n+            path: path, tokens: TokenStream::empty(), span: span,\n+            // irrelevant:\n+            id: ast::AttrId(0), style: ast::AttrStyle::Outer, is_sugared_doc: false,\n+        };\n \n         self.cx.bt_push(ExpnInfo {\n             call_site: span,\n             callee: NameAndSpan {\n                 format: MacroAttribute(pretty_name),\n-                span: Some(span),\n+                span: None,\n                 allow_internal_unstable: false,\n             }\n         });\n@@ -571,7 +572,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     }),\n                     ..span\n                 };\n-                return kind.expect_from_annotatables(ext.expand(self.cx, span, &mitem, item));\n+                let dummy = ast::MetaItem { // FIXME(jseyfried) avoid this\n+                    name: keywords::Invalid.name(),\n+                    span: DUMMY_SP,\n+                    node: ast::MetaItemKind::Word,\n+                };\n+                return kind.expect_from_annotatables(ext.expand(self.cx, span, &dummy, item));\n             }\n             SyntaxExtension::BuiltinDerive(func) => {\n                 let span = Span {\n@@ -586,20 +592,18 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     ..span\n                 };\n                 let mut items = Vec::new();\n-                func(self.cx, span, &mitem, &item, &mut |a| {\n-                    items.push(a)\n-                });\n+                func(self.cx, span, &attr.meta().unwrap(), &item, &mut |a| items.push(a));\n                 return kind.expect_from_annotatables(items);\n             }\n             _ => {\n-                let msg = &format!(\"macro `{}` may not be used for derive attributes\", name);\n+                let msg = &format!(\"macro `{}` may not be used for derive attributes\", attr.path);\n                 self.cx.span_err(span, &msg);\n                 kind.dummy(span)\n             }\n         }\n     }\n \n-    fn parse_expansion(&mut self, toks: TokenStream, kind: ExpansionKind, name: Name, span: Span)\n+    fn parse_expansion(&mut self, toks: TokenStream, kind: ExpansionKind, path: &Path, span: Span)\n                        -> Expansion {\n         let mut parser = self.cx.new_parser_from_tts(&toks.into_trees().collect::<Vec<_>>());\n         let expansion = match parser.parse_expansion(kind, false) {\n@@ -609,7 +613,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 return kind.dummy(span);\n             }\n         };\n-        parser.ensure_complete_parse(name, kind.name(), span);\n+        parser.ensure_complete_parse(path, kind.name(), span);\n         // FIXME better span info\n         expansion.fold_with(&mut ChangeSpan { span: span })\n     }\n@@ -658,14 +662,14 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    pub fn ensure_complete_parse(&mut self, macro_name: ast::Name, kind_name: &str, span: Span) {\n+    pub fn ensure_complete_parse(&mut self, macro_path: &Path, kind_name: &str, span: Span) {\n         if self.token != token::Eof {\n             let msg = format!(\"macro expansion ignores token `{}` and any following\",\n                               self.this_token_to_string());\n             let mut err = self.diagnostic().struct_span_err(self.span, &msg);\n             let msg = format!(\"caused by the macro expansion here; the usage \\\n                                of `{}!` is likely invalid in {} context\",\n-                               macro_name, kind_name);\n+                               macro_path, kind_name);\n             err.span_note(span, &msg).emit();\n         }\n     }\n@@ -708,20 +712,20 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n \n     fn collect_attr(&mut self,\n                     attr: Option<ast::Attribute>,\n-                    traits: Vec<(Symbol, Span)>,\n+                    traits: Vec<Path>,\n                     item: Annotatable,\n                     kind: ExpansionKind)\n                     -> Expansion {\n         if !traits.is_empty() &&\n            (kind == ExpansionKind::TraitItems || kind == ExpansionKind::ImplItems) {\n-            self.cx.span_err(traits[0].1, \"`derive` can be only be applied to items\");\n+            self.cx.span_err(traits[0].span, \"`derive` can be only be applied to items\");\n             return kind.expect_from_annotatables(::std::iter::once(item));\n         }\n         self.collect(kind, InvocationKind::Attr { attr: attr, traits: traits, item: item })\n     }\n \n     // If `item` is an attr invocation, remove and return the macro attribute.\n-    fn classify_item<T>(&mut self, mut item: T) -> (Option<ast::Attribute>, Vec<(Symbol, Span)>, T)\n+    fn classify_item<T>(&mut self, mut item: T) -> (Option<ast::Attribute>, Vec<Path>, T)\n         where T: HasAttrs,\n     {\n         let (mut attr, mut traits) = (None, Vec::new());\n@@ -900,7 +904,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                 // Detect if this is an inline module (`mod m { ... }` as opposed to `mod m;`).\n                 // In the non-inline case, `inner` is never the dummy span (c.f. `parse_item_mod`).\n                 // Thus, if `inner` is the dummy span, we know the module is inline.\n-                let inline_module = item.span.contains(inner) || inner == syntax_pos::DUMMY_SP;\n+                let inline_module = item.span.contains(inner) || inner == DUMMY_SP;\n \n                 if inline_module {\n                     if let Some(path) = attr::first_attr_value_str_by_name(&item.attrs, \"path\") {"}, {"sha": "021c5398a4200459218a8f94d78df25ed77b6502", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=839c2860ccb7cd3d381abf2838dfba566f52618e", "patch": "@@ -51,7 +51,8 @@ impl<'a> ParserAnyMacro<'a> {\n         }\n \n         // Make sure we don't have any tokens left to parse so we don't silently drop anything.\n-        parser.ensure_complete_parse(macro_ident.name, kind.name(), site_span);\n+        let path = ast::Path::from_ident(site_span, macro_ident);\n+        parser.ensure_complete_parse(&path, kind.name(), site_span);\n         expansion\n     }\n }"}, {"sha": "05e7b0f9aa4da8b38d5eb7ad4c23a111054be5df", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=839c2860ccb7cd3d381abf2838dfba566f52618e", "patch": "@@ -1096,6 +1096,10 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             self.context.check_attribute(attr, false);\n         }\n \n+        if self.context.features.proc_macro && attr::is_known(attr) {\n+            return\n+        }\n+\n         let meta = panictry!(attr.parse_meta(&self.context.parse_sess));\n         if contains_novel_literal(&meta) {\n             gate_feature_post!(&self, attr_literals, attr.span,"}, {"sha": "53106214fa3107f53fef6b85d608e895ca1eba39", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=839c2860ccb7cd3d381abf2838dfba566f52618e", "patch": "@@ -14,8 +14,9 @@ use syntax_pos::{mk_sp, Span};\n use codemap::spanned;\n use parse::common::SeqSep;\n use parse::PResult;\n-use parse::token;\n-use parse::parser::{Parser, TokenType};\n+use parse::token::{self, Nonterminal};\n+use parse::parser::{Parser, TokenType, PathStyle};\n+use tokenstream::TokenStream;\n \n #[derive(PartialEq, Eq, Debug)]\n enum InnerAttributeParsePolicy<'a> {\n@@ -91,7 +92,7 @@ impl<'a> Parser<'a> {\n         debug!(\"parse_attribute_with_inner_parse_policy: inner_parse_policy={:?} self.token={:?}\",\n                inner_parse_policy,\n                self.token);\n-        let (span, value, mut style) = match self.token {\n+        let (span, path, tokens, mut style) = match self.token {\n             token::Pound => {\n                 let lo = self.span.lo;\n                 self.bump();\n@@ -119,11 +120,11 @@ impl<'a> Parser<'a> {\n                 };\n \n                 self.expect(&token::OpenDelim(token::Bracket))?;\n-                let meta_item = self.parse_meta_item()?;\n+                let (path, tokens) = self.parse_path_and_tokens()?;\n                 self.expect(&token::CloseDelim(token::Bracket))?;\n                 let hi = self.prev_span.hi;\n \n-                (mk_sp(lo, hi), meta_item, style)\n+                (mk_sp(lo, hi), path, tokens, style)\n             }\n             _ => {\n                 let token_str = self.this_token_to_string();\n@@ -143,13 +144,30 @@ impl<'a> Parser<'a> {\n         Ok(ast::Attribute {\n             id: attr::mk_attr_id(),\n             style: style,\n-            path: ast::Path::from_ident(value.span, ast::Ident::with_empty_ctxt(value.name)),\n-            tokens: value.node.tokens(value.span),\n+            path: path,\n+            tokens: tokens,\n             is_sugared_doc: false,\n             span: span,\n         })\n     }\n \n+    pub fn parse_path_and_tokens(&mut self) -> PResult<'a, (ast::Path, TokenStream)> {\n+        let meta = match self.token {\n+            token::Interpolated(ref nt) => match **nt {\n+                Nonterminal::NtMeta(ref meta) => Some(meta.clone()),\n+                _ => None,\n+            },\n+            _ => None,\n+        };\n+        Ok(if let Some(meta) = meta {\n+            self.bump();\n+            (ast::Path::from_ident(meta.span, ast::Ident::with_empty_ctxt(meta.name)),\n+             meta.node.tokens(meta.span))\n+        } else {\n+            (self.parse_path(PathStyle::Mod)?, self.parse_tokens())\n+        })\n+    }\n+\n     /// Parse attributes that appear after the opening of an item. These should\n     /// be preceded by an exclamation mark, but we accept and warn about one\n     /// terminated by a semicolon."}, {"sha": "308876fed56dc8d03ed5e2d036c5f8762c6d5703", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=839c2860ccb7cd3d381abf2838dfba566f52618e", "patch": "@@ -2644,6 +2644,17 @@ impl<'a> Parser<'a> {\n         Ok(tts)\n     }\n \n+    pub fn parse_tokens(&mut self) -> TokenStream {\n+        let mut result = Vec::new();\n+        loop {\n+            match self.token {\n+                token::Eof | token::CloseDelim(..) => break,\n+                _ => result.push(self.parse_token_tree().into()),\n+            }\n+        }\n+        TokenStream::concat(result)\n+    }\n+\n     /// Parse a prefix-unary-operator expr\n     pub fn parse_prefix_expr(&mut self,\n                              already_parsed_attrs: Option<ThinVec<Attribute>>)"}, {"sha": "52f867fe913b8af0a3de2bcc19a46ecfcf443b66", "filename": "src/test/compile-fail/macro-attribute.rs", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Ftest%2Fcompile-fail%2Fmacro-attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Ftest%2Fcompile-fail%2Fmacro-attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-attribute.rs?ref=839c2860ccb7cd3d381abf2838dfba566f52618e", "patch": "@@ -8,7 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n-\n #[doc = $not_there] //~ error: unexpected token: `$`\n fn main() { }", "previous_filename": "src/test/parse-fail/macro-attribute.rs"}, {"sha": "ac000628f2b0498331d4ceb729fe3e40cdaa4f60", "filename": "src/test/compile-fail/malformed-derive-entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Ftest%2Fcompile-fail%2Fmalformed-derive-entry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Ftest%2Fcompile-fail%2Fmalformed-derive-entry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmalformed-derive-entry.rs?ref=839c2860ccb7cd3d381abf2838dfba566f52618e", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n #[derive(Copy(Bad))]\n-//~^ ERROR malformed `derive` entry\n+//~^ ERROR expected one of `)`, `,`, or `::`, found `(`\n struct Test1;\n \n #[derive(Copy=\"bad\")]\n-//~^ ERROR malformed `derive` entry\n+//~^ ERROR expected one of `)`, `,`, or `::`, found `=`\n struct Test2;\n \n #[derive()]"}, {"sha": "bf55b7bdcb1def55da516ae84240abe19d0b3876", "filename": "src/test/compile-fail/suffixed-literal-meta.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Ftest%2Fcompile-fail%2Fsuffixed-literal-meta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Ftest%2Fcompile-fail%2Fsuffixed-literal-meta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsuffixed-literal-meta.rs?ref=839c2860ccb7cd3d381abf2838dfba566f52618e", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(attr_literals)]\n+\n+#[path = 1usize] //~ ERROR: suffixed literals are not allowed in attributes\n+#[path = 1u8] //~ ERROR: suffixed literals are not allowed in attributes\n+#[path = 1u16] //~ ERROR: suffixed literals are not allowed in attributes\n+#[path = 1u32] //~ ERROR: suffixed literals are not allowed in attributes\n+#[path = 1u64] //~ ERROR: suffixed literals are not allowed in attributes\n+#[path = 1isize] //~ ERROR: suffixed literals are not allowed in attributes\n+#[path = 1i8] //~ ERROR: suffixed literals are not allowed in attributes\n+#[path = 1i16] //~ ERROR: suffixed literals are not allowed in attributes\n+#[path = 1i32] //~ ERROR: suffixed literals are not allowed in attributes\n+#[path = 1i64] //~ ERROR: suffixed literals are not allowed in attributes\n+#[path = 1.0f32] //~ ERROR: suffixed literals are not allowed in attributes\n+#[path = 1.0f64] //~ ERROR: suffixed literals are not allowed in attributes\n+fn main() { }"}, {"sha": "d57a813311b5ab509f35fe980da31c47624fbdf2", "filename": "src/test/parse-fail/attr-bad-meta.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Ftest%2Fparse-fail%2Fattr-bad-meta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Ftest%2Fparse-fail%2Fattr-bad-meta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fattr-bad-meta.rs?ref=839c2860ccb7cd3d381abf2838dfba566f52618e", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n-\n-// error-pattern:expected one of `=` or `]`\n-\n // asterisk is bogus\n-#[attr*]\n+#[path*] //~ ERROR expected one of `(` or `=`\n mod m {}"}, {"sha": "0e2840c69d3643eee7e58f2f646b59b1448a1e2f", "filename": "src/test/parse-fail/suffixed-literal-meta.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Ftest%2Fparse-fail%2Fsuffixed-literal-meta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Ftest%2Fparse-fail%2Fsuffixed-literal-meta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fsuffixed-literal-meta.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z parse-only\n-\n-#[foo = 1usize] //~ ERROR: suffixed literals are not allowed in attributes\n-#[foo = 1u8] //~ ERROR: suffixed literals are not allowed in attributes\n-#[foo = 1u16] //~ ERROR: suffixed literals are not allowed in attributes\n-#[foo = 1u32] //~ ERROR: suffixed literals are not allowed in attributes\n-#[foo = 1u64] //~ ERROR: suffixed literals are not allowed in attributes\n-#[foo = 1isize] //~ ERROR: suffixed literals are not allowed in attributes\n-#[foo = 1i8] //~ ERROR: suffixed literals are not allowed in attributes\n-#[foo = 1i16] //~ ERROR: suffixed literals are not allowed in attributes\n-#[foo = 1i32] //~ ERROR: suffixed literals are not allowed in attributes\n-#[foo = 1i64] //~ ERROR: suffixed literals are not allowed in attributes\n-#[foo = 1.0f32] //~ ERROR: suffixed literals are not allowed in attributes\n-#[foo = 1.0f64] //~ ERROR: suffixed literals are not allowed in attributes\n-fn main() { }"}, {"sha": "b2da0c6a296d8fc5119d4f68560f799f9947408d", "filename": "src/test/ui/span/E0536.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Ftest%2Fui%2Fspan%2FE0536.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Ftest%2Fui%2Fspan%2FE0536.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2FE0536.stderr?ref=839c2860ccb7cd3d381abf2838dfba566f52618e", "patch": "@@ -2,7 +2,7 @@ error[E0536]: expected 1 cfg-pattern\n   --> $DIR/E0536.rs:11:7\n    |\n 11 | #[cfg(not())] //~ ERROR E0536\n-   |       ^^^^^\n+   |       ^^^\n \n error: aborting due to previous error\n "}, {"sha": "29873943f444d8e65a7fc59f27af530744919307", "filename": "src/test/ui/span/E0537.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Ftest%2Fui%2Fspan%2FE0537.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/839c2860ccb7cd3d381abf2838dfba566f52618e/src%2Ftest%2Fui%2Fspan%2FE0537.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2FE0537.stderr?ref=839c2860ccb7cd3d381abf2838dfba566f52618e", "patch": "@@ -2,7 +2,7 @@ error[E0537]: invalid predicate `unknown`\n   --> $DIR/E0537.rs:11:7\n    |\n 11 | #[cfg(unknown())] //~ ERROR E0537\n-   |       ^^^^^^^^^\n+   |       ^^^^^^^\n \n error: aborting due to previous error\n "}]}