{"sha": "4ce7ef5f5936a220c9df5c7efae669f010238e32", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjZTdlZjVmNTkzNmEyMjBjOWRmNWM3ZWZhZTY2OWYwMTAyMzhlMzI=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2018-06-03T01:55:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-06-03T01:55:06Z"}, "message": "Rollup merge of #51226 - gnzlbg:nonzero_align, r=SimonSapin\n\nMake Layout's align a NonZeroUsize\n\nThis PR makes the `Layout`'s align field a `NonZeroUsize` since it cannot ever be zero, not even while building a `Layout`. It also contains some drive-by minor cleanups over the docs and the code, like updating the documented error types, or using the `size()` and `align()` methods instead of accessing the fields directly (the latter was required for the `NonZeroUsize` change anyways).\n\nr? @SimonSapin\n\ncc @Amanieu", "tree": {"sha": "1c064d0b99600eb77008eb3408750d7e3a9e9d64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c064d0b99600eb77008eb3408750d7e3a9e9d64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ce7ef5f5936a220c9df5c7efae669f010238e32", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbE0p6CRBK7hj4Ov3rIwAAdHIIAKgZdDXfDgKteLA13mKl0bDM\nx6rWg6Ru1G8qAHMlnHFYlFnWZi88nsIGZ7p9I89PDS+HsWE7wjSUG18oxgVWL9+b\nMjNGi/PWu6G81Q354BDEmXJ5qNoYsaCb1WJnow9d8lyUKYtq6N0A3WWfnsBuCqL6\n8DKqavqN1g3xz43z7bIRdxWciSolXnYyld3ifipOdgHTBlix+s9mU510dMe5gk6B\nFX3YYKVKqTLXd7Hb/6IX93e3Wq5jaZ9MQyWA0ZN1Dl0j04sNZ2WdUmouRUN9IYqU\n12hJ+RG6rAZUKLLXw2nd6mUSh08DkoEaLVSQ4oA4C8A3mNpGgWbnpdx7pKfSixw=\n=7ooK\n-----END PGP SIGNATURE-----\n", "payload": "tree 1c064d0b99600eb77008eb3408750d7e3a9e9d64\nparent a6ab2153f679d72ac63a5f200e721e8d4c27e2af\nparent 2d7cd70b1ac0dc1ce3a2602b51301dedae6a25a6\nauthor Mark Simulacrum <mark.simulacrum@gmail.com> 1527990906 -0600\ncommitter GitHub <noreply@github.com> 1527990906 -0600\n\nRollup merge of #51226 - gnzlbg:nonzero_align, r=SimonSapin\n\nMake Layout's align a NonZeroUsize\n\nThis PR makes the `Layout`'s align field a `NonZeroUsize` since it cannot ever be zero, not even while building a `Layout`. It also contains some drive-by minor cleanups over the docs and the code, like updating the documented error types, or using the `size()` and `align()` methods instead of accessing the fields directly (the latter was required for the `NonZeroUsize` change anyways).\n\nr? @SimonSapin\n\ncc @Amanieu\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ce7ef5f5936a220c9df5c7efae669f010238e32", "html_url": "https://github.com/rust-lang/rust/commit/4ce7ef5f5936a220c9df5c7efae669f010238e32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ce7ef5f5936a220c9df5c7efae669f010238e32/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6ab2153f679d72ac63a5f200e721e8d4c27e2af", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6ab2153f679d72ac63a5f200e721e8d4c27e2af", "html_url": "https://github.com/rust-lang/rust/commit/a6ab2153f679d72ac63a5f200e721e8d4c27e2af"}, {"sha": "2d7cd70b1ac0dc1ce3a2602b51301dedae6a25a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d7cd70b1ac0dc1ce3a2602b51301dedae6a25a6", "html_url": "https://github.com/rust-lang/rust/commit/2d7cd70b1ac0dc1ce3a2602b51301dedae6a25a6"}], "stats": {"total": 80, "additions": 43, "deletions": 37}, "files": [{"sha": "229758803c87071e1d4497b6a69c0f50113e496f", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 43, "deletions": 37, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/4ce7ef5f5936a220c9df5c7efae669f010238e32/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce7ef5f5936a220c9df5c7efae669f010238e32/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=4ce7ef5f5936a220c9df5c7efae669f010238e32", "patch": "@@ -20,6 +20,7 @@ use fmt;\n use mem;\n use usize;\n use ptr::{self, NonNull};\n+use num::NonZeroUsize;\n \n extern {\n     /// An opaque, unsized type. Used for pointers to allocated memory.\n@@ -66,7 +67,7 @@ fn size_align<T>() -> (usize, usize) {\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct Layout {\n     // size of the requested block of memory, measured in bytes.\n-    size: usize,\n+    size_: usize,\n \n     // alignment of the requested block of memory, measured in bytes.\n     // we ensure that this is always a power-of-two, because API's\n@@ -75,17 +76,12 @@ pub struct Layout {\n     //\n     // (However, we do not analogously require `align >= sizeof(void*)`,\n     //  even though that is *also* a requirement of `posix_memalign`.)\n-    align: usize,\n+    align_: NonZeroUsize,\n }\n \n-\n-// FIXME: audit default implementations for overflow errors,\n-// (potentially switching to overflowing_add and\n-//  overflowing_mul as necessary).\n-\n impl Layout {\n     /// Constructs a `Layout` from a given `size` and `align`,\n-    /// or returns `None` if either of the following conditions\n+    /// or returns `LayoutErr` if either of the following conditions\n     /// are not met:\n     ///\n     /// * `align` must be a power of two,\n@@ -126,23 +122,23 @@ impl Layout {\n     ///\n     /// # Safety\n     ///\n-    /// This function is unsafe as it does not verify that `align` is\n-    /// a power-of-two nor `size` aligned to `align` fits within the\n-    /// address space (i.e. the `Layout::from_size_align` preconditions).\n+    /// This function is unsafe as it does not verify the preconditions from\n+    /// [`Layout::from_size_align`](#method.from_size_align).\n     #[inline]\n     pub unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Self {\n-        Layout { size: size, align: align }\n+        Layout { size_: size, align_: NonZeroUsize::new_unchecked(align) }\n     }\n \n     /// The minimum size in bytes for a memory block of this layout.\n     #[inline]\n-    pub fn size(&self) -> usize { self.size }\n+    pub fn size(&self) -> usize { self.size_ }\n \n     /// The minimum byte alignment for a memory block of this layout.\n     #[inline]\n-    pub fn align(&self) -> usize { self.align }\n+    pub fn align(&self) -> usize { self.align_.get() }\n \n     /// Constructs a `Layout` suitable for holding a value of type `T`.\n+    #[inline]\n     pub fn new<T>() -> Self {\n         let (size, align) = size_align::<T>();\n         // Note that the align is guaranteed by rustc to be a power of two and\n@@ -158,6 +154,7 @@ impl Layout {\n     /// Produces layout describing a record that could be used to\n     /// allocate backing structure for `T` (which could be a trait\n     /// or other unsized type like a slice).\n+    #[inline]\n     pub fn for_value<T: ?Sized>(t: &T) -> Self {\n         let (size, align) = (mem::size_of_val(t), mem::align_of_val(t));\n         // See rationale in `new` for why this us using an unsafe variant below\n@@ -181,18 +178,19 @@ impl Layout {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the combination of `self.size` and the given `align`\n-    /// violates the conditions listed in `from_size_align`.\n+    /// Panics if the combination of `self.size()` and the given `align`\n+    /// violates the conditions listed in\n+    /// [`Layout::from_size_align`](#method.from_size_align).\n     #[inline]\n     pub fn align_to(&self, align: usize) -> Self {\n-        Layout::from_size_align(self.size, cmp::max(self.align, align)).unwrap()\n+        Layout::from_size_align(self.size(), cmp::max(self.align(), align)).unwrap()\n     }\n \n     /// Returns the amount of padding we must insert after `self`\n     /// to ensure that the following address will satisfy `align`\n     /// (measured in bytes).\n     ///\n-    /// E.g. if `self.size` is 9, then `self.padding_needed_for(4)`\n+    /// E.g. if `self.size()` is 9, then `self.padding_needed_for(4)`\n     /// returns 3, because that is the minimum number of bytes of\n     /// padding required to get a 4-aligned address (assuming that the\n     /// corresponding memory block starts at a 4-aligned address).\n@@ -203,7 +201,7 @@ impl Layout {\n     /// Note that the utility of the returned value requires `align`\n     /// to be less than or equal to the alignment of the starting\n     /// address for the whole allocated block of memory. One way to\n-    /// satisfy this constraint is to ensure `align <= self.align`.\n+    /// satisfy this constraint is to ensure `align <= self.align()`.\n     #[inline]\n     pub fn padding_needed_for(&self, align: usize) -> usize {\n         let len = self.size();\n@@ -227,7 +225,8 @@ impl Layout {\n         // size and padding overflow in the above manner should cause\n         // the allocator to yield an error anyway.)\n \n-        let len_rounded_up = len.wrapping_add(align).wrapping_sub(1) & !align.wrapping_sub(1);\n+        let len_rounded_up = len.wrapping_add(align).wrapping_sub(1)\n+            & !align.wrapping_sub(1);\n         return len_rounded_up.wrapping_sub(len);\n     }\n \n@@ -238,14 +237,19 @@ impl Layout {\n     /// layout of the array and `offs` is the distance between the start\n     /// of each element in the array.\n     ///\n-    /// On arithmetic overflow, returns `None`.\n+    /// On arithmetic overflow, returns `LayoutErr`.\n     #[inline]\n     pub fn repeat(&self, n: usize) -> Result<(Self, usize), LayoutErr> {\n-        let padded_size = self.size.checked_add(self.padding_needed_for(self.align))\n+        let padded_size = self.size().checked_add(self.padding_needed_for(self.align()))\n             .ok_or(LayoutErr { private: () })?;\n         let alloc_size = padded_size.checked_mul(n)\n             .ok_or(LayoutErr { private: () })?;\n-        Ok((Layout::from_size_align(alloc_size, self.align)?, padded_size))\n+\n+        unsafe {\n+            // self.align is already known to be valid and alloc_size has been\n+            // padded already.\n+            Ok((Layout::from_size_align_unchecked(alloc_size, self.align()), padded_size))\n+        }\n     }\n \n     /// Creates a layout describing the record for `self` followed by\n@@ -258,16 +262,15 @@ impl Layout {\n     /// start of the `next` embedded within the concatenated record\n     /// (assuming that the record itself starts at offset 0).\n     ///\n-    /// On arithmetic overflow, returns `None`.\n+    /// On arithmetic overflow, returns `LayoutErr`.\n+    #[inline]\n     pub fn extend(&self, next: Self) -> Result<(Self, usize), LayoutErr> {\n-        let new_align = cmp::max(self.align, next.align);\n-        let realigned = Layout::from_size_align(self.size, new_align)?;\n-\n-        let pad = realigned.padding_needed_for(next.align);\n+        let new_align = cmp::max(self.align(), next.align());\n+        let pad = self.padding_needed_for(next.align());\n \n-        let offset = self.size.checked_add(pad)\n+        let offset = self.size().checked_add(pad)\n             .ok_or(LayoutErr { private: () })?;\n-        let new_size = offset.checked_add(next.size)\n+        let new_size = offset.checked_add(next.size())\n             .ok_or(LayoutErr { private: () })?;\n \n         let layout = Layout::from_size_align(new_size, new_align)?;\n@@ -285,10 +288,11 @@ impl Layout {\n     /// guaranteed that all elements in the array will be properly\n     /// aligned.\n     ///\n-    /// On arithmetic overflow, returns `None`.\n+    /// On arithmetic overflow, returns `LayoutErr`.\n+    #[inline]\n     pub fn repeat_packed(&self, n: usize) -> Result<Self, LayoutErr> {\n         let size = self.size().checked_mul(n).ok_or(LayoutErr { private: () })?;\n-        Layout::from_size_align(size, self.align)\n+        Layout::from_size_align(size, self.align())\n     }\n \n     /// Creates a layout describing the record for `self` followed by\n@@ -305,17 +309,19 @@ impl Layout {\n     ///  signature out of convenience in matching the signature of\n     ///  `extend`.)\n     ///\n-    /// On arithmetic overflow, returns `None`.\n+    /// On arithmetic overflow, returns `LayoutErr`.\n+    #[inline]\n     pub fn extend_packed(&self, next: Self) -> Result<(Self, usize), LayoutErr> {\n         let new_size = self.size().checked_add(next.size())\n             .ok_or(LayoutErr { private: () })?;\n-        let layout = Layout::from_size_align(new_size, self.align)?;\n+        let layout = Layout::from_size_align(new_size, self.align())?;\n         Ok((layout, self.size()))\n     }\n \n     /// Creates a layout describing the record for a `[T; n]`.\n     ///\n-    /// On arithmetic overflow, returns `None`.\n+    /// On arithmetic overflow, returns `LayoutErr`.\n+    #[inline]\n     pub fn array<T>(n: usize) -> Result<Self, LayoutErr> {\n         Layout::new::<T>()\n             .repeat(n)\n@@ -842,7 +848,7 @@ pub unsafe trait Alloc {\n                             layout: Layout,\n                             new_size: usize) -> Result<(), CannotReallocInPlace> {\n         let _ = ptr; // this default implementation doesn't care about the actual address.\n-        debug_assert!(new_size >= layout.size);\n+        debug_assert!(new_size >= layout.size());\n         let (_l, u) = self.usable_size(&layout);\n         // _l <= layout.size()                       [guaranteed by usable_size()]\n         //       layout.size() <= new_layout.size()  [required by this method]\n@@ -897,7 +903,7 @@ pub unsafe trait Alloc {\n                               layout: Layout,\n                               new_size: usize) -> Result<(), CannotReallocInPlace> {\n         let _ = ptr; // this default implementation doesn't care about the actual address.\n-        debug_assert!(new_size <= layout.size);\n+        debug_assert!(new_size <= layout.size());\n         let (l, _u) = self.usable_size(&layout);\n         //                      layout.size() <= _u  [guaranteed by usable_size()]\n         // new_layout.size() <= layout.size()        [required by this method]"}]}