{"sha": "5fc14c1a6f66c2d9300afd282210fe743878c9a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmYzE0YzFhNmY2NmMyZDkzMDBhZmQyODIyMTBmZTc0Mzg3OGM5YTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-25T19:14:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-25T19:14:11Z"}, "message": "Auto merge of #36616 - jseyfried:load_macros_in_resolve, r=nrc\n\nLoad macros from `#[macro_use]` extern crates in `resolve`\n\nr? @nrc", "tree": {"sha": "07c02ed8cb4b71557c7e5eb335c2246390272d44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07c02ed8cb4b71557c7e5eb335c2246390272d44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fc14c1a6f66c2d9300afd282210fe743878c9a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fc14c1a6f66c2d9300afd282210fe743878c9a7", "html_url": "https://github.com/rust-lang/rust/commit/5fc14c1a6f66c2d9300afd282210fe743878c9a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fc14c1a6f66c2d9300afd282210fe743878c9a7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49dd95b07807a26f94bf11eb4771bbb7d79ef02c", "url": "https://api.github.com/repos/rust-lang/rust/commits/49dd95b07807a26f94bf11eb4771bbb7d79ef02c", "html_url": "https://github.com/rust-lang/rust/commit/49dd95b07807a26f94bf11eb4771bbb7d79ef02c"}, {"sha": "b4906a93a04fe2659b6b0c3de49a0c5442248585", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4906a93a04fe2659b6b0c3de49a0c5442248585", "html_url": "https://github.com/rust-lang/rust/commit/b4906a93a04fe2659b6b0c3de49a0c5442248585"}], "stats": {"total": 243, "additions": 118, "deletions": 125}, "files": [{"sha": "107cf9b6cae6bd46c32dddd87b319f27953165c9", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5fc14c1a6f66c2d9300afd282210fe743878c9a7/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fc14c1a6f66c2d9300afd282210fe743878c9a7/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=5fc14c1a6f66c2d9300afd282210fe743878c9a7", "patch": "@@ -36,9 +36,10 @@ use session::config::PanicStrategy;\n use session::search_paths::PathKind;\n use util::nodemap::{NodeSet, DefIdMap};\n use std::path::PathBuf;\n+use std::rc::Rc;\n use syntax::ast;\n use syntax::attr;\n-use syntax::ext::base::LoadedMacro;\n+use syntax::ext::base::MultiItemModifier;\n use syntax::ptr::P;\n use syntax::parse::token::InternedString;\n use syntax_pos::Span;\n@@ -422,6 +423,11 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }\n }\n \n+pub enum LoadedMacro {\n+    Def(ast::MacroDef),\n+    CustomDerive(String, Rc<MultiItemModifier>),\n+}\n+\n pub trait CrateLoader {\n     fn load_macros(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<LoadedMacro>;\n     fn process_item(&mut self, item: &ast::Item, defs: &Definitions);"}, {"sha": "9d5dce7ad058eafd0e494067cb6e1722faddf0d6", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5fc14c1a6f66c2d9300afd282210fe743878c9a7/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fc14c1a6f66c2d9300afd282210fe743878c9a7/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=5fc14c1a6f66c2d9300afd282210fe743878c9a7", "patch": "@@ -43,6 +43,7 @@ use super::Compilation;\n use serialize::json;\n \n use std::env;\n+use std::mem;\n use std::ffi::{OsString, OsStr};\n use std::fs;\n use std::io::{self, Write};\n@@ -686,6 +687,8 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n         ret\n     });\n \n+    krate.exported_macros = mem::replace(&mut resolver.exported_macros, Vec::new());\n+\n     krate = time(time_passes, \"maybe building test harness\", || {\n         syntax::test::modify_for_testing(&sess.parse_sess,\n                                          &mut resolver,"}, {"sha": "2e03b7868a3bc8fe18d293435652eb03f4131c19", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fc14c1a6f66c2d9300afd282210fe743878c9a7/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fc14c1a6f66c2d9300afd282210fe743878c9a7/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=5fc14c1a6f66c2d9300afd282210fe743878c9a7", "patch": "@@ -17,6 +17,7 @@ use schema::CrateRoot;\n \n use rustc::hir::def_id::{CrateNum, DefIndex};\n use rustc::hir::svh::Svh;\n+use rustc::middle::cstore::LoadedMacro;\n use rustc::session::{config, Session};\n use rustc::session::config::PanicStrategy;\n use rustc::session::search_paths::PathKind;\n@@ -32,7 +33,6 @@ use std::rc::Rc;\n use std::fs;\n \n use syntax::ast;\n-use syntax::ext::base::LoadedMacro;\n use syntax::abi::Abi;\n use syntax::parse;\n use syntax::attr;"}, {"sha": "2ff7a6c41b551b260e2b4f503c8aca5b498ab4f9", "filename": "src/librustc_metadata/macro_import.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5fc14c1a6f66c2d9300afd282210fe743878c9a7/src%2Flibrustc_metadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fc14c1a6f66c2d9300afd282210fe743878c9a7/src%2Flibrustc_metadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacro_import.rs?ref=5fc14c1a6f66c2d9300afd282210fe743878c9a7", "patch": "@@ -11,20 +11,21 @@\n //! Used by `rustc` when loading a crate with exported macros.\n \n use std::collections::HashSet;\n+use std::rc::Rc;\n use std::env;\n use std::mem;\n \n use creader::{CrateLoader, Macros};\n \n use rustc::hir::def_id::DefIndex;\n+use rustc::middle::cstore::LoadedMacro;\n use rustc::session::Session;\n use rustc::util::nodemap::FnvHashMap;\n use rustc_back::dynamic_lib::DynamicLibrary;\n use rustc_macro::TokenStream;\n use rustc_macro::__internal::Registry;\n use syntax::ast;\n use syntax::attr;\n-use syntax::ext::base::LoadedMacro;\n use syntax::parse::token;\n use syntax_ext::deriving::custom::CustomDerive;\n use syntax_pos::Span;\n@@ -204,9 +205,8 @@ impl<'a> CrateLoader<'a> {\n             fn register_custom_derive(&mut self,\n                                       trait_name: &str,\n                                       expand: fn(TokenStream) -> TokenStream) {\n-                let derive = Box::new(CustomDerive::new(expand));\n-                self.0.push(LoadedMacro::CustomDerive(trait_name.to_string(),\n-                                                      derive));\n+                let derive = Rc::new(CustomDerive::new(expand));\n+                self.0.push(LoadedMacro::CustomDerive(trait_name.to_string(), derive));\n             }\n         }\n "}, {"sha": "fb9819b72ab3e43b40bcb9fc86c14cc2acbdee52", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5fc14c1a6f66c2d9300afd282210fe743878c9a7/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fc14c1a6f66c2d9300afd282210fe743878c9a7/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=5fc14c1a6f66c2d9300afd282210fe743878c9a7", "patch": "@@ -53,6 +53,7 @@ use rustc::ty;\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FnvHashMap, FnvHashSet};\n \n+use syntax::ext::base::MultiItemModifier;\n use syntax::ext::hygiene::Mark;\n use syntax::ast::{self, FloatTy};\n use syntax::ast::{CRATE_NODE_ID, Name, NodeId, IntTy, UintTy};\n@@ -71,6 +72,7 @@ use syntax_pos::{Span, DUMMY_SP};\n use errors::DiagnosticBuilder;\n \n use std::cell::{Cell, RefCell};\n+use std::rc::Rc;\n use std::fmt;\n use std::mem::replace;\n \n@@ -1066,6 +1068,8 @@ pub struct Resolver<'a> {\n     dummy_binding: &'a NameBinding<'a>,\n     new_import_semantics: bool, // true if `#![feature(item_like_imports)]`\n \n+    pub exported_macros: Vec<ast::MacroDef>,\n+    pub derive_modes: FnvHashMap<Name, Rc<MultiItemModifier>>,\n     crate_loader: &'a mut CrateLoader,\n     macro_names: FnvHashSet<Name>,\n \n@@ -1240,6 +1244,8 @@ impl<'a> Resolver<'a> {\n             }),\n             new_import_semantics: session.features.borrow().item_like_imports,\n \n+            exported_macros: Vec::new(),\n+            derive_modes: FnvHashMap(),\n             crate_loader: crate_loader,\n             macro_names: FnvHashSet(),\n             expansion_data: expansion_data,"}, {"sha": "37cb2861c1c0af2204e041f105ba749aa240e103", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 49, "deletions": 8, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/5fc14c1a6f66c2d9300afd282210fe743878c9a7/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fc14c1a6f66c2d9300afd282210fe743878c9a7/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=5fc14c1a6f66c2d9300afd282210fe743878c9a7", "patch": "@@ -9,19 +9,23 @@\n // except according to those terms.\n \n use Resolver;\n+use rustc::middle::cstore::LoadedMacro;\n use rustc::util::nodemap::FnvHashMap;\n use std::cell::RefCell;\n use std::mem;\n use std::rc::Rc;\n use syntax::ast::{self, Name};\n use syntax::errors::DiagnosticBuilder;\n-use syntax::ext::base::{self, LoadedMacro, MultiModifier, MultiDecorator};\n-use syntax::ext::base::{NormalTT, SyntaxExtension};\n+use syntax::ext::base::{self, MultiModifier, MultiDecorator, MultiItemModifier};\n+use syntax::ext::base::{NormalTT, Resolver as SyntaxResolver, SyntaxExtension};\n use syntax::ext::expand::{Expansion, Invocation, InvocationKind};\n use syntax::ext::hygiene::Mark;\n-use syntax::parse::token::intern;\n+use syntax::ext::tt::macro_rules;\n+use syntax::feature_gate::{self, emit_feature_err};\n+use syntax::parse::token::{self, intern};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::visit::{self, Visitor};\n+use syntax_pos::Span;\n \n #[derive(Clone, Default)]\n pub struct ExpansionData {\n@@ -37,10 +41,6 @@ struct ModuleData {\n }\n \n impl<'a> base::Resolver for Resolver<'a> {\n-    fn load_crate(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<LoadedMacro> {\n-        self.crate_loader.load_macros(extern_crate, allows_macros)\n-    }\n-\n     fn next_node_id(&mut self) -> ast::NodeId {\n         self.session.next_node_id()\n     }\n@@ -52,7 +52,18 @@ impl<'a> base::Resolver for Resolver<'a> {\n         });\n     }\n \n-    fn add_macro(&mut self, scope: Mark, ident: ast::Ident, ext: Rc<SyntaxExtension>) {\n+    fn add_macro(&mut self, scope: Mark, mut def: ast::MacroDef) {\n+        if def.use_locally {\n+            let ext = macro_rules::compile(&self.session.parse_sess, &def);\n+            self.add_ext(scope, def.ident, Rc::new(ext));\n+        }\n+        if def.export {\n+            def.id = self.next_node_id();\n+            self.exported_macros.push(def);\n+        }\n+    }\n+\n+    fn add_ext(&mut self, scope: Mark, ident: ast::Ident, ext: Rc<SyntaxExtension>) {\n         if let NormalTT(..) = *ext {\n             self.macro_names.insert(ident.name);\n         }\n@@ -116,6 +127,10 @@ impl<'a> base::Resolver for Resolver<'a> {\n         err.emit();\n         None\n     }\n+\n+    fn resolve_derive_mode(&mut self, ident: ast::Ident) -> Option<Rc<MultiItemModifier>> {\n+        self.derive_modes.get(&ident.name).cloned()\n+    }\n }\n \n impl<'a> Resolver<'a> {\n@@ -128,6 +143,17 @@ impl<'a> Resolver<'a> {\n             }\n         }\n     }\n+\n+    fn insert_custom_derive(&mut self, name: &str, ext: Rc<MultiItemModifier>, sp: Span) {\n+        if !self.session.features.borrow().rustc_macro {\n+            let diagnostic = &self.session.parse_sess.span_diagnostic;\n+            let msg = \"loading custom derive macro crates is experimentally supported\";\n+            emit_feature_err(diagnostic, \"rustc_macro\", sp, feature_gate::GateIssue::Language, msg);\n+        }\n+        if self.derive_modes.insert(token::intern(name), ext).is_some() {\n+            self.session.span_err(sp, &format!(\"cannot shadow existing derive mode `{}`\", name));\n+        }\n+    }\n }\n \n struct ExpansionVisitor<'b, 'a: 'b> {\n@@ -201,6 +227,21 @@ impl<'a, 'b> Visitor for ExpansionVisitor<'a, 'b>  {\n                 visit::walk_item(self, item);\n                 self.current_module = orig_module;\n             }\n+            ast::ItemKind::ExternCrate(..) => {\n+                // We need to error on `#[macro_use] extern crate` when it isn't at the\n+                // crate root, because `$crate` won't work properly.\n+                // FIXME(jseyfried): This will be nicer once `ModuleData` is merged with `ModuleS`.\n+                let is_crate_root = self.current_module.parent.as_ref().unwrap().parent.is_none();\n+                for def in self.resolver.crate_loader.load_macros(item, is_crate_root) {\n+                    match def {\n+                        LoadedMacro::Def(def) => self.resolver.add_macro(Mark::root(), def),\n+                        LoadedMacro::CustomDerive(name, ext) => {\n+                            self.resolver.insert_custom_derive(&name, ext, item.span);\n+                        }\n+                    }\n+                }\n+                visit::walk_item(self, item);\n+            }\n             _ => visit::walk_item(self, item),\n         }\n     }"}, {"sha": "3e85565beb6d118e2da672622e67def58b0f15fd", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 8, "deletions": 46, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5fc14c1a6f66c2d9300afd282210fe743878c9a7/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fc14c1a6f66c2d9300afd282210fe743878c9a7/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=5fc14c1a6f66c2d9300afd282210fe743878c9a7", "patch": "@@ -17,19 +17,15 @@ use syntax_pos::{Span, ExpnId, NO_EXPANSION};\n use errors::DiagnosticBuilder;\n use ext::expand::{self, Invocation, Expansion};\n use ext::hygiene::Mark;\n-use ext::tt::macro_rules;\n-use fold;\n+use fold::{self, Folder};\n use parse;\n use parse::parser::{self, Parser};\n use parse::token;\n use parse::token::{InternedString, str_to_ident};\n use ptr::P;\n use std_inject;\n use util::small_vector::SmallVector;\n-use fold::Folder;\n-use feature_gate;\n \n-use std::collections::HashMap;\n use std::path::PathBuf;\n use std::rc::Rc;\n use std::default::Default;\n@@ -659,35 +655,30 @@ pub enum SyntaxExtension {\n pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n \n pub trait Resolver {\n-    fn load_crate(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<LoadedMacro>;\n     fn next_node_id(&mut self) -> ast::NodeId;\n \n     fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion);\n-    fn add_macro(&mut self, scope: Mark, ident: ast::Ident, ext: Rc<SyntaxExtension>);\n+    fn add_macro(&mut self, scope: Mark, def: ast::MacroDef);\n+    fn add_ext(&mut self, scope: Mark, ident: ast::Ident, ext: Rc<SyntaxExtension>);\n     fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>);\n \n     fn find_attr_invoc(&mut self, attrs: &mut Vec<Attribute>) -> Option<Attribute>;\n     fn resolve_invoc(&mut self, scope: Mark, invoc: &Invocation) -> Option<Rc<SyntaxExtension>>;\n-}\n-\n-pub enum LoadedMacro {\n-    Def(ast::MacroDef),\n-    CustomDerive(String, Box<MultiItemModifier>),\n+    fn resolve_derive_mode(&mut self, ident: ast::Ident) -> Option<Rc<MultiItemModifier>>;\n }\n \n pub struct DummyResolver;\n \n impl Resolver for DummyResolver {\n-    fn load_crate(&mut self, _extern_crate: &ast::Item, _allows_macros: bool) -> Vec<LoadedMacro> {\n-        Vec::new()\n-    }\n     fn next_node_id(&mut self) -> ast::NodeId { ast::DUMMY_NODE_ID }\n \n     fn visit_expansion(&mut self, _invoc: Mark, _expansion: &Expansion) {}\n-    fn add_macro(&mut self, _scope: Mark, _ident: ast::Ident, _ext: Rc<SyntaxExtension>) {}\n+    fn add_macro(&mut self, _scope: Mark, _def: ast::MacroDef) {}\n+    fn add_ext(&mut self, _scope: Mark, _ident: ast::Ident, _ext: Rc<SyntaxExtension>) {}\n     fn add_expansions_at_stmt(&mut self, _id: ast::NodeId, _macros: Vec<Mark>) {}\n \n     fn find_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>) -> Option<Attribute> { None }\n+    fn resolve_derive_mode(&mut self, _ident: ast::Ident) -> Option<Rc<MultiItemModifier>> { None }\n     fn resolve_invoc(&mut self, _scope: Mark, _invoc: &Invocation) -> Option<Rc<SyntaxExtension>> {\n         None\n     }\n@@ -717,8 +708,6 @@ pub struct ExtCtxt<'a> {\n     pub ecfg: expand::ExpansionConfig<'a>,\n     pub crate_root: Option<&'static str>,\n     pub resolver: &'a mut Resolver,\n-    pub exported_macros: Vec<ast::MacroDef>,\n-    pub derive_modes: HashMap<InternedString, Box<MultiItemModifier>>,\n     pub current_expansion: ExpansionData,\n }\n \n@@ -732,9 +721,7 @@ impl<'a> ExtCtxt<'a> {\n             cfg: cfg,\n             ecfg: ecfg,\n             crate_root: None,\n-            exported_macros: Vec::new(),\n             resolver: resolver,\n-            derive_modes: HashMap::new(),\n             current_expansion: ExpansionData {\n                 mark: Mark::root(),\n                 depth: 0,\n@@ -811,31 +798,6 @@ impl<'a> ExtCtxt<'a> {\n     }\n     pub fn bt_pop(&mut self) {}\n \n-    pub fn insert_macro(&mut self, def: ast::MacroDef) {\n-        if def.export {\n-            self.exported_macros.push(def.clone());\n-        }\n-        if def.use_locally {\n-            let ext = macro_rules::compile(self, &def);\n-            self.resolver.add_macro(self.current_expansion.mark, def.ident, Rc::new(ext));\n-        }\n-    }\n-\n-    pub fn insert_custom_derive(&mut self, name: &str, ext: Box<MultiItemModifier>, sp: Span) {\n-        if !self.ecfg.enable_rustc_macro() {\n-            feature_gate::emit_feature_err(&self.parse_sess.span_diagnostic,\n-                                           \"rustc_macro\",\n-                                           sp,\n-                                           feature_gate::GateIssue::Language,\n-                                           \"loading custom derive macro crates \\\n-                                            is experimentally supported\");\n-        }\n-        let name = token::intern_and_get_ident(name);\n-        if self.derive_modes.insert(name.clone(), ext).is_some() {\n-            self.span_err(sp, &format!(\"cannot shadow existing derive mode `{}`\", name));\n-        }\n-    }\n-\n     pub fn struct_span_warn(&self,\n                             sp: Span,\n                             msg: &str)\n@@ -922,7 +884,7 @@ impl<'a> ExtCtxt<'a> {\n \n         for (name, extension) in user_exts {\n             let ident = ast::Ident::with_empty_ctxt(name);\n-            self.resolver.add_macro(Mark::root(), ident, Rc::new(extension));\n+            self.resolver.add_ext(Mark::root(), ident, Rc::new(extension));\n         }\n \n         let mut module = ModuleData {"}, {"sha": "7359c21ecccacc134710c75bca158fd104f5a308", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5fc14c1a6f66c2d9300afd282210fe743878c9a7/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fc14c1a6f66c2d9300afd282210fe743878c9a7/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=5fc14c1a6f66c2d9300afd282210fe743878c9a7", "patch": "@@ -199,11 +199,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             },\n             _ => unreachable!(),\n         };\n-        krate.exported_macros = mem::replace(&mut self.cx.exported_macros, Vec::new());\n-\n-        for def in &mut krate.exported_macros {\n-            def.id = self.cx.resolver.next_node_id()\n-        }\n \n         if self.cx.parse_sess.span_diagnostic.err_count() > err_count {\n             self.cx.parse_sess.span_diagnostic.abort_if_errors();\n@@ -672,20 +667,6 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                 self.cx.current_expansion.module = orig_module;\n                 return result;\n             }\n-            ast::ItemKind::ExternCrate(..) => {\n-                // We need to error on `#[macro_use] extern crate` when it isn't at the\n-                // crate root, because `$crate` won't work properly.\n-                let is_crate_root = self.cx.current_expansion.module.mod_path.len() == 1;\n-                for def in self.cx.resolver.load_crate(&*item, is_crate_root) {\n-                    match def {\n-                        LoadedMacro::Def(def) => self.cx.insert_macro(def),\n-                        LoadedMacro::CustomDerive(name, ext) => {\n-                            self.cx.insert_custom_derive(&name, ext, item.span);\n-                        }\n-                    }\n-                }\n-                noop_fold_item(item, self)\n-            },\n             _ => noop_fold_item(item, self),\n         }\n     }"}, {"sha": "0eed3e5898c00d17747b6fe7cddb03389ad6e7dc", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 37, "deletions": 43, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/5fc14c1a6f66c2d9300afd282210fe743878c9a7/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fc14c1a6f66c2d9300afd282210fe743878c9a7/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=5fc14c1a6f66c2d9300afd282210fe743878c9a7", "patch": "@@ -16,6 +16,7 @@ use ext::placeholders;\n use ext::tt::macro_parser::{Success, Error, Failure};\n use ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n use ext::tt::macro_parser::parse;\n+use parse::ParseSess;\n use parse::lexer::new_tt_reader;\n use parse::parser::{Parser, Restrictions};\n use parse::token::{self, gensym_ident, NtTT, Token};\n@@ -204,7 +205,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                     _ => cx.span_bug(sp, \"malformed macro rhs\"),\n                 };\n                 // rhs has holes ( `$id` and `$(...)` that need filled)\n-                let trncbr = new_tt_reader(&cx.parse_sess().span_diagnostic,\n+                let trncbr = new_tt_reader(&cx.parse_sess.span_diagnostic,\n                                            Some(named_matches),\n                                            imported_from,\n                                            rhs);\n@@ -261,14 +262,15 @@ impl IdentMacroExpander for MacroRulesExpander {\n             attrs: attrs,\n         };\n \n-        cx.insert_macro(def.clone());\n-\n         // If keep_macs is true, expands to a MacEager::items instead.\n-        if cx.ecfg.keep_macs {\n+        let result = if cx.ecfg.keep_macs {\n             MacEager::items(placeholders::reconstructed_macro_rules(&def).make_items())\n         } else {\n             MacEager::items(placeholders::macro_scope_placeholder().make_items())\n-        }\n+        };\n+\n+        cx.resolver.add_macro(cx.current_expansion.mark, def);\n+        result\n     }\n }\n \n@@ -278,9 +280,7 @@ impl IdentMacroExpander for MacroRulesExpander {\n // Holy self-referential!\n \n /// Converts a `macro_rules!` invocation into a syntax extension.\n-pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n-                    def: &ast::MacroDef) -> SyntaxExtension {\n-\n+pub fn compile(sess: &ParseSess, def: &ast::MacroDef) -> SyntaxExtension {\n     let lhs_nm =  gensym_ident(\"lhs\");\n     let rhs_nm =  gensym_ident(\"rhs\");\n \n@@ -312,19 +312,12 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n     ];\n \n     // Parse the macro_rules! invocation (`none` is for no interpolations):\n-    let arg_reader = new_tt_reader(&cx.parse_sess().span_diagnostic,\n-                                   None,\n-                                   None,\n-                                   def.body.clone());\n-\n-    let argument_map = match parse(cx.parse_sess(),\n-                                   cx.cfg(),\n-                                   arg_reader,\n-                                   &argument_gram) {\n+    let arg_reader = new_tt_reader(&sess.span_diagnostic, None, None, def.body.clone());\n+\n+    let argument_map = match parse(sess, Vec::new(), arg_reader, &argument_gram) {\n         Success(m) => m,\n         Failure(sp, str) | Error(sp, str) => {\n-            panic!(cx.parse_sess().span_diagnostic\n-                     .span_fatal(sp.substitute_dummy(def.span), &str[..]));\n+            panic!(sess.span_diagnostic.span_fatal(sp.substitute_dummy(def.span), &str));\n         }\n     };\n \n@@ -335,27 +328,27 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n         MatchedSeq(ref s, _) => {\n             s.iter().map(|m| match **m {\n                 MatchedNonterminal(NtTT(ref tt)) => {\n-                    valid &= check_lhs_nt_follows(cx, tt);\n+                    valid &= check_lhs_nt_follows(sess, tt);\n                     (**tt).clone()\n                 }\n-                _ => cx.span_bug(def.span, \"wrong-structured lhs\")\n+                _ => sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n             }).collect()\n         }\n-        _ => cx.span_bug(def.span, \"wrong-structured lhs\")\n+        _ => sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n     };\n \n     let rhses = match **argument_map.get(&rhs_nm).unwrap() {\n         MatchedSeq(ref s, _) => {\n             s.iter().map(|m| match **m {\n                 MatchedNonterminal(NtTT(ref tt)) => (**tt).clone(),\n-                _ => cx.span_bug(def.span, \"wrong-structured rhs\")\n+                _ => sess.span_diagnostic.span_bug(def.span, \"wrong-structured rhs\")\n             }).collect()\n         }\n-        _ => cx.span_bug(def.span, \"wrong-structured rhs\")\n+        _ => sess.span_diagnostic.span_bug(def.span, \"wrong-structured rhs\")\n     };\n \n     for rhs in &rhses {\n-        valid &= check_rhs(cx, rhs);\n+        valid &= check_rhs(sess, rhs);\n     }\n \n     let exp: Box<_> = Box::new(MacroRulesMacroExpander {\n@@ -369,35 +362,35 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n     NormalTT(exp, Some(def.span), def.allow_internal_unstable)\n }\n \n-fn check_lhs_nt_follows(cx: &mut ExtCtxt, lhs: &TokenTree) -> bool {\n+fn check_lhs_nt_follows(sess: &ParseSess, lhs: &TokenTree) -> bool {\n     // lhs is going to be like TokenTree::Delimited(...), where the\n     // entire lhs is those tts. Or, it can be a \"bare sequence\", not wrapped in parens.\n     match lhs {\n-        &TokenTree::Delimited(_, ref tts) => check_matcher(cx, &tts.tts),\n+        &TokenTree::Delimited(_, ref tts) => check_matcher(sess, &tts.tts),\n         _ => {\n-            cx.span_err(lhs.get_span(), \"invalid macro matcher; matchers must \\\n-                                         be contained in balanced delimiters\");\n+            let msg = \"invalid macro matcher; matchers must be contained in balanced delimiters\";\n+            sess.span_diagnostic.span_err(lhs.get_span(), msg);\n             false\n         }\n     }\n     // we don't abort on errors on rejection, the driver will do that for us\n     // after parsing/expansion. we can report every error in every macro this way.\n }\n \n-fn check_rhs(cx: &mut ExtCtxt, rhs: &TokenTree) -> bool {\n+fn check_rhs(sess: &ParseSess, rhs: &TokenTree) -> bool {\n     match *rhs {\n         TokenTree::Delimited(..) => return true,\n-        _ => cx.span_err(rhs.get_span(), \"macro rhs must be delimited\")\n+        _ => sess.span_diagnostic.span_err(rhs.get_span(), \"macro rhs must be delimited\")\n     }\n     false\n }\n \n-fn check_matcher(cx: &mut ExtCtxt, matcher: &[TokenTree]) -> bool {\n+fn check_matcher(sess: &ParseSess, matcher: &[TokenTree]) -> bool {\n     let first_sets = FirstSets::new(matcher);\n     let empty_suffix = TokenSet::empty();\n-    let err = cx.parse_sess.span_diagnostic.err_count();\n-    check_matcher_core(cx, &first_sets, matcher, &empty_suffix);\n-    err == cx.parse_sess.span_diagnostic.err_count()\n+    let err = sess.span_diagnostic.err_count();\n+    check_matcher_core(sess, &first_sets, matcher, &empty_suffix);\n+    err == sess.span_diagnostic.err_count()\n }\n \n // The FirstSets for a matcher is a mapping from subsequences in the\n@@ -635,7 +628,7 @@ impl TokenSet {\n //\n // Requires that `first_sets` is pre-computed for `matcher`;\n // see `FirstSets::new`.\n-fn check_matcher_core(cx: &mut ExtCtxt,\n+fn check_matcher_core(sess: &ParseSess,\n                       first_sets: &FirstSets,\n                       matcher: &[TokenTree],\n                       follow: &TokenSet) -> TokenSet {\n@@ -667,7 +660,8 @@ fn check_matcher_core(cx: &mut ExtCtxt,\n             TokenTree::Token(sp, ref tok) => {\n                 let can_be_followed_by_any;\n                 if let Err(bad_frag) = has_legal_fragment_specifier(tok) {\n-                    cx.struct_span_err(sp, &format!(\"invalid fragment specifier `{}`\", bad_frag))\n+                    let msg = format!(\"invalid fragment specifier `{}`\", bad_frag);\n+                    sess.span_diagnostic.struct_span_err(sp, &msg)\n                         .help(\"valid fragment specifiers are `ident`, `block`, \\\n                                `stmt`, `expr`, `pat`, `ty`, `path`, `meta`, `tt` \\\n                                and `item`\")\n@@ -692,7 +686,7 @@ fn check_matcher_core(cx: &mut ExtCtxt,\n             }\n             TokenTree::Delimited(_, ref d) => {\n                 let my_suffix = TokenSet::singleton((d.close_span, Token::CloseDelim(d.delim)));\n-                check_matcher_core(cx, first_sets, &d.tts, &my_suffix);\n+                check_matcher_core(sess, first_sets, &d.tts, &my_suffix);\n                 // don't track non NT tokens\n                 last.replace_with_irrelevant();\n \n@@ -724,7 +718,7 @@ fn check_matcher_core(cx: &mut ExtCtxt,\n                 // At this point, `suffix_first` is built, and\n                 // `my_suffix` is some TokenSet that we can use\n                 // for checking the interior of `seq_rep`.\n-                let next = check_matcher_core(cx, first_sets, &seq_rep.tts, my_suffix);\n+                let next = check_matcher_core(sess, first_sets, &seq_rep.tts, my_suffix);\n                 if next.maybe_empty {\n                     last.add_all(&next);\n                 } else {\n@@ -744,9 +738,9 @@ fn check_matcher_core(cx: &mut ExtCtxt,\n         'each_last: for &(_sp, ref t) in &last.tokens {\n             if let MatchNt(ref name, ref frag_spec) = *t {\n                 for &(sp, ref next_token) in &suffix_first.tokens {\n-                    match is_in_follow(cx, next_token, &frag_spec.name.as_str()) {\n+                    match is_in_follow(next_token, &frag_spec.name.as_str()) {\n                         Err((msg, help)) => {\n-                            cx.struct_span_err(sp, &msg).help(help).emit();\n+                            sess.span_diagnostic.struct_span_err(sp, &msg).help(help).emit();\n                             // don't bother reporting every source of\n                             // conflict for a particular element of `last`.\n                             continue 'each_last;\n@@ -761,7 +755,7 @@ fn check_matcher_core(cx: &mut ExtCtxt,\n                                 \"may be\"\n                             };\n \n-                            cx.span_err(\n+                            sess.span_diagnostic.span_err(\n                                 sp,\n                                 &format!(\"`${name}:{frag}` {may_be} followed by `{next}`, which \\\n                                           is not allowed for `{frag}` fragments\",\n@@ -818,7 +812,7 @@ fn frag_can_be_followed_by_any(frag: &str) -> bool {\n /// break macros that were relying on that binary operator as a\n /// separator.\n // when changing this do not forget to update doc/book/macros.md!\n-fn is_in_follow(_: &ExtCtxt, tok: &Token, frag: &str) -> Result<bool, (String, &'static str)> {\n+fn is_in_follow(tok: &Token, frag: &str) -> Result<bool, (String, &'static str)> {\n     if let &CloseDelim(_) = tok {\n         // closing a token tree can never be matched by any fragment;\n         // iow, we always require that `(` and `)` match, etc."}, {"sha": "c3c2f7eabb9c797d3a2a812eb3ecbe4e0579b083", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fc14c1a6f66c2d9300afd282210fe743878c9a7/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fc14c1a6f66c2d9300afd282210fe743878c9a7/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=5fc14c1a6f66c2d9300afd282210fe743878c9a7", "patch": "@@ -195,7 +195,8 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n         // If custom derive extensions end up threading through the `#[derive]`\n         // attribute, we'll get called again later on to continue expanding\n         // those modes.\n-        } else if let Some(ext) = cx.derive_modes.remove(&tname) {\n+        } else if let Some(ext) =\n+                   cx.resolver.resolve_derive_mode(ast::Ident::with_empty_ctxt(intern(&tname))) {\n             let remaining_derives = iter.cloned().collect::<Vec<_>>();\n             if remaining_derives.len() > 0 {\n                 let list = cx.meta_list(titem.span,\n@@ -214,7 +215,6 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n             let item = Annotatable::Item(item);\n             let mut items = ext.expand(cx, mitem.span, &mitem, item);\n             items.extend(other_items);\n-            cx.derive_modes.insert(tname.clone(), ext);\n             return items\n \n         // If we've gotten this far then it means that we're in the territory of"}, {"sha": "bd9f1cf0d77f1a6e7d7abbff8d91044a2c325497", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fc14c1a6f66c2d9300afd282210fe743878c9a7/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fc14c1a6f66c2d9300afd282210fe743878c9a7/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=5fc14c1a6f66c2d9300afd282210fe743878c9a7", "patch": "@@ -57,7 +57,7 @@ use syntax::parse::token::intern;\n \n pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver, enable_quotes: bool) {\n     let mut register = |name, ext| {\n-        resolver.add_macro(Mark::root(), ast::Ident::with_empty_ctxt(intern(name)), Rc::new(ext));\n+        resolver.add_ext(Mark::root(), ast::Ident::with_empty_ctxt(intern(name)), Rc::new(ext));\n     };\n \n     register(\"macro_rules\", IdentTT(Box::new(MacroRulesExpander), None, false));"}]}