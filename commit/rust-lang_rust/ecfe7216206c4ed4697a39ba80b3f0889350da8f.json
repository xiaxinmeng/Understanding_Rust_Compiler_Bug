{"sha": "ecfe7216206c4ed4697a39ba80b3f0889350da8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjZmU3MjE2MjA2YzRlZDQ2OTdhMzliYTgwYjNmMDg4OTM1MGRhOGY=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-11-30T18:29:45Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-11-30T18:29:45Z"}, "message": "Rollup merge of #56324 - Zoxc:int-ext, r=nikomatsakis\n\nUse raw_entry for more efficient interning\n\nFixes https://github.com/rust-lang/rust/issues/56308#issuecomment-442492744", "tree": {"sha": "b26c376fa756c7d9dc1e9fe1386f3a81313acbcb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b26c376fa756c7d9dc1e9fe1386f3a81313acbcb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecfe7216206c4ed4697a39ba80b3f0889350da8f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlwBgZkACgkQ/vbIBR0O\nATwRYA/+PdriMDuDpCF4L/ZKuy4i2Kw+0EDFxW27KJxUkfAIQtnvlygZXPRWCZM7\n2oyfSqt2/0ejO8Ue1Ck2LdyVxgCjQx/SzSYU8e7bYCmPE9kaignU9qmjqvmBVvdm\n6Ep9rDF6PPp+mLkqAhZfgHrmwpI8XnxJhjZK/TEPTvndS6Jgcp5WsIGGGrPqQUUe\nYKCxu6xvI7xyBKTxdQAPmytCe3ovJix9eGplJ7Zdd0AB9gIrHbsHRuiPSK5dCv7N\ncUM0x4V9LKEQ1ZC9Hs76uSlE6HR6KfPbuqgAszOGTx9eMgtuNwiHD1uaL3jip+8B\nlru6iHB5WuRYfBf9PrzCGkDdA5G5JQv/wSj26/FUAJpwtu27+W6DbNisg+fOcv9f\ndeem5cZxSONfM1AWXW7bxthHHPRjthBOVyMFBwqeklrYpWuLEj3A4TNYR9ADVboG\nZ/E2/WpIUMxNVa+kIgzrUktxIi3lSHPmHxGm7IxUmF77Rt9DdqjQKjryq2Y0/vxc\nDJajIzWufyUGjRo/4cMeaPxQ0EYfUmmZLOiiMFfoS3RSXmbAVR6Klohl2Knx3Nd2\nr6tocStcYLKZ8hy5rzhvQ/TX+fI7uF7XOUgg+wWuvmDsFg0sgyNEGRGhPh2JxGkp\nVMM28S+I2qdfp75FtZXU9J+ScHRyaCySMx/9PvYImMw5wwOHV1s=\n=i18z\n-----END PGP SIGNATURE-----", "payload": "tree b26c376fa756c7d9dc1e9fe1386f3a81313acbcb\nparent 2584d9216d717fba24ba5770275b2621a50babfe\nparent 946ea1453d5a611084566c190cea60d9ccd41697\nauthor kennytm <kennytm@gmail.com> 1543602585 +0800\ncommitter kennytm <kennytm@gmail.com> 1543602585 +0800\n\nRollup merge of #56324 - Zoxc:int-ext, r=nikomatsakis\n\nUse raw_entry for more efficient interning\n\nFixes https://github.com/rust-lang/rust/issues/56308#issuecomment-442492744\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecfe7216206c4ed4697a39ba80b3f0889350da8f", "html_url": "https://github.com/rust-lang/rust/commit/ecfe7216206c4ed4697a39ba80b3f0889350da8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecfe7216206c4ed4697a39ba80b3f0889350da8f/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2584d9216d717fba24ba5770275b2621a50babfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/2584d9216d717fba24ba5770275b2621a50babfe", "html_url": "https://github.com/rust-lang/rust/commit/2584d9216d717fba24ba5770275b2621a50babfe"}, {"sha": "946ea1453d5a611084566c190cea60d9ccd41697", "url": "https://api.github.com/repos/rust-lang/rust/commits/946ea1453d5a611084566c190cea60d9ccd41697", "html_url": "https://github.com/rust-lang/rust/commit/946ea1453d5a611084566c190cea60d9ccd41697"}], "stats": {"total": 268, "additions": 157, "deletions": 111}, "files": [{"sha": "955cab1d93f769ebac5a7e9700faa4e430db57fc", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecfe7216206c4ed4697a39ba80b3f0889350da8f/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecfe7216206c4ed4697a39ba80b3f0889350da8f/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=ecfe7216206c4ed4697a39ba80b3f0889350da8f", "patch": "@@ -298,6 +298,7 @@ pub struct DroplessArena {\n unsafe impl Send for DroplessArena {}\n \n impl Default for DroplessArena {\n+    #[inline]\n     fn default() -> DroplessArena {\n         DroplessArena {\n             ptr: Cell::new(0 as *mut u8),\n@@ -319,6 +320,7 @@ impl DroplessArena {\n         false\n     }\n \n+    #[inline]\n     fn align(&self, align: usize) {\n         let final_address = ((self.ptr.get() as usize) + align - 1) & !(align - 1);\n         self.ptr.set(final_address as *mut u8);"}, {"sha": "42a4de1682c391e71b0101a223b2120965aad385", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 74, "deletions": 111, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/ecfe7216206c4ed4697a39ba80b3f0889350da8f/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecfe7216206c4ed4697a39ba80b3f0889350da8f/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=ecfe7216206c4ed4697a39ba80b3f0889350da8f", "patch": "@@ -53,6 +53,7 @@ use ty::CanonicalTy;\n use ty::CanonicalPolyFnSig;\n use util::nodemap::{DefIdMap, DefIdSet, ItemLocalMap};\n use util::nodemap::{FxHashMap, FxHashSet};\n+use rustc_data_structures::interner::HashInterner;\n use smallvec::SmallVec;\n use rustc_data_structures::stable_hasher::{HashStable, hash_stable_hashmap,\n                                            StableHasher, StableHasherResult,\n@@ -113,7 +114,7 @@ pub struct GlobalArenas<'tcx> {\n     const_allocs: TypedArena<interpret::Allocation>,\n }\n \n-type InternedSet<'tcx, T> = Lock<FxHashSet<Interned<'tcx, T>>>;\n+type InternedSet<'tcx, T> = Lock<FxHashMap<Interned<'tcx, T>, ()>>;\n \n pub struct CtxtInterners<'tcx> {\n     /// The arena that types, regions, etc are allocated from\n@@ -167,51 +168,39 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n         // determine that all contents are in the global tcx.\n         // See comments on Lift for why we can't use that.\n         if flags.flags.intersects(ty::TypeFlags::KEEP_IN_LOCAL_TCX) {\n-            let mut interner = local.type_.borrow_mut();\n-            if let Some(&Interned(ty)) = interner.get(&st) {\n-                return ty;\n-            }\n-\n-            let ty_struct = TyS {\n-                sty: st,\n-                flags: flags.flags,\n-                outer_exclusive_binder: flags.outer_exclusive_binder,\n-            };\n+            local.type_.borrow_mut().intern(st, |st| {\n+                let ty_struct = TyS {\n+                    sty: st,\n+                    flags: flags.flags,\n+                    outer_exclusive_binder: flags.outer_exclusive_binder,\n+                };\n \n-            // Make sure we don't end up with inference\n-            // types/regions in the global interner\n-            if local as *const _ as usize == global as *const _ as usize {\n-                bug!(\"Attempted to intern `{:?}` which contains \\\n-                      inference types/regions in the global type context\",\n-                     &ty_struct);\n-            }\n+                // Make sure we don't end up with inference\n+                // types/regions in the global interner\n+                if local as *const _ as usize == global as *const _ as usize {\n+                    bug!(\"Attempted to intern `{:?}` which contains \\\n+                        inference types/regions in the global type context\",\n+                        &ty_struct);\n+                }\n \n-            // Don't be &mut TyS.\n-            let ty: Ty<'tcx> = local.arena.alloc(ty_struct);\n-            interner.insert(Interned(ty));\n-            ty\n+                Interned(local.arena.alloc(ty_struct))\n+            }).0\n         } else {\n-            let mut interner = global.type_.borrow_mut();\n-            if let Some(&Interned(ty)) = interner.get(&st) {\n-                return ty;\n-            }\n-\n-            let ty_struct = TyS {\n-                sty: st,\n-                flags: flags.flags,\n-                outer_exclusive_binder: flags.outer_exclusive_binder,\n-            };\n+            global.type_.borrow_mut().intern(st, |st| {\n+                let ty_struct = TyS {\n+                    sty: st,\n+                    flags: flags.flags,\n+                    outer_exclusive_binder: flags.outer_exclusive_binder,\n+                };\n \n-            // This is safe because all the types the ty_struct can point to\n-            // already is in the global arena\n-            let ty_struct: TyS<'gcx> = unsafe {\n-                mem::transmute(ty_struct)\n-            };\n+                // This is safe because all the types the ty_struct can point to\n+                // already is in the global arena\n+                let ty_struct: TyS<'gcx> = unsafe {\n+                    mem::transmute(ty_struct)\n+                };\n \n-            // Don't be &mut TyS.\n-            let ty: Ty<'gcx> = global.arena.alloc(ty_struct);\n-            interner.insert(Interned(ty));\n-            ty\n+                Interned(global.arena.alloc(ty_struct))\n+            }).0\n         }\n     }\n }\n@@ -827,12 +816,9 @@ impl<'tcx> CommonTypes<'tcx> {\n     fn new(interners: &CtxtInterners<'tcx>) -> CommonTypes<'tcx> {\n         let mk = |sty| CtxtInterners::intern_ty(interners, interners, sty);\n         let mk_region = |r| {\n-            if let Some(r) = interners.region.borrow().get(&r) {\n-                return r.0;\n-            }\n-            let r = interners.arena.alloc(r);\n-            interners.region.borrow_mut().insert(Interned(r));\n-            &*r\n+            interners.region.borrow_mut().intern(r, |r| {\n+                Interned(interners.arena.alloc(r))\n+            }).0\n         };\n \n         CommonTypes {\n@@ -955,14 +941,14 @@ pub struct GlobalCtxt<'tcx> {\n     /// Data layout specification for the current target.\n     pub data_layout: TargetDataLayout,\n \n-    stability_interner: Lock<FxHashSet<&'tcx attr::Stability>>,\n+    stability_interner: Lock<FxHashMap<&'tcx attr::Stability, ()>>,\n \n     /// Stores the value of constants (and deduplicates the actual memory)\n-    allocation_interner: Lock<FxHashSet<&'tcx Allocation>>,\n+    allocation_interner: Lock<FxHashMap<&'tcx Allocation, ()>>,\n \n     pub alloc_map: Lock<interpret::AllocMap<'tcx, &'tcx Allocation>>,\n \n-    layout_interner: Lock<FxHashSet<&'tcx LayoutDetails>>,\n+    layout_interner: Lock<FxHashMap<&'tcx LayoutDetails, ()>>,\n \n     /// A general purpose channel to throw data out the back towards LLVM worker\n     /// threads.\n@@ -1045,16 +1031,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self,\n         alloc: Allocation,\n     ) -> &'gcx Allocation {\n-        let allocs = &mut self.allocation_interner.borrow_mut();\n-        if let Some(alloc) = allocs.get(&alloc) {\n-            return alloc;\n-        }\n-\n-        let interned = self.global_arenas.const_allocs.alloc(alloc);\n-        if let Some(prev) = allocs.replace(interned) { // insert into interner\n-            bug!(\"Tried to overwrite interned Allocation: {:#?}\", prev)\n-        }\n-        interned\n+        self.allocation_interner.borrow_mut().intern(alloc, |alloc| {\n+            self.global_arenas.const_allocs.alloc(alloc)\n+        })\n     }\n \n     /// Allocates a byte or string literal for `mir::interpret`, read-only\n@@ -1066,29 +1045,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn intern_stability(self, stab: attr::Stability) -> &'gcx attr::Stability {\n-        let mut stability_interner = self.stability_interner.borrow_mut();\n-        if let Some(st) = stability_interner.get(&stab) {\n-            return st;\n-        }\n-\n-        let interned = self.global_interners.arena.alloc(stab);\n-        if let Some(prev) = stability_interner.replace(interned) {\n-            bug!(\"Tried to overwrite interned Stability: {:?}\", prev)\n-        }\n-        interned\n+        self.stability_interner.borrow_mut().intern(stab, |stab| {\n+            self.global_interners.arena.alloc(stab)\n+        })\n     }\n \n     pub fn intern_layout(self, layout: LayoutDetails) -> &'gcx LayoutDetails {\n-        let mut layout_interner = self.layout_interner.borrow_mut();\n-        if let Some(layout) = layout_interner.get(&layout) {\n-            return layout;\n-        }\n-\n-        let interned = self.global_arenas.layout.alloc(layout);\n-        if let Some(prev) = layout_interner.replace(interned) {\n-            bug!(\"Tried to overwrite interned Layout: {:?}\", prev)\n-        }\n-        interned\n+        self.layout_interner.borrow_mut().intern(layout, |layout| {\n+            self.global_arenas.layout.alloc(layout)\n+        })\n     }\n \n     /// Returns a range of the start/end indices specified with the\n@@ -2198,7 +2163,7 @@ macro_rules! sty_debug_print {\n                 };\n                 $(let mut $variant = total;)*\n \n-                for &Interned(t) in tcx.interners.type_.borrow().iter() {\n+                for &Interned(t) in tcx.interners.type_.borrow().keys() {\n                     let variant = match t.sty {\n                         ty::Bool | ty::Char | ty::Int(..) | ty::Uint(..) |\n                             ty::Float(..) | ty::Str | ty::Never => continue,\n@@ -2257,6 +2222,13 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n /// An entry in an interner.\n struct Interned<'tcx, T: 'tcx+?Sized>(&'tcx T);\n \n+impl<'tcx, T: 'tcx+?Sized> Clone for Interned<'tcx, T> {\n+    fn clone(&self) -> Self {\n+        Interned(self.0)\n+    }\n+}\n+impl<'tcx, T: 'tcx+?Sized> Copy for Interned<'tcx, T> {}\n+\n // NB: An Interned<Ty> compares and hashes as a sty.\n impl<'tcx> PartialEq for Interned<'tcx, TyS<'tcx>> {\n     fn eq(&self, other: &Interned<'tcx, TyS<'tcx>>) -> bool {\n@@ -2377,37 +2349,28 @@ macro_rules! intern_method {\n                 // determine that all contents are in the global tcx.\n                 // See comments on Lift for why we can't use that.\n                 if ($keep_in_local_tcx)(&v) {\n-                    let mut interner = self.interners.$name.borrow_mut();\n-                    if let Some(&Interned(v)) = interner.get(key) {\n-                        return v;\n-                    }\n-\n-                    // Make sure we don't end up with inference\n-                    // types/regions in the global tcx.\n-                    if self.is_global() {\n-                        bug!(\"Attempted to intern `{:?}` which contains \\\n-                              inference types/regions in the global type context\",\n-                             v);\n-                    }\n-\n-                    let i = $alloc_method(&self.interners.arena, v);\n-                    interner.insert(Interned(i));\n-                    i\n+                    self.interners.$name.borrow_mut().intern_ref(key, || {\n+                        // Make sure we don't end up with inference\n+                        // types/regions in the global tcx.\n+                        if self.is_global() {\n+                            bug!(\"Attempted to intern `{:?}` which contains \\\n+                                inference types/regions in the global type context\",\n+                                v);\n+                        }\n+\n+                        Interned($alloc_method(&self.interners.arena, v))\n+                    }).0\n                 } else {\n-                    let mut interner = self.global_interners.$name.borrow_mut();\n-                    if let Some(&Interned(v)) = interner.get(key) {\n-                        return v;\n-                    }\n-\n-                    // This transmutes $alloc<'tcx> to $alloc<'gcx>\n-                    let v = unsafe {\n-                        mem::transmute(v)\n-                    };\n-                    let i: &$lt_tcx $ty = $alloc_method(&self.global_interners.arena, v);\n-                    // Cast to 'gcx\n-                    let i = unsafe { mem::transmute(i) };\n-                    interner.insert(Interned(i));\n-                    i\n+                    self.global_interners.$name.borrow_mut().intern_ref(key, || {\n+                        // This transmutes $alloc<'tcx> to $alloc<'gcx>\n+                        let v = unsafe {\n+                            mem::transmute(v)\n+                        };\n+                        let i: &$lt_tcx $ty = $alloc_method(&self.global_interners.arena, v);\n+                        // Cast to 'gcx\n+                        let i = unsafe { mem::transmute(i) };\n+                        Interned(i)\n+                    }).0\n                 }\n             }\n         }"}, {"sha": "29e5aefee7f0bbbf35a81dd982d34aa710d6c001", "filename": "src/librustc_data_structures/interner.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/ecfe7216206c4ed4697a39ba80b3f0889350da8f/src%2Flibrustc_data_structures%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecfe7216206c4ed4697a39ba80b3f0889350da8f/src%2Flibrustc_data_structures%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Finterner.rs?ref=ecfe7216206c4ed4697a39ba80b3f0889350da8f", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::hash::Hash;\n+use std::hash::BuildHasher;\n+use std::hash::Hasher;\n+use std::collections::HashMap;\n+use std::collections::hash_map::RawEntryMut;\n+use std::borrow::Borrow;\n+\n+pub trait HashInterner<K: Eq + Hash> {\n+    fn intern_ref<Q: ?Sized, F: FnOnce() -> K>(&mut self, value: &Q, make: F) -> K\n+        where K: Borrow<Q>,\n+              Q: Hash + Eq;\n+\n+    fn intern<Q, F: FnOnce(Q) -> K>(&mut self, value: Q, make: F) -> K\n+        where K: Borrow<Q>,\n+              Q: Hash + Eq;\n+}\n+\n+impl<K: Eq + Hash + Copy, S: BuildHasher> HashInterner<K> for HashMap<K, (), S> {\n+    #[inline]\n+    fn intern_ref<Q: ?Sized, F: FnOnce() -> K>(&mut self, value: &Q, make: F) -> K\n+        where K: Borrow<Q>,\n+              Q: Hash + Eq\n+    {\n+        let mut hasher = self.hasher().build_hasher();\n+        value.hash(&mut hasher);\n+        let hash = hasher.finish();\n+        let entry = self.raw_entry_mut().from_key_hashed_nocheck(hash, value);\n+\n+        match entry {\n+            RawEntryMut::Occupied(e) => *e.key(),\n+            RawEntryMut::Vacant(e) => {\n+                let v = make();\n+                e.insert_hashed_nocheck(hash, v, ());\n+                v\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn intern<Q, F: FnOnce(Q) -> K>(&mut self, value: Q, make: F) -> K\n+        where K: Borrow<Q>,\n+              Q: Hash + Eq\n+    {\n+        let mut hasher = self.hasher().build_hasher();\n+        value.hash(&mut hasher);\n+        let hash = hasher.finish();\n+        let entry = self.raw_entry_mut().from_key_hashed_nocheck(hash, &value);\n+\n+        match entry {\n+            RawEntryMut::Occupied(e) => *e.key(),\n+            RawEntryMut::Vacant(e) => {\n+                let v = make(value);\n+                e.insert_hashed_nocheck(hash, v, ());\n+                v\n+            }\n+        }\n+    }\n+}"}, {"sha": "96cb235a933627c4d593400696b0cfa317439b62", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecfe7216206c4ed4697a39ba80b3f0889350da8f/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecfe7216206c4ed4697a39ba80b3f0889350da8f/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=ecfe7216206c4ed4697a39ba80b3f0889350da8f", "patch": "@@ -29,6 +29,7 @@\n #![feature(nll)]\n #![feature(allow_internal_unstable)]\n #![feature(vec_resize_with)]\n+#![feature(hash_raw_entry)]\n \n #![cfg_attr(unix, feature(libc))]\n #![cfg_attr(test, feature(test))]\n@@ -66,6 +67,7 @@ pub mod flock;\n pub mod fx;\n pub mod graph;\n pub mod indexed_vec;\n+pub mod interner;\n pub mod obligation_forest;\n pub mod owning_ref;\n pub mod ptr_key;"}, {"sha": "349aa029ba8cb9a69aefa2890793677dbe7a0901", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ecfe7216206c4ed4697a39ba80b3f0889350da8f/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecfe7216206c4ed4697a39ba80b3f0889350da8f/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=ecfe7216206c4ed4697a39ba80b3f0889350da8f", "patch": "@@ -849,6 +849,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// let mut map: HashMap<&str, i32> = HashMap::new();\n     /// map.reserve(10);\n     /// ```\n+    #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: usize) {\n         match self.reserve_internal(additional, Infallible) {\n@@ -880,6 +881,7 @@ impl<K, V, S> HashMap<K, V, S>\n         self.reserve_internal(additional, Fallible)\n     }\n \n+    #[inline]\n     fn reserve_internal(&mut self, additional: usize, fallibility: Fallibility)\n         -> Result<(), CollectionAllocErr> {\n \n@@ -1571,6 +1573,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// so that the map now contains keys which compare equal, search may start\n     /// acting erratically, with two keys randomly masking each other. Implementations\n     /// are free to assume this doesn't happen (within the limits of memory-safety).\n+    #[inline(always)]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn raw_entry_mut(&mut self) -> RawEntryBuilderMut<K, V, S> {\n         self.reserve(1);\n@@ -1911,6 +1914,7 @@ impl<'a, K, V, S> RawEntryBuilderMut<'a, K, V, S>\n     }\n \n     /// Create a `RawEntryMut` from the given key and its hash.\n+    #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn from_key_hashed_nocheck<Q: ?Sized>(self, hash: u64, k: &Q) -> RawEntryMut<'a, K, V, S>\n         where K: Borrow<Q>,\n@@ -1919,6 +1923,7 @@ impl<'a, K, V, S> RawEntryBuilderMut<'a, K, V, S>\n         self.from_hash(hash, |q| q.borrow().eq(k))\n     }\n \n+    #[inline]\n     fn search<F>(self, hash: u64, is_match: F, compare_hashes: bool)  -> RawEntryMut<'a, K, V, S>\n         where for<'b> F: FnMut(&'b K) -> bool,\n     {\n@@ -1941,6 +1946,7 @@ impl<'a, K, V, S> RawEntryBuilderMut<'a, K, V, S>\n         }\n     }\n     /// Create a `RawEntryMut` from the given hash.\n+    #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn from_hash<F>(self, hash: u64, is_match: F) -> RawEntryMut<'a, K, V, S>\n         where for<'b> F: FnMut(&'b K) -> bool,\n@@ -2215,6 +2221,7 @@ impl<'a, K, V, S> RawVacantEntryMut<'a, K, V, S> {\n \n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it.\n+    #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn insert_hashed_nocheck(self, hash: u64, key: K, value: V) -> (&'a mut K, &'a mut V) {\n         let hash = SafeHash::new(hash);"}, {"sha": "479e6dccb90dd1d51ec00c3783a32f2777689069", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecfe7216206c4ed4697a39ba80b3f0889350da8f/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecfe7216206c4ed4697a39ba80b3f0889350da8f/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=ecfe7216206c4ed4697a39ba80b3f0889350da8f", "patch": "@@ -329,6 +329,7 @@ impl<K, V, M> Put<K, V> for FullBucket<K, V, M>\n }\n \n impl<K, V, M: Deref<Target = RawTable<K, V>>> Bucket<K, V, M> {\n+    #[inline]\n     pub fn new(table: M, hash: SafeHash) -> Bucket<K, V, M> {\n         Bucket::at_index(table, hash.inspect() as usize)\n     }\n@@ -342,6 +343,7 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> Bucket<K, V, M> {\n         }\n     }\n \n+    #[inline]\n     pub fn at_index(table: M, ib_index: usize) -> Bucket<K, V, M> {\n         // if capacity is 0, then the RawBucket will be populated with bogus pointers.\n         // This is an uncommon case though, so avoid it in release builds.\n@@ -654,6 +656,7 @@ impl<K, V, M> GapThenFull<K, V, M>\n \n // Returns a Layout which describes the allocation required for a hash table,\n // and the offset of the array of (key, value) pairs in the allocation.\n+#[inline(always)]\n fn calculate_layout<K, V>(capacity: usize) -> Result<(Layout, usize), LayoutErr> {\n     let hashes = Layout::array::<HashUint>(capacity)?;\n     let pairs = Layout::array::<(K, V)>(capacity)?;\n@@ -722,6 +725,7 @@ impl<K, V> RawTable<K, V> {\n         }\n     }\n \n+    #[inline(always)]\n     fn raw_bucket_at(&self, index: usize) -> RawBucket<K, V> {\n         let (_, pairs_offset) = calculate_layout::<K, V>(self.capacity())\n             .unwrap_or_else(|_| unsafe { hint::unreachable_unchecked() });"}]}