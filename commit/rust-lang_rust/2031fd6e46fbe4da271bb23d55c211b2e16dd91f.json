{"sha": "2031fd6e46fbe4da271bb23d55c211b2e16dd91f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwMzFmZDZlNDZmYmU0ZGEyNzFiYjIzZDU1YzIxMWIyZTE2ZGQ5MWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-28T08:04:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-28T08:04:41Z"}, "message": "Auto merge of #88245 - Sl1mb0:s390-asm, r=Amanieu\n\nS390x inline asm\n\nThis adds register definitions and constraint codes for the s390x general and floating point registers necessary for fixing #85931; as well as a few tests.\n\nFurther testing is needed, but I am a little unsure of what specific tests should be added to `src/test/assembly/asm/s390x.rs` to address this.", "tree": {"sha": "cf769574a7701b82e45ee3434020479e89ed0157", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf769574a7701b82e45ee3434020479e89ed0157"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2031fd6e46fbe4da271bb23d55c211b2e16dd91f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2031fd6e46fbe4da271bb23d55c211b2e16dd91f", "html_url": "https://github.com/rust-lang/rust/commit/2031fd6e46fbe4da271bb23d55c211b2e16dd91f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2031fd6e46fbe4da271bb23d55c211b2e16dd91f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac50a53359328a5d7f2f558833e63d59d372e4f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac50a53359328a5d7f2f558833e63d59d372e4f7", "html_url": "https://github.com/rust-lang/rust/commit/ac50a53359328a5d7f2f558833e63d59d372e4f7"}, {"sha": "4a9ba65ca9eaf9db3a010cbf5859b3fdf16ac687", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a9ba65ca9eaf9db3a010cbf5859b3fdf16ac687", "html_url": "https://github.com/rust-lang/rust/commit/4a9ba65ca9eaf9db3a010cbf5859b3fdf16ac687"}], "stats": {"total": 305, "additions": 305, "deletions": 0}, "files": [{"sha": "1689fdd4f2e815877620c42667a3d2e3136e1cda", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2031fd6e46fbe4da271bb23d55c211b2e16dd91f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2031fd6e46fbe4da271bb23d55c211b2e16dd91f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=2031fd6e46fbe4da271bb23d55c211b2e16dd91f", "patch": "@@ -314,6 +314,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 InlineAsmArch::PowerPC | InlineAsmArch::PowerPC64 => {}\n                 InlineAsmArch::Hexagon => {}\n                 InlineAsmArch::Mips | InlineAsmArch::Mips64 => {}\n+                InlineAsmArch::S390x => {}\n                 InlineAsmArch::SpirV => {}\n                 InlineAsmArch::Wasm32 => {}\n                 InlineAsmArch::Bpf => {}\n@@ -633,6 +634,8 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass, layout: Option<&TyAndLayout<'tcx>>)\n             InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => \"r\",\n             InlineAsmRegClass::Bpf(BpfInlineAsmRegClass::reg) => \"r\",\n             InlineAsmRegClass::Bpf(BpfInlineAsmRegClass::wreg) => \"w\",\n+            InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => \"f\",\n             InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n                 bug!(\"LLVM backend does not support SPIR-V\")\n             }\n@@ -711,6 +714,7 @@ fn modifier_to_llvm(\n         }\n         InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => None,\n         InlineAsmRegClass::Bpf(_) => None,\n+        InlineAsmRegClass::S390x(_) => None,\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n         }\n@@ -769,6 +773,8 @@ fn dummy_output_type(cx: &CodegenCx<'ll, 'tcx>, reg: InlineAsmRegClass) -> &'ll\n         InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => cx.type_i32(),\n         InlineAsmRegClass::Bpf(BpfInlineAsmRegClass::reg) => cx.type_i64(),\n         InlineAsmRegClass::Bpf(BpfInlineAsmRegClass::wreg) => cx.type_i32(),\n+        InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => cx.type_i32(),\n+        InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => cx.type_f64(),\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n         }"}, {"sha": "fb23e5c85a1093efde2f4dc5236c0a3a530b1410", "filename": "compiler/rustc_target/src/asm/mod.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2031fd6e46fbe4da271bb23d55c211b2e16dd91f/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2031fd6e46fbe4da271bb23d55c211b2e16dd91f/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs?ref=2031fd6e46fbe4da271bb23d55c211b2e16dd91f", "patch": "@@ -154,6 +154,7 @@ mod mips;\n mod nvptx;\n mod powerpc;\n mod riscv;\n+mod s390x;\n mod spirv;\n mod wasm;\n mod x86;\n@@ -166,6 +167,7 @@ pub use mips::{MipsInlineAsmReg, MipsInlineAsmRegClass};\n pub use nvptx::{NvptxInlineAsmReg, NvptxInlineAsmRegClass};\n pub use powerpc::{PowerPCInlineAsmReg, PowerPCInlineAsmRegClass};\n pub use riscv::{RiscVInlineAsmReg, RiscVInlineAsmRegClass};\n+pub use s390x::{S390xInlineAsmReg, S390xInlineAsmRegClass};\n pub use spirv::{SpirVInlineAsmReg, SpirVInlineAsmRegClass};\n pub use wasm::{WasmInlineAsmReg, WasmInlineAsmRegClass};\n pub use x86::{X86InlineAsmReg, X86InlineAsmRegClass};\n@@ -184,6 +186,7 @@ pub enum InlineAsmArch {\n     Mips64,\n     PowerPC,\n     PowerPC64,\n+    S390x,\n     SpirV,\n     Wasm32,\n     Bpf,\n@@ -206,6 +209,7 @@ impl FromStr for InlineAsmArch {\n             \"hexagon\" => Ok(Self::Hexagon),\n             \"mips\" => Ok(Self::Mips),\n             \"mips64\" => Ok(Self::Mips64),\n+            \"s390x\" => Ok(Self::S390x),\n             \"spirv\" => Ok(Self::SpirV),\n             \"wasm32\" => Ok(Self::Wasm32),\n             \"bpf\" => Ok(Self::Bpf),\n@@ -235,6 +239,7 @@ pub enum InlineAsmReg {\n     PowerPC(PowerPCInlineAsmReg),\n     Hexagon(HexagonInlineAsmReg),\n     Mips(MipsInlineAsmReg),\n+    S390x(S390xInlineAsmReg),\n     SpirV(SpirVInlineAsmReg),\n     Wasm(WasmInlineAsmReg),\n     Bpf(BpfInlineAsmReg),\n@@ -252,6 +257,7 @@ impl InlineAsmReg {\n             Self::PowerPC(r) => r.name(),\n             Self::Hexagon(r) => r.name(),\n             Self::Mips(r) => r.name(),\n+            Self::S390x(r) => r.name(),\n             Self::Bpf(r) => r.name(),\n             Self::Err => \"<reg>\",\n         }\n@@ -266,6 +272,7 @@ impl InlineAsmReg {\n             Self::PowerPC(r) => InlineAsmRegClass::PowerPC(r.reg_class()),\n             Self::Hexagon(r) => InlineAsmRegClass::Hexagon(r.reg_class()),\n             Self::Mips(r) => InlineAsmRegClass::Mips(r.reg_class()),\n+            Self::S390x(r) => InlineAsmRegClass::S390x(r.reg_class()),\n             Self::Bpf(r) => InlineAsmRegClass::Bpf(r.reg_class()),\n             Self::Err => InlineAsmRegClass::Err,\n         }\n@@ -305,6 +312,9 @@ impl InlineAsmReg {\n             InlineAsmArch::Mips | InlineAsmArch::Mips64 => {\n                 Self::Mips(MipsInlineAsmReg::parse(arch, has_feature, target, &name)?)\n             }\n+            InlineAsmArch::S390x => {\n+                Self::S390x(S390xInlineAsmReg::parse(arch, has_feature, target, &name)?)\n+            }\n             InlineAsmArch::SpirV => {\n                 Self::SpirV(SpirVInlineAsmReg::parse(arch, has_feature, target, &name)?)\n             }\n@@ -333,6 +343,7 @@ impl InlineAsmReg {\n             Self::PowerPC(r) => r.emit(out, arch, modifier),\n             Self::Hexagon(r) => r.emit(out, arch, modifier),\n             Self::Mips(r) => r.emit(out, arch, modifier),\n+            Self::S390x(r) => r.emit(out, arch, modifier),\n             Self::Bpf(r) => r.emit(out, arch, modifier),\n             Self::Err => unreachable!(\"Use of InlineAsmReg::Err\"),\n         }\n@@ -347,6 +358,7 @@ impl InlineAsmReg {\n             Self::PowerPC(_) => cb(self),\n             Self::Hexagon(r) => r.overlapping_regs(|r| cb(Self::Hexagon(r))),\n             Self::Mips(_) => cb(self),\n+            Self::S390x(_) => cb(self),\n             Self::Bpf(r) => r.overlapping_regs(|r| cb(Self::Bpf(r))),\n             Self::Err => unreachable!(\"Use of InlineAsmReg::Err\"),\n         }\n@@ -374,6 +386,7 @@ pub enum InlineAsmRegClass {\n     PowerPC(PowerPCInlineAsmRegClass),\n     Hexagon(HexagonInlineAsmRegClass),\n     Mips(MipsInlineAsmRegClass),\n+    S390x(S390xInlineAsmRegClass),\n     SpirV(SpirVInlineAsmRegClass),\n     Wasm(WasmInlineAsmRegClass),\n     Bpf(BpfInlineAsmRegClass),\n@@ -392,6 +405,7 @@ impl InlineAsmRegClass {\n             Self::PowerPC(r) => r.name(),\n             Self::Hexagon(r) => r.name(),\n             Self::Mips(r) => r.name(),\n+            Self::S390x(r) => r.name(),\n             Self::SpirV(r) => r.name(),\n             Self::Wasm(r) => r.name(),\n             Self::Bpf(r) => r.name(),\n@@ -412,6 +426,7 @@ impl InlineAsmRegClass {\n             Self::PowerPC(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::PowerPC),\n             Self::Hexagon(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Hexagon),\n             Self::Mips(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Mips),\n+            Self::S390x(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::S390x),\n             Self::SpirV(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::SpirV),\n             Self::Wasm(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Wasm),\n             Self::Bpf(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Bpf),\n@@ -439,6 +454,7 @@ impl InlineAsmRegClass {\n             Self::PowerPC(r) => r.suggest_modifier(arch, ty),\n             Self::Hexagon(r) => r.suggest_modifier(arch, ty),\n             Self::Mips(r) => r.suggest_modifier(arch, ty),\n+            Self::S390x(r) => r.suggest_modifier(arch, ty),\n             Self::SpirV(r) => r.suggest_modifier(arch, ty),\n             Self::Wasm(r) => r.suggest_modifier(arch, ty),\n             Self::Bpf(r) => r.suggest_modifier(arch, ty),\n@@ -462,6 +478,7 @@ impl InlineAsmRegClass {\n             Self::PowerPC(r) => r.default_modifier(arch),\n             Self::Hexagon(r) => r.default_modifier(arch),\n             Self::Mips(r) => r.default_modifier(arch),\n+            Self::S390x(r) => r.default_modifier(arch),\n             Self::SpirV(r) => r.default_modifier(arch),\n             Self::Wasm(r) => r.default_modifier(arch),\n             Self::Bpf(r) => r.default_modifier(arch),\n@@ -484,6 +501,7 @@ impl InlineAsmRegClass {\n             Self::PowerPC(r) => r.supported_types(arch),\n             Self::Hexagon(r) => r.supported_types(arch),\n             Self::Mips(r) => r.supported_types(arch),\n+            Self::S390x(r) => r.supported_types(arch),\n             Self::SpirV(r) => r.supported_types(arch),\n             Self::Wasm(r) => r.supported_types(arch),\n             Self::Bpf(r) => r.supported_types(arch),\n@@ -509,6 +527,7 @@ impl InlineAsmRegClass {\n             InlineAsmArch::Mips | InlineAsmArch::Mips64 => {\n                 Self::Mips(MipsInlineAsmRegClass::parse(arch, name)?)\n             }\n+            InlineAsmArch::S390x => Self::S390x(S390xInlineAsmRegClass::parse(arch, name)?),\n             InlineAsmArch::SpirV => Self::SpirV(SpirVInlineAsmRegClass::parse(arch, name)?),\n             InlineAsmArch::Wasm32 => Self::Wasm(WasmInlineAsmRegClass::parse(arch, name)?),\n             InlineAsmArch::Bpf => Self::Bpf(BpfInlineAsmRegClass::parse(arch, name)?),\n@@ -527,6 +546,7 @@ impl InlineAsmRegClass {\n             Self::PowerPC(r) => r.valid_modifiers(arch),\n             Self::Hexagon(r) => r.valid_modifiers(arch),\n             Self::Mips(r) => r.valid_modifiers(arch),\n+            Self::S390x(r) => r.valid_modifiers(arch),\n             Self::SpirV(r) => r.valid_modifiers(arch),\n             Self::Wasm(r) => r.valid_modifiers(arch),\n             Self::Bpf(r) => r.valid_modifiers(arch),\n@@ -695,6 +715,11 @@ pub fn allocatable_registers(\n             mips::fill_reg_map(arch, has_feature, target, &mut map);\n             map\n         }\n+        InlineAsmArch::S390x => {\n+            let mut map = s390x::regclass_map();\n+            s390x::fill_reg_map(arch, has_feature, target, &mut map);\n+            map\n+        }\n         InlineAsmArch::SpirV => {\n             let mut map = spirv::regclass_map();\n             spirv::fill_reg_map(arch, has_feature, target, &mut map);"}, {"sha": "a74873f17476ea4d9f96ddc8c9c1a9dd211be751", "filename": "compiler/rustc_target/src/asm/s390x.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/2031fd6e46fbe4da271bb23d55c211b2e16dd91f/compiler%2Frustc_target%2Fsrc%2Fasm%2Fs390x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2031fd6e46fbe4da271bb23d55c211b2e16dd91f/compiler%2Frustc_target%2Fsrc%2Fasm%2Fs390x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fs390x.rs?ref=2031fd6e46fbe4da271bb23d55c211b2e16dd91f", "patch": "@@ -0,0 +1,106 @@\n+use super::{InlineAsmArch, InlineAsmType};\n+use rustc_macros::HashStable_Generic;\n+use std::fmt;\n+\n+def_reg_class! {\n+    S390x S390xInlineAsmRegClass {\n+        reg,\n+        freg,\n+    }\n+}\n+\n+impl S390xInlineAsmRegClass {\n+    pub fn valid_modifiers(self, _arch: super::InlineAsmArch) -> &'static [char] {\n+        &[]\n+    }\n+\n+    pub fn suggest_class(self, _arch: InlineAsmArch, _ty: InlineAsmType) -> Option<Self> {\n+        None\n+    }\n+\n+    pub fn suggest_modifier(\n+        self,\n+        _arch: InlineAsmArch,\n+        _ty: InlineAsmType,\n+    ) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn default_modifier(self, _arch: InlineAsmArch) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn supported_types(\n+        self,\n+        arch: InlineAsmArch,\n+    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+        match (self, arch) {\n+            (Self::reg, _) => types! { _: I8, I16, I32, I64; },\n+            (Self::freg, _) => types! { _: F32, F64; },\n+        }\n+    }\n+}\n+\n+def_regs! {\n+    S390x S390xInlineAsmReg S390xInlineAsmRegClass {\n+        r0: reg = [\"r0\"],\n+        r1: reg = [\"r1\"],\n+        r2: reg = [\"r2\"],\n+        r3: reg = [\"r3\"],\n+        r4: reg = [\"r4\"],\n+        r5: reg = [\"r5\"],\n+        r6: reg = [\"r6\"],\n+        r7: reg = [\"r7\"],\n+        r8: reg = [\"r8\"],\n+        r9: reg = [\"r9\"],\n+        r10: reg = [\"r10\"],\n+        r12: reg = [\"r12\"],\n+        r13: reg = [\"r13\"],\n+        r14: reg = [\"r14\"],\n+        f0: freg = [\"f0\"],\n+        f1: freg = [\"f1\"],\n+        f2: freg = [\"f2\"],\n+        f3: freg = [\"f3\"],\n+        f4: freg = [\"f4\"],\n+        f5: freg = [\"f5\"],\n+        f6: freg = [\"f6\"],\n+        f7: freg = [\"f7\"],\n+        f8: freg = [\"f8\"],\n+        f9: freg = [\"f9\"],\n+        f10: freg = [\"f10\"],\n+        f11: freg = [\"f11\"],\n+        f12: freg = [\"f12\"],\n+        f13: freg = [\"f13\"],\n+        f14: freg = [\"f14\"],\n+        f15: freg = [\"f15\"],\n+        #error = [\"r11\"] =>\n+            \"The frame pointer cannot be used as an operand for inline asm\",\n+        #error = [\"r15\"] =>\n+            \"The stack pointer cannot be used as an operand for inline asm\",\n+        #error = [\n+            \"c0\", \"c1\", \"c2\", \"c3\",\n+            \"c4\", \"c5\", \"c6\", \"c7\",\n+            \"c8\", \"c9\", \"c10\", \"c11\",\n+            \"c12\", \"c13\", \"c14\", \"c15\"\n+        ] =>\n+            \"control registers are reserved by the kernel and cannot be used as operands for inline asm\",\n+        #error = [\n+            \"a0\", \"a1\", \"a2\", \"a3\",\n+            \"a4\", \"a5\", \"a6\", \"a7\",\n+            \"a8\", \"a9\", \"a10\", \"a11\",\n+            \"a12\", \"a13\", \"a14\", \"a15\"\n+        ] =>\n+            \"access registers are not supported and cannot be used as operands for inline asm\",\n+    }\n+}\n+\n+impl S390xInlineAsmReg {\n+    pub fn emit(\n+        self,\n+        out: &mut dyn fmt::Write,\n+        _arch: InlineAsmArch,\n+        _modifier: Option<char>,\n+    ) -> fmt::Result {\n+        write!(out, \"%{}\", self.name())\n+    }\n+}"}, {"sha": "69d9cab23c8edde71d4f9453b237e233b8989855", "filename": "src/test/assembly/asm/s390x-types.rs", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/2031fd6e46fbe4da271bb23d55c211b2e16dd91f/src%2Ftest%2Fassembly%2Fasm%2Fs390x-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2031fd6e46fbe4da271bb23d55c211b2e16dd91f/src%2Ftest%2Fassembly%2Fasm%2Fs390x-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Fs390x-types.rs?ref=2031fd6e46fbe4da271bb23d55c211b2e16dd91f", "patch": "@@ -0,0 +1,168 @@\n+// min-llvm-version: 10.0.1\n+// revisions: s390x\n+// assembly-output: emit-asm\n+//[s390x] compile-flags: --target s390x-unknown-linux-gnu\n+//[s390x] needs-llvm-components: systemz\n+\n+#![feature(no_core, lang_items, rustc_attrs, repr_simd)]\n+#![crate_type = \"rlib\"]\n+#![no_core]\n+#![allow(asm_sub_register, non_camel_case_types)]\n+\n+#[rustc_builtin_macro]\n+macro_rules! asm {\n+    () => {};\n+}\n+#[rustc_builtin_macro]\n+macro_rules! concat {\n+    () => {};\n+}\n+#[rustc_builtin_macro]\n+macro_rules! stringify {\n+    () => {};\n+}\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+type ptr = *const i32;\n+\n+impl Copy for i8 {}\n+impl Copy for u8 {}\n+impl Copy for i16 {}\n+impl Copy for i32 {}\n+impl Copy for i64 {}\n+impl Copy for f32 {}\n+impl Copy for f64 {}\n+impl Copy for ptr {}\n+\n+extern \"C\" {\n+    fn extern_func();\n+    static extern_static: u8;\n+}\n+\n+// Hack to avoid function merging\n+extern \"Rust\" {\n+    fn dont_merge(s: &str);\n+}\n+\n+macro_rules! check { ($func:ident, $ty:ty, $class:ident, $mov:literal) => {\n+    #[no_mangle]\n+    pub unsafe fn $func(x: $ty) -> $ty {\n+        dont_merge(stringify!($func));\n+\n+        let y;\n+        asm!(concat!($mov,\" {}, {}\"), out($class) y, in($class) x);\n+        y\n+    }\n+};}\n+\n+macro_rules! check_reg { ($func:ident, $ty:ty, $reg:tt, $mov:literal) => {\n+    #[no_mangle]\n+    pub unsafe fn $func(x: $ty) -> $ty {\n+        dont_merge(stringify!($func));\n+\n+        let y;\n+        asm!(concat!($mov, \" %\", $reg, \", %\", $reg), lateout($reg) y, in($reg) x);\n+        y\n+    }\n+};}\n+\n+// CHECK-LABEL: sym_fn_32:\n+// CHECK: #APP\n+// CHECK: brasl %r14, extern_func\n+// CHECK: #NO_APP\n+#[cfg(s390x)]\n+#[no_mangle]\n+pub unsafe fn sym_fn_32() {\n+    asm!(\"brasl %r14, {}\", sym extern_func);\n+}\n+\n+// CHECK-LABEL: sym_static:\n+// CHECK: #APP\n+// CHECK: brasl %r14, extern_static\n+// CHECK: #NO_APP\n+#[no_mangle]\n+pub unsafe fn sym_static() {\n+    asm!(\"brasl %r14, {}\", sym extern_static);\n+}\n+\n+// CHECK-LABEL: reg_i8:\n+// CHECK: #APP\n+// CHECK: lgr %r{{[0-9]+}}, %r{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(reg_i8, i8, reg, \"lgr\");\n+\n+// CHECK-LABEL: reg_i16:\n+// CHECK: #APP\n+// CHECK: lgr %r{{[0-9]+}}, %r{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(reg_i16, i16, reg, \"lgr\");\n+\n+// CHECK-LABEL: reg_i32:\n+// CHECK: #APP\n+// CHECK: lgr %r{{[0-9]+}}, %r{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(reg_i32, i32, reg, \"lgr\");\n+\n+// CHECK-LABEL: reg_i64:\n+// CHECK: #APP\n+// CHECK: lgr %r{{[0-9]+}}, %r{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(reg_i64, i64, reg, \"lgr\");\n+\n+// CHECK-LABEL: reg_f32:\n+// CHECK: #APP\n+// CHECK: ler %f{{[0-9]+}}, %f{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(reg_f32, f32, freg, \"ler\");\n+\n+// CHECK-LABEL: reg_f64:\n+// CHECK: #APP\n+// CHECK: ldr %f{{[0-9]+}}, %f{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(reg_f64, f64, freg, \"ldr\");\n+\n+// CHECK-LABEL: reg_ptr:\n+// CHECK: #APP\n+// CHECK: lgr %r{{[0-9]+}}, %r{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(reg_ptr, ptr, reg, \"lgr\");\n+\n+// CHECK-LABEL: r0_i8:\n+// CHECK: #APP\n+// CHECK: lr %r0, %r0\n+// CHECK: #NO_APP\n+check_reg!(r0_i8, i8, \"r0\", \"lr\");\n+\n+// CHECK-LABEL: r0_i16:\n+// CHECK: #APP\n+// CHECK: lr %r0, %r0\n+// CHECK: #NO_APP\n+check_reg!(r0_i16, i16, \"r0\", \"lr\");\n+\n+// CHECK-LABEL: r0_i32:\n+// CHECK: #APP\n+// CHECK: lr %r0, %r0\n+// CHECK: #NO_APP\n+check_reg!(r0_i32, i32, \"r0\", \"lr\");\n+\n+// CHECK-LABEL: r0_i64:\n+// CHECK: #APP\n+// CHECK: lr %r0, %r0\n+// CHECK: #NO_APP\n+check_reg!(r0_i64, i64, \"r0\", \"lr\");\n+\n+// CHECK-LABEL: f0_f32:\n+// CHECK: #APP\n+// CHECK: ler %f0, %f0\n+// CHECK: #NO_APP\n+check_reg!(f0_f32, f32, \"f0\", \"ler\");\n+\n+// CHECK-LABEL: f0_f64:\n+// CHECK: #APP\n+// CHECK: ldr %f0, %f0\n+// CHECK: #NO_APP\n+check_reg!(f0_f64, f64, \"f0\", \"ldr\");"}]}