{"sha": "906169d608c51b032666e05fff4d870968abe9d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwNjE2OWQ2MDhjNTFiMDMyNjY2ZTA1ZmZmNGQ4NzA5NjhhYmU5ZDQ=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-06-18T23:41:42Z"}, "committer": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-06-19T23:35:26Z"}, "message": "Add a `node` type in place of hand-rolled records in infer", "tree": {"sha": "39a5a7b6740c52e0fac2c883dced4a7268bfdae2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39a5a7b6740c52e0fac2c883dced4a7268bfdae2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/906169d608c51b032666e05fff4d870968abe9d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/906169d608c51b032666e05fff4d870968abe9d4", "html_url": "https://github.com/rust-lang/rust/commit/906169d608c51b032666e05fff4d870968abe9d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/906169d608c51b032666e05fff4d870968abe9d4/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8cc1149130dab62a70e2eea5070d85bff07b1a03", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cc1149130dab62a70e2eea5070d85bff07b1a03", "html_url": "https://github.com/rust-lang/rust/commit/8cc1149130dab62a70e2eea5070d85bff07b1a03"}], "stats": {"total": 93, "additions": 66, "deletions": 27}, "files": [{"sha": "8d4571ecc9ccc1f81b30d312d1f182ca4e2c4821", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 66, "deletions": 27, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/906169d608c51b032666e05fff4d870968abe9d4/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906169d608c51b032666e05fff4d870968abe9d4/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=906169d608c51b032666e05fff4d870968abe9d4", "patch": "@@ -275,6 +275,11 @@ type vals_and_bindings<V:copy, T:copy> = {\n     mut bindings: [(V, var_value<V, T>)]\n };\n \n+enum node<V:copy, T:copy> = {\n+    root: V,\n+    possible_types: T,\n+};\n+\n enum infer_ctxt = @{\n     tcx: ty::ctxt,\n \n@@ -639,7 +644,7 @@ impl unify_methods for infer_ctxt {\n \n     fn get<V:copy vid, T:copy>(\n         vb: vals_and_bindings<V, T>, vid: V)\n-        -> {root: V, possible_types: T} {\n+        -> node<V, T> {\n \n         alt vb.vals.find(vid.to_uint()) {\n           none {\n@@ -649,15 +654,15 @@ impl unify_methods for infer_ctxt {\n           some(var_val) {\n             alt var_val {\n               redirect(vid) {\n-                let {root: rt, possible_types: pt} = self.get(vb, vid);\n-                if rt != vid {\n+                let nde = self.get(vb, vid);\n+                if nde.root != vid {\n                     // Path compression\n-                    vb.vals.insert(vid.to_uint(), redirect(rt));\n+                    vb.vals.insert(vid.to_uint(), redirect(nde.root));\n                 }\n-                {root: rt, possible_types: pt}\n+                nde\n               }\n               root(pt) {\n-                {root: vid, possible_types: pt}\n+                node({root: vid, possible_types: pt})\n               }\n             }\n           }\n@@ -771,8 +776,12 @@ impl unify_methods for infer_ctxt {\n         a_id: V, b_id: V) -> ures {\n \n         // Need to make sub_id a subtype of sup_id.\n-        let {root: a_id, possible_types: a_bounds} = self.get(vb, a_id);\n-        let {root: b_id, possible_types: b_bounds} = self.get(vb, b_id);\n+        let nde_a = self.get(vb, a_id);\n+        let nde_b = self.get(vb, b_id);\n+        let a_id = nde_a.root;\n+        let b_id = nde_b.root;\n+        let a_bounds = nde_a.possible_types;\n+        let b_bounds = nde_b.possible_types;\n \n         #debug[\"vars(%s=%s <: %s=%s)\",\n                a_id.to_str(), a_bounds.to_str(self),\n@@ -809,8 +818,12 @@ impl unify_methods for infer_ctxt {\n         vb: vals_and_bindings<V, int_ty_set>,\n         a_id: V, b_id: V) -> ures {\n \n-        let {root: a_id, possible_types: a_pt} = self.get(vb, a_id);\n-        let {root: b_id, possible_types: b_pt} = self.get(vb, b_id);\n+        let nde_a = self.get(vb, a_id);\n+        let nde_b = self.get(vb, b_id);\n+        let a_id = nde_a.root;\n+        let b_id = nde_b.root;\n+        let a_pt = nde_a.possible_types;\n+        let b_pt = nde_b.possible_types;\n \n         // If we're already dealing with the same two variables,\n         // there's nothing to do.\n@@ -831,7 +844,10 @@ impl unify_methods for infer_ctxt {\n         vb: vals_and_bindings<V, bounds<T>>,\n         a_id: V, b: T) -> ures {\n \n-        let {root: a_id, possible_types: a_bounds} = self.get(vb, a_id);\n+        let nde_a = self.get(vb, a_id);\n+        let a_id = nde_a.root;\n+        let a_bounds = nde_a.possible_types;\n+\n         #debug[\"vart(%s=%s <: %s)\",\n                a_id.to_str(), a_bounds.to_str(self),\n                b.to_str(self)];\n@@ -845,7 +861,9 @@ impl unify_methods for infer_ctxt {\n \n         assert ty::type_is_integral(b);\n \n-        let {root: a_id, possible_types: a_pt} = self.get(vb, a_id);\n+        let nde_a = self.get(vb, a_id);\n+        let a_id = nde_a.root;\n+        let a_pt = nde_a.possible_types;\n \n         let intersection =\n             intersection(a_pt, convert_integral_ty_to_int_ty_set(\n@@ -862,7 +880,10 @@ impl unify_methods for infer_ctxt {\n         a: T, b_id: V) -> ures {\n \n         let a_bounds = {lb: some(a), ub: none};\n-        let {root: b_id, possible_types: b_bounds} = self.get(vb, b_id);\n+        let nde_b = self.get(vb, b_id);\n+        let b_id = nde_b.root;\n+        let b_bounds = nde_b.possible_types;\n+\n         #debug[\"tvar(%s <: %s=%s)\",\n                a.to_str(self),\n                b_id.to_str(), b_bounds.to_str(self)];\n@@ -875,7 +896,9 @@ impl unify_methods for infer_ctxt {\n \n         assert ty::type_is_integral(a);\n \n-        let {root: b_id, possible_types: b_pt} = self.get(vb, b_id);\n+        let nde_b = self.get(vb, b_id);\n+        let b_id = nde_b.root;\n+        let b_pt = nde_b.possible_types;\n \n         let intersection =\n             intersection(b_pt, convert_integral_ty_to_int_ty_set(\n@@ -1101,8 +1124,9 @@ impl methods for resolve_state {\n             ret ty::re_var(rid);\n         } else {\n             vec::push(self.r_seen, rid);\n-            let {root:_, possible_types: bounds} =\n-                self.infcx.get(self.infcx.rb, rid);\n+            let nde = self.infcx.get(self.infcx.rb, rid);\n+            let bounds = nde.possible_types;\n+\n             let r1 = alt bounds {\n               { ub:_, lb:some(t) } { self.resolve_region(t) }\n               { ub:some(t), lb:_ } { self.resolve_region(t) }\n@@ -1135,8 +1159,9 @@ impl methods for resolve_state {\n             // tend to carry more restrictions or higher\n             // perf. penalties, so it pays to know more.\n \n-            let {root:_, possible_types: bounds} =\n-                self.infcx.get(self.infcx.tvb, vid);\n+            let nde = self.infcx.get(self.infcx.tvb, vid);\n+            let bounds = nde.possible_types;\n+\n             let t1 = alt bounds {\n               { ub:_, lb:some(t) } if !type_is_bot(t) { self.resolve1(t) }\n               { ub:some(t), lb:_ } { self.resolve1(t) }\n@@ -1157,8 +1182,9 @@ impl methods for resolve_state {\n     }\n \n     fn resolve_ty_var_integral(vid: tvi_vid) -> ty::t {\n-        let {root:_, possible_types: pt} =\n-            self.infcx.get(self.infcx.tvib, vid);\n+        let nde = self.infcx.get(self.infcx.tvib, vid);\n+        let pt = nde.possible_types;\n+\n         // If there's only one type in the set of possible types, then\n         // that's the answer.\n         alt single_type_contained_in(self.infcx.tcx, pt) {\n@@ -1258,21 +1284,28 @@ impl assignment for infer_ctxt {\n           }\n \n           (ty::ty_var(a_id), ty::ty_var(b_id)) {\n-            let {root:_, possible_types: a_bounds} = self.get(self.tvb, a_id);\n-            let {root:_, possible_types: b_bounds} = self.get(self.tvb, b_id);\n+            let nde_a = self.get(self.tvb, a_id);\n+            let nde_b = self.get(self.tvb, b_id);\n+            let a_bounds = nde_a.possible_types;\n+            let b_bounds = nde_b.possible_types;\n+\n             let a_bnd = select(a_bounds.ub, a_bounds.lb);\n             let b_bnd = select(b_bounds.lb, b_bounds.ub);\n             self.assign_tys_or_sub(anmnt, a, b, a_bnd, b_bnd)\n           }\n \n           (ty::ty_var(a_id), _) {\n-            let {root:_, possible_types:a_bounds} = self.get(self.tvb, a_id);\n+            let nde_a = self.get(self.tvb, a_id);\n+            let a_bounds = nde_a.possible_types;\n+\n             let a_bnd = select(a_bounds.ub, a_bounds.lb);\n             self.assign_tys_or_sub(anmnt, a, b, a_bnd, some(b))\n           }\n \n           (_, ty::ty_var(b_id)) {\n-            let {root:_, possible_types: b_bounds} = self.get(self.tvb, b_id);\n+            let nde_b = self.get(self.tvb, b_id);\n+            let b_bounds = nde_b.possible_types;\n+\n             let b_bnd = select(b_bounds.lb, b_bounds.ub);\n             self.assign_tys_or_sub(anmnt, a, b, some(a), b_bnd)\n           }\n@@ -2466,8 +2499,12 @@ fn lattice_vars<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n     // upper/lower/sub/super/etc.\n \n     // Need to find a type that is a supertype of both a and b:\n-    let {root: a_vid, possible_types: a_bounds} = self.infcx().get(vb, a_vid);\n-    let {root: b_vid, possible_types: b_bounds} = self.infcx().get(vb, b_vid);\n+    let nde_a = self.infcx().get(vb, a_vid);\n+    let nde_b = self.infcx().get(vb, b_vid);\n+    let a_vid = nde_a.root;\n+    let b_vid = nde_b.root;\n+    let a_bounds = nde_a.possible_types;\n+    let b_bounds = nde_b.possible_types;\n \n     #debug[\"%s.lattice_vars(%s=%s <: %s=%s)\",\n            self.tag(),\n@@ -2503,7 +2540,9 @@ fn lattice_var_t<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n     a_id: V, b: T,\n     c_ts: fn(T, T) -> cres<T>) -> cres<T> {\n \n-    let {root: a_id, possible_types: a_bounds} = self.infcx().get(vb, a_id);\n+    let nde_a = self.infcx().get(vb, a_id);\n+    let a_id = nde_a.root;\n+    let a_bounds = nde_a.possible_types;\n \n     // The comments in this function are written for LUB, but they\n     // apply equally well to GLB if you inverse upper/lower/sub/super/etc."}]}