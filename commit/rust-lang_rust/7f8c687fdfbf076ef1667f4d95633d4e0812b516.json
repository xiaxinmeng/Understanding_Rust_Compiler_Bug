{"sha": "7f8c687fdfbf076ef1667f4d95633d4e0812b516", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmOGM2ODdmZGZiZjA3NmVmMTY2N2Y0ZDk1NjMzZDRlMDgxMmI1MTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-19T21:37:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-19T21:37:52Z"}, "message": "Auto merge of #19490 - oli-obk:json_non_string_key_maps, r=alexcrichton\n\nimporting object type string key maps is still supported\r\nwriting them should be explicit, and can be done as follows\r\n\r\n```rust\r\nlet some_tree_map : TreeMap<String, Json> = ...;\r\nJson::Object(some_tree_map).to_writer(&mut writer);\r\n```\r\n\r\nrelated to #8335, #9028, #9142", "tree": {"sha": "e91078087df374bfbecf76d3cfefa98f9c4c71b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e91078087df374bfbecf76d3cfefa98f9c4c71b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f8c687fdfbf076ef1667f4d95633d4e0812b516", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f8c687fdfbf076ef1667f4d95633d4e0812b516", "html_url": "https://github.com/rust-lang/rust/commit/7f8c687fdfbf076ef1667f4d95633d4e0812b516", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f8c687fdfbf076ef1667f4d95633d4e0812b516/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4032b85aec962486af7f205e72e93efc8a0bc434", "url": "https://api.github.com/repos/rust-lang/rust/commits/4032b85aec962486af7f205e72e93efc8a0bc434", "html_url": "https://github.com/rust-lang/rust/commit/4032b85aec962486af7f205e72e93efc8a0bc434"}, {"sha": "a320149dcce2eb27d3014113cbf87aacc04d24eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/a320149dcce2eb27d3014113cbf87aacc04d24eb", "html_url": "https://github.com/rust-lang/rust/commit/a320149dcce2eb27d3014113cbf87aacc04d24eb"}], "stats": {"total": 292, "additions": 201, "deletions": 91}, "files": [{"sha": "25279796c03c03d2ceb63425b9cc9c6e551d075a", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f8c687fdfbf076ef1667f4d95633d4e0812b516/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f8c687fdfbf076ef1667f4d95633d4e0812b516/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=7f8c687fdfbf076ef1667f4d95633d4e0812b516", "patch": "@@ -1059,8 +1059,8 @@ pub mod writer {\n             self.end_tag()\n         }\n \n-        fn emit_map_elt_key<F>(&mut self, _idx: uint, mut f: F) -> EncodeResult where\n-            F: FnMut(&mut Encoder<'a, W>) -> EncodeResult,\n+        fn emit_map_elt_key<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n         {\n \n             try!(self.start_tag(EsMapKey as uint));"}, {"sha": "77e1ebc5ef342ce2ff6707a5ed869a73701dc367", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 198, "deletions": 88, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/7f8c687fdfbf076ef1667f4d95633d4e0812b516/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f8c687fdfbf076ef1667f4d95633d4e0812b516/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=7f8c687fdfbf076ef1667f4d95633d4e0812b516", "patch": "@@ -202,7 +202,7 @@ use self::InternalStackElement::*;\n use std;\n use std::collections::{HashMap, BTreeMap};\n use std::{char, f64, fmt, io, num, str};\n-use std::mem::{swap, transmute};\n+use std::mem::{swap};\n use std::num::{Float, Int};\n use std::num::FpCategory as Fp;\n use std::str::FromStr;\n@@ -275,6 +275,12 @@ pub enum DecoderError {\n     ApplicationError(string::String)\n }\n \n+#[derive(Copy, Show)]\n+pub enum EncoderError {\n+    FmtError(fmt::Error),\n+    BadHashmapKey,\n+}\n+\n /// Returns a readable error string for a given error code.\n pub fn error_str(error: ErrorCode) -> &'static str {\n     match error {\n@@ -334,10 +340,19 @@ impl std::error::Error for DecoderError {\n     fn detail(&self) -> Option<std::string::String> { Some(format!(\"{:?}\", self)) }\n }\n \n-pub type EncodeResult = fmt::Result;\n+impl std::error::Error for EncoderError {\n+    fn description(&self) -> &str { \"encoder error\" }\n+    fn detail(&self) -> Option<std::string::String> { Some(format!(\"{:?}\", self)) }\n+}\n+\n+impl std::error::FromError<fmt::Error> for EncoderError {\n+    fn from_error(err: fmt::Error) -> EncoderError { EncoderError::FmtError(err) }\n+}\n+\n+pub type EncodeResult = Result<(), EncoderError>;\n pub type DecodeResult<T> = Result<T, DecoderError>;\n \n-fn escape_str(wr: &mut fmt::Writer, v: &str) -> fmt::Result {\n+fn escape_str(wr: &mut fmt::Writer, v: &str) -> EncodeResult {\n     try!(wr.write_str(\"\\\"\"));\n \n     let mut start = 0;\n@@ -395,17 +410,18 @@ fn escape_str(wr: &mut fmt::Writer, v: &str) -> fmt::Result {\n         try!(wr.write_str(&v[start..]));\n     }\n \n-    wr.write_str(\"\\\"\")\n+    try!(wr.write_str(\"\\\"\"));\n+    Ok(())\n }\n \n-fn escape_char(writer: &mut fmt::Writer, v: char) -> fmt::Result {\n+fn escape_char(writer: &mut fmt::Writer, v: char) -> EncodeResult {\n     let mut buf = [0; 4];\n     let n = v.encode_utf8(&mut buf).unwrap();\n     let buf = unsafe { str::from_utf8_unchecked(&buf[..n]) };\n     escape_str(writer, buf)\n }\n \n-fn spaces(wr: &mut fmt::Writer, mut n: uint) -> fmt::Result {\n+fn spaces(wr: &mut fmt::Writer, mut n: uint) -> EncodeResult {\n     const BUF: &'static str = \"                \";\n \n     while n >= BUF.len() {\n@@ -414,10 +430,9 @@ fn spaces(wr: &mut fmt::Writer, mut n: uint) -> fmt::Result {\n     }\n \n     if n > 0 {\n-        wr.write_str(&BUF[..n])\n-    } else {\n-        Ok(())\n+        try!(wr.write_str(&BUF[..n]));\n     }\n+    Ok(())\n }\n \n fn fmt_number_or_null(v: f64) -> string::String {\n@@ -431,43 +446,62 @@ fn fmt_number_or_null(v: f64) -> string::String {\n /// A structure for implementing serialization to JSON.\n pub struct Encoder<'a> {\n     writer: &'a mut (fmt::Writer+'a),\n+    is_emitting_map_key: bool,\n }\n \n impl<'a> Encoder<'a> {\n     /// Creates a new JSON encoder whose output will be written to the writer\n     /// specified.\n     pub fn new(writer: &'a mut fmt::Writer) -> Encoder<'a> {\n-        Encoder { writer: writer }\n+        Encoder { writer: writer, is_emitting_map_key: false, }\n+    }\n+}\n+\n+macro_rules! emit_enquoted_if_mapkey {\n+    ($enc:ident,$e:expr) => {\n+        if $enc.is_emitting_map_key {\n+            try!(write!($enc.writer, \"\\\"{}\\\"\", $e));\n+            Ok(())\n+        } else {\n+            try!(write!($enc.writer, \"{}\", $e));\n+            Ok(())\n+        }\n     }\n }\n \n impl<'a> ::Encoder for Encoder<'a> {\n-    type Error = fmt::Error;\n+    type Error = EncoderError;\n \n-    fn emit_nil(&mut self) -> EncodeResult { write!(self.writer, \"null\") }\n+    fn emit_nil(&mut self) -> EncodeResult {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n+        try!(write!(self.writer, \"null\"));\n+        Ok(())\n+    }\n \n-    fn emit_uint(&mut self, v: uint) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_u64(&mut self, v: u64) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_u32(&mut self, v: u32) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_u16(&mut self, v: u16) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_u8(&mut self, v: u8) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_uint(&mut self, v: uint) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_u64(&mut self, v: u64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_u32(&mut self, v: u32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_u16(&mut self, v: u16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_u8(&mut self, v: u8) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n \n-    fn emit_int(&mut self, v: int) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_i64(&mut self, v: i64) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_i32(&mut self, v: i32) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_i16(&mut self, v: i16) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_i8(&mut self, v: i8) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_int(&mut self, v: int) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_i64(&mut self, v: i64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_i32(&mut self, v: i32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_i16(&mut self, v: i16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_i8(&mut self, v: i8) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n \n     fn emit_bool(&mut self, v: bool) -> EncodeResult {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if v {\n-            write!(self.writer, \"true\")\n+            try!(write!(self.writer, \"true\"));\n         } else {\n-            write!(self.writer, \"false\")\n+            try!(write!(self.writer, \"false\"));\n         }\n+        Ok(())\n     }\n \n     fn emit_f64(&mut self, v: f64) -> EncodeResult {\n-        write!(self.writer, \"{}\", fmt_number_or_null(v))\n+        emit_enquoted_if_mapkey!(self, fmt_number_or_null(v))\n     }\n     fn emit_f32(&mut self, v: f32) -> EncodeResult {\n         self.emit_f64(v as f64)\n@@ -483,6 +517,7 @@ impl<'a> ::Encoder for Encoder<'a> {\n     fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         f(self)\n     }\n \n@@ -496,20 +531,23 @@ impl<'a> ::Encoder for Encoder<'a> {\n         // enums are encoded as strings or objects\n         // Bunny => \"Bunny\"\n         // Kangaroo(34,\"William\") => {\"variant\": \"Kangaroo\", \"fields\": [34,\"William\"]}\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if cnt == 0 {\n             escape_str(self.writer, name)\n         } else {\n             try!(write!(self.writer, \"{{\\\"variant\\\":\"));\n             try!(escape_str(self.writer, name));\n             try!(write!(self.writer, \",\\\"fields\\\":[\"));\n             try!(f(self));\n-            write!(self.writer, \"]}}\")\n+            try!(write!(self.writer, \"]}}\"));\n+            Ok(())\n         }\n     }\n \n     fn emit_enum_variant_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx != 0 {\n             try!(write!(self.writer, \",\"));\n         }\n@@ -523,6 +561,7 @@ impl<'a> ::Encoder for Encoder<'a> {\n                                    f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_enum_variant(name, id, cnt, f)\n     }\n \n@@ -532,20 +571,24 @@ impl<'a> ::Encoder for Encoder<'a> {\n                                          f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_enum_variant_arg(idx, f)\n     }\n \n     fn emit_struct<F>(&mut self, _: &str, _: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         try!(write!(self.writer, \"{{\"));\n         try!(f(self));\n-        write!(self.writer, \"}}\")\n+        try!(write!(self.writer, \"}}\"));\n+        Ok(())\n     }\n \n     fn emit_struct_field<F>(&mut self, name: &str, idx: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx != 0 { try!(write!(self.writer, \",\")); }\n         try!(escape_str(self.writer, name));\n         try!(write!(self.writer, \":\"));\n@@ -555,48 +598,60 @@ impl<'a> ::Encoder for Encoder<'a> {\n     fn emit_tuple<F>(&mut self, len: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_seq(len, f)\n     }\n     fn emit_tuple_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_seq_elt(idx, f)\n     }\n \n     fn emit_tuple_struct<F>(&mut self, _name: &str, len: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_seq(len, f)\n     }\n     fn emit_tuple_struct_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_seq_elt(idx, f)\n     }\n \n     fn emit_option<F>(&mut self, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         f(self)\n     }\n-    fn emit_option_none(&mut self) -> EncodeResult { self.emit_nil() }\n+    fn emit_option_none(&mut self) -> EncodeResult {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n+        self.emit_nil()\n+    }\n     fn emit_option_some<F>(&mut self, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         f(self)\n     }\n \n     fn emit_seq<F>(&mut self, _len: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         try!(write!(self.writer, \"[\"));\n         try!(f(self));\n-        write!(self.writer, \"]\")\n+        try!(write!(self.writer, \"]\"));\n+        Ok(())\n     }\n \n     fn emit_seq_elt<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx != 0 {\n             try!(write!(self.writer, \",\"));\n         }\n@@ -606,34 +661,28 @@ impl<'a> ::Encoder for Encoder<'a> {\n     fn emit_map<F>(&mut self, _len: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         try!(write!(self.writer, \"{{\"));\n         try!(f(self));\n-        write!(self.writer, \"}}\")\n+        try!(write!(self.writer, \"}}\"));\n+        Ok(())\n     }\n \n-    fn emit_map_elt_key<F>(&mut self, idx: uint, mut f: F) -> EncodeResult where\n-        F: FnMut(&mut Encoder<'a>) -> EncodeResult,\n+    fn emit_map_elt_key<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx != 0 { try!(write!(self.writer, \",\")) }\n-        // ref #12967, make sure to wrap a key in double quotes,\n-        // in the event that its of a type that omits them (eg numbers)\n-        let mut buf = Vec::new();\n-        // FIXME(14302) remove the transmute and unsafe block.\n-        unsafe {\n-            let mut check_encoder = Encoder::new(&mut buf);\n-            try!(f(transmute(&mut check_encoder)));\n-        }\n-        let out = str::from_utf8(&buf[]).unwrap();\n-        let needs_wrapping = out.char_at(0) != '\"' && out.char_at_reverse(out.len()) != '\"';\n-        if needs_wrapping { try!(write!(self.writer, \"\\\"\")); }\n+        self.is_emitting_map_key = true;\n         try!(f(self));\n-        if needs_wrapping { try!(write!(self.writer, \"\\\"\")); }\n+        self.is_emitting_map_key = false;\n         Ok(())\n     }\n \n     fn emit_map_elt_val<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         try!(write!(self.writer, \":\"));\n         f(self)\n     }\n@@ -645,12 +694,18 @@ pub struct PrettyEncoder<'a> {\n     writer: &'a mut (fmt::Writer+'a),\n     curr_indent: uint,\n     indent: uint,\n+    is_emitting_map_key: bool,\n }\n \n impl<'a> PrettyEncoder<'a> {\n     /// Creates a new encoder whose output will be written to the specified writer\n     pub fn new(writer: &'a mut fmt::Writer) -> PrettyEncoder<'a> {\n-        PrettyEncoder { writer: writer, curr_indent: 0, indent: 2, }\n+        PrettyEncoder {\n+            writer: writer,\n+            curr_indent: 0,\n+            indent: 2,\n+            is_emitting_map_key: false,\n+        }\n     }\n \n     /// Set the number of spaces to indent for each level.\n@@ -664,32 +719,38 @@ impl<'a> PrettyEncoder<'a> {\n }\n \n impl<'a> ::Encoder for PrettyEncoder<'a> {\n-    type Error = fmt::Error;\n+    type Error = EncoderError;\n \n-    fn emit_nil(&mut self) -> EncodeResult { write!(self.writer, \"null\") }\n+    fn emit_nil(&mut self) -> EncodeResult {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n+        try!(write!(self.writer, \"null\"));\n+        Ok(())\n+    }\n \n-    fn emit_uint(&mut self, v: uint) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_u64(&mut self, v: u64) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_u32(&mut self, v: u32) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_u16(&mut self, v: u16) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_u8(&mut self, v: u8) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_uint(&mut self, v: uint) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_u64(&mut self, v: u64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_u32(&mut self, v: u32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_u16(&mut self, v: u16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_u8(&mut self, v: u8) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n \n-    fn emit_int(&mut self, v: int) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_i64(&mut self, v: i64) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_i32(&mut self, v: i32) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_i16(&mut self, v: i16) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_i8(&mut self, v: i8) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_int(&mut self, v: int) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_i64(&mut self, v: i64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_i32(&mut self, v: i32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_i16(&mut self, v: i16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_i8(&mut self, v: i8) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n \n     fn emit_bool(&mut self, v: bool) -> EncodeResult {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if v {\n-            write!(self.writer, \"true\")\n+            try!(write!(self.writer, \"true\"));\n         } else {\n-            write!(self.writer, \"false\")\n+            try!(write!(self.writer, \"false\"));\n         }\n+        Ok(())\n     }\n \n     fn emit_f64(&mut self, v: f64) -> EncodeResult {\n-        write!(self.writer, \"{}\", fmt_number_or_null(v))\n+        emit_enquoted_if_mapkey!(self, fmt_number_or_null(v))\n     }\n     fn emit_f32(&mut self, v: f32) -> EncodeResult {\n         self.emit_f64(v as f64)\n@@ -705,6 +766,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         f(self)\n     }\n \n@@ -716,6 +778,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n                             -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if cnt == 0 {\n             escape_str(self.writer, name)\n         } else {\n@@ -735,13 +798,15 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n             self.curr_indent -= self.indent;\n             try!(write!(self.writer, \"]\\n\"));\n             try!(spaces(self.writer, self.curr_indent));\n-            write!(self.writer, \"}}\")\n+            try!(write!(self.writer, \"}}\"));\n+            Ok(())\n         }\n     }\n \n     fn emit_enum_variant_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx != 0 {\n             try!(write!(self.writer, \",\\n\"));\n         }\n@@ -756,6 +821,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n                                    f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_enum_variant(name, id, cnt, f)\n     }\n \n@@ -765,29 +831,33 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n                                          f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_enum_variant_arg(idx, f)\n     }\n \n \n     fn emit_struct<F>(&mut self, _: &str, len: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if len == 0 {\n-            write!(self.writer, \"{{}}\")\n+            try!(write!(self.writer, \"{{}}\"));\n         } else {\n             try!(write!(self.writer, \"{{\"));\n             self.curr_indent += self.indent;\n             try!(f(self));\n             self.curr_indent -= self.indent;\n             try!(write!(self.writer, \"\\n\"));\n             try!(spaces(self.writer, self.curr_indent));\n-            write!(self.writer, \"}}\")\n+            try!(write!(self.writer, \"}}\"));\n         }\n+        Ok(())\n     }\n \n     fn emit_struct_field<F>(&mut self, name: &str, idx: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx == 0 {\n             try!(write!(self.writer, \"\\n\"));\n         } else {\n@@ -802,56 +872,68 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     fn emit_tuple<F>(&mut self, len: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_seq(len, f)\n     }\n     fn emit_tuple_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_seq_elt(idx, f)\n     }\n \n     fn emit_tuple_struct<F>(&mut self, _: &str, len: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_seq(len, f)\n     }\n     fn emit_tuple_struct_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_seq_elt(idx, f)\n     }\n \n     fn emit_option<F>(&mut self, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         f(self)\n     }\n-    fn emit_option_none(&mut self) -> EncodeResult { self.emit_nil() }\n+    fn emit_option_none(&mut self) -> EncodeResult {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n+        self.emit_nil()\n+    }\n     fn emit_option_some<F>(&mut self, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         f(self)\n     }\n \n     fn emit_seq<F>(&mut self, len: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if len == 0 {\n-            write!(self.writer, \"[]\")\n+            try!(write!(self.writer, \"[]\"));\n         } else {\n             try!(write!(self.writer, \"[\"));\n             self.curr_indent += self.indent;\n             try!(f(self));\n             self.curr_indent -= self.indent;\n             try!(write!(self.writer, \"\\n\"));\n             try!(spaces(self.writer, self.curr_indent));\n-            write!(self.writer, \"]\")\n+            try!(write!(self.writer, \"]\"));\n         }\n+        Ok(())\n     }\n \n     fn emit_seq_elt<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx == 0 {\n             try!(write!(self.writer, \"\\n\"));\n         } else {\n@@ -864,47 +946,41 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     fn emit_map<F>(&mut self, len: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if len == 0 {\n-            write!(self.writer, \"{{}}\")\n+            try!(write!(self.writer, \"{{}}\"));\n         } else {\n             try!(write!(self.writer, \"{{\"));\n             self.curr_indent += self.indent;\n             try!(f(self));\n             self.curr_indent -= self.indent;\n             try!(write!(self.writer, \"\\n\"));\n             try!(spaces(self.writer, self.curr_indent));\n-            write!(self.writer, \"}}\")\n+            try!(write!(self.writer, \"}}\"));\n         }\n+        Ok(())\n     }\n \n-    fn emit_map_elt_key<F>(&mut self, idx: uint, mut f: F) -> EncodeResult where\n-        F: FnMut(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    fn emit_map_elt_key<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx == 0 {\n             try!(write!(self.writer, \"\\n\"));\n         } else {\n             try!(write!(self.writer, \",\\n\"));\n         }\n         try!(spaces(self.writer, self.curr_indent));\n-        // ref #12967, make sure to wrap a key in double quotes,\n-        // in the event that its of a type that omits them (eg numbers)\n-        let mut buf = Vec::new();\n-        // FIXME(14302) remove the transmute and unsafe block.\n-        unsafe {\n-            let mut check_encoder = PrettyEncoder::new(&mut buf);\n-            try!(f(transmute(&mut check_encoder)));\n-        }\n-        let out = str::from_utf8(&buf[]).unwrap();\n-        let needs_wrapping = out.char_at(0) != '\"' && out.char_at_reverse(out.len()) != '\"';\n-        if needs_wrapping { try!(write!(self.writer, \"\\\"\")); }\n+        self.is_emitting_map_key = true;\n         try!(f(self));\n-        if needs_wrapping { try!(write!(self.writer, \"\\\"\")); }\n+        self.is_emitting_map_key = false;\n         Ok(())\n     }\n \n     fn emit_map_elt_val<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         try!(write!(self.writer, \": \"));\n         f(self)\n     }\n@@ -2436,7 +2512,10 @@ struct FormatShim<'a, 'b: 'a> {\n \n impl<'a, 'b> fmt::Writer for FormatShim<'a, 'b> {\n     fn write_str(&mut self, s: &str) -> fmt::Result {\n-        self.inner.write_str(s)\n+        match self.inner.write_str(s) {\n+            Ok(_) => Ok(()),\n+            Err(_) => Err(fmt::Error)\n+        }\n     }\n }\n \n@@ -2445,7 +2524,10 @@ impl fmt::String for Json {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };\n         let mut encoder = Encoder::new(&mut shim);\n-        self.encode(&mut encoder)\n+        match self.encode(&mut encoder) {\n+            Ok(_) => Ok(()),\n+            Err(_) => Err(fmt::Error)\n+        }\n     }\n }\n \n@@ -2454,7 +2536,10 @@ impl<'a> fmt::String for PrettyJson<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };\n         let mut encoder = PrettyEncoder::new(&mut shim);\n-        self.inner.encode(&mut encoder)\n+        match self.inner.encode(&mut encoder) {\n+            Ok(_) => Ok(()),\n+            Err(_) => Err(fmt::Error)\n+        }\n     }\n }\n \n@@ -2463,7 +2548,10 @@ impl<'a, T: Encodable> fmt::String for AsJson<'a, T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };\n         let mut encoder = Encoder::new(&mut shim);\n-        self.inner.encode(&mut encoder)\n+        match self.inner.encode(&mut encoder) {\n+            Ok(_) => Ok(()),\n+            Err(_) => Err(fmt::Error)\n+        }\n     }\n }\n \n@@ -2484,7 +2572,10 @@ impl<'a, T: Encodable> fmt::String for AsPrettyJson<'a, T> {\n             Some(n) => encoder.set_indent(n),\n             None => {}\n         }\n-        self.inner.encode(&mut encoder)\n+        match self.inner.encode(&mut encoder) {\n+            Ok(_) => Ok(()),\n+            Err(_) => Err(fmt::Error)\n+        }\n     }\n }\n \n@@ -2507,7 +2598,7 @@ mod tests {\n     use super::DecoderError::*;\n     use super::JsonEvent::*;\n     use super::{Json, from_str, DecodeResult, DecoderError, JsonEvent, Parser,\n-                StackElement, Stack, Decoder};\n+                StackElement, Stack, Decoder, Encoder, EncoderError};\n     use std::{i64, u64, f32, f64, io};\n     use std::collections::BTreeMap;\n     use std::num::Float;\n@@ -3816,6 +3907,25 @@ mod tests {\n         assert_eq!(None::<int>.to_json(), Null);\n     }\n \n+    #[test]\n+    fn test_encode_hashmap_with_arbitrary_key() {\n+        use std::str::from_utf8;\n+        use std::io::Writer;\n+        use std::collections::HashMap;\n+        use std::fmt;\n+        #[derive(PartialEq, Eq, Hash, RustcEncodable)]\n+        struct ArbitraryType(uint);\n+        let mut hm: HashMap<ArbitraryType, bool> = HashMap::new();\n+        hm.insert(ArbitraryType(1), true);\n+        let mut mem_buf = Vec::new();\n+        let mut encoder = Encoder::new(&mut mem_buf as &mut fmt::Writer);\n+        let result = hm.encode(&mut encoder);\n+        match result.unwrap_err() {\n+            EncoderError::BadHashmapKey => (),\n+            _ => panic!(\"expected bad hash map key\")\n+        }\n+    }\n+\n     #[bench]\n     fn bench_streaming_small(b: &mut Bencher) {\n         b.iter( || {"}, {"sha": "e93d71a9dff4a1ab81fb3986b34aab207c0dc057", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f8c687fdfbf076ef1667f4d95633d4e0812b516/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f8c687fdfbf076ef1667f4d95633d4e0812b516/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=7f8c687fdfbf076ef1667f4d95633d4e0812b516", "patch": "@@ -98,7 +98,7 @@ pub trait Encoder {\n     fn emit_map<F>(&mut self, len: uint, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n     fn emit_map_elt_key<F>(&mut self, idx: uint, f: F) -> Result<(), Self::Error>\n-        where F: FnMut(&mut Self) -> Result<(), Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n     fn emit_map_elt_val<F>(&mut self, idx: uint, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n }"}]}