{"sha": "19d070393c05da7dfa1948f17872e55603a8c359", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5ZDA3MDM5M2MwNWRhN2RmYTE5NDhmMTc4NzJlNTU2MDNhOGMzNTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-19T02:54:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-19T02:54:11Z"}, "message": "Auto merge of #64598 - Centril:rollup-htmf39p, r=Centril\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #63630 (Update installed compiler dependencies)\n - #64536 (Update Cargo)\n - #64554 (Polonius: more `ui` test suite fixes)\n - #64566 (A more generic interface for dataflow analysis)\n - #64591 (Fix a minor grammar nit, update UI tests)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "ec79d111f0d728409e8fc8e87822e37db32157bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec79d111f0d728409e8fc8e87822e37db32157bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19d070393c05da7dfa1948f17872e55603a8c359", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19d070393c05da7dfa1948f17872e55603a8c359", "html_url": "https://github.com/rust-lang/rust/commit/19d070393c05da7dfa1948f17872e55603a8c359", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19d070393c05da7dfa1948f17872e55603a8c359/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eceec57f72150dd548e05025a05a93381da41385", "url": "https://api.github.com/repos/rust-lang/rust/commits/eceec57f72150dd548e05025a05a93381da41385", "html_url": "https://github.com/rust-lang/rust/commit/eceec57f72150dd548e05025a05a93381da41385"}, {"sha": "cad2d5840b1be3163855223b5c784852554ebfe0", "url": "https://api.github.com/repos/rust-lang/rust/commits/cad2d5840b1be3163855223b5c784852554ebfe0", "html_url": "https://github.com/rust-lang/rust/commit/cad2d5840b1be3163855223b5c784852554ebfe0"}], "stats": {"total": 640, "additions": 615, "deletions": 25}, "files": [{"sha": "f52e9738da8f97191531164828be2ffbee58bd77", "filename": "Cargo.lock", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/19d070393c05da7dfa1948f17872e55603a8c359/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/19d070393c05da7dfa1948f17872e55603a8c359/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=19d070393c05da7dfa1948f17872e55603a8c359", "patch": "@@ -270,6 +270,7 @@ dependencies = [\n  \"atty\",\n  \"bytesize\",\n  \"cargo-test-macro\",\n+ \"cargo-test-support\",\n  \"clap\",\n  \"core-foundation\",\n  \"crates-io\",\n@@ -286,8 +287,9 @@ dependencies = [\n  \"git2\",\n  \"git2-curl\",\n  \"glob\",\n- \"hex\",\n+ \"hex 0.4.0\",\n  \"home\",\n+ \"humantime\",\n  \"ignore\",\n  \"im-rc\",\n  \"jobserver\",\n@@ -327,6 +329,23 @@ dependencies = [\n name = \"cargo-test-macro\"\n version = \"0.1.0\"\n \n+[[package]]\n+name = \"cargo-test-support\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"cargo\",\n+ \"cargo-test-macro\",\n+ \"filetime\",\n+ \"flate2\",\n+ \"git2\",\n+ \"glob\",\n+ \"lazy_static 1.3.0\",\n+ \"remove_dir_all\",\n+ \"serde_json\",\n+ \"tar\",\n+ \"url 2.1.0\",\n+]\n+\n [[package]]\n name = \"cargo_metadata\"\n version = \"0.8.0\"\n@@ -698,7 +717,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"09de9ee0fc255ace04c7fa0763c9395a945c37c8292bb554f8d48361d1dcf1b4\"\n dependencies = [\n  \"commoncrypto\",\n- \"hex\",\n+ \"hex 0.3.2\",\n  \"openssl\",\n  \"winapi 0.3.6\",\n ]\n@@ -1260,6 +1279,12 @@ version = \"0.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"805026a5d0141ffc30abb3be3173848ad46a1b1664fe632428479619a3644d77\"\n \n+[[package]]\n+name = \"hex\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"023b39be39e3a2da62a94feb433e91e8bcd37676fbc8bea371daf52b7a769a3e\"\n+\n [[package]]\n name = \"home\"\n version = \"0.5.0\"\n@@ -2062,7 +2087,7 @@ dependencies = [\n  \"directories\",\n  \"env_logger\",\n  \"getrandom\",\n- \"hex\",\n+ \"hex 0.3.2\",\n  \"log\",\n  \"num-traits\",\n  \"rand 0.7.0\",\n@@ -3257,6 +3282,7 @@ dependencies = [\n  \"serde\",\n  \"serde_json\",\n  \"smallvec\",\n+ \"url 2.1.0\",\n  \"winapi 0.3.6\",\n ]\n "}, {"sha": "96d7e938be2f2ca8cbf253e70213530827a547c4", "filename": "README.md", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/19d070393c05da7dfa1948f17872e55603a8c359/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/19d070393c05da7dfa1948f17872e55603a8c359/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=19d070393c05da7dfa1948f17872e55603a8c359", "patch": "@@ -26,7 +26,7 @@ or reading the [rustc guide][rustcguidebuild].\n ### Building on *nix\n 1. Make sure you have installed the dependencies:\n \n-   * `g++` 4.7 or later or `clang++` 3.x or later\n+   * `g++` 5.1 or later or `clang++` 3.5 or later\n    * `python` 2.7 (but not 3.x)\n    * GNU `make` 3.81 or later\n    * `cmake` 3.4.3 or later\n@@ -151,6 +151,17 @@ by manually calling the appropriate vcvars file before running the bootstrap.\n > python x.py build\n ```\n \n+### Building rustc with older host toolchains\n+It is still possible to build Rust with the older toolchain versions listed below, but only if the\n+LLVM_TEMPORARILY_ALLOW_OLD_TOOLCHAIN option is set to true in the config.toml file.\n+\n+* Clang 3.1\n+* Apple Clang 3.1\n+* GCC 4.8\n+* Visual Studio 2015 (Update 3)\n+\n+Toolchain versions older than what is listed above cannot be used to build rustc.\n+\n #### Specifying an ABI\n \n Each specific ABI can also be used from either environment (for example, using"}, {"sha": "a54bc05f169615917beae66bd191b58209457937", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19d070393c05da7dfa1948f17872e55603a8c359/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19d070393c05da7dfa1948f17872e55603a8c359/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=19d070393c05da7dfa1948f17872e55603a8c359", "patch": "@@ -134,7 +134,7 @@ impl IntercrateAmbiguityCause {\n                     String::new()\n                 };\n                 format!(\n-                    \"upstream crates may add new impl of trait `{}`{} \\\n+                    \"upstream crates may add a new impl of trait `{}`{} \\\n                      in future versions\",\n                     trait_desc, self_desc\n                 )"}, {"sha": "886044c0692829e2c283e2e3cb10586c16ef1ef0", "filename": "src/librustc_mir/dataflow/generic.rs", "status": "added", "additions": 512, "deletions": 0, "changes": 512, "blob_url": "https://github.com/rust-lang/rust/blob/19d070393c05da7dfa1948f17872e55603a8c359/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19d070393c05da7dfa1948f17872e55603a8c359/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs?ref=19d070393c05da7dfa1948f17872e55603a8c359", "patch": "@@ -0,0 +1,512 @@\n+//! Dataflow analysis with arbitrary transfer functions.\n+//!\n+//! This module is a work in progress. You should instead use `BitDenotation` in\n+//! `librustc_mir/dataflow/mod.rs` and encode your transfer function as a [gen/kill set][gk]. In\n+//! doing so, your analysis will run faster and you will be able to generate graphviz diagrams for\n+//! debugging with no extra effort. The interface in this module is intended only for dataflow\n+//! problems that cannot be expressed using gen/kill sets.\n+//!\n+//! FIXME(ecstaticmorse): In the long term, the plan is to preserve the existing `BitDenotation`\n+//! interface, but make `Engine` and `ResultsCursor` the canonical way to perform and inspect a\n+//! dataflow analysis. This requires porting the graphviz debugging logic to this module, deciding\n+//! on a way to handle the `before` methods in `BitDenotation` and creating an adapter so that\n+//! gen-kill problems can still be evaluated efficiently. See the discussion in [#64566][] for more\n+//! information.\n+//!\n+//! [gk]: https://en.wikipedia.org/wiki/Data-flow_analysis#Bit_vector_problems\n+//! [#64566]: https://github.com/rust-lang/rust/pull/64566\n+\n+use std::cmp::Ordering;\n+use std::ops;\n+\n+use rustc::mir::{self, traversal, BasicBlock, Location};\n+use rustc_data_structures::bit_set::BitSet;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::work_queue::WorkQueue;\n+\n+use crate::dataflow::BottomValue;\n+\n+/// A specific kind of dataflow analysis.\n+///\n+/// To run a dataflow analysis, one must set the initial state of the `START_BLOCK` via\n+/// `initialize_start_block` and define a transfer function for each statement or terminator via\n+/// the various `effect` methods. The entry set for all other basic blocks is initialized to\n+/// `Self::BOTTOM_VALUE`. The dataflow `Engine` then iteratively updates the various entry sets for\n+/// each block with the cumulative effects of the transfer functions of all preceding blocks.\n+///\n+/// You should use an `Engine` to actually run an analysis, and a `ResultsCursor` to inspect the\n+/// results of that analysis like so:\n+///\n+/// ```ignore(cross-crate-imports)\n+/// fn do_my_analysis(body: &mir::Body<'tcx>, dead_unwinds: &BitSet<BasicBlock>) {\n+///     // `MyAnalysis` implements `Analysis`.\n+///     let analysis = MyAnalysis::new();\n+///\n+///     let results = Engine::new(body, dead_unwinds, analysis).iterate_to_fixpoint();\n+///     let mut cursor = ResultsCursor::new(body, results);\n+///\n+///     for (_, statement_index) in body.block_data[START_BLOCK].statements.iter_enumerated() {\n+///         cursor.seek_after(Location { block: START_BLOCK, statement_index });\n+///         let state = cursor.get();\n+///         println!(\"{:?}\", state);\n+///     }\n+/// }\n+/// ```\n+pub trait Analysis<'tcx>: BottomValue {\n+    /// The index type used to access the dataflow state.\n+    type Idx: Idx;\n+\n+    /// A name, used for debugging, that describes this dataflow analysis.\n+    ///\n+    /// The name should be suitable as part of a filename, so avoid whitespace, slashes or periods\n+    /// and try to keep it short.\n+    const NAME: &'static str;\n+\n+    /// The size of each bitvector allocated for each block.\n+    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize;\n+\n+    /// Mutates the entry set of the `START_BLOCK` to contain the initial state for dataflow\n+    /// analysis.\n+    fn initialize_start_block(&self, body: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>);\n+\n+    /// Updates the current dataflow state with the effect of evaluating a statement.\n+    fn apply_statement_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    );\n+\n+    /// Updates the current dataflow state with the effect of evaluating a statement.\n+    ///\n+    /// Note that the effect of a successful return from a `Call` terminator should **not** be\n+    /// acounted for in this function. That should go in `apply_call_return_effect`. For example,\n+    /// in the `InitializedPlaces` analyses, the return place is not marked as initialized here.\n+    fn apply_terminator_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    );\n+\n+    /// Updates the current dataflow state with the effect of a successful return from a `Call`\n+    /// terminator.\n+    ///\n+    /// This is separated from `apply_terminator_effect` to properly track state across\n+    /// unwind edges for `Call`s.\n+    fn apply_call_return_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        block: BasicBlock,\n+        func: &mir::Operand<'tcx>,\n+        args: &[mir::Operand<'tcx>],\n+        return_place: &mir::Place<'tcx>,\n+    );\n+\n+    /// Applies the cumulative effect of an entire basic block to the dataflow state (except for\n+    /// `call_return_effect`, which is handled in the `Engine`).\n+    ///\n+    /// The default implementation calls `statement_effect` for every statement in the block before\n+    /// finally calling `terminator_effect`. However, some dataflow analyses are able to coalesce\n+    /// transfer functions for an entire block and apply them at once. Such analyses should\n+    /// override `block_effect`.\n+    fn apply_whole_block_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        block: BasicBlock,\n+        block_data: &mir::BasicBlockData<'tcx>,\n+    ) {\n+        for (statement_index, stmt) in block_data.statements.iter().enumerate() {\n+            let location = Location { block, statement_index };\n+            self.apply_statement_effect(state, stmt, location);\n+        }\n+\n+        let location = Location { block, statement_index: block_data.statements.len() };\n+        self.apply_terminator_effect(state, block_data.terminator(), location);\n+    }\n+\n+    /// Applies the cumulative effect of a sequence of statements (and possibly a terminator)\n+    /// within a single basic block.\n+    ///\n+    /// When called with `0..block_data.statements.len() + 1` as the statement range, this function\n+    /// is equivalent to `apply_whole_block_effect`.\n+    fn apply_partial_block_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        block: BasicBlock,\n+        block_data: &mir::BasicBlockData<'tcx>,\n+        mut range: ops::Range<usize>,\n+    ) {\n+        if range.is_empty() {\n+            return;\n+        }\n+\n+        // The final location might be a terminator, so iterate through all statements until the\n+        // final one, then check to see whether the final one is a statement or terminator.\n+        //\n+        // This can't cause the range to wrap-around since we check that the range contains at\n+        // least one element above.\n+        range.end -= 1;\n+        let final_location = Location { block, statement_index: range.end };\n+\n+        for statement_index in range {\n+            let location = Location { block, statement_index };\n+            let stmt = &block_data.statements[statement_index];\n+            self.apply_statement_effect(state, stmt, location);\n+        }\n+\n+        if final_location.statement_index == block_data.statements.len() {\n+            let terminator = block_data.terminator();\n+            self.apply_terminator_effect(state, terminator, final_location);\n+        } else {\n+            let stmt = &block_data.statements[final_location.statement_index];\n+            self.apply_statement_effect(state, stmt, final_location);\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+enum CursorPosition {\n+    AtBlockStart(BasicBlock),\n+    After(Location),\n+}\n+\n+impl CursorPosition {\n+    fn block(&self) -> BasicBlock {\n+        match *self {\n+            Self::AtBlockStart(block) => block,\n+            Self::After(Location { block, .. }) => block,\n+        }\n+    }\n+}\n+\n+/// Inspect the results of dataflow analysis.\n+///\n+/// This cursor has linear performance when visiting statements in a block in order. Visiting\n+/// statements within a block in reverse order is `O(n^2)`, where `n` is the number of statements\n+/// in that block.\n+pub struct ResultsCursor<'mir, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    body: &'mir mir::Body<'tcx>,\n+    results: Results<'tcx, A>,\n+    state: BitSet<A::Idx>,\n+\n+    pos: CursorPosition,\n+\n+    /// Whether the effects of `apply_call_return_effect` are currently stored in `state`.\n+    ///\n+    /// This flag ensures that multiple calls to `seek_after_assume_call_returns` with the same\n+    /// target only result in one invocation of `apply_call_return_effect`.\n+    is_call_return_effect_applied: bool,\n+}\n+\n+impl<'mir, 'tcx, A> ResultsCursor<'mir, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    /// Returns a new cursor for `results` that points to the start of the `START_BLOCK`.\n+    pub fn new(body: &'mir mir::Body<'tcx>, results: Results<'tcx, A>) -> Self {\n+        ResultsCursor {\n+            body,\n+            pos: CursorPosition::AtBlockStart(mir::START_BLOCK),\n+            is_call_return_effect_applied: false,\n+            state: results.entry_sets[mir::START_BLOCK].clone(),\n+            results,\n+        }\n+    }\n+\n+    /// Resets the cursor to the start of the given `block`.\n+    pub fn seek_to_block_start(&mut self, block: BasicBlock) {\n+        self.state.overwrite(&self.results.entry_sets[block]);\n+        self.pos = CursorPosition::AtBlockStart(block);\n+        self.is_call_return_effect_applied = false;\n+    }\n+\n+    /// Updates the cursor to hold the dataflow state immediately before `target`.\n+    pub fn seek_before(&mut self, target: Location) {\n+        assert!(target <= self.body.terminator_loc(target.block));\n+\n+        if target.statement_index == 0 {\n+            self.seek_to_block_start(target.block);\n+        } else {\n+            self._seek_after(Location {\n+                block: target.block,\n+                statement_index: target.statement_index - 1,\n+            });\n+        }\n+    }\n+\n+    /// Updates the cursor to hold the dataflow state at `target`.\n+    ///\n+    /// If `target` is a `Call` terminator, `apply_call_return_effect` will not be called. See\n+    /// `seek_after_assume_call_returns` if you wish to observe the dataflow state upon a\n+    /// successful return.\n+    pub fn seek_after(&mut self, target: Location) {\n+        assert!(target <= self.body.terminator_loc(target.block));\n+\n+        // This check ensures the correctness of a call to `seek_after_assume_call_returns`\n+        // followed by one to `seek_after` with the same target.\n+        if self.is_call_return_effect_applied {\n+            self.seek_to_block_start(target.block);\n+        }\n+\n+        self._seek_after(target);\n+    }\n+\n+    /// Equivalent to `seek_after`, but also calls `apply_call_return_effect` if `target` is a\n+    /// `Call` terminator whose callee is convergent.\n+    pub fn seek_after_assume_call_returns(&mut self, target: Location) {\n+        assert!(target <= self.body.terminator_loc(target.block));\n+\n+        self._seek_after(target);\n+\n+        if target != self.body.terminator_loc(target.block) {\n+            return;\n+        }\n+\n+        let term = self.body.basic_blocks()[target.block].terminator();\n+        if let mir::TerminatorKind::Call {\n+            destination: Some((return_place, _)),\n+            func,\n+            args,\n+            ..\n+        } = &term.kind {\n+            if !self.is_call_return_effect_applied {\n+                self.is_call_return_effect_applied = true;\n+                self.results.analysis.apply_call_return_effect(\n+                    &mut self.state,\n+                    target.block,\n+                    func,\n+                    args,\n+                    return_place,\n+                );\n+            }\n+        }\n+    }\n+\n+    fn _seek_after(&mut self, target: Location) {\n+        let Location { block: target_block, statement_index: target_index } = target;\n+\n+        if self.pos.block() != target_block {\n+            self.seek_to_block_start(target_block);\n+        }\n+\n+        // If we're in the same block but after the target statement, we need to reset to the start\n+        // of the block.\n+        if let CursorPosition::After(Location { statement_index: curr_index, .. }) = self.pos {\n+            match curr_index.cmp(&target_index) {\n+                Ordering::Equal => return,\n+                Ordering::Less => {},\n+                Ordering::Greater => self.seek_to_block_start(target_block),\n+            }\n+        }\n+\n+        // The cursor is now in the same block as the target location pointing at an earlier\n+        // statement.\n+        debug_assert_eq!(self.pos.block(), target_block);\n+        if let CursorPosition::After(Location { statement_index, .. }) = self.pos {\n+            debug_assert!(statement_index < target_index);\n+        }\n+\n+        let first_unapplied_statement = match self.pos {\n+            CursorPosition::AtBlockStart(_) => 0,\n+            CursorPosition::After(Location { statement_index, .. }) => statement_index + 1,\n+        };\n+\n+        let block_data = &self.body.basic_blocks()[target_block];\n+        self.results.analysis.apply_partial_block_effect(\n+            &mut self.state,\n+            target_block,\n+            block_data,\n+            first_unapplied_statement..target_index + 1,\n+        );\n+\n+        self.pos = CursorPosition::After(target);\n+        self.is_call_return_effect_applied = false;\n+    }\n+\n+    /// Gets the dataflow state at the current location.\n+    pub fn get(&self) -> &BitSet<A::Idx> {\n+        &self.state\n+    }\n+}\n+\n+/// A completed dataflow analysis.\n+pub struct Results<'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    analysis: A,\n+    entry_sets: IndexVec<BasicBlock, BitSet<A::Idx>>,\n+}\n+\n+/// All information required to iterate a dataflow analysis to fixpoint.\n+pub struct Engine<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    analysis: A,\n+    bits_per_block: usize,\n+    body: &'a mir::Body<'tcx>,\n+    dead_unwinds: &'a BitSet<BasicBlock>,\n+    entry_sets: IndexVec<BasicBlock, BitSet<A::Idx>>,\n+}\n+\n+impl<A> Engine<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    pub fn new(\n+        body: &'a mir::Body<'tcx>,\n+        dead_unwinds: &'a BitSet<BasicBlock>,\n+        analysis: A,\n+    ) -> Self {\n+        let bits_per_block = analysis.bits_per_block(body);\n+\n+        let bottom_value_set = if A::BOTTOM_VALUE == true {\n+            BitSet::new_filled(bits_per_block)\n+        } else {\n+            BitSet::new_empty(bits_per_block)\n+        };\n+\n+        let mut entry_sets = IndexVec::from_elem(bottom_value_set, body.basic_blocks());\n+        analysis.initialize_start_block(body, &mut entry_sets[mir::START_BLOCK]);\n+\n+        Engine {\n+            analysis,\n+            bits_per_block,\n+            body,\n+            dead_unwinds,\n+            entry_sets,\n+        }\n+    }\n+\n+    pub fn iterate_to_fixpoint(mut self) -> Results<'tcx, A> {\n+        let mut temp_state = BitSet::new_empty(self.bits_per_block);\n+\n+        let mut dirty_queue: WorkQueue<BasicBlock> =\n+            WorkQueue::with_none(self.body.basic_blocks().len());\n+\n+        for (bb, _) in traversal::reverse_postorder(self.body) {\n+            dirty_queue.insert(bb);\n+        }\n+\n+        // Add blocks that are not reachable from START_BLOCK to the work queue. These blocks will\n+        // be processed after the ones added above.\n+        for bb in self.body.basic_blocks().indices() {\n+            dirty_queue.insert(bb);\n+        }\n+\n+        while let Some(bb) = dirty_queue.pop() {\n+            let bb_data = &self.body[bb];\n+            let on_entry = &self.entry_sets[bb];\n+\n+            temp_state.overwrite(on_entry);\n+            self.analysis.apply_whole_block_effect(&mut temp_state, bb, bb_data);\n+\n+            self.propagate_bits_into_graph_successors_of(\n+                &mut temp_state,\n+                (bb, bb_data),\n+                &mut dirty_queue,\n+            );\n+        }\n+\n+        Results {\n+            analysis: self.analysis,\n+            entry_sets: self.entry_sets,\n+        }\n+    }\n+\n+    fn propagate_bits_into_graph_successors_of(\n+        &mut self,\n+        in_out: &mut BitSet<A::Idx>,\n+        (bb, bb_data): (BasicBlock, &'a mir::BasicBlockData<'tcx>),\n+        dirty_list: &mut WorkQueue<BasicBlock>,\n+    ) {\n+        match bb_data.terminator().kind {\n+            mir::TerminatorKind::Return\n+            | mir::TerminatorKind::Resume\n+            | mir::TerminatorKind::Abort\n+            | mir::TerminatorKind::GeneratorDrop\n+            | mir::TerminatorKind::Unreachable => {}\n+\n+            mir::TerminatorKind::Goto { target }\n+            | mir::TerminatorKind::Assert { target, cleanup: None, .. }\n+            | mir::TerminatorKind::Yield { resume: target, drop: None, .. }\n+            | mir::TerminatorKind::Drop { target, location: _, unwind: None }\n+            | mir::TerminatorKind::DropAndReplace { target, value: _, location: _, unwind: None } =>\n+            {\n+                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n+            }\n+\n+            mir::TerminatorKind::Yield { resume: target, drop: Some(drop), .. } => {\n+                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n+                self.propagate_bits_into_entry_set_for(in_out, drop, dirty_list);\n+            }\n+\n+            mir::TerminatorKind::Assert { target, cleanup: Some(unwind), .. }\n+            | mir::TerminatorKind::Drop { target, location: _, unwind: Some(unwind) }\n+            | mir::TerminatorKind::DropAndReplace {\n+                target,\n+                value: _,\n+                location: _,\n+                unwind: Some(unwind),\n+            } => {\n+                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n+                if !self.dead_unwinds.contains(bb) {\n+                    self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n+                }\n+            }\n+\n+            mir::TerminatorKind::SwitchInt { ref targets, .. } => {\n+                for target in targets {\n+                    self.propagate_bits_into_entry_set_for(in_out, *target, dirty_list);\n+                }\n+            }\n+\n+            mir::TerminatorKind::Call { cleanup, ref destination, ref func, ref args, .. } => {\n+                if let Some(unwind) = cleanup {\n+                    if !self.dead_unwinds.contains(bb) {\n+                        self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n+                    }\n+                }\n+\n+                if let Some((ref dest_place, dest_bb)) = *destination {\n+                    // N.B.: This must be done *last*, after all other\n+                    // propagation, as documented in comment above.\n+                    self.analysis.apply_call_return_effect(in_out, bb, func, args, dest_place);\n+                    self.propagate_bits_into_entry_set_for(in_out, dest_bb, dirty_list);\n+                }\n+            }\n+\n+            mir::TerminatorKind::FalseEdges { real_target, imaginary_target } => {\n+                self.propagate_bits_into_entry_set_for(in_out, real_target, dirty_list);\n+                self.propagate_bits_into_entry_set_for(in_out, imaginary_target, dirty_list);\n+            }\n+\n+            mir::TerminatorKind::FalseUnwind { real_target, unwind } => {\n+                self.propagate_bits_into_entry_set_for(in_out, real_target, dirty_list);\n+                if let Some(unwind) = unwind {\n+                    if !self.dead_unwinds.contains(bb) {\n+                        self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn propagate_bits_into_entry_set_for(\n+        &mut self,\n+        in_out: &BitSet<A::Idx>,\n+        bb: BasicBlock,\n+        dirty_queue: &mut WorkQueue<BasicBlock>,\n+    ) {\n+        let entry_set = &mut self.entry_sets[bb];\n+        let set_changed = self.analysis.join(entry_set, &in_out);\n+        if set_changed {\n+            dirty_queue.insert(bb);\n+        }\n+    }\n+}"}, {"sha": "5ab4e25b683cb2f077fd7a7b5f65bc145d52fb26", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/19d070393c05da7dfa1948f17872e55603a8c359/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19d070393c05da7dfa1948f17872e55603a8c359/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=19d070393c05da7dfa1948f17872e55603a8c359", "patch": "@@ -30,6 +30,7 @@ use self::move_paths::MoveData;\n \n mod at_location;\n pub mod drop_flag_effects;\n+pub mod generic;\n mod graphviz;\n mod impls;\n pub mod move_paths;"}, {"sha": "9a03719ab61f5013bfdc053a701046d557d07f2d", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/19d070393c05da7dfa1948f17872e55603a8c359/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19d070393c05da7dfa1948f17872e55603a8c359/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=19d070393c05da7dfa1948f17872e55603a8c359", "patch": "@@ -23,6 +23,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(try_blocks)]\n #![feature(mem_take)]\n #![feature(associated_type_bounds)]\n+#![feature(range_is_empty)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "5f20367b6aba97e8c68dfcb74974fbe9a9c76cf5", "filename": "src/test/ui/async-await/async-borrowck-escaping-closure-error.polonius.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-closure-error.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-closure-error.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-closure-error.polonius.stderr?ref=19d070393c05da7dfa1948f17872e55603a8c359", "patch": "@@ -0,0 +1,16 @@\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/async-borrowck-escaping-closure-error.rs:5:24\n+   |\n+LL |     Box::new((async || x)())\n+   |     -------------------^----\n+   |     |         |        |\n+   |     |         |        borrowed value does not live long enough\n+   |     |         value captured here\n+   |     borrow later used here\n+LL |\n+LL | }\n+   | - `x` dropped here while still borrowed\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "c818379762c9df661067128c0557dfab0b019a0b", "filename": "src/test/ui/borrowck/return-local-binding-from-desugaring.polonius.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fborrowck%2Freturn-local-binding-from-desugaring.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fborrowck%2Freturn-local-binding-from-desugaring.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Freturn-local-binding-from-desugaring.polonius.stderr?ref=19d070393c05da7dfa1948f17872e55603a8c359", "patch": "@@ -0,0 +1,16 @@\n+error[E0716]: temporary value dropped while borrowed\n+  --> $DIR/return-local-binding-from-desugaring.rs:26:18\n+   |\n+LL |     for ref x in xs {\n+   |                  ^^ creates a temporary which is freed while still in use\n+...\n+LL |     }\n+   |     - temporary value is freed at the end of this statement\n+LL |     result\n+   |     ------ borrow later used here\n+   |\n+   = note: consider using a `let` binding to create a longer lived value\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0716`."}, {"sha": "8fe24bae7c6ca1e995cca02707235bf511608406", "filename": "src/test/ui/codemap_tests/overlapping_inherent_impls.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_inherent_impls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_inherent_impls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_inherent_impls.stderr?ref=19d070393c05da7dfa1948f17872e55603a8c359", "patch": "@@ -25,7 +25,7 @@ LL |     fn baz(&self) {}\n LL |     fn baz(&self) {}\n    |     ---------------- other definition for `baz`\n    |\n-   = note: upstream crates may add new impl of trait `std::marker::Copy` for type `std::vec::Vec<_>` in future versions\n+   = note: upstream crates may add a new impl of trait `std::marker::Copy` for type `std::vec::Vec<_>` in future versions\n \n error: aborting due to 3 previous errors\n "}, {"sha": "3a3e1a4afc3bb9596b4f7cb004e2cffe25491a91", "filename": "src/test/ui/coherence/coherence-overlap-upstream-inherent.old.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-upstream-inherent.old.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-upstream-inherent.old.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-upstream-inherent.old.stderr?ref=19d070393c05da7dfa1948f17872e55603a8c359", "patch": "@@ -7,7 +7,7 @@ LL | impl<T> A<T> where T: Remote { fn dummy(&self) { } }\n LL | impl A<i16> { fn dummy(&self) { } }\n    |               ------------------- other definition for `dummy`\n    |\n-   = note: upstream crates may add new impl of trait `coherence_lib::Remote` for type `i16` in future versions\n+   = note: upstream crates may add a new impl of trait `coherence_lib::Remote` for type `i16` in future versions\n \n error: aborting due to previous error\n "}, {"sha": "3a3e1a4afc3bb9596b4f7cb004e2cffe25491a91", "filename": "src/test/ui/coherence/coherence-overlap-upstream-inherent.re.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-upstream-inherent.re.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-upstream-inherent.re.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-upstream-inherent.re.stderr?ref=19d070393c05da7dfa1948f17872e55603a8c359", "patch": "@@ -7,7 +7,7 @@ LL | impl<T> A<T> where T: Remote { fn dummy(&self) { } }\n LL | impl A<i16> { fn dummy(&self) { } }\n    |               ------------------- other definition for `dummy`\n    |\n-   = note: upstream crates may add new impl of trait `coherence_lib::Remote` for type `i16` in future versions\n+   = note: upstream crates may add a new impl of trait `coherence_lib::Remote` for type `i16` in future versions\n \n error: aborting due to previous error\n "}, {"sha": "bd6f59f346b6d6937e0329c8ec2c2b7f1aed913a", "filename": "src/test/ui/coherence/coherence-overlap-upstream.old.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-upstream.old.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-upstream.old.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-upstream.old.stderr?ref=19d070393c05da7dfa1948f17872e55603a8c359", "patch": "@@ -6,7 +6,7 @@ LL | impl<T> Foo for T where T: Remote {}\n LL | impl Foo for i16 {}\n    | ^^^^^^^^^^^^^^^^ conflicting implementation for `i16`\n    |\n-   = note: upstream crates may add new impl of trait `coherence_lib::Remote` for type `i16` in future versions\n+   = note: upstream crates may add a new impl of trait `coherence_lib::Remote` for type `i16` in future versions\n \n error: aborting due to previous error\n "}, {"sha": "bd6f59f346b6d6937e0329c8ec2c2b7f1aed913a", "filename": "src/test/ui/coherence/coherence-overlap-upstream.re.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-upstream.re.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-upstream.re.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-upstream.re.stderr?ref=19d070393c05da7dfa1948f17872e55603a8c359", "patch": "@@ -6,7 +6,7 @@ LL | impl<T> Foo for T where T: Remote {}\n LL | impl Foo for i16 {}\n    | ^^^^^^^^^^^^^^^^ conflicting implementation for `i16`\n    |\n-   = note: upstream crates may add new impl of trait `coherence_lib::Remote` for type `i16` in future versions\n+   = note: upstream crates may add a new impl of trait `coherence_lib::Remote` for type `i16` in future versions\n \n error: aborting due to previous error\n "}, {"sha": "728eae5e547dabbe6569807e86cbd0301abef98f", "filename": "src/test/ui/coherence/coherence-projection-conflict-orphan.old.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-projection-conflict-orphan.old.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-projection-conflict-orphan.old.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-projection-conflict-orphan.old.stderr?ref=19d070393c05da7dfa1948f17872e55603a8c359", "patch": "@@ -7,7 +7,7 @@ LL |\n LL | impl<A:Iterator> Foo<A::Item> for A { }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `i32`\n    |\n-   = note: upstream crates may add new impl of trait `std::iter::Iterator` for type `i32` in future versions\n+   = note: upstream crates may add a new impl of trait `std::iter::Iterator` for type `i32` in future versions\n \n error: aborting due to previous error\n "}, {"sha": "728eae5e547dabbe6569807e86cbd0301abef98f", "filename": "src/test/ui/coherence/coherence-projection-conflict-orphan.re.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-projection-conflict-orphan.re.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-projection-conflict-orphan.re.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-projection-conflict-orphan.re.stderr?ref=19d070393c05da7dfa1948f17872e55603a8c359", "patch": "@@ -7,7 +7,7 @@ LL |\n LL | impl<A:Iterator> Foo<A::Item> for A { }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `i32`\n    |\n-   = note: upstream crates may add new impl of trait `std::iter::Iterator` for type `i32` in future versions\n+   = note: upstream crates may add a new impl of trait `std::iter::Iterator` for type `i32` in future versions\n \n error: aborting due to previous error\n "}, {"sha": "4d9f55c1215471cc99eb97190130b9bdafb1337f", "filename": "src/test/ui/coherence/coherence_copy_like_err_fundamental_struct_tuple.old.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_fundamental_struct_tuple.old.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_fundamental_struct_tuple.old.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_fundamental_struct_tuple.old.stderr?ref=19d070393c05da7dfa1948f17872e55603a8c359", "patch": "@@ -7,7 +7,7 @@ LL | impl<T: lib::MyCopy> MyTrait for T { }\n LL | impl MyTrait for lib::MyFundamentalStruct<(MyType,)> { }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `lib::MyFundamentalStruct<(MyType,)>`\n    |\n-   = note: upstream crates may add new impl of trait `lib::MyCopy` for type `lib::MyFundamentalStruct<(MyType,)>` in future versions\n+   = note: upstream crates may add a new impl of trait `lib::MyCopy` for type `lib::MyFundamentalStruct<(MyType,)>` in future versions\n \n error: aborting due to previous error\n "}, {"sha": "4d9f55c1215471cc99eb97190130b9bdafb1337f", "filename": "src/test/ui/coherence/coherence_copy_like_err_fundamental_struct_tuple.re.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_fundamental_struct_tuple.re.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_fundamental_struct_tuple.re.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_fundamental_struct_tuple.re.stderr?ref=19d070393c05da7dfa1948f17872e55603a8c359", "patch": "@@ -7,7 +7,7 @@ LL | impl<T: lib::MyCopy> MyTrait for T { }\n LL | impl MyTrait for lib::MyFundamentalStruct<(MyType,)> { }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `lib::MyFundamentalStruct<(MyType,)>`\n    |\n-   = note: upstream crates may add new impl of trait `lib::MyCopy` for type `lib::MyFundamentalStruct<(MyType,)>` in future versions\n+   = note: upstream crates may add a new impl of trait `lib::MyCopy` for type `lib::MyFundamentalStruct<(MyType,)>` in future versions\n \n error: aborting due to previous error\n "}, {"sha": "f0bcf659bb696946741bdccbdf5dd9af2b727ccd", "filename": "src/test/ui/coherence/coherence_copy_like_err_struct.old.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_struct.old.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_struct.old.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_struct.old.stderr?ref=19d070393c05da7dfa1948f17872e55603a8c359", "patch": "@@ -7,7 +7,7 @@ LL | impl<T: lib::MyCopy> MyTrait for T { }\n LL | impl MyTrait for lib::MyStruct<MyType> { }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `lib::MyStruct<MyType>`\n    |\n-   = note: upstream crates may add new impl of trait `lib::MyCopy` for type `lib::MyStruct<MyType>` in future versions\n+   = note: upstream crates may add a new impl of trait `lib::MyCopy` for type `lib::MyStruct<MyType>` in future versions\n \n error: aborting due to previous error\n "}, {"sha": "f0bcf659bb696946741bdccbdf5dd9af2b727ccd", "filename": "src/test/ui/coherence/coherence_copy_like_err_struct.re.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_struct.re.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_struct.re.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_struct.re.stderr?ref=19d070393c05da7dfa1948f17872e55603a8c359", "patch": "@@ -7,7 +7,7 @@ LL | impl<T: lib::MyCopy> MyTrait for T { }\n LL | impl MyTrait for lib::MyStruct<MyType> { }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `lib::MyStruct<MyType>`\n    |\n-   = note: upstream crates may add new impl of trait `lib::MyCopy` for type `lib::MyStruct<MyType>` in future versions\n+   = note: upstream crates may add a new impl of trait `lib::MyCopy` for type `lib::MyStruct<MyType>` in future versions\n \n error: aborting due to previous error\n "}, {"sha": "a40153af2cf30daf331b75e2086eab64f2375402", "filename": "src/test/ui/coherence/coherence_copy_like_err_tuple.old.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_tuple.old.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_tuple.old.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_tuple.old.stderr?ref=19d070393c05da7dfa1948f17872e55603a8c359", "patch": "@@ -7,7 +7,7 @@ LL | impl<T: lib::MyCopy> MyTrait for T { }\n LL | impl MyTrait for (MyType,) { }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `(MyType,)`\n    |\n-   = note: upstream crates may add new impl of trait `lib::MyCopy` for type `(MyType,)` in future versions\n+   = note: upstream crates may add a new impl of trait `lib::MyCopy` for type `(MyType,)` in future versions\n \n error: aborting due to previous error\n "}, {"sha": "a40153af2cf30daf331b75e2086eab64f2375402", "filename": "src/test/ui/coherence/coherence_copy_like_err_tuple.re.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_tuple.re.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_tuple.re.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_tuple.re.stderr?ref=19d070393c05da7dfa1948f17872e55603a8c359", "patch": "@@ -7,7 +7,7 @@ LL | impl<T: lib::MyCopy> MyTrait for T { }\n LL | impl MyTrait for (MyType,) { }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `(MyType,)`\n    |\n-   = note: upstream crates may add new impl of trait `lib::MyCopy` for type `(MyType,)` in future versions\n+   = note: upstream crates may add a new impl of trait `lib::MyCopy` for type `(MyType,)` in future versions\n \n error: aborting due to previous error\n "}, {"sha": "5e93a0234259c154435e3cffd30e060a233403ce", "filename": "src/test/ui/dropck/dropck_trait_cycle_checked.polonius.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fdropck%2Fdropck_trait_cycle_checked.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fdropck%2Fdropck_trait_cycle_checked.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck_trait_cycle_checked.polonius.stderr?ref=19d070393c05da7dfa1948f17872e55603a8c359", "patch": "@@ -8,7 +8,9 @@ LL | }\n    | -\n    | |\n    | `o2` dropped here while still borrowed\n-   | borrow might be used here, when `o2` is dropped and runs the destructor for type `std::boxed::Box<dyn Obj<'_>>`\n+   | borrow might be used here, when `o1` is dropped and runs the destructor for type `std::boxed::Box<dyn Obj<'_>>`\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error[E0597]: `o3` does not live long enough\n   --> $DIR/dropck_trait_cycle_checked.rs:112:13\n@@ -20,7 +22,9 @@ LL | }\n    | -\n    | |\n    | `o3` dropped here while still borrowed\n-   | borrow might be used here, when `o3` is dropped and runs the destructor for type `std::boxed::Box<dyn Obj<'_>>`\n+   | borrow might be used here, when `o1` is dropped and runs the destructor for type `std::boxed::Box<dyn Obj<'_>>`\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error[E0597]: `o2` does not live long enough\n   --> $DIR/dropck_trait_cycle_checked.rs:113:13\n@@ -38,7 +42,7 @@ error[E0597]: `o3` does not live long enough\n   --> $DIR/dropck_trait_cycle_checked.rs:114:13\n    |\n LL |     let (o1, o2, o3): (Box<dyn Obj>, Box<dyn Obj>, Box<dyn Obj>) = (O::new(), O::new(), O::new());\n-   |                                                                                         -------- cast requires that `o3` is borrowed for `'static`\n+   |                                                                               -------- cast requires that `o3` is borrowed for `'static`\n ...\n LL |     o2.set1(&o3);\n    |             ^^^ borrowed value does not live long enough\n@@ -62,7 +66,7 @@ error[E0597]: `o2` does not live long enough\n   --> $DIR/dropck_trait_cycle_checked.rs:116:13\n    |\n LL |     let (o1, o2, o3): (Box<dyn Obj>, Box<dyn Obj>, Box<dyn Obj>) = (O::new(), O::new(), O::new());\n-   |                                                                               -------- cast requires that `o2` is borrowed for `'static`\n+   |                                                                                         -------- cast requires that `o2` is borrowed for `'static`\n ...\n LL |     o3.set1(&o2);\n    |             ^^^ borrowed value does not live long enough"}, {"sha": "84c10d8fbc47728c0dabb807ae250f7f75ab35d7", "filename": "src/test/ui/issues/issue-48728.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fissues%2Fissue-48728.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fissues%2Fissue-48728.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-48728.stderr?ref=19d070393c05da7dfa1948f17872e55603a8c359", "patch": "@@ -7,7 +7,7 @@ LL | #[derive(Clone)]\n LL | impl<T: Clone + ?Sized> Clone for Node<[T]> {\n    | ------------------------------------------- first implementation here\n    |\n-   = note: upstream crates may add new impl of trait `std::clone::Clone` for type `[_]` in future versions\n+   = note: upstream crates may add a new impl of trait `std::clone::Clone` for type `[_]` in future versions\n \n error: aborting due to previous error\n "}, {"sha": "0e4d442f299c3c418882653062ccb64fc857b44a", "filename": "src/test/ui/json-multiple.polonius.stderr", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fjson-multiple.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fjson-multiple.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-multiple.polonius.stderr?ref=19d070393c05da7dfa1948f17872e55603a8c359", "patch": "@@ -0,0 +1 @@\n+{\"artifact\":\"$TEST_BUILD_DIR/json-multiple.polonius/libjson_multiple.rlib\",\"emit\":\"link\"}"}, {"sha": "e21f6f85d162d1a5d6c8ddf92ecc2597b815834b", "filename": "src/test/ui/json-options.polonius.stderr", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fjson-options.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fjson-options.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-options.polonius.stderr?ref=19d070393c05da7dfa1948f17872e55603a8c359", "patch": "@@ -0,0 +1 @@\n+{\"artifact\":\"$TEST_BUILD_DIR/json-options.polonius/libjson_options.rlib\",\"emit\":\"link\"}"}, {"sha": "36f96b011983f0db757362adbeb9d23edc7d15a4", "filename": "src/test/ui/specialization/issue-52050.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fspecialization%2Fissue-52050.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftest%2Fui%2Fspecialization%2Fissue-52050.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fissue-52050.stderr?ref=19d070393c05da7dfa1948f17872e55603a8c359", "patch": "@@ -11,7 +11,7 @@ LL |\n LL |   impl IntoPyDictPointer for ()\n    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `()`\n    |\n-   = note: upstream crates may add new impl of trait `std::iter::Iterator` for type `()` in future versions\n+   = note: upstream crates may add a new impl of trait `std::iter::Iterator` for type `()` in future versions\n \n error: aborting due to previous error\n "}, {"sha": "3596cb86b2e87dd9b9c1bb90d4a9d73ec2c1512f", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=19d070393c05da7dfa1948f17872e55603a8c359", "patch": "@@ -1 +1 @@\n-Subproject commit 9655d70af8a6dddac238e3afa2fec75088c9226f\n+Subproject commit 3596cb86b2e87dd9b9c1bb90d4a9d73ec2c1512f"}, {"sha": "980c9753761ed5cb727198b355f871c5b003da4b", "filename": "src/tools/rustc-workspace-hack/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/19d070393c05da7dfa1948f17872e55603a8c359/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml?ref=19d070393c05da7dfa1948f17872e55603a8c359", "patch": "@@ -62,6 +62,7 @@ crossbeam-utils = { version = \"0.6.5\", features = [\"nightly\"] }\n serde = { version = \"1.0.82\", features = ['derive'] }\n serde_json = { version = \"1.0.31\", features = [\"raw_value\"] }\n smallvec = { version = \"0.6\", features = ['union', 'may_dangle'] }\n+url = { version = \"2.0\", features = ['serde'] }\n \n \n [target.'cfg(not(windows))'.dependencies]"}]}