{"sha": "26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2YmYwZWYwYjVhNzBhNzBhNmUwZjg1NTMzYmIzY2ExNDA0ZTk2NTA=", "commit": {"author": {"name": "Klim Tsoutsman", "email": "32662194+tsoutsman@users.noreply.github.com", "date": "2021-08-08T03:17:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-08T03:17:23Z"}, "message": "Merge branch 'rust-lang:master' into master", "tree": {"sha": "064df89e6802b6fbd290957508e553da317c242a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/064df89e6802b6fbd290957508e553da317c242a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhD0zDCRBK7hj4Ov3rIwAAZeYIAHgtB6pPIudx0cFuSlYoXweC\nrSlaJ+TXVH9t7+rVgXY78GE9d88NuhdYrgUAN6KrGL4iUtcS41isCqK203wvVU9S\n53WZD8vHvw5rfvU3M3rbyOXi461cLFQK1RWJXw6dToB2ISDFjVtP42pfVhBcak5J\nXv50iErQFzO3LNukX76J8rZE2Cx5qj9tEtQA+41W+q5fGpUXN6mRmuF+7pHaRC2k\nsF4UzwPYgRLeWAvUWLizPSjGMt9PqeRlGdloRHgV5tHBPrDg3d1wQz2zScETCURy\n33h709pydFMGjODlPqBP/q1lExlHLbJeETjuyZWwSWEC6GgpvM4yt7K2JaGUKos=\n=w1DW\n-----END PGP SIGNATURE-----\n", "payload": "tree 064df89e6802b6fbd290957508e553da317c242a\nparent 75e80358d20d41ef148da32a1a5a4e29282181fc\nparent 798446fe0612dd83a151e99c201b87dd649d4eb3\nauthor Klim Tsoutsman <32662194+tsoutsman@users.noreply.github.com> 1628392643 +1000\ncommitter GitHub <noreply@github.com> 1628392643 +1000\n\nMerge branch 'rust-lang:master' into master\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "html_url": "https://github.com/rust-lang/rust/commit/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/comments", "author": {"login": "tsoutsman", "id": 32662194, "node_id": "MDQ6VXNlcjMyNjYyMTk0", "avatar_url": "https://avatars.githubusercontent.com/u/32662194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tsoutsman", "html_url": "https://github.com/tsoutsman", "followers_url": "https://api.github.com/users/tsoutsman/followers", "following_url": "https://api.github.com/users/tsoutsman/following{/other_user}", "gists_url": "https://api.github.com/users/tsoutsman/gists{/gist_id}", "starred_url": "https://api.github.com/users/tsoutsman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tsoutsman/subscriptions", "organizations_url": "https://api.github.com/users/tsoutsman/orgs", "repos_url": "https://api.github.com/users/tsoutsman/repos", "events_url": "https://api.github.com/users/tsoutsman/events{/privacy}", "received_events_url": "https://api.github.com/users/tsoutsman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75e80358d20d41ef148da32a1a5a4e29282181fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/75e80358d20d41ef148da32a1a5a4e29282181fc", "html_url": "https://github.com/rust-lang/rust/commit/75e80358d20d41ef148da32a1a5a4e29282181fc"}, {"sha": "798446fe0612dd83a151e99c201b87dd649d4eb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/798446fe0612dd83a151e99c201b87dd649d4eb3", "html_url": "https://github.com/rust-lang/rust/commit/798446fe0612dd83a151e99c201b87dd649d4eb3"}], "stats": {"total": 847, "additions": 528, "deletions": 319}, "files": [{"sha": "5253c819ca2c93ac4505afae60554cb8ce693405", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -4795,9 +4795,9 @@ checksum = \"da73c8f77aebc0e40c300b93f0a5f1bece7a248a36eee287d4e095f35c7b7d6e\"\n \n [[package]]\n name = \"socket2\"\n-version = \"0.4.0\"\n+version = \"0.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9e3dfc207c526015c632472a77be09cf1b6e46866581aecae5cc38fb4235dea2\"\n+checksum = \"765f090f0e423d2b55843402a07915add955e7d60657db13707a159727326cad\"\n dependencies = [\n  \"libc\",\n  \"winapi\","}, {"sha": "abf0ea8cc0a65b05c4329b1312e507a17eb2a698", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -353,7 +353,11 @@ pub trait FnAbiLlvmExt<'tcx> {\n \n impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n     fn llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type {\n-        let args_capacity: usize = self.args.iter().map(|arg|\n+        // Ignore \"extra\" args from the call site for C variadic functions.\n+        // Only the \"fixed\" args are part of the LLVM function signature.\n+        let args = if self.c_variadic { &self.args[..self.fixed_count] } else { &self.args };\n+\n+        let args_capacity: usize = args.iter().map(|arg|\n             if arg.pad.is_some() { 1 } else { 0 } +\n             if let PassMode::Pair(_, _) = arg.mode { 2 } else { 1 }\n         ).sum();\n@@ -371,7 +375,7 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n             }\n         };\n \n-        for arg in &self.args {\n+        for arg in args {\n             // add padding\n             if let Some(ty) = arg.pad {\n                 llargument_tys.push(ty.llvm_type(cx));"}, {"sha": "2d79b73cf9f519e921d2c50626c5228b093ae700", "filename": "compiler/rustc_codegen_llvm/src/allocator.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -78,8 +78,14 @@ pub(crate) unsafe fn codegen(\n             .enumerate()\n             .map(|(i, _)| llvm::LLVMGetParam(llfn, i as c_uint))\n             .collect::<Vec<_>>();\n-        let ret =\n-            llvm::LLVMRustBuildCall(llbuilder, callee, args.as_ptr(), args.len() as c_uint, None);\n+        let ret = llvm::LLVMRustBuildCall(\n+            llbuilder,\n+            ty,\n+            callee,\n+            args.as_ptr(),\n+            args.len() as c_uint,\n+            None,\n+        );\n         llvm::LLVMSetTailCall(ret, True);\n         if output.is_some() {\n             llvm::LLVMBuildRet(llbuilder, ret);\n@@ -121,7 +127,8 @@ pub(crate) unsafe fn codegen(\n         .enumerate()\n         .map(|(i, _)| llvm::LLVMGetParam(llfn, i as c_uint))\n         .collect::<Vec<_>>();\n-    let ret = llvm::LLVMRustBuildCall(llbuilder, callee, args.as_ptr(), args.len() as c_uint, None);\n+    let ret =\n+        llvm::LLVMRustBuildCall(llbuilder, ty, callee, args.as_ptr(), args.len() as c_uint, None);\n     llvm::LLVMSetTailCall(ret, True);\n     llvm::LLVMBuildRetVoid(llbuilder);\n     llvm::LLVMDisposeBuilder(llbuilder);"}, {"sha": "ebc3773df57cd7fd84b1bbce79876ce3142a64b2", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -464,7 +464,7 @@ fn inline_asm_call(\n                 alignstack,\n                 llvm::AsmDialect::from_generic(dia),\n             );\n-            let call = bx.call(v, inputs, None);\n+            let call = bx.call(fty, v, inputs, None);\n \n             // Store mark in a metadata node so we can map LLVM errors\n             // back to source locations.  See #17552."}, {"sha": "2139f9776b736192edc8c391b667ad1c23a3a047", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -200,6 +200,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn invoke(\n         &mut self,\n+        llty: &'ll Type,\n         llfn: &'ll Value,\n         args: &[&'ll Value],\n         then: &'ll BasicBlock,\n@@ -208,13 +209,14 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     ) -> &'ll Value {\n         debug!(\"invoke {:?} with args ({:?})\", llfn, args);\n \n-        let args = self.check_call(\"invoke\", llfn, args);\n+        let args = self.check_call(\"invoke\", llty, llfn, args);\n         let bundle = funclet.map(|funclet| funclet.bundle());\n         let bundle = bundle.as_ref().map(|b| &*b.raw);\n \n         unsafe {\n             llvm::LLVMRustBuildInvoke(\n                 self.llbuilder,\n+                llty,\n                 llfn,\n                 args.as_ptr(),\n                 args.len() as c_uint,\n@@ -369,8 +371,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n             },\n         };\n \n-        let intrinsic = self.get_intrinsic(&name);\n-        let res = self.call(intrinsic, &[lhs, rhs], None);\n+        let res = self.call_intrinsic(name, &[lhs, rhs]);\n         (self.extract_value(res, 0), self.extract_value(res, 1))\n     }\n \n@@ -695,8 +696,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n             let float_width = self.cx.float_width(src_ty);\n             let int_width = self.cx.int_width(dest_ty);\n             let name = format!(\"llvm.fptoui.sat.i{}.f{}\", int_width, float_width);\n-            let intrinsic = self.get_intrinsic(&name);\n-            return Some(self.call(intrinsic, &[val], None));\n+            return Some(self.call_intrinsic(&name, &[val]));\n         }\n \n         None\n@@ -708,8 +708,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n             let float_width = self.cx.float_width(src_ty);\n             let int_width = self.cx.int_width(dest_ty);\n             let name = format!(\"llvm.fptosi.sat.i{}.f{}\", int_width, float_width);\n-            let intrinsic = self.get_intrinsic(&name);\n-            return Some(self.call(intrinsic, &[val], None));\n+            return Some(self.call_intrinsic(&name, &[val]));\n         }\n \n         None\n@@ -743,8 +742,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                     _ => None,\n                 };\n                 if let Some(name) = name {\n-                    let intrinsic = self.get_intrinsic(name);\n-                    return self.call(intrinsic, &[val], None);\n+                    return self.call_intrinsic(name, &[val]);\n                 }\n             }\n         }\n@@ -766,8 +764,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                     _ => None,\n                 };\n                 if let Some(name) = name {\n-                    let intrinsic = self.get_intrinsic(name);\n-                    return self.call(intrinsic, &[val], None);\n+                    return self.call_intrinsic(name, &[val]);\n                 }\n             }\n         }\n@@ -1115,12 +1112,17 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         );\n \n         let llfn = unsafe { llvm::LLVMRustGetInstrProfIncrementIntrinsic(self.cx().llmod) };\n+        let llty = self.cx.type_func(\n+            &[self.cx.type_i8p(), self.cx.type_i64(), self.cx.type_i32(), self.cx.type_i32()],\n+            self.cx.type_void(),\n+        );\n         let args = &[fn_name, hash, num_counters, index];\n-        let args = self.check_call(\"call\", llfn, args);\n+        let args = self.check_call(\"call\", llty, llfn, args);\n \n         unsafe {\n             let _ = llvm::LLVMRustBuildCall(\n                 self.llbuilder,\n+                llty,\n                 llfn,\n                 args.as_ptr() as *const &llvm::Value,\n                 args.len() as c_uint,\n@@ -1131,19 +1133,21 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn call(\n         &mut self,\n+        llty: &'ll Type,\n         llfn: &'ll Value,\n         args: &[&'ll Value],\n         funclet: Option<&Funclet<'ll>>,\n     ) -> &'ll Value {\n         debug!(\"call {:?} with args ({:?})\", llfn, args);\n \n-        let args = self.check_call(\"call\", llfn, args);\n+        let args = self.check_call(\"call\", llty, llfn, args);\n         let bundle = funclet.map(|funclet| funclet.bundle());\n         let bundle = bundle.as_ref().map(|b| &*b.raw);\n \n         unsafe {\n             llvm::LLVMRustBuildCall(\n                 self.llbuilder,\n+                llty,\n                 llfn,\n                 args.as_ptr() as *const &llvm::Value,\n                 args.len() as c_uint,\n@@ -1313,15 +1317,10 @@ impl Builder<'a, 'll, 'tcx> {\n     fn check_call<'b>(\n         &mut self,\n         typ: &str,\n+        fn_ty: &'ll Type,\n         llfn: &'ll Value,\n         args: &'b [&'ll Value],\n     ) -> Cow<'b, [&'ll Value]> {\n-        let mut fn_ty = self.cx.val_ty(llfn);\n-        // Strip off pointers\n-        while self.cx.type_kind(fn_ty) == TypeKind::Pointer {\n-            fn_ty = self.cx.element_type(fn_ty);\n-        }\n-\n         assert!(\n             self.cx.type_kind(fn_ty) == TypeKind::Function,\n             \"builder::{} not passed a function, but {:?}\",\n@@ -1362,6 +1361,11 @@ impl Builder<'a, 'll, 'tcx> {\n         unsafe { llvm::LLVMBuildVAArg(self.llbuilder, list, ty, UNNAMED) }\n     }\n \n+    crate fn call_intrinsic(&mut self, intrinsic: &str, args: &[&'ll Value]) -> &'ll Value {\n+        let (ty, f) = self.cx.get_intrinsic(intrinsic);\n+        self.call(ty, f, args, None)\n+    }\n+\n     fn call_lifetime_intrinsic(&mut self, intrinsic: &str, ptr: &'ll Value, size: Size) {\n         let size = size.bytes();\n         if size == 0 {\n@@ -1372,10 +1376,8 @@ impl Builder<'a, 'll, 'tcx> {\n             return;\n         }\n \n-        let lifetime_intrinsic = self.cx.get_intrinsic(intrinsic);\n-\n         let ptr = self.pointercast(ptr, self.cx.type_i8p());\n-        self.call(lifetime_intrinsic, &[self.cx.const_u64(size), ptr], None);\n+        self.call_intrinsic(intrinsic, &[self.cx.const_u64(size), ptr]);\n     }\n \n     pub(crate) fn phi("}, {"sha": "685f222e8025f90dc44c81d949b20ac82f20da2f", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -84,9 +84,9 @@ pub struct CodegenCx<'ll, 'tcx> {\n \n     eh_personality: Cell<Option<&'ll Value>>,\n     eh_catch_typeinfo: Cell<Option<&'ll Value>>,\n-    pub rust_try_fn: Cell<Option<&'ll Value>>,\n+    pub rust_try_fn: Cell<Option<(&'ll Type, &'ll Value)>>,\n \n-    intrinsics: RefCell<FxHashMap<&'static str, &'ll Value>>,\n+    intrinsics: RefCell<FxHashMap<&'static str, (&'ll Type, &'ll Value)>>,\n \n     /// A counter that is used for generating local symbol names\n     local_gen_sym_counter: Cell<usize>,\n@@ -452,7 +452,7 @@ impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n }\n \n impl CodegenCx<'b, 'tcx> {\n-    crate fn get_intrinsic(&self, key: &str) -> &'b Value {\n+    crate fn get_intrinsic(&self, key: &str) -> (&'b Type, &'b Value) {\n         if let Some(v) = self.intrinsics.borrow().get(key).cloned() {\n             return v;\n         }\n@@ -465,18 +465,18 @@ impl CodegenCx<'b, 'tcx> {\n         name: &'static str,\n         args: Option<&[&'b llvm::Type]>,\n         ret: &'b llvm::Type,\n-    ) -> &'b llvm::Value {\n+    ) -> (&'b llvm::Type, &'b llvm::Value) {\n         let fn_ty = if let Some(args) = args {\n             self.type_func(args, ret)\n         } else {\n             self.type_variadic_func(&[], ret)\n         };\n         let f = self.declare_cfn(name, llvm::UnnamedAddr::No, fn_ty);\n-        self.intrinsics.borrow_mut().insert(name, f);\n-        f\n+        self.intrinsics.borrow_mut().insert(name, (fn_ty, f));\n+        (fn_ty, f)\n     }\n \n-    fn declare_intrinsic(&self, key: &str) -> Option<&'b Value> {\n+    fn declare_intrinsic(&self, key: &str) -> Option<(&'b Type, &'b Value)> {\n         macro_rules! ifn {\n             ($name:expr, fn() -> $ret:expr) => (\n                 if key == $name {"}, {"sha": "ed4841858651749e613e83abc9516bf496ab7d42", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 80, "deletions": 94, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -1,4 +1,4 @@\n-use crate::abi::{Abi, FnAbi, LlvmType, PassMode};\n+use crate::abi::{Abi, FnAbi, FnAbiLlvmExt, LlvmType, PassMode};\n use crate::builder::Builder;\n use crate::context::CodegenCx;\n use crate::llvm;\n@@ -24,7 +24,7 @@ use rustc_target::spec::PanicStrategy;\n use std::cmp::Ordering;\n use std::iter;\n \n-fn get_simple_intrinsic(cx: &CodegenCx<'ll, '_>, name: Symbol) -> Option<&'ll Value> {\n+fn get_simple_intrinsic(cx: &CodegenCx<'ll, '_>, name: Symbol) -> Option<(&'ll Type, &'ll Value)> {\n     let llvm_name = match name {\n         sym::sqrtf32 => \"llvm.sqrt.f32\",\n         sym::sqrtf64 => \"llvm.sqrt.f64\",\n@@ -102,19 +102,20 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n \n         let simple = get_simple_intrinsic(self, name);\n         let llval = match name {\n-            _ if simple.is_some() => self.call(\n-                simple.unwrap(),\n-                &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n-                None,\n-            ),\n-            sym::likely => {\n-                let expect = self.get_intrinsic(&(\"llvm.expect.i1\"));\n-                self.call(expect, &[args[0].immediate(), self.const_bool(true)], None)\n+            _ if simple.is_some() => {\n+                let (simple_ty, simple_fn) = simple.unwrap();\n+                self.call(\n+                    simple_ty,\n+                    simple_fn,\n+                    &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n+                    None,\n+                )\n             }\n-            sym::unlikely => {\n-                let expect = self.get_intrinsic(&(\"llvm.expect.i1\"));\n-                self.call(expect, &[args[0].immediate(), self.const_bool(false)], None)\n+            sym::likely => {\n+                self.call_intrinsic(\"llvm.expect.i1\", &[args[0].immediate(), self.const_bool(true)])\n             }\n+            sym::unlikely => self\n+                .call_intrinsic(\"llvm.expect.i1\", &[args[0].immediate(), self.const_bool(false)]),\n             kw::Try => {\n                 try_intrinsic(\n                     self,\n@@ -125,13 +126,9 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 );\n                 return;\n             }\n-            sym::breakpoint => {\n-                let llfn = self.get_intrinsic(&(\"llvm.debugtrap\"));\n-                self.call(llfn, &[], None)\n-            }\n+            sym::breakpoint => self.call_intrinsic(\"llvm.debugtrap\", &[]),\n             sym::va_copy => {\n-                let intrinsic = self.cx().get_intrinsic(&(\"llvm.va_copy\"));\n-                self.call(intrinsic, &[args[0].immediate(), args[1].immediate()], None)\n+                self.call_intrinsic(\"llvm.va_copy\", &[args[0].immediate(), args[1].immediate()])\n             }\n             sym::va_arg => {\n                 match fn_abi.ret.layout.abi {\n@@ -194,23 +191,21 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             | sym::prefetch_write_data\n             | sym::prefetch_read_instruction\n             | sym::prefetch_write_instruction => {\n-                let expect = self.get_intrinsic(&(\"llvm.prefetch\"));\n                 let (rw, cache_type) = match name {\n                     sym::prefetch_read_data => (0, 1),\n                     sym::prefetch_write_data => (1, 1),\n                     sym::prefetch_read_instruction => (0, 0),\n                     sym::prefetch_write_instruction => (1, 0),\n                     _ => bug!(),\n                 };\n-                self.call(\n-                    expect,\n+                self.call_intrinsic(\n+                    \"llvm.prefetch\",\n                     &[\n                         args[0].immediate(),\n                         self.const_i32(rw),\n                         args[1].immediate(),\n                         self.const_i32(cache_type),\n                     ],\n-                    None,\n                 )\n             }\n             sym::ctlz\n@@ -229,35 +224,33 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                     Some((width, signed)) => match name {\n                         sym::ctlz | sym::cttz => {\n                             let y = self.const_bool(false);\n-                            let llfn = self.get_intrinsic(&format!(\"llvm.{}.i{}\", name, width));\n-                            self.call(llfn, &[args[0].immediate(), y], None)\n+                            self.call_intrinsic(\n+                                &format!(\"llvm.{}.i{}\", name, width),\n+                                &[args[0].immediate(), y],\n+                            )\n                         }\n                         sym::ctlz_nonzero | sym::cttz_nonzero => {\n                             let y = self.const_bool(true);\n                             let llvm_name = &format!(\"llvm.{}.i{}\", &name_str[..4], width);\n-                            let llfn = self.get_intrinsic(llvm_name);\n-                            self.call(llfn, &[args[0].immediate(), y], None)\n+                            self.call_intrinsic(llvm_name, &[args[0].immediate(), y])\n                         }\n-                        sym::ctpop => self.call(\n-                            self.get_intrinsic(&format!(\"llvm.ctpop.i{}\", width)),\n+                        sym::ctpop => self.call_intrinsic(\n+                            &format!(\"llvm.ctpop.i{}\", width),\n                             &[args[0].immediate()],\n-                            None,\n                         ),\n                         sym::bswap => {\n                             if width == 8 {\n                                 args[0].immediate() // byte swap a u8/i8 is just a no-op\n                             } else {\n-                                self.call(\n-                                    self.get_intrinsic(&format!(\"llvm.bswap.i{}\", width)),\n+                                self.call_intrinsic(\n+                                    &format!(\"llvm.bswap.i{}\", width),\n                                     &[args[0].immediate()],\n-                                    None,\n                                 )\n                             }\n                         }\n-                        sym::bitreverse => self.call(\n-                            self.get_intrinsic(&format!(\"llvm.bitreverse.i{}\", width)),\n+                        sym::bitreverse => self.call_intrinsic(\n+                            &format!(\"llvm.bitreverse.i{}\", width),\n                             &[args[0].immediate()],\n-                            None,\n                         ),\n                         sym::rotate_left | sym::rotate_right => {\n                             let is_left = name == sym::rotate_left;\n@@ -266,8 +259,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                             // rotate = funnel shift with first two args the same\n                             let llvm_name =\n                                 &format!(\"llvm.fsh{}.i{}\", if is_left { 'l' } else { 'r' }, width);\n-                            let llfn = self.get_intrinsic(llvm_name);\n-                            self.call(llfn, &[val, val, raw_shift], None)\n+                            self.call_intrinsic(llvm_name, &[val, val, raw_shift])\n                         }\n                         sym::saturating_add | sym::saturating_sub => {\n                             let is_add = name == sym::saturating_add;\n@@ -279,8 +271,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                                 if is_add { \"add\" } else { \"sub\" },\n                                 width\n                             );\n-                            let llfn = self.get_intrinsic(llvm_name);\n-                            self.call(llfn, &[lhs, rhs], None)\n+                            self.call_intrinsic(llvm_name, &[lhs, rhs])\n                         }\n                         _ => bug!(),\n                     },\n@@ -331,8 +322,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                     let a_ptr = self.bitcast(a, i8p_ty);\n                     let b_ptr = self.bitcast(b, i8p_ty);\n                     let n = self.const_usize(layout.size.bytes());\n-                    let llfn = self.get_intrinsic(\"memcmp\");\n-                    let cmp = self.call(llfn, &[a_ptr, b_ptr, n], None);\n+                    let cmp = self.call_intrinsic(\"memcmp\", &[a_ptr, b_ptr, n]);\n                     self.icmp(IntPredicate::IntEQ, cmp, self.const_i32(0))\n                 }\n             }\n@@ -361,38 +351,32 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn abort(&mut self) {\n-        let fnname = self.get_intrinsic(&(\"llvm.trap\"));\n-        self.call(fnname, &[], None);\n+        self.call_intrinsic(\"llvm.trap\", &[]);\n     }\n \n     fn assume(&mut self, val: Self::Value) {\n-        let assume_intrinsic = self.get_intrinsic(\"llvm.assume\");\n-        self.call(assume_intrinsic, &[val], None);\n+        self.call_intrinsic(\"llvm.assume\", &[val]);\n     }\n \n     fn expect(&mut self, cond: Self::Value, expected: bool) -> Self::Value {\n-        let expect = self.get_intrinsic(&\"llvm.expect.i1\");\n-        self.call(expect, &[cond, self.const_bool(expected)], None)\n+        self.call_intrinsic(\"llvm.expect.i1\", &[cond, self.const_bool(expected)])\n     }\n \n     fn sideeffect(&mut self) {\n         // This kind of check would make a ton of sense in the caller, but currently the only\n         // caller of this function is in `rustc_codegen_ssa`, which is agnostic to whether LLVM\n         // codegen backend being used, and so is unable to check the LLVM version.\n         if unsafe { llvm::LLVMRustVersionMajor() } < 12 {\n-            let fnname = self.get_intrinsic(&(\"llvm.sideeffect\"));\n-            self.call(fnname, &[], None);\n+            self.call_intrinsic(\"llvm.sideeffect\", &[]);\n         }\n     }\n \n     fn va_start(&mut self, va_list: &'ll Value) -> &'ll Value {\n-        let intrinsic = self.cx().get_intrinsic(\"llvm.va_start\");\n-        self.call(intrinsic, &[va_list], None)\n+        self.call_intrinsic(\"llvm.va_start\", &[va_list])\n     }\n \n     fn va_end(&mut self, va_list: &'ll Value) -> &'ll Value {\n-        let intrinsic = self.cx().get_intrinsic(\"llvm.va_end\");\n-        self.call(intrinsic, &[va_list], None)\n+        self.call_intrinsic(\"llvm.va_end\", &[va_list])\n     }\n }\n \n@@ -404,7 +388,8 @@ fn try_intrinsic(\n     dest: &'ll Value,\n ) {\n     if bx.sess().panic_strategy() == PanicStrategy::Abort {\n-        bx.call(try_func, &[data], None);\n+        let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n+        bx.call(try_func_ty, try_func, &[data], None);\n         // Return 0 unconditionally from the intrinsic call;\n         // we can never unwind.\n         let ret_align = bx.tcx().data_layout.i32_align.abi;\n@@ -432,7 +417,7 @@ fn codegen_msvc_try(\n     catch_func: &'ll Value,\n     dest: &'ll Value,\n ) {\n-    let llfn = get_rust_try_fn(bx, &mut |mut bx| {\n+    let (llty, llfn) = get_rust_try_fn(bx, &mut |mut bx| {\n         bx.set_personality_fn(bx.eh_personality());\n \n         let mut normal = bx.build_sibling_block(\"normal\");\n@@ -502,7 +487,8 @@ fn codegen_msvc_try(\n         // More information can be found in libstd's seh.rs implementation.\n         let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n         let slot = bx.alloca(bx.type_i8p(), ptr_align);\n-        bx.invoke(try_func, &[data], normal.llbb(), catchswitch.llbb(), None);\n+        let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n+        bx.invoke(try_func_ty, try_func, &[data], normal.llbb(), catchswitch.llbb(), None);\n \n         normal.ret(bx.const_i32(0));\n \n@@ -544,22 +530,23 @@ fn codegen_msvc_try(\n         let flags = bx.const_i32(8);\n         let funclet = catchpad_rust.catch_pad(cs, &[tydesc, flags, slot]);\n         let ptr = catchpad_rust.load(bx.type_i8p(), slot, ptr_align);\n-        catchpad_rust.call(catch_func, &[data, ptr], Some(&funclet));\n+        let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n+        catchpad_rust.call(catch_ty, catch_func, &[data, ptr], Some(&funclet));\n         catchpad_rust.catch_ret(&funclet, caught.llbb());\n \n         // The flag value of 64 indicates a \"catch-all\".\n         let flags = bx.const_i32(64);\n         let null = bx.const_null(bx.type_i8p());\n         let funclet = catchpad_foreign.catch_pad(cs, &[null, flags, null]);\n-        catchpad_foreign.call(catch_func, &[data, null], Some(&funclet));\n+        catchpad_foreign.call(catch_ty, catch_func, &[data, null], Some(&funclet));\n         catchpad_foreign.catch_ret(&funclet, caught.llbb());\n \n         caught.ret(bx.const_i32(1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = bx.call(llfn, &[try_func, data, catch_func], None);\n+    let ret = bx.call(llty, llfn, &[try_func, data, catch_func], None);\n     let i32_align = bx.tcx().data_layout.i32_align.abi;\n     bx.store(ret, dest, i32_align);\n }\n@@ -582,7 +569,7 @@ fn codegen_gnu_try(\n     catch_func: &'ll Value,\n     dest: &'ll Value,\n ) {\n-    let llfn = get_rust_try_fn(bx, &mut |mut bx| {\n+    let (llty, llfn) = get_rust_try_fn(bx, &mut |mut bx| {\n         // Codegens the shims described above:\n         //\n         //   bx:\n@@ -601,7 +588,8 @@ fn codegen_gnu_try(\n         let try_func = llvm::get_param(bx.llfn(), 0);\n         let data = llvm::get_param(bx.llfn(), 1);\n         let catch_func = llvm::get_param(bx.llfn(), 2);\n-        bx.invoke(try_func, &[data], then.llbb(), catch.llbb(), None);\n+        let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n+        bx.invoke(try_func_ty, try_func, &[data], then.llbb(), catch.llbb(), None);\n         then.ret(bx.const_i32(0));\n \n         // Type indicator for the exception being thrown.\n@@ -615,13 +603,14 @@ fn codegen_gnu_try(\n         let tydesc = bx.const_null(bx.type_i8p());\n         catch.add_clause(vals, tydesc);\n         let ptr = catch.extract_value(vals, 0);\n-        catch.call(catch_func, &[data, ptr], None);\n+        let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n+        catch.call(catch_ty, catch_func, &[data, ptr], None);\n         catch.ret(bx.const_i32(1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = bx.call(llfn, &[try_func, data, catch_func], None);\n+    let ret = bx.call(llty, llfn, &[try_func, data, catch_func], None);\n     let i32_align = bx.tcx().data_layout.i32_align.abi;\n     bx.store(ret, dest, i32_align);\n }\n@@ -636,7 +625,7 @@ fn codegen_emcc_try(\n     catch_func: &'ll Value,\n     dest: &'ll Value,\n ) {\n-    let llfn = get_rust_try_fn(bx, &mut |mut bx| {\n+    let (llty, llfn) = get_rust_try_fn(bx, &mut |mut bx| {\n         // Codegens the shims described above:\n         //\n         //   bx:\n@@ -660,7 +649,8 @@ fn codegen_emcc_try(\n         let try_func = llvm::get_param(bx.llfn(), 0);\n         let data = llvm::get_param(bx.llfn(), 1);\n         let catch_func = llvm::get_param(bx.llfn(), 2);\n-        bx.invoke(try_func, &[data], then.llbb(), catch.llbb(), None);\n+        let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n+        bx.invoke(try_func_ty, try_func, &[data], then.llbb(), catch.llbb(), None);\n         then.ret(bx.const_i32(0));\n \n         // Type indicator for the exception being thrown.\n@@ -677,8 +667,7 @@ fn codegen_emcc_try(\n         let selector = catch.extract_value(vals, 1);\n \n         // Check if the typeid we got is the one for a Rust panic.\n-        let llvm_eh_typeid_for = bx.get_intrinsic(\"llvm.eh.typeid.for\");\n-        let rust_typeid = catch.call(llvm_eh_typeid_for, &[tydesc], None);\n+        let rust_typeid = catch.call_intrinsic(\"llvm.eh.typeid.for\", &[tydesc]);\n         let is_rust_panic = catch.icmp(IntPredicate::IntEQ, selector, rust_typeid);\n         let is_rust_panic = catch.zext(is_rust_panic, bx.type_bool());\n \n@@ -702,13 +691,14 @@ fn codegen_emcc_try(\n         catch.store(is_rust_panic, catch_data_1, i8_align);\n         let catch_data = catch.bitcast(catch_data, bx.type_i8p());\n \n-        catch.call(catch_func, &[data, catch_data], None);\n+        let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n+        catch.call(catch_ty, catch_func, &[data, catch_data], None);\n         catch.ret(bx.const_i32(1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = bx.call(llfn, &[try_func, data, catch_func], None);\n+    let ret = bx.call(llty, llfn, &[try_func, data, catch_func], None);\n     let i32_align = bx.tcx().data_layout.i32_align.abi;\n     bx.store(ret, dest, i32_align);\n }\n@@ -720,8 +710,9 @@ fn gen_fn<'ll, 'tcx>(\n     name: &str,\n     rust_fn_sig: ty::PolyFnSig<'tcx>,\n     codegen: &mut dyn FnMut(Builder<'_, 'll, 'tcx>),\n-) -> &'ll Value {\n+) -> (&'ll Type, &'ll Value) {\n     let fn_abi = FnAbi::of_fn_ptr(cx, rust_fn_sig, &[]);\n+    let llty = fn_abi.llvm_type(cx);\n     let llfn = cx.declare_fn(name, &fn_abi);\n     cx.set_frame_pointer_type(llfn);\n     cx.apply_target_cpu_attr(llfn);\n@@ -730,7 +721,7 @@ fn gen_fn<'ll, 'tcx>(\n     let llbb = Builder::append_block(cx, llfn, \"entry-block\");\n     let bx = Builder::build(cx, llbb);\n     codegen(bx);\n-    llfn\n+    (llty, llfn)\n }\n \n // Helper function used to get a handle to the `__rust_try` function used to\n@@ -740,7 +731,7 @@ fn gen_fn<'ll, 'tcx>(\n fn get_rust_try_fn<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     codegen: &mut dyn FnMut(Builder<'_, 'll, 'tcx>),\n-) -> &'ll Value {\n+) -> (&'ll Type, &'ll Value) {\n     if let Some(llfn) = cx.rust_try_fn.get() {\n         return llfn;\n     }\n@@ -1123,7 +1114,8 @@ fn generic_simd_intrinsic(\n         };\n         let llvm_name = &format!(\"llvm.{0}.v{1}{2}\", intr_name, in_len, elem_ty_str);\n         let f = bx.declare_cfn(&llvm_name, llvm::UnnamedAddr::No, fn_ty);\n-        let c = bx.call(f, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None);\n+        let c =\n+            bx.call(fn_ty, f, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None);\n         Ok(c)\n     }\n \n@@ -1300,15 +1292,13 @@ fn generic_simd_intrinsic(\n \n         let llvm_intrinsic =\n             format!(\"llvm.masked.gather.{}.{}\", llvm_elem_vec_str, llvm_pointer_vec_str);\n-        let f = bx.declare_cfn(\n-            &llvm_intrinsic,\n-            llvm::UnnamedAddr::No,\n-            bx.type_func(\n-                &[llvm_pointer_vec_ty, alignment_ty, mask_ty, llvm_elem_vec_ty],\n-                llvm_elem_vec_ty,\n-            ),\n+        let fn_ty = bx.type_func(\n+            &[llvm_pointer_vec_ty, alignment_ty, mask_ty, llvm_elem_vec_ty],\n+            llvm_elem_vec_ty,\n         );\n-        let v = bx.call(f, &[args[1].immediate(), alignment, mask, args[0].immediate()], None);\n+        let f = bx.declare_cfn(&llvm_intrinsic, llvm::UnnamedAddr::No, fn_ty);\n+        let v =\n+            bx.call(fn_ty, f, &[args[1].immediate(), alignment, mask, args[0].immediate()], None);\n         return Ok(v);\n     }\n \n@@ -1430,12 +1420,11 @@ fn generic_simd_intrinsic(\n \n         let llvm_intrinsic =\n             format!(\"llvm.masked.scatter.{}.{}\", llvm_elem_vec_str, llvm_pointer_vec_str);\n-        let f = bx.declare_cfn(\n-            &llvm_intrinsic,\n-            llvm::UnnamedAddr::No,\n-            bx.type_func(&[llvm_elem_vec_ty, llvm_pointer_vec_ty, alignment_ty, mask_ty], ret_t),\n-        );\n-        let v = bx.call(f, &[args[0].immediate(), args[1].immediate(), alignment, mask], None);\n+        let fn_ty =\n+            bx.type_func(&[llvm_elem_vec_ty, llvm_pointer_vec_ty, alignment_ty, mask_ty], ret_t);\n+        let f = bx.declare_cfn(&llvm_intrinsic, llvm::UnnamedAddr::No, fn_ty);\n+        let v =\n+            bx.call(fn_ty, f, &[args[0].immediate(), args[1].immediate(), alignment, mask], None);\n         return Ok(v);\n     }\n \n@@ -1757,12 +1746,9 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n         );\n         let vec_ty = bx.cx.type_vector(elem_ty, in_len as u64);\n \n-        let f = bx.declare_cfn(\n-            &llvm_intrinsic,\n-            llvm::UnnamedAddr::No,\n-            bx.type_func(&[vec_ty, vec_ty], vec_ty),\n-        );\n-        let v = bx.call(f, &[lhs, rhs], None);\n+        let fn_ty = bx.type_func(&[vec_ty, vec_ty], vec_ty);\n+        let f = bx.declare_cfn(&llvm_intrinsic, llvm::UnnamedAddr::No, fn_ty);\n+        let v = bx.call(fn_ty, f, &[lhs, rhs], None);\n         return Ok(v);\n     }\n "}, {"sha": "57173a49107a53f3cd8d58522daac043f72c92ef", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -1155,6 +1155,7 @@ extern \"C\" {\n     ) -> &'a Value;\n     pub fn LLVMRustBuildInvoke(\n         B: &Builder<'a>,\n+        Ty: &'a Type,\n         Fn: &'a Value,\n         Args: *const &'a Value,\n         NumArgs: c_uint,\n@@ -1526,6 +1527,7 @@ extern \"C\" {\n     pub fn LLVMRustGetInstrProfIncrementIntrinsic(M: &Module) -> &'a Value;\n     pub fn LLVMRustBuildCall(\n         B: &Builder<'a>,\n+        Ty: &'a Type,\n         Fn: &'a Value,\n         Args: *const &'a Value,\n         NumArgs: c_uint,"}, {"sha": "52ae56b89b33170c671cd82cf5122b126a0bd839", "filename": "compiler/rustc_codegen_llvm/src/type_.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -203,7 +203,11 @@ impl BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     }\n \n     fn element_type(&self, ty: &'ll Type) -> &'ll Type {\n-        unsafe { llvm::LLVMGetElementType(ty) }\n+        match self.type_kind(ty) {\n+            TypeKind::Array | TypeKind::Vector => unsafe { llvm::LLVMGetElementType(ty) },\n+            TypeKind::Pointer => bug!(\"element_type is not supported for opaque pointers\"),\n+            other => bug!(\"element_type called on unsupported type {:?}\", other),\n+        }\n     }\n \n     fn vector_length(&self, ty: &'ll Type) -> usize {\n@@ -275,6 +279,9 @@ impl LayoutTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn cast_backend_type(&self, ty: &CastTarget) -> &'ll Type {\n         ty.llvm_type(self)\n     }\n+    fn fn_decl_backend_type(&self, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> &'ll Type {\n+        fn_abi.llvm_type(self)\n+    }\n     fn fn_ptr_backend_type(&self, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> &'ll Type {\n         fn_abi.ptr_to_llvm_type(self)\n     }"}, {"sha": "064a51c8f609086e00e4d4721e246c3a75737a73", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -441,9 +441,11 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n         bx.insert_reference_to_gdb_debug_scripts_section_global();\n \n+        let isize_ty = cx.type_isize();\n+        let i8pp_ty = cx.type_ptr_to(cx.type_i8p());\n         let (arg_argc, arg_argv) = get_argc_argv(cx, &mut bx);\n \n-        let (start_fn, args) = if use_start_lang_item {\n+        let (start_fn, start_ty, args) = if use_start_lang_item {\n             let start_def_id = cx.tcx().require_lang_item(LangItem::Start, None);\n             let start_fn = cx.get_fn_addr(\n                 ty::Instance::resolve(\n@@ -455,16 +457,15 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 .unwrap()\n                 .unwrap(),\n             );\n-            (\n-                start_fn,\n-                vec![bx.pointercast(rust_main, cx.type_ptr_to(cx.type_i8p())), arg_argc, arg_argv],\n-            )\n+            let start_ty = cx.type_func(&[cx.val_ty(rust_main), isize_ty, i8pp_ty], isize_ty);\n+            (start_fn, start_ty, vec![rust_main, arg_argc, arg_argv])\n         } else {\n             debug!(\"using user-defined start fn\");\n-            (rust_main, vec![arg_argc, arg_argv])\n+            let start_ty = cx.type_func(&[isize_ty, i8pp_ty], isize_ty);\n+            (rust_main, start_ty, vec![arg_argc, arg_argv])\n         };\n \n-        let result = bx.call(start_fn, &args, None);\n+        let result = bx.call(start_ty, start_fn, &args, None);\n         let cast = bx.intcast(result, cx.type_int(), true);\n         bx.ret(cast);\n "}, {"sha": "58ce31e0c4c9d48747a0a9e0d032862e133f87da", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -132,14 +132,21 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n     ) {\n         // If there is a cleanup block and the function we're calling can unwind, then\n         // do an invoke, otherwise do a call.\n+        let fn_ty = bx.fn_decl_backend_type(&fn_abi);\n         if let Some(cleanup) = cleanup.filter(|_| fn_abi.can_unwind) {\n             let ret_llbb = if let Some((_, target)) = destination {\n                 fx.llbb(target)\n             } else {\n                 fx.unreachable_block()\n             };\n-            let invokeret =\n-                bx.invoke(fn_ptr, &llargs, ret_llbb, self.llblock(fx, cleanup), self.funclet(fx));\n+            let invokeret = bx.invoke(\n+                fn_ty,\n+                fn_ptr,\n+                &llargs,\n+                ret_llbb,\n+                self.llblock(fx, cleanup),\n+                self.funclet(fx),\n+            );\n             bx.apply_attrs_callsite(&fn_abi, invokeret);\n \n             if let Some((ret_dest, target)) = destination {\n@@ -148,7 +155,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n                 fx.store_return(&mut ret_bx, ret_dest, &fn_abi.ret, invokeret);\n             }\n         } else {\n-            let llret = bx.call(fn_ptr, &llargs, self.funclet(fx));\n+            let llret = bx.call(fn_ty, fn_ptr, &llargs, self.funclet(fx));\n             bx.apply_attrs_callsite(&fn_abi, llret);\n             if fx.mir[self.bb].is_cleanup {\n                 // Cleanup is always the cold path. Don't inline"}, {"sha": "7e432d274022453b7726a5c48df9c1256244f87f", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -518,7 +518,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 };\n                 let instance = ty::Instance::mono(bx.tcx(), def_id);\n                 let r = bx.cx().get_fn_addr(instance);\n-                let call = bx.call(r, &[llsize, llalign], None);\n+                let ty = bx.type_func(&[bx.type_isize(), bx.type_isize()], bx.type_i8p());\n+                let call = bx.call(ty, r, &[llsize, llalign], None);\n                 let val = bx.pointercast(call, llty_ptr);\n \n                 let operand = OperandRef { val: OperandValue::Immediate(val), layout: box_layout };"}, {"sha": "afb8ee3c40d5569169327fe602c1d2bcc54c5093", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -72,6 +72,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n     );\n     fn invoke(\n         &mut self,\n+        llty: Self::Type,\n         llfn: Self::Value,\n         args: &[Self::Value],\n         then: Self::BasicBlock,\n@@ -303,6 +304,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n \n     fn call(\n         &mut self,\n+        llty: Self::Type,\n         llfn: Self::Value,\n         args: &[Self::Value],\n         funclet: Option<&Self::Funclet>,"}, {"sha": "b94fb1e10db0198386750c06b657ae5e52a940a8", "filename": "compiler/rustc_codegen_ssa/src/traits/type_.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -102,6 +102,7 @@ impl<T> DerivedTypeMethods<'tcx> for T where Self: BaseTypeMethods<'tcx> + MiscM\n pub trait LayoutTypeMethods<'tcx>: Backend<'tcx> {\n     fn backend_type(&self, layout: TyAndLayout<'tcx>) -> Self::Type;\n     fn cast_backend_type(&self, ty: &CastTarget) -> Self::Type;\n+    fn fn_decl_backend_type(&self, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> Self::Type;\n     fn fn_ptr_backend_type(&self, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> Self::Type;\n     fn reg_backend_type(&self, ty: &Reg) -> Self::Type;\n     fn immediate_backend_type(&self, layout: TyAndLayout<'tcx>) -> Self::Type;"}, {"sha": "1998386603f12df543a4541f73f1f9ffae43d337", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -2689,6 +2689,38 @@ declare_lint! {\n     \"detects deprecation attributes with no effect\",\n }\n \n+declare_lint! {\n+    /// The `undefined_naked_function_abi` lint detects naked function definitions that\n+    /// either do not specify an ABI or specify the Rust ABI.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// #![feature(naked_functions)]\n+    /// #![feature(asm)]\n+    ///\n+    /// #[naked]\n+    /// pub fn default_abi() -> u32 {\n+    ///     unsafe { asm!(\"\", options(noreturn)); }\n+    /// }\n+    ///\n+    /// #[naked]\n+    /// pub extern \"Rust\" fn rust_abi() -> u32 {\n+    ///     unsafe { asm!(\"\", options(noreturn)); }\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The Rust ABI is currently undefined. Therefore, naked functions should\n+    /// specify a non-Rust ABI.\n+    pub UNDEFINED_NAKED_FUNCTION_ABI,\n+    Warn,\n+    \"undefined naked function ABI\"\n+}\n+\n declare_lint! {\n     /// The `unsupported_naked_functions` lint detects naked function\n     /// definitions that are unsupported but were previously accepted.\n@@ -2699,7 +2731,7 @@ declare_lint! {\n     /// #![feature(naked_functions)]\n     ///\n     /// #[naked]\n-    /// pub fn f() -> u32 {\n+    /// pub extern \"C\" fn f() -> u32 {\n     ///     42\n     /// }\n     /// ```"}, {"sha": "52566b19eca045298e5987abaff628ea470156af", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -1392,11 +1392,11 @@ extern \"C\" void LLVMRustFreeOperandBundleDef(OperandBundleDef *Bundle) {\n   delete Bundle;\n }\n \n-extern \"C\" LLVMValueRef LLVMRustBuildCall(LLVMBuilderRef B, LLVMValueRef Fn,\n+extern \"C\" LLVMValueRef LLVMRustBuildCall(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Fn,\n                                           LLVMValueRef *Args, unsigned NumArgs,\n                                           OperandBundleDef *Bundle) {\n   Value *Callee = unwrap(Fn);\n-  FunctionType *FTy = cast<FunctionType>(Callee->getType()->getPointerElementType());\n+  FunctionType *FTy = unwrap<FunctionType>(Ty);\n   unsigned Len = Bundle ? 1 : 0;\n   ArrayRef<OperandBundleDef> Bundles = makeArrayRef(Bundle, Len);\n   return wrap(unwrap(B)->CreateCall(\n@@ -1437,12 +1437,12 @@ extern \"C\" LLVMValueRef LLVMRustBuildMemSet(LLVMBuilderRef B,\n }\n \n extern \"C\" LLVMValueRef\n-LLVMRustBuildInvoke(LLVMBuilderRef B, LLVMValueRef Fn, LLVMValueRef *Args,\n-                    unsigned NumArgs, LLVMBasicBlockRef Then,\n-                    LLVMBasicBlockRef Catch, OperandBundleDef *Bundle,\n-                    const char *Name) {\n+LLVMRustBuildInvoke(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Fn,\n+                    LLVMValueRef *Args, unsigned NumArgs,\n+                    LLVMBasicBlockRef Then, LLVMBasicBlockRef Catch,\n+                    OperandBundleDef *Bundle, const char *Name) {\n   Value *Callee = unwrap(Fn);\n-  FunctionType *FTy = cast<FunctionType>(Callee->getType()->getPointerElementType());\n+  FunctionType *FTy = unwrap<FunctionType>(Ty);\n   unsigned Len = Bundle ? 1 : 0;\n   ArrayRef<OperandBundleDef> Bundles = makeArrayRef(Bundle, Len);\n   return wrap(unwrap(B)->CreateInvoke(FTy, Callee, unwrap(Then), unwrap(Catch),"}, {"sha": "f91067526b13f28293cfdf94ad9566e9d8bd58d6", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -51,6 +51,7 @@\n #![feature(iter_zip)]\n #![feature(thread_local_const_init)]\n #![feature(try_reserve)]\n+#![feature(try_reserve_kind)]\n #![feature(nonzero_ops)]\n #![recursion_limit = \"512\"]\n "}, {"sha": "00fb4902c61f759085f65b26eaa0348a062ae76c", "filename": "compiler/rustc_mir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Flib.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -30,6 +30,7 @@ Rust MIR: a lowered representation of Rust.\n #![feature(once_cell)]\n #![feature(control_flow_enum)]\n #![feature(try_reserve)]\n+#![feature(try_reserve_kind)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "899503cc556e5920e135d171966b32256129a348", "filename": "compiler/rustc_passes/src/naked_functions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -7,6 +7,7 @@ use rustc_hir::intravisit::{ErasedMap, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::{ExprKind, HirId, InlineAsmOperand, StmtKind};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n+use rustc_session::lint::builtin::UNDEFINED_NAKED_FUNCTION_ABI;\n use rustc_session::lint::builtin::UNSUPPORTED_NAKED_FUNCTIONS;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n@@ -87,7 +88,7 @@ fn check_inline(tcx: TyCtxt<'_>, hir_id: HirId, attrs: &[Attribute]) {\n /// Checks that function uses non-Rust ABI.\n fn check_abi(tcx: TyCtxt<'_>, hir_id: HirId, abi: Abi, fn_ident_span: Span) {\n     if abi == Abi::Rust {\n-        tcx.struct_span_lint_hir(UNSUPPORTED_NAKED_FUNCTIONS, hir_id, fn_ident_span, |lint| {\n+        tcx.struct_span_lint_hir(UNDEFINED_NAKED_FUNCTION_ABI, hir_id, fn_ident_span, |lint| {\n             lint.build(\"Rust ABI is unsupported in naked functions\").emit();\n         });\n     }"}, {"sha": "3ee857f3399e09f931e342a03528244ae48d6941", "filename": "library/alloc/src/collections/mod.rs", "status": "modified", "additions": 43, "deletions": 6, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/library%2Falloc%2Fsrc%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/library%2Falloc%2Fsrc%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fmod.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -58,7 +58,31 @@ use core::fmt::Display;\n /// The error type for `try_reserve` methods.\n #[derive(Clone, PartialEq, Eq, Debug)]\n #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n-pub enum TryReserveError {\n+pub struct TryReserveError {\n+    kind: TryReserveErrorKind,\n+}\n+\n+impl TryReserveError {\n+    /// Details about the allocation that caused the error\n+    #[inline]\n+    #[unstable(\n+        feature = \"try_reserve_kind\",\n+        reason = \"Uncertain how much info should be exposed\",\n+        issue = \"48043\"\n+    )]\n+    pub fn kind(&self) -> TryReserveErrorKind {\n+        self.kind.clone()\n+    }\n+}\n+\n+/// Details of the allocation that caused a `TryReserveError`\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+#[unstable(\n+    feature = \"try_reserve_kind\",\n+    reason = \"Uncertain how much info should be exposed\",\n+    issue = \"48043\"\n+)]\n+pub enum TryReserveErrorKind {\n     /// Error due to the computed capacity exceeding the collection's maximum\n     /// (usually `isize::MAX` bytes).\n     CapacityOverflow,\n@@ -81,12 +105,23 @@ pub enum TryReserveError {\n     },\n }\n \n+#[unstable(\n+    feature = \"try_reserve_kind\",\n+    reason = \"Uncertain how much info should be exposed\",\n+    issue = \"48043\"\n+)]\n+impl From<TryReserveErrorKind> for TryReserveError {\n+    fn from(kind: TryReserveErrorKind) -> Self {\n+        Self { kind }\n+    }\n+}\n+\n #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n impl From<LayoutError> for TryReserveError {\n-    /// Always evaluates to [`TryReserveError::CapacityOverflow`].\n+    /// Always evaluates to [`TryReserveErrorKind::CapacityOverflow`].\n     #[inline]\n     fn from(_: LayoutError) -> Self {\n-        TryReserveError::CapacityOverflow\n+        TryReserveErrorKind::CapacityOverflow.into()\n     }\n }\n \n@@ -97,11 +132,13 @@ impl Display for TryReserveError {\n         fmt: &mut core::fmt::Formatter<'_>,\n     ) -> core::result::Result<(), core::fmt::Error> {\n         fmt.write_str(\"memory allocation failed\")?;\n-        let reason = match &self {\n-            TryReserveError::CapacityOverflow => {\n+        let reason = match self.kind {\n+            TryReserveErrorKind::CapacityOverflow => {\n                 \" because the computed capacity exceeded the collection's maximum\"\n             }\n-            TryReserveError::AllocError { .. } => \" because the memory allocator returned a error\",\n+            TryReserveErrorKind::AllocError { .. } => {\n+                \" because the memory allocator returned a error\"\n+            }\n         };\n         fmt.write_str(reason)\n     }"}, {"sha": "bea5cf11be5e8da7ae83dfb45a92ed109d63f865", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -19,6 +19,7 @@ use core::slice;\n \n use crate::alloc::{Allocator, Global};\n use crate::collections::TryReserveError;\n+use crate::collections::TryReserveErrorKind;\n use crate::raw_vec::RawVec;\n use crate::vec::Vec;\n \n@@ -773,7 +774,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         let new_cap = used_cap\n             .checked_add(additional)\n             .and_then(|needed_cap| needed_cap.checked_next_power_of_two())\n-            .ok_or(TryReserveError::CapacityOverflow)?;\n+            .ok_or(TryReserveErrorKind::CapacityOverflow)?;\n \n         if new_cap > old_cap {\n             self.buf.try_reserve_exact(used_cap, new_cap - used_cap)?;"}, {"sha": "3caada06f6b58d33128685ea8fb0ca32184c3b4f", "filename": "library/alloc/src/raw_vec.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/library%2Falloc%2Fsrc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/library%2Falloc%2Fsrc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -13,7 +13,8 @@ use core::slice;\n use crate::alloc::handle_alloc_error;\n use crate::alloc::{Allocator, Global, Layout};\n use crate::boxed::Box;\n-use crate::collections::TryReserveError::{self, *};\n+use crate::collections::TryReserveError;\n+use crate::collections::TryReserveErrorKind::*;\n \n #[cfg(test)]\n mod tests;\n@@ -425,7 +426,7 @@ impl<T, A: Allocator> RawVec<T, A> {\n         if mem::size_of::<T>() == 0 {\n             // Since we return a capacity of `usize::MAX` when `elem_size` is\n             // 0, getting to here necessarily means the `RawVec` is overfull.\n-            return Err(CapacityOverflow);\n+            return Err(CapacityOverflow.into());\n         }\n \n         // Nothing we can really do about these checks, sadly.\n@@ -451,7 +452,7 @@ impl<T, A: Allocator> RawVec<T, A> {\n         if mem::size_of::<T>() == 0 {\n             // Since we return a capacity of `usize::MAX` when the type size is\n             // 0, getting to here necessarily means the `RawVec` is overfull.\n-            return Err(CapacityOverflow);\n+            return Err(CapacityOverflow.into());\n         }\n \n         let cap = len.checked_add(additional).ok_or(CapacityOverflow)?;\n@@ -471,10 +472,9 @@ impl<T, A: Allocator> RawVec<T, A> {\n \n         let ptr = unsafe {\n             let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n-            self.alloc.shrink(ptr, layout, new_layout).map_err(|_| TryReserveError::AllocError {\n-                layout: new_layout,\n-                non_exhaustive: (),\n-            })?\n+            self.alloc\n+                .shrink(ptr, layout, new_layout)\n+                .map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })?\n         };\n         self.set_ptr(ptr);\n         Ok(())\n@@ -510,7 +510,7 @@ where\n         alloc.allocate(new_layout)\n     };\n \n-    memory.map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })\n+    memory.map_err(|_| AllocError { layout: new_layout, non_exhaustive: () }.into())\n }\n \n unsafe impl<#[may_dangle] T, A: Allocator> Drop for RawVec<T, A> {\n@@ -526,7 +526,7 @@ unsafe impl<#[may_dangle] T, A: Allocator> Drop for RawVec<T, A> {\n #[cfg(not(no_global_oom_handling))]\n #[inline]\n fn handle_reserve(result: Result<(), TryReserveError>) {\n-    match result {\n+    match result.map_err(|e| e.kind()) {\n         Err(CapacityOverflow) => capacity_overflow(),\n         Err(AllocError { layout, .. }) => handle_alloc_error(layout),\n         Ok(()) => { /* yay */ }\n@@ -545,7 +545,7 @@ fn handle_reserve(result: Result<(), TryReserveError>) {\n #[inline]\n fn alloc_guard(alloc_size: usize) -> Result<(), TryReserveError> {\n     if usize::BITS < 64 && alloc_size > isize::MAX as usize {\n-        Err(CapacityOverflow)\n+        Err(CapacityOverflow.into())\n     } else {\n         Ok(())\n     }"}, {"sha": "b3e048a6587b9aa020ccf3e04ec354bcfa0940ce", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -8,6 +8,7 @@\n #![feature(pattern)]\n #![feature(trusted_len)]\n #![feature(try_reserve)]\n+#![feature(try_reserve_kind)]\n #![feature(unboxed_closures)]\n #![feature(associated_type_bounds)]\n #![feature(binary_heap_into_iter_sorted)]"}, {"sha": "cf9d734a9d54ddee3f1d7d1ec0e0ef1f1cae7da0", "filename": "library/alloc/tests/string.rs", "status": "modified", "additions": 51, "deletions": 23, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/library%2Falloc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/library%2Falloc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fstring.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -1,6 +1,6 @@\n use std::borrow::Cow;\n use std::cell::Cell;\n-use std::collections::TryReserveError::*;\n+use std::collections::TryReserveErrorKind::*;\n use std::ops::Bound;\n use std::ops::Bound::*;\n use std::ops::RangeBounds;\n@@ -703,35 +703,42 @@ fn test_try_reserve() {\n         let mut empty_string: String = String::new();\n \n         // Check isize::MAX doesn't count as an overflow\n-        if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_CAP) {\n+        if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_CAP).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         // Play it again, frank! (just to be sure)\n-        if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_CAP) {\n+        if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_CAP).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n \n         if guards_against_isize {\n             // Check isize::MAX + 1 does count as overflow\n-            if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_CAP + 1) {\n+            if let Err(CapacityOverflow) =\n+                empty_string.try_reserve(MAX_CAP + 1).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\")\n             }\n \n             // Check usize::MAX does count as overflow\n-            if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_USIZE) {\n+            if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_USIZE).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"usize::MAX should trigger an overflow!\")\n             }\n         } else {\n             // Check isize::MAX + 1 is an OOM\n-            if let Err(AllocError { .. }) = empty_string.try_reserve(MAX_CAP + 1) {\n+            if let Err(AllocError { .. }) =\n+                empty_string.try_reserve(MAX_CAP + 1).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n \n             // Check usize::MAX is an OOM\n-            if let Err(AllocError { .. }) = empty_string.try_reserve(MAX_USIZE) {\n+            if let Err(AllocError { .. }) =\n+                empty_string.try_reserve(MAX_USIZE).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"usize::MAX should trigger an OOM!\")\n             }\n@@ -742,25 +749,27 @@ fn test_try_reserve() {\n         // Same basic idea, but with non-zero len\n         let mut ten_bytes: String = String::from(\"0123456789\");\n \n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\");\n             }\n         } else {\n-            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n         }\n         // Should always overflow in the add-to-len\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE) {\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()) {\n         } else {\n             panic!(\"usize::MAX should trigger an overflow!\")\n         }\n@@ -782,30 +791,40 @@ fn test_try_reserve_exact() {\n     {\n         let mut empty_string: String = String::new();\n \n-        if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_CAP) {\n+        if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_CAP).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_CAP) {\n+        if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_CAP).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n \n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_CAP + 1) {\n+            if let Err(CapacityOverflow) =\n+                empty_string.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\")\n             }\n \n-            if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_USIZE) {\n+            if let Err(CapacityOverflow) =\n+                empty_string.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"usize::MAX should trigger an overflow!\")\n             }\n         } else {\n-            if let Err(AllocError { .. }) = empty_string.try_reserve_exact(MAX_CAP + 1) {\n+            if let Err(AllocError { .. }) =\n+                empty_string.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n \n-            if let Err(AllocError { .. }) = empty_string.try_reserve_exact(MAX_USIZE) {\n+            if let Err(AllocError { .. }) =\n+                empty_string.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"usize::MAX should trigger an OOM!\")\n             }\n@@ -815,24 +834,33 @@ fn test_try_reserve_exact() {\n     {\n         let mut ten_bytes: String = String::from(\"0123456789\");\n \n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+        if let Err(CapacityOverflow) =\n+            ten_bytes.try_reserve_exact(MAX_CAP - 10).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+        if let Err(CapacityOverflow) =\n+            ten_bytes.try_reserve_exact(MAX_CAP - 10).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(CapacityOverflow) =\n+                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\");\n             }\n         } else {\n-            if let Err(AllocError { .. }) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) =\n+                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n         }\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n+        {\n         } else {\n             panic!(\"usize::MAX should trigger an overflow!\")\n         }"}, {"sha": "d3a6dcfddc5270f8bdea31709c7dd6d1e6b5a233", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 76, "deletions": 33, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -1,6 +1,6 @@\n use std::borrow::Cow;\n use std::cell::Cell;\n-use std::collections::TryReserveError::*;\n+use std::collections::TryReserveErrorKind::*;\n use std::fmt::Debug;\n use std::iter::InPlaceIterable;\n use std::mem::{size_of, swap};\n@@ -1478,35 +1478,41 @@ fn test_try_reserve() {\n         let mut empty_bytes: Vec<u8> = Vec::new();\n \n         // Check isize::MAX doesn't count as an overflow\n-        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP) {\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         // Play it again, frank! (just to be sure)\n-        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP) {\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n \n         if guards_against_isize {\n             // Check isize::MAX + 1 does count as overflow\n-            if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP + 1) {\n+            if let Err(CapacityOverflow) =\n+                empty_bytes.try_reserve(MAX_CAP + 1).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\")\n             }\n \n             // Check usize::MAX does count as overflow\n-            if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE) {\n+            if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"usize::MAX should trigger an overflow!\")\n             }\n         } else {\n             // Check isize::MAX + 1 is an OOM\n-            if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_CAP + 1) {\n+            if let Err(AllocError { .. }) =\n+                empty_bytes.try_reserve(MAX_CAP + 1).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n \n             // Check usize::MAX is an OOM\n-            if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_USIZE) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"usize::MAX should trigger an OOM!\")\n             }\n@@ -1517,25 +1523,27 @@ fn test_try_reserve() {\n         // Same basic idea, but with non-zero len\n         let mut ten_bytes: Vec<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n \n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\");\n             }\n         } else {\n-            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n         }\n         // Should always overflow in the add-to-len\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE) {\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()) {\n         } else {\n             panic!(\"usize::MAX should trigger an overflow!\")\n         }\n@@ -1545,25 +1553,31 @@ fn test_try_reserve() {\n         // Same basic idea, but with interesting type size\n         let mut ten_u32s: Vec<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n \n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 10) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 10).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 10) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 10).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 9) {\n+            if let Err(CapacityOverflow) =\n+                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\");\n             }\n         } else {\n-            if let Err(AllocError { .. }) = ten_u32s.try_reserve(MAX_CAP / 4 - 9) {\n+            if let Err(AllocError { .. }) =\n+                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n         }\n         // Should fail in the mul-by-size\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_USIZE - 20) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_USIZE - 20).map_err(|e| e.kind()) {\n         } else {\n             panic!(\"usize::MAX should trigger an overflow!\");\n         }\n@@ -1585,30 +1599,40 @@ fn test_try_reserve_exact() {\n     {\n         let mut empty_bytes: Vec<u8> = Vec::new();\n \n-        if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n \n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n+            if let Err(CapacityOverflow) =\n+                empty_bytes.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\")\n             }\n \n-            if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n+            if let Err(CapacityOverflow) =\n+                empty_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"usize::MAX should trigger an overflow!\")\n             }\n         } else {\n-            if let Err(AllocError { .. }) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n+            if let Err(AllocError { .. }) =\n+                empty_bytes.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n \n-            if let Err(AllocError { .. }) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n+            if let Err(AllocError { .. }) =\n+                empty_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"usize::MAX should trigger an OOM!\")\n             }\n@@ -1618,24 +1642,33 @@ fn test_try_reserve_exact() {\n     {\n         let mut ten_bytes: Vec<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n \n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+        if let Err(CapacityOverflow) =\n+            ten_bytes.try_reserve_exact(MAX_CAP - 10).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+        if let Err(CapacityOverflow) =\n+            ten_bytes.try_reserve_exact(MAX_CAP - 10).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(CapacityOverflow) =\n+                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\");\n             }\n         } else {\n-            if let Err(AllocError { .. }) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) =\n+                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n         }\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n+        {\n         } else {\n             panic!(\"usize::MAX should trigger an overflow!\")\n         }\n@@ -1644,24 +1677,34 @@ fn test_try_reserve_exact() {\n     {\n         let mut ten_u32s: Vec<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n \n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 10) {\n+        if let Err(CapacityOverflow) =\n+            ten_u32s.try_reserve_exact(MAX_CAP / 4 - 10).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 10) {\n+        if let Err(CapacityOverflow) =\n+            ten_u32s.try_reserve_exact(MAX_CAP / 4 - 10).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9) {\n+            if let Err(CapacityOverflow) =\n+                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\");\n             }\n         } else {\n-            if let Err(AllocError { .. }) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9) {\n+            if let Err(AllocError { .. }) =\n+                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n         }\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_USIZE - 20) {\n+        if let Err(CapacityOverflow) =\n+            ten_u32s.try_reserve_exact(MAX_USIZE - 20).map_err(|e| e.kind())\n+        {\n         } else {\n             panic!(\"usize::MAX should trigger an overflow!\")\n         }"}, {"sha": "e9fd19d76ea43f293df52f574b58fb54bde41472", "filename": "library/alloc/tests/vec_deque.rs", "status": "modified", "additions": 69, "deletions": 31, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/library%2Falloc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/library%2Falloc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec_deque.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -1,4 +1,4 @@\n-use std::collections::TryReserveError::*;\n+use std::collections::TryReserveErrorKind::*;\n use std::collections::{vec_deque::Drain, VecDeque};\n use std::fmt::Debug;\n use std::mem::size_of;\n@@ -1171,23 +1171,26 @@ fn test_try_reserve() {\n         let mut empty_bytes: VecDeque<u8> = VecDeque::new();\n \n         // Check isize::MAX doesn't count as an overflow\n-        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP) {\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         // Play it again, frank! (just to be sure)\n-        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP) {\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n \n         if guards_against_isize {\n             // Check isize::MAX + 1 does count as overflow\n-            if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP + 1) {\n+            if let Err(CapacityOverflow) =\n+                empty_bytes.try_reserve(MAX_CAP + 1).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\")\n             }\n \n             // Check usize::MAX does count as overflow\n-            if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE) {\n+            if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"usize::MAX should trigger an overflow!\")\n             }\n@@ -1196,7 +1199,7 @@ fn test_try_reserve() {\n             // VecDeque starts with capacity 7, always adds 1 to the capacity\n             // and also rounds the number to next power of 2 so this is the\n             // furthest we can go without triggering CapacityOverflow\n-            if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_CAP) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_CAP).map_err(|e| e.kind()) {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n@@ -1207,25 +1210,27 @@ fn test_try_reserve() {\n         // Same basic idea, but with non-zero len\n         let mut ten_bytes: VecDeque<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n \n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10).map_err(|e| e.kind()) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\");\n             }\n         } else {\n-            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n         }\n         // Should always overflow in the add-to-len\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE) {\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()) {\n         } else {\n             panic!(\"usize::MAX should trigger an overflow!\")\n         }\n@@ -1235,25 +1240,31 @@ fn test_try_reserve() {\n         // Same basic idea, but with interesting type size\n         let mut ten_u32s: VecDeque<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n \n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 10) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 10).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 10) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 10).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 9) {\n+            if let Err(CapacityOverflow) =\n+                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\");\n             }\n         } else {\n-            if let Err(AllocError { .. }) = ten_u32s.try_reserve(MAX_CAP / 4 - 9) {\n+            if let Err(AllocError { .. }) =\n+                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n         }\n         // Should fail in the mul-by-size\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_USIZE - 20) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_USIZE - 20).map_err(|e| e.kind()) {\n         } else {\n             panic!(\"usize::MAX should trigger an overflow!\");\n         }\n@@ -1275,20 +1286,26 @@ fn test_try_reserve_exact() {\n     {\n         let mut empty_bytes: VecDeque<u8> = VecDeque::new();\n \n-        if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n \n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n+            if let Err(CapacityOverflow) =\n+                empty_bytes.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\")\n             }\n \n-            if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n+            if let Err(CapacityOverflow) =\n+                empty_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"usize::MAX should trigger an overflow!\")\n             }\n@@ -1297,7 +1314,9 @@ fn test_try_reserve_exact() {\n             // VecDeque starts with capacity 7, always adds 1 to the capacity\n             // and also rounds the number to next power of 2 so this is the\n             // furthest we can go without triggering CapacityOverflow\n-            if let Err(AllocError { .. }) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+            if let Err(AllocError { .. }) =\n+                empty_bytes.try_reserve_exact(MAX_CAP).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n@@ -1307,24 +1326,33 @@ fn test_try_reserve_exact() {\n     {\n         let mut ten_bytes: VecDeque<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n \n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+        if let Err(CapacityOverflow) =\n+            ten_bytes.try_reserve_exact(MAX_CAP - 10).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+        if let Err(CapacityOverflow) =\n+            ten_bytes.try_reserve_exact(MAX_CAP - 10).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(CapacityOverflow) =\n+                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\");\n             }\n         } else {\n-            if let Err(AllocError { .. }) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) =\n+                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n         }\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n+        {\n         } else {\n             panic!(\"usize::MAX should trigger an overflow!\")\n         }\n@@ -1333,24 +1361,34 @@ fn test_try_reserve_exact() {\n     {\n         let mut ten_u32s: VecDeque<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n \n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 10) {\n+        if let Err(CapacityOverflow) =\n+            ten_u32s.try_reserve_exact(MAX_CAP / 4 - 10).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 10) {\n+        if let Err(CapacityOverflow) =\n+            ten_u32s.try_reserve_exact(MAX_CAP / 4 - 10).map_err(|e| e.kind())\n+        {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9) {\n+            if let Err(CapacityOverflow) =\n+                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an overflow!\");\n             }\n         } else {\n-            if let Err(AllocError { .. }) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9) {\n+            if let Err(AllocError { .. }) =\n+                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n+            {\n             } else {\n                 panic!(\"isize::MAX + 1 should trigger an OOM!\")\n             }\n         }\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_USIZE - 20) {\n+        if let Err(CapacityOverflow) =\n+            ten_u32s.try_reserve_exact(MAX_USIZE - 20).map_err(|e| e.kind())\n+        {\n         } else {\n             panic!(\"usize::MAX should trigger an overflow!\")\n         }"}, {"sha": "6b24d33bebca39239d618a74f3cd0d23615eadbd", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -3452,7 +3452,7 @@ pub trait Iterator {\n         self.map(f).is_sorted()\n     }\n \n-    /// See [TrustedRandomAccess]\n+    /// See [TrustedRandomAccess][super::super::TrustedRandomAccess]\n     // The unusual name is to avoid name collisions in method resolution\n     // see #76479.\n     #[inline]"}, {"sha": "941708429b98587210ebcddc0b89c69eff4c9a11", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -8,6 +8,7 @@ use hashbrown::hash_map as base;\n use crate::borrow::Borrow;\n use crate::cell::Cell;\n use crate::collections::TryReserveError;\n+use crate::collections::TryReserveErrorKind;\n use crate::fmt::{self, Debug};\n #[allow(deprecated)]\n use crate::hash::{BuildHasher, Hash, Hasher, SipHasher13};\n@@ -2990,9 +2991,11 @@ fn map_entry<'a, K: 'a, V: 'a>(raw: base::RustcEntry<'a, K, V>) -> Entry<'a, K,\n #[inline]\n pub(super) fn map_try_reserve_error(err: hashbrown::TryReserveError) -> TryReserveError {\n     match err {\n-        hashbrown::TryReserveError::CapacityOverflow => TryReserveError::CapacityOverflow,\n+        hashbrown::TryReserveError::CapacityOverflow => {\n+            TryReserveErrorKind::CapacityOverflow.into()\n+        }\n         hashbrown::TryReserveError::AllocError { layout } => {\n-            TryReserveError::AllocError { layout, non_exhaustive: () }\n+            TryReserveErrorKind::AllocError { layout, non_exhaustive: () }.into()\n         }\n     }\n }"}, {"sha": "18d868d49a634e3e1204e05c33fbe6d256851cc2", "filename": "library/std/src/collections/hash/map/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -3,7 +3,7 @@ use super::HashMap;\n use super::RandomState;\n use crate::cell::RefCell;\n use rand::{thread_rng, Rng};\n-use realstd::collections::TryReserveError::*;\n+use realstd::collections::TryReserveErrorKind::*;\n \n // https://github.com/rust-lang/rust/issues/62301\n fn _assert_hashmap_is_unwind_safe() {\n@@ -821,12 +821,12 @@ fn test_try_reserve() {\n \n     const MAX_USIZE: usize = usize::MAX;\n \n-    if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE) {\n+    if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()) {\n     } else {\n         panic!(\"usize::MAX should trigger an overflow!\");\n     }\n \n-    if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_USIZE / 8) {\n+    if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_USIZE / 8).map_err(|e| e.kind()) {\n     } else {\n         panic!(\"usize::MAX / 8 should trigger an OOM!\")\n     }"}, {"sha": "130bb5cb2b3c2b77f6b7402330dd2ded199be0f7", "filename": "library/std/src/collections/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/library%2Fstd%2Fsrc%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/library%2Fstd%2Fsrc%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fmod.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -422,6 +422,12 @@ pub use self::hash_set::HashSet;\n \n #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n pub use alloc_crate::collections::TryReserveError;\n+#[unstable(\n+    feature = \"try_reserve_kind\",\n+    reason = \"Uncertain how much info should be exposed\",\n+    issue = \"48043\"\n+)]\n+pub use alloc_crate::collections::TryReserveErrorKind;\n \n mod hash;\n "}, {"sha": "2c04481c04ec0dd04763b180093fa2cbfe527d62", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -2039,6 +2039,8 @@ pub fn remove_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n ///\n /// The iterator will yield instances of [`io::Result`]`<`[`DirEntry`]`>`.\n /// New errors may be encountered after an iterator is initially constructed.\n+/// Entries for the current and parent directories (typically `.` and `..`) are\n+/// skipped.\n ///\n /// # Platform-specific behavior\n ///"}, {"sha": "1af6157ca68bfb98ec5426f61223f3eb6e815032", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -326,6 +326,7 @@\n #![feature(trace_macros)]\n #![feature(try_blocks)]\n #![feature(try_reserve)]\n+#![feature(try_reserve_kind)]\n #![feature(unboxed_closures)]\n #![feature(unsafe_cell_raw_get)]\n #![feature(unwrap_infallible)]"}, {"sha": "bbfe846e31556d732a9ad70ee33800b894d11e2d", "filename": "library/std/src/sys/unix/os.rs", "status": "modified", "additions": 8, "deletions": 33, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -388,46 +388,21 @@ pub fn current_exe() -> io::Result<PathBuf> {\n \n #[cfg(target_os = \"haiku\")]\n pub fn current_exe() -> io::Result<PathBuf> {\n-    // Use Haiku's image info functions\n-    #[repr(C)]\n-    struct image_info {\n-        id: i32,\n-        type_: i32,\n-        sequence: i32,\n-        init_order: i32,\n-        init_routine: *mut libc::c_void, // function pointer\n-        term_routine: *mut libc::c_void, // function pointer\n-        device: libc::dev_t,\n-        node: libc::ino_t,\n-        name: [libc::c_char; 1024], // MAXPATHLEN\n-        text: *mut libc::c_void,\n-        data: *mut libc::c_void,\n-        text_size: i32,\n-        data_size: i32,\n-        api_version: i32,\n-        abi: i32,\n-    }\n-\n     unsafe {\n-        extern \"C\" {\n-            fn _get_next_image_info(\n-                team_id: i32,\n-                cookie: *mut i32,\n-                info: *mut image_info,\n-                size: i32,\n-            ) -> i32;\n-        }\n-\n-        let mut info: image_info = mem::zeroed();\n+        let mut info: mem::MaybeUninit<libc::image_info> = mem::MaybeUninit::uninit();\n         let mut cookie: i32 = 0;\n         // the executable can be found at team id 0\n-        let result =\n-            _get_next_image_info(0, &mut cookie, &mut info, mem::size_of::<image_info>() as i32);\n+        let result = libc::_get_next_image_info(\n+            0,\n+            &mut cookie,\n+            info.as_mut_ptr(),\n+            mem::size_of::<libc::image_info>(),\n+        );\n         if result != 0 {\n             use crate::io::ErrorKind;\n             Err(io::Error::new_const(ErrorKind::Uncategorized, &\"Error getting executable path\"))\n         } else {\n-            let name = CStr::from_ptr(info.name.as_ptr()).to_bytes();\n+            let name = CStr::from_ptr((*info.as_ptr()).name.as_ptr()).to_bytes();\n             Ok(PathBuf::from(OsStr::from_bytes(name)))\n         }\n     }"}, {"sha": "bb3ea04d4ace9ff28a44ee8b62efbc4a020f78fb", "filename": "src/bootstrap/builder/tests.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -486,6 +486,7 @@ mod dist {\n             fail_fast: true,\n             doc_tests: DocTests::No,\n             bless: false,\n+            force_rerun: false,\n             compare_mode: None,\n             rustfix_coverage: false,\n             pass: None,\n@@ -527,6 +528,7 @@ mod dist {\n             fail_fast: true,\n             doc_tests: DocTests::No,\n             bless: false,\n+            force_rerun: false,\n             compare_mode: None,\n             rustfix_coverage: false,\n             pass: None,\n@@ -583,6 +585,7 @@ mod dist {\n             fail_fast: true,\n             doc_tests: DocTests::Yes,\n             bless: false,\n+            force_rerun: false,\n             compare_mode: None,\n             rustfix_coverage: false,\n             pass: None,"}, {"sha": "7b74a909c286e6b2a320d1702af7ac18c9b09aab", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -102,6 +102,7 @@ pub enum Subcommand {\n         paths: Vec<PathBuf>,\n         /// Whether to automatically update stderr/stdout files\n         bless: bool,\n+        force_rerun: bool,\n         compare_mode: Option<String>,\n         pass: Option<String>,\n         run: Option<String>,\n@@ -284,6 +285,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n                 opts.optflag(\"\", \"no-doc\", \"do not run doc tests\");\n                 opts.optflag(\"\", \"doc\", \"only run doc tests\");\n                 opts.optflag(\"\", \"bless\", \"update all stderr/stdout files of failing ui tests\");\n+                opts.optflag(\"\", \"force-rerun\", \"rerun tests even if the inputs are unchanged\");\n                 opts.optopt(\n                     \"\",\n                     \"compare-mode\",\n@@ -558,6 +560,7 @@ Arguments:\n             \"test\" | \"t\" => Subcommand::Test {\n                 paths,\n                 bless: matches.opt_present(\"bless\"),\n+                force_rerun: matches.opt_present(\"force-rerun\"),\n                 compare_mode: matches.opt_str(\"compare-mode\"),\n                 pass: matches.opt_str(\"pass\"),\n                 run: matches.opt_str(\"run\"),\n@@ -726,6 +729,13 @@ impl Subcommand {\n         }\n     }\n \n+    pub fn force_rerun(&self) -> bool {\n+        match *self {\n+            Subcommand::Test { force_rerun, .. } => force_rerun,\n+            _ => false,\n+        }\n+    }\n+\n     pub fn rustfix_coverage(&self) -> bool {\n         match *self {\n             Subcommand::Test { rustfix_coverage, .. } => rustfix_coverage,"}, {"sha": "9effdb2c959d0840423ed738dcdbc2f911f95134", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -1315,6 +1315,10 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n             cmd.arg(\"--bless\");\n         }\n \n+        if builder.config.cmd.force_rerun() {\n+            cmd.arg(\"--force-rerun\");\n+        }\n+\n         let compare_mode =\n             builder.config.cmd.compare_mode().or_else(|| {\n                 if builder.config.test_compare_mode { self.compare_mode } else { None }"}, {"sha": "af42a4cd06d585e5d6ce91c8e54f003707c47d63", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -1937,7 +1937,7 @@ crate enum Variant {\n     Struct(VariantStruct),\n }\n \n-/// Small wrapper around [`rustc_span::Span]` that adds helper methods\n+/// Small wrapper around [`rustc_span::Span`] that adds helper methods\n /// and enforces calling [`rustc_span::Span::source_callsite()`].\n #[derive(Copy, Clone, Debug)]\n crate struct Span(rustc_span::Span);"}, {"sha": "6b0ac78857a0ebcb42349f1340434b3ce1fe3fd9", "filename": "src/test/codegen/vec-shrink-panik.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/src%2Ftest%2Fcodegen%2Fvec-shrink-panik.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/src%2Ftest%2Fcodegen%2Fvec-shrink-panik.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fvec-shrink-panik.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "previous_filename": "src/test/codegen/vec-shrink-panic.rs"}, {"sha": "900f4443a1fd67317bf4acb791b35e50ca87f01d", "filename": "src/test/ui/asm/naked-functions.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/src%2Ftest%2Fui%2Fasm%2Fnaked-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/src%2Ftest%2Fui%2Fasm%2Fnaked-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fnaked-functions.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -134,14 +134,12 @@ unsafe extern \"C\" fn invalid_options_continued() {\n #[naked]\n pub unsafe fn default_abi() {\n     //~^ WARN Rust ABI is unsupported in naked functions\n-    //~| WARN this was previously accepted\n     asm!(\"\", options(noreturn));\n }\n \n #[naked]\n pub unsafe extern \"Rust\" fn rust_abi() {\n     //~^ WARN Rust ABI is unsupported in naked functions\n-    //~| WARN this was previously accepted\n     asm!(\"\", options(noreturn));\n }\n "}, {"sha": "231a6239cbde59602d20f6aa59fb107d69f41c99", "filename": "src/test/ui/asm/naked-functions.stderr", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/src%2Ftest%2Fui%2Fasm%2Fnaked-functions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/src%2Ftest%2Fui%2Fasm%2Fnaked-functions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fnaked-functions.stderr?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -284,20 +284,16 @@ warning: Rust ABI is unsupported in naked functions\n LL | pub unsafe fn default_abi() {\n    |               ^^^^^^^^^^^\n    |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #32408 <https://github.com/rust-lang/rust/issues/32408>\n+   = note: `#[warn(undefined_naked_function_abi)]` on by default\n \n warning: Rust ABI is unsupported in naked functions\n-  --> $DIR/naked-functions.rs:142:29\n+  --> $DIR/naked-functions.rs:141:29\n    |\n LL | pub unsafe extern \"Rust\" fn rust_abi() {\n    |                             ^^^^^^^^\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #32408 <https://github.com/rust-lang/rust/issues/32408>\n \n warning: naked functions cannot be inlined\n-  --> $DIR/naked-functions.rs:177:1\n+  --> $DIR/naked-functions.rs:175:1\n    |\n LL | #[inline]\n    | ^^^^^^^^^\n@@ -306,7 +302,7 @@ LL | #[inline]\n    = note: for more information, see issue #32408 <https://github.com/rust-lang/rust/issues/32408>\n \n warning: naked functions cannot be inlined\n-  --> $DIR/naked-functions.rs:185:1\n+  --> $DIR/naked-functions.rs:183:1\n    |\n LL | #[inline(always)]\n    | ^^^^^^^^^^^^^^^^^\n@@ -315,7 +311,7 @@ LL | #[inline(always)]\n    = note: for more information, see issue #32408 <https://github.com/rust-lang/rust/issues/32408>\n \n warning: naked functions cannot be inlined\n-  --> $DIR/naked-functions.rs:193:1\n+  --> $DIR/naked-functions.rs:191:1\n    |\n LL | #[inline(never)]\n    | ^^^^^^^^^^^^^^^^\n@@ -324,7 +320,7 @@ LL | #[inline(never)]\n    = note: for more information, see issue #32408 <https://github.com/rust-lang/rust/issues/32408>\n \n warning: naked functions cannot be inlined\n-  --> $DIR/naked-functions.rs:201:1\n+  --> $DIR/naked-functions.rs:199:1\n    |\n LL | #[inline]\n    | ^^^^^^^^^\n@@ -333,7 +329,7 @@ LL | #[inline]\n    = note: for more information, see issue #32408 <https://github.com/rust-lang/rust/issues/32408>\n \n warning: naked functions cannot be inlined\n-  --> $DIR/naked-functions.rs:204:1\n+  --> $DIR/naked-functions.rs:202:1\n    |\n LL | #[inline(always)]\n    | ^^^^^^^^^^^^^^^^^\n@@ -342,7 +338,7 @@ LL | #[inline(always)]\n    = note: for more information, see issue #32408 <https://github.com/rust-lang/rust/issues/32408>\n \n warning: naked functions cannot be inlined\n-  --> $DIR/naked-functions.rs:207:1\n+  --> $DIR/naked-functions.rs:205:1\n    |\n LL | #[inline(never)]\n    | ^^^^^^^^^^^^^^^^"}, {"sha": "99b0a3454e89ccaed91b758a80c9155d3ed18828", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -362,6 +362,9 @@ pub struct Config {\n     pub nodejs: Option<String>,\n     /// Path to a npm executable. Used for rustdoc GUI tests\n     pub npm: Option<String>,\n+\n+    /// Whether to rerun tests even if the inputs are unchanged.\n+    pub force_rerun: bool,\n }\n \n impl Config {"}, {"sha": "9e655557fd271829dbee42ccd09ba7693b3f2640", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -144,6 +144,7 @@ pub fn parse_config(args: Vec<String>) -> Config {\n             \"enable this to generate a Rustfix coverage file, which is saved in \\\n                 `./<build_base>/rustfix_missing_coverage.txt`\",\n         )\n+        .optflag(\"\", \"force-rerun\", \"rerun tests even if the inputs are unchanged\")\n         .optflag(\"h\", \"help\", \"show this message\")\n         .reqopt(\"\", \"channel\", \"current Rust channel\", \"CHANNEL\");\n \n@@ -289,6 +290,8 @@ pub fn parse_config(args: Vec<String>) -> Config {\n         llvm_components: matches.opt_str(\"llvm-components\").unwrap(),\n         nodejs: matches.opt_str(\"nodejs\"),\n         npm: matches.opt_str(\"npm\"),\n+\n+        force_rerun: matches.opt_present(\"force-rerun\"),\n     }\n }\n \n@@ -644,13 +647,15 @@ fn make_test(config: &Config, testpaths: &TestPaths, inputs: &Stamp) -> Vec<test\n             let test_name = crate::make_test_name(config, testpaths, revision);\n             let mut desc = make_test_description(config, test_name, &test_path, src_file, cfg);\n             // Ignore tests that already run and are up to date with respect to inputs.\n-            desc.ignore |= is_up_to_date(\n-                config,\n-                testpaths,\n-                &early_props,\n-                revision.map(|s| s.as_str()),\n-                inputs,\n-            );\n+            if !config.force_rerun {\n+                desc.ignore |= is_up_to_date(\n+                    config,\n+                    testpaths,\n+                    &early_props,\n+                    revision.map(|s| s.as_str()),\n+                    inputs,\n+                );\n+            }\n             test::TestDescAndFn { desc, testfn: make_test_closure(config, testpaths, revision) }\n         })\n         .collect()"}, {"sha": "8cbe0a0c2e8e1736329b4033775ede5a4b8e0f01", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -129,7 +129,7 @@ enum FileEntry {\n     /// An HTML file.\n     ///\n     /// This includes the contents of the HTML file, and an optional set of\n-    /// HTML IDs. The IDs are used for checking fragments. The are computed\n+    /// HTML IDs. The IDs are used for checking fragments. They are computed\n     /// as-needed. The source is discarded (replaced with an empty string)\n     /// after the file has been checked, to conserve on memory.\n     HtmlFile { source: Rc<String>, ids: RefCell<HashSet<String>> },"}, {"sha": "042cbf175bfdad6524fd00d7570b2297a0426063", "filename": "src/tools/miri", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri?ref=26bf0ef0b5a70a70a6e0f85533bb3ca1404e9650", "patch": "@@ -1 +1 @@\n-Subproject commit 99ec9c1707aad74b4a4a6d301f27fb1c19733f58\n+Subproject commit 042cbf175bfdad6524fd00d7570b2297a0426063"}]}