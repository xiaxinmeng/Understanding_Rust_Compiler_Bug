{"sha": "2cbe8a4c4be2a69b27c248ab96341c2336f983cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjYmU4YTRjNGJlMmE2OWIyN2MyNDhhYjk2MzQxYzIzMzZmOTgzY2Q=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-02-22T12:31:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-22T12:31:30Z"}, "message": "Merge #3263\n\n3263: Implement unsizing coercions using Chalk r=matklad a=flodiebold\n\nThese are coercions like `&[T; n] -> &[T]`, which are handled by the `Unsize` and `CoerceUnsized` traits. The impls for `Unsize` are all built in to the compiler and require special handling, so we need to provide them to Chalk.\r\n\r\nThis adds the following `Unsize` impls:\r\n - `Unsize<[T]> for [T; _]`\r\n - `Unsize<dyn Trait> for T where T: Trait`\r\n - `Unsize<dyn SuperTrait> for dyn SubTrait`\r\n\r\nHence we are still missing the 'unsizing the last field of a generic struct' case.\n\nCo-authored-by: Florian Diebold <florian.diebold@freiheit.com>\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "ee1a32b47f889ed132a314286cd90a07f3700216", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee1a32b47f889ed132a314286cd90a07f3700216"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2cbe8a4c4be2a69b27c248ab96341c2336f983cd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeUR8iCRBK7hj4Ov3rIwAAdHIIACrJUvagjP/8dQ5kaQ6sk8VN\nn+ZpPmQUdG1VFj+pGuKYAkSRxiN5O9H1nEeGSXJ1pATVO5pKuPdJlXrAFfswQqYd\nNod04E8lhb+ymu3LiiDwbfDdkR8b6p94hfFJfQ7D5HGuuJ3KBuiLNeuACAp/tQnf\nImGIJTzuu/1d9FQFgAuItroefpqknPq08p0RLpriHCBjaMn/ZfdBjfcz7EVkWgCl\nw5Y9gzRX5jE0IIzofMyhSJtfJJLolw0UtJfSI0Jc4RpQOKUcJrN0kbZPnrZvJpUT\nxD59GKV116YvU/b7tx5wv6H1WN7hXN/wMWrGjqxE+JkE1YejV58cRvyK7ztgwDM=\n=QQKk\n-----END PGP SIGNATURE-----\n", "payload": "tree ee1a32b47f889ed132a314286cd90a07f3700216\nparent 7836720f2e9a7fa01ae09ff9d51413ecd5877139\nparent 5a6e770f99d1549432c1e8a1abb1aada09ad2590\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1582374690 +0000\ncommitter GitHub <noreply@github.com> 1582374690 +0000\n\nMerge #3263\n\n3263: Implement unsizing coercions using Chalk r=matklad a=flodiebold\n\nThese are coercions like `&[T; n] -> &[T]`, which are handled by the `Unsize` and `CoerceUnsized` traits. The impls for `Unsize` are all built in to the compiler and require special handling, so we need to provide them to Chalk.\r\n\r\nThis adds the following `Unsize` impls:\r\n - `Unsize<[T]> for [T; _]`\r\n - `Unsize<dyn Trait> for T where T: Trait`\r\n - `Unsize<dyn SuperTrait> for dyn SubTrait`\r\n\r\nHence we are still missing the 'unsizing the last field of a generic struct' case.\n\nCo-authored-by: Florian Diebold <florian.diebold@freiheit.com>\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2cbe8a4c4be2a69b27c248ab96341c2336f983cd", "html_url": "https://github.com/rust-lang/rust/commit/2cbe8a4c4be2a69b27c248ab96341c2336f983cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2cbe8a4c4be2a69b27c248ab96341c2336f983cd/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7836720f2e9a7fa01ae09ff9d51413ecd5877139", "url": "https://api.github.com/repos/rust-lang/rust/commits/7836720f2e9a7fa01ae09ff9d51413ecd5877139", "html_url": "https://github.com/rust-lang/rust/commit/7836720f2e9a7fa01ae09ff9d51413ecd5877139"}, {"sha": "5a6e770f99d1549432c1e8a1abb1aada09ad2590", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a6e770f99d1549432c1e8a1abb1aada09ad2590", "html_url": "https://github.com/rust-lang/rust/commit/5a6e770f99d1549432c1e8a1abb1aada09ad2590"}], "stats": {"total": 741, "additions": 480, "deletions": 261}, "files": [{"sha": "6e1d268dea48bdd09ec109305ea664dc5ac7fd28", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2cbe8a4c4be2a69b27c248ab96341c2336f983cd/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cbe8a4c4be2a69b27c248ab96341c2336f983cd/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=2cbe8a4c4be2a69b27c248ab96341c2336f983cd", "patch": "@@ -206,12 +206,6 @@ struct InferenceContext<'a, D: HirDatabase> {\n     /// closures, but currently this is the only field that will change there,\n     /// so it doesn't make sense.\n     return_ty: Ty,\n-\n-    /// Impls of `CoerceUnsized` used in coercion.\n-    /// (from_ty_ctor, to_ty_ctor) => coerce_generic_index\n-    // FIXME: Use trait solver for this.\n-    // Chalk seems unable to work well with builtin impl of `Unsize` now.\n-    coerce_unsized_map: FxHashMap<(TypeCtor, TypeCtor), usize>,\n }\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n@@ -222,7 +216,6 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             obligations: Vec::default(),\n             return_ty: Ty::Unknown, // set in collect_fn_signature\n             trait_env: TraitEnvironment::lower(db, &resolver),\n-            coerce_unsized_map: Self::init_coerce_unsized_map(db, &resolver),\n             db,\n             owner,\n             body: db.body(owner),"}, {"sha": "95ac3c713243eb05d4eb4237355ede19ef780c52", "filename": "crates/ra_hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 26, "deletions": 179, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/2cbe8a4c4be2a69b27c248ab96341c2336f983cd/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cbe8a4c4be2a69b27c248ab96341c2336f983cd/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=2cbe8a4c4be2a69b27c248ab96341c2336f983cd", "patch": "@@ -4,11 +4,12 @@\n //!\n //! See: https://doc.rust-lang.org/nomicon/coercions.html\n \n-use hir_def::{lang_item::LangItemTarget, resolver::Resolver, type_ref::Mutability, AdtId};\n-use rustc_hash::FxHashMap;\n+use hir_def::{lang_item::LangItemTarget, type_ref::Mutability};\n use test_utils::tested_by;\n \n-use crate::{autoderef, db::HirDatabase, Substs, Ty, TypeCtor, TypeWalk};\n+use crate::{\n+    autoderef, db::HirDatabase, traits::Solution, Obligation, Substs, TraitRef, Ty, TypeCtor,\n+};\n \n use super::{unify::TypeVarValue, InEnvironment, InferTy, InferenceContext};\n \n@@ -39,44 +40,6 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         }\n     }\n \n-    pub(super) fn init_coerce_unsized_map(\n-        db: &'a D,\n-        resolver: &Resolver,\n-    ) -> FxHashMap<(TypeCtor, TypeCtor), usize> {\n-        let krate = resolver.krate().unwrap();\n-        let impls = match db.lang_item(krate, \"coerce_unsized\".into()) {\n-            Some(LangItemTarget::TraitId(trait_)) => db.impls_for_trait(krate, trait_),\n-            _ => return FxHashMap::default(),\n-        };\n-\n-        impls\n-            .iter()\n-            .filter_map(|&impl_id| {\n-                let trait_ref = db.impl_trait(impl_id)?;\n-\n-                // `CoerseUnsized` has one generic parameter for the target type.\n-                let cur_from_ty = trait_ref.value.substs.0.get(0)?;\n-                let cur_to_ty = trait_ref.value.substs.0.get(1)?;\n-\n-                match (&cur_from_ty, cur_to_ty) {\n-                    (ty_app!(ctor1, st1), ty_app!(ctor2, st2)) => {\n-                        // FIXME: We return the first non-equal bound as the type parameter to coerce to unsized type.\n-                        // This works for smart-pointer-like coercion, which covers all impls from std.\n-                        st1.iter().zip(st2.iter()).enumerate().find_map(|(i, (ty1, ty2))| {\n-                            match (ty1, ty2) {\n-                                (Ty::Bound(idx1), Ty::Bound(idx2)) if idx1 != idx2 => {\n-                                    Some(((*ctor1, *ctor2), i))\n-                                }\n-                                _ => None,\n-                            }\n-                        })\n-                    }\n-                    _ => None,\n-                }\n-            })\n-            .collect()\n-    }\n-\n     fn coerce_inner(&mut self, mut from_ty: Ty, to_ty: &Ty) -> bool {\n         match (&from_ty, to_ty) {\n             // Never type will make type variable to fallback to Never Type instead of Unknown.\n@@ -157,154 +120,38 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     ///\n     /// See: https://doc.rust-lang.org/nightly/std/marker/trait.CoerceUnsized.html\n     fn try_coerce_unsized(&mut self, from_ty: &Ty, to_ty: &Ty) -> Option<bool> {\n-        let (ctor1, st1, ctor2, st2) = match (from_ty, to_ty) {\n-            (ty_app!(ctor1, st1), ty_app!(ctor2, st2)) => (ctor1, st1, ctor2, st2),\n+        let krate = self.resolver.krate().unwrap();\n+        let coerce_unsized_trait = match self.db.lang_item(krate, \"coerce_unsized\".into()) {\n+            Some(LangItemTarget::TraitId(trait_)) => trait_,\n             _ => return None,\n         };\n \n-        let coerce_generic_index = *self.coerce_unsized_map.get(&(*ctor1, *ctor2))?;\n-\n-        // Check `Unsize` first\n-        match self.check_unsize_and_coerce(\n-            st1.0.get(coerce_generic_index)?,\n-            st2.0.get(coerce_generic_index)?,\n-            0,\n-        ) {\n-            Some(true) => {}\n-            ret => return ret,\n+        let generic_params = crate::utils::generics(self.db, coerce_unsized_trait.into());\n+        if generic_params.len() != 2 {\n+            // The CoerceUnsized trait should have two generic params: Self and T.\n+            return None;\n         }\n \n-        let ret = st1\n-            .iter()\n-            .zip(st2.iter())\n-            .enumerate()\n-            .filter(|&(idx, _)| idx != coerce_generic_index)\n-            .all(|(_, (ty1, ty2))| self.unify(ty1, ty2));\n+        let substs = Substs::build_for_generics(&generic_params)\n+            .push(from_ty.clone())\n+            .push(to_ty.clone())\n+            .build();\n+        let trait_ref = TraitRef { trait_: coerce_unsized_trait, substs };\n+        let goal = InEnvironment::new(self.trait_env.clone(), Obligation::Trait(trait_ref));\n \n-        Some(ret)\n-    }\n+        let canonicalizer = self.canonicalizer();\n+        let canonicalized = canonicalizer.canonicalize_obligation(goal);\n \n-    /// Check if `from_ty: Unsize<to_ty>`, and coerce to `to_ty` if it holds.\n-    ///\n-    /// It should not be directly called. It is only used by `try_coerce_unsized`.\n-    ///\n-    /// See: https://doc.rust-lang.org/nightly/std/marker/trait.Unsize.html\n-    fn check_unsize_and_coerce(&mut self, from_ty: &Ty, to_ty: &Ty, depth: usize) -> Option<bool> {\n-        if depth > 1000 {\n-            panic!(\"Infinite recursion in coercion\");\n-        }\n-\n-        match (&from_ty, &to_ty) {\n-            // `[T; N]` -> `[T]`\n-            (ty_app!(TypeCtor::Array, st1), ty_app!(TypeCtor::Slice, st2)) => {\n-                Some(self.unify(&st1[0], &st2[0]))\n-            }\n+        let solution = self.db.trait_solve(krate, canonicalized.value.clone())?;\n \n-            // `T` -> `dyn Trait` when `T: Trait`\n-            (_, Ty::Dyn(_)) => {\n-                // FIXME: Check predicates\n-                Some(true)\n-            }\n-\n-            // `(..., T)` -> `(..., U)` when `T: Unsize<U>`\n-            (\n-                ty_app!(TypeCtor::Tuple { cardinality: len1 }, st1),\n-                ty_app!(TypeCtor::Tuple { cardinality: len2 }, st2),\n-            ) => {\n-                if len1 != len2 || *len1 == 0 {\n-                    return None;\n-                }\n-\n-                match self.check_unsize_and_coerce(\n-                    st1.last().unwrap(),\n-                    st2.last().unwrap(),\n-                    depth + 1,\n-                ) {\n-                    Some(true) => {}\n-                    ret => return ret,\n-                }\n-\n-                let ret = st1[..st1.len() - 1]\n-                    .iter()\n-                    .zip(&st2[..st2.len() - 1])\n-                    .all(|(ty1, ty2)| self.unify(ty1, ty2));\n-\n-                Some(ret)\n-            }\n-\n-            // Foo<..., T, ...> is Unsize<Foo<..., U, ...>> if:\n-            // - T: Unsize<U>\n-            // - Foo is a struct\n-            // - Only the last field of Foo has a type involving T\n-            // - T is not part of the type of any other fields\n-            // - Bar<T>: Unsize<Bar<U>>, if the last field of Foo has type Bar<T>\n-            (\n-                ty_app!(TypeCtor::Adt(AdtId::StructId(struct1)), st1),\n-                ty_app!(TypeCtor::Adt(AdtId::StructId(struct2)), st2),\n-            ) if struct1 == struct2 => {\n-                let field_tys = self.db.field_types((*struct1).into());\n-                let struct_data = self.db.struct_data(*struct1);\n-\n-                let mut fields = struct_data.variant_data.fields().iter();\n-                let (last_field_id, _data) = fields.next_back()?;\n-\n-                // Get the generic parameter involved in the last field.\n-                let unsize_generic_index = {\n-                    let mut index = None;\n-                    let mut multiple_param = false;\n-                    field_tys[last_field_id].value.walk(&mut |ty| {\n-                        if let &Ty::Bound(idx) = ty {\n-                            if index.is_none() {\n-                                index = Some(idx);\n-                            } else if Some(idx) != index {\n-                                multiple_param = true;\n-                            }\n-                        }\n-                    });\n-\n-                    if multiple_param {\n-                        return None;\n-                    }\n-                    index?\n-                };\n-\n-                // Check other fields do not involve it.\n-                let mut multiple_used = false;\n-                fields.for_each(|(field_id, _data)| {\n-                    field_tys[field_id].value.walk(&mut |ty| match ty {\n-                        &Ty::Bound(idx) if idx == unsize_generic_index => multiple_used = true,\n-                        _ => {}\n-                    })\n-                });\n-                if multiple_used {\n-                    return None;\n-                }\n-\n-                let unsize_generic_index = unsize_generic_index as usize;\n-\n-                // Check `Unsize` first\n-                match self.check_unsize_and_coerce(\n-                    st1.get(unsize_generic_index)?,\n-                    st2.get(unsize_generic_index)?,\n-                    depth + 1,\n-                ) {\n-                    Some(true) => {}\n-                    ret => return ret,\n-                }\n-\n-                // Then unify other parameters\n-                let ret = st1\n-                    .iter()\n-                    .zip(st2.iter())\n-                    .enumerate()\n-                    .filter(|&(idx, _)| idx != unsize_generic_index)\n-                    .all(|(_, (ty1, ty2))| self.unify(ty1, ty2));\n-\n-                Some(ret)\n+        match solution {\n+            Solution::Unique(v) => {\n+                canonicalized.apply_solution(self, v.0);\n             }\n+            _ => return None,\n+        };\n \n-            _ => None,\n-        }\n+        Some(true)\n     }\n \n     /// Unify `from_ty` to `to_ty` with optional auto Deref"}, {"sha": "aed527fe591d3c43d11c1320ef5273349310a66b", "filename": "crates/ra_hir_ty/src/infer/unify.rs", "status": "modified", "additions": 35, "deletions": 64, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/2cbe8a4c4be2a69b27c248ab96341c2336f983cd/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cbe8a4c4be2a69b27c248ab96341c2336f983cd/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs?ref=2cbe8a4c4be2a69b27c248ab96341c2336f983cd", "patch": "@@ -7,10 +7,7 @@ use ena::unify::{InPlaceUnificationTable, NoError, UnifyKey, UnifyValue};\n use test_utils::tested_by;\n \n use super::{InferenceContext, Obligation};\n-use crate::{\n-    db::HirDatabase, utils::make_mut_slice, Canonical, InEnvironment, InferTy, ProjectionPredicate,\n-    ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk,\n-};\n+use crate::{db::HirDatabase, Canonical, InEnvironment, InferTy, Substs, Ty, TypeCtor, TypeWalk};\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     pub(super) fn canonicalizer<'b>(&'b mut self) -> Canonicalizer<'a, 'b, D>\n@@ -50,42 +47,38 @@ where\n         })\n     }\n \n-    fn do_canonicalize_ty(&mut self, ty: Ty) -> Ty {\n-        ty.fold(&mut |ty| match ty {\n-            Ty::Infer(tv) => {\n-                let inner = tv.to_inner();\n-                if self.var_stack.contains(&inner) {\n-                    // recursive type\n-                    return tv.fallback_value();\n-                }\n-                if let Some(known_ty) =\n-                    self.ctx.table.var_unification_table.inlined_probe_value(inner).known()\n-                {\n-                    self.var_stack.push(inner);\n-                    let result = self.do_canonicalize_ty(known_ty.clone());\n-                    self.var_stack.pop();\n-                    result\n-                } else {\n-                    let root = self.ctx.table.var_unification_table.find(inner);\n-                    let free_var = match tv {\n-                        InferTy::TypeVar(_) => InferTy::TypeVar(root),\n-                        InferTy::IntVar(_) => InferTy::IntVar(root),\n-                        InferTy::FloatVar(_) => InferTy::FloatVar(root),\n-                        InferTy::MaybeNeverTypeVar(_) => InferTy::MaybeNeverTypeVar(root),\n-                    };\n-                    let position = self.add(free_var);\n-                    Ty::Bound(position as u32)\n+    fn do_canonicalize<T: TypeWalk>(&mut self, t: T, binders: usize) -> T {\n+        t.fold_binders(\n+            &mut |ty, binders| match ty {\n+                Ty::Infer(tv) => {\n+                    let inner = tv.to_inner();\n+                    if self.var_stack.contains(&inner) {\n+                        // recursive type\n+                        return tv.fallback_value();\n+                    }\n+                    if let Some(known_ty) =\n+                        self.ctx.table.var_unification_table.inlined_probe_value(inner).known()\n+                    {\n+                        self.var_stack.push(inner);\n+                        let result = self.do_canonicalize(known_ty.clone(), binders);\n+                        self.var_stack.pop();\n+                        result\n+                    } else {\n+                        let root = self.ctx.table.var_unification_table.find(inner);\n+                        let free_var = match tv {\n+                            InferTy::TypeVar(_) => InferTy::TypeVar(root),\n+                            InferTy::IntVar(_) => InferTy::IntVar(root),\n+                            InferTy::FloatVar(_) => InferTy::FloatVar(root),\n+                            InferTy::MaybeNeverTypeVar(_) => InferTy::MaybeNeverTypeVar(root),\n+                        };\n+                        let position = self.add(free_var);\n+                        Ty::Bound((position + binders) as u32)\n+                    }\n                 }\n-            }\n-            _ => ty,\n-        })\n-    }\n-\n-    fn do_canonicalize_trait_ref(&mut self, mut trait_ref: TraitRef) -> TraitRef {\n-        for ty in make_mut_slice(&mut trait_ref.substs.0) {\n-            *ty = self.do_canonicalize_ty(ty.clone());\n-        }\n-        trait_ref\n+                _ => ty,\n+            },\n+            binders,\n+        )\n     }\n \n     fn into_canonicalized<T>(self, result: T) -> Canonicalized<T> {\n@@ -95,28 +88,8 @@ where\n         }\n     }\n \n-    fn do_canonicalize_projection_ty(&mut self, mut projection_ty: ProjectionTy) -> ProjectionTy {\n-        for ty in make_mut_slice(&mut projection_ty.parameters.0) {\n-            *ty = self.do_canonicalize_ty(ty.clone());\n-        }\n-        projection_ty\n-    }\n-\n-    fn do_canonicalize_projection_predicate(\n-        &mut self,\n-        projection: ProjectionPredicate,\n-    ) -> ProjectionPredicate {\n-        let ty = self.do_canonicalize_ty(projection.ty);\n-        let projection_ty = self.do_canonicalize_projection_ty(projection.projection_ty);\n-\n-        ProjectionPredicate { ty, projection_ty }\n-    }\n-\n-    // FIXME: add some point, we need to introduce a `Fold` trait that abstracts\n-    // over all the things that can be canonicalized (like Chalk and rustc have)\n-\n     pub(crate) fn canonicalize_ty(mut self, ty: Ty) -> Canonicalized<Ty> {\n-        let result = self.do_canonicalize_ty(ty);\n+        let result = self.do_canonicalize(ty, 0);\n         self.into_canonicalized(result)\n     }\n \n@@ -125,10 +98,8 @@ where\n         obligation: InEnvironment<Obligation>,\n     ) -> Canonicalized<InEnvironment<Obligation>> {\n         let result = match obligation.value {\n-            Obligation::Trait(tr) => Obligation::Trait(self.do_canonicalize_trait_ref(tr)),\n-            Obligation::Projection(pr) => {\n-                Obligation::Projection(self.do_canonicalize_projection_predicate(pr))\n-            }\n+            Obligation::Trait(tr) => Obligation::Trait(self.do_canonicalize(tr, 0)),\n+            Obligation::Projection(pr) => Obligation::Projection(self.do_canonicalize(pr, 0)),\n         };\n         self.into_canonicalized(InEnvironment {\n             value: result,"}, {"sha": "0009c426c4ed557c127ba7e916c1c9fc563595ba", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 41, "deletions": 7, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2cbe8a4c4be2a69b27c248ab96341c2336f983cd/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cbe8a4c4be2a69b27c248ab96341c2336f983cd/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=2cbe8a4c4be2a69b27c248ab96341c2336f983cd", "patch": "@@ -461,6 +461,12 @@ impl<T> Binders<T> {\n     }\n }\n \n+impl<T: Clone> Binders<&T> {\n+    pub fn cloned(&self) -> Binders<T> {\n+        Binders { num_binders: self.num_binders, value: self.value.clone() }\n+    }\n+}\n+\n impl<T: TypeWalk> Binders<T> {\n     /// Substitutes all variables.\n     pub fn subst(self, subst: &Substs) -> T {\n@@ -661,6 +667,17 @@ impl Ty {\n         }\n     }\n \n+    /// If this is a `dyn Trait` type, this returns the `Trait` part.\n+    pub fn dyn_trait_ref(&self) -> Option<&TraitRef> {\n+        match self {\n+            Ty::Dyn(bounds) => bounds.get(0).and_then(|b| match b {\n+                GenericPredicate::Implemented(trait_ref) => Some(trait_ref),\n+                _ => None,\n+            }),\n+            _ => None,\n+        }\n+    }\n+\n     fn builtin_deref(&self) -> Option<Ty> {\n         match self {\n             Ty::Apply(a_ty) => match a_ty.ctor {\n@@ -746,6 +763,20 @@ pub trait TypeWalk {\n     /// variable for the self type.\n     fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize);\n \n+    fn fold_binders(mut self, f: &mut impl FnMut(Ty, usize) -> Ty, binders: usize) -> Self\n+    where\n+        Self: Sized,\n+    {\n+        self.walk_mut_binders(\n+            &mut |ty_mut, binders| {\n+                let ty = mem::replace(ty_mut, Ty::Unknown);\n+                *ty_mut = f(ty, binders);\n+            },\n+            binders,\n+        );\n+        self\n+    }\n+\n     fn fold(mut self, f: &mut impl FnMut(Ty) -> Ty) -> Self\n     where\n         Self: Sized,\n@@ -783,13 +814,16 @@ pub trait TypeWalk {\n     where\n         Self: Sized,\n     {\n-        self.fold(&mut |ty| match ty {\n-            Ty::Bound(idx) => {\n-                assert!(idx as i32 >= -n);\n-                Ty::Bound((idx as i32 + n) as u32)\n-            }\n-            ty => ty,\n-        })\n+        self.fold_binders(\n+            &mut |ty, binders| match ty {\n+                Ty::Bound(idx) if idx as usize >= binders => {\n+                    assert!(idx as i32 >= -n);\n+                    Ty::Bound((idx as i32 + n) as u32)\n+                }\n+                ty => ty,\n+            },\n+            0,\n+        )\n     }\n }\n "}, {"sha": "092977e93054e1850f2fd858f8bd8b4a259e507f", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2cbe8a4c4be2a69b27c248ab96341c2336f983cd/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cbe8a4c4be2a69b27c248ab96341c2336f983cd/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=2cbe8a4c4be2a69b27c248ab96341c2336f983cd", "patch": "@@ -239,7 +239,10 @@ impl Ty {\n     ) -> Ty {\n         let ty = match resolution {\n             TypeNs::TraitId(trait_) => {\n-                let trait_ref = TraitRef::from_resolved_path(ctx, trait_, resolved_segment, None);\n+                // if this is a bare dyn Trait, we'll directly put the required ^0 for the self type in there\n+                let self_ty = if remaining_segments.len() == 0 { Some(Ty::Bound(0)) } else { None };\n+                let trait_ref =\n+                    TraitRef::from_resolved_path(ctx, trait_, resolved_segment, self_ty);\n                 return if remaining_segments.len() == 1 {\n                     let segment = remaining_segments.first().unwrap();\n                     let associated_ty = associated_type_by_name_including_super_traits("}, {"sha": "60ad6e9be3ab728f34d02a351bd3ce09a88d57c4", "filename": "crates/ra_hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/2cbe8a4c4be2a69b27c248ab96341c2336f983cd/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cbe8a4c4be2a69b27c248ab96341c2336f983cd/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=2cbe8a4c4be2a69b27c248ab96341c2336f983cd", "patch": "@@ -548,3 +548,141 @@ impl<TT> S<TT> {\n     \"###\n     );\n }\n+\n+#[test]\n+fn coerce_unsize_array() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+#[lang = \"unsize\"]\n+pub trait Unsize<T> {}\n+#[lang = \"coerce_unsized\"]\n+pub trait CoerceUnsized<T> {}\n+\n+impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n+\n+fn test() {\n+    let f: &[usize] = &[1, 2, 3];\n+}\n+\"#, true),\n+        @r###\"\n+    [162; 199) '{     ... 3]; }': ()\n+    [172; 173) 'f': &[usize]\n+    [186; 196) '&[1, 2, 3]': &[usize; _]\n+    [187; 196) '[1, 2, 3]': [usize; _]\n+    [188; 189) '1': usize\n+    [191; 192) '2': usize\n+    [194; 195) '3': usize\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn coerce_unsize_trait_object() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+#[lang = \"unsize\"]\n+pub trait Unsize<T> {}\n+#[lang = \"coerce_unsized\"]\n+pub trait CoerceUnsized<T> {}\n+\n+impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n+\n+trait Foo<T, U> {}\n+trait Bar<U, T, X>: Foo<T, U> {}\n+trait Baz<T, X>: Bar<usize, T, X> {}\n+\n+struct S<T, X>;\n+impl<T, X> Foo<T, usize> for S<T, X> {}\n+impl<T, X> Bar<usize, T, X> for S<T, X> {}\n+impl<T, X> Baz<T, X> for S<T, X> {}\n+\n+fn test() {\n+    let obj: &dyn Baz<i8, i16> = &S;\n+    let obj: &dyn Bar<_, _, _> = obj;\n+    let obj: &dyn Foo<_, _> = obj;\n+    let obj2: &dyn Baz<i8, i16> = &S;\n+    let _: &dyn Foo<_, _> = obj2;\n+}\n+\"#, true),\n+        @r###\"\n+    [388; 573) '{     ...bj2; }': ()\n+    [398; 401) 'obj': &dyn Baz<i8, i16>\n+    [423; 425) '&S': &S<i8, i16>\n+    [424; 425) 'S': S<i8, i16>\n+    [435; 438) 'obj': &dyn Bar<usize, i8, i16>\n+    [460; 463) 'obj': &dyn Baz<i8, i16>\n+    [473; 476) 'obj': &dyn Foo<i8, usize>\n+    [495; 498) 'obj': &dyn Bar<usize, i8, i16>\n+    [508; 512) 'obj2': &dyn Baz<i8, i16>\n+    [534; 536) '&S': &S<i8, i16>\n+    [535; 536) 'S': S<i8, i16>\n+    [546; 547) '_': &dyn Foo<i8, usize>\n+    [566; 570) 'obj2': &dyn Baz<i8, i16>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn coerce_unsize_super_trait_cycle() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+#[lang = \"unsize\"]\n+pub trait Unsize<T> {}\n+#[lang = \"coerce_unsized\"]\n+pub trait CoerceUnsized<T> {}\n+\n+impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n+\n+trait A {}\n+trait B: C + A {}\n+trait C: B {}\n+trait D: C\n+\n+struct S;\n+impl A for S {}\n+impl B for S {}\n+impl C for S {}\n+impl D for S {}\n+\n+fn test() {\n+    let obj: &dyn D = &S;\n+    let obj: &dyn A = obj;\n+}\n+\"#, true),\n+        @r###\"\n+    [292; 348) '{     ...obj; }': ()\n+    [302; 305) 'obj': &dyn D\n+    [316; 318) '&S': &S\n+    [317; 318) 'S': S\n+    [328; 331) 'obj': &dyn A\n+    [342; 345) 'obj': &dyn D\n+    \"###\n+    );\n+}\n+\n+#[ignore]\n+#[test]\n+fn coerce_unsize_generic() {\n+    // FIXME: Implement this\n+    // https://doc.rust-lang.org/reference/type-coercions.html#unsized-coercions\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+#[lang = \"unsize\"]\n+pub trait Unsize<T> {}\n+#[lang = \"coerce_unsized\"]\n+pub trait CoerceUnsized<T> {}\n+\n+impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n+\n+struct Foo<T> { t: T };\n+struct Bar<T>(Foo<T>);\n+\n+fn test() {\n+    let _: &Foo<[usize]> = &Foo { t: [1, 2, 3] };\n+    let _: &Bar<[usize]> = &Bar(Foo { t: [1, 2, 3] });\n+}\n+\"#, true),\n+        @r###\"\n+    \"###\n+    );\n+}"}, {"sha": "2317fcac369940444420c6bde2d2ee3a683b583a", "filename": "crates/ra_hir_ty/src/traits.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2cbe8a4c4be2a69b27c248ab96341c2336f983cd/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cbe8a4c4be2a69b27c248ab96341c2336f983cd/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs?ref=2cbe8a4c4be2a69b27c248ab96341c2336f983cd", "patch": "@@ -335,6 +335,12 @@ pub struct ClosureFnTraitImplData {\n     fn_trait: FnTrait,\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct UnsizeToSuperTraitObjectData {\n+    trait_: TraitId,\n+    super_trait: TraitId,\n+}\n+\n /// An impl. Usually this comes from an impl block, but some built-in types get\n /// synthetic impls.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -343,6 +349,12 @@ pub enum Impl {\n     ImplBlock(ImplId),\n     /// Closure types implement the Fn traits synthetically.\n     ClosureFnTraitImpl(ClosureFnTraitImplData),\n+    /// [T; n]: Unsize<[T]>\n+    UnsizeArray,\n+    /// T: Unsize<dyn Trait> where T: Trait\n+    UnsizeToTraitObject(TraitId),\n+    /// dyn Trait: Unsize<dyn SuperTrait> if Trait: SuperTrait\n+    UnsizeToSuperTraitObject(UnsizeToSuperTraitObjectData),\n }\n /// This exists just for Chalk, because our ImplIds are only unique per module.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]"}, {"sha": "cc0f3eeb46bcd9d2e202b755c486599befb828c0", "filename": "crates/ra_hir_ty/src/traits/builtin.rs", "status": "modified", "additions": 189, "deletions": 2, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/2cbe8a4c4be2a69b27c248ab96341c2336f983cd/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cbe8a4c4be2a69b27c248ab96341c2336f983cd/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs?ref=2cbe8a4c4be2a69b27c248ab96341c2336f983cd", "patch": "@@ -4,8 +4,12 @@ use hir_def::{expr::Expr, lang_item::LangItemTarget, TraitId, TypeAliasId};\n use hir_expand::name::name;\n use ra_db::CrateId;\n \n-use super::{AssocTyValue, Impl};\n-use crate::{db::HirDatabase, ApplicationTy, Substs, TraitRef, Ty, TypeCtor};\n+use super::{AssocTyValue, Impl, UnsizeToSuperTraitObjectData};\n+use crate::{\n+    db::HirDatabase,\n+    utils::{all_super_traits, generics},\n+    ApplicationTy, Binders, GenericPredicate, Substs, TraitRef, Ty, TypeCtor,\n+};\n \n pub(super) struct BuiltinImplData {\n     pub num_vars: usize,\n@@ -25,6 +29,8 @@ pub(super) fn get_builtin_impls(\n     db: &impl HirDatabase,\n     krate: CrateId,\n     ty: &Ty,\n+    // The first argument for the trait, if present\n+    arg: &Option<Ty>,\n     trait_: TraitId,\n     mut callback: impl FnMut(Impl),\n ) {\n@@ -43,12 +49,60 @@ pub(super) fn get_builtin_impls(\n             }\n         }\n     }\n+\n+    let unsize_trait = get_unsize_trait(db, krate);\n+    if let Some(actual_trait) = unsize_trait {\n+        if trait_ == actual_trait {\n+            get_builtin_unsize_impls(db, krate, ty, arg, callback);\n+        }\n+    }\n+}\n+\n+fn get_builtin_unsize_impls(\n+    db: &impl HirDatabase,\n+    krate: CrateId,\n+    ty: &Ty,\n+    // The first argument for the trait, if present\n+    arg: &Option<Ty>,\n+    mut callback: impl FnMut(Impl),\n+) {\n+    if !check_unsize_impl_prerequisites(db, krate) {\n+        return;\n+    }\n+\n+    if let Ty::Apply(ApplicationTy { ctor: TypeCtor::Array, .. }) = ty {\n+        callback(Impl::UnsizeArray);\n+        return; // array is unsized, the rest of the impls shouldn't apply\n+    }\n+\n+    if let Some(target_trait) = arg.as_ref().and_then(|t| t.dyn_trait_ref()) {\n+        // FIXME what about more complicated dyn tys with marker traits?\n+        if let Some(trait_ref) = ty.dyn_trait_ref() {\n+            if trait_ref.trait_ != target_trait.trait_ {\n+                let super_traits = all_super_traits(db, trait_ref.trait_);\n+                if super_traits.contains(&target_trait.trait_) {\n+                    callback(Impl::UnsizeToSuperTraitObject(UnsizeToSuperTraitObjectData {\n+                        trait_: trait_ref.trait_,\n+                        super_trait: target_trait.trait_,\n+                    }));\n+                }\n+            }\n+        } else {\n+            // FIXME only for sized types\n+            callback(Impl::UnsizeToTraitObject(target_trait.trait_));\n+        }\n+    }\n }\n \n pub(super) fn impl_datum(db: &impl HirDatabase, krate: CrateId, impl_: Impl) -> BuiltinImplData {\n     match impl_ {\n         Impl::ImplBlock(_) => unreachable!(),\n         Impl::ClosureFnTraitImpl(data) => closure_fn_trait_impl_datum(db, krate, data),\n+        Impl::UnsizeArray => array_unsize_impl_datum(db, krate),\n+        Impl::UnsizeToTraitObject(trait_) => trait_object_unsize_impl_datum(db, krate, trait_),\n+        Impl::UnsizeToSuperTraitObject(data) => {\n+            super_trait_object_unsize_impl_datum(db, krate, data)\n+        }\n     }\n }\n \n@@ -65,6 +119,8 @@ pub(super) fn associated_ty_value(\n     }\n }\n \n+// Closure Fn trait impls\n+\n fn check_closure_fn_trait_impl_prerequisites(\n     db: &impl HirDatabase,\n     krate: CrateId,\n@@ -165,6 +221,129 @@ fn closure_fn_trait_output_assoc_ty_value(\n     }\n }\n \n+// Array unsizing\n+\n+fn check_unsize_impl_prerequisites(db: &impl HirDatabase, krate: CrateId) -> bool {\n+    // the Unsize trait needs to exist and have two type parameters (Self and T)\n+    let unsize_trait = match get_unsize_trait(db, krate) {\n+        Some(t) => t,\n+        None => return false,\n+    };\n+    let generic_params = generics(db, unsize_trait.into());\n+    generic_params.len() == 2\n+}\n+\n+fn array_unsize_impl_datum(db: &impl HirDatabase, krate: CrateId) -> BuiltinImplData {\n+    // impl<T> Unsize<[T]> for [T; _]\n+    // (this can be a single impl because we don't distinguish array sizes currently)\n+\n+    let trait_ = get_unsize_trait(db, krate) // get unsize trait\n+        // the existence of the Unsize trait has been checked before\n+        .expect(\"Unsize trait missing\");\n+\n+    let var = Ty::Bound(0);\n+    let substs = Substs::builder(2)\n+        .push(Ty::apply_one(TypeCtor::Array, var.clone()))\n+        .push(Ty::apply_one(TypeCtor::Slice, var))\n+        .build();\n+\n+    let trait_ref = TraitRef { trait_, substs };\n+\n+    BuiltinImplData {\n+        num_vars: 1,\n+        trait_ref,\n+        where_clauses: Vec::new(),\n+        assoc_ty_values: Vec::new(),\n+    }\n+}\n+\n+// Trait object unsizing\n+\n+fn trait_object_unsize_impl_datum(\n+    db: &impl HirDatabase,\n+    krate: CrateId,\n+    trait_: TraitId,\n+) -> BuiltinImplData {\n+    // impl<T, T1, ...> Unsize<dyn Trait<T1, ...>> for T where T: Trait<T1, ...>\n+\n+    let unsize_trait = get_unsize_trait(db, krate) // get unsize trait\n+        // the existence of the Unsize trait has been checked before\n+        .expect(\"Unsize trait missing\");\n+\n+    let self_ty = Ty::Bound(0);\n+\n+    let target_substs = Substs::build_for_def(db, trait_)\n+        .push(Ty::Bound(0))\n+        // starting from ^2 because we want to start with ^1 outside of the\n+        // `dyn`, which is ^2 inside\n+        .fill_with_bound_vars(2)\n+        .build();\n+    let num_vars = target_substs.len();\n+    let target_trait_ref = TraitRef { trait_, substs: target_substs };\n+    let target_bounds = vec![GenericPredicate::Implemented(target_trait_ref)];\n+\n+    let self_substs = Substs::build_for_def(db, trait_).fill_with_bound_vars(0).build();\n+    let self_trait_ref = TraitRef { trait_, substs: self_substs };\n+    let where_clauses = vec![GenericPredicate::Implemented(self_trait_ref)];\n+\n+    let impl_substs =\n+        Substs::builder(2).push(self_ty).push(Ty::Dyn(target_bounds.clone().into())).build();\n+\n+    let trait_ref = TraitRef { trait_: unsize_trait, substs: impl_substs };\n+\n+    BuiltinImplData { num_vars, trait_ref, where_clauses, assoc_ty_values: Vec::new() }\n+}\n+\n+fn super_trait_object_unsize_impl_datum(\n+    db: &impl HirDatabase,\n+    krate: CrateId,\n+    data: UnsizeToSuperTraitObjectData,\n+) -> BuiltinImplData {\n+    // impl<T1, ...> Unsize<dyn SuperTrait> for dyn Trait<T1, ...>\n+\n+    let unsize_trait = get_unsize_trait(db, krate) // get unsize trait\n+        // the existence of the Unsize trait has been checked before\n+        .expect(\"Unsize trait missing\");\n+\n+    let self_substs = Substs::build_for_def(db, data.trait_).fill_with_bound_vars(0).build();\n+\n+    let num_vars = self_substs.len() - 1;\n+\n+    let self_trait_ref = TraitRef { trait_: data.trait_, substs: self_substs.clone() };\n+    let self_bounds = vec![GenericPredicate::Implemented(self_trait_ref.clone())];\n+\n+    // we need to go from our trait to the super trait, substituting type parameters\n+    let path = crate::utils::find_super_trait_path(db, data.trait_, data.super_trait);\n+\n+    let mut current_trait_ref = self_trait_ref;\n+    for t in path.into_iter().skip(1) {\n+        let bounds = db.generic_predicates(current_trait_ref.trait_.into());\n+        let super_trait_ref = bounds\n+            .iter()\n+            .find_map(|b| match &b.value {\n+                GenericPredicate::Implemented(tr)\n+                    if tr.trait_ == t && tr.substs[0] == Ty::Bound(0) =>\n+                {\n+                    Some(Binders { value: tr, num_binders: b.num_binders })\n+                }\n+                _ => None,\n+            })\n+            .expect(\"trait bound for known super trait not found\");\n+        current_trait_ref = super_trait_ref.cloned().subst(&current_trait_ref.substs);\n+    }\n+\n+    let super_bounds = vec![GenericPredicate::Implemented(current_trait_ref)];\n+\n+    let substs = Substs::builder(2)\n+        .push(Ty::Dyn(self_bounds.into()))\n+        .push(Ty::Dyn(super_bounds.into()))\n+        .build();\n+\n+    let trait_ref = TraitRef { trait_: unsize_trait, substs };\n+\n+    BuiltinImplData { num_vars, trait_ref, where_clauses: Vec::new(), assoc_ty_values: Vec::new() }\n+}\n+\n fn get_fn_trait(\n     db: &impl HirDatabase,\n     krate: CrateId,\n@@ -176,3 +355,11 @@ fn get_fn_trait(\n         _ => None,\n     }\n }\n+\n+fn get_unsize_trait(db: &impl HirDatabase, krate: CrateId) -> Option<TraitId> {\n+    let target = db.lang_item(krate, \"unsize\".into())?;\n+    match target {\n+        LangItemTarget::TraitId(t) => Some(t),\n+        _ => None,\n+    }\n+}"}, {"sha": "e1e430aeb09f1578a3dfe39f26e1e75d3c53ce90", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2cbe8a4c4be2a69b27c248ab96341c2336f983cd/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cbe8a4c4be2a69b27c248ab96341c2336f983cd/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=2cbe8a4c4be2a69b27c248ab96341c2336f983cd", "patch": "@@ -572,8 +572,10 @@ where\n             .collect();\n \n         let ty: Ty = from_chalk(self.db, parameters[0].assert_ty_ref().clone());\n+        let arg: Option<Ty> =\n+            parameters.get(1).map(|p| from_chalk(self.db, p.assert_ty_ref().clone()));\n \n-        builtin::get_builtin_impls(self.db, self.krate, &ty, trait_, |i| {\n+        builtin::get_builtin_impls(self.db, self.krate, &ty, &arg, trait_, |i| {\n             result.push(i.to_chalk(self.db))\n         });\n "}, {"sha": "463fd65b4e27ec979820881ece74b8a46c383270", "filename": "crates/ra_hir_ty/src/utils.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2cbe8a4c4be2a69b27c248ab96341c2336f983cd/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cbe8a4c4be2a69b27c248ab96341c2336f983cd/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Futils.rs?ref=2cbe8a4c4be2a69b27c248ab96341c2336f983cd", "patch": "@@ -62,6 +62,38 @@ pub(super) fn all_super_traits(db: &impl DefDatabase, trait_: TraitId) -> Vec<Tr\n     result\n }\n \n+/// Finds a path from a trait to one of its super traits. Returns an empty\n+/// vector if there is no path.\n+pub(super) fn find_super_trait_path(\n+    db: &impl DefDatabase,\n+    trait_: TraitId,\n+    super_trait: TraitId,\n+) -> Vec<TraitId> {\n+    let mut result = Vec::with_capacity(2);\n+    result.push(trait_);\n+    return if go(db, super_trait, &mut result) { result } else { Vec::new() };\n+\n+    fn go(db: &impl DefDatabase, super_trait: TraitId, path: &mut Vec<TraitId>) -> bool {\n+        let trait_ = *path.last().unwrap();\n+        if trait_ == super_trait {\n+            return true;\n+        }\n+\n+        for tt in direct_super_traits(db, trait_) {\n+            if path.contains(&tt) {\n+                continue;\n+            }\n+            path.push(tt);\n+            if go(db, super_trait, path) {\n+                return true;\n+            } else {\n+                path.pop();\n+            }\n+        }\n+        false\n+    }\n+}\n+\n pub(super) fn associated_type_by_name_including_super_traits(\n     db: &impl DefDatabase,\n     trait_: TraitId,"}]}