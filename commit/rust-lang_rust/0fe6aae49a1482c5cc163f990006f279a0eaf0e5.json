{"sha": "0fe6aae49a1482c5cc163f990006f279a0eaf0e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmZTZhYWU0OWExNDgyYzVjYzE2M2Y5OTAwMDZmMjc5YTBlYWYwZTU=", "commit": {"author": {"name": "QuietMisdreavus", "email": "grey@quietmisdreavus.net", "date": "2018-11-01T16:57:29Z"}, "committer": {"name": "QuietMisdreavus", "email": "grey@quietmisdreavus.net", "date": "2018-11-01T16:57:29Z"}, "message": "buffer errors from initial tokenization when parsing", "tree": {"sha": "3654cfa3d4d78ea5389bbc9d5aedb6f5ddabf129", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3654cfa3d4d78ea5389bbc9d5aedb6f5ddabf129"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0fe6aae49a1482c5cc163f990006f279a0eaf0e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0fe6aae49a1482c5cc163f990006f279a0eaf0e5", "html_url": "https://github.com/rust-lang/rust/commit/0fe6aae49a1482c5cc163f990006f279a0eaf0e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0fe6aae49a1482c5cc163f990006f279a0eaf0e5/comments", "author": {"login": "QuietMisdreavus", "id": 5217170, "node_id": "MDQ6VXNlcjUyMTcxNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/5217170?v=4", "gravatar_id": "", "url": "https://api.github.com/users/QuietMisdreavus", "html_url": "https://github.com/QuietMisdreavus", "followers_url": "https://api.github.com/users/QuietMisdreavus/followers", "following_url": "https://api.github.com/users/QuietMisdreavus/following{/other_user}", "gists_url": "https://api.github.com/users/QuietMisdreavus/gists{/gist_id}", "starred_url": "https://api.github.com/users/QuietMisdreavus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/QuietMisdreavus/subscriptions", "organizations_url": "https://api.github.com/users/QuietMisdreavus/orgs", "repos_url": "https://api.github.com/users/QuietMisdreavus/repos", "events_url": "https://api.github.com/users/QuietMisdreavus/events{/privacy}", "received_events_url": "https://api.github.com/users/QuietMisdreavus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "QuietMisdreavus", "id": 5217170, "node_id": "MDQ6VXNlcjUyMTcxNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/5217170?v=4", "gravatar_id": "", "url": "https://api.github.com/users/QuietMisdreavus", "html_url": "https://github.com/QuietMisdreavus", "followers_url": "https://api.github.com/users/QuietMisdreavus/followers", "following_url": "https://api.github.com/users/QuietMisdreavus/following{/other_user}", "gists_url": "https://api.github.com/users/QuietMisdreavus/gists{/gist_id}", "starred_url": "https://api.github.com/users/QuietMisdreavus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/QuietMisdreavus/subscriptions", "organizations_url": "https://api.github.com/users/QuietMisdreavus/orgs", "repos_url": "https://api.github.com/users/QuietMisdreavus/repos", "events_url": "https://api.github.com/users/QuietMisdreavus/events{/privacy}", "received_events_url": "https://api.github.com/users/QuietMisdreavus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a3b5e99addbda7e8c15aa1641f4d8ea517e1be4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a3b5e99addbda7e8c15aa1641f4d8ea517e1be4", "html_url": "https://github.com/rust-lang/rust/commit/8a3b5e99addbda7e8c15aa1641f4d8ea517e1be4"}], "stats": {"total": 86, "additions": 79, "deletions": 7}, "files": [{"sha": "06cb4fbd71602787933804c4a9375caa888723bd", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0fe6aae49a1482c5cc163f990006f279a0eaf0e5/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fe6aae49a1482c5cc163f990006f279a0eaf0e5/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=0fe6aae49a1482c5cc163f990006f279a0eaf0e5", "patch": "@@ -422,13 +422,20 @@ pub fn make_test(s: &str,\n \n         debug!(\"about to parse: \\n{}\", source);\n \n-        // FIXME(misdreavus): this can still emit a FatalError (and thus halt rustdoc prematurely)\n-        // if there is a lexing error in the first token\n-        let mut parser = parse::new_parser_from_source_str(&sess, filename, source);\n-\n         let mut found_main = false;\n         let mut found_extern_crate = cratename.is_none();\n \n+        let mut parser = match parse::maybe_new_parser_from_source_str(&sess, filename, source) {\n+            Ok(p) => p,\n+            Err(errs) => {\n+                for mut err in errs {\n+                    err.cancel();\n+                }\n+\n+                return (found_main, found_extern_crate);\n+            }\n+        };\n+\n         loop {\n             match parser.parse_item() {\n                 Ok(Some(item)) => {"}, {"sha": "dc7a9736b94d8a6cc997481dcd2d189069603e3e", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0fe6aae49a1482c5cc163f990006f279a0eaf0e5/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fe6aae49a1482c5cc163f990006f279a0eaf0e5/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=0fe6aae49a1482c5cc163f990006f279a0eaf0e5", "patch": "@@ -11,7 +11,7 @@\n use ast::{self, Ident};\n use syntax_pos::{self, BytePos, CharPos, Pos, Span, NO_EXPANSION};\n use source_map::{SourceMap, FilePathMapping};\n-use errors::{Applicability, FatalError, DiagnosticBuilder};\n+use errors::{Applicability, FatalError, Diagnostic, DiagnosticBuilder};\n use parse::{token, ParseSess};\n use str::char_at;\n use symbol::{Symbol, keywords};\n@@ -175,6 +175,16 @@ impl<'a> StringReader<'a> {\n         self.fatal_errs.clear();\n     }\n \n+    pub fn buffer_fatal_errors(&mut self) -> Vec<Diagnostic> {\n+        let mut buffer = Vec::new();\n+\n+        for err in self.fatal_errs.drain(..) {\n+            err.buffer(&mut buffer);\n+        }\n+\n+        buffer\n+    }\n+\n     pub fn peek(&self) -> TokenAndSpan {\n         // FIXME(pcwalton): Bad copy!\n         TokenAndSpan {\n@@ -251,6 +261,17 @@ impl<'a> StringReader<'a> {\n         Ok(sr)\n     }\n \n+    pub fn new_or_buffered_errs(sess: &'a ParseSess,\n+                                source_file: Lrc<syntax_pos::SourceFile>,\n+                                override_span: Option<Span>) -> Result<Self, Vec<Diagnostic>> {\n+        let mut sr = StringReader::new_raw(sess, source_file, override_span);\n+        if sr.advance_token().is_err() {\n+            Err(sr.buffer_fatal_errors())\n+        } else {\n+            Ok(sr)\n+        }\n+    }\n+\n     pub fn retokenize(sess: &'a ParseSess, mut span: Span) -> Self {\n         let begin = sess.source_map().lookup_byte_offset(span.lo());\n         let end = sess.source_map().lookup_byte_offset(span.hi());"}, {"sha": "5723c60e87404d9259858cb15e176ee290155c83", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0fe6aae49a1482c5cc163f990006f279a0eaf0e5/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fe6aae49a1482c5cc163f990006f279a0eaf0e5/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=0fe6aae49a1482c5cc163f990006f279a0eaf0e5", "patch": "@@ -15,7 +15,7 @@ use ast::{self, CrateConfig, NodeId};\n use early_buffered_lints::{BufferedEarlyLint, BufferedEarlyLintId};\n use source_map::{SourceMap, FilePathMapping};\n use syntax_pos::{Span, SourceFile, FileName, MultiSpan};\n-use errors::{Handler, ColorConfig, DiagnosticBuilder};\n+use errors::{Handler, ColorConfig, Diagnostic, DiagnosticBuilder};\n use feature_gate::UnstableFeatures;\n use parse::parser::Parser;\n use ptr::P;\n@@ -174,14 +174,25 @@ pub fn parse_stream_from_source_str(name: FileName, source: String, sess: &Parse\n     source_file_to_stream(sess, sess.source_map().new_source_file(name, source), override_span)\n }\n \n-// Create a new parser from a source string\n+/// Create a new parser from a source string\n pub fn new_parser_from_source_str(sess: &ParseSess, name: FileName, source: String)\n                                       -> Parser {\n     let mut parser = source_file_to_parser(sess, sess.source_map().new_source_file(name, source));\n     parser.recurse_into_file_modules = false;\n     parser\n }\n \n+/// Create a new parser from a source string. Returns any buffered errors from lexing the initial\n+/// token stream.\n+pub fn maybe_new_parser_from_source_str(sess: &ParseSess, name: FileName, source: String)\n+    -> Result<Parser, Vec<Diagnostic>>\n+{\n+    let mut parser = maybe_source_file_to_parser(sess,\n+                                                 sess.source_map().new_source_file(name, source))?;\n+    parser.recurse_into_file_modules = false;\n+    Ok(parser)\n+}\n+\n /// Create a new parser, handling errors as appropriate\n /// if the file doesn't exist\n pub fn new_parser_from_file<'a>(sess: &'a ParseSess, path: &Path) -> Parser<'a> {\n@@ -214,6 +225,21 @@ fn source_file_to_parser(sess: & ParseSess, source_file: Lrc<SourceFile>) -> Par\n     parser\n }\n \n+/// Given a source_file and config, return a parser. Returns any buffered errors from lexing the\n+/// initial token stream.\n+fn maybe_source_file_to_parser(sess: &ParseSess, source_file: Lrc<SourceFile>)\n+    -> Result<Parser, Vec<Diagnostic>>\n+{\n+    let end_pos = source_file.end_pos;\n+    let mut parser = stream_to_parser(sess, maybe_file_to_stream(sess, source_file, None)?);\n+\n+    if parser.token == token::Eof && parser.span.is_dummy() {\n+        parser.span = Span::new(end_pos, end_pos, parser.span.ctxt());\n+    }\n+\n+    Ok(parser)\n+}\n+\n // must preserve old name for now, because quote! from the *existing*\n // compiler expands into it\n pub fn new_parser_from_tts(sess: &ParseSess, tts: Vec<TokenTree>) -> Parser {\n@@ -248,6 +274,24 @@ pub fn source_file_to_stream(sess: &ParseSess,\n     panictry!(srdr.parse_all_token_trees())\n }\n \n+/// Given a source file, produce a sequence of token-trees. Returns any buffered errors from\n+/// parsing the token tream.\n+pub fn maybe_file_to_stream(sess: &ParseSess,\n+                            source_file: Lrc<SourceFile>,\n+                            override_span: Option<Span>) -> Result<TokenStream, Vec<Diagnostic>> {\n+    let mut srdr = lexer::StringReader::new_or_buffered_errs(sess, source_file, override_span)?;\n+    srdr.real_token();\n+\n+    match srdr.parse_all_token_trees() {\n+        Ok(stream) => Ok(stream),\n+        Err(err) => {\n+            let mut buffer = Vec::with_capacity(1);\n+            err.buffer(&mut buffer);\n+            Err(buffer)\n+        }\n+    }\n+}\n+\n /// Given stream and the `ParseSess`, produce a parser\n pub fn stream_to_parser(sess: &ParseSess, stream: TokenStream) -> Parser {\n     Parser::new(sess, stream, None, true, false)"}]}