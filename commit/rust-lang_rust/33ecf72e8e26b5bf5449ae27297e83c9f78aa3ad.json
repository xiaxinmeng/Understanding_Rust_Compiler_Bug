{"sha": "33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzZWNmNzJlOGUyNmI1YmY1NDQ5YWUyNzI5N2U4M2M5Zjc4YWEzYWQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-05-13T14:11:52Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-06-27T13:39:52Z"}, "message": "rustc: move the PolyFnSig out of TyFnDef.", "tree": {"sha": "270622bfa20dcbe721aa55550b7e42839bfcb0b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/270622bfa20dcbe721aa55550b7e42839bfcb0b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "html_url": "https://github.com/rust-lang/rust/commit/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e53a03d15bfd425c99fc4f5a7d6a1ec71cbe720", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e53a03d15bfd425c99fc4f5a7d6a1ec71cbe720", "html_url": "https://github.com/rust-lang/rust/commit/8e53a03d15bfd425c99fc4f5a7d6a1ec71cbe720"}], "stats": {"total": 781, "additions": 427, "deletions": 354}, "files": [{"sha": "4f365a97f4ceba1719af50f475bf9b06e1068263", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -524,10 +524,9 @@ for ty::TypeVariants<'tcx>\n                 region.hash_stable(hcx, hasher);\n                 pointee_ty.hash_stable(hcx, hasher);\n             }\n-            TyFnDef(def_id, substs, ref sig) => {\n+            TyFnDef(def_id, substs) => {\n                 def_id.hash_stable(hcx, hasher);\n                 substs.hash_stable(hcx, hasher);\n-                sig.hash_stable(hcx, hasher);\n             }\n             TyFnPtr(ref sig) => {\n                 sig.hash_stable(hcx, hasher);"}, {"sha": "eab5a8f910331184187caac0a7dd822df61afd86", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -12,7 +12,7 @@\n //! `unsafe`.\n use self::RootUnsafeContext::*;\n \n-use ty::{self, Ty, TyCtxt};\n+use ty::{self, TyCtxt};\n use lint;\n \n use syntax::ast;\n@@ -40,14 +40,6 @@ enum RootUnsafeContext {\n     UnsafeBlock(ast::NodeId),\n }\n \n-fn type_is_unsafe_function(ty: Ty) -> bool {\n-    match ty.sty {\n-        ty::TyFnDef(.., f) |\n-        ty::TyFnPtr(f) => f.unsafety() == hir::Unsafety::Unsafe,\n-        _ => false,\n-    }\n-}\n-\n struct EffectCheckVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n@@ -174,10 +166,11 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n                 let def_id = self.tables.type_dependent_defs[&expr.id].def_id();\n-                let base_type = self.tcx.type_of(def_id);\n-                debug!(\"effect: method call case, base type is {:?}\",\n-                        base_type);\n-                if type_is_unsafe_function(base_type) {\n+                let sig = self.tcx.fn_sig(def_id);\n+                debug!(\"effect: method call case, signature is {:?}\",\n+                        sig);\n+\n+                if sig.0.unsafety == hir::Unsafety::Unsafe {\n                     self.require_unsafe(expr.span,\n                                         \"invocation of unsafe method\")\n                 }\n@@ -186,8 +179,13 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n                 let base_type = self.tables.expr_ty_adjusted(base);\n                 debug!(\"effect: call case, base type is {:?}\",\n                         base_type);\n-                if type_is_unsafe_function(base_type) {\n-                    self.require_unsafe(expr.span, \"call to unsafe function\")\n+                match base_type.sty {\n+                    ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+                        if base_type.fn_sig(self.tcx).unsafety() == hir::Unsafety::Unsafe {\n+                            self.require_unsafe(expr.span, \"call to unsafe function\")\n+                        }\n+                    }\n+                    _ => {}\n                 }\n             }\n             hir::ExprUnary(hir::UnDeref, ref base) => {"}, {"sha": "fde207e4b2f79f75922a2fb36ef74ce9739ad07b", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -66,11 +66,8 @@ fn unpack_option_like<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n impl<'a, 'tcx> ExprVisitor<'a, 'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n-        let intrinsic = match self.tcx.type_of(def_id).sty {\n-            ty::TyFnDef(.., bfty) => bfty.abi() == RustIntrinsic,\n-            _ => return false\n-        };\n-        intrinsic && self.tcx.item_name(def_id) == \"transmute\"\n+        self.tcx.fn_sig(def_id).abi() == RustIntrinsic &&\n+        self.tcx.item_name(def_id) == \"transmute\"\n     }\n \n     fn check_transmute(&self, span: Span, from: Ty<'tcx>, to: Ty<'tcx>) {\n@@ -153,22 +150,14 @@ impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n         } else {\n             Def::Err\n         };\n-        match def {\n-            Def::Fn(did) if self.def_id_is_transmute(did) => {\n+        if let Def::Fn(did) = def {\n+            if self.def_id_is_transmute(did) {\n                 let typ = self.tables.node_id_to_type(expr.id);\n-                let typ = self.tcx.lift_to_global(&typ).unwrap();\n-                match typ.sty {\n-                    ty::TyFnDef(.., sig) if sig.abi() == RustIntrinsic => {\n-                        let from = sig.inputs().skip_binder()[0];\n-                        let to = *sig.output().skip_binder();\n-                        self.check_transmute(expr.span, from, to);\n-                    }\n-                    _ => {\n-                        span_bug!(expr.span, \"transmute wasn't a bare fn?!\");\n-                    }\n-                }\n+                let sig = typ.fn_sig(self.tcx);\n+                let from = sig.inputs().skip_binder()[0];\n+                let to = *sig.output().skip_binder();\n+                self.check_transmute(expr.span, from, to);\n             }\n-            _ => {}\n         }\n \n         intravisit::walk_expr(self, expr);"}, {"sha": "c6c052fa4b1bc100b8bd034126464cd2d71d4bc8", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -260,7 +260,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         // The `Self` type is erased, so it should not appear in list of\n         // arguments or return type apart from the receiver.\n-        let ref sig = self.type_of(method.def_id).fn_sig();\n+        let ref sig = self.fn_sig(method.def_id);\n         for input_ty in &sig.skip_binder().inputs()[1..] {\n             if self.contains_illegal_self_type_reference(trait_def_id, input_ty) {\n                 return Some(MethodViolationCode::ReferencesSelf);"}, {"sha": "c356e53234d9c3e3248eb17138fce58c9f012e19", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -1137,9 +1137,19 @@ fn confirm_fn_pointer_candidate<'cx, 'gcx, 'tcx>(\n     -> Progress<'tcx>\n {\n     let fn_type = selcx.infcx().shallow_resolve(fn_pointer_vtable.fn_ty);\n-    let sig = fn_type.fn_sig();\n+    let sig = fn_type.fn_sig(selcx.tcx());\n+    let Normalized {\n+        value: sig,\n+        obligations\n+    } = normalize_with_depth(selcx,\n+                             obligation.param_env,\n+                             obligation.cause.clone(),\n+                             obligation.recursion_depth+1,\n+                             &sig);\n+\n     confirm_callable_candidate(selcx, obligation, sig, util::TupleArgumentsFlag::Yes)\n         .with_addl_obligations(fn_pointer_vtable.nested)\n+        .with_addl_obligations(obligations)\n }\n \n fn confirm_closure_candidate<'cx, 'gcx, 'tcx>("}, {"sha": "a66b6b863541e2446170291ace748b925f95c010", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -1404,19 +1404,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             // provide an impl, but only for suitable `fn` pointers\n-            ty::TyFnDef(.., ty::Binder(ty::FnSig {\n-                unsafety: hir::Unsafety::Normal,\n-                abi: Abi::Rust,\n-                variadic: false,\n-                ..\n-            })) |\n-            ty::TyFnPtr(ty::Binder(ty::FnSig {\n-                unsafety: hir::Unsafety::Normal,\n-                abi: Abi::Rust,\n-                variadic: false,\n-                ..\n-            })) => {\n-                candidates.vec.push(FnPointerCandidate);\n+            ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+                if let ty::Binder(ty::FnSig {\n+                    unsafety: hir::Unsafety::Normal,\n+                    abi: Abi::Rust,\n+                    variadic: false,\n+                    ..\n+                }) = self_ty.fn_sig(self.tcx()) {\n+                    candidates.vec.push(FnPointerCandidate);\n+                }\n             }\n \n             _ => { }\n@@ -2348,19 +2344,26 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         // ok to skip binder; it is reintroduced below\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n-        let sig = self_ty.fn_sig();\n+        let sig = self_ty.fn_sig(self.tcx());\n         let trait_ref =\n             self.tcx().closure_trait_ref_and_return_type(obligation.predicate.def_id(),\n                                                          self_ty,\n                                                          sig,\n                                                          util::TupleArgumentsFlag::Yes)\n             .map_bound(|(trait_ref, _)| trait_ref);\n \n+        let Normalized { value: trait_ref, obligations } =\n+            project::normalize_with_depth(self,\n+                                          obligation.param_env,\n+                                          obligation.cause.clone(),\n+                                          obligation.recursion_depth + 1,\n+                                          &trait_ref);\n+\n         self.confirm_poly_trait_refs(obligation.cause.clone(),\n                                      obligation.param_env,\n                                      obligation.predicate.to_poly_trait_ref(),\n                                      trait_ref)?;\n-        Ok(VtableFnPointerData { fn_ty: self_ty, nested: vec![] })\n+        Ok(VtableFnPointerData { fn_ty: self_ty, nested: obligations })\n     }\n \n     fn confirm_closure_candidate(&mut self,"}, {"sha": "5f869fc5567ee186d58a7641505634de882a94b9", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -1378,9 +1378,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_fn_def(self, def_id: DefId,\n-                     substs: &'tcx Substs<'tcx>,\n-                     fty: PolyFnSig<'tcx>) -> Ty<'tcx> {\n-        self.mk_ty(TyFnDef(def_id, substs, fty))\n+                     substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+        self.mk_ty(TyFnDef(def_id, substs))\n     }\n \n     pub fn mk_fn_ptr(self, fty: PolyFnSig<'tcx>) -> Ty<'tcx> {"}, {"sha": "68f85ba7d33e23dc87beb3ab93134b71352c6edd", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -68,14 +68,15 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n             // view of possibly unifying\n             simplify_type(tcx, mt.ty, can_simplify_params)\n         }\n+        ty::TyFnDef(def_id, _) |\n         ty::TyClosure(def_id, _) => {\n             Some(ClosureSimplifiedType(def_id))\n         }\n         ty::TyNever => Some(NeverSimplifiedType),\n         ty::TyTuple(ref tys, _) => {\n             Some(TupleSimplifiedType(tys.len()))\n         }\n-        ty::TyFnDef(.., ref f) | ty::TyFnPtr(ref f) => {\n+        ty::TyFnPtr(ref f) => {\n             Some(FunctionSimplifiedType(f.skip_binder().inputs().len()))\n         }\n         ty::TyProjection(_) | ty::TyParam(_) => {"}, {"sha": "d5aa9f55ff0c4e34beb5942070f79ba6bee1f78b", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -155,9 +155,8 @@ impl FlagComputation {\n                 self.add_tys(&ts[..]);\n             }\n \n-            &ty::TyFnDef(_, substs, f) => {\n+            &ty::TyFnDef(_, substs) => {\n                 self.add_substs(substs);\n-                self.add_fn_sig(f);\n             }\n \n             &ty::TyFnPtr(f) => {"}, {"sha": "b9896e0cecf5dac93d19cebe75950af51194daf8", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -348,7 +348,7 @@ pub fn characteristic_def_id_of_type(ty: Ty) -> Option<DefId> {\n                                       .filter_map(|ty| characteristic_def_id_of_type(ty))\n                                       .next(),\n \n-        ty::TyFnDef(def_id, ..) |\n+        ty::TyFnDef(def_id, _) |\n         ty::TyClosure(def_id, _) => Some(def_id),\n \n         ty::TyBool |"}, {"sha": "f4d0867d130001846310f4bf0ce373ed5ad96ff1", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -206,7 +206,7 @@ impl AssociatedItem {\n                 // late-bound regions, and we don't want method signatures to show up\n                 // `as for<'r> fn(&'r MyType)`.  Pretty-printing handles late-bound\n                 // regions just fine, showing `fn(&MyType)`.\n-                format!(\"{}\", tcx.type_of(self.def_id).fn_sig().skip_binder())\n+                format!(\"{}\", tcx.fn_sig(self.def_id).skip_binder())\n             }\n             ty::AssociatedKind::Type => format!(\"type {};\", self.name.to_string()),\n             ty::AssociatedKind::Const => {"}, {"sha": "9345e5047015d7c16e8fc05d36b91acb15a72a23", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -440,13 +440,11 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             }\n         }\n \n-        (&ty::TyFnDef(a_def_id, a_substs, a_fty),\n-         &ty::TyFnDef(b_def_id, b_substs, b_fty))\n+        (&ty::TyFnDef(a_def_id, a_substs), &ty::TyFnDef(b_def_id, b_substs))\n             if a_def_id == b_def_id =>\n         {\n             let substs = relate_substs(relation, None, a_substs, b_substs)?;\n-            let fty = relation.relate(&a_fty, &b_fty)?;\n-            Ok(tcx.mk_fn_def(a_def_id, substs, fty))\n+            Ok(tcx.mk_fn_def(a_def_id, substs))\n         }\n \n         (&ty::TyFnPtr(a_fty), &ty::TyFnPtr(b_fty)) =>"}, {"sha": "d05262965d7fd6daf8505f23bcdd7bb51c842c8b", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -531,10 +531,8 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyDynamic(ref trait_ty, ref region) =>\n                 ty::TyDynamic(trait_ty.fold_with(folder), region.fold_with(folder)),\n             ty::TyTuple(ts, defaulted) => ty::TyTuple(ts.fold_with(folder), defaulted),\n-            ty::TyFnDef(def_id, substs, f) => {\n-                ty::TyFnDef(def_id,\n-                            substs.fold_with(folder),\n-                            f.fold_with(folder))\n+            ty::TyFnDef(def_id, substs) => {\n+                ty::TyFnDef(def_id, substs.fold_with(folder))\n             }\n             ty::TyFnPtr(f) => ty::TyFnPtr(f.fold_with(folder)),\n             ty::TyRef(ref r, tm) => {\n@@ -568,9 +566,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyDynamic(ref trait_ty, ref reg) =>\n                 trait_ty.visit_with(visitor) || reg.visit_with(visitor),\n             ty::TyTuple(ts, _) => ts.visit_with(visitor),\n-            ty::TyFnDef(_, substs, ref f) => {\n-                substs.visit_with(visitor) || f.visit_with(visitor)\n-            }\n+            ty::TyFnDef(_, substs) => substs.visit_with(visitor),\n             ty::TyFnPtr(ref f) => f.visit_with(visitor),\n             ty::TyRef(r, ref tm) => r.visit_with(visitor) || tm.visit_with(visitor),\n             ty::TyClosure(_did, ref substs) => substs.visit_with(visitor),"}, {"sha": "ed3312d88a38420babc569919be055fe161b30f3", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -14,7 +14,7 @@ use hir::def_id::DefId;\n use hir::map::DefPathHash;\n \n use middle::region;\n-use ty::subst::Substs;\n+use ty::subst::{Substs, Subst};\n use ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n use ty::{Slice, TyS};\n use ty::subst::Kind;\n@@ -138,7 +138,7 @@ pub enum TypeVariants<'tcx> {\n \n     /// The anonymous type of a function declaration/definition. Each\n     /// function has a unique type.\n-    TyFnDef(DefId, &'tcx Substs<'tcx>, PolyFnSig<'tcx>),\n+    TyFnDef(DefId, &'tcx Substs<'tcx>),\n \n     /// A pointer to a function.  Written as `fn() -> i32`.\n     TyFnPtr(PolyFnSig<'tcx>),\n@@ -1329,9 +1329,12 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn fn_sig(&self) -> PolyFnSig<'tcx> {\n+    pub fn fn_sig(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> PolyFnSig<'tcx> {\n         match self.sty {\n-            TyFnDef(.., f) | TyFnPtr(f) => f,\n+            TyFnDef(def_id, substs) => {\n+                tcx.fn_sig(def_id).subst(tcx, substs)\n+            }\n+            TyFnPtr(f) => f,\n             _ => bug!(\"Ty::fn_sig() called on non-fn type: {:?}\", self)\n         }\n     }"}, {"sha": "98ef7918fef82ac263afe005a05ddd94a86e0e93", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -679,7 +679,7 @@ impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n             TyRef(_, m) => self.hash(m.mutbl),\n             TyClosure(def_id, _) |\n             TyAnon(def_id, _) |\n-            TyFnDef(def_id, ..) => self.def_id(def_id),\n+            TyFnDef(def_id, _) => self.def_id(def_id),\n             TyAdt(d, _) => self.def_id(d.did),\n             TyFnPtr(f) => {\n                 self.hash(f.unsafety());"}, {"sha": "71844abfe534c14b8e6cf5dcd0f6e97de1325467", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -115,9 +115,8 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n         ty::TyTuple(ts, _) => {\n             stack.extend(ts.iter().cloned().rev());\n         }\n-        ty::TyFnDef(_, substs, ft) => {\n+        ty::TyFnDef(_, substs) => {\n             stack.extend(substs.types().rev());\n-            push_sig_subtypes(stack, ft);\n         }\n         ty::TyFnPtr(ft) => {\n             push_sig_subtypes(stack, ft);"}, {"sha": "eb6bffc29c56171ecc37cd1d07a7cc0571defb39", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -753,8 +753,14 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                 }\n                 write!(f, \")\")\n             }\n-            TyFnDef(def_id, substs, ref bare_fn) => {\n-                write!(f, \"{} {{\", bare_fn.0)?;\n+            TyFnDef(def_id, substs) => {\n+                ty::tls::with(|tcx| {\n+                    let mut sig = tcx.fn_sig(def_id);\n+                    if let Some(substs) = tcx.lift(&substs) {\n+                        sig = sig.subst(tcx, substs);\n+                    }\n+                    write!(f, \"{} {{\", sig.0)\n+                })?;\n                 parameterized(f, substs, def_id, &[])?;\n                 write!(f, \"}}\")\n             }"}, {"sha": "4bef191b113bd66816416df4614fe65146c6c794", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/sanity_check.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -161,18 +161,13 @@ fn is_rustc_peek<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            terminator: &'a Option<mir::Terminator<'tcx>>)\n                            -> Option<(&'a [mir::Operand<'tcx>], Span)> {\n     if let Some(mir::Terminator { ref kind, source_info, .. }) = *terminator {\n-        if let mir::TerminatorKind::Call { func: ref oper, ref args, .. } = *kind\n-        {\n-            if let mir::Operand::Constant(ref func) = *oper\n-            {\n-                if let ty::TyFnDef(def_id, _, sig) = func.ty.sty\n-                {\n-                    let abi = sig.abi();\n+        if let mir::TerminatorKind::Call { func: ref oper, ref args, .. } = *kind {\n+            if let mir::Operand::Constant(ref func) = *oper {\n+                if let ty::TyFnDef(def_id, _) = func.ty.sty {\n+                    let abi = tcx.fn_sig(def_id).abi();\n                     let name = tcx.item_name(def_id);\n-                    if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n-                        if name == \"rustc_peek\" {\n-                            return Some((args, source_info.span));\n-                        }\n+                    if abi == Abi::RustIntrinsic &&  name == \"rustc_peek\" {\n+                        return Some((args, source_info.span));\n                     }\n                 }\n             }"}, {"sha": "0a966b0c170712dceabb786c3b72e1e8f81bcc7f", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -12,7 +12,7 @@ use eval;\n \n use rustc::middle::const_val::{ConstEvalErr, ConstVal};\n use rustc::mir::{Field, BorrowKind, Mutability};\n-use rustc::ty::{self, TyCtxt, AdtDef, Ty, TypeVariants, Region};\n+use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n use rustc::ty::subst::{Substs, Kind};\n use rustc::hir::{self, PatKind, RangeEnd};\n use rustc::hir::def::{Def, CtorKind};\n@@ -549,8 +549,8 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                 let adt_def = self.tcx.adt_def(enum_id);\n                 if adt_def.variants.len() > 1 {\n                     let substs = match ty.sty {\n-                        TypeVariants::TyAdt(_, substs) => substs,\n-                        TypeVariants::TyFnDef(_, substs, _) => substs,\n+                        ty::TyAdt(_, substs) |\n+                        ty::TyFnDef(_, substs) => substs,\n                         _ => bug!(\"inappropriate type for def: {:?}\", ty.sty),\n                     };\n                     PatternKind::Variant {"}, {"sha": "ad154f9b8153106b73263b07b5fa92f1a2ef7198", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -1154,24 +1154,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n                 if !def_id_is_transmute(cx, did) {\n                     return None;\n                 }\n-                let typ = cx.tables.node_id_to_type(expr.id);\n-                match typ.sty {\n-                    ty::TyFnDef(.., bare_fn) if bare_fn.abi() == RustIntrinsic => {\n-                        let from = bare_fn.inputs().skip_binder()[0];\n-                        let to = *bare_fn.output().skip_binder();\n-                        return Some((&from.sty, &to.sty));\n-                    }\n-                    _ => (),\n-                }\n+                let sig = cx.tables.node_id_to_type(expr.id).fn_sig(cx.tcx);\n+                let from = sig.inputs().skip_binder()[0];\n+                let to = *sig.output().skip_binder();\n+                return Some((&from.sty, &to.sty));\n             }\n             None\n         }\n \n         fn def_id_is_transmute(cx: &LateContext, def_id: DefId) -> bool {\n-            match cx.tcx.type_of(def_id).sty {\n-                ty::TyFnDef(.., bfty) if bfty.abi() == RustIntrinsic => (),\n-                _ => return false,\n-            }\n+            cx.tcx.fn_sig(def_id).abi() == RustIntrinsic &&\n             cx.tcx.item_name(def_id) == \"transmute\"\n         }\n     }"}, {"sha": "ac3977bd216e7a4587f293ffb4c961635c391766", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -659,7 +659,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n     fn check_foreign_fn(&mut self, id: ast::NodeId, decl: &hir::FnDecl) {\n         let def_id = self.cx.tcx.hir.local_def_id(id);\n-        let sig = self.cx.tcx.type_of(def_id).fn_sig();\n+        let sig = self.cx.tcx.fn_sig(def_id);\n         let sig = self.cx.tcx.erase_late_bound_regions(&sig);\n \n         for (input_ty, input_hir) in sig.inputs().iter().zip(&decl.inputs) {"}, {"sha": "3e6d06ec86ff89530f3ca014e92db8f870300997", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -1085,13 +1085,19 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn fn_sig(&self,\n-                  closure_id: DefIndex,\n+                  id: DefIndex,\n                   tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                   -> ty::PolyFnSig<'tcx> {\n-        match self.entry(closure_id).kind {\n-            EntryKind::Closure(data) => data.decode(self).sig.decode((self, tcx)),\n+        let sig = match self.entry(id).kind {\n+            EntryKind::Fn(data) |\n+            EntryKind::ForeignFn(data) => data.decode(self).sig,\n+            EntryKind::Method(data) => data.decode(self).fn_data.sig,\n+            EntryKind::Variant(data) |\n+            EntryKind::Struct(data, _) => data.decode(self).ctor_sig.unwrap(),\n+            EntryKind::Closure(data) => data.decode(self).sig,\n             _ => bug!(),\n-        }\n+        };\n+        sig.decode((self, tcx))\n     }\n \n     #[inline]"}, {"sha": "34b25a4b7e4235ce315d083a2b82036489f08aaa", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -16,6 +16,7 @@ use schema::*;\n use rustc::middle::cstore::{LinkMeta, LinkagePreference, NativeLibrary,\n                             EncodedMetadata, EncodedMetadataHashes,\n                             EncodedMetadataHash};\n+use rustc::hir::def::CtorKind;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId, LOCAL_CRATE};\n use rustc::hir::map::definitions::{DefPathTable, GlobalMetaDataKind};\n use rustc::ich::Fingerprint;\n@@ -499,6 +500,11 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n             struct_ctor: None,\n+            ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n+                Some(self.lazy(&tcx.fn_sig(def_id)))\n+            } else {\n+                None\n+            }\n         };\n \n         let enum_id = tcx.hir.as_local_node_id(enum_did).unwrap();\n@@ -617,6 +623,11 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n             struct_ctor: Some(def_id.index),\n+            ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n+                Some(self.lazy(&tcx.fn_sig(def_id)))\n+            } else {\n+                None\n+            }\n         };\n \n         let struct_id = tcx.hir.as_local_node_id(adt_def_id).unwrap();\n@@ -695,7 +706,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                     };\n                     FnData {\n                         constness: hir::Constness::NotConst,\n-                        arg_names: arg_names\n+                        arg_names: arg_names,\n+                        sig: self.lazy(&tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n@@ -747,6 +759,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n     fn encode_info_for_impl_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n         debug!(\"IsolatedEncoder::encode_info_for_impl_item({:?})\", def_id);\n+        let tcx = self.tcx;\n+\n         let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n         let ast_item = self.tcx.hir.expect_impl_item(node_id);\n         let impl_item = self.tcx.associated_item(def_id);\n@@ -768,6 +782,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                     FnData {\n                         constness: sig.constness,\n                         arg_names: self.encode_fn_arg_names_for_body(body),\n+                        sig: self.lazy(&tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n@@ -881,6 +896,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 let data = FnData {\n                     constness: constness,\n                     arg_names: self.encode_fn_arg_names_for_body(body),\n+                    sig: self.lazy(&tcx.fn_sig(def_id)),\n                 };\n \n                 EntryKind::Fn(self.lazy(&data))\n@@ -910,6 +926,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     struct_ctor: struct_ctor,\n+                    ctor_sig: None,\n                 }), repr_options)\n             }\n             hir::ItemUnion(..) => {\n@@ -920,6 +937,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     struct_ctor: None,\n+                    ctor_sig: None,\n                 }), repr_options)\n             }\n             hir::ItemDefaultImpl(..) => {\n@@ -1363,6 +1381,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 let data = FnData {\n                     constness: hir::Constness::NotConst,\n                     arg_names: self.encode_fn_arg_names(names),\n+                    sig: self.lazy(&tcx.fn_sig(def_id)),\n                 };\n                 EntryKind::ForeignFn(self.lazy(&data))\n             }"}, {"sha": "9ef5b9408303d7f886ad74a3a145e2a872d6665b", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -343,18 +343,18 @@ pub enum EntryKind<'tcx> {\n     Type,\n     Enum(ReprOptions),\n     Field,\n-    Variant(Lazy<VariantData>),\n-    Struct(Lazy<VariantData>, ReprOptions),\n-    Union(Lazy<VariantData>, ReprOptions),\n-    Fn(Lazy<FnData>),\n-    ForeignFn(Lazy<FnData>),\n+    Variant(Lazy<VariantData<'tcx>>),\n+    Struct(Lazy<VariantData<'tcx>>, ReprOptions),\n+    Union(Lazy<VariantData<'tcx>>, ReprOptions),\n+    Fn(Lazy<FnData<'tcx>>),\n+    ForeignFn(Lazy<FnData<'tcx>>),\n     Mod(Lazy<ModData>),\n     MacroDef(Lazy<MacroDef>),\n     Closure(Lazy<ClosureData<'tcx>>),\n     Trait(Lazy<TraitData<'tcx>>),\n     Impl(Lazy<ImplData<'tcx>>),\n     DefaultImpl(Lazy<ImplData<'tcx>>),\n-    Method(Lazy<MethodData>),\n+    Method(Lazy<MethodData<'tcx>>),\n     AssociatedType(AssociatedContainer),\n     AssociatedConst(AssociatedContainer, u8),\n }\n@@ -439,27 +439,33 @@ pub struct MacroDef {\n impl_stable_hash_for!(struct MacroDef { body, legacy });\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct FnData {\n+pub struct FnData<'tcx> {\n     pub constness: hir::Constness,\n     pub arg_names: LazySeq<ast::Name>,\n+    pub sig: Lazy<ty::PolyFnSig<'tcx>>,\n }\n \n-impl_stable_hash_for!(struct FnData { constness, arg_names });\n+impl_stable_hash_for!(struct FnData<'tcx> { constness, arg_names, sig });\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct VariantData {\n+pub struct VariantData<'tcx> {\n     pub ctor_kind: CtorKind,\n     pub discr: ty::VariantDiscr,\n \n     /// If this is a struct's only variant, this\n     /// is the index of the \"struct ctor\" item.\n     pub struct_ctor: Option<DefIndex>,\n+\n+    /// If this is a tuple struct or variant\n+    /// ctor, this is its \"function\" signature.\n+    pub ctor_sig: Option<Lazy<ty::PolyFnSig<'tcx>>>,\n }\n \n-impl_stable_hash_for!(struct VariantData {\n+impl_stable_hash_for!(struct VariantData<'tcx> {\n     ctor_kind,\n     discr,\n-    struct_ctor\n+    struct_ctor,\n+    ctor_sig\n });\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -543,12 +549,12 @@ impl AssociatedContainer {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct MethodData {\n-    pub fn_data: FnData,\n+pub struct MethodData<'tcx> {\n+    pub fn_data: FnData<'tcx>,\n     pub container: AssociatedContainer,\n     pub has_self: bool,\n }\n-impl_stable_hash_for!(struct MethodData { fn_data, container, has_self });\n+impl_stable_hash_for!(struct MethodData<'tcx> { fn_data, container, has_self });\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ClosureData<'tcx> {"}, {"sha": "326c1df69ebebd364c4990d2cadccd097c64985c", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -205,11 +205,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // FIXME(canndrew): This is_never should probably be an is_uninhabited\n                 let diverges = expr.ty.is_never();\n                 let intrinsic = match ty.sty {\n-                    ty::TyFnDef(def_id, _, ref f) if\n-                        f.abi() == Abi::RustIntrinsic ||\n-                        f.abi() == Abi::PlatformIntrinsic =>\n-                    {\n-                        Some(this.hir.tcx().item_name(def_id).as_str())\n+                    ty::TyFnDef(def_id, _)  => {\n+                        let f = ty.fn_sig(this.hir.tcx());\n+                        if f.abi() == Abi::RustIntrinsic ||\n+                           f.abi() == Abi::PlatformIntrinsic {\n+                            Some(this.hir.tcx().item_name(def_id).as_str())\n+                        } else {\n+                            None\n+                        }\n                     }\n                     _ => None\n                 };"}, {"sha": "0010f312ef9852e13bfe166f4c0a0c6768fa76cb", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -19,7 +19,6 @@ use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, AdtKind, VariantDef, Ty};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use rustc::ty::cast::CastKind as TyCastKind;\n-use rustc::ty::subst::Subst;\n use rustc::hir;\n \n impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n@@ -586,7 +585,7 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     });\n     Expr {\n         temp_lifetime: temp_lifetime,\n-        ty: cx.tcx.type_of(def_id).subst(cx.tcx, substs),\n+        ty: cx.tcx().mk_fn_def(def_id, substs),\n         span: expr.span,\n         kind: ExprKind::Literal {\n             literal: Literal::Value {"}, {"sha": "11ad5d1509d29bcd17b2cd0bb1c541986de4cf31", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -58,7 +58,7 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n             // types in the MIR. They will be substituted again with\n             // the param-substs, but because they are concrete, this\n             // will not do any harm.\n-            let sig = tcx.erase_late_bound_regions(&ty.fn_sig());\n+            let sig = tcx.erase_late_bound_regions(&ty.fn_sig(tcx));\n             let arg_tys = sig.inputs();\n \n             build_call_shim(\n@@ -153,8 +153,8 @@ fn build_drop_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n     } else {\n         Substs::identity_for_item(tcx, def_id)\n     };\n-    let fn_ty = tcx.type_of(def_id).subst(tcx, substs);\n-    let sig = tcx.erase_late_bound_regions(&fn_ty.fn_sig());\n+    let sig = tcx.fn_sig(def_id).subst(tcx, substs);\n+    let sig = tcx.erase_late_bound_regions(&sig);\n     let span = tcx.def_span(def_id);\n \n     let source_info = SourceInfo { span, scope: ARGUMENT_VISIBILITY_SCOPE };\n@@ -276,8 +276,8 @@ fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n             call_kind={:?}, untuple_args={:?})\",\n            def_id, rcvr_adjustment, call_kind, untuple_args);\n \n-    let fn_ty = tcx.type_of(def_id);\n-    let sig = tcx.erase_late_bound_regions(&fn_ty.fn_sig());\n+    let sig = tcx.fn_sig(def_id);\n+    let sig = tcx.erase_late_bound_regions(&sig);\n     let span = tcx.def_span(def_id);\n \n     debug!(\"build_call_shim: sig={:?}\", sig);\n@@ -409,11 +409,8 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n {\n     let tcx = infcx.tcx;\n     let def_id = tcx.hir.local_def_id(ctor_id);\n-    let sig = match tcx.type_of(def_id).sty {\n-        ty::TyFnDef(_, _, fty) => tcx.no_late_bound_regions(&fty)\n-            .expect(\"LBR in ADT constructor signature\"),\n-        _ => bug!(\"unexpected type for ctor {:?}\", def_id)\n-    };\n+    let sig = tcx.no_late_bound_regions(&tcx.fn_sig(def_id))\n+        .expect(\"LBR in ADT constructor signature\");\n     let sig = tcx.erase_regions(&sig);\n \n     let (adt_def, substs) = match sig.output().sty {"}, {"sha": "5f80c7bee147832ca51ef19283df30b27a76e3f5", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -87,7 +87,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                 let terminator = bb_data.terminator();\n                 if let TerminatorKind::Call {\n                     func: Operand::Constant(ref f), .. } = terminator.kind {\n-                    if let ty::TyFnDef(callee_def_id, substs, _) = f.ty.sty {\n+                    if let ty::TyFnDef(callee_def_id, substs) = f.ty.sty {\n                         callsites.push_back(CallSite {\n                             callee: callee_def_id,\n                             substs: substs,\n@@ -131,7 +131,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                     let terminator = bb_data.terminator();\n                     if let TerminatorKind::Call {\n                         func: Operand::Constant(ref f), .. } = terminator.kind {\n-                        if let ty::TyFnDef(callee_def_id, substs, _) = f.ty.sty {\n+                        if let ty::TyFnDef(callee_def_id, substs) = f.ty.sty {\n                             // Don't inline the same function multiple times.\n                             if callsite.callee != callee_def_id {\n                                 callsites.push_back(CallSite {\n@@ -270,8 +270,9 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                 }\n \n                 TerminatorKind::Call {func: Operand::Constant(ref f), .. } => {\n-                    if let ty::TyFnDef(.., f) = f.ty.sty {\n+                    if let ty::TyFnDef(def_id, _) = f.ty.sty {\n                         // Don't give intrinsics the extra penalty for calls\n+                        let f = tcx.fn_sig(def_id);\n                         if f.abi() == Abi::RustIntrinsic || f.abi() == Abi::PlatformIntrinsic {\n                             cost += INSTR_COST;\n                         } else {"}, {"sha": "91d6ce60b39044809ea169ab71f798d8fcc1ac36", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -750,8 +750,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n \n             let fn_ty = func.ty(self.mir, self.tcx);\n             let (is_shuffle, is_const_fn) = match fn_ty.sty {\n-                ty::TyFnDef(def_id, _, f) => {\n-                    (f.abi() == Abi::PlatformIntrinsic &&\n+                ty::TyFnDef(def_id, _) => {\n+                    (self.tcx.fn_sig(def_id).abi() == Abi::PlatformIntrinsic &&\n                      self.tcx.item_name(def_id).as_str().starts_with(\"simd_shuffle\"),\n                      self.tcx.is_const_fn(def_id))\n                 }"}, {"sha": "7e6fccf30192ce626dbc072efd9b4948bf41b747", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -462,7 +462,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let func_ty = func.ty(mir, tcx);\n                 debug!(\"check_terminator: call, func_ty={:?}\", func_ty);\n                 let sig = match func_ty.sty {\n-                    ty::TyFnDef(.., sig) | ty::TyFnPtr(sig) => sig,\n+                    ty::TyFnDef(..) | ty::TyFnPtr(_) => func_ty.fn_sig(tcx),\n                     _ => {\n                         span_mirbug!(self, term, \"call to non-function {:?}\", func_ty);\n                         return;"}, {"sha": "9eb96fea52778e6677d09a28deacfd1ee99d15fe", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -400,7 +400,13 @@ impl<'b, 'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n     }\n \n     fn ty(&mut self) -> &mut Self {\n-        self.ev.tcx.type_of(self.item_def_id).visit_with(self);\n+        let ty = self.ev.tcx.type_of(self.item_def_id);\n+        ty.visit_with(self);\n+        if let ty::TyFnDef(def_id, _) = ty.sty {\n+            if def_id == self.item_def_id {\n+                self.ev.tcx.fn_sig(def_id).visit_with(self);\n+            }\n+        }\n         self\n     }\n \n@@ -910,7 +916,13 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n     }\n \n     fn ty(&mut self) -> &mut Self {\n-        self.tcx.type_of(self.item_def_id).visit_with(self);\n+        let ty = self.tcx.type_of(self.item_def_id);\n+        ty.visit_with(self);\n+        if let ty::TyFnDef(def_id, _) = ty.sty {\n+            if def_id == self.item_def_id {\n+                self.tcx.fn_sig(def_id).visit_with(self);\n+            }\n+        }\n         self\n     }\n "}, {"sha": "10b66fb1991087a351150bcc8ec921a8cd7ce349", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -154,6 +154,13 @@ fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         assert!(!item_type.has_erasable_regions());\n         hasher.visit_ty(item_type);\n \n+        // If this is a function, we hash the signature as well.\n+        // This is not *strictly* needed, but it may help in some\n+        // situations, see the `run-make/a-b-a-linker-guard` test.\n+        if let ty::TyFnDef(..) = item_type.sty {\n+            item_type.fn_sig(tcx).visit_with(&mut hasher);\n+        }\n+\n         // also include any type parameters (for generic items)\n         if let Some(substs) = substs {\n             assert!(!substs.has_erasable_regions());"}, {"sha": "3c502eec549b27413ccc5208c35a2b1c5bef0c90", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -587,7 +587,7 @@ fn visit_fn_use<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                           is_direct_call: bool,\n                           output: &mut Vec<TransItem<'tcx>>)\n {\n-    if let ty::TyFnDef(def_id, substs, _) = ty.sty {\n+    if let ty::TyFnDef(def_id, substs) = ty.sty {\n         let instance = monomorphize::resolve(scx, def_id, substs);\n         visit_instance_use(scx, instance, is_direct_call, output);\n     }"}, {"sha": "9b0803908b162582e1dc86bbdc152f4b4f3a4dc5", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -495,9 +495,9 @@ pub fn ty_fn_sig<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                            -> ty::PolyFnSig<'tcx>\n {\n     match ty.sty {\n-        ty::TyFnDef(_, _, sig) => sig,\n+        ty::TyFnDef(..) |\n         // Shims currently have type TyFnPtr. Not sure this should remain.\n-        ty::TyFnPtr(sig) => sig,\n+        ty::TyFnPtr(_) => ty.fn_sig(ccx.tcx()),\n         ty::TyClosure(def_id, substs) => {\n             let tcx = ccx.tcx();\n             let sig = tcx.fn_sig(def_id).subst(tcx, substs.substs);"}, {"sha": "0cc1993601119597c7d2e553f9abd8126a1d70d8", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -488,7 +488,6 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     debug!(\"type_metadata: {:?}\", t);\n \n-    let sty = &t.sty;\n     let ptr_metadata = |ty: Ty<'tcx>| {\n         match ty.sty {\n             ty::TySlice(typ) => {\n@@ -518,7 +517,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n     };\n \n-    let MetadataCreationResult { metadata, already_stored_in_typemap } = match *sty {\n+    let MetadataCreationResult { metadata, already_stored_in_typemap } = match t.sty {\n         ty::TyNever    |\n         ty::TyBool     |\n         ty::TyChar     |\n@@ -557,10 +556,10 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 Err(metadata) => return metadata,\n             }\n         }\n-        ty::TyFnDef(.., sig) | ty::TyFnPtr(sig) => {\n+        ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n             let fn_metadata = subroutine_type_metadata(cx,\n                                                        unique_type_id,\n-                                                       sig,\n+                                                       t.fn_sig(cx.tcx()),\n                                                        usage_site_span).metadata;\n             match debug_context(cx).type_map\n                                    .borrow()\n@@ -610,7 +609,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    usage_site_span).finalize(cx)\n         }\n         _ => {\n-            bug!(\"debuginfo: unexpected type in type_metadata: {:?}\", sty)\n+            bug!(\"debuginfo: unexpected type in type_metadata: {:?}\", t)\n         }\n     };\n "}, {"sha": "bfca4fec706eda94267e9779c79320c94d18866a", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -96,8 +96,8 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 push_type_params(cx, principal.substs, output);\n             }\n         },\n-        ty::TyFnDef(.., sig) |\n-        ty::TyFnPtr(sig) => {\n+        ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+            let sig = t.fn_sig(cx.tcx());\n             if sig.unsafety() == hir::Unsafety::Unsafe {\n                 output.push_str(\"unsafe \");\n             }"}, {"sha": "9956c28e6412139d2f2fc2fddc106b74b020a104", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -95,11 +95,12 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     let ccx = bcx.ccx;\n     let tcx = ccx.tcx();\n \n-    let (def_id, substs, sig) = match callee_ty.sty {\n-        ty::TyFnDef(def_id, substs, sig) => (def_id, substs, sig),\n+    let (def_id, substs) = match callee_ty.sty {\n+        ty::TyFnDef(def_id, substs) => (def_id, substs),\n         _ => bug!(\"expected fn item type, found {}\", callee_ty)\n     };\n \n+    let sig = callee_ty.fn_sig(tcx);\n     let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n     let arg_tys = sig.inputs();\n     let ret_ty = sig.output();\n@@ -986,7 +987,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n \n \n     let tcx = bcx.tcx();\n-    let sig = tcx.erase_late_bound_regions_and_normalize(&callee_ty.fn_sig());\n+    let sig = tcx.erase_late_bound_regions_and_normalize(&callee_ty.fn_sig(tcx));\n     let arg_tys = sig.inputs();\n \n     // every intrinsic takes a SIMD vector as its first argument"}, {"sha": "16972a1b1ae249a9683776534d2e241de7a85c66", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -404,20 +404,18 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // Create the callee. This is a fn ptr or zero-sized and hence a kind of scalar.\n                 let callee = self.trans_operand(&bcx, func);\n \n-                let (instance, mut llfn, sig) = match callee.ty.sty {\n-                    ty::TyFnDef(def_id, substs, sig) => {\n+                let (instance, mut llfn) = match callee.ty.sty {\n+                    ty::TyFnDef(def_id, substs) => {\n                         (Some(monomorphize::resolve(bcx.ccx.shared(), def_id, substs)),\n-                         None,\n-                         sig)\n+                         None)\n                     }\n-                    ty::TyFnPtr(sig) => {\n-                        (None,\n-                         Some(callee.immediate()),\n-                         sig)\n+                    ty::TyFnPtr(_) => {\n+                        (None, Some(callee.immediate()))\n                     }\n                     _ => bug!(\"{} is not callable\", callee.ty)\n                 };\n                 let def = instance.map(|i| i.def);\n+                let sig = callee.ty.fn_sig(bcx.tcx());\n                 let sig = bcx.tcx().erase_late_bound_regions_and_normalize(&sig);\n                 let abi = sig.abi;\n "}, {"sha": "fcb4b25e6fe88d6a8bf6d6f7584ade9bad7ef86c", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -334,7 +334,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     let fn_ty = func.ty(self.mir, tcx);\n                     let fn_ty = self.monomorphize(&fn_ty);\n                     let (def_id, substs) = match fn_ty.sty {\n-                        ty::TyFnDef(def_id, substs, _) => (def_id, substs),\n+                        ty::TyFnDef(def_id, substs) => (def_id, substs),\n                         _ => span_bug!(span, \"calling {:?} (of type {}) in constant\",\n                                        func, fn_ty)\n                     };\n@@ -560,7 +560,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 let val = match *kind {\n                     mir::CastKind::ReifyFnPointer => {\n                         match operand.ty.sty {\n-                            ty::TyFnDef(def_id, substs, _) => {\n+                            ty::TyFnDef(def_id, substs) => {\n                                 callee::resolve_and_get_fn(self.ccx, def_id, substs)\n                             }\n                             _ => {"}, {"sha": "4bd5091a4f35f8069ea4225e58a17a3a07916468", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -180,7 +180,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let val = match *kind {\n                     mir::CastKind::ReifyFnPointer => {\n                         match operand.ty.sty {\n-                            ty::TyFnDef(def_id, substs, _) => {\n+                            ty::TyFnDef(def_id, substs) => {\n                                 OperandValue::Immediate(\n                                     callee::resolve_and_get_fn(bcx.ccx, def_id, substs))\n                             }"}, {"sha": "1f6a262162d3950021550cba8a44dce92be8777d", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -165,9 +165,11 @@ pub fn resolve<'a, 'tcx>(\n     } else {\n         let item_type = def_ty(scx, def_id, substs);\n         let def = match item_type.sty {\n-            ty::TyFnDef(_, _, f) if\n-                f.abi() == Abi::RustIntrinsic ||\n-                f.abi() == Abi::PlatformIntrinsic =>\n+            ty::TyFnDef(..) if {\n+                    let f = item_type.fn_sig(scx.tcx());\n+                    f.abi() == Abi::RustIntrinsic ||\n+                    f.abi() == Abi::PlatformIntrinsic\n+                } =>\n             {\n                 debug!(\" => intrinsic\");\n                 ty::InstanceDef::Intrinsic(def_id)"}, {"sha": "f59f6850da103de65ee6f877b7f635c63cbc6e20", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -401,8 +401,9 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n                         output);\n                 }\n             },\n-            ty::TyFnDef(.., sig) |\n-            ty::TyFnPtr(sig) => {\n+            ty::TyFnDef(..) |\n+            ty::TyFnPtr(_) => {\n+                let sig = t.fn_sig(self.tcx);\n                 if sig.unsafety() == hir::Unsafety::Unsafe {\n                     output.push_str(\"unsafe \");\n                 }"}, {"sha": "68726a7b1c4ebe111a7c53f35cf7ca2d63bd0774", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -619,7 +619,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Type check the path.\n         let pat_ty = self.instantiate_value_path(segments, opt_ty, def, pat.span, pat.id);\n         // Replace constructor type with constructed type for tuple struct patterns.\n-        let pat_ty = pat_ty.fn_sig().output();\n+        let pat_ty = pat_ty.fn_sig(tcx).output();\n         let pat_ty = tcx.no_late_bound_regions(&pat_ty).expect(\"expected fn type\");\n         self.demand_eqtype(pat.span, expected, pat_ty);\n "}, {"sha": "a0801a7486654580f86ef2e6a8e5717fba2c6342", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -196,8 +196,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             expected: Expectation<'tcx>)\n                             -> Ty<'tcx> {\n         let (fn_sig, def_span) = match callee_ty.sty {\n-            ty::TyFnDef(def_id, .., sig) => {\n-                (sig, self.tcx.hir.span_if_local(def_id))\n+            ty::TyFnDef(def_id, _) => {\n+                (callee_ty.fn_sig(self.tcx), self.tcx.hir.span_if_local(def_id))\n             }\n             ty::TyFnPtr(sig) => (sig, None),\n             ref t => {"}, {"sha": "46d304976dc635b11585a36ba061e301b90b9cba", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -356,8 +356,9 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n             (Some(t_from), Some(t_cast)) => (t_from, t_cast),\n             // Function item types may need to be reified before casts.\n             (None, Some(t_cast)) => {\n-                if let ty::TyFnDef(.., f) = self.expr_ty.sty {\n+                if let ty::TyFnDef(..) = self.expr_ty.sty {\n                     // Attempt a coercion to a fn pointer type.\n+                    let f = self.expr_ty.fn_sig(fcx.tcx);\n                     let res = fcx.try_coerce(self.expr,\n                                              self.expr_ty,\n                                              self.expr_diverges,"}, {"sha": "17d02223716827e7fbf3530496abaabdf0fb648a", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 46, "deletions": 40, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -210,13 +210,13 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         }\n \n         match a.sty {\n-            ty::TyFnDef(.., a_f) => {\n+            ty::TyFnDef(..) => {\n                 // Function items are coercible to any closure\n                 // type; function pointers are not (that would\n                 // require double indirection).\n                 // Additionally, we permit coercion of function\n                 // items to drop the unsafe qualifier.\n-                self.coerce_from_fn_item(a, a_f, b)\n+                self.coerce_from_fn_item(a, b)\n             }\n             ty::TyFnPtr(a_f) => {\n                 // We permit coercion of fn pointers to drop the\n@@ -600,7 +600,6 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n     fn coerce_from_fn_item(&self,\n                            a: Ty<'tcx>,\n-                           fn_ty_a: ty::PolyFnSig<'tcx>,\n                            b: Ty<'tcx>)\n                            -> CoerceResult<'tcx> {\n         //! Attempts to coerce from the type of a Rust function item\n@@ -612,9 +611,17 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         match b.sty {\n             ty::TyFnPtr(_) => {\n-                let a_fn_pointer = self.tcx.mk_fn_ptr(fn_ty_a);\n-                self.coerce_from_safe_fn(a_fn_pointer, fn_ty_a, b,\n-                    simple(Adjust::ReifyFnPointer), simple(Adjust::ReifyFnPointer))\n+                let a_sig = a.fn_sig(self.tcx);\n+                let InferOk { value: a_sig, mut obligations } =\n+                    self.normalize_associated_types_in_as_infer_ok(self.cause.span, &a_sig);\n+\n+                let a_fn_pointer = self.tcx.mk_fn_ptr(a_sig);\n+                let InferOk { value, obligations: o2 } =\n+                    self.coerce_from_safe_fn(a_fn_pointer, a_sig, b,\n+                        simple(Adjust::ReifyFnPointer), simple(Adjust::ReifyFnPointer))?;\n+\n+                obligations.extend(o2);\n+                Ok(InferOk { value, obligations })\n             }\n             _ => self.unify_and(a, b, identity),\n         }\n@@ -775,42 +782,41 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Special-case that coercion alone cannot handle:\n         // Two function item types of differing IDs or Substs.\n-        match (&prev_ty.sty, &new_ty.sty) {\n-            (&ty::TyFnDef(a_def_id, a_substs, a_fty), &ty::TyFnDef(b_def_id, b_substs, b_fty)) => {\n-                // The signature must always match.\n-                let fty = self.at(cause, self.param_env)\n-                              .trace(prev_ty, new_ty)\n-                              .lub(&a_fty, &b_fty)\n-                              .map(|ok| self.register_infer_ok_obligations(ok))?;\n-\n-                if a_def_id == b_def_id {\n-                    // Same function, maybe the parameters match.\n-                    let substs = self.commit_if_ok(|_| {\n-                        self.at(cause, self.param_env)\n-                            .trace(prev_ty, new_ty)\n-                            .lub(&a_substs, &b_substs)\n-                            .map(|ok| self.register_infer_ok_obligations(ok))\n-                    });\n-\n-                    if let Ok(substs) = substs {\n-                        // We have a LUB of prev_ty and new_ty, just return it.\n-                        return Ok(self.tcx.mk_fn_def(a_def_id, substs, fty));\n-                    }\n-                }\n+        if let (&ty::TyFnDef(..), &ty::TyFnDef(..)) = (&prev_ty.sty, &new_ty.sty) {\n+            // Don't reify if the function types have a LUB, i.e. they\n+            // are the same function and their parameters have a LUB.\n+            let lub_ty = self.commit_if_ok(|_| {\n+                self.at(cause, self.param_env)\n+                    .lub(prev_ty, new_ty)\n+                    .map(|ok| self.register_infer_ok_obligations(ok))\n+            });\n+\n+            if lub_ty.is_ok() {\n+                // We have a LUB of prev_ty and new_ty, just return it.\n+                return lub_ty;\n+            }\n \n-                // Reify both sides and return the reified fn pointer type.\n-                let fn_ptr = self.tcx.mk_fn_ptr(fty);\n-                for expr in exprs.iter().map(|e| e.as_coercion_site()).chain(Some(new)) {\n-                    // The only adjustment that can produce an fn item is\n-                    // `NeverToAny`, so this should always be valid.\n-                    self.apply_adjustments(expr, vec![Adjustment {\n-                        kind: Adjust::ReifyFnPointer,\n-                        target: fn_ptr\n-                    }]);\n-                }\n-                return Ok(fn_ptr);\n+            // The signature must match.\n+            let a_sig = prev_ty.fn_sig(self.tcx);\n+            let a_sig = self.normalize_associated_types_in(new.span, &a_sig);\n+            let b_sig = new_ty.fn_sig(self.tcx);\n+            let b_sig = self.normalize_associated_types_in(new.span, &b_sig);\n+            let sig = self.at(cause, self.param_env)\n+                          .trace(prev_ty, new_ty)\n+                          .lub(&a_sig, &b_sig)\n+                          .map(|ok| self.register_infer_ok_obligations(ok))?;\n+\n+            // Reify both sides and return the reified fn pointer type.\n+            let fn_ptr = self.tcx.mk_fn_ptr(sig);\n+            for expr in exprs.iter().map(|e| e.as_coercion_site()).chain(Some(new)) {\n+                // The only adjustment that can produce an fn item is\n+                // `NeverToAny`, so this should always be valid.\n+                self.apply_adjustments(expr, vec![Adjustment {\n+                    kind: Adjust::ReifyFnPointer,\n+                    target: fn_ptr\n+                }]);\n             }\n-            _ => {}\n+            return Ok(fn_ptr);\n         }\n \n         let mut coerce = Coerce::new(self, cause.clone());"}, {"sha": "fd5147d76e8fdb72ebed4dbc0c0bac2cfcddce93", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -256,17 +256,10 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // Compute skolemized form of impl and trait method tys.\n         let tcx = infcx.tcx;\n \n-        let m_sig = |method: &ty::AssociatedItem| {\n-            match tcx.type_of(method.def_id).sty {\n-                ty::TyFnDef(_, _, f) => f,\n-                _ => bug!()\n-            }\n-        };\n-\n         let (impl_sig, _) =\n             infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n                                                             infer::HigherRankedType,\n-                                                            &m_sig(impl_m));\n+                                                            &tcx.fn_sig(impl_m.def_id));\n         let impl_sig =\n             inh.normalize_associated_types_in(impl_m_span,\n                                               impl_m_node_id,\n@@ -277,7 +270,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         let trait_sig = inh.liberate_late_bound_regions(\n             impl_m.def_id,\n-            &m_sig(trait_m));\n+            &tcx.fn_sig(trait_m.def_id));\n         let trait_sig =\n             trait_sig.subst(tcx, trait_to_skol_substs);\n         let trait_sig =\n@@ -507,8 +500,7 @@ fn compare_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             ty::ImplContainer(_) => impl_trait_ref.self_ty(),\n             ty::TraitContainer(_) => tcx.mk_self_type()\n         };\n-        let method_ty = tcx.type_of(method.def_id);\n-        let self_arg_ty = *method_ty.fn_sig().input(0).skip_binder();\n+        let self_arg_ty = *tcx.fn_sig(method.def_id).input(0).skip_binder();\n         match ExplicitSelf::determine(untransformed_self_ty, self_arg_ty) {\n             ExplicitSelf::ByValue => \"self\".to_string(),\n             ExplicitSelf::ByReference(_, hir::MutImmutable) => \"&self\".to_string(),\n@@ -637,14 +629,8 @@ fn compare_number_of_method_arguments<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 trait_m: &ty::AssociatedItem,\n                                                 trait_item_span: Option<Span>)\n                                                 -> Result<(), ErrorReported> {\n-    let m_fty = |method: &ty::AssociatedItem| {\n-        match tcx.type_of(method.def_id).sty {\n-            ty::TyFnDef(_, _, f) => f,\n-            _ => bug!()\n-        }\n-    };\n-    let impl_m_fty = m_fty(impl_m);\n-    let trait_m_fty = m_fty(trait_m);\n+    let impl_m_fty = tcx.fn_sig(impl_m.def_id);\n+    let trait_m_fty = tcx.fn_sig(trait_m.def_id);\n     let trait_number_args = trait_m_fty.inputs().skip_binder().len();\n     let impl_number_args = impl_m_fty.inputs().skip_binder().len();\n     if trait_number_args != impl_number_args {"}, {"sha": "287c591c1183d5e12f12fb9461b439b5995f6169", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -143,12 +143,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn has_no_input_arg(&self, method: &AssociatedItem) -> bool {\n         match method.def() {\n             Def::Method(def_id) => {\n-                match self.tcx.type_of(def_id).sty {\n-                    ty::TypeVariants::TyFnDef(_, _, sig) => {\n-                        sig.inputs().skip_binder().len() == 1\n-                    }\n-                    _ => false,\n-                }\n+                self.tcx.fn_sig(def_id).inputs().skip_binder().len() == 1\n             }\n             _ => false,\n         }"}, {"sha": "3acfbd1d844038183f92c32ea1b24433e353ed4d", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -13,7 +13,6 @@\n \n use intrinsics;\n use rustc::traits::{ObligationCause, ObligationCauseCode};\n-use rustc::ty::subst::Substs;\n use rustc::ty::{self, TyCtxt, Ty};\n use rustc::util::nodemap::FxHashMap;\n use require_same_types;\n@@ -35,22 +34,22 @@ fn equate_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    output: Ty<'tcx>) {\n     let def_id = tcx.hir.local_def_id(it.id);\n \n-    let substs = Substs::for_item(tcx, def_id,\n-                                  |_, _| tcx.types.re_erased,\n-                                  |def, _| tcx.mk_param_from_def(def));\n+    match it.node {\n+        hir::ForeignItemFn(..) => {}\n+        _ => {\n+            struct_span_err!(tcx.sess, it.span, E0619,\n+                             \"intrinsic must be a function\")\n+                .span_label(it.span, \"expected a function\")\n+                .emit();\n+            return;\n+        }\n+    }\n \n-    let fty = tcx.mk_fn_def(def_id, substs, ty::Binder(tcx.mk_fn_sig(\n-        inputs.into_iter(),\n-        output,\n-        false,\n-        hir::Unsafety::Unsafe,\n-        abi\n-    )));\n     let i_n_tps = tcx.generics_of(def_id).types.len();\n     if i_n_tps != n_tps {\n         let span = match it.node {\n             hir::ForeignItemFn(_, _, ref generics) => generics.span,\n-            hir::ForeignItemStatic(..) => it.span\n+            _ => bug!()\n         };\n \n         struct_span_err!(tcx.sess, span, E0094,\n@@ -59,14 +58,18 @@ fn equate_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         i_n_tps, n_tps)\n             .span_label(span, format!(\"expected {} type parameter\", n_tps))\n             .emit();\n-    } else {\n-        require_same_types(tcx,\n-                           &ObligationCause::new(it.span,\n-                                                 it.id,\n-                                                 ObligationCauseCode::IntrinsicType),\n-                           tcx.type_of(def_id),\n-                           fty);\n+        return;\n     }\n+\n+    let fty = tcx.mk_fn_ptr(ty::Binder(tcx.mk_fn_sig(\n+        inputs.into_iter(),\n+        output,\n+        false,\n+        hir::Unsafety::Unsafe,\n+        abi\n+    )));\n+    let cause = ObligationCause::new(it.span, it.id, ObligationCauseCode::IntrinsicType);\n+    require_same_types(tcx, &cause, tcx.mk_fn_ptr(tcx.fn_sig(def_id)), fty);\n }\n \n /// Remember to add all intrinsics here, in librustc_trans/trans/intrinsic.rs,\n@@ -376,7 +379,7 @@ pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n                     let mut structural_to_nomimal = FxHashMap();\n \n-                    let sig = tcx.type_of(def_id).fn_sig();\n+                    let sig = tcx.fn_sig(def_id);\n                     let sig = tcx.no_late_bound_regions(&sig).unwrap();\n                     if intr.inputs.len() != sig.inputs().len() {\n                         span_err!(tcx.sess, it.span, E0444,"}, {"sha": "209245187b13fd8bdc4903f266af7ccde2e051c1", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -375,7 +375,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n         debug!(\"method_predicates after subst = {:?}\", method_predicates);\n \n-        let sig = self.tcx.type_of(def_id).fn_sig();\n+        let sig = self.tcx.fn_sig(def_id);\n \n         // Instantiate late-bound regions and substitute the trait\n         // parameters into the method type to get the actual method type."}, {"sha": "4f4169ac93d1b3d98027be9149eb20a868ef72b0", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -235,7 +235,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // NB: Instantiate late-bound regions first so that\n         // `instantiate_type_scheme` can normalize associated types that\n         // may reference those regions.\n-        let fn_sig = tcx.type_of(def_id).fn_sig();\n+        let fn_sig = tcx.fn_sig(def_id);\n         let fn_sig = self.replace_late_bound_regions_with_fresh_var(span,\n                                                                     infer::FnCall,\n                                                                     &fn_sig).0;"}, {"sha": "ee9a347ae95111b299c963ebb98a3ce554fae271", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -673,7 +673,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                                expected: ty::Ty<'tcx>) -> bool {\n         match method.def() {\n             Def::Method(def_id) => {\n-                let fty = self.tcx.type_of(def_id).fn_sig();\n+                let fty = self.tcx.fn_sig(def_id);\n                 self.probe(|_| {\n                     let substs = self.fresh_substs_for_item(self.span, method.def_id);\n                     let output = fty.output().subst(self.tcx, substs);\n@@ -1288,7 +1288,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                             impl_ty: Ty<'tcx>,\n                             substs: &Substs<'tcx>)\n                             -> Ty<'tcx> {\n-        let self_ty = self.tcx.type_of(method).fn_sig().input(0);\n+        let self_ty = self.tcx.fn_sig(method).input(0);\n         debug!(\"xform_self_ty(impl_ty={:?}, self_ty={:?}, substs={:?})\",\n                impl_ty,\n                self_ty,"}, {"sha": "701de029b2bd5362bf9941574246d416eb3ab70d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -718,20 +718,12 @@ pub fn provide(providers: &mut Providers) {\n         typeck_item_bodies,\n         typeck_tables_of,\n         has_typeck_tables,\n-        fn_sig,\n         closure_kind,\n         adt_destructor,\n         ..*providers\n     };\n }\n \n-fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    def_id: DefId)\n-                    -> ty::PolyFnSig<'tcx> {\n-    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    tcx.typeck_tables_of(def_id).closure_tys[&node_id]\n-}\n-\n fn closure_kind<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           def_id: DefId)\n                           -> ty::ClosureKind {\n@@ -844,7 +836,7 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     Inherited::build(tcx, def_id).enter(|inh| {\n         let param_env = tcx.param_env(def_id);\n         let fcx = if let Some(decl) = fn_decl {\n-            let fn_sig = tcx.type_of(def_id).fn_sig();\n+            let fn_sig = tcx.fn_sig(def_id);\n \n             check_abi(tcx, span, fn_sig.abi());\n \n@@ -2173,7 +2165,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                           -> ty::TypeAndMut<'tcx>\n     {\n         // extract method return type, which will be &T;\n-        // all LB regions should have been instantiated during method lookup\n         let ret_ty = method.sig.output();\n \n         // method returns &T, but the type as visible to user is T, so deref\n@@ -2580,8 +2571,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     ty::TyUint(ast::UintTy::U8) | ty::TyUint(ast::UintTy::U16) => {\n                         variadic_error(tcx.sess, arg.span, arg_ty, \"c_uint\");\n                     }\n-                    ty::TyFnDef(.., f) => {\n-                        let ptr_ty = self.tcx.mk_fn_ptr(f);\n+                    ty::TyFnDef(..) => {\n+                        let ptr_ty = self.tcx.mk_fn_ptr(arg_ty.fn_sig(self.tcx));\n                         let ptr_ty = self.resolve_type_vars_if_possible(&ptr_ty);\n                         variadic_error(tcx.sess, arg.span, arg_ty, &format!(\"{}\", ptr_ty));\n                     }"}, {"sha": "cbda1227742ca32d5756e27344e204cd02736915", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -177,12 +177,11 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                 }\n                 ty::AssociatedKind::Method => {\n                     reject_shadowing_type_parameters(fcx.tcx, item.def_id);\n-                    let method_ty = fcx.tcx.type_of(item.def_id);\n-                    let method_ty = fcx.normalize_associated_types_in(span, &method_ty);\n+                    let sig = fcx.tcx.fn_sig(item.def_id);\n+                    let sig = fcx.normalize_associated_types_in(span, &sig);\n                     let predicates = fcx.tcx.predicates_of(item.def_id)\n                         .instantiate_identity(fcx.tcx);\n                     let predicates = fcx.normalize_associated_types_in(span, &predicates);\n-                    let sig = method_ty.fn_sig();\n                     this.check_fn_or_method(fcx, span, sig, &predicates,\n                                             item.def_id, &mut implied_bounds);\n                     let sig_if_method = sig_if_method.expect(\"bad signature for method\");\n@@ -331,9 +330,8 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n     fn check_item_fn(&mut self, item: &hir::Item) {\n         self.for_item(item).with_fcx(|fcx, this| {\n             let def_id = fcx.tcx.hir.local_def_id(item.id);\n-            let ty = fcx.tcx.type_of(def_id);\n-            let item_ty = fcx.normalize_associated_types_in(item.span, &ty);\n-            let sig = item_ty.fn_sig();\n+            let sig = fcx.tcx.fn_sig(def_id);\n+            let sig = fcx.normalize_associated_types_in(item.span, &sig);\n \n             let predicates = fcx.tcx.predicates_of(def_id).instantiate_identity(fcx.tcx);\n             let predicates = fcx.normalize_associated_types_in(item.span, &predicates);\n@@ -461,9 +459,9 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n \n         let span = method_sig.decl.inputs[0].span;\n \n-        let method_ty = fcx.tcx.type_of(method.def_id);\n-        let fty = fcx.normalize_associated_types_in(span, &method_ty);\n-        let sig = fcx.liberate_late_bound_regions(method.def_id, &fty.fn_sig());\n+        let sig = fcx.tcx.fn_sig(method.def_id);\n+        let sig = fcx.normalize_associated_types_in(span, &sig);\n+        let sig = fcx.liberate_late_bound_regions(method.def_id, &sig);\n \n         debug!(\"check_method_receiver: sig={:?}\", sig);\n "}, {"sha": "fd6dda5ccf4a72e9c81be10c6bef8beec7c4f7ca", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 82, "deletions": 30, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -97,6 +97,7 @@ pub fn provide(providers: &mut Providers) {\n         type_param_predicates,\n         trait_def,\n         adt_def,\n+        fn_sig,\n         impl_trait_ref,\n         impl_polarity,\n         is_foreign_item,\n@@ -447,6 +448,9 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n                 tcx.generics_of(def_id);\n                 tcx.type_of(def_id);\n                 tcx.predicates_of(def_id);\n+                if let hir::ForeignItemFn(..) = item.node {\n+                    tcx.fn_sig(def_id);\n+                }\n             }\n         }\n         hir::ItemEnum(ref enum_definition, _) => {\n@@ -497,6 +501,9 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n             tcx.generics_of(def_id);\n             tcx.type_of(def_id);\n             tcx.predicates_of(def_id);\n+            if let hir::ItemFn(..) = it.node {\n+                tcx.fn_sig(def_id);\n+            }\n         }\n     }\n }\n@@ -511,6 +518,9 @@ fn convert_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_item_id: ast:\n         hir::TraitItemKind::Type(_, Some(_)) |\n         hir::TraitItemKind::Method(..) => {\n             tcx.type_of(def_id);\n+            if let hir::TraitItemKind::Method(..) = trait_item.node {\n+                tcx.fn_sig(def_id);\n+            }\n         }\n \n         hir::TraitItemKind::Type(_, None) => {}\n@@ -524,6 +534,9 @@ fn convert_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_item_id: ast::N\n     tcx.generics_of(def_id);\n     tcx.type_of(def_id);\n     tcx.predicates_of(def_id);\n+    if let hir::ImplItemKind::Method(..) = tcx.hir.expect_impl_item(impl_item_id).node {\n+        tcx.fn_sig(def_id);\n+    }\n }\n \n fn convert_variant_ctor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -963,10 +976,9 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match tcx.hir.get(node_id) {\n         NodeTraitItem(item) => {\n             match item.node {\n-                TraitItemKind::Method(ref sig, _) => {\n-                    let fty = AstConv::ty_of_fn(&icx, sig.unsafety, sig.abi, &sig.decl);\n+                TraitItemKind::Method(..) => {\n                     let substs = Substs::identity_for_item(tcx, def_id);\n-                    tcx.mk_fn_def(def_id, substs, fty)\n+                    tcx.mk_fn_def(def_id, substs)\n                 }\n                 TraitItemKind::Const(ref ty, _) |\n                 TraitItemKind::Type(_, Some(ref ty)) => icx.to_ty(ty),\n@@ -978,10 +990,9 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         NodeImplItem(item) => {\n             match item.node {\n-                ImplItemKind::Method(ref sig, _) => {\n-                    let fty = AstConv::ty_of_fn(&icx, sig.unsafety, sig.abi, &sig.decl);\n+                ImplItemKind::Method(..) => {\n                     let substs = Substs::identity_for_item(tcx, def_id);\n-                    tcx.mk_fn_def(def_id, substs, fty)\n+                    tcx.mk_fn_def(def_id, substs)\n                 }\n                 ImplItemKind::Const(ref ty, _) => icx.to_ty(ty),\n                 ImplItemKind::Type(ref ty) => {\n@@ -1001,10 +1012,9 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 ItemTy(ref t, _) | ItemImpl(.., ref t, _) => {\n                     icx.to_ty(t)\n                 }\n-                ItemFn(ref decl, unsafety, _, abi, _, _) => {\n-                    let tofd = AstConv::ty_of_fn(&icx, unsafety, abi, &decl);\n+                ItemFn(..) => {\n                     let substs = Substs::identity_for_item(tcx, def_id);\n-                    tcx.mk_fn_def(def_id, substs, tofd)\n+                    tcx.mk_fn_def(def_id, substs)\n                 }\n                 ItemEnum(..) |\n                 ItemStruct(..) |\n@@ -1029,33 +1039,24 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         NodeForeignItem(foreign_item) => {\n-            let abi = tcx.hir.get_foreign_abi(node_id);\n-\n             match foreign_item.node {\n-                ForeignItemFn(ref fn_decl, _, _) => {\n-                    compute_type_of_foreign_fn_decl(tcx, def_id, fn_decl, abi)\n+                ForeignItemFn(..) => {\n+                    let substs = Substs::identity_for_item(tcx, def_id);\n+                    tcx.mk_fn_def(def_id, substs)\n                 }\n                 ForeignItemStatic(ref t, _) => icx.to_ty(t)\n             }\n         }\n \n         NodeStructCtor(&ref def) |\n         NodeVariant(&Spanned { node: hir::Variant_ { data: ref def, .. }, .. }) => {\n-            let ty = tcx.type_of(tcx.hir.get_parent_did(node_id));\n             match *def {\n-                VariantData::Unit(..) | VariantData::Struct(..) => ty,\n-                VariantData::Tuple(ref fields, _) => {\n-                    let inputs = fields.iter().map(|f| {\n-                        tcx.type_of(tcx.hir.local_def_id(f.id))\n-                    });\n+                VariantData::Unit(..) | VariantData::Struct(..) => {\n+                    tcx.type_of(tcx.hir.get_parent_did(node_id))\n+                }\n+                VariantData::Tuple(..) => {\n                     let substs = Substs::identity_for_item(tcx, def_id);\n-                    tcx.mk_fn_def(def_id, substs, ty::Binder(tcx.mk_fn_sig(\n-                        inputs,\n-                        ty,\n-                        false,\n-                        hir::Unsafety::Normal,\n-                        abi::Abi::Rust\n-                    )))\n+                    tcx.mk_fn_def(def_id, substs)\n                 }\n             }\n         }\n@@ -1105,6 +1106,58 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n+fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    def_id: DefId)\n+                    -> ty::PolyFnSig<'tcx> {\n+    use rustc::hir::map::*;\n+    use rustc::hir::*;\n+\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+\n+    let icx = ItemCtxt::new(tcx, def_id);\n+\n+    match tcx.hir.get(node_id) {\n+        NodeTraitItem(&hir::TraitItem { node: TraitItemKind::Method(ref sig, _), .. }) |\n+        NodeImplItem(&hir::ImplItem { node: ImplItemKind::Method(ref sig, _), .. }) => {\n+            AstConv::ty_of_fn(&icx, sig.unsafety, sig.abi, &sig.decl)\n+        }\n+\n+        NodeItem(&hir::Item { node: ItemFn(ref decl, unsafety, _, abi, _, _), .. }) => {\n+            AstConv::ty_of_fn(&icx, unsafety, abi, decl)\n+        }\n+\n+        NodeForeignItem(&hir::ForeignItem { node: ForeignItemFn(ref fn_decl, _, _), .. }) => {\n+            let abi = tcx.hir.get_foreign_abi(node_id);\n+            compute_sig_of_foreign_fn_decl(tcx, def_id, fn_decl, abi)\n+        }\n+\n+        NodeStructCtor(&VariantData::Tuple(ref fields, _)) |\n+        NodeVariant(&Spanned { node: hir::Variant_ {\n+            data: VariantData::Tuple(ref fields, _), ..\n+        }, .. }) => {\n+            let ty = tcx.type_of(tcx.hir.get_parent_did(node_id));\n+            let inputs = fields.iter().map(|f| {\n+                tcx.type_of(tcx.hir.local_def_id(f.id))\n+            });\n+            ty::Binder(tcx.mk_fn_sig(\n+                inputs,\n+                ty,\n+                false,\n+                hir::Unsafety::Normal,\n+                abi::Abi::Rust\n+            ))\n+        }\n+\n+        NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) => {\n+            tcx.typeck_tables_of(def_id).closure_tys[&node_id]\n+        }\n+\n+        x => {\n+            bug!(\"unexpected sort of node in fn_sig(): {:?}\", x);\n+        }\n+    }\n+}\n+\n fn impl_trait_ref<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             def_id: DefId)\n                             -> Option<ty::TraitRef<'tcx>> {\n@@ -1502,12 +1555,12 @@ fn predicates_from_bound<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n     }\n }\n \n-fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n+fn compute_sig_of_foreign_fn_decl<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n     decl: &hir::FnDecl,\n     abi: abi::Abi)\n-    -> Ty<'tcx>\n+    -> ty::PolyFnSig<'tcx>\n {\n     let fty = AstConv::ty_of_fn(&ItemCtxt::new(tcx, def_id), hir::Unsafety::Unsafe, abi, decl);\n \n@@ -1533,8 +1586,7 @@ fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n         }\n     }\n \n-    let substs = Substs::identity_for_item(tcx, def_id);\n-    tcx.mk_fn_def(def_id, substs, fty)\n+    fty\n }\n \n fn is_foreign_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "bf5adc8644d516af15cf2cb71c802e7c9d7d28c2", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -4736,4 +4736,5 @@ register_diagnostics! {\n     E0568, // auto-traits can not have predicates,\n     E0588, // packed struct cannot transitively contain a `[repr(align)]` struct\n     E0592, // duplicate definitions with name `{}`\n+    E0619, // intrinsic must be a function\n }"}, {"sha": "519e1ca6e5a3c31a34d81c4a47427c6f387cacb1", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -198,22 +198,21 @@ fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 }\n                 _ => ()\n             }\n-            let substs = tcx.intern_substs(&[]);\n-            let se_ty = tcx.mk_fn_def(main_def_id, substs,\n-                ty::Binder(tcx.mk_fn_sig(\n+            let se_ty = tcx.mk_fn_ptr(ty::Binder(\n+                tcx.mk_fn_sig(\n                     iter::empty(),\n                     tcx.mk_nil(),\n                     false,\n                     hir::Unsafety::Normal,\n                     Abi::Rust\n-                ))\n-            );\n+                )\n+            ));\n \n             require_same_types(\n                 tcx,\n                 &ObligationCause::new(main_span, main_id, ObligationCauseCode::MainFunctionType),\n                 se_ty,\n-                main_t);\n+                tcx.mk_fn_ptr(tcx.fn_sig(main_def_id)));\n         }\n         _ => {\n             span_bug!(main_span,\n@@ -248,9 +247,8 @@ fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 _ => ()\n             }\n \n-            let substs = tcx.intern_substs(&[]);\n-            let se_ty = tcx.mk_fn_def(start_def_id, substs,\n-                ty::Binder(tcx.mk_fn_sig(\n+            let se_ty = tcx.mk_fn_ptr(ty::Binder(\n+                tcx.mk_fn_sig(\n                     [\n                         tcx.types.isize,\n                         tcx.mk_imm_ptr(tcx.mk_imm_ptr(tcx.types.u8))\n@@ -259,14 +257,14 @@ fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     false,\n                     hir::Unsafety::Normal,\n                     Abi::Rust\n-                ))\n-            );\n+                )\n+            ));\n \n             require_same_types(\n                 tcx,\n                 &ObligationCause::new(start_span, start_id, ObligationCauseCode::StartFunctionType),\n                 se_ty,\n-                start_t);\n+                tcx.mk_fn_ptr(tcx.fn_sig(start_def_id)));\n         }\n         _ => {\n             span_bug!(start_span,"}, {"sha": "4c09d90f853dc0b949d168315b4fe5fa3bb55e39", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -382,6 +382,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 // leaf type -- noop\n             }\n \n+            ty::TyFnDef(..) |\n             ty::TyClosure(..) |\n             ty::TyAnon(..) => {\n                 bug!(\"Unexpected closure type in variance computation\");\n@@ -466,7 +467,6 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 }\n             }\n \n-            ty::TyFnDef(.., sig) |\n             ty::TyFnPtr(sig) => {\n                 self.add_constraints_from_sig(current, sig, variance);\n             }"}, {"sha": "fa5a999adf1960c00dfb57d52365d19397d25a79", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -149,7 +149,7 @@ pub fn build_external_trait(cx: &DocContext, did: DefId) -> clean::Trait {\n }\n \n fn build_external_function(cx: &DocContext, did: DefId) -> clean::Function {\n-    let sig = cx.tcx.type_of(did).fn_sig();\n+    let sig = cx.tcx.fn_sig(did);\n \n     let constness = if cx.tcx.is_const_fn(did) {\n         hir::Constness::Const"}, {"sha": "478e2fc5085d19fe8dba0e3fcc7ea6ac6d30e777", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -1367,7 +1367,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n             ty::AssociatedKind::Method => {\n                 let generics = (cx.tcx.generics_of(self.def_id),\n                                 &cx.tcx.predicates_of(self.def_id)).clean(cx);\n-                let sig = cx.tcx.type_of(self.def_id).fn_sig();\n+                let sig = cx.tcx.fn_sig(self.def_id);\n                 let mut decl = (self.def_id, sig).clean(cx);\n \n                 if self.method_has_self_argument {\n@@ -1842,17 +1842,21 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                 mutability: mt.mutbl.clean(cx),\n                 type_: box mt.ty.clean(cx),\n             },\n-            ty::TyFnDef(.., sig) |\n-            ty::TyFnPtr(sig) => BareFunction(box BareFunctionDecl {\n-                unsafety: sig.unsafety(),\n-                generics: Generics {\n-                    lifetimes: Vec::new(),\n-                    type_params: Vec::new(),\n-                    where_predicates: Vec::new()\n-                },\n-                decl: (cx.tcx.hir.local_def_id(ast::CRATE_NODE_ID), sig).clean(cx),\n-                abi: sig.abi(),\n-            }),\n+            ty::TyFnDef(..) |\n+            ty::TyFnPtr(_) => {\n+                let ty = cx.tcx.lift(self).unwrap();\n+                let sig = ty.fn_sig(cx.tcx);\n+                BareFunction(box BareFunctionDecl {\n+                    unsafety: sig.unsafety(),\n+                    generics: Generics {\n+                        lifetimes: Vec::new(),\n+                        type_params: Vec::new(),\n+                        where_predicates: Vec::new()\n+                    },\n+                    decl: (cx.tcx.hir.local_def_id(ast::CRATE_NODE_ID), sig).clean(cx),\n+                    abi: sig.abi(),\n+                })\n+            }\n             ty::TyAdt(def, substs) => {\n                 let did = def.did;\n                 let kind = match def.adt_kind() {"}, {"sha": "c42d78c323e3ce643d1fff53e2afeec0e130b131", "filename": "src/test/compile-fail/invalid-intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Ftest%2Fcompile-fail%2Finvalid-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Ftest%2Fcompile-fail%2Finvalid-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finvalid-intrinsic.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -11,6 +11,6 @@\n #![feature(intrinsics)]\n extern \"rust-intrinsic\" {\n     pub static breakpoint : unsafe extern \"rust-intrinsic\" fn();\n-    //~^ ERROR intrinsic has wrong type\n+    //~^ ERROR intrinsic must be a function\n }\n-fn main() { unsafe { breakpoint(); } }\n\\ No newline at end of file\n+fn main() { unsafe { breakpoint(); } }"}]}