{"sha": "1baac86670227658962d895157d27cfd4e4ea70c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiYWFjODY2NzAyMjc2NTg5NjJkODk1MTU3ZDI3Y2ZkNGU0ZWE3MGM=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-07-15T21:00:42Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-09-03T21:35:55Z"}, "message": "Simplify lifetimes_from_impl_trait_bounds.", "tree": {"sha": "c332c1dc602c35bed48b2f230b000ddf06b8af5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c332c1dc602c35bed48b2f230b000ddf06b8af5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1baac86670227658962d895157d27cfd4e4ea70c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1baac86670227658962d895157d27cfd4e4ea70c", "html_url": "https://github.com/rust-lang/rust/commit/1baac86670227658962d895157d27cfd4e4ea70c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1baac86670227658962d895157d27cfd4e4ea70c/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4878034c000a0404a4c83e77eddf493deab550d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4878034c000a0404a4c83e77eddf493deab550d6", "html_url": "https://github.com/rust-lang/rust/commit/4878034c000a0404a4c83e77eddf493deab550d6"}], "stats": {"total": 381, "additions": 181, "deletions": 200}, "files": [{"sha": "4e1aab459b1318e785e0d53e84bc08abc5888121", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 181, "deletions": 200, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/1baac86670227658962d895157d27cfd4e4ea70c/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1baac86670227658962d895157d27cfd4e4ea70c/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=1baac86670227658962d895157d27cfd4e4ea70c", "patch": "@@ -1497,20 +1497,50 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         self.allocate_hir_id_counter(opaque_ty_node_id);\n \n-        let hir_bounds = self.with_hir_id_owner(opaque_ty_node_id, lower_bounds);\n+        let collected_lifetimes = self.with_hir_id_owner(opaque_ty_node_id, move |lctx| {\n+            let hir_bounds = lower_bounds(lctx);\n \n-        let (lifetimes, lifetime_defs) = self.lifetimes_from_impl_trait_bounds(\n-            opaque_ty_node_id,\n-            opaque_ty_def_id,\n-            &hir_bounds,\n-            capturable_lifetimes,\n-        );\n+            let collected_lifetimes = lifetimes_from_impl_trait_bounds(\n+                opaque_ty_node_id,\n+                &hir_bounds,\n+                capturable_lifetimes,\n+            );\n \n-        debug!(\"lower_opaque_impl_trait: lifetimes={:#?}\", lifetimes);\n+            let lifetime_defs =\n+                lctx.arena.alloc_from_iter(collected_lifetimes.iter().map(|&(name, span)| {\n+                    let def_node_id = lctx.resolver.next_node_id();\n+                    let hir_id = lctx.lower_node_id(def_node_id);\n+                    lctx.resolver.create_def(\n+                        opaque_ty_def_id,\n+                        def_node_id,\n+                        DefPathData::LifetimeNs(name.ident().name),\n+                        ExpnId::root(),\n+                        span,\n+                    );\n \n-        debug!(\"lower_opaque_impl_trait: lifetime_defs={:#?}\", lifetime_defs);\n+                    let (name, kind) = match name {\n+                        hir::LifetimeName::Underscore => (\n+                            hir::ParamName::Plain(Ident::with_dummy_span(kw::UnderscoreLifetime)),\n+                            hir::LifetimeParamKind::Elided,\n+                        ),\n+                        hir::LifetimeName::Param(param_name) => {\n+                            (param_name, hir::LifetimeParamKind::Explicit)\n+                        }\n+                        _ => panic!(\"expected `LifetimeName::Param` or `ParamName::Plain`\"),\n+                    };\n+\n+                    hir::GenericParam {\n+                        hir_id,\n+                        name,\n+                        span,\n+                        pure_wrt_drop: false,\n+                        bounds: &[],\n+                        kind: hir::GenericParamKind::Lifetime { kind },\n+                    }\n+                }));\n+\n+            debug!(\"lower_opaque_impl_trait: lifetime_defs={:#?}\", lifetime_defs);\n \n-        self.with_hir_id_owner(opaque_ty_node_id, move |lctx| {\n             let opaque_ty_item = hir::OpaqueTy {\n                 generics: hir::Generics {\n                     params: lifetime_defs,\n@@ -1525,9 +1555,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             trace!(\"lower_opaque_impl_trait: {:#?}\", opaque_ty_def_id);\n             lctx.generate_opaque_type(opaque_ty_def_id, opaque_ty_item, span, opaque_ty_span);\n \n-            // `impl Trait` now just becomes `Foo<'a, 'b, ..>`.\n-            hir::TyKind::OpaqueDef(hir::ItemId { def_id: opaque_ty_def_id }, lifetimes)\n-        })\n+            collected_lifetimes\n+        });\n+\n+        let lifetimes =\n+            self.arena.alloc_from_iter(collected_lifetimes.into_iter().map(|(name, span)| {\n+                hir::GenericArg::Lifetime(hir::Lifetime { hir_id: self.next_id(), span, name })\n+            }));\n+\n+        debug!(\"lower_opaque_impl_trait: lifetimes={:#?}\", lifetimes);\n+\n+        // `impl Trait` now just becomes `Foo<'a, 'b, ..>`.\n+        hir::TyKind::OpaqueDef(hir::ItemId { def_id: opaque_ty_def_id }, lifetimes)\n     }\n \n     /// Registers a new opaque type with the proper `NodeId`s and\n@@ -1556,193 +1595,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.insert_item(opaque_ty_item);\n     }\n \n-    fn lifetimes_from_impl_trait_bounds(\n-        &mut self,\n-        opaque_ty_id: NodeId,\n-        parent_def_id: LocalDefId,\n-        bounds: hir::GenericBounds<'hir>,\n-        lifetimes_to_include: Option<&FxHashSet<hir::LifetimeName>>,\n-    ) -> (&'hir [hir::GenericArg<'hir>], &'hir [hir::GenericParam<'hir>]) {\n-        debug!(\n-            \"lifetimes_from_impl_trait_bounds(opaque_ty_id={:?}, \\\n-             parent_def_id={:?}, \\\n-             bounds={:#?})\",\n-            opaque_ty_id, parent_def_id, bounds,\n-        );\n-\n-        // This visitor walks over `impl Trait` bounds and creates defs for all lifetimes that\n-        // appear in the bounds, excluding lifetimes that are created within the bounds.\n-        // E.g., `'a`, `'b`, but not `'c` in `impl for<'c> SomeTrait<'a, 'b, 'c>`.\n-        struct ImplTraitLifetimeCollector<'r, 'a, 'hir> {\n-            context: &'r mut LoweringContext<'a, 'hir>,\n-            parent: LocalDefId,\n-            opaque_ty_id: NodeId,\n-            collect_elided_lifetimes: bool,\n-            currently_bound_lifetimes: Vec<hir::LifetimeName>,\n-            already_defined_lifetimes: FxHashSet<hir::LifetimeName>,\n-            output_lifetimes: Vec<hir::GenericArg<'hir>>,\n-            output_lifetime_params: Vec<hir::GenericParam<'hir>>,\n-            lifetimes_to_include: Option<&'r FxHashSet<hir::LifetimeName>>,\n-        }\n-\n-        impl<'r, 'a, 'v, 'hir> intravisit::Visitor<'v> for ImplTraitLifetimeCollector<'r, 'a, 'hir> {\n-            type Map = intravisit::ErasedMap<'v>;\n-\n-            fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n-                intravisit::NestedVisitorMap::None\n-            }\n-\n-            fn visit_generic_args(&mut self, span: Span, parameters: &'v hir::GenericArgs<'v>) {\n-                // Don't collect elided lifetimes used inside of `Fn()` syntax.\n-                if parameters.parenthesized {\n-                    let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n-                    self.collect_elided_lifetimes = false;\n-                    intravisit::walk_generic_args(self, span, parameters);\n-                    self.collect_elided_lifetimes = old_collect_elided_lifetimes;\n-                } else {\n-                    intravisit::walk_generic_args(self, span, parameters);\n-                }\n-            }\n-\n-            fn visit_ty(&mut self, t: &'v hir::Ty<'v>) {\n-                // Don't collect elided lifetimes used inside of `fn()` syntax.\n-                if let hir::TyKind::BareFn(_) = t.kind {\n-                    let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n-                    self.collect_elided_lifetimes = false;\n-\n-                    // Record the \"stack height\" of `for<'a>` lifetime bindings\n-                    // to be able to later fully undo their introduction.\n-                    let old_len = self.currently_bound_lifetimes.len();\n-                    intravisit::walk_ty(self, t);\n-                    self.currently_bound_lifetimes.truncate(old_len);\n-\n-                    self.collect_elided_lifetimes = old_collect_elided_lifetimes;\n-                } else {\n-                    intravisit::walk_ty(self, t)\n-                }\n-            }\n-\n-            fn visit_poly_trait_ref(\n-                &mut self,\n-                trait_ref: &'v hir::PolyTraitRef<'v>,\n-                modifier: hir::TraitBoundModifier,\n-            ) {\n-                // Record the \"stack height\" of `for<'a>` lifetime bindings\n-                // to be able to later fully undo their introduction.\n-                let old_len = self.currently_bound_lifetimes.len();\n-                intravisit::walk_poly_trait_ref(self, trait_ref, modifier);\n-                self.currently_bound_lifetimes.truncate(old_len);\n-            }\n-\n-            fn visit_generic_param(&mut self, param: &'v hir::GenericParam<'v>) {\n-                // Record the introduction of 'a in `for<'a> ...`.\n-                if let hir::GenericParamKind::Lifetime { .. } = param.kind {\n-                    // Introduce lifetimes one at a time so that we can handle\n-                    // cases like `fn foo<'d>() -> impl for<'a, 'b: 'a, 'c: 'b + 'd>`.\n-                    let lt_name = hir::LifetimeName::Param(param.name);\n-                    self.currently_bound_lifetimes.push(lt_name);\n-                }\n-\n-                intravisit::walk_generic_param(self, param);\n-            }\n-\n-            fn visit_lifetime(&mut self, lifetime: &'v hir::Lifetime) {\n-                let name = match lifetime.name {\n-                    hir::LifetimeName::Implicit | hir::LifetimeName::Underscore => {\n-                        if self.collect_elided_lifetimes {\n-                            // Use `'_` for both implicit and underscore lifetimes in\n-                            // `type Foo<'_> = impl SomeTrait<'_>;`.\n-                            hir::LifetimeName::Underscore\n-                        } else {\n-                            return;\n-                        }\n-                    }\n-                    hir::LifetimeName::Param(_) => lifetime.name,\n-\n-                    // Refers to some other lifetime that is \"in\n-                    // scope\" within the type.\n-                    hir::LifetimeName::ImplicitObjectLifetimeDefault => return,\n-\n-                    hir::LifetimeName::Error | hir::LifetimeName::Static => return,\n-                };\n-\n-                if !self.currently_bound_lifetimes.contains(&name)\n-                    && !self.already_defined_lifetimes.contains(&name)\n-                    && self.lifetimes_to_include.map_or(true, |lifetimes| lifetimes.contains(&name))\n-                {\n-                    self.already_defined_lifetimes.insert(name);\n-\n-                    self.output_lifetimes.push(hir::GenericArg::Lifetime(hir::Lifetime {\n-                        hir_id: self.context.next_id(),\n-                        span: self.context.lower_span(lifetime.span),\n-                        name,\n-                    }));\n-\n-                    let def_node_id = self.context.resolver.next_node_id();\n-                    let hir_id =\n-                        self.context.lower_node_id_with_owner(def_node_id, self.opaque_ty_id);\n-                    self.context.resolver.create_def(\n-                        self.parent,\n-                        def_node_id,\n-                        DefPathData::LifetimeNs(name.ident().name),\n-                        ExpnId::root(),\n-                        lifetime.span,\n-                    );\n-\n-                    let (name, kind) = match name {\n-                        hir::LifetimeName::Underscore => (\n-                            hir::ParamName::Plain(Ident::with_dummy_span(kw::UnderscoreLifetime)),\n-                            hir::LifetimeParamKind::Elided,\n-                        ),\n-                        hir::LifetimeName::Param(param_name) => {\n-                            (param_name, hir::LifetimeParamKind::Explicit)\n-                        }\n-                        _ => panic!(\"expected `LifetimeName::Param` or `ParamName::Plain`\"),\n-                    };\n-                    let name = match name {\n-                        hir::ParamName::Plain(ident) => {\n-                            hir::ParamName::Plain(self.context.lower_ident(ident))\n-                        }\n-                        name => name,\n-                    };\n-\n-                    self.output_lifetime_params.push(hir::GenericParam {\n-                        hir_id,\n-                        name,\n-                        span: self.context.lower_span(lifetime.span),\n-                        pure_wrt_drop: false,\n-                        bounds: &[],\n-                        kind: hir::GenericParamKind::Lifetime { kind },\n-                    });\n-                }\n-            }\n-        }\n-\n-        let mut lifetime_collector = ImplTraitLifetimeCollector {\n-            context: self,\n-            parent: parent_def_id,\n-            opaque_ty_id,\n-            collect_elided_lifetimes: true,\n-            currently_bound_lifetimes: Vec::new(),\n-            already_defined_lifetimes: FxHashSet::default(),\n-            output_lifetimes: Vec::new(),\n-            output_lifetime_params: Vec::new(),\n-            lifetimes_to_include,\n-        };\n-\n-        for bound in bounds {\n-            intravisit::walk_param_bound(&mut lifetime_collector, &bound);\n-        }\n-\n-        let ImplTraitLifetimeCollector { output_lifetimes, output_lifetime_params, .. } =\n-            lifetime_collector;\n-\n-        (\n-            self.arena.alloc_from_iter(output_lifetimes),\n-            self.arena.alloc_from_iter(output_lifetime_params),\n-        )\n-    }\n-\n     fn lower_fn_params_to_names(&mut self, decl: &FnDecl) -> &'hir [Ident] {\n         // Skip the `...` (`CVarArgs`) trailing arguments from the AST,\n         // as they are not explicit in HIR/Ty function signatures.\n@@ -2723,3 +2575,132 @@ impl<'hir> GenericArgsCtor<'hir> {\n         this.arena.alloc(ga)\n     }\n }\n+\n+fn lifetimes_from_impl_trait_bounds(\n+    opaque_ty_id: NodeId,\n+    bounds: hir::GenericBounds<'_>,\n+    lifetimes_to_include: Option<&FxHashSet<hir::LifetimeName>>,\n+) -> Vec<(hir::LifetimeName, Span)> {\n+    debug!(\n+        \"lifetimes_from_impl_trait_bounds(opaque_ty_id={:?}, \\\n+             bounds={:#?})\",\n+        opaque_ty_id, bounds,\n+    );\n+\n+    // This visitor walks over `impl Trait` bounds and creates defs for all lifetimes that\n+    // appear in the bounds, excluding lifetimes that are created within the bounds.\n+    // E.g., `'a`, `'b`, but not `'c` in `impl for<'c> SomeTrait<'a, 'b, 'c>`.\n+    struct ImplTraitLifetimeCollector<'r> {\n+        collect_elided_lifetimes: bool,\n+        currently_bound_lifetimes: Vec<hir::LifetimeName>,\n+        already_defined_lifetimes: FxHashSet<hir::LifetimeName>,\n+        lifetimes: Vec<(hir::LifetimeName, Span)>,\n+        lifetimes_to_include: Option<&'r FxHashSet<hir::LifetimeName>>,\n+    }\n+\n+    impl<'r, 'v> intravisit::Visitor<'v> for ImplTraitLifetimeCollector<'r> {\n+        type Map = intravisit::ErasedMap<'v>;\n+\n+        fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+            intravisit::NestedVisitorMap::None\n+        }\n+\n+        fn visit_generic_args(&mut self, span: Span, parameters: &'v hir::GenericArgs<'v>) {\n+            // Don't collect elided lifetimes used inside of `Fn()` syntax.\n+            if parameters.parenthesized {\n+                let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n+                self.collect_elided_lifetimes = false;\n+                intravisit::walk_generic_args(self, span, parameters);\n+                self.collect_elided_lifetimes = old_collect_elided_lifetimes;\n+            } else {\n+                intravisit::walk_generic_args(self, span, parameters);\n+            }\n+        }\n+\n+        fn visit_ty(&mut self, t: &'v hir::Ty<'v>) {\n+            // Don't collect elided lifetimes used inside of `fn()` syntax.\n+            if let hir::TyKind::BareFn(_) = t.kind {\n+                let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n+                self.collect_elided_lifetimes = false;\n+\n+                // Record the \"stack height\" of `for<'a>` lifetime bindings\n+                // to be able to later fully undo their introduction.\n+                let old_len = self.currently_bound_lifetimes.len();\n+                intravisit::walk_ty(self, t);\n+                self.currently_bound_lifetimes.truncate(old_len);\n+\n+                self.collect_elided_lifetimes = old_collect_elided_lifetimes;\n+            } else {\n+                intravisit::walk_ty(self, t)\n+            }\n+        }\n+\n+        fn visit_poly_trait_ref(\n+            &mut self,\n+            trait_ref: &'v hir::PolyTraitRef<'v>,\n+            modifier: hir::TraitBoundModifier,\n+        ) {\n+            // Record the \"stack height\" of `for<'a>` lifetime bindings\n+            // to be able to later fully undo their introduction.\n+            let old_len = self.currently_bound_lifetimes.len();\n+            intravisit::walk_poly_trait_ref(self, trait_ref, modifier);\n+            self.currently_bound_lifetimes.truncate(old_len);\n+        }\n+\n+        fn visit_generic_param(&mut self, param: &'v hir::GenericParam<'v>) {\n+            // Record the introduction of 'a in `for<'a> ...`.\n+            if let hir::GenericParamKind::Lifetime { .. } = param.kind {\n+                // Introduce lifetimes one at a time so that we can handle\n+                // cases like `fn foo<'d>() -> impl for<'a, 'b: 'a, 'c: 'b + 'd>`.\n+                let lt_name = hir::LifetimeName::Param(param.name);\n+                self.currently_bound_lifetimes.push(lt_name);\n+            }\n+\n+            intravisit::walk_generic_param(self, param);\n+        }\n+\n+        fn visit_lifetime(&mut self, lifetime: &'v hir::Lifetime) {\n+            let name = match lifetime.name {\n+                hir::LifetimeName::Implicit | hir::LifetimeName::Underscore => {\n+                    if self.collect_elided_lifetimes {\n+                        // Use `'_` for both implicit and underscore lifetimes in\n+                        // `type Foo<'_> = impl SomeTrait<'_>;`.\n+                        hir::LifetimeName::Underscore\n+                    } else {\n+                        return;\n+                    }\n+                }\n+                hir::LifetimeName::Param(_) => lifetime.name,\n+\n+                // Refers to some other lifetime that is \"in\n+                // scope\" within the type.\n+                hir::LifetimeName::ImplicitObjectLifetimeDefault => return,\n+\n+                hir::LifetimeName::Error | hir::LifetimeName::Static => return,\n+            };\n+\n+            if !self.currently_bound_lifetimes.contains(&name)\n+                && !self.already_defined_lifetimes.contains(&name)\n+                && self.lifetimes_to_include.map_or(true, |lifetimes| lifetimes.contains(&name))\n+            {\n+                self.already_defined_lifetimes.insert(name);\n+\n+                self.lifetimes.push((name, lifetime.span));\n+            }\n+        }\n+    }\n+\n+    let mut lifetime_collector = ImplTraitLifetimeCollector {\n+        collect_elided_lifetimes: true,\n+        currently_bound_lifetimes: Vec::new(),\n+        already_defined_lifetimes: FxHashSet::default(),\n+        lifetimes: Vec::new(),\n+        lifetimes_to_include,\n+    };\n+\n+    for bound in bounds {\n+        intravisit::walk_param_bound(&mut lifetime_collector, &bound);\n+    }\n+\n+    lifetime_collector.lifetimes\n+}"}]}