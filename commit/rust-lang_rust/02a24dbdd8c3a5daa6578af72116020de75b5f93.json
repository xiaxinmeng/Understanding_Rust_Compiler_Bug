{"sha": "02a24dbdd8c3a5daa6578af72116020de75b5f93", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyYTI0ZGJkZDhjM2E1ZGFhNjU3OGFmNzIxMTYwMjBkZTc1YjVmOTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-13T20:14:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-13T20:14:38Z"}, "message": "Auto merge of #45069 - sinkuu:tuple_arg, r=nikomatsakis\n\nBetter error for missing tuple pattern in args\n\n#44150\n\nBefore:\n```\nerror[E0593]: closure takes 2 arguments but 1 argument is required\n --> test.rs:5:40\n  |\n5 |     let it = v.into_iter().enumerate().map(|i, x| i);\n  |                                        ^^^ -------- takes 2 arguments\n  |                                        |\n  |                                        expected closure that takes 1 argument\n```\n\nAfter:\n```\nerror[E0593]: closure takes 2 arguments but a 2-tuple is required\n --> test.rs:5:40\n  |\n5 |     let it = v.into_iter().enumerate().map(|i, x| i);\n  |                                        ^^^ ------ takes 2 arguments\n  |                                        |\n  |                                        expected closure that takes a 2-tuple\n```", "tree": {"sha": "649fdefa210fce381e1581457b8eb530dd2055a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/649fdefa210fce381e1581457b8eb530dd2055a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02a24dbdd8c3a5daa6578af72116020de75b5f93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02a24dbdd8c3a5daa6578af72116020de75b5f93", "html_url": "https://github.com/rust-lang/rust/commit/02a24dbdd8c3a5daa6578af72116020de75b5f93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02a24dbdd8c3a5daa6578af72116020de75b5f93/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c", "html_url": "https://github.com/rust-lang/rust/commit/6cb49d2a3e86f0d2f220f12c59c0ebb2965ff38c"}, {"sha": "f577847aa22cda4935562fe8e7c9420bcc58f148", "url": "https://api.github.com/repos/rust-lang/rust/commits/f577847aa22cda4935562fe8e7c9420bcc58f148", "html_url": "https://github.com/rust-lang/rust/commit/f577847aa22cda4935562fe8e7c9420bcc58f148"}], "stats": {"total": 261, "additions": 209, "deletions": 52}, "files": [{"sha": "030b7e4f646f924d8360e18af59113a512f282f9", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 172, "deletions": 43, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/02a24dbdd8c3a5daa6578af72116020de75b5f93/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02a24dbdd8c3a5daa6578af72116020de75b5f93/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=02a24dbdd8c3a5daa6578af72116020de75b5f93", "patch": "@@ -711,41 +711,105 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            OutputTypeParameterMismatch(ref expected_trait_ref, ref actual_trait_ref, _) => {\n+            OutputTypeParameterMismatch(ref found_trait_ref, ref expected_trait_ref, _) => {\n+                let found_trait_ref = self.resolve_type_vars_if_possible(&*found_trait_ref);\n                 let expected_trait_ref = self.resolve_type_vars_if_possible(&*expected_trait_ref);\n-                let actual_trait_ref = self.resolve_type_vars_if_possible(&*actual_trait_ref);\n-                if actual_trait_ref.self_ty().references_error() {\n+                if expected_trait_ref.self_ty().references_error() {\n                     return;\n                 }\n-                let expected_trait_ty = expected_trait_ref.self_ty();\n-                let found_span = expected_trait_ty.ty_to_def_id().and_then(|did| {\n+                let found_trait_ty = found_trait_ref.self_ty();\n+\n+                let found_did = found_trait_ty.ty_to_def_id();\n+                let found_span = found_did.and_then(|did| {\n                     self.tcx.hir.span_if_local(did)\n                 });\n \n-                let self_ty_count =\n-                    match expected_trait_ref.skip_binder().substs.type_at(1).sty {\n+                let found_ty_count =\n+                    match found_trait_ref.skip_binder().substs.type_at(1).sty {\n                         ty::TyTuple(ref tys, _) => tys.len(),\n                         _ => 1,\n                     };\n-                let arg_ty_count =\n-                    match actual_trait_ref.skip_binder().substs.type_at(1).sty {\n-                        ty::TyTuple(ref tys, _) => tys.len(),\n-                        _ => 1,\n+                let (expected_tys, expected_ty_count) =\n+                    match expected_trait_ref.skip_binder().substs.type_at(1).sty {\n+                        ty::TyTuple(ref tys, _) =>\n+                            (tys.iter().map(|t| &t.sty).collect(), tys.len()),\n+                        ref sty => (vec![sty], 1),\n                     };\n-                if self_ty_count == arg_ty_count {\n+                if found_ty_count == expected_ty_count {\n                     self.report_closure_arg_mismatch(span,\n                                                      found_span,\n-                                                     expected_trait_ref,\n-                                                     actual_trait_ref)\n+                                                     found_trait_ref,\n+                                                     expected_trait_ref)\n                 } else {\n-                    // Expected `|| { }`, found `|x, y| { }`\n-                    // Expected `fn(x) -> ()`, found `|| { }`\n+                    let expected_tuple = if expected_ty_count == 1 {\n+                        expected_tys.first().and_then(|t| {\n+                            if let &&ty::TyTuple(ref tuptys, _) = t {\n+                                Some(tuptys.len())\n+                            } else {\n+                                None\n+                            }\n+                        })\n+                    } else {\n+                        None\n+                    };\n+\n+                    // FIXME(#44150): Expand this to \"N args expected but a N-tuple found.\"\n+                    // Type of the 1st expected argument is somehow provided as type of a\n+                    // found one in that case.\n+                    //\n+                    // ```\n+                    // [1i32, 2, 3].sort_by(|(a, b)| ..)\n+                    // //                   ^^^^^^^^\n+                    // // expected_trait_ref:  std::ops::FnMut<(&i32, &i32)>\n+                    // //    found_trait_ref:  std::ops::FnMut<(&i32,)>\n+                    // ```\n+\n+                    let (closure_span, closure_args) = found_did\n+                        .and_then(|did| self.tcx.hir.get_if_local(did))\n+                        .and_then(|node| {\n+                            if let hir::map::NodeExpr(\n+                                &hir::Expr {\n+                                    node: hir::ExprClosure(_, ref decl, id, span, _),\n+                                    ..\n+                                }) = node\n+                            {\n+                                let ty_snips = decl.inputs.iter()\n+                                    .map(|ty| {\n+                                        self.tcx.sess.codemap().span_to_snippet(ty.span).ok()\n+                                            .and_then(|snip| {\n+                                                // filter out dummy spans\n+                                                if snip == \",\" || snip == \"|\" {\n+                                                    None\n+                                                } else {\n+                                                    Some(snip)\n+                                                }\n+                                            })\n+                                    })\n+                                    .collect::<Vec<Option<String>>>();\n+\n+                                let body = self.tcx.hir.body(id);\n+                                let pat_snips = body.arguments.iter()\n+                                    .map(|arg|\n+                                        self.tcx.sess.codemap().span_to_snippet(arg.pat.span).ok())\n+                                    .collect::<Option<Vec<String>>>();\n+\n+                                Some((span, pat_snips, ty_snips))\n+                            } else {\n+                                None\n+                            }\n+                        })\n+                        .map(|(span, pat, ty)| (Some(span), Some((pat, ty))))\n+                        .unwrap_or((None, None));\n+                    let closure_args = closure_args.and_then(|(pat, ty)| Some((pat?, ty)));\n+\n                     self.report_arg_count_mismatch(\n                         span,\n-                        found_span,\n-                        arg_ty_count,\n-                        self_ty_count,\n-                        expected_trait_ty.is_closure()\n+                        closure_span.or(found_span),\n+                        expected_ty_count,\n+                        expected_tuple,\n+                        found_ty_count,\n+                        closure_args,\n+                        found_trait_ty.is_closure()\n                     )\n                 }\n             }\n@@ -767,32 +831,97 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         err.emit();\n     }\n \n-    fn report_arg_count_mismatch(&self,\n-                                 span: Span,\n-                                 found_span: Option<Span>,\n-                                 expected: usize,\n-                                 found: usize,\n-                                 is_closure: bool)\n-        -> DiagnosticBuilder<'tcx>\n-    {\n+    fn report_arg_count_mismatch(\n+        &self,\n+        span: Span,\n+        found_span: Option<Span>,\n+        expected: usize,\n+        expected_tuple: Option<usize>,\n+        found: usize,\n+        closure_args: Option<(Vec<String>, Vec<Option<String>>)>,\n+        is_closure: bool\n+    ) -> DiagnosticBuilder<'tcx> {\n+        use std::borrow::Cow;\n+\n+        let kind = if is_closure { \"closure\" } else { \"function\" };\n+\n+        let args_str = |n, distinct| format!(\n+                \"{} {}argument{}\",\n+                n,\n+                if distinct && n >= 2 { \"distinct \" } else { \"\" },\n+                if n == 1 { \"\" } else { \"s\" },\n+            );\n+\n+        let expected_str = if let Some(n) = expected_tuple {\n+            assert!(expected == 1);\n+            if closure_args.as_ref().map(|&(ref pats, _)| pats.len()) == Some(n) {\n+                Cow::from(\"a single tuple as argument\")\n+            } else {\n+                // be verbose when numbers differ\n+                Cow::from(format!(\"a single {}-tuple as argument\", n))\n+            }\n+        } else {\n+            Cow::from(args_str(expected, false))\n+        };\n+\n+        let found_str = if expected_tuple.is_some() {\n+            args_str(found, true)\n+        } else {\n+            args_str(found, false)\n+        };\n+\n+\n         let mut err = struct_span_err!(self.tcx.sess, span, E0593,\n-            \"{} takes {} argument{} but {} argument{} {} required\",\n-            if is_closure { \"closure\" } else { \"function\" },\n-            found,\n-            if found == 1 { \"\" } else { \"s\" },\n-            expected,\n-            if expected == 1 { \"\" } else { \"s\" },\n-            if expected == 1 { \"is\" } else { \"are\" });\n-\n-        err.span_label(span, format!(\"expected {} that takes {} argument{}\",\n-                                      if is_closure { \"closure\" } else { \"function\" },\n-                                      expected,\n-                                      if expected == 1 { \"\" } else { \"s\" }));\n+            \"{} is expected to take {}, but it takes {}\",\n+            kind,\n+            expected_str,\n+            found_str,\n+        );\n+\n+        err.span_label(\n+            span,\n+            format!(\n+                \"expected {} that takes {}\",\n+                kind,\n+                expected_str,\n+            )\n+        );\n+\n         if let Some(span) = found_span {\n-            err.span_label(span, format!(\"takes {} argument{}\",\n-                                          found,\n-                                          if found == 1 { \"\" } else { \"s\" }));\n+            if let (Some(expected_tuple), Some((pats, tys))) = (expected_tuple, closure_args) {\n+                if expected_tuple != found || pats.len() != found {\n+                    err.span_label(span, format!(\"takes {}\", found_str));\n+                } else {\n+                    let sugg = format!(\n+                        \"|({}){}|\",\n+                        pats.join(\", \"),\n+\n+                        // add type annotations if available\n+                        if tys.iter().any(|ty| ty.is_some()) {\n+                            Cow::from(format!(\n+                                \": ({})\",\n+                                tys.into_iter().map(|ty| if let Some(ty) = ty {\n+                                    ty\n+                                } else {\n+                                    \"_\".to_string()\n+                                }).collect::<Vec<String>>().join(\", \")\n+                            ))\n+                        } else {\n+                            Cow::from(\"\")\n+                        },\n+                    );\n+\n+                    err.span_suggestion(\n+                        span,\n+                        \"consider changing the closure to accept a tuple\",\n+                        sugg\n+                    );\n+                }\n+            } else {\n+                err.span_label(span, format!(\"takes {}\", found_str));\n+            }\n         }\n+\n         err\n     }\n "}, {"sha": "5d2d1d2b04c50c2c033470036afcc657249b0897", "filename": "src/test/ui/mismatched_types/closure-arg-count.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02a24dbdd8c3a5daa6578af72116020de75b5f93/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02a24dbdd8c3a5daa6578af72116020de75b5f93/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.rs?ref=02a24dbdd8c3a5daa6578af72116020de75b5f93", "patch": "@@ -16,4 +16,8 @@ fn main() {\n     [1, 2, 3].sort_by(|tuple| panic!());\n     [1, 2, 3].sort_by(|(tuple, tuple2)| panic!());\n     f(|| panic!());\n+\n+    let _it = vec![1, 2, 3].into_iter().enumerate().map(|i, x| i);\n+    let _it = vec![1, 2, 3].into_iter().enumerate().map(|i: usize, x| i);\n+    let _it = vec![1, 2, 3].into_iter().enumerate().map(|i, x, y| i);\n }"}, {"sha": "9d4ac6305465a54ba1efeeb491e2d926ca41a10d", "filename": "src/test/ui/mismatched_types/closure-arg-count.stderr", "status": "modified", "additions": 33, "deletions": 9, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/02a24dbdd8c3a5daa6578af72116020de75b5f93/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02a24dbdd8c3a5daa6578af72116020de75b5f93/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr?ref=02a24dbdd8c3a5daa6578af72116020de75b5f93", "patch": "@@ -1,16 +1,16 @@\n-error[E0593]: closure takes 0 arguments but 2 arguments are required\n+error[E0593]: closure is expected to take 2 arguments, but it takes 0 arguments\n   --> $DIR/closure-arg-count.rs:15:15\n    |\n 15 |     [1, 2, 3].sort_by(|| panic!());\n-   |               ^^^^^^^ ----------- takes 0 arguments\n+   |               ^^^^^^^ -- takes 0 arguments\n    |               |\n    |               expected closure that takes 2 arguments\n \n-error[E0593]: closure takes 1 argument but 2 arguments are required\n+error[E0593]: closure is expected to take 2 arguments, but it takes 1 argument\n   --> $DIR/closure-arg-count.rs:16:15\n    |\n 16 |     [1, 2, 3].sort_by(|tuple| panic!());\n-   |               ^^^^^^^ ---------------- takes 1 argument\n+   |               ^^^^^^^ ------- takes 1 argument\n    |               |\n    |               expected closure that takes 2 arguments\n \n@@ -23,23 +23,47 @@ error[E0308]: mismatched types\n    = note: expected type `&{integer}`\n               found type `(_, _)`\n \n-error[E0593]: closure takes 1 argument but 2 arguments are required\n+error[E0593]: closure is expected to take 2 arguments, but it takes 1 argument\n   --> $DIR/closure-arg-count.rs:17:15\n    |\n 17 |     [1, 2, 3].sort_by(|(tuple, tuple2)| panic!());\n-   |               ^^^^^^^ -------------------------- takes 1 argument\n+   |               ^^^^^^^ ----------------- takes 1 argument\n    |               |\n    |               expected closure that takes 2 arguments\n \n-error[E0593]: closure takes 0 arguments but 1 argument is required\n+error[E0593]: closure is expected to take 1 argument, but it takes 0 arguments\n   --> $DIR/closure-arg-count.rs:18:5\n    |\n 18 |     f(|| panic!());\n-   |     ^ ----------- takes 0 arguments\n+   |     ^ -- takes 0 arguments\n    |     |\n    |     expected closure that takes 1 argument\n    |\n    = note: required by `f`\n \n-error: aborting due to 5 previous errors\n+error[E0593]: closure is expected to take a single tuple as argument, but it takes 2 distinct arguments\n+  --> $DIR/closure-arg-count.rs:20:53\n+   |\n+20 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(|i, x| i);\n+   |                                                     ^^^ ------ help: consider changing the closure to accept a tuple: `|(i, x)|`\n+   |                                                     |\n+   |                                                     expected closure that takes a single tuple as argument\n+\n+error[E0593]: closure is expected to take a single tuple as argument, but it takes 2 distinct arguments\n+  --> $DIR/closure-arg-count.rs:21:53\n+   |\n+21 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(|i: usize, x| i);\n+   |                                                     ^^^ ------------- help: consider changing the closure to accept a tuple: `|(i, x): (usize, _)|`\n+   |                                                     |\n+   |                                                     expected closure that takes a single tuple as argument\n+\n+error[E0593]: closure is expected to take a single 2-tuple as argument, but it takes 3 distinct arguments\n+  --> $DIR/closure-arg-count.rs:22:53\n+   |\n+22 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(|i, x, y| i);\n+   |                                                     ^^^ --------- takes 3 distinct arguments\n+   |                                                     |\n+   |                                                     expected closure that takes a single 2-tuple as argument\n+\n+error: aborting due to 8 previous errors\n "}]}