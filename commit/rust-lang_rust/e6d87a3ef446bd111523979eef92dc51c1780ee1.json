{"sha": "e6d87a3ef446bd111523979eef92dc51c1780ee1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2ZDg3YTNlZjQ0NmJkMTExNTIzOTc5ZWVmOTJkYzUxYzE3ODBlZTE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-21T03:20:55Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-21T18:27:37Z"}, "message": "libsyntax: Implement `deriving` correctly for type-parameterized structs and enums. r=brson", "tree": {"sha": "6008f9f8e8984904348307046c8cf9a45089ef0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6008f9f8e8984904348307046c8cf9a45089ef0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6d87a3ef446bd111523979eef92dc51c1780ee1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6d87a3ef446bd111523979eef92dc51c1780ee1", "html_url": "https://github.com/rust-lang/rust/commit/e6d87a3ef446bd111523979eef92dc51c1780ee1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6d87a3ef446bd111523979eef92dc51c1780ee1/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57588edf3bc2450fd1daff4ec2565fe5edbedcef", "url": "https://api.github.com/repos/rust-lang/rust/commits/57588edf3bc2450fd1daff4ec2565fe5edbedcef", "html_url": "https://github.com/rust-lang/rust/commit/57588edf3bc2450fd1daff4ec2565fe5edbedcef"}], "stats": {"total": 229, "additions": 168, "deletions": 61}, "files": [{"sha": "d6b653c618997091200d94704f37d194b2ffb452", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e6d87a3ef446bd111523979eef92dc51c1780ee1/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d87a3ef446bd111523979eef92dc51c1780ee1/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=e6d87a3ef446bd111523979eef92dc51c1780ee1", "patch": "@@ -39,6 +39,12 @@ fn mk_raw_path(sp: span, idents: ~[ast::ident]) -> @ast::path {\n                            rp: None, types: ~[]};\n     return p;\n }\n+fn mk_raw_path_(sp: span,\n+                idents: ~[ast::ident],\n+                +types: ~[@ast::Ty])\n+             -> @ast::path {\n+    @{ span: sp, global: false, idents: idents, rp: None, types: move types }\n+}\n fn mk_path(cx: ext_ctxt, sp: span, idents: ~[ast::ident]) ->\n     @ast::expr {\n     mk_expr(cx, sp, ast::expr_path(mk_raw_path(sp, idents)))\n@@ -224,4 +230,10 @@ fn mk_arg(cx: ext_ctxt,\n fn mk_fn_decl(+inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl {\n     { inputs: move inputs, output: output, cf: ast::return_val }\n }\n+fn mk_ty_param(cx: ext_ctxt,\n+               ident: ast::ident,\n+               bounds: @~[ast::ty_param_bound])\n+            -> ast::ty_param {\n+    { ident: ident, id: cx.next_id(), bounds: bounds }\n+}\n "}, {"sha": "4a92086963ec6db42bc61f3f30d8712ae14b1d74", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 139, "deletions": 61, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/e6d87a3ef446bd111523979eef92dc51c1780ee1/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d87a3ef446bd111523979eef92dc51c1780ee1/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=e6d87a3ef446bd111523979eef92dc51c1780ee1", "patch": "@@ -1,15 +1,13 @@\n /// The compiler code necessary to implement the #[deriving_eq] and\n /// #[deriving_iter_bytes] extensions.\n \n-use ast::{and, bind_by_ref, binop, blk, default_blk, deref, enum_def};\n-use ast::{enum_variant_kind, expr};\n-use ast::{expr_, expr_addr_of, expr_binary, expr_call, expr_field, expr_lit};\n-use ast::{expr_match, expr_path, expr_unary, ident, infer, item, item_};\n-use ast::{item_class, item_enum, item_impl, lit_bool, m_imm, meta_item};\n-use ast::{method, named_field, or, pat, pat_ident, pat_wild, path, public};\n-use ast::{pure_fn, re_anon, return_val, stmt, struct_def};\n+use ast::{Ty, and, bind_by_ref, binop, deref, enum_def, enum_variant_kind};\n+use ast::{expr, expr_match, ident, item, item_, item_class, item_enum};\n+use ast::{item_impl, m_imm, meta_item, method, named_field, or, pat};\n+use ast::{pat_ident, pat_wild, public, pure_fn, re_anon, stmt, struct_def};\n use ast::{struct_variant_kind, sty_by_ref, sty_region, tuple_variant_kind};\n-use ast::{ty_nil, ty_path, ty_rptr, unnamed_field, variant};\n+use ast::{ty_nil, ty_param, ty_param_bound, ty_path, ty_rptr, unnamed_field};\n+use ast::{variant};\n use base::ext_ctxt;\n use codemap::span;\n use parse::token::special_idents::clownshoes_extensions;\n@@ -31,13 +29,15 @@ impl Junction {\n type ExpandDerivingStructDefFn = &fn(ext_ctxt,\n                                      span,\n                                      x: &struct_def,\n-                                     ident)\n-                                  -> @item;\n-type ExpandDerivingEnumDefFn   = &fn(ext_ctxt,\n-                                     span,\n-                                     x: &enum_def,\n-                                     ident)\n+                                     ident,\n+                                     +y: ~[ty_param])\n                                   -> @item;\n+type ExpandDerivingEnumDefFn = &fn(ext_ctxt,\n+                                   span,\n+                                   x: &enum_def,\n+                                   ident,\n+                                   +y: ~[ty_param])\n+                                -> @item;\n \n pub fn expand_deriving_eq(cx: ext_ctxt,\n                           span: span,\n@@ -73,17 +73,19 @@ fn expand_deriving(cx: ext_ctxt,\n     for in_items.each |item| {\n         result.push(copy *item);\n         match item.node {\n-            item_class(struct_def, _) => {\n+            item_class(struct_def, copy ty_params) => {\n                 result.push(expand_deriving_struct_def(cx,\n                                                        span,\n                                                        struct_def,\n-                                                       item.ident));\n+                                                       item.ident,\n+                                                       move ty_params));\n             }\n-            item_enum(ref enum_definition, _) => {\n+            item_enum(ref enum_definition, copy ty_params) => {\n                 result.push(expand_deriving_enum_def(cx,\n                                                      span,\n                                                      enum_definition,\n-                                                     item.ident));\n+                                                     item.ident,\n+                                                     move ty_params));\n             }\n             _ => ()\n         }\n@@ -97,7 +99,7 @@ fn create_impl_item(cx: ext_ctxt, span: span, +item: item_) -> @item {\n         attrs: ~[],\n         id: cx.next_id(),\n         node: move item,\n-        vis: ast::public,\n+        vis: public,\n         span: span,\n     }\n }\n@@ -108,10 +110,14 @@ fn create_eq_method(cx: ext_ctxt,\n                     span: span,\n                     method_ident: ident,\n                     type_ident: ident,\n+                    ty_params: &[ty_param],\n                     body: @expr)\n                  -> @method {\n     // Create the type of the `other` parameter.\n-    let arg_path_type = build::mk_simple_ty_path(cx, span, type_ident);\n+    let arg_path_type = create_self_type_with_params(cx,\n+                                                     span,\n+                                                     type_ident,\n+                                                     ty_params);\n     let arg_region = @{ id: cx.next_id(), node: re_anon };\n     let arg_type = ty_rptr(arg_region, { ty: arg_path_type, mutbl: m_imm });\n     let arg_type = @{ id: cx.next_id(), node: move arg_type, span: span };\n@@ -153,12 +159,46 @@ fn create_eq_method(cx: ext_ctxt,\n     };\n }\n \n+fn create_self_type_with_params(cx: ext_ctxt,\n+                                span: span,\n+                                type_ident: ident,\n+                                ty_params: &[ty_param])\n+                             -> @Ty {\n+    // Create the type parameters on the `self` path.\n+    let self_ty_params = dvec::DVec();\n+    for ty_params.each |ty_param| {\n+        let self_ty_param = build::mk_simple_ty_path(cx,\n+                                                     span,\n+                                                     ty_param.ident);\n+        self_ty_params.push(move self_ty_param);\n+    }\n+    let self_ty_params = dvec::unwrap(move self_ty_params);\n+\n+    // Create the type of `self`.\n+    let self_type = build::mk_raw_path_(span,\n+                                        ~[ type_ident ],\n+                                        move self_ty_params);\n+    let self_type = ty_path(self_type, cx.next_id());\n+    @{ id: cx.next_id(), node: move self_type, span: span }\n+}\n+\n fn create_derived_impl(cx: ext_ctxt,\n                        span: span,\n                        type_ident: ident,\n+                       +ty_params: ~[ty_param],\n                        methods: &[@method],\n-                       trait_path: &[ast::ident])\n+                       trait_path: &[ident])\n                     -> @item {\n+    // Create the type parameters.\n+    let impl_ty_params = dvec::DVec();\n+    for ty_params.each |ty_param| {\n+        let bound = build::mk_ty_path(cx, span, trait_path.map(|x| *x));\n+        let bounds = @~[ ty_param_bound(bound) ];\n+        let impl_ty_param = build::mk_ty_param(cx, ty_param.ident, bounds);\n+        impl_ty_params.push(move impl_ty_param);\n+    }\n+    let impl_ty_params = dvec::unwrap(move impl_ty_params);\n+\n     // Create the reference to the trait.\n     let trait_path = {\n         span: span,\n@@ -176,12 +216,13 @@ fn create_derived_impl(cx: ext_ctxt,\n     let trait_ref = @move trait_ref;\n \n     // Create the type of `self`.\n-    let self_type = build::mk_raw_path(span, ~[ type_ident ]);\n-    let self_type = ty_path(self_type, cx.next_id());\n-    let self_type = @{ id: cx.next_id(), node: move self_type, span: span };\n+    let self_type = create_self_type_with_params(cx,\n+                                                 span,\n+                                                 type_ident,\n+                                                 ty_params);\n \n     // Create the impl item.\n-    let impl_item = item_impl(~[],\n+    let impl_item = item_impl(move impl_ty_params,\n                               Some(trait_ref),\n                               self_type,\n                               methods.map(|x| *x));\n@@ -191,6 +232,7 @@ fn create_derived_impl(cx: ext_ctxt,\n fn create_derived_eq_impl(cx: ext_ctxt,\n                           span: span,\n                           type_ident: ident,\n+                          +ty_params: ~[ty_param],\n                           eq_method: @method,\n                           ne_method: @method)\n                        -> @item {\n@@ -200,20 +242,22 @@ fn create_derived_eq_impl(cx: ext_ctxt,\n         cx.ident_of(~\"cmp\"),\n         cx.ident_of(~\"Eq\")\n     ];\n-    create_derived_impl(cx, span, type_ident, methods, trait_path)\n+    create_derived_impl(cx, span, type_ident, ty_params, methods, trait_path)\n }\n \n fn create_derived_iter_bytes_impl(cx: ext_ctxt,\n                                   span: span,\n                                   type_ident: ident,\n+                                  +ty_params: ~[ty_param],\n                                   method: @method)\n                                -> @item {\n+    let methods = [ method ];\n     let trait_path = [\n         cx.ident_of(~\"core\"),\n         cx.ident_of(~\"to_bytes\"),\n         cx.ident_of(~\"IterBytes\")\n     ];\n-    create_derived_impl(cx, span, type_ident, [ method ], trait_path)\n+    create_derived_impl(cx, span, type_ident, ty_params, methods, trait_path)\n }\n \n // Creates a method from the given set of statements conforming to the\n@@ -267,9 +311,9 @@ fn create_iter_bytes_method(cx: ext_ctxt,\n \n fn create_enum_variant_pattern(cx: ext_ctxt,\n                                span: span,\n-                               variant: &ast::variant,\n+                               variant: &variant,\n                                prefix: ~str)\n-                            -> @ast::pat {\n+                            -> @pat {\n     let variant_ident = variant.node.name;\n     match variant.node.kind {\n         tuple_variant_kind(ref variant_args) => {\n@@ -386,7 +430,8 @@ fn variant_arg_count(cx: ext_ctxt, span: span, variant: &variant) -> uint {\n fn expand_deriving_eq_struct_def(cx: ext_ctxt,\n                                  span: span,\n                                  struct_def: &struct_def,\n-                                 type_ident: ident)\n+                                 type_ident: ident,\n+                                 +ty_params: ~[ty_param])\n                               -> @item {\n     // Create the methods.\n     let eq_ident = cx.ident_of(~\"eq\");\n@@ -396,51 +441,102 @@ fn expand_deriving_eq_struct_def(cx: ext_ctxt,\n                                                      struct_def,\n                                                      eq_ident,\n                                                      type_ident,\n+                                                     ty_params,\n                                                      Conjunction);\n     let ne_method = expand_deriving_eq_struct_method(cx,\n                                                      span,\n                                                      struct_def,\n                                                      ne_ident,\n                                                      type_ident,\n+                                                     ty_params,\n                                                      Disjunction);\n \n     // Create the implementation.\n-    return create_derived_eq_impl(cx, span, type_ident, eq_method, ne_method);\n+    return create_derived_eq_impl(cx,\n+                                  span,\n+                                  type_ident,\n+                                  move ty_params,\n+                                  eq_method,\n+                                  ne_method);\n+}\n+\n+fn expand_deriving_eq_enum_def(cx: ext_ctxt,\n+                               span: span,\n+                               enum_definition: &enum_def,\n+                               type_ident: ident,\n+                               +ty_params: ~[ty_param])\n+                            -> @item {\n+    // Create the methods.\n+    let eq_ident = cx.ident_of(~\"eq\");\n+    let ne_ident = cx.ident_of(~\"ne\");\n+    let eq_method = expand_deriving_eq_enum_method(cx,\n+                                                   span,\n+                                                   enum_definition,\n+                                                   eq_ident,\n+                                                   type_ident,\n+                                                   ty_params,\n+                                                   Conjunction);\n+    let ne_method = expand_deriving_eq_enum_method(cx,\n+                                                   span,\n+                                                   enum_definition,\n+                                                   ne_ident,\n+                                                   type_ident,\n+                                                   ty_params,\n+                                                   Disjunction);\n+\n+    // Create the implementation.\n+    return create_derived_eq_impl(cx,\n+                                  span,\n+                                  type_ident,\n+                                  move ty_params,\n+                                  eq_method,\n+                                  ne_method);\n }\n \n fn expand_deriving_iter_bytes_struct_def(cx: ext_ctxt,\n                                          span: span,\n                                          struct_def: &struct_def,\n-                                         type_ident: ident)\n+                                         type_ident: ident,\n+                                         +ty_params: ~[ty_param])\n                                       -> @item {\n     // Create the method.\n     let method = expand_deriving_iter_bytes_struct_method(cx,\n                                                           span,\n                                                           struct_def);\n \n     // Create the implementation.\n-    return create_derived_iter_bytes_impl(cx, span, type_ident, method);\n+    return create_derived_iter_bytes_impl(cx,\n+                                          span,\n+                                          type_ident,\n+                                          move ty_params,\n+                                          method);\n }\n \n fn expand_deriving_iter_bytes_enum_def(cx: ext_ctxt,\n                                        span: span,\n                                        enum_definition: &enum_def,\n-                                       type_ident: ident)\n+                                       type_ident: ident,\n+                                       +ty_params: ~[ty_param])\n                                     -> @item {\n     // Create the method.\n     let method = expand_deriving_iter_bytes_enum_method(cx,\n                                                         span,\n                                                         enum_definition);\n \n     // Create the implementation.\n-    return create_derived_iter_bytes_impl(cx, span, type_ident, method);\n+    return create_derived_iter_bytes_impl(cx,\n+                                          span,\n+                                          type_ident,\n+                                          move ty_params,\n+                                          method);\n }\n \n fn expand_deriving_eq_struct_method(cx: ext_ctxt,\n                                     span: span,\n                                     struct_def: &struct_def,\n                                     method_ident: ident,\n                                     type_ident: ident,\n+                                    ty_params: &[ty_param],\n                                     junction: Junction)\n                                  -> @method {\n     let self_ident = cx.ident_of(~\"self\");\n@@ -483,7 +579,12 @@ fn expand_deriving_eq_struct_method(cx: ext_ctxt,\n \n     // Create the method itself.\n     let body = finish_eq_chain_expr(cx, span, outer_expr, junction);\n-    return create_eq_method(cx, span, method_ident, type_ident, body);\n+    return create_eq_method(cx,\n+                            span,\n+                            method_ident,\n+                            type_ident,\n+                            ty_params,\n+                            body);\n }\n \n fn expand_deriving_iter_bytes_struct_method(cx: ext_ctxt,\n@@ -521,36 +622,12 @@ fn expand_deriving_iter_bytes_struct_method(cx: ext_ctxt,\n     return create_iter_bytes_method(cx, span, move statements);\n }\n \n-fn expand_deriving_eq_enum_def(cx: ext_ctxt,\n-                               span: span,\n-                               enum_definition: &enum_def,\n-                               type_ident: ident)\n-                            -> @item {\n-    // Create the methods.\n-    let eq_ident = cx.ident_of(~\"eq\");\n-    let ne_ident = cx.ident_of(~\"ne\");\n-    let eq_method = expand_deriving_eq_enum_method(cx,\n-                                                span,\n-                                                enum_definition,\n-                                                eq_ident,\n-                                                type_ident,\n-                                                Conjunction);\n-    let ne_method = expand_deriving_eq_enum_method(cx,\n-                                                   span,\n-                                                   enum_definition,\n-                                                   ne_ident,\n-                                                   type_ident,\n-                                                   Disjunction);\n-\n-    // Create the implementation.\n-    return create_derived_eq_impl(cx, span, type_ident, eq_method, ne_method);\n-}\n-\n fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n                                   span: span,\n                                   enum_definition: &enum_def,\n                                   method_ident: ident,\n                                   type_ident: ident,\n+                                  ty_params: &[ty_param],\n                                   junction: Junction)\n                                -> @method {\n     let self_ident = cx.ident_of(~\"self\");\n@@ -672,6 +749,7 @@ fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n                             span,\n                             method_ident,\n                             type_ident,\n+                            ty_params,\n                             self_match_expr);\n }\n "}, {"sha": "74ecac67f499edd3e61c8937d2418e3a07125c39", "filename": "src/test/run-pass/deriving-via-extension-type-params.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e6d87a3ef446bd111523979eef92dc51c1780ee1/src%2Ftest%2Frun-pass%2Fderiving-via-extension-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d87a3ef446bd111523979eef92dc51c1780ee1/src%2Ftest%2Frun-pass%2Fderiving-via-extension-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-type-params.rs?ref=e6d87a3ef446bd111523979eef92dc51c1780ee1", "patch": "@@ -0,0 +1,17 @@\n+#[deriving_eq]\n+#[deriving_iter_bytes]\n+struct Foo<T> {\n+    x: int,\n+    y: T,\n+    z: int\n+}\n+\n+fn main() {\n+    let a = Foo { x: 1, y: 2.0, z: 3 };\n+    let b = Foo { x: 1, y: 2.0, z: 3 };\n+    assert a == b;\n+    assert !(a != b);\n+    assert a.eq(&b);\n+    assert !a.ne(&b);\n+}\n+"}]}