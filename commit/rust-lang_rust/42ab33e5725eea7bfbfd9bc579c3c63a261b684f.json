{"sha": "42ab33e5725eea7bfbfd9bc579c3c63a261b684f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyYWIzM2U1NzI1ZWVhN2JmYmZkOWJjNTc5YzNjNjNhMjYxYjY4NGY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-20T09:51:28Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-21T00:32:42Z"}, "message": "Use explicit self in rest of tutorial\n\n/cc: #4217", "tree": {"sha": "c07ae7aca8c4e7b818d70a21ab1358ba3e541139", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c07ae7aca8c4e7b818d70a21ab1358ba3e541139"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42ab33e5725eea7bfbfd9bc579c3c63a261b684f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42ab33e5725eea7bfbfd9bc579c3c63a261b684f", "html_url": "https://github.com/rust-lang/rust/commit/42ab33e5725eea7bfbfd9bc579c3c63a261b684f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42ab33e5725eea7bfbfd9bc579c3c63a261b684f/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "171e6a16f74eceba5760791708a1382bfb1e6894", "url": "https://api.github.com/repos/rust-lang/rust/commits/171e6a16f74eceba5760791708a1382bfb1e6894", "html_url": "https://github.com/rust-lang/rust/commit/171e6a16f74eceba5760791708a1382bfb1e6894"}], "stats": {"total": 89, "additions": 45, "deletions": 44}, "files": [{"sha": "de3b2ed4a3a96fb3ece2f527d3fda893dd425456", "filename": "doc/tutorial.md", "status": "modified", "additions": 45, "deletions": 44, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/42ab33e5725eea7bfbfd9bc579c3c63a261b684f/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/42ab33e5725eea7bfbfd9bc579c3c63a261b684f/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=42ab33e5725eea7bfbfd9bc579c3c63a261b684f", "patch": "@@ -2033,7 +2033,7 @@ console, with a single method:\n \n ~~~~\n trait Printable {\n-    fn print();\n+    fn print(&self);\n }\n ~~~~\n \n@@ -2045,13 +2045,13 @@ and `~str`.\n [impls]: #functions-and-methods\n \n ~~~~\n-# trait Printable { fn print(); }\n+# trait Printable { fn print(&self); }\n impl int: Printable {\n-    fn print() { io::println(fmt!(\"%d\", self)) }\n+    fn print(&self) { io::println(fmt!(\"%d\", *self)) }\n }\n \n impl &str: Printable {\n-    fn print() { io::println(self) }\n+    fn print(&self) { io::println(*self) }\n }\n \n # 1.print();\n@@ -2065,14 +2065,14 @@ types might look like the following:\n \n ~~~~\n trait Seq<T> {\n-    fn len() -> uint;\n-    fn iter(b: fn(v: &T));\n+    fn len(&self) -> uint;\n+    fn iter(&self, b: fn(v: &T));\n }\n \n impl<T> ~[T]: Seq<T> {\n-    fn len() -> uint { vec::len(self) }\n-    fn iter(b: fn(v: &T)) {\n-        for vec::each(self) |elt| { b(elt); }\n+    fn len(&self) -> uint { vec::len(*self) }\n+    fn iter(&self, b: fn(v: &T)) {\n+        for vec::each(*self) |elt| { b(elt); }\n     }\n }\n ~~~~\n@@ -2096,21 +2096,22 @@ trait, `self` is a type, and in an impl, `self` is a value. The\n following trait describes types that support an equality operation:\n \n ~~~~\n-// In a trait, `self` refers to the type implementing the trait\n+// In a trait, `self` refers both to the self argument\n+// and to the type implementing the trait\n trait Eq {\n-  fn equals(other: &self) -> bool;\n+  fn equals(&self, other: &self) -> bool;\n }\n \n-// In an impl, `self` refers to the value of the receiver\n+// In an impl, `self` refers just to the value of the receiver\n impl int: Eq {\n-  fn equals(other: &int) -> bool { *other == self }\n+  fn equals(&self, other: &int) -> bool { *other == *self }\n }\n ~~~~\n \n-Notice that in the trait definition, `equals` takes a parameter of\n-type `self`. In contrast, in the `impl`, `equals` takes a parameter of\n-type `int`, and uses `self` as the name of the receiver (analogous to\n-the `this` pointer in C++).\n+Notice that in the trait definition, `equals` takes a\n+second parameter of type `self`.\n+In contrast, in the `impl`, `equals` takes a second parameter of\n+type `int`, only using `self` as the name of the receiver.\n \n ## Bounded type parameters and static method dispatch\n \n@@ -2120,7 +2121,7 @@ define _bounds_ on type parameters, so that we can then operate on\n generic types.\n \n ~~~~\n-# trait Printable { fn print(); }\n+# trait Printable { fn print(&self); }\n fn print_all<T: Printable>(printable_things: ~[T]) {\n     for printable_things.each |thing| {\n         thing.print();\n@@ -2138,7 +2139,7 @@ Type parameters can have multiple bounds by separating them with spaces,\n as in this version of `print_all` that copies elements.\n \n ~~~\n-# trait Printable { fn print(); }\n+# trait Printable { fn print(&self); }\n fn print_all<T: Printable Copy>(printable_things: ~[T]) {\n     let mut i = 0;\n     while i < printable_things.len() {\n@@ -2163,9 +2164,9 @@ However, consider this function:\n \n ~~~~\n # type Circle = int; type Rectangle = int;\n-# impl int: Drawable { fn draw() {} }\n+# impl int: Drawable { fn draw(&self) {} }\n # fn new_circle() -> int { 1 }\n-trait Drawable { fn draw(); }\n+trait Drawable { fn draw(&self); }\n \n fn draw_all<T: Drawable>(shapes: ~[T]) {\n     for shapes.each |shape| { shape.draw(); }\n@@ -2181,7 +2182,7 @@ needed, a trait name can alternately be used as a type, called\n an _object_.\n \n ~~~~\n-# trait Drawable { fn draw(); }\n+# trait Drawable { fn draw(&self); }\n fn draw_all(shapes: &[@Drawable]) {\n     for shapes.each |shape| { shape.draw(); }\n }\n@@ -2194,14 +2195,14 @@ value to an object:\n \n ~~~~\n # type Circle = int; type Rectangle = bool;\n-# trait Drawable { fn draw(); }\n+# trait Drawable { fn draw(&self); }\n # fn new_circle() -> Circle { 1 }\n # fn new_rectangle() -> Rectangle { true }\n # fn draw_all(shapes: &[@Drawable]) {}\n \n-impl Circle: Drawable { fn draw() { ... } }\n+impl Circle: Drawable { fn draw(&self) { ... } }\n \n-impl Rectangle: Drawable { fn draw() { ... } }\n+impl Rectangle: Drawable { fn draw(&self) { ... } }\n \n let c: @Circle = @new_circle();\n let r: @Rectangle = @new_rectangle();\n@@ -2218,8 +2219,8 @@ for example, an `@Circle` may not be cast to an `~Drawable`.\n \n ~~~\n # type Circle = int; type Rectangle = int;\n-# trait Drawable { fn draw(); }\n-# impl int: Drawable { fn draw() {} }\n+# trait Drawable { fn draw(&self); }\n+# impl int: Drawable { fn draw(&self) {} }\n # fn new_circle() -> int { 1 }\n # fn new_rectangle() -> int { 2 }\n // A managed object\n@@ -2244,7 +2245,7 @@ The `static` keyword distinguishes static methods from methods that have a `self\n \n ~~~~\n trait Shape {\n-    fn area() -> float;\n+    fn area(&self) -> float;\n     static fn new_shape(area: float) -> Shape;\n }\n ~~~~\n@@ -2271,25 +2272,25 @@ Types that implement a trait must also implement its supertraits.\n For example, we can define a `Circle` trait that only types that also have the `Shape` trait can have:\n \n ~~~~\n-trait Shape { fn area() -> float; }\n-trait Circle : Shape { fn radius() -> float; }\n+trait Shape { fn area(&self) -> float; }\n+trait Circle : Shape { fn radius(&self) -> float; }\n ~~~~\n \n Now, implementations of `Circle` methods can call `Shape` methods:\n \n ~~~~\n-# trait Shape { fn area() -> float; }\n-# trait Circle : Shape { fn radius() -> float; }\n+# trait Shape { fn area(&self) -> float; }\n+# trait Circle : Shape { fn radius(&self) -> float; }\n # struct Point { x: float, y: float }\n # use float::consts::pi;\n # use float::sqrt;\n # fn square(x: float) -> float { x * x }\n struct CircleStruct { center: Point, radius: float }\n impl CircleStruct: Circle {\n-     fn radius() -> float { sqrt(self.area() / pi) }\n+     fn radius(&self) -> float { sqrt(self.area() / pi) }\n }\n impl CircleStruct: Shape {\n-     fn area() -> float { pi * square(self.radius) }\n+     fn area(&self) -> float { pi * square(self.radius) }\n }   \n ~~~~\n \n@@ -2301,8 +2302,8 @@ methods of the supertrait may be called on values of subtrait-bound type paramet\n Refering to the previous example of `trait Circle : Shape`:\n \n ~~~\n-# trait Shape { fn area() -> float; }\n-# trait Circle : Shape { fn radius() -> float; }\n+# trait Shape { fn area(&self) -> float; }\n+# trait Circle : Shape { fn radius(&self) -> float; }\n fn radius_times_area<T: Circle>(c: T) -> float {\n     // `c` is both a Circle and a Shape\n     c.radius() * c.area()\n@@ -2312,10 +2313,10 @@ fn radius_times_area<T: Circle>(c: T) -> float {\n Likewise, supertrait methods may also be called on trait objects.\n \n ~~~ {.xfail-test}\n-# trait Shape { fn area() -> float; }\n-# trait Circle : Shape { fn radius() -> float; }\n-# impl int: Shape { fn area() -> float { 0.0 } }\n-# impl int: Circle { fn radius() -> float { 0.0 } }\n+# trait Shape { fn area(&self) -> float; }\n+# trait Circle : Shape { fn radius(&self) -> float; }\n+# impl int: Shape { fn area(&self) -> float { 0.0 } }\n+# impl int: Circle { fn radius(&self) -> float { 0.0 } }\n # let mycircle = 0;\n \n let mycircle: Circle = @mycircle as @Circle;\n@@ -2385,9 +2386,9 @@ mod farm {\n \n     // Note - visibility modifiers on impls currently have no effect\n     impl Farm {\n-        priv fn feed_chickens() { ... }\n-        priv fn feed_cows() { ... }\n-        fn add_chicken(c: Chicken) { ... }\n+        priv fn feed_chickens(&self) { ... }\n+        priv fn feed_cows(&self) { ... }\n+        fn add_chicken(&self, c: Chicken) { ... }\n     }\n \n     pub fn feed_animals(farm: &Farm) {\n@@ -2407,7 +2408,7 @@ fn main() {\n # enum Human = int;\n # fn make_me_a_farm() -> farm::Farm { farm::make_me_a_farm() }\n # fn make_me_a_chicken() -> Chicken { 0 }\n-# impl Human { fn rest() { } }\n+# impl Human { fn rest(&self) { } }\n ~~~\n \n ## Crates"}]}