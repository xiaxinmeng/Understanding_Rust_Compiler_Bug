{"sha": "f2f0e6cc81227fe60b1c164144b763f222c92820", "node_id": "C_kwDOAAsO6NoAKGYyZjBlNmNjODEyMjdmZTYwYjFjMTY0MTQ0Yjc2M2YyMjJjOTI4MjA", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-06-04T11:21:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-06-04T11:21:26Z"}, "message": "Rollup merge of #110701 - jyn514:test-core, r=Mark-Simulacrum\n\nFix `x test core` when download-rustc is enabled\n\nFix `x test --stage 2 core` when download-rustc is enabled\n\nThis works by building std from source instead of downloading it, for library tests only.\n\nThis was somewhat complicated because of the following requirements:\n1. Unconditionally downloading libstd breaks `x test core`, because `coretests` requires the std loaded from the sysroot to match the std that's currently being tested.\n2. Unconditionally rebuilding libstd breaks `x test ui-fulldeps librustdoc`, because anything loading `rustc_private` needs to use the same libstd that rustc was built with.\n\nBreak the knot by introducing a new `stage2-test-sysroot`, used only for testing `std` itself. This\nholds a freshly compiled std, while `stage2` and `ci-rustc-sysroot` still hold the downloaded std.\n\nThis also extends the existing `cp_filtered` in Sysroot to apply to the `rust-std` component, not just the `rustc-dev` component, to avoid having both versions of std in `stage2-test-sysroot`.\n\nFixes #110352.", "tree": {"sha": "8e206ee2059aaded4da04554c99cbd1404289656", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e206ee2059aaded4da04554c99cbd1404289656"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2f0e6cc81227fe60b1c164144b763f222c92820", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkfHO2CRBK7hj4Ov3rIwAA6g4IAFjI7Eo1qS5QzhtoKTbNsWuu\nKgDFSINcllDAr3dOwhE+d/1LwxTJdgPKJXfx4L6C87YxduEwAvNsfHDB/+y9b+A2\ntKL3n9MBx572p8FlTYq7QV44CVH8HUtDJKle4apC6Zb7xoxYFf14jNDYrXxQXRyO\nKKzCigW76Eupr28xdfgO+9Q9ZeedqkDWf680ylZkZZiGxO47u/PBdYn1S+Smre3i\nu9syWWISm/lq6QYM8yf+hCFurfVs1zgxiHd+AKaW4X9MSJpLXk6MvuOUwWlgriMv\n6yUk3dJMWZrivd2IepiT6KB8aCUN94FqYrxYgvJGbMOqEJ6r5P1+HrlFG+kjK7Y=\n=gyDz\n-----END PGP SIGNATURE-----\n", "payload": "tree 8e206ee2059aaded4da04554c99cbd1404289656\nparent 7ee25055299830804b9714bbb5fdd36fb9d74ba9\nparent a80d69a6ac996616937fb41357f10db036f85f73\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1685877686 +0200\ncommitter GitHub <noreply@github.com> 1685877686 +0200\n\nRollup merge of #110701 - jyn514:test-core, r=Mark-Simulacrum\n\nFix `x test core` when download-rustc is enabled\n\nFix `x test --stage 2 core` when download-rustc is enabled\n\nThis works by building std from source instead of downloading it, for library tests only.\n\nThis was somewhat complicated because of the following requirements:\n1. Unconditionally downloading libstd breaks `x test core`, because `coretests` requires the std loaded from the sysroot to match the std that's currently being tested.\n2. Unconditionally rebuilding libstd breaks `x test ui-fulldeps librustdoc`, because anything loading `rustc_private` needs to use the same libstd that rustc was built with.\n\nBreak the knot by introducing a new `stage2-test-sysroot`, used only for testing `std` itself. This\nholds a freshly compiled std, while `stage2` and `ci-rustc-sysroot` still hold the downloaded std.\n\nThis also extends the existing `cp_filtered` in Sysroot to apply to the `rust-std` component, not just the `rustc-dev` component, to avoid having both versions of std in `stage2-test-sysroot`.\n\nFixes #110352.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2f0e6cc81227fe60b1c164144b763f222c92820", "html_url": "https://github.com/rust-lang/rust/commit/f2f0e6cc81227fe60b1c164144b763f222c92820", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2f0e6cc81227fe60b1c164144b763f222c92820/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ee25055299830804b9714bbb5fdd36fb9d74ba9", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ee25055299830804b9714bbb5fdd36fb9d74ba9", "html_url": "https://github.com/rust-lang/rust/commit/7ee25055299830804b9714bbb5fdd36fb9d74ba9"}, {"sha": "a80d69a6ac996616937fb41357f10db036f85f73", "url": "https://api.github.com/repos/rust-lang/rust/commits/a80d69a6ac996616937fb41357f10db036f85f73", "html_url": "https://github.com/rust-lang/rust/commit/a80d69a6ac996616937fb41357f10db036f85f73"}], "stats": {"total": 181, "additions": 142, "deletions": 39}, "files": [{"sha": "8b0f3d702c1d17de9b2d6364b3c03ac939d8aee5", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f0e6cc81227fe60b1c164144b763f222c92820/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f0e6cc81227fe60b1c164144b763f222c92820/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=f2f0e6cc81227fe60b1c164144b763f222c92820", "patch": "@@ -995,7 +995,7 @@ impl<'a> Builder<'a> {\n     }\n \n     pub fn sysroot(&self, compiler: Compiler) -> Interned<PathBuf> {\n-        self.ensure(compile::Sysroot { compiler })\n+        self.ensure(compile::Sysroot::new(compiler))\n     }\n \n     /// Returns the libdir where the standard library and other artifacts are"}, {"sha": "48685f7a9d5ac47b95650854a08ed662a1a977b5", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 92, "deletions": 28, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/f2f0e6cc81227fe60b1c164144b763f222c92820/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f0e6cc81227fe60b1c164144b763f222c92820/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=f2f0e6cc81227fe60b1c164144b763f222c92820", "patch": "@@ -40,11 +40,18 @@ pub struct Std {\n     ///\n     /// This shouldn't be used from other steps; see the comment on [`Rustc`].\n     crates: Interned<Vec<String>>,\n+    /// When using download-rustc, we need to use a new build of `std` for running unit tests of Std itself,\n+    /// but we need to use the downloaded copy of std for linking to rustdoc. Allow this to be overriden by `builder.ensure` from other steps.\n+    force_recompile: bool,\n }\n \n impl Std {\n     pub fn new(compiler: Compiler, target: TargetSelection) -> Self {\n-        Self { target, compiler, crates: Default::default() }\n+        Self { target, compiler, crates: Default::default(), force_recompile: false }\n+    }\n+\n+    pub fn force_recompile(compiler: Compiler, target: TargetSelection) -> Self {\n+        Self { target, compiler, crates: Default::default(), force_recompile: true }\n     }\n }\n \n@@ -77,6 +84,7 @@ impl Step for Std {\n             compiler: run.builder.compiler(run.builder.top_stage, run.build_triple()),\n             target: run.target,\n             crates: make_run_crates(&run, \"library\"),\n+            force_recompile: false,\n         });\n     }\n \n@@ -89,11 +97,20 @@ impl Step for Std {\n         let target = self.target;\n         let compiler = self.compiler;\n \n-        // When using `download-rustc`, we already have artifacts for the host available\n-        // (they were copied in `impl Step for Sysroot`). Don't recompile them.\n-        // NOTE: the ABI of the beta compiler is different from the ABI of the downloaded compiler,\n-        // so its artifacts can't be reused.\n-        if builder.download_rustc() && compiler.stage != 0 && target == builder.build.build {\n+        // When using `download-rustc`, we already have artifacts for the host available. Don't\n+        // recompile them.\n+        if builder.download_rustc() && target == builder.build.build\n+            // NOTE: the beta compiler may generate different artifacts than the downloaded compiler, so\n+            // its artifacts can't be reused.\n+            && compiler.stage != 0\n+            // This check is specific to testing std itself; see `test::Std` for more details.\n+            && !self.force_recompile\n+        {\n+            cp_rustc_component_to_ci_sysroot(\n+                builder,\n+                compiler,\n+                builder.config.ci_rust_std_contents(),\n+            );\n             return;\n         }\n \n@@ -428,6 +445,8 @@ struct StdLink {\n     pub target: TargetSelection,\n     /// Not actually used; only present to make sure the cache invalidation is correct.\n     crates: Interned<Vec<String>>,\n+    /// See [`Std::force_recompile`].\n+    force_recompile: bool,\n }\n \n impl StdLink {\n@@ -437,6 +456,7 @@ impl StdLink {\n             target_compiler: std.compiler,\n             target: std.target,\n             crates: std.crates,\n+            force_recompile: std.force_recompile,\n         }\n     }\n }\n@@ -460,8 +480,24 @@ impl Step for StdLink {\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n-        let libdir = builder.sysroot_libdir(target_compiler, target);\n-        let hostdir = builder.sysroot_libdir(target_compiler, compiler.host);\n+\n+        // NOTE: intentionally does *not* check `target == builder.build` to avoid having to add the same check in `test::Crate`.\n+        let (libdir, hostdir) = if self.force_recompile && builder.download_rustc() {\n+            // NOTE: copies part of `sysroot_libdir` to avoid having to add a new `force_recompile` argument there too\n+            let lib = builder.sysroot_libdir_relative(self.compiler);\n+            let sysroot = builder.ensure(crate::compile::Sysroot {\n+                compiler: self.compiler,\n+                force_recompile: self.force_recompile,\n+            });\n+            let libdir = sysroot.join(lib).join(\"rustlib\").join(target.triple).join(\"lib\");\n+            let hostdir = sysroot.join(lib).join(\"rustlib\").join(compiler.host.triple).join(\"lib\");\n+            (INTERNER.intern_path(libdir), INTERNER.intern_path(hostdir))\n+        } else {\n+            let libdir = builder.sysroot_libdir(target_compiler, target);\n+            let hostdir = builder.sysroot_libdir(target_compiler, compiler.host);\n+            (libdir, hostdir)\n+        };\n+\n         add_to_sysroot(builder, &libdir, &hostdir, &libstd_stamp(builder, compiler, target));\n     }\n }\n@@ -594,6 +630,25 @@ impl Step for StartupObjects {\n     }\n }\n \n+fn cp_rustc_component_to_ci_sysroot(\n+    builder: &Builder<'_>,\n+    compiler: Compiler,\n+    contents: Vec<String>,\n+) {\n+    let sysroot = builder.ensure(Sysroot { compiler, force_recompile: false });\n+\n+    let ci_rustc_dir = builder.out.join(&*builder.build.build.triple).join(\"ci-rustc\");\n+    for file in contents {\n+        let src = ci_rustc_dir.join(&file);\n+        let dst = sysroot.join(file);\n+        if src.is_dir() {\n+            t!(fs::create_dir_all(dst));\n+        } else {\n+            builder.copy(&src, &dst);\n+        }\n+    }\n+}\n+\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Rustc {\n     pub target: TargetSelection,\n@@ -653,18 +708,11 @@ impl Step for Rustc {\n         if builder.download_rustc() && compiler.stage != 0 {\n             // Copy the existing artifacts instead of rebuilding them.\n             // NOTE: this path is only taken for tools linking to rustc-dev (including ui-fulldeps tests).\n-            let sysroot = builder.ensure(Sysroot { compiler });\n-\n-            let ci_rustc_dir = builder.out.join(&*builder.build.build.triple).join(\"ci-rustc\");\n-            for file in builder.config.rustc_dev_contents() {\n-                let src = ci_rustc_dir.join(&file);\n-                let dst = sysroot.join(file);\n-                if src.is_dir() {\n-                    t!(fs::create_dir_all(dst));\n-                } else {\n-                    builder.copy(&src, &dst);\n-                }\n-            }\n+            cp_rustc_component_to_ci_sysroot(\n+                builder,\n+                compiler,\n+                builder.config.ci_rustc_dev_contents(),\n+            );\n             return;\n         }\n \n@@ -1225,6 +1273,14 @@ pub fn compiler_file(\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Sysroot {\n     pub compiler: Compiler,\n+    /// See [`Std::force_recompile`].\n+    force_recompile: bool,\n+}\n+\n+impl Sysroot {\n+    pub(crate) fn new(compiler: Compiler) -> Self {\n+        Sysroot { compiler, force_recompile: false }\n+    }\n }\n \n impl Step for Sysroot {\n@@ -1247,6 +1303,8 @@ impl Step for Sysroot {\n         let sysroot_dir = |stage| {\n             if stage == 0 {\n                 host_dir.join(\"stage0-sysroot\")\n+            } else if self.force_recompile && stage == compiler.stage {\n+                host_dir.join(format!(\"stage{stage}-test-sysroot\"))\n             } else if builder.download_rustc() && compiler.stage != builder.top_stage {\n                 host_dir.join(\"ci-rustc-sysroot\")\n             } else {\n@@ -1286,14 +1344,19 @@ impl Step for Sysroot {\n             // 2. The sysroot is deleted and recreated between each invocation, so running `x test\n             //    ui-fulldeps && x test ui` can't cause failures.\n             let mut filtered_files = Vec::new();\n-            // Don't trim directories or files that aren't loaded per-target; they can't cause conflicts.\n-            let suffix = format!(\"lib/rustlib/{}/lib\", compiler.host);\n-            for path in builder.config.rustc_dev_contents() {\n-                let path = Path::new(&path);\n-                if path.parent().map_or(false, |parent| parent.ends_with(&suffix)) {\n-                    filtered_files.push(path.file_name().unwrap().to_owned());\n+            let mut add_filtered_files = |suffix, contents| {\n+                for path in contents {\n+                    let path = Path::new(&path);\n+                    if path.parent().map_or(false, |parent| parent.ends_with(&suffix)) {\n+                        filtered_files.push(path.file_name().unwrap().to_owned());\n+                    }\n                 }\n-            }\n+            };\n+            let suffix = format!(\"lib/rustlib/{}/lib\", compiler.host);\n+            add_filtered_files(suffix.as_str(), builder.config.ci_rustc_dev_contents());\n+            // NOTE: we can't copy std eagerly because `stage2-test-sysroot` needs to have only the\n+            // newly compiled std, not the downloaded std.\n+            add_filtered_files(\"lib\", builder.config.ci_rust_std_contents());\n \n             let filtered_extensions = [OsStr::new(\"rmeta\"), OsStr::new(\"rlib\"), OsStr::new(\"so\")];\n             let ci_rustc_dir = builder.ci_rustc_dir(builder.config.build);\n@@ -1411,7 +1474,8 @@ impl Step for Assemble {\n \n         // If we're downloading a compiler from CI, we can use the same compiler for all stages other than 0.\n         if builder.download_rustc() {\n-            let sysroot = builder.ensure(Sysroot { compiler: target_compiler });\n+            let sysroot =\n+                builder.ensure(Sysroot { compiler: target_compiler, force_recompile: false });\n             // Ensure that `libLLVM.so` ends up in the newly created target directory,\n             // so that tools using `rustc_private` can use it.\n             dist::maybe_install_llvm_target(builder, target_compiler.host, &sysroot);"}, {"sha": "06f479808b97578b1626eadbfa4c92284384cfbd", "filename": "src/bootstrap/download.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f2f0e6cc81227fe60b1c164144b763f222c92820/src%2Fbootstrap%2Fdownload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f0e6cc81227fe60b1c164144b763f222c92820/src%2Fbootstrap%2Fdownload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdownload.rs?ref=f2f0e6cc81227fe60b1c164144b763f222c92820", "patch": "@@ -271,11 +271,8 @@ impl Config {\n         // `compile::Sysroot` needs to know the contents of the `rustc-dev` tarball to avoid adding\n         // it to the sysroot unless it was explicitly requested. But parsing the 100 MB tarball is slow.\n         // Cache the entries when we extract it so we only have to read it once.\n-        let mut recorded_entries = if dst.ends_with(\"ci-rustc\") && pattern == \"rustc-dev\" {\n-            Some(BufWriter::new(t!(File::create(dst.join(\".rustc-dev-contents\")))))\n-        } else {\n-            None\n-        };\n+        let mut recorded_entries =\n+            if dst.ends_with(\"ci-rustc\") { recorded_entries(dst, pattern) } else { None };\n \n         for member in t!(tar.entries()) {\n             let mut member = t!(member);\n@@ -332,6 +329,17 @@ impl Config {\n     }\n }\n \n+fn recorded_entries(dst: &Path, pattern: &str) -> Option<BufWriter<File>> {\n+    let name = if pattern == \"rustc-dev\" {\n+        \".rustc-dev-contents\"\n+    } else if pattern.starts_with(\"rust-std\") {\n+        \".rust-std-contents\"\n+    } else {\n+        return None;\n+    };\n+    Some(BufWriter::new(t!(File::create(dst.join(name)))))\n+}\n+\n enum DownloadSource {\n     CI,\n     Dist,\n@@ -382,11 +390,20 @@ impl Config {\n         Some(rustfmt_path)\n     }\n \n-    pub(crate) fn rustc_dev_contents(&self) -> Vec<String> {\n+    pub(crate) fn ci_rust_std_contents(&self) -> Vec<String> {\n+        self.ci_component_contents(\".rust-std-contents\")\n+    }\n+\n+    pub(crate) fn ci_rustc_dev_contents(&self) -> Vec<String> {\n+        self.ci_component_contents(\".rustc-dev-contents\")\n+    }\n+\n+    fn ci_component_contents(&self, stamp_file: &str) -> Vec<String> {\n         assert!(self.download_rustc());\n         let ci_rustc_dir = self.out.join(&*self.build.triple).join(\"ci-rustc\");\n-        let rustc_dev_contents_file = t!(File::open(ci_rustc_dir.join(\".rustc-dev-contents\")));\n-        t!(BufReader::new(rustc_dev_contents_file).lines().collect())\n+        let stamp_file = ci_rustc_dir.join(stamp_file);\n+        let contents_file = t!(File::open(&stamp_file), stamp_file.display().to_string());\n+        t!(BufReader::new(contents_file).lines().collect())\n     }\n \n     pub(crate) fn download_ci_rustc(&self, commit: &str) {"}, {"sha": "29e48481f0f84da0129096d895ba2c684465884f", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f2f0e6cc81227fe60b1c164144b763f222c92820/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f0e6cc81227fe60b1c164144b763f222c92820/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=f2f0e6cc81227fe60b1c164144b763f222c92820", "patch": "@@ -2204,7 +2204,8 @@ impl Step for Crate {\n         let target = self.target;\n         let mode = self.mode;\n \n-        builder.ensure(compile::Std::new(compiler, target));\n+        // See [field@compile::Std::force_recompile].\n+        builder.ensure(compile::Std::force_recompile(compiler, target));\n         builder.ensure(RemoteCopyLibs { compiler, target });\n \n         // If we're not doing a full bootstrap but we're testing a stage2\n@@ -2218,6 +2219,16 @@ impl Step for Crate {\n         match mode {\n             Mode::Std => {\n                 compile::std_cargo(builder, target, compiler.stage, &mut cargo);\n+                // `std_cargo` actually does the wrong thing: it passes `--sysroot build/host/stage2`,\n+                // but we want to use the force-recompile std we just built in `build/host/stage2-test-sysroot`.\n+                // Override it.\n+                if builder.download_rustc() {\n+                    let sysroot = builder\n+                        .out\n+                        .join(compiler.host.triple)\n+                        .join(format!(\"stage{}-test-sysroot\", compiler.stage));\n+                    cargo.env(\"RUSTC_SYSROOT\", sysroot);\n+                }\n             }\n             Mode::Rustc => {\n                 compile::rustc_cargo(builder, &mut cargo, target, compiler.stage);\n@@ -2269,6 +2280,11 @@ impl Step for CrateRustdoc {\n             // isn't really necessary.\n             builder.compiler_for(builder.top_stage, target, target)\n         };\n+        // NOTE: normally `ensure(Rustc)` automatically runs `ensure(Std)` for us. However, when\n+        // using `download-rustc`, the rustc_private artifacts may be in a *different sysroot* from\n+        // the target rustdoc (`ci-rustc-sysroot` vs `stage2`). In that case, we need to ensure this\n+        // explicitly to make sure it ends up in the stage2 sysroot.\n+        builder.ensure(compile::Std::new(compiler, target));\n         builder.ensure(compile::Rustc::new(compiler, target));\n \n         let mut cargo = tool::prepare_tool_cargo(\n@@ -2320,7 +2336,13 @@ impl Step for CrateRustdoc {\n         dylib_path.insert(0, PathBuf::from(&*libdir));\n         cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n \n-        let _guard = builder.msg(builder.kind, compiler.stage, \"rustdoc\", compiler.host, target);\n+        let _guard = builder.msg_sysroot_tool(\n+            builder.kind,\n+            compiler.stage,\n+            \"rustdoc\",\n+            compiler.host,\n+            target,\n+        );\n         run_cargo_test(\n             cargo,\n             &[],"}]}