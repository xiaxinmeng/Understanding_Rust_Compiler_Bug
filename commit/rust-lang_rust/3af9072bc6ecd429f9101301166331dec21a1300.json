{"sha": "3af9072bc6ecd429f9101301166331dec21a1300", "node_id": "C_kwDOAAsO6NoAKDNhZjkwNzJiYzZlY2Q0MjlmOTEwMTMwMTE2NjMzMWRlYzIxYTEzMDA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-09T00:12:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-09T00:12:29Z"}, "message": "Auto merge of #9288 - lukaslueg:partialeqnone, r=Jarcho\n\nAdd partialeq_to_none lint\n\nInitial implementation of #9275, adding lint `partialeq_to_none`. This is my first time working on `clippy`, so please review carefully.\n\nI'm unsure especially about the `Sugg`, as it covers the entire `BinOp`, instead of just covering one of the sides and the operator (see the multi-line example). I was unsure if pinpointing the suggestion wouldn't be brittle...\n\nchangelog: [`PARTIALEQ_TO_NONE`]: Initial commit", "tree": {"sha": "5b81a197559f48ead486a9df806141d74b04d310", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b81a197559f48ead486a9df806141d74b04d310"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3af9072bc6ecd429f9101301166331dec21a1300", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3af9072bc6ecd429f9101301166331dec21a1300", "html_url": "https://github.com/rust-lang/rust/commit/3af9072bc6ecd429f9101301166331dec21a1300", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3af9072bc6ecd429f9101301166331dec21a1300/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f390610a521b745b2fb84945b258371983fed49", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f390610a521b745b2fb84945b258371983fed49", "html_url": "https://github.com/rust-lang/rust/commit/8f390610a521b745b2fb84945b258371983fed49"}, {"sha": "657b0da912f0281aa11fe61df7fa273bf9be1d5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/657b0da912f0281aa11fe61df7fa273bf9be1d5b", "html_url": "https://github.com/rust-lang/rust/commit/657b0da912f0281aa11fe61df7fa273bf9be1d5b"}], "stats": {"total": 368, "additions": 356, "deletions": 12}, "files": [{"sha": "380cd451987bfc982d00448668e1699fb999ffc9", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3af9072bc6ecd429f9101301166331dec21a1300/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/3af9072bc6ecd429f9101301166331dec21a1300/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=3af9072bc6ecd429f9101301166331dec21a1300", "patch": "@@ -3824,6 +3824,7 @@ Released 2018-09-13\n [`panic_params`]: https://rust-lang.github.io/rust-clippy/master/index.html#panic_params\n [`panicking_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#panicking_unwrap\n [`partialeq_ne_impl`]: https://rust-lang.github.io/rust-clippy/master/index.html#partialeq_ne_impl\n+[`partialeq_to_none`]: https://rust-lang.github.io/rust-clippy/master/index.html#partialeq_to_none\n [`path_buf_push_overwrite`]: https://rust-lang.github.io/rust-clippy/master/index.html#path_buf_push_overwrite\n [`pattern_type_mismatch`]: https://rust-lang.github.io/rust-clippy/master/index.html#pattern_type_mismatch\n [`possible_missing_comma`]: https://rust-lang.github.io/rust-clippy/master/index.html#possible_missing_comma"}, {"sha": "01082cc8eeb64933304d54f3c2616d81a723f247", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3af9072bc6ecd429f9101301166331dec21a1300/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af9072bc6ecd429f9101301166331dec21a1300/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=3af9072bc6ecd429f9101301166331dec21a1300", "patch": "@@ -266,6 +266,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(option_env_unwrap::OPTION_ENV_UNWRAP),\n     LintId::of(overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL),\n     LintId::of(partialeq_ne_impl::PARTIALEQ_NE_IMPL),\n+    LintId::of(partialeq_to_none::PARTIALEQ_TO_NONE),\n     LintId::of(precedence::PRECEDENCE),\n     LintId::of(ptr::CMP_NULL),\n     LintId::of(ptr::INVALID_NULL_PTR_USAGE),"}, {"sha": "c540573b80228e8f3786a4117ab3dbda503266f7", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3af9072bc6ecd429f9101301166331dec21a1300/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af9072bc6ecd429f9101301166331dec21a1300/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=3af9072bc6ecd429f9101301166331dec21a1300", "patch": "@@ -454,6 +454,7 @@ store.register_lints(&[\n     panic_unimplemented::UNIMPLEMENTED,\n     panic_unimplemented::UNREACHABLE,\n     partialeq_ne_impl::PARTIALEQ_NE_IMPL,\n+    partialeq_to_none::PARTIALEQ_TO_NONE,\n     pass_by_ref_or_value::LARGE_TYPES_PASSED_BY_VALUE,\n     pass_by_ref_or_value::TRIVIALLY_COPY_PASS_BY_REF,\n     path_buf_push_overwrite::PATH_BUF_PUSH_OVERWRITE,"}, {"sha": "bfa654238f130386f1332b134d6a86eefc0fe544", "filename": "clippy_lints/src/lib.register_style.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3af9072bc6ecd429f9101301166331dec21a1300/clippy_lints%2Fsrc%2Flib.register_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af9072bc6ecd429f9101301166331dec21a1300/clippy_lints%2Fsrc%2Flib.register_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_style.rs?ref=3af9072bc6ecd429f9101301166331dec21a1300", "patch": "@@ -100,6 +100,7 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(operators::ASSIGN_OP_PATTERN),\n     LintId::of(operators::OP_REF),\n     LintId::of(operators::PTR_EQ),\n+    LintId::of(partialeq_to_none::PARTIALEQ_TO_NONE),\n     LintId::of(ptr::CMP_NULL),\n     LintId::of(ptr::PTR_ARG),\n     LintId::of(question_mark::QUESTION_MARK),"}, {"sha": "e6a405f8170d8f0a8e06df0fb807942f9eaf22d4", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3af9072bc6ecd429f9101301166331dec21a1300/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af9072bc6ecd429f9101301166331dec21a1300/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=3af9072bc6ecd429f9101301166331dec21a1300", "patch": "@@ -332,6 +332,7 @@ mod overflow_check_conditional;\n mod panic_in_result_fn;\n mod panic_unimplemented;\n mod partialeq_ne_impl;\n+mod partialeq_to_none;\n mod pass_by_ref_or_value;\n mod path_buf_push_overwrite;\n mod pattern_type_mismatch;\n@@ -931,6 +932,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(invalid_utf8_in_unchecked::InvalidUtf8InUnchecked));\n     store.register_late_pass(|| Box::new(std_instead_of_core::StdReexports::default()));\n     store.register_late_pass(|| Box::new(manual_instant_elapsed::ManualInstantElapsed));\n+    store.register_late_pass(|| Box::new(partialeq_to_none::PartialeqToNone));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n "}, {"sha": "eee7642068d6237bebe5fdcae8b91624fe40518b", "filename": "clippy_lints/src/partialeq_to_none.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/3af9072bc6ecd429f9101301166331dec21a1300/clippy_lints%2Fsrc%2Fpartialeq_to_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af9072bc6ecd429f9101301166331dec21a1300/clippy_lints%2Fsrc%2Fpartialeq_to_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_to_none.rs?ref=3af9072bc6ecd429f9101301166331dec21a1300", "patch": "@@ -0,0 +1,104 @@\n+use clippy_utils::{\n+    diagnostics::span_lint_and_sugg, is_lang_ctor, peel_hir_expr_refs, peel_ref_operators, sugg,\n+    ty::is_type_diagnostic_item,\n+};\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind, LangItem};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    ///\n+    /// Checks for binary comparisons to a literal `Option::None`.\n+    ///\n+    /// ### Why is this bad?\n+    ///\n+    /// A programmer checking if some `foo` is `None` via a comparison `foo == None`\n+    /// is usually inspired from other programming languages (e.g. `foo is None`\n+    /// in Python).\n+    /// Checking if a value of type `Option<T>` is (not) equal to `None` in that\n+    /// way relies on `T: PartialEq` to do the comparison, which is unneeded.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// fn foo(f: Option<u32>) -> &'static str {\n+    ///     if f != None { \"yay\" } else { \"nay\" }\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn foo(f: Option<u32>) -> &'static str {\n+    ///     if f.is_some() { \"yay\" } else { \"nay\" }\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.64.0\"]\n+    pub PARTIALEQ_TO_NONE,\n+    style,\n+    \"Binary comparison to `Option<T>::None` relies on `T: PartialEq`, which is unneeded\"\n+}\n+declare_lint_pass!(PartialeqToNone => [PARTIALEQ_TO_NONE]);\n+\n+impl<'tcx> LateLintPass<'tcx> for PartialeqToNone {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n+        // Skip expanded code, as we have no control over it anyway...\n+        if e.span.from_expansion() {\n+            return;\n+        }\n+\n+        // If the expression is of type `Option`\n+        let is_ty_option =\n+            |expr: &Expr<'_>| is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr).peel_refs(), sym::Option);\n+\n+        // If the expression is a literal `Option::None`\n+        let is_none_ctor = |expr: &Expr<'_>| {\n+            matches!(&peel_hir_expr_refs(expr).0.kind,\n+            ExprKind::Path(p) if is_lang_ctor(cx, p, LangItem::OptionNone))\n+        };\n+\n+        let mut applicability = Applicability::MachineApplicable;\n+\n+        if let ExprKind::Binary(op, left_side, right_side) = e.kind {\n+            // All other comparisons (e.g. `>= None`) have special meaning wrt T\n+            let is_eq = match op.node {\n+                BinOpKind::Eq => true,\n+                BinOpKind::Ne => false,\n+                _ => return,\n+            };\n+\n+            // We are only interested in comparisons between `Option` and a literal `Option::None`\n+            let scrutinee = match (\n+                is_none_ctor(left_side) && is_ty_option(right_side),\n+                is_none_ctor(right_side) && is_ty_option(left_side),\n+            ) {\n+                (true, false) => right_side,\n+                (false, true) => left_side,\n+                _ => return,\n+            };\n+\n+            // Peel away refs/derefs (as long as we don't cross manual deref impls), as\n+            // autoref/autoderef will take care of those\n+            let sugg = format!(\n+                \"{}.{}\",\n+                sugg::Sugg::hir_with_applicability(cx, peel_ref_operators(cx, scrutinee), \"..\", &mut applicability)\n+                    .maybe_par(),\n+                if is_eq { \"is_none()\" } else { \"is_some()\" }\n+            );\n+\n+            span_lint_and_sugg(\n+                cx,\n+                PARTIALEQ_TO_NONE,\n+                e.span,\n+                \"binary comparison to literal `Option::None`\",\n+                if is_eq {\n+                    \"use `Option::is_none()` instead\"\n+                } else {\n+                    \"use `Option::is_some()` instead\"\n+                },\n+                sugg,\n+                applicability,\n+            );\n+        }\n+    }\n+}"}, {"sha": "9850fc0919e12b76d78fc709353484d809a00ba8", "filename": "tests/ui/ifs_same_cond.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3af9072bc6ecd429f9101301166331dec21a1300/tests%2Fui%2Fifs_same_cond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af9072bc6ecd429f9101301166331dec21a1300/tests%2Fui%2Fifs_same_cond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fifs_same_cond.rs?ref=3af9072bc6ecd429f9101301166331dec21a1300", "patch": "@@ -32,9 +32,9 @@ fn ifs_same_cond() {\n     };\n \n     let mut v = vec![1];\n-    if v.pop() == None {\n+    if v.pop().is_none() {\n         // ok, functions\n-    } else if v.pop() == None {\n+    } else if v.pop().is_none() {\n     }\n \n     if v.len() == 42 {"}, {"sha": "65598f1eaccc54e928026ccdad249f28f43711a6", "filename": "tests/ui/manual_assert.edition2018.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3af9072bc6ecd429f9101301166331dec21a1300/tests%2Fui%2Fmanual_assert.edition2018.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3af9072bc6ecd429f9101301166331dec21a1300/tests%2Fui%2Fmanual_assert.edition2018.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_assert.edition2018.fixed?ref=3af9072bc6ecd429f9101301166331dec21a1300", "patch": "@@ -17,7 +17,7 @@ fn main() {\n     let c = Some(2);\n     if !a.is_empty()\n         && a.len() == 3\n-        && c != None\n+        && c.is_some()\n         && !a.is_empty()\n         && a.len() == 3\n         && !a.is_empty()"}, {"sha": "65598f1eaccc54e928026ccdad249f28f43711a6", "filename": "tests/ui/manual_assert.edition2021.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3af9072bc6ecd429f9101301166331dec21a1300/tests%2Fui%2Fmanual_assert.edition2021.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3af9072bc6ecd429f9101301166331dec21a1300/tests%2Fui%2Fmanual_assert.edition2021.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_assert.edition2021.fixed?ref=3af9072bc6ecd429f9101301166331dec21a1300", "patch": "@@ -17,7 +17,7 @@ fn main() {\n     let c = Some(2);\n     if !a.is_empty()\n         && a.len() == 3\n-        && c != None\n+        && c.is_some()\n         && !a.is_empty()\n         && a.len() == 3\n         && !a.is_empty()"}, {"sha": "a2393674fe6129dae1a74fe21562dceb014dafd3", "filename": "tests/ui/manual_assert.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3af9072bc6ecd429f9101301166331dec21a1300/tests%2Fui%2Fmanual_assert.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3af9072bc6ecd429f9101301166331dec21a1300/tests%2Fui%2Fmanual_assert.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_assert.fixed?ref=3af9072bc6ecd429f9101301166331dec21a1300", "patch": "@@ -11,7 +11,7 @@ fn main() {\n     let c = Some(2);\n     if !a.is_empty()\n         && a.len() == 3\n-        && c != None\n+        && c.is_some()\n         && !a.is_empty()\n         && a.len() == 3\n         && !a.is_empty()"}, {"sha": "4d2706dd6211380804c40f004ca9c86569e644ed", "filename": "tests/ui/manual_assert.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3af9072bc6ecd429f9101301166331dec21a1300/tests%2Fui%2Fmanual_assert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af9072bc6ecd429f9101301166331dec21a1300/tests%2Fui%2Fmanual_assert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_assert.rs?ref=3af9072bc6ecd429f9101301166331dec21a1300", "patch": "@@ -17,7 +17,7 @@ fn main() {\n     let c = Some(2);\n     if !a.is_empty()\n         && a.len() == 3\n-        && c != None\n+        && c.is_some()\n         && !a.is_empty()\n         && a.len() == 3\n         && !a.is_empty()"}, {"sha": "f3e4c58d6949223e0fe16b7e32c5bac5d22a34de", "filename": "tests/ui/partialeq_to_none.fixed", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/3af9072bc6ecd429f9101301166331dec21a1300/tests%2Fui%2Fpartialeq_to_none.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3af9072bc6ecd429f9101301166331dec21a1300/tests%2Fui%2Fpartialeq_to_none.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpartialeq_to_none.fixed?ref=3af9072bc6ecd429f9101301166331dec21a1300", "patch": "@@ -0,0 +1,62 @@\n+// run-rustfix\n+#![warn(clippy::partialeq_to_none)]\n+\n+struct Foobar;\n+\n+impl PartialEq<Option<()>> for Foobar {\n+    fn eq(&self, _: &Option<()>) -> bool {\n+        false\n+    }\n+}\n+\n+#[allow(dead_code)]\n+fn foo(f: Option<u32>) -> &'static str {\n+    if f.is_some() { \"yay\" } else { \"nay\" }\n+}\n+\n+fn foobar() -> Option<()> {\n+    None\n+}\n+\n+fn bar() -> Result<(), ()> {\n+    Ok(())\n+}\n+\n+fn optref() -> &'static &'static Option<()> {\n+    &&None\n+}\n+\n+fn main() {\n+    let x = Some(0);\n+\n+    let _ = x.is_none();\n+    let _ = x.is_some();\n+    let _ = x.is_none();\n+    let _ = x.is_some();\n+\n+    if foobar().is_none() {}\n+\n+    if bar().ok().is_some() {}\n+\n+    let _ = Some(1 + 2).is_some();\n+\n+    let _ = { Some(0) }.is_none();\n+\n+    let _ = {\n+        /*\n+          This comment runs long\n+        */\n+        Some(1)\n+    }.is_some();\n+\n+    // Should not trigger, as `Foobar` is not an `Option` and has no `is_none`\n+    let _ = Foobar == None;\n+\n+    let _ = optref().is_none();\n+    let _ = optref().is_some();\n+    let _ = optref().is_none();\n+    let _ = optref().is_some();\n+\n+    let x = Box::new(Option::<()>::None);\n+    let _ = (*x).is_some();\n+}"}, {"sha": "767b2a38bcc17ddba17267c2faa09ad10bef6cc1", "filename": "tests/ui/partialeq_to_none.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/3af9072bc6ecd429f9101301166331dec21a1300/tests%2Fui%2Fpartialeq_to_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af9072bc6ecd429f9101301166331dec21a1300/tests%2Fui%2Fpartialeq_to_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpartialeq_to_none.rs?ref=3af9072bc6ecd429f9101301166331dec21a1300", "patch": "@@ -0,0 +1,62 @@\n+// run-rustfix\n+#![warn(clippy::partialeq_to_none)]\n+\n+struct Foobar;\n+\n+impl PartialEq<Option<()>> for Foobar {\n+    fn eq(&self, _: &Option<()>) -> bool {\n+        false\n+    }\n+}\n+\n+#[allow(dead_code)]\n+fn foo(f: Option<u32>) -> &'static str {\n+    if f != None { \"yay\" } else { \"nay\" }\n+}\n+\n+fn foobar() -> Option<()> {\n+    None\n+}\n+\n+fn bar() -> Result<(), ()> {\n+    Ok(())\n+}\n+\n+fn optref() -> &'static &'static Option<()> {\n+    &&None\n+}\n+\n+fn main() {\n+    let x = Some(0);\n+\n+    let _ = x == None;\n+    let _ = x != None;\n+    let _ = None == x;\n+    let _ = None != x;\n+\n+    if foobar() == None {}\n+\n+    if bar().ok() != None {}\n+\n+    let _ = Some(1 + 2) != None;\n+\n+    let _ = { Some(0) } == None;\n+\n+    let _ = {\n+        /*\n+          This comment runs long\n+        */\n+        Some(1)\n+    } != None;\n+\n+    // Should not trigger, as `Foobar` is not an `Option` and has no `is_none`\n+    let _ = Foobar == None;\n+\n+    let _ = optref() == &&None;\n+    let _ = &&None != optref();\n+    let _ = **optref() == None;\n+    let _ = &None != *optref();\n+\n+    let x = Box::new(Option::<()>::None);\n+    let _ = None != *x;\n+}"}, {"sha": "de15a9f7baaf030b02b5d4ab7a33a2e960134082", "filename": "tests/ui/partialeq_to_none.stderr", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/3af9072bc6ecd429f9101301166331dec21a1300/tests%2Fui%2Fpartialeq_to_none.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3af9072bc6ecd429f9101301166331dec21a1300/tests%2Fui%2Fpartialeq_to_none.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpartialeq_to_none.stderr?ref=3af9072bc6ecd429f9101301166331dec21a1300", "patch": "@@ -0,0 +1,110 @@\n+error: binary comparison to literal `Option::None`\n+  --> $DIR/partialeq_to_none.rs:14:8\n+   |\n+LL |     if f != None { \"yay\" } else { \"nay\" }\n+   |        ^^^^^^^^^ help: use `Option::is_some()` instead: `f.is_some()`\n+   |\n+   = note: `-D clippy::partialeq-to-none` implied by `-D warnings`\n+\n+error: binary comparison to literal `Option::None`\n+  --> $DIR/partialeq_to_none.rs:32:13\n+   |\n+LL |     let _ = x == None;\n+   |             ^^^^^^^^^ help: use `Option::is_none()` instead: `x.is_none()`\n+\n+error: binary comparison to literal `Option::None`\n+  --> $DIR/partialeq_to_none.rs:33:13\n+   |\n+LL |     let _ = x != None;\n+   |             ^^^^^^^^^ help: use `Option::is_some()` instead: `x.is_some()`\n+\n+error: binary comparison to literal `Option::None`\n+  --> $DIR/partialeq_to_none.rs:34:13\n+   |\n+LL |     let _ = None == x;\n+   |             ^^^^^^^^^ help: use `Option::is_none()` instead: `x.is_none()`\n+\n+error: binary comparison to literal `Option::None`\n+  --> $DIR/partialeq_to_none.rs:35:13\n+   |\n+LL |     let _ = None != x;\n+   |             ^^^^^^^^^ help: use `Option::is_some()` instead: `x.is_some()`\n+\n+error: binary comparison to literal `Option::None`\n+  --> $DIR/partialeq_to_none.rs:37:8\n+   |\n+LL |     if foobar() == None {}\n+   |        ^^^^^^^^^^^^^^^^ help: use `Option::is_none()` instead: `foobar().is_none()`\n+\n+error: binary comparison to literal `Option::None`\n+  --> $DIR/partialeq_to_none.rs:39:8\n+   |\n+LL |     if bar().ok() != None {}\n+   |        ^^^^^^^^^^^^^^^^^^ help: use `Option::is_some()` instead: `bar().ok().is_some()`\n+\n+error: binary comparison to literal `Option::None`\n+  --> $DIR/partialeq_to_none.rs:41:13\n+   |\n+LL |     let _ = Some(1 + 2) != None;\n+   |             ^^^^^^^^^^^^^^^^^^^ help: use `Option::is_some()` instead: `Some(1 + 2).is_some()`\n+\n+error: binary comparison to literal `Option::None`\n+  --> $DIR/partialeq_to_none.rs:43:13\n+   |\n+LL |     let _ = { Some(0) } == None;\n+   |             ^^^^^^^^^^^^^^^^^^^ help: use `Option::is_none()` instead: `{ Some(0) }.is_none()`\n+\n+error: binary comparison to literal `Option::None`\n+  --> $DIR/partialeq_to_none.rs:45:13\n+   |\n+LL |       let _ = {\n+   |  _____________^\n+LL | |         /*\n+LL | |           This comment runs long\n+LL | |         */\n+LL | |         Some(1)\n+LL | |     } != None;\n+   | |_____________^\n+   |\n+help: use `Option::is_some()` instead\n+   |\n+LL ~     let _ = {\n+LL +         /*\n+LL +           This comment runs long\n+LL +         */\n+LL +         Some(1)\n+LL ~     }.is_some();\n+   |\n+\n+error: binary comparison to literal `Option::None`\n+  --> $DIR/partialeq_to_none.rs:55:13\n+   |\n+LL |     let _ = optref() == &&None;\n+   |             ^^^^^^^^^^^^^^^^^^ help: use `Option::is_none()` instead: `optref().is_none()`\n+\n+error: binary comparison to literal `Option::None`\n+  --> $DIR/partialeq_to_none.rs:56:13\n+   |\n+LL |     let _ = &&None != optref();\n+   |             ^^^^^^^^^^^^^^^^^^ help: use `Option::is_some()` instead: `optref().is_some()`\n+\n+error: binary comparison to literal `Option::None`\n+  --> $DIR/partialeq_to_none.rs:57:13\n+   |\n+LL |     let _ = **optref() == None;\n+   |             ^^^^^^^^^^^^^^^^^^ help: use `Option::is_none()` instead: `optref().is_none()`\n+\n+error: binary comparison to literal `Option::None`\n+  --> $DIR/partialeq_to_none.rs:58:13\n+   |\n+LL |     let _ = &None != *optref();\n+   |             ^^^^^^^^^^^^^^^^^^ help: use `Option::is_some()` instead: `optref().is_some()`\n+\n+error: binary comparison to literal `Option::None`\n+  --> $DIR/partialeq_to_none.rs:61:13\n+   |\n+LL |     let _ = None != *x;\n+   |             ^^^^^^^^^^ help: use `Option::is_some()` instead: `(*x).is_some()`\n+\n+error: aborting due to 15 previous errors\n+"}, {"sha": "a48829caac019249bab85a83552340e117574e82", "filename": "tests/ui/same_functions_in_if_condition.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3af9072bc6ecd429f9101301166331dec21a1300/tests%2Fui%2Fsame_functions_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af9072bc6ecd429f9101301166331dec21a1300/tests%2Fui%2Fsame_functions_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsame_functions_in_if_condition.rs?ref=3af9072bc6ecd429f9101301166331dec21a1300", "patch": "@@ -48,9 +48,9 @@ fn ifs_same_cond_fn() {\n     }\n \n     let mut v = vec![1];\n-    if v.pop() == None {\n+    if v.pop().is_none() {\n         //~ ERROR ifs same condition\n-    } else if v.pop() == None {\n+    } else if v.pop().is_none() {\n     }\n \n     if v.len() == 42 {"}, {"sha": "cd438b830401d746587e10d51b646be076b6de58", "filename": "tests/ui/same_functions_in_if_condition.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3af9072bc6ecd429f9101301166331dec21a1300/tests%2Fui%2Fsame_functions_in_if_condition.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3af9072bc6ecd429f9101301166331dec21a1300/tests%2Fui%2Fsame_functions_in_if_condition.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsame_functions_in_if_condition.stderr?ref=3af9072bc6ecd429f9101301166331dec21a1300", "patch": "@@ -50,14 +50,14 @@ LL |     if obj.method_arg(a) {\n error: this `if` has the same function call as a previous `if`\n   --> $DIR/same_functions_in_if_condition.rs:53:15\n    |\n-LL |     } else if v.pop() == None {\n-   |               ^^^^^^^^^^^^^^^\n+LL |     } else if v.pop().is_none() {\n+   |               ^^^^^^^^^^^^^^^^^\n    |\n note: same as this\n   --> $DIR/same_functions_in_if_condition.rs:51:8\n    |\n-LL |     if v.pop() == None {\n-   |        ^^^^^^^^^^^^^^^\n+LL |     if v.pop().is_none() {\n+   |        ^^^^^^^^^^^^^^^^^\n \n error: this `if` has the same function call as a previous `if`\n   --> $DIR/same_functions_in_if_condition.rs:58:15"}]}