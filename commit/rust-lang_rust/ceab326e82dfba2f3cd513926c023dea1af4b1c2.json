{"sha": "ceab326e82dfba2f3cd513926c023dea1af4b1c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlYWIzMjZlODJkZmJhMmYzY2Q1MTM5MjZjMDIzZGVhMWFmNGIxYzI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-01T17:26:43Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-10T09:37:10Z"}, "message": "Migrate uv process bindings away from ~fn()", "tree": {"sha": "93c60882449d67cb450e08347f097a5484e6f0fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93c60882449d67cb450e08347f097a5484e6f0fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ceab326e82dfba2f3cd513926c023dea1af4b1c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ceab326e82dfba2f3cd513926c023dea1af4b1c2", "html_url": "https://github.com/rust-lang/rust/commit/ceab326e82dfba2f3cd513926c023dea1af4b1c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ceab326e82dfba2f3cd513926c023dea1af4b1c2/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24b42234185427c5141b03103d8ce640538ba500", "url": "https://api.github.com/repos/rust-lang/rust/commits/24b42234185427c5141b03103d8ce640538ba500", "html_url": "https://github.com/rust-lang/rust/commit/24b42234185427c5141b03103d8ce640538ba500"}], "stats": {"total": 315, "additions": 115, "deletions": 200}, "files": [{"sha": "66abca5924f2f2c14a6133eca6a3240837988543", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ceab326e82dfba2f3cd513926c023dea1af4b1c2/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceab326e82dfba2f3cd513926c023dea1af4b1c2/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=ceab326e82dfba2f3cd513926c023dea1af4b1c2", "patch": "@@ -139,8 +139,8 @@ pub trait UvHandle<T> {\n \n     fn install(~self) -> ~Self {\n         unsafe {\n-            let myptr = cast::transmute::<&~Self, *u8>(&self);\n-            uvll::set_data_for_uv_handle(self.uv_handle(), myptr);\n+            let myptr = cast::transmute::<&~Self, &*u8>(&self);\n+            uvll::set_data_for_uv_handle(self.uv_handle(), *myptr);\n         }\n         self\n     }\n@@ -188,9 +188,6 @@ pub type NullCallback = ~fn();\n pub type IdleCallback = ~fn(IdleWatcher, Option<UvError>);\n pub type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n pub type FsCallback = ~fn(&mut FsRequest, Option<UvError>);\n-// first int is exit_status, second is term_signal\n-pub type ExitCallback = ~fn(Process, int, int, Option<UvError>);\n-pub type TimerCallback = ~fn(TimerWatcher, Option<UvError>);\n pub type AsyncCallback = ~fn(AsyncWatcher, Option<UvError>);\n pub type UdpReceiveCallback = ~fn(UdpWatcher, int, Buf, SocketAddr, uint, Option<UvError>);\n pub type UdpSendCallback = ~fn(UdpWatcher, Option<UvError>);\n@@ -206,11 +203,9 @@ struct WatcherData {\n     close_cb: Option<NullCallback>,\n     alloc_cb: Option<AllocCallback>,\n     idle_cb: Option<IdleCallback>,\n-    timer_cb: Option<TimerCallback>,\n     async_cb: Option<AsyncCallback>,\n     udp_recv_cb: Option<UdpReceiveCallback>,\n     udp_send_cb: Option<UdpSendCallback>,\n-    exit_cb: Option<ExitCallback>,\n     signal_cb: Option<SignalCallback>,\n }\n \n@@ -242,11 +237,9 @@ impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n                 close_cb: None,\n                 alloc_cb: None,\n                 idle_cb: None,\n-                timer_cb: None,\n                 async_cb: None,\n                 udp_recv_cb: None,\n                 udp_send_cb: None,\n-                exit_cb: None,\n                 signal_cb: None,\n             };\n             let data = transmute::<~WatcherData, *c_void>(data);"}, {"sha": "96b08b3f88b6e56703f50b3834d4f0e4992a9cab", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 105, "deletions": 61, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/ceab326e82dfba2f3cd513926c023dea1af4b1c2/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceab326e82dfba2f3cd513926c023dea1af4b1c2/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=ceab326e82dfba2f3cd513926c023dea1af4b1c2", "patch": "@@ -9,58 +9,42 @@\n // except according to those terms.\n \n use std::cell::Cell;\n+use std::libc::c_int;\n use std::libc;\n use std::ptr;\n-use std::vec;\n+use std::rt::BlockedTask;\n+use std::rt::io::IoError;\n use std::rt::io::process::*;\n+use std::rt::local::Local;\n+use std::rt::rtio::RtioProcess;\n+use std::rt::sched::{Scheduler, SchedHandle};\n+use std::vec;\n \n-use super::{Watcher, Loop, NativeHandle, UvError};\n-use super::{status_to_maybe_uv_error, ExitCallback};\n-use uvio::{UvPipeStream, UvUnboundPipe};\n+use super::{Loop, NativeHandle, UvHandle, UvError, uv_error_to_io_error};\n+use uvio::{HomingIO, UvPipeStream, UvUnboundPipe};\n use uvll;\n \n-/// A process wraps the handle of the underlying uv_process_t.\n-pub struct Process(*uvll::uv_process_t);\n+pub struct Process {\n+    handle: *uvll::uv_process_t,\n+    home: SchedHandle,\n \n-impl Watcher for Process {}\n+    /// Task to wake up (may be null) for when the process exits\n+    to_wake: Option<BlockedTask>,\n \n-impl Process {\n-    /// Creates a new process, ready to spawn inside an event loop\n-    pub fn new() -> Process {\n-        let handle = unsafe { uvll::malloc_handle(uvll::UV_PROCESS) };\n-        assert!(handle.is_not_null());\n-        let mut ret: Process = NativeHandle::from_native_handle(handle);\n-        ret.install_watcher_data();\n-        return ret;\n-    }\n+    /// Collected from the exit_cb\n+    exit_status: Option<int>,\n+    term_signal: Option<int>,\n+}\n \n+impl Process {\n     /// Spawn a new process inside the specified event loop.\n     ///\n-    /// The `config` variable will be passed down to libuv, and the `exit_cb`\n-    /// will be run only once, when the process exits.\n-    ///\n     /// Returns either the corresponding process object or an error which\n     /// occurred.\n-    pub fn spawn(&mut self, loop_: &Loop, config: ProcessConfig,\n-                 exit_cb: ExitCallback)\n-                    -> Result<~[Option<~UvPipeStream>], UvError>\n+    pub fn spawn(loop_: &Loop, config: ProcessConfig)\n+                -> Result<(~Process, ~[Option<~UvPipeStream>]), UvError>\n     {\n         let cwd = config.cwd.map(|s| s.to_c_str());\n-\n-        extern fn on_exit(p: *uvll::uv_process_t,\n-                          exit_status: libc::c_int,\n-                          term_signal: libc::c_int) {\n-            let mut p: Process = NativeHandle::from_native_handle(p);\n-            let err = match exit_status {\n-                0 => None,\n-                _ => status_to_maybe_uv_error(-1)\n-            };\n-            p.get_watcher_data().exit_cb.take_unwrap()(p,\n-                                                       exit_status as int,\n-                                                       term_signal as int,\n-                                                       err);\n-        }\n-\n         let io = config.io;\n         let mut stdio = vec::with_capacity::<uvll::uv_stdio_container_t>(io.len());\n         let mut ret_io = vec::with_capacity(io.len());\n@@ -73,7 +57,6 @@ impl Process {\n             }\n         }\n \n-        let exit_cb = Cell::new(exit_cb);\n         let ret_io = Cell::new(ret_io);\n         do with_argv(config.program, config.args) |argv| {\n             do with_env(config.env) |envp| {\n@@ -93,34 +76,47 @@ impl Process {\n                     gid: 0,\n                 };\n \n+                let handle = UvHandle::alloc(None::<Process>, uvll::UV_PROCESS);\n                 match unsafe {\n-                    uvll::uv_spawn(loop_.native_handle(), **self, options)\n+                    uvll::uv_spawn(loop_.native_handle(), handle, options)\n                 } {\n                     0 => {\n-                        (*self).get_watcher_data().exit_cb = Some(exit_cb.take());\n-                        Ok(ret_io.take())\n+                        let process = ~Process {\n+                            handle: handle,\n+                            home: get_handle_to_current_scheduler!(),\n+                            to_wake: None,\n+                            exit_status: None,\n+                            term_signal: None,\n+                        };\n+                        Ok((process.install(), ret_io.take()))\n+                    }\n+                    err => {\n+                        unsafe { uvll::free_handle(handle) }\n+                        Err(UvError(err))\n                     }\n-                    err => Err(UvError(err))\n                 }\n             }\n         }\n     }\n+}\n \n-    /// Sends a signal to this process.\n-    ///\n-    /// This is a wrapper around `uv_process_kill`\n-    pub fn kill(&self, signum: int) -> Result<(), UvError> {\n-        match unsafe {\n-            uvll::uv_process_kill(self.native_handle(), signum as libc::c_int)\n-        } {\n-            0 => Ok(()),\n-            err => Err(UvError(err))\n+extern fn on_exit(handle: *uvll::uv_process_t,\n+                  exit_status: libc::c_int,\n+                  term_signal: libc::c_int) {\n+    let handle = handle as *uvll::uv_handle_t;\n+    let p: &mut Process = unsafe { UvHandle::from_uv_handle(&handle) };\n+\n+    assert!(p.exit_status.is_none());\n+    assert!(p.term_signal.is_none());\n+    p.exit_status = Some(exit_status as int);\n+    p.term_signal = Some(term_signal as int);\n+\n+    match p.to_wake.take() {\n+        Some(task) => {\n+            let scheduler: ~Scheduler = Local::take();\n+            scheduler.resume_blocked_task_immediately(task);\n         }\n-    }\n-\n-    /// Returns the process id of a spawned process\n-    pub fn pid(&self) -> libc::pid_t {\n-        unsafe { uvll::process_pid(**self) as libc::pid_t }\n+        None => {}\n     }\n }\n \n@@ -192,11 +188,59 @@ fn with_env<T>(env: Option<&[(~str, ~str)]>, f: &fn(**libc::c_char) -> T) -> T {\n     c_envp.as_imm_buf(|buf, _| f(buf))\n }\n \n-impl NativeHandle<*uvll::uv_process_t> for Process {\n-    fn from_native_handle(handle: *uvll::uv_process_t) -> Process {\n-        Process(handle)\n+impl HomingIO for Process {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+}\n+\n+impl UvHandle<uvll::uv_process_t> for Process {\n+    fn uv_handle(&self) -> *uvll::uv_process_t { self.handle }\n+}\n+\n+impl RtioProcess for Process {\n+    fn id(&self) -> libc::pid_t {\n+        unsafe { uvll::process_pid(self.handle) as libc::pid_t }\n+    }\n+\n+    fn kill(&mut self, signal: int) -> Result<(), IoError> {\n+        do self.home_for_io |self_| {\n+            match unsafe {\n+                uvll::process_kill(self_.handle, signal as libc::c_int)\n+            } {\n+                0 => Ok(()),\n+                err => Err(uv_error_to_io_error(UvError(err)))\n+            }\n+        }\n+    }\n+\n+    fn wait(&mut self) -> int {\n+        // Make sure (on the home scheduler) that we have an exit status listed\n+        do self.home_for_io |self_| {\n+            match self_.exit_status {\n+                Some(*) => {}\n+                None => {\n+                    // If there's no exit code previously listed, then the\n+                    // process's exit callback has yet to be invoked. We just\n+                    // need to deschedule ourselves and wait to be reawoken.\n+                    let scheduler: ~Scheduler = Local::take();\n+                    do scheduler.deschedule_running_task_and_then |_, task| {\n+                        assert!(self_.to_wake.is_none());\n+                        self_.to_wake = Some(task);\n+                    }\n+                    assert!(self_.exit_status.is_some());\n+                }\n+            }\n+        }\n+\n+        // FIXME(#10109): this is wrong\n+        self.exit_status.unwrap()\n     }\n-    fn native_handle(&self) -> *uvll::uv_process_t {\n-        match self { &Process(ptr) => ptr }\n+}\n+\n+impl Drop for Process {\n+    fn drop(&mut self) {\n+        do self.home_for_io |self_| {\n+            assert!(self_.to_wake.is_none());\n+            self_.close_async_();\n+        }\n     }\n }"}, {"sha": "f4f2563f0b9e82625e8ce11e17b66f996a28d716", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ceab326e82dfba2f3cd513926c023dea1af4b1c2/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceab326e82dfba2f3cd513926c023dea1af4b1c2/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=ceab326e82dfba2f3cd513926c023dea1af4b1c2", "patch": "@@ -103,17 +103,17 @@ impl RtioTimer for TimerWatcher {\n \n extern fn timer_cb(handle: *uvll::uv_timer_t, _status: c_int) {\n     let handle = handle as *uvll::uv_handle_t;\n-    let foo: &mut TimerWatcher = unsafe { UvHandle::from_uv_handle(&handle) };\n+    let timer : &mut TimerWatcher = unsafe { UvHandle::from_uv_handle(&handle) };\n \n-    match foo.action.take_unwrap() {\n+    match timer.action.take_unwrap() {\n         WakeTask(task) => {\n             let sched: ~Scheduler = Local::take();\n             sched.resume_blocked_task_immediately(task);\n         }\n         SendOnce(chan) => chan.send(()),\n         SendMany(chan) => {\n             chan.send(());\n-            foo.action = Some(SendMany(chan));\n+            timer.action = Some(SendMany(chan));\n         }\n     }\n }"}, {"sha": "226507ff09a438f3f931d6ee8a0916a3db812205", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 5, "deletions": 127, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/ceab326e82dfba2f3cd513926c023dea1af4b1c2/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceab326e82dfba2f3cd513926c023dea1af4b1c2/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=ceab326e82dfba2f3cd513926c023dea1af4b1c2", "patch": "@@ -23,7 +23,6 @@ use std::rt::io::net::ip::{SocketAddr, IpAddr};\n use std::rt::io::{standard_error, OtherIoError, SeekStyle, SeekSet, SeekCur,\n                   SeekEnd};\n use std::rt::io::process::ProcessConfig;\n-use std::rt::BlockedTask;\n use std::rt::local::Local;\n use std::rt::rtio::*;\n use std::rt::sched::{Scheduler, SchedHandle};\n@@ -772,54 +771,12 @@ impl IoFactory for UvIoFactory {\n     fn spawn(&mut self, config: ProcessConfig)\n             -> Result<(~RtioProcess, ~[Option<~RtioPipe>]), IoError>\n     {\n-        // Sadly, we must create the UvProcess before we actually call uv_spawn\n-        // so that the exit_cb can close over it and notify it when the process\n-        // has exited.\n-        let mut ret = ~UvProcess {\n-            process: Process::new(),\n-            home: None,\n-            exit_status: None,\n-            term_signal: None,\n-            exit_error: None,\n-            descheduled: None,\n-        };\n-        let ret_ptr = unsafe {\n-            *cast::transmute::<&~UvProcess, &*mut UvProcess>(&ret)\n-        };\n-\n-        // The purpose of this exit callback is to record the data about the\n-        // exit and then wake up the task which may be waiting for the process\n-        // to exit. This is all performed in the current io-loop, and the\n-        // implementation of UvProcess ensures that reading these fields always\n-        // occurs on the current io-loop.\n-        let exit_cb: ExitCallback = |_, exit_status, term_signal, error| {\n-            unsafe {\n-                assert!((*ret_ptr).exit_status.is_none());\n-                (*ret_ptr).exit_status = Some(exit_status);\n-                (*ret_ptr).term_signal = Some(term_signal);\n-                (*ret_ptr).exit_error = error;\n-                match (*ret_ptr).descheduled.take() {\n-                    Some(task) => {\n-                        let scheduler: ~Scheduler = Local::take();\n-                        scheduler.resume_blocked_task_immediately(task);\n-                    }\n-                    None => {}\n-                }\n-            }\n-        };\n-\n-        match ret.process.spawn(self.uv_loop(), config, exit_cb) {\n-            Ok(io) => {\n-                // Only now do we actually get a handle to this scheduler.\n-                ret.home = Some(get_handle_to_current_scheduler!());\n-                Ok((ret as ~RtioProcess,\n-                    io.move_iter().map(|p| p.map(|p| p as ~RtioPipe)).collect()))\n-            }\n-            Err(uverr) => {\n-                // We still need to close the process handle we created, but\n-                // that's taken care for us in the destructor of UvProcess\n-                Err(uv_error_to_io_error(uverr))\n+        match Process::spawn(self.uv_loop(), config) {\n+            Ok((p, io)) => {\n+                Ok((p as ~RtioProcess,\n+                    io.move_iter().map(|i| i.map(|p| p as ~RtioPipe)).collect()))\n             }\n+            Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n@@ -1511,85 +1468,6 @@ impl RtioFileStream for UvFileStream {\n     }\n }\n \n-pub struct UvProcess {\n-    priv process: process::Process,\n-\n-    // Sadly, this structure must be created before we return it, so in that\n-    // brief interim the `home` is None.\n-    priv home: Option<SchedHandle>,\n-\n-    // All None until the process exits (exit_error may stay None)\n-    priv exit_status: Option<int>,\n-    priv term_signal: Option<int>,\n-    priv exit_error: Option<UvError>,\n-\n-    // Used to store which task to wake up from the exit_cb\n-    priv descheduled: Option<BlockedTask>,\n-}\n-\n-impl HomingIO for UvProcess {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { self.home.get_mut_ref() }\n-}\n-\n-impl Drop for UvProcess {\n-    fn drop(&mut self) {\n-        let close = |self_: &mut UvProcess| {\n-            let scheduler: ~Scheduler = Local::take();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task = Cell::new(task);\n-                do self_.process.close {\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task.take());\n-                }\n-            }\n-        };\n-\n-        // If home is none, then this process never actually successfully\n-        // spawned, so there's no need to switch event loops\n-        if self.home.is_none() {\n-            close(self)\n-        } else {\n-            let _m = self.fire_homing_missile();\n-            close(self)\n-        }\n-    }\n-}\n-\n-impl RtioProcess for UvProcess {\n-    fn id(&self) -> pid_t {\n-        self.process.pid()\n-    }\n-\n-    fn kill(&mut self, signal: int) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        match self.process.kill(signal) {\n-            Ok(()) => Ok(()),\n-            Err(uverr) => Err(uv_error_to_io_error(uverr))\n-        }\n-    }\n-\n-    fn wait(&mut self) -> int {\n-        // Make sure (on the home scheduler) that we have an exit status listed\n-        let _m = self.fire_homing_missile();\n-        match self.exit_status {\n-            Some(*) => {}\n-            None => {\n-                // If there's no exit code previously listed, then the\n-                // process's exit callback has yet to be invoked. We just\n-                // need to deschedule ourselves and wait to be reawoken.\n-                let scheduler: ~Scheduler = Local::take();\n-                do scheduler.deschedule_running_task_and_then |_, task| {\n-                    assert!(self.descheduled.is_none());\n-                    self.descheduled = Some(task);\n-                }\n-                assert!(self.exit_status.is_some());\n-            }\n-        }\n-\n-        self.exit_status.unwrap()\n-    }\n-}\n-\n pub struct UvUnixListener {\n     priv inner: UvUnboundPipe\n }"}]}