{"sha": "c645a9febe4451bec13eda67fb808f3471d5d00f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2NDVhOWZlYmU0NDUxYmVjMTNlZGE2N2ZiODA4ZjM0NzFkNWQwMGY=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-12-14T21:16:56Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-12-14T21:16:56Z"}, "message": "adding missing doc comments", "tree": {"sha": "390e499d7a74748c7aafcfe9692ec846cd76897e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/390e499d7a74748c7aafcfe9692ec846cd76897e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c645a9febe4451bec13eda67fb808f3471d5d00f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c645a9febe4451bec13eda67fb808f3471d5d00f", "html_url": "https://github.com/rust-lang/rust/commit/c645a9febe4451bec13eda67fb808f3471d5d00f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c645a9febe4451bec13eda67fb808f3471d5d00f/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "827082ac41a7f05fe6b974523a54977100fda6b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/827082ac41a7f05fe6b974523a54977100fda6b6", "html_url": "https://github.com/rust-lang/rust/commit/827082ac41a7f05fe6b974523a54977100fda6b6"}], "stats": {"total": 93, "additions": 93, "deletions": 0}, "files": [{"sha": "c2cc6a8c4ab8e75a20c3563a4a61a36be130ba14", "filename": "src/cyclomatic_complexity.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c645a9febe4451bec13eda67fb808f3471d5d00f/src%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c645a9febe4451bec13eda67fb808f3471d5d00f/src%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcyclomatic_complexity.rs?ref=c645a9febe4451bec13eda67fb808f3471d5d00f", "patch": "@@ -11,6 +11,13 @@ use rustc_front::intravisit::{Visitor, walk_expr};\n \n use utils::{in_macro, LimitStack};\n \n+/// **What it does:** It `Warn`s on methods with high cyclomatic complexity\n+///\n+/// **Why is this bad?** Methods of high cyclomatic complexity tend to be badly readable. Also LLVM will usually optimize small methods better.\n+///\n+/// **Known problems:** Sometimes it's hard to find a way to reduce the complexity\n+///\n+/// **Example:** No. You'll see it when you get the warning.\n declare_lint! { pub CYCLOMATIC_COMPLEXITY, Warn,\n     \"finds functions that should be split up into multiple functions\" }\n "}, {"sha": "6ae10c0945572b6a4000ad95ee27e431139e2c9d", "filename": "src/lifetimes.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c645a9febe4451bec13eda67fb808f3471d5d00f/src%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c645a9febe4451bec13eda67fb808f3471d5d00f/src%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flifetimes.rs?ref=c645a9febe4451bec13eda67fb808f3471d5d00f", "patch": "@@ -19,6 +19,13 @@ declare_lint!(pub NEEDLESS_LIFETIMES, Warn,\n               \"using explicit lifetimes for references in function arguments when elision rules \\\n                would allow omitting them\");\n \n+/// **What it does:** This lint checks for lifetimes in generics that are never used anywhere else. It is `Warn` by default.\n+///\n+/// **Why is this bad?** The additional lifetimes make the code look more complicated, while there is nothing out of the ordinary going on. Removing them leads to more readable code.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `fn unused_lifetime<'a>(x: u8) { .. }`\n declare_lint!(pub UNUSED_LIFETIMES, Warn,\n               \"unused lifetimes in function definitions\");\n "}, {"sha": "5c552d2ce4244df619e750a4fb9f61b88dc23ee7", "filename": "src/loops.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c645a9febe4451bec13eda67fb808f3471d5d00f/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c645a9febe4451bec13eda67fb808f3471d5d00f/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=c645a9febe4451bec13eda67fb808f3471d5d00f", "patch": "@@ -114,6 +114,13 @@ declare_lint!{ pub EXPLICIT_COUNTER_LOOP, Warn,\n /// **Example:** `loop {}`\n declare_lint!{ pub EMPTY_LOOP, Warn, \"empty `loop {}` detected\" }\n \n+/// **What it does:** This lint checks for `while let` expressions on iterators. It is `Warn` by default.\n+///\n+/// **Why is this bad?** Readability. A simple `for` loop is shorter and conveys the intent better.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** `while let Some(val) = iter() { .. }`\n declare_lint!{ pub WHILE_LET_ON_ITERATOR, Warn, \"using a while-let loop instead of a for loop on an iterator\" }\n \n #[derive(Copy, Clone)]"}, {"sha": "ef7a58959ace95618b249e59feec9a5b1721fff0", "filename": "src/methods.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c645a9febe4451bec13eda67fb808f3471d5d00f/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c645a9febe4451bec13eda67fb808f3471d5d00f/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=c645a9febe4451bec13eda67fb808f3471d5d00f", "patch": "@@ -24,6 +24,7 @@ pub struct MethodsPass;\n /// **Example:** `x.unwrap()`\n declare_lint!(pub OPTION_UNWRAP_USED, Allow,\n               \"using `Option.unwrap()`, which should at least get a better message using `expect()`\");\n+\n /// **What it does:** This lint checks for `.unwrap()` calls on `Result`s. It is `Allow` by default.\n ///\n /// **Why is this bad?** `result.unwrap()` will let the thread panic on `Err` values. Normally, you want to implement more sophisticated error handling, and propagate errors upwards with `try!`.\n@@ -35,6 +36,7 @@ declare_lint!(pub OPTION_UNWRAP_USED, Allow,\n /// **Example:** `x.unwrap()`\n declare_lint!(pub RESULT_UNWRAP_USED, Allow,\n               \"using `Result.unwrap()`, which might be better handled\");\n+\n /// **What it does:** This lint checks for `.to_string()` method calls on values of type `&str`. It is `Warn` by default.\n ///\n /// **Why is this bad?** This uses the whole formatting machinery just to clone a string. Using `.to_owned()` is lighter on resources. You can also consider using a [`Cow<'a, str>`](http://doc.rust-lang.org/std/borrow/enum.Cow.html) instead in some cases.\n@@ -44,6 +46,7 @@ declare_lint!(pub RESULT_UNWRAP_USED, Allow,\n /// **Example:** `s.to_string()` where `s: &str`\n declare_lint!(pub STR_TO_STRING, Warn,\n               \"using `to_string()` on a str, which should be `to_owned()`\");\n+\n /// **What it does:** This lint checks for `.to_string()` method calls on values of type `String`. It is `Warn` by default.\n ///\n /// **Why is this bad?** As our string is already owned, this whole operation is basically a no-op, but still creates a clone of the string (which, if really wanted, should be done with `.clone()`).\n@@ -53,6 +56,7 @@ declare_lint!(pub STR_TO_STRING, Warn,\n /// **Example:** `s.to_string()` where `s: String`\n declare_lint!(pub STRING_TO_STRING, Warn,\n               \"calling `String.to_string()` which is a no-op\");\n+\n /// **What it does:** This lint checks for methods that should live in a trait implementation of a `std` trait (see [llogiq's blog post](http://llogiq.github.io/2015/07/30/traits.html) for further information) instead of an inherent implementation. It is `Warn` by default.\n ///\n /// **Why is this bad?** Implementing the traits improve ergonomics for users of the code, often with very little cost. Also people seeing a `mul(..)` method may expect `*` to work equally, so you should have good reason to disappoint them.\n@@ -68,6 +72,7 @@ declare_lint!(pub STRING_TO_STRING, Warn,\n /// ```\n declare_lint!(pub SHOULD_IMPLEMENT_TRAIT, Warn,\n               \"defining a method that should be implementing a std trait\");\n+\n /// **What it does:** This lint checks for methods with certain name prefixes and `Warn`s (by default) if the prefix doesn't match how self is taken. The actual rules are:\n ///\n /// |Prefix |`self` taken        |\n@@ -92,6 +97,7 @@ declare_lint!(pub SHOULD_IMPLEMENT_TRAIT, Warn,\n declare_lint!(pub WRONG_SELF_CONVENTION, Warn,\n               \"defining a method named with an established prefix (like \\\"into_\\\") that takes \\\n                `self` with the wrong convention\");\n+\n /// **What it does:** This is the same as [`wrong_self_convention`](#wrong_self_convention), but for public items. This lint is `Allow` by default.\n ///\n /// **Why is this bad?** See [`wrong_self_convention`](#wrong_self_convention).\n@@ -107,12 +113,36 @@ declare_lint!(pub WRONG_SELF_CONVENTION, Warn,\n declare_lint!(pub WRONG_PUB_SELF_CONVENTION, Allow,\n               \"defining a public method named with an established prefix (like \\\"into_\\\") that takes \\\n                `self` with the wrong convention\");\n+\n+/// **What it does:** This lint `Warn`s on using `ok().expect(..)`.\n+///\n+/// **Why is this bad?** Because you usually call `expect()` on the `Result` directly to get a good error message.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:** `x.ok().expect(\"why did I do this again?\")`\n declare_lint!(pub OK_EXPECT, Warn,\n               \"using `ok().expect()`, which gives worse error messages than \\\n                calling `expect` directly on the Result\");\n+\n+/// **What it does:** This lint `Warn`s on `_.map(_).unwrap_or(_)`.\n+///\n+/// **Why is this bad?** Readability, this can be written more concisely as `_.map_or(_, _)`.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:** `x.map(|a| a + 1).unwrap_or(0)`\n declare_lint!(pub OPTION_MAP_UNWRAP_OR, Warn,\n               \"using `Option.map(f).unwrap_or(a)`, which is more succinctly expressed as \\\n                `map_or(a, f)`)\");\n+\n+/// **What it does:** This lint `Warn`s on `_.map(_).unwrap_or_else(_)`.\n+///\n+/// **Why is this bad?** Readability, this can be written more concisely as `_.map_or_else(_, _)`.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:** `x.map(|a| a + 1).unwrap_or_else(some_function)`\n declare_lint!(pub OPTION_MAP_UNWRAP_OR_ELSE, Warn,\n               \"using `Option.map(f).unwrap_or_else(g)`, which is more succinctly expressed as \\\n                `map_or_else(g, f)`)\");"}, {"sha": "1520e9c0e585dbee82bd65565bed2fdc1007395e", "filename": "src/misc_early.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c645a9febe4451bec13eda67fb808f3471d5d00f/src%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c645a9febe4451bec13eda67fb808f3471d5d00f/src%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc_early.rs?ref=c645a9febe4451bec13eda67fb808f3471d5d00f", "patch": "@@ -6,6 +6,13 @@ use syntax::ast::*;\n \n use utils::span_lint;\n \n+/// **What it does:** This lint `Warn`s on struct field patterns bound to wildcards.\n+///\n+/// **Why is this bad?** Using `..` instead is shorter and leaves the focus on the fields that are actually bound.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:** `let { a: _, b: ref b, c: _ } = ..`\n declare_lint!(pub UNNEEDED_FIELD_PATTERN, Warn,\n               \"Struct fields are bound to a wildcard instead of using `..`\");\n "}, {"sha": "2dd53c2d7839639472445de72414c69a62668020", "filename": "src/needless_features.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c645a9febe4451bec13eda67fb808f3471d5d00f/src%2Fneedless_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c645a9febe4451bec13eda67fb808f3471d5d00f/src%2Fneedless_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fneedless_features.rs?ref=c645a9febe4451bec13eda67fb808f3471d5d00f", "patch": "@@ -8,13 +8,27 @@ use rustc_front::hir::*;\n use utils::span_lint;\n use utils;\n \n+/// **What it does:** This lint `Warn`s on use of the `as_slice(..)` function, which is unstable.\n+///\n+/// **Why is this bad?** Using this function doesn't make your code better, but it will preclude it from building with stable Rust.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:** `x.as_slice(..)`\n declare_lint! {\n     pub UNSTABLE_AS_SLICE,\n     Warn,\n     \"as_slice is not stable and can be replaced by & v[..]\\\n see https://github.com/rust-lang/rust/issues/27729\"\n }\n \n+/// **What it does:** This lint `Warn`s on use of the `as_mut_slice(..)` function, which is unstable.\n+///\n+/// **Why is this bad?** Using this function doesn't make your code better, but it will preclude it from building with stable Rust.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:** `x.as_mut_slice(..)`\n declare_lint! {\n     pub UNSTABLE_AS_MUT_SLICE,\n     Warn,"}, {"sha": "e1e0f481848d14d44b2556983b5c722a3c9d60e5", "filename": "src/needless_update.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c645a9febe4451bec13eda67fb808f3471d5d00f/src%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c645a9febe4451bec13eda67fb808f3471d5d00f/src%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fneedless_update.rs?ref=c645a9febe4451bec13eda67fb808f3471d5d00f", "patch": "@@ -4,6 +4,13 @@ use rustc_front::hir::{Expr, ExprStruct};\n \n use utils::span_lint;\n \n+/// **What it does:** This lint `Warn`s on needlessly including a base struct on update when all fields are changed anyway.\n+///\n+/// **Why is this bad?** This will cost resources (because the base has to be somewhere), and make the code less readable.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:** `Point { x: 1, y: 0, ..zero_point }``\n declare_lint! {\n     pub NEEDLESS_UPDATE,\n     Warn,"}, {"sha": "b51b4235d549b907e81101c8789b49ab2de7d20f", "filename": "src/no_effect.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c645a9febe4451bec13eda67fb808f3471d5d00f/src%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c645a9febe4451bec13eda67fb808f3471d5d00f/src%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fno_effect.rs?ref=c645a9febe4451bec13eda67fb808f3471d5d00f", "patch": "@@ -6,6 +6,13 @@ use rustc_front::hir::{Stmt, StmtSemi};\n use utils::in_macro;\n use utils::span_lint;\n \n+/// **What it does:** This lint `Warn`s on statements which have no effect.\n+///\n+/// **Why is this bad?** Similar to dead code, these statements are actually executed. However, as they have no effect, all they do is make the code less readable.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:** `0;`\n declare_lint! {\n     pub NO_EFFECT,\n     Warn,"}, {"sha": "622bf5bc25e89f9376052e55c0e9424bbdac87a0", "filename": "src/temporary_assignment.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c645a9febe4451bec13eda67fb808f3471d5d00f/src%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c645a9febe4451bec13eda67fb808f3471d5d00f/src%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftemporary_assignment.rs?ref=c645a9febe4451bec13eda67fb808f3471d5d00f", "patch": "@@ -4,6 +4,13 @@ use rustc_front::hir::{Expr, ExprAssign, ExprField, ExprStruct, ExprTup, ExprTup\n use utils::is_adjusted;\n use utils::span_lint;\n \n+/// **What it does:** This lint `Warn`s on creating a struct or tuple just to assign a value in it.\n+///\n+/// **Why is this bad?** Readability. If the struct is only created to be updated, why not write the struct you want in the first place?\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:** `(0, 0).0 = 1`\n declare_lint! {\n     pub TEMPORARY_ASSIGNMENT,\n     Warn,"}]}