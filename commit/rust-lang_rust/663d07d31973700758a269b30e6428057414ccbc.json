{"sha": "663d07d31973700758a269b30e6428057414ccbc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2M2QwN2QzMTk3MzcwMDc1OGEyNjliMzBlNjQyODA1NzQxNGNjYmM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-23T01:06:44Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-23T04:33:49Z"}, "message": "Add std::istr. Issue #855", "tree": {"sha": "24ebd38c3b1b60009f1f6b7cba3f1bd21f412863", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24ebd38c3b1b60009f1f6b7cba3f1bd21f412863"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/663d07d31973700758a269b30e6428057414ccbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/663d07d31973700758a269b30e6428057414ccbc", "html_url": "https://github.com/rust-lang/rust/commit/663d07d31973700758a269b30e6428057414ccbc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/663d07d31973700758a269b30e6428057414ccbc/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55c54f0db5be696be4b27cc23e5948f8eb3acd86", "url": "https://api.github.com/repos/rust-lang/rust/commits/55c54f0db5be696be4b27cc23e5948f8eb3acd86", "html_url": "https://github.com/rust-lang/rust/commit/55c54f0db5be696be4b27cc23e5948f8eb3acd86"}], "stats": {"total": 712, "additions": 712, "deletions": 0}, "files": [{"sha": "3bb6908a787b38d51fa982bf849253260a6a21da", "filename": "src/lib/istr.rs", "status": "added", "additions": 428, "deletions": 0, "changes": 428, "blob_url": "https://github.com/rust-lang/rust/blob/663d07d31973700758a269b30e6428057414ccbc/src%2Flib%2Fistr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/663d07d31973700758a269b30e6428057414ccbc/src%2Flib%2Fistr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fistr.rs?ref=663d07d31973700758a269b30e6428057414ccbc", "patch": "@@ -0,0 +1,428 @@\n+export eq, lteq, hash, is_empty, is_not_empty, is_whitespace, byte_len,\n+index, rindex, find, starts_with, ends_with, substr, slice, split,\n+concat, connect, to_upper, replace, char_slice, trim_left, trim_right, trim,\n+unshift_char, shift_char, pop_char, push_char, is_utf8, from_chars, to_chars,\n+char_len, char_at, bytes, is_ascii, shift_byte, pop_byte;\n+\n+fn eq(a: &istr, b: &istr) -> bool { a == b }\n+\n+fn lteq(a: &istr, b: &istr) -> bool { a <= b }\n+\n+fn hash(s: &istr) -> uint {\n+    // djb hash.\n+    // FIXME: replace with murmur.\n+\n+    let u: uint = 5381u;\n+    for c: u8 in s { u *= 33u; u += c as uint; }\n+    ret u;\n+}\n+\n+// UTF-8 tags and ranges\n+const tag_cont_u8: u8 = 128u8;\n+const tag_cont: uint = 128u;\n+const max_one_b: uint = 128u;\n+const tag_two_b: uint = 192u;\n+const max_two_b: uint = 2048u;\n+const tag_three_b: uint = 224u;\n+const max_three_b: uint = 65536u;\n+const tag_four_b: uint = 240u;\n+const max_four_b: uint = 2097152u;\n+const tag_five_b: uint = 248u;\n+const max_five_b: uint = 67108864u;\n+const tag_six_b: uint = 252u;\n+\n+fn is_utf8(v: &[u8]) -> bool {\n+    let i = 0u;\n+    let total = vec::len::<u8>(v);\n+    while i < total {\n+        let chsize = utf8_char_width(v[i]);\n+        if chsize == 0u { ret false; }\n+        if i + chsize > total { ret false; }\n+        i += 1u;\n+        while chsize > 1u {\n+            if v[i] & 192u8 != tag_cont_u8 { ret false; }\n+            i += 1u;\n+            chsize -= 1u;\n+        }\n+    }\n+    ret true;\n+}\n+\n+fn is_ascii(s: &istr) -> bool {\n+    let i: uint = byte_len(s);\n+    while i > 0u { i -= 1u; if s[i] & 128u8 != 0u8 { ret false; } }\n+    ret true;\n+}\n+\n+/// Returns true if the string has length 0\n+pred is_empty(s: &istr) -> bool {\n+    for c: u8 in s { ret false; } ret true;\n+}\n+\n+/// Returns true if the string has length greater than 0\n+pred is_not_empty(s: &istr) -> bool {\n+    !is_empty(s)\n+}\n+\n+fn is_whitespace(s: &istr) -> bool {\n+    let i = 0u;\n+    let len = char_len(s);\n+    while i < len {\n+        if !char::is_whitespace(char_at(s, i)) { ret false; }\n+        i += 1u\n+    }\n+    ret true;\n+}\n+\n+fn byte_len(s: &istr) -> uint {\n+    let v: [u8] = unsafe::reinterpret_cast(s);\n+    let vlen = vec::len(v);\n+    unsafe::leak(v);\n+    // There should always be a null terminator\n+    assert vlen > 0u;\n+    ret vlen - 1u;\n+}\n+\n+fn bytes(s: &istr) -> [u8] {\n+    let v = unsafe::reinterpret_cast(s);\n+    let vcopy = vec::slice(v, 0u, vec::len(v) - 1u);\n+    unsafe::leak(v);\n+    ret vcopy;\n+}\n+\n+fn unsafe_from_bytes(v: &[mutable? u8]) -> istr {\n+    let vcopy: [u8] = v + [0u8];\n+    let scopy: istr = unsafe::reinterpret_cast(vcopy);\n+    ret scopy;\n+}\n+\n+fn unsafe_from_byte(u: u8) -> istr {\n+    unsafe_from_bytes([u])\n+}\n+\n+fn push_utf8_bytes(s: &mutable istr, ch: char) {\n+    let code = ch as uint;\n+    let bytes = if code < max_one_b {\n+        [code as u8]\n+    } else if code < max_two_b {\n+        [(code >> 6u & 31u | tag_two_b) as u8,\n+         (code & 63u | tag_cont) as u8]\n+    } else if code < max_three_b {\n+        [(code >> 12u & 15u | tag_three_b) as u8,\n+         (code >> 6u & 63u | tag_cont) as u8,\n+         (code & 63u | tag_cont) as u8]\n+    } else if code < max_four_b {\n+        [(code >> 18u & 7u | tag_four_b) as u8,\n+         (code >> 12u & 63u | tag_cont) as u8,\n+         (code >> 6u & 63u | tag_cont) as u8,\n+         (code & 63u | tag_cont) as u8]\n+    } else if code < max_five_b {\n+        [(code >> 24u & 3u | tag_five_b) as u8,\n+         (code >> 18u & 63u | tag_cont) as u8,\n+         (code >> 12u & 63u | tag_cont) as u8,\n+         (code >> 6u & 63u | tag_cont) as u8,\n+         (code & 63u | tag_cont) as u8]\n+    } else {\n+        [(code >> 30u & 1u | tag_six_b) as u8,\n+         (code >> 24u & 63u | tag_cont) as u8,\n+         (code >> 18u & 63u | tag_cont) as u8,\n+         (code >> 12u & 63u | tag_cont) as u8,\n+         (code >> 6u & 63u | tag_cont) as u8,\n+         (code & 63u | tag_cont) as u8]\n+    };\n+    push_bytes(s, bytes);\n+}\n+\n+fn from_char(ch: char) -> istr {\n+    let buf = ~\"\";\n+    push_utf8_bytes(buf, ch);\n+    ret buf;\n+}\n+\n+fn from_chars(chs: &[char]) -> istr {\n+    let buf = ~\"\";\n+    for ch: char in chs { push_utf8_bytes(buf, ch); }\n+    ret buf;\n+}\n+\n+fn utf8_char_width(b: u8) -> uint {\n+    let byte: uint = b as uint;\n+    if byte < 128u { ret 1u; }\n+    if byte < 192u {\n+        ret 0u; // Not a valid start byte\n+\n+    }\n+    if byte < 224u { ret 2u; }\n+    if byte < 240u { ret 3u; }\n+    if byte < 248u { ret 4u; }\n+    if byte < 252u { ret 5u; }\n+    ret 6u;\n+}\n+\n+fn char_range_at(s: &istr, i: uint) -> {ch: char, next: uint} {\n+    let b0 = s[i];\n+    let w = utf8_char_width(b0);\n+    assert (w != 0u);\n+    if w == 1u { ret {ch: b0 as char, next: i + 1u}; }\n+    let val = 0u;\n+    let end = i + w;\n+    i += 1u;\n+    while i < end {\n+        let byte = s[i];\n+        assert (byte & 192u8 == tag_cont_u8);\n+        val <<= 6u;\n+        val += byte & 63u8 as uint;\n+        i += 1u;\n+    }\n+    // Clunky way to get the right bits from the first byte. Uses two shifts,\n+    // the first to clip off the marker bits at the left of the byte, and then\n+    // a second (as uint) to get it to the right position.\n+    val += (b0 << (w + 1u as u8) as uint) << (w - 1u) * 6u - w - 1u;\n+    ret {ch: val as char, next: i};\n+}\n+\n+fn char_at(s: &istr, i: uint) -> char { ret char_range_at(s, i).ch; }\n+\n+fn char_len(s: &istr) -> uint {\n+    let i = 0u;\n+    let len = 0u;\n+    let total = byte_len(s);\n+    while i < total {\n+        let chsize = utf8_char_width(s[i]);\n+        assert (chsize > 0u);\n+        len += 1u;\n+        i += chsize;\n+    }\n+    assert (i == total);\n+    ret len;\n+}\n+\n+fn to_chars(s: &istr) -> [char] {\n+    let buf: [char] = [];\n+    let i = 0u;\n+    let len = byte_len(s);\n+    while i < len {\n+        let cur = char_range_at(s, i);\n+        buf += [cur.ch];\n+        i = cur.next;\n+    }\n+    ret buf;\n+}\n+\n+fn push_char(s: &mutable istr, ch: char) { s += from_char(ch); }\n+\n+fn pop_char(s: &mutable istr) -> char {\n+    let end = byte_len(s);\n+    while end > 0u && s[end - 1u] & 192u8 == tag_cont_u8 { end -= 1u; }\n+    assert (end > 0u);\n+    let ch = char_at(s, end - 1u);\n+    s = substr(s, 0u, end - 1u);\n+    ret ch;\n+}\n+\n+fn shift_char(s: &mutable istr) -> char {\n+    let r = char_range_at(s, 0u);\n+    s = substr(s, r.next, byte_len(s) - r.next);\n+    ret r.ch;\n+}\n+\n+fn unshift_char(s: &mutable istr, ch: char) { s = from_char(ch) + s; }\n+\n+fn index(s: &istr, c: u8) -> int {\n+    let i: int = 0;\n+    for k: u8 in s { if k == c { ret i; } i += 1; }\n+    ret -1;\n+}\n+\n+fn rindex(s: &istr, c: u8) -> int {\n+    let n: int = byte_len(s) as int;\n+    while n >= 0 { if s[n] == c { ret n; } n -= 1; }\n+    ret n;\n+}\n+\n+fn find(haystack: &istr, needle: &istr) -> int {\n+    let haystack_len: int = byte_len(haystack) as int;\n+    let needle_len: int = byte_len(needle) as int;\n+    if needle_len == 0 { ret 0; }\n+    fn match_at(haystack: &istr, needle: &istr, i: int) -> bool {\n+        let j: int = i;\n+        for c: u8 in needle { if haystack[j] != c { ret false; } j += 1; }\n+        ret true;\n+    }\n+    let i: int = 0;\n+    while i <= haystack_len - needle_len {\n+        if match_at(haystack, needle, i) { ret i; }\n+        i += 1;\n+    }\n+    ret -1;\n+}\n+\n+fn starts_with(haystack: &istr, needle: &istr) -> bool {\n+    let haystack_len: uint = byte_len(haystack);\n+    let needle_len: uint = byte_len(needle);\n+    if needle_len == 0u { ret true; }\n+    if needle_len > haystack_len { ret false; }\n+    ret eq(substr(haystack, 0u, needle_len), needle);\n+}\n+\n+fn ends_with(haystack: &istr, needle: &istr) -> bool {\n+    let haystack_len: uint = byte_len(haystack);\n+    let needle_len: uint = byte_len(needle);\n+    ret if needle_len == 0u {\n+            true\n+        } else if needle_len > haystack_len {\n+            false\n+        } else {\n+            eq(substr(haystack, haystack_len - needle_len, needle_len),\n+               needle)\n+        };\n+}\n+\n+fn substr(s: &istr, begin: uint, len: uint) -> istr {\n+    ret slice(s, begin, begin + len);\n+}\n+\n+fn slice(s: &istr, begin: uint, end: uint) -> istr {\n+    // FIXME: Typestate precondition\n+    assert (begin <= end);\n+    assert (end <= byte_len(s));\n+\n+    let v: [u8] = unsafe::reinterpret_cast(s);\n+    let v2 = vec::slice(v, begin, end);\n+    unsafe::leak(v);\n+    v2 += [0u8];\n+    let s2: istr = unsafe::reinterpret_cast(v2);\n+    unsafe::leak(v2);\n+    ret s2;\n+}\n+\n+fn safe_slice(s: &istr, begin: uint, end: uint)\n+    : uint::le(begin, end) -> istr {\n+    // would need some magic to make this a precondition\n+    assert (end <= byte_len(s));\n+    ret slice(s, begin, end);\n+}\n+\n+fn shift_byte(s: &mutable istr) -> u8 {\n+    let len = byte_len(s);\n+    assert (len > 0u);\n+    let b = s[0];\n+    s = substr(s, 1u, len - 1u);\n+    ret b;\n+}\n+\n+fn pop_byte(s: &mutable istr) -> u8 {\n+    let len = byte_len(s);\n+    assert (len > 0u);\n+    let b = s[len - 1u];\n+    s = substr(s, 0u, len - 1u);\n+    ret b;\n+}\n+\n+fn push_byte(s: &mutable istr, b: u8) {\n+    s += unsafe_from_byte(b);\n+}\n+\n+fn push_bytes(s: &mutable istr, bytes: &[u8]) {\n+    for byte in bytes {\n+        push_byte(s, byte);\n+    }\n+}\n+\n+fn split(s: &istr, sep: u8) -> [istr] {\n+    let v: [istr] = [];\n+    let accum: istr = ~\"\";\n+    let ends_with_sep: bool = false;\n+    for c: u8 in s {\n+        if c == sep {\n+            v += [accum];\n+            accum = ~\"\";\n+            ends_with_sep = true;\n+        } else { accum += unsafe_from_byte(c); ends_with_sep = false; }\n+    }\n+    if byte_len(accum) != 0u || ends_with_sep { v += [accum]; }\n+    ret v;\n+}\n+\n+fn concat(v: &[istr]) -> istr {\n+    let s: istr = ~\"\";\n+    for ss: istr in v { s += ss; }\n+    ret s;\n+}\n+\n+fn connect(v: &[istr], sep: &istr) -> istr {\n+    let s: istr = ~\"\";\n+    let first: bool = true;\n+    for ss: istr in v {\n+        if first { first = false; } else { s += sep; }\n+        s += ss;\n+    }\n+    ret s;\n+}\n+\n+// FIXME: This only handles ASCII\n+fn to_upper(s: &istr) -> istr {\n+    let outstr = ~\"\";\n+    let ascii_a = 'a' as u8;\n+    let ascii_z = 'z' as u8;\n+    let diff = 32u8;\n+    for byte: u8 in s {\n+        let next;\n+        if ascii_a <= byte && byte <= ascii_z {\n+            next = byte - diff;\n+        } else { next = byte; }\n+        push_byte(outstr, next);\n+    }\n+    ret outstr;\n+}\n+\n+// FIXME: This is super-inefficient\n+fn replace(s: &istr, from: &istr, to: &istr) : is_not_empty(from) -> istr {\n+    // FIXME (694): Shouldn't have to check this\n+    check (is_not_empty(from));\n+    if byte_len(s) == 0u {\n+        ret ~\"\";\n+    } else if starts_with(s, from) {\n+        ret to + replace(slice(s, byte_len(from), byte_len(s)), from, to);\n+    } else {\n+        ret unsafe_from_byte(s[0]) +\n+                replace(slice(s, 1u, byte_len(s)), from, to);\n+    }\n+}\n+\n+// FIXME: Also not efficient\n+fn char_slice(s: &istr, begin: uint, end: uint) -> istr {\n+    from_chars(vec::slice(to_chars(s), begin, end))\n+}\n+\n+fn trim_left(s: &istr) -> istr {\n+    fn count_whities(s: &[char]) -> uint {\n+        let i = 0u;\n+        while i < vec::len(s) {\n+            if !char::is_whitespace(s[i]) { break; }\n+            i += 1u;\n+        }\n+        ret i;\n+    }\n+    let chars = to_chars(s);\n+    let whities = count_whities(chars);\n+    ret from_chars(vec::slice(chars, whities, vec::len(chars)));\n+}\n+\n+fn trim_right(s: &istr) -> istr {\n+    fn count_whities(s: &[char]) -> uint {\n+        let i = vec::len(s);\n+        while 0u < i {\n+            if !char::is_whitespace(s[i - 1u]) { break; }\n+            i -= 1u;\n+        }\n+        ret i;\n+    }\n+    let chars = to_chars(s);\n+    let whities = count_whities(chars);\n+    ret from_chars(vec::slice(chars, 0u, whities));\n+}\n+\n+fn trim(s: &istr) -> istr {\n+    trim_left(trim_right(s))\n+}\n\\ No newline at end of file"}, {"sha": "fca67a25da46130a83344327f052e529fef0dc74", "filename": "src/lib/std.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/663d07d31973700758a269b30e6428057414ccbc/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/663d07d31973700758a269b30e6428057414ccbc/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=663d07d31973700758a269b30e6428057414ccbc", "patch": "@@ -16,6 +16,7 @@ mod u8;\n mod u64;\n mod vec;\n mod str;\n+mod istr;\n \n // General io and system-services modules.\n "}, {"sha": "737bde7c5f3c25bf6be9646b0240ecc964ee1aca", "filename": "src/test/run-pass/utf8_chars-istr.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/663d07d31973700758a269b30e6428057414ccbc/src%2Ftest%2Frun-pass%2Futf8_chars-istr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/663d07d31973700758a269b30e6428057414ccbc/src%2Ftest%2Frun-pass%2Futf8_chars-istr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars-istr.rs?ref=663d07d31973700758a269b30e6428057414ccbc", "patch": "@@ -0,0 +1,31 @@\n+use std;\n+import std::istr;\n+import std::vec;\n+\n+fn main() {\n+    // Chars of 1, 2, 3, and 4 bytes\n+    let chs: [char] = ['e', '\u00e9', '\u20ac', 0x10000 as char];\n+    let s: istr = istr::from_chars(chs);\n+\n+    assert (istr::byte_len(s) == 10u);\n+    assert (istr::char_len(s) == 4u);\n+    assert (vec::len::<char>(istr::to_chars(s)) == 4u);\n+    assert (istr::eq(istr::from_chars(istr::to_chars(s)), s));\n+    assert (istr::char_at(s, 0u) == 'e');\n+    assert (istr::char_at(s, 1u) == '\u00e9');\n+\n+    assert (istr::is_utf8(istr::bytes(s)));\n+    assert (!istr::is_utf8([0x80_u8]));\n+    assert (!istr::is_utf8([0xc0_u8]));\n+    assert (!istr::is_utf8([0xc0_u8, 0x10_u8]));\n+\n+    let stack = ~\"a\u00d7c\u20ac\";\n+    assert (istr::pop_char(stack) == '\u20ac');\n+    assert (istr::pop_char(stack) == 'c');\n+    istr::push_char(stack, 'u');\n+    assert (istr::eq(stack, ~\"a\u00d7u\"));\n+    assert (istr::shift_char(stack) == 'a');\n+    assert (istr::shift_char(stack) == '\u00d7');\n+    istr::unshift_char(stack, '\u00df');\n+    assert (istr::eq(stack, ~\"\u00dfu\"));\n+}"}, {"sha": "f37b0b0e640c856496730ff67e4843556d923b97", "filename": "src/test/stdtest/istr.rs", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/663d07d31973700758a269b30e6428057414ccbc/src%2Ftest%2Fstdtest%2Fistr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/663d07d31973700758a269b30e6428057414ccbc/src%2Ftest%2Fstdtest%2Fistr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fistr.rs?ref=663d07d31973700758a269b30e6428057414ccbc", "patch": "@@ -0,0 +1,251 @@\n+import std::istr;\n+\n+#[test]\n+fn test_eq() {\n+    assert istr::eq(~\"\", ~\"\");\n+    assert istr::eq(~\"foo\", ~\"foo\");\n+    assert !istr::eq(~\"foo\", ~\"bar\");\n+}\n+\n+#[test]\n+fn test_lteq() {\n+    assert istr::lteq(~\"\", ~\"\");\n+    assert istr::lteq(~\"\", ~\"foo\");\n+    assert istr::lteq(~\"foo\", ~\"foo\");\n+    assert !istr::eq(~\"foo\", ~\"bar\");\n+}\n+\n+#[test]\n+fn test_bytes_len() {\n+    assert (istr::byte_len(~\"\") == 0u);\n+    assert (istr::byte_len(~\"hello world\") == 11u);\n+    assert (istr::byte_len(~\"\\x63\") == 1u);\n+    assert (istr::byte_len(~\"\\xa2\") == 2u);\n+    assert (istr::byte_len(~\"\\u03c0\") == 2u);\n+    assert (istr::byte_len(~\"\\u2620\") == 3u);\n+    assert (istr::byte_len(~\"\\U0001d11e\") == 4u);\n+}\n+\n+#[test]\n+fn test_index_and_rindex() {\n+    assert (istr::index(~\"hello\", 'e' as u8) == 1);\n+    assert (istr::index(~\"hello\", 'o' as u8) == 4);\n+    assert (istr::index(~\"hello\", 'z' as u8) == -1);\n+    assert (istr::rindex(~\"hello\", 'l' as u8) == 3);\n+    assert (istr::rindex(~\"hello\", 'h' as u8) == 0);\n+    assert (istr::rindex(~\"hello\", 'z' as u8) == -1);\n+}\n+\n+#[test]\n+fn test_split() {\n+    fn t(s: &istr, c: char, i: int, k: &istr) {\n+        log ~\"splitting: \" + s;\n+        log i;\n+        let v = istr::split(s, c as u8);\n+        log ~\"split to: \";\n+        for z: istr in v { log z; }\n+        log ~\"comparing: \" + v[i] + ~\" vs. \" + k;\n+        assert (istr::eq(v[i], k));\n+    }\n+    t(~\"abc.hello.there\", '.', 0, ~\"abc\");\n+    t(~\"abc.hello.there\", '.', 1, ~\"hello\");\n+    t(~\"abc.hello.there\", '.', 2, ~\"there\");\n+    t(~\".hello.there\", '.', 0, ~\"\");\n+    t(~\".hello.there\", '.', 1, ~\"hello\");\n+    t(~\"...hello.there.\", '.', 3, ~\"hello\");\n+    t(~\"...hello.there.\", '.', 5, ~\"\");\n+}\n+\n+#[test]\n+fn test_find() {\n+    fn t(haystack: &istr, needle: &istr, i: int) {\n+        let j: int = istr::find(haystack, needle);\n+        log ~\"searched for \" + needle;\n+        log j;\n+        assert (i == j);\n+    }\n+    t(~\"this is a simple\", ~\"is a\", 5);\n+    t(~\"this is a simple\", ~\"is z\", -1);\n+    t(~\"this is a simple\", ~\"\", 0);\n+    t(~\"this is a simple\", ~\"simple\", 10);\n+    t(~\"this\", ~\"simple\", -1);\n+}\n+\n+#[test]\n+fn test_substr() {\n+    fn t(a: &istr, b: &istr, start: int) {\n+        assert (istr::eq(istr::substr(a, start as uint,\n+                                      istr::byte_len(b)), b));\n+    }\n+    t(~\"hello\", ~\"llo\", 2);\n+    t(~\"hello\", ~\"el\", 1);\n+    t(~\"substr should not be a challenge\", ~\"not\", 14);\n+}\n+\n+#[test]\n+fn test_concat() {\n+    fn t(v: &[istr], s: &istr) { assert (istr::eq(istr::concat(v), s)); }\n+    t([~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"], ~\"youknowI'mnogood\");\n+    let v: [istr] = [];\n+    t(v, ~\"\");\n+    t([~\"hi\"], ~\"hi\");\n+}\n+\n+#[test]\n+fn test_connect() {\n+    fn t(v: &[istr], sep: &istr, s: &istr) {\n+        assert (istr::eq(istr::connect(v, sep), s));\n+    }\n+    t([~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"], ~\" \",\n+      ~\"you know I'm no good\");\n+    let v: [istr] = [];\n+    t(v, ~\" \", ~\"\");\n+    t([~\"hi\"], ~\" \", ~\"hi\");\n+}\n+\n+#[test]\n+fn test_to_upper() {\n+    // to_upper doesn't understand unicode yet,\n+    // but we need to at least preserve it\n+\n+    let unicode = ~\"\\u65e5\\u672c\";\n+    let input = ~\"abcDEF\" + unicode + ~\"xyz:.;\";\n+    let expected = ~\"ABCDEF\" + unicode + ~\"XYZ:.;\";\n+    let actual = istr::to_upper(input);\n+    assert (istr::eq(expected, actual));\n+}\n+\n+#[test]\n+fn test_slice() {\n+    assert (istr::eq(~\"ab\", istr::slice(~\"abc\", 0u, 2u)));\n+    assert (istr::eq(~\"bc\", istr::slice(~\"abc\", 1u, 3u)));\n+    assert (istr::eq(~\"\", istr::slice(~\"abc\", 1u, 1u)));\n+    fn a_million_letter_a() -> istr {\n+        let i = 0;\n+        let rs = ~\"\";\n+        while i < 100000 { rs += ~\"aaaaaaaaaa\"; i += 1; }\n+        ret rs;\n+    }\n+    fn half_a_million_letter_a() -> istr {\n+        let i = 0;\n+        let rs = ~\"\";\n+        while i < 100000 { rs += ~\"aaaaa\"; i += 1; }\n+        ret rs;\n+    }\n+    assert (istr::eq(half_a_million_letter_a(),\n+                    istr::slice(a_million_letter_a(), 0u, 500000u)));\n+}\n+\n+#[test]\n+fn test_starts_with() {\n+    assert (istr::starts_with(~\"\", ~\"\"));\n+    assert (istr::starts_with(~\"abc\", ~\"\"));\n+    assert (istr::starts_with(~\"abc\", ~\"a\"));\n+    assert (!istr::starts_with(~\"a\", ~\"abc\"));\n+    assert (!istr::starts_with(~\"\", ~\"abc\"));\n+}\n+\n+#[test]\n+fn test_ends_with() {\n+    assert (istr::ends_with(~\"\", ~\"\"));\n+    assert (istr::ends_with(~\"abc\", ~\"\"));\n+    assert (istr::ends_with(~\"abc\", ~\"c\"));\n+    assert (!istr::ends_with(~\"a\", ~\"abc\"));\n+    assert (!istr::ends_with(~\"\", ~\"abc\"));\n+}\n+\n+#[test]\n+fn test_is_empty() {\n+    assert (istr::is_empty(~\"\"));\n+    assert (!istr::is_empty(~\"a\"));\n+}\n+\n+#[test]\n+fn test_is_not_empty() {\n+    assert (istr::is_not_empty(~\"a\"));\n+    assert (!istr::is_not_empty(~\"\"));\n+}\n+\n+#[test]\n+fn test_replace() {\n+    let a = ~\"a\";\n+    check (istr::is_not_empty(a));\n+    assert (istr::replace(~\"\", a, ~\"b\") == ~\"\");\n+    assert (istr::replace(~\"a\", a, ~\"b\") == ~\"b\");\n+    assert (istr::replace(~\"ab\", a, ~\"b\") == ~\"bb\");\n+    let test = ~\"test\";\n+    check (istr::is_not_empty(test));\n+    assert (istr::replace(~\" test test \", test, ~\"toast\")\n+            == ~\" toast toast \");\n+    assert (istr::replace(~\" test test \", test, ~\"\") == ~\"   \");\n+}\n+\n+#[test]\n+fn test_char_slice() {\n+    assert (istr::eq(~\"ab\", istr::char_slice(~\"abc\", 0u, 2u)));\n+    assert (istr::eq(~\"bc\", istr::char_slice(~\"abc\", 1u, 3u)));\n+    assert (istr::eq(~\"\", istr::char_slice(~\"abc\", 1u, 1u)));\n+    assert (istr::eq(~\"\\u65e5\", istr::char_slice(~\"\\u65e5\\u672c\", 0u, 1u)));\n+}\n+\n+#[test]\n+fn trim_left() {\n+    assert (istr::trim_left(~\"\") == ~\"\");\n+    assert (istr::trim_left(~\"a\") == ~\"a\");\n+    assert (istr::trim_left(~\"    \") == ~\"\");\n+    assert (istr::trim_left(~\"     blah\") == ~\"blah\");\n+    assert (istr::trim_left(~\"   \\u3000  wut\") == ~\"wut\");\n+    assert (istr::trim_left(~\"hey \") == ~\"hey \");\n+}\n+\n+#[test]\n+fn trim_right() {\n+    assert (istr::trim_right(~\"\") == ~\"\");\n+    assert (istr::trim_right(~\"a\") == ~\"a\");\n+    assert (istr::trim_right(~\"    \") == ~\"\");\n+    assert (istr::trim_right(~\"blah     \") == ~\"blah\");\n+    assert (istr::trim_right(~\"wut   \\u3000  \") == ~\"wut\");\n+    assert (istr::trim_right(~\" hey\") == ~\" hey\");\n+}\n+\n+#[test]\n+fn trim() {\n+    assert (istr::trim(~\"\") == ~\"\");\n+    assert (istr::trim(~\"a\") == ~\"a\");\n+    assert (istr::trim(~\"    \") == ~\"\");\n+    assert (istr::trim(~\"    blah     \") == ~\"blah\");\n+    assert (istr::trim(~\"\\nwut   \\u3000  \") == ~\"wut\");\n+    assert (istr::trim(~\" hey dude \") == ~\"hey dude\");\n+}\n+\n+#[test]\n+fn is_whitespace() {\n+    assert (istr::is_whitespace(~\"\"));\n+    assert (istr::is_whitespace(~\" \"));\n+    assert (istr::is_whitespace(~\"\\u2009\")); // Thin space\n+    assert (istr::is_whitespace(~\"  \\n\\t   \"));\n+    assert (!istr::is_whitespace(~\"   _   \"));\n+}\n+\n+#[test]\n+fn is_ascii() {\n+    assert istr::is_ascii(~\"\");\n+    assert istr::is_ascii(~\"a\");\n+    assert !istr::is_ascii(~\"\\u2009\");\n+}\n+\n+#[test]\n+fn shift_byte() {\n+    let s = ~\"ABC\";\n+    let b = istr::shift_byte(s);\n+    assert s == ~\"BC\";\n+    assert b == 65u8;\n+}\n+\n+#[test]\n+fn pop_byte() {\n+    let s = ~\"ABC\";\n+    let b = istr::pop_byte(s);\n+    assert s == ~\"AB\";\n+    assert b == 67u8;\n+}"}, {"sha": "ecf157cddaed108f807053898736b72cc3fd5b77", "filename": "src/test/stdtest/stdtest.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/663d07d31973700758a269b30e6428057414ccbc/src%2Ftest%2Fstdtest%2Fstdtest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/663d07d31973700758a269b30e6428057414ccbc/src%2Ftest%2Fstdtest%2Fstdtest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fstdtest.rc?ref=663d07d31973700758a269b30e6428057414ccbc", "patch": "@@ -25,6 +25,7 @@ mod sha1;\n mod sort;\n mod str_buf;\n mod str;\n+mod istr;\n mod task;\n mod test;\n mod uint;"}]}