{"sha": "8289b96216b5d4ddd0b6cf9feccb7af574d022a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyODliOTYyMTZiNWQ0ZGRkMGI2Y2Y5ZmVjY2I3YWY1NzRkMDIyYTg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-03T09:19:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-03T09:19:55Z"}, "message": "Merge #8309\n\n8309: Introduce `GenericArg` like in Chalk r=flodiebold a=flodiebold\n\nPlus some more adaptations to Substitution.\r\n\r\nLots of `assert_ty_ref` that we should revisit when introducing lifetime/const parameters.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "079dabc4e0de72e30d2bd04bd50427ff6950b348", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/079dabc4e0de72e30d2bd04bd50427ff6950b348"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8289b96216b5d4ddd0b6cf9feccb7af574d022a8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgaDM7CRBK7hj4Ov3rIwAAdHIIAJ7XE6NthsabSoEQd7TWpyLG\n4C4N7r1fu+qiAa/qb+RANJ4KoSvTa3evuf43JKgYdeJqbDl30hDTTdjASE96lqRy\nAIKTFaCwl+G8qI09zhulF5XvS07gU9PJXsxmneamBs63FdDLnKOZK0Evjt5N02ds\nBxJUxfcGmizelbauvVzC+H4nDG2nJyL64I49mP8/FCNcMzPpjGDZX6eKsrE0D3iP\n8E5KEk9jxf3fKbdTYJ/K2tCHGDt3yknIDZ64iDAs3y4Us/jxq1178otIEzWebc4x\n47qmtT7vq5DLy97kLcp4JgAGnOpM6V6+ANYre51izPkz/vz7Yp8yF/gkgAxRzyM=\n=P+Pt\n-----END PGP SIGNATURE-----\n", "payload": "tree 079dabc4e0de72e30d2bd04bd50427ff6950b348\nparent 327f3a0a3017e047be58b8312f8bf3ac690db3fd\nparent e480d81988fc0c0e4f80f1c54058b95b9aaf1ebf\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1617441595 +0000\ncommitter GitHub <noreply@github.com> 1617441595 +0000\n\nMerge #8309\n\n8309: Introduce `GenericArg` like in Chalk r=flodiebold a=flodiebold\n\nPlus some more adaptations to Substitution.\r\n\r\nLots of `assert_ty_ref` that we should revisit when introducing lifetime/const parameters.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8289b96216b5d4ddd0b6cf9feccb7af574d022a8", "html_url": "https://github.com/rust-lang/rust/commit/8289b96216b5d4ddd0b6cf9feccb7af574d022a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "327f3a0a3017e047be58b8312f8bf3ac690db3fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/327f3a0a3017e047be58b8312f8bf3ac690db3fd", "html_url": "https://github.com/rust-lang/rust/commit/327f3a0a3017e047be58b8312f8bf3ac690db3fd"}, {"sha": "e480d81988fc0c0e4f80f1c54058b95b9aaf1ebf", "url": "https://api.github.com/repos/rust-lang/rust/commits/e480d81988fc0c0e4f80f1c54058b95b9aaf1ebf", "html_url": "https://github.com/rust-lang/rust/commit/e480d81988fc0c0e4f80f1c54058b95b9aaf1ebf"}], "stats": {"total": 484, "additions": 323, "deletions": 161}, "files": [{"sha": "fcc577384d97a238b2e97ad6a668bd02ddd0f1c8", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=8289b96216b5d4ddd0b6cf9feccb7af574d022a8", "patch": "@@ -1829,9 +1829,11 @@ impl Type {\n         );\n \n         match db.trait_solve(self.krate, goal)? {\n-            Solution::Unique(SolutionVariables(subst)) => {\n-                subst.value.first().map(|ty| self.derived(ty.clone()))\n-            }\n+            Solution::Unique(SolutionVariables(subst)) => subst\n+                .value\n+                .interned(&Interner)\n+                .first()\n+                .map(|ty| self.derived(ty.assert_ty_ref(&Interner).clone())),\n             Solution::Ambig(_) => None,\n         }\n     }\n@@ -1889,7 +1891,9 @@ impl Type {\n                 | TyKind::Tuple(_, substs)\n                 | TyKind::OpaqueType(_, substs)\n                 | TyKind::FnDef(_, substs)\n-                | TyKind::Closure(_, substs) => substs.iter().any(go),\n+                | TyKind::Closure(_, substs) => {\n+                    substs.iter(&Interner).filter_map(|a| a.ty(&Interner)).any(go)\n+                }\n \n                 TyKind::Array(ty) | TyKind::Slice(ty) | TyKind::Raw(_, ty) | TyKind::Ref(_, ty) => {\n                     go(ty)\n@@ -1928,7 +1932,10 @@ impl Type {\n \n     pub fn tuple_fields(&self, _db: &dyn HirDatabase) -> Vec<Type> {\n         if let TyKind::Tuple(_, substs) = &self.ty.interned(&Interner) {\n-            substs.iter().map(|ty| self.derived(ty.clone())).collect()\n+            substs\n+                .iter(&Interner)\n+                .map(|ty| self.derived(ty.assert_ty_ref(&Interner).clone()))\n+                .collect()\n         } else {\n             Vec::new()\n         }\n@@ -1973,8 +1980,9 @@ impl Type {\n             .strip_references()\n             .substs()\n             .into_iter()\n-            .flat_map(|substs| substs.iter())\n-            .map(move |ty| self.derived(ty.clone()))\n+            .flat_map(|substs| substs.iter(&Interner))\n+            .filter_map(|arg| arg.ty(&Interner).cloned())\n+            .map(move |ty| self.derived(ty))\n     }\n \n     pub fn iterate_method_candidates<T>(\n@@ -2080,7 +2088,7 @@ impl Type {\n             substs: &Substitution,\n             cb: &mut impl FnMut(Type),\n         ) {\n-            for ty in substs.iter() {\n+            for ty in substs.iter(&Interner).filter_map(|a| a.ty(&Interner)) {\n                 walk_type(db, &type_.derived(ty.clone()), cb);\n             }\n         }\n@@ -2096,7 +2104,12 @@ impl Type {\n                     WhereClause::Implemented(trait_ref) => {\n                         cb(type_.clone());\n                         // skip the self type. it's likely the type we just got the bounds from\n-                        for ty in trait_ref.substitution.iter().skip(1) {\n+                        for ty in trait_ref\n+                            .substitution\n+                            .iter(&Interner)\n+                            .skip(1)\n+                            .filter_map(|a| a.ty(&Interner))\n+                        {\n                             walk_type(db, &type_.derived(ty.clone()), cb);\n                         }\n                     }"}, {"sha": "5e3c018a848835087f70c27ed31468a2b380e99c", "filename": "crates/hir_ty/src/autoderef.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs?ref=8289b96216b5d4ddd0b6cf9feccb7af574d022a8", "patch": "@@ -131,15 +131,20 @@ fn deref_by_trait(\n             // new variables in that case\n \n             for i in 1..vars.0.binders.len(&Interner) {\n-                if vars.0.value[i - 1].interned(&Interner)\n+                if vars.0.value.at(&Interner, i - 1).assert_ty_ref(&Interner).interned(&Interner)\n                     != &TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, i - 1))\n                 {\n                     warn!(\"complex solution for derefing {:?}: {:?}, ignoring\", ty.goal, solution);\n                     return None;\n                 }\n             }\n             Some(Canonical {\n-                value: vars.0.value[vars.0.value.len() - 1].clone(),\n+                value: vars\n+                    .0\n+                    .value\n+                    .at(&Interner, vars.0.value.len(&Interner) - 1)\n+                    .assert_ty_ref(&Interner)\n+                    .clone(),\n                 binders: vars.0.binders.clone(),\n             })\n         }"}, {"sha": "df6492113f96d336b820b70410444e335f2519ce", "filename": "crates/hir_ty/src/chalk_cast.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Fchalk_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Fchalk_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fchalk_cast.rs?ref=8289b96216b5d4ddd0b6cf9feccb7af574d022a8", "patch": "@@ -5,7 +5,7 @@ use chalk_ir::{\n     interner::HasInterner,\n };\n \n-use crate::{AliasEq, DomainGoal, Interner, TraitRef, WhereClause};\n+use crate::{AliasEq, DomainGoal, GenericArg, GenericArgData, Interner, TraitRef, Ty, WhereClause};\n \n macro_rules! has_interner {\n     ($t:ty) => {\n@@ -17,6 +17,8 @@ macro_rules! has_interner {\n \n has_interner!(WhereClause);\n has_interner!(DomainGoal);\n+has_interner!(GenericArg);\n+has_interner!(Ty);\n \n impl CastTo<WhereClause> for TraitRef {\n     fn cast_to(self, _interner: &Interner) -> WhereClause {\n@@ -36,6 +38,12 @@ impl CastTo<DomainGoal> for WhereClause {\n     }\n }\n \n+impl CastTo<GenericArg> for Ty {\n+    fn cast_to(self, interner: &Interner) -> GenericArg {\n+        GenericArg::new(interner, GenericArgData::Ty(self))\n+    }\n+}\n+\n macro_rules! transitive_impl {\n     ($a:ty, $b:ty, $c:ty) => {\n         impl CastTo<$c> for $a {\n@@ -51,3 +59,15 @@ macro_rules! transitive_impl {\n \n transitive_impl!(TraitRef, WhereClause, DomainGoal);\n transitive_impl!(AliasEq, WhereClause, DomainGoal);\n+\n+macro_rules! reflexive_impl {\n+    ($a:ty) => {\n+        impl CastTo<$a> for $a {\n+            fn cast_to(self, _interner: &Interner) -> $a {\n+                self\n+            }\n+        }\n+    };\n+}\n+\n+reflexive_impl!(GenericArg);"}, {"sha": "373d1cb743ab1959fa3e92ab31572366f1eb9d9d", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=8289b96216b5d4ddd0b6cf9feccb7af574d022a8", "patch": "@@ -392,7 +392,9 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             _ => return,\n         };\n \n-        if params.len() > 0 && params[0] == mismatch.actual {\n+        if params.len(&Interner) > 0\n+            && params.at(&Interner, 0).ty(&Interner) == Some(&mismatch.actual)\n+        {\n             let (_, source_map) = db.body_with_source_map(self.owner);\n \n             if let Ok(source_ptr) = source_map.expr_syntax(id) {"}, {"sha": "85ba58c443f8f982401dc2086969d3ecf1c86b22", "filename": "crates/hir_ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=8289b96216b5d4ddd0b6cf9feccb7af574d022a8", "patch": "@@ -792,7 +792,10 @@ fn pat_constructor(cx: &MatchCheckCtx, pat: PatIdOrWild) -> MatchCheckResult<Opt\n         Pat::Tuple { .. } => {\n             let pat_id = pat.as_id().expect(\"we already know this pattern is not a wild\");\n             Some(Constructor::Tuple {\n-                arity: cx.infer.type_of_pat[pat_id].as_tuple().ok_or(MatchCheckErr::Unknown)?.len(),\n+                arity: cx.infer.type_of_pat[pat_id]\n+                    .as_tuple()\n+                    .ok_or(MatchCheckErr::Unknown)?\n+                    .len(&Interner),\n             })\n         }\n         Pat::Lit(lit_expr) => match cx.body.exprs[lit_expr] {"}, {"sha": "59fd18c2ae35034b5e3be42d2ec1d5dc794be2b3", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 37, "deletions": 24, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=8289b96216b5d4ddd0b6cf9feccb7af574d022a8", "patch": "@@ -8,7 +8,7 @@ use hir_def::{\n     find_path,\n     generics::TypeParamProvenance,\n     item_scope::ItemInNs,\n-    path::{GenericArg, Path, PathKind},\n+    path::{Path, PathKind},\n     type_ref::{TypeBound, TypeRef},\n     visibility::Visibility,\n     AssocContainerId, Lookup, ModuleId, TraitId,\n@@ -18,7 +18,7 @@ use hir_expand::name::Name;\n use crate::{\n     db::HirDatabase, from_assoc_type_id, from_foreign_def_id, from_placeholder_idx, primitive,\n     to_assoc_type_id, traits::chalk::from_chalk, utils::generics, AdtId, AliasEq, AliasTy,\n-    CallableDefId, CallableSig, DomainGoal, ImplTraitId, Interner, Lifetime, OpaqueTy,\n+    CallableDefId, CallableSig, DomainGoal, GenericArg, ImplTraitId, Interner, Lifetime, OpaqueTy,\n     ProjectionTy, QuantifiedWhereClause, Scalar, Substitution, TraitRef, Ty, TyKind, WhereClause,\n };\n \n@@ -251,16 +251,16 @@ impl HirDisplay for ProjectionTy {\n         }\n \n         let trait_ = f.db.trait_data(self.trait_(f.db));\n-        let first_parameter = self.substitution[0].into_displayable(\n+        let first_parameter = self.self_type_parameter().into_displayable(\n             f.db,\n             f.max_size,\n             f.omit_verbose_types,\n             f.display_target,\n         );\n         write!(f, \"<{} as {}\", first_parameter, trait_.name)?;\n-        if self.substitution.len() > 1 {\n+        if self.substitution.len(&Interner) > 1 {\n             write!(f, \"<\")?;\n-            f.write_joined(&self.substitution[1..], \", \")?;\n+            f.write_joined(&self.substitution.interned(&Interner)[1..], \", \")?;\n             write!(f, \">\")?;\n         }\n         write!(f, \">::{}\", f.db.type_alias_data(from_assoc_type_id(self.associated_ty_id)).name)?;\n@@ -274,7 +274,15 @@ impl HirDisplay for OpaqueTy {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n \n-        self.substitution[0].hir_fmt(f)\n+        self.substitution.at(&Interner, 0).hir_fmt(f)\n+    }\n+}\n+\n+impl HirDisplay for GenericArg {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        match self.interned() {\n+            crate::GenericArgData::Ty(ty) => ty.hir_fmt(f),\n+        }\n     }\n }\n \n@@ -373,9 +381,9 @@ impl HirDisplay for Ty {\n                 }\n             }\n             TyKind::Tuple(_, substs) => {\n-                if substs.len() == 1 {\n+                if substs.len(&Interner) == 1 {\n                     write!(f, \"(\")?;\n-                    substs[0].hir_fmt(f)?;\n+                    substs.at(&Interner, 0).hir_fmt(f)?;\n                     write!(f, \",)\")?;\n                 } else {\n                     write!(f, \"(\")?;\n@@ -399,7 +407,7 @@ impl HirDisplay for Ty {\n                         write!(f, \"{}\", f.db.enum_data(e.parent).variants[e.local_id].name)?\n                     }\n                 };\n-                if parameters.len() > 0 {\n+                if parameters.len(&Interner) > 0 {\n                     let generics = generics(f.db.upcast(), def.into());\n                     let (parent_params, self_param, type_params, _impl_trait_params) =\n                         generics.provenance_split();\n@@ -451,7 +459,7 @@ impl HirDisplay for Ty {\n                     }\n                 }\n \n-                if parameters.len() > 0 {\n+                if parameters.len(&Interner) > 0 {\n                     let parameters_to_write = if f.display_target.is_source_code()\n                         || f.omit_verbose_types()\n                     {\n@@ -463,17 +471,20 @@ impl HirDisplay for Ty {\n                             None => parameters.0.as_ref(),\n                             Some(default_parameters) => {\n                                 let mut default_from = 0;\n-                                for (i, parameter) in parameters.iter().enumerate() {\n-                                    match (parameter.interned(&Interner), default_parameters.get(i))\n-                                    {\n+                                for (i, parameter) in parameters.iter(&Interner).enumerate() {\n+                                    match (\n+                                        parameter.assert_ty_ref(&Interner).interned(&Interner),\n+                                        default_parameters.get(i),\n+                                    ) {\n                                         (&TyKind::Unknown, _) | (_, None) => {\n                                             default_from = i + 1;\n                                         }\n                                         (_, Some(default_parameter)) => {\n                                             let actual_default = default_parameter\n                                                 .clone()\n                                                 .subst(&parameters.prefix(i));\n-                                            if parameter != &actual_default {\n+                                            if parameter.assert_ty_ref(&Interner) != &actual_default\n+                                            {\n                                                 default_from = i + 1;\n                                             }\n                                         }\n@@ -504,7 +515,7 @@ impl HirDisplay for Ty {\n                 // Use placeholder associated types when the target is test (https://rust-lang.github.io/chalk/book/clauses/type_equality.html#placeholder-associated-types)\n                 if f.display_target.is_test() {\n                     write!(f, \"{}::{}\", trait_.name, type_alias_data.name)?;\n-                    if parameters.len() > 0 {\n+                    if parameters.len(&Interner) > 0 {\n                         write!(f, \"<\")?;\n                         f.write_joined(&*parameters.0, \", \")?;\n                         write!(f, \">\")?;\n@@ -537,7 +548,7 @@ impl HirDisplay for Ty {\n                     }\n                     ImplTraitId::AsyncBlockTypeImplTrait(..) => {\n                         write!(f, \"impl Future<Output = \")?;\n-                        parameters[0].hir_fmt(f)?;\n+                        parameters.at(&Interner, 0).hir_fmt(f)?;\n                         write!(f, \">\")?;\n                     }\n                 }\n@@ -548,7 +559,7 @@ impl HirDisplay for Ty {\n                         DisplaySourceCodeError::Closure,\n                     ));\n                 }\n-                let sig = substs[0].callable_sig(f.db);\n+                let sig = substs.at(&Interner, 0).assert_ty_ref(&Interner).callable_sig(f.db);\n                 if let Some(sig) = sig {\n                     if sig.params().is_empty() {\n                         write!(f, \"||\")?;\n@@ -718,7 +729,9 @@ fn write_bounds_like_dyn_trait(\n                 write!(f, \"{}\", f.db.trait_data(trait_).name)?;\n                 if let [_, params @ ..] = &*trait_ref.substitution.0 {\n                     if is_fn_trait {\n-                        if let Some(args) = params.first().and_then(|it| it.as_tuple()) {\n+                        if let Some(args) =\n+                            params.first().and_then(|it| it.assert_ty_ref(&Interner).as_tuple())\n+                        {\n                             write!(f, \"(\")?;\n                             f.write_joined(&*args.0, \", \")?;\n                             write!(f, \")\")?;\n@@ -767,16 +780,16 @@ impl TraitRef {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n \n-        self.substitution[0].hir_fmt(f)?;\n+        self.self_type_parameter().hir_fmt(f)?;\n         if use_as {\n             write!(f, \" as \")?;\n         } else {\n             write!(f, \": \")?;\n         }\n         write!(f, \"{}\", f.db.trait_data(self.hir_trait_id()).name)?;\n-        if self.substitution.len() > 1 {\n+        if self.substitution.len(&Interner) > 1 {\n             write!(f, \"<\")?;\n-            f.write_joined(&self.substitution[1..], \", \")?;\n+            f.write_joined(&self.substitution.interned(&Interner)[1..], \", \")?;\n             write!(f, \">\")?;\n         }\n         Ok(())\n@@ -1016,11 +1029,11 @@ impl HirDisplay for Path {\n     }\n }\n \n-impl HirDisplay for GenericArg {\n+impl HirDisplay for hir_def::path::GenericArg {\n     fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         match self {\n-            GenericArg::Type(ty) => ty.hir_fmt(f),\n-            GenericArg::Lifetime(lifetime) => write!(f, \"{}\", lifetime.name),\n+            hir_def::path::GenericArg::Type(ty) => ty.hir_fmt(f),\n+            hir_def::path::GenericArg::Lifetime(lifetime) => write!(f, \"{}\", lifetime.name),\n         }\n     }\n }"}, {"sha": "8f7322b36ba04eed26f1e7e3db1c2d29851225d6", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=8289b96216b5d4ddd0b6cf9feccb7af574d022a8", "patch": "@@ -100,7 +100,7 @@ impl<'a> InferenceContext<'a> {\n             },\n \n             (TyKind::Closure(.., substs), TyKind::Function { .. }) => {\n-                from_ty = substs[0].clone();\n+                from_ty = substs.at(&Interner, 0).assert_ty_ref(&Interner).clone();\n             }\n \n             _ => {}"}, {"sha": "b99b6cd219dda7f7d0760d6426980e6e2527fc2a", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=8289b96216b5d4ddd0b6cf9feccb7af574d022a8", "patch": "@@ -266,7 +266,7 @@ impl<'a> InferenceContext<'a> {\n                 let sig_ty = TyKind::Function(FnPointer {\n                     num_args: sig_tys.len() - 1,\n                     sig: FnSig { abi: (), safety: chalk_ir::Safety::Safe, variadic: false },\n-                    substs: Substitution(sig_tys.clone().into()),\n+                    substs: Substitution::from_iter(&Interner, sig_tys.clone()),\n                 })\n                 .intern(&Interner);\n                 let closure_id = self.db.intern_closure((self.owner, tgt_expr)).into();\n@@ -406,7 +406,7 @@ impl<'a> InferenceContext<'a> {\n \n                 self.unify(&ty, &expected.ty);\n \n-                let substs = ty.substs().cloned().unwrap_or_else(Substitution::empty);\n+                let substs = ty.substs().cloned().unwrap_or_else(|| Substitution::empty(&Interner));\n                 let field_types = def_id.map(|it| self.db.field_types(it)).unwrap_or_default();\n                 let variant_data = def_id.map(|it| variant_data(self.db.upcast(), it));\n                 for field in fields.iter() {\n@@ -456,9 +456,13 @@ impl<'a> InferenceContext<'a> {\n                             .unwrap_or(true)\n                     };\n                     match canonicalized.decanonicalize_ty(derefed_ty.value).interned(&Interner) {\n-                        TyKind::Tuple(_, substs) => {\n-                            name.as_tuple_index().and_then(|idx| substs.0.get(idx).cloned())\n-                        }\n+                        TyKind::Tuple(_, substs) => name.as_tuple_index().and_then(|idx| {\n+                            substs\n+                                .interned(&Interner)\n+                                .get(idx)\n+                                .map(|a| a.assert_ty_ref(&Interner))\n+                                .cloned()\n+                        }),\n                         TyKind::Adt(AdtId(hir_def::AdtId::StructId(s)), parameters) => {\n                             let local_id = self.db.struct_data(*s).variant_data.field(name)?;\n                             let field = FieldId { parent: (*s).into(), local_id };\n@@ -635,7 +639,7 @@ impl<'a> InferenceContext<'a> {\n                 let rhs_ty = rhs.map(|e| self.infer_expr(e, &rhs_expect));\n                 match (range_type, lhs_ty, rhs_ty) {\n                     (RangeOp::Exclusive, None, None) => match self.resolve_range_full() {\n-                        Some(adt) => Ty::adt_ty(adt, Substitution::empty()),\n+                        Some(adt) => Ty::adt_ty(adt, Substitution::empty(&Interner)),\n                         None => self.err_ty(),\n                     },\n                     (RangeOp::Exclusive, None, Some(ty)) => match self.resolve_range_to() {\n@@ -694,8 +698,8 @@ impl<'a> InferenceContext<'a> {\n             Expr::Tuple { exprs } => {\n                 let mut tys = match expected.ty.interned(&Interner) {\n                     TyKind::Tuple(_, substs) => substs\n-                        .iter()\n-                        .cloned()\n+                        .iter(&Interner)\n+                        .map(|a| a.assert_ty_ref(&Interner).clone())\n                         .chain(repeat_with(|| self.table.new_type_var()))\n                         .take(exprs.len())\n                         .collect::<Vec<_>>(),\n@@ -706,7 +710,7 @@ impl<'a> InferenceContext<'a> {\n                     self.infer_expr_coerce(*expr, &Expectation::has_type(ty.clone()));\n                 }\n \n-                TyKind::Tuple(tys.len(), Substitution(tys.into())).intern(&Interner)\n+                TyKind::Tuple(tys.len(), Substitution::from_iter(&Interner, tys)).intern(&Interner)\n             }\n             Expr::Array(array) => {\n                 let elem_ty = match expected.ty.interned(&Interner) {\n@@ -953,7 +957,7 @@ impl<'a> InferenceContext<'a> {\n             substs.push(self.err_ty());\n         }\n         assert_eq!(substs.len(), total_len);\n-        Substitution(substs.into())\n+        Substitution::from_iter(&Interner, substs)\n     }\n \n     fn register_obligations_for_call(&mut self, callable_ty: &Ty) {"}, {"sha": "f1316415f79f4996e2d879844292a097449706dd", "filename": "crates/hir_ty/src/infer/pat.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=8289b96216b5d4ddd0b6cf9feccb7af574d022a8", "patch": "@@ -35,7 +35,7 @@ impl<'a> InferenceContext<'a> {\n         }\n         self.unify(&ty, expected);\n \n-        let substs = ty.substs().cloned().unwrap_or_else(Substitution::empty);\n+        let substs = ty.substs().cloned().unwrap_or_else(|| Substitution::empty(&Interner));\n \n         let field_tys = def.map(|it| self.db.field_types(it)).unwrap_or_default();\n         let (pre, post) = match ellipsis {\n@@ -74,7 +74,7 @@ impl<'a> InferenceContext<'a> {\n \n         self.unify(&ty, expected);\n \n-        let substs = ty.substs().cloned().unwrap_or_else(Substitution::empty);\n+        let substs = ty.substs().cloned().unwrap_or_else(|| Substitution::empty(&Interner));\n \n         let field_tys = def.map(|it| self.db.field_types(it)).unwrap_or_default();\n         for subpat in subpats {\n@@ -134,15 +134,17 @@ impl<'a> InferenceContext<'a> {\n                 };\n                 let n_uncovered_patterns = expectations.len().saturating_sub(args.len());\n                 let err_ty = self.err_ty();\n-                let mut expectations_iter = expectations.iter().chain(repeat(&err_ty));\n+                let mut expectations_iter =\n+                    expectations.iter().map(|a| a.assert_ty_ref(&Interner)).chain(repeat(&err_ty));\n                 let mut infer_pat = |(&pat, ty)| self.infer_pat(pat, ty, default_bm);\n \n                 let mut inner_tys = Vec::with_capacity(n_uncovered_patterns + args.len());\n                 inner_tys.extend(pre.iter().zip(expectations_iter.by_ref()).map(&mut infer_pat));\n                 inner_tys.extend(expectations_iter.by_ref().take(n_uncovered_patterns).cloned());\n                 inner_tys.extend(post.iter().zip(expectations_iter).map(infer_pat));\n \n-                TyKind::Tuple(inner_tys.len(), Substitution(inner_tys.into())).intern(&Interner)\n+                TyKind::Tuple(inner_tys.len(), Substitution::from_iter(&Interner, inner_tys))\n+                    .intern(&Interner)\n             }\n             Pat::Or(ref pats) => {\n                 if let Some((first_pat, rest)) = pats.split_first() {\n@@ -236,9 +238,10 @@ impl<'a> InferenceContext<'a> {\n             Pat::Box { inner } => match self.resolve_boxed_box() {\n                 Some(box_adt) => {\n                     let (inner_ty, alloc_ty) = match expected.as_adt() {\n-                        Some((adt, subst)) if adt == box_adt => {\n-                            (subst[0].clone(), subst.get(1).cloned())\n-                        }\n+                        Some((adt, subst)) if adt == box_adt => (\n+                            subst.at(&Interner, 0).assert_ty_ref(&Interner).clone(),\n+                            subst.interned(&Interner).get(1).and_then(|a| a.ty(&Interner).cloned()),\n+                        ),\n                         _ => (self.result.standard_types.unknown.clone(), None),\n                     };\n "}, {"sha": "b96391776c51469c51dd71463bdc009325d85c4c", "filename": "crates/hir_ty/src/infer/path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=8289b96216b5d4ddd0b6cf9feccb7af574d022a8", "patch": "@@ -97,12 +97,12 @@ impl<'a> InferenceContext<'a> {\n \n         let ty = self.db.value_ty(typable);\n         // self_subst is just for the parent\n-        let parent_substs = self_subst.unwrap_or_else(Substitution::empty);\n+        let parent_substs = self_subst.unwrap_or_else(|| Substitution::empty(&Interner));\n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n         let substs = ctx.substs_from_path(path, typable, true);\n-        let full_substs = Substitution::builder(substs.len())\n+        let full_substs = Substitution::builder(substs.len(&Interner))\n             .use_parent_substs(&parent_substs)\n-            .fill(substs.0[parent_substs.len()..].iter().cloned())\n+            .fill(substs.interned(&Interner)[parent_substs.len(&Interner)..].iter().cloned())\n             .build();\n         let ty = ty.subst(&full_substs);\n         Some(ty)"}, {"sha": "0efc62e5332e96adc95aecec48260ddc5edc861f", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=8289b96216b5d4ddd0b6cf9feccb7af574d022a8", "patch": "@@ -129,29 +129,28 @@ impl<T> Canonicalized<T> {\n         solution: Canonical<Substitution>,\n     ) {\n         // the solution may contain new variables, which we need to convert to new inference vars\n-        let new_vars = Substitution(\n-            solution\n-                .binders\n-                .iter(&Interner)\n-                .map(|k| match k.kind {\n-                    VariableKind::Ty(TyVariableKind::General) => ctx.table.new_type_var(),\n-                    VariableKind::Ty(TyVariableKind::Integer) => ctx.table.new_integer_var(),\n-                    VariableKind::Ty(TyVariableKind::Float) => ctx.table.new_float_var(),\n-                    // HACK: Chalk can sometimes return new lifetime variables. We\n-                    // want to just skip them, but to not mess up the indices of\n-                    // other variables, we'll just create a new type variable in\n-                    // their place instead. This should not matter (we never see the\n-                    // actual *uses* of the lifetime variable).\n-                    VariableKind::Lifetime => ctx.table.new_type_var(),\n-                    _ => panic!(\"const variable in solution\"),\n-                })\n-                .collect(),\n+        let new_vars = Substitution::from_iter(\n+            &Interner,\n+            solution.binders.iter(&Interner).map(|k| match k.kind {\n+                VariableKind::Ty(TyVariableKind::General) => ctx.table.new_type_var(),\n+                VariableKind::Ty(TyVariableKind::Integer) => ctx.table.new_integer_var(),\n+                VariableKind::Ty(TyVariableKind::Float) => ctx.table.new_float_var(),\n+                // HACK: Chalk can sometimes return new lifetime variables. We\n+                // want to just skip them, but to not mess up the indices of\n+                // other variables, we'll just create a new type variable in\n+                // their place instead. This should not matter (we never see the\n+                // actual *uses* of the lifetime variable).\n+                VariableKind::Lifetime => ctx.table.new_type_var(),\n+                _ => panic!(\"const variable in solution\"),\n+            }),\n         );\n-        for (i, ty) in solution.value.into_iter().enumerate() {\n+        for (i, ty) in solution.value.iter(&Interner).enumerate() {\n             let (v, k) = self.free_vars[i];\n             // eagerly replace projections in the type; we may be getting types\n             // e.g. from where clauses where this hasn't happened yet\n-            let ty = ctx.normalize_associated_types_in(ty.clone().subst_bound_vars(&new_vars));\n+            let ty = ctx.normalize_associated_types_in(\n+                ty.assert_ty_ref(&Interner).clone().subst_bound_vars(&new_vars),\n+            );\n             ctx.table.unify(&TyKind::InferenceVar(v, k).intern(&Interner), &ty);\n         }\n     }\n@@ -163,13 +162,13 @@ pub fn could_unify(t1: &Ty, t2: &Ty) -> bool {\n \n pub(crate) fn unify(tys: &Canonical<(Ty, Ty)>) -> Option<Substitution> {\n     let mut table = InferenceTable::new();\n-    let vars = Substitution(\n+    let vars = Substitution::from_iter(\n+        &Interner,\n         tys.binders\n             .iter(&Interner)\n             // we always use type vars here because we want everything to\n             // fallback to Unknown in the end (kind of hacky, as below)\n-            .map(|_| table.new_type_var())\n-            .collect(),\n+            .map(|_| table.new_type_var()),\n     );\n     let ty1_with_vars = tys.value.0.clone().subst_bound_vars(&vars);\n     let ty2_with_vars = tys.value.1.clone().subst_bound_vars(&vars);\n@@ -178,7 +177,8 @@ pub(crate) fn unify(tys: &Canonical<(Ty, Ty)>) -> Option<Substitution> {\n     }\n     // default any type vars that weren't unified back to their original bound vars\n     // (kind of hacky)\n-    for (i, var) in vars.iter().enumerate() {\n+    for (i, var) in vars.iter(&Interner).enumerate() {\n+        let var = var.assert_ty_ref(&Interner);\n         if &*table.resolve_ty_shallow(var) == var {\n             table.unify(\n                 var,\n@@ -188,7 +188,10 @@ pub(crate) fn unify(tys: &Canonical<(Ty, Ty)>) -> Option<Substitution> {\n     }\n     Some(\n         Substitution::builder(tys.binders.len(&Interner))\n-            .fill(vars.iter().map(|v| table.resolve_ty_completely(v.clone())))\n+            .fill(\n+                vars.iter(&Interner)\n+                    .map(|v| table.resolve_ty_completely(v.assert_ty_ref(&Interner).clone())),\n+            )\n             .build(),\n     )\n }\n@@ -284,7 +287,9 @@ impl InferenceTable {\n         substs2: &Substitution,\n         depth: usize,\n     ) -> bool {\n-        substs1.0.iter().zip(substs2.0.iter()).all(|(t1, t2)| self.unify_inner(t1, t2, depth))\n+        substs1.0.iter().zip(substs2.0.iter()).all(|(t1, t2)| {\n+            self.unify_inner(t1.assert_ty_ref(&Interner), t2.assert_ty_ref(&Interner), depth)\n+        })\n     }\n \n     fn unify_inner(&mut self, ty1: &Ty, ty2: &Ty, depth: usize) -> bool {"}, {"sha": "c927ed9738d917ab16bb418649ab75d9da3443a7", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 125, "deletions": 48, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=8289b96216b5d4ddd0b6cf9feccb7af574d022a8", "patch": "@@ -24,9 +24,10 @@ mod tests;\n #[cfg(test)]\n mod test_db;\n \n-use std::{iter, mem, ops::Deref, sync::Arc};\n+use std::{iter, mem, sync::Arc};\n \n use base_db::salsa;\n+use chalk_ir::cast::{CastTo, Caster};\n use hir_def::{\n     builtin_type::BuiltinType, expr::ExprId, type_ref::Rawness, AssocContainerId, FunctionId,\n     GenericDefId, HasModule, LifetimeParamId, Lookup, TraitId, TypeAliasId, TypeParamId,\n@@ -109,7 +110,7 @@ impl ProjectionTy {\n     }\n \n     pub fn self_type_parameter(&self) -> &Ty {\n-        &self.substitution[0]\n+        &self.substitution.interned(&Interner)[0].assert_ty_ref(&Interner)\n     }\n \n     fn trait_(&self, db: &dyn HirDatabase) -> TraitId {\n@@ -324,9 +325,72 @@ impl Ty {\n     }\n }\n \n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct GenericArg {\n+    interned: GenericArgData,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub enum GenericArgData {\n+    Ty(Ty),\n+}\n+\n+impl GenericArg {\n+    /// Constructs a generic argument using `GenericArgData`.\n+    pub fn new(_interner: &Interner, data: GenericArgData) -> Self {\n+        GenericArg { interned: data }\n+    }\n+\n+    /// Gets the interned value.\n+    pub fn interned(&self) -> &GenericArgData {\n+        &self.interned\n+    }\n+\n+    /// Asserts that this is a type argument.\n+    pub fn assert_ty_ref(&self, interner: &Interner) -> &Ty {\n+        self.ty(interner).unwrap()\n+    }\n+\n+    /// Checks whether the generic argument is a type.\n+    pub fn is_ty(&self, _interner: &Interner) -> bool {\n+        match self.interned() {\n+            GenericArgData::Ty(_) => true,\n+        }\n+    }\n+\n+    /// Returns the type if it is one, `None` otherwise.\n+    pub fn ty(&self, _interner: &Interner) -> Option<&Ty> {\n+        match self.interned() {\n+            GenericArgData::Ty(t) => Some(t),\n+        }\n+    }\n+}\n+\n+impl TypeWalk for GenericArg {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        match &self.interned {\n+            GenericArgData::Ty(ty) => {\n+                ty.walk(f);\n+            }\n+        }\n+    }\n+\n+    fn walk_mut_binders(\n+        &mut self,\n+        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n+        binders: DebruijnIndex,\n+    ) {\n+        match &mut self.interned {\n+            GenericArgData::Ty(ty) => {\n+                ty.walk_mut_binders(f, binders);\n+            }\n+        }\n+    }\n+}\n+\n /// A list of substitutions for generic parameters.\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct Substitution(SmallVec<[Ty; 2]>);\n+pub struct Substitution(SmallVec<[GenericArg; 2]>);\n \n impl TypeWalk for Substitution {\n     fn walk(&self, f: &mut impl FnMut(&Ty)) {\n@@ -347,18 +411,34 @@ impl TypeWalk for Substitution {\n }\n \n impl Substitution {\n-    pub fn interned(&self, _: &Interner) -> &[Ty] {\n+    pub fn interned(&self, _: &Interner) -> &[GenericArg] {\n         &self.0\n     }\n \n-    pub fn empty() -> Substitution {\n+    pub fn len(&self, _: &Interner) -> usize {\n+        self.0.len()\n+    }\n+\n+    pub fn is_empty(&self, _: &Interner) -> bool {\n+        self.0.is_empty()\n+    }\n+\n+    pub fn at(&self, _: &Interner, i: usize) -> &GenericArg {\n+        &self.0[i]\n+    }\n+\n+    pub fn empty(_: &Interner) -> Substitution {\n         Substitution(SmallVec::new())\n     }\n \n+    pub fn iter(&self, _: &Interner) -> std::slice::Iter<'_, GenericArg> {\n+        self.0.iter()\n+    }\n+\n     pub fn single(ty: Ty) -> Substitution {\n         Substitution({\n             let mut v = SmallVec::new();\n-            v.push(ty);\n+            v.push(ty.cast(&Interner));\n             v\n         })\n     }\n@@ -371,27 +451,23 @@ impl Substitution {\n         Substitution(self.0[self.0.len() - std::cmp::min(self.0.len(), n)..].into())\n     }\n \n-    pub fn as_single(&self) -> &Ty {\n-        if self.0.len() != 1 {\n-            panic!(\"expected substs of len 1, got {:?}\", self);\n-        }\n-        &self.0[0]\n-    }\n-\n-    pub fn from_iter(_interner: &Interner, elements: impl IntoIterator<Item = Ty>) -> Self {\n-        Substitution(elements.into_iter().collect())\n+    pub fn from_iter(\n+        interner: &Interner,\n+        elements: impl IntoIterator<Item = impl CastTo<GenericArg>>,\n+    ) -> Self {\n+        Substitution(elements.into_iter().casted(interner).collect())\n     }\n \n     /// Return Substs that replace each parameter by itself (i.e. `Ty::Param`).\n     pub(crate) fn type_params_for_generics(\n         db: &dyn HirDatabase,\n         generic_params: &Generics,\n     ) -> Substitution {\n-        Substitution(\n+        Substitution::from_iter(\n+            &Interner,\n             generic_params\n                 .iter()\n-                .map(|(id, _)| TyKind::Placeholder(to_placeholder_idx(db, id)).intern(&Interner))\n-                .collect(),\n+                .map(|(id, _)| TyKind::Placeholder(to_placeholder_idx(db, id)).intern(&Interner)),\n         )\n     }\n \n@@ -403,12 +479,12 @@ impl Substitution {\n \n     /// Return Substs that replace each parameter by a bound variable.\n     pub(crate) fn bound_vars(generic_params: &Generics, debruijn: DebruijnIndex) -> Substitution {\n-        Substitution(\n+        Substitution::from_iter(\n+            &Interner,\n             generic_params\n                 .iter()\n                 .enumerate()\n-                .map(|(idx, _)| TyKind::BoundVar(BoundVar::new(debruijn, idx)).intern(&Interner))\n-                .collect(),\n+                .map(|(idx, _)| TyKind::BoundVar(BoundVar::new(debruijn, idx)).intern(&Interner)),\n         )\n     }\n \n@@ -435,18 +511,18 @@ pub fn param_idx(db: &dyn HirDatabase, id: TypeParamId) -> Option<usize> {\n \n #[derive(Debug, Clone)]\n pub struct SubstsBuilder {\n-    vec: Vec<Ty>,\n+    vec: Vec<GenericArg>,\n     param_count: usize,\n }\n \n impl SubstsBuilder {\n     pub fn build(self) -> Substitution {\n         assert_eq!(self.vec.len(), self.param_count);\n-        Substitution(self.vec.into())\n+        Substitution::from_iter(&Interner, self.vec)\n     }\n \n-    pub fn push(mut self, ty: Ty) -> Self {\n-        self.vec.push(ty);\n+    pub fn push(mut self, ty: impl CastTo<GenericArg>) -> Self {\n+        self.vec.push(ty.cast(&Interner));\n         self\n     }\n \n@@ -465,28 +541,20 @@ impl SubstsBuilder {\n         self.fill(iter::repeat(TyKind::Unknown.intern(&Interner)))\n     }\n \n-    pub fn fill(mut self, filler: impl Iterator<Item = Ty>) -> Self {\n-        self.vec.extend(filler.take(self.remaining()));\n+    pub fn fill(mut self, filler: impl Iterator<Item = impl CastTo<GenericArg>>) -> Self {\n+        self.vec.extend(filler.take(self.remaining()).casted(&Interner));\n         assert_eq!(self.remaining(), 0);\n         self\n     }\n \n     pub fn use_parent_substs(mut self, parent_substs: &Substitution) -> Self {\n         assert!(self.vec.is_empty());\n-        assert!(parent_substs.len() <= self.param_count);\n-        self.vec.extend(parent_substs.iter().cloned());\n+        assert!(parent_substs.len(&Interner) <= self.param_count);\n+        self.vec.extend(parent_substs.iter(&Interner).cloned());\n         self\n     }\n }\n \n-impl Deref for Substitution {\n-    type Target = [Ty];\n-\n-    fn deref(&self) -> &[Ty] {\n-        &self.0\n-    }\n-}\n-\n #[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n pub struct Binders<T> {\n     pub num_binders: usize,\n@@ -535,7 +603,7 @@ impl<T: Clone> Binders<&T> {\n impl<T: TypeWalk> Binders<T> {\n     /// Substitutes all variables.\n     pub fn subst(self, subst: &Substitution) -> T {\n-        assert_eq!(subst.len(), self.num_binders);\n+        assert_eq!(subst.len(&Interner), self.num_binders);\n         self.value.subst_bound_vars(subst)\n     }\n }\n@@ -563,7 +631,7 @@ pub struct TraitRef {\n \n impl TraitRef {\n     pub fn self_type_parameter(&self) -> &Ty {\n-        &self.substitution[0]\n+        &self.substitution.at(&Interner, 0).assert_ty_ref(&Interner)\n     }\n \n     pub fn hir_trait_id(&self) -> TraitId {\n@@ -699,14 +767,20 @@ impl CallableSig {\n                 .shift_bound_vars_out(DebruijnIndex::ONE)\n                 .interned(&Interner)\n                 .iter()\n-                .cloned()\n+                .map(|arg| arg.assert_ty_ref(&Interner).clone())\n                 .collect(),\n             is_varargs: fn_ptr.sig.variadic,\n         }\n     }\n \n     pub fn from_substs(substs: &Substitution) -> CallableSig {\n-        CallableSig { params_and_return: substs.iter().cloned().collect(), is_varargs: false }\n+        CallableSig {\n+            params_and_return: substs\n+                .iter(&Interner)\n+                .map(|arg| arg.assert_ty_ref(&Interner).clone())\n+                .collect(),\n+            is_varargs: false,\n+        }\n     }\n \n     pub fn params(&self) -> &[Ty] {\n@@ -738,7 +812,7 @@ impl TypeWalk for CallableSig {\n \n impl Ty {\n     pub fn unit() -> Self {\n-        TyKind::Tuple(0, Substitution::empty()).intern(&Interner)\n+        TyKind::Tuple(0, Substitution::empty(&Interner)).intern(&Interner)\n     }\n \n     pub fn adt_ty(adt: hir_def::AdtId, substs: Substitution) -> Ty {\n@@ -908,7 +982,7 @@ impl Ty {\n                 Some(sig.subst(&parameters))\n             }\n             TyKind::Closure(.., substs) => {\n-                let sig_param = &substs[0];\n+                let sig_param = substs.at(&Interner, 0).assert_ty_ref(&Interner);\n                 sig_param.callable_sig(db)\n             }\n             _ => None,\n@@ -960,7 +1034,7 @@ impl Ty {\n                                 0,\n                                 WhereClause::Implemented(TraitRef {\n                                     trait_id: to_chalk_trait_id(future_trait),\n-                                    substitution: Substitution::empty(),\n+                                    substitution: Substitution::empty(&Interner),\n                                 }),\n                             );\n                             Some(vec![impl_bound])\n@@ -1109,7 +1183,10 @@ pub trait TypeWalk {\n             &mut |ty, binders| {\n                 if let &mut TyKind::BoundVar(bound) = ty.interned_mut() {\n                     if bound.debruijn >= binders {\n-                        *ty = substs.0[bound.index].clone().shift_bound_vars(binders);\n+                        *ty = substs.0[bound.index]\n+                            .assert_ty_ref(&Interner)\n+                            .clone()\n+                            .shift_bound_vars(binders);\n                     }\n                 }\n             },\n@@ -1156,12 +1233,12 @@ impl TypeWalk for Ty {\n     fn walk(&self, f: &mut impl FnMut(&Ty)) {\n         match self.interned(&Interner) {\n             TyKind::Alias(AliasTy::Projection(p_ty)) => {\n-                for t in p_ty.substitution.iter() {\n+                for t in p_ty.substitution.iter(&Interner) {\n                     t.walk(f);\n                 }\n             }\n             TyKind::Alias(AliasTy::Opaque(o_ty)) => {\n-                for t in o_ty.substitution.iter() {\n+                for t in o_ty.substitution.iter(&Interner) {\n                     t.walk(f);\n                 }\n             }\n@@ -1175,7 +1252,7 @@ impl TypeWalk for Ty {\n             }\n             _ => {\n                 if let Some(substs) = self.substs() {\n-                    for t in substs.iter() {\n+                    for t in substs.iter(&Interner) {\n                         t.walk(f);\n                     }\n                 }"}, {"sha": "f595683e5f983387581f38cf74810a58e4427216", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=8289b96216b5d4ddd0b6cf9feccb7af574d022a8", "patch": "@@ -178,9 +178,10 @@ impl<'a> TyLoweringContext<'a> {\n             }\n             TypeRef::Placeholder => TyKind::Unknown.intern(&Interner),\n             TypeRef::Fn(params, is_varargs) => {\n-                let substs = Substitution(params.iter().map(|tr| self.lower_ty(tr)).collect());\n+                let substs =\n+                    Substitution::from_iter(&Interner, params.iter().map(|tr| self.lower_ty(tr)));\n                 TyKind::Function(FnPointer {\n-                    num_args: substs.len() - 1,\n+                    num_args: substs.len(&Interner) - 1,\n                     sig: FnSig { abi: (), safety: Safety::Safe, variadic: *is_varargs },\n                     substs,\n                 })\n@@ -625,7 +626,7 @@ impl<'a> TyLoweringContext<'a> {\n \n                 for default_ty in defaults.iter().skip(substs.len()) {\n                     // each default can depend on the previous parameters\n-                    let substs_so_far = Substitution(substs.clone().into());\n+                    let substs_so_far = Substitution::from_iter(&Interner, substs.clone());\n                     substs.push(default_ty.clone().subst(&substs_so_far));\n                 }\n             }\n@@ -638,7 +639,7 @@ impl<'a> TyLoweringContext<'a> {\n         }\n         assert_eq!(substs.len(), total_len);\n \n-        Substitution(substs.into())\n+        Substitution::from_iter(&Interner, substs)\n     }\n \n     fn lower_trait_ref_from_path(\n@@ -1062,7 +1063,7 @@ fn type_for_fn(db: &dyn HirDatabase, def: FunctionId) -> Binders<Ty> {\n     let generics = generics(db.upcast(), def.into());\n     let substs = Substitution::bound_vars(&generics, DebruijnIndex::INNERMOST);\n     Binders::new(\n-        substs.len(),\n+        substs.len(&Interner),\n         TyKind::FnDef(CallableDefId::FunctionId(def).to_chalk(db), substs).intern(&Interner),\n     )\n }\n@@ -1107,7 +1108,7 @@ fn type_for_struct_constructor(db: &dyn HirDatabase, def: StructId) -> Binders<T\n     let generics = generics(db.upcast(), def.into());\n     let substs = Substitution::bound_vars(&generics, DebruijnIndex::INNERMOST);\n     Binders::new(\n-        substs.len(),\n+        substs.len(&Interner),\n         TyKind::FnDef(CallableDefId::StructId(def).to_chalk(db), substs).intern(&Interner),\n     )\n }\n@@ -1134,15 +1135,15 @@ fn type_for_enum_variant_constructor(db: &dyn HirDatabase, def: EnumVariantId) -\n     let generics = generics(db.upcast(), def.parent.into());\n     let substs = Substitution::bound_vars(&generics, DebruijnIndex::INNERMOST);\n     Binders::new(\n-        substs.len(),\n+        substs.len(&Interner),\n         TyKind::FnDef(CallableDefId::EnumVariantId(def).to_chalk(db), substs).intern(&Interner),\n     )\n }\n \n fn type_for_adt(db: &dyn HirDatabase, adt: AdtId) -> Binders<Ty> {\n     let generics = generics(db.upcast(), adt.into());\n     let substs = Substitution::bound_vars(&generics, DebruijnIndex::INNERMOST);\n-    Binders::new(substs.len(), Ty::adt_ty(adt, substs))\n+    Binders::new(substs.len(&Interner), Ty::adt_ty(adt, substs))\n }\n \n fn type_for_type_alias(db: &dyn HirDatabase, t: TypeAliasId) -> Binders<Ty> {"}, {"sha": "054896475f3f0eb20d2a38d4452b0dcb8cb5a81f", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=8289b96216b5d4ddd0b6cf9feccb7af574d022a8", "patch": "@@ -720,7 +720,7 @@ pub(crate) fn inherent_impl_substs(\n             chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General),\n             UniverseIndex::ROOT,\n         ))\n-        .take(vars.len()),\n+        .take(vars.len(&Interner)),\n     );\n     let tys = Canonical {\n         binders: CanonicalVarKinds::from_iter(&Interner, kinds),\n@@ -732,7 +732,8 @@ pub(crate) fn inherent_impl_substs(\n     // Unknown. I think this can only really happen if self_ty contained\n     // Unknown, and in that case we want the result to contain Unknown in those\n     // places again.\n-    substs.map(|s| fallback_bound_vars(s.suffix(vars.len()), self_ty.binders.len(&Interner)))\n+    substs\n+        .map(|s| fallback_bound_vars(s.suffix(vars.len(&Interner)), self_ty.binders.len(&Interner)))\n }\n \n /// This replaces any 'free' Bound vars in `s` (i.e. those with indices past\n@@ -821,7 +822,7 @@ fn generic_implements_goal(\n             chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General),\n             UniverseIndex::ROOT,\n         ))\n-        .take(substs.len() - 1),\n+        .take(substs.len(&Interner) - 1),\n     );\n     let trait_ref = TraitRef { trait_id: to_chalk_trait_id(trait_), substitution: substs };\n     let obligation = trait_ref.cast(&Interner);"}, {"sha": "a15b6486e2b64db686b589043ce1fa8797110f5e", "filename": "crates/hir_ty/src/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits.rs?ref=8289b96216b5d4ddd0b6cf9feccb7af574d022a8", "patch": "@@ -138,7 +138,7 @@ pub(crate) fn trait_solve_query(\n         ..\n     })) = &goal.value.goal\n     {\n-        if let TyKind::BoundVar(_) = &projection_ty.substitution[0].interned(&Interner) {\n+        if let TyKind::BoundVar(_) = projection_ty.self_type_parameter().interned(&Interner) {\n             // Hack: don't ask Chalk to normalize with an unknown self type, it'll say that's impossible\n             return Some(Solution::Ambig(Guidance::Unknown));\n         }"}, {"sha": "cf7ed1e11f1377fbe1fa5fef2e9b52edaabc8b5f", "filename": "crates/hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=8289b96216b5d4ddd0b6cf9feccb7af574d022a8", "patch": "@@ -3,7 +3,7 @@ use std::sync::Arc;\n \n use log::debug;\n \n-use chalk_ir::{fold::shift::Shift, CanonicalVarKinds, GenericArg};\n+use chalk_ir::{fold::shift::Shift, CanonicalVarKinds};\n use chalk_solve::rust_ir::{self, OpaqueTyDatumBound, WellKnownTrait};\n \n use base_db::{salsa::InternKey, CrateId};\n@@ -80,7 +80,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n     fn impls_for_trait(\n         &self,\n         trait_id: TraitId,\n-        parameters: &[GenericArg<Interner>],\n+        parameters: &[chalk_ir::GenericArg<Interner>],\n         binders: &CanonicalVarKinds<Interner>,\n     ) -> Vec<ImplId> {\n         debug!(\"impls_for_trait {:?}\", trait_id);\n@@ -308,7 +308,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         _closure_id: chalk_ir::ClosureId<Interner>,\n         _substs: &chalk_ir::Substitution<Interner>,\n     ) -> chalk_ir::Substitution<Interner> {\n-        Substitution::empty().to_chalk(self.db)\n+        Substitution::empty(&Interner).to_chalk(self.db)\n     }\n \n     fn trait_name(&self, trait_id: chalk_ir::TraitId<Interner>) -> String {\n@@ -439,7 +439,7 @@ pub(crate) fn trait_datum_query(\n         lang_attr(db.upcast(), trait_).and_then(|name| well_known_trait_from_lang_attr(&name));\n     let trait_datum = TraitDatum {\n         id: trait_id,\n-        binders: make_binders(trait_datum_bound, bound_vars.len()),\n+        binders: make_binders(trait_datum_bound, bound_vars.len(&Interner)),\n         flags,\n         associated_ty_ids,\n         well_known,\n@@ -577,7 +577,7 @@ fn impl_def_datum(\n         .collect();\n     debug!(\"impl_datum: {:?}\", impl_datum_bound);\n     let impl_datum = ImplDatum {\n-        binders: make_binders(impl_datum_bound, bound_vars.len()),\n+        binders: make_binders(impl_datum_bound, bound_vars.len(&Interner)),\n         impl_type,\n         polarity,\n         associated_ty_value_ids,"}, {"sha": "452b357e83e1637698a16179123e6d9262257d91", "filename": "crates/hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8289b96216b5d4ddd0b6cf9feccb7af574d022a8/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=8289b96216b5d4ddd0b6cf9feccb7af574d022a8", "patch": "@@ -13,7 +13,7 @@ use crate::{\n     db::HirDatabase,\n     primitive::UintTy,\n     traits::{Canonical, DomainGoal},\n-    AliasTy, CallableDefId, FnPointer, InEnvironment, OpaqueTy, ProjectionTy,\n+    AliasTy, CallableDefId, FnPointer, GenericArg, InEnvironment, OpaqueTy, ProjectionTy,\n     QuantifiedWhereClause, Scalar, Substitution, TraitRef, Ty, TypeWalk, WhereClause,\n };\n \n@@ -137,7 +137,7 @@ impl ToChalk for Ty {\n                     db,\n                     substitution.0.shifted_out(&Interner).expect(\"fn ptr should have no binders\"),\n                 );\n-                TyKind::Function(FnPointer { num_args: (substs.len() - 1), sig, substs })\n+                TyKind::Function(FnPointer { num_args: (substs.len(&Interner) - 1), sig, substs })\n             }\n             chalk_ir::TyKind::BoundVar(idx) => TyKind::BoundVar(idx),\n             chalk_ir::TyKind::InferenceVar(_iv, _kind) => TyKind::Unknown,\n@@ -216,24 +216,39 @@ fn array_to_chalk(db: &dyn HirDatabase, ty: Ty) -> chalk_ir::Ty<Interner> {\n     chalk_ir::TyKind::Array(arg, const_).intern(&Interner)\n }\n \n+impl ToChalk for GenericArg {\n+    type Chalk = chalk_ir::GenericArg<Interner>;\n+\n+    fn to_chalk(self, db: &dyn HirDatabase) -> Self::Chalk {\n+        match self.interned {\n+            crate::GenericArgData::Ty(ty) => ty.to_chalk(db).cast(&Interner),\n+        }\n+    }\n+\n+    fn from_chalk(db: &dyn HirDatabase, chalk: Self::Chalk) -> Self {\n+        match chalk.interned() {\n+            chalk_ir::GenericArgData::Ty(ty) => Ty::from_chalk(db, ty.clone()).cast(&Interner),\n+            chalk_ir::GenericArgData::Lifetime(_) => unimplemented!(),\n+            chalk_ir::GenericArgData::Const(_) => unimplemented!(),\n+        }\n+    }\n+}\n+\n impl ToChalk for Substitution {\n     type Chalk = chalk_ir::Substitution<Interner>;\n \n     fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Substitution<Interner> {\n-        chalk_ir::Substitution::from_iter(&Interner, self.iter().map(|ty| ty.clone().to_chalk(db)))\n+        chalk_ir::Substitution::from_iter(\n+            &Interner,\n+            self.iter(&Interner).map(|ty| ty.clone().to_chalk(db)),\n+        )\n     }\n \n     fn from_chalk(\n         db: &dyn HirDatabase,\n         parameters: chalk_ir::Substitution<Interner>,\n     ) -> Substitution {\n-        let tys = parameters\n-            .iter(&Interner)\n-            .map(|p| match p.ty(&Interner) {\n-                Some(ty) => from_chalk(db, ty.clone()),\n-                None => unimplemented!(),\n-            })\n-            .collect();\n+        let tys = parameters.iter(&Interner).map(|p| from_chalk(db, p.clone())).collect();\n         Substitution(tys)\n     }\n }\n@@ -531,7 +546,7 @@ pub(super) fn generic_predicate_to_inline_bound(\n                 // have the expected self type\n                 return None;\n             }\n-            let args_no_self = trait_ref.substitution[1..]\n+            let args_no_self = trait_ref.substitution.interned(&Interner)[1..]\n                 .iter()\n                 .map(|ty| ty.clone().to_chalk(db).cast(&Interner))\n                 .collect();\n@@ -543,7 +558,7 @@ pub(super) fn generic_predicate_to_inline_bound(\n                 return None;\n             }\n             let trait_ = projection_ty.trait_(db);\n-            let args_no_self = projection_ty.substitution[1..]\n+            let args_no_self = projection_ty.substitution.interned(&Interner)[1..]\n                 .iter()\n                 .map(|ty| ty.clone().to_chalk(db).cast(&Interner))\n                 .collect();"}]}