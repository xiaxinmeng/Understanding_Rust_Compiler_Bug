{"sha": "3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2NTdhZTEzZjVmN2VmNDM2N2E2ZGU0YjYxYmQ0MTQzZmM2YjUyYjQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-28T15:07:21Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-30T14:36:22Z"}, "message": "Don't normalize associated types when in region binders, wait until we instantiate\nthem. Also fix some assertions and handling of builtin bounds.", "tree": {"sha": "7728f76208f5b4e07ebf41ea0927c4c71e7b5567", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7728f76208f5b4e07ebf41ea0927c4c71e7b5567"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4", "html_url": "https://github.com/rust-lang/rust/commit/3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bbd2f9ceafb86614b431cff4184f6e8ce7c973f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bbd2f9ceafb86614b431cff4184f6e8ce7c973f", "html_url": "https://github.com/rust-lang/rust/commit/2bbd2f9ceafb86614b431cff4184f6e8ce7c973f"}], "stats": {"total": 299, "additions": 214, "deletions": 85}, "files": [{"sha": "e72d5b405c4e4dae1117e1773ec4990955071d6c", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4", "patch": "@@ -109,6 +109,10 @@ impl<'tcx> FulfillmentContext<'tcx> {\n                                          cause: ObligationCause<'tcx>)\n                                          -> Ty<'tcx>\n     {\n+        debug!(\"normalize_associated_type(trait_ref={}, item_name={})\",\n+               trait_ref.repr(infcx.tcx),\n+               item_name.repr(infcx.tcx));\n+\n         assert!(!trait_ref.has_escaping_regions());\n \n         let ty_var = infcx.next_ty_var();\n@@ -120,6 +124,9 @@ impl<'tcx> FulfillmentContext<'tcx> {\n             });\n         let obligation = Obligation::new(cause, projection.as_predicate());\n         self.register_predicate(infcx, obligation);\n+\n+        debug!(\"normalize_associated_type: result={}\", ty_var.repr(infcx.tcx));\n+\n         ty_var\n     }\n "}, {"sha": "9301531e84d5e1b2e22bbede4b3806c0a01d3057", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4", "patch": "@@ -1141,7 +1141,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                      obligation: &TraitObligation<'tcx>)\n                      -> Result<BuiltinBoundConditions<'tcx>,SelectionError<'tcx>>\n     {\n-        // TODO seems like we ought to skolemize here, oder?\n+        // Note: these tests operate on types that may contain bound\n+        // regions. To be proper, we ought to skolemize here, but we\n+        // forego the skolemization and defer it until the\n+        // confirmation step.\n+\n         let self_ty = self.infcx.shallow_resolve(obligation.predicate.0.self_ty());\n         return match self_ty.sty {\n             ty::ty_infer(ty::IntVar(_)) |\n@@ -1627,13 +1631,31 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                            -> VtableBuiltinData<PredicateObligation<'tcx>>\n     {\n         let derived_cause = self.derived_cause(obligation, BuiltinDerivedObligation);\n-        let obligations = nested.iter().map(|&t| {\n-            util::predicate_for_builtin_bound(\n-                self.tcx(),\n-                derived_cause.clone(),\n-                bound,\n-                obligation.recursion_depth + 1,\n-                t)\n+        let obligations = nested.iter().map(|&bound_ty| {\n+            // the obligation might be higher-ranked, e.g. for<'a> &'a\n+            // int : Copy. In that case, we will wind up with\n+            // late-bound regions in the `nested` vector. So for each\n+            // one we instantiate to a skolemized region, do our work\n+            // to produce something like `&'0 int : Copy`, and then\n+            // re-bind it. This is a bit of busy-work but preserves\n+            // the invariant that we only manipulate free regions, not\n+            // bound ones.\n+            self.infcx.try(|snapshot| {\n+                let (skol_ty, skol_map) =\n+                    self.infcx().skolemize_late_bound_regions(&ty::Binder(bound_ty), snapshot);\n+                let skol_predicate =\n+                    util::predicate_for_builtin_bound(\n+                        self.tcx(),\n+                        derived_cause.clone(),\n+                        bound,\n+                        obligation.recursion_depth + 1,\n+                        skol_ty);\n+                match skol_predicate {\n+                    Ok(skol_predicate) => Ok(self.infcx().plug_leaks(skol_map, snapshot,\n+                                                                     &skol_predicate)),\n+                    Err(ErrorReported) => Err(ErrorReported)\n+                }\n+            })\n         }).collect::<Result<_, _>>();\n         let mut obligations = match obligations {\n             Ok(o) => o,"}, {"sha": "583d2ce3b67c238d30477587087525125d5f7bab", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4", "patch": "@@ -6903,8 +6903,19 @@ impl RegionEscape for Region {\n \n impl<'tcx> RegionEscape for TraitRef<'tcx> {\n     fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        self.substs.types.iter().any(|t| t.has_regions_escaping_depth(depth)) &&\n-            self.substs.regions().iter().any(|t| t.has_regions_escaping_depth(depth))\n+        self.substs.types.iter().any(|t| t.has_regions_escaping_depth(depth)) ||\n+            self.substs.regions.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for subst::RegionSubsts {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        match *self {\n+            subst::ErasedRegions => false,\n+            subst::NonerasedRegions(ref r) => {\n+                r.iter().any(|t| t.has_regions_escaping_depth(depth))\n+            }\n+        }\n     }\n }\n \n@@ -6921,7 +6932,7 @@ impl<'tcx> RegionEscape for EquatePredicate<'tcx> {\n }\n \n impl<'tcx> RegionEscape for TraitPredicate<'tcx> {\n-    fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n         self.trait_ref.has_regions_escaping_depth(depth)\n     }\n }\n@@ -6933,14 +6944,14 @@ impl<T:RegionEscape,U:RegionEscape> RegionEscape for OutlivesPredicate<T,U> {\n }\n \n impl<'tcx> RegionEscape for ProjectionPredicate<'tcx> {\n-    fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n         self.projection_ty.has_regions_escaping_depth(depth) ||\n             self.ty.has_regions_escaping_depth(depth)\n     }\n }\n \n impl<'tcx> RegionEscape for ProjectionTy<'tcx> {\n-    fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n         self.trait_ref.has_regions_escaping_depth(depth)\n     }\n }"}, {"sha": "b59f9291e4fc66dc8f2095aea8057f2fbad0b6a9", "filename": "src/librustc_typeck/check/assoc.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4", "patch": "@@ -33,7 +33,8 @@ pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n     let mut normalizer = AssociatedTypeNormalizer { span: span,\n                                                     body_id: body_id,\n                                                     infcx: infcx,\n-                                                    fulfillment_cx: fulfillment_cx };\n+                                                    fulfillment_cx: fulfillment_cx,\n+                                                    region_binders: 0 };\n     value.fold_with(&mut normalizer)\n }\n \n@@ -42,16 +43,37 @@ struct AssociatedTypeNormalizer<'a,'tcx:'a> {\n     fulfillment_cx: &'a mut FulfillmentContext<'tcx>,\n     span: Span,\n     body_id: ast::NodeId,\n+    region_binders: uint,\n }\n \n impl<'a,'tcx> TypeFolder<'tcx> for AssociatedTypeNormalizer<'a,'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> {\n         self.infcx.tcx\n     }\n \n+    fn enter_region_binder(&mut self) {\n+        self.region_binders += 1;\n+    }\n+\n+    fn exit_region_binder(&mut self) {\n+        self.region_binders -= 1;\n+    }\n+\n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        // We don't want to normalize associated types that occur inside of region\n+        // binders, because they may contain bound regions, and we can't cope with that.\n+        //\n+        // Example:\n+        //\n+        //     for<'a> fn(<T as Foo<&'a>>::A)\n+        //\n+        // Instead of normalizing `<T as Foo<&'a>>::A` here, we'll\n+        // normalize it when we instantiate those bound regions (which\n+        // should occur eventually).\n+        let no_region_binders = self.region_binders == 0;\n+\n         match ty.sty {\n-            ty::ty_projection(ref data) => {\n+            ty::ty_projection(ref data) if no_region_binders => {\n                 let cause =\n                     ObligationCause::new(\n                         self.span,"}, {"sha": "340cc9b355c0252043b9c8bfb859c0e8c2d92ad6", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4", "patch": "@@ -14,6 +14,7 @@ use super::{check_fn, Expectation, FnCtxt};\n \n use astconv;\n use middle::infer;\n+use middle::region::CodeExtent;\n use middle::subst;\n use middle::ty::{mod, ToPolyTraitRef, Ty};\n use rscope::RegionScope;\n@@ -132,10 +133,13 @@ fn check_unboxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n \n     fcx.write_ty(expr.id, closure_type);\n \n+    let fn_sig =\n+        ty::liberate_late_bound_regions(fcx.tcx(), CodeExtent::from_node_id(body.id), &fn_ty.sig);\n+\n     check_fn(fcx.ccx,\n              ast::Unsafety::Normal,\n              expr.id,\n-             &fn_ty.sig,\n+             &fn_sig,\n              decl,\n              expr.id,\n              &*body,\n@@ -310,7 +314,7 @@ fn check_boxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                                        decl,\n                                        abi::Rust,\n                                        expected_sig);\n-    let fty_sig = fn_ty.sig.clone();\n+    let fn_sig = fn_ty.sig.clone();\n     let fty = ty::mk_closure(tcx, fn_ty);\n     debug!(\"check_expr_fn fty={}\", fcx.infcx().ty_to_string(fty));\n \n@@ -325,10 +329,13 @@ fn check_boxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n         ty::UniqTraitStore => (ast::Unsafety::Normal, expr.id)\n     };\n \n+    let fn_sig =\n+        ty::liberate_late_bound_regions(tcx, CodeExtent::from_node_id(body.id), &fn_sig);\n+\n     check_fn(fcx.ccx,\n              inherited_style,\n              inherited_style_id,\n-             &fty_sig,\n+             &fn_sig,\n              &*decl,\n              expr.id,\n              &*body,"}, {"sha": "1aa9adaf9ec4d4422fe3ae65601375fbdf602a50", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4", "patch": "@@ -424,17 +424,18 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         debug!(\"method_bounds after subst = {}\",\n                method_bounds.repr(self.tcx()));\n \n-        // Substitute the type/early-bound-regions into the method\n-        // signature. In addition, the method signature may bind\n-        // late-bound regions, so instantiate those.\n-        let method_sig = self.fcx.instantiate_type_scheme(self.span,\n-                                                          &all_substs,\n-                                                          &pick.method_ty.fty.sig);\n-        debug!(\"late-bound lifetimes from method substituted, method_sig={}\",\n+        // Instantiate late-bound regions and substitute the trait\n+        // parameters into the method type to get the actual method type.\n+        //\n+        // NB: Instantiate late-bound regions first so that\n+        // `instantiate_type_scheme` can normalize associated types that\n+        // may reference those regions.\n+        let method_sig = self.replace_late_bound_regions_with_fresh_var(&pick.method_ty.fty.sig);\n+        debug!(\"late-bound lifetimes from method instantiated, method_sig={}\",\n                method_sig.repr(self.tcx()));\n \n-        let method_sig = self.replace_late_bound_regions_with_fresh_var(&method_sig);\n-        debug!(\"late-bound lifetimes from method instantiated, method_sig={}\",\n+        let method_sig = self.fcx.instantiate_type_scheme(self.span, &all_substs, &method_sig);\n+        debug!(\"type scheme substituted, method_sig={}\",\n                method_sig.repr(self.tcx()));\n \n         InstantiatedMethodSig {"}, {"sha": "5b6acdbf3ada5fff99b347b0ea71aa77bd852b5e", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4", "patch": "@@ -190,19 +190,21 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n     debug!(\"lookup_in_trait_adjusted: method_num={} method_ty={}\",\n            method_num, method_ty.repr(fcx.tcx()));\n \n-    // Substitute the trait parameters into the method type and\n-    // instantiate late-bound regions to get the actual method type.\n-    let bare_fn_ty = fcx.instantiate_type_scheme(span,\n-                                                 &trait_ref.substs,\n-                                                 &method_ty.fty);\n+    // Instantiate late-bound regions and substitute the trait\n+    // parameters into the method type to get the actual method type.\n+    //\n+    // NB: Instantiate late-bound regions first so that\n+    // `instantiate_type_scheme` can normalize associated types that\n+    // may reference those regions.\n     let fn_sig = fcx.infcx().replace_late_bound_regions_with_fresh_var(span,\n                                                                        infer::FnCall,\n-                                                                       &bare_fn_ty.sig).0;\n+                                                                       &method_ty.fty.sig).0;\n+    let fn_sig = fcx.instantiate_type_scheme(span, &trait_ref.substs, &fn_sig);\n     let transformed_self_ty = fn_sig.inputs[0];\n     let fty = ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(ty::BareFnTy {\n         sig: ty::Binder(fn_sig),\n-        unsafety: bare_fn_ty.unsafety,\n-        abi: bare_fn_ty.abi.clone(),\n+        unsafety: method_ty.fty.unsafety,\n+        abi: method_ty.fty.abi.clone(),\n     }));\n \n     debug!(\"lookup_in_trait_adjusted: matched method fty={} obligation={}\","}, {"sha": "e485e49148fe4831a0ed9416a582e1eab9dc4875", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 87, "deletions": 42, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4", "patch": "@@ -432,13 +432,15 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         ty::ty_bare_fn(_, ref fn_ty) => {\n             let inh = Inherited::new(ccx.tcx, param_env);\n \n-            // Compute the fty from point of view of inside fn\n-            // (replace any type-scheme with a type, and normalize\n-            // associated types appearing in the fn signature).\n-            let fn_ty = fn_ty.subst(ccx.tcx, &inh.param_env.free_substs);\n-            let fn_ty = inh.normalize_associated_types_in(body.span, body.id, &fn_ty);\n-\n-            let fcx = check_fn(ccx, fn_ty.unsafety, id, &fn_ty.sig,\n+            // Compute the fty from point of view of inside fn.\n+            let fn_sig =\n+                fn_ty.sig.subst(ccx.tcx, &inh.param_env.free_substs);\n+            let fn_sig =\n+                liberate_late_bound_regions(ccx.tcx, CodeExtent::from_node_id(body.id), &fn_sig);\n+            let fn_sig =\n+                inh.normalize_associated_types_in(body.span, body.id, &fn_sig);\n+\n+            let fcx = check_fn(ccx, fn_ty.unsafety, id, &fn_sig,\n                                decl, id, body, &inh);\n \n             vtable::select_all_fcx_obligations_or_error(&fcx);\n@@ -542,7 +544,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for GatherLocalsVisitor<'a, 'tcx> {\n fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n                       unsafety: ast::Unsafety,\n                       unsafety_id: ast::NodeId,\n-                      fn_sig: &ty::PolyFnSig<'tcx>,\n+                      fn_sig: &ty::FnSig<'tcx>,\n                       decl: &ast::FnDecl,\n                       fn_id: ast::NodeId,\n                       body: &ast::Block,\n@@ -552,10 +554,6 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n     let tcx = ccx.tcx;\n     let err_count_on_creation = tcx.sess.err_count();\n \n-    // First, we have to replace any bound regions in the fn type with free ones.\n-    // The free region references will be bound the node_id of the body block.\n-    let fn_sig = liberate_late_bound_regions(tcx, CodeExtent::from_node_id(body.id), fn_sig);\n-\n     let arg_tys = fn_sig.inputs[];\n     let ret_ty = fn_sig.output;\n \n@@ -1161,39 +1159,80 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         }\n     }\n \n+    // We now need to check that the signature of the impl method is\n+    // compatible with that of the trait method. We do this by\n+    // checking that `impl_fty <: trait_fty`.\n+    //\n+    // FIXME. Unfortunately, this doesn't quite work right now because\n+    // associated type normalization is not integrated into subtype\n+    // checks. For the comparison to be valid, we need to\n+    // normalize the associated types in the impl/trait methods\n+    // first. However, because function types bind regions, just\n+    // calling `normalize_associated_types_in` would have no effect on\n+    // any associated types appearing in the fn arguments or return\n+    // type.\n+\n+\n     // Compute skolemized form of impl and trait method tys.\n     let impl_fty = ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(impl_m.fty.clone()));\n     let impl_fty = impl_fty.subst(tcx, impl_to_skol_substs);\n     let trait_fty = ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(trait_m.fty.clone()));\n     let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n-    let trait_fty =\n-        assoc::normalize_associated_types_in(&infcx,\n-                                             &mut fulfillment_cx,\n-                                             impl_m_span,\n-                                             impl_m_body_id,\n-                                             &trait_fty);\n-\n-    // Check the impl method type IM is a subtype of the trait method\n-    // type TM. To see why this makes sense, think of a vtable. The\n-    // expected type of the function pointers in the vtable is the\n-    // type TM of the trait method.  The actual type will be the type\n-    // IM of the impl method. Because we know that IM <: TM, that\n-    // means that anywhere a TM is expected, a IM will do instead. In\n-    // other words, anyone expecting to call a method with the type\n-    // from the trait, can safely call a method with the type from the\n-    // impl instead.\n-    debug!(\"checking trait method for compatibility: impl ty {}, trait ty {}\",\n-           impl_fty.repr(tcx),\n-           trait_fty.repr(tcx));\n-    match infer::mk_subty(&infcx, false, infer::MethodCompatCheck(impl_m_span),\n-                          impl_fty, trait_fty) {\n-        Ok(()) => {}\n-        Err(ref terr) => {\n+\n+    let err = infcx.try(|snapshot| {\n+        let origin = infer::MethodCompatCheck(impl_m_span);\n+\n+        let (impl_sig, _) =\n+            infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n+                                                            infer::HigherRankedType,\n+                                                            &impl_m.fty.sig);\n+        let impl_sig =\n+            impl_sig.subst(tcx, impl_to_skol_substs);\n+        let impl_sig =\n+            assoc::normalize_associated_types_in(&infcx,\n+                                                 &mut fulfillment_cx,\n+                                                 impl_m_span,\n+                                                 impl_m_body_id,\n+                                                 &impl_sig);\n+        let impl_fty = ty::mk_bare_fn(tcx, None, ty::BareFnTy { unsafety: impl_m.fty.unsafety,\n+                                                                abi: impl_m.fty.abi,\n+                                                                sig: ty::Binder(impl_sig) });\n+        debug!(\"compare_impl_method: impl_fty={}\",\n+               impl_fty.repr(tcx));\n+\n+        let (trait_sig, skol_map) =\n+            infcx.skolemize_late_bound_regions(&trait_m.fty.sig, snapshot);\n+        let trait_sig =\n+            trait_sig.subst(tcx, &trait_to_skol_substs);\n+        let trait_sig =\n+            assoc::normalize_associated_types_in(&infcx,\n+                                                 &mut fulfillment_cx,\n+                                                 impl_m_span,\n+                                                 impl_m_body_id,\n+                                                 &trait_sig);\n+        let trait_fty = ty::mk_bare_fn(tcx, None, ty::BareFnTy { unsafety: trait_m.fty.unsafety,\n+                                                                 abi: trait_m.fty.abi,\n+                                                                 sig: ty::Binder(trait_sig) });\n+\n+        debug!(\"compare_impl_method: trait_fty={}\",\n+               trait_fty.repr(tcx));\n+\n+        try!(infer::mk_subty(&infcx, false, origin, impl_fty, trait_fty));\n+\n+        infcx.leak_check(&skol_map, snapshot)\n+    });\n+\n+    match err {\n+        Ok(()) => { }\n+        Err(terr) => {\n+            debug!(\"checking trait method for compatibility: impl ty {}, trait ty {}\",\n+                   impl_fty.repr(tcx),\n+                   trait_fty.repr(tcx));\n             span_err!(tcx.sess, impl_m_span, E0053,\n-                \"method `{}` has an incompatible type for trait: {}\",\n-                token::get_name(trait_m.name),\n-                ty::type_err_to_str(tcx, terr));\n-            ty::note_and_explain_type_err(tcx, terr);\n+                      \"method `{}` has an incompatible type for trait: {}\",\n+                      token::get_name(trait_m.name),\n+                      ty::type_err_to_str(tcx, &terr));\n+            return;\n         }\n     }\n \n@@ -1791,7 +1830,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Also returns the substitution from the type parameters on `def_id` to the fresh variables.\n     /// Registers any trait obligations specified on `def_id` at the same time.\n     ///\n-    /// Note that function is only intended to be used with types (notably, not impls). This is\n+    /// Note that function is only intended to be used with types (notably, not fns). This is\n     /// because it doesn't do any instantiation of late-bound regions.\n     pub fn instantiate_type(&self,\n                             span: Span,\n@@ -3061,12 +3100,18 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n         };\n \n-        // Replace any bound regions that appear in the function\n-        // signature with region variables\n+        // Replace any late-bound regions that appear in the function\n+        // signature with region variables. We also have to\n+        // renormalize the associated types at this point, since they\n+        // previously appeared within a `Binder<>` and hence would not\n+        // have been normalized before.\n         let fn_sig =\n             fcx.infcx().replace_late_bound_regions_with_fresh_var(call_expr.span,\n                                                                   infer::FnCall,\n                                                                   fn_sig).0;\n+        let fn_sig =\n+            fcx.normalize_associated_types_in(call_expr.span,\n+                                              &fn_sig);\n \n         // Call the generic checker.\n         check_argument_types(fcx,"}, {"sha": "c0b281450a2c0bb2956c95ff918fbb1ab09b410e", "filename": "src/librustc_typeck/check/regionmanip.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs?ref=3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4", "patch": "@@ -104,7 +104,8 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n \n             ty::ty_enum(def_id, substs) |\n             ty::ty_struct(def_id, substs) => {\n-                self.accumulate_from_adt(ty, def_id, substs)\n+                let item_scheme = ty::lookup_item_type(self.tcx, def_id);\n+                self.accumulate_from_adt(ty, def_id, &item_scheme.generics, substs)\n             }\n \n             ty::ty_vec(t, _) |\n@@ -127,7 +128,9 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n                 // TODO What region constraints are necessary here, if any??\n \n                 // this seems like a minimal requirement:\n-                self.accumulate_from_ty(data.trait_ref.self_ty());\n+                let trait_def = ty::lookup_trait_def(self.tcx, data.trait_ref.def_id);\n+                self.accumulate_from_adt(ty, data.trait_ref.def_id,\n+                                         &trait_def.generics, &data.trait_ref.substs)\n             }\n \n             ty::ty_tup(ref tuptys) => {\n@@ -222,14 +225,12 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n     fn accumulate_from_adt(&mut self,\n                            ty: Ty<'tcx>,\n                            def_id: ast::DefId,\n+                           generics: &ty::Generics<'tcx>,\n                            substs: &Substs<'tcx>)\n     {\n         // The generic declarations from the type, appropriately\n         // substituted for the actual substitutions.\n-        let generics =\n-            ty::lookup_item_type(self.tcx, def_id)\n-            .generics\n-            .subst(self.tcx, substs);\n+        let generics = generics.subst(self.tcx, substs);\n \n         // Variance of each type/region parameter.\n         let variances = ty::item_variances(self.tcx, def_id);"}, {"sha": "2a3f528809cfd883776e85f39b997dfe95a5ce3f", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4", "patch": "@@ -349,8 +349,7 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n                     //\n                     // (I believe we should do the same for traits, but\n                     // that will require an RFC. -nmatsakis)\n-                    let bounds = type_scheme\n-.generics.to_bounds(self.tcx(), substs);\n+                    let bounds = type_scheme.generics.to_bounds(self.tcx(), substs);\n                     let bounds = filter_to_trait_obligations(bounds);\n                     self.fcx.add_obligations_for_parameters(\n                         traits::ObligationCause::new(self.span,"}, {"sha": "40ca6354ca6d14d114378799746d40b2de55527c", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=3657ae13f5f7ef4367a6de4b61bd4143fc6b52b4", "patch": "@@ -133,6 +133,9 @@ pub trait Visitor<'v> {\n     fn visit_path_parameters(&mut self, path_span: Span, path_parameters: &'v PathParameters) {\n         walk_path_parameters(self, path_span, path_parameters)\n     }\n+    fn visit_assoc_type_binding(&mut self, type_binding: &'v TypeBinding) {\n+        walk_assoc_type_binding(self, type_binding)\n+    }\n     fn visit_attribute(&mut self, _attr: &'v Attribute) {}\n }\n \n@@ -467,6 +470,9 @@ pub fn walk_path_parameters<'v, V: Visitor<'v>>(visitor: &mut V,\n             for lifetime in data.lifetimes.iter() {\n                 visitor.visit_lifetime_ref(lifetime);\n             }\n+            for binding in data.bindings.iter() {\n+                visitor.visit_assoc_type_binding(&**binding);\n+            }\n         }\n         ast::ParenthesizedParameters(ref data) => {\n             for typ in data.inputs.iter() {\n@@ -479,6 +485,12 @@ pub fn walk_path_parameters<'v, V: Visitor<'v>>(visitor: &mut V,\n     }\n }\n \n+pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                                   type_binding: &'v TypeBinding) {\n+    visitor.visit_ident(type_binding.span, type_binding.ident);\n+    visitor.visit_ty(&*type_binding.ty);\n+}\n+\n pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n     match pattern.node {\n         PatEnum(ref path, ref children) => {"}]}