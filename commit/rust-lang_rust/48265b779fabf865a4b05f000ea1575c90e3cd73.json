{"sha": "48265b779fabf865a4b05f000ea1575c90e3cd73", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4MjY1Yjc3OWZhYmY4NjVhNGIwNWYwMDBlYTE1NzVjOTBlM2NkNzM=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-08-15T02:19:29Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-08-15T08:32:10Z"}, "message": "Check for interior nulls in .to_c_str()\n\nPrevious dicussions about CString suggested that interior nulls should\nthrow an error. This was never implemented. Add this now, using a\ncondition (named null_byte) to allow for recovery.\n\nAdd method .to_c_str_unchecked() that skips this check.", "tree": {"sha": "70e4fc83ed145142c5f7b53440e2ff7f9181ad29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70e4fc83ed145142c5f7b53440e2ff7f9181ad29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48265b779fabf865a4b05f000ea1575c90e3cd73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48265b779fabf865a4b05f000ea1575c90e3cd73", "html_url": "https://github.com/rust-lang/rust/commit/48265b779fabf865a4b05f000ea1575c90e3cd73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48265b779fabf865a4b05f000ea1575c90e3cd73/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e4f13f95fc629bcee2ad9a766d9af7c7b2e18f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e4f13f95fc629bcee2ad9a766d9af7c7b2e18f7", "html_url": "https://github.com/rust-lang/rust/commit/1e4f13f95fc629bcee2ad9a766d9af7c7b2e18f7"}], "stats": {"total": 119, "additions": 107, "deletions": 12}, "files": [{"sha": "5c77aa4a65aa32f364163f329bd0c3b5a3639c82", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 99, "deletions": 12, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/48265b779fabf865a4b05f000ea1575c90e3cd73/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48265b779fabf865a4b05f000ea1575c90e3cd73/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=48265b779fabf865a4b05f000ea1575c90e3cd73", "patch": "@@ -9,14 +9,28 @@\n // except according to those terms.\n \n use cast;\n-use iterator::Iterator;\n+use iterator::{Iterator,range};\n use libc;\n use ops::Drop;\n use option::{Option, Some, None};\n use ptr::RawPtr;\n use ptr;\n use str::StrSlice;\n-use vec::ImmutableVector;\n+use vec::{ImmutableVector,CopyableVector};\n+use container::Container;\n+\n+/// Resolution options for the `null_byte` condition\n+pub enum NullByteResolution {\n+    /// Truncate at the null byte\n+    Truncate,\n+    /// Use a replacement byte\n+    ReplaceWith(libc::c_char)\n+}\n+\n+condition! {\n+    // this should be &[u8] but there's a lifetime issue\n+    null_byte: (~[u8]) -> super::NullByteResolution;\n+}\n \n /// The representation of a C String.\n ///\n@@ -110,31 +124,59 @@ impl Drop for CString {\n \n /// A generic trait for converting a value to a CString.\n pub trait ToCStr {\n-    /// Create a C String.\n+    /// Copy the receiver into a CString.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the receiver has an interior null.\n     fn to_c_str(&self) -> CString;\n+\n+    /// Unsafe variant of `to_c_str()` that doesn't check for nulls.\n+    unsafe fn to_c_str_unchecked(&self) -> CString;\n }\n \n impl<'self> ToCStr for &'self str {\n     #[inline]\n     fn to_c_str(&self) -> CString {\n         self.as_bytes().to_c_str()\n     }\n+\n+    #[inline]\n+    unsafe fn to_c_str_unchecked(&self) -> CString {\n+        self.as_bytes().to_c_str_unchecked()\n+    }\n }\n \n impl<'self> ToCStr for &'self [u8] {\n     fn to_c_str(&self) -> CString {\n-        do self.as_imm_buf |self_buf, self_len| {\n-            unsafe {\n-                let buf = libc::malloc(self_len as libc::size_t + 1) as *mut u8;\n-                if buf.is_null() {\n-                    fail!(\"failed to allocate memory!\");\n+        let mut cs = unsafe { self.to_c_str_unchecked() };\n+        do cs.with_mut_ref |buf| {\n+            for i in range(0, self.len()) {\n+                unsafe {\n+                    let p = buf.offset_inbounds(i as int);\n+                    if *p == 0 {\n+                        match null_byte::cond.raise(self.to_owned()) {\n+                            Truncate => break,\n+                            ReplaceWith(c) => *p = c\n+                        }\n+                    }\n                 }\n+            }\n+        }\n+        cs\n+    }\n \n-                ptr::copy_memory(buf, self_buf, self_len);\n-                *ptr::mut_offset(buf, self_len as int) = 0;\n-\n-                CString::new(buf as *libc::c_char, true)\n+    unsafe fn to_c_str_unchecked(&self) -> CString {\n+        do self.as_imm_buf |self_buf, self_len| {\n+            let buf = libc::malloc(self_len as libc::size_t + 1) as *mut u8;\n+            if buf.is_null() {\n+                fail!(\"failed to allocate memory!\");\n             }\n+\n+            ptr::copy_memory(buf, self_buf, self_len);\n+            *ptr::mut_offset(buf, self_len as int) = 0;\n+\n+            CString::new(buf as *libc::c_char, true)\n         }\n     }\n }\n@@ -231,4 +273,49 @@ mod tests {\n         assert_eq!(iter.next(), Some('o' as libc::c_char));\n         assert_eq!(iter.next(), None);\n     }\n+\n+    #[test]\n+    #[ignore(cfg(windows))]\n+    fn test_to_c_str_fail() {\n+        use c_str::null_byte::cond;\n+\n+        let mut error_happened = false;\n+        do cond.trap(|err| {\n+            assert_eq!(err, bytes!(\"he\", 0, \"llo\").to_owned())\n+            error_happened = true;\n+            Truncate\n+        }).inside {\n+            \"he\\x00llo\".to_c_str()\n+        };\n+        assert!(error_happened);\n+\n+        do cond.trap(|_| {\n+            ReplaceWith('?' as libc::c_char)\n+        }).inside(|| \"he\\x00llo\".to_c_str()).with_ref |buf| {\n+            unsafe {\n+                assert_eq!(*buf.offset(0), 'h' as libc::c_char);\n+                assert_eq!(*buf.offset(1), 'e' as libc::c_char);\n+                assert_eq!(*buf.offset(2), '?' as libc::c_char);\n+                assert_eq!(*buf.offset(3), 'l' as libc::c_char);\n+                assert_eq!(*buf.offset(4), 'l' as libc::c_char);\n+                assert_eq!(*buf.offset(5), 'o' as libc::c_char);\n+                assert_eq!(*buf.offset(6), 0);\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_to_c_str_unchecked() {\n+        unsafe {\n+            do \"he\\x00llo\".to_c_str_unchecked().with_ref |buf| {\n+                assert_eq!(*buf.offset(0), 'h' as libc::c_char);\n+                assert_eq!(*buf.offset(1), 'e' as libc::c_char);\n+                assert_eq!(*buf.offset(2), 0);\n+                assert_eq!(*buf.offset(3), 'l' as libc::c_char);\n+                assert_eq!(*buf.offset(4), 'l' as libc::c_char);\n+                assert_eq!(*buf.offset(5), 'o' as libc::c_char);\n+                assert_eq!(*buf.offset(6), 0);\n+            }\n+        }\n+    }\n }"}, {"sha": "7f53ddf6e795a880111887d1c61de3d8f6c1aafd", "filename": "src/libstd/path.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/48265b779fabf865a4b05f000ea1575c90e3cd73/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48265b779fabf865a4b05f000ea1575c90e3cd73/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=48265b779fabf865a4b05f000ea1575c90e3cd73", "patch": "@@ -569,6 +569,10 @@ impl ToCStr for PosixPath {\n     fn to_c_str(&self) -> c_str::CString {\n         self.to_str().to_c_str()\n     }\n+\n+    unsafe fn to_c_str_unchecked(&self) -> c_str::CString {\n+        self.to_str().to_c_str_unchecked()\n+    }\n }\n \n // FIXME (#3227): when default methods in traits are working, de-duplicate\n@@ -781,6 +785,10 @@ impl c_str::ToCStr for WindowsPath {\n     fn to_c_str(&self) -> c_str::CString {\n         self.to_str().to_c_str()\n     }\n+\n+    unsafe fn to_c_str_unchecked(&self) -> c_str::CString {\n+        self.to_str().to_c_str_unchecked()\n+    }\n }\n \n impl GenericPath for WindowsPath {"}]}