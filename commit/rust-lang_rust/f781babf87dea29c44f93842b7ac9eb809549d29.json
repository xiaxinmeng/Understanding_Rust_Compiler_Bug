{"sha": "f781babf87dea29c44f93842b7ac9eb809549d29", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3ODFiYWJmODdkZWEyOWM0NGY5Mzg0MmI3YWM5ZWI4MDk1NDlkMjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-01T14:45:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-01T14:45:56Z"}, "message": "Auto merge of #73924 - Manishearth:rollup-8r51ld9, r=Manishearth\n\nRollup of 17 pull requests\n\nSuccessful merges:\n\n - #72071 (Added detailed error code explanation for issue E0687 in Rust compiler.)\n - #72369 (Bring net/parser.rs up to modern up to date with modern rust patterns)\n - #72445 (Stabilize `#[track_caller]`.)\n - #73466 (impl From<char> for String)\n - #73548 (remove rustdoc warnings)\n - #73649 (Fix sentence structure)\n - #73678 (Update Box::from_raw example to generalize better)\n - #73705 (stop taking references in Relate)\n - #73716 (Document the static keyword)\n - #73752 (Remap Windows ERROR_INVALID_PARAMETER to ErrorKind::InvalidInput from Other)\n - #73776 (Move terminator to new module)\n - #73778 (Make `likely` and `unlikely` const, gated by feature `const_unlikely`)\n - #73805 (Document the type keyword)\n - #73806 (Use an 'approximate' universal upper bound when reporting region errors)\n - #73828 (Fix wording for anonymous parameter name help)\n - #73846 (Fix comma in debug_assert! docs)\n - #73847 (Edit cursor.prev() method docs in lexer)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "fcb575eda0c6d0e786d9b42d1b6559b4865f3ff6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fcb575eda0c6d0e786d9b42d1b6559b4865f3ff6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f781babf87dea29c44f93842b7ac9eb809549d29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f781babf87dea29c44f93842b7ac9eb809549d29", "html_url": "https://github.com/rust-lang/rust/commit/f781babf87dea29c44f93842b7ac9eb809549d29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f781babf87dea29c44f93842b7ac9eb809549d29/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1505c1239554fd8c9a5f7a6f4823c7384a0c29e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/1505c1239554fd8c9a5f7a6f4823c7384a0c29e3", "html_url": "https://github.com/rust-lang/rust/commit/1505c1239554fd8c9a5f7a6f4823c7384a0c29e3"}, {"sha": "c9b3e869771e7944719e139a327422726f7529de", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9b3e869771e7944719e139a327422726f7529de", "html_url": "https://github.com/rust-lang/rust/commit/c9b3e869771e7944719e139a327422726f7529de"}], "stats": {"total": 2754, "additions": 1520, "deletions": 1234}, "files": [{"sha": "c2ded10f05a36c0270206346aa6ffc0fb70863e4", "filename": "README.md", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1,7 +1,9 @@\n-# The Rust Programming Language\n+<a href = \"https://www.rust-lang.org/\"> \n+<img width = \"90%\" height = \"auto\" src = \"https://img.shields.io/badge/Rust-Programming%20Language-black?style=flat&logo=rust\" alt = \"The Rust Programming Language\">\n+</a>\n \n This is the main source code repository for [Rust]. It contains the compiler,\n-standard library, and documentation.\n+standard library, and documentation. \n \n [Rust]: https://www.rust-lang.org\n \n@@ -17,9 +19,9 @@ Read [\"Installation\"] from [The Book].\n _Note: If you wish to contribute to the compiler, you should read [this\n chapter][rustcguidebuild] of the rustc-dev-guide instead of this section._\n \n-The Rust build system has a Python script called `x.py` to bootstrap building\n-the compiler. More information about it may be found by running `./x.py --help`\n-or reading the [rustc dev guide][rustcguidebuild].\n+The Rust build system uses a Python script called `x.py` to build the compiler,\n+which manages the bootstrapping process. More information about it can be found \n+by running `./x.py --help` or reading the [rustc dev guide][rustcguidebuild].\n \n [rustcguidebuild]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html\n \n@@ -54,9 +56,8 @@ or reading the [rustc dev guide][rustcguidebuild].\n     $ cp config.toml.example config.toml\n     ```\n \n-    It is recommended that if you plan to use the Rust build system to create\n-    an installation (using `./x.py install`) that you set the `prefix` value\n-    in the `[install]` section to a directory that you have write permissions.\n+    If you plan to use `x.py install` to create an installation, it is recommended\n+    that you set the `prefix` value in the `[install]` section to a directory.\n \n     Create install directory if you are not installing in default directory\n \n@@ -143,8 +144,8 @@ shell with:\n ```\n \n Currently, building Rust only works with some known versions of Visual Studio. If\n-you have a more recent version installed the build system doesn't understand\n-then you may need to force rustbuild to use an older version. This can be done\n+you have a more recent version installed and the build system doesn't understand,\n+you may need to force rustbuild to use an older version. This can be done\n by manually calling the appropriate vcvars file before running the bootstrap.\n \n ```batch"}, {"sha": "afc11a2b9492cfa8ef06de26bebf2a1662a2d195", "filename": "src/doc/unstable-book/src/language-features/track-caller.md", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1505c1239554fd8c9a5f7a6f4823c7384a0c29e3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftrack-caller.md", "raw_url": "https://github.com/rust-lang/rust/raw/1505c1239554fd8c9a5f7a6f4823c7384a0c29e3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftrack-caller.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftrack-caller.md?ref=1505c1239554fd8c9a5f7a6f4823c7384a0c29e3", "patch": "@@ -1,5 +0,0 @@\n-# `track_caller`\n-\n-The tracking issue for this feature is: [#47809](https://github.com/rust-lang/rust/issues/47809).\n-\n-------------------------"}, {"sha": "3320ebdf821d054e31217ba4b02591375d268db0", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -384,7 +384,10 @@ impl<T: ?Sized> Box<T> {\n     ///\n     /// unsafe {\n     ///     let ptr = alloc(Layout::new::<i32>()) as *mut i32;\n-    ///     *ptr = 5;\n+    ///     // In general .write is required to avoid attempting to destruct\n+    ///     // the (uninitialized) previous contents of `ptr`, though for this\n+    ///     // simple example `*ptr = 5` would have worked as well.\n+    ///     ptr.write(5);\n     ///     let x = Box::from_raw(ptr);\n     /// }\n     /// ```"}, {"sha": "13ef94dee2326c59f73ac2d3ba2f5c9b816cff21", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -2518,3 +2518,11 @@ impl DoubleEndedIterator for Drain<'_> {\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl FusedIterator for Drain<'_> {}\n+\n+#[stable(feature = \"from_char_for_string\", since = \"1.46.0\")]\n+impl From<char> for String {\n+    #[inline]\n+    fn from(c: char) -> Self {\n+        c.to_string()\n+    }\n+}"}, {"sha": "d38655af78cb79175e95fd294f28584f71f6f94f", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -714,3 +714,10 @@ fn test_try_reserve_exact() {\n         }\n     }\n }\n+\n+#[test]\n+fn test_from_char() {\n+    assert_eq!(String::from('a'), 'a'.to_string());\n+    let s: String = 'x'.into();\n+    assert_eq!(s, 'x'.to_string());\n+}"}, {"sha": "57ffed19c0085d29c7c7441f672f6a7103e3f12a", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -952,6 +952,7 @@ extern \"rust-intrinsic\" {\n     /// Any use other than with `if` statements will probably not have an effect.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_const_unstable(feature = \"const_likely\", issue = \"none\")]\n     pub fn likely(b: bool) -> bool;\n \n     /// Hints to the compiler that branch condition is likely to be false.\n@@ -960,6 +961,7 @@ extern \"rust-intrinsic\" {\n     /// Any use other than with `if` statements will probably not have an effect.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_const_unstable(feature = \"const_likely\", issue = \"none\")]\n     pub fn unlikely(b: bool) -> bool;\n \n     /// Executes a breakpoint trap, for inspection by a debugger."}, {"sha": "63ddd97eed3df0c8a5daab5775398ae5f4c3e70b", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -92,6 +92,7 @@\n #![feature(const_slice_from_raw_parts)]\n #![feature(const_slice_ptr_len)]\n #![feature(const_type_name)]\n+#![feature(const_likely)]\n #![feature(custom_inner_attributes)]\n #![feature(decl_macro)]\n #![feature(doc_cfg)]\n@@ -118,7 +119,7 @@\n #![feature(staged_api)]\n #![feature(std_internals)]\n #![feature(stmt_expr_attributes)]\n-#![feature(track_caller)]\n+#![cfg_attr(bootstrap, feature(track_caller))]\n #![feature(transparent_unions)]\n #![feature(unboxed_closures)]\n #![feature(unsized_locals)]"}, {"sha": "17f7349bac23380f4d0477244eecfdc8e3008d9f", "filename": "src/libcore/macros/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibcore%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibcore%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros%2Fmod.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1,6 +1,6 @@\n #[doc(include = \"panic.md\")]\n #[macro_export]\n-#[allow_internal_unstable(core_panic, track_caller)]\n+#[allow_internal_unstable(core_panic, const_caller_location)]\n #[stable(feature = \"core\", since = \"1.6.0\")]\n macro_rules! panic {\n     () => (\n@@ -151,7 +151,7 @@ macro_rules! assert_ne {\n /// An unchecked assertion allows a program in an inconsistent state to keep\n /// running, which might have unexpected consequences but does not introduce\n /// unsafety as long as this only happens in safe code. The performance cost\n-/// of assertions, is however, not measurable in general. Replacing [`assert!`]\n+/// of assertions, however, is not measurable in general. Replacing [`assert!`]\n /// with `debug_assert!` is thus only encouraged after thorough profiling, and\n /// more importantly, only in safe code!\n ///"}, {"sha": "543aa969330aedbf8056a4dbf140a4ba815677f9", "filename": "src/libcore/panic.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibcore%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibcore%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanic.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -190,7 +190,6 @@ impl<'a> Location<'a> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(track_caller)]\n     /// use core::panic::Location;\n     ///\n     /// /// Returns the [`Location`] at which it is called.\n@@ -206,7 +205,7 @@ impl<'a> Location<'a> {\n     ///\n     /// let fixed_location = get_just_one_location();\n     /// assert_eq!(fixed_location.file(), file!());\n-    /// assert_eq!(fixed_location.line(), 15);\n+    /// assert_eq!(fixed_location.line(), 14);\n     /// assert_eq!(fixed_location.column(), 5);\n     ///\n     /// // running the same untracked function in a different location gives us the same result\n@@ -217,7 +216,7 @@ impl<'a> Location<'a> {\n     ///\n     /// let this_location = get_caller_location();\n     /// assert_eq!(this_location.file(), file!());\n-    /// assert_eq!(this_location.line(), 29);\n+    /// assert_eq!(this_location.line(), 28);\n     /// assert_eq!(this_location.column(), 21);\n     ///\n     /// // running the tracked function in a different location produces a different value\n@@ -226,13 +225,8 @@ impl<'a> Location<'a> {\n     /// assert_ne!(this_location.line(), another_location.line());\n     /// assert_ne!(this_location.column(), another_location.column());\n     /// ```\n-    // FIXME: When stabilizing this method, please also update the documentation\n-    // of `intrinsics::caller_location`.\n-    #[unstable(\n-        feature = \"track_caller\",\n-        reason = \"uses #[track_caller] which is not yet stable\",\n-        issue = \"47809\"\n-    )]\n+    #[stable(feature = \"track_caller\", since = \"1.46.0\")]\n+    #[rustc_const_unstable(feature = \"const_caller_location\", issue = \"47809\")]\n     #[track_caller]\n     pub const fn caller() -> &'static Location<'static> {\n         crate::intrinsics::caller_location()"}, {"sha": "a5527158aab3c0d35a82d89b0f166e90fc93973a", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -382,6 +382,7 @@ E0668: include_str!(\"./error_codes/E0668.md\"),\n E0669: include_str!(\"./error_codes/E0669.md\"),\n E0670: include_str!(\"./error_codes/E0670.md\"),\n E0671: include_str!(\"./error_codes/E0671.md\"),\n+E0687: include_str!(\"./error_codes/E0687.md\"),\n E0689: include_str!(\"./error_codes/E0689.md\"),\n E0690: include_str!(\"./error_codes/E0690.md\"),\n E0691: include_str!(\"./error_codes/E0691.md\"),\n@@ -613,7 +614,6 @@ E0766: include_str!(\"./error_codes/E0766.md\"),\n     E0640, // infer outlives requirements\n //  E0645, // trait aliases not finished\n     E0667, // `impl Trait` in projections\n-    E0687, // in-band lifetimes cannot be used in `fn`/`Fn` syntax\n     E0688, // in-band lifetimes cannot be mixed with explicit lifetime binders\n //  E0694, // an unknown tool name found in scoped attributes\n //  E0702, // replaced with a generic attribute input check"}, {"sha": "67b7db2d31fdeb663d37384437aa59fcc8644403", "filename": "src/librustc_error_codes/error_codes/E0687.md", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_error_codes%2Ferror_codes%2FE0687.md", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_error_codes%2Ferror_codes%2FE0687.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0687.md?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -0,0 +1,36 @@\n+In-band lifetimes cannot be used in `fn`/`Fn` syntax.\n+\n+Erroneous code examples:\n+\n+```compile_fail,E0687\n+#![feature(in_band_lifetimes)]\n+\n+fn foo(x: fn(&'a u32)) {} // error!\n+\n+fn bar(x: &Fn(&'a u32)) {} // error!\n+\n+fn baz(x: fn(&'a u32), y: &'a u32) {} // error!\n+\n+struct Foo<'a> { x: &'a u32 }\n+\n+impl Foo<'a> {\n+    fn bar(&self, x: fn(&'a u32)) {} // error!\n+}\n+```\n+\n+Lifetimes used in `fn` or `Fn` syntax must be explicitly\n+declared using `<...>` binders. For example:\n+\n+```\n+fn foo<'a>(x: fn(&'a u32)) {} // ok!\n+\n+fn bar<'a>(x: &Fn(&'a u32)) {} // ok!\n+\n+fn baz<'a>(x: fn(&'a u32), y: &'a u32) {} // ok!\n+\n+struct Foo<'a> { x: &'a u32 }\n+\n+impl<'a> Foo<'a> {\n+    fn bar(&self, x: fn(&'a u32)) {} // ok!\n+}\n+```"}, {"sha": "0f3d41ba66dc4efe95f4ed957e96c309a4f97659", "filename": "src/librustc_error_codes/error_codes/E0736.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_error_codes%2Ferror_codes%2FE0736.md", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_error_codes%2Ferror_codes%2FE0736.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0736.md?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -3,8 +3,6 @@\n Erroneous code example:\n \n ```compile_fail,E0736\n-#![feature(track_caller)]\n-\n #[naked]\n #[track_caller]\n fn foo() {}"}, {"sha": "ab5e60692b4da157ff645a8ccb6aab36efb31690", "filename": "src/librustc_error_codes/error_codes/E0737.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_error_codes%2Ferror_codes%2FE0737.md", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_error_codes%2Ferror_codes%2FE0737.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0737.md?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -5,8 +5,6 @@ restrictions.\n Erroneous code example:\n \n ```compile_fail,E0737\n-#![feature(track_caller)]\n-\n #[track_caller]\n extern \"C\" fn foo() {}\n ```"}, {"sha": "8d9039bef93f6da0bedc75231f51bb5b403d73d0", "filename": "src/librustc_error_codes/error_codes/E0739.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_error_codes%2Ferror_codes%2FE0739.md", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_error_codes%2Ferror_codes%2FE0739.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0739.md?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -3,7 +3,6 @@\n Erroneous code example:\n \n ```compile_fail,E0739\n-#![feature(track_caller)]\n #[track_caller]\n struct Bar {\n     a: u8,"}, {"sha": "362913ceadf18aa4e911617156cacd2e16c260e9", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -5,7 +5,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(crate_visibility_modifier)]\n #![feature(nll)]\n-#![feature(track_caller)]\n+#![cfg_attr(bootstrap, feature(track_caller))]\n \n pub use emitter::ColorConfig;\n "}, {"sha": "d93c17b05b498c02baa6225f0173191cc519cca3", "filename": "src/librustc_feature/accepted.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_feature%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_feature%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Faccepted.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -265,6 +265,9 @@ declare_features! (\n     (accepted, const_if_match, \"1.45.0\", Some(49146), None),\n     /// Allows the use of `loop` and `while` in constants.\n     (accepted, const_loop, \"1.45.0\", Some(52000), None),\n+    /// Allows `#[track_caller]` to be used which provides\n+    /// accurate caller location reporting during panic (RFC 2091).\n+    (accepted, track_caller, \"1.46.0\", Some(47809), None),\n \n     // -------------------------------------------------------------------------\n     // feature-group-end: accepted features"}, {"sha": "b9a55377949f2bf9297909c0e0434ed3e02663b8", "filename": "src/librustc_feature/active.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_feature%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_feature%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Factive.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -494,10 +494,6 @@ declare_features! (\n     /// Allows the use of raw-dylibs (RFC 2627).\n     (active, raw_dylib, \"1.40.0\", Some(58713), None),\n \n-    /// Allows `#[track_caller]` to be used which provides\n-    /// accurate caller location reporting during panic (RFC 2091).\n-    (active, track_caller, \"1.40.0\", Some(47809), None),\n-\n     /// Allows making `dyn Trait` well-formed even if `Trait` is not object safe.\n     /// In that case, `dyn Trait: Trait` does not hold. Moreover, coercions and\n     /// casts in safe Rust to `dyn Trait` for such a `Trait` is also forbidden."}, {"sha": "c9a34f033758b66721b60ebdd381fc07ae2484ba", "filename": "src/librustc_feature/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Fbuiltin_attrs.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -260,6 +260,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ungated!(cold, Whitelisted, template!(Word)),\n     ungated!(no_builtins, Whitelisted, template!(Word)),\n     ungated!(target_feature, Whitelisted, template!(List: r#\"enable = \"name\"\"#)),\n+    ungated!(track_caller, Whitelisted, template!(Word)),\n     gated!(\n         no_sanitize, Whitelisted,\n         template!(List: \"address, memory, thread\"),\n@@ -333,7 +334,6 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     gated!(ffi_returns_twice, Whitelisted, template!(Word), experimental!(ffi_returns_twice)),\n     gated!(ffi_pure, Whitelisted, template!(Word), experimental!(ffi_pure)),\n     gated!(ffi_const, Whitelisted, template!(Word), experimental!(ffi_const)),\n-    gated!(track_caller, Whitelisted, template!(Word), experimental!(track_caller)),\n     gated!(\n         register_attr, CrateLevel, template!(List: \"attr1, attr2, ...\"),\n         experimental!(register_attr),"}, {"sha": "a7749d33b7c1389edcd874c10151ac8403d17da7", "filename": "src/librustc_infer/infer/at.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_infer%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_infer%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fat.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -82,7 +82,7 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace_exp(a_is_expected, a, b).sub(&a, &b)\n+        self.trace_exp(a_is_expected, a, b).sub(a, b)\n     }\n \n     /// Makes `actual <: expected`. For example, if type-checking a\n@@ -109,15 +109,15 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace_exp(a_is_expected, a, b).eq(&a, &b)\n+        self.trace_exp(a_is_expected, a, b).eq(a, b)\n     }\n \n     /// Makes `expected <: actual`.\n     pub fn eq<T>(self, expected: T, actual: T) -> InferResult<'tcx, ()>\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace(expected, actual).eq(&expected, &actual)\n+        self.trace(expected, actual).eq(expected, actual)\n     }\n \n     pub fn relate<T>(self, expected: T, variance: ty::Variance, actual: T) -> InferResult<'tcx, ()>\n@@ -147,7 +147,7 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace(expected, actual).lub(&expected, &actual)\n+        self.trace(expected, actual).lub(expected, actual)\n     }\n \n     /// Computes the greatest-lower-bound, or mutual subtype, of two\n@@ -157,7 +157,7 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace(expected, actual).glb(&expected, &actual)\n+        self.trace(expected, actual).glb(expected, actual)\n     }\n \n     /// Sets the \"trace\" values that will be used for\n@@ -186,7 +186,7 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n impl<'a, 'tcx> Trace<'a, 'tcx> {\n     /// Makes `a <: b` where `a` may or may not be expected (if\n     /// `a_is_expected` is true, then `a` is expected).\n-    pub fn sub<T>(self, a: &T, b: &T) -> InferResult<'tcx, ()>\n+    pub fn sub<T>(self, a: T, b: T) -> InferResult<'tcx, ()>\n     where\n         T: Relate<'tcx>,\n     {\n@@ -203,7 +203,7 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n \n     /// Makes `a == b`; the expectation is set by the call to\n     /// `trace()`.\n-    pub fn eq<T>(self, a: &T, b: &T) -> InferResult<'tcx, ()>\n+    pub fn eq<T>(self, a: T, b: T) -> InferResult<'tcx, ()>\n     where\n         T: Relate<'tcx>,\n     {\n@@ -218,7 +218,7 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n         })\n     }\n \n-    pub fn lub<T>(self, a: &T, b: &T) -> InferResult<'tcx, T>\n+    pub fn lub<T>(self, a: T, b: T) -> InferResult<'tcx, T>\n     where\n         T: Relate<'tcx>,\n     {\n@@ -233,7 +233,7 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n         })\n     }\n \n-    pub fn glb<T>(self, a: &T, b: &T) -> InferResult<'tcx, T>\n+    pub fn glb<T>(self, a: T, b: T) -> InferResult<'tcx, T>\n     where\n         T: Relate<'tcx>,\n     {"}, {"sha": "5cba581b9dffb4c2bdc10c07d111e1d532436334", "filename": "src/librustc_infer/infer/canonical/query_response.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -271,7 +271,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                         },\n                         ty::Variance::Invariant,\n                     )\n-                    .relate(&v1, &v2)?;\n+                    .relate(v1, v2)?;\n                 }\n \n                 (GenericArgKind::Const(v1), GenericArgKind::Const(v2)) => {\n@@ -285,7 +285,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                         },\n                         ty::Variance::Invariant,\n                     )\n-                    .relate(&v1, &v2)?;\n+                    .relate(v1, v2)?;\n                 }\n \n                 _ => {\n@@ -302,7 +302,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 // Screen out `'a: 'a` cases -- we skip the binder here but\n                 // only compare the inner values to one another, so they are still at\n                 // consistent binding levels.\n-                let &ty::OutlivesPredicate(k1, r2) = r_c.skip_binder();\n+                let ty::OutlivesPredicate(k1, r2) = r_c.skip_binder();\n                 if k1 != r2.into() { Some(r_c) } else { None }\n             }),\n         );\n@@ -526,7 +526,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     ) -> impl Iterator<Item = PredicateObligation<'tcx>> + 'a + Captures<'tcx> {\n         unsubstituted_region_constraints.iter().map(move |constraint| {\n             let constraint = substitute_value(self.tcx, result_subst, constraint);\n-            let &ty::OutlivesPredicate(k1, r2) = constraint.skip_binder(); // restored below\n+            let ty::OutlivesPredicate(k1, r2) = constraint.skip_binder(); // restored below\n \n             Obligation::new(\n                 cause.clone(),"}, {"sha": "c8d4e9f0e14b9e66c916b3cb84b8927ae24c2a72", "filename": "src/librustc_infer/infer/combine.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcombine.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -318,10 +318,10 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         // to associate causes/spans with each of the relations in\n         // the stack to get this right.\n         match dir {\n-            EqTo => self.equate(a_is_expected).relate(&a_ty, &b_ty),\n-            SubtypeOf => self.sub(a_is_expected).relate(&a_ty, &b_ty),\n+            EqTo => self.equate(a_is_expected).relate(a_ty, b_ty),\n+            SubtypeOf => self.sub(a_is_expected).relate(a_ty, b_ty),\n             SupertypeOf => {\n-                self.sub(a_is_expected).relate_with_variance(ty::Contravariant, &a_ty, &b_ty)\n+                self.sub(a_is_expected).relate_with_variance(ty::Contravariant, a_ty, b_ty)\n             }\n         }?;\n \n@@ -379,7 +379,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             param_env: self.param_env,\n         };\n \n-        let ty = match generalize.relate(&ty, &ty) {\n+        let ty = match generalize.relate(ty, ty) {\n             Ok(ty) => ty,\n             Err(e) => {\n                 debug!(\"generalize: failure {:?}\", e);\n@@ -490,8 +490,8 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>,\n@@ -519,8 +519,8 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T> {\n         let old_ambient_variance = self.ambient_variance;\n         self.ambient_variance = self.ambient_variance.xform(variance);\n@@ -552,7 +552,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                     match probe {\n                         TypeVariableValue::Known { value: u } => {\n                             debug!(\"generalize: known value {:?}\", u);\n-                            self.relate(&u, &u)\n+                            self.relate(u, u)\n                         }\n                         TypeVariableValue::Unknown { universe } => {\n                             match self.ambient_variance {\n@@ -655,7 +655,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                 let variable_table = &mut inner.const_unification_table();\n                 let var_value = variable_table.probe_value(vid);\n                 match var_value.val {\n-                    ConstVariableValue::Known { value: u } => self.relate(&u, &u),\n+                    ConstVariableValue::Known { value: u } => self.relate(u, u),\n                     ConstVariableValue::Unknown { universe } => {\n                         if self.for_universe.can_name(universe) {\n                             Ok(c)"}, {"sha": "7de752d1de0dbe3be10fc0175965ed5b69897fac", "filename": "src/librustc_infer/infer/equate.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_infer%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_infer%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fequate.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -59,8 +59,8 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T> {\n         self.relate(a, b)\n     }\n@@ -124,8 +124,8 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>,\n@@ -136,7 +136,7 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n         } else {\n             // Fast path for the common case.\n             self.relate(a.skip_binder(), b.skip_binder())?;\n-            Ok(a.clone())\n+            Ok(a)\n         }\n     }\n }"}, {"sha": "8a0ab52f383065cd72205619ec3232cf0a6ce8a2", "filename": "src/librustc_infer/infer/glb.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_infer%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_infer%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fglb.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -43,8 +43,8 @@ impl TypeRelation<'tcx> for Glb<'combine, 'infcx, 'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T> {\n         match variance {\n             ty::Invariant => self.fields.equate(self.a_is_expected).relate(a, b),\n@@ -85,8 +85,8 @@ impl TypeRelation<'tcx> for Glb<'combine, 'infcx, 'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>,\n@@ -112,8 +112,8 @@ impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Glb<'combine, 'infcx,\n \n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n         let mut sub = self.fields.sub(self.a_is_expected);\n-        sub.relate(&v, &a)?;\n-        sub.relate(&v, &b)?;\n+        sub.relate(v, a)?;\n+        sub.relate(v, b)?;\n         Ok(())\n     }\n }"}, {"sha": "ea19dff7db125098ba4b1ad85f765af989cf64aa", "filename": "src/librustc_infer/infer/higher_ranked/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_infer%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_infer%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -11,8 +11,8 @@ use rustc_middle::ty::{self, Binder, TypeFoldable};\n impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n     pub fn higher_ranked_sub<T>(\n         &mut self,\n-        a: &Binder<T>,\n-        b: &Binder<T>,\n+        a: Binder<T>,\n+        b: Binder<T>,\n         a_is_expected: bool,\n     ) -> RelateResult<'tcx, Binder<T>>\n     where\n@@ -33,20 +33,20 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n         self.infcx.commit_if_ok(|_| {\n             // First, we instantiate each bound region in the supertype with a\n             // fresh placeholder region.\n-            let (b_prime, _) = self.infcx.replace_bound_vars_with_placeholders(b);\n+            let (b_prime, _) = self.infcx.replace_bound_vars_with_placeholders(&b);\n \n             // Next, we instantiate each bound region in the subtype\n             // with a fresh region variable. These region variables --\n             // but no other pre-existing region variables -- can name\n             // the placeholders.\n             let (a_prime, _) =\n-                self.infcx.replace_bound_vars_with_fresh_vars(span, HigherRankedType, a);\n+                self.infcx.replace_bound_vars_with_fresh_vars(span, HigherRankedType, &a);\n \n             debug!(\"a_prime={:?}\", a_prime);\n             debug!(\"b_prime={:?}\", b_prime);\n \n             // Compare types now that bound regions have been replaced.\n-            let result = self.sub(a_is_expected).relate(&a_prime, &b_prime)?;\n+            let result = self.sub(a_is_expected).relate(a_prime, b_prime)?;\n \n             debug!(\"higher_ranked_sub: OK result={:?}\", result);\n "}, {"sha": "3e2ea3d0f8fbf19856222dcaefbed6e22acfa477", "filename": "src/librustc_infer/infer/lub.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_infer%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_infer%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flub.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -43,8 +43,8 @@ impl TypeRelation<'tcx> for Lub<'combine, 'infcx, 'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T> {\n         match variance {\n             ty::Invariant => self.fields.equate(self.a_is_expected).relate(a, b),\n@@ -85,8 +85,8 @@ impl TypeRelation<'tcx> for Lub<'combine, 'infcx, 'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>,\n@@ -97,7 +97,7 @@ impl TypeRelation<'tcx> for Lub<'combine, 'infcx, 'tcx> {\n         // very challenging, switch to invariance. This is obviously\n         // overly conservative but works ok in practice.\n         self.relate_with_variance(ty::Variance::Invariant, a, b)?;\n-        Ok(a.clone())\n+        Ok(a)\n     }\n }\n \n@@ -118,8 +118,8 @@ impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Lub<'combine, 'infcx,\n \n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n         let mut sub = self.fields.sub(self.a_is_expected);\n-        sub.relate(&a, &v)?;\n-        sub.relate(&b, &v)?;\n+        sub.relate(a, v)?;\n+        sub.relate(b, v)?;\n         Ok(())\n     }\n }"}, {"sha": "cb1f1c08d88f88cce50efd51249bd7482c324e28", "filename": "src/librustc_infer/infer/nll_relate/mod.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -161,7 +161,7 @@ where\n \n     fn create_scope(\n         &mut self,\n-        value: &ty::Binder<impl TypeFoldable<'tcx>>,\n+        value: ty::Binder<impl Relate<'tcx>>,\n         universally_quantified: UniversallyQuantified,\n     ) -> BoundRegionScope<'tcx> {\n         let mut scope = BoundRegionScope::default();\n@@ -369,7 +369,7 @@ where\n             universe,\n         };\n \n-        generalizer.relate(&value, &value)\n+        generalizer.relate(value, value)\n     }\n }\n \n@@ -495,8 +495,8 @@ where\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T> {\n         debug!(\"relate_with_variance(variance={:?}, a={:?}, b={:?})\", variance, a, b);\n \n@@ -613,8 +613,8 @@ where\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>,\n@@ -640,11 +640,10 @@ where\n \n         debug!(\"binders({:?}: {:?}, ambient_variance={:?})\", a, b, self.ambient_variance);\n \n-        if !a.skip_binder().has_escaping_bound_vars() && !b.skip_binder().has_escaping_bound_vars()\n-        {\n+        if let (Some(a), Some(b)) = (a.no_bound_vars(), b.no_bound_vars()) {\n             // Fast path for the common case.\n-            self.relate(a.skip_binder(), b.skip_binder())?;\n-            return Ok(a.clone());\n+            self.relate(a, b)?;\n+            return Ok(ty::Binder::bind(a));\n         }\n \n         if self.ambient_covariance() {\n@@ -839,8 +838,8 @@ where\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T> {\n         debug!(\n             \"TypeGeneralizer::relate_with_variance(variance={:?}, a={:?}, b={:?})\",\n@@ -890,7 +889,7 @@ where\n                     match variables.probe(vid) {\n                         TypeVariableValue::Known { value: u } => {\n                             drop(variables);\n-                            self.relate(&u, &u)\n+                            self.relate(u, u)\n                         }\n                         TypeVariableValue::Unknown { universe: _universe } => {\n                             if self.ambient_variance == ty::Bivariant {\n@@ -984,7 +983,7 @@ where\n                 let variable_table = &mut inner.const_unification_table();\n                 let var_value = variable_table.probe_value(vid);\n                 match var_value.val.known() {\n-                    Some(u) => self.relate(&u, &u),\n+                    Some(u) => self.relate(u, u),\n                     None => {\n                         let new_var_id = variable_table.new_key(ConstVarValue {\n                             origin: var_value.origin,\n@@ -1001,8 +1000,8 @@ where\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        _: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        _: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>,"}, {"sha": "d190f7e434298996252818144e695e96fcc61d75", "filename": "src/librustc_infer/infer/sub.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fsub.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -62,8 +62,8 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T> {\n         match variance {\n             ty::Invariant => self.fields.equate(self.a_is_expected).relate(a, b),\n@@ -162,8 +162,8 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>,"}, {"sha": "c0045d3f79be1ffca53fd956aa0251a53d6a8692", "filename": "src/librustc_lexer/src/cursor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_lexer%2Fsrc%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_lexer%2Fsrc%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Fcursor.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -23,8 +23,8 @@ impl<'a> Cursor<'a> {\n         }\n     }\n \n-    /// For debug assertions only\n-    /// Returns the last eaten symbol (or '\\0' in release builds).\n+    /// Returns the last eaten symbol (or `'\\0'` in release builds).\n+    /// (For debug assertions only.)\n     pub(crate) fn prev(&self) -> char {\n         #[cfg(debug_assertions)]\n         {"}, {"sha": "d55cbbe19c279d9699672b8842762e24bb64b261", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -911,7 +911,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n                 }\n                 let sig = cx.tables().node_type(expr.hir_id).fn_sig(cx.tcx);\n                 let from = sig.inputs().skip_binder()[0];\n-                let to = *sig.output().skip_binder();\n+                let to = sig.output().skip_binder();\n                 return Some((from, to));\n             }\n             None"}, {"sha": "8f15c99f951fe234000288f1a36bc70cbd4b8494", "filename": "src/librustc_middle/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_middle%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_middle%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fich%2Fimpls_ty.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -123,7 +123,7 @@ where\n     T: HashStable<StableHashingContext<'a>>,\n {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        self.skip_binder().hash_stable(hcx, hasher);\n+        self.as_ref().skip_binder().hash_stable(hcx, hasher);\n     }\n }\n "}, {"sha": "96b8ca27183ede146602121022eeef25bc074976", "filename": "src/librustc_middle/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_middle%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_middle%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Flib.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -42,7 +42,7 @@\n #![feature(or_patterns)]\n #![feature(range_is_empty)]\n #![feature(min_specialization)]\n-#![feature(track_caller)]\n+#![cfg_attr(bootstrap, feature(track_caller))]\n #![feature(trusted_len)]\n #![feature(stmt_expr_attributes)]\n #![feature(test)]"}, {"sha": "ae59f8c542d8c5ece510ba471023358990abe0ab", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 492, "changes": 494, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -19,7 +19,6 @@ use rustc_target::abi::VariantIdx;\n \n use polonius_engine::Atom;\n pub use rustc_ast::ast::Mutability;\n-use rustc_ast::ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::dominators::{dominators, Dominators};\n use rustc_data_structures::graph::{self, GraphSuccessors};\n@@ -45,6 +44,8 @@ pub mod mono;\n mod predecessors;\n mod query;\n pub mod tcx;\n+pub mod terminator;\n+pub use terminator::*;\n pub mod traversal;\n mod type_foldable;\n pub mod visit;\n@@ -1046,191 +1047,6 @@ pub struct BasicBlockData<'tcx> {\n     pub is_cleanup: bool,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct Terminator<'tcx> {\n-    pub source_info: SourceInfo,\n-    pub kind: TerminatorKind<'tcx>,\n-}\n-\n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable, PartialEq)]\n-pub enum TerminatorKind<'tcx> {\n-    /// Block should have one successor in the graph; we jump there.\n-    Goto { target: BasicBlock },\n-\n-    /// Operand evaluates to an integer; jump depending on its value\n-    /// to one of the targets, and otherwise fallback to `otherwise`.\n-    SwitchInt {\n-        /// The discriminant value being tested.\n-        discr: Operand<'tcx>,\n-\n-        /// The type of value being tested.\n-        /// This is always the same as the type of `discr`.\n-        /// FIXME: remove this redundant information. Currently, it is relied on by pretty-printing.\n-        switch_ty: Ty<'tcx>,\n-\n-        /// Possible values. The locations to branch to in each case\n-        /// are found in the corresponding indices from the `targets` vector.\n-        values: Cow<'tcx, [u128]>,\n-\n-        /// Possible branch sites. The last element of this vector is used\n-        /// for the otherwise branch, so targets.len() == values.len() + 1\n-        /// should hold.\n-        //\n-        // This invariant is quite non-obvious and also could be improved.\n-        // One way to make this invariant is to have something like this instead:\n-        //\n-        // branches: Vec<(ConstInt, BasicBlock)>,\n-        // otherwise: Option<BasicBlock> // exhaustive if None\n-        //\n-        // However we\u2019ve decided to keep this as-is until we figure a case\n-        // where some other approach seems to be strictly better than other.\n-        targets: Vec<BasicBlock>,\n-    },\n-\n-    /// Indicates that the landing pad is finished and unwinding should\n-    /// continue. Emitted by `build::scope::diverge_cleanup`.\n-    Resume,\n-\n-    /// Indicates that the landing pad is finished and that the process\n-    /// should abort. Used to prevent unwinding for foreign items.\n-    Abort,\n-\n-    /// Indicates a normal return. The return place should have\n-    /// been filled in before this executes. This can occur multiple times\n-    /// in different basic blocks.\n-    Return,\n-\n-    /// Indicates a terminator that can never be reached.\n-    Unreachable,\n-\n-    /// Drop the `Place`.\n-    Drop { place: Place<'tcx>, target: BasicBlock, unwind: Option<BasicBlock> },\n-\n-    /// Drop the `Place` and assign the new value over it. This ensures\n-    /// that the assignment to `P` occurs *even if* the destructor for\n-    /// place unwinds. Its semantics are best explained by the\n-    /// elaboration:\n-    ///\n-    /// ```\n-    /// BB0 {\n-    ///   DropAndReplace(P <- V, goto BB1, unwind BB2)\n-    /// }\n-    /// ```\n-    ///\n-    /// becomes\n-    ///\n-    /// ```\n-    /// BB0 {\n-    ///   Drop(P, goto BB1, unwind BB2)\n-    /// }\n-    /// BB1 {\n-    ///   // P is now uninitialized\n-    ///   P <- V\n-    /// }\n-    /// BB2 {\n-    ///   // P is now uninitialized -- its dtor panicked\n-    ///   P <- V\n-    /// }\n-    /// ```\n-    DropAndReplace {\n-        place: Place<'tcx>,\n-        value: Operand<'tcx>,\n-        target: BasicBlock,\n-        unwind: Option<BasicBlock>,\n-    },\n-\n-    /// Block ends with a call of a converging function.\n-    Call {\n-        /// The function that\u2019s being called.\n-        func: Operand<'tcx>,\n-        /// Arguments the function is called with.\n-        /// These are owned by the callee, which is free to modify them.\n-        /// This allows the memory occupied by \"by-value\" arguments to be\n-        /// reused across function calls without duplicating the contents.\n-        args: Vec<Operand<'tcx>>,\n-        /// Destination for the return value. If some, the call is converging.\n-        destination: Option<(Place<'tcx>, BasicBlock)>,\n-        /// Cleanups to be done if the call unwinds.\n-        cleanup: Option<BasicBlock>,\n-        /// `true` if this is from a call in HIR rather than from an overloaded\n-        /// operator. True for overloaded function call.\n-        from_hir_call: bool,\n-        /// This `Span` is the span of the function, without the dot and receiver\n-        /// (e.g. `foo(a, b)` in `x.foo(a, b)`\n-        fn_span: Span,\n-    },\n-\n-    /// Jump to the target if the condition has the expected value,\n-    /// otherwise panic with a message and a cleanup target.\n-    Assert {\n-        cond: Operand<'tcx>,\n-        expected: bool,\n-        msg: AssertMessage<'tcx>,\n-        target: BasicBlock,\n-        cleanup: Option<BasicBlock>,\n-    },\n-\n-    /// A suspend point.\n-    Yield {\n-        /// The value to return.\n-        value: Operand<'tcx>,\n-        /// Where to resume to.\n-        resume: BasicBlock,\n-        /// The place to store the resume argument in.\n-        resume_arg: Place<'tcx>,\n-        /// Cleanup to be done if the generator is dropped at this suspend point.\n-        drop: Option<BasicBlock>,\n-    },\n-\n-    /// Indicates the end of the dropping of a generator.\n-    GeneratorDrop,\n-\n-    /// A block where control flow only ever takes one real path, but borrowck\n-    /// needs to be more conservative.\n-    FalseEdge {\n-        /// The target normal control flow will take.\n-        real_target: BasicBlock,\n-        /// A block control flow could conceptually jump to, but won't in\n-        /// practice.\n-        imaginary_target: BasicBlock,\n-    },\n-    /// A terminator for blocks that only take one path in reality, but where we\n-    /// reserve the right to unwind in borrowck, even if it won't happen in practice.\n-    /// This can arise in infinite loops with no function calls for example.\n-    FalseUnwind {\n-        /// The target normal control flow will take.\n-        real_target: BasicBlock,\n-        /// The imaginary cleanup block link. This particular path will never be taken\n-        /// in practice, but in order to avoid fragility we want to always\n-        /// consider it in borrowck. We don't want to accept programs which\n-        /// pass borrowck only when `panic=abort` or some assertions are disabled\n-        /// due to release vs. debug mode builds. This needs to be an `Option` because\n-        /// of the `remove_noop_landing_pads` and `no_landing_pads` passes.\n-        unwind: Option<BasicBlock>,\n-    },\n-\n-    /// Block ends with an inline assembly block. This is a terminator since\n-    /// inline assembly is allowed to diverge.\n-    InlineAsm {\n-        /// The template for the inline assembly, with placeholders.\n-        template: &'tcx [InlineAsmTemplatePiece],\n-\n-        /// The operands for the inline assembly, as `Operand`s or `Place`s.\n-        operands: Vec<InlineAsmOperand<'tcx>>,\n-\n-        /// Miscellaneous options for the inline assembly.\n-        options: InlineAsmOptions,\n-\n-        /// Source spans for each line of the inline assembly code. These are\n-        /// used to map assembler errors back to the line in the source code.\n-        line_spans: &'tcx [Span],\n-\n-        /// Destination block after the inline assembly returns, unless it is\n-        /// diverging (InlineAsmOptions::NORETURN).\n-        destination: Option<BasicBlock>,\n-    },\n-}\n-\n /// Information about an assertion failure.\n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable, PartialEq)]\n pub enum AssertKind<O> {\n@@ -1279,149 +1095,6 @@ pub type Successors<'a> =\n pub type SuccessorsMut<'a> =\n     iter::Chain<option::IntoIter<&'a mut BasicBlock>, slice::IterMut<'a, BasicBlock>>;\n \n-impl<'tcx> Terminator<'tcx> {\n-    pub fn successors(&self) -> Successors<'_> {\n-        self.kind.successors()\n-    }\n-\n-    pub fn successors_mut(&mut self) -> SuccessorsMut<'_> {\n-        self.kind.successors_mut()\n-    }\n-\n-    pub fn unwind(&self) -> Option<&Option<BasicBlock>> {\n-        self.kind.unwind()\n-    }\n-\n-    pub fn unwind_mut(&mut self) -> Option<&mut Option<BasicBlock>> {\n-        self.kind.unwind_mut()\n-    }\n-}\n-\n-impl<'tcx> TerminatorKind<'tcx> {\n-    pub fn if_(\n-        tcx: TyCtxt<'tcx>,\n-        cond: Operand<'tcx>,\n-        t: BasicBlock,\n-        f: BasicBlock,\n-    ) -> TerminatorKind<'tcx> {\n-        static BOOL_SWITCH_FALSE: &[u128] = &[0];\n-        TerminatorKind::SwitchInt {\n-            discr: cond,\n-            switch_ty: tcx.types.bool,\n-            values: From::from(BOOL_SWITCH_FALSE),\n-            targets: vec![f, t],\n-        }\n-    }\n-\n-    pub fn successors(&self) -> Successors<'_> {\n-        use self::TerminatorKind::*;\n-        match *self {\n-            Resume\n-            | Abort\n-            | GeneratorDrop\n-            | Return\n-            | Unreachable\n-            | Call { destination: None, cleanup: None, .. }\n-            | InlineAsm { destination: None, .. } => None.into_iter().chain(&[]),\n-            Goto { target: ref t }\n-            | Call { destination: None, cleanup: Some(ref t), .. }\n-            | Call { destination: Some((_, ref t)), cleanup: None, .. }\n-            | Yield { resume: ref t, drop: None, .. }\n-            | DropAndReplace { target: ref t, unwind: None, .. }\n-            | Drop { target: ref t, unwind: None, .. }\n-            | Assert { target: ref t, cleanup: None, .. }\n-            | FalseUnwind { real_target: ref t, unwind: None }\n-            | InlineAsm { destination: Some(ref t), .. } => Some(t).into_iter().chain(&[]),\n-            Call { destination: Some((_, ref t)), cleanup: Some(ref u), .. }\n-            | Yield { resume: ref t, drop: Some(ref u), .. }\n-            | DropAndReplace { target: ref t, unwind: Some(ref u), .. }\n-            | Drop { target: ref t, unwind: Some(ref u), .. }\n-            | Assert { target: ref t, cleanup: Some(ref u), .. }\n-            | FalseUnwind { real_target: ref t, unwind: Some(ref u) } => {\n-                Some(t).into_iter().chain(slice::from_ref(u))\n-            }\n-            SwitchInt { ref targets, .. } => None.into_iter().chain(&targets[..]),\n-            FalseEdge { ref real_target, ref imaginary_target } => {\n-                Some(real_target).into_iter().chain(slice::from_ref(imaginary_target))\n-            }\n-        }\n-    }\n-\n-    pub fn successors_mut(&mut self) -> SuccessorsMut<'_> {\n-        use self::TerminatorKind::*;\n-        match *self {\n-            Resume\n-            | Abort\n-            | GeneratorDrop\n-            | Return\n-            | Unreachable\n-            | Call { destination: None, cleanup: None, .. }\n-            | InlineAsm { destination: None, .. } => None.into_iter().chain(&mut []),\n-            Goto { target: ref mut t }\n-            | Call { destination: None, cleanup: Some(ref mut t), .. }\n-            | Call { destination: Some((_, ref mut t)), cleanup: None, .. }\n-            | Yield { resume: ref mut t, drop: None, .. }\n-            | DropAndReplace { target: ref mut t, unwind: None, .. }\n-            | Drop { target: ref mut t, unwind: None, .. }\n-            | Assert { target: ref mut t, cleanup: None, .. }\n-            | FalseUnwind { real_target: ref mut t, unwind: None }\n-            | InlineAsm { destination: Some(ref mut t), .. } => Some(t).into_iter().chain(&mut []),\n-            Call { destination: Some((_, ref mut t)), cleanup: Some(ref mut u), .. }\n-            | Yield { resume: ref mut t, drop: Some(ref mut u), .. }\n-            | DropAndReplace { target: ref mut t, unwind: Some(ref mut u), .. }\n-            | Drop { target: ref mut t, unwind: Some(ref mut u), .. }\n-            | Assert { target: ref mut t, cleanup: Some(ref mut u), .. }\n-            | FalseUnwind { real_target: ref mut t, unwind: Some(ref mut u) } => {\n-                Some(t).into_iter().chain(slice::from_mut(u))\n-            }\n-            SwitchInt { ref mut targets, .. } => None.into_iter().chain(&mut targets[..]),\n-            FalseEdge { ref mut real_target, ref mut imaginary_target } => {\n-                Some(real_target).into_iter().chain(slice::from_mut(imaginary_target))\n-            }\n-        }\n-    }\n-\n-    pub fn unwind(&self) -> Option<&Option<BasicBlock>> {\n-        match *self {\n-            TerminatorKind::Goto { .. }\n-            | TerminatorKind::Resume\n-            | TerminatorKind::Abort\n-            | TerminatorKind::Return\n-            | TerminatorKind::Unreachable\n-            | TerminatorKind::GeneratorDrop\n-            | TerminatorKind::Yield { .. }\n-            | TerminatorKind::SwitchInt { .. }\n-            | TerminatorKind::FalseEdge { .. }\n-            | TerminatorKind::InlineAsm { .. } => None,\n-            TerminatorKind::Call { cleanup: ref unwind, .. }\n-            | TerminatorKind::Assert { cleanup: ref unwind, .. }\n-            | TerminatorKind::DropAndReplace { ref unwind, .. }\n-            | TerminatorKind::Drop { ref unwind, .. }\n-            | TerminatorKind::FalseUnwind { ref unwind, .. } => Some(unwind),\n-        }\n-    }\n-\n-    pub fn unwind_mut(&mut self) -> Option<&mut Option<BasicBlock>> {\n-        match *self {\n-            TerminatorKind::Goto { .. }\n-            | TerminatorKind::Resume\n-            | TerminatorKind::Abort\n-            | TerminatorKind::Return\n-            | TerminatorKind::Unreachable\n-            | TerminatorKind::GeneratorDrop\n-            | TerminatorKind::Yield { .. }\n-            | TerminatorKind::SwitchInt { .. }\n-            | TerminatorKind::FalseEdge { .. }\n-            | TerminatorKind::InlineAsm { .. } => None,\n-            TerminatorKind::Call { cleanup: ref mut unwind, .. }\n-            | TerminatorKind::Assert { cleanup: ref mut unwind, .. }\n-            | TerminatorKind::DropAndReplace { ref mut unwind, .. }\n-            | TerminatorKind::Drop { ref mut unwind, .. }\n-            | TerminatorKind::FalseUnwind { ref mut unwind, .. } => Some(unwind),\n-        }\n-    }\n-}\n-\n impl<'tcx> BasicBlockData<'tcx> {\n     pub fn new(terminator: Option<Terminator<'tcx>>) -> BasicBlockData<'tcx> {\n         BasicBlockData { statements: vec![], terminator, is_cleanup: false }\n@@ -1628,169 +1301,6 @@ impl<O: fmt::Debug> fmt::Debug for AssertKind<O> {\n     }\n }\n \n-impl<'tcx> Debug for TerminatorKind<'tcx> {\n-    fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n-        self.fmt_head(fmt)?;\n-        let successor_count = self.successors().count();\n-        let labels = self.fmt_successor_labels();\n-        assert_eq!(successor_count, labels.len());\n-\n-        match successor_count {\n-            0 => Ok(()),\n-\n-            1 => write!(fmt, \" -> {:?}\", self.successors().next().unwrap()),\n-\n-            _ => {\n-                write!(fmt, \" -> [\")?;\n-                for (i, target) in self.successors().enumerate() {\n-                    if i > 0 {\n-                        write!(fmt, \", \")?;\n-                    }\n-                    write!(fmt, \"{}: {:?}\", labels[i], target)?;\n-                }\n-                write!(fmt, \"]\")\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> TerminatorKind<'tcx> {\n-    /// Writes the \"head\" part of the terminator; that is, its name and the data it uses to pick the\n-    /// successor basic block, if any. The only information not included is the list of possible\n-    /// successors, which may be rendered differently between the text and the graphviz format.\n-    pub fn fmt_head<W: Write>(&self, fmt: &mut W) -> fmt::Result {\n-        use self::TerminatorKind::*;\n-        match self {\n-            Goto { .. } => write!(fmt, \"goto\"),\n-            SwitchInt { discr, .. } => write!(fmt, \"switchInt({:?})\", discr),\n-            Return => write!(fmt, \"return\"),\n-            GeneratorDrop => write!(fmt, \"generator_drop\"),\n-            Resume => write!(fmt, \"resume\"),\n-            Abort => write!(fmt, \"abort\"),\n-            Yield { value, resume_arg, .. } => write!(fmt, \"{:?} = yield({:?})\", resume_arg, value),\n-            Unreachable => write!(fmt, \"unreachable\"),\n-            Drop { place, .. } => write!(fmt, \"drop({:?})\", place),\n-            DropAndReplace { place, value, .. } => {\n-                write!(fmt, \"replace({:?} <- {:?})\", place, value)\n-            }\n-            Call { func, args, destination, .. } => {\n-                if let Some((destination, _)) = destination {\n-                    write!(fmt, \"{:?} = \", destination)?;\n-                }\n-                write!(fmt, \"{:?}(\", func)?;\n-                for (index, arg) in args.iter().enumerate() {\n-                    if index > 0 {\n-                        write!(fmt, \", \")?;\n-                    }\n-                    write!(fmt, \"{:?}\", arg)?;\n-                }\n-                write!(fmt, \")\")\n-            }\n-            Assert { cond, expected, msg, .. } => {\n-                write!(fmt, \"assert(\")?;\n-                if !expected {\n-                    write!(fmt, \"!\")?;\n-                }\n-                write!(fmt, \"{:?}, \", cond)?;\n-                msg.fmt_assert_args(fmt)?;\n-                write!(fmt, \")\")\n-            }\n-            FalseEdge { .. } => write!(fmt, \"falseEdge\"),\n-            FalseUnwind { .. } => write!(fmt, \"falseUnwind\"),\n-            InlineAsm { template, ref operands, options, .. } => {\n-                write!(fmt, \"asm!(\\\"{}\\\"\", InlineAsmTemplatePiece::to_string(template))?;\n-                for op in operands {\n-                    write!(fmt, \", \")?;\n-                    let print_late = |&late| if late { \"late\" } else { \"\" };\n-                    match op {\n-                        InlineAsmOperand::In { reg, value } => {\n-                            write!(fmt, \"in({}) {:?}\", reg, value)?;\n-                        }\n-                        InlineAsmOperand::Out { reg, late, place: Some(place) } => {\n-                            write!(fmt, \"{}out({}) {:?}\", print_late(late), reg, place)?;\n-                        }\n-                        InlineAsmOperand::Out { reg, late, place: None } => {\n-                            write!(fmt, \"{}out({}) _\", print_late(late), reg)?;\n-                        }\n-                        InlineAsmOperand::InOut {\n-                            reg,\n-                            late,\n-                            in_value,\n-                            out_place: Some(out_place),\n-                        } => {\n-                            write!(\n-                                fmt,\n-                                \"in{}out({}) {:?} => {:?}\",\n-                                print_late(late),\n-                                reg,\n-                                in_value,\n-                                out_place\n-                            )?;\n-                        }\n-                        InlineAsmOperand::InOut { reg, late, in_value, out_place: None } => {\n-                            write!(fmt, \"in{}out({}) {:?} => _\", print_late(late), reg, in_value)?;\n-                        }\n-                        InlineAsmOperand::Const { value } => {\n-                            write!(fmt, \"const {:?}\", value)?;\n-                        }\n-                        InlineAsmOperand::SymFn { value } => {\n-                            write!(fmt, \"sym_fn {:?}\", value)?;\n-                        }\n-                        InlineAsmOperand::SymStatic { def_id } => {\n-                            write!(fmt, \"sym_static {:?}\", def_id)?;\n-                        }\n-                    }\n-                }\n-                write!(fmt, \", options({:?}))\", options)\n-            }\n-        }\n-    }\n-\n-    /// Returns the list of labels for the edges to the successor basic blocks.\n-    pub fn fmt_successor_labels(&self) -> Vec<Cow<'static, str>> {\n-        use self::TerminatorKind::*;\n-        match *self {\n-            Return | Resume | Abort | Unreachable | GeneratorDrop => vec![],\n-            Goto { .. } => vec![\"\".into()],\n-            SwitchInt { ref values, switch_ty, .. } => ty::tls::with(|tcx| {\n-                let param_env = ty::ParamEnv::empty();\n-                let switch_ty = tcx.lift(&switch_ty).unwrap();\n-                let size = tcx.layout_of(param_env.and(switch_ty)).unwrap().size;\n-                values\n-                    .iter()\n-                    .map(|&u| {\n-                        ty::Const::from_scalar(tcx, Scalar::from_uint(u, size), switch_ty)\n-                            .to_string()\n-                            .into()\n-                    })\n-                    .chain(iter::once(\"otherwise\".into()))\n-                    .collect()\n-            }),\n-            Call { destination: Some(_), cleanup: Some(_), .. } => {\n-                vec![\"return\".into(), \"unwind\".into()]\n-            }\n-            Call { destination: Some(_), cleanup: None, .. } => vec![\"return\".into()],\n-            Call { destination: None, cleanup: Some(_), .. } => vec![\"unwind\".into()],\n-            Call { destination: None, cleanup: None, .. } => vec![],\n-            Yield { drop: Some(_), .. } => vec![\"resume\".into(), \"drop\".into()],\n-            Yield { drop: None, .. } => vec![\"resume\".into()],\n-            DropAndReplace { unwind: None, .. } | Drop { unwind: None, .. } => {\n-                vec![\"return\".into()]\n-            }\n-            DropAndReplace { unwind: Some(_), .. } | Drop { unwind: Some(_), .. } => {\n-                vec![\"return\".into(), \"unwind\".into()]\n-            }\n-            Assert { cleanup: None, .. } => vec![\"\".into()],\n-            Assert { .. } => vec![\"success\".into(), \"unwind\".into()],\n-            FalseEdge { .. } => vec![\"real\".into(), \"imaginary\".into()],\n-            FalseUnwind { unwind: Some(_), .. } => vec![\"real\".into(), \"cleanup\".into()],\n-            FalseUnwind { unwind: None, .. } => vec![\"real\".into()],\n-            InlineAsm { destination: Some(_), .. } => vec![\"\".into()],\n-            InlineAsm { destination: None, .. } => vec![],\n-        }\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Statements\n "}, {"sha": "1f5041141d55b93420b81cf1d3246928b6192bde", "filename": "src/librustc_middle/mir/terminator/mod.rs", "status": "added", "additions": 507, "deletions": 0, "changes": 507, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_middle%2Fmir%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_middle%2Fmir%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fterminator%2Fmod.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -0,0 +1,507 @@\n+use crate::mir::interpret::Scalar;\n+use crate::ty::{self, Ty, TyCtxt};\n+use rustc_ast::ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n+\n+use super::{\n+    AssertMessage, BasicBlock, InlineAsmOperand, Operand, Place, SourceInfo, Successors,\n+    SuccessorsMut,\n+};\n+pub use rustc_ast::ast::Mutability;\n+use rustc_macros::HashStable;\n+use rustc_span::Span;\n+use std::borrow::Cow;\n+use std::fmt::{self, Debug, Formatter, Write};\n+use std::iter;\n+use std::slice;\n+\n+pub use super::query::*;\n+\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable, PartialEq)]\n+pub enum TerminatorKind<'tcx> {\n+    /// Block should have one successor in the graph; we jump there.\n+    Goto { target: BasicBlock },\n+\n+    /// Operand evaluates to an integer; jump depending on its value\n+    /// to one of the targets, and otherwise fallback to `otherwise`.\n+    SwitchInt {\n+        /// The discriminant value being tested.\n+        discr: Operand<'tcx>,\n+\n+        /// The type of value being tested.\n+        /// This is always the same as the type of `discr`.\n+        /// FIXME: remove this redundant information. Currently, it is relied on by pretty-printing.\n+        switch_ty: Ty<'tcx>,\n+\n+        /// Possible values. The locations to branch to in each case\n+        /// are found in the corresponding indices from the `targets` vector.\n+        values: Cow<'tcx, [u128]>,\n+\n+        /// Possible branch sites. The last element of this vector is used\n+        /// for the otherwise branch, so targets.len() == values.len() + 1\n+        /// should hold.\n+        //\n+        // This invariant is quite non-obvious and also could be improved.\n+        // One way to make this invariant is to have something like this instead:\n+        //\n+        // branches: Vec<(ConstInt, BasicBlock)>,\n+        // otherwise: Option<BasicBlock> // exhaustive if None\n+        //\n+        // However we\u2019ve decided to keep this as-is until we figure a case\n+        // where some other approach seems to be strictly better than other.\n+        targets: Vec<BasicBlock>,\n+    },\n+\n+    /// Indicates that the landing pad is finished and unwinding should\n+    /// continue. Emitted by `build::scope::diverge_cleanup`.\n+    Resume,\n+\n+    /// Indicates that the landing pad is finished and that the process\n+    /// should abort. Used to prevent unwinding for foreign items.\n+    Abort,\n+\n+    /// Indicates a normal return. The return place should have\n+    /// been filled in before this executes. This can occur multiple times\n+    /// in different basic blocks.\n+    Return,\n+\n+    /// Indicates a terminator that can never be reached.\n+    Unreachable,\n+\n+    /// Drop the `Place`.\n+    Drop { place: Place<'tcx>, target: BasicBlock, unwind: Option<BasicBlock> },\n+\n+    /// Drop the `Place` and assign the new value over it. This ensures\n+    /// that the assignment to `P` occurs *even if* the destructor for\n+    /// place unwinds. Its semantics are best explained by the\n+    /// elaboration:\n+    ///\n+    /// ```\n+    /// BB0 {\n+    ///   DropAndReplace(P <- V, goto BB1, unwind BB2)\n+    /// }\n+    /// ```\n+    ///\n+    /// becomes\n+    ///\n+    /// ```\n+    /// BB0 {\n+    ///   Drop(P, goto BB1, unwind BB2)\n+    /// }\n+    /// BB1 {\n+    ///   // P is now uninitialized\n+    ///   P <- V\n+    /// }\n+    /// BB2 {\n+    ///   // P is now uninitialized -- its dtor panicked\n+    ///   P <- V\n+    /// }\n+    /// ```\n+    DropAndReplace {\n+        place: Place<'tcx>,\n+        value: Operand<'tcx>,\n+        target: BasicBlock,\n+        unwind: Option<BasicBlock>,\n+    },\n+\n+    /// Block ends with a call of a converging function.\n+    Call {\n+        /// The function that\u2019s being called.\n+        func: Operand<'tcx>,\n+        /// Arguments the function is called with.\n+        /// These are owned by the callee, which is free to modify them.\n+        /// This allows the memory occupied by \"by-value\" arguments to be\n+        /// reused across function calls without duplicating the contents.\n+        args: Vec<Operand<'tcx>>,\n+        /// Destination for the return value. If some, the call is converging.\n+        destination: Option<(Place<'tcx>, BasicBlock)>,\n+        /// Cleanups to be done if the call unwinds.\n+        cleanup: Option<BasicBlock>,\n+        /// `true` if this is from a call in HIR rather than from an overloaded\n+        /// operator. True for overloaded function call.\n+        from_hir_call: bool,\n+        /// This `Span` is the span of the function, without the dot and receiver\n+        /// (e.g. `foo(a, b)` in `x.foo(a, b)`\n+        fn_span: Span,\n+    },\n+\n+    /// Jump to the target if the condition has the expected value,\n+    /// otherwise panic with a message and a cleanup target.\n+    Assert {\n+        cond: Operand<'tcx>,\n+        expected: bool,\n+        msg: AssertMessage<'tcx>,\n+        target: BasicBlock,\n+        cleanup: Option<BasicBlock>,\n+    },\n+\n+    /// A suspend point.\n+    Yield {\n+        /// The value to return.\n+        value: Operand<'tcx>,\n+        /// Where to resume to.\n+        resume: BasicBlock,\n+        /// The place to store the resume argument in.\n+        resume_arg: Place<'tcx>,\n+        /// Cleanup to be done if the generator is dropped at this suspend point.\n+        drop: Option<BasicBlock>,\n+    },\n+\n+    /// Indicates the end of the dropping of a generator.\n+    GeneratorDrop,\n+\n+    /// A block where control flow only ever takes one real path, but borrowck\n+    /// needs to be more conservative.\n+    FalseEdge {\n+        /// The target normal control flow will take.\n+        real_target: BasicBlock,\n+        /// A block control flow could conceptually jump to, but won't in\n+        /// practice.\n+        imaginary_target: BasicBlock,\n+    },\n+    /// A terminator for blocks that only take one path in reality, but where we\n+    /// reserve the right to unwind in borrowck, even if it won't happen in practice.\n+    /// This can arise in infinite loops with no function calls for example.\n+    FalseUnwind {\n+        /// The target normal control flow will take.\n+        real_target: BasicBlock,\n+        /// The imaginary cleanup block link. This particular path will never be taken\n+        /// in practice, but in order to avoid fragility we want to always\n+        /// consider it in borrowck. We don't want to accept programs which\n+        /// pass borrowck only when `panic=abort` or some assertions are disabled\n+        /// due to release vs. debug mode builds. This needs to be an `Option` because\n+        /// of the `remove_noop_landing_pads` and `no_landing_pads` passes.\n+        unwind: Option<BasicBlock>,\n+    },\n+\n+    /// Block ends with an inline assembly block. This is a terminator since\n+    /// inline assembly is allowed to diverge.\n+    InlineAsm {\n+        /// The template for the inline assembly, with placeholders.\n+        template: &'tcx [InlineAsmTemplatePiece],\n+\n+        /// The operands for the inline assembly, as `Operand`s or `Place`s.\n+        operands: Vec<InlineAsmOperand<'tcx>>,\n+\n+        /// Miscellaneous options for the inline assembly.\n+        options: InlineAsmOptions,\n+\n+        /// Source spans for each line of the inline assembly code. These are\n+        /// used to map assembler errors back to the line in the source code.\n+        line_spans: &'tcx [Span],\n+\n+        /// Destination block after the inline assembly returns, unless it is\n+        /// diverging (InlineAsmOptions::NORETURN).\n+        destination: Option<BasicBlock>,\n+    },\n+}\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+pub struct Terminator<'tcx> {\n+    pub source_info: SourceInfo,\n+    pub kind: TerminatorKind<'tcx>,\n+}\n+\n+impl<'tcx> Terminator<'tcx> {\n+    pub fn successors(&self) -> Successors<'_> {\n+        self.kind.successors()\n+    }\n+\n+    pub fn successors_mut(&mut self) -> SuccessorsMut<'_> {\n+        self.kind.successors_mut()\n+    }\n+\n+    pub fn unwind(&self) -> Option<&Option<BasicBlock>> {\n+        self.kind.unwind()\n+    }\n+\n+    pub fn unwind_mut(&mut self) -> Option<&mut Option<BasicBlock>> {\n+        self.kind.unwind_mut()\n+    }\n+}\n+\n+impl<'tcx> TerminatorKind<'tcx> {\n+    pub fn if_(\n+        tcx: TyCtxt<'tcx>,\n+        cond: Operand<'tcx>,\n+        t: BasicBlock,\n+        f: BasicBlock,\n+    ) -> TerminatorKind<'tcx> {\n+        static BOOL_SWITCH_FALSE: &[u128] = &[0];\n+        TerminatorKind::SwitchInt {\n+            discr: cond,\n+            switch_ty: tcx.types.bool,\n+            values: From::from(BOOL_SWITCH_FALSE),\n+            targets: vec![f, t],\n+        }\n+    }\n+\n+    pub fn successors(&self) -> Successors<'_> {\n+        use self::TerminatorKind::*;\n+        match *self {\n+            Resume\n+            | Abort\n+            | GeneratorDrop\n+            | Return\n+            | Unreachable\n+            | Call { destination: None, cleanup: None, .. }\n+            | InlineAsm { destination: None, .. } => None.into_iter().chain(&[]),\n+            Goto { target: ref t }\n+            | Call { destination: None, cleanup: Some(ref t), .. }\n+            | Call { destination: Some((_, ref t)), cleanup: None, .. }\n+            | Yield { resume: ref t, drop: None, .. }\n+            | DropAndReplace { target: ref t, unwind: None, .. }\n+            | Drop { target: ref t, unwind: None, .. }\n+            | Assert { target: ref t, cleanup: None, .. }\n+            | FalseUnwind { real_target: ref t, unwind: None }\n+            | InlineAsm { destination: Some(ref t), .. } => Some(t).into_iter().chain(&[]),\n+            Call { destination: Some((_, ref t)), cleanup: Some(ref u), .. }\n+            | Yield { resume: ref t, drop: Some(ref u), .. }\n+            | DropAndReplace { target: ref t, unwind: Some(ref u), .. }\n+            | Drop { target: ref t, unwind: Some(ref u), .. }\n+            | Assert { target: ref t, cleanup: Some(ref u), .. }\n+            | FalseUnwind { real_target: ref t, unwind: Some(ref u) } => {\n+                Some(t).into_iter().chain(slice::from_ref(u))\n+            }\n+            SwitchInt { ref targets, .. } => None.into_iter().chain(&targets[..]),\n+            FalseEdge { ref real_target, ref imaginary_target } => {\n+                Some(real_target).into_iter().chain(slice::from_ref(imaginary_target))\n+            }\n+        }\n+    }\n+\n+    pub fn successors_mut(&mut self) -> SuccessorsMut<'_> {\n+        use self::TerminatorKind::*;\n+        match *self {\n+            Resume\n+            | Abort\n+            | GeneratorDrop\n+            | Return\n+            | Unreachable\n+            | Call { destination: None, cleanup: None, .. }\n+            | InlineAsm { destination: None, .. } => None.into_iter().chain(&mut []),\n+            Goto { target: ref mut t }\n+            | Call { destination: None, cleanup: Some(ref mut t), .. }\n+            | Call { destination: Some((_, ref mut t)), cleanup: None, .. }\n+            | Yield { resume: ref mut t, drop: None, .. }\n+            | DropAndReplace { target: ref mut t, unwind: None, .. }\n+            | Drop { target: ref mut t, unwind: None, .. }\n+            | Assert { target: ref mut t, cleanup: None, .. }\n+            | FalseUnwind { real_target: ref mut t, unwind: None }\n+            | InlineAsm { destination: Some(ref mut t), .. } => Some(t).into_iter().chain(&mut []),\n+            Call { destination: Some((_, ref mut t)), cleanup: Some(ref mut u), .. }\n+            | Yield { resume: ref mut t, drop: Some(ref mut u), .. }\n+            | DropAndReplace { target: ref mut t, unwind: Some(ref mut u), .. }\n+            | Drop { target: ref mut t, unwind: Some(ref mut u), .. }\n+            | Assert { target: ref mut t, cleanup: Some(ref mut u), .. }\n+            | FalseUnwind { real_target: ref mut t, unwind: Some(ref mut u) } => {\n+                Some(t).into_iter().chain(slice::from_mut(u))\n+            }\n+            SwitchInt { ref mut targets, .. } => None.into_iter().chain(&mut targets[..]),\n+            FalseEdge { ref mut real_target, ref mut imaginary_target } => {\n+                Some(real_target).into_iter().chain(slice::from_mut(imaginary_target))\n+            }\n+        }\n+    }\n+\n+    pub fn unwind(&self) -> Option<&Option<BasicBlock>> {\n+        match *self {\n+            TerminatorKind::Goto { .. }\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Abort\n+            | TerminatorKind::Return\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::Yield { .. }\n+            | TerminatorKind::SwitchInt { .. }\n+            | TerminatorKind::FalseEdge { .. }\n+            | TerminatorKind::InlineAsm { .. } => None,\n+            TerminatorKind::Call { cleanup: ref unwind, .. }\n+            | TerminatorKind::Assert { cleanup: ref unwind, .. }\n+            | TerminatorKind::DropAndReplace { ref unwind, .. }\n+            | TerminatorKind::Drop { ref unwind, .. }\n+            | TerminatorKind::FalseUnwind { ref unwind, .. } => Some(unwind),\n+        }\n+    }\n+\n+    pub fn unwind_mut(&mut self) -> Option<&mut Option<BasicBlock>> {\n+        match *self {\n+            TerminatorKind::Goto { .. }\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Abort\n+            | TerminatorKind::Return\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::Yield { .. }\n+            | TerminatorKind::SwitchInt { .. }\n+            | TerminatorKind::FalseEdge { .. }\n+            | TerminatorKind::InlineAsm { .. } => None,\n+            TerminatorKind::Call { cleanup: ref mut unwind, .. }\n+            | TerminatorKind::Assert { cleanup: ref mut unwind, .. }\n+            | TerminatorKind::DropAndReplace { ref mut unwind, .. }\n+            | TerminatorKind::Drop { ref mut unwind, .. }\n+            | TerminatorKind::FalseUnwind { ref mut unwind, .. } => Some(unwind),\n+        }\n+    }\n+}\n+\n+impl<'tcx> Debug for TerminatorKind<'tcx> {\n+    fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n+        self.fmt_head(fmt)?;\n+        let successor_count = self.successors().count();\n+        let labels = self.fmt_successor_labels();\n+        assert_eq!(successor_count, labels.len());\n+\n+        match successor_count {\n+            0 => Ok(()),\n+\n+            1 => write!(fmt, \" -> {:?}\", self.successors().next().unwrap()),\n+\n+            _ => {\n+                write!(fmt, \" -> [\")?;\n+                for (i, target) in self.successors().enumerate() {\n+                    if i > 0 {\n+                        write!(fmt, \", \")?;\n+                    }\n+                    write!(fmt, \"{}: {:?}\", labels[i], target)?;\n+                }\n+                write!(fmt, \"]\")\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> TerminatorKind<'tcx> {\n+    /// Writes the \"head\" part of the terminator; that is, its name and the data it uses to pick the\n+    /// successor basic block, if any. The only information not included is the list of possible\n+    /// successors, which may be rendered differently between the text and the graphviz format.\n+    pub fn fmt_head<W: Write>(&self, fmt: &mut W) -> fmt::Result {\n+        use self::TerminatorKind::*;\n+        match self {\n+            Goto { .. } => write!(fmt, \"goto\"),\n+            SwitchInt { discr, .. } => write!(fmt, \"switchInt({:?})\", discr),\n+            Return => write!(fmt, \"return\"),\n+            GeneratorDrop => write!(fmt, \"generator_drop\"),\n+            Resume => write!(fmt, \"resume\"),\n+            Abort => write!(fmt, \"abort\"),\n+            Yield { value, resume_arg, .. } => write!(fmt, \"{:?} = yield({:?})\", resume_arg, value),\n+            Unreachable => write!(fmt, \"unreachable\"),\n+            Drop { place, .. } => write!(fmt, \"drop({:?})\", place),\n+            DropAndReplace { place, value, .. } => {\n+                write!(fmt, \"replace({:?} <- {:?})\", place, value)\n+            }\n+            Call { func, args, destination, .. } => {\n+                if let Some((destination, _)) = destination {\n+                    write!(fmt, \"{:?} = \", destination)?;\n+                }\n+                write!(fmt, \"{:?}(\", func)?;\n+                for (index, arg) in args.iter().enumerate() {\n+                    if index > 0 {\n+                        write!(fmt, \", \")?;\n+                    }\n+                    write!(fmt, \"{:?}\", arg)?;\n+                }\n+                write!(fmt, \")\")\n+            }\n+            Assert { cond, expected, msg, .. } => {\n+                write!(fmt, \"assert(\")?;\n+                if !expected {\n+                    write!(fmt, \"!\")?;\n+                }\n+                write!(fmt, \"{:?}, \", cond)?;\n+                msg.fmt_assert_args(fmt)?;\n+                write!(fmt, \")\")\n+            }\n+            FalseEdge { .. } => write!(fmt, \"falseEdge\"),\n+            FalseUnwind { .. } => write!(fmt, \"falseUnwind\"),\n+            InlineAsm { template, ref operands, options, .. } => {\n+                write!(fmt, \"asm!(\\\"{}\\\"\", InlineAsmTemplatePiece::to_string(template))?;\n+                for op in operands {\n+                    write!(fmt, \", \")?;\n+                    let print_late = |&late| if late { \"late\" } else { \"\" };\n+                    match op {\n+                        InlineAsmOperand::In { reg, value } => {\n+                            write!(fmt, \"in({}) {:?}\", reg, value)?;\n+                        }\n+                        InlineAsmOperand::Out { reg, late, place: Some(place) } => {\n+                            write!(fmt, \"{}out({}) {:?}\", print_late(late), reg, place)?;\n+                        }\n+                        InlineAsmOperand::Out { reg, late, place: None } => {\n+                            write!(fmt, \"{}out({}) _\", print_late(late), reg)?;\n+                        }\n+                        InlineAsmOperand::InOut {\n+                            reg,\n+                            late,\n+                            in_value,\n+                            out_place: Some(out_place),\n+                        } => {\n+                            write!(\n+                                fmt,\n+                                \"in{}out({}) {:?} => {:?}\",\n+                                print_late(late),\n+                                reg,\n+                                in_value,\n+                                out_place\n+                            )?;\n+                        }\n+                        InlineAsmOperand::InOut { reg, late, in_value, out_place: None } => {\n+                            write!(fmt, \"in{}out({}) {:?} => _\", print_late(late), reg, in_value)?;\n+                        }\n+                        InlineAsmOperand::Const { value } => {\n+                            write!(fmt, \"const {:?}\", value)?;\n+                        }\n+                        InlineAsmOperand::SymFn { value } => {\n+                            write!(fmt, \"sym_fn {:?}\", value)?;\n+                        }\n+                        InlineAsmOperand::SymStatic { def_id } => {\n+                            write!(fmt, \"sym_static {:?}\", def_id)?;\n+                        }\n+                    }\n+                }\n+                write!(fmt, \", options({:?}))\", options)\n+            }\n+        }\n+    }\n+\n+    /// Returns the list of labels for the edges to the successor basic blocks.\n+    pub fn fmt_successor_labels(&self) -> Vec<Cow<'static, str>> {\n+        use self::TerminatorKind::*;\n+        match *self {\n+            Return | Resume | Abort | Unreachable | GeneratorDrop => vec![],\n+            Goto { .. } => vec![\"\".into()],\n+            SwitchInt { ref values, switch_ty, .. } => ty::tls::with(|tcx| {\n+                let param_env = ty::ParamEnv::empty();\n+                let switch_ty = tcx.lift(&switch_ty).unwrap();\n+                let size = tcx.layout_of(param_env.and(switch_ty)).unwrap().size;\n+                values\n+                    .iter()\n+                    .map(|&u| {\n+                        ty::Const::from_scalar(tcx, Scalar::from_uint(u, size), switch_ty)\n+                            .to_string()\n+                            .into()\n+                    })\n+                    .chain(iter::once(\"otherwise\".into()))\n+                    .collect()\n+            }),\n+            Call { destination: Some(_), cleanup: Some(_), .. } => {\n+                vec![\"return\".into(), \"unwind\".into()]\n+            }\n+            Call { destination: Some(_), cleanup: None, .. } => vec![\"return\".into()],\n+            Call { destination: None, cleanup: Some(_), .. } => vec![\"unwind\".into()],\n+            Call { destination: None, cleanup: None, .. } => vec![],\n+            Yield { drop: Some(_), .. } => vec![\"resume\".into(), \"drop\".into()],\n+            Yield { drop: None, .. } => vec![\"resume\".into()],\n+            DropAndReplace { unwind: None, .. } | Drop { unwind: None, .. } => {\n+                vec![\"return\".into()]\n+            }\n+            DropAndReplace { unwind: Some(_), .. } | Drop { unwind: Some(_), .. } => {\n+                vec![\"return\".into(), \"unwind\".into()]\n+            }\n+            Assert { cleanup: None, .. } => vec![\"\".into()],\n+            Assert { .. } => vec![\"success\".into(), \"unwind\".into()],\n+            FalseEdge { .. } => vec![\"real\".into(), \"imaginary\".into()],\n+            FalseUnwind { unwind: Some(_), .. } => vec![\"real\".into(), \"cleanup\".into()],\n+            FalseUnwind { unwind: None, .. } => vec![\"real\".into()],\n+            InlineAsm { destination: Some(_), .. } => vec![\"\".into()],\n+            InlineAsm { destination: None, .. } => vec![],\n+        }\n+    }\n+}"}, {"sha": "4693a2f66fb4ccfef2522681a9e436c82a38b916", "filename": "src/librustc_middle/ty/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_middle%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_middle%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2F_match.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -46,8 +46,8 @@ impl TypeRelation<'tcx> for Match<'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T> {\n         self.relate(a, b)\n     }\n@@ -112,8 +112,8 @@ impl TypeRelation<'tcx> for Match<'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>,"}, {"sha": "30ff5a2d9ebdfcd660dbd4c48eee1971204471d5", "filename": "src/librustc_middle/ty/error.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_middle%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_middle%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ferror.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -57,7 +57,6 @@ pub enum TypeError<'tcx> {\n     /// type).\n     CyclicTy(Ty<'tcx>),\n     ProjectionMismatched(ExpectedFound<DefId>),\n-    ProjectionBoundsLength(ExpectedFound<usize>),\n     ExistentialMismatch(ExpectedFound<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>),\n     ObjectUnsafeCoercion(DefId),\n     ConstMismatch(ExpectedFound<&'tcx ty::Const<'tcx>>),\n@@ -174,13 +173,6 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n                     tcx.def_path_str(values.found)\n                 )\n             }),\n-            ProjectionBoundsLength(ref values) => write!(\n-                f,\n-                \"expected {} associated type binding{}, found {}\",\n-                values.expected,\n-                pluralize!(values.expected),\n-                values.found\n-            ),\n             ExistentialMismatch(ref values) => report_maybe_different(\n                 f,\n                 &format!(\"trait `{}`\", values.expected),\n@@ -216,7 +208,6 @@ impl<'tcx> TypeError<'tcx> {\n             | RegionsPlaceholderMismatch\n             | Traits(_)\n             | ProjectionMismatched(_)\n-            | ProjectionBoundsLength(_)\n             | ExistentialMismatch(_)\n             | ConstMismatch(_)\n             | IntrinsicCast"}, {"sha": "0e86fcf53b247e0d460ab171e3ab18d45e5f73d5", "filename": "src/librustc_middle/ty/flags.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_middle%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_middle%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fflags.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -88,13 +88,13 @@ impl FlagComputation {\n                 self.add_substs(substs);\n             }\n \n-            &ty::GeneratorWitness(ref ts) => {\n+            &ty::GeneratorWitness(ts) => {\n                 let mut computation = FlagComputation::new();\n-                computation.add_tys(&ts.skip_binder()[..]);\n+                computation.add_tys(ts.skip_binder());\n                 self.add_bound_computation(computation);\n             }\n \n-            &ty::Closure(_, ref substs) => {\n+            &ty::Closure(_, substs) => {\n                 self.add_substs(substs);\n             }\n \n@@ -122,7 +122,7 @@ impl FlagComputation {\n                 self.add_substs(substs);\n             }\n \n-            &ty::Projection(ref data) => {\n+            &ty::Projection(data) => {\n                 self.add_flags(TypeFlags::HAS_TY_PROJECTION);\n                 self.add_projection_ty(data);\n             }\n@@ -211,7 +211,7 @@ impl FlagComputation {\n \n                 self.add_bound_computation(computation);\n             }\n-            ty::PredicateKind::Projection(projection) => {\n+            &ty::PredicateKind::Projection(projection) => {\n                 let mut computation = FlagComputation::new();\n                 let ty::ProjectionPredicate { projection_ty, ty } = projection.skip_binder();\n                 computation.add_projection_ty(projection_ty);\n@@ -298,7 +298,7 @@ impl FlagComputation {\n         self.add_ty(projection.ty);\n     }\n \n-    fn add_projection_ty(&mut self, projection_ty: &ty::ProjectionTy<'_>) {\n+    fn add_projection_ty(&mut self, projection_ty: ty::ProjectionTy<'_>) {\n         self.add_substs(projection_ty.substs);\n     }\n "}, {"sha": "492f8ce9ef1a9d1afd832535d5a91b7a7edf1b35", "filename": "src/librustc_middle/ty/fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_middle%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_middle%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ffold.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -336,7 +336,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         {\n             fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> bool {\n                 self.outer_index.shift_in(1);\n-                let result = t.skip_binder().visit_with(self);\n+                let result = t.as_ref().skip_binder().visit_with(self);\n                 self.outer_index.shift_out(1);\n                 result\n             }\n@@ -558,7 +558,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let fld_c = |bound_ct, ty| {\n             self.mk_const(ty::Const { val: ty::ConstKind::Bound(ty::INNERMOST, bound_ct), ty })\n         };\n-        self.replace_escaping_bound_vars(value.skip_binder(), fld_r, fld_t, fld_c)\n+        self.replace_escaping_bound_vars(value.as_ref().skip_binder(), fld_r, fld_t, fld_c)\n     }\n \n     /// Replaces all escaping bound vars. The `fld_r` closure replaces escaping\n@@ -617,7 +617,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         H: FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::Const<'tcx>,\n         T: TypeFoldable<'tcx>,\n     {\n-        self.replace_escaping_bound_vars(value.skip_binder(), fld_r, fld_t, fld_c)\n+        self.replace_escaping_bound_vars(value.as_ref().skip_binder(), fld_r, fld_t, fld_c)\n     }\n \n     /// Replaces any late-bound regions bound in `value` with\n@@ -673,7 +673,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         T: TypeFoldable<'tcx>,\n     {\n         let mut collector = LateBoundRegionsCollector::new(just_constraint);\n-        let result = value.skip_binder().visit_with(&mut collector);\n+        let result = value.as_ref().skip_binder().visit_with(&mut collector);\n         assert!(!result); // should never have stopped early\n         collector.regions\n     }"}, {"sha": "39b8566e7a873a0d9f50d27c02084880babe2428", "filename": "src/librustc_middle/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_middle%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_middle%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flayout.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -2303,7 +2303,7 @@ impl<'tcx> ty::Instance<'tcx> {\n \n                 let env_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n                 sig.map_bound(|sig| tcx.mk_fn_sig(\n-                    iter::once(*env_ty.skip_binder()).chain(sig.inputs().iter().cloned()),\n+                    iter::once(env_ty.skip_binder()).chain(sig.inputs().iter().cloned()),\n                     sig.output(),\n                     sig.c_variadic,\n                     sig.unsafety,"}, {"sha": "9fa1260f64d7407e8db9de792e944b409dd56f09", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -189,7 +189,7 @@ pub trait PrettyPrinter<'tcx>:\n     where\n         T: Print<'tcx, Self, Output = Self, Error = Self::Error> + TypeFoldable<'tcx>,\n     {\n-        value.skip_binder().print(self)\n+        value.as_ref().skip_binder().print(self)\n     }\n \n     /// Prints comma-separated elements."}, {"sha": "cee04ce8c6a831f62212f0b73c461acacad8af27", "filename": "src/librustc_middle/ty/relate.rs", "status": "modified", "additions": 90, "deletions": 136, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_middle%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_middle%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Frelate.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -13,7 +13,6 @@ use rustc_hir::def_id::DefId;\n use rustc_span::DUMMY_SP;\n use rustc_target::spec::abi;\n use std::iter;\n-use std::rc::Rc;\n \n pub type RelateResult<'tcx, T> = Result<T, TypeError<'tcx>>;\n \n@@ -42,7 +41,7 @@ pub trait TypeRelation<'tcx>: Sized {\n     }\n \n     /// Generic relation routine suitable for most anything.\n-    fn relate<T: Relate<'tcx>>(&mut self, a: &T, b: &T) -> RelateResult<'tcx, T> {\n+    fn relate<T: Relate<'tcx>>(&mut self, a: T, b: T) -> RelateResult<'tcx, T> {\n         Relate::relate(self, a, b)\n     }\n \n@@ -68,8 +67,8 @@ pub trait TypeRelation<'tcx>: Sized {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T>;\n \n     // Overridable relations. You shouldn't typically call these\n@@ -94,18 +93,18 @@ pub trait TypeRelation<'tcx>: Sized {\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>;\n }\n \n-pub trait Relate<'tcx>: TypeFoldable<'tcx> {\n+pub trait Relate<'tcx>: TypeFoldable<'tcx> + Copy {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &Self,\n-        b: &Self,\n+        a: Self,\n+        b: Self,\n     ) -> RelateResult<'tcx, Self>;\n }\n \n@@ -115,8 +114,8 @@ pub trait Relate<'tcx>: TypeFoldable<'tcx> {\n impl<'tcx> Relate<'tcx> for ty::TypeAndMut<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::TypeAndMut<'tcx>,\n-        b: &ty::TypeAndMut<'tcx>,\n+        a: ty::TypeAndMut<'tcx>,\n+        b: ty::TypeAndMut<'tcx>,\n     ) -> RelateResult<'tcx, ty::TypeAndMut<'tcx>> {\n         debug!(\"{}.mts({:?}, {:?})\", relation.tag(), a, b);\n         if a.mutbl != b.mutbl {\n@@ -127,7 +126,7 @@ impl<'tcx> Relate<'tcx> for ty::TypeAndMut<'tcx> {\n                 ast::Mutability::Not => ty::Covariant,\n                 ast::Mutability::Mut => ty::Invariant,\n             };\n-            let ty = relation.relate_with_variance(variance, &a.ty, &b.ty)?;\n+            let ty = relation.relate_with_variance(variance, a.ty, b.ty)?;\n             Ok(ty::TypeAndMut { ty, mutbl })\n         }\n     }\n@@ -143,7 +142,7 @@ pub fn relate_substs<R: TypeRelation<'tcx>>(\n \n     let params = a_subst.iter().zip(b_subst).enumerate().map(|(i, (a, b))| {\n         let variance = variances.map_or(ty::Invariant, |v| v[i]);\n-        relation.relate_with_variance(variance, &a, &b)\n+        relation.relate_with_variance(variance, a, b)\n     });\n \n     Ok(tcx.mk_substs(params)?)\n@@ -152,8 +151,8 @@ pub fn relate_substs<R: TypeRelation<'tcx>>(\n impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::FnSig<'tcx>,\n-        b: &ty::FnSig<'tcx>,\n+        a: ty::FnSig<'tcx>,\n+        b: ty::FnSig<'tcx>,\n     ) -> RelateResult<'tcx, ty::FnSig<'tcx>> {\n         let tcx = relation.tcx();\n \n@@ -164,8 +163,8 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n                 &b.c_variadic,\n             )));\n         }\n-        let unsafety = relation.relate(&a.unsafety, &b.unsafety)?;\n-        let abi = relation.relate(&a.abi, &b.abi)?;\n+        let unsafety = relation.relate(a.unsafety, b.unsafety)?;\n+        let abi = relation.relate(a.abi, b.abi)?;\n \n         if a.inputs().len() != b.inputs().len() {\n             return Err(TypeError::ArgCount);\n@@ -180,9 +179,9 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n             .chain(iter::once(((a.output(), b.output()), true)))\n             .map(|((a, b), is_output)| {\n                 if is_output {\n-                    relation.relate(&a, &b)\n+                    relation.relate(a, b)\n                 } else {\n-                    relation.relate_with_variance(ty::Contravariant, &a, &b)\n+                    relation.relate_with_variance(ty::Contravariant, a, b)\n                 }\n             });\n         Ok(ty::FnSig {\n@@ -197,32 +196,32 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n impl<'tcx> Relate<'tcx> for ast::Unsafety {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ast::Unsafety,\n-        b: &ast::Unsafety,\n+        a: ast::Unsafety,\n+        b: ast::Unsafety,\n     ) -> RelateResult<'tcx, ast::Unsafety> {\n         if a != b {\n-            Err(TypeError::UnsafetyMismatch(expected_found(relation, a, b)))\n+            Err(TypeError::UnsafetyMismatch(expected_found(relation, &a, &b)))\n         } else {\n-            Ok(*a)\n+            Ok(a)\n         }\n     }\n }\n \n impl<'tcx> Relate<'tcx> for abi::Abi {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &abi::Abi,\n-        b: &abi::Abi,\n+        a: abi::Abi,\n+        b: abi::Abi,\n     ) -> RelateResult<'tcx, abi::Abi> {\n-        if a == b { Ok(*a) } else { Err(TypeError::AbiMismatch(expected_found(relation, a, b))) }\n+        if a == b { Ok(a) } else { Err(TypeError::AbiMismatch(expected_found(relation, &a, &b))) }\n     }\n }\n \n impl<'tcx> Relate<'tcx> for ty::ProjectionTy<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::ProjectionTy<'tcx>,\n-        b: &ty::ProjectionTy<'tcx>,\n+        a: ty::ProjectionTy<'tcx>,\n+        b: ty::ProjectionTy<'tcx>,\n     ) -> RelateResult<'tcx, ty::ProjectionTy<'tcx>> {\n         if a.item_def_id != b.item_def_id {\n             Err(TypeError::ProjectionMismatched(expected_found(\n@@ -231,7 +230,7 @@ impl<'tcx> Relate<'tcx> for ty::ProjectionTy<'tcx> {\n                 &b.item_def_id,\n             )))\n         } else {\n-            let substs = relation.relate(&a.substs, &b.substs)?;\n+            let substs = relation.relate(a.substs, b.substs)?;\n             Ok(ty::ProjectionTy { item_def_id: a.item_def_id, substs: &substs })\n         }\n     }\n@@ -240,8 +239,8 @@ impl<'tcx> Relate<'tcx> for ty::ProjectionTy<'tcx> {\n impl<'tcx> Relate<'tcx> for ty::ExistentialProjection<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::ExistentialProjection<'tcx>,\n-        b: &ty::ExistentialProjection<'tcx>,\n+        a: ty::ExistentialProjection<'tcx>,\n+        b: ty::ExistentialProjection<'tcx>,\n     ) -> RelateResult<'tcx, ty::ExistentialProjection<'tcx>> {\n         if a.item_def_id != b.item_def_id {\n             Err(TypeError::ProjectionMismatched(expected_found(\n@@ -250,37 +249,18 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialProjection<'tcx> {\n                 &b.item_def_id,\n             )))\n         } else {\n-            let ty = relation.relate_with_variance(ty::Invariant, &a.ty, &b.ty)?;\n-            let substs = relation.relate_with_variance(ty::Invariant, &a.substs, &b.substs)?;\n+            let ty = relation.relate_with_variance(ty::Invariant, a.ty, b.ty)?;\n+            let substs = relation.relate_with_variance(ty::Invariant, a.substs, b.substs)?;\n             Ok(ty::ExistentialProjection { item_def_id: a.item_def_id, substs, ty })\n         }\n     }\n }\n \n-impl<'tcx> Relate<'tcx> for Vec<ty::PolyExistentialProjection<'tcx>> {\n-    fn relate<R: TypeRelation<'tcx>>(\n-        relation: &mut R,\n-        a: &Vec<ty::PolyExistentialProjection<'tcx>>,\n-        b: &Vec<ty::PolyExistentialProjection<'tcx>>,\n-    ) -> RelateResult<'tcx, Vec<ty::PolyExistentialProjection<'tcx>>> {\n-        // To be compatible, `a` and `b` must be for precisely the\n-        // same set of traits and item names. We always require that\n-        // projection bounds lists are sorted by trait-def-id and item-name,\n-        // so we can just iterate through the lists pairwise, so long as they are the\n-        // same length.\n-        if a.len() != b.len() {\n-            Err(TypeError::ProjectionBoundsLength(expected_found(relation, &a.len(), &b.len())))\n-        } else {\n-            a.iter().zip(b).map(|(a, b)| relation.relate(a, b)).collect()\n-        }\n-    }\n-}\n-\n impl<'tcx> Relate<'tcx> for ty::TraitRef<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::TraitRef<'tcx>,\n-        b: &ty::TraitRef<'tcx>,\n+        a: ty::TraitRef<'tcx>,\n+        b: ty::TraitRef<'tcx>,\n     ) -> RelateResult<'tcx, ty::TraitRef<'tcx>> {\n         // Different traits cannot be related.\n         if a.def_id != b.def_id {\n@@ -295,8 +275,8 @@ impl<'tcx> Relate<'tcx> for ty::TraitRef<'tcx> {\n impl<'tcx> Relate<'tcx> for ty::ExistentialTraitRef<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::ExistentialTraitRef<'tcx>,\n-        b: &ty::ExistentialTraitRef<'tcx>,\n+        a: ty::ExistentialTraitRef<'tcx>,\n+        b: ty::ExistentialTraitRef<'tcx>,\n     ) -> RelateResult<'tcx, ty::ExistentialTraitRef<'tcx>> {\n         // Different traits cannot be related.\n         if a.def_id != b.def_id {\n@@ -308,27 +288,27 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialTraitRef<'tcx> {\n     }\n }\n \n-#[derive(Debug, Clone, TypeFoldable)]\n+#[derive(Copy, Debug, Clone, TypeFoldable)]\n struct GeneratorWitness<'tcx>(&'tcx ty::List<Ty<'tcx>>);\n \n impl<'tcx> Relate<'tcx> for GeneratorWitness<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &GeneratorWitness<'tcx>,\n-        b: &GeneratorWitness<'tcx>,\n+        a: GeneratorWitness<'tcx>,\n+        b: GeneratorWitness<'tcx>,\n     ) -> RelateResult<'tcx, GeneratorWitness<'tcx>> {\n         assert_eq!(a.0.len(), b.0.len());\n         let tcx = relation.tcx();\n-        let types = tcx.mk_type_list(a.0.iter().zip(b.0).map(|(a, b)| relation.relate(&a, &b)))?;\n+        let types = tcx.mk_type_list(a.0.iter().zip(b.0).map(|(a, b)| relation.relate(a, b)))?;\n         Ok(GeneratorWitness(types))\n     }\n }\n \n impl<'tcx> Relate<'tcx> for Ty<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &Ty<'tcx>,\n-        b: &Ty<'tcx>,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n     ) -> RelateResult<'tcx, Ty<'tcx>> {\n         relation.tys(a, b)\n     }\n@@ -379,7 +359,7 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n \n         (&ty::Foreign(a_id), &ty::Foreign(b_id)) if a_id == b_id => Ok(tcx.mk_foreign(a_id)),\n \n-        (&ty::Dynamic(ref a_obj, ref a_region), &ty::Dynamic(ref b_obj, ref b_region)) => {\n+        (&ty::Dynamic(a_obj, a_region), &ty::Dynamic(b_obj, b_region)) => {\n             let region_bound = relation.with_cause(Cause::ExistentialRegionBound, |relation| {\n                 relation.relate_with_variance(ty::Contravariant, a_region, b_region)\n             })?;\n@@ -392,7 +372,7 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n             // All Generator types with the same id represent\n             // the (anonymous) type of the same generator expression. So\n             // all of their regions should be equated.\n-            let substs = relation.relate(&a_substs, &b_substs)?;\n+            let substs = relation.relate(a_substs, b_substs)?;\n             Ok(tcx.mk_generator(a_id, substs, movability))\n         }\n \n@@ -402,34 +382,34 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n             let a_types = a_types.map_bound(GeneratorWitness);\n             let b_types = b_types.map_bound(GeneratorWitness);\n             // Then remove the GeneratorWitness for the result\n-            let types = relation.relate(&a_types, &b_types)?.map_bound(|witness| witness.0);\n+            let types = relation.relate(a_types, b_types)?.map_bound(|witness| witness.0);\n             Ok(tcx.mk_generator_witness(types))\n         }\n \n         (&ty::Closure(a_id, a_substs), &ty::Closure(b_id, b_substs)) if a_id == b_id => {\n             // All Closure types with the same id represent\n             // the (anonymous) type of the same closure expression. So\n             // all of their regions should be equated.\n-            let substs = relation.relate(&a_substs, &b_substs)?;\n+            let substs = relation.relate(a_substs, b_substs)?;\n             Ok(tcx.mk_closure(a_id, &substs))\n         }\n \n-        (&ty::RawPtr(ref a_mt), &ty::RawPtr(ref b_mt)) => {\n+        (&ty::RawPtr(a_mt), &ty::RawPtr(b_mt)) => {\n             let mt = relation.relate(a_mt, b_mt)?;\n             Ok(tcx.mk_ptr(mt))\n         }\n \n         (&ty::Ref(a_r, a_ty, a_mutbl), &ty::Ref(b_r, b_ty, b_mutbl)) => {\n-            let r = relation.relate_with_variance(ty::Contravariant, &a_r, &b_r)?;\n+            let r = relation.relate_with_variance(ty::Contravariant, a_r, b_r)?;\n             let a_mt = ty::TypeAndMut { ty: a_ty, mutbl: a_mutbl };\n             let b_mt = ty::TypeAndMut { ty: b_ty, mutbl: b_mutbl };\n-            let mt = relation.relate(&a_mt, &b_mt)?;\n+            let mt = relation.relate(a_mt, b_mt)?;\n             Ok(tcx.mk_ref(r, mt))\n         }\n \n         (&ty::Array(a_t, sz_a), &ty::Array(b_t, sz_b)) => {\n-            let t = relation.relate(&a_t, &b_t)?;\n-            match relation.relate(&sz_a, &sz_b) {\n+            let t = relation.relate(a_t, b_t)?;\n+            match relation.relate(sz_a, sz_b) {\n                 Ok(sz) => Ok(tcx.mk_ty(ty::Array(t, sz))),\n                 // FIXME(#72219) Implement improved diagnostics for mismatched array\n                 // length?\n@@ -450,16 +430,14 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n         }\n \n         (&ty::Slice(a_t), &ty::Slice(b_t)) => {\n-            let t = relation.relate(&a_t, &b_t)?;\n+            let t = relation.relate(a_t, b_t)?;\n             Ok(tcx.mk_slice(t))\n         }\n \n         (&ty::Tuple(as_), &ty::Tuple(bs)) => {\n             if as_.len() == bs.len() {\n                 Ok(tcx.mk_tup(\n-                    as_.iter()\n-                        .zip(bs)\n-                        .map(|(a, b)| relation.relate(&a.expect_ty(), &b.expect_ty())),\n+                    as_.iter().zip(bs).map(|(a, b)| relation.relate(a.expect_ty(), b.expect_ty())),\n                 )?)\n             } else if !(as_.is_empty() || bs.is_empty()) {\n                 Err(TypeError::TupleSize(expected_found(relation, &as_.len(), &bs.len())))\n@@ -476,12 +454,12 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n         }\n \n         (&ty::FnPtr(a_fty), &ty::FnPtr(b_fty)) => {\n-            let fty = relation.relate(&a_fty, &b_fty)?;\n+            let fty = relation.relate(a_fty, b_fty)?;\n             Ok(tcx.mk_fn_ptr(fty))\n         }\n \n         // these two are already handled downstream in case of lazy normalization\n-        (ty::Projection(a_data), ty::Projection(b_data)) => {\n+        (&ty::Projection(a_data), &ty::Projection(b_data)) => {\n             let projection_ty = relation.relate(a_data, b_data)?;\n             Ok(tcx.mk_projection(projection_ty.item_def_id, projection_ty.substs))\n         }\n@@ -603,8 +581,8 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n             ty::ConstKind::Unevaluated(b_def_id, b_substs, b_promoted),\n         ) if a_def_id == b_def_id && a_promoted == b_promoted => {\n             let substs =\n-                relation.relate_with_variance(ty::Variance::Invariant, &a_substs, &b_substs)?;\n-            Ok(ty::ConstKind::Unevaluated(a_def_id, &substs, a_promoted))\n+                relation.relate_with_variance(ty::Variance::Invariant, a_substs, b_substs)?;\n+            Ok(ty::ConstKind::Unevaluated(a_def_id, substs, a_promoted))\n         }\n         _ => Err(TypeError::ConstMismatch(expected_found(relation, &a, &b))),\n     };\n@@ -614,8 +592,8 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &Self,\n-        b: &Self,\n+        a: Self,\n+        b: Self,\n     ) -> RelateResult<'tcx, Self> {\n         let tcx = relation.tcx();\n \n@@ -629,16 +607,16 @@ impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n         b_v.sort_by(|a, b| a.stable_cmp(tcx, b));\n         b_v.dedup();\n         if a_v.len() != b_v.len() {\n-            return Err(TypeError::ExistentialMismatch(expected_found(relation, a, b)));\n+            return Err(TypeError::ExistentialMismatch(expected_found(relation, &a, &b)));\n         }\n \n         let v = a_v.into_iter().zip(b_v.into_iter()).map(|(ep_a, ep_b)| {\n             use crate::ty::ExistentialPredicate::*;\n             match (ep_a, ep_b) {\n-                (Trait(ref a), Trait(ref b)) => Ok(Trait(relation.relate(a, b)?)),\n-                (Projection(ref a), Projection(ref b)) => Ok(Projection(relation.relate(a, b)?)),\n-                (AutoTrait(ref a), AutoTrait(ref b)) if a == b => Ok(AutoTrait(*a)),\n-                _ => Err(TypeError::ExistentialMismatch(expected_found(relation, a, b))),\n+                (Trait(a), Trait(b)) => Ok(Trait(relation.relate(a, b)?)),\n+                (Projection(a), Projection(b)) => Ok(Projection(relation.relate(a, b)?)),\n+                (AutoTrait(a), AutoTrait(b)) if a == b => Ok(AutoTrait(a)),\n+                _ => Err(TypeError::ExistentialMismatch(expected_found(relation, &a, &b))),\n             }\n         });\n         Ok(tcx.mk_existential_predicates(v)?)\n@@ -648,8 +626,8 @@ impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n impl<'tcx> Relate<'tcx> for ty::ClosureSubsts<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::ClosureSubsts<'tcx>,\n-        b: &ty::ClosureSubsts<'tcx>,\n+        a: ty::ClosureSubsts<'tcx>,\n+        b: ty::ClosureSubsts<'tcx>,\n     ) -> RelateResult<'tcx, ty::ClosureSubsts<'tcx>> {\n         let substs = relate_substs(relation, None, a.substs, b.substs)?;\n         Ok(ty::ClosureSubsts { substs })\n@@ -659,8 +637,8 @@ impl<'tcx> Relate<'tcx> for ty::ClosureSubsts<'tcx> {\n impl<'tcx> Relate<'tcx> for ty::GeneratorSubsts<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::GeneratorSubsts<'tcx>,\n-        b: &ty::GeneratorSubsts<'tcx>,\n+        a: ty::GeneratorSubsts<'tcx>,\n+        b: ty::GeneratorSubsts<'tcx>,\n     ) -> RelateResult<'tcx, ty::GeneratorSubsts<'tcx>> {\n         let substs = relate_substs(relation, None, a.substs, b.substs)?;\n         Ok(ty::GeneratorSubsts { substs })\n@@ -670,8 +648,8 @@ impl<'tcx> Relate<'tcx> for ty::GeneratorSubsts<'tcx> {\n impl<'tcx> Relate<'tcx> for SubstsRef<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &SubstsRef<'tcx>,\n-        b: &SubstsRef<'tcx>,\n+        a: SubstsRef<'tcx>,\n+        b: SubstsRef<'tcx>,\n     ) -> RelateResult<'tcx, SubstsRef<'tcx>> {\n         relate_substs(relation, None, a, b)\n     }\n@@ -680,72 +658,48 @@ impl<'tcx> Relate<'tcx> for SubstsRef<'tcx> {\n impl<'tcx> Relate<'tcx> for ty::Region<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::Region<'tcx>,\n-        b: &ty::Region<'tcx>,\n+        a: ty::Region<'tcx>,\n+        b: ty::Region<'tcx>,\n     ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n-        relation.regions(*a, *b)\n+        relation.regions(a, b)\n     }\n }\n \n impl<'tcx> Relate<'tcx> for &'tcx ty::Const<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &&'tcx ty::Const<'tcx>,\n-        b: &&'tcx ty::Const<'tcx>,\n+        a: &'tcx ty::Const<'tcx>,\n+        b: &'tcx ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n-        relation.consts(*a, *b)\n+        relation.consts(a, b)\n     }\n }\n \n impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for ty::Binder<T> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>> {\n         relation.binders(a, b)\n     }\n }\n \n-impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for Rc<T> {\n-    fn relate<R: TypeRelation<'tcx>>(\n-        relation: &mut R,\n-        a: &Rc<T>,\n-        b: &Rc<T>,\n-    ) -> RelateResult<'tcx, Rc<T>> {\n-        let a: &T = a;\n-        let b: &T = b;\n-        Ok(Rc::new(relation.relate(a, b)?))\n-    }\n-}\n-\n-impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for Box<T> {\n-    fn relate<R: TypeRelation<'tcx>>(\n-        relation: &mut R,\n-        a: &Box<T>,\n-        b: &Box<T>,\n-    ) -> RelateResult<'tcx, Box<T>> {\n-        let a: &T = a;\n-        let b: &T = b;\n-        Ok(Box::new(relation.relate(a, b)?))\n-    }\n-}\n-\n impl<'tcx> Relate<'tcx> for GenericArg<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &GenericArg<'tcx>,\n-        b: &GenericArg<'tcx>,\n+        a: GenericArg<'tcx>,\n+        b: GenericArg<'tcx>,\n     ) -> RelateResult<'tcx, GenericArg<'tcx>> {\n         match (a.unpack(), b.unpack()) {\n             (GenericArgKind::Lifetime(a_lt), GenericArgKind::Lifetime(b_lt)) => {\n-                Ok(relation.relate(&a_lt, &b_lt)?.into())\n+                Ok(relation.relate(a_lt, b_lt)?.into())\n             }\n             (GenericArgKind::Type(a_ty), GenericArgKind::Type(b_ty)) => {\n-                Ok(relation.relate(&a_ty, &b_ty)?.into())\n+                Ok(relation.relate(a_ty, b_ty)?.into())\n             }\n             (GenericArgKind::Const(a_ct), GenericArgKind::Const(b_ct)) => {\n-                Ok(relation.relate(&a_ct, &b_ct)?.into())\n+                Ok(relation.relate(a_ct, b_ct)?.into())\n             }\n             (GenericArgKind::Lifetime(unpacked), x) => {\n                 bug!(\"impossible case reached: can't relate: {:?} with {:?}\", unpacked, x)\n@@ -763,22 +717,22 @@ impl<'tcx> Relate<'tcx> for GenericArg<'tcx> {\n impl<'tcx> Relate<'tcx> for ty::TraitPredicate<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::TraitPredicate<'tcx>,\n-        b: &ty::TraitPredicate<'tcx>,\n+        a: ty::TraitPredicate<'tcx>,\n+        b: ty::TraitPredicate<'tcx>,\n     ) -> RelateResult<'tcx, ty::TraitPredicate<'tcx>> {\n-        Ok(ty::TraitPredicate { trait_ref: relation.relate(&a.trait_ref, &b.trait_ref)? })\n+        Ok(ty::TraitPredicate { trait_ref: relation.relate(a.trait_ref, b.trait_ref)? })\n     }\n }\n \n impl<'tcx> Relate<'tcx> for ty::ProjectionPredicate<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::ProjectionPredicate<'tcx>,\n-        b: &ty::ProjectionPredicate<'tcx>,\n+        a: ty::ProjectionPredicate<'tcx>,\n+        b: ty::ProjectionPredicate<'tcx>,\n     ) -> RelateResult<'tcx, ty::ProjectionPredicate<'tcx>> {\n         Ok(ty::ProjectionPredicate {\n-            projection_ty: relation.relate(&a.projection_ty, &b.projection_ty)?,\n-            ty: relation.relate(&a.ty, &b.ty)?,\n+            projection_ty: relation.relate(a.projection_ty, b.projection_ty)?,\n+            ty: relation.relate(a.ty, b.ty)?,\n         })\n     }\n }"}, {"sha": "1d3607fe32ffce570cba672a64bcf87ff6b28910", "filename": "src/librustc_middle/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -514,7 +514,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::PredicateKind<'a> {\n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::Binder<T> {\n     type Lifted = ty::Binder<T::Lifted>;\n     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(self.skip_binder()).map(ty::Binder::bind)\n+        tcx.lift(self.as_ref().skip_binder()).map(ty::Binder::bind)\n     }\n }\n \n@@ -655,7 +655,6 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             VariadicMismatch(x) => VariadicMismatch(x),\n             CyclicTy(t) => return tcx.lift(&t).map(|t| CyclicTy(t)),\n             ProjectionMismatched(x) => ProjectionMismatched(x),\n-            ProjectionBoundsLength(x) => ProjectionBoundsLength(x),\n             Sorts(ref x) => return tcx.lift(x).map(Sorts),\n             ExistentialMismatch(ref x) => return tcx.lift(x).map(ExistentialMismatch),\n             ConstMismatch(ref x) => return tcx.lift(x).map(ConstMismatch),\n@@ -798,7 +797,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.skip_binder().visit_with(visitor)\n+        self.as_ref().skip_binder().visit_with(visitor)\n     }\n \n     fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {"}, {"sha": "c7683cefd82f6a6541c65bb6a5b6b0eedb00910f", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -615,7 +615,7 @@ impl<'tcx> ExistentialPredicate<'tcx> {\n impl<'tcx> Binder<ExistentialPredicate<'tcx>> {\n     pub fn with_self_ty(&self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> ty::Predicate<'tcx> {\n         use crate::ty::ToPredicate;\n-        match *self.skip_binder() {\n+        match self.skip_binder() {\n             ExistentialPredicate::Trait(tr) => {\n                 Binder(tr).with_self_ty(tcx, self_ty).without_const().to_predicate(tcx)\n             }\n@@ -776,7 +776,7 @@ impl<'tcx> PolyTraitRef<'tcx> {\n \n     pub fn to_poly_trait_predicate(&self) -> ty::PolyTraitPredicate<'tcx> {\n         // Note that we preserve binding levels\n-        Binder(ty::TraitPredicate { trait_ref: *self.skip_binder() })\n+        Binder(ty::TraitPredicate { trait_ref: self.skip_binder() })\n     }\n }\n \n@@ -880,8 +880,8 @@ impl<T> Binder<T> {\n     /// - extracting the `DefId` from a PolyTraitRef;\n     /// - comparing the self type of a PolyTraitRef to see if it is equal to\n     ///   a type parameter `X`, since the type `X` does not reference any regions\n-    pub fn skip_binder(&self) -> &T {\n-        &self.0\n+    pub fn skip_binder(self) -> T {\n+        self.0\n     }\n \n     pub fn as_ref(&self) -> Binder<&T> {\n@@ -916,11 +916,7 @@ impl<T> Binder<T> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        if self.skip_binder().has_escaping_bound_vars() {\n-            None\n-        } else {\n-            Some(self.skip_binder().clone())\n-        }\n+        if self.0.has_escaping_bound_vars() { None } else { Some(self.skip_binder()) }\n     }\n \n     /// Given two things that have the same binder level,\n@@ -997,7 +993,7 @@ impl<'tcx> ProjectionTy<'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, TypeFoldable)]\n+#[derive(Copy, Clone, Debug, TypeFoldable)]\n pub struct GenSig<'tcx> {\n     pub resume_ty: Ty<'tcx>,\n     pub yield_ty: Ty<'tcx>,"}, {"sha": "82c649b8f543b88c22794ac1ac0e5909c54ca606", "filename": "src/librustc_middle/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_middle%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_middle%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fwalk.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -133,7 +133,7 @@ fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>)\n             ty::Dynamic(obj, lt) => {\n                 stack.push(lt.into());\n                 stack.extend(obj.iter().rev().flat_map(|predicate| {\n-                    let (substs, opt_ty) = match *predicate.skip_binder() {\n+                    let (substs, opt_ty) = match predicate.skip_binder() {\n                         ty::ExistentialPredicate::Trait(tr) => (tr.substs, None),\n                         ty::ExistentialPredicate::Projection(p) => (p.substs, Some(p.ty)),\n                         ty::ExistentialPredicate::AutoTrait(_) =>"}, {"sha": "17846055f6c9615290796c931375e39317239e59", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1923,7 +1923,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n                 // We use a mix of the HIR and the Ty types to get information\n                 // as the HIR doesn't have full types for closure arguments.\n-                let return_ty = *sig.output().skip_binder();\n+                let return_ty = sig.output().skip_binder();\n                 let mut return_span = fn_decl.output.span();\n                 if let hir::FnRetTy::Return(ty) = &fn_decl.output {\n                     if let hir::TyKind::Rptr(lifetime, _) = ty.kind {\n@@ -1965,7 +1965,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let argument_ty = sig.inputs().skip_binder().first()?;\n \n                 let return_span = fn_decl.output.span();\n-                let return_ty = *sig.output().skip_binder();\n+                let return_ty = sig.output().skip_binder();\n \n                 // We expect the first argument to be a reference.\n                 match argument_ty.kind {"}, {"sha": "26c2aea41d5dc616b9fc4953966ee7061a14b4c1", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -122,7 +122,9 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         if self.regioncx.universal_regions().is_universal_region(r) {\n             Some(r)\n         } else {\n-            let upper_bound = self.regioncx.universal_upper_bound(r);\n+            // We just want something nameable, even if it's not\n+            // actually an upper bound.\n+            let upper_bound = self.regioncx.approx_universal_upper_bound(r);\n \n             if self.regioncx.upper_bound_in_region_scc(r, upper_bound) {\n                 self.to_error_region_vid(upper_bound)"}, {"sha": "081125cb625c237a1dca978be4aa403c701412e4", "filename": "src/librustc_mir/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1114,6 +1114,40 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         lub\n     }\n \n+    /// Like `universal_upper_bound`, but returns an approximation more suitable\n+    /// for diagnostics. If `r` contains multiple disjoint universal regions\n+    /// (e.g. 'a and 'b in `fn foo<'a, 'b> { ... }`, we pick the lower-numbered region.\n+    /// This corresponds to picking named regions over unnamed regions\n+    /// (e.g. picking early-bound regions over a closure late-bound region).\n+    ///\n+    /// This means that the returned value may not be a true upper bound, since\n+    /// only 'static is known to outlive disjoint universal regions.\n+    /// Therefore, this method should only be used in diagnostic code,\n+    /// where displaying *some* named universal region is better than\n+    /// falling back to 'static.\n+    pub(in crate::borrow_check) fn approx_universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n+        debug!(\"approx_universal_upper_bound(r={:?}={})\", r, self.region_value_str(r));\n+\n+        // Find the smallest universal region that contains all other\n+        // universal regions within `region`.\n+        let mut lub = self.universal_regions.fr_fn_body;\n+        let r_scc = self.constraint_sccs.scc(r);\n+        let static_r = self.universal_regions.fr_static;\n+        for ur in self.scc_values.universal_regions_outlived_by(r_scc) {\n+            let new_lub = self.universal_region_relations.postdom_upper_bound(lub, ur);\n+            debug!(\"approx_universal_upper_bound: ur={:?} lub={:?} new_lub={:?}\", ur, lub, new_lub);\n+            if ur != static_r && lub != static_r && new_lub == static_r {\n+                lub = std::cmp::min(ur, lub);\n+            } else {\n+                lub = new_lub;\n+            }\n+        }\n+\n+        debug!(\"approx_universal_upper_bound: r={:?} lub={:?}\", r, lub);\n+\n+        lub\n+    }\n+\n     /// Tests if `test` is true when applied to `lower_bound` at\n     /// `point`.\n     fn eval_verify_bound("}, {"sha": "325dca8c8ca9997425f6f062f6e67065787ace33", "filename": "src/librustc_mir/borrow_check/region_infer/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -141,7 +141,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     {\n         tcx.fold_regions(&ty, &mut false, |region, _| match *region {\n             ty::ReVar(vid) => {\n-                let upper_bound = self.universal_upper_bound(vid);\n+                // Find something that we can name\n+                let upper_bound = self.approx_universal_upper_bound(vid);\n                 self.definitions[upper_bound].external_name.unwrap_or(region)\n             }\n             _ => region,"}, {"sha": "91b1a1fbd97059492a75221f2ed13ebe3d9f46d2", "filename": "src/librustc_mir/borrow_check/type_check/relate_tys.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Frelate_tys.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -31,7 +31,7 @@ pub(super) fn relate_types<'tcx>(\n         NllTypeRelatingDelegate::new(infcx, borrowck_context, locations, category),\n         v,\n     )\n-    .relate(&a, &b)?;\n+    .relate(a, b)?;\n     Ok(())\n }\n "}, {"sha": "01eb2d0b8e2660cde96c5468b0cd2d8fed563d05", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -409,6 +409,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 );\n                 self.copy_op(self.operand_index(args[0], index)?, dest)?;\n             }\n+            sym::likely | sym::unlikely => {\n+                // These just return their argument\n+                self.copy_op(args[0], dest)?;\n+            }\n             // FIXME(#73156): Handle source code coverage in const eval\n             sym::count_code_region => (),\n             _ => return Ok(false),"}, {"sha": "f00fc96e5915a97e368d497ce735faa328194bc3", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -531,9 +531,12 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n                 if is_lang_panic_fn(self.tcx, def_id) {\n                     self.check_op(ops::Panic);\n                 } else if let Some(feature) = is_unstable_const_fn(self.tcx, def_id) {\n-                    // Exempt unstable const fns inside of macros with\n+                    // Exempt unstable const fns inside of macros or functions with\n                     // `#[allow_internal_unstable]`.\n-                    if !self.span.allows_unstable(feature) {\n+                    use crate::transform::qualify_min_const_fn::lib_feature_allowed;\n+                    if !self.span.allows_unstable(feature)\n+                        && !lib_feature_allowed(self.tcx, self.def_id, feature)\n+                    {\n                         self.check_op(ops::FnCallUnstable(def_id, feature));\n                     }\n                 } else {"}, {"sha": "2f5257080cd5c21f26ced2787e18acffcff65cea", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -328,6 +328,26 @@ fn feature_allowed(tcx: TyCtxt<'tcx>, def_id: DefId, feature_gate: Symbol) -> bo\n         .map_or(false, |mut features| features.any(|name| name == feature_gate))\n }\n \n+/// Returns `true` if the given library feature gate is allowed within the function with the given `DefId`.\n+pub fn lib_feature_allowed(tcx: TyCtxt<'tcx>, def_id: DefId, feature_gate: Symbol) -> bool {\n+    // All features require that the corresponding gate be enabled,\n+    // even if the function has `#[allow_internal_unstable(the_gate)]`.\n+    if !tcx.features().declared_lib_features.iter().any(|&(sym, _)| sym == feature_gate) {\n+        return false;\n+    }\n+\n+    // If this crate is not using stability attributes, or this function is not claiming to be a\n+    // stable `const fn`, that is all that is required.\n+    if !tcx.features().staged_api || tcx.has_attr(def_id, sym::rustc_const_unstable) {\n+        return true;\n+    }\n+\n+    // However, we cannot allow stable `const fn`s to use unstable features without an explicit\n+    // opt-in via `allow_internal_unstable`.\n+    attr::allow_internal_unstable(&tcx.get_attrs(def_id), &tcx.sess.diagnostic())\n+        .map_or(false, |mut features| features.any(|name| name == feature_gate))\n+}\n+\n fn check_terminator(\n     tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n@@ -367,8 +387,17 @@ fn check_terminator(\n             fn_span: _,\n         } => {\n             let fn_ty = func.ty(body, tcx);\n-            if let ty::FnDef(def_id, _) = fn_ty.kind {\n-                if !crate::const_eval::is_min_const_fn(tcx, def_id) {\n+            if let ty::FnDef(fn_def_id, _) = fn_ty.kind {\n+                // Allow unstable const if we opt in by using #[allow_internal_unstable]\n+                // on function or macro declaration.\n+                if !crate::const_eval::is_min_const_fn(tcx, fn_def_id)\n+                    && !crate::const_eval::is_unstable_const_fn(tcx, fn_def_id)\n+                        .map(|feature| {\n+                            span.allows_unstable(feature)\n+                                || lib_feature_allowed(tcx, def_id, feature)\n+                        })\n+                        .unwrap_or(false)\n+                {\n                     return Err((\n                         span,\n                         format!(\n@@ -380,10 +409,10 @@ fn check_terminator(\n                     ));\n                 }\n \n-                check_operand(tcx, func, span, def_id, body)?;\n+                check_operand(tcx, func, span, fn_def_id, body)?;\n \n                 for arg in args {\n-                    check_operand(tcx, arg, span, def_id, body)?;\n+                    check_operand(tcx, arg, span, fn_def_id, body)?;\n                 }\n                 Ok(())\n             } else {"}, {"sha": "e794a6949d2f0eb5af50522f5103c460e51f8846", "filename": "src/librustc_mir/transform/validate.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -74,8 +74,8 @@ pub fn equal_up_to_regions(\n         fn relate_with_variance<T: Relate<'tcx>>(\n             &mut self,\n             _: ty::Variance,\n-            a: &T,\n-            b: &T,\n+            a: T,\n+            b: T,\n         ) -> RelateResult<'tcx, T> {\n             // Ignore variance, require types to be exactly the same.\n             self.relate(a, b)\n@@ -108,8 +108,8 @@ pub fn equal_up_to_regions(\n \n         fn binders<T>(\n             &mut self,\n-            a: &ty::Binder<T>,\n-            b: &ty::Binder<T>,\n+            a: ty::Binder<T>,\n+            b: ty::Binder<T>,\n         ) -> RelateResult<'tcx, ty::Binder<T>>\n         where\n             T: Relate<'tcx>,\n@@ -121,7 +121,7 @@ pub fn equal_up_to_regions(\n \n     // Instantiate and run relation.\n     let mut relator: LifetimeIgnoreRelation<'tcx> = LifetimeIgnoreRelation { tcx: tcx, param_env };\n-    relator.relate(&src, &dest).is_ok()\n+    relator.relate(src, dest).is_ok()\n }\n \n struct TypeChecker<'a, 'tcx> {"}, {"sha": "18b92bf29bf1b6bf5e6866ddcfb455a89bde34c9", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 99, "deletions": 98, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -4,8 +4,8 @@\n //! This file includes the logic for exhaustiveness and usefulness checking for\n //! pattern-matching. Specifically, given a list of patterns for a type, we can\n //! tell whether:\n-//! (a) the patterns cover every possible constructor for the type [exhaustiveness]\n-//! (b) each pattern is necessary [usefulness]\n+//! (a) the patterns cover every possible constructor for the type (exhaustiveness)\n+//! (b) each pattern is necessary (usefulness)\n //!\n //! The algorithm implemented here is a modified version of the one described in:\n //! http://moscova.inria.fr/~maranget/papers/warn/index.html\n@@ -101,53 +101,54 @@\n //! To match the paper, the top of the stack is at the beginning / on the left.\n //!\n //! There are two important operations on pattern-stacks necessary to understand the algorithm:\n-//!     1. We can pop a given constructor off the top of a stack. This operation is called\n-//!        `specialize`, and is denoted `S(c, p)` where `c` is a constructor (like `Some` or\n-//!        `None`) and `p` a pattern-stack.\n-//!        If the pattern on top of the stack can cover `c`, this removes the constructor and\n-//!        pushes its arguments onto the stack. It also expands OR-patterns into distinct patterns.\n-//!        Otherwise the pattern-stack is discarded.\n-//!        This essentially filters those pattern-stacks whose top covers the constructor `c` and\n-//!        discards the others.\n //!\n-//!        For example, the first pattern above initially gives a stack `[(Some(true), _)]`. If we\n-//!        pop the tuple constructor, we are left with `[Some(true), _]`, and if we then pop the\n-//!        `Some` constructor we get `[true, _]`. If we had popped `None` instead, we would get\n-//!        nothing back.\n+//! 1. We can pop a given constructor off the top of a stack. This operation is called\n+//!    `specialize`, and is denoted `S(c, p)` where `c` is a constructor (like `Some` or\n+//!    `None`) and `p` a pattern-stack.\n+//!    If the pattern on top of the stack can cover `c`, this removes the constructor and\n+//!    pushes its arguments onto the stack. It also expands OR-patterns into distinct patterns.\n+//!    Otherwise the pattern-stack is discarded.\n+//!    This essentially filters those pattern-stacks whose top covers the constructor `c` and\n+//!    discards the others.\n //!\n-//!        This returns zero or more new pattern-stacks, as follows. We look at the pattern `p_1`\n-//!        on top of the stack, and we have four cases:\n-//!             1.1. `p_1 = c(r_1, .., r_a)`, i.e. the top of the stack has constructor `c`. We\n-//!                  push onto the stack the arguments of this constructor, and return the result:\n-//!                     r_1, .., r_a, p_2, .., p_n\n-//!             1.2. `p_1 = c'(r_1, .., r_a')` where `c \u2260 c'`. We discard the current stack and\n-//!                  return nothing.\n-//!             1.3. `p_1 = _`. We push onto the stack as many wildcards as the constructor `c` has\n-//!                  arguments (its arity), and return the resulting stack:\n-//!                     _, .., _, p_2, .., p_n\n-//!             1.4. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n-//!                  stack:\n-//!                     S(c, (r_1, p_2, .., p_n))\n-//!                     S(c, (r_2, p_2, .., p_n))\n+//!    For example, the first pattern above initially gives a stack `[(Some(true), _)]`. If we\n+//!    pop the tuple constructor, we are left with `[Some(true), _]`, and if we then pop the\n+//!    `Some` constructor we get `[true, _]`. If we had popped `None` instead, we would get\n+//!    nothing back.\n //!\n-//!     2. We can pop a wildcard off the top of the stack. This is called `D(p)`, where `p` is\n-//!        a pattern-stack.\n-//!        This is used when we know there are missing constructor cases, but there might be\n-//!        existing wildcard patterns, so to check the usefulness of the matrix, we have to check\n-//!        all its *other* components.\n+//!    This returns zero or more new pattern-stacks, as follows. We look at the pattern `p_1`\n+//!    on top of the stack, and we have four cases:\n+//!         1.1. `p_1 = c(r_1, .., r_a)`, i.e. the top of the stack has constructor `c`. We\n+//!              push onto the stack the arguments of this constructor, and return the result:\n+//!                 r_1, .., r_a, p_2, .., p_n\n+//!         1.2. `p_1 = c'(r_1, .., r_a')` where `c \u2260 c'`. We discard the current stack and\n+//!              return nothing.\n+//!         1.3. `p_1 = _`. We push onto the stack as many wildcards as the constructor `c` has\n+//!              arguments (its arity), and return the resulting stack:\n+//!                 _, .., _, p_2, .., p_n\n+//!         1.4. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n+//!              stack:\n+//!                 S(c, (r_1, p_2, .., p_n))\n+//!                 S(c, (r_2, p_2, .., p_n))\n //!\n-//!        It is computed as follows. We look at the pattern `p_1` on top of the stack,\n-//!        and we have three cases:\n-//!             1.1. `p_1 = c(r_1, .., r_a)`. We discard the current stack and return nothing.\n-//!             1.2. `p_1 = _`. We return the rest of the stack:\n-//!                     p_2, .., p_n\n-//!             1.3. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n-//!               stack.\n-//!                     D((r_1, p_2, .., p_n))\n-//!                     D((r_2, p_2, .., p_n))\n+//! 2. We can pop a wildcard off the top of the stack. This is called `D(p)`, where `p` is\n+//!    a pattern-stack.\n+//!    This is used when we know there are missing constructor cases, but there might be\n+//!    existing wildcard patterns, so to check the usefulness of the matrix, we have to check\n+//!    all its *other* components.\n //!\n-//!     Note that the OR-patterns are not always used directly in Rust, but are used to derive the\n-//!     exhaustive integer matching rules, so they're written here for posterity.\n+//!    It is computed as follows. We look at the pattern `p_1` on top of the stack,\n+//!    and we have three cases:\n+//!         1.1. `p_1 = c(r_1, .., r_a)`. We discard the current stack and return nothing.\n+//!         1.2. `p_1 = _`. We return the rest of the stack:\n+//!                 p_2, .., p_n\n+//!         1.3. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n+//!           stack.\n+//!                 D((r_1, p_2, .., p_n))\n+//!                 D((r_2, p_2, .., p_n))\n+//!\n+//! Note that the OR-patterns are not always used directly in Rust, but are used to derive the\n+//! exhaustive integer matching rules, so they're written here for posterity.\n //!\n //! Both those operations extend straightforwardly to a list or pattern-stacks, i.e. a matrix, by\n //! working row-by-row. Popping a constructor ends up keeping only the matrix rows that start with\n@@ -168,66 +169,66 @@\n //!\n //! Inductive step. (`n > 0`, i.e., whether there's at least one column\n //!                  [which may then be expanded into further columns later])\n-//!     We're going to match on the top of the new pattern-stack, `p_1`.\n-//!         - If `p_1 == c(r_1, .., r_a)`, i.e. we have a constructor pattern.\n-//!           Then, the usefulness of `p_1` can be reduced to whether it is useful when\n-//!           we ignore all the patterns in the first column of `P` that involve other constructors.\n-//!           This is where `S(c, P)` comes in:\n-//!           `U(P, p) := U(S(c, P), S(c, p))`\n-//!           This special case is handled in `is_useful_specialized`.\n+//! We're going to match on the top of the new pattern-stack, `p_1`.\n+//!     - If `p_1 == c(r_1, .., r_a)`, i.e. we have a constructor pattern.\n+//! Then, the usefulness of `p_1` can be reduced to whether it is useful when\n+//! we ignore all the patterns in the first column of `P` that involve other constructors.\n+//! This is where `S(c, P)` comes in:\n+//! `U(P, p) := U(S(c, P), S(c, p))`\n+//! This special case is handled in `is_useful_specialized`.\n //!\n-//!           For example, if `P` is:\n-//!           [\n-//!               [Some(true), _],\n-//!               [None, 0],\n-//!           ]\n-//!           and `p` is [Some(false), 0], then we don't care about row 2 since we know `p` only\n-//!           matches values that row 2 doesn't. For row 1 however, we need to dig into the\n-//!           arguments of `Some` to know whether some new value is covered. So we compute\n-//!           `U([[true, _]], [false, 0])`.\n+//! For example, if `P` is:\n+//! [\n+//! [Some(true), _],\n+//! [None, 0],\n+//! ]\n+//! and `p` is [Some(false), 0], then we don't care about row 2 since we know `p` only\n+//! matches values that row 2 doesn't. For row 1 however, we need to dig into the\n+//! arguments of `Some` to know whether some new value is covered. So we compute\n+//! `U([[true, _]], [false, 0])`.\n //!\n-//!         - If `p_1 == _`, then we look at the list of constructors that appear in the first\n-//!               component of the rows of `P`:\n-//!             + If there are some constructors that aren't present, then we might think that the\n-//!               wildcard `_` is useful, since it covers those constructors that weren't covered\n-//!               before.\n-//!               That's almost correct, but only works if there were no wildcards in those first\n-//!               components. So we need to check that `p` is useful with respect to the rows that\n-//!               start with a wildcard, if there are any. This is where `D` comes in:\n-//!               `U(P, p) := U(D(P), D(p))`\n+//!   - If `p_1 == _`, then we look at the list of constructors that appear in the first\n+//! component of the rows of `P`:\n+//!   + If there are some constructors that aren't present, then we might think that the\n+//! wildcard `_` is useful, since it covers those constructors that weren't covered\n+//! before.\n+//! That's almost correct, but only works if there were no wildcards in those first\n+//! components. So we need to check that `p` is useful with respect to the rows that\n+//! start with a wildcard, if there are any. This is where `D` comes in:\n+//! `U(P, p) := U(D(P), D(p))`\n //!\n-//!               For example, if `P` is:\n-//!               [\n-//!                   [_, true, _],\n-//!                   [None, false, 1],\n-//!               ]\n-//!               and `p` is [_, false, _], the `Some` constructor doesn't appear in `P`. So if we\n-//!               only had row 2, we'd know that `p` is useful. However row 1 starts with a\n-//!               wildcard, so we need to check whether `U([[true, _]], [false, 1])`.\n+//! For example, if `P` is:\n+//! [\n+//!     [_, true, _],\n+//!     [None, false, 1],\n+//! ]\n+//! and `p` is [_, false, _], the `Some` constructor doesn't appear in `P`. So if we\n+//! only had row 2, we'd know that `p` is useful. However row 1 starts with a\n+//! wildcard, so we need to check whether `U([[true, _]], [false, 1])`.\n //!\n-//!             + Otherwise, all possible constructors (for the relevant type) are present. In this\n-//!               case we must check whether the wildcard pattern covers any unmatched value. For\n-//!               that, we can think of the `_` pattern as a big OR-pattern that covers all\n-//!               possible constructors. For `Option`, that would mean `_ = None | Some(_)` for\n-//!               example. The wildcard pattern is useful in this case if it is useful when\n-//!               specialized to one of the possible constructors. So we compute:\n-//!               `U(P, p) := \u2203(k \u03f5 constructors) U(S(k, P), S(k, p))`\n+//!   + Otherwise, all possible constructors (for the relevant type) are present. In this\n+//! case we must check whether the wildcard pattern covers any unmatched value. For\n+//! that, we can think of the `_` pattern as a big OR-pattern that covers all\n+//! possible constructors. For `Option`, that would mean `_ = None | Some(_)` for\n+//! example. The wildcard pattern is useful in this case if it is useful when\n+//! specialized to one of the possible constructors. So we compute:\n+//! `U(P, p) := \u2203(k \u03f5 constructors) U(S(k, P), S(k, p))`\n //!\n-//!               For example, if `P` is:\n-//!               [\n-//!                   [Some(true), _],\n-//!                   [None, false],\n-//!               ]\n-//!               and `p` is [_, false], both `None` and `Some` constructors appear in the first\n-//!               components of `P`. We will therefore try popping both constructors in turn: we\n-//!               compute U([[true, _]], [_, false]) for the `Some` constructor, and U([[false]],\n-//!               [false]) for the `None` constructor. The first case returns true, so we know that\n-//!               `p` is useful for `P`. Indeed, it matches `[Some(false), _]` that wasn't matched\n-//!               before.\n+//! For example, if `P` is:\n+//! [\n+//!     [Some(true), _],\n+//!     [None, false],\n+//! ]\n+//! and `p` is [_, false], both `None` and `Some` constructors appear in the first\n+//! components of `P`. We will therefore try popping both constructors in turn: we\n+//! compute `U([[true, _]], [_, false])` for the `Some` constructor, and `U([[false]],\n+//! [false])` for the `None` constructor. The first case returns true, so we know that\n+//! `p` is useful for `P`. Indeed, it matches `[Some(false), _]` that wasn't matched\n+//! before.\n //!\n-//!         - If `p_1 == r_1 | r_2`, then the usefulness depends on each `r_i` separately:\n-//!           `U(P, p) := U(P, (r_1, p_2, .., p_n))\n-//!                    || U(P, (r_2, p_2, .., p_n))`\n+//!   - If `p_1 == r_1 | r_2`, then the usefulness depends on each `r_i` separately:\n+//! `U(P, p) := U(P, (r_1, p_2, .., p_n))\n+//!  || U(P, (r_2, p_2, .., p_n))`\n //!\n //! Modifications to the algorithm\n //! ------------------------------"}, {"sha": "e27bbc532cfc4da26b70b0e8268cf65d5096c5ab", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1415,7 +1415,7 @@ impl<'a> Parser<'a> {\n                 if self.token != token::Lt {\n                     err.span_suggestion(\n                         pat.span,\n-                        \"if this was a parameter name, give it a type\",\n+                        \"if this is a parameter name, give it a type\",\n                         format!(\"{}: TypeName\", ident),\n                         Applicability::HasPlaceholders,\n                     );"}, {"sha": "e4f4885690fd92045d423a777b701c73bffcaba4", "filename": "src/librustc_passes/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_passes%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_passes%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fintrinsicck.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -422,7 +422,7 @@ impl Visitor<'tcx> for ExprVisitor<'tcx> {\n                         let typ = self.tables.node_type(expr.hir_id);\n                         let sig = typ.fn_sig(self.tcx);\n                         let from = sig.inputs().skip_binder()[0];\n-                        let to = *sig.output().skip_binder();\n+                        let to = sig.output().skip_binder();\n                         self.check_transmute(expr.span, from, to);\n                     }\n                 }"}, {"sha": "20f09ef52f00bd741abeeb182ee0f75cc9c2119f", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -92,14 +92,14 @@ where\n         for (predicate, _span) in predicates {\n             match predicate.kind() {\n                 ty::PredicateKind::Trait(poly_predicate, _) => {\n-                    let ty::TraitPredicate { trait_ref } = *poly_predicate.skip_binder();\n+                    let ty::TraitPredicate { trait_ref } = poly_predicate.skip_binder();\n                     if self.visit_trait(trait_ref) {\n                         return true;\n                     }\n                 }\n                 ty::PredicateKind::Projection(poly_predicate) => {\n                     let ty::ProjectionPredicate { projection_ty, ty } =\n-                        *poly_predicate.skip_binder();\n+                        poly_predicate.skip_binder();\n                     if ty.visit_with(self) {\n                         return true;\n                     }\n@@ -108,7 +108,7 @@ where\n                     }\n                 }\n                 ty::PredicateKind::TypeOutlives(poly_predicate) => {\n-                    let ty::OutlivesPredicate(ty, _region) = *poly_predicate.skip_binder();\n+                    let ty::OutlivesPredicate(ty, _region) = poly_predicate.skip_binder();\n                     if ty.visit_with(self) {\n                         return true;\n                     }\n@@ -175,7 +175,7 @@ where\n             ty::Dynamic(predicates, ..) => {\n                 // All traits in the list are considered the \"primary\" part of the type\n                 // and are visited by shallow visitors.\n-                for predicate in *predicates.skip_binder() {\n+                for predicate in predicates.skip_binder() {\n                     let trait_ref = match predicate {\n                         ty::ExistentialPredicate::Trait(trait_ref) => trait_ref,\n                         ty::ExistentialPredicate::Projection(proj) => proj.trait_ref(tcx),\n@@ -1270,7 +1270,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n             );\n \n             for (trait_predicate, _, _) in bounds.trait_bounds {\n-                if self.visit_trait(*trait_predicate.skip_binder()) {\n+                if self.visit_trait(trait_predicate.skip_binder()) {\n                     return;\n                 }\n             }"}, {"sha": "e2f0d0b94c46c8c7dc3c8549a25594d07e6663ea", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -427,6 +427,7 @@ symbols! {\n         lhs,\n         lib,\n         lifetime,\n+        likely,\n         line,\n         link,\n         linkage,\n@@ -813,6 +814,7 @@ symbols! {\n         underscore_lifetimes,\n         uniform_paths,\n         universal_impl_trait,\n+        unlikely,\n         unmarked_api,\n         unreachable_code,\n         unrestricted_attribute_tokens,"}, {"sha": "ecf27fbf54220a00d1205a3382e73394713b594a", "filename": "src/librustc_symbol_mangling/v0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_symbol_mangling%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_symbol_mangling%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_symbol_mangling%2Fv0.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -219,7 +219,7 @@ impl SymbolMangler<'tcx> {\n         lifetime_depths.end += lifetimes;\n \n         self.binders.push(BinderLevel { lifetime_depths });\n-        self = print_value(self, value.skip_binder())?;\n+        self = print_value(self, value.as_ref().skip_binder())?;\n         self.binders.pop();\n \n         Ok(self)"}, {"sha": "ce478de7c755c64e071ceff53ef6998307d83311", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -691,7 +691,7 @@ where\n     OP: FnMut(ty::Region<'tcx>),\n {\n     fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n-        t.skip_binder().visit_with(self);\n+        t.as_ref().skip_binder().visit_with(self);\n         false // keep visiting\n     }\n "}, {"sha": "49e43873df759d652118a863a2370d36d7286300", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1569,7 +1569,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     // no need to overload user in such cases\n                     return;\n                 }\n-                let &SubtypePredicate { a_is_expected: _, a, b } = data.skip_binder();\n+                let SubtypePredicate { a_is_expected: _, a, b } = data.skip_binder();\n                 // both must be type variables, or the other would've been instantiated\n                 assert!(a.is_ty_var() && b.is_ty_var());\n                 self.need_type_info_err(body_id, span, a, ErrorCode::E0282)"}, {"sha": "ec51dddc2c8102265469b2fb08cc6b842eafbbf3", "filename": "src/librustc_trait_selection/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -122,7 +122,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     ) -> OnUnimplementedNote {\n         let def_id =\n             self.impl_similar_to(trait_ref, obligation).unwrap_or_else(|| trait_ref.def_id());\n-        let trait_ref = *trait_ref.skip_binder();\n+        let trait_ref = trait_ref.skip_binder();\n \n         let mut flags = vec![];\n         flags.push((\n@@ -219,7 +219,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n         }\n         if let ty::Dynamic(traits, _) = self_ty.kind {\n-            for t in *traits.skip_binder() {\n+            for t in traits.skip_binder() {\n                 if let ty::ExistentialPredicate::Trait(trait_ref) = t {\n                     flags.push((sym::_Self, Some(self.tcx.def_path_str(trait_ref.def_id))))\n                 }"}, {"sha": "1fafa9ec035cebb544c3f7e41ec2b3d8ad938724", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1179,7 +1179,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     ) -> DiagnosticBuilder<'tcx> {\n         crate fn build_fn_sig_string<'tcx>(\n             tcx: TyCtxt<'tcx>,\n-            trait_ref: &ty::TraitRef<'tcx>,\n+            trait_ref: ty::TraitRef<'tcx>,\n         ) -> String {\n             let inputs = trait_ref.substs.type_at(1);\n             let sig = if let ty::Tuple(inputs) = inputs.kind {\n@@ -1360,7 +1360,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         }\n                         ty::GeneratorWitness(..) => {}\n                         _ if generator.is_none() => {\n-                            trait_ref = Some(*derived_obligation.parent_trait_ref.skip_binder());\n+                            trait_ref = Some(derived_obligation.parent_trait_ref.skip_binder());\n                             target_ty = Some(ty);\n                         }\n                         _ => {}"}, {"sha": "91c162872b21572226891f30a46c2ba5d8e9c5e4", "filename": "src/librustc_trait_selection/traits/select/candidate_assembly.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -220,7 +220,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Okay to skip binder because the substs on generator types never\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters.\n-        let self_ty = *obligation.self_ty().skip_binder();\n+        let self_ty = obligation.self_ty().skip_binder();\n         match self_ty.kind {\n             ty::Generator(..) => {\n                 debug!(\n@@ -299,7 +299,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         // Okay to skip binder because what we are inspecting doesn't involve bound regions.\n-        let self_ty = *obligation.self_ty().skip_binder();\n+        let self_ty = obligation.self_ty().skip_binder();\n         match self_ty.kind {\n             ty::Infer(ty::TyVar(_)) => {\n                 debug!(\"assemble_fn_pointer_candidates: ambiguous self-type\");\n@@ -362,7 +362,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) -> Result<(), SelectionError<'tcx>> {\n         // Okay to skip binder here because the tests we do below do not involve bound regions.\n-        let self_ty = *obligation.self_ty().skip_binder();\n+        let self_ty = obligation.self_ty().skip_binder();\n         debug!(\"assemble_candidates_from_auto_impls(self_ty={:?})\", self_ty);\n \n         let def_id = obligation.predicate.def_id();\n@@ -583,7 +583,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) -> Result<(), SelectionError<'tcx>> {\n         // Okay to skip binder here because the tests we do below do not involve bound regions.\n-        let self_ty = *obligation.self_ty().skip_binder();\n+        let self_ty = obligation.self_ty().skip_binder();\n         debug!(\"assemble_candidates_for_trait_alias(self_ty={:?})\", self_ty);\n \n         let def_id = obligation.predicate.def_id();"}, {"sha": "fa970589bbbf60399b801884cd6ccb94db9572da", "filename": "src/librustc_trait_selection/traits/select/confirmation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fconfirmation.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -326,7 +326,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // probably flatten the binder from the obligation and the binder\n         // from the object. Have to try to make a broken test case that\n         // results.\n-        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());\n         let poly_trait_ref = match self_ty.kind {\n             ty::Dynamic(ref data, ..) => data\n                 .principal()\n@@ -379,7 +379,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"confirm_fn_pointer_candidate({:?})\", obligation);\n \n         // Okay to skip binder; it is reintroduced below.\n-        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());\n         let sig = self_ty.fn_sig(self.tcx());\n         let trait_ref = closure_trait_ref_and_return_type(\n             self.tcx(),\n@@ -448,7 +448,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Okay to skip binder because the substs on generator types never\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters.\n-        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());\n         let (generator_def_id, substs) = match self_ty.kind {\n             ty::Generator(id, substs, _) => (id, substs),\n             _ => bug!(\"closure candidate for non-closure {:?}\", obligation),\n@@ -497,7 +497,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Okay to skip binder because the substs on closure types never\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters.\n-        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());\n         let (closure_def_id, substs) = match self_ty.kind {\n             ty::Closure(id, substs) => (id, substs),\n             _ => bug!(\"closure candidate for non-closure {:?}\", obligation),"}, {"sha": "c41a27c6f431f4e840f8953ef912f5415bb315b8", "filename": "src/librustc_trait_selection/traits/select/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -748,8 +748,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             && stack.iter().skip(1).any(|prev| {\n                 stack.obligation.param_env == prev.obligation.param_env\n                     && self.match_fresh_trait_refs(\n-                        &stack.fresh_trait_ref,\n-                        &prev.fresh_trait_ref,\n+                        stack.fresh_trait_ref,\n+                        prev.fresh_trait_ref,\n                         prev.obligation.param_env,\n                     )\n             })\n@@ -1944,8 +1944,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn match_fresh_trait_refs(\n         &self,\n-        previous: &ty::PolyTraitRef<'tcx>,\n-        current: &ty::PolyTraitRef<'tcx>,\n+        previous: ty::PolyTraitRef<'tcx>,\n+        current: ty::PolyTraitRef<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> bool {\n         let mut matcher = ty::_match::Match::new(self.tcx(), param_env);"}, {"sha": "ebff2dd9b23c1e3e46780d2933bce28348e97524", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -695,7 +695,7 @@ pub fn object_region_bounds<'tcx>(\n     let open_ty = tcx.mk_ty_infer(ty::FreshTy(0));\n \n     let predicates = existential_predicates.iter().filter_map(|predicate| {\n-        if let ty::ExistentialPredicate::Projection(_) = *predicate.skip_binder() {\n+        if let ty::ExistentialPredicate::Projection(_) = predicate.skip_binder() {\n             None\n         } else {\n             Some(predicate.with_self_ty(tcx, open_ty))"}, {"sha": "ed021e5b9de1b8431e4698ce26177e53a6b65e84", "filename": "src/librustc_traits/chalk/lowering.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Flowering.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -615,7 +615,7 @@ crate fn collect_bound_vars<'a, 'tcx, T: TypeFoldable<'tcx>>(\n     ty: &'a Binder<T>,\n ) -> (T, chalk_ir::VariableKinds<RustInterner<'tcx>>, BTreeMap<DefId, u32>) {\n     let mut bound_vars_collector = BoundVarsCollector::new();\n-    ty.skip_binder().visit_with(&mut bound_vars_collector);\n+    ty.as_ref().skip_binder().visit_with(&mut bound_vars_collector);\n     let mut parameters = bound_vars_collector.parameters;\n     let named_parameters: BTreeMap<DefId, u32> = bound_vars_collector\n         .named_parameters\n@@ -625,7 +625,7 @@ crate fn collect_bound_vars<'a, 'tcx, T: TypeFoldable<'tcx>>(\n         .collect();\n \n     let mut bound_var_substitutor = NamedBoundVarSubstitutor::new(tcx, &named_parameters);\n-    let new_ty = ty.skip_binder().fold_with(&mut bound_var_substitutor);\n+    let new_ty = ty.as_ref().skip_binder().fold_with(&mut bound_var_substitutor);\n \n     for var in named_parameters.values() {\n         parameters.insert(*var, chalk_ir::VariableKind::Lifetime);"}, {"sha": "5d1949626dd84e82a24bb0dc482b19993bacf35e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1802,15 +1802,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         // Calling `skip_binder` is okay because the predicates are re-bound.\n         let regular_trait_predicates = existential_trait_refs\n-            .map(|trait_ref| ty::ExistentialPredicate::Trait(*trait_ref.skip_binder()));\n+            .map(|trait_ref| ty::ExistentialPredicate::Trait(trait_ref.skip_binder()));\n         let auto_trait_predicates = auto_traits\n             .into_iter()\n             .map(|trait_ref| ty::ExistentialPredicate::AutoTrait(trait_ref.trait_ref().def_id()));\n         let mut v = regular_trait_predicates\n             .chain(auto_trait_predicates)\n             .chain(\n                 existential_projections\n-                    .map(|x| ty::ExistentialPredicate::Projection(*x.skip_binder())),\n+                    .map(|x| ty::ExistentialPredicate::Projection(x.skip_binder())),\n             )\n             .collect::<SmallVec<[_; 8]>>();\n         v.sort_by(|a, b| a.stable_cmp(tcx, b));"}, {"sha": "fce2b18b782fb3a0794695f215d2d1d69ae18b45", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -188,7 +188,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             ty::Infer(ty::TyVar(vid)) => self.deduce_expectations_from_obligations(vid),\n             ty::FnPtr(sig) => {\n-                let expected_sig = ExpectedSig { cause_span: None, sig: *sig.skip_binder() };\n+                let expected_sig = ExpectedSig { cause_span: None, sig: sig.skip_binder() };\n                 (Some(expected_sig), Some(ty::ClosureKind::Fn))\n             }\n             _ => (None, None),\n@@ -501,7 +501,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             for ((hir_ty, &supplied_ty), expected_ty) in decl\n                 .inputs\n                 .iter()\n-                .zip(*supplied_sig.inputs().skip_binder()) // binder moved to (*) below\n+                .zip(supplied_sig.inputs().skip_binder()) // binder moved to (*) below\n                 .zip(expected_sigs.liberated_sig.inputs())\n             // `liberated_sig` is E'.\n             {"}, {"sha": "e6b3224050e9bc755fd70a299060f86fe99fb834", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -964,7 +964,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let sig = self\n                 .at(cause, self.param_env)\n                 .trace(prev_ty, new_ty)\n-                .lub(&a_sig, &b_sig)\n+                .lub(a_sig, b_sig)\n                 .map(|ok| self.register_infer_ok_obligations(ok))?;\n \n             // Reify both sides and return the reified fn pointer type."}, {"sha": "e6217e0cc1b6eceb45f10a1d9dc44e1f7f4ad115", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -502,7 +502,7 @@ fn compare_self_type<'tcx>(\n             ty::ImplContainer(_) => impl_trait_ref.self_ty(),\n             ty::TraitContainer(_) => tcx.types.self_param,\n         };\n-        let self_arg_ty = *tcx.fn_sig(method.def_id).input(0).skip_binder();\n+        let self_arg_ty = tcx.fn_sig(method.def_id).input(0).skip_binder();\n         let param_env = ty::ParamEnv::reveal_all();\n \n         tcx.infer_ctxt().enter(|infcx| {"}, {"sha": "f6991120f347989da516a95e7cd58c979805d0d6", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -227,10 +227,10 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n         let predicate_matches_closure = |p: Predicate<'tcx>| {\n             let mut relator: SimpleEqRelation<'tcx> = SimpleEqRelation::new(tcx, self_param_env);\n             match (predicate.kind(), p.kind()) {\n-                (ty::PredicateKind::Trait(a, _), ty::PredicateKind::Trait(b, _)) => {\n+                (&ty::PredicateKind::Trait(a, _), &ty::PredicateKind::Trait(b, _)) => {\n                     relator.relate(a, b).is_ok()\n                 }\n-                (ty::PredicateKind::Projection(a), ty::PredicateKind::Projection(b)) => {\n+                (&ty::PredicateKind::Projection(a), &ty::PredicateKind::Projection(b)) => {\n                     relator.relate(a, b).is_ok()\n                 }\n                 _ => predicate == p,\n@@ -310,8 +310,8 @@ impl TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T> {\n         // Here we ignore variance because we require drop impl's types\n         // to be *exactly* the same as to the ones in the struct definition.\n@@ -354,8 +354,8 @@ impl TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>,\n@@ -364,8 +364,8 @@ impl TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n \n         // Anonymizing the LBRs is necessary to solve (Issue #59497).\n         // After we do so, it should be totally fine to skip the binders.\n-        let anon_a = self.tcx.anonymize_late_bound_regions(a);\n-        let anon_b = self.tcx.anonymize_late_bound_regions(b);\n+        let anon_a = self.tcx.anonymize_late_bound_regions(&a);\n+        let anon_b = self.tcx.anonymize_late_bound_regions(&b);\n         self.relate(anon_a.skip_binder(), anon_b.skip_binder())?;\n \n         Ok(a.clone())"}, {"sha": "b75dac52b93e51eca8a9278758f5c870bee05fc2", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -608,7 +608,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             ty::Adt(def, _) => bound_spans.push((def_span(def.did), msg)),\n                             // Point at the trait object that couldn't satisfy the bound.\n                             ty::Dynamic(preds, _) => {\n-                                for pred in *preds.skip_binder() {\n+                                for pred in preds.skip_binder() {\n                                     match pred {\n                                         ty::ExistentialPredicate::Trait(tr) => {\n                                             bound_spans.push((def_span(tr.def_id), msg.clone()))"}, {"sha": "b617937d6bd542d43324e485e1a843f546de6112", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -2446,7 +2446,7 @@ fn bounds_from_generic_predicates(\n /// Return placeholder code for the given function.\n fn fn_sig_suggestion(\n     tcx: TyCtxt<'_>,\n-    sig: &ty::FnSig<'_>,\n+    sig: ty::FnSig<'_>,\n     ident: Ident,\n     predicates: ty::GenericPredicates<'_>,\n     assoc: &ty::AssocItem,"}, {"sha": "a1e060b97ad2815a6b527ba48b3541910f3f70d9", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -500,7 +500,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 return false;\n             }\n             // We're emitting a suggestion, so we can just ignore regions\n-            let fn_sig = *self.tcx.fn_sig(def_id).skip_binder();\n+            let fn_sig = self.tcx.fn_sig(def_id).skip_binder();\n \n             let other_ty = if let FnDef(def_id, _) = other_ty.kind {\n                 if !self.tcx.has_typeck_tables(def_id) {"}, {"sha": "3b203dd222afbbd15e2a737e9071c801449ece6e", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -216,7 +216,7 @@ fn check_object_overlap<'tcx>(\n         let component_def_ids = data.iter().flat_map(|predicate| {\n             match predicate.skip_binder() {\n                 ty::ExistentialPredicate::Trait(tr) => Some(tr.def_id),\n-                ty::ExistentialPredicate::AutoTrait(def_id) => Some(*def_id),\n+                ty::ExistentialPredicate::AutoTrait(def_id) => Some(def_id),\n                 // An associated type projection necessarily comes with\n                 // an additional `Trait` requirement.\n                 ty::ExistentialPredicate::Projection(..) => None,"}, {"sha": "8920203e6af400a46e133816d8ffb3d2f53fcc81", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -2102,11 +2102,11 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n                     .emit();\n             }\n         };\n-        for (input, ty) in decl.inputs.iter().zip(*fty.inputs().skip_binder()) {\n+        for (input, ty) in decl.inputs.iter().zip(fty.inputs().skip_binder()) {\n             check(&input, ty)\n         }\n         if let hir::FnRetTy::Return(ref ty) = decl.output {\n-            check(&ty, *fty.output().skip_binder())\n+            check(&ty, fty.output().skip_binder())\n         }\n     }\n "}, {"sha": "bfe8464347d2986b7982e7f7cd3ac7482ddbac72", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -347,7 +347,7 @@ impl Clean<GenericBound> for (ty::PolyTraitRef<'_>, &[TypeBinding]) {\n \n         GenericBound::TraitBound(\n             PolyTrait {\n-                trait_: (*poly_trait_ref.skip_binder(), bounds).clean(cx),\n+                trait_: (poly_trait_ref.skip_binder(), bounds).clean(cx),\n                 generic_params: late_bound_regions,\n             },\n             hir::TraitBoundModifier::None,\n@@ -549,7 +549,7 @@ impl<'tcx> Clean<Option<WherePredicate>> for ty::PolyOutlivesPredicate<Ty<'tcx>,\n \n impl<'tcx> Clean<WherePredicate> for ty::PolyProjectionPredicate<'tcx> {\n     fn clean(&self, cx: &DocContext<'_>) -> WherePredicate {\n-        let ty::ProjectionPredicate { projection_ty, ty } = *self.skip_binder();\n+        let ty::ProjectionPredicate { projection_ty, ty } = self.skip_binder();\n         WherePredicate::EqPredicate { lhs: projection_ty.clean(cx), rhs: ty.clean(cx) }\n     }\n }\n@@ -1177,7 +1177,7 @@ impl Clean<Item> for ty::AssocItem {\n                         ty::ImplContainer(def_id) => cx.tcx.type_of(def_id),\n                         ty::TraitContainer(_) => cx.tcx.types.self_param,\n                     };\n-                    let self_arg_ty = *sig.input(0).skip_binder();\n+                    let self_arg_ty = sig.input(0).skip_binder();\n                     if self_arg_ty == self_ty {\n                         decl.inputs.values[0].type_ = Generic(String::from(\"Self\"));\n                     } else if let ty::Ref(_, ty, _) = self_arg_ty.kind {\n@@ -1679,7 +1679,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                                 if let ty::PredicateKind::Projection(proj) = pred.kind() {\n                                     let proj = proj.skip_binder();\n                                     if proj.projection_ty.trait_ref(cx.tcx)\n-                                        == *trait_ref.skip_binder()\n+                                        == trait_ref.skip_binder()\n                                     {\n                                         Some(TypeBinding {\n                                             name: cx"}, {"sha": "0b3386c05d54b35d755dac6efea756958b78c08e", "filename": "src/libstd/keyword_docs.rs", "status": "modified", "additions": 113, "deletions": 5, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibstd%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibstd%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkeyword_docs.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1281,11 +1281,84 @@ mod self_upper_keyword {}\n \n #[doc(keyword = \"static\")]\n //\n-/// A place that is valid for the duration of a program.\n+/// A static item is a value which is valid for the entire duration of your\n+/// program (a `'static` lifetime).\n ///\n-/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+/// On the surface, `static` items seem very similar to [`const`]s: both contain\n+/// a value, both require type annotations and both can only be initialized with\n+/// constant functions and values. However, `static`s are notably different in\n+/// that they represent a location in memory. That means that you can have\n+/// references to `static` items and potentially even modify them, making them\n+/// essentially global variables.\n ///\n-/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+/// Static items do not call [`drop`] at the end of the program.\n+///\n+/// There are two types of `static` items: those declared in association with\n+/// the [`mut`] keyword and those without.\n+///\n+/// Static items cannot be moved:\n+///\n+/// ```rust,compile_fail,E0507\n+/// static VEC: Vec<u32> = vec![];\n+///\n+/// fn move_vec(v: Vec<u32>) -> Vec<u32> {\n+///     v\n+/// }\n+///\n+/// // This line causes an error\n+/// move_vec(VEC);\n+/// ```\n+///\n+/// # Simple `static`s\n+///\n+/// Accessing non-[`mut`] `static` items is considered safe, but some\n+/// restrictions apply. Most notably, the type of a `static` value needs to\n+/// implement the [`Sync`] trait, ruling out interior mutability containers\n+/// like [`RefCell`]. See the [Reference] for more information.\n+///\n+/// ```rust\n+/// static FOO: [i32; 5] = [1, 2, 3, 4, 5];\n+///\n+/// let r1 = &FOO as *const _;\n+/// let r2 = &FOO as *const _;\n+/// // With a strictly read-only static, references will have the same adress\n+/// assert_eq!(r1, r2);\n+/// // A static item can be used just like a variable in many cases\n+/// println!(\"{:?}\", FOO);\n+/// ```\n+///\n+/// # Mutable `static`s\n+///\n+/// If a `static` item is declared with the [`mut`] keyword, then it is allowed\n+/// to be modified by the program. However, accessing mutable `static`s can\n+/// cause undefined behavior in a number of ways, for example due to data races\n+/// in a multithreaded context. As such, all accesses to mutable `static`s\n+/// require an [`unsafe`] block.\n+///\n+/// Despite their unsafety, mutable `static`s are necessary in many contexts:\n+/// they can be used to represent global state shared by the whole program or in\n+/// [`extern`] blocks to bind to variables from C libraries.\n+///\n+/// In an [`extern`] block:\n+///\n+/// ```rust,no_run\n+/// # #![allow(dead_code)]\n+/// extern \"C\" {\n+///     static mut ERROR_MESSAGE: *mut std::os::raw::c_char;\n+/// }\n+/// ```\n+///\n+/// Mutable `static`s, just like simple `static`s, have some restrictions that\n+/// apply to them. See the [Reference] for more information.\n+///\n+/// [`const`]: keyword.const.html\n+/// [`extern`]: keyword.extern.html\n+/// [`mut`]: keyword.mut.html\n+/// [`unsafe`]: keyword.unsafe.html\n+/// [`drop`]: mem/fn.drop.html\n+/// [`Sync`]: marker/trait.Sync.html\n+/// [`RefCell`]: cell/struct.RefCell.html\n+/// [Reference]: ../reference/items/static-items.html\n mod static_keyword {}\n \n #[doc(keyword = \"struct\")]\n@@ -1463,9 +1536,44 @@ mod true_keyword {}\n //\n /// Define an alias for an existing type.\n ///\n-/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+/// The syntax is `type Name = ExistingType;`.\n ///\n-/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+/// # Examples\n+///\n+/// `type` does **not** create a new type:\n+///\n+/// ```rust\n+/// type Meters = u32;\n+/// type Kilograms = u32;\n+///\n+/// let m: Meters = 3;\n+/// let k: Kilograms = 3;\n+///\n+/// assert_eq!(m, k);\n+/// ```\n+///\n+/// In traits, `type` is used to declare an [associated type]:\n+///\n+/// ```rust\n+/// trait Iterator {\n+///     // associated type declaration\n+///     type Item;\n+///     fn next(&mut self) -> Option<Self::Item>;\n+/// }\n+///\n+/// struct Once<T>(Option<T>);\n+///\n+/// impl<T> Iterator for Once<T> {\n+///     // associated type definition\n+///     type Item = T;\n+///     fn next(&mut self) -> Option<Self::Item> {\n+///         self.0.take()\n+///     }\n+/// }\n+/// ```\n+///\n+/// [`trait`]: keyword.trait.html\n+/// [associated type]: ../reference/items/associated-items.html#associated-types\n mod type_keyword {}\n \n #[doc(keyword = \"unsafe\")]"}, {"sha": "372038df54f2e39c568f499f9f7eb402756c136c", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -316,7 +316,7 @@\n #![feature(toowned_clone_into)]\n #![feature(total_cmp)]\n #![feature(trace_macros)]\n-#![feature(track_caller)]\n+#![cfg_attr(bootstrap, feature(track_caller))]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(untagged_unions)]"}, {"sha": "12d3baf633362b55369139d1ba86c9cf27ddc2cf", "filename": "src/libstd/net/parser.rs", "status": "modified", "additions": 289, "deletions": 193, "changes": 482, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibstd%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibstd%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fparser.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -10,163 +10,132 @@ use crate::str::FromStr;\n \n struct Parser<'a> {\n     // parsing as ASCII, so can use byte array\n-    s: &'a [u8],\n-    pos: usize,\n+    state: &'a [u8],\n }\n \n impl<'a> Parser<'a> {\n-    fn new(s: &'a str) -> Parser<'a> {\n-        Parser { s: s.as_bytes(), pos: 0 }\n+    fn new(input: &'a str) -> Parser<'a> {\n+        Parser { state: input.as_bytes() }\n     }\n \n     fn is_eof(&self) -> bool {\n-        self.pos == self.s.len()\n+        self.state.is_empty()\n     }\n \n-    // Commit only if parser returns Some\n-    fn read_atomically<T, F>(&mut self, cb: F) -> Option<T>\n+    /// Run a parser, and restore the pre-parse state if it fails\n+    fn read_atomically<T, F>(&mut self, inner: F) -> Option<T>\n     where\n         F: FnOnce(&mut Parser<'_>) -> Option<T>,\n     {\n-        let pos = self.pos;\n-        let r = cb(self);\n-        if r.is_none() {\n-            self.pos = pos;\n+        let state = self.state;\n+        let result = inner(self);\n+        if result.is_none() {\n+            self.state = state;\n         }\n-        r\n+        result\n     }\n \n-    // Commit only if parser read till EOF\n-    fn read_till_eof<T, F>(&mut self, cb: F) -> Option<T>\n+    /// Run a parser, but fail if the entire input wasn't consumed.\n+    /// Doesn't run atomically.\n+    fn read_till_eof<T, F>(&mut self, inner: F) -> Option<T>\n     where\n         F: FnOnce(&mut Parser<'_>) -> Option<T>,\n     {\n-        self.read_atomically(move |p| cb(p).filter(|_| p.is_eof()))\n+        inner(self).filter(|_| self.is_eof())\n     }\n \n-    // Apply 3 parsers sequentially\n-    fn read_seq_3<A, B, C, PA, PB, PC>(&mut self, pa: PA, pb: PB, pc: PC) -> Option<(A, B, C)>\n+    /// Same as read_till_eof, but returns a Result<AddrParseError> on failure\n+    fn parse_with<T, F>(&mut self, inner: F) -> Result<T, AddrParseError>\n     where\n-        PA: FnOnce(&mut Parser<'_>) -> Option<A>,\n-        PB: FnOnce(&mut Parser<'_>) -> Option<B>,\n-        PC: FnOnce(&mut Parser<'_>) -> Option<C>,\n+        F: FnOnce(&mut Parser<'_>) -> Option<T>,\n     {\n-        self.read_atomically(move |p| {\n-            let a = pa(p);\n-            let b = if a.is_some() { pb(p) } else { None };\n-            let c = if b.is_some() { pc(p) } else { None };\n-            match (a, b, c) {\n-                (Some(a), Some(b), Some(c)) => Some((a, b, c)),\n-                _ => None,\n-            }\n-        })\n+        self.read_till_eof(inner).ok_or(AddrParseError(()))\n     }\n \n-    // Read next char\n+    /// Read the next character from the input\n     fn read_char(&mut self) -> Option<char> {\n-        if self.is_eof() {\n-            None\n-        } else {\n-            let r = self.s[self.pos] as char;\n-            self.pos += 1;\n-            Some(r)\n-        }\n-    }\n-\n-    // Return char and advance iff next char is equal to requested\n-    fn read_given_char(&mut self, c: char) -> Option<char> {\n-        self.read_atomically(|p| match p.read_char() {\n-            Some(next) if next == c => Some(next),\n-            _ => None,\n+        self.state.split_first().map(|(&b, tail)| {\n+            self.state = tail;\n+            b as char\n         })\n     }\n \n-    // Read digit\n-    fn read_digit(&mut self, radix: u8) -> Option<u8> {\n-        fn parse_digit(c: char, radix: u8) -> Option<u8> {\n-            let c = c as u8;\n-            // assuming radix is either 10 or 16\n-            if c >= b'0' && c <= b'9' {\n-                Some(c - b'0')\n-            } else if radix > 10 && c >= b'a' && c < b'a' + (radix - 10) {\n-                Some(c - b'a' + 10)\n-            } else if radix > 10 && c >= b'A' && c < b'A' + (radix - 10) {\n-                Some(c - b'A' + 10)\n-            } else {\n-                None\n-            }\n-        }\n-\n-        self.read_atomically(|p| p.read_char().and_then(|c| parse_digit(c, radix)))\n+    /// Read the next character from the input if it matches the target\n+    fn read_given_char(&mut self, target: char) -> Option<char> {\n+        self.read_atomically(|p| p.read_char().filter(|&c| c == target))\n     }\n \n-    fn read_number_impl(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> {\n-        let mut r = 0;\n-        let mut digit_count = 0;\n-        loop {\n-            match self.read_digit(radix) {\n-                Some(d) => {\n-                    r = r * (radix as u32) + (d as u32);\n-                    digit_count += 1;\n-                    if digit_count > max_digits || r >= upto {\n-                        return None;\n-                    }\n-                }\n-                None => {\n-                    if digit_count == 0 {\n-                        return None;\n-                    } else {\n-                        return Some(r);\n-                    }\n-                }\n-            };\n-        }\n+    /// Helper for reading separators in an indexed loop. Reads the separator\n+    /// character iff index > 0, then runs the parser. When used in a loop,\n+    /// the separator character will only be read on index > 0 (see\n+    /// read_ipv4_addr for an example)\n+    fn read_separator<T, F>(&mut self, sep: char, index: usize, inner: F) -> Option<T>\n+    where\n+        F: FnOnce(&mut Parser<'_>) -> Option<T>,\n+    {\n+        self.read_atomically(move |p| {\n+            if index > 0 {\n+                let _ = p.read_given_char(sep)?;\n+            }\n+            inner(p)\n+        })\n     }\n \n-    // Read number, failing if max_digits of number value exceeded\n-    fn read_number(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> {\n-        self.read_atomically(|p| p.read_number_impl(radix, max_digits, upto))\n+    // Read a single digit in the given radix. For instance, 0-9 in radix 10;\n+    // 0-9A-F in radix 16.\n+    fn read_digit(&mut self, radix: u32) -> Option<u32> {\n+        self.read_atomically(move |p| p.read_char()?.to_digit(radix))\n     }\n \n-    fn read_ipv4_addr_impl(&mut self) -> Option<Ipv4Addr> {\n-        let mut bs = [0; 4];\n-        let mut i = 0;\n-        while i < 4 {\n-            if i != 0 && self.read_given_char('.').is_none() {\n-                return None;\n+    // Read a number off the front of the input in the given radix, stopping\n+    // at the first non-digit character or eof. Fails if the number has more\n+    // digits than max_digits, or the value is >= upto, or if there is no number.\n+    fn read_number(&mut self, radix: u32, max_digits: u32, upto: u32) -> Option<u32> {\n+        self.read_atomically(move |p| {\n+            let mut result = 0;\n+            let mut digit_count = 0;\n+\n+            while let Some(digit) = p.read_digit(radix) {\n+                result = (result * radix) + digit;\n+                digit_count += 1;\n+                if digit_count > max_digits || result >= upto {\n+                    return None;\n+                }\n             }\n \n-            bs[i] = self.read_number(10, 3, 0x100).map(|n| n as u8)?;\n-            i += 1;\n-        }\n-        Some(Ipv4Addr::new(bs[0], bs[1], bs[2], bs[3]))\n+            if digit_count == 0 { None } else { Some(result) }\n+        })\n     }\n \n-    // Read IPv4 address\n+    /// Read an IPv4 address\n     fn read_ipv4_addr(&mut self) -> Option<Ipv4Addr> {\n-        self.read_atomically(|p| p.read_ipv4_addr_impl())\n-    }\n+        self.read_atomically(|p| {\n+            let mut groups = [0; 4];\n \n-    fn read_ipv6_addr_impl(&mut self) -> Option<Ipv6Addr> {\n-        fn ipv6_addr_from_head_tail(head: &[u16], tail: &[u16]) -> Ipv6Addr {\n-            assert!(head.len() + tail.len() <= 8);\n-            let mut gs = [0; 8];\n-            gs[..head.len()].copy_from_slice(head);\n-            gs[(8 - tail.len())..8].copy_from_slice(tail);\n-            Ipv6Addr::new(gs[0], gs[1], gs[2], gs[3], gs[4], gs[5], gs[6], gs[7])\n-        }\n+            for (i, slot) in groups.iter_mut().enumerate() {\n+                *slot = p.read_separator('.', i, |p| p.read_number(10, 3, 0x100))? as u8;\n+            }\n+\n+            Some(groups.into())\n+        })\n+    }\n \n-        fn read_groups(p: &mut Parser<'_>, groups: &mut [u16; 8], limit: usize) -> (usize, bool) {\n-            let mut i = 0;\n-            while i < limit {\n+    /// Read an IPV6 Address\n+    fn read_ipv6_addr(&mut self) -> Option<Ipv6Addr> {\n+        /// Read a chunk of an ipv6 address into `groups`. Returns the number\n+        /// of groups read, along with a bool indicating if an embedded\n+        /// trailing ipv4 address was read. Specifically, read a series of\n+        /// colon-separated ipv6 groups (0x0000 - 0xFFFF), with an optional\n+        /// trailing embedded ipv4 address.\n+        fn read_groups(p: &mut Parser<'_>, groups: &mut [u16]) -> (usize, bool) {\n+            let limit = groups.len();\n+\n+            for (i, slot) in groups.iter_mut().enumerate() {\n+                // Try to read a trailing embedded ipv4 address. There must be\n+                // at least two groups left.\n                 if i < limit - 1 {\n-                    let ipv4 = p.read_atomically(|p| {\n-                        if i == 0 || p.read_given_char(':').is_some() {\n-                            p.read_ipv4_addr()\n-                        } else {\n-                            None\n-                        }\n-                    });\n+                    let ipv4 = p.read_separator(':', i, |p| p.read_ipv4_addr());\n+\n                     if let Some(v4_addr) = ipv4 {\n                         let octets = v4_addr.octets();\n                         groups[i + 0] = ((octets[0] as u16) << 8) | (octets[1] as u16);\n@@ -175,83 +144,85 @@ impl<'a> Parser<'a> {\n                     }\n                 }\n \n-                let group = p.read_atomically(|p| {\n-                    if i == 0 || p.read_given_char(':').is_some() {\n-                        p.read_number(16, 4, 0x10000).map(|n| n as u16)\n-                    } else {\n-                        None\n-                    }\n-                });\n+                let group = p.read_separator(':', i, |p| p.read_number(16, 4, 0x10000));\n+\n                 match group {\n-                    Some(g) => groups[i] = g,\n+                    Some(g) => *slot = g as u16,\n                     None => return (i, false),\n                 }\n-                i += 1;\n             }\n-            (i, false)\n+            (groups.len(), false)\n         }\n \n-        let mut head = [0; 8];\n-        let (head_size, head_ipv4) = read_groups(self, &mut head, 8);\n+        self.read_atomically(|p| {\n+            // Read the front part of the address; either the whole thing, or up\n+            // to the first ::\n+            let mut head = [0; 8];\n+            let (head_size, head_ipv4) = read_groups(p, &mut head);\n \n-        if head_size == 8 {\n-            return Some(Ipv6Addr::new(\n-                head[0], head[1], head[2], head[3], head[4], head[5], head[6], head[7],\n-            ));\n-        }\n+            if head_size == 8 {\n+                return Some(head.into());\n+            }\n \n-        // IPv4 part is not allowed before `::`\n-        if head_ipv4 {\n-            return None;\n-        }\n+            // IPv4 part is not allowed before `::`\n+            if head_ipv4 {\n+                return None;\n+            }\n \n-        // read `::` if previous code parsed less than 8 groups\n-        if self.read_given_char(':').is_none() || self.read_given_char(':').is_none() {\n-            return None;\n-        }\n+            // read `::` if previous code parsed less than 8 groups\n+            // `::` indicates one or more groups of 16 bits of zeros\n+            let _ = p.read_given_char(':')?;\n+            let _ = p.read_given_char(':')?;\n \n-        let mut tail = [0; 8];\n-        // `::` indicates one or more groups of 16 bits of zeros\n-        let limit = 8 - (head_size + 1);\n-        let (tail_size, _) = read_groups(self, &mut tail, limit);\n-        Some(ipv6_addr_from_head_tail(&head[..head_size], &tail[..tail_size]))\n-    }\n+            // Read the back part of the address. The :: must contain at least one\n+            // set of zeroes, so our max length is 7.\n+            let mut tail = [0; 7];\n+            let limit = 8 - (head_size + 1);\n+            let (tail_size, _) = read_groups(p, &mut tail[..limit]);\n \n-    fn read_ipv6_addr(&mut self) -> Option<Ipv6Addr> {\n-        self.read_atomically(|p| p.read_ipv6_addr_impl())\n+            // Concat the head and tail of the IP address\n+            head[(8 - tail_size)..8].copy_from_slice(&tail[..tail_size]);\n+\n+            Some(head.into())\n+        })\n     }\n \n+    /// Read an IP Address, either IPV4 or IPV6.\n     fn read_ip_addr(&mut self) -> Option<IpAddr> {\n-        self.read_ipv4_addr().map(IpAddr::V4).or_else(|| self.read_ipv6_addr().map(IpAddr::V6))\n+        self.read_ipv4_addr().map(IpAddr::V4).or_else(move || self.read_ipv6_addr().map(IpAddr::V6))\n     }\n \n-    fn read_socket_addr_v4(&mut self) -> Option<SocketAddrV4> {\n-        let ip_addr = |p: &mut Parser<'_>| p.read_ipv4_addr();\n-        let colon = |p: &mut Parser<'_>| p.read_given_char(':');\n-        let port = |p: &mut Parser<'_>| p.read_number(10, 5, 0x10000).map(|n| n as u16);\n+    /// Read a : followed by a port in base 10\n+    fn read_port(&mut self) -> Option<u16> {\n+        self.read_atomically(|p| {\n+            let _ = p.read_given_char(':')?;\n+            let port = p.read_number(10, 5, 0x10000)?;\n+            Some(port as u16)\n+        })\n+    }\n \n-        self.read_seq_3(ip_addr, colon, port).map(|t| {\n-            let (ip, _, port): (Ipv4Addr, char, u16) = t;\n-            SocketAddrV4::new(ip, port)\n+    /// Read an IPV4 address with a port\n+    fn read_socket_addr_v4(&mut self) -> Option<SocketAddrV4> {\n+        self.read_atomically(|p| {\n+            let ip = p.read_ipv4_addr()?;\n+            let port = p.read_port()?;\n+            Some(SocketAddrV4::new(ip, port))\n         })\n     }\n \n+    /// Read an IPV6 address with a port\n     fn read_socket_addr_v6(&mut self) -> Option<SocketAddrV6> {\n-        let ip_addr = |p: &mut Parser<'_>| {\n-            let open_br = |p: &mut Parser<'_>| p.read_given_char('[');\n-            let ip_addr = |p: &mut Parser<'_>| p.read_ipv6_addr();\n-            let clos_br = |p: &mut Parser<'_>| p.read_given_char(']');\n-            p.read_seq_3(open_br, ip_addr, clos_br).map(|t| t.1)\n-        };\n-        let colon = |p: &mut Parser<'_>| p.read_given_char(':');\n-        let port = |p: &mut Parser<'_>| p.read_number(10, 5, 0x10000).map(|n| n as u16);\n-\n-        self.read_seq_3(ip_addr, colon, port).map(|t| {\n-            let (ip, _, port): (Ipv6Addr, char, u16) = t;\n-            SocketAddrV6::new(ip, port, 0, 0)\n+        self.read_atomically(|p| {\n+            let _ = p.read_given_char('[')?;\n+            let ip = p.read_ipv6_addr()?;\n+            let _ = p.read_given_char(']')?;\n+\n+            let port = p.read_port()?;\n+            Some(SocketAddrV6::new(ip, port, 0, 0))\n         })\n     }\n \n+    /// Read an IP address with a port\n     fn read_socket_addr(&mut self) -> Option<SocketAddr> {\n         self.read_socket_addr_v4()\n             .map(SocketAddr::V4)\n@@ -263,65 +234,47 @@ impl<'a> Parser<'a> {\n impl FromStr for IpAddr {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<IpAddr, AddrParseError> {\n-        match Parser::new(s).read_till_eof(|p| p.read_ip_addr()) {\n-            Some(s) => Ok(s),\n-            None => Err(AddrParseError(())),\n-        }\n+        Parser::new(s).parse_with(|p| p.read_ip_addr())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromStr for Ipv4Addr {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<Ipv4Addr, AddrParseError> {\n-        match Parser::new(s).read_till_eof(|p| p.read_ipv4_addr()) {\n-            Some(s) => Ok(s),\n-            None => Err(AddrParseError(())),\n-        }\n+        Parser::new(s).parse_with(|p| p.read_ipv4_addr())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromStr for Ipv6Addr {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<Ipv6Addr, AddrParseError> {\n-        match Parser::new(s).read_till_eof(|p| p.read_ipv6_addr()) {\n-            Some(s) => Ok(s),\n-            None => Err(AddrParseError(())),\n-        }\n+        Parser::new(s).parse_with(|p| p.read_ipv6_addr())\n     }\n }\n \n #[stable(feature = \"socket_addr_from_str\", since = \"1.5.0\")]\n impl FromStr for SocketAddrV4 {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<SocketAddrV4, AddrParseError> {\n-        match Parser::new(s).read_till_eof(|p| p.read_socket_addr_v4()) {\n-            Some(s) => Ok(s),\n-            None => Err(AddrParseError(())),\n-        }\n+        Parser::new(s).parse_with(|p| p.read_socket_addr_v4())\n     }\n }\n \n #[stable(feature = \"socket_addr_from_str\", since = \"1.5.0\")]\n impl FromStr for SocketAddrV6 {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<SocketAddrV6, AddrParseError> {\n-        match Parser::new(s).read_till_eof(|p| p.read_socket_addr_v6()) {\n-            Some(s) => Ok(s),\n-            None => Err(AddrParseError(())),\n-        }\n+        Parser::new(s).parse_with(|p| p.read_socket_addr_v6())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromStr for SocketAddr {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<SocketAddr, AddrParseError> {\n-        match Parser::new(s).read_till_eof(|p| p.read_socket_addr()) {\n-            Some(s) => Ok(s),\n-            None => Err(AddrParseError(())),\n-        }\n+        Parser::new(s).parse_with(|p| p.read_socket_addr())\n     }\n }\n \n@@ -376,3 +329,146 @@ impl Error for AddrParseError {\n         \"invalid IP address syntax\"\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    // FIXME: These tests are all excellent candidates for AFL fuzz testing\n+    use crate::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};\n+    use crate::str::FromStr;\n+\n+    const PORT: u16 = 8080;\n+\n+    const IPV4: Ipv4Addr = Ipv4Addr::new(192, 168, 0, 1);\n+    const IPV4_STR: &str = \"192.168.0.1\";\n+    const IPV4_STR_PORT: &str = \"192.168.0.1:8080\";\n+\n+    const IPV6: Ipv6Addr = Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0xc0a8, 0x1);\n+    const IPV6_STR_FULL: &str = \"2001:db8:0:0:0:0:c0a8:1\";\n+    const IPV6_STR_COMPRESS: &str = \"2001:db8::c0a8:1\";\n+    const IPV6_STR_V4: &str = \"2001:db8::192.168.0.1\";\n+    const IPV6_STR_PORT: &str = \"[2001:db8::c0a8:1]:8080\";\n+\n+    #[test]\n+    fn parse_ipv4() {\n+        let result: Ipv4Addr = IPV4_STR.parse().unwrap();\n+        assert_eq!(result, IPV4);\n+\n+        assert!(Ipv4Addr::from_str(IPV4_STR_PORT).is_err());\n+        assert!(Ipv4Addr::from_str(IPV6_STR_FULL).is_err());\n+        assert!(Ipv4Addr::from_str(IPV6_STR_COMPRESS).is_err());\n+        assert!(Ipv4Addr::from_str(IPV6_STR_V4).is_err());\n+        assert!(Ipv4Addr::from_str(IPV6_STR_PORT).is_err());\n+    }\n+\n+    #[test]\n+    fn parse_ipv6() {\n+        let result: Ipv6Addr = IPV6_STR_FULL.parse().unwrap();\n+        assert_eq!(result, IPV6);\n+\n+        let result: Ipv6Addr = IPV6_STR_COMPRESS.parse().unwrap();\n+        assert_eq!(result, IPV6);\n+\n+        let result: Ipv6Addr = IPV6_STR_V4.parse().unwrap();\n+        assert_eq!(result, IPV6);\n+\n+        assert!(Ipv6Addr::from_str(IPV4_STR).is_err());\n+        assert!(Ipv6Addr::from_str(IPV4_STR_PORT).is_err());\n+        assert!(Ipv6Addr::from_str(IPV6_STR_PORT).is_err());\n+    }\n+\n+    #[test]\n+    fn parse_ip() {\n+        let result: IpAddr = IPV4_STR.parse().unwrap();\n+        assert_eq!(result, IpAddr::from(IPV4));\n+\n+        let result: IpAddr = IPV6_STR_FULL.parse().unwrap();\n+        assert_eq!(result, IpAddr::from(IPV6));\n+\n+        let result: IpAddr = IPV6_STR_COMPRESS.parse().unwrap();\n+        assert_eq!(result, IpAddr::from(IPV6));\n+\n+        let result: IpAddr = IPV6_STR_V4.parse().unwrap();\n+        assert_eq!(result, IpAddr::from(IPV6));\n+\n+        assert!(IpAddr::from_str(IPV4_STR_PORT).is_err());\n+        assert!(IpAddr::from_str(IPV6_STR_PORT).is_err());\n+    }\n+\n+    #[test]\n+    fn parse_socket_v4() {\n+        let result: SocketAddrV4 = IPV4_STR_PORT.parse().unwrap();\n+        assert_eq!(result, SocketAddrV4::new(IPV4, PORT));\n+\n+        assert!(SocketAddrV4::from_str(IPV4_STR).is_err());\n+        assert!(SocketAddrV4::from_str(IPV6_STR_FULL).is_err());\n+        assert!(SocketAddrV4::from_str(IPV6_STR_COMPRESS).is_err());\n+        assert!(SocketAddrV4::from_str(IPV6_STR_V4).is_err());\n+        assert!(SocketAddrV4::from_str(IPV6_STR_PORT).is_err());\n+    }\n+\n+    #[test]\n+    fn parse_socket_v6() {\n+        let result: SocketAddrV6 = IPV6_STR_PORT.parse().unwrap();\n+        assert_eq!(result, SocketAddrV6::new(IPV6, PORT, 0, 0));\n+\n+        assert!(SocketAddrV6::from_str(IPV4_STR).is_err());\n+        assert!(SocketAddrV6::from_str(IPV4_STR_PORT).is_err());\n+        assert!(SocketAddrV6::from_str(IPV6_STR_FULL).is_err());\n+        assert!(SocketAddrV6::from_str(IPV6_STR_COMPRESS).is_err());\n+        assert!(SocketAddrV6::from_str(IPV6_STR_V4).is_err());\n+    }\n+\n+    #[test]\n+    fn parse_socket() {\n+        let result: SocketAddr = IPV4_STR_PORT.parse().unwrap();\n+        assert_eq!(result, SocketAddr::from((IPV4, PORT)));\n+\n+        let result: SocketAddr = IPV6_STR_PORT.parse().unwrap();\n+        assert_eq!(result, SocketAddr::from((IPV6, PORT)));\n+\n+        assert!(SocketAddr::from_str(IPV4_STR).is_err());\n+        assert!(SocketAddr::from_str(IPV6_STR_FULL).is_err());\n+        assert!(SocketAddr::from_str(IPV6_STR_COMPRESS).is_err());\n+        assert!(SocketAddr::from_str(IPV6_STR_V4).is_err());\n+    }\n+\n+    #[test]\n+    fn ipv6_corner_cases() {\n+        let result: Ipv6Addr = \"1::\".parse().unwrap();\n+        assert_eq!(result, Ipv6Addr::new(1, 0, 0, 0, 0, 0, 0, 0));\n+\n+        let result: Ipv6Addr = \"1:1::\".parse().unwrap();\n+        assert_eq!(result, Ipv6Addr::new(1, 1, 0, 0, 0, 0, 0, 0));\n+\n+        let result: Ipv6Addr = \"::1\".parse().unwrap();\n+        assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n+\n+        let result: Ipv6Addr = \"::1:1\".parse().unwrap();\n+        assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 1, 1));\n+\n+        let result: Ipv6Addr = \"::\".parse().unwrap();\n+        assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0));\n+\n+        let result: Ipv6Addr = \"::192.168.0.1\".parse().unwrap();\n+        assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0xc0a8, 0x1));\n+\n+        let result: Ipv6Addr = \"::1:192.168.0.1\".parse().unwrap();\n+        assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 1, 0xc0a8, 0x1));\n+\n+        let result: Ipv6Addr = \"1:1:1:1:1:1:192.168.0.1\".parse().unwrap();\n+        assert_eq!(result, Ipv6Addr::new(1, 1, 1, 1, 1, 1, 0xc0a8, 0x1));\n+    }\n+\n+    // Things that might not seem like failures but are\n+    #[test]\n+    fn ipv6_corner_failures() {\n+        // No IP address before the ::\n+        assert!(Ipv6Addr::from_str(\"1:192.168.0.1::\").is_err());\n+\n+        // :: must have at least 1 set of zeroes\n+        assert!(Ipv6Addr::from_str(\"1:1:1:1::1:1:1:1\").is_err());\n+\n+        // Need brackets for a port\n+        assert!(SocketAddrV6::from_str(\"1:1:1:1:1:1:1:1:8080\").is_err());\n+    }\n+}"}, {"sha": "193ab5b47ef1332cf6c9d26e631acd5a28907d77", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -61,6 +61,7 @@ pub fn decode_error_kind(errno: i32) -> ErrorKind {\n         c::ERROR_FILE_NOT_FOUND => return ErrorKind::NotFound,\n         c::ERROR_PATH_NOT_FOUND => return ErrorKind::NotFound,\n         c::ERROR_NO_DATA => return ErrorKind::BrokenPipe,\n+        c::ERROR_INVALID_PARAMETER => return ErrorKind::InvalidInput,\n         c::ERROR_SEM_TIMEOUT\n         | c::WAIT_TIMEOUT\n         | c::ERROR_DRIVER_CANCEL_TIMEOUT"}, {"sha": "840294db0830a043138c337386bf15a8dacc223a", "filename": "src/test/ui/anon-params/anon-params-denied-2018.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Fanon-params%2Fanon-params-denied-2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Fanon-params%2Fanon-params-denied-2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fanon-params%2Fanon-params-denied-2018.stderr?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -9,7 +9,7 @@ help: if this is a `self` type, give it a parameter name\n    |\n LL |     fn foo(self: i32);\n    |            ^^^^^^^^^\n-help: if this was a parameter name, give it a type\n+help: if this is a parameter name, give it a type\n    |\n LL |     fn foo(i32: TypeName);\n    |            ^^^^^^^^^^^^^\n@@ -29,7 +29,7 @@ help: if this is a `self` type, give it a parameter name\n    |\n LL |     fn bar_with_default_impl(self: String, String) {}\n    |                              ^^^^^^^^^^^^\n-help: if this was a parameter name, give it a type\n+help: if this is a parameter name, give it a type\n    |\n LL |     fn bar_with_default_impl(String: TypeName, String) {}\n    |                              ^^^^^^^^^^^^^^^^\n@@ -45,7 +45,7 @@ LL |     fn bar_with_default_impl(String, String) {}\n    |                                            ^ expected one of `:`, `@`, or `|`\n    |\n    = note: anonymous parameters are removed in the 2018 edition (see RFC 1685)\n-help: if this was a parameter name, give it a type\n+help: if this is a parameter name, give it a type\n    |\n LL |     fn bar_with_default_impl(String, String: TypeName) {}\n    |                                      ^^^^^^^^^^^^^^^^\n@@ -61,7 +61,7 @@ LL |     fn baz(a:usize, b, c: usize) -> usize {\n    |                      ^ expected one of `:`, `@`, or `|`\n    |\n    = note: anonymous parameters are removed in the 2018 edition (see RFC 1685)\n-help: if this was a parameter name, give it a type\n+help: if this is a parameter name, give it a type\n    |\n LL |     fn baz(a:usize, b: TypeName, c: usize) -> usize {\n    |                     ^^^^^^^^^^^"}, {"sha": "9931697e4129c2b7dfa6a0bb83f4343f65a4d38f", "filename": "src/test/ui/asm/sym.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Fasm%2Fsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Fasm%2Fsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fsym.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -3,7 +3,7 @@\n // only-linux\n // run-pass\n \n-#![feature(asm, track_caller, thread_local)]\n+#![feature(asm, thread_local)]\n \n extern \"C\" fn f1() -> i32 {\n     111"}, {"sha": "5093916e73a45b68aa0672aae38da94b83fc1fbe", "filename": "src/test/ui/async-await/issue-67765-async-diagnostic.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Fasync-await%2Fissue-67765-async-diagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Fasync-await%2Fissue-67765-async-diagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-67765-async-diagnostic.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -0,0 +1,16 @@\n+// edition:2018\n+//\n+// Regression test for issue #67765\n+// Tests that we point at the proper location when giving\n+// a lifetime error.\n+fn main() {}\n+\n+async fn func<'a>() -> Result<(), &'a str> {\n+    let s = String::new();\n+\n+    let b = &s[..];\n+\n+    Err(b)?; //~ ERROR cannot return value referencing local variable `s`\n+\n+    Ok(())\n+}"}, {"sha": "78253042bee1c35eb4ace7a201f892bbf5d3a92e", "filename": "src/test/ui/async-await/issue-67765-async-diagnostic.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Fasync-await%2Fissue-67765-async-diagnostic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Fasync-await%2Fissue-67765-async-diagnostic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-67765-async-diagnostic.stderr?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -0,0 +1,12 @@\n+error[E0515]: cannot return value referencing local variable `s`\n+  --> $DIR/issue-67765-async-diagnostic.rs:13:11\n+   |\n+LL |     let b = &s[..];\n+   |              - `s` is borrowed here\n+LL | \n+LL |     Err(b)?;\n+   |           ^ returns a value referencing data owned by the current function\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0515`."}, {"sha": "5865cf0a4f754facf2d04bdfd7ecfb49502b41fb", "filename": "src/test/ui/feature-gates/feature-gate-track_caller.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1505c1239554fd8c9a5f7a6f4823c7384a0c29e3/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-track_caller.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1505c1239554fd8c9a5f7a6f4823c7384a0c29e3/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-track_caller.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-track_caller.rs?ref=1505c1239554fd8c9a5f7a6f4823c7384a0c29e3", "patch": "@@ -1,5 +0,0 @@\n-#[track_caller]\n-fn f() {}\n-//~^^ ERROR the `#[track_caller]` attribute is an experimental feature\n-\n-fn main() {}"}, {"sha": "8ceab501617eec6539ad1ac93d31acea7b05fde7", "filename": "src/test/ui/feature-gates/feature-gate-track_caller.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1505c1239554fd8c9a5f7a6f4823c7384a0c29e3/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-track_caller.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1505c1239554fd8c9a5f7a6f4823c7384a0c29e3/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-track_caller.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-track_caller.stderr?ref=1505c1239554fd8c9a5f7a6f4823c7384a0c29e3", "patch": "@@ -1,12 +0,0 @@\n-error[E0658]: the `#[track_caller]` attribute is an experimental feature\n-  --> $DIR/feature-gate-track_caller.rs:1:1\n-   |\n-LL | #[track_caller]\n-   | ^^^^^^^^^^^^^^^\n-   |\n-   = note: see issue #47809 <https://github.com/rust-lang/rust/issues/47809> for more information\n-   = help: add `#![feature(track_caller)]` to the crate attributes to enable\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "7aea2f220466c53a0a0aed36d390b3a433d9b2fe", "filename": "src/test/ui/in-band-lifetimes/E0687.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Fin-band-lifetimes%2FE0687.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Fin-band-lifetimes%2FE0687.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2FE0687.stderr?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -24,3 +24,4 @@ LL |     fn bar(&self, x: fn(&'a u32)) {}\n \n error: aborting due to 4 previous errors\n \n+For more information about this error, try `rustc --explain E0687`."}, {"sha": "af0f9665f5d06df7ded816bc7e4b9bde522a8ffd", "filename": "src/test/ui/in-band-lifetimes/E0687_where.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Fin-band-lifetimes%2FE0687_where.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Fin-band-lifetimes%2FE0687_where.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2FE0687_where.stderr?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -12,3 +12,4 @@ LL | fn baz(x: &impl Fn(&'a u32)) {}\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0687`."}, {"sha": "8deb3655158409ae252528e7d023615c19e8b419", "filename": "src/test/ui/lifetimes/unnamed-closure-doesnt-life-long-enough-issue-67634.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Flifetimes%2Funnamed-closure-doesnt-life-long-enough-issue-67634.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Flifetimes%2Funnamed-closure-doesnt-life-long-enough-issue-67634.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Funnamed-closure-doesnt-life-long-enough-issue-67634.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1,3 +1,3 @@\n fn main() {\n-    [0].iter().flat_map(|a| [0].iter().map(|_| &a)); //~ ERROR `a` does not live long enough\n+    [0].iter().flat_map(|a| [0].iter().map(|_| &a)); //~ ERROR closure may outlive\n }"}, {"sha": "34470119112fbf60b35265029b804dfcf4fc9dad", "filename": "src/test/ui/lifetimes/unnamed-closure-doesnt-life-long-enough-issue-67634.stderr", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Flifetimes%2Funnamed-closure-doesnt-life-long-enough-issue-67634.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Flifetimes%2Funnamed-closure-doesnt-life-long-enough-issue-67634.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Funnamed-closure-doesnt-life-long-enough-issue-67634.stderr?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1,15 +1,21 @@\n-error[E0597]: `a` does not live long enough\n-  --> $DIR/unnamed-closure-doesnt-life-long-enough-issue-67634.rs:2:49\n+error[E0373]: closure may outlive the current function, but it borrows `a`, which is owned by the current function\n+  --> $DIR/unnamed-closure-doesnt-life-long-enough-issue-67634.rs:2:44\n    |\n LL |     [0].iter().flat_map(|a| [0].iter().map(|_| &a));\n-   |                                             -   ^- ...but `a` will be dropped here, when the enclosing closure returns\n-   |                                             |   |\n-   |                                             |   `a` would have to be valid for `'_`...\n-   |                                             has type `&i32`\n+   |                                            ^^^  - `a` is borrowed here\n+   |                                            |\n+   |                                            may outlive borrowed value `a`\n    |\n-   = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#dangling-references>\n+note: closure is returned here\n+  --> $DIR/unnamed-closure-doesnt-life-long-enough-issue-67634.rs:2:29\n+   |\n+LL |     [0].iter().flat_map(|a| [0].iter().map(|_| &a));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^\n+help: to force the closure to take ownership of `a` (and any other referenced variables), use the `move` keyword\n+   |\n+LL |     [0].iter().flat_map(|a| [0].iter().map(move |_| &a));\n+   |                                            ^^^^^^^^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0597`.\n+For more information about this error, try `rustc --explain E0373`."}, {"sha": "8772e98b6e9bb584be90dca90902dd91b8a90ec5", "filename": "src/test/ui/macros/issue-68060.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Fmacros%2Fissue-68060.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Fmacros%2Fissue-68060.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-68060.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1,5 +1,3 @@\n-#![feature(track_caller)]\n-\n fn main() {\n     (0..)\n         .map("}, {"sha": "b9b2f946c5967bc6915bb9cd9b26efb39b11c084", "filename": "src/test/ui/macros/issue-68060.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Fmacros%2Fissue-68060.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Fmacros%2Fissue-68060.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-68060.stderr?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: `#[target_feature(..)]` can only be applied to `unsafe` functions\n-  --> $DIR/issue-68060.rs:6:13\n+  --> $DIR/issue-68060.rs:4:13\n    |\n LL |             #[target_feature(enable = \"\")]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -11,13 +11,13 @@ LL |             |_| (),\n    = help: add `#![feature(target_feature_11)]` to the crate attributes to enable\n \n error: the feature named `` is not valid for this target\n-  --> $DIR/issue-68060.rs:6:30\n+  --> $DIR/issue-68060.rs:4:30\n    |\n LL |             #[target_feature(enable = \"\")]\n    |                              ^^^^^^^^^^^ `` is not valid for this target\n \n error[E0737]: `#[track_caller]` requires Rust ABI\n-  --> $DIR/issue-68060.rs:9:13\n+  --> $DIR/issue-68060.rs:7:13\n    |\n LL |             #[track_caller]\n    |             ^^^^^^^^^^^^^^^"}, {"sha": "825a11972aeebc517d63eed12f0cbbfd304c6c9d", "filename": "src/test/ui/numbers-arithmetic/saturating-float-casts.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -9,7 +9,6 @@\n // merged.\n \n #![feature(test, stmt_expr_attributes)]\n-#![feature(track_caller)]\n #![deny(overflowing_literals)]\n extern crate test;\n "}, {"sha": "5c4272504e061055fcd5c991e26e5d864404e1f5", "filename": "src/test/ui/parser/inverted-parameters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Fparser%2Finverted-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Fparser%2Finverted-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Finverted-parameters.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -20,7 +20,7 @@ fn pattern((i32, i32) (a, b)) {}\n \n fn fizz(i32) {}\n //~^ ERROR expected one of `:`, `@`\n-//~| HELP if this was a parameter name, give it a type\n+//~| HELP if this is a parameter name, give it a type\n //~| HELP if this is a `self` type, give it a parameter name\n //~| HELP if this is a type, explicitly ignore the parameter name\n "}, {"sha": "ae180af93e37394ce0bab605db1cbe10ac18848d", "filename": "src/test/ui/parser/inverted-parameters.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Fparser%2Finverted-parameters.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Fparser%2Finverted-parameters.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Finverted-parameters.stderr?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -39,7 +39,7 @@ help: if this is a `self` type, give it a parameter name\n    |\n LL | fn fizz(self: i32) {}\n    |         ^^^^^^^^^\n-help: if this was a parameter name, give it a type\n+help: if this is a parameter name, give it a type\n    |\n LL | fn fizz(i32: TypeName) {}\n    |         ^^^^^^^^^^^^^"}, {"sha": "bc3329dcbc23d91ee20c41bf013a119701fe3e4d", "filename": "src/test/ui/parser/omitted-arg-in-item-fn.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Fparser%2Fomitted-arg-in-item-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Fparser%2Fomitted-arg-in-item-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fomitted-arg-in-item-fn.stderr?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -9,7 +9,7 @@ help: if this is a `self` type, give it a parameter name\n    |\n LL | fn foo(self: x) {\n    |        ^^^^^^^\n-help: if this was a parameter name, give it a type\n+help: if this is a parameter name, give it a type\n    |\n LL | fn foo(x: TypeName) {\n    |        ^^^^^^^^^^^"}, {"sha": "d0feb3b65e12ac09bab1b0c7a7d8686725308952", "filename": "src/test/ui/return-disjoint-regions.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Freturn-disjoint-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Freturn-disjoint-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freturn-disjoint-regions.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -0,0 +1,7 @@\n+// See https://github.com/rust-lang/rust/pull/67911#issuecomment-576023915\n+fn f<'a, 'b>(x: i32) -> (&'a i32, &'b i32) {\n+    let y = &x;\n+    (y, y) //~ ERROR cannot return\n+}\n+\n+fn main() {}"}, {"sha": "ed159298804ae89265c0e2cc321e3689c7a0ced1", "filename": "src/test/ui/return-disjoint-regions.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Freturn-disjoint-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Freturn-disjoint-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freturn-disjoint-regions.stderr?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -0,0 +1,11 @@\n+error[E0515]: cannot return value referencing function parameter `x`\n+  --> $DIR/return-disjoint-regions.rs:4:5\n+   |\n+LL |     let y = &x;\n+   |             -- `x` is borrowed here\n+LL |     (y, y)\n+   |     ^^^^^^ returns a value referencing data owned by the current function\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0515`."}, {"sha": "fefb84de729fed481dec362ebebbe72bb983872d", "filename": "src/test/ui/rfc-2091-track-caller/call-chain.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fcall-chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fcall-chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fcall-chain.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1,7 +1,5 @@\n // run-pass\n \n-#![feature(track_caller)]\n-\n use std::panic::Location;\n \n struct Foo;"}, {"sha": "05240908917bc0f37e55ead53e56ab9a1dd67f15", "filename": "src/test/ui/rfc-2091-track-caller/caller-location-fnptr-rt-ctfe-equiv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fcaller-location-fnptr-rt-ctfe-equiv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fcaller-location-fnptr-rt-ctfe-equiv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fcaller-location-fnptr-rt-ctfe-equiv.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -6,7 +6,7 @@\n // run-pass\n // compile-flags: -Z unleash-the-miri-inside-of-you\n \n-#![feature(core_intrinsics, const_caller_location, track_caller, const_fn)]\n+#![feature(core_intrinsics, const_caller_location, const_fn)]\n \n type L = &'static std::panic::Location<'static>;\n "}, {"sha": "f244b74e391ffa4a2d098947fffb0ca7a3638fc1", "filename": "src/test/ui/rfc-2091-track-caller/caller-location-intrinsic.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fcaller-location-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fcaller-location-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fcaller-location-intrinsic.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1,7 +1,5 @@\n // run-pass\n \n-#![feature(track_caller)]\n-\n #[inline(never)]\n #[track_caller]\n fn codegen_caller_loc() -> &'static core::panic::Location<'static> {\n@@ -15,13 +13,13 @@ macro_rules! caller_location_from_macro {\n fn main() {\n     let loc = codegen_caller_loc();\n     assert_eq!(loc.file(), file!());\n-    assert_eq!(loc.line(), 16);\n+    assert_eq!(loc.line(), 14);\n     assert_eq!(loc.column(), 15);\n \n     // `Location::caller()` in a macro should behave similarly to `file!` and `line!`,\n     // i.e. point to where the macro was invoked, instead of the macro itself.\n     let loc2 = caller_location_from_macro!();\n     assert_eq!(loc2.file(), file!());\n-    assert_eq!(loc2.line(), 23);\n+    assert_eq!(loc2.line(), 21);\n     assert_eq!(loc2.column(), 16);\n }"}, {"sha": "8030a4d967a676dfe98eec70cb745ddd6677f647", "filename": "src/test/ui/rfc-2091-track-caller/const-caller-location.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fconst-caller-location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fconst-caller-location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fconst-caller-location.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1,6 +1,6 @@\n // run-pass\n \n-#![feature(const_fn, track_caller)]\n+#![feature(const_caller_location, const_fn)]\n \n use std::panic::Location;\n "}, {"sha": "6681119557d797616a37273a6d10160fdea21b16", "filename": "src/test/ui/rfc-2091-track-caller/diverging-caller-location.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fdiverging-caller-location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fdiverging-caller-location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fdiverging-caller-location.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -6,8 +6,6 @@\n //! we don't inspect the location returned -- it would be difficult to distinguish between the\n //! explicit panic and a failed assertion. That it compiles and runs is enough for this one.\n \n-#![feature(track_caller)]\n-\n #[track_caller]\n fn doesnt_return() -> ! {\n     let _location = core::panic::Location::caller();"}, {"sha": "6f4290e2a5ee955287429fd4b357b8bb5aadc8a7", "filename": "src/test/ui/rfc-2091-track-caller/error-odd-syntax.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-odd-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-odd-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-odd-syntax.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1,5 +1,3 @@\n-#![feature(track_caller)]\n-\n #[track_caller(1)]\n fn f() {}\n //~^^ ERROR malformed `track_caller` attribute input"}, {"sha": "e7ddf8df4ab53fcb8e8554aac3816045b1f15a75", "filename": "src/test/ui/rfc-2091-track-caller/error-odd-syntax.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-odd-syntax.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-odd-syntax.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-odd-syntax.stderr?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1,5 +1,5 @@\n error: malformed `track_caller` attribute input\n-  --> $DIR/error-odd-syntax.rs:3:1\n+  --> $DIR/error-odd-syntax.rs:1:1\n    |\n LL | #[track_caller(1)]\n    | ^^^^^^^^^^^^^^^^^^ help: must be of the form: `#[track_caller]`"}, {"sha": "074e1ceb791cef1ebc67632211a898edcf330660", "filename": "src/test/ui/rfc-2091-track-caller/error-with-invalid-abi.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-invalid-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-invalid-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-invalid-abi.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1,5 +1,3 @@\n-#![feature(track_caller)]\n-\n #[track_caller]\n extern \"C\" fn f() {}\n //~^^ ERROR `#[track_caller]` requires Rust ABI"}, {"sha": "bcc0c8170e655f9261e43dd60d2614cb6173d71d", "filename": "src/test/ui/rfc-2091-track-caller/error-with-invalid-abi.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-invalid-abi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-invalid-abi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-invalid-abi.stderr?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1,11 +1,11 @@\n error[E0737]: `#[track_caller]` requires Rust ABI\n-  --> $DIR/error-with-invalid-abi.rs:3:1\n+  --> $DIR/error-with-invalid-abi.rs:1:1\n    |\n LL | #[track_caller]\n    | ^^^^^^^^^^^^^^^\n \n error[E0737]: `#[track_caller]` requires Rust ABI\n-  --> $DIR/error-with-invalid-abi.rs:8:5\n+  --> $DIR/error-with-invalid-abi.rs:6:5\n    |\n LL |     #[track_caller]\n    |     ^^^^^^^^^^^^^^^"}, {"sha": "2b110c9a325156081c18b7edb19d8e78eaf79c1f", "filename": "src/test/ui/rfc-2091-track-caller/error-with-naked.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-naked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-naked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-naked.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1,4 +1,4 @@\n-#![feature(naked_functions, track_caller)]\n+#![feature(naked_functions)]\n \n #[track_caller] //~ ERROR cannot use `#[track_caller]` with `#[naked]`\n #[naked]"}, {"sha": "74217f47084a33f2aee0bd8bbdae1be0c741ec26", "filename": "src/test/ui/rfc-2091-track-caller/intrinsic-wrapper.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fintrinsic-wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fintrinsic-wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fintrinsic-wrapper.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1,21 +1,19 @@\n // run-pass\n \n-#![feature(track_caller)]\n-\n macro_rules! caller_location_from_macro {\n     () => (core::panic::Location::caller());\n }\n \n fn main() {\n     let loc = core::panic::Location::caller();\n     assert_eq!(loc.file(), file!());\n-    assert_eq!(loc.line(), 10);\n+    assert_eq!(loc.line(), 8);\n     assert_eq!(loc.column(), 15);\n \n     // `Location::caller()` in a macro should behave similarly to `file!` and `line!`,\n     // i.e. point to where the macro was invoked, instead of the macro itself.\n     let loc2 = caller_location_from_macro!();\n     assert_eq!(loc2.file(), file!());\n-    assert_eq!(loc2.line(), 17);\n+    assert_eq!(loc2.line(), 15);\n     assert_eq!(loc2.column(), 16);\n }"}, {"sha": "bc0ca9552806f6ca9c8eb331d7dc53ca7b665c70", "filename": "src/test/ui/rfc-2091-track-caller/only-for-fns.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fonly-for-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fonly-for-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fonly-for-fns.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1,5 +1,3 @@\n-#![feature(track_caller)]\n-\n #[track_caller]\n struct S;\n //~^^ ERROR attribute should be applied to function"}, {"sha": "6666dcfa6e5995421e58365ec2782fa4d548a73b", "filename": "src/test/ui/rfc-2091-track-caller/only-for-fns.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fonly-for-fns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fonly-for-fns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fonly-for-fns.stderr?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1,5 +1,5 @@\n error[E0739]: attribute should be applied to function\n-  --> $DIR/only-for-fns.rs:3:1\n+  --> $DIR/only-for-fns.rs:1:1\n    |\n LL | #[track_caller]\n    | ^^^^^^^^^^^^^^^"}, {"sha": "ada150b25cf2c6830dd363123574151f75d4faaa", "filename": "src/test/ui/rfc-2091-track-caller/pass.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fpass.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1,6 +1,4 @@\n // run-pass\n-#![feature(track_caller)]\n-\n #[track_caller]\n fn f() {}\n "}, {"sha": "efcc1f6942de18f4dbb5033e68aff8daa7587a61", "filename": "src/test/ui/rfc-2091-track-caller/track-caller-attribute.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftrack-caller-attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftrack-caller-attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftrack-caller-attribute.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1,7 +1,5 @@\n // run-pass\n \n-#![feature(track_caller)]\n-\n use std::panic::Location;\n \n #[track_caller]\n@@ -20,21 +18,21 @@ fn nested_tracked() -> &'static Location<'static> {\n fn main() {\n     let location = Location::caller();\n     assert_eq!(location.file(), file!());\n-    assert_eq!(location.line(), 21);\n+    assert_eq!(location.line(), 19);\n     assert_eq!(location.column(), 20);\n \n     let tracked = tracked();\n     assert_eq!(tracked.file(), file!());\n-    assert_eq!(tracked.line(), 26);\n+    assert_eq!(tracked.line(), 24);\n     assert_eq!(tracked.column(), 19);\n \n     let nested = nested_intrinsic();\n     assert_eq!(nested.file(), file!());\n-    assert_eq!(nested.line(), 13);\n+    assert_eq!(nested.line(), 11);\n     assert_eq!(nested.column(), 5);\n \n     let contained = nested_tracked();\n     assert_eq!(contained.file(), file!());\n-    assert_eq!(contained.line(), 17);\n+    assert_eq!(contained.line(), 15);\n     assert_eq!(contained.column(), 5);\n }"}, {"sha": "5115f687c26328943da96d38f0c1a30beaa997a2", "filename": "src/test/ui/rfc-2091-track-caller/track-caller-ffi.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftrack-caller-ffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftrack-caller-ffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftrack-caller-ffi.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1,7 +1,5 @@\n // run-pass\n \n-#![feature(track_caller)]\n-\n use std::panic::Location;\n \n extern \"Rust\" {\n@@ -30,21 +28,21 @@ mod provides {\n fn main() {\n     let location = Location::caller();\n     assert_eq!(location.file(), file!());\n-    assert_eq!(location.line(), 31);\n+    assert_eq!(location.line(), 29);\n     assert_eq!(location.column(), 20);\n \n     let tracked = unsafe { rust_track_caller_ffi_test_tracked() };\n     assert_eq!(tracked.file(), file!());\n-    assert_eq!(tracked.line(), 36);\n+    assert_eq!(tracked.line(), 34);\n     assert_eq!(tracked.column(), 28);\n \n     let untracked = unsafe { rust_track_caller_ffi_test_untracked() };\n     assert_eq!(untracked.file(), file!());\n-    assert_eq!(untracked.line(), 26);\n+    assert_eq!(untracked.line(), 24);\n     assert_eq!(untracked.column(), 9);\n \n     let contained = rust_track_caller_ffi_test_nested_tracked();\n     assert_eq!(contained.file(), file!());\n-    assert_eq!(contained.line(), 14);\n+    assert_eq!(contained.line(), 12);\n     assert_eq!(contained.column(), 14);\n }"}, {"sha": "5fcfea96d547ab79cb25fe5cb1378b3542a7f5b7", "filename": "src/test/ui/rfc-2091-track-caller/tracked-fn-ptr-with-arg.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftracked-fn-ptr-with-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftracked-fn-ptr-with-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftracked-fn-ptr-with-arg.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1,7 +1,5 @@\n // run-pass\n \n-#![feature(track_caller)]\n-\n fn pass_to_ptr_call<T>(f: fn(T), x: T) {\n     f(x);\n }"}, {"sha": "4415d850c241ce9516b7f852e9fe38d423a46047", "filename": "src/test/ui/rfc-2091-track-caller/tracked-fn-ptr.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftracked-fn-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftracked-fn-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftracked-fn-ptr.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1,7 +1,5 @@\n // run-pass\n \n-#![feature(track_caller)]\n-\n fn ptr_call(f: fn()) {\n     f();\n }"}, {"sha": "4db4c29e53d580b8b37191d1d4459d0b27512141", "filename": "src/test/ui/rfc-2091-track-caller/tracked-trait-impls.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftracked-trait-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftracked-trait-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftracked-trait-impls.rs?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -1,7 +1,5 @@\n // run-pass\n \n-#![feature(track_caller)]\n-\n macro_rules! assert_expansion_site_is_tracked {\n     () => {{\n         let location = std::panic::Location::caller();"}, {"sha": "5516d4a4c1c1cd0398b944edf5e2c69dfdb39e54", "filename": "src/test/ui/rfc-2565-param-attrs/param-attrs-2018.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-2018.stderr?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -9,7 +9,7 @@ help: if this is a `self` type, give it a parameter name\n    |\n LL | trait Trait2015 { fn foo(#[allow(C)] self: i32); }\n    |                                      ^^^^^^^^^\n-help: if this was a parameter name, give it a type\n+help: if this is a parameter name, give it a type\n    |\n LL | trait Trait2015 { fn foo(#[allow(C)] i32: TypeName); }\n    |                                      ^^^^^^^^^^^^^"}, {"sha": "40c3219bf27b0497437a099e04da6d315e77054d", "filename": "src/test/ui/span/issue-34264.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Fspan%2Fissue-34264.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f781babf87dea29c44f93842b7ac9eb809549d29/src%2Ftest%2Fui%2Fspan%2Fissue-34264.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-34264.stderr?ref=f781babf87dea29c44f93842b7ac9eb809549d29", "patch": "@@ -21,7 +21,7 @@ LL | fn foo(Option<i32>, String) {}\n    |                           ^ expected one of `:`, `@`, or `|`\n    |\n    = note: anonymous parameters are removed in the 2018 edition (see RFC 1685)\n-help: if this was a parameter name, give it a type\n+help: if this is a parameter name, give it a type\n    |\n LL | fn foo(Option<i32>, String: TypeName) {}\n    |                     ^^^^^^^^^^^^^^^^\n@@ -41,7 +41,7 @@ help: if this is a `self` type, give it a parameter name\n    |\n LL | fn bar(self: x, y: usize) {}\n    |        ^^^^^^^\n-help: if this was a parameter name, give it a type\n+help: if this is a parameter name, give it a type\n    |\n LL | fn bar(x: TypeName, y: usize) {}\n    |        ^^^^^^^^^^^"}]}