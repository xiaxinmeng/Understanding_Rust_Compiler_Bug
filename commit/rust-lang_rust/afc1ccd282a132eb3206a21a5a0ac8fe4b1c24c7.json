{"sha": "afc1ccd282a132eb3206a21a5a0ac8fe4b1c24c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmYzFjY2QyODJhMTMyZWIzMjA2YTIxYTVhMGFjOGZlNGIxYzI0Yzc=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2012-08-31T21:51:48Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2012-08-31T21:51:48Z"}, "message": "Merge pull request #3308 from killerswan/modes7\n\nRemove deprecated modes", "tree": {"sha": "87066c4636ce88fc85e8ef6f8feac51d8b1d1a75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87066c4636ce88fc85e8ef6f8feac51d8b1d1a75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afc1ccd282a132eb3206a21a5a0ac8fe4b1c24c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afc1ccd282a132eb3206a21a5a0ac8fe4b1c24c7", "html_url": "https://github.com/rust-lang/rust/commit/afc1ccd282a132eb3206a21a5a0ac8fe4b1c24c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afc1ccd282a132eb3206a21a5a0ac8fe4b1c24c7/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3cd54ab1f2f351484a2869120c580b13b2ca7eec", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cd54ab1f2f351484a2869120c580b13b2ca7eec", "html_url": "https://github.com/rust-lang/rust/commit/3cd54ab1f2f351484a2869120c580b13b2ca7eec"}, {"sha": "7d57b4864a90776d46898f97a3f4b9b6519cf38d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d57b4864a90776d46898f97a3f4b9b6519cf38d", "html_url": "https://github.com/rust-lang/rust/commit/7d57b4864a90776d46898f97a3f4b9b6519cf38d"}], "stats": {"total": 120, "additions": 71, "deletions": 49}, "files": [{"sha": "6484bf298d2d976222fecd8c21d7561341cdaafe", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/afc1ccd282a132eb3206a21a5a0ac8fe4b1c24c7/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc1ccd282a132eb3206a21a5a0ac8fe4b1c24c7/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=afc1ccd282a132eb3206a21a5a0ac8fe4b1c24c7", "patch": "@@ -1,34 +1,36 @@\n #[deny(non_camel_case_types)];\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n /// Additional general-purpose comparison functionality.\n \n const fuzzy_epsilon: float = 1.0e-6;\n \n trait FuzzyEq {\n-    pure fn fuzzy_eq(&&other: self) -> bool;\n+    pure fn fuzzy_eq(other: &self) -> bool;\n }\n \n impl float: FuzzyEq {\n-    pure fn fuzzy_eq(&&other: float) -> bool {\n-        return float::abs(self - other) < fuzzy_epsilon;\n+    pure fn fuzzy_eq(other: &float) -> bool {\n+        return float::abs(self - *other) < fuzzy_epsilon;\n     }\n }\n \n impl f32: FuzzyEq {\n-    pure fn fuzzy_eq(&&other: f32) -> bool {\n-        return f32::abs(self - other) < (fuzzy_epsilon as f32);\n+    pure fn fuzzy_eq(other: &f32) -> bool {\n+        return f32::abs(self - *other) < (fuzzy_epsilon as f32);\n     }\n }\n \n impl f64: FuzzyEq {\n-    pure fn fuzzy_eq(&&other: f64) -> bool {\n-        return f64::abs(self - other) < (fuzzy_epsilon as f64);\n+    pure fn fuzzy_eq(other: &f64) -> bool {\n+        return f64::abs(self - *other) < (fuzzy_epsilon as f64);\n     }\n }\n \n #[test]\n fn test_fuzzy_equals() {\n-    assert ((1.0).fuzzy_eq(1.0));\n-    assert ((1.0f32).fuzzy_eq(1.0f32));\n-    assert ((1.0f64).fuzzy_eq(1.0f64));\n+    assert ((&1.0).fuzzy_eq(&1.0));\n+    assert ((&1.0f32).fuzzy_eq(&1.0f32));\n+    assert ((&1.0f64).fuzzy_eq(&1.0f64));\n }\n "}, {"sha": "386cfee1a6a78d7f7c0a5394dd8d7c421ad13866", "filename": "src/libstd/dbg.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/afc1ccd282a132eb3206a21a5a0ac8fe4b1c24c7/src%2Flibstd%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc1ccd282a132eb3206a21a5a0ac8fe4b1c24c7/src%2Flibstd%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdbg.rs?ref=afc1ccd282a132eb3206a21a5a0ac8fe4b1c24c7", "patch": "@@ -1,4 +1,6 @@\n #[deny(non_camel_case_types)];\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n //! Unsafe debugging functions for inspecting values.\n \n import unsafe::reinterpret_cast;\n@@ -26,19 +28,19 @@ fn debug_tydesc<T>() {\n     rustrt::debug_tydesc(sys::get_type_desc::<T>());\n }\n \n-fn debug_opaque<T>(x: T) {\n+fn debug_opaque<T>(+x: T) {\n     rustrt::debug_opaque(sys::get_type_desc::<T>(), ptr::addr_of(x) as *());\n }\n \n fn debug_box<T>(x: @T) {\n     rustrt::debug_box(sys::get_type_desc::<T>(), ptr::addr_of(x) as *());\n }\n \n-fn debug_tag<T>(x: T) {\n+fn debug_tag<T>(+x: T) {\n     rustrt::debug_tag(sys::get_type_desc::<T>(), ptr::addr_of(x) as *());\n }\n \n-fn debug_fn<T>(x: T) {\n+fn debug_fn<T>(+x: T) {\n     rustrt::debug_fn(sys::get_type_desc::<T>(), ptr::addr_of(x) as *());\n }\n "}, {"sha": "e1ff5c8b352b61a9765b130a4c6c2a32eaa009ba", "filename": "src/libstd/list.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/afc1ccd282a132eb3206a21a5a0ac8fe4b1c24c7/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc1ccd282a132eb3206a21a5a0ac8fe4b1c24c7/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=afc1ccd282a132eb3206a21a5a0ac8fe4b1c24c7", "patch": "@@ -1,4 +1,6 @@\n //! A standard linked list\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n \n import core::cmp::Eq;\n import core::option;\n@@ -28,9 +30,9 @@ fn from_vec<T: copy>(v: &[T]) -> @list<T> {\n  * * z - The initial value\n  * * f - The function to apply\n  */\n-fn foldl<T: copy, U>(z: T, ls: @list<U>, f: fn(T, U) -> T) -> T {\n+fn foldl<T: copy, U>(+z: T, ls: @list<U>, f: fn((&T), (&U)) -> T) -> T {\n     let mut accum: T = z;\n-    do iter(ls) |elt| { accum = f(accum, elt);}\n+    do iter(ls) |elt| { accum = f(&accum, &elt);}\n     accum\n }\n \n@@ -41,12 +43,12 @@ fn foldl<T: copy, U>(z: T, ls: @list<U>, f: fn(T, U) -> T) -> T {\n  * When function `f` returns true then an option containing the element\n  * is returned. If `f` matches no elements then none is returned.\n  */\n-fn find<T: copy>(ls: @list<T>, f: fn(T) -> bool) -> Option<T> {\n+fn find<T: copy>(ls: @list<T>, f: fn((&T)) -> bool) -> Option<T> {\n     let mut ls = ls;\n     loop {\n         ls = match *ls {\n           cons(hd, tl) => {\n-            if f(hd) { return Some(hd); }\n+            if f(&hd) { return Some(hd); }\n             tl\n           }\n           nil => return None\n@@ -55,7 +57,7 @@ fn find<T: copy>(ls: @list<T>, f: fn(T) -> bool) -> Option<T> {\n }\n \n /// Returns true if a list contains an element with the given value\n-fn has<T: copy Eq>(ls: @list<T>, elt: T) -> bool {\n+fn has<T: copy Eq>(ls: @list<T>, +elt: T) -> bool {\n     for each(ls) |e| {\n         if e == elt { return true; }\n     }\n@@ -110,10 +112,13 @@ pure fn append<T: copy>(l: @list<T>, m: @list<T>) -> @list<T> {\n     }\n }\n \n-/// Push an element to the front of a list\n-fn push<T: copy>(&l: list<T>, v: T) {\n-    l = cons(v, @l);\n+/*\n+/// Push one element into the front of a list, returning a new list\n+/// THIS VERSION DOESN'T ACTUALLY WORK\n+pure fn push<T: copy>(ll: &mut @list<T>, +vv: T) {\n+    ll = &mut @cons(vv, *ll)\n }\n+*/\n \n /// Iterate over a list\n fn iter<T>(l: @list<T>, f: fn(T)) {\n@@ -201,7 +206,7 @@ mod tests {\n \n     #[test]\n     fn test_foldl() {\n-        fn add(&&a: uint, &&b: int) -> uint { return a + (b as uint); }\n+        fn add(a: &uint, b: &int) -> uint { return *a + (*b as uint); }\n         let l = from_vec(~[0, 1, 2, 3, 4]);\n         let empty = @list::nil::<int>;\n         assert (list::foldl(0u, l, add) == 10u);\n@@ -210,23 +215,23 @@ mod tests {\n \n     #[test]\n     fn test_foldl2() {\n-        fn sub(&&a: int, &&b: int) -> int {\n-            a - b\n+        fn sub(a: &int, b: &int) -> int {\n+            *a - *b\n         }\n         let l = from_vec(~[1, 2, 3, 4]);\n         assert (list::foldl(0, l, sub) == -10);\n     }\n \n     #[test]\n     fn test_find_success() {\n-        fn match_(&&i: int) -> bool { return i == 2; }\n+        fn match_(i: &int) -> bool { return *i == 2; }\n         let l = from_vec(~[0, 1, 2]);\n         assert (list::find(l, match_) == option::Some(2));\n     }\n \n     #[test]\n     fn test_find_fail() {\n-        fn match_(&&_i: int) -> bool { return false; }\n+        fn match_(_i: &int) -> bool { return false; }\n         let l = from_vec(~[0, 1, 2]);\n         let empty = @list::nil::<int>;\n         assert (list::find(l, match_) == option::None::<int>);\n@@ -251,6 +256,11 @@ mod tests {\n         assert (list::len(empty) == 0u);\n     }\n \n+    #[test]\n+    fn test_append() {\n+        assert from_vec(~[1,2,3,4])\n+            == list::append(list::from_vec(~[1,2]), list::from_vec(~[3,4]));\n+    }\n }\n \n // Local Variables:"}, {"sha": "d9e64d7b1a0deb1901b1c769bf0fd148927061a1", "filename": "src/libstd/prettyprint.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/afc1ccd282a132eb3206a21a5a0ac8fe4b1c24c7/src%2Flibstd%2Fprettyprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc1ccd282a132eb3206a21a5a0ac8fe4b1c24c7/src%2Flibstd%2Fprettyprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprettyprint.rs?ref=afc1ccd282a132eb3206a21a5a0ac8fe4b1c24c7", "patch": "@@ -1,3 +1,6 @@\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n import io::Writer;\n import io::WriterUtil;\n import serialization::serializer;"}, {"sha": "12676377defafc2d91a64bba1484d7af7452df26", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/afc1ccd282a132eb3206a21a5a0ac8fe4b1c24c7/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc1ccd282a132eb3206a21a5a0ac8fe4b1c24c7/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=afc1ccd282a132eb3206a21a5a0ac8fe4b1c24c7", "patch": "@@ -23,6 +23,8 @@\n  * * access to a character by index is logarithmic (linear in strings);\n  */\n \n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n \n /// The type of ropes.\n type rope = node::root;\n@@ -436,7 +438,7 @@ mod iterator {\n               node::content(x) => return node::leaf_iterator::start(x)\n             }\n         }\n-        fn next(it: node::leaf_iterator::t) -> Option<node::leaf> {\n+        fn next(it: &node::leaf_iterator::t) -> Option<node::leaf> {\n             return node::leaf_iterator::next(it);\n         }\n     }\n@@ -447,7 +449,7 @@ mod iterator {\n               node::content(x) => return node::char_iterator::start(x)\n             }\n         }\n-        fn next(it: node::char_iterator::t) -> Option<char> {\n+        fn next(it: &node::char_iterator::t) -> Option<char> {\n             return node::char_iterator::next(it)\n         }\n     }\n@@ -751,7 +753,7 @@ mod node {\n      * * forest - The forest. This vector is progressively rewritten during\n      *            execution and should be discarded as meaningless afterwards.\n      */\n-    fn tree_from_forest_destructive(forest: ~[mut @node]) -> @node {\n+    fn tree_from_forest_destructive(forest: &[mut @node]) -> @node {\n         let mut i;\n         let mut len = vec::len(forest);\n         while len > 1u {\n@@ -800,7 +802,7 @@ mod node {\n         let mut offset = 0u;//Current position in the buffer\n         let it = leaf_iterator::start(node);\n         loop {\n-            match (leaf_iterator::next(it)) {\n+            match (leaf_iterator::next(&it)) {\n               option::None => break,\n               option::Some(x) => {\n                 //FIXME (#2744): Replace with memcpy or something similar\n@@ -861,7 +863,7 @@ mod node {\n         let mut forest = ~[mut];\n         let it = leaf_iterator::start(node);\n         loop {\n-            match (leaf_iterator::next(it)) {\n+            match (leaf_iterator::next(&it)) {\n               option::None    => break,\n               option::Some(x) => vec::push(forest, @leaf(x))\n             }\n@@ -1018,7 +1020,7 @@ mod node {\n         let itb = char_iterator::start(b);\n         let mut result = 0;\n         while result == 0 {\n-            match ((char_iterator::next(ita), char_iterator::next(itb))) {\n+            match ((char_iterator::next(&ita), char_iterator::next(&itb))) {\n               (option::None, option::None) => break,\n               (option::Some(chara), option::Some(charb)) => {\n                 result = char::cmp(chara, charb);\n@@ -1121,7 +1123,7 @@ mod node {\n             }\n         }\n \n-        fn next(it: t) -> Option<leaf> {\n+        fn next(it: &t) -> Option<leaf> {\n             if it.stackpos < 0 { return option::None; }\n             loop {\n                 let current = it.stack[it.stackpos];\n@@ -1162,7 +1164,7 @@ mod node {\n             }\n         }\n \n-        fn next(it: t) -> Option<char> {\n+        fn next(it: &t) -> Option<char> {\n             loop {\n                 match (get_current_or_next_leaf(it)) {\n                   option::None => return option::None,\n@@ -1177,36 +1179,36 @@ mod node {\n             };\n         }\n \n-        fn get_current_or_next_leaf(it: t) -> Option<leaf> {\n-            match (it.leaf) {\n-              option::Some(_) => return it.leaf,\n+        fn get_current_or_next_leaf(it: &t) -> Option<leaf> {\n+            match ((*it).leaf) {\n+              option::Some(_) => return (*it).leaf,\n               option::None => {\n-                let next = leaf_iterator::next(it.leaf_iterator);\n+                let next = leaf_iterator::next(&((*it).leaf_iterator));\n                 match (next) {\n                   option::None => return option::None,\n                   option::Some(_) => {\n-                    it.leaf          = next;\n-                    it.leaf_byte_pos = 0u;\n+                    (*it).leaf          = next;\n+                    (*it).leaf_byte_pos = 0u;\n                     return next;\n                   }\n                 }\n               }\n             }\n         }\n \n-        fn get_next_char_in_leaf(it: t) -> Option<char> {\n-            match copy it.leaf {\n+        fn get_next_char_in_leaf(it: &t) -> Option<char> {\n+            match copy (*it).leaf {\n               option::None => return option::None,\n               option::Some(aleaf) => {\n-                if it.leaf_byte_pos >= aleaf.byte_len {\n+                if (*it).leaf_byte_pos >= aleaf.byte_len {\n                     //We are actually past the end of the leaf\n-                    it.leaf = option::None;\n+                    (*it).leaf = option::None;\n                     return option::None\n                 } else {\n                     let {ch, next} =\n                         str::char_range_at(*aleaf.content,\n-                                     it.leaf_byte_pos + aleaf.byte_offset);\n-                    it.leaf_byte_pos = next - aleaf.byte_offset;\n+                                     (*it).leaf_byte_pos + aleaf.byte_offset);\n+                    (*it).leaf_byte_pos = next - aleaf.byte_offset;\n                     return option::Some(ch)\n                 }\n               }\n@@ -1274,7 +1276,7 @@ mod tests {\n         let rope_iter   = iterator::char::start(r);\n         let mut equal   = true;\n         while equal {\n-            match (node::char_iterator::next(rope_iter)) {\n+            match (node::char_iterator::next(&rope_iter)) {\n               option::None => {\n                 if string_iter < string_len {\n                     equal = false;\n@@ -1301,7 +1303,7 @@ mod tests {\n         let mut len = 0u;\n         let it  = iterator::char::start(r);\n         loop {\n-            match (node::char_iterator::next(it)) {\n+            match (node::char_iterator::next(&it)) {\n               option::None => break,\n               option::Some(_) => len += 1u\n             }"}, {"sha": "5d2a04c038870e79b25b34db1a0bd8d6aaf03e9f", "filename": "src/libstd/tempfile.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/afc1ccd282a132eb3206a21a5a0ac8fe4b1c24c7/src%2Flibstd%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc1ccd282a132eb3206a21a5a0ac8fe4b1c24c7/src%2Flibstd%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftempfile.rs?ref=afc1ccd282a132eb3206a21a5a0ac8fe4b1c24c7", "patch": "@@ -1,5 +1,8 @@\n //! Temporary files and directories\n \n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n import core::option;\n import option::{None, Some};\n import rand;"}, {"sha": "53b150a8b6c83ad220eca37f96bfdbe3072cc4af", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afc1ccd282a132eb3206a21a5a0ac8fe4b1c24c7/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc1ccd282a132eb3206a21a5a0ac8fe4b1c24c7/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=afc1ccd282a132eb3206a21a5a0ac8fe4b1c24c7", "patch": "@@ -140,7 +140,7 @@ fn type_needs_inner(cx: ctx, use: uint, ty: ty::t,\n               ty::ty_fn(_) | ty::ty_ptr(_) | ty::ty_rptr(_, _)\n                | ty::ty_trait(_, _, _) => false,\n               ty::ty_enum(did, substs) => {\n-                if option::is_none(list::find(enums_seen, |id| id == did)) {\n+                if option::is_none(list::find(enums_seen, |id| *id == did)) {\n                     let seen = @cons(did, enums_seen);\n                     for vec::each(*ty::enum_variants(cx.ccx.tcx, did)) |v| {\n                         for vec::each(v.args) |aty| {"}]}