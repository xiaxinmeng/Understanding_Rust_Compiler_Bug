{"sha": "6c751e045642376eafe7ec8a2cae6d92995a46b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjNzUxZTA0NTY0MjM3NmVhZmU3ZWM4YTJjYWU2ZDkyOTk1YTQ2YjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-20T12:38:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-20T12:38:18Z"}, "message": "Auto merge of #31474 - arielb1:mir-typeck, r=nikomatsakis\n\nThis should stop broken MIR from annoying us when we try to implement things", "tree": {"sha": "b5096f050a0278e3bc7cc294d0bd43779af71dc8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5096f050a0278e3bc7cc294d0bd43779af71dc8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c751e045642376eafe7ec8a2cae6d92995a46b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c751e045642376eafe7ec8a2cae6d92995a46b6", "html_url": "https://github.com/rust-lang/rust/commit/6c751e045642376eafe7ec8a2cae6d92995a46b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c751e045642376eafe7ec8a2cae6d92995a46b6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfabd173724e5e1bae204126261a03d850d86107", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfabd173724e5e1bae204126261a03d850d86107", "html_url": "https://github.com/rust-lang/rust/commit/cfabd173724e5e1bae204126261a03d850d86107"}, {"sha": "d84658e317ac5b881a46e27204a1cb9f4ac1b691", "url": "https://api.github.com/repos/rust-lang/rust/commits/d84658e317ac5b881a46e27204a1cb9f4ac1b691", "html_url": "https://github.com/rust-lang/rust/commit/d84658e317ac5b881a46e27204a1cb9f4ac1b691"}], "stats": {"total": 1699, "additions": 1509, "deletions": 190}, "files": [{"sha": "93cc158cd12f2d6c58858b84a5244d0904dee7d3", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -721,10 +721,11 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         if let Some(adjustment) = adj {\n             match adjustment {\n                 adjustment::AdjustReifyFnPointer |\n-                adjustment::AdjustUnsafeFnPointer => {\n+                adjustment::AdjustUnsafeFnPointer |\n+                adjustment::AdjustMutToConstPointer => {\n                     // Creating a closure/fn-pointer or unsizing consumes\n                     // the input and stores it into the resulting rvalue.\n-                    debug!(\"walk_adjustment(AdjustReifyFnPointer|AdjustUnsafeFnPointer)\");\n+                    debug!(\"walk_adjustment: trivial adjustment\");\n                     let cmt_unadjusted =\n                         return_if_err!(self.mc.cat_expr_unadjusted(expr));\n                     self.delegate_consume(expr.id, expr.span, cmt_unadjusted);"}, {"sha": "fef35764e1cc13d216b817df350747d9ce631f4d", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -430,6 +430,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n \n                     adjustment::AdjustReifyFnPointer |\n                     adjustment::AdjustUnsafeFnPointer |\n+                    adjustment::AdjustMutToConstPointer |\n                     adjustment::AdjustDerefRef(_) => {\n                         debug!(\"cat_expr({:?}): {:?}\",\n                                adjustment,"}, {"sha": "afe177fbdcdcb3aff6ac1440c6af7b326ee42aa4", "filename": "src/librustc/middle/ty/adjustment.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc%2Fmiddle%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc%2Fmiddle%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fadjustment.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -21,8 +21,9 @@ use rustc_front::hir;\n \n #[derive(Copy, Clone)]\n pub enum AutoAdjustment<'tcx> {\n-    AdjustReifyFnPointer,   // go from a fn-item type to a fn-pointer type\n-    AdjustUnsafeFnPointer,  // go from a safe fn pointer to an unsafe fn pointer\n+    AdjustReifyFnPointer,    // go from a fn-item type to a fn-pointer type\n+    AdjustUnsafeFnPointer,   // go from a safe fn pointer to an unsafe fn pointer\n+    AdjustMutToConstPointer, // go from a mut raw pointer to a const raw pointer\n     AdjustDerefRef(AutoDerefRef<'tcx>),\n }\n \n@@ -106,7 +107,8 @@ impl<'tcx> AutoAdjustment<'tcx> {\n     pub fn is_identity(&self) -> bool {\n         match *self {\n             AdjustReifyFnPointer |\n-            AdjustUnsafeFnPointer => false,\n+            AdjustUnsafeFnPointer |\n+            AdjustMutToConstPointer => false,\n             AdjustDerefRef(ref r) => r.is_identity(),\n         }\n     }\n@@ -151,7 +153,7 @@ impl<'tcx> ty::TyS<'tcx> {\n         return match adjustment {\n             Some(adjustment) => {\n                 match *adjustment {\n-                   AdjustReifyFnPointer => {\n+                    AdjustReifyFnPointer => {\n                         match self.sty {\n                             ty::TyBareFn(Some(_), b) => {\n                                 cx.mk_fn(None, b)\n@@ -164,17 +166,32 @@ impl<'tcx> ty::TyS<'tcx> {\n                         }\n                     }\n \n-                   AdjustUnsafeFnPointer => {\n+                    AdjustUnsafeFnPointer => {\n                         match self.sty {\n                             ty::TyBareFn(None, b) => cx.safe_to_unsafe_fn_ty(b),\n                             ref b => {\n                                 cx.sess.bug(\n-                                    &format!(\"AdjustReifyFnPointer adjustment on non-fn-item: \\\n+                                    &format!(\"AdjustUnsafeFnPointer adjustment on non-fn-ptr: \\\n                                              {:?}\",\n                                             b));\n                             }\n                         }\n-                   }\n+                    }\n+\n+                    AdjustMutToConstPointer => {\n+                        match self.sty {\n+                            ty::TyRawPtr(mt) => cx.mk_ptr(ty::TypeAndMut {\n+                                ty: mt.ty,\n+                                mutbl: hir::MutImmutable\n+                            }),\n+                            ref b => {\n+                                cx.sess.bug(\n+                                    &format!(\"AdjustMutToConstPointer on non-raw-ptr: \\\n+                                             {:?}\",\n+                                            b));\n+                            }\n+                        }\n+                    }\n \n                     AdjustDerefRef(ref adj) => {\n                         let mut adjusted_ty = self;"}, {"sha": "ea6b4df8104d5996f2c914e0788663e16a08e8a3", "filename": "src/librustc/middle/ty/context.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -131,6 +131,12 @@ pub struct Tables<'tcx> {\n     /// equivalents. This table is not used in trans (since regions\n     /// are erased there) and hence is not serialized to metadata.\n     pub liberated_fn_sigs: NodeMap<ty::FnSig<'tcx>>,\n+\n+    /// For each FRU expression, record the normalized types of the fields\n+    /// of the struct - this is needed because it is non-trivial to\n+    /// normalize while preserving regions. This table is used only in\n+    /// MIR construction and hence is not serialized to metadata.\n+    pub fru_field_types: NodeMap<Vec<Ty<'tcx>>>\n }\n \n impl<'tcx> Tables<'tcx> {\n@@ -144,6 +150,7 @@ impl<'tcx> Tables<'tcx> {\n             closure_tys: DefIdMap(),\n             closure_kinds: DefIdMap(),\n             liberated_fn_sigs: NodeMap(),\n+            fru_field_types: NodeMap()\n         }\n     }\n "}, {"sha": "32e78b04676395428c936061eb45f5b5e6c17b1d", "filename": "src/librustc/mir/mir_map.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc%2Fmir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc%2Fmir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmir_map.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -8,20 +8,30 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use dep_graph::DepNode;\n use util::nodemap::NodeMap;\n use mir::repr::Mir;\n use mir::transform::MirPass;\n use middle::ty;\n+use middle::infer;\n \n pub struct MirMap<'tcx> {\n     pub map: NodeMap<Mir<'tcx>>,\n }\n \n impl<'tcx> MirMap<'tcx> {\n     pub fn run_passes(&mut self, passes: &mut [Box<MirPass>], tcx: &ty::ctxt<'tcx>) {\n-        for (_, ref mut mir) in &mut self.map {\n+        if passes.is_empty() { return; }\n+\n+        for (&id, mir) in &mut self.map {\n+            let did = tcx.map.local_def_id(id);\n+            let _task = tcx.dep_graph.in_task(DepNode::MirMapConstruction(did));\n+\n+            let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n+            let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(param_env));\n+\n             for pass in &mut *passes {\n-                pass.run_on_mir(mir, tcx)\n+                pass.run_on_mir(mir, &infcx)\n             }\n         }\n     }"}, {"sha": "ce7b1ceb355401d02b08fd3a4c5362affffee396", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -45,6 +45,9 @@ pub struct Mir<'tcx> {\n     /// values in that it is possible to borrow them and mutate them\n     /// through the resulting reference.\n     pub temp_decls: Vec<TempDecl<'tcx>>,\n+\n+    /// A span representing this MIR, for error reporting\n+    pub span: Span,\n }\n \n /// where execution begins\n@@ -145,7 +148,7 @@ pub enum BorrowKind {\n \n /// A \"variable\" is a binding declared by the user as part of the fn\n /// decl, a let, etc.\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct VarDecl<'tcx> {\n     pub mutability: Mutability,\n     pub name: Name,\n@@ -154,7 +157,7 @@ pub struct VarDecl<'tcx> {\n \n /// A \"temp\" is a temporary that we place on the stack. They are\n /// anonymous, always mutable, and have only a type.\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct TempDecl<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n@@ -170,7 +173,7 @@ pub struct TempDecl<'tcx> {\n ///\n /// there is only one argument, of type `(i32, u32)`, but two bindings\n /// (`x` and `y`).\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct ArgDecl<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n@@ -499,7 +502,7 @@ pub struct Projection<'tcx, B, V> {\n #[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum ProjectionElem<'tcx, V> {\n     Deref,\n-    Field(Field),\n+    Field(Field, Ty<'tcx>),\n     Index(V),\n \n     /// These indices are generated by slice patterns. Easiest to explain\n@@ -550,8 +553,8 @@ impl Field {\n }\n \n impl<'tcx> Lvalue<'tcx> {\n-    pub fn field(self, f: Field) -> Lvalue<'tcx> {\n-        self.elem(ProjectionElem::Field(f))\n+    pub fn field(self, f: Field, ty: Ty<'tcx>) -> Lvalue<'tcx> {\n+        self.elem(ProjectionElem::Field(f, ty))\n     }\n \n     pub fn deref(self) -> Lvalue<'tcx> {\n@@ -591,8 +594,8 @@ impl<'tcx> Debug for Lvalue<'tcx> {\n                         write!(fmt, \"({:?} as {})\", data.base, adt_def.variants[index].name),\n                     ProjectionElem::Deref =>\n                         write!(fmt, \"(*{:?})\", data.base),\n-                    ProjectionElem::Field(field) =>\n-                        write!(fmt, \"{:?}.{:?}\", data.base, field.index()),\n+                    ProjectionElem::Field(field, ty) =>\n+                        write!(fmt, \"({:?}.{:?}: {:?})\", data.base, field.index(), ty),\n                     ProjectionElem::Index(ref index) =>\n                         write!(fmt, \"{:?}[{:?}]\", data.base, index),\n                     ProjectionElem::ConstantIndex { offset, min_length, from_end: false } =>"}, {"sha": "20e083f840f8cf908af68e039912957a0480ec06", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 70, "deletions": 18, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -14,7 +14,8 @@\n  */\n \n use mir::repr::*;\n-use middle::subst::Substs;\n+use middle::const_eval::ConstVal;\n+use middle::subst::{Subst, Substs};\n use middle::ty::{self, AdtDef, Ty};\n use rustc_front::hir;\n \n@@ -72,23 +73,7 @@ impl<'tcx> LvalueTy<'tcx> {\n                         tcx.sess.bug(&format!(\"cannot downcast non-enum type: `{:?}`\", self))\n                     }\n                 },\n-            ProjectionElem::Field(field) => {\n-                let field_ty = match self {\n-                    LvalueTy::Ty { ty } => match ty.sty {\n-                        ty::TyStruct(adt_def, substs) =>\n-                            adt_def.struct_variant().fields[field.index()].ty(tcx, substs),\n-                        ty::TyTuple(ref tys) =>\n-                            tys[field.index()],\n-                        ty::TyClosure(_, ref closure_substs) =>\n-                            closure_substs.upvar_tys[field.index()],\n-                        _ =>\n-                            tcx.sess.bug(&format!(\"cannot get field of type: `{:?}`\", ty)),\n-                    },\n-                    LvalueTy::Downcast { adt_def, substs, variant_index } =>\n-                        adt_def.variants[variant_index].fields[field.index()].ty(tcx, substs),\n-                };\n-                LvalueTy::Ty { ty: field_ty }\n-            }\n+            ProjectionElem::Field(_, fty) => LvalueTy::Ty { ty: fty }\n         }\n     }\n }\n@@ -150,6 +135,73 @@ impl<'tcx> Mir<'tcx> {\n                 self.lvalue_ty(tcx, &proj.base).projection_ty(tcx, &proj.elem)\n         }\n     }\n+\n+    pub fn rvalue_ty(&self,\n+                     tcx: &ty::ctxt<'tcx>,\n+                     rvalue: &Rvalue<'tcx>)\n+                     -> Option<Ty<'tcx>>\n+    {\n+        match *rvalue {\n+            Rvalue::Use(ref operand) => Some(self.operand_ty(tcx, operand)),\n+            Rvalue::Repeat(ref operand, ref count) => {\n+                if let ConstVal::Uint(u) = count.value {\n+                    let op_ty = self.operand_ty(tcx, operand);\n+                    Some(tcx.mk_array(op_ty, u as usize))\n+                } else {\n+                    None\n+                }\n+            }\n+            Rvalue::Ref(reg, bk, ref lv) => {\n+                let lv_ty = self.lvalue_ty(tcx, lv).to_ty(tcx);\n+                Some(tcx.mk_ref(\n+                    tcx.mk_region(reg),\n+                    ty::TypeAndMut {\n+                        ty: lv_ty,\n+                        mutbl: bk.to_mutbl_lossy()\n+                    }\n+                ))\n+            }\n+            Rvalue::Len(..) => Some(tcx.types.usize),\n+            Rvalue::Cast(_, _, ty) => Some(ty),\n+            Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n+                let lhs_ty = self.operand_ty(tcx, lhs);\n+                let rhs_ty = self.operand_ty(tcx, rhs);\n+                Some(self.binop_ty(tcx, op, lhs_ty, rhs_ty))\n+            }\n+            Rvalue::UnaryOp(_, ref operand) => {\n+                Some(self.operand_ty(tcx, operand))\n+            }\n+            Rvalue::Box(t) => {\n+                Some(tcx.mk_box(t))\n+            }\n+            Rvalue::Aggregate(ref ak, ref ops) => {\n+                match *ak {\n+                    AggregateKind::Vec => {\n+                        if let Some(operand) = ops.get(0) {\n+                            let ty = self.operand_ty(tcx, operand);\n+                            Some(tcx.mk_array(ty, ops.len()))\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                    AggregateKind::Tuple => {\n+                        Some(tcx.mk_tup(\n+                            ops.iter().map(|op| self.operand_ty(tcx, op)).collect()\n+                        ))\n+                    }\n+                    AggregateKind::Adt(def, _, substs) => {\n+                        Some(def.type_scheme(tcx).ty.subst(tcx, substs))\n+                    }\n+                    AggregateKind::Closure(did, substs) => {\n+                        Some(tcx.mk_closure_from_closure_substs(\n+                            did, Box::new(substs.clone())))\n+                    }\n+                }\n+            }\n+            Rvalue::Slice { .. } => None,\n+            Rvalue::InlineAsm(..) => None\n+        }\n+    }\n }\n \n impl BorrowKind {"}, {"sha": "cc417f5a99ea6f93f1824bad0904d2c018f17a79", "filename": "src/librustc/mir/transform.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc%2Fmir%2Ftransform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc%2Fmir%2Ftransform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftransform.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n use mir::repr::Mir;\n-use middle::ty::ctxt;\n+use middle::infer::InferCtxt;\n \n pub trait MirPass {\n-    fn run_on_mir<'tcx>(&mut self, mir: &mut Mir<'tcx>, tcx: &ctxt<'tcx>);\n+    fn run_on_mir<'a, 'tcx>(&mut self, mir: &mut Mir<'tcx>, infcx: &InferCtxt<'a, 'tcx>);\n }"}, {"sha": "f835613cfcbb998d29cbdee60b35e70b1fe745f9", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -138,6 +138,7 @@ pub struct Options {\n     pub no_trans: bool,\n     pub error_format: ErrorOutputType,\n     pub treat_err_as_bug: bool,\n+    pub mir_opt_level: usize,\n \n     /// if true, build up the dep-graph\n     pub build_dep_graph: bool,\n@@ -254,6 +255,7 @@ pub fn basic_options() -> Options {\n         parse_only: false,\n         no_trans: false,\n         treat_err_as_bug: false,\n+        mir_opt_level: 1,\n         build_dep_graph: false,\n         dump_dep_graph: false,\n         no_analysis: false,\n@@ -655,6 +657,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"show spans for compiler debugging (expr|pat|ty)\"),\n     print_trans_items: Option<String> = (None, parse_opt_string,\n           \"print the result of the translation item collection pass\"),\n+    mir_opt_level: Option<usize> = (None, parse_opt_uint,\n+          \"set the MIR optimization level (0-3)\"),\n }\n \n pub fn default_lib_output() -> CrateType {\n@@ -988,6 +992,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let parse_only = debugging_opts.parse_only;\n     let no_trans = debugging_opts.no_trans;\n     let treat_err_as_bug = debugging_opts.treat_err_as_bug;\n+    let mir_opt_level = debugging_opts.mir_opt_level.unwrap_or(1);\n     let incremental_compilation = debugging_opts.incr_comp;\n     let dump_dep_graph = debugging_opts.dump_dep_graph;\n     let no_analysis = debugging_opts.no_analysis;\n@@ -1166,6 +1171,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         parse_only: parse_only,\n         no_trans: no_trans,\n         treat_err_as_bug: treat_err_as_bug,\n+        mir_opt_level: mir_opt_level,\n         build_dep_graph: incremental_compilation || dump_dep_graph,\n         dump_dep_graph: dump_dep_graph,\n         no_analysis: no_analysis,"}, {"sha": "5868f233776c20af519338084f3ad3994f4cb713", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -396,6 +396,9 @@ impl<'tcx> fmt::Debug for ty::adjustment::AutoAdjustment<'tcx> {\n             ty::adjustment::AdjustUnsafeFnPointer => {\n                 write!(f, \"AdjustUnsafeFnPointer\")\n             }\n+            ty::adjustment::AdjustMutToConstPointer => {\n+                write!(f, \"AdjustMutToConstPointer\")\n+            }\n             ty::adjustment::AdjustDerefRef(ref data) => {\n                 write!(f, \"{:?}\", data)\n             }"}, {"sha": "b446dec96fbfb622882e9392fcfc0567fb39c212", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -844,6 +844,18 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"match checking\",\n              || middle::check_match::check_crate(tcx));\n \n+        // this must run before MIR dump, because\n+        // \"not all control paths return a value\" is reported here.\n+        //\n+        // maybe move the check to a MIR pass?\n+        time(time_passes,\n+             \"liveness checking\",\n+             || middle::liveness::check_crate(tcx));\n+\n+        time(time_passes,\n+             \"rvalue checking\",\n+             || rvalues::check_crate(tcx));\n+\n         let mut mir_map =\n             time(time_passes,\n                  \"MIR dump\",\n@@ -853,18 +865,10 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"MIR passes\",\n              || mir_map.run_passes(&mut sess.plugin_mir_passes.borrow_mut(), tcx));\n \n-        time(time_passes,\n-             \"liveness checking\",\n-             || middle::liveness::check_crate(tcx));\n-\n         time(time_passes,\n              \"borrow checking\",\n              || borrowck::check_crate(tcx));\n \n-        time(time_passes,\n-             \"rvalue checking\",\n-             || rvalues::check_crate(tcx));\n-\n         // Avoid overwhelming user with errors if type checking failed.\n         // I'm not sure how helpful this is, to be honest, but it avoids\n         // a"}, {"sha": "fe4df865a0e61cd910bd0613827227256038ce65", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -610,7 +610,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n \n         self.emit_enum(\"AutoAdjustment\", |this| {\n             match *adj {\n-                adjustment::AdjustReifyFnPointer=> {\n+                adjustment::AdjustReifyFnPointer => {\n                     this.emit_enum_variant(\"AdjustReifyFnPointer\", 1, 0, |_| Ok(()))\n                 }\n \n@@ -620,8 +620,14 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                     })\n                 }\n \n+                adjustment::AdjustMutToConstPointer => {\n+                    this.emit_enum_variant(\"AdjustMutToConstPointer\", 3, 0, |_| {\n+                        Ok(())\n+                    })\n+                }\n+\n                 adjustment::AdjustDerefRef(ref auto_deref_ref) => {\n-                    this.emit_enum_variant(\"AdjustDerefRef\", 3, 2, |this| {\n+                    this.emit_enum_variant(\"AdjustDerefRef\", 4, 2, |this| {\n                         this.emit_enum_variant_arg(0,\n                             |this| Ok(this.emit_auto_deref_ref(ecx, auto_deref_ref)))\n                     })\n@@ -1002,12 +1008,14 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     fn read_auto_adjustment<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                     -> adjustment::AutoAdjustment<'tcx> {\n         self.read_enum(\"AutoAdjustment\", |this| {\n-            let variants = [\"AdjustReifyFnPointer\", \"AdjustUnsafeFnPointer\", \"AdjustDerefRef\"];\n+            let variants = [\"AdjustReifyFnPointer\", \"AdjustUnsafeFnPointer\",\n+                            \"AdjustMutToConstPointer\", \"AdjustDerefRef\"];\n             this.read_enum_variant(&variants, |this, i| {\n                 Ok(match i {\n                     1 => adjustment::AdjustReifyFnPointer,\n                     2 => adjustment::AdjustUnsafeFnPointer,\n-                    3 => {\n+                    3 => adjustment::AdjustMutToConstPointer,\n+                    4 => {\n                         let auto_deref_ref: adjustment::AutoDerefRef =\n                             this.read_enum_variant_arg(0,\n                                 |this| Ok(this.read_auto_deref_ref(dcx))).unwrap();"}, {"sha": "b2c7507ed7b282aedca237bd5e6d53c0fa258908", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -41,7 +41,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             }\n             ExprKind::Field { lhs, name } => {\n                 let lvalue = unpack!(block = this.as_lvalue(block, lhs));\n-                let lvalue = lvalue.field(name);\n+                let lvalue = lvalue.field(name, expr.ty);\n                 block.and(lvalue)\n             }\n             ExprKind::Deref { arg } => {"}, {"sha": "2338d7df01a854096460e830136be12b907d1249", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -139,33 +139,34 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                           .collect();\n                 block.and(Rvalue::Aggregate(AggregateKind::Closure(closure_id, substs), upvars))\n             }\n-            ExprKind::Adt { adt_def, variant_index, substs, fields, base } => { // see (*) above\n+            ExprKind::Adt {\n+                adt_def, variant_index, substs, fields, base\n+            } => { // see (*) above\n                 // first process the set of fields that were provided\n                 // (evaluating them in order given by user)\n                 let fields_map: FnvHashMap<_, _> =\n                     fields.into_iter()\n                           .map(|f| (f.name, unpack!(block = this.as_operand(block, f.expr))))\n                           .collect();\n \n-                // if base expression is given, evaluate it now\n-                let base = base.map(|base| unpack!(block = this.as_lvalue(block, base)));\n-\n-                // get list of all fields that we will need\n                 let field_names = this.hir.all_fields(adt_def, variant_index);\n \n-                // for the actual values we use, take either the\n-                // expr the user specified or, if they didn't\n-                // specify something for this field name, create a\n-                // path relative to the base (which must have been\n-                // supplied, or the IR is internally\n-                // inconsistent).\n-                let fields: Vec<_> =\n+                let fields = if let Some(FruInfo { base, field_types }) = base {\n+                    let base = unpack!(block = this.as_lvalue(block, base));\n+\n+                    // MIR does not natively support FRU, so for each\n+                    // base-supplied field, generate an operand that\n+                    // reads it from the base.\n                     field_names.into_iter()\n-                               .map(|n| match fields_map.get(&n) {\n-                                   Some(v) => v.clone(),\n-                                   None => Operand::Consume(base.clone().unwrap().field(n)),\n-                               })\n-                               .collect();\n+                        .zip(field_types.into_iter())\n+                        .map(|(n, ty)| match fields_map.get(&n) {\n+                            Some(v) => v.clone(),\n+                            None => Operand::Consume(base.clone().field(n, ty))\n+                        })\n+                        .collect()\n+                } else {\n+                    field_names.iter().map(|n| fields_map[n].clone()).collect()\n+                };\n \n                 block.and(Rvalue::Aggregate(AggregateKind::Adt(adt_def, variant_index, substs),\n                                             fields))"}, {"sha": "02f32da2b83fc23d796bda27ff78ebc1a09d93e6", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -404,7 +404,8 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             subpatterns.iter()\n                        .map(|subpattern| {\n                            // e.g., `(x as Variant).0`\n-                           let lvalue = downcast_lvalue.clone().field(subpattern.field);\n+                           let lvalue = downcast_lvalue.clone().field(subpattern.field,\n+                                                                      subpattern.field_ty());\n                            // e.g., `(x as Variant).0 @ P1`\n                            MatchPair::new(lvalue, &subpattern.pattern)\n                        });"}, {"sha": "c295ed168badb0307928a7b05c6d10209bb718e0", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -21,7 +21,8 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                                    -> Vec<MatchPair<'pat, 'tcx>> {\n         subpatterns.iter()\n                    .map(|fieldpat| {\n-                       let lvalue = lvalue.clone().field(fieldpat.field);\n+                       let lvalue = lvalue.clone().field(fieldpat.field,\n+                                                         fieldpat.field_ty());\n                        MatchPair::new(lvalue, &fieldpat.pattern)\n                    })\n                    .collect()"}, {"sha": "b83d0f6a9803a96c2990b61910367fcc36822b73", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -80,7 +80,7 @@ macro_rules! unpack {\n /// the main entry point for building MIR for a function\n \n pub fn construct<'a,'tcx>(hir: Cx<'a,'tcx>,\n-                          _span: Span,\n+                          span: Span,\n                           implicit_arguments: Vec<Ty<'tcx>>,\n                           explicit_arguments: Vec<(Ty<'tcx>, &'tcx hir::Pat)>,\n                           argument_extent: CodeExtent,\n@@ -97,7 +97,7 @@ pub fn construct<'a,'tcx>(hir: Cx<'a,'tcx>,\n         temp_decls: vec![],\n         var_decls: vec![],\n         var_indices: FnvHashMap(),\n-        unit_temp: None\n+        unit_temp: None,\n     };\n \n     assert_eq!(builder.cfg.start_new_block(), START_BLOCK);\n@@ -119,6 +119,7 @@ pub fn construct<'a,'tcx>(hir: Cx<'a,'tcx>,\n         arg_decls: arg_decls,\n         temp_decls: builder.temp_decls,\n         return_ty: return_ty,\n+        span: span\n     }\n }\n "}, {"sha": "7be70867796ff0088aa7350ebaf1384eb7afdb32", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -418,25 +418,28 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                              len: Operand<'tcx>,\n                              span: Span) {\n         // fn(&(filename: &'static str, line: u32), index: usize, length: usize) -> !\n+        let region = ty::ReStatic; // FIXME(mir-borrowck): use a better region?\n         let func = self.lang_function(lang_items::PanicBoundsCheckFnLangItem);\n-        let args = func.ty.fn_args();\n-        let ref_ty = args.skip_binder()[0];\n-        let (region, tup_ty) = if let ty::TyRef(region, tyandmut) = ref_ty.sty {\n-            (region, tyandmut.ty)\n+        let args = self.hir.tcx().replace_late_bound_regions(&func.ty.fn_args(), |_| region).0;\n+\n+        let ref_ty = args[0];\n+        let tup_ty = if let ty::TyRef(_, tyandmut) = ref_ty.sty {\n+            tyandmut.ty\n         } else {\n             self.hir.span_bug(span, &format!(\"unexpected panic_bound_check type: {:?}\", func.ty));\n         };\n+\n         let (tuple, tuple_ref) = (self.temp(tup_ty), self.temp(ref_ty));\n         let (file, line) = self.span_to_fileline_args(span);\n         let elems = vec![Operand::Constant(file), Operand::Constant(line)];\n         // FIXME: We should have this as a constant, rather than a stack variable (to not pollute\n         // icache with cold branch code), however to achieve that we either have to rely on rvalue\n         // promotion or have some way, in MIR, to create constants.\n-        self.cfg.push_assign(block, DUMMY_SP, &tuple, // tuple = (file_arg, line_arg);\n+        self.cfg.push_assign(block, span, &tuple, // tuple = (file_arg, line_arg);\n                              Rvalue::Aggregate(AggregateKind::Tuple, elems));\n         // FIXME: is this region really correct here?\n-        self.cfg.push_assign(block, DUMMY_SP, &tuple_ref, // tuple_ref = &tuple;\n-                             Rvalue::Ref(*region, BorrowKind::Unique, tuple));\n+        self.cfg.push_assign(block, span, &tuple_ref, // tuple_ref = &tuple;\n+                             Rvalue::Ref(region, BorrowKind::Shared, tuple));\n         let cleanup = self.diverge_cleanup();\n         self.cfg.terminate(block, Terminator::Call {\n             func: Operand::Constant(func),\n@@ -449,18 +452,21 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     /// Create diverge cleanup and branch to it from `block`.\n     pub fn panic(&mut self, block: BasicBlock, msg: &'static str, span: Span) {\n         // fn(&(msg: &'static str filename: &'static str, line: u32)) -> !\n+        let region = ty::ReStatic; // FIXME(mir-borrowck): use a better region?\n         let func = self.lang_function(lang_items::PanicFnLangItem);\n-        let args = func.ty.fn_args();\n-        let ref_ty = args.skip_binder()[0];\n-        let (region, tup_ty) = if let ty::TyRef(region, tyandmut) = ref_ty.sty {\n-            (region, tyandmut.ty)\n+        let args = self.hir.tcx().replace_late_bound_regions(&func.ty.fn_args(), |_| region).0;\n+\n+        let ref_ty = args[0];\n+        let tup_ty = if let ty::TyRef(_, tyandmut) = ref_ty.sty {\n+            tyandmut.ty\n         } else {\n             self.hir.span_bug(span, &format!(\"unexpected panic type: {:?}\", func.ty));\n         };\n+\n         let (tuple, tuple_ref) = (self.temp(tup_ty), self.temp(ref_ty));\n         let (file, line) = self.span_to_fileline_args(span);\n         let message = Constant {\n-            span: DUMMY_SP,\n+            span: span,\n             ty: self.hir.tcx().mk_static_str(),\n             literal: self.hir.str_literal(intern_and_get_ident(msg))\n         };\n@@ -470,11 +476,11 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         // FIXME: We should have this as a constant, rather than a stack variable (to not pollute\n         // icache with cold branch code), however to achieve that we either have to rely on rvalue\n         // promotion or have some way, in MIR, to create constants.\n-        self.cfg.push_assign(block, DUMMY_SP, &tuple, // tuple = (message_arg, file_arg, line_arg);\n+        self.cfg.push_assign(block, span, &tuple, // tuple = (message_arg, file_arg, line_arg);\n                              Rvalue::Aggregate(AggregateKind::Tuple, elems));\n         // FIXME: is this region really correct here?\n-        self.cfg.push_assign(block, DUMMY_SP, &tuple_ref, // tuple_ref = &tuple;\n-                             Rvalue::Ref(*region, BorrowKind::Unique, tuple));\n+        self.cfg.push_assign(block, span, &tuple_ref, // tuple_ref = &tuple;\n+                             Rvalue::Ref(region, BorrowKind::Shared, tuple));\n         let cleanup = self.diverge_cleanup();\n         self.cfg.terminate(block, Terminator::Call {\n             func: Operand::Constant(func),\n@@ -505,11 +511,11 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     fn span_to_fileline_args(&mut self, span: Span) -> (Constant<'tcx>, Constant<'tcx>) {\n         let span_lines = self.hir.tcx().sess.codemap().lookup_char_pos(span.lo);\n         (Constant {\n-            span: DUMMY_SP,\n+            span: span,\n             ty: self.hir.tcx().mk_static_str(),\n             literal: self.hir.str_literal(intern_and_get_ident(&span_lines.file.name))\n         }, Constant {\n-            span: DUMMY_SP,\n+            span: span,\n             ty: self.hir.tcx().types.u32,\n             literal: self.hir.usize_literal(span_lines.line)\n         })"}, {"sha": "ac1cff527fe91f68cf6976db76b5ed4e5a7034aa", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 102, "deletions": 18, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -32,6 +32,8 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n         debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.id, self.span);\n \n         let expr_ty = cx.tcx.expr_ty(self); // note: no adjustments (yet)!\n+        let temp_lifetime = cx.tcx.region_maps.temporary_scope(self.id);\n+        let expr_extent = cx.tcx.region_maps.node_extent(self.id);\n \n         let kind = match self.node {\n             // Here comes the interesting stuff:\n@@ -54,14 +56,35 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     // Find the actual method implementation being called and\n                     // build the appropriate UFCS call expression with the\n                     // callee-object as self parameter.\n+\n+                    // rewrite f(u, v) into FnOnce::call_once(f, (u, v))\n+\n                     let method = method_callee(cx, self, ty::MethodCall::expr(self.id));\n-                    let mut argrefs = vec![fun.to_ref()];\n-                    argrefs.extend(args.iter().map(|a| a.to_ref()));\n+\n+                    let sig = match method.ty.sty {\n+                        ty::TyBareFn(_, fn_ty) => &fn_ty.sig,\n+                        _ => cx.tcx.sess.span_bug(self.span, \"type of method is not an fn\")\n+                    };\n+\n+                    let sig = cx.tcx.no_late_bound_regions(sig).unwrap_or_else(|| {\n+                        cx.tcx.sess.span_bug(self.span, \"method call has late-bound regions\")\n+                    });\n+\n+                    assert_eq!(sig.inputs.len(), 2);\n+\n+                    let tupled_args = Expr {\n+                        ty: sig.inputs[1],\n+                        temp_lifetime: temp_lifetime,\n+                        span: self.span,\n+                        kind: ExprKind::Tuple {\n+                            fields: args.iter().map(ToRef::to_ref).collect()\n+                        }\n+                    };\n \n                     ExprKind::Call {\n                         ty: method.ty,\n                         fun: method.to_ref(),\n-                        args: argrefs,\n+                        args: vec![fun.to_ref(), tupled_args.to_ref()]\n                     }\n                 } else {\n                     let adt_data = if let hir::ExprPath(..) = fun.node {\n@@ -125,11 +148,20 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n             }\n \n             hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n-                let op = bin_op(op.node);\n-                ExprKind::AssignOp {\n-                    op: op,\n-                    lhs: lhs.to_ref(),\n-                    rhs: rhs.to_ref(),\n+                if cx.tcx.is_method_call(self.id) {\n+                    let pass_args = if hir_util::is_by_value_binop(op.node) {\n+                        PassArgs::ByValue\n+                    } else {\n+                        PassArgs::ByRef\n+                    };\n+                    overloaded_operator(cx, self, ty::MethodCall::expr(self.id),\n+                                        pass_args, lhs.to_ref(), vec![rhs])\n+                } else {\n+                    ExprKind::AssignOp {\n+                        op: bin_op(op.node),\n+                        lhs: lhs.to_ref(),\n+                        rhs: rhs.to_ref(),\n+                    }\n                 }\n             }\n \n@@ -227,21 +259,31 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                             variant_index: 0,\n                             substs: substs,\n                             fields: field_refs,\n-                            base: base.to_ref(),\n+                            base: base.as_ref().map(|base| {\n+                                FruInfo {\n+                                    base: base.to_ref(),\n+                                    field_types: cx.tcx.tables\n+                                        .borrow()\n+                                        .fru_field_types[&self.id]\n+                                        .clone()\n+                                }\n+                            })\n                         }\n                     }\n                     ty::TyEnum(adt, substs) => {\n                         match cx.tcx.def_map.borrow()[&self.id].full_def() {\n                             Def::Variant(enum_id, variant_id) => {\n                                 debug_assert!(adt.did == enum_id);\n+                                assert!(base.is_none());\n+\n                                 let index = adt.variant_index_with_id(variant_id);\n                                 let field_refs = field_refs(&adt.variants[index], fields);\n                                 ExprKind::Adt {\n                                     adt_def: adt,\n                                     variant_index: index,\n                                     substs: substs,\n                                     fields: field_refs,\n-                                    base: base.to_ref(),\n+                                    base: None\n                                 }\n                             }\n                             ref def => {\n@@ -385,16 +427,16 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                 ExprKind::Tuple { fields: fields.to_ref() },\n         };\n \n-        let temp_lifetime = cx.tcx.region_maps.temporary_scope(self.id);\n-        let expr_extent = cx.tcx.region_maps.node_extent(self.id);\n-\n         let mut expr = Expr {\n             temp_lifetime: temp_lifetime,\n             ty: expr_ty,\n             span: self.span,\n             kind: kind,\n         };\n \n+        debug!(\"make_mirror: unadjusted-expr={:?} applying adjustments={:?}\",\n+               expr, cx.tcx.tables.borrow().adjustments.get(&self.id));\n+\n         // Now apply adjustments, if any.\n         match cx.tcx.tables.borrow().adjustments.get(&self.id) {\n             None => {}\n@@ -416,6 +458,15 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     kind: ExprKind::UnsafeFnPointer { source: expr.to_ref() },\n                 };\n             }\n+            Some(&ty::adjustment::AdjustMutToConstPointer) => {\n+                let adjusted_ty = cx.tcx.expr_ty_adjusted(self);\n+                expr = Expr {\n+                    temp_lifetime: temp_lifetime,\n+                    ty: adjusted_ty,\n+                    span: self.span,\n+                    kind: ExprKind::Cast { source: expr.to_ref() },\n+                };\n+            }\n             Some(&ty::adjustment::AdjustDerefRef(ref adj)) => {\n                 for i in 0..adj.autoderefs {\n                     let i = i as u32;\n@@ -426,10 +477,38 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                             self.span,\n                             i,\n                             |mc| cx.tcx.tables.borrow().method_map.get(&mc).map(|m| m.ty));\n-                    let kind = if cx.tcx.is_overloaded_autoderef(self.id, i) {\n-                        overloaded_lvalue(cx, self, ty::MethodCall::autoderef(self.id, i),\n-                                          PassArgs::ByValue, expr.to_ref(), vec![])\n+                    debug!(\"make_mirror: autoderef #{}, adjusted_ty={:?}\", i, adjusted_ty);\n+                    let method_key = ty::MethodCall::autoderef(self.id, i);\n+                    let meth_ty =\n+                        cx.tcx.tables.borrow().method_map.get(&method_key).map(|m| m.ty);\n+                    let kind = if let Some(meth_ty) = meth_ty {\n+                        debug!(\"make_mirror: overloaded autoderef (meth_ty={:?})\", meth_ty);\n+\n+                        let ref_ty = cx.tcx.no_late_bound_regions(&meth_ty.fn_ret());\n+                        let (region, mutbl) = match ref_ty {\n+                            Some(ty::FnConverging(&ty::TyS {\n+                                sty: ty::TyRef(region, mt), ..\n+                            })) => (region, mt.mutbl),\n+                            _ => cx.tcx.sess.span_bug(\n+                                expr.span, \"autoderef returned bad type\")\n+                        };\n+\n+                        expr = Expr {\n+                            temp_lifetime: temp_lifetime,\n+                            ty: cx.tcx.mk_ref(\n+                                region, ty::TypeAndMut { ty: expr.ty, mutbl: mutbl }),\n+                            span: expr.span,\n+                            kind: ExprKind::Borrow {\n+                                region: *region,\n+                                borrow_kind: to_borrow_kind(mutbl),\n+                                arg: expr.to_ref()\n+                            }\n+                        };\n+\n+                        overloaded_lvalue(cx, self, method_key,\n+                                          PassArgs::ByRef, expr.to_ref(), vec![])\n                     } else {\n+                        debug!(\"make_mirror: built-in autoderef\");\n                         ExprKind::Deref { arg: expr.to_ref() }\n                     };\n                     expr = Expr {\n@@ -749,11 +828,16 @@ fn convert_var<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n             };\n             match upvar_capture {\n                 ty::UpvarCapture::ByValue => field_kind,\n-                ty::UpvarCapture::ByRef(_) => {\n+                ty::UpvarCapture::ByRef(borrow) => {\n                     ExprKind::Deref {\n                         arg: Expr {\n                             temp_lifetime: temp_lifetime,\n-                            ty: var_ty,\n+                            ty: cx.tcx.mk_ref(\n+                                cx.tcx.mk_region(borrow.region),\n+                                ty::TypeAndMut {\n+                                    ty: var_ty,\n+                                    mutbl: borrow.kind.to_mutbl_lossy()\n+                                }),\n                             span: expr.span,\n                             kind: field_kind,\n                         }.to_ref()"}, {"sha": "6f4375d53ec4bf95f24531532d08b93682fa575d", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -314,3 +314,20 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n         }\n     }\n }\n+\n+impl<'tcx> FieldPattern<'tcx> {\n+    pub fn field_ty(&self) -> Ty<'tcx> {\n+        debug!(\"field_ty({:?},ty={:?})\", self, self.pattern.ty);\n+        let r = match *self.pattern.kind {\n+            PatternKind::Binding { mode: BindingMode::ByRef(..), ..} => {\n+                match self.pattern.ty.sty {\n+                    ty::TyRef(_, mt) => mt.ty,\n+                    _ => unreachable!()\n+                }\n+            }\n+            _ => self.pattern.ty\n+        };\n+        debug!(\"field_ty -> {:?}\", r);\n+        r\n+    }\n+}"}, {"sha": "e8edd4067e2f827dd0971a80b130aa17e2b896c1", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -229,7 +229,7 @@ pub enum ExprKind<'tcx> {\n         variant_index: usize,\n         substs: &'tcx Substs<'tcx>,\n         fields: Vec<FieldExprRef<'tcx>>,\n-        base: Option<ExprRef<'tcx>>,\n+        base: Option<FruInfo<'tcx>>\n     },\n     Closure {\n         closure_id: DefId,\n@@ -256,6 +256,12 @@ pub struct FieldExprRef<'tcx> {\n     pub expr: ExprRef<'tcx>,\n }\n \n+#[derive(Clone, Debug)]\n+pub struct FruInfo<'tcx> {\n+    pub base: ExprRef<'tcx>,\n+    pub field_types: Vec<Ty<'tcx>>\n+}\n+\n #[derive(Clone, Debug)]\n pub struct Arm<'tcx> {\n     pub patterns: Vec<Pattern<'tcx>>,"}, {"sha": "5d915f37f6ebf8653ffbcfc6e1081f4eac617e54", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -20,6 +20,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![cfg_attr(not(stage0), deny(warnings))]\n #![unstable(feature = \"rustc_private\", issue = \"27812\")]\n \n+#![feature(box_patterns)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n "}, {"sha": "70c3354012135513a716f3f91f65b354f4a9cf9b", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -22,7 +22,8 @@ extern crate rustc_front;\n use build;\n use graphviz;\n use pretty;\n-use transform::{simplify_cfg, no_landing_pads};\n+use transform::{clear_dead_blocks, simplify_cfg, type_check};\n+use transform::{no_landing_pads};\n use rustc::dep_graph::DepNode;\n use rustc::mir::repr::Mir;\n use hair::cx::Cx;\n@@ -148,9 +149,12 @@ impl<'a, 'm, 'tcx> Visitor<'tcx> for InnerDump<'a,'m,'tcx> {\n \n         match build_mir(Cx::new(&infcx), implicit_arg_tys, id, span, decl, body) {\n             Ok(mut mir) => {\n-                no_landing_pads::NoLandingPads.run_on_mir(&mut mir, self.tcx);\n-                simplify_cfg::SimplifyCfg::new().run_on_mir(&mut mir, self.tcx);\n-\n+                clear_dead_blocks::ClearDeadBlocks::new().run_on_mir(&mut mir, &infcx);\n+                type_check::TypeckMir::new().run_on_mir(&mut mir, &infcx);\n+                no_landing_pads::NoLandingPads.run_on_mir(&mut mir, &infcx);\n+                if self.tcx.sess.opts.mir_opt_level > 0 {\n+                    simplify_cfg::SimplifyCfg::new().run_on_mir(&mut mir, &infcx);\n+                }\n                 let meta_item_list = self.attr\n                                          .iter()\n                                          .flat_map(|a| a.meta_item_list())"}, {"sha": "b35d8c08f5dc1e5da95d6a8b16bc337164e40942", "filename": "src/librustc_mir/transform/clear_dead_blocks.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Ftransform%2Fclear_dead_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Ftransform%2Fclear_dead_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fclear_dead_blocks.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -0,0 +1,81 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A pass that erases the contents of dead blocks. This pass must\n+//! run before any analysis passes because some of the dead blocks\n+//! can be ill-typed.\n+//!\n+//! The main problem is that typeck lets most blocks whose end is not\n+//! reachable have an arbitrary return type, rather than having the\n+//! usual () return type (as a note, typeck's notion of reachability\n+//! is in fact slightly weaker than MIR CFG reachability - see #31617).\n+//!\n+//! A standard example of the situation is:\n+//! ```rust\n+//!   fn example() {\n+//!       let _a: char = { return; };\n+//!   }\n+//! ```\n+//!\n+//! Here the block (`{ return; }`) has the return type `char`,\n+//! rather than `()`, but the MIR we naively generate still contains\n+//! the `_a = ()` write in the unreachable block \"after\" the return.\n+//!\n+//! As we have to run this pass even when we want to debug the MIR,\n+//! this pass just replaces the blocks with empty \"return\" blocks\n+//! and does not renumber anything.\n+\n+use rustc::middle::infer;\n+use rustc::mir::repr::*;\n+use rustc::mir::transform::MirPass;\n+\n+pub struct ClearDeadBlocks;\n+\n+impl ClearDeadBlocks {\n+    pub fn new() -> ClearDeadBlocks {\n+        ClearDeadBlocks\n+    }\n+\n+    fn clear_dead_blocks(&self, mir: &mut Mir) {\n+        let mut seen = vec![false; mir.basic_blocks.len()];\n+\n+        // These blocks are always required.\n+        seen[START_BLOCK.index()] = true;\n+        seen[END_BLOCK.index()] = true;\n+\n+        let mut worklist = vec![START_BLOCK];\n+        while let Some(bb) = worklist.pop() {\n+            for succ in mir.basic_block_data(bb).terminator().successors().iter() {\n+                if !seen[succ.index()] {\n+                    seen[succ.index()] = true;\n+                    worklist.push(*succ);\n+                }\n+            }\n+        }\n+\n+        for (n, (block, seen)) in mir.basic_blocks.iter_mut().zip(seen).enumerate() {\n+            if !seen {\n+                info!(\"clearing block #{}: {:?}\", n, block);\n+                *block = BasicBlockData {\n+                    statements: vec![],\n+                    terminator: Some(Terminator::Return),\n+                    is_cleanup: false\n+                };\n+            }\n+        }\n+    }\n+}\n+\n+impl MirPass for ClearDeadBlocks {\n+    fn run_on_mir<'a, 'tcx>(&mut self, mir: &mut Mir<'tcx>, _: &infer::InferCtxt<'a, 'tcx>)\n+    {\n+        self.clear_dead_blocks(mir);\n+    }\n+}"}, {"sha": "a82d1fc53991f5855aac1b98eff04be8063651d7", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -16,18 +16,13 @@ use rustc::middle::ty;\n use rustc::mir::repr::*;\n use rustc::mir::visit::MutVisitor;\n use rustc::mir::mir_map::MirMap;\n-use rustc::mir::transform::MirPass;\n \n pub fn erase_regions<'tcx>(tcx: &ty::ctxt<'tcx>, mir_map: &mut MirMap<'tcx>) {\n-    let mut eraser = EraseRegions;\n-\n     for (_, mir) in &mut mir_map.map {\n-        eraser.run_on_mir(mir, tcx);\n+        EraseRegionsVisitor::new(tcx).visit_mir(mir);\n     }\n }\n \n-pub struct EraseRegions;\n-\n struct EraseRegionsVisitor<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n }\n@@ -58,12 +53,6 @@ impl<'a, 'tcx> EraseRegionsVisitor<'a, 'tcx> {\n     }\n }\n \n-impl MirPass for EraseRegions {\n-    fn run_on_mir<'tcx>(&mut self, mir: &mut Mir<'tcx>, tcx: &ty::ctxt<'tcx>) {\n-        EraseRegionsVisitor::new(tcx).visit_mir(mir);\n-    }\n-}\n-\n impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n     fn visit_mir(&mut self, mir: &mut Mir<'tcx>) {\n         self.erase_regions_return_ty(&mut mir.return_ty);"}, {"sha": "d27c208041faf658eefc0aba6bffd0e4ed90fba4", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+pub mod clear_dead_blocks;\n pub mod simplify_cfg;\n pub mod erase_regions;\n pub mod no_landing_pads;\n+pub mod type_check;\n mod util;"}, {"sha": "e2c93bd4e8751cd87b721b0b9fd2296edf5dae99", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -11,7 +11,7 @@\n //! This pass removes the unwind branch of all the terminators when the no-landing-pads option is\n //! specified.\n \n-use rustc::middle::ty;\n+use rustc::middle::infer;\n use rustc::mir::repr::*;\n use rustc::mir::visit::MutVisitor;\n use rustc::mir::transform::MirPass;\n@@ -41,8 +41,9 @@ impl<'tcx> MutVisitor<'tcx> for NoLandingPads {\n }\n \n impl MirPass for NoLandingPads {\n-    fn run_on_mir<'tcx>(&mut self, mir: &mut Mir<'tcx>, tcx: &ty::ctxt<'tcx>) {\n-        if tcx.sess.no_landing_pads() {\n+    fn run_on_mir<'a, 'tcx>(&mut self, mir: &mut Mir<'tcx>,\n+                            infcx: &infer::InferCtxt<'a, 'tcx>) {\n+        if infcx.tcx.sess.no_landing_pads() {\n             self.visit_mir(mir);\n         }\n     }"}, {"sha": "16d12324202f33c8f1bbf05e346cad613caa615a", "filename": "src/librustc_mir/transform/simplify_cfg.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use rustc::middle::const_eval::ConstVal;\n+use rustc::middle::infer;\n use rustc::mir::repr::*;\n use transform::util;\n use rustc::mir::transform::MirPass;\n@@ -119,7 +120,7 @@ impl SimplifyCfg {\n }\n \n impl MirPass for SimplifyCfg {\n-    fn run_on_mir<'tcx>(&mut self, mir: &mut Mir<'tcx>, _: &::rustc::middle::ty::ctxt<'tcx>) {\n+    fn run_on_mir<'a, 'tcx>(&mut self, mir: &mut Mir<'tcx>, _: &infer::InferCtxt<'a, 'tcx>) {\n         let mut changed = true;\n         while changed {\n             changed = self.simplify_branches(mir);"}, {"sha": "0e97e3629064be16abd9b6fe7a1b1fb98323554c", "filename": "src/librustc_mir/transform/type_check.rs", "status": "added", "additions": 598, "deletions": 0, "changes": 598, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -0,0 +1,598 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This pass type-checks the MIR to ensure it is not broken.\n+#![allow(unreachable_code)]\n+\n+use rustc::middle::infer::{self, InferCtxt};\n+use rustc::middle::traits;\n+use rustc::middle::ty::{self, Ty};\n+use rustc::middle::ty::fold::TypeFoldable;\n+use rustc::mir::repr::*;\n+use rustc::mir::tcx::LvalueTy;\n+use rustc::mir::transform::MirPass;\n+use rustc::mir::visit::{self, Visitor};\n+\n+use syntax::codemap::{Span, DUMMY_SP};\n+use std::fmt;\n+\n+macro_rules! span_mirbug {\n+    ($context:expr, $elem:expr, $($message:tt)*) => ({\n+        $context.tcx().sess.span_warn(\n+            $context.last_span,\n+            &format!(\"broken MIR ({:?}): {}\", $elem, format!($($message)*))\n+        )\n+    })\n+}\n+\n+macro_rules! span_mirbug_and_err {\n+    ($context:expr, $elem:expr, $($message:tt)*) => ({\n+        {\n+            $context.tcx().sess.span_warn(\n+                $context.last_span,\n+                &format!(\"broken MIR ({:?}): {:?}\", $elem, format!($($message)*))\n+            );\n+            $context.error()\n+        }\n+    })\n+}\n+\n+enum FieldAccessError {\n+    OutOfRange { field_count: usize }\n+}\n+\n+/// Verifies that MIR types are sane to not crash further checks.\n+///\n+/// The sanitize_XYZ methods here take an MIR object and compute its\n+/// type, calling `span_mirbug` and returning an error type if there\n+/// is a problem.\n+struct TypeVerifier<'a, 'b: 'a, 'tcx: 'b> {\n+    cx: &'a mut TypeChecker<'b, 'tcx>,\n+    mir: &'a Mir<'tcx>,\n+    last_span: Span,\n+    errors_reported: bool\n+}\n+\n+impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n+    fn visit_span(&mut self, span: &Span) {\n+        if *span != DUMMY_SP {\n+            self.last_span = *span;\n+        }\n+    }\n+\n+    fn visit_lvalue(&mut self, lvalue: &Lvalue<'tcx>, _context: visit::LvalueContext) {\n+        self.sanitize_lvalue(lvalue);\n+    }\n+\n+    fn visit_constant(&mut self, constant: &Constant<'tcx>) {\n+        self.super_constant(constant);\n+        self.sanitize_type(constant, constant.ty);\n+    }\n+\n+    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>) {\n+        self.super_rvalue(rvalue);\n+        if let Some(ty) = self.mir.rvalue_ty(self.tcx(), rvalue) {\n+            self.sanitize_type(rvalue, ty);\n+        }\n+    }\n+\n+    fn visit_mir(&mut self, mir: &Mir<'tcx>) {\n+        if let ty::FnConverging(t) = mir.return_ty {\n+            self.sanitize_type(&\"return type\", t);\n+        }\n+        for var_decl in &mir.var_decls {\n+            self.sanitize_type(var_decl, var_decl.ty);\n+        }\n+        for (n, arg_decl) in mir.arg_decls.iter().enumerate() {\n+            self.sanitize_type(&(n, arg_decl), arg_decl.ty);\n+        }\n+        for (n, tmp_decl) in mir.temp_decls.iter().enumerate() {\n+            self.sanitize_type(&(n, tmp_decl), tmp_decl.ty);\n+        }\n+        if self.errors_reported {\n+            return;\n+        }\n+        self.super_mir(mir);\n+    }\n+}\n+\n+impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n+    fn new(cx: &'a mut TypeChecker<'b, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n+        TypeVerifier {\n+            cx: cx,\n+            mir: mir,\n+            last_span: mir.span,\n+            errors_reported: false\n+        }\n+    }\n+\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n+        self.cx.infcx.tcx\n+    }\n+\n+    fn infcx(&self) -> &'a InferCtxt<'a, 'tcx> {\n+        self.cx.infcx\n+    }\n+\n+    fn sanitize_type(&mut self, parent: &fmt::Debug, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        if ty.needs_infer() || ty.has_escaping_regions() || ty.references_error() {\n+            span_mirbug_and_err!(self, parent, \"bad type {:?}\", ty)\n+        } else {\n+            ty\n+        }\n+    }\n+\n+    fn sanitize_lvalue(&mut self, lvalue: &Lvalue<'tcx>) -> LvalueTy<'tcx> {\n+        debug!(\"sanitize_lvalue: {:?}\", lvalue);\n+        match *lvalue {\n+            Lvalue::Var(index) => LvalueTy::Ty { ty: self.mir.var_decls[index as usize].ty },\n+            Lvalue::Temp(index) =>\n+                LvalueTy::Ty { ty: self.mir.temp_decls[index as usize].ty },\n+            Lvalue::Arg(index) =>\n+                LvalueTy::Ty { ty: self.mir.arg_decls[index as usize].ty },\n+            Lvalue::Static(def_id) =>\n+                LvalueTy::Ty { ty: self.tcx().lookup_item_type(def_id).ty },\n+            Lvalue::ReturnPointer => {\n+                if let ty::FnConverging(return_ty) = self.mir.return_ty {\n+                    LvalueTy::Ty { ty: return_ty }\n+                } else {\n+                    LvalueTy::Ty {\n+                        ty: span_mirbug_and_err!(\n+                            self, lvalue, \"return in diverging function\")\n+                    }\n+                }\n+            }\n+            Lvalue::Projection(ref proj) => {\n+                let base_ty = self.sanitize_lvalue(&proj.base);\n+                if let LvalueTy::Ty { ty } = base_ty {\n+                    if ty.references_error() {\n+                        assert!(self.errors_reported);\n+                        return LvalueTy::Ty { ty: self.tcx().types.err };\n+                    }\n+                }\n+                self.sanitize_projection(base_ty, &proj.elem, lvalue)\n+            }\n+        }\n+    }\n+\n+    fn sanitize_projection(&mut self,\n+                           base: LvalueTy<'tcx>,\n+                           pi: &LvalueElem<'tcx>,\n+                           lvalue: &Lvalue<'tcx>)\n+                           -> LvalueTy<'tcx> {\n+        debug!(\"sanitize_projection: {:?} {:?} {:?}\", base, pi, lvalue);\n+        let tcx = self.tcx();\n+        let base_ty = base.to_ty(tcx);\n+        let span = self.last_span;\n+        match *pi {\n+            ProjectionElem::Deref => {\n+                let deref_ty = base_ty.builtin_deref(true, ty::LvaluePreference::NoPreference);\n+                LvalueTy::Ty {\n+                    ty: deref_ty.map(|t| t.ty).unwrap_or_else(|| {\n+                        span_mirbug_and_err!(\n+                            self, lvalue, \"deref of non-pointer {:?}\", base_ty)\n+                    })\n+                }\n+            }\n+            ProjectionElem::Index(ref i) => {\n+                self.visit_operand(i);\n+                let index_ty = self.mir.operand_ty(tcx, i);\n+                if index_ty != tcx.types.usize {\n+                    LvalueTy::Ty {\n+                        ty: span_mirbug_and_err!(self, i, \"index by non-usize {:?}\", i)\n+                    }\n+                } else {\n+                    LvalueTy::Ty {\n+                        ty: base_ty.builtin_index().unwrap_or_else(|| {\n+                            span_mirbug_and_err!(\n+                                self, lvalue, \"index of non-array {:?}\", base_ty)\n+                        })\n+                    }\n+                }\n+            }\n+            ProjectionElem::ConstantIndex { .. } => {\n+                // consider verifying in-bounds\n+                LvalueTy::Ty {\n+                    ty: base_ty.builtin_index().unwrap_or_else(|| {\n+                        span_mirbug_and_err!(\n+                            self, lvalue, \"index of non-array {:?}\", base_ty)\n+                    })\n+                }\n+            }\n+            ProjectionElem::Downcast(adt_def1, index) =>\n+                match base_ty.sty {\n+                    ty::TyEnum(adt_def, substs) if adt_def == adt_def1 => {\n+                        if index >= adt_def.variants.len() {\n+                            LvalueTy::Ty {\n+                                ty: span_mirbug_and_err!(\n+                                    self,\n+                                    lvalue,\n+                                    \"cast to variant #{:?} but enum only has {:?}\",\n+                                    index,\n+                                    adt_def.variants.len())\n+                            }\n+                        } else {\n+                            LvalueTy::Downcast {\n+                                adt_def: adt_def,\n+                                substs: substs,\n+                                variant_index: index\n+                            }\n+                        }\n+                    }\n+                    _ => LvalueTy::Ty {\n+                        ty: span_mirbug_and_err!(\n+                            self, lvalue, \"can't downcast {:?} as {:?}\",\n+                            base_ty, adt_def1)\n+                    }\n+                },\n+            ProjectionElem::Field(field, fty) => {\n+                let fty = self.sanitize_type(lvalue, fty);\n+                match self.field_ty(lvalue, base, field) {\n+                    Ok(ty) => {\n+                        if let Err(terr) = self.cx.mk_eqty(span, ty, fty) {\n+                            span_mirbug!(\n+                                self, lvalue, \"bad field access ({:?}: {:?}): {:?}\",\n+                                ty, fty, terr);\n+                        }\n+                    }\n+                    Err(FieldAccessError::OutOfRange { field_count }) => {\n+                        span_mirbug!(\n+                            self, lvalue, \"accessed field #{} but variant only has {}\",\n+                            field.index(), field_count)\n+                    }\n+                }\n+                LvalueTy::Ty { ty: fty }\n+            }\n+        }\n+    }\n+\n+    fn error(&mut self) -> Ty<'tcx> {\n+        self.errors_reported = true;\n+        self.tcx().types.err\n+    }\n+\n+    fn field_ty(&mut self,\n+                parent: &fmt::Debug,\n+                base_ty: LvalueTy<'tcx>,\n+                field: Field)\n+                -> Result<Ty<'tcx>, FieldAccessError>\n+    {\n+        let tcx = self.tcx();\n+\n+        let (variant, substs) = match base_ty {\n+            LvalueTy::Downcast { adt_def, substs, variant_index } => {\n+                (&adt_def.variants[variant_index], substs)\n+            }\n+            LvalueTy::Ty { ty } => match ty.sty {\n+                ty::TyStruct(adt_def, substs) | ty::TyEnum(adt_def, substs)\n+                    if adt_def.is_univariant() => {\n+                        (&adt_def.variants[0], substs)\n+                    }\n+                ty::TyTuple(ref tys) | ty::TyClosure(_, box ty::ClosureSubsts {\n+                    upvar_tys: ref tys, ..\n+                }) => {\n+                    return match tys.get(field.index()) {\n+                        Some(&ty) => Ok(ty),\n+                        None => Err(FieldAccessError::OutOfRange {\n+                            field_count: tys.len()\n+                        })\n+                    }\n+                }\n+                _ => return Ok(span_mirbug_and_err!(\n+                    self, parent, \"can't project out of {:?}\", base_ty))\n+            }\n+        };\n+\n+        if let Some(field) = variant.fields.get(field.index()) {\n+            Ok(self.normalize(field.ty(tcx, substs)))\n+        } else {\n+            Err(FieldAccessError::OutOfRange { field_count: variant.fields.len() })\n+        }\n+    }\n+\n+    fn normalize(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        let infcx = self.infcx();\n+        let mut selcx = traits::SelectionContext::new(infcx);\n+        let cause = traits::ObligationCause::misc(self.last_span, 0);\n+        let traits::Normalized { value: ty, obligations } =\n+            traits::normalize(&mut selcx, cause, &ty);\n+\n+        debug!(\"normalize: ty={:?} obligations={:?}\",\n+               ty,\n+               obligations);\n+\n+        let mut fulfill_cx = &mut self.cx.fulfillment_cx;\n+        for obligation in obligations {\n+            fulfill_cx.register_predicate_obligation(infcx, obligation);\n+        }\n+\n+        ty\n+    }\n+}\n+\n+pub struct TypeChecker<'a, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    fulfillment_cx: traits::FulfillmentContext<'tcx>,\n+    last_span: Span\n+}\n+\n+impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n+    fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> Self {\n+        TypeChecker {\n+            infcx: infcx,\n+            fulfillment_cx: traits::FulfillmentContext::new(),\n+            last_span: DUMMY_SP\n+        }\n+    }\n+\n+    fn mk_subty(&self, span: Span, sup: Ty<'tcx>, sub: Ty<'tcx>)\n+                -> infer::UnitResult<'tcx>\n+    {\n+        infer::mk_subty(self.infcx, false, infer::TypeOrigin::Misc(span),\n+                        sup, sub)\n+    }\n+\n+    fn mk_eqty(&self, span: Span, a: Ty<'tcx>, b: Ty<'tcx>)\n+                -> infer::UnitResult<'tcx>\n+    {\n+        infer::mk_eqty(self.infcx, false, infer::TypeOrigin::Misc(span),\n+                       a, b)\n+    }\n+\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn check_stmt(&mut self, mir: &Mir<'tcx>, stmt: &Statement<'tcx>) {\n+        debug!(\"check_stmt: {:?}\", stmt);\n+        let tcx = self.tcx();\n+        match stmt.kind {\n+            StatementKind::Assign(ref lv, ref rv) => {\n+                let lv_ty = mir.lvalue_ty(tcx, lv).to_ty(tcx);\n+                let rv_ty = mir.rvalue_ty(tcx, rv);\n+                if let Some(rv_ty) = rv_ty {\n+                    if let Err(terr) = self.mk_subty(self.last_span, rv_ty, lv_ty) {\n+                        span_mirbug!(self, stmt, \"bad assignment ({:?} = {:?}): {:?}\",\n+                                     lv_ty, rv_ty, terr);\n+                    }\n+                }\n+\n+                // FIXME: rvalue with undeterminable type - e.g. inline\n+                // asm.\n+            }\n+        }\n+    }\n+\n+    fn check_terminator(&self,\n+                        mir: &Mir<'tcx>,\n+                        term: &Terminator<'tcx>) {\n+        debug!(\"check_terminator: {:?}\", term);\n+        let tcx = self.tcx();\n+        match *term {\n+            Terminator::Goto { .. } |\n+            Terminator::Resume |\n+            Terminator::Return |\n+            Terminator::Drop { .. } => {\n+                // no checks needed for these\n+            }\n+\n+            Terminator::If { ref cond, .. } => {\n+                let cond_ty = mir.operand_ty(tcx, cond);\n+                match cond_ty.sty {\n+                    ty::TyBool => {}\n+                    _ => {\n+                        span_mirbug!(self, term, \"bad If ({:?}, not bool\", cond_ty);\n+                    }\n+                }\n+            }\n+            Terminator::SwitchInt { ref discr, switch_ty, .. } => {\n+                let discr_ty = mir.lvalue_ty(tcx, discr).to_ty(tcx);\n+                if let Err(terr) = self.mk_subty(self.last_span, discr_ty, switch_ty) {\n+                    span_mirbug!(self, term, \"bad SwitchInt ({:?} on {:?}): {:?}\",\n+                                 switch_ty, discr_ty, terr);\n+                }\n+                if !switch_ty.is_integral() && !switch_ty.is_char() &&\n+                    !switch_ty.is_bool()\n+                {\n+                    span_mirbug!(self, term, \"bad SwitchInt discr ty {:?}\",switch_ty);\n+                }\n+                // FIXME: check the values\n+            }\n+            Terminator::Switch { ref discr, adt_def, ref targets } => {\n+                let discr_ty = mir.lvalue_ty(tcx, discr).to_ty(tcx);\n+                match discr_ty.sty {\n+                    ty::TyEnum(def, _)\n+                        if def == adt_def && adt_def.variants.len() == targets.len()\n+                        => {},\n+                    _ => {\n+                        span_mirbug!(self, term, \"bad Switch ({:?} on {:?})\",\n+                                     adt_def, discr_ty);\n+                    }\n+                }\n+            }\n+            Terminator::Call { ref func, ref args, ref destination, .. } => {\n+                let func_ty = mir.operand_ty(tcx, func);\n+                debug!(\"check_terminator: call, func_ty={:?}\", func_ty);\n+                let func_ty = match func_ty.sty {\n+                    ty::TyBareFn(_, func_ty) => func_ty,\n+                    _ => {\n+                        span_mirbug!(self, term, \"call to non-function {:?}\", func_ty);\n+                        return;\n+                    }\n+                };\n+                let sig = tcx.erase_late_bound_regions(&func_ty.sig);\n+                self.check_call_dest(mir, term, &sig, destination);\n+\n+                if self.is_box_free(func) {\n+                    self.check_box_free_inputs(mir, term, &sig, args);\n+                } else {\n+                    self.check_call_inputs(mir, term, &sig, args);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_call_dest(&self,\n+                       mir: &Mir<'tcx>,\n+                       term: &Terminator<'tcx>,\n+                       sig: &ty::FnSig<'tcx>,\n+                       destination: &Option<(Lvalue<'tcx>, BasicBlock)>) {\n+        let tcx = self.tcx();\n+        match (destination, sig.output) {\n+            (&Some(..), ty::FnDiverging) => {\n+                span_mirbug!(self, term, \"call to diverging function {:?} with dest\", sig);\n+            }\n+            (&Some((ref dest, _)), ty::FnConverging(ty)) => {\n+                let dest_ty = mir.lvalue_ty(tcx, dest).to_ty(tcx);\n+                if let Err(terr) = self.mk_subty(self.last_span, ty, dest_ty) {\n+                    span_mirbug!(self, term,\n+                                 \"call dest mismatch ({:?} <- {:?}): {:?}\",\n+                                 dest_ty, ty, terr);\n+                }\n+            }\n+            (&None, ty::FnDiverging) => {}\n+            (&None, ty::FnConverging(..)) => {\n+                span_mirbug!(self, term, \"call to converging function {:?} w/o dest\", sig);\n+             }\n+        }\n+    }\n+\n+    fn check_call_inputs(&self,\n+                         mir: &Mir<'tcx>,\n+                         term: &Terminator<'tcx>,\n+                         sig: &ty::FnSig<'tcx>,\n+                         args: &[Operand<'tcx>])\n+    {\n+        debug!(\"check_call_inputs({:?}, {:?})\", sig, args);\n+        if args.len() < sig.inputs.len() ||\n+           (args.len() > sig.inputs.len() && !sig.variadic) {\n+            span_mirbug!(self, term, \"call to {:?} with wrong # of args\", sig);\n+        }\n+        for (n, (fn_arg, op_arg)) in sig.inputs.iter().zip(args).enumerate() {\n+            let op_arg_ty = mir.operand_ty(self.tcx(), op_arg);\n+            if let Err(terr) = self.mk_subty(self.last_span, op_arg_ty, fn_arg) {\n+                span_mirbug!(self, term, \"bad arg #{:?} ({:?} <- {:?}): {:?}\",\n+                             n, fn_arg, op_arg_ty, terr);\n+            }\n+        }\n+    }\n+\n+    fn is_box_free(&self, operand: &Operand<'tcx>) -> bool {\n+        match operand {\n+            &Operand::Constant(Constant {\n+                literal: Literal::Item { def_id, .. }, ..\n+            }) => {\n+                Some(def_id) == self.tcx().lang_items.box_free_fn()\n+            }\n+            _ => false,\n+        }\n+    }\n+\n+    fn check_box_free_inputs(&self,\n+                             mir: &Mir<'tcx>,\n+                             term: &Terminator<'tcx>,\n+                             sig: &ty::FnSig<'tcx>,\n+                             args: &[Operand<'tcx>])\n+    {\n+        debug!(\"check_box_free_inputs\");\n+\n+        // box_free takes a Box as a pointer. Allow for that.\n+\n+        if sig.inputs.len() != 1 {\n+            span_mirbug!(self, term, \"box_free should take 1 argument\");\n+            return;\n+        }\n+\n+        let pointee_ty = match sig.inputs[0].sty {\n+            ty::TyRawPtr(mt) => mt.ty,\n+            _ => {\n+                span_mirbug!(self, term, \"box_free should take a raw ptr\");\n+                return;\n+            }\n+        };\n+\n+        if args.len() != 1 {\n+            span_mirbug!(self, term, \"box_free called with wrong # of args\");\n+            return;\n+        }\n+\n+        let arg_ty = match mir.operand_ty(self.tcx(), &args[0]).sty {\n+            ty::TyRawPtr(mt) => mt.ty,\n+            ty::TyBox(ty) => ty,\n+            _ => {\n+                span_mirbug!(self, term, \"box_free called with bad arg ty\");\n+                return;\n+            }\n+        };\n+\n+        if let Err(terr) = self.mk_subty(self.last_span, arg_ty, pointee_ty) {\n+            span_mirbug!(self, term, \"bad box_free arg ({:?} <- {:?}): {:?}\",\n+                         pointee_ty, arg_ty, terr);\n+        }\n+    }\n+\n+    fn typeck_mir(&mut self, mir: &Mir<'tcx>) {\n+        self.last_span = mir.span;\n+        debug!(\"run_on_mir: {:?}\", mir.span);\n+        for block in &mir.basic_blocks {\n+            for stmt in &block.statements {\n+                if stmt.span != DUMMY_SP {\n+                    self.last_span = stmt.span;\n+                }\n+                self.check_stmt(mir, stmt);\n+            }\n+\n+            if let Some(ref terminator) = block.terminator {\n+                self.check_terminator(mir, terminator);\n+            }\n+        }\n+    }\n+\n+    fn verify_obligations(&mut self, mir: &Mir<'tcx>) {\n+        self.last_span = mir.span;\n+        if let Err(e) = self.fulfillment_cx.select_all_or_error(self.infcx) {\n+            span_mirbug!(self, \"\", \"errors selecting obligation: {:?}\",\n+                         e);\n+        }\n+    }\n+}\n+\n+pub struct TypeckMir;\n+\n+impl TypeckMir {\n+    pub fn new() -> Self {\n+        TypeckMir\n+    }\n+}\n+\n+impl MirPass for TypeckMir {\n+    fn run_on_mir<'a, 'tcx>(&mut self, mir: &mut Mir<'tcx>, infcx: &InferCtxt<'a, 'tcx>)\n+    {\n+        if infcx.tcx.sess.err_count() > 0 {\n+            // compiling a broken program can obviously result in a\n+            // broken MIR, so try not to report duplicate errors.\n+            return;\n+        }\n+\n+        let mut checker = TypeChecker::new(infcx);\n+\n+        {\n+            let mut verifier = TypeVerifier::new(&mut checker, mir);\n+            verifier.visit_mir(mir);\n+            if verifier.errors_reported {\n+                // don't do further checks to avoid ICEs\n+                return;\n+            }\n+        }\n+\n+        checker.typeck_mir(mir);\n+        checker.verify_obligations(mir);\n+    }\n+}"}, {"sha": "b0d459063ef29a5bccf2c5858d10ce574a3e7368", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -768,7 +768,8 @@ fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Exp\n     match v.tcx.tables.borrow().adjustments.get(&e.id) {\n         None |\n         Some(&ty::adjustment::AdjustReifyFnPointer) |\n-        Some(&ty::adjustment::AdjustUnsafeFnPointer) => {}\n+        Some(&ty::adjustment::AdjustUnsafeFnPointer) |\n+        Some(&ty::adjustment::AdjustMutToConstPointer) => {}\n \n         Some(&ty::adjustment::AdjustDerefRef(\n             ty::adjustment::AutoDerefRef { autoderefs, .. }"}, {"sha": "79c73a83ee7e0e5889152482aa246d0e2f860b05", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -40,7 +40,7 @@ use trans::type_of;\n use trans::Disr;\n use middle::subst::Substs;\n use middle::ty::adjustment::{AdjustDerefRef, AdjustReifyFnPointer};\n-use middle::ty::adjustment::AdjustUnsafeFnPointer;\n+use middle::ty::adjustment::{AdjustUnsafeFnPointer, AdjustMutToConstPointer};\n use middle::ty::{self, Ty};\n use middle::ty::cast::{CastTy,IntTy};\n use util::nodemap::NodeMap;\n@@ -354,7 +354,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // FIXME(#19925) once fn item types are\n             // zero-sized, we'll need to do something here\n         }\n-        Some(AdjustUnsafeFnPointer) => {\n+        Some(AdjustUnsafeFnPointer) | Some(AdjustMutToConstPointer) => {\n             // purely a type-level thing\n         }\n         Some(AdjustDerefRef(adj)) => {"}, {"sha": "782e38d3af2d4ea6d57d4f59aeb4a7f041281fe9", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -71,7 +71,8 @@ use trans::tvec;\n use trans::type_of;\n use trans::Disr;\n use middle::ty::adjustment::{AdjustDerefRef, AdjustReifyFnPointer};\n-use middle::ty::adjustment::{AdjustUnsafeFnPointer, CustomCoerceUnsized};\n+use middle::ty::adjustment::{AdjustUnsafeFnPointer, AdjustMutToConstPointer};\n+use middle::ty::adjustment::CustomCoerceUnsized;\n use middle::ty::{self, Ty};\n use middle::ty::MethodCall;\n use middle::ty::cast::{CastKind, CastTy};\n@@ -354,7 +355,7 @@ fn adjustment_required<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             // zero-sized, we'll need to return true here\n             false\n         }\n-        AdjustUnsafeFnPointer => {\n+        AdjustUnsafeFnPointer | AdjustMutToConstPointer => {\n             // purely a type-level thing\n             false\n         }\n@@ -391,7 +392,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             // FIXME(#19925) once fn item types are\n             // zero-sized, we'll need to do something here\n         }\n-        AdjustUnsafeFnPointer => {\n+        AdjustUnsafeFnPointer | AdjustMutToConstPointer => {\n             // purely a type-level thing\n         }\n         AdjustDerefRef(ref adj) => {"}, {"sha": "609f1dee98aadb2e3eb9593a56b08597e2a686d2", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 51, "deletions": 10, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use llvm::{BasicBlockRef, ValueRef, OperandBundleDef};\n-use rustc::middle::ty;\n+use rustc::middle::ty::{self, Ty};\n use rustc::mir::repr as mir;\n use syntax::abi::Abi;\n use trans::adt;\n@@ -26,8 +26,55 @@ use trans::type_::Type;\n \n use super::MirContext;\n use super::operand::OperandValue::{FatPtr, Immediate, Ref};\n+use super::operand::OperandRef;\n+\n+#[derive(PartialEq, Eq)]\n+enum AbiStyle {\n+    Foreign,\n+    RustCall,\n+    Rust\n+}\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n+    fn abi_style(&self, fn_ty: Ty<'tcx>) -> AbiStyle {\n+        if let ty::TyBareFn(_, ref f) = fn_ty.sty {\n+            // We do not translate intrinsics here (they shouldn\u2019t be functions)\n+            assert!(f.abi != Abi::RustIntrinsic && f.abi != Abi::PlatformIntrinsic);\n+\n+            match f.abi {\n+                Abi::Rust => AbiStyle::Rust,\n+                Abi::RustCall => AbiStyle::RustCall,\n+                _ => AbiStyle::Foreign\n+            }\n+        } else {\n+            unreachable!()\n+        }\n+    }\n+\n+    fn arg_operands(&mut self,\n+                    bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                    abi_style: AbiStyle,\n+                    args: &[mir::Operand<'tcx>])\n+                    -> Vec<OperandRef<'tcx>>\n+    {\n+        match abi_style {\n+            AbiStyle::Foreign | AbiStyle::Rust => {\n+                args.iter().map(|arg| self.trans_operand(bcx, arg)).collect()\n+            }\n+            AbiStyle::RustCall => match args.split_last() {\n+                None => vec![],\n+                Some((tup, self_ty)) => {\n+                    // we can reorder safely because of MIR\n+                    let untupled_args = self.trans_operand_untupled(bcx, tup);\n+                    self_ty\n+                        .iter().map(|arg| self.trans_operand(bcx, arg))\n+                        .chain(untupled_args.into_iter())\n+                        .collect()\n+                }\n+            }\n+        }\n+    }\n+\n     pub fn trans_block(&mut self, bb: mir::BasicBlock) {\n         debug!(\"trans_block({:?})\", bb);\n \n@@ -159,13 +206,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let mut arg_tys = Vec::new();\n \n                 // Foreign-ABI functions are translated differently\n-                let is_foreign = if let ty::TyBareFn(_, ref f) = callee.ty.sty {\n-                    // We do not translate intrinsics here (they shouldn\u2019t be functions)\n-                    assert!(f.abi != Abi::RustIntrinsic && f.abi != Abi::PlatformIntrinsic);\n-                    f.abi != Abi::Rust && f.abi != Abi::RustCall\n-                } else {\n-                    false\n-                };\n+                let abi_style = self.abi_style(callee.ty);\n+                let is_foreign = abi_style == AbiStyle::Foreign;\n \n                 // Prepare the return value destination\n                 let (ret_dest_ty, must_copy_dest) = if let Some((ref d, _)) = *destination {\n@@ -182,8 +224,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 };\n \n                 // Process the rest of the args.\n-                for arg in args {\n-                    let operand = self.trans_operand(&bcx, arg);\n+                for operand in self.arg_operands(&bcx, abi_style, args) {\n                     match operand.val {\n                         Ref(llval) | Immediate(llval) => llargs.push(llval),\n                         FatPtr(b, e) => {"}, {"sha": "826fb025bc1f72438caa76e675104b7d14b1f0f7", "filename": "src/librustc_trans/trans/mir/lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -126,7 +126,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             }\n                         })\n                     }\n-                    mir::ProjectionElem::Field(ref field) => {\n+                    mir::ProjectionElem::Field(ref field, _) => {\n                         let base_ty = tr_base.ty.to_ty(tcx);\n                         let base_repr = adt::represent_type(ccx, base_ty);\n                         let discr = match tr_base.ty {"}, {"sha": "2183348c8b5eabafc421597c6a547c6e5a2b4a02", "filename": "src/librustc_trans/trans/mir/operand.rs", "status": "modified", "additions": 73, "deletions": 25, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -9,13 +9,16 @@\n // except according to those terms.\n \n use llvm::ValueRef;\n-use rustc::middle::ty::{Ty, TypeFoldable};\n+use rustc::middle::ty::{self, Ty};\n use rustc::mir::repr as mir;\n+use trans::adt;\n use trans::base;\n use trans::common::{self, Block, BlockAndBuilder};\n use trans::datum;\n+use trans::Disr;\n \n use super::{MirContext, TempRef};\n+use super::lvalue::LvalueRef;\n \n /// The representation of a Rust value. The enum variant is in fact\n /// uniquely determined by the value's type, but is kept as a\n@@ -90,6 +93,32 @@ impl<'tcx> OperandRef<'tcx> {\n }\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n+    pub fn trans_load(&mut self,\n+                      bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                      llval: ValueRef,\n+                      ty: Ty<'tcx>)\n+                      -> OperandRef<'tcx>\n+    {\n+        debug!(\"trans_load: {} @ {:?}\", bcx.val_to_string(llval), ty);\n+\n+        let val = match datum::appropriate_rvalue_mode(bcx.ccx(), ty) {\n+            datum::ByValue => {\n+                bcx.with_block(|bcx| {\n+                    OperandValue::Immediate(base::load_ty(bcx, llval, ty))\n+                })\n+            }\n+            datum::ByRef if common::type_is_fat_ptr(bcx.tcx(), ty) => {\n+                let (lldata, llextra) = bcx.with_block(|bcx| {\n+                    base::load_fat_ptr(bcx, llval, ty)\n+                });\n+                OperandValue::FatPtr(lldata, llextra)\n+            }\n+            datum::ByRef => OperandValue::Ref(llval)\n+        };\n+\n+        OperandRef { val: val, ty: ty }\n+    }\n+\n     pub fn trans_operand(&mut self,\n                          bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                          operand: &mir::Operand<'tcx>)\n@@ -120,30 +149,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 // out from their home\n                 let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n                 let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n-                debug!(\"trans_operand: tr_lvalue={} @ {:?}\",\n-                       bcx.val_to_string(tr_lvalue.llval),\n-                       ty);\n-                let val = match datum::appropriate_rvalue_mode(bcx.ccx(), ty) {\n-                    datum::ByValue => {\n-                        bcx.with_block(|bcx| {\n-                            OperandValue::Immediate(base::load_ty(bcx, tr_lvalue.llval, ty))\n-                        })\n-                    }\n-                    datum::ByRef if common::type_is_fat_ptr(bcx.tcx(), ty) => {\n-                        let (lldata, llextra) = bcx.with_block(|bcx| {\n-                            base::load_fat_ptr(bcx, tr_lvalue.llval, ty)\n-                        });\n-                        OperandValue::FatPtr(lldata, llextra)\n-                    }\n-                    datum::ByRef => OperandValue::Ref(tr_lvalue.llval)\n-                };\n-\n-                assert!(!ty.has_erasable_regions());\n-\n-                OperandRef {\n-                    val: val,\n-                    ty: ty\n-                }\n+                self.trans_load(bcx, tr_lvalue.llval, ty)\n             }\n \n             mir::Operand::Constant(ref constant) => {\n@@ -197,4 +203,46 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n         }\n     }\n+\n+    pub fn trans_operand_untupled(&mut self,\n+                                  bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                                  operand: &mir::Operand<'tcx>)\n+                                  -> Vec<OperandRef<'tcx>>\n+    {\n+        // FIXME: consider having some optimization to avoid tupling/untupling\n+        // (and storing/loading in the case of immediates)\n+\n+        // avoid trans_operand for pointless copying\n+        let lv = match *operand {\n+            mir::Operand::Consume(ref lvalue) => self.trans_lvalue(bcx, lvalue),\n+            mir::Operand::Constant(ref constant) => {\n+                // FIXME: consider being less pessimized\n+                if constant.ty.is_nil() {\n+                    return vec![];\n+                }\n+\n+                let ty = bcx.monomorphize(&constant.ty);\n+                let lv = LvalueRef::alloca(bcx, ty, \"__untuple_alloca\");\n+                let constant = self.trans_constant(bcx, constant);\n+                self.store_operand(bcx, lv.llval, constant);\n+                lv\n+           }\n+        };\n+\n+        let lv_ty = lv.ty.to_ty(bcx.tcx());\n+        let result_types = match lv_ty.sty {\n+            ty::TyTuple(ref tys) => tys,\n+            _ => bcx.tcx().sess.span_bug(\n+                self.mir.span,\n+                &format!(\"bad final argument to \\\"rust-call\\\" fn {:?}\", lv_ty))\n+        };\n+\n+        let base_repr = adt::represent_type(bcx.ccx(), lv_ty);\n+        let base = adt::MaybeSizedValue::sized(lv.llval);\n+        result_types.iter().enumerate().map(|(n, &ty)| {\n+            self.trans_load(bcx, bcx.with_block(|bcx| {\n+                adt::trans_field_ptr(bcx, &base_repr, base, Disr(0), n)\n+            }), ty)\n+        }).collect()\n+    }\n }"}, {"sha": "f07464592faacbd887fc3785d97f635bfd07d9b6", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -67,7 +67,7 @@ use middle::traits::{self, ObligationCause};\n use middle::traits::{predicate_for_trait_def, report_selection_error};\n use middle::ty::adjustment::{AutoAdjustment, AutoDerefRef, AdjustDerefRef};\n use middle::ty::adjustment::{AutoPtr, AutoUnsafe, AdjustReifyFnPointer};\n-use middle::ty::adjustment::{AdjustUnsafeFnPointer};\n+use middle::ty::adjustment::{AdjustUnsafeFnPointer, AdjustMutToConstPointer};\n use middle::ty::{self, LvaluePreference, TypeAndMut, Ty};\n use middle::ty::fold::TypeFoldable;\n use middle::ty::error::TypeError;\n@@ -427,6 +427,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 autoref: Some(AutoUnsafe(mutbl_b)),\n                 unsize: None\n             })))\n+        } else if mt_a.mutbl != mutbl_b {\n+            Ok(Some(AdjustMutToConstPointer))\n         } else {\n             Ok(None)\n         }"}, {"sha": "7ab4975c8b8aed6ae2fb89d4e1228c0fa8fd0a68", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -3179,8 +3179,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             check_struct_fields_on_error(fcx, expr.id, fields, base_expr);\n             return;\n         }\n-        let (adt, variant) = match fcx.def_struct_variant(def, path.span) {\n-            Some((adt, variant)) => (adt, variant),\n+        let variant = match fcx.def_struct_variant(def, path.span) {\n+            Some((_, variant)) => variant,\n             None => {\n                 span_err!(fcx.tcx().sess, path.span, E0071,\n                           \"`{}` does not name a structure\",\n@@ -3195,12 +3195,23 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n         check_expr_struct_fields(fcx, expr_ty, expr.span, variant, fields,\n                                  base_expr.is_none());\n-\n         if let &Some(ref base_expr) = base_expr {\n             check_expr_has_type(fcx, base_expr, expr_ty);\n-            if adt.adt_kind() == ty::AdtKind::Enum {\n-                span_err!(tcx.sess, base_expr.span, E0436,\n-                          \"functional record update syntax requires a struct\");\n+            match expr_ty.sty {\n+                ty::TyStruct(adt, substs) => {\n+                    fcx.inh.tables.borrow_mut().fru_field_types.insert(\n+                        expr.id,\n+                        adt.struct_variant().fields.iter().map(|f| {\n+                            fcx.normalize_associated_types_in(\n+                                expr.span, &f.ty(tcx, substs)\n+                            )\n+                        }).collect()\n+                    );\n+                }\n+                _ => {\n+                    span_err!(tcx.sess, base_expr.span, E0436,\n+                              \"functional record update syntax requires a struct\");\n+                }\n             }\n         }\n     }"}, {"sha": "9b8b6dedb6345a1818b7f087e5edca423721dc08", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -43,6 +43,7 @@ pub fn resolve_type_vars_in_expr(fcx: &FnCtxt, e: &hir::Expr) {\n     wbcx.visit_upvar_borrow_map();\n     wbcx.visit_closures();\n     wbcx.visit_liberated_fn_sigs();\n+    wbcx.visit_fru_field_types();\n }\n \n pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n@@ -64,6 +65,7 @@ pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n     wbcx.visit_upvar_borrow_map();\n     wbcx.visit_closures();\n     wbcx.visit_liberated_fn_sigs();\n+    wbcx.visit_fru_field_types();\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -305,6 +307,10 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                         adjustment::AdjustReifyFnPointer\n                     }\n \n+                    adjustment::AdjustMutToConstPointer => {\n+                        adjustment::AdjustMutToConstPointer\n+                    }\n+\n                     adjustment::AdjustUnsafeFnPointer => {\n                         adjustment::AdjustUnsafeFnPointer\n                     }\n@@ -367,6 +373,13 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         }\n     }\n \n+    fn visit_fru_field_types(&self) {\n+        for (&node_id, ftys) in self.fcx.inh.tables.borrow().fru_field_types.iter() {\n+            let ftys = self.resolve(ftys, ResolvingFieldTypes(node_id));\n+            self.tcx().tables.borrow_mut().fru_field_types.insert(node_id, ftys);\n+        }\n+    }\n+\n     fn resolve<T:TypeFoldable<'tcx>>(&self, t: &T, reason: ResolveReason) -> T {\n         t.fold_with(&mut Resolver::new(self.fcx, reason))\n     }\n@@ -383,6 +396,7 @@ enum ResolveReason {\n     ResolvingUpvar(ty::UpvarId),\n     ResolvingClosure(DefId),\n     ResolvingFnSig(ast::NodeId),\n+    ResolvingFieldTypes(ast::NodeId)\n }\n \n impl ResolveReason {\n@@ -397,6 +411,9 @@ impl ResolveReason {\n             ResolvingFnSig(id) => {\n                 tcx.map.span(id)\n             }\n+            ResolvingFieldTypes(id) => {\n+                tcx.map.span(id)\n+            }\n             ResolvingClosure(did) => {\n                 if let Some(node_id) = tcx.map.as_local_node_id(did) {\n                     tcx.expr_span(node_id)\n@@ -474,14 +491,14 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n                               \"cannot determine a type for this closure\")\n                 }\n \n-                ResolvingFnSig(id) => {\n+                ResolvingFnSig(id) | ResolvingFieldTypes(id) => {\n                     // any failures here should also fail when\n                     // resolving the patterns, closure types, or\n                     // something else.\n                     let span = self.reason.span(self.tcx);\n                     self.tcx.sess.delay_span_bug(\n                         span,\n-                        &format!(\"cannot resolve some aspect of fn sig for {:?}\", id));\n+                        &format!(\"cannot resolve some aspect of data for {:?}\", id));\n                 }\n             }\n         }"}, {"sha": "16ef965e0dbd5421262e3ff8d7802349c6d3227a", "filename": "src/test/auxiliary/dummy_mir_pass.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Ftest%2Fauxiliary%2Fdummy_mir_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Ftest%2Fauxiliary%2Fdummy_mir_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fdummy_mir_pass.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -21,17 +21,14 @@ extern crate syntax;\n use rustc::mir::transform::MirPass;\n use rustc::mir::repr::{Mir, Literal};\n use rustc::mir::visit::MutVisitor;\n-use rustc::middle::ty;\n+use rustc::middle::infer::InferCtxt;\n use rustc::middle::const_eval::ConstVal;\n-use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass, LateLintPassObject, LintArray};\n use rustc_plugin::Registry;\n-use rustc_front::hir;\n-use syntax::attr;\n \n struct Pass;\n \n impl MirPass for Pass {\n-    fn run_on_mir<'tcx>(&mut self, mir: &mut Mir<'tcx>, tcx: &ty::ctxt<'tcx>) {\n+    fn run_on_mir<'a, 'tcx>(&mut self, mir: &mut Mir<'tcx>, _: &InferCtxt<'a, 'tcx>) {\n         Visitor.visit_mir(mir)\n     }\n }"}, {"sha": "c85ac458edd88ca0d79748d83446d422d62d8b29", "filename": "src/test/run-pass/mir_augmented_assignments.rs", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Ftest%2Frun-pass%2Fmir_augmented_assignments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Ftest%2Frun-pass%2Fmir_augmented_assignments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_augmented_assignments.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -0,0 +1,187 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(augmented_assignments)]\n+#![feature(op_assign_traits)]\n+#![feature(rustc_attrs)]\n+\n+use std::mem;\n+use std::ops::{\n+    AddAssign, BitAndAssign, BitOrAssign, BitXorAssign, DivAssign, MulAssign, RemAssign,\n+    ShlAssign, ShrAssign, SubAssign,\n+};\n+\n+#[derive(Debug, PartialEq)]\n+struct Int(i32);\n+\n+struct Slice([i32]);\n+\n+impl Slice {\n+    fn new(slice: &mut [i32]) -> &mut Slice {\n+        unsafe {\n+            mem::transmute(slice)\n+        }\n+    }\n+}\n+\n+fn main() {\n+    main_mir();\n+}\n+\n+#[rustc_mir]\n+fn main_mir() {\n+    let mut x = Int(1);\n+\n+    x += Int(2);\n+    assert_eq!(x, Int(0b11));\n+\n+    x &= Int(0b01);\n+    assert_eq!(x, Int(0b01));\n+\n+    x |= Int(0b10);\n+    assert_eq!(x, Int(0b11));\n+\n+    x ^= Int(0b01);\n+    assert_eq!(x, Int(0b10));\n+\n+    x /= Int(2);\n+    assert_eq!(x, Int(1));\n+\n+    x *= Int(3);\n+    assert_eq!(x, Int(3));\n+\n+    x %= Int(2);\n+    assert_eq!(x, Int(1));\n+\n+    // overloaded RHS\n+    x <<= 1u8;\n+    assert_eq!(x, Int(2));\n+\n+    x <<= 1u16;\n+    assert_eq!(x, Int(4));\n+\n+    x >>= 1u8;\n+    assert_eq!(x, Int(2));\n+\n+    x >>= 1u16;\n+    assert_eq!(x, Int(1));\n+\n+    x -= Int(1);\n+    assert_eq!(x, Int(0));\n+\n+    // indexed LHS\n+    // FIXME(mir-drop): use the vec![..] macro\n+    let mut v = Vec::new();\n+    v.push(Int(1));\n+    v.push(Int(2));\n+    v[0] += Int(2);\n+    assert_eq!(v[0], Int(3));\n+\n+    // unsized RHS\n+    let mut array = [0, 1, 2];\n+    *Slice::new(&mut array) += 1;\n+    assert_eq!(array[0], 1);\n+    assert_eq!(array[1], 2);\n+    assert_eq!(array[2], 3);\n+\n+}\n+\n+impl AddAssign for Int {\n+    #[rustc_mir]\n+    fn add_assign(&mut self, rhs: Int) {\n+        self.0 += rhs.0;\n+    }\n+}\n+\n+impl BitAndAssign for Int {\n+    #[rustc_mir]\n+    fn bitand_assign(&mut self, rhs: Int) {\n+        self.0 &= rhs.0;\n+    }\n+}\n+\n+impl BitOrAssign for Int {\n+    #[rustc_mir]\n+    fn bitor_assign(&mut self, rhs: Int) {\n+        self.0 |= rhs.0;\n+    }\n+}\n+\n+impl BitXorAssign for Int {\n+    #[rustc_mir]\n+    fn bitxor_assign(&mut self, rhs: Int) {\n+        self.0 ^= rhs.0;\n+    }\n+}\n+\n+impl DivAssign for Int {\n+    #[rustc_mir]\n+    fn div_assign(&mut self, rhs: Int) {\n+        self.0 /= rhs.0;\n+    }\n+}\n+\n+impl MulAssign for Int {\n+    #[rustc_mir]\n+    fn mul_assign(&mut self, rhs: Int) {\n+        self.0 *= rhs.0;\n+    }\n+}\n+\n+impl RemAssign for Int {\n+    #[rustc_mir]\n+    fn rem_assign(&mut self, rhs: Int) {\n+        self.0 %= rhs.0;\n+    }\n+}\n+\n+impl ShlAssign<u8> for Int {\n+    #[rustc_mir]\n+    fn shl_assign(&mut self, rhs: u8) {\n+        self.0 <<= rhs;\n+    }\n+}\n+\n+impl ShlAssign<u16> for Int {\n+    #[rustc_mir]\n+    fn shl_assign(&mut self, rhs: u16) {\n+        self.0 <<= rhs;\n+    }\n+}\n+\n+impl ShrAssign<u8> for Int {\n+    #[rustc_mir]\n+    fn shr_assign(&mut self, rhs: u8) {\n+        self.0 >>= rhs;\n+    }\n+}\n+\n+impl ShrAssign<u16> for Int {\n+    #[rustc_mir]\n+    fn shr_assign(&mut self, rhs: u16) {\n+        self.0 >>= rhs;\n+    }\n+}\n+\n+impl SubAssign for Int {\n+    #[rustc_mir]\n+    fn sub_assign(&mut self, rhs: Int) {\n+        self.0 -= rhs.0;\n+    }\n+}\n+\n+impl AddAssign<i32> for Slice {\n+    #[rustc_mir]\n+    fn add_assign(&mut self, rhs: i32) {\n+        for lhs in &mut self.0 {\n+            *lhs += rhs;\n+        }\n+    }\n+}"}, {"sha": "81712e4569f06b288985fdb0a6590929e21eb8e7", "filename": "src/test/run-pass/mir_autoderef.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Ftest%2Frun-pass%2Fmir_autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Ftest%2Frun-pass%2Fmir_autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_autoderef.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+use std::ops::{Deref, DerefMut};\n+\n+pub struct MyRef(u32);\n+\n+impl Deref for MyRef {\n+    type Target = u32;\n+    fn deref(&self) -> &u32 { &self.0 }\n+}\n+\n+impl DerefMut for MyRef {\n+    fn deref_mut(&mut self) -> &mut u32 { &mut self.0 }\n+}\n+\n+\n+#[rustc_mir]\n+fn deref(x: &MyRef) -> &u32 {\n+    x\n+}\n+\n+#[rustc_mir]\n+fn deref_mut(x: &mut MyRef) -> &mut u32 {\n+    x\n+}\n+\n+fn main() {\n+    let mut r = MyRef(2);\n+    assert_eq!(deref(&r) as *const _, &r.0 as *const _);\n+    assert_eq!(deref_mut(&mut r) as *mut _, &mut r.0 as *mut _);\n+}"}, {"sha": "1f75369b94a8617ecd54c1f5a080049217038760", "filename": "src/test/run-pass/mir_struct_with_assoc_ty.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Ftest%2Frun-pass%2Fmir_struct_with_assoc_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Ftest%2Frun-pass%2Fmir_struct_with_assoc_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_struct_with_assoc_ty.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+use std::marker::PhantomData;\n+\n+pub trait DataBind {\n+    type Data;\n+}\n+\n+impl<T> DataBind for Global<T> {\n+    type Data = T;\n+}\n+\n+pub struct Global<T>(PhantomData<T>);\n+\n+pub struct Data {\n+    pub offsets: <Global<[u32; 2]> as DataBind>::Data,\n+}\n+\n+#[rustc_mir]\n+fn create_data() -> Data {\n+    let mut d = Data { offsets: [1, 2] };\n+    d.offsets[0] = 3;\n+    d\n+}\n+\n+\n+fn main() {\n+    let d = create_data();\n+    assert_eq!(d.offsets[0], 3);\n+    assert_eq!(d.offsets[1], 2);\n+}"}, {"sha": "b8b7ecbf03cd6e834817eee2bd01d4366ebf1dd4", "filename": "src/test/run-pass/mir_trans_calls.rs", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Ftest%2Frun-pass%2Fmir_trans_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c751e045642376eafe7ec8a2cae6d92995a46b6/src%2Ftest%2Frun-pass%2Fmir_trans_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_trans_calls.rs?ref=6c751e045642376eafe7ec8a2cae6d92995a46b6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n+#![feature(rustc_attrs, unboxed_closures, fn_traits)]\n \n #[rustc_mir]\n fn test1(a: isize, b: (i32, i32), c: &[i32]) -> (isize, (i32, i32), &[i32]) {\n@@ -117,6 +117,27 @@ fn test_fn_impl(f: &&Fn(i32, i32) -> i32, x: i32, y: i32) -> i32 {\n     f(x, y)\n }\n \n+#[rustc_mir]\n+fn test_fn_direct_call<F>(f: &F, x: i32, y: i32) -> i32\n+    where F: Fn(i32, i32) -> i32\n+{\n+    f.call((x, y))\n+}\n+\n+#[rustc_mir]\n+fn test_fn_const_call<F>(f: &F) -> i32\n+    where F: Fn(i32, i32) -> i32\n+{\n+    f.call((100, -1))\n+}\n+\n+#[rustc_mir]\n+fn test_fn_nil_call<F>(f: &F) -> i32\n+    where F: Fn() -> i32\n+{\n+    f()\n+}\n+\n fn main() {\n     assert_eq!(test1(1, (2, 3), &[4, 5, 6]), (1, (2, 3), &[4, 5, 6][..]));\n     assert_eq!(test2(98), 98);\n@@ -128,9 +149,14 @@ fn main() {\n     assert_eq!(test8(), 2);\n     assert_eq!(test9(), 41 + 42 * 43);\n \n-    let closure = |x: i32, y: i32| { x + y };\n-    assert_eq!(test_closure(&closure, 100, 1), 101);\n+    let r = 3;\n+    let closure = |x: i32, y: i32| { r*(x + (y*2)) };\n+    assert_eq!(test_fn_const_call(&closure), 294);\n+    assert_eq!(test_closure(&closure, 100, 1), 306);\n     let function_object = &closure as &Fn(i32, i32) -> i32;\n-    assert_eq!(test_fn_object(function_object, 100, 2), 102);\n-    assert_eq!(test_fn_impl(&function_object, 100, 3), 103);\n+    assert_eq!(test_fn_object(function_object, 100, 2), 312);\n+    assert_eq!(test_fn_impl(&function_object, 100, 3), 318);\n+    assert_eq!(test_fn_direct_call(&closure, 100, 4), 324);\n+\n+    assert_eq!(test_fn_nil_call(&(|| 42)), 42);\n }"}]}