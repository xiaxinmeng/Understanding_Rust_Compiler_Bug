{"sha": "041254b81495a5aa67af839e00b890e78ed0cbeb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0MTI1NGI4MTQ5NWE1YWE2N2FmODM5ZTAwYjg5MGU3OGVkMGNiZWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-18T06:50:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-18T06:50:11Z"}, "message": "Auto merge of #56481 - arielb1:dynamic-order, r=nikomatsakis\n\nadd coherence future-compat warnings for marker-only trait objects\n\nThe future-compat warnings break code that assumes that `dyn Send + Sync !=\ndyn Sync + Send`, and are the first step in making them equal. cc #33140.\n\nNote: this lint should be made to default-warn before we merge. It is deny only for the crater run.\n\nr? @nikomatsakis / @scalexm . cc @Centril & @alexreg.", "tree": {"sha": "b4bedfb4d0bd8d2005d876f5b5e114c4113de7e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4bedfb4d0bd8d2005d876f5b5e114c4113de7e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/041254b81495a5aa67af839e00b890e78ed0cbeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/041254b81495a5aa67af839e00b890e78ed0cbeb", "html_url": "https://github.com/rust-lang/rust/commit/041254b81495a5aa67af839e00b890e78ed0cbeb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/041254b81495a5aa67af839e00b890e78ed0cbeb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9bb68f5ae5cc297246a084a2cd589787d1ee315", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9bb68f5ae5cc297246a084a2cd589787d1ee315", "html_url": "https://github.com/rust-lang/rust/commit/c9bb68f5ae5cc297246a084a2cd589787d1ee315"}, {"sha": "f934cfc40c253415ab6d4a9ac232fc99a21764db", "url": "https://api.github.com/repos/rust-lang/rust/commits/f934cfc40c253415ab6d4a9ac232fc99a21764db", "html_url": "https://github.com/rust-lang/rust/commit/f934cfc40c253415ab6d4a9ac232fc99a21764db"}], "stats": {"total": 517, "additions": 458, "deletions": 59}, "files": [{"sha": "833da67d3f1750a89e1d73613a52b488d0bfc1dd", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=041254b81495a5aa67af839e00b890e78ed0cbeb", "patch": "@@ -347,6 +347,10 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n         self.infcx.tcx\n     }\n \n+    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n+        self.infcx.trait_object_mode()\n+    }\n+\n     fn tag(&self) -> &'static str {\n         \"Generalizer\"\n     }"}, {"sha": "caa120fa267023b9c6f64f61b372dfec88a6c9b1", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=041254b81495a5aa67af839e00b890e78ed0cbeb", "patch": "@@ -39,6 +39,10 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n \n     fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.tcx() }\n \n+    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n+        self.fields.infcx.trait_object_mode()\n+    }\n+\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n \n     fn relate_item_substs(&mut self,"}, {"sha": "ba21ebb49eb95a99db0d40b17e0301c5722c2c49", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=041254b81495a5aa67af839e00b890e78ed0cbeb", "patch": "@@ -15,7 +15,7 @@ use super::Subtype;\n \n use traits::ObligationCause;\n use ty::{self, Ty, TyCtxt};\n-use ty::relate::{Relate, RelateResult, TypeRelation};\n+use ty::relate::{self, Relate, RelateResult, TypeRelation};\n \n /// \"Greatest lower bound\" (common subtype)\n pub struct Glb<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n@@ -36,6 +36,10 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n {\n     fn tag(&self) -> &'static str { \"Glb\" }\n \n+    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n+        self.fields.infcx.trait_object_mode()\n+    }\n+\n     fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.a_is_expected }"}, {"sha": "80fad447b46e30e75dd506ad3499d84cc3d3bb2b", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=041254b81495a5aa67af839e00b890e78ed0cbeb", "patch": "@@ -15,7 +15,7 @@ use super::Subtype;\n \n use traits::ObligationCause;\n use ty::{self, Ty, TyCtxt};\n-use ty::relate::{Relate, RelateResult, TypeRelation};\n+use ty::relate::{self, Relate, RelateResult, TypeRelation};\n \n /// \"Least upper bound\" (common supertype)\n pub struct Lub<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n@@ -36,6 +36,10 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n {\n     fn tag(&self) -> &'static str { \"Lub\" }\n \n+    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n+        self.fields.infcx.trait_object_mode()\n+    }\n+\n     fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.a_is_expected }"}, {"sha": "c961fd5fbd4b1b608797fd555ac40ce188f76738", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=041254b81495a5aa67af839e00b890e78ed0cbeb", "patch": "@@ -35,7 +35,7 @@ use syntax_pos::{self, Span};\n use traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use ty::fold::TypeFoldable;\n-use ty::relate::RelateResult;\n+use ty::relate::{RelateResult, TraitObjectMode};\n use ty::subst::{Kind, Substs};\n use ty::{self, GenericParamDefKind, Ty, TyCtxt};\n use ty::{FloatVid, IntVid, TyVid};\n@@ -182,6 +182,9 @@ pub struct InferCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     // This flag is true while there is an active snapshot.\n     in_snapshot: Cell<bool>,\n \n+    // The TraitObjectMode used here,\n+    trait_object_mode: TraitObjectMode,\n+\n     // A set of constraints that regionck must validate. Each\n     // constraint has the form `T:'a`, meaning \"some type `T` must\n     // outlive the lifetime 'a\". These constraints derive from\n@@ -472,6 +475,7 @@ pub struct InferCtxtBuilder<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     global_tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     arena: SyncDroplessArena,\n     fresh_tables: Option<RefCell<ty::TypeckTables<'tcx>>>,\n+    trait_object_mode: TraitObjectMode,\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n@@ -480,6 +484,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n             global_tcx: self,\n             arena: SyncDroplessArena::default(),\n             fresh_tables: None,\n+            trait_object_mode: TraitObjectMode::NoSquash,\n         }\n     }\n }\n@@ -492,6 +497,12 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n         self\n     }\n \n+    pub fn with_trait_object_mode(mut self, mode: TraitObjectMode) -> Self {\n+        debug!(\"with_trait_object_mode: setting mode to {:?}\", mode);\n+        self.trait_object_mode = mode;\n+        self\n+    }\n+\n     /// Given a canonical value `C` as a starting point, create an\n     /// inference context that contains each of the bound values\n     /// within instantiated as a fresh variable. The `f` closure is\n@@ -518,6 +529,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n     pub fn enter<R>(&'tcx mut self, f: impl for<'b> FnOnce(InferCtxt<'b, 'gcx, 'tcx>) -> R) -> R {\n         let InferCtxtBuilder {\n             global_tcx,\n+            trait_object_mode,\n             ref arena,\n             ref fresh_tables,\n         } = *self;\n@@ -526,6 +538,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             f(InferCtxt {\n                 tcx,\n                 in_progress_tables,\n+                trait_object_mode,\n                 projection_cache: Default::default(),\n                 type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n                 int_unification_table: RefCell::new(ut::UnificationTable::new()),\n@@ -607,6 +620,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.in_snapshot.get()\n     }\n \n+    pub fn trait_object_mode(&self) -> TraitObjectMode {\n+        self.trait_object_mode\n+    }\n+\n     pub fn freshen<T: TypeFoldable<'tcx>>(&self, t: T) -> T {\n         t.fold_with(&mut self.freshener())\n     }"}, {"sha": "0ce0eb9a1abae169804d5c249a8e91888e3bd40e", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=041254b81495a5aa67af839e00b890e78ed0cbeb", "patch": "@@ -382,6 +382,13 @@ where\n         self.infcx.tcx\n     }\n \n+    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n+        // squashing should only be done in coherence, not NLL\n+        assert_eq!(self.infcx.trait_object_mode(),\n+                   relate::TraitObjectMode::NoSquash);\n+        relate::TraitObjectMode::NoSquash\n+    }\n+\n     fn tag(&self) -> &'static str {\n         \"nll::subtype\"\n     }\n@@ -696,6 +703,13 @@ where\n         self.infcx.tcx\n     }\n \n+    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n+        // squashing should only be done in coherence, not NLL\n+        assert_eq!(self.infcx.trait_object_mode(),\n+                   relate::TraitObjectMode::NoSquash);\n+        relate::TraitObjectMode::NoSquash\n+    }\n+\n     fn tag(&self) -> &'static str {\n         \"nll::generalizer\"\n     }"}, {"sha": "ef2ef3f8a86014ca847f2a6f9f403d7dfc8b8890", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=041254b81495a5aa67af839e00b890e78ed0cbeb", "patch": "@@ -15,7 +15,7 @@ use traits::Obligation;\n use ty::{self, Ty, TyCtxt};\n use ty::TyVar;\n use ty::fold::TypeFoldable;\n-use ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n+use ty::relate::{self, Cause, Relate, RelateResult, TypeRelation};\n use std::mem;\n \n /// Ensures `a` is made a subtype of `b`. Returns `a` on success.\n@@ -43,6 +43,10 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n     for Sub<'combine, 'infcx, 'gcx, 'tcx>\n {\n     fn tag(&self) -> &'static str { \"Sub\" }\n+    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n+        self.fields.infcx.trait_object_mode()\n+    }\n+\n     fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.infcx.tcx }\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n "}, {"sha": "cf437109e6767ab4ebd06440a6a0df53b04f6f67", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=041254b81495a5aa67af839e00b890e78ed0cbeb", "patch": "@@ -208,6 +208,12 @@ declare_lint! {\n     \"potentially-conflicting impls were erroneously allowed\"\n }\n \n+declare_lint! {\n+    pub ORDER_DEPENDENT_TRAIT_OBJECTS,\n+    Deny,\n+    \"trait-object types were treated as different depending on marker-trait order\"\n+}\n+\n declare_lint! {\n     pub BAD_REPR,\n     Warn,\n@@ -412,6 +418,7 @@ impl LintPass for HardwiredLints {\n             PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n             LATE_BOUND_LIFETIME_ARGUMENTS,\n             INCOHERENT_FUNDAMENTAL_IMPLS,\n+            ORDER_DEPENDENT_TRAIT_OBJECTS,\n             DEPRECATED,\n             UNUSED_UNSAFE,\n             UNUSED_MUT,"}, {"sha": "af338cd3868fad5ada046912163c41c47d697c3d", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=041254b81495a5aa67af839e00b890e78ed0cbeb", "patch": "@@ -20,6 +20,7 @@ use traits::{self, Normalized, SelectionContext, Obligation, ObligationCause};\n use traits::IntercrateMode;\n use traits::select::IntercrateAmbiguityCause;\n use ty::{self, Ty, TyCtxt};\n+use ty::relate::TraitObjectMode;\n use ty::fold::TypeFoldable;\n use ty::subst::Subst;\n \n@@ -52,6 +53,7 @@ pub fn overlapping_impls<'gcx, F1, F2, R>(\n     impl1_def_id: DefId,\n     impl2_def_id: DefId,\n     intercrate_mode: IntercrateMode,\n+    trait_object_mode: TraitObjectMode,\n     on_overlap: F1,\n     no_overlap: F2,\n ) -> R\n@@ -62,12 +64,14 @@ where\n     debug!(\"overlapping_impls(\\\n            impl1_def_id={:?}, \\\n            impl2_def_id={:?},\n-           intercrate_mode={:?})\",\n+           intercrate_mode={:?},\n+           trait_object_mode={:?})\",\n            impl1_def_id,\n            impl2_def_id,\n-           intercrate_mode);\n+           intercrate_mode,\n+           trait_object_mode);\n \n-    let overlaps = tcx.infer_ctxt().enter(|infcx| {\n+    let overlaps = tcx.infer_ctxt().with_trait_object_mode(trait_object_mode).enter(|infcx| {\n         let selcx = &mut SelectionContext::intercrate(&infcx, intercrate_mode);\n         overlap(selcx, impl1_def_id, impl2_def_id).is_some()\n     });\n@@ -79,7 +83,7 @@ where\n     // In the case where we detect an error, run the check again, but\n     // this time tracking intercrate ambuiguity causes for better\n     // diagnostics. (These take time and can lead to false errors.)\n-    tcx.infer_ctxt().enter(|infcx| {\n+    tcx.infer_ctxt().with_trait_object_mode(trait_object_mode).enter(|infcx| {\n         let selcx = &mut SelectionContext::intercrate(&infcx, intercrate_mode);\n         selcx.enable_tracking_intercrate_ambiguity_causes();\n         on_overlap(overlap(selcx, impl1_def_id, impl2_def_id).unwrap())"}, {"sha": "373d6652b9e6abc7935770252e15497669714acb", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=041254b81495a5aa67af839e00b890e78ed0cbeb", "patch": "@@ -459,7 +459,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     {\n         let simp = fast_reject::simplify_type(self.tcx,\n                                               trait_ref.skip_binder().self_ty(),\n-                                              true);\n+                                              true,);\n         let all_impls = self.tcx.all_impls(trait_ref.def_id());\n \n         match simp {"}, {"sha": "cf37c3fceba8f2b8a3bb8fb50ef95dcb5591afcc", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=041254b81495a5aa67af839e00b890e78ed0cbeb", "patch": "@@ -64,6 +64,8 @@ pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};\n pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError};\n pub use self::specialize::{OverlapError, specialization_graph, translate_substs};\n pub use self::specialize::find_associated_item;\n+pub use self::specialize::specialization_graph::FutureCompatOverlapError;\n+pub use self::specialize::specialization_graph::FutureCompatOverlapErrorKind;\n pub use self::engine::{TraitEngine, TraitEngineExt};\n pub use self::util::{elaborate_predicates, elaborate_trait_ref, elaborate_trait_refs};\n pub use self::util::{supertraits, supertrait_def_ids, transitive_bounds,"}, {"sha": "d46389b0ee226139a50b61ce82383e3bc2e5dc78", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=041254b81495a5aa67af839e00b890e78ed0cbeb", "patch": "@@ -44,7 +44,7 @@ use infer::{InferCtxt, InferOk, TypeFreshener};\n use middle::lang_items;\n use mir::interpret::GlobalId;\n use ty::fast_reject;\n-use ty::relate::TypeRelation;\n+use ty::relate::{TypeRelation, TraitObjectMode};\n use ty::subst::{Subst, Substs};\n use ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable};\n \n@@ -1501,6 +1501,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return false;\n         }\n \n+        // Same idea as the above, but for alt trait object modes. These\n+        // should only be used in intercrate mode - better safe than sorry.\n+        if self.infcx.trait_object_mode() != TraitObjectMode::NoSquash {\n+            bug!(\"using squashing TraitObjectMode outside of intercrate mode? param_env={:?}\",\n+                 param_env);\n+        }\n+\n         // Otherwise, we can use the global cache.\n         true\n     }\n@@ -3699,7 +3706,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         previous: &ty::PolyTraitRef<'tcx>,\n         current: &ty::PolyTraitRef<'tcx>,\n     ) -> bool {\n-        let mut matcher = ty::_match::Match::new(self.tcx());\n+        let mut matcher = ty::_match::Match::new(\n+            self.tcx(), self.infcx.trait_object_mode());\n         matcher.relate(previous, current).is_ok()\n     }\n "}, {"sha": "70d36e9afe192d76e93afbfd04a20e1755f72cba", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=041254b81495a5aa67af839e00b890e78ed0cbeb", "patch": "@@ -24,10 +24,10 @@ pub mod specialization_graph;\n use hir::def_id::DefId;\n use infer::{InferCtxt, InferOk};\n use lint;\n+use traits::{self, FutureCompatOverlapErrorKind, ObligationCause, TraitEngine};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use syntax_pos::DUMMY_SP;\n-use traits::{self, ObligationCause, TraitEngine};\n use traits::select::IntercrateAmbiguityCause;\n use ty::{self, TyCtxt, TypeFoldable};\n use ty::subst::{Subst, Substs};\n@@ -36,6 +36,7 @@ use super::{SelectionContext, FulfillmentContext};\n use super::util::impl_trait_ref_and_oblig;\n \n /// Information pertinent to an overlapping impl error.\n+#[derive(Debug)]\n pub struct OverlapError {\n     pub with_impl: DefId,\n     pub trait_desc: String,\n@@ -318,8 +319,9 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(\n             let insert_result = sg.insert(tcx, impl_def_id);\n             // Report error if there was one.\n             let (overlap, used_to_be_allowed) = match insert_result {\n-                Err(overlap) => (Some(overlap), false),\n-                Ok(opt_overlap) => (opt_overlap, true)\n+                Err(overlap) => (Some(overlap), None),\n+                Ok(Some(overlap)) => (Some(overlap.error), Some(overlap.kind)),\n+                Ok(None) => (None, None)\n             };\n \n             if let Some(overlap) = overlap {\n@@ -329,14 +331,20 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(\n                         String::new(), |ty| {\n                             format!(\" for type `{}`\", ty)\n                         }),\n-                    if used_to_be_allowed { \" (E0119)\" } else { \"\" }\n+                    if used_to_be_allowed.is_some() { \" (E0119)\" } else { \"\" }\n                 );\n                 let impl_span = tcx.sess.source_map().def_span(\n                     tcx.span_of_impl(impl_def_id).unwrap()\n                 );\n-                let mut err = if used_to_be_allowed {\n+                let mut err = if let Some(kind) = used_to_be_allowed {\n+                    let lint = match kind {\n+                        FutureCompatOverlapErrorKind::Issue43355 =>\n+                            lint::builtin::INCOHERENT_FUNDAMENTAL_IMPLS,\n+                        FutureCompatOverlapErrorKind::Issue33140 =>\n+                            lint::builtin::ORDER_DEPENDENT_TRAIT_OBJECTS,\n+                    };\n                     tcx.struct_span_lint_node(\n-                        lint::builtin::INCOHERENT_FUNDAMENTAL_IMPLS,\n+                        lint,\n                         tcx.hir().as_local_node_id(impl_def_id).unwrap(),\n                         impl_span,\n                         &msg)"}, {"sha": "1a228660306418a5aaf10f9d65c5b4d27e576d7d", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=041254b81495a5aa67af839e00b890e78ed0cbeb", "patch": "@@ -17,6 +17,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n use traits;\n use ty::{self, TyCtxt, TypeFoldable};\n use ty::fast_reject::{self, SimplifiedType};\n+use ty::relate::TraitObjectMode;\n use rustc_data_structures::sync::Lrc;\n use syntax::ast::Ident;\n use util::captures::Captures;\n@@ -68,10 +69,22 @@ struct Children {\n     blanket_impls: Vec<DefId>,\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub enum FutureCompatOverlapErrorKind {\n+    Issue43355,\n+    Issue33140,\n+}\n+\n+#[derive(Debug)]\n+pub struct FutureCompatOverlapError {\n+    pub error: OverlapError,\n+    pub kind: FutureCompatOverlapErrorKind\n+}\n+\n /// The result of attempting to insert an impl into a group of children.\n enum Inserted {\n     /// The impl was inserted as a new child in this group of children.\n-    BecameNewSibling(Option<OverlapError>),\n+    BecameNewSibling(Option<FutureCompatOverlapError>),\n \n     /// The impl should replace existing impls [X1, ..], because the impl specializes X1, X2, etc.\n     ReplaceChildren(Vec<DefId>),\n@@ -170,6 +183,7 @@ impl<'a, 'gcx, 'tcx> Children {\n                 possible_sibling,\n                 impl_def_id,\n                 traits::IntercrateMode::Issue43355,\n+                TraitObjectMode::NoSquash,\n                 |overlap| {\n                     if tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling) {\n                         return Ok((false, false));\n@@ -200,12 +214,36 @@ impl<'a, 'gcx, 'tcx> Children {\n                 replace_children.push(possible_sibling);\n             } else {\n                 if !tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling) {\n+                    // do future-compat checks for overlap. Have issue #43355\n+                    // errors overwrite issue #33140 errors when both are present.\n+\n+                    traits::overlapping_impls(\n+                        tcx,\n+                        possible_sibling,\n+                        impl_def_id,\n+                        traits::IntercrateMode::Fixed,\n+                        TraitObjectMode::SquashAutoTraitsIssue33140,\n+                        |overlap| {\n+                            last_lint = Some(FutureCompatOverlapError {\n+                                error: overlap_error(overlap),\n+                                kind: FutureCompatOverlapErrorKind::Issue33140\n+                            });\n+                        },\n+                        || (),\n+                    );\n+\n                     traits::overlapping_impls(\n                         tcx,\n                         possible_sibling,\n                         impl_def_id,\n                         traits::IntercrateMode::Fixed,\n-                        |overlap| last_lint = Some(overlap_error(overlap)),\n+                        TraitObjectMode::NoSquash,\n+                        |overlap| {\n+                            last_lint = Some(FutureCompatOverlapError {\n+                                error: overlap_error(overlap),\n+                                kind: FutureCompatOverlapErrorKind::Issue43355\n+                            });\n+                        },\n                         || (),\n                     );\n                 }\n@@ -272,7 +310,7 @@ impl<'a, 'gcx, 'tcx> Graph {\n     pub fn insert(&mut self,\n                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                   impl_def_id: DefId)\n-                  -> Result<Option<OverlapError>, OverlapError> {\n+                  -> Result<Option<FutureCompatOverlapError>, OverlapError> {\n         assert!(impl_def_id.is_local());\n \n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();"}, {"sha": "29067bf518da02201de197b28921af2fbaf4a4eb", "filename": "src/librustc/ty/_match.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2F_match.rs?ref=041254b81495a5aa67af839e00b890e78ed0cbeb", "patch": "@@ -29,17 +29,24 @@ use ty::relate::{self, Relate, TypeRelation, RelateResult};\n /// important thing about the result is Ok/Err. Also, matching never\n /// affects any type variables or unification state.\n pub struct Match<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    trait_object_mode: relate::TraitObjectMode\n }\n \n impl<'a, 'gcx, 'tcx> Match<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Match<'a, 'gcx, 'tcx> {\n-        Match { tcx }\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+               trait_object_mode: relate::TraitObjectMode)\n+               -> Match<'a, 'gcx, 'tcx> {\n+        Match { tcx, trait_object_mode }\n     }\n }\n \n impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Match<'a, 'gcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Match\" }\n+    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n+        self.trait_object_mode\n+    }\n+\n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.tcx }\n     fn a_is_expected(&self) -> bool { true } // irrelevant\n "}, {"sha": "bd01dd8cb0ce64ecd3628dcdeab6dcd72ffe1cdd", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=041254b81495a5aa67af839e00b890e78ed0cbeb", "patch": "@@ -43,6 +43,9 @@ pub enum SimplifiedTypeGen<D>\n     PtrSimplifiedType,\n     NeverSimplifiedType,\n     TupleSimplifiedType(usize),\n+    /// A trait object, all of whose components are markers\n+    /// (e.g., `dyn Send + Sync`).\n+    MarkerTraitObjectSimplifiedType,\n     TraitSimplifiedType(D),\n     ClosureSimplifiedType(D),\n     GeneratorSimplifiedType(D),\n@@ -78,7 +81,12 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::Array(..) | ty::Slice(_) => Some(ArraySimplifiedType),\n         ty::RawPtr(_) => Some(PtrSimplifiedType),\n         ty::Dynamic(ref trait_info, ..) => {\n-            Some(TraitSimplifiedType(trait_info.principal().def_id()))\n+            let principal_def_id = trait_info.principal().def_id();\n+            if tcx.trait_is_auto(principal_def_id) {\n+                Some(MarkerTraitObjectSimplifiedType)\n+            } else {\n+                Some(TraitSimplifiedType(principal_def_id))\n+            }\n         }\n         ty::Ref(_, ty, _) => {\n             // since we introduce auto-refs during method lookup, we\n@@ -144,6 +152,7 @@ impl<D: Copy + Debug + Ord + Eq + Hash> SimplifiedTypeGen<D> {\n             NeverSimplifiedType => NeverSimplifiedType,\n             TupleSimplifiedType(n) => TupleSimplifiedType(n),\n             TraitSimplifiedType(d) => TraitSimplifiedType(map(d)),\n+            MarkerTraitObjectSimplifiedType => MarkerTraitObjectSimplifiedType,\n             ClosureSimplifiedType(d) => ClosureSimplifiedType(map(d)),\n             GeneratorSimplifiedType(d) => GeneratorSimplifiedType(map(d)),\n             GeneratorWitnessSimplifiedType(n) => GeneratorWitnessSimplifiedType(n),\n@@ -170,7 +179,8 @@ impl<'a, 'gcx, D> HashStable<StableHashingContext<'a>> for SimplifiedTypeGen<D>\n             ArraySimplifiedType |\n             PtrSimplifiedType |\n             NeverSimplifiedType |\n-            ParameterSimplifiedType => {\n+            ParameterSimplifiedType |\n+            MarkerTraitObjectSimplifiedType => {\n                 // nothing to do\n             }\n             IntSimplifiedType(t) => t.hash_stable(hcx, hasher),"}, {"sha": "88c3e5c8715668fd5423de2ae386418ffcc471b3", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=041254b81495a5aa67af839e00b890e78ed0cbeb", "patch": "@@ -35,9 +35,20 @@ pub enum Cause {\n     ExistentialRegionBound, // relating an existential region bound\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum TraitObjectMode {\n+    NoSquash,\n+    /// A temporary mode to treat `Send + Sync = Sync + Send`, should be\n+    /// used only in coherence.\n+    SquashAutoTraitsIssue33140\n+}\n+\n pub trait TypeRelation<'a, 'gcx: 'a+'tcx, 'tcx: 'a> : Sized {\n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx>;\n \n+    /// Return the trait object mode to be used.\n+    fn trait_object_mode(&self) -> TraitObjectMode;\n+\n     /// Returns a static string we can use for printouts.\n     fn tag(&self) -> &'static str;\n \n@@ -596,14 +607,44 @@ impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n                            a: &Self,\n                            b: &Self)\n         -> RelateResult<'tcx, Self>\n-            where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a {\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a {\n+        use ty::ExistentialPredicate::*;\n \n-        if a.len() != b.len() {\n+        let tcx = relation.tcx();\n+        let (a_buf, b_buf);\n+        let (a_norm, b_norm): (&[_], &[_]) = match relation.trait_object_mode() {\n+            TraitObjectMode::NoSquash => {\n+                (a, b)\n+            }\n+            TraitObjectMode::SquashAutoTraitsIssue33140 => {\n+                // Treat auto-trait \"principal\" components as equal\n+                // to the non-principal components, to make\n+                // `dyn Send+Sync = dyn Sync+Send`.\n+                let normalize = |d: &[ty::ExistentialPredicate<'tcx>]| {\n+                    let mut result: Vec<_> = d.iter().map(|pi| match pi {\n+                        Trait(ref a) if tcx.trait_is_auto(a.def_id) => {\n+                            AutoTrait(a.def_id)\n+                        },\n+                        other => *other\n+                    }).collect();\n+\n+                    result.sort_by(|a, b| a.stable_cmp(tcx, b));\n+                    result.dedup();\n+                    result\n+                };\n+\n+                a_buf = normalize(a);\n+                b_buf = normalize(b);\n+\n+                (&a_buf, &b_buf)\n+            }\n+        };\n+\n+        if a_norm.len() != b_norm.len() {\n             return Err(TypeError::ExistentialMismatch(expected_found(relation, a, b)));\n         }\n \n-        let tcx = relation.tcx();\n-        let v = a.iter().zip(b.iter()).map(|(ep_a, ep_b)| {\n+        let v = a_norm.iter().zip(b_norm.iter()).map(|(ep_a, ep_b)| {\n             use ty::ExistentialPredicate::*;\n             match (*ep_a, *ep_b) {\n                 (Trait(ref a), Trait(ref b)) => Ok(Trait(relation.relate(a, b)?)),"}, {"sha": "347121833d3f14f889de3389f03b71a162e31edf", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=041254b81495a5aa67af839e00b890e78ed0cbeb", "patch": "@@ -293,6 +293,11 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             reference: \"issue #46205 <https://github.com/rust-lang/rust/issues/46205>\",\n             edition: None,\n         },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(ORDER_DEPENDENT_TRAIT_OBJECTS),\n+            reference: \"issue #56484 <https://github.com/rust-lang/rust/issues/56484>\",\n+            edition: None,\n+        },\n         FutureIncompatibleInfo {\n             id: LintId::of(TYVAR_BEHIND_RAW_POINTER),\n             reference: \"issue #46906 <https://github.com/rust-lang/rust/issues/46906>\","}, {"sha": "73aa8a107247ddb128d2a9cb5818aadb96c92dfa", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=041254b81495a5aa67af839e00b890e78ed0cbeb", "patch": "@@ -17,7 +17,7 @@ use rustc::traits::{\n };\n use rustc::ty::{self, Ty};\n use rustc::ty::subst::Kind;\n-use rustc::ty::relate::{Relate, RelateResult, TypeRelation};\n+use rustc::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use syntax_pos::DUMMY_SP;\n \n use super::{ChalkInferenceContext, ChalkArenas, ChalkExClause, ConstrainedSubst};\n@@ -137,6 +137,10 @@ impl TypeRelation<'cx, 'gcx, 'tcx> for AnswerSubstitutor<'cx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n+    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n+        self.infcx.trait_object_mode()\n+    }\n+\n     fn tag(&self) -> &'static str {\n         \"chalk_context::answer_substitutor\"\n     }"}, {"sha": "c273c8f64567756a3e84c6410bde3752f95c653a", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 76, "deletions": 29, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=041254b81495a5aa67af839e00b890e78ed0cbeb", "patch": "@@ -12,8 +12,9 @@ use namespace::Namespace;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::traits::{self, IntercrateMode};\n+use rustc::traits::{self, IntercrateMode, FutureCompatOverlapErrorKind};\n use rustc::ty::TyCtxt;\n+use rustc::ty::relate::TraitObjectMode;\n \n use lint;\n \n@@ -29,9 +30,11 @@ struct InherentOverlapChecker<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n-    fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId,\n-                                       overlap: traits::OverlapResult,\n-                                       used_to_be_allowed: bool) {\n+    fn check_for_common_items_in_impls(\n+        &self, impl1: DefId, impl2: DefId,\n+        overlap: traits::OverlapResult,\n+        used_to_be_allowed: Option<FutureCompatOverlapErrorKind>)\n+    {\n \n         let name_and_namespace = |def_id| {\n             let item = self.tcx.associated_item(def_id);\n@@ -47,19 +50,28 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n             for &item2 in &impl_items2[..] {\n                 if (name, namespace) == name_and_namespace(item2) {\n                     let node_id = self.tcx.hir().as_local_node_id(impl1);\n-                    let mut err = if used_to_be_allowed && node_id.is_some() {\n-                        self.tcx.struct_span_lint_node(\n-                            lint::builtin::INCOHERENT_FUNDAMENTAL_IMPLS,\n-                            node_id.unwrap(),\n-                            self.tcx.span_of_impl(item1).unwrap(),\n-                            &format!(\"duplicate definitions with name `{}` (E0592)\", name)\n-                        )\n-                    } else {\n-                        struct_span_err!(self.tcx.sess,\n-                                         self.tcx.span_of_impl(item1).unwrap(),\n-                                         E0592,\n-                                         \"duplicate definitions with name `{}`\",\n-                                         name)\n+                    let mut err = match used_to_be_allowed {\n+                        Some(kind) if node_id.is_some() => {\n+                            let lint = match kind {\n+                                FutureCompatOverlapErrorKind::Issue43355 =>\n+                                    lint::builtin::INCOHERENT_FUNDAMENTAL_IMPLS,\n+                                FutureCompatOverlapErrorKind::Issue33140 =>\n+                                    lint::builtin::ORDER_DEPENDENT_TRAIT_OBJECTS,\n+                            };\n+                            self.tcx.struct_span_lint_node(\n+                                lint,\n+                                node_id.unwrap(),\n+                                self.tcx.span_of_impl(item1).unwrap(),\n+                                &format!(\"duplicate definitions with name `{}` (E0592)\", name)\n+                            )\n+                        }\n+                        _ => {\n+                            struct_span_err!(self.tcx.sess,\n+                                             self.tcx.span_of_impl(item1).unwrap(),\n+                                             E0592,\n+                                             \"duplicate definitions with name `{}`\",\n+                                             name)\n+                        }\n                     };\n \n                     err.span_label(self.tcx.span_of_impl(item1).unwrap(),\n@@ -82,38 +94,73 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n \n         for (i, &impl1_def_id) in impls.iter().enumerate() {\n             for &impl2_def_id in &impls[(i + 1)..] {\n+                // First, check if the impl was forbidden under the\n+                // old rules. In that case, just have an error.\n                 let used_to_be_allowed = traits::overlapping_impls(\n                     self.tcx,\n                     impl1_def_id,\n                     impl2_def_id,\n                     IntercrateMode::Issue43355,\n+                    TraitObjectMode::NoSquash,\n                     |overlap| {\n                         self.check_for_common_items_in_impls(\n                             impl1_def_id,\n                             impl2_def_id,\n                             overlap,\n-                            false,\n+                            None,\n                         );\n                         false\n                     },\n                     || true,\n                 );\n \n-                if used_to_be_allowed {\n-                    traits::overlapping_impls(\n-                        self.tcx,\n-                        impl1_def_id,\n-                        impl2_def_id,\n-                        IntercrateMode::Fixed,\n-                        |overlap| self.check_for_common_items_in_impls(\n+                if !used_to_be_allowed {\n+                    continue;\n+                }\n+\n+                // Then, check if the impl was forbidden under only\n+                // #43355. In that case, emit an #43355 error.\n+                let used_to_be_allowed = traits::overlapping_impls(\n+                    self.tcx,\n+                    impl1_def_id,\n+                    impl2_def_id,\n+                    IntercrateMode::Fixed,\n+                    TraitObjectMode::NoSquash,\n+                    |overlap| {\n+                        self.check_for_common_items_in_impls(\n                             impl1_def_id,\n                             impl2_def_id,\n                             overlap,\n-                            true,\n-                        ),\n-                        || (),\n-                    );\n+                            Some(FutureCompatOverlapErrorKind::Issue43355),\n+                        );\n+                        false\n+                    },\n+                    || true,\n+                );\n+\n+                if !used_to_be_allowed {\n+                    continue;\n                 }\n+\n+                // Then, check if the impl was forbidden under\n+                // #33140. In that case, emit a #33140 error.\n+                traits::overlapping_impls(\n+                    self.tcx,\n+                    impl1_def_id,\n+                    impl2_def_id,\n+                    IntercrateMode::Fixed,\n+                    TraitObjectMode::SquashAutoTraitsIssue33140,\n+                    |overlap| {\n+                        self.check_for_common_items_in_impls(\n+                            impl1_def_id,\n+                            impl2_def_id,\n+                            overlap,\n+                            Some(FutureCompatOverlapErrorKind::Issue33140),\n+                        );\n+                        false\n+                    },\n+                    || true,\n+                );\n             }\n         }\n     }"}, {"sha": "08c69452f69ebe62c117e5b1214a5e8345315006", "filename": "src/test/run-pass/issues/issue-33140.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Ftest%2Frun-pass%2Fissues%2Fissue-33140.rs", "raw_url": "https://github.com/rust-lang/rust/raw/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Ftest%2Frun-pass%2Fissues%2Fissue-33140.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-33140.rs?ref=041254b81495a5aa67af839e00b890e78ed0cbeb", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(order_dependent_trait_objects)]\n+\n+trait Trait {\n+    fn xyz() -> bool;\n+}\n+\n+impl Trait for dyn Send + Sync {\n+    fn xyz() -> bool { false }\n+}\n+\n+impl Trait for dyn Sync + Send {\n+    fn xyz() -> bool { true }\n+}\n+\n+trait Trait2 {\n+    fn uvw() -> bool;\n+}\n+\n+impl Trait2 for dyn Send + Sync {\n+    fn uvw() -> bool { false }\n+}\n+\n+impl Trait2 for dyn Sync + Send + Sync {\n+    fn uvw() -> bool { true }\n+}\n+\n+struct Foo<T: ?Sized>(T);\n+impl Foo<dyn Send + Sync> {\n+    fn abc() -> bool {\n+        false\n+    }\n+}\n+\n+impl Foo<dyn Sync + Send> {\n+    fn abc() -> bool {\n+        true\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(<dyn Send+Sync>::xyz(), false);\n+    assert_eq!(<dyn Sync+Send>::xyz(), true);\n+    assert_eq!(<dyn Send+Sync>::uvw(), false);\n+    assert_eq!(<dyn Sync+Send+Sync>::uvw(), true);\n+    assert_eq!(<Foo<dyn Send+Sync>>::abc(), false);\n+    assert_eq!(<Foo<dyn Sync+Send>>::abc(), true);\n+}"}, {"sha": "fef5a82d9f81a6ed599869c4df9d08dd80b43dc2", "filename": "src/test/ui/issues/issue-33140.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Ftest%2Fui%2Fissues%2Fissue-33140.rs", "raw_url": "https://github.com/rust-lang/rust/raw/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Ftest%2Fui%2Fissues%2Fissue-33140.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33140.rs?ref=041254b81495a5aa67af839e00b890e78ed0cbeb", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(order_dependent_trait_objects)]\n+\n+trait Trait {\n+    fn xyz() -> bool;\n+}\n+\n+impl Trait for dyn Send + Sync {\n+    fn xyz() -> bool { false }\n+}\n+\n+impl Trait for dyn Sync + Send {\n+//~^ ERROR conflicting implementations\n+//~| hard error\n+    fn xyz() -> bool { true }\n+}\n+\n+trait Trait2 {\n+    fn uvw() -> bool;\n+}\n+\n+impl Trait2 for dyn Send + Sync {\n+    fn uvw() -> bool { false }\n+}\n+\n+impl Trait2 for dyn Sync + Send + Sync {\n+//~^ ERROR conflicting implementations\n+//~| hard error\n+    fn uvw() -> bool { true }\n+}\n+\n+struct Foo<T: ?Sized>(T);\n+impl Foo<dyn Send + Sync> {\n+    fn abc() -> bool { //~ ERROR duplicate definitions with name `abc`\n+                       //~| hard error\n+        false\n+    }\n+}\n+\n+impl Foo<dyn Sync + Send> {\n+    fn abc() -> bool {\n+        true\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(<Send+Sync>::xyz(), false);\n+    assert_eq!(<Sync+Send>::xyz(), true);\n+    assert_eq!(<Send+Sync>::uvw(), false);\n+    assert_eq!(<Sync+Send+Sync>::uvw(), true);\n+    assert_eq!(<Foo<Send+Sync>>::abc(), false);\n+    assert_eq!(<Foo<Sync+Send>>::abc(), true);\n+}"}, {"sha": "240137f863abe8b002d9335ca37d31a1e76df7e5", "filename": "src/test/ui/issues/issue-33140.stderr", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Ftest%2Fui%2Fissues%2Fissue-33140.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Ftest%2Fui%2Fissues%2Fissue-33140.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33140.stderr?ref=041254b81495a5aa67af839e00b890e78ed0cbeb", "patch": "@@ -0,0 +1,48 @@\n+error: conflicting implementations of trait `Trait` for type `(dyn std::marker::Send + std::marker::Sync + 'static)`: (E0119)\n+  --> $DIR/issue-33140.rs:21:1\n+   |\n+LL | impl Trait for dyn Send + Sync {\n+   | ------------------------------ first implementation here\n+...\n+LL | impl Trait for dyn Sync + Send {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `(dyn std::marker::Send + std::marker::Sync + 'static)`\n+   |\n+note: lint level defined here\n+  --> $DIR/issue-33140.rs:11:9\n+   |\n+LL | #![deny(order_dependent_trait_objects)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #56484 <https://github.com/rust-lang/rust/issues/56484>\n+\n+error: conflicting implementations of trait `Trait2` for type `(dyn std::marker::Send + std::marker::Sync + 'static)`: (E0119)\n+  --> $DIR/issue-33140.rs:35:1\n+   |\n+LL | impl Trait2 for dyn Send + Sync {\n+   | ------------------------------- first implementation here\n+...\n+LL | impl Trait2 for dyn Sync + Send + Sync {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `(dyn std::marker::Send + std::marker::Sync + 'static)`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #56484 <https://github.com/rust-lang/rust/issues/56484>\n+\n+error: duplicate definitions with name `abc` (E0592)\n+  --> $DIR/issue-33140.rs:43:5\n+   |\n+LL | /     fn abc() -> bool { //~ ERROR duplicate definitions with name `abc`\n+LL | |                        //~| hard error\n+LL | |         false\n+LL | |     }\n+   | |_____^ duplicate definitions for `abc`\n+...\n+LL | /     fn abc() -> bool {\n+LL | |         true\n+LL | |     }\n+   | |_____- other definition for `abc`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #56484 <https://github.com/rust-lang/rust/issues/56484>\n+\n+error: aborting due to 3 previous errors\n+"}]}