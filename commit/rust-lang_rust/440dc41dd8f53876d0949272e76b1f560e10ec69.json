{"sha": "440dc41dd8f53876d0949272e76b1f560e10ec69", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0MGRjNDFkZDhmNTM4NzZkMDk0OTI3MmU3NmIxZjU2MGUxMGVjNjk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-02T17:08:58Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-02T19:51:59Z"}, "message": "Add source root", "tree": {"sha": "55daf3b6e687be992e84845e813151daaec64267", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55daf3b6e687be992e84845e813151daaec64267"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/440dc41dd8f53876d0949272e76b1f560e10ec69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/440dc41dd8f53876d0949272e76b1f560e10ec69", "html_url": "https://github.com/rust-lang/rust/commit/440dc41dd8f53876d0949272e76b1f560e10ec69", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/440dc41dd8f53876d0949272e76b1f560e10ec69/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e98d8cd255ab5c2fee873a58af6c2c3ad561dab4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e98d8cd255ab5c2fee873a58af6c2c3ad561dab4", "html_url": "https://github.com/rust-lang/rust/commit/e98d8cd255ab5c2fee873a58af6c2c3ad561dab4"}], "stats": {"total": 299, "additions": 167, "deletions": 132}, "files": [{"sha": "73a6f430647fdd3a6f06a43b9093690a313a5431", "filename": "crates/libanalysis/src/imp.rs", "status": "modified", "additions": 16, "deletions": 105, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/440dc41dd8f53876d0949272e76b1f560e10ec69/crates%2Flibanalysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/440dc41dd8f53876d0949272e76b1f560e10ec69/crates%2Flibanalysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fimp.rs?ref=440dc41dd8f53876d0949272e76b1f560e10ec69", "patch": "@@ -4,13 +4,9 @@ use std::{\n         atomic::{AtomicBool, Ordering::SeqCst},\n     },\n     fmt,\n-    time::Instant,\n-    collections::{HashMap, HashSet, VecDeque},\n-    panic,\n+    collections::{HashSet, VecDeque},\n };\n \n-use rayon::prelude::*;\n-use once_cell::sync::OnceCell;\n use libeditor::{self, FileSymbol, LineIndex, find_node_at_offset, LocalEdit};\n use libsyntax2::{\n     TextUnit, TextRange, SmolStr, File, AstNode,\n@@ -20,10 +16,9 @@ use libsyntax2::{\n \n use {\n     FileId, FileResolver, Query, Diagnostic, SourceChange, SourceFileEdit, Position, FileSystemEdit,\n-    module_map::Problem,\n-    symbol_index::FileSymbols,\n-    module_map::{ModuleMap, ChangeKind},\n     JobToken, CrateGraph, CrateId,\n+    module_map::Problem,\n+    roots::SourceRoot,\n };\n \n #[derive(Debug)]\n@@ -50,23 +45,7 @@ impl AnalysisHostImpl {\n     pub fn change_files(&mut self, changes: &mut dyn Iterator<Item=(FileId, Option<String>)>) {\n         let data = self.data_mut();\n         for (file_id, text) in changes {\n-            let change_kind = if data.file_map.remove(&file_id).is_some() {\n-                if text.is_some() {\n-                    ChangeKind::Update\n-                } else {\n-                    ChangeKind::Delete\n-                }\n-            } else {\n-                ChangeKind::Insert\n-            };\n-            data.module_map.update_file(file_id, change_kind);\n-            data.file_map.remove(&file_id);\n-            if let Some(text) = text {\n-                let file_data = FileData::new(text);\n-                data.file_map.insert(file_id, Arc::new(file_data));\n-            } else {\n-                data.file_map.remove(&file_id);\n-            }\n+            data.root.update(file_id, text);\n         }\n     }\n     pub fn set_crate_graph(&mut self, graph: CrateGraph) {\n@@ -106,31 +85,18 @@ impl Clone for AnalysisImpl {\n }\n \n impl AnalysisImpl {\n-    pub fn file_syntax(&self, file_id: FileId) -> File {\n-        self.file_data(file_id).syntax().clone()\n+    pub fn file_syntax(&self, file_id: FileId) -> &File {\n+        self.data.root.syntax(file_id)\n     }\n-\n-    pub fn file_line_index(&self, id: FileId) -> LineIndex {\n-        let data = self.file_data(id);\n-        data\n-            .lines\n-            .get_or_init(|| LineIndex::new(&data.text))\n-            .clone()\n+    pub fn file_line_index(&self, file_id: FileId) -> &LineIndex {\n+        self.data.root.lines(file_id)\n     }\n-\n-    pub fn world_symbols(&self, mut query: Query, token: &JobToken) -> Vec<(FileId, FileSymbol)> {\n+    pub fn world_symbols(&self,  query: Query, token: &JobToken) -> Vec<(FileId, FileSymbol)> {\n         self.reindex();\n-        self.data.file_map.iter()\n-            .take_while(move |_| !token.is_canceled())\n-            .flat_map(move |(id, data)| {\n-                let symbols = data.symbols();\n-                query.process(symbols).into_iter().map(move |s| (*id, s))\n-            })\n-            .collect()\n+        query.search(&self.data.root.symbols(), token)\n     }\n-\n     pub fn parent_module(&self, id: FileId) -> Vec<(FileId, FileSymbol)> {\n-        let module_map = &self.data.module_map;\n+        let module_map = self.data.root.module_map();\n         let id = module_map.file2module(id);\n         module_map\n             .parent_modules(\n@@ -152,7 +118,7 @@ impl AnalysisImpl {\n     }\n \n     pub fn crate_for(&self, id: FileId) -> Vec<CrateId> {\n-        let module_map = &self.data.module_map;\n+        let module_map = self.data.root.module_map();\n         let crate_graph = &self.data.crate_graph;\n         let mut res = Vec::new();\n         let mut work = VecDeque::new();\n@@ -222,7 +188,7 @@ impl AnalysisImpl {\n             .map(|d| Diagnostic { range: d.range, message: d.msg, fix: None })\n             .collect::<Vec<_>>();\n \n-        self.data.module_map.problems(\n+        self.data.root.module_map().problems(\n             file_id,\n             &*self.file_resolver,\n             &|file_id| self.file_syntax(file_id),\n@@ -296,7 +262,7 @@ impl AnalysisImpl {\n             Some(name) => name.text(),\n             None => return Vec::new(),\n         };\n-        let module_map = &self.data.module_map;\n+        let module_map = self.data.root.module_map();\n         let id = module_map.file2module(id);\n         module_map\n             .child_module_by_name(\n@@ -311,70 +277,15 @@ impl AnalysisImpl {\n \n     fn reindex(&self) {\n         if self.needs_reindex.compare_and_swap(true, false, SeqCst) {\n-            let now = Instant::now();\n-            let data = &*self.data;\n-            data.file_map\n-                .par_iter()\n-                .for_each(|(_, data)| drop(data.symbols()));\n-            info!(\"parallel indexing took {:?}\", now.elapsed());\n-        }\n-    }\n-\n-    fn file_data(&self, file_id: FileId) -> Arc<FileData> {\n-        match self.data.file_map.get(&file_id) {\n-            Some(data) => data.clone(),\n-            None => panic!(\"unknown file: {:?}\", file_id),\n+            self.data.root.reindex();\n         }\n     }\n }\n \n #[derive(Clone, Default, Debug)]\n struct WorldData {\n     crate_graph: CrateGraph,\n-    file_map: HashMap<FileId, Arc<FileData>>,\n-    module_map: ModuleMap,\n-}\n-\n-#[derive(Debug)]\n-struct FileData {\n-    text: String,\n-    symbols: OnceCell<FileSymbols>,\n-    syntax: OnceCell<File>,\n-    lines: OnceCell<LineIndex>,\n-}\n-\n-impl FileData {\n-    fn new(text: String) -> FileData {\n-        FileData {\n-            text,\n-            symbols: OnceCell::new(),\n-            syntax: OnceCell::new(),\n-            lines: OnceCell::new(),\n-        }\n-    }\n-\n-    fn syntax(&self) -> &File {\n-        let text = &self.text;\n-        let syntax = &self.syntax;\n-        match panic::catch_unwind(panic::AssertUnwindSafe(|| syntax.get_or_init(|| File::parse(text)))) {\n-            Ok(file) => file,\n-            Err(err) => {\n-                error!(\"Parser paniced on:\\n------\\n{}\\n------\\n\", &self.text);\n-                panic::resume_unwind(err)\n-            }\n-        }\n-    }\n-\n-    fn syntax_transient(&self) -> File {\n-        self.syntax.get().map(|s| s.clone())\n-            .unwrap_or_else(|| File::parse(&self.text))\n-    }\n-\n-    fn symbols(&self) -> &FileSymbols {\n-        let syntax = self.syntax_transient();\n-        self.symbols\n-            .get_or_init(|| FileSymbols::new(&syntax))\n-    }\n+    root: SourceRoot,\n }\n \n impl SourceChange {"}, {"sha": "b044fdae817c29c2ef49af73c6c24ee8baf8b185", "filename": "crates/libanalysis/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/440dc41dd8f53876d0949272e76b1f560e10ec69/crates%2Flibanalysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/440dc41dd8f53876d0949272e76b1f560e10ec69/crates%2Flibanalysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Flib.rs?ref=440dc41dd8f53876d0949272e76b1f560e10ec69", "patch": "@@ -14,6 +14,7 @@ mod symbol_index;\n mod module_map;\n mod imp;\n mod job;\n+mod roots;\n \n use std::{\n     sync::Arc,\n@@ -146,10 +147,10 @@ pub struct Analysis {\n \n impl Analysis {\n     pub fn file_syntax(&self, file_id: FileId) -> File {\n-        self.imp.file_syntax(file_id)\n+        self.imp.file_syntax(file_id).clone()\n     }\n     pub fn file_line_index(&self, file_id: FileId) -> LineIndex {\n-        self.imp.file_line_index(file_id)\n+        self.imp.file_line_index(file_id).clone()\n     }\n     pub fn extend_selection(&self, file: &File, range: TextRange) -> TextRange {\n         libeditor::extend_selection(file, range).unwrap_or(range)"}, {"sha": "5ceb7181787986ebb1e759430034e4681520d5b8", "filename": "crates/libanalysis/src/module_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/440dc41dd8f53876d0949272e76b1f560e10ec69/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/440dc41dd8f53876d0949272e76b1f560e10ec69/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs?ref=440dc41dd8f53876d0949272e76b1f560e10ec69", "patch": "@@ -8,7 +8,7 @@ use libsyntax2::{\n };\n use {FileId, FileResolver};\n \n-type SyntaxProvider<'a> = dyn Fn(FileId) -> File + 'a;\n+type SyntaxProvider<'a> = dyn Fn(FileId) -> &'a File + 'a;\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub struct ModuleId(FileId);"}, {"sha": "675bce54ca1a1d1c008e09b82b1f339c0252cce9", "filename": "crates/libanalysis/src/roots.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/440dc41dd8f53876d0949272e76b1f560e10ec69/crates%2Flibanalysis%2Fsrc%2Froots.rs", "raw_url": "https://github.com/rust-lang/rust/raw/440dc41dd8f53876d0949272e76b1f560e10ec69/crates%2Flibanalysis%2Fsrc%2Froots.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Froots.rs?ref=440dc41dd8f53876d0949272e76b1f560e10ec69", "patch": "@@ -0,0 +1,113 @@\n+use std::{\n+    collections::HashMap,\n+    time::Instant,\n+    sync::Arc,\n+    panic,\n+};\n+\n+use once_cell::sync::OnceCell;\n+use rayon::prelude::*;\n+use libeditor::LineIndex;\n+use libsyntax2::File;\n+\n+use {\n+    FileId,\n+    module_map::{ModuleMap, ChangeKind},\n+    symbol_index::FileSymbols,\n+};\n+\n+#[derive(Clone, Default, Debug)]\n+pub(crate) struct SourceRoot {\n+    file_map: HashMap<FileId, Arc<FileData>>,\n+    module_map: ModuleMap,\n+}\n+\n+impl SourceRoot {\n+    pub fn update(&mut self, file_id: FileId, text: Option<String>) {\n+        let change_kind = if self.file_map.remove(&file_id).is_some() {\n+            if text.is_some() {\n+                ChangeKind::Update\n+            } else {\n+                ChangeKind::Delete\n+            }\n+        } else {\n+            ChangeKind::Insert\n+        };\n+        self.module_map.update_file(file_id, change_kind);\n+        self.file_map.remove(&file_id);\n+        if let Some(text) = text {\n+            let file_data = FileData::new(text);\n+            self.file_map.insert(file_id, Arc::new(file_data));\n+        } else {\n+            self.file_map.remove(&file_id);\n+        }\n+    }\n+    pub fn module_map(&self) -> &ModuleMap {\n+        &self.module_map\n+    }\n+    pub fn lines(&self, file_id: FileId) -> &LineIndex {\n+        let data = self.data(file_id);\n+        data.lines.get_or_init(|| LineIndex::new(&data.text))\n+    }\n+    pub fn syntax(&self, file_id: FileId) -> &File {\n+        let data = self.data(file_id);\n+        let text = &data.text;\n+        let syntax = &data.syntax;\n+        match panic::catch_unwind(panic::AssertUnwindSafe(|| syntax.get_or_init(|| File::parse(text)))) {\n+            Ok(file) => file,\n+            Err(err) => {\n+                error!(\"Parser paniced on:\\n------\\n{}\\n------\\n\", &data.text);\n+                panic::resume_unwind(err)\n+            }\n+        }\n+    }\n+    pub(crate) fn symbols(&self) -> Vec<(FileId, &FileSymbols)> {\n+        self.file_map\n+            .iter()\n+            .map(|(&file_id, data)| (file_id, data.symbols()))\n+            .collect()\n+    }\n+    pub fn reindex(&self) {\n+        let now = Instant::now();\n+        self.file_map\n+            .par_iter()\n+            .for_each(|(_, data)| {\n+                data.symbols();\n+            });\n+        info!(\"parallel indexing took {:?}\", now.elapsed());\n+\n+    }\n+    fn data(&self, file_id: FileId) -> &FileData {\n+        match self.file_map.get(&file_id) {\n+            Some(data) => data,\n+            None => panic!(\"unknown file: {:?}\", file_id),\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct FileData {\n+    text: String,\n+    lines: OnceCell<LineIndex>,\n+    syntax: OnceCell<File>,\n+    symbols: OnceCell<FileSymbols>,\n+}\n+\n+impl FileData {\n+    fn new(text: String) -> FileData {\n+        FileData {\n+            text,\n+            symbols: OnceCell::new(),\n+            syntax: OnceCell::new(),\n+            lines: OnceCell::new(),\n+        }\n+    }\n+    fn syntax_transient(&self) -> File {\n+        self.syntax.get().map(|s| s.clone())\n+            .unwrap_or_else(|| File::parse(&self.text))\n+    }\n+    fn symbols(&self) -> &FileSymbols {\n+        let syntax = self.syntax_transient();\n+        self.symbols.get_or_init(|| FileSymbols::new(&syntax))\n+    }\n+}"}, {"sha": "2cad3f6eba3ce0e6b8022d199749fe3943167395", "filename": "crates/libanalysis/src/symbol_index.rs", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/440dc41dd8f53876d0949272e76b1f560e10ec69/crates%2Flibanalysis%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/440dc41dd8f53876d0949272e76b1f560e10ec69/crates%2Flibanalysis%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fsymbol_index.rs?ref=440dc41dd8f53876d0949272e76b1f560e10ec69", "patch": "@@ -3,8 +3,8 @@ use libsyntax2::{\n     File,\n     SyntaxKind::{self, *},\n };\n-use fst::{self, IntoStreamer, Streamer};\n-use Query;\n+use fst::{self, Streamer};\n+use {Query, FileId, JobToken};\n \n #[derive(Debug)]\n pub(crate) struct FileSymbols {\n@@ -32,35 +32,45 @@ impl FileSymbols {\n }\n \n impl Query {\n-    pub(crate) fn process(\n-        &mut self,\n-        file: &FileSymbols,\n-    ) -> Vec<FileSymbol> {\n-        fn is_type(kind: SyntaxKind) -> bool {\n-            match kind {\n-                STRUCT_DEF | ENUM_DEF | TRAIT_DEF | TYPE_DEF => true,\n-                _ => false,\n-            }\n+    pub(crate) fn search(\n+        mut self,\n+        indices: &[(FileId, &FileSymbols)],\n+        token: &JobToken,\n+    ) -> Vec<(FileId, FileSymbol)> {\n+\n+        let mut op = fst::map::OpBuilder::new();\n+        for (_, file_symbols) in indices.iter() {\n+            let automaton = fst::automaton::Subsequence::new(&self.lowercased);\n+            op = op.add(file_symbols.map.search(automaton))\n         }\n-        let automaton = fst::automaton::Subsequence::new(&self.lowercased);\n-        let mut stream = file.map.search(automaton).into_stream();\n+        let mut stream = op.union();\n         let mut res = Vec::new();\n-        while let Some((_, idx)) = stream.next() {\n-            if self.limit == 0 {\n+        while let Some((_, indexed_values)) = stream.next() {\n+            if self.limit == 0 || token.is_canceled() {\n                 break;\n             }\n-            let idx = idx as usize;\n-            let symbol = &file.symbols[idx];\n-            if self.only_types && !is_type(symbol.kind) {\n-                continue;\n-            }\n-            if self.exact && symbol.name != self.query {\n-                continue;\n+            for indexed_value in indexed_values {\n+                let (file_id, file_symbols) = &indices[indexed_value.index];\n+                let idx = indexed_value.value as usize;\n+\n+                let symbol = &file_symbols.symbols[idx];\n+                if self.only_types && !is_type(symbol.kind) {\n+                    continue;\n+                }\n+                if self.exact && symbol.name != self.query {\n+                    continue;\n+                }\n+                res.push((*file_id, symbol.clone()));\n+                self.limit -= 1;\n             }\n-            res.push(symbol.clone());\n-            self.limit -= 1;\n         }\n         res\n     }\n }\n \n+fn is_type(kind: SyntaxKind) -> bool {\n+    match kind {\n+        STRUCT_DEF | ENUM_DEF | TRAIT_DEF | TYPE_DEF => true,\n+        _ => false,\n+    }\n+}"}]}