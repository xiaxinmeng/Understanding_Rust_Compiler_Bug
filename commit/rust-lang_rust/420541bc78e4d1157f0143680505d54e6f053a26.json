{"sha": "420541bc78e4d1157f0143680505d54e6f053a26", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyMDU0MWJjNzhlNGQxMTU3ZjAxNDM2ODA1MDVkNTRlNmYwNTNhMjY=", "commit": {"author": {"name": "Emerentius", "email": "emerentius@arcor.de", "date": "2018-08-20T11:57:10Z"}, "committer": {"name": "Emerentius", "email": "emerentius@arcor.de", "date": "2018-10-13T22:58:17Z"}, "message": "add option to libtest to run all tests\n\nflag name is --include-ignored\nrequires -Zunstable-options for now", "tree": {"sha": "62ecc2057382320d969fdcd96e5eaa6c4be74c09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62ecc2057382320d969fdcd96e5eaa6c4be74c09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/420541bc78e4d1157f0143680505d54e6f053a26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/420541bc78e4d1157f0143680505d54e6f053a26", "html_url": "https://github.com/rust-lang/rust/commit/420541bc78e4d1157f0143680505d54e6f053a26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/420541bc78e4d1157f0143680505d54e6f053a26/comments", "author": {"login": "Emerentius", "id": 9992929, "node_id": "MDQ6VXNlcjk5OTI5Mjk=", "avatar_url": "https://avatars.githubusercontent.com/u/9992929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Emerentius", "html_url": "https://github.com/Emerentius", "followers_url": "https://api.github.com/users/Emerentius/followers", "following_url": "https://api.github.com/users/Emerentius/following{/other_user}", "gists_url": "https://api.github.com/users/Emerentius/gists{/gist_id}", "starred_url": "https://api.github.com/users/Emerentius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Emerentius/subscriptions", "organizations_url": "https://api.github.com/users/Emerentius/orgs", "repos_url": "https://api.github.com/users/Emerentius/repos", "events_url": "https://api.github.com/users/Emerentius/events{/privacy}", "received_events_url": "https://api.github.com/users/Emerentius/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Emerentius", "id": 9992929, "node_id": "MDQ6VXNlcjk5OTI5Mjk=", "avatar_url": "https://avatars.githubusercontent.com/u/9992929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Emerentius", "html_url": "https://github.com/Emerentius", "followers_url": "https://api.github.com/users/Emerentius/followers", "following_url": "https://api.github.com/users/Emerentius/following{/other_user}", "gists_url": "https://api.github.com/users/Emerentius/gists{/gist_id}", "starred_url": "https://api.github.com/users/Emerentius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Emerentius/subscriptions", "organizations_url": "https://api.github.com/users/Emerentius/orgs", "repos_url": "https://api.github.com/users/Emerentius/repos", "events_url": "https://api.github.com/users/Emerentius/events{/privacy}", "received_events_url": "https://api.github.com/users/Emerentius/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68b596408dd6cdd0827e61458fc09c374548218f", "url": "https://api.github.com/repos/rust-lang/rust/commits/68b596408dd6cdd0827e61458fc09c374548218f", "html_url": "https://github.com/rust-lang/rust/commit/68b596408dd6cdd0827e61458fc09c374548218f"}], "stats": {"total": 150, "additions": 104, "deletions": 46}, "files": [{"sha": "7c26d042a7ccfbed2c13de0a306848b1bca9d2fe", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 104, "deletions": 46, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/420541bc78e4d1157f0143680505d54e6f053a26/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/420541bc78e4d1157f0143680505d54e6f053a26/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=420541bc78e4d1157f0143680505d54e6f053a26", "patch": "@@ -89,7 +89,7 @@ const QUIET_MODE_MAX_COLUMN: usize = 100; // insert a '\\n' after 100 tests in qu\n // to be used by rustc to compile tests in libtest\n pub mod test {\n     pub use {assert_test_result, filter_tests, parse_opts, run_test, test_main, test_main_static,\n-             Bencher, DynTestFn, DynTestName, Metric, MetricMap, Options, ShouldPanic,\n+             Bencher, DynTestFn, DynTestName, Metric, MetricMap, Options, RunIgnored, ShouldPanic,\n              StaticBenchFn, StaticTestFn, StaticTestName, TestDesc, TestDescAndFn, TestName,\n              TestOpts, TestResult, TrFailed, TrFailedMsg, TrIgnored, TrOk};\n }\n@@ -357,12 +357,19 @@ pub enum OutputFormat {\n     Json,\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum RunIgnored {\n+    Yes,\n+    No,\n+    Only,\n+}\n+\n #[derive(Debug)]\n pub struct TestOpts {\n     pub list: bool,\n     pub filter: Option<String>,\n     pub filter_exact: bool,\n-    pub run_ignored: bool,\n+    pub run_ignored: RunIgnored,\n     pub run_tests: bool,\n     pub bench_benchmarks: bool,\n     pub logfile: Option<PathBuf>,\n@@ -381,7 +388,7 @@ impl TestOpts {\n             list: false,\n             filter: None,\n             filter_exact: false,\n-            run_ignored: false,\n+            run_ignored: RunIgnored::No,\n             run_tests: false,\n             bench_benchmarks: false,\n             logfile: None,\n@@ -400,7 +407,8 @@ pub type OptRes = Result<TestOpts, String>;\n \n fn optgroups() -> getopts::Options {\n     let mut opts = getopts::Options::new();\n-    opts.optflag(\"\", \"ignored\", \"Run ignored tests\")\n+    opts.optflag(\"\", \"include-ignored\", \"Run ignored and not ignored tests\")\n+        .optflag(\"\", \"ignored\", \"Run only ignored tests\")\n         .optflag(\"\", \"test\", \"Run tests and not benchmarks\")\n         .optflag(\"\", \"bench\", \"Run benchmarks instead of tests\")\n         .optflag(\"\", \"list\", \"List all tests and benchmarks\")\n@@ -499,8 +507,8 @@ Test Attributes:\n                      contain: #[should_panic(expected = \"foo\")].\n     #[ignore]      - When applied to a function which is already attributed as a\n                      test, then the test runner will ignore these tests during\n-                     normal test runs. Running with --ignored will run these\n-                     tests.\"#,\n+                     normal test runs. Running with --ignored or --include-ignored will run\n+                     these tests.\"#,\n         usage = options.usage(&message)\n     );\n }\n@@ -553,7 +561,21 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         None\n     };\n \n-    let run_ignored = matches.opt_present(\"ignored\");\n+    let include_ignored = matches.opt_present(\"include-ignored\");\n+    if !allow_unstable && include_ignored {\n+        return Some(Err(\n+            \"The \\\"include-ignored\\\" flag is only accepted on the nightly compiler\".into()\n+        ));\n+    }\n+\n+    let run_ignored = match (include_ignored, matches.opt_present(\"ignored\")) {\n+        (true, true) => return Some(Err(\n+            \"the options --include-ignored and --ignored are mutually exclusive\".into()\n+        )),\n+        (true, false) => RunIgnored::Yes,\n+        (false, true) => RunIgnored::Only,\n+        (false, false) => RunIgnored::No,\n+    };\n     let quiet = matches.opt_present(\"quiet\");\n     let exact = matches.opt_present(\"exact\");\n     let list = matches.opt_present(\"list\");\n@@ -1324,16 +1346,17 @@ pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescA\n         !opts.skip.iter().any(|sf| matches_filter(test, sf))\n     });\n \n-    // Maybe pull out the ignored test and unignore them\n-    if opts.run_ignored {\n-        filtered = filtered.into_iter()\n-            .filter(|test| test.desc.ignore)\n-            .map(|mut test| {\n-                test.desc.ignore = false;\n-                test\n-            })\n-            .collect();\n-    };\n+    // maybe unignore tests\n+    match opts.run_ignored {\n+        RunIgnored::Yes => {\n+            filtered.iter_mut().for_each(|test| test.desc.ignore = false);\n+        },\n+        RunIgnored::Only => {\n+            filtered.retain(|test| test.desc.ignore);\n+            filtered.iter_mut().for_each(|test| test.desc.ignore = false);\n+        }\n+        RunIgnored::No => {}\n+    }\n \n     // Sort the tests alphabetically\n     filtered.sort_by(|t1, t2| t1.desc.name.as_slice().cmp(t2.desc.name.as_slice()));\n@@ -1722,13 +1745,37 @@ pub mod bench {\n \n #[cfg(test)]\n mod tests {\n-    use test::{filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, ShouldPanic,\n-               StaticTestName, TestDesc, TestDescAndFn, TestOpts, TrFailed, TrFailedMsg,\n-               TrIgnored, TrOk};\n+    use test::{filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, RunIgnored,\n+               ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts, TrFailed,\n+               TrFailedMsg, TrIgnored, TrOk};\n     use std::sync::mpsc::channel;\n     use bench;\n     use Bencher;\n \n+\n+    fn one_ignored_one_unignored_test() -> Vec<TestDescAndFn> {\n+        vec![\n+            TestDescAndFn {\n+                desc: TestDesc {\n+                    name: StaticTestName(\"1\"),\n+                    ignore: true,\n+                    should_panic: ShouldPanic::No,\n+                    allow_fail: false,\n+                },\n+                testfn: DynTestFn(Box::new(move || {})),\n+            },\n+            TestDescAndFn {\n+                desc: TestDesc {\n+                    name: StaticTestName(\"2\"),\n+                    ignore: false,\n+                    should_panic: ShouldPanic::No,\n+                    allow_fail: false,\n+                },\n+                testfn: DynTestFn(Box::new(move || {})),\n+            },\n+        ]\n+    }\n+\n     #[test]\n     pub fn do_not_run_ignored_tests() {\n         fn f() {\n@@ -1854,11 +1901,20 @@ mod tests {\n             \"filter\".to_string(),\n             \"--ignored\".to_string(),\n         ];\n-        let opts = match parse_opts(&args) {\n-            Some(Ok(o)) => o,\n-            _ => panic!(\"Malformed arg in parse_ignored_flag\"),\n-        };\n-        assert!((opts.run_ignored));\n+        let opts = parse_opts(&args).unwrap().unwrap();\n+        assert_eq!(opts.run_ignored, RunIgnored::Only);\n+    }\n+\n+    #[test]\n+    fn parse_include_ignored_flag() {\n+        let args = vec![\n+            \"progname\".to_string(),\n+            \"filter\".to_string(),\n+            \"-Zunstable-options\".to_string(),\n+            \"--include-ignored\".to_string(),\n+        ];\n+        let opts = parse_opts(&args).unwrap().unwrap();\n+        assert_eq!(opts.run_ignored, RunIgnored::Yes);\n     }\n \n     #[test]\n@@ -1868,35 +1924,33 @@ mod tests {\n \n         let mut opts = TestOpts::new();\n         opts.run_tests = true;\n-        opts.run_ignored = true;\n+        opts.run_ignored = RunIgnored::Only;\n \n-        let tests = vec![\n-            TestDescAndFn {\n-                desc: TestDesc {\n-                    name: StaticTestName(\"1\"),\n-                    ignore: true,\n-                    should_panic: ShouldPanic::No,\n-                    allow_fail: false,\n-                },\n-                testfn: DynTestFn(Box::new(move || {})),\n-            },\n-            TestDescAndFn {\n-                desc: TestDesc {\n-                    name: StaticTestName(\"2\"),\n-                    ignore: false,\n-                    should_panic: ShouldPanic::No,\n-                    allow_fail: false,\n-                },\n-                testfn: DynTestFn(Box::new(move || {})),\n-            },\n-        ];\n+        let tests = one_ignored_one_unignored_test();\n         let filtered = filter_tests(&opts, tests);\n \n         assert_eq!(filtered.len(), 1);\n         assert_eq!(filtered[0].desc.name.to_string(), \"1\");\n         assert!(!filtered[0].desc.ignore);\n     }\n \n+    #[test]\n+    pub fn run_include_ignored_option() {\n+        // When we \"--include-ignored\" tests, the ignore flag should be set to false on\n+        // all tests and no test filtered out\n+\n+        let mut opts = TestOpts::new();\n+        opts.run_tests = true;\n+        opts.run_ignored = RunIgnored::Yes;\n+\n+        let tests = one_ignored_one_unignored_test();\n+        let filtered = filter_tests(&opts, tests);\n+\n+        assert_eq!(filtered.len(), 2);\n+        assert!(!filtered[0].desc.ignore);\n+        assert!(!filtered[1].desc.ignore);\n+    }\n+\n     #[test]\n     pub fn exact_filter_match() {\n         fn tests() -> Vec<TestDescAndFn> {\n@@ -2004,7 +2058,9 @@ mod tests {\n             \"test::ignored_tests_result_in_ignored\".to_string(),\n             \"test::first_free_arg_should_be_a_filter\".to_string(),\n             \"test::parse_ignored_flag\".to_string(),\n+            \"test::parse_include_ignored_flag\".to_string(),\n             \"test::filter_for_ignored_option\".to_string(),\n+            \"test::run_include_ignored_option\".to_string(),\n             \"test::sort_tests\".to_string(),\n         ];\n         let tests = {\n@@ -2035,6 +2091,8 @@ mod tests {\n             \"test::first_free_arg_should_be_a_filter\".to_string(),\n             \"test::ignored_tests_result_in_ignored\".to_string(),\n             \"test::parse_ignored_flag\".to_string(),\n+            \"test::parse_include_ignored_flag\".to_string(),\n+            \"test::run_include_ignored_option\".to_string(),\n             \"test::sort_tests\".to_string(),\n         ];\n "}]}