{"sha": "0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0OTRiMDc4YTk1NTVmNzdkOWNkNGZiZTJhNGZmOTEwYmZiYTI5Yjg=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2012-12-13T01:13:41Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2012-12-13T01:13:41Z"}, "message": "Merge pull request #4172 from graydon/remove-old-syntax-ext\n\nRemove old syntax ext", "tree": {"sha": "f2bbe5ce3b3a42ca98902c66e8bff4a41a536f41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2bbe5ce3b3a42ca98902c66e8bff4a41a536f41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "html_url": "https://github.com/rust-lang/rust/commit/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0138d87f8f1b9f9614e439deb14cbaabad6d104c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0138d87f8f1b9f9614e439deb14cbaabad6d104c", "html_url": "https://github.com/rust-lang/rust/commit/0138d87f8f1b9f9614e439deb14cbaabad6d104c"}, {"sha": "9a4c669867765d42bdd13fc09eb9a32b7a667a43", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a4c669867765d42bdd13fc09eb9a32b7a667a43", "html_url": "https://github.com/rust-lang/rust/commit/9a4c669867765d42bdd13fc09eb9a32b7a667a43"}], "stats": {"total": 2233, "additions": 272, "deletions": 1961}, "files": [{"sha": "781ac7809e70cf5904fbe6e05e44fa7bee4d9d34", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -1033,6 +1033,8 @@ fn decode_item_ast(par_doc: ebml::Doc) -> @ast::item {\n trait fake_ext_ctxt {\n     fn cfg() -> ast::crate_cfg;\n     fn parse_sess() -> parse::parse_sess;\n+    fn call_site() -> span;\n+    fn ident_of(st: ~str) -> ast::ident;\n }\n \n #[cfg(test)]\n@@ -1042,6 +1044,16 @@ type fake_session = parse::parse_sess;\n impl fake_session: fake_ext_ctxt {\n     fn cfg() -> ast::crate_cfg { ~[] }\n     fn parse_sess() -> parse::parse_sess { self }\n+    fn call_site() -> span {\n+        codemap::span {\n+            lo: codemap::BytePos(0),\n+            hi: codemap::BytePos(0),\n+            expn_info: None\n+        }\n+    }\n+    fn ident_of(st: ~str) -> ast::ident {\n+        self.interner.intern(@st)\n+    }\n }\n \n #[cfg(test)]\n@@ -1050,7 +1062,8 @@ fn mk_ctxt() -> fake_ext_ctxt {\n }\n \n #[cfg(test)]\n-fn roundtrip(in_item: @ast::item) {\n+fn roundtrip(in_item: Option<@ast::item>) {\n+    let in_item = in_item.get();\n     let bytes = do io::with_bytes_writer |wr| {\n         let ebml_w = writer::Serializer(wr);\n         encode_item_ast(ebml_w, in_item);\n@@ -1074,45 +1087,45 @@ fn roundtrip(in_item: @ast::item) {\n #[test]\n fn test_basic() {\n     let ext_cx = mk_ctxt();\n-    roundtrip(#ast[item]{\n+    roundtrip(quote_item!(\n         fn foo() {}\n-    });\n+    ));\n }\n \n #[test]\n fn test_smalltalk() {\n     let ext_cx = mk_ctxt();\n-    roundtrip(#ast[item]{\n+    roundtrip(quote_item!(\n         fn foo() -> int { 3 + 4 } // first smalltalk program ever executed.\n-    });\n+    ));\n }\n \n #[test]\n fn test_more() {\n     let ext_cx = mk_ctxt();\n-    roundtrip(#ast[item]{\n+    roundtrip(quote_item!(\n         fn foo(x: uint, y: uint) -> uint {\n             let z = x + y;\n             return z;\n         }\n-    });\n+    ));\n }\n \n #[test]\n fn test_simplification() {\n     let ext_cx = mk_ctxt();\n-    let item_in = ast::ii_item(#ast[item] {\n+    let item_in = ast::ii_item(quote_item!(\n         fn new_int_alist<B: Copy>() -> alist<int, B> {\n             fn eq_int(&&a: int, &&b: int) -> bool { a == b }\n             return {eq_fn: eq_int, mut data: ~[]};\n         }\n-    });\n+    ).get());\n     let item_out = simplify_ast(item_in);\n-    let item_exp = ast::ii_item(#ast[item] {\n+    let item_exp = ast::ii_item(quote_item!(\n         fn new_int_alist<B: Copy>() -> alist<int, B> {\n             return {eq_fn: eq_int, mut data: ~[]};\n         }\n-    });\n+    ).get());\n     match (item_out, item_exp) {\n       (ast::ii_item(item_out), ast::ii_item(item_exp)) => {\n         assert pprust::item_to_str(item_out, ext_cx.parse_sess().interner)"}, {"sha": "c21aa7d248ea0c50d16dc4ada4db26e4b6f46d1d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -831,24 +831,10 @@ enum matcher_ {\n \n type mac = spanned<mac_>;\n \n-type mac_arg = Option<@expr>;\n-\n-#[auto_serialize]\n-#[auto_deserialize]\n-type mac_body_ = {span: span};\n-\n-type mac_body = Option<mac_body_>;\n-\n #[auto_serialize]\n #[auto_deserialize]\n enum mac_ {\n-    mac_invoc(@path, mac_arg, mac_body), // old macro-invocation\n     mac_invoc_tt(@path,~[token_tree]),   // new macro-invocation\n-    mac_ellipsis,                        // old pattern-match (obsolete)\n-\n-    // the span is used by the quoter/anti-quoter ...\n-    mac_aq(span /* span of quote */, @expr), // anti-quote\n-    mac_var(uint)\n }\n \n type lit = spanned<lit_>;"}, {"sha": "9830a5b1434fbf512e385926f6107eb67d5e364e", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -309,7 +309,7 @@ priv impl ext_ctxt {\n     fn lambda(blk: ast::blk) -> @ast::expr {\n         let ext_cx = self;\n         let blk_e = self.expr(blk.span, ast::expr_block(blk));\n-        #ast{ || $(blk_e) }\n+        quote_expr!( || $blk_e )\n     }\n \n     fn blk(span: span, stmts: ~[@ast::stmt]) -> ast::blk {"}, {"sha": "a5ed1f5e101895b0249e3ea18f64bee52dbf554d", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 52, "deletions": 116, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -13,32 +13,19 @@ use parse::parser;\n use diagnostic::span_handler;\n use codemap::{CodeMap, span, ExpnInfo, ExpandedFrom};\n use ast_util::dummy_sp;\n+use parse::token;\n \n-// obsolete old-style #macro code:\n-//\n-//    syntax_expander, normal, macro_defining, macro_definer,\n-//    builtin\n-//\n // new-style macro! tt code:\n //\n //    syntax_expander_tt, syntax_expander_tt_item, mac_result,\n //    normal_tt, item_tt\n //\n-// also note that ast::mac has way too many cases and can probably\n-// be trimmed down substantially.\n-\n-// second argument is the span to blame for general argument problems\n-type syntax_expander_ =\n-    fn@(ext_ctxt, span, ast::mac_arg, ast::mac_body) -> @ast::expr;\n-// second argument is the origin of the macro, if user-defined\n-type syntax_expander = {expander: syntax_expander_, span: Option<span>};\n+// also note that ast::mac used to have a bunch of extraneous cases and\n+// is now probably a redundant AST node, can be merged with\n+// ast::mac_invoc_tt.\n \n type macro_def = {name: ~str, ext: syntax_extension};\n \n-// macro_definer is obsolete, remove when #old_macros go away.\n-type macro_definer =\n-    fn@(ext_ctxt, span, ast::mac_arg, ast::mac_body) -> macro_def;\n-\n type item_decorator =\n     fn@(ext_ctxt, span, ast::meta_item, ~[@ast::item]) -> ~[@ast::item];\n \n@@ -60,13 +47,7 @@ enum mac_result {\n \n enum syntax_extension {\n \n-    // normal() is obsolete, remove when #old_macros go away.\n-    normal(syntax_expander),\n-\n-    // macro_defining() is obsolete, remove when #old_macros go away.\n-    macro_defining(macro_definer),\n-\n-    // #[auto_serialize] and such. will probably survive death of #old_macros\n+    // #[auto_serialize] and such\n     item_decorator(item_decorator),\n \n     // Token-tree expanders\n@@ -80,37 +61,32 @@ enum syntax_extension {\n // A temporary hard-coded map of methods for expanding syntax extension\n // AST nodes into full ASTs\n fn syntax_expander_table() -> HashMap<~str, syntax_extension> {\n-    fn builtin(f: syntax_expander_) -> syntax_extension\n-        {normal({expander: f, span: None})}\n     fn builtin_normal_tt(f: syntax_expander_tt_) -> syntax_extension {\n         normal_tt({expander: f, span: None})\n     }\n     fn builtin_item_tt(f: syntax_expander_tt_item_) -> syntax_extension {\n         item_tt({expander: f, span: None})\n     }\n     let syntax_expanders = HashMap();\n-    syntax_expanders.insert(~\"macro\",\n-                            macro_defining(ext::simplext::add_new_extension));\n     syntax_expanders.insert(~\"macro_rules\",\n                             builtin_item_tt(\n                                 ext::tt::macro_rules::add_new_extension));\n-    syntax_expanders.insert(~\"fmt\", builtin(ext::fmt::expand_syntax_ext));\n+    syntax_expanders.insert(~\"fmt\",\n+                            builtin_normal_tt(ext::fmt::expand_syntax_ext));\n     syntax_expanders.insert(\n         ~\"auto_serialize\",\n         item_decorator(ext::auto_serialize::expand_auto_serialize));\n     syntax_expanders.insert(\n         ~\"auto_deserialize\",\n         item_decorator(ext::auto_serialize::expand_auto_deserialize));\n-    syntax_expanders.insert(~\"env\", builtin(ext::env::expand_syntax_ext));\n+    syntax_expanders.insert(~\"env\",\n+                            builtin_normal_tt(ext::env::expand_syntax_ext));\n     syntax_expanders.insert(~\"concat_idents\",\n-                            builtin(ext::concat_idents::expand_syntax_ext));\n-    syntax_expanders.insert(~\"ident_to_str\",\n-                            builtin(ext::ident_to_str::expand_syntax_ext));\n+                            builtin_normal_tt(\n+                                ext::concat_idents::expand_syntax_ext));\n     syntax_expanders.insert(~\"log_syntax\",\n                             builtin_normal_tt(\n                                 ext::log_syntax::expand_syntax_ext));\n-    syntax_expanders.insert(~\"ast\",\n-                            builtin(ext::qquote::expand_ast));\n     syntax_expanders.insert(~\"deriving_eq\",\n                             item_decorator(\n                                 ext::deriving::expand_deriving_eq));\n@@ -133,21 +109,29 @@ fn syntax_expander_table() -> HashMap<~str, syntax_extension> {\n                             builtin_normal_tt(ext::quote::expand_quote_stmt));\n \n     syntax_expanders.insert(~\"line\",\n-                            builtin(ext::source_util::expand_line));\n+                            builtin_normal_tt(\n+                                ext::source_util::expand_line));\n     syntax_expanders.insert(~\"col\",\n-                            builtin(ext::source_util::expand_col));\n+                            builtin_normal_tt(\n+                                ext::source_util::expand_col));\n     syntax_expanders.insert(~\"file\",\n-                            builtin(ext::source_util::expand_file));\n+                            builtin_normal_tt(\n+                                ext::source_util::expand_file));\n     syntax_expanders.insert(~\"stringify\",\n-                            builtin(ext::source_util::expand_stringify));\n+                            builtin_normal_tt(\n+                                ext::source_util::expand_stringify));\n     syntax_expanders.insert(~\"include\",\n-                            builtin(ext::source_util::expand_include));\n+                            builtin_normal_tt(\n+                                ext::source_util::expand_include));\n     syntax_expanders.insert(~\"include_str\",\n-                            builtin(ext::source_util::expand_include_str));\n+                            builtin_normal_tt(\n+                                ext::source_util::expand_include_str));\n     syntax_expanders.insert(~\"include_bin\",\n-                            builtin(ext::source_util::expand_include_bin));\n+                            builtin_normal_tt(\n+                                ext::source_util::expand_include_bin));\n     syntax_expanders.insert(~\"module_path\",\n-                            builtin(ext::source_util::expand_mod));\n+                            builtin_normal_tt(\n+                                ext::source_util::expand_mod));\n     syntax_expanders.insert(~\"proto\",\n                             builtin_item_tt(ext::pipes::expand_proto));\n     syntax_expanders.insert(\n@@ -303,87 +287,39 @@ fn expr_to_ident(cx: ext_ctxt,\n     }\n }\n \n-fn get_mac_args_no_max(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n-                       min: uint, name: ~str) -> ~[@ast::expr] {\n-    return get_mac_args(cx, sp, arg, min, None, name);\n+fn check_zero_tts(cx: ext_ctxt, sp: span, tts: &[ast::token_tree],\n+                  name: &str) {\n+    if tts.len() != 0 {\n+        cx.span_fatal(sp, fmt!(\"%s takes no arguments\", name));\n+    }\n }\n \n-fn get_mac_args(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n-                min: uint, max: Option<uint>, name: ~str) -> ~[@ast::expr] {\n-    match arg {\n-      Some(expr) => match expr.node {\n-        ast::expr_vec(elts, _) => {\n-            let elts_len = vec::len(elts);\n-              match max {\n-                Some(max) if ! (min <= elts_len && elts_len <= max) => {\n-                  cx.span_fatal(sp,\n-                                fmt!(\"%s! takes between %u and %u arguments.\",\n-                                     name, min, max));\n-                }\n-                None if ! (min <= elts_len) => {\n-                  cx.span_fatal(sp, fmt!(\"%s! needs at least %u arguments.\",\n-                                         name, min));\n-                }\n-                _ => return elts /* we are good */\n-              }\n-          }\n-        _ => {\n-            cx.span_fatal(sp, fmt!(\"%s!: malformed invocation\", name))\n-        }\n-      },\n-      None => cx.span_fatal(sp, fmt!(\"%s!: missing arguments\", name))\n+fn get_single_str_from_tts(cx: ext_ctxt, sp: span, tts: &[ast::token_tree],\n+                           name: &str) -> ~str {\n+    if tts.len() != 1 {\n+        cx.span_fatal(sp, fmt!(\"%s takes 1 argument.\", name));\n     }\n-}\n \n-fn get_mac_body(cx: ext_ctxt, sp: span, args: ast::mac_body)\n-    -> ast::mac_body_\n-{\n-    match (args) {\n-      Some(body) => body,\n-      None => cx.span_fatal(sp, ~\"missing macro body\")\n+    match tts[0] {\n+        ast::tt_tok(_, token::LIT_STR(ident)) => cx.str_of(ident),\n+        _ =>\n+        cx.span_fatal(sp, fmt!(\"%s requires a string.\", name))\n     }\n }\n \n-// Massage syntactic form of new-style arguments to internal representation\n-// of old-style macro args, such that old-style macro can be run and invoked\n-// using new syntax. This will be obsolete when #old_macros go away.\n-fn tt_args_to_original_flavor(cx: ext_ctxt, sp: span, arg: ~[ast::token_tree])\n-    -> ast::mac_arg {\n-    use ast::{matcher, matcher_, match_tok, match_seq, match_nonterminal};\n-    use parse::lexer::{new_tt_reader, reader};\n-    use tt::macro_parser::{parse_or_else, matched_seq,\n-                              matched_nonterminal};\n-\n-    // these spans won't matter, anyways\n-    fn ms(m: matcher_) -> matcher {\n-        {node: m, span: dummy_sp()}\n+fn get_exprs_from_tts(cx: ext_ctxt, tts: ~[ast::token_tree])\n+    -> ~[@ast::expr] {\n+    let p = parse::new_parser_from_tts(cx.parse_sess(),\n+                                       cx.cfg(),\n+                                       tts);\n+    let mut es = ~[];\n+    while p.token != token::EOF {\n+        if es.len() != 0 {\n+            p.eat(token::COMMA);\n+        }\n+        es.push(p.parse_expr());\n     }\n-    let arg_nm = cx.parse_sess().interner.gensym(@~\"arg\");\n-\n-    let argument_gram = ~[ms(match_seq(~[\n-        ms(match_nonterminal(arg_nm, parse::token::special_idents::expr, 0u))\n-    ], Some(parse::token::COMMA), true, 0u, 1u))];\n-\n-    let arg_reader = new_tt_reader(cx.parse_sess().span_diagnostic,\n-                                   cx.parse_sess().interner, None, arg);\n-    let args =\n-        match parse_or_else(cx.parse_sess(), cx.cfg(), arg_reader as reader,\n-                          argument_gram).get(arg_nm) {\n-          @matched_seq(s, _) => {\n-            do s.map() |lf| {\n-                match *lf {\n-                  @matched_nonterminal(parse::token::nt_expr(arg)) =>\n-                    arg, /* whew! list of exprs, here we come! */\n-                  _ => fail ~\"badly-structured parse result\"\n-                }\n-            }\n-          },\n-          _ => fail ~\"badly-structured parse result\"\n-        };\n-\n-    return Some(@{id: parse::next_node_id(cx.parse_sess()),\n-               callee_id: parse::next_node_id(cx.parse_sess()),\n-               node: ast::expr_vec(args, ast::m_imm), span: sp});\n+    es\n }\n \n //"}, {"sha": "a47b64bea3af109f50c49819d9fce81317fcc3a0", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -10,19 +10,32 @@\n \n use base::*;\n \n-fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n-                     _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args_no_max(cx,sp,arg,1u,~\"concat_idents\");\n+fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+    -> base::mac_result {\n     let mut res_str = ~\"\";\n-    for args.each |e| {\n-        res_str += *cx.parse_sess().interner.get(\n-            expr_to_ident(cx, *e, ~\"expected an ident\"));\n+    for tts.eachi |i, e| {\n+        if i & 1 == 1 {\n+            match *e {\n+                ast::tt_tok(_, token::COMMA) => (),\n+                _ => cx.span_fatal(sp, ~\"concat_idents! \\\n+                                         expecting comma.\")\n+            }\n+        } else {\n+            match *e {\n+                ast::tt_tok(_, token::IDENT(ident,_)) =>\n+                res_str += cx.str_of(ident),\n+                _ => cx.span_fatal(sp, ~\"concat_idents! \\\n+                                         requires ident args.\")\n+            }\n+        }\n     }\n     let res = cx.parse_sess().interner.intern(@res_str);\n \n-    return @{id: cx.next_id(),\n-          callee_id: cx.next_id(),\n-          node: ast::expr_path(@{span: sp, global: false, idents: ~[res],\n-                                 rp: None, types: ~[]}),\n-          span: sp};\n+    let e = @{id: cx.next_id(),\n+              callee_id: cx.next_id(),\n+              node: ast::expr_path(@{span: sp, global: false,\n+                                     idents: ~[res],\n+                                     rp: None, types: ~[]}),\n+              span: sp};\n+    mr_expr(e)\n }"}, {"sha": "68db1b41781e40f6041d53518443eb4f09a33803", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -18,18 +18,19 @@ use base::*;\n use build::mk_uniq_str;\n export expand_syntax_ext;\n \n-fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n-                     _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args(cx, sp, arg, 1u, option::Some(1u), ~\"env\");\n+fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+    -> base::mac_result {\n+\n+    let var = get_single_str_from_tts(cx, sp, tts, \"env!\");\n \n     // FIXME (#2248): if this was more thorough it would manufacture an\n     // Option<str> rather than just an maybe-empty string.\n \n-    let var = expr_to_str(cx, args[0], ~\"env! requires a string\");\n-    match os::getenv(var) {\n-      option::None => return mk_uniq_str(cx, sp, ~\"\"),\n-      option::Some(ref s) => return mk_uniq_str(cx, sp, (*s))\n-    }\n+    let e = match os::getenv(var) {\n+      option::None => mk_uniq_str(cx, sp, ~\"\"),\n+      option::Some(ref s) => mk_uniq_str(cx, sp, (*s))\n+    };\n+    mr_expr(e)\n }\n \n //"}, {"sha": "a35f351451bdc6ee8c5b66af9e0769611befdaaa", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 22, "deletions": 114, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -10,11 +10,10 @@\n \n use std::map::HashMap;\n \n-use ast::{crate, expr_, expr_mac, mac_invoc, mac_invoc_tt,\n+use ast::{crate, expr_, expr_mac, mac_invoc_tt,\n           tt_delim, tt_tok, item_mac, stmt_, stmt_mac, stmt_expr, stmt_semi};\n use fold::*;\n use ext::base::*;\n-use ext::qquote::{qq_helper};\n use parse::{parser, parse_expr_from_source_str, new_parser_from_tts};\n \n \n@@ -32,51 +31,6 @@ fn expand_expr(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n           expr_mac(ref mac) => {\n \n             match (*mac).node {\n-              // Old-style macros. For compatibility, will erase this whole\n-              // block once we've transitioned.\n-              mac_invoc(pth, args, body) => {\n-                assert (vec::len(pth.idents) > 0u);\n-                /* using idents and token::special_idents would make the\n-                the macro names be hygienic */\n-                let extname = cx.parse_sess().interner.get(pth.idents[0]);\n-                match exts.find(*extname) {\n-                  None => {\n-                    cx.span_fatal(pth.span,\n-                                  fmt!(\"macro undefined: '%s'\", *extname))\n-                  }\n-                  Some(item_decorator(_)) => {\n-                    cx.span_fatal(\n-                        pth.span,\n-                        fmt!(\"%s can only be used as a decorator\", *extname));\n-                  }\n-                  Some(normal({expander: exp, span: exp_sp})) => {\n-\n-                    cx.bt_push(ExpandedFrom({call_site: s,\n-                                callie: {name: *extname, span: exp_sp}}));\n-                    let expanded = exp(cx, (*mac).span, args, body);\n-\n-                    //keep going, outside-in\n-                    let fully_expanded = fld.fold_expr(expanded).node;\n-                    cx.bt_pop();\n-\n-                    (fully_expanded, s)\n-                  }\n-                  Some(macro_defining(ext)) => {\n-                    let named_extension = ext(cx, (*mac).span, args, body);\n-                    exts.insert(named_extension.name, named_extension.ext);\n-                    (ast::expr_rec(~[], None), s)\n-                  }\n-                  Some(normal_tt(_)) => {\n-                    cx.span_fatal(pth.span,\n-                                  fmt!(\"this tt-style macro should be \\\n-                                        invoked '%s!(...)'\", *extname))\n-                  }\n-                  Some(item_tt(*)) => {\n-                    cx.span_fatal(pth.span,\n-                                  ~\"cannot use item macros in this context\");\n-                  }\n-                }\n-              }\n \n               // Token-tree macros, these will be the only case when we're\n               // finished transitioning.\n@@ -108,21 +62,6 @@ fn expand_expr(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n \n                     (fully_expanded, s)\n                   }\n-                  Some(normal({expander: exp, span: exp_sp})) => {\n-                    cx.bt_push(ExpandedFrom({call_site: s,\n-                                callie: {name: *extname, span: exp_sp}}));\n-\n-                    //convert the new-style invoc for the old-style macro\n-                    let arg = base::tt_args_to_original_flavor(cx, pth.span,\n-                                                               (*tts));\n-                    let expanded = exp(cx, (*mac).span, arg, None);\n-\n-                    //keep going, outside-in\n-                    let fully_expanded = fld.fold_expr(expanded).node;\n-                    cx.bt_pop();\n-\n-                    (fully_expanded, s)\n-                  }\n                   _ => {\n                     cx.span_fatal(pth.span,\n                                   fmt!(\"'%s' is not a tt-style macro\",\n@@ -131,7 +70,6 @@ fn expand_expr(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n \n                 }\n               }\n-              _ => cx.span_bug((*mac).span, ~\"naked syntactic bit\")\n             }\n           }\n           _ => orig(e, s, fld)\n@@ -166,10 +104,14 @@ fn expand_mod_items(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n               ast::meta_list(ref n, _) => (*n)\n             };\n             match exts.find(mname) {\n-              None | Some(normal(_)) | Some(macro_defining(_))\n-              | Some(normal_tt(_)) | Some(item_tt(*)) => items,\n+              None | Some(normal_tt(_)) | Some(item_tt(*)) => items,\n               Some(item_decorator(dec_fn)) => {\n-                dec_fn(cx, attr.span, attr.node.value, items)\n+                  cx.bt_push(ExpandedFrom({call_site: attr.span,\n+                                           callie: {name: copy mname,\n+                                                    span: None}}));\n+                  let r = dec_fn(cx, attr.span, attr.node.value, items);\n+                  cx.bt_pop();\n+                  r\n               }\n             }\n         }\n@@ -205,36 +147,16 @@ fn expand_item(exts: HashMap<~str, syntax_extension>,\n     }\n }\n \n-// avoid excess indentation when a series of nested `match`es\n-// has only one \"good\" outcome\n-macro_rules! biased_match (\n-    (   ($e    :expr) ~ ($p    :pat) else $err    :stmt ;\n-     $( ($e_cdr:expr) ~ ($p_cdr:pat) else $err_cdr:stmt ; )*\n-     => $body:expr\n-    ) => (\n-        match $e {\n-            $p => {\n-                biased_match!($( ($e_cdr) ~ ($p_cdr) else $err_cdr ; )*\n-                              => $body)\n-            }\n-            _ => { $err }\n-        }\n-    );\n-    ( => $body:expr ) => ( $body )\n-)\n-\n-\n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n fn expand_item_mac(exts: HashMap<~str, syntax_extension>,\n                    cx: ext_ctxt, &&it: @ast::item,\n                    fld: ast_fold) -> Option<@ast::item> {\n-    let (pth, tts) = biased_match!(\n-        (it.node) ~ (item_mac({node: mac_invoc_tt(pth, ref tts), _})) else {\n-            cx.span_bug(it.span, ~\"invalid item macro invocation\")\n-        };\n-        => (pth, (*tts))\n-    );\n+\n+    let (pth, tts) = match it.node {\n+        item_mac({node: mac_invoc_tt(pth, ref tts), _}) => (pth, (*tts)),\n+        _ => cx.span_bug(it.span, ~\"invalid item macro invocation\")\n+    };\n \n     let extname = cx.parse_sess().interner.get(pth.idents[0]);\n     let expanded = match exts.find(*extname) {\n@@ -289,12 +211,15 @@ fn expand_stmt(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n                orig: fn@(&&s: stmt_, span, ast_fold) -> (stmt_, span))\n     -> (stmt_, span)\n {\n-    let (mac, pth, tts, semi) = biased_match! (\n-        (s)        ~ (stmt_mac(ref mac, semi))   else return orig(s, sp, fld);\n-        ((*mac).node) ~ (mac_invoc_tt(pth, ref tts)) else {\n-            cx.span_bug((*mac).span, ~\"naked syntactic bit\")\n-        };\n-        => ((*mac), pth, (*tts), semi));\n+\n+    let (mac, pth, tts, semi) = match s {\n+        stmt_mac(ref mac, semi) => {\n+            match (*mac).node {\n+                mac_invoc_tt(pth, ref tts) => ((*mac), pth, (*tts), semi)\n+            }\n+        }\n+        _ => return orig(s, sp, fld)\n+    };\n \n     assert(vec::len(pth.idents) == 1u);\n     let extname = cx.parse_sess().interner.get(pth.idents[0]);\n@@ -321,23 +246,6 @@ fn expand_stmt(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n             (fully_expanded, sp)\n         }\n \n-        Some(normal({expander: exp, span: exp_sp})) => {\n-            cx.bt_push(ExpandedFrom({call_site: sp,\n-                                      callie: {name: *extname,\n-                                               span: exp_sp}}));\n-            //convert the new-style invoc for the old-style macro\n-            let arg = base::tt_args_to_original_flavor(cx, pth.span, tts);\n-            let exp_expr = exp(cx, mac.span, arg, None);\n-            let expanded = @{node: stmt_expr(exp_expr, cx.next_id()),\n-                             span: exp_expr.span};\n-\n-            //keep going, outside-in\n-            let fully_expanded = fld.fold_stmt(expanded).node;\n-            cx.bt_pop();\n-\n-            (fully_expanded, sp)\n-        }\n-\n         _ => {\n             cx.span_fatal(pth.span,\n                           fmt!(\"'%s' is not a tt-style macro\", *extname))"}, {"sha": "46003624a76e512155bf65f3f693f06b521b3007", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -21,9 +21,12 @@ use codemap::span;\n use ext::build::*;\n export expand_syntax_ext;\n \n-fn expand_syntax_ext(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n-                     _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args_no_max(cx, sp, arg, 1u, ~\"fmt\");\n+fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+    -> base::mac_result {\n+    let args = get_exprs_from_tts(cx, copy tts);\n+    if args.len() == 0 {\n+        cx.span_fatal(sp, \"fmt! takes at least 1 argument.\");\n+    }\n     let fmt =\n         expr_to_str(cx, args[0],\n                     ~\"first argument to fmt! must be a string literal.\");\n@@ -37,7 +40,7 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n         parse_fmt_err_(cx, fmtspan, s)\n     };\n     let pieces = parse_fmt_string(fmt, parse_fmt_err);\n-    return pieces_to_expr(cx, sp, pieces, args);\n+    mr_expr(pieces_to_expr(cx, sp, pieces, args))\n }\n \n // FIXME (#2249): A lot of these functions for producing expressions can"}, {"sha": "ededc1a5f7ffc7263ce106884e8852b79ae1da9b", "filename": "src/libsyntax/ext/ident_to_str.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0138d87f8f1b9f9614e439deb14cbaabad6d104c/src%2Flibsyntax%2Fext%2Fident_to_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0138d87f8f1b9f9614e439deb14cbaabad6d104c/src%2Flibsyntax%2Fext%2Fident_to_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fident_to_str.rs?ref=0138d87f8f1b9f9614e439deb14cbaabad6d104c", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use base::*;\n-use build::mk_uniq_str;\n-\n-fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n-                     _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args(cx,sp,arg,1u,option::Some(1u),~\"ident_to_str\");\n-\n-    return mk_uniq_str(cx, sp, *cx.parse_sess().interner.get(\n-        expr_to_ident(cx, args[0u], ~\"expected an ident\")));\n-}"}, {"sha": "e13dfe750b790484dcf5b38282b42e81ef3dd37a", "filename": "src/libsyntax/ext/qquote.rs", "status": "removed", "additions": 0, "deletions": 370, "changes": 370, "blob_url": "https://github.com/rust-lang/rust/blob/0138d87f8f1b9f9614e439deb14cbaabad6d104c/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0138d87f8f1b9f9614e439deb14cbaabad6d104c/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=0138d87f8f1b9f9614e439deb14cbaabad6d104c", "patch": "@@ -1,370 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use ast::{crate, expr_, mac_invoc,\n-                     mac_aq, mac_var};\n-use parse::parser;\n-use parse::parser::{Parser, parse_from_source_str};\n-use dvec::DVec;\n-use parse::token::ident_interner;\n-use codemap::{CharPos, BytePos};\n-\n-use fold::*;\n-use visit::*;\n-use ext::base::*;\n-use ext::build::*;\n-use print::*;\n-use io::*;\n-\n-use codemap::span;\n-\n-struct gather_item {\n-    lo: BytePos,\n-    hi: BytePos,\n-    e: @ast::expr,\n-    constr: ~str\n-}\n-\n-type aq_ctxt = @{lo: BytePos, gather: DVec<gather_item>};\n-enum fragment {\n-    from_expr(@ast::expr),\n-    from_ty(@ast::Ty)\n-}\n-\n-fn ids_ext(cx: ext_ctxt, strs: ~[~str]) -> ~[ast::ident] {\n-    strs.map(|str| cx.parse_sess().interner.intern(@*str))\n-}\n-fn id_ext(cx: ext_ctxt, str: ~str) -> ast::ident {\n-    cx.parse_sess().interner.intern(@str)\n-}\n-\n-\n-trait qq_helper {\n-    fn span() -> span;\n-    fn visit(aq_ctxt, vt<aq_ctxt>);\n-    fn extract_mac() -> Option<ast::mac_>;\n-    fn mk_parse_fn(ext_ctxt,span) -> @ast::expr;\n-    fn get_fold_fn() -> ~str;\n-}\n-\n-impl @ast::crate: qq_helper {\n-    fn span() -> span {self.span}\n-    fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_crate(*self, cx, v);}\n-    fn extract_mac() -> Option<ast::mac_> {fail}\n-    fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp,\n-                ids_ext(cx, ~[~\"syntax\", ~\"ext\", ~\"qquote\", ~\"parse_crate\"]))\n-    }\n-    fn get_fold_fn() -> ~str {~\"fold_crate\"}\n-}\n-impl @ast::expr: qq_helper {\n-    fn span() -> span {self.span}\n-    fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_expr(self, cx, v);}\n-    fn extract_mac() -> Option<ast::mac_> {\n-        match (self.node) {\n-          ast::expr_mac({node: ref mac, _}) => Some((*mac)),\n-          _ => None\n-        }\n-    }\n-    fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp,\n-                ids_ext(cx, ~[~\"syntax\", ~\"ext\", ~\"qquote\", ~\"parse_expr\"]))\n-    }\n-    fn get_fold_fn() -> ~str {~\"fold_expr\"}\n-}\n-impl @ast::Ty: qq_helper {\n-    fn span() -> span {self.span}\n-    fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_ty(self, cx, v);}\n-    fn extract_mac() -> Option<ast::mac_> {\n-        match (self.node) {\n-          ast::ty_mac({node: ref mac, _}) => Some((*mac)),\n-          _ => None\n-        }\n-    }\n-    fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp,\n-                ids_ext(cx, ~[~\"syntax\", ~\"ext\", ~\"qquote\", ~\"parse_ty\"]))\n-    }\n-    fn get_fold_fn() -> ~str {~\"fold_ty\"}\n-}\n-impl @ast::item: qq_helper {\n-    fn span() -> span {self.span}\n-    fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_item(self, cx, v);}\n-    fn extract_mac() -> Option<ast::mac_> {fail}\n-    fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp,\n-                ids_ext(cx, ~[~\"syntax\", ~\"ext\", ~\"qquote\", ~\"parse_item\"]))\n-    }\n-    fn get_fold_fn() -> ~str {~\"fold_item\"}\n-}\n-impl @ast::stmt: qq_helper {\n-    fn span() -> span {self.span}\n-    fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_stmt(self, cx, v);}\n-    fn extract_mac() -> Option<ast::mac_> {fail}\n-    fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp,\n-                ids_ext(cx, ~[~\"syntax\", ~\"ext\", ~\"qquote\", ~\"parse_stmt\"]))\n-    }\n-    fn get_fold_fn() -> ~str {~\"fold_stmt\"}\n-}\n-impl @ast::pat: qq_helper {\n-    fn span() -> span {self.span}\n-    fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_pat(self, cx, v);}\n-    fn extract_mac() -> Option<ast::mac_> {fail}\n-    fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp, ids_ext(cx, ~[~\"syntax\", ~\"ext\", ~\"qquote\",\n-                                      ~\"parse_pat\"]))\n-    }\n-    fn get_fold_fn() -> ~str {~\"fold_pat\"}\n-}\n-\n-fn gather_anti_quotes<N: qq_helper>(lo: BytePos, node: N) -> aq_ctxt\n-{\n-    let v = @{visit_expr: |node, &&cx, v| visit_aq(node, ~\"from_expr\", cx, v),\n-              visit_ty: |node, &&cx, v| visit_aq(node, ~\"from_ty\", cx, v),\n-              .. *default_visitor()};\n-    let cx = @{lo:lo, gather: DVec()};\n-    node.visit(cx, mk_vt(v));\n-    // FIXME (#2250): Maybe this is an overkill (merge_sort), it might\n-    // be better to just keep the gather array in sorted order.\n-    do cx.gather.swap |v| {\n-        pure fn by_lo(a: &gather_item, b: &gather_item) -> bool {\n-            a.lo < b.lo\n-        }\n-        std::sort::merge_sort(v, by_lo)\n-    };\n-    return cx;\n-}\n-\n-fn visit_aq<T:qq_helper>(node: T, constr: ~str, &&cx: aq_ctxt, v: vt<aq_ctxt>)\n-{\n-    match (node.extract_mac()) {\n-      Some(mac_aq(sp, e)) => {\n-        cx.gather.push(gather_item {\n-            lo: sp.lo - cx.lo,\n-            hi: sp.hi - cx.lo,\n-            e: e,\n-            constr: constr});\n-      }\n-      _ => node.visit(cx, v)\n-    }\n-}\n-\n-fn is_space(c: char) -> bool {\n-    parse::lexer::is_whitespace(c)\n-}\n-\n-fn expand_ast(ecx: ext_ctxt, _sp: span,\n-              arg: ast::mac_arg, body: ast::mac_body)\n-    -> @ast::expr\n-{\n-    let mut what = ~\"expr\";\n-    do arg.iter |arg| {\n-        let args: ~[@ast::expr] =\n-            match arg.node {\n-              ast::expr_vec(elts, _) => elts,\n-              _ => {\n-                ecx.span_fatal\n-                    (_sp, ~\"#ast requires arguments of the form `~[...]`.\")\n-              }\n-            };\n-        if vec::len::<@ast::expr>(args) != 1u {\n-            ecx.span_fatal(_sp, ~\"#ast requires exactly one arg\");\n-        }\n-        match (args[0].node) {\n-          ast::expr_path(@{idents: id, _}) if vec::len(id) == 1u\n-            => what = *ecx.parse_sess().interner.get(id[0]),\n-          _ => ecx.span_fatal(args[0].span, ~\"expected an identifier\")\n-        }\n-    }\n-    let body = get_mac_body(ecx,_sp,body);\n-\n-    return match what {\n-      ~\"crate\" => finish(ecx, body, parse_crate),\n-      ~\"expr\" => finish(ecx, body, parse_expr),\n-      ~\"ty\" => finish(ecx, body, parse_ty),\n-      ~\"item\" => finish(ecx, body, parse_item),\n-      ~\"stmt\" => finish(ecx, body, parse_stmt),\n-      ~\"pat\" => finish(ecx, body, parse_pat),\n-      _ => ecx.span_fatal(_sp, ~\"unsupported ast type\")\n-    };\n-}\n-\n-fn parse_crate(p: Parser) -> @ast::crate { p.parse_crate_mod(~[]) }\n-fn parse_ty(p: Parser) -> @ast::Ty { p.parse_ty(false) }\n-fn parse_stmt(p: Parser) -> @ast::stmt { p.parse_stmt(~[]) }\n-fn parse_expr(p: Parser) -> @ast::expr { p.parse_expr() }\n-fn parse_pat(p: Parser) -> @ast::pat { p.parse_pat(true) }\n-\n-fn parse_item(p: Parser) -> @ast::item {\n-    match p.parse_item(~[]) {\n-      Some(item) => item,\n-      None       => fail ~\"parse_item: parsing an item failed\"\n-    }\n-}\n-\n-fn finish<T: qq_helper>\n-    (ecx: ext_ctxt, body: ast::mac_body_, f: fn (p: Parser) -> T)\n-    -> @ast::expr\n-{\n-    let cm = ecx.codemap();\n-    let str = @cm.span_to_snippet(body.span);\n-    debug!(\"qquote--str==%?\", str);\n-    let fname = cm.mk_substr_filename(body.span);\n-    let node = parse_from_source_str\n-        (f, fname, codemap::FssInternal(body.span), str,\n-         ecx.cfg(), ecx.parse_sess());\n-    let loc = cm.lookup_char_pos(body.span.lo);\n-\n-    let sp = node.span();\n-    let qcx = gather_anti_quotes(sp.lo, node);\n-    let cx = qcx;\n-\n-    for uint::range(1u, cx.gather.len()) |i| {\n-        assert cx.gather[i-1u].lo < cx.gather[i].lo;\n-        // ^^ check that the vector is sorted\n-        assert cx.gather[i-1u].hi <= cx.gather[i].lo;\n-        // ^^ check that the spans are non-overlapping\n-    }\n-\n-    let mut str2 = ~\"\";\n-    enum state {active, skip(uint), blank};\n-    let mut state = active;\n-    let mut i = BytePos(0u);\n-    let mut j = 0u;\n-    let g_len = cx.gather.len();\n-    for str::chars_each(*str) |ch| {\n-        if (j < g_len && i == cx.gather[j].lo) {\n-            assert ch == '$';\n-            let repl = fmt!(\"$%u \", j);\n-            state = skip(str::char_len(repl));\n-            str2 += repl;\n-        }\n-        match copy state {\n-          active => str::push_char(&mut str2, ch),\n-          skip(1u) => state = blank,\n-          skip(sk) => state = skip (sk-1u),\n-          blank if is_space(ch) => str::push_char(&mut str2, ch),\n-          blank => str::push_char(&mut str2, ' ')\n-        }\n-        i += BytePos(1u);\n-        if (j < g_len && i == cx.gather[j].hi) {\n-            assert ch == ')';\n-            state = active;\n-            j += 1u;\n-        }\n-    }\n-\n-    let cx = ecx;\n-\n-    let cfg_call = || mk_call_(\n-        cx, sp, mk_access(cx, sp, ids_ext(cx, ~[~\"ext_cx\"]),\n-                          id_ext(cx, ~\"cfg\")), ~[]);\n-\n-    let parse_sess_call = || mk_call_(\n-        cx, sp, mk_access(cx, sp, ids_ext(cx, ~[~\"ext_cx\"]),\n-                          id_ext(cx, ~\"parse_sess\")), ~[]);\n-\n-    let pcall = mk_call(cx,sp,\n-                       ids_ext(cx, ~[~\"syntax\", ~\"parse\", ~\"parser\",\n-                        ~\"parse_from_source_str\"]),\n-                       ~[node.mk_parse_fn(cx,sp),\n-                        mk_uniq_str(cx,sp, fname),\n-                        mk_call(cx,sp,\n-                                ids_ext(cx, ~[~\"syntax\",~\"ext\",\n-                                 ~\"qquote\", ~\"mk_file_substr\"]),\n-                                ~[mk_uniq_str(cx,sp, loc.file.name),\n-                                 mk_uint(cx,sp, loc.line),\n-                                 mk_uint(cx,sp, loc.col.to_uint())]),\n-                        mk_unary(cx,sp, ast::box(ast::m_imm),\n-                                 mk_uniq_str(cx,sp, str2)),\n-                        cfg_call(),\n-                        parse_sess_call()]\n-                      );\n-    let mut rcall = pcall;\n-    if (g_len > 0u) {\n-        rcall = mk_call(cx,sp,\n-                        ids_ext(cx, ~[~\"syntax\", ~\"ext\", ~\"qquote\",\n-                                      ~\"replace\"]),\n-                        ~[pcall,\n-                          mk_uniq_vec_e(cx,sp, qcx.gather.map_to_vec(|g| {\n-                             mk_call(cx,sp,\n-                                     ids_ext(cx, ~[~\"syntax\", ~\"ext\",\n-                                                   ~\"qquote\", g.constr]),\n-                                     ~[g.e])})),\n-                         mk_path(cx,sp,\n-                                 ids_ext(cx, ~[~\"syntax\", ~\"ext\", ~\"qquote\",\n-                                               node.get_fold_fn()]))]);\n-    }\n-    return rcall;\n-}\n-\n-fn replace<T>(node: T, repls: ~[fragment], ff: fn (ast_fold, T) -> T)\n-    -> T\n-{\n-    let aft = default_ast_fold();\n-    let f_pre = @{fold_expr: |a,b,c|replace_expr(repls, a, b, c,\n-                                                  aft.fold_expr),\n-                  fold_ty: |a,b,c|replace_ty(repls, a, b, c,\n-                                              aft.fold_ty),\n-                  .. *aft};\n-    return ff(make_fold(f_pre), node);\n-}\n-fn fold_crate(f: ast_fold, &&n: @ast::crate) -> @ast::crate {\n-    @f.fold_crate(*n)\n-}\n-fn fold_expr(f: ast_fold, &&n: @ast::expr) -> @ast::expr {f.fold_expr(n)}\n-fn fold_ty(f: ast_fold, &&n: @ast::Ty) -> @ast::Ty {f.fold_ty(n)}\n-fn fold_item(f: ast_fold, &&n: @ast::item) -> @ast::item {\n-    f.fold_item(n).get() //HACK: we know we don't drop items\n-}\n-fn fold_stmt(f: ast_fold, &&n: @ast::stmt) -> @ast::stmt {f.fold_stmt(n)}\n-fn fold_pat(f: ast_fold, &&n: @ast::pat) -> @ast::pat {f.fold_pat(n)}\n-\n-fn replace_expr(repls: ~[fragment],\n-                e: ast::expr_, s: span, fld: ast_fold,\n-                orig: fn@(ast::expr_, span, ast_fold)->(ast::expr_, span))\n-    -> (ast::expr_, span)\n-{\n-    match e {\n-      ast::expr_mac({node: mac_var(i), _}) => match (repls[i]) {\n-        from_expr(r) => (r.node, r.span),\n-        _ => fail /* fixme error message */\n-      },\n-      _ => orig(e,s,fld)\n-    }\n-}\n-\n-fn replace_ty(repls: ~[fragment],\n-                e: ast::ty_, s: span, fld: ast_fold,\n-                orig: fn@(ast::ty_, span, ast_fold)->(ast::ty_, span))\n-    -> (ast::ty_, span)\n-{\n-    match e {\n-      ast::ty_mac({node: mac_var(i), _}) => match (repls[i]) {\n-        from_ty(r) => (r.node, r.span),\n-        _ => fail /* fixme error message */\n-      },\n-      _ => orig(e,s,fld)\n-    }\n-}\n-\n-fn mk_file_substr(fname: ~str, line: uint, col: uint) ->\n-    codemap::FileSubstr {\n-    codemap::FssExternal({filename: fname, line: line, col: CharPos(col)})\n-}\n-\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "1e5d4ea8d16f884f863b4f1864156fe5225b052f", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -406,7 +406,6 @@ fn mk_token(cx: ext_ctxt, sp: span, tok: token::Token) -> @ast::expr {\n         AT => \"AT\",\n         DOT => \"DOT\",\n         DOTDOT => \"DOTDOT\",\n-        ELLIPSIS => \"ELLIPSIS\",\n         COMMA => \"COMMA\",\n         SEMI => \"SEMI\",\n         COLON => \"COLON\","}, {"sha": "f13c5c9aff9ea228c0f90f5cd4b01e35c2d51723", "filename": "src/libsyntax/ext/simplext.rs", "status": "removed", "additions": 0, "deletions": 750, "changes": 750, "blob_url": "https://github.com/rust-lang/rust/blob/0138d87f8f1b9f9614e439deb14cbaabad6d104c/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0138d87f8f1b9f9614e439deb14cbaabad6d104c/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=0138d87f8f1b9f9614e439deb14cbaabad6d104c", "patch": "@@ -1,750 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use codemap::span;\n-use std::map::HashMap;\n-use dvec::DVec;\n-\n-use base::*;\n-\n-use fold::*;\n-use ast_util::respan;\n-use ast::{ident, path, Ty, blk_, expr, expr_path,\n-             expr_vec, expr_mac, mac_invoc, node_id, expr_index};\n-\n-export add_new_extension;\n-\n-fn path_to_ident(pth: @path) -> Option<ident> {\n-    if vec::len(pth.idents) == 1u && vec::len(pth.types) == 0u {\n-        return Some(pth.idents[0u]);\n-    }\n-    return None;\n-}\n-\n-//a vec of binders might be a little big.\n-type clause = {params: binders, body: @expr};\n-\n-/* logically, an arb_depth should contain only one kind of matchable */\n-enum arb_depth<T> { leaf(T), seq(@~[arb_depth<T>], span), }\n-\n-\n-enum matchable {\n-    match_expr(@expr),\n-    match_path(@path),\n-    match_ident(ast::spanned<ident>),\n-    match_ty(@Ty),\n-    match_block(ast::blk),\n-    match_exact, /* don't bind anything, just verify the AST traversal */\n-}\n-\n-/* for when given an incompatible bit of AST */\n-fn match_error(cx: ext_ctxt, m: matchable, expected: ~str) -> ! {\n-    match m {\n-      match_expr(x) => cx.span_fatal(\n-          x.span, ~\"this argument is an expr, expected \" + expected),\n-      match_path(x) => cx.span_fatal(\n-          x.span, ~\"this argument is a path, expected \" + expected),\n-      match_ident(x) => cx.span_fatal(\n-          x.span, ~\"this argument is an ident, expected \" + expected),\n-      match_ty(x) => cx.span_fatal(\n-          x.span, ~\"this argument is a type, expected \" + expected),\n-      match_block(ref x) => cx.span_fatal(\n-          (*x).span, ~\"this argument is a block, expected \" + expected),\n-      match_exact => cx.bug(~\"what is a match_exact doing in a bindings?\")\n-    }\n-}\n-\n-// We can't make all the matchables in a match_result the same type because\n-// idents can be paths, which can be exprs.\n-\n-// If we want better match failure error messages (like in Fortifying Syntax),\n-// we'll want to return something indicating amount of progress and location\n-// of failure instead of `none`.\n-type match_result = Option<arb_depth<matchable>>;\n-type selector = fn@(matchable) -> match_result;\n-\n-fn elts_to_ell(cx: ext_ctxt, elts: ~[@expr]) ->\n-   {pre: ~[@expr], rep: Option<@expr>, post: ~[@expr]} {\n-    let mut idx: uint = 0u;\n-    let mut res = None;\n-    for elts.each |elt| {\n-        match elt.node {\n-          expr_mac(ref m) => match (*m).node {\n-            ast::mac_ellipsis => {\n-                if res.is_some() {\n-                    cx.span_fatal((*m).span, ~\"only one ellipsis allowed\");\n-                }\n-                res =\n-                    Some({pre: vec::slice(elts, 0u, idx - 1u),\n-                          rep: Some(elts[idx - 1u]),\n-                          post: vec::slice(elts, idx + 1u, vec::len(elts))});\n-            }\n-            _ => ()\n-          },\n-          _ => ()\n-        }\n-        idx += 1u;\n-    }\n-    return match res {\n-          Some(val) => val,\n-          None => {pre: elts, rep: None, post: ~[]}\n-    }\n-}\n-\n-fn option_flatten_map<T: Copy, U: Copy>(f: fn@(T) -> Option<U>, v: ~[T]) ->\n-   Option<~[U]> {\n-    let mut res = ~[];\n-    for v.each |elem| {\n-        match f(*elem) {\n-          None => return None,\n-          Some(ref fv) => res.push((*fv))\n-        }\n-    }\n-    return Some(res);\n-}\n-\n-fn a_d_map(ad: arb_depth<matchable>, f: selector) -> match_result {\n-    match ad {\n-      leaf(ref x) => return f((*x)),\n-      seq(ads, span) => match option_flatten_map(|x| a_d_map(x, f), *ads) {\n-        None => return None,\n-        Some(ts) => return Some(seq(@ts, span))\n-      }\n-    }\n-}\n-\n-fn compose_sels(s1: selector, s2: selector) -> selector {\n-    fn scomp(s1: selector, s2: selector, m: matchable) -> match_result {\n-        return match s1(m) {\n-              None => None,\n-              Some(ref matches) => a_d_map((*matches), s2)\n-            }\n-    }\n-    return { |x| scomp(s1, s2, x) };\n-}\n-\n-\n-\n-type binders =\n-    {real_binders: HashMap<ident, selector>,\n-     literal_ast_matchers: DVec<selector>};\n-type bindings = HashMap<ident, arb_depth<matchable>>;\n-\n-fn acumm_bindings(_cx: ext_ctxt, _b_dest: bindings, _b_src: bindings) { }\n-\n-/* these three functions are the big moving parts */\n-\n-/* create the selectors needed to bind and verify the pattern */\n-\n-fn pattern_to_selectors(cx: ext_ctxt, e: @expr) -> binders {\n-    let res: binders =\n-        {real_binders: HashMap(),\n-         literal_ast_matchers: DVec()};\n-    //this oughta return binders instead, but macro args are a sequence of\n-    //expressions, rather than a single expression\n-    fn trivial_selector(m: matchable) -> match_result {\n-        return Some(leaf(m));\n-    }\n-    p_t_s_rec(cx, match_expr(e), trivial_selector, res);\n-    move res\n-}\n-\n-\n-\n-/* use the selectors on the actual arguments to the macro to extract\n-bindings. Most of the work is done in p_t_s, which generates the\n-selectors. */\n-\n-fn use_selectors_to_bind(b: binders, e: @expr) -> Option<bindings> {\n-    let res = HashMap();\n-    //need to do this first, to check vec lengths.\n-    for b.literal_ast_matchers.each |sel| {\n-        match (*sel)(match_expr(e)) { None => return None, _ => () }\n-    }\n-    let mut never_mind: bool = false;\n-    for b.real_binders.each |key, val| {\n-        match val(match_expr(e)) {\n-          None => never_mind = true,\n-          Some(ref mtc) => { res.insert(key, (*mtc)); }\n-        }\n-    };\n-    //HACK: `ret` doesn't work in `for each`\n-    if never_mind { return None; }\n-    return Some(res);\n-}\n-\n-/* use the bindings on the body to generate the expanded code */\n-\n-fn transcribe(cx: ext_ctxt, b: bindings, body: @expr) -> @expr {\n-    let idx_path: @mut ~[uint] = @mut ~[];\n-    fn new_id(_old: node_id, cx: ext_ctxt) -> node_id { return cx.next_id(); }\n-    fn new_span(cx: ext_ctxt, sp: span) -> span {\n-        /* this discards information in the case of macro-defining macros */\n-        return span {lo: sp.lo, hi: sp.hi, expn_info: cx.backtrace()};\n-    }\n-    let afp = default_ast_fold();\n-    let f_pre =\n-        @{fold_ident: |x,y|transcribe_ident(cx, b, idx_path, x, y),\n-          fold_path: |x,y|transcribe_path(cx, b, idx_path, x, y),\n-          fold_expr: |x,y,z|\n-              transcribe_expr(cx, b, idx_path, x, y, z, afp.fold_expr)\n-          ,\n-          fold_ty: |x,y,z|\n-              transcribe_type(cx, b, idx_path,\n-                              x, y, z, afp.fold_ty)\n-          ,\n-          fold_block: |x,y,z|\n-              transcribe_block(cx, b, idx_path, x, y, z, afp.fold_block)\n-          ,\n-          map_exprs: |x,y|\n-              transcribe_exprs(cx, b, idx_path, x, y)\n-          ,\n-          new_id: |x|new_id(x, cx),\n-          .. *afp};\n-    let f = make_fold(f_pre);\n-    let result = f.fold_expr(body);\n-    return result;\n-}\n-\n-\n-/* helper: descend into a matcher */\n-pure fn follow(m: arb_depth<matchable>, idx_path: &[uint]) ->\n-   arb_depth<matchable> {\n-    let mut res: arb_depth<matchable> = m;\n-    for vec::each(idx_path) |idx| {\n-        res = match res {\n-          leaf(_) => return res,/* end of the line */\n-          seq(new_ms, _) => new_ms[*idx]\n-        }\n-    }\n-    return res;\n-}\n-\n-fn follow_for_trans(cx: ext_ctxt, mmaybe: Option<arb_depth<matchable>>,\n-                    idx_path: @mut ~[uint]) -> Option<matchable> {\n-    match mmaybe {\n-      None => return None,\n-      Some(ref m) => {\n-        return match follow((*m), *idx_path) {\n-              seq(_, sp) => {\n-                cx.span_fatal(sp,\n-                              ~\"syntax matched under ... but not \" +\n-                                  ~\"used that way.\")\n-              }\n-              leaf(ref m) => return Some((*m))\n-            }\n-      }\n-    }\n-\n-}\n-\n-/* helper for transcribe_exprs: what vars from `b` occur in `e`? */\n-fn free_vars(b: bindings, e: @expr, it: fn(ident)) {\n-    let idents = HashMap();\n-    fn mark_ident(&&i: ident, _fld: ast_fold, b: bindings,\n-                  idents: HashMap<ident, ()>) -> ident {\n-        if b.contains_key(i) { idents.insert(i, ()); }\n-        return i;\n-    }\n-    // using fold is a hack: we want visit, but it doesn't hit idents ) :\n-    // solve this with macros\n-    let f_pre =\n-        @{fold_ident: |x,y|mark_ident(x, y, b, idents),\n-          .. *default_ast_fold()};\n-    let f = make_fold(f_pre);\n-    f.fold_expr(e); // ignore result\n-    for idents.each_key |x| { it(x); };\n-}\n-\n-fn wrong_occurs(cx: ext_ctxt, l: ident, l_c: uint, r: ident, r_c: uint)\n-    -> ~str {\n-    fmt!(\"'%s' occurs %u times, but '%s' occurs %u times\",\n-         *cx.parse_sess().interner.get(l), l_c,\n-         *cx.parse_sess().interner.get(r), r_c)\n-}\n-\n-/* handle sequences (anywhere in the AST) of exprs, either real or ...ed */\n-fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n-                    recur: fn@(&&v: @expr) -> @expr,\n-                    exprs: ~[@expr]) -> ~[@expr] {\n-    match elts_to_ell(cx, exprs) {\n-      {pre: pre, rep: repeat_me_maybe, post: post} => {\n-        let mut res = vec::map(pre, |x| recur(*x));\n-        match repeat_me_maybe {\n-          None => (),\n-          Some(repeat_me) => {\n-            let mut repeat: Option<{rep_count: uint, name: ident}> = None;\n-            /* we need to walk over all the free vars in lockstep, except for\n-            the leaves, which are just duplicated */\n-            do free_vars(b, repeat_me) |fv| {\n-                let fv_depth = b.get(fv);\n-                let cur_pos = follow(fv_depth, *idx_path);\n-                match cur_pos {\n-                  leaf(_) => (),\n-                  seq(ms, _) => {\n-                    match repeat {\n-                      None => {\n-                        repeat = Some({rep_count: vec::len(*ms), name: fv});\n-                      }\n-                      Some({rep_count: old_len, name: old_name}) => {\n-                        let len = vec::len(*ms);\n-                        if old_len != len {\n-                            let msg = wrong_occurs(cx, fv, len,\n-                                                   old_name, old_len);\n-                            cx.span_fatal(repeat_me.span, msg);\n-                        }\n-                      }\n-                    }\n-                  }\n-                }\n-            };\n-            match repeat {\n-              None => {\n-                cx.span_fatal(repeat_me.span,\n-                              ~\"'...' surrounds an expression without any\" +\n-                                  ~\" repeating syntax variables\");\n-              }\n-              Some({rep_count: rc, _}) => {\n-                /* Whew, we now know how how many times to repeat */\n-                let mut idx: uint = 0u;\n-                while idx < rc {\n-                    idx_path.push(idx);\n-                    res.push(recur(repeat_me)); // whew!\n-                    idx_path.pop();\n-                    idx += 1u;\n-                }\n-              }\n-            }\n-          }\n-        }\n-        res = vec::append(res, vec::map(post, |x| recur(*x)));\n-        return res;\n-      }\n-    }\n-}\n-\n-\n-\n-// substitute, in a position that's required to be an ident\n-fn transcribe_ident(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n-                    &&i: ident, _fld: ast_fold) -> ident {\n-    return match follow_for_trans(cx, b.find(i), idx_path) {\n-          Some(match_ident(a_id)) => a_id.node,\n-          Some(ref m) => match_error(cx, (*m), ~\"an identifier\"),\n-          None => i\n-        }\n-}\n-\n-\n-fn transcribe_path(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n-                   p: path, _fld: ast_fold) -> path {\n-    // Don't substitute into qualified names.\n-    if vec::len(p.types) > 0u || vec::len(p.idents) != 1u { return p; }\n-    match follow_for_trans(cx, b.find(p.idents[0]), idx_path) {\n-      Some(match_ident(id)) => {\n-        {span: id.span, global: false, idents: ~[id.node],\n-         rp: None, types: ~[]}\n-      }\n-      Some(match_path(a_pth)) => *a_pth,\n-      Some(ref m) => match_error(cx, (*m), ~\"a path\"),\n-      None => p\n-    }\n-}\n-\n-\n-fn transcribe_expr(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n-                   e: ast::expr_, s: span, fld: ast_fold,\n-                   orig: fn@(ast::expr_, span, ast_fold)->(ast::expr_, span))\n-    -> (ast::expr_, span)\n-{\n-    return match e {\n-          expr_path(p) => {\n-            // Don't substitute into qualified names.\n-            if vec::len(p.types) > 0u || vec::len(p.idents) != 1u {\n-                (e, s);\n-            }\n-            match follow_for_trans(cx, b.find(p.idents[0]), idx_path) {\n-              Some(match_ident(id)) => {\n-                (expr_path(@{span: id.span,\n-                             global: false,\n-                             idents: ~[id.node],\n-                             rp: None,\n-                             types: ~[]}), id.span)\n-              }\n-              Some(match_path(a_pth)) => (expr_path(a_pth), s),\n-              Some(match_expr(a_exp)) => (a_exp.node, a_exp.span),\n-              Some(ref m) => match_error(cx, (*m), ~\"an expression\"),\n-              None => orig(e, s, fld)\n-            }\n-          }\n-          _ => orig(e, s, fld)\n-        }\n-}\n-\n-fn transcribe_type(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n-                   t: ast::ty_, s: span, fld: ast_fold,\n-                   orig: fn@(ast::ty_, span, ast_fold) -> (ast::ty_, span))\n-    -> (ast::ty_, span)\n-{\n-    return match t {\n-          ast::ty_path(pth, _) => {\n-            match path_to_ident(pth) {\n-              Some(id) => {\n-                match follow_for_trans(cx, b.find(id), idx_path) {\n-                  Some(match_ty(ty)) => (ty.node, ty.span),\n-                  Some(ref m) => match_error(cx, (*m), ~\"a type\"),\n-                  None => orig(t, s, fld)\n-                }\n-              }\n-              None => orig(t, s, fld)\n-            }\n-          }\n-          _ => orig(t, s, fld)\n-        }\n-}\n-\n-\n-/* for parsing reasons, syntax variables bound to blocks must be used like\n-`{v}` */\n-\n-fn transcribe_block(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n-                    blk: blk_, s: span, fld: ast_fold,\n-                    orig: fn@(blk_, span, ast_fold) -> (blk_, span))\n-    -> (blk_, span)\n-{\n-    return match block_to_ident(blk) {\n-          Some(id) => {\n-            match follow_for_trans(cx, b.find(id), idx_path) {\n-              Some(match_block(ref new_blk)) => {\n-                ((*new_blk).node, (*new_blk).span)\n-              }\n-\n-              // possibly allow promotion of ident/path/expr to blocks?\n-              Some(ref m) => match_error(cx, (*m), ~\"a block\"),\n-              None => orig(blk, s, fld)\n-            }\n-          }\n-          None => orig(blk, s, fld)\n-        }\n-}\n-\n-\n-/* traverse the pattern, building instructions on how to bind the actual\n-argument. ps accumulates instructions on navigating the tree.*/\n-fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n-\n-    //it might be possible to traverse only exprs, not matchables\n-    match m {\n-      match_expr(e) => {\n-        match e.node {\n-          expr_path(p_pth) => p_t_s_r_path(cx, p_pth, s, b),\n-          expr_vec(p_elts, _) => {\n-            match elts_to_ell(cx, p_elts) {\n-              {pre: pre, rep: Some(repeat_me), post: post} => {\n-                p_t_s_r_length(cx, vec::len(pre) + vec::len(post), true, s,\n-                               b);\n-                if vec::len(pre) > 0u {\n-                    p_t_s_r_actual_vector(cx, pre, true, s, b);\n-                }\n-                p_t_s_r_ellipses(cx, repeat_me, vec::len(pre), s, b);\n-\n-                if vec::len(post) > 0u {\n-                    cx.span_unimpl(e.span,\n-                                   ~\"matching after `...` not yet supported\");\n-                }\n-              }\n-              {pre: pre, rep: None, post: post} => {\n-                if post.len() > 0 {\n-                    cx.bug(~\"elts_to_ell provided an invalid result\");\n-                }\n-                p_t_s_r_length(cx, vec::len(pre), false, s, b);\n-                p_t_s_r_actual_vector(cx, pre, false, s, b);\n-              }\n-            }\n-          }\n-          /* FIXME (#2251): handle embedded types and blocks, at least */\n-          expr_mac(ref mac) => {\n-            p_t_s_r_mac(cx, (*mac), s, b);\n-          }\n-          _ => {\n-            fn select(cx: ext_ctxt, m: matchable, pat: @expr) ->\n-               match_result {\n-                return match m {\n-                      match_expr(e) => {\n-                        if managed::ptr_eq(e, pat) {\n-                            // XXX: Is this right?\n-                            Some(leaf(match_exact))\n-                        } else {\n-                            None\n-                        }\n-                      }\n-                      _ => cx.bug(~\"broken traversal in p_t_s_r\")\n-                    }\n-            }\n-            b.literal_ast_matchers.push(|x| select(cx, x, e));\n-          }\n-        }\n-      }\n-      _ => cx.bug(~\"undocumented invariant in p_t_s_rec\")\n-    }\n-}\n-\n-\n-/* make a match more precise */\n-fn specialize_match(m: matchable) -> matchable {\n-    return match m {\n-          match_expr(e) => {\n-            match e.node {\n-              expr_path(pth) => {\n-                match path_to_ident(pth) {\n-                  Some(id) => match_ident(respan(pth.span, id)),\n-                  None => match_path(pth)\n-                }\n-              }\n-              _ => m\n-            }\n-          }\n-          _ => m\n-        }\n-}\n-\n-/* pattern_to_selectors helper functions */\n-fn p_t_s_r_path(cx: ext_ctxt, p: @path, s: selector, b: binders) {\n-    match path_to_ident(p) {\n-      Some(p_id) => {\n-        fn select(cx: ext_ctxt, m: matchable) -> match_result {\n-            return match m {\n-                  match_expr(*) => Some(leaf(specialize_match(m))),\n-                  _ => cx.bug(~\"broken traversal in p_t_s_r\")\n-                }\n-        }\n-        if b.real_binders.contains_key(p_id) {\n-            cx.span_fatal(p.span, ~\"duplicate binding identifier\");\n-        }\n-        b.real_binders.insert(p_id, compose_sels(s, |x| select(cx, x)));\n-      }\n-      None => ()\n-    }\n-}\n-\n-fn block_to_ident(blk: blk_) -> Option<ident> {\n-    if vec::len(blk.stmts) != 0u { return None; }\n-    return match blk.expr {\n-          Some(expr) => match expr.node {\n-            expr_path(pth) => path_to_ident(pth),\n-            _ => None\n-          },\n-          None => None\n-        }\n-}\n-\n-fn p_t_s_r_mac(cx: ext_ctxt, mac: ast::mac, _s: selector, _b: binders) {\n-    fn select_pt_1(cx: ext_ctxt, m: matchable,\n-                   fn_m: fn(ast::mac) -> match_result) -> match_result {\n-        return match m {\n-              match_expr(e) => match e.node {\n-                expr_mac(ref mac) => fn_m((*mac)),\n-                _ => None\n-              },\n-              _ => cx.bug(~\"broken traversal in p_t_s_r\")\n-            }\n-    }\n-    fn no_des(cx: ext_ctxt, sp: span, syn: ~str) -> ! {\n-        cx.span_fatal(sp, ~\"destructuring \" + syn + ~\" is not yet supported\");\n-    }\n-    match mac.node {\n-      ast::mac_ellipsis => cx.span_fatal(mac.span, ~\"misused `...`\"),\n-      ast::mac_invoc(_, _, _) => no_des(cx, mac.span, ~\"macro calls\"),\n-      ast::mac_invoc_tt(_, _) => no_des(cx, mac.span, ~\"macro calls\"),\n-      ast::mac_aq(_,_) => no_des(cx, mac.span, ~\"antiquotes\"),\n-      ast::mac_var(_) => no_des(cx, mac.span, ~\"antiquote variables\")\n-    }\n-}\n-\n-fn p_t_s_r_ellipses(cx: ext_ctxt, repeat_me: @expr, offset: uint, s: selector,\n-                    b: binders) {\n-    fn select(cx: ext_ctxt, repeat_me: @expr, offset: uint, m: matchable) ->\n-       match_result {\n-        return match m {\n-              match_expr(e) => {\n-                match e.node {\n-                  expr_vec(arg_elts, _) => {\n-                    let mut elts = ~[];\n-                    let mut idx = offset;\n-                    while idx < vec::len(arg_elts) {\n-                        elts.push(leaf(match_expr(arg_elts[idx])));\n-                        idx += 1u;\n-                    }\n-\n-                    // using repeat_me.span is a little wacky, but the\n-                    // error we want to report is one in the macro def\n-                    Some(seq(@elts, repeat_me.span))\n-                  }\n-                  _ => None\n-                }\n-              }\n-              _ => cx.bug(~\"broken traversal in p_t_s_r\")\n-            }\n-    }\n-    p_t_s_rec(cx, match_expr(repeat_me),\n-              compose_sels(s, |x| select(cx, repeat_me, offset, x)), b);\n-}\n-\n-\n-fn p_t_s_r_length(cx: ext_ctxt, len: uint, at_least: bool, s: selector,\n-                  b: binders) {\n-    fn len_select(_cx: ext_ctxt, m: matchable, at_least: bool, len: uint) ->\n-       match_result {\n-        return match m {\n-              match_expr(e) => {\n-                match e.node {\n-                  expr_vec(arg_elts, _) => {\n-                    let actual_len = vec::len(arg_elts);\n-                    if at_least && actual_len >= len || actual_len == len {\n-                        Some(leaf(match_exact))\n-                    } else { None }\n-                  }\n-                  _ => None\n-                }\n-              }\n-              _ => None\n-            }\n-    }\n-    b.literal_ast_matchers.push(\n-        compose_sels(s, |x| len_select(cx, x, at_least, len)));\n-}\n-\n-fn p_t_s_r_actual_vector(cx: ext_ctxt, elts: ~[@expr], _repeat_after: bool,\n-                         s: selector, b: binders) {\n-    let mut idx: uint = 0u;\n-    while idx < vec::len(elts) {\n-        fn select(cx: ext_ctxt, m: matchable, idx: uint) -> match_result {\n-            return match m {\n-                  match_expr(e) => {\n-                    match e.node {\n-                      expr_vec(arg_elts, _) => {\n-                        Some(leaf(match_expr(arg_elts[idx])))\n-                      }\n-                      _ => None\n-                    }\n-                  }\n-                  _ => cx.bug(~\"broken traversal in p_t_s_r\")\n-                }\n-        }\n-        p_t_s_rec(cx, match_expr(elts[idx]),\n-                  compose_sels(s, |x, copy idx| select(cx, x, idx)), b);\n-        idx += 1u;\n-    }\n-}\n-\n-fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n-                     _body: ast::mac_body) -> base::macro_def {\n-    let args = get_mac_args_no_max(cx, sp, arg, 0u, ~\"macro\");\n-\n-    let mut macro_name: Option<~str> = None;\n-    let mut clauses: ~[@clause] = ~[];\n-    for args.each |arg| {\n-        match arg.node {\n-          expr_vec(elts, _) => {\n-            if vec::len(elts) != 2u {\n-                cx.span_fatal((*arg).span,\n-                              ~\"extension clause must consist of ~[\" +\n-                                  ~\"macro invocation, expansion body]\");\n-            }\n-\n-\n-            match elts[0u].node {\n-              expr_mac(ref mac) => {\n-                match (*mac).node {\n-                  mac_invoc(pth, invoc_arg, _) => {\n-                    match path_to_ident(pth) {\n-                      Some(id) => {\n-                        let id_str = cx.str_of(id);\n-                        match macro_name {\n-                          None => macro_name = Some(id_str),\n-                          Some(ref other_id) => if id_str != (*other_id) {\n-                            cx.span_fatal(pth.span,\n-                                          ~\"macro name must be \" +\n-                                          ~\"consistent\");\n-                          }\n-                        }\n-                      },\n-                      None => cx.span_fatal(pth.span,\n-                                            ~\"macro name must not be a path\")\n-                    }\n-                    let arg = match invoc_arg {\n-                      Some(arg) => arg,\n-                      None => cx.span_fatal((*mac).span,\n-                                           ~\"macro must have arguments\")\n-                    };\n-                    clauses.push(@{params: pattern_to_selectors(cx, arg),\n-                                   body: elts[1u]});\n-\n-                    // FIXME (#2251): check duplicates (or just simplify\n-                    // the macro arg situation)\n-                  }\n-                  _ => {\n-                      cx.span_bug((*mac).span, ~\"undocumented invariant in \\\n-                         add_extension\");\n-                  }\n-                }\n-              }\n-              _ => {\n-                cx.span_fatal(elts[0u].span,\n-                              ~\"extension clause must\" +\n-                                  ~\" start with a macro invocation.\");\n-              }\n-            }\n-          }\n-          _ => {\n-            cx.span_fatal((*arg).span,\n-                          ~\"extension must be ~[clause, \" + ~\" ...]\");\n-          }\n-        }\n-    }\n-\n-    let ext = |a,b,c,d, move clauses| generic_extension(a,b,c,d,clauses);\n-\n-    return {name:\n-             match macro_name {\n-               Some(ref id) => (*id),\n-               None => cx.span_fatal(sp, ~\"macro definition must have \" +\n-                                     ~\"at least one clause\")\n-             },\n-         ext: normal({expander: ext, span: Some(arg.get().span)})};\n-\n-    fn generic_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n-                         _body: ast::mac_body,\n-                         clauses: ~[@clause]) -> @expr {\n-        let arg = match arg {\n-          Some(arg) => arg,\n-          None => cx.span_fatal(sp, ~\"macro must have arguments\")\n-        };\n-        for clauses.each |c| {\n-            match use_selectors_to_bind(c.params, arg) {\n-              Some(bindings) => return transcribe(cx, bindings, c.body),\n-              None => loop\n-            }\n-        }\n-        cx.span_fatal(sp, ~\"no clauses match macro invocation\");\n-    }\n-}\n-\n-\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "8d2b9163f152fd7800c245424bba77f82812d63e", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 34, "deletions": 42, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -23,63 +23,58 @@ export expand_include_str;\n export expand_include_bin;\n \n /* line!(): expands to the current line number */\n-fn expand_line(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n-               _body: ast::mac_body) -> @ast::expr {\n-    get_mac_args(cx, sp, arg, 0u, option::Some(0u), ~\"line\");\n+fn expand_line(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+    -> base::mac_result {\n+    base::check_zero_tts(cx, sp, tts, \"line!\");\n     let loc = cx.codemap().lookup_char_pos(sp.lo);\n-    return mk_uint(cx, sp, loc.line);\n+    base::mr_expr(mk_uint(cx, sp, loc.line))\n }\n \n /* col!(): expands to the current column number */\n-fn expand_col(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n-              _body: ast::mac_body) -> @ast::expr {\n-    get_mac_args(cx, sp, arg, 0u, option::Some(0u), ~\"col\");\n+fn expand_col(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+    -> base::mac_result {\n+    base::check_zero_tts(cx, sp, tts, \"col!\");\n     let loc = cx.codemap().lookup_char_pos(sp.lo);\n-    return mk_uint(cx, sp, loc.col.to_uint());\n+    base::mr_expr(mk_uint(cx, sp, loc.col.to_uint()))\n }\n \n /* file!(): expands to the current filename */\n /* The filemap (`loc.file`) contains a bunch more information we could spit\n  * out if we wanted. */\n-fn expand_file(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n-               _body: ast::mac_body) -> @ast::expr {\n-    get_mac_args(cx, sp, arg, 0u, option::Some(0u), ~\"file\");\n+fn expand_file(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+    -> base::mac_result {\n+    base::check_zero_tts(cx, sp, tts, \"file!\");\n     let Loc { file: @FileMap { name: filename, _ }, _ } =\n         cx.codemap().lookup_char_pos(sp.lo);\n-    return mk_uniq_str(cx, sp, filename);\n+    base::mr_expr(mk_uniq_str(cx, sp, filename))\n }\n \n-fn expand_stringify(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n-                    _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args(cx, sp, arg, 1u, option::Some(1u), ~\"stringify\");\n-    let s = pprust::expr_to_str(args[0], cx.parse_sess().interner);\n-    return mk_uniq_str(cx, sp, s);\n+fn expand_stringify(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+    -> base::mac_result {\n+    let s = pprust::tts_to_str(tts, cx.parse_sess().interner);\n+    base::mr_expr(mk_uniq_str(cx, sp, s))\n }\n \n-fn expand_mod(cx: ext_ctxt, sp: span, arg: ast::mac_arg, _body: ast::mac_body)\n-    -> @ast::expr {\n-    get_mac_args(cx, sp, arg, 0u, option::Some(0u), ~\"file\");\n-    return mk_uniq_str(cx, sp,\n-                       str::connect(cx.mod_path().map(\n-                           |x| cx.str_of(*x)), ~\"::\"));\n+fn expand_mod(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+    -> base::mac_result {\n+    base::check_zero_tts(cx, sp, tts, \"module_path!\");\n+    base::mr_expr(mk_uniq_str(cx, sp,\n+                              str::connect(cx.mod_path().map(\n+                                  |x| cx.str_of(*x)), ~\"::\")))\n }\n \n-fn expand_include(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n-                  _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args(cx, sp, arg, 1u, option::Some(1u), ~\"include\");\n-    let file = expr_to_str(cx, args[0], ~\"include_str! requires a string\");\n+fn expand_include(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+    -> base::mac_result {\n+    let file = get_single_str_from_tts(cx, sp, tts, \"include!\");\n     let p = parse::new_sub_parser_from_file(\n         cx.parse_sess(), cx.cfg(),\n         &res_rel_file(cx, sp, &Path(file)), sp);\n-    return p.parse_expr();\n+    base::mr_expr(p.parse_expr())\n }\n \n-fn expand_include_str(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n-                      _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args(cx,sp,arg,1u,option::Some(1u),~\"include_str\");\n-\n-    let file = expr_to_str(cx, args[0], ~\"include_str! requires a string\");\n-\n+fn expand_include_str(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+    -> base::mac_result {\n+    let file = get_single_str_from_tts(cx, sp, tts, \"include_str!\");\n     let res = io::read_whole_file_str(&res_rel_file(cx, sp, &Path(file)));\n     match res {\n       result::Ok(_) => { /* Continue. */ }\n@@ -88,21 +83,18 @@ fn expand_include_str(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n       }\n     }\n \n-    return mk_uniq_str(cx, sp, result::unwrap(res));\n+    base::mr_expr(mk_uniq_str(cx, sp, result::unwrap(res)))\n }\n \n-fn expand_include_bin(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n-                      _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args(cx,sp,arg,1u,option::Some(1u),~\"include_bin\");\n-\n-    let file = expr_to_str(cx, args[0], ~\"include_bin! requires a string\");\n-\n+fn expand_include_bin(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+    -> base::mac_result {\n+    let file = get_single_str_from_tts(cx, sp, tts, \"include_bin!\");\n     match io::read_whole_file(&res_rel_file(cx, sp, &Path(file))) {\n       result::Ok(src) => {\n         let u8_exprs = vec::map(src, |char| {\n             mk_u8(cx, sp, *char)\n         });\n-        return mk_base_vec_e(cx, sp, u8_exprs);\n+        base::mr_expr(mk_base_vec_e(cx, sp, u8_exprs))\n       }\n       result::Err(ref e) => {\n         cx.parse_sess().span_diagnostic.handler().fatal((*e))"}, {"sha": "93845f3dbb859cc34315ca563dd205c6e3e0892a", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -120,14 +120,7 @@ fn fold_arg_(a: arg, fld: ast_fold) -> arg {\n fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n     return {node:\n              match m.node {\n-               mac_invoc(pth, arg, body) => {\n-                 mac_invoc(fld.fold_path(pth),\n-                           option::map(&arg, |x| fld.fold_expr(*x)), body)\n-               }\n                mac_invoc_tt(*) => m.node,\n-               mac_ellipsis => mac_ellipsis,\n-               mac_aq(_,_) => /* FIXME (#2543) */ copy m.node,\n-               mac_var(_) => /* FIXME (#2543) */ copy m.node,\n              },\n          span: fld.new_span(m.span)};\n }"}, {"sha": "7248a0e224476a6e83cb7546a00fed02c5ae8283", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -12,16 +12,9 @@ use either::{Either, Left, Right};\n use ast_util::spanned;\n use common::*; //resolve bug?\n \n-export attr_or_ext;\n export parser_attr;\n \n-// A type to distingush between the parsing of item attributes or syntax\n-// extensions, which both begin with token.POUND\n-type attr_or_ext = Option<Either<~[ast::attribute], @ast::expr>>;\n-\n trait parser_attr {\n-    fn parse_outer_attrs_or_ext(first_item_attrs: ~[ast::attribute])\n-        -> attr_or_ext;\n     fn parse_outer_attributes() -> ~[ast::attribute];\n     fn parse_attribute(style: ast::attr_style) -> ast::attribute;\n     fn parse_attribute_naked(style: ast::attr_style, lo: BytePos) ->\n@@ -35,34 +28,6 @@ trait parser_attr {\n \n impl Parser: parser_attr {\n \n-    fn parse_outer_attrs_or_ext(first_item_attrs: ~[ast::attribute])\n-        -> attr_or_ext\n-    {\n-        let expect_item_next = vec::is_not_empty(first_item_attrs);\n-        match self.token {\n-          token::POUND => {\n-            let lo = self.span.lo;\n-            if self.look_ahead(1u) == token::LBRACKET {\n-                self.bump();\n-                let first_attr =\n-                    self.parse_attribute_naked(ast::attr_outer, lo);\n-                return Some(Left(vec::append(~[first_attr],\n-                                          self.parse_outer_attributes())));\n-            } else if !(self.look_ahead(1u) == token::LT\n-                        || self.look_ahead(1u) == token::LBRACKET\n-                        || self.look_ahead(1u) == token::POUND\n-                        || expect_item_next) {\n-                self.bump();\n-                return Some(Right(self.parse_syntax_ext_naked(lo)));\n-            } else { return None; }\n-        }\n-        token::DOC_COMMENT(_) => {\n-          return Some(Left(self.parse_outer_attributes()));\n-        }\n-        _ => return None\n-      }\n-    }\n-\n     // Parse attributes that appear before an item\n     fn parse_outer_attributes() -> ~[ast::attribute] {\n         let mut attrs: ~[ast::attribute] = ~[];"}, {"sha": "c4e34311b889838841e221ed7483d2726c9230c9", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -515,11 +515,6 @@ fn next_token_inner(rdr: string_reader) -> token::Token {\n             bump(rdr);\n             return token::DOTDOT;\n         }\n-        if rdr.curr == '.' && nextch(rdr) == '.' {\n-            bump(rdr);\n-            bump(rdr);\n-            return token::ELLIPSIS;\n-        }\n         return token::DOT;\n       }\n       '(' => { bump(rdr); return token::LPAREN; }"}, {"sha": "625ff289607f619db052cc3fb848291230b40012", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 115, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -54,8 +54,8 @@ use ast::{_mod, add, arg, arm, attribute,\n              item_foreign_mod, item_impl, item_mac, item_mod, item_trait,\n              item_ty, lit, lit_, lit_bool, lit_float, lit_float_unsuffixed,\n              lit_int, lit_int_unsuffixed, lit_nil, lit_str, lit_uint, local,\n-             m_const, m_imm, m_mutbl, mac_, mac_aq, mac_ellipsis, mac_invoc,\n-             mac_invoc_tt, mac_var, matcher, match_nonterminal, match_seq,\n+             m_const, m_imm, m_mutbl, mac_,\n+             mac_invoc_tt, matcher, match_nonterminal, match_seq,\n              match_tok, method, mode, module_ns, mt, mul, mutability,\n              named_field, neg, noreturn, not, pat, pat_box, pat_enum,\n              pat_ident, pat_lit, pat_range, pat_rec, pat_region, pat_struct,\n@@ -81,13 +81,6 @@ use ast::{_mod, add, arg, arm, attribute,\n \n export Parser;\n \n-// FIXME (#3726): #ast expects to find this here but it's actually\n-// defined in `parse` Fixing this will be easier when we have export\n-// decls on individual items -- then parse can export this publicly, and\n-// everything else crate-visibly.\n-use parse::parse_from_source_str;\n-export parse_from_source_str;\n-\n export item_or_view_item, iovi_none, iovi_view_item, iovi_item;\n \n enum restriction {\n@@ -517,15 +510,6 @@ impl Parser {\n \n         let lo = self.span.lo;\n \n-        match self.maybe_parse_dollar_mac() {\n-          Some(ref e) => {\n-            return @{id: self.get_id(),\n-                  node: ty_mac(spanned(lo, self.span.hi, (*e))),\n-                  span: mk_sp(lo, self.span.hi)};\n-          }\n-          None => ()\n-        }\n-\n         let t = if self.token == token::LPAREN {\n             self.bump();\n             if self.token == token::RPAREN {\n@@ -737,32 +721,6 @@ impl Parser {\n         }\n     }\n \n-    fn maybe_parse_dollar_mac() -> Option<mac_> {\n-        match copy self.token {\n-          token::DOLLAR => {\n-            let lo = self.span.lo;\n-            self.bump();\n-            match copy self.token {\n-              token::LIT_INT_UNSUFFIXED(num) => {\n-                self.bump();\n-                Some(mac_var(num as uint))\n-              }\n-              token::LPAREN => {\n-                self.bump();\n-                let e = self.parse_expr();\n-                self.expect(token::RPAREN);\n-                let hi = self.last_span.hi;\n-                Some(mac_aq(mk_sp(lo,hi), e))\n-              }\n-              _ => {\n-                self.fatal(~\"expected `(` or unsuffixed integer literal\");\n-              }\n-            }\n-          }\n-          _ => None\n-        }\n-    }\n-\n     fn maybe_parse_fixed_vstore_with_star() -> Option<uint> {\n         if self.eat(token::BINOP(token::STAR)) {\n             match copy self.token {\n@@ -935,11 +893,6 @@ impl Parser {\n \n         let mut ex: expr_;\n \n-        match self.maybe_parse_dollar_mac() {\n-          Some(ref x) => return self.mk_mac_expr(lo, self.span.hi, (*x)),\n-          _ => ()\n-        }\n-\n         if self.token == token::LPAREN {\n             self.bump();\n             if self.token == token::RPAREN {\n@@ -1029,13 +982,6 @@ impl Parser {\n                 }\n             }\n             hi = self.span.hi;\n-        } else if self.token == token::ELLIPSIS {\n-            self.bump();\n-            return self.mk_mac_expr(lo, self.span.hi, mac_ellipsis);\n-        } else if self.token == token::POUND {\n-            let ex_ext = self.parse_syntax_ext();\n-            hi = ex_ext.span.hi;\n-            ex = ex_ext.node;\n         } else if self.eat_keyword(~\"fail\") {\n             if can_begin_expr(self.token) {\n                 let e = self.parse_expr();\n@@ -1148,54 +1094,6 @@ impl Parser {\n         return self.mk_expr(blk.span.lo, blk.span.hi, expr_block(blk));\n     }\n \n-    fn parse_syntax_ext() -> @expr {\n-        let lo = self.span.lo;\n-        self.expect(token::POUND);\n-        return self.parse_syntax_ext_naked(lo);\n-    }\n-\n-    fn parse_syntax_ext_naked(lo: BytePos) -> @expr {\n-        match self.token {\n-          token::IDENT(_, _) => (),\n-          _ => self.fatal(~\"expected a syntax expander name\")\n-        }\n-        let pth = self.parse_path_without_tps();\n-        //temporary for a backwards-compatible cycle:\n-        let sep = seq_sep_trailing_disallowed(token::COMMA);\n-        let mut e = None;\n-        if (self.token == token::LPAREN || self.token == token::LBRACKET) {\n-            let lo = self.span.lo;\n-            let es =\n-                if self.token == token::LPAREN {\n-                    self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n-                                             sep, |p| p.parse_expr())\n-                } else {\n-                    self.parse_unspanned_seq(token::LBRACKET, token::RBRACKET,\n-                                             sep, |p| p.parse_expr())\n-                };\n-            let hi = self.span.hi;\n-            e = Some(self.mk_expr(lo, hi, expr_vec(es, m_imm)));\n-        }\n-        let mut b = None;\n-        if self.token == token::LBRACE {\n-            self.bump();\n-            let lo = self.span.lo;\n-            let mut depth = 1u;\n-            while (depth > 0u) {\n-                match (self.token) {\n-                  token::LBRACE => depth += 1u,\n-                  token::RBRACE => depth -= 1u,\n-                  token::EOF => self.fatal(~\"unexpected EOF in macro body\"),\n-                  _ => ()\n-                }\n-                self.bump();\n-            }\n-            let hi = self.last_span.lo;\n-            b = Some({span: mk_sp(lo,hi)});\n-        }\n-        return self.mk_mac_expr(lo, self.span.hi, mac_invoc(pth, e, b));\n-    }\n-\n     fn parse_dot_or_call_expr() -> @expr {\n         let b = self.parse_bottom_expr();\n         self.parse_dot_or_call_expr_with(b)\n@@ -2260,17 +2158,8 @@ impl Parser {\n             }\n \n         } else {\n-            let mut item_attrs;\n-            match self.parse_outer_attrs_or_ext(first_item_attrs) {\n-              None => item_attrs = ~[],\n-              Some(Left(ref attrs)) => item_attrs = (*attrs),\n-              Some(Right(ext)) => {\n-                return @spanned(lo, ext.span.hi,\n-                                stmt_expr(ext, self.get_id()));\n-              }\n-            }\n-\n-            let item_attrs = vec::append(first_item_attrs, item_attrs);\n+            let item_attrs = vec::append(first_item_attrs,\n+                                         self.parse_outer_attributes());\n \n             match self.parse_item_or_view_item(item_attrs,\n                                                true, false, false) {"}, {"sha": "7e7c61d2bf24903cd3273139cb9c1d1e4dac55a1", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -49,7 +49,6 @@ enum Token {\n     AT,\n     DOT,\n     DOTDOT,\n-    ELLIPSIS,\n     COMMA,\n     SEMI,\n     COLON,\n@@ -137,7 +136,6 @@ fn to_str(in: @ident_interner, t: Token) -> ~str {\n       AT => ~\"@\",\n       DOT => ~\".\",\n       DOTDOT => ~\"..\",\n-      ELLIPSIS => ~\"...\",\n       COMMA => ~\",\",\n       SEMI => ~\";\",\n       COLON => ~\":\",\n@@ -578,12 +576,6 @@ impl Token : cmp::Eq {\n                     _ => false\n                 }\n             }\n-            ELLIPSIS => {\n-                match (*other) {\n-                    ELLIPSIS => true,\n-                    _ => false\n-                }\n-            }\n             COMMA => {\n                 match (*other) {\n                     COMMA => true,"}, {"sha": "d90341254cc3404e93b1d9d76052da86e7e56d5b", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -154,8 +154,7 @@ fn mk_printer(out: io::Writer, linewidth: uint) -> printer {\n                mut top: 0,\n                mut bottom: 0,\n                print_stack: DVec(),\n-               mut pending_indentation: 0,\n-               mut token_tree_last_was_ident: false})\n+               mut pending_indentation: 0 })\n }\n \n \n@@ -261,7 +260,6 @@ type printer_ = {\n     print_stack: DVec<print_stack_elt>,\n     // buffered indentation to avoid writing trailing whitespace\n     mut pending_indentation: int,\n-    mut token_tree_last_was_ident: bool\n };\n \n enum printer {"}, {"sha": "fa384341fb9734f1199721a7ebd16a4f4f2c9924", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 19, "deletions": 32, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -118,6 +118,10 @@ fn tt_to_str(tt: ast::token_tree, intr: @ident_interner) -> ~str {\n     to_str(tt, print_tt, intr)\n }\n \n+fn tts_to_str(tts: &[ast::token_tree], intr: @ident_interner) -> ~str {\n+    to_str(tts, print_tts, intr)\n+}\n+\n fn stmt_to_str(s: ast::stmt, intr: @ident_interner) -> ~str {\n     to_str(s, print_stmt, intr)\n }\n@@ -584,15 +588,10 @@ fn print_item(s: ps, &&item: @ast::item) {\n         print_ident(s, item.ident);\n         cbox(s, indent_unit);\n         popen(s);\n-        for (*tts).each |tt| {\n-            print_tt(s, *tt);\n-        }\n+        print_tts(s, *tts);\n         pclose(s);\n         end(s);\n       }\n-      ast::item_mac(_) => {\n-        fail ~\"invalid item-position syntax bit\"\n-      }\n     }\n     (s.ann.post)(ann_node);\n }\n@@ -739,17 +738,9 @@ fn print_struct(s: ps, struct_def: @ast::struct_def, tps: ~[ast::ty_param],\n /// expression arguments as expressions). It can be done! I think.\n fn print_tt(s: ps, tt: ast::token_tree) {\n     match tt {\n-      ast::tt_delim(ref tts) =>\n-        for (*tts).each() |tt_elt| { print_tt(s, *tt_elt); },\n+      ast::tt_delim(ref tts) => print_tts(s, *tts),\n       ast::tt_tok(_, ref tk) => {\n-        match (*tk) {\n-          parse::token::IDENT(*) => { // don't let idents run together\n-            if s.s.token_tree_last_was_ident { word(s.s, ~\" \") }\n-            s.s.token_tree_last_was_ident = true;\n-          }\n-          _ => { s.s.token_tree_last_was_ident = false; }\n-        }\n-        word(s.s, parse::token::to_str(s.intr, (*tk)));\n+          word(s.s, parse::token::to_str(s.intr, (*tk)));\n       }\n       ast::tt_seq(_, ref tts, ref sep, zerok) => {\n         word(s.s, ~\"$(\");\n@@ -760,16 +751,25 @@ fn print_tt(s: ps, tt: ast::token_tree) {\n           None => ()\n         }\n         word(s.s, if zerok { ~\"*\" } else { ~\"+\" });\n-        s.s.token_tree_last_was_ident = false;\n       }\n       ast::tt_nonterminal(_, name) => {\n         word(s.s, ~\"$\");\n         print_ident(s, name);\n-        s.s.token_tree_last_was_ident = true;\n       }\n     }\n }\n \n+fn print_tts(s: ps, &&tts: &[ast::token_tree]) {\n+    ibox(s, 0);\n+    for tts.eachi |i, tt| {\n+        if i != 0 {\n+            space(s.s);\n+        }\n+        print_tt(s, *tt);\n+    }\n+    end(s);\n+}\n+\n fn print_variant(s: ps, v: ast::variant) {\n     print_visibility(s, v.node.vis);\n     match v.node.kind {\n@@ -1000,26 +1000,13 @@ fn print_if(s: ps, test: @ast::expr, blk: ast::blk,\n \n fn print_mac(s: ps, m: ast::mac) {\n     match m.node {\n-      ast::mac_invoc(path, arg, _body) => {\n-        word(s.s, ~\"#\");\n-        print_path(s, path, false);\n-        match arg {\n-          Some(@{node: ast::expr_vec(_, _), _}) => (),\n-          _ => word(s.s, ~\" \")\n-        }\n-        arg.iter(|a| print_expr(s, *a));\n-        // FIXME: extension 'body' (#2339)\n-      }\n       ast::mac_invoc_tt(pth, ref tts) => {\n         print_path(s, pth, false);\n         word(s.s, ~\"!\");\n         popen(s);\n-        for (*tts).each() |tt| { print_tt(s, *tt); }\n+        print_tts(s, *tts);\n         pclose(s);\n       }\n-      ast::mac_ellipsis => word(s.s, ~\"...\"),\n-      ast::mac_var(v) => word(s.s, fmt!(\"$%u\", v)),\n-      _ => { /* fixme */ }\n     }\n }\n "}, {"sha": "fbc5f10fcd6f9e794d7a9fc45814756faf9f05c9", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -75,9 +75,6 @@ mod ext {\n     #[legacy_exports]\n     #[path = \"ext/expand.rs\"]\n     mod expand;\n-    #[legacy_exports]\n-    #[path = \"ext/qquote.rs\"]\n-    mod qquote;\n \n     #[path = \"ext/quote.rs\"]\n     mod quote;\n@@ -102,9 +99,6 @@ mod ext {\n     }\n \n \n-    #[legacy_exports]\n-    #[path = \"ext/simplext.rs\"]\n-    mod simplext;\n     #[legacy_exports]\n     #[path = \"ext/fmt.rs\"]\n     mod fmt;\n@@ -115,9 +109,6 @@ mod ext {\n     #[path = \"ext/concat_idents.rs\"]\n     mod concat_idents;\n     #[legacy_exports]\n-    #[path = \"ext/ident_to_str.rs\"]\n-    mod ident_to_str;\n-    #[legacy_exports]\n     #[path = \"ext/log_syntax.rs\"]\n     mod log_syntax;\n     #[legacy_exports]"}, {"sha": "7b406564114b8c7622e4f8d30d9b2b1d7973b994", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -379,15 +379,8 @@ fn visit_exprs<E>(exprs: ~[@expr], e: E, v: vt<E>) {\n     for exprs.each |ex| { (v.visit_expr)(*ex, e, v); }\n }\n \n-fn visit_mac<E>(m: mac, e: E, v: vt<E>) {\n-    match m.node {\n-      ast::mac_invoc(_, arg, _) => {\n-        option::map(&arg, |arg| (v.visit_expr)(*arg, e, v)); }\n-      ast::mac_invoc_tt(*) => { /* no user-serviceable parts inside */ }\n-      ast::mac_ellipsis => (),\n-      ast::mac_aq(*) => { /* FIXME: maybe visit (Issue #2340) */ }\n-      ast::mac_var(_) => ()\n-    }\n+fn visit_mac<E>(_m: mac, _e: E, _v: vt<E>) {\n+    /* no user-serviceable parts inside */\n }\n \n fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {"}, {"sha": "bf6bcd6f0817d9635f91d9e66f64b6c622da2e22", "filename": "src/test/compile-fail/ext-noname.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0138d87f8f1b9f9614e439deb14cbaabad6d104c/src%2Ftest%2Fcompile-fail%2Fext-noname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0138d87f8f1b9f9614e439deb14cbaabad6d104c/src%2Ftest%2Fcompile-fail%2Fext-noname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fext-noname.rs?ref=0138d87f8f1b9f9614e439deb14cbaabad6d104c", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:expected a syntax expander name\n-\n-fn main() {\n-  #();\n-}"}, {"sha": "7ff1357dcf3c90845f777375540918c60710c0c6", "filename": "src/test/compile-fail/extenv-no-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Ftest%2Fcompile-fail%2Fextenv-no-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Ftest%2Fcompile-fail%2Fextenv-no-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextenv-no-args.rs?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: env! takes between 1 and 1 arguments\n+// error-pattern: env! takes 1 argument\n \n fn main() { env!(); }"}, {"sha": "b1b2001abc35874dc140d66fb442b5d75968c27a", "filename": "src/test/compile-fail/extenv-too-many-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Ftest%2Fcompile-fail%2Fextenv-too-many-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Ftest%2Fcompile-fail%2Fextenv-too-many-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextenv-too-many-args.rs?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: env! takes between 1 and 1 arguments\n+// error-pattern: env! takes 1 argument\n \n fn main() { env!(\"one\", \"two\"); }"}, {"sha": "cd9308e7b3f25f562b4261dd2a0e787657cae82e", "filename": "src/test/compile-fail/extfmt-no-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:fmt! needs at least 1 arguments\n+// error-pattern:fmt! takes at least 1 argument\n \n fn main() { fmt!(); }"}, {"sha": "187956b645af80c4067844bf9b15e165c06128f8", "filename": "src/test/compile-fail/issue-1448-1.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0138d87f8f1b9f9614e439deb14cbaabad6d104c/src%2Ftest%2Fcompile-fail%2Fissue-1448-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0138d87f8f1b9f9614e439deb14cbaabad6d104c/src%2Ftest%2Fcompile-fail%2Fissue-1448-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1448-1.rs?ref=0138d87f8f1b9f9614e439deb14cbaabad6d104c", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Regresion test for issue #1448 and #1386\n-\n-fn main() {\n-    #macro[[#apply[f, [x, ...]], f(x, ...)]];\n-    fn add(a: int, b: int) -> int { return a + b; }\n-    assert (apply!(add, [y, 15]) == 16); //~ ERROR unresolved name: y\n-}"}, {"sha": "57ed12789ab6ec821418e3a88a3d64cdfc981954", "filename": "src/test/compile-fail/macro-2.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0138d87f8f1b9f9614e439deb14cbaabad6d104c/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0138d87f8f1b9f9614e439deb14cbaabad6d104c/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs?ref=0138d87f8f1b9f9614e439deb14cbaabad6d104c", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//error-pattern:is an expr, expected a path\n-fn main() {\n-    #macro[[#mylambda[x, body],\n-            {\n-                fn f(x: int) -> int { return body }\n-                f\n-            }]];\n-\n-    assert (mylambda!(y * 1, y * 2)(8) == 16);\n-}"}, {"sha": "43ce05845ec58b5178ec0ee5914ee2b9e0db6ca2", "filename": "src/test/compile-fail/macro.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0138d87f8f1b9f9614e439deb14cbaabad6d104c/src%2Ftest%2Fcompile-fail%2Fmacro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0138d87f8f1b9f9614e439deb14cbaabad6d104c/src%2Ftest%2Fcompile-fail%2Fmacro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro.rs?ref=0138d87f8f1b9f9614e439deb14cbaabad6d104c", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//error-pattern:no clauses match\n-\n-fn main() {\n-    #macro[[#trivial[], 1 * 2 * 4 * 2 * 1]];\n-\n-    assert (trivial!(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16) ==\n-                16);\n-}"}, {"sha": "a343158337d09570d88958bdad27a607fb7f436b", "filename": "src/test/compile-fail/qquote-1.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -21,36 +21,44 @@ use syntax::codemap;\n use syntax::parse;\n use syntax::print::*;\n \n-fn new_parse_sess() -> parse::parse_sess {\n-  fail;\n-}\n \n trait fake_ext_ctxt {\n-    fn session() -> fake_session;\n+    fn cfg() -> ast::crate_cfg;\n+    fn parse_sess() -> parse::parse_sess;\n+    fn call_site() -> span;\n+    fn ident_of(st: ~str) -> ast::ident;\n }\n \n-type fake_options = {cfg: ast::crate_cfg};\n-\n-type fake_session = {opts: @fake_options,\n-                     parse_sess: parse::parse_sess};\n+type fake_session = parse::parse_sess;\n \n impl fake_session: fake_ext_ctxt {\n-    fn session() -> fake_session {self}\n+    fn cfg() -> ast::crate_cfg { ~[] }\n+    fn parse_sess() -> parse::parse_sess { self }\n+    fn call_site() -> span {\n+        codemap::span {\n+            lo: codemap::BytePos(0),\n+            hi: codemap::BytePos(0),\n+            expn_info: None\n+        }\n+    }\n+    fn ident_of(st: ~str) -> ast::ident {\n+        self.interner.intern(@st)\n+    }\n }\n \n fn mk_ctxt() -> fake_ext_ctxt {\n-    let opts : fake_options = {cfg: ~[]};\n-    {opts: @opts, parse_sess: new_parse_sess()} as fake_ext_ctxt\n+    parse::new_parse_sess(None) as fake_ext_ctxt\n }\n \n \n+\n fn main() {\n     let ext_cx = mk_ctxt();\n \n-    let abc = #ast{23};\n+    let abc = quote_expr!(23);\n     check_pp(abc,  pprust::print_expr, \"23\");\n \n-    let expr3 = #ast{2 - $(abcd) + 7}; //~ ERROR unresolved name: abcd\n+    let expr3 = quote_expr!(2 - $abcd + 7); //~ ERROR unresolved name: abcd\n     check_pp(expr3,  pprust::print_expr, \"2 - 23 + 7\");\n }\n "}, {"sha": "b7e33f99e3b487c06fee59dae97cb38af1e15445", "filename": "src/test/compile-fail/qquote-2.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -8,9 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-test Can't use syntax crate here\n \n extern mod std;\n-use syntax;\n+extern mod syntax;\n \n use std::io::*;\n \n@@ -20,33 +21,39 @@ use syntax::codemap;\n use syntax::parse::parser;\n use syntax::print::*;\n \n-fn new_parse_sess() -> parser::parse_sess {\n-  fail;\n-}\n-\n trait fake_ext_ctxt {\n-    fn session() -> fake_session;\n+    fn cfg() -> ast::crate_cfg;\n+    fn parse_sess() -> parse::parse_sess;\n+    fn call_site() -> span;\n+    fn ident_of(st: ~str) -> ast::ident;\n }\n \n-type fake_options = {cfg: ast::crate_cfg};\n-\n-type fake_session = {opts: @fake_options,\n-                     parse_sess: parser::parse_sess};\n+type fake_session = parse::parse_sess;\n \n impl fake_session: fake_ext_ctxt {\n-    fn session() -> fake_session {self}\n+    fn cfg() -> ast::crate_cfg { ~[] }\n+    fn parse_sess() -> parse::parse_sess { self }\n+    fn call_site() -> span {\n+        codemap::span {\n+            lo: codemap::BytePos(0),\n+            hi: codemap::BytePos(0),\n+            expn_info: None\n+        }\n+    }\n+    fn ident_of(st: ~str) -> ast::ident {\n+        self.interner.intern(@st)\n+    }\n }\n \n fn mk_ctxt() -> fake_ext_ctxt {\n-    let opts : fake_options = {cfg: ~[]};\n-    {opts: @opts, parse_sess: new_parse_sess()} as fake_ext_ctxt\n+    parse::new_parse_sess(None) as fake_ext_ctxt\n }\n \n \n fn main() {\n     let ext_cx = mk_ctxt();\n \n-    let stmt = #ast[stmt]{let x int = 20;}; //~ ERROR expected end-of-string\n+    let stmt = quote_stmt!(let x int = 20;); //~ ERROR expected end-of-string\n     check_pp(*stmt,  pprust::print_stmt, \"\");\n }\n "}, {"sha": "7d52f13b0750ad6000245f2644548ad2b7f382ad", "filename": "src/test/run-pass-fulldeps/issue-1926.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Ftest%2Frun-pass-fulldeps%2Fissue-1926.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Ftest%2Frun-pass-fulldeps%2Fissue-1926.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-1926.rs?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -55,8 +55,8 @@ fn mk_ctxt() -> fake_ext_ctxt {\n \n fn main() {\n     let ext_cx = mk_ctxt();\n-    let s = #ast[expr]{__s};\n-    let e = #ast[expr]{__e};\n-    let f = #ast[expr]{$(s).foo {|__e| $(e)}};\n+    let s = quote_expr!(__s);\n+    let e = quote_expr!(__e);\n+    let f = quote_expr!($s.foo {|__e| $e});\n     log(error, pprust::expr_to_str(f));\n }"}, {"sha": "3345dcaaad02a611d618b751b604e333495c802e", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 19, "deletions": 40, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -20,79 +20,58 @@ use io::*;\n use syntax::diagnostic;\n use syntax::ast;\n use syntax::codemap;\n+use syntax::codemap::span;\n use syntax::parse;\n use syntax::print::*;\n \n+\n trait fake_ext_ctxt {\n     fn cfg() -> ast::crate_cfg;\n     fn parse_sess() -> parse::parse_sess;\n+    fn call_site() -> span;\n+    fn ident_of(st: ~str) -> ast::ident;\n }\n \n type fake_session = parse::parse_sess;\n \n impl fake_session: fake_ext_ctxt {\n     fn cfg() -> ast::crate_cfg { ~[] }\n     fn parse_sess() -> parse::parse_sess { self }\n+    fn call_site() -> span {\n+        codemap::span {\n+            lo: codemap::BytePos(0),\n+            hi: codemap::BytePos(0),\n+            expn_info: None\n+        }\n+    }\n+    fn ident_of(st: ~str) -> ast::ident {\n+        self.interner.intern(@copy st)\n+    }\n }\n \n fn mk_ctxt() -> fake_ext_ctxt {\n     parse::new_parse_sess(None) as fake_ext_ctxt\n }\n \n-\n fn main() {\n     let ext_cx = mk_ctxt();\n \n-    let abc = #ast{23};\n+    let abc = quote_expr!(23);\n     check_pp(ext_cx, abc,  pprust::print_expr, ~\"23\");\n \n-    let expr3 = #ast{2 - $(abc) + 7};\n-    check_pp(ext_cx, expr3,  pprust::print_expr, ~\"2 - 23 + 7\");\n-\n-    let expr4 = #ast{2 - $(#ast{3}) + 9};\n-    check_pp(ext_cx, expr4,  pprust::print_expr, ~\"2 - 3 + 9\");\n \n-    let ty = #ast[ty]{int};\n+    let ty = quote_ty!(int);\n     check_pp(ext_cx, ty, pprust::print_type, ~\"int\");\n \n-    let ty2 = #ast[ty]{option<$(ty)>};\n-    check_pp(ext_cx, ty2, pprust::print_type, ~\"option<int>\");\n-\n-    let item = #ast[item]{const x : int = 10;};\n+    let item = quote_item!(const x : int = 10;).get();\n     check_pp(ext_cx, item, pprust::print_item, ~\"const x: int = 10;\");\n \n-    let item2: @ast::item = #ast[item]{const x : int = $(abc);};\n-    check_pp(ext_cx, item2, pprust::print_item, ~\"const x: int = 23;\");\n-\n-    let stmt = #ast[stmt]{let x = 20;};\n+    let stmt = quote_stmt!(let x = 20;);\n     check_pp(ext_cx, *stmt, pprust::print_stmt, ~\"let x = 20;\");\n \n-    let stmt2 = #ast[stmt]{let x : $(ty) = $(abc);};\n-    check_pp(ext_cx, *stmt2, pprust::print_stmt, ~\"let x: int = 23;\");\n-\n-    let pat = #ast[pat]{some(_)};\n+    let pat = quote_pat!(some(_));\n     check_pp(ext_cx, pat, pprust::print_refutable_pat, ~\"some(_)\");\n \n-    // issue #1785\n-    let x = #ast{1};\n-    let test1 = #ast{1+$(x)};\n-    check_pp(ext_cx, test1, pprust::print_expr, ~\"1 + 1\");\n-\n-    let test2 = #ast{$(x)+1};\n-    check_pp(ext_cx, test2, pprust::print_expr, ~\"1 + 1\");\n-\n-    let y = #ast{2};\n-    let test3 = #ast{$(x) + $(y)};\n-    check_pp(ext_cx, test3, pprust::print_expr, ~\"1 + 2\");\n-\n-    let crate = #ast[crate] { fn a() { } };\n-    check_pp(ext_cx, crate, pprust::print_crate_, ~\"fn a() { }\\n\");\n-\n-    // issue #1926\n-    let s = #ast[expr]{__s};\n-    let e = #ast[expr]{__e};\n-    let call = #ast[expr]{$(s).foo(|__e| $(e) )};\n-    check_pp(ext_cx, call, pprust::print_expr, ~\"__s.foo(|__e| __e)\")\n }\n \n fn check_pp<T>(cx: fake_ext_ctxt,"}, {"sha": "ef3a82d1e2b699e7b44c74281beedff0ab4b0052", "filename": "src/test/run-pass/class-attributes-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Ftest%2Frun-pass%2Fclass-attributes-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Ftest%2Frun-pass%2Fclass-attributes-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-attributes-1.rs?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -16,7 +16,7 @@ struct cat {\n \n impl cat: Drop {\n     #[cat_dropper]\n-    fn finalize(&self) { error!(\"%s landed on hir feet\",self.name); }\n+    fn finalize(&self) { error!(\"%s landed on hir feet\" , self . name); }\n }\n \n "}, {"sha": "e23651d262cc971f103d67efb46ed916b1af7350", "filename": "src/test/run-pass/macro-3.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0138d87f8f1b9f9614e439deb14cbaabad6d104c/src%2Ftest%2Frun-pass%2Fmacro-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0138d87f8f1b9f9614e439deb14cbaabad6d104c/src%2Ftest%2Frun-pass%2Fmacro-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-3.rs?ref=0138d87f8f1b9f9614e439deb14cbaabad6d104c", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-pretty - token trees can't pretty print\n-\n-fn main() {\n-    #macro[[#trivial[], 1 * 2 * 4 * 2 * 1]];\n-\n-    assert (trivial!() == 16);\n-\n-    macro_rules! trivial_tt(\n-        () => {1*2*4*2*1}\n-    )\n-    assert(trivial_tt!() == 16);\n-}"}, {"sha": "3e8bced1b889c460c6de8f60423a204dd48f223a", "filename": "src/test/run-pass/macro-by-example-1.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0138d87f8f1b9f9614e439deb14cbaabad6d104c/src%2Ftest%2Frun-pass%2Fmacro-by-example-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0138d87f8f1b9f9614e439deb14cbaabad6d104c/src%2Ftest%2Frun-pass%2Fmacro-by-example-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-by-example-1.rs?ref=0138d87f8f1b9f9614e439deb14cbaabad6d104c", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-fn main() {\n-    #macro[[#apply[f, [x, ...]], f(x, ...)]];\n-\n-    macro_rules! apply_tt(\n-        ($f:expr, ($($x:expr),*)) => {$f($($x),*)}\n-    )\n-\n-    fn add(a: int, b: int) -> int { return a + b; }\n-\n-    assert(apply!(add, [1, 15]) == 16);\n-    assert(apply!(add, [1, 15]) == 16);\n-    assert(apply_tt!(add, (1, 15)) == 16);\n-}"}, {"sha": "903dc0439e580e65a110e6e3f886f04db285b398", "filename": "src/test/run-pass/macro-by-example-2.rs", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0138d87f8f1b9f9614e439deb14cbaabad6d104c/src%2Ftest%2Frun-pass%2Fmacro-by-example-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0138d87f8f1b9f9614e439deb14cbaabad6d104c/src%2Ftest%2Frun-pass%2Fmacro-by-example-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-by-example-2.rs?ref=0138d87f8f1b9f9614e439deb14cbaabad6d104c", "patch": "@@ -1,60 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-test\n-// I can't for the life of me manage to untangle all of the brackets\n-// in this test, so I am xfailing it...\n-\n-fn main() {\n-    #macro[[#zip_or_unzip[[x, ...], [y, ...]], [[x, y], ...]],\n-           [#zip_or_unzip[[xx, yy], ...], [[xx, ...], [yy, ...]]]];\n-\n-\n-    assert (zip_or_unzip!([1, 2, 3, 4], [5, 6, 7, 8]) ==\n-                [[1, 5], [2, 6], [3, 7], [4, 8]]);\n-    assert (zip_or_unzip!([1, 5], [2, 6], [3, 7], [4, 8]) ==\n-                [[1, 2, 3, 4], [5, 6, 7, 8]]);\n-\n-\n-    #macro[[#nested[[[x, ...], ...], [[y, ...], ...]], [[[x, y], ...], ...]]];\n-    assert (nested!([[1, 2, 3, 4, 5], [7, 8, 9, 10, 11, 12]],\n-                    [[-1, -2, -3, -4, -5], [-7, -8, -9, -10, -11, -12]]) ==\n-                [[[1, -1], [2, -2], [3, -3], [4, -4], [5, -5]],\n-                 [[7, -7], [8, -8], [9, -9], [10, -10], [11, -11],\n-                  [12, -12]]]);\n-\n-    #macro[[#dup[y, [x, ...]], [[y, x], ...]]];\n-\n-    assert (dup!(1, [1, 2, 3, 4]) == [[1, 1], [1, 2], [1, 3], [1, 4]]);\n-\n-\n-    #macro[[#lambda[x, #<t>, body, #<s>],\n-            {\n-                fn result(x: t) -> s { return body }\n-                result\n-            }]];\n-\n-\n-    assert (lambda!(i, #<uint>, i + 4u, #<uint>)(12u) == 16u);\n-\n-    #macro[[#sum[x, xs, ...], x + #sum[xs, ...]], [#sum[], 0]];\n-\n-    assert (sum!(1, 2, 3, 4) == 10);\n-\n-\n-    #macro[[#transcr_mixed[a, as, ...], #sum[6, as, ...] * a]];\n-\n-    assert (transcr_mixed!(10, 5, 4, 3, 2, 1) == 210);\n-\n-    #macro[[#surround[pre, [xs, ...], post], [pre, xs, ..., post]]];\n-\n-    assert (surround!(1, [2, 3, 4], 5) == [1, 2, 3, 4, 5]);\n-\n-}"}, {"sha": "f928043150ede2c0a147bd3bee864b271c615a8f", "filename": "src/test/run-pass/macro.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0138d87f8f1b9f9614e439deb14cbaabad6d104c/src%2Ftest%2Frun-pass%2Fmacro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0138d87f8f1b9f9614e439deb14cbaabad6d104c/src%2Ftest%2Frun-pass%2Fmacro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro.rs?ref=0138d87f8f1b9f9614e439deb14cbaabad6d104c", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-pretty - token trees can't pretty print\n-\n-fn main() {\n-    #macro[[#m1[a], a * 4]];\n-    assert (m1!(2) == 8);\n-\n-    macro_rules! m1tt (\n-        ($a:expr) => {$a*4}\n-    );\n-    assert(m1tt!(2) == 8);\n-}"}, {"sha": "aafd71d9162c838391e8ef4691286d34e5cf90fc", "filename": "src/test/run-pass/syntax-extension-minor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Ftest%2Frun-pass%2Fsyntax-extension-minor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Ftest%2Frun-pass%2Fsyntax-extension-minor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-minor.rs?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -13,6 +13,6 @@ fn main() {\n     let asdf_fdsa = ~\"<.<\";\n     assert (concat_idents!(asd, f_f, dsa) == ~\"<.<\");\n \n-    assert (ident_to_str!(use_mention_distinction) ==\n+    assert (stringify!(use_mention_distinction) ==\n                 ~\"use_mention_distinction\");\n }"}, {"sha": "eca0881deafd5e91bff4a1af171ed4e539750728", "filename": "src/test/run-pass/syntax-extension-source-utils-files/includeme.fragment", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils-files%2Fincludeme.fragment", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils-files%2Fincludeme.fragment", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils-files%2Fincludeme.fragment?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -1,7 +1,7 @@\n /* this is for run-pass/syntax-extension-source-utils.rs */\n \n {\n-    assert(#file[].ends_with(\"includeme.fragment\"));\n-    assert(#line[] == 5u);\n-    #fmt[\"victory robot %u\", #line[]]\n+    assert(file!().ends_with(\"includeme.fragment\"));\n+    assert(line!() == 5u);\n+    fmt!(\"victory robot %u\", line!())\n }"}, {"sha": "0d7174370a084d18225eb0e9cebd96941ba4869c", "filename": "src/test/run-pass/syntax-extension-source-utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0494b078a9555f77d9cd4fbe2a4ff910bfba29b8/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs?ref=0494b078a9555f77d9cd4fbe2a4ff910bfba29b8", "patch": "@@ -24,7 +24,7 @@ fn main() {\n     assert(line!() == 24);\n     assert(col!() == 11);\n     assert(file!().ends_with(~\"syntax-extension-source-utils.rs\"));\n-    assert(stringify!((2*3) + 5) == ~\"(2 * 3) + 5\");\n+    assert(stringify!((2*3) + 5) == ~\"( 2 * 3 ) + 5\");\n     assert(include!(\"syntax-extension-source-utils-files/includeme.fragment\")\n            == ~\"victory robot 6\");\n "}]}