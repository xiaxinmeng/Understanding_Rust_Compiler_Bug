{"sha": "c5022f2f16f380c4847b75d66c20f638b2fd1919", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1MDIyZjJmMTZmMzgwYzQ4NDdiNzVkNjZjMjBmNjM4YjJmZDE5MTk=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-10T11:58:06Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-14T06:52:25Z"}, "message": "rustc_mir: drive passes directly with a macro.", "tree": {"sha": "7abe1f349f202f1a17d353d22c5f0be661edb430", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7abe1f349f202f1a17d353d22c5f0be661edb430"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5022f2f16f380c4847b75d66c20f638b2fd1919", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5022f2f16f380c4847b75d66c20f638b2fd1919", "html_url": "https://github.com/rust-lang/rust/commit/c5022f2f16f380c4847b75d66c20f638b2fd1919", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5022f2f16f380c4847b75d66c20f638b2fd1919/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86206f22a08f32a848f08d0f2415db2f5ef4a89a", "url": "https://api.github.com/repos/rust-lang/rust/commits/86206f22a08f32a848f08d0f2415db2f5ef4a89a", "html_url": "https://github.com/rust-lang/rust/commit/86206f22a08f32a848f08d0f2415db2f5ef4a89a"}], "stats": {"total": 328, "additions": 108, "deletions": 220}, "files": [{"sha": "5e65398e2b90993773109383c413ff4fbb5914b4", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5022f2f16f380c4847b75d66c20f638b2fd1919/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5022f2f16f380c4847b75d66c20f638b2fd1919/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=c5022f2f16f380c4847b75d66c20f638b2fd1919", "patch": "@@ -21,6 +21,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(conservative_impl_trait)]\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n+#![feature(decl_macro)]\n #![feature(i128_type)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(placement_in_syntax)]"}, {"sha": "37ec1efa5cef865fdf2fed7b4e3c350cff524c90", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 15, "deletions": 31, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c5022f2f16f380c4847b75d66c20f638b2fd1919/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5022f2f16f380c4847b75d66c20f638b2fd1919/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=c5022f2f16f380c4847b75d66c20f638b2fd1919", "patch": "@@ -19,7 +19,7 @@ use rustc::mir::Mir;\n use rustc::mir::transform::MirSource;\n use rustc::session::config::{OutputFilenames, OutputType};\n use rustc::ty::TyCtxt;\n-use transform::{MirPass, MirPassIndex, MirSuite, PassHook};\n+use transform::MirPass;\n use util as mir_util;\n \n pub struct Marker(pub &'static str);\n@@ -48,37 +48,21 @@ impl fmt::Display for Disambiguator {\n     }\n }\n \n-pub struct DumpMir;\n \n-impl PassHook for DumpMir {\n-    fn on_mir_pass<'a, 'tcx: 'a>(&self,\n-                                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 suite: MirSuite,\n-                                 pass_num: MirPassIndex,\n-                                 pass_name: &str,\n-                                 source: MirSource,\n-                                 mir: &Mir<'tcx>,\n-                                 is_after: bool)\n-    {\n-        if mir_util::dump_enabled(tcx, pass_name, source) {\n-            mir_util::dump_mir(tcx,\n-                               Some((suite, pass_num)),\n-                               pass_name,\n-                               &Disambiguator { is_after },\n-                               source,\n-                               mir,\n-                               |_, _| Ok(()) );\n-            for (index, promoted_mir) in mir.promoted.iter_enumerated() {\n-                let promoted_source = MirSource::Promoted(source.item_id(), index);\n-                mir_util::dump_mir(tcx,\n-                                   Some((suite, pass_num)),\n-                                   pass_name,\n-                                   &Disambiguator { is_after },\n-                                   promoted_source,\n-                                   promoted_mir,\n-                                   |_, _| Ok(()) );\n-            }\n-        }\n+pub fn on_mir_pass<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             pass_num: &fmt::Display,\n+                             pass_name: &str,\n+                             source: MirSource,\n+                             mir: &Mir<'tcx>,\n+                             is_after: bool) {\n+    if mir_util::dump_enabled(tcx, pass_name, source) {\n+        mir_util::dump_mir(tcx,\n+                           Some(pass_num),\n+                           pass_name,\n+                           &Disambiguator { is_after },\n+                           source,\n+                           mir,\n+                           |_, _| Ok(()) );\n     }\n }\n "}, {"sha": "9b79e7aa11443ee3926a815d999acc41fd939192", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 89, "deletions": 185, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/c5022f2f16f380c4847b75d66c20f638b2fd1919/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5022f2f16f380c4847b75d66c20f638b2fd1919/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=c5022f2f16f380c4847b75d66c20f638b2fd1919", "patch": "@@ -22,7 +22,6 @@ use std::borrow::Cow;\n use std::rc::Rc;\n use syntax::ast;\n use syntax_pos::Span;\n-use transform;\n \n pub mod add_validation;\n pub mod clean_end_regions;\n@@ -109,41 +108,6 @@ fn mir_built<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Stea\n     tcx.alloc_steal_mir(mir)\n }\n \n-fn mir_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Mir<'tcx>> {\n-    // Unsafety check uses the raw mir, so make sure it is run\n-    let _ = tcx.unsafety_check_result(def_id);\n-\n-    let source = MirSource::from_local_def_id(tcx, def_id);\n-    let mut mir = tcx.mir_built(def_id).steal();\n-    transform::run_suite(tcx, source, MIR_CONST, &mut mir);\n-    tcx.alloc_steal_mir(mir)\n-}\n-\n-fn mir_validated<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Mir<'tcx>> {\n-    let source = MirSource::from_local_def_id(tcx, def_id);\n-    if let MirSource::Const(_) = source {\n-        // Ensure that we compute the `mir_const_qualif` for constants at\n-        // this point, before we steal the mir-const result.\n-        let _ = tcx.mir_const_qualif(def_id);\n-    }\n-\n-    let mut mir = tcx.mir_const(def_id).steal();\n-    transform::run_suite(tcx, source, MIR_VALIDATED, &mut mir);\n-    tcx.alloc_steal_mir(mir)\n-}\n-\n-fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Mir<'tcx> {\n-    // (Mir-)Borrowck uses `mir_validated`, so we have to force it to\n-    // execute before we can steal.\n-    let _ = tcx.mir_borrowck(def_id);\n-    let _ = tcx.borrowck(def_id);\n-\n-    let mut mir = tcx.mir_validated(def_id).steal();\n-    let source = MirSource::from_local_def_id(tcx, def_id);\n-    transform::run_suite(tcx, source, MIR_OPTIMIZED, &mut mir);\n-    tcx.alloc_mir(mir)\n-}\n-\n /// Generates a default name for the pass based on the name of the\n /// type `T`.\n pub fn default_name<T: ?Sized>() -> Cow<'static, str> {\n@@ -155,38 +119,6 @@ pub fn default_name<T: ?Sized>() -> Cow<'static, str> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n-pub struct MirSuite(pub usize);\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n-pub struct MirPassIndex(pub usize);\n-\n-/// A pass hook is invoked both before and after each pass executes.\n-/// This is primarily used to dump MIR for debugging.\n-///\n-/// You can tell whether this is before or after by inspecting the\n-/// `mir` parameter -- before the pass executes, it will be `None` (in\n-/// which case you can inspect the MIR from previous pass by executing\n-/// `mir_cx.read_previous_mir()`); after the pass executes, it will be\n-/// `Some()` with the result of the pass (in which case the output\n-/// from the previous pass is most likely stolen, so you would not\n-/// want to try and access it). If the pass is interprocedural, then\n-/// the hook will be invoked once per output.\n-pub trait PassHook {\n-    fn on_mir_pass<'a, 'tcx: 'a>(&self,\n-                                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 suite: MirSuite,\n-                                 pass_num: MirPassIndex,\n-                                 pass_name: &str,\n-                                 source: MirSource,\n-                                 mir: &Mir<'tcx>,\n-                                 is_after: bool);\n-}\n-\n-/// The full suite of types that identifies a particular\n-/// application of a pass to a def-id.\n-pub type PassId = (MirSuite, MirPassIndex, DefId);\n-\n /// A streamlined trait that you can implement to create a pass; the\n /// pass will be named after the type, and it will consist of a main\n /// loop that goes over each available MIR and applies `run_pass`.\n@@ -201,132 +133,104 @@ pub trait MirPass {\n                           mir: &mut Mir<'tcx>);\n }\n \n-/// A manager for MIR passes.\n-///\n-/// FIXME(#41712) -- it is unclear whether we should have this struct.\n-#[derive(Clone)]\n-pub struct Passes {\n-    pass_hooks: Vec<Rc<PassHook>>,\n-    suites: Vec<Vec<Rc<MirPass>>>,\n-}\n-\n-/// The number of \"pass suites\" that we have:\n-///\n-/// - ready for constant evaluation\n-/// - unopt\n-/// - optimized\n-pub const MIR_SUITES: usize = 3;\n-\n-/// Run the passes we need to do constant qualification and evaluation.\n-pub const MIR_CONST: MirSuite = MirSuite(0);\n-\n-/// Run the passes we need to consider the MIR validated and ready for borrowck etc.\n-pub const MIR_VALIDATED: MirSuite = MirSuite(1);\n+pub macro run_passes($tcx:ident, $mir:ident, $source:ident, $suite_index:expr; $($pass:expr,)*) {{\n+    let suite_index: usize = $suite_index;\n+    let run_passes = |mir: &mut _, source| {\n+        let mut index = 0;\n+        let mut run_pass = |pass: &MirPass| {\n+            let run_hooks = |mir: &_, index, is_after| {\n+                dump_mir::on_mir_pass($tcx, &format_args!(\"{:03}-{:03}\", suite_index, index),\n+                                      &pass.name(), source, mir, is_after);\n+            };\n+            run_hooks(mir, index, false);\n+            pass.run_pass($tcx, source, mir);\n+            run_hooks(mir, index, true);\n+\n+            index += 1;\n+        };\n+        $(run_pass(&$pass);)*\n+    };\n+    run_passes(&mut $mir, $source);\n \n-/// Run the passes we need to consider the MIR *optimized*.\n-pub const MIR_OPTIMIZED: MirSuite = MirSuite(2);\n+    for (index, promoted_mir) in $mir.promoted.iter_enumerated_mut() {\n+        run_passes(promoted_mir, MirSource::Promoted($source.item_id(), index));\n \n-impl<'a, 'tcx> Passes {\n-    pub fn new() -> Passes {\n-        Passes {\n-            pass_hooks: Vec::new(),\n-            suites: (0..MIR_SUITES).map(|_| Vec::new()).collect(),\n-        }\n+        // Let's make sure we don't miss any nested instances\n+        assert!(promoted_mir.promoted.is_empty());\n     }\n+}}\n \n-    /// Pushes a built-in pass.\n-    pub fn push_pass<T: MirPass + 'static>(&mut self, suite: MirSuite, pass: T) {\n-        self.suites[suite.0].push(Rc::new(pass));\n-    }\n+fn mir_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Mir<'tcx>> {\n+    // Unsafety check uses the raw mir, so make sure it is run\n+    let _ = tcx.unsafety_check_result(def_id);\n \n-    /// Pushes a pass hook.\n-    pub fn push_hook<T: PassHook + 'static>(&mut self, hook: T) {\n-        self.pass_hooks.push(Rc::new(hook));\n-    }\n+    let mut mir = tcx.mir_built(def_id).steal();\n+    let source = MirSource::from_local_def_id(tcx, def_id);\n+    run_passes![tcx, mir, source, 0;\n+        // Remove all `EndRegion` statements that are not involved in borrows.\n+        clean_end_regions::CleanEndRegions,\n+\n+        // What we need to do constant evaluation.\n+        simplify::SimplifyCfg::new(\"initial\"),\n+        type_check::TypeckMir,\n+        rustc_peek::SanityCheck,\n+    ];\n+    tcx.alloc_steal_mir(mir)\n+}\n \n-    pub fn passes(&self, suite: MirSuite) -> &[Rc<MirPass>] {\n-        &self.suites[suite.0]\n+fn mir_validated<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Mir<'tcx>> {\n+    let source = MirSource::from_local_def_id(tcx, def_id);\n+    if let MirSource::Const(_) = source {\n+        // Ensure that we compute the `mir_const_qualif` for constants at\n+        // this point, before we steal the mir-const result.\n+        let _ = tcx.mir_const_qualif(def_id);\n     }\n \n-    pub fn hooks(&self) -> &[Rc<PassHook>] {\n-        &self.pass_hooks\n-    }\n+    let mut mir = tcx.mir_const(def_id).steal();\n+    run_passes![tcx, mir, source, 1;\n+        // What we need to run borrowck etc.\n+        qualify_consts::QualifyAndPromoteConstants,\n+        simplify::SimplifyCfg::new(\"qualify-consts\"),\n+    ];\n+    tcx.alloc_steal_mir(mir)\n }\n \n-fn run_suite<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                       source: MirSource,\n-                       suite: MirSuite,\n-                       mir: &mut Mir<'tcx>)\n-{\n-    // Setup the MIR passes that we want to run.\n-    let mut passes = Passes::new();\n-    passes.push_hook(dump_mir::DumpMir);\n-\n-    // Remove all `EndRegion` statements that are not involved in borrows.\n-    passes.push_pass(MIR_CONST, clean_end_regions::CleanEndRegions);\n-\n-    // What we need to do constant evaluation.\n-    passes.push_pass(MIR_CONST, simplify::SimplifyCfg::new(\"initial\"));\n-    passes.push_pass(MIR_CONST, type_check::TypeckMir);\n-    passes.push_pass(MIR_CONST, rustc_peek::SanityCheck);\n-\n-    // We compute \"constant qualifications\" between MIR_CONST and MIR_VALIDATED.\n-\n-    // What we need to run borrowck etc.\n-\n-    passes.push_pass(MIR_VALIDATED, qualify_consts::QualifyAndPromoteConstants);\n-    passes.push_pass(MIR_VALIDATED, simplify::SimplifyCfg::new(\"qualify-consts\"));\n-\n-    // borrowck runs between MIR_VALIDATED and MIR_OPTIMIZED.\n-\n-    passes.push_pass(MIR_OPTIMIZED, no_landing_pads::NoLandingPads);\n-    passes.push_pass(MIR_OPTIMIZED,\n-                     simplify_branches::SimplifyBranches::new(\"initial\"));\n-\n-    // These next passes must be executed together\n-    passes.push_pass(MIR_OPTIMIZED, add_call_guards::CriticalCallEdges);\n-    passes.push_pass(MIR_OPTIMIZED, elaborate_drops::ElaborateDrops);\n-    passes.push_pass(MIR_OPTIMIZED, no_landing_pads::NoLandingPads);\n-    // AddValidation needs to run after ElaborateDrops and before EraseRegions, and it needs\n-    // an AllCallEdges pass right before it.\n-    passes.push_pass(MIR_OPTIMIZED, add_call_guards::AllCallEdges);\n-    passes.push_pass(MIR_OPTIMIZED, add_validation::AddValidation);\n-    passes.push_pass(MIR_OPTIMIZED, simplify::SimplifyCfg::new(\"elaborate-drops\"));\n-    // No lifetime analysis based on borrowing can be done from here on out.\n-\n-    // From here on out, regions are gone.\n-    passes.push_pass(MIR_OPTIMIZED, erase_regions::EraseRegions);\n-\n-    // Optimizations begin.\n-    passes.push_pass(MIR_OPTIMIZED, inline::Inline);\n-    passes.push_pass(MIR_OPTIMIZED, instcombine::InstCombine);\n-    passes.push_pass(MIR_OPTIMIZED, deaggregator::Deaggregator);\n-    passes.push_pass(MIR_OPTIMIZED, copy_prop::CopyPropagation);\n-    passes.push_pass(MIR_OPTIMIZED, simplify::SimplifyLocals);\n-\n-    passes.push_pass(MIR_OPTIMIZED, generator::StateTransform);\n-    passes.push_pass(MIR_OPTIMIZED, add_call_guards::CriticalCallEdges);\n-    passes.push_pass(MIR_OPTIMIZED, dump_mir::Marker(\"PreTrans\"));\n-\n-    for (index, pass) in passes.passes(suite).iter().enumerate() {\n-        let pass_num = MirPassIndex(index);\n-\n-        for hook in passes.hooks() {\n-            hook.on_mir_pass(tcx, suite, pass_num, &pass.name(), source, &mir, false);\n-        }\n-\n-        pass.run_pass(tcx, source, mir);\n-\n-        for (index, promoted_mir) in mir.promoted.iter_enumerated_mut() {\n-            let promoted_source = MirSource::Promoted(source.item_id(), index);\n-            pass.run_pass(tcx, promoted_source, promoted_mir);\n-\n-            // Let's make sure we don't miss any nested instances\n-            assert!(promoted_mir.promoted.is_empty());\n-        }\n+fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Mir<'tcx> {\n+    // (Mir-)Borrowck uses `mir_validated`, so we have to force it to\n+    // execute before we can steal.\n+    let _ = tcx.mir_borrowck(def_id);\n+    let _ = tcx.borrowck(def_id);\n \n-        for hook in passes.hooks() {\n-            hook.on_mir_pass(tcx, suite, pass_num, &pass.name(), source, &mir, true);\n-        }\n-    }\n+    let mut mir = tcx.mir_validated(def_id).steal();\n+    let source = MirSource::from_local_def_id(tcx, def_id);\n+    run_passes![tcx, mir, source, 2;\n+        no_landing_pads::NoLandingPads,\n+        simplify_branches::SimplifyBranches::new(\"initial\"),\n+\n+        // These next passes must be executed together\n+        add_call_guards::CriticalCallEdges,\n+        elaborate_drops::ElaborateDrops,\n+        no_landing_pads::NoLandingPads,\n+        // AddValidation needs to run after ElaborateDrops and before EraseRegions, and it needs\n+        // an AllCallEdges pass right before it.\n+        add_call_guards::AllCallEdges,\n+        add_validation::AddValidation,\n+        simplify::SimplifyCfg::new(\"elaborate-drops\"),\n+        // No lifetime analysis based on borrowing can be done from here on out.\n+\n+        // From here on out, regions are gone.\n+        erase_regions::EraseRegions,\n+\n+        // Optimizations begin.\n+        inline::Inline,\n+        instcombine::InstCombine,\n+        deaggregator::Deaggregator,\n+        copy_prop::CopyPropagation,\n+        simplify::SimplifyLocals,\n+\n+        generator::StateTransform,\n+        add_call_guards::CriticalCallEdges,\n+        dump_mir::Marker(\"PreTrans\"),\n+    ];\n+    tcx.alloc_mir(mir)\n }"}, {"sha": "927d885f2c93b91d0ae23117a91cb256cd284bfb", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c5022f2f16f380c4847b75d66c20f638b2fd1919/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5022f2f16f380c4847b75d66c20f638b2fd1919/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=c5022f2f16f380c4847b75d66c20f638b2fd1919", "patch": "@@ -20,7 +20,6 @@ use std::fmt::Display;\n use std::fs;\n use std::io::{self, Write};\n use std::path::{PathBuf, Path};\n-use transform::{MirSuite, MirPassIndex};\n use super::graphviz::write_mir_fn_graphviz;\n \n const INDENT: &'static str = \"    \";\n@@ -58,7 +57,7 @@ pub enum PassWhere {\n ///   that can appear in the pass-name or the `item_path_str` for the given\n ///   node-id. If any one of the substrings match, the data is dumped out.\n pub fn dump_mir<'a, 'gcx, 'tcx, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                   pass_num: Option<(MirSuite, MirPassIndex)>,\n+                                   pass_num: Option<&Display>,\n                                    pass_name: &str,\n                                    disambiguator: &Display,\n                                    source: MirSource,\n@@ -103,7 +102,7 @@ pub fn dump_enabled<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n // run while we are already attempting to evaluate `type_of`.\n \n fn dump_matched_mir_node<'a, 'gcx, 'tcx, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                            pass_num: Option<(MirSuite, MirPassIndex)>,\n+                                            pass_num: Option<&Display>,\n                                             pass_name: &str,\n                                             node_path: &str,\n                                             disambiguator: &Display,\n@@ -124,7 +123,7 @@ where\n     } else {\n         match pass_num {\n             None => format!(\".-------\"),\n-            Some((suite, pass_num)) => format!(\".{:03}-{:03}\", suite.0, pass_num.0),\n+            Some(pass_num) => format!(\".{}\", pass_num),\n         }\n     };\n "}]}