{"sha": "90e3665fa79d32c3188169cfa992516fb36b81a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwZTM2NjVmYTc5ZDMyYzMxODgxNjljZmE5OTI1MTZmYjM2YjgxYTg=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-21T00:37:10Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-21T00:37:21Z"}, "message": "syntax: Make attributes sendable for rustdoc's benefit", "tree": {"sha": "744d1e3eff6316baf1be0018f74191023fb18dab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/744d1e3eff6316baf1be0018f74191023fb18dab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90e3665fa79d32c3188169cfa992516fb36b81a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90e3665fa79d32c3188169cfa992516fb36b81a8", "html_url": "https://github.com/rust-lang/rust/commit/90e3665fa79d32c3188169cfa992516fb36b81a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90e3665fa79d32c3188169cfa992516fb36b81a8/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19ad88c2b81d733d50474896d2e0c870a9dc3015", "url": "https://api.github.com/repos/rust-lang/rust/commits/19ad88c2b81d733d50474896d2e0c870a9dc3015", "html_url": "https://github.com/rust-lang/rust/commit/19ad88c2b81d733d50474896d2e0c870a9dc3015"}], "stats": {"total": 212, "additions": 106, "deletions": 106}, "files": [{"sha": "d5a5528f8c9a8314742e0e527e0ad0dbbf242909", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=90e3665fa79d32c3188169cfa992516fb36b81a8", "patch": "@@ -279,7 +279,7 @@ fn assume_source_method(url: ~str) -> ~str {\n     ~\"curl\"\n }\n \n-fn load_link(mis: ~[@ast::meta_item]) -> (Option<~str>,\n+fn load_link(mis: ~[ast::meta_item]) -> (Option<~str>,\n                                          Option<~str>,\n                                          Option<~str>) {\n     let mut name = None;\n@@ -358,9 +358,9 @@ fn load_crate(filename: &Path) -> Option<crate> {\n                 let mut attr_from = ~\"\";\n \n               for m.each |item| {\n-                    match attr::get_meta_item_value_str(*item) {\n+                    match attr::get_meta_item_value_str(item) {\n                         Some(value) => {\n-                            let name = attr::get_meta_item_name(*item);\n+                            let name = attr::get_meta_item_name(item);\n \n                             match name {\n                                 ~\"vers\" => attr_vers = value,"}, {"sha": "90d9dd28c9bd4925f7d7f4e084a2e35a28cd4b91", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=90e3665fa79d32c3188169cfa992516fb36b81a8", "patch": "@@ -388,7 +388,7 @@ impl def : cmp::Eq {\n \n // The set of meta_items that define the compilation environment of the crate,\n // used to drive conditional compilation\n-type crate_cfg = ~[@meta_item];\n+type crate_cfg = ~[meta_item];\n \n type crate = spanned<crate_>;\n \n@@ -420,7 +420,7 @@ type meta_item = spanned<meta_item_>;\n #[auto_serialize]\n enum meta_item_ {\n     meta_word(~str),\n-    meta_list(~str, ~[@meta_item]),\n+    meta_list(~str, ~[meta_item]),\n     meta_name_value(~str, lit),\n }\n \n@@ -1859,7 +1859,7 @@ type view_item = {node: view_item_, attrs: ~[attribute],\n \n #[auto_serialize]\n enum view_item_ {\n-    view_item_use(ident, ~[@meta_item], node_id),\n+    view_item_use(ident, ~[meta_item], node_id),\n     view_item_import(~[@view_path]),\n     view_item_export(~[@view_path])\n }"}, {"sha": "f8792ab6c202e090aba3b4fe601df79869eaf592", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=90e3665fa79d32c3188169cfa992516fb36b81a8", "patch": "@@ -50,27 +50,27 @@ export require_unique_names;\n /* Constructors */\n \n fn mk_name_value_item_str(name: ~str, +value: ~str) ->\n-    @ast::meta_item {\n+    ast::meta_item {\n     let value_lit = dummy_spanned(ast::lit_str(@value));\n     return mk_name_value_item(name, value_lit);\n }\n \n fn mk_name_value_item(name: ~str, +value: ast::lit)\n-        -> @ast::meta_item {\n-    return @dummy_spanned(ast::meta_name_value(name, value));\n+        -> ast::meta_item {\n+    return dummy_spanned(ast::meta_name_value(name, value));\n }\n \n-fn mk_list_item(name: ~str, +items: ~[@ast::meta_item]) ->\n-   @ast::meta_item {\n-    return @dummy_spanned(ast::meta_list(name, items));\n+fn mk_list_item(name: ~str, +items: ~[ast::meta_item]) ->\n+   ast::meta_item {\n+    return dummy_spanned(ast::meta_list(name, items));\n }\n \n-fn mk_word_item(name: ~str) -> @ast::meta_item {\n-    return @dummy_spanned(ast::meta_word(name));\n+fn mk_word_item(name: ~str) -> ast::meta_item {\n+    return dummy_spanned(ast::meta_word(name));\n }\n \n-fn mk_attr(item: @ast::meta_item) -> ast::attribute {\n-    return dummy_spanned({style: ast::attr_inner, value: *item,\n+fn mk_attr(+item: ast::meta_item) -> ast::attribute {\n+    return dummy_spanned({style: ast::attr_inner, value: item,\n                        is_sugared_doc: false});\n }\n \n@@ -86,10 +86,10 @@ fn mk_sugared_doc_attr(text: ~str, lo: uint, hi: uint) -> ast::attribute {\n \n /* Conversion */\n \n-fn attr_meta(attr: ast::attribute) -> @ast::meta_item { @attr.node.value }\n+fn attr_meta(attr: ast::attribute) -> ast::meta_item { attr.node.value }\n \n // Get the meta_items from inside a vector of attributes\n-fn attr_metas(attrs: ~[ast::attribute]) -> ~[@ast::meta_item] {\n+fn attr_metas(attrs: ~[ast::attribute]) -> ~[ast::meta_item] {\n     let mut mitems = ~[];\n     for attrs.each |a| { vec::push(mitems, attr_meta(*a)); }\n     return mitems;\n@@ -112,7 +112,7 @@ fn get_attr_name(attr: ast::attribute) -> ~str {\n     get_meta_item_name(@attr.node.value)\n }\n \n-fn get_meta_item_name(meta: @ast::meta_item) -> ~str {\n+fn get_meta_item_name(meta: &ast::meta_item) -> ~str {\n     match meta.node {\n       ast::meta_word(n) => n,\n       ast::meta_name_value(n, _) => n,\n@@ -124,7 +124,7 @@ fn get_meta_item_name(meta: @ast::meta_item) -> ~str {\n  * Gets the string value if the meta_item is a meta_name_value variant\n  * containing a string, otherwise none\n  */\n-fn get_meta_item_value_str(meta: @ast::meta_item) -> Option<~str> {\n+fn get_meta_item_value_str(meta: &ast::meta_item) -> Option<~str> {\n     match meta.node {\n         ast::meta_name_value(_, v) => match v.node {\n             ast::lit_str(s) => option::Some(*s),\n@@ -135,7 +135,7 @@ fn get_meta_item_value_str(meta: @ast::meta_item) -> Option<~str> {\n }\n \n /// Gets a list of inner meta items from a list meta_item type\n-fn get_meta_item_list(meta: @ast::meta_item) -> Option<~[@ast::meta_item]> {\n+fn get_meta_item_list(meta: &ast::meta_item) -> Option<~[ast::meta_item]> {\n     match meta.node {\n       ast::meta_list(_, l) => option::Some(/* FIXME (#2543) */ copy l),\n       _ => option::None\n@@ -146,7 +146,7 @@ fn get_meta_item_list(meta: @ast::meta_item) -> Option<~[@ast::meta_item]> {\n  * If the meta item is a nam-value type with a string value then returns\n  * a tuple containing the name and string value, otherwise `none`\n  */\n-fn get_name_value_str_pair(item: @ast::meta_item) -> Option<(~str, ~str)> {\n+fn get_name_value_str_pair(item: &ast::meta_item) -> Option<(~str, ~str)> {\n     match attr::get_meta_item_value_str(item) {\n       Some(value) => {\n         let name = attr::get_meta_item_name(item);\n@@ -173,10 +173,10 @@ fn find_attrs_by_name(attrs: ~[ast::attribute], name: ~str) ->\n }\n \n /// Searcha list of meta items and return only those with a specific name\n-fn find_meta_items_by_name(metas: ~[@ast::meta_item], name: ~str) ->\n-   ~[@ast::meta_item] {\n-    let filter = fn@(&&m: @ast::meta_item) -> Option<@ast::meta_item> {\n-        if get_meta_item_name(m) == name {\n+fn find_meta_items_by_name(metas: ~[ast::meta_item], name: ~str) ->\n+   ~[ast::meta_item] {\n+    let filter = fn@(&&m: ast::meta_item) -> Option<ast::meta_item> {\n+        if get_meta_item_name(&m) == name {\n             option::Some(m)\n         } else { option::None }\n     };\n@@ -187,14 +187,14 @@ fn find_meta_items_by_name(metas: ~[@ast::meta_item], name: ~str) ->\n  * Returns true if a list of meta items contains another meta item. The\n  * comparison is performed structurally.\n  */\n-fn contains(haystack: ~[@ast::meta_item], needle: @ast::meta_item) -> bool {\n+fn contains(haystack: ~[ast::meta_item], needle: &ast::meta_item) -> bool {\n     for haystack.each |item| {\n-        if eq(*item, needle) { return true; }\n+        if eq(item, needle) { return true; }\n     }\n     return false;\n }\n \n-fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n+fn eq(a: &ast::meta_item, b: &ast::meta_item) -> bool {\n     return match a.node {\n           ast::meta_word(na) => match b.node {\n             ast::meta_word(nb) => na == nb,\n@@ -215,7 +215,7 @@ fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n         }\n }\n \n-fn contains_name(metas: ~[@ast::meta_item], name: ~str) -> bool {\n+fn contains_name(metas: ~[ast::meta_item], name: ~str) -> bool {\n     let matches = find_meta_items_by_name(metas, name);\n     return vec::len(matches) > 0u;\n }\n@@ -229,35 +229,35 @@ fn first_attr_value_str_by_name(attrs: ~[ast::attribute], name: ~str)\n \n     let mattrs = find_attrs_by_name(attrs, name);\n     if vec::len(mattrs) > 0u {\n-        return get_meta_item_value_str(attr_meta(mattrs[0]));\n+        return get_meta_item_value_str(&attr_meta(mattrs[0]));\n     }\n     return option::None;\n }\n \n-fn last_meta_item_by_name(items: ~[@ast::meta_item], name: ~str)\n-    -> Option<@ast::meta_item> {\n+fn last_meta_item_by_name(items: ~[ast::meta_item], name: ~str)\n+    -> Option<ast::meta_item> {\n \n     let items = attr::find_meta_items_by_name(items, name);\n     vec::last_opt(items)\n }\n \n-fn last_meta_item_value_str_by_name(items: ~[@ast::meta_item], name: ~str)\n+fn last_meta_item_value_str_by_name(items: ~[ast::meta_item], name: ~str)\n     -> Option<~str> {\n \n     match last_meta_item_by_name(items, name) {\n-      Some(item) => match attr::get_meta_item_value_str(item) {\n+      Some(item) => match attr::get_meta_item_value_str(&item) {\n         Some(value) => Some(value),\n         None => None\n       },\n       None => None\n     }\n }\n \n-fn last_meta_item_list_by_name(items: ~[@ast::meta_item], name: ~str)\n-    -> Option<~[@ast::meta_item]> {\n+fn last_meta_item_list_by_name(items: ~[ast::meta_item], name: ~str)\n+    -> Option<~[ast::meta_item]> {\n \n     match last_meta_item_by_name(items, name) {\n-      Some(item) => attr::get_meta_item_list(item),\n+      Some(item) => attr::get_meta_item_list(&item),\n       None => None\n     }\n }\n@@ -267,29 +267,29 @@ fn last_meta_item_list_by_name(items: ~[@ast::meta_item], name: ~str)\n \n // FIXME (#607): This needs to sort by meta_item variant in addition to\n // the item name (See [Fixme-sorting])\n-fn sort_meta_items(+items: ~[@ast::meta_item]) -> ~[@ast::meta_item] {\n-    pure fn lteq(ma: &@ast::meta_item, mb: &@ast::meta_item) -> bool {\n+fn sort_meta_items(+items: ~[ast::meta_item]) -> ~[ast::meta_item] {\n+    pure fn lteq(ma: &ast::meta_item, mb: &ast::meta_item) -> bool {\n         pure fn key(m: &ast::meta_item) -> ~str {\n             match m.node {\n               ast::meta_word(name) => name,\n               ast::meta_name_value(name, _) => name,\n               ast::meta_list(name, _) => name\n             }\n         }\n-        key(*ma) <= key(*mb)\n+        key(ma) <= key(mb)\n     }\n \n     // This is sort of stupid here, converting to a vec of mutables and back\n-    let v: ~[mut @ast::meta_item] = vec::to_mut(items);\n+    let v: ~[mut ast::meta_item] = vec::to_mut(items);\n     std::sort::quick_sort(lteq, v);\n     vec::from_mut(move v)\n }\n \n-fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: ~str) ->\n-   ~[@ast::meta_item] {\n+fn remove_meta_items_by_name(items: ~[ast::meta_item], name: ~str) ->\n+   ~[ast::meta_item] {\n \n     return vec::filter_map(items, |item| {\n-        if get_meta_item_name(item) != name {\n+        if get_meta_item_name(&item) != name {\n             option::Some(/* FIXME (#2543) */ copy item)\n         } else {\n             option::None\n@@ -301,7 +301,7 @@ fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: ~str) ->\n  * From a list of crate attributes get only the meta_items that affect crate\n  * linkage\n  */\n-fn find_linkage_metas(attrs: ~[ast::attribute]) -> ~[@ast::meta_item] {\n+fn find_linkage_metas(attrs: ~[ast::attribute]) -> ~[ast::meta_item] {\n     do find_attrs_by_name(attrs, ~\"link\").flat_map |attr| {\n         match attr.node.value.node {\n             ast::meta_list(_, items) => /* FIXME (#2543) */ copy items,\n@@ -376,10 +376,10 @@ fn find_inline_attr(attrs: ~[ast::attribute]) -> inline_attr {\n \n \n fn require_unique_names(diagnostic: span_handler,\n-                        metas: ~[@ast::meta_item]) {\n+                        metas: ~[ast::meta_item]) {\n     let map = map::HashMap();\n     for metas.each |meta| {\n-        let name = get_meta_item_name(*meta);\n+        let name = get_meta_item_name(meta);\n \n         // FIXME: How do I silence the warnings? --pcw (#2619)\n         if map.contains_key(name) {"}, {"sha": "45c7483765e9146b34d9917d3229fcc8e8d77c09", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=90e3665fa79d32c3188169cfa992516fb36b81a8", "patch": "@@ -215,8 +215,8 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n             style: ast::attr_outer,\n             value: respan(self.empty_span(),\n                           ast::meta_list(~\"allow\", ~[\n-                              @respan(self.empty_span(),\n-                                      ast::meta_word(~\"non_camel_case_types\"))\n+                              respan(self.empty_span(),\n+                                     ast::meta_word(~\"non_camel_case_types\"))\n                           ])),\n             is_sugared_doc: false\n         });"}, {"sha": "ee24857b96ed03d781a3fd39475fe959223d6a4b", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=90e3665fa79d32c3188169cfa992516fb36b81a8", "patch": "@@ -78,8 +78,8 @@ type ast_fold_precursor = @{\n /* some little folds that probably aren't useful to have in ast_fold itself*/\n \n //used in noop_fold_item and noop_fold_crate and noop_fold_crate_directive\n-fn fold_meta_item_(&&mi: @meta_item, fld: ast_fold) -> @meta_item {\n-    return @{node:\n+fn fold_meta_item_(&&mi: meta_item, fld: ast_fold) -> meta_item {\n+    return {node:\n               match mi.node {\n                 meta_word(id) => meta_word(id),\n                 meta_list(id, mis) => {\n@@ -97,7 +97,7 @@ fn fold_meta_item_(&&mi: @meta_item, fld: ast_fold) -> @meta_item {\n fn fold_attribute_(at: attribute, fld: ast_fold) ->\n    attribute {\n     return {node: {style: at.node.style,\n-                value: *fold_meta_item_(@at.node.value, fld),\n+                value: fold_meta_item_(at.node.value, fld),\n                 is_sugared_doc: at.node.is_sugared_doc },\n          span: fld.new_span(at.span)};\n }"}, {"sha": "fcbdf7807730b739735278c21c1bd4bb649a761c", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=90e3665fa79d32c3188169cfa992516fb36b81a8", "patch": "@@ -18,9 +18,9 @@ trait parser_attr {\n         ast::attribute;\n     fn parse_inner_attrs_and_next() ->\n         {inner: ~[ast::attribute], next: ~[ast::attribute]};\n-    fn parse_meta_item() -> @ast::meta_item;\n-    fn parse_meta_seq() -> ~[@ast::meta_item];\n-    fn parse_optional_meta() -> ~[@ast::meta_item];\n+    fn parse_meta_item() -> ast::meta_item;\n+    fn parse_meta_seq() -> ~[ast::meta_item];\n+    fn parse_optional_meta() -> ~[ast::meta_item];\n }\n \n impl parser: parser_attr {\n@@ -91,7 +91,7 @@ impl parser: parser_attr {\n         let meta_item = self.parse_meta_item();\n         self.expect(token::RBRACKET);\n         let mut hi = self.span.hi;\n-        return spanned(lo, hi, {style: style, value: *meta_item,\n+        return spanned(lo, hi, {style: style, value: meta_item,\n                              is_sugared_doc: false});\n     }\n \n@@ -143,35 +143,35 @@ impl parser: parser_attr {\n         return {inner: inner_attrs, next: next_outer_attrs};\n     }\n \n-    fn parse_meta_item() -> @ast::meta_item {\n+    fn parse_meta_item() -> ast::meta_item {\n         let lo = self.span.lo;\n         let name = *self.id_to_str(self.parse_ident());\n         match self.token {\n           token::EQ => {\n             self.bump();\n             let lit = self.parse_lit();\n             let mut hi = self.span.hi;\n-            return @spanned(lo, hi, ast::meta_name_value(name, lit));\n+            return spanned(lo, hi, ast::meta_name_value(name, lit));\n           }\n           token::LPAREN => {\n             let inner_items = self.parse_meta_seq();\n             let mut hi = self.span.hi;\n-            return @spanned(lo, hi, ast::meta_list(name, inner_items));\n+            return spanned(lo, hi, ast::meta_list(name, inner_items));\n           }\n           _ => {\n             let mut hi = self.span.hi;\n-            return @spanned(lo, hi, ast::meta_word(name));\n+            return spanned(lo, hi, ast::meta_word(name));\n           }\n         }\n     }\n \n-    fn parse_meta_seq() -> ~[@ast::meta_item] {\n+    fn parse_meta_seq() -> ~[ast::meta_item] {\n         return self.parse_seq(token::LPAREN, token::RPAREN,\n                            seq_sep_trailing_disallowed(token::COMMA),\n                            |p| p.parse_meta_item()).node;\n     }\n \n-    fn parse_optional_meta() -> ~[@ast::meta_item] {\n+    fn parse_optional_meta() -> ~[ast::meta_item] {\n         match self.token {\n           token::LPAREN => return self.parse_meta_seq(),\n           _ => return ~[]"}, {"sha": "a218e866710791a9a72aec978f2e538bca469868", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=90e3665fa79d32c3188169cfa992516fb36b81a8", "patch": "@@ -159,7 +159,7 @@ fn block_to_str(blk: ast::blk, intr: ident_interner) -> ~str {\n     }\n }\n \n-fn meta_item_to_str(mi: @ast::meta_item, intr: ident_interner) -> ~str {\n+fn meta_item_to_str(mi: ast::meta_item, intr: ident_interner) -> ~str {\n     to_str(mi, print_meta_item, intr)\n }\n \n@@ -800,11 +800,11 @@ fn print_attribute(s: ps, attr: ast::attribute) {\n     maybe_print_comment(s, attr.span.lo);\n     if attr.node.is_sugared_doc {\n         let meta = attr::attr_meta(attr);\n-        let comment = attr::get_meta_item_value_str(meta).get();\n+        let comment = attr::get_meta_item_value_str(&meta).get();\n         word(s.s, comment);\n     } else {\n         word(s.s, ~\"#[\");\n-        print_meta_item(s, @attr.node.value);\n+        print_meta_item(s, attr.node.value);\n         word(s.s, ~\"]\");\n     }\n }\n@@ -1701,7 +1701,7 @@ fn print_type_params(s: ps, &&params: ~[ast::ty_param]) {\n     }\n }\n \n-fn print_meta_item(s: ps, &&item: @ast::meta_item) {\n+fn print_meta_item(s: ps, &&item: ast::meta_item) {\n     ibox(s, indent_unit);\n     match item.node {\n       ast::meta_word(name) => word(s.s, name),"}, {"sha": "da5f924b865002974ce54bc8b59276b8f5ed2aed", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=90e3665fa79d32c3188169cfa992516fb36b81a8", "patch": "@@ -385,23 +385,23 @@ fn build_link_meta(sess: session, c: ast::crate, output: &Path,\n     type provided_metas =\n         {name: Option<~str>,\n          vers: Option<~str>,\n-         cmh_items: ~[@ast::meta_item]};\n+         cmh_items: ~[ast::meta_item]};\n \n     fn provided_link_metas(sess: session, c: ast::crate) ->\n        provided_metas {\n         let mut name: Option<~str> = None;\n         let mut vers: Option<~str> = None;\n-        let mut cmh_items: ~[@ast::meta_item] = ~[];\n+        let mut cmh_items: ~[ast::meta_item] = ~[];\n         let linkage_metas = attr::find_linkage_metas(c.node.attrs);\n         attr::require_unique_names(sess.diagnostic(), linkage_metas);\n         for linkage_metas.each |meta| {\n-            if attr::get_meta_item_name(*meta) == ~\"name\" {\n-                match attr::get_meta_item_value_str(*meta) {\n+            if attr::get_meta_item_name(meta) == ~\"name\" {\n+                match attr::get_meta_item_value_str(meta) {\n                   Some(v) => { name = Some(v); }\n                   None => vec::push(cmh_items, *meta)\n                 }\n-            } else if attr::get_meta_item_name(*meta) == ~\"vers\" {\n-                match attr::get_meta_item_value_str(*meta) {\n+            } else if attr::get_meta_item_name(meta) == ~\"vers\" {\n+                match attr::get_meta_item_value_str(meta) {\n                   Some(v) => { vers = Some(v); }\n                   None => vec::push(cmh_items, *meta)\n                 }"}, {"sha": "d1545fd62a639109bd571d7da85e74af335a9073", "filename": "src/rustc/front/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Frustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Frustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fconfig.rs?ref=90e3665fa79d32c3188169cfa992516fb36b81a8", "patch": "@@ -127,7 +127,7 @@ fn in_cfg(cfg: ast::crate_cfg, attrs: ~[ast::attribute]) -> bool {\n     metas_in_cfg(cfg, attr::attr_metas(attrs))\n }\n \n-fn metas_in_cfg(cfg: ast::crate_cfg, metas: ~[@ast::meta_item]) -> bool {\n+fn metas_in_cfg(cfg: ast::crate_cfg, metas: ~[ast::meta_item]) -> bool {\n \n     // The \"cfg\" attributes on the item\n     let cfg_metas = attr::find_meta_items_by_name(metas, ~\"cfg\");\n@@ -136,13 +136,13 @@ fn metas_in_cfg(cfg: ast::crate_cfg, metas: ~[@ast::meta_item]) -> bool {\n     // so we can match against them. This is the list of configurations for\n     // which the item is valid\n     let cfg_metas = vec::concat(vec::filter_map(cfg_metas,\n-        |&&i| attr::get_meta_item_list(i) ));\n+        |&&i| attr::get_meta_item_list(&i) ));\n \n     let has_cfg_metas = vec::len(cfg_metas) > 0u;\n     if !has_cfg_metas { return true; }\n \n     for cfg_metas.each |cfg_mi| {\n-        if attr::contains(cfg, *cfg_mi) { return true; }\n+        if attr::contains(cfg, cfg_mi) { return true; }\n     }\n \n     return false;"}, {"sha": "b40acbe8679c962b7853827cc2c278622dcedbb1", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=90e3665fa79d32c3188169cfa992516fb36b81a8", "patch": "@@ -152,7 +152,7 @@ fn is_ignored(cx: test_ctxt, i: @ast::item) -> bool {\n     let ignoreattrs = attr::find_attrs_by_name(i.attrs, ~\"ignore\");\n     let ignoreitems = attr::attr_metas(ignoreattrs);\n     let cfg_metas = vec::concat(vec::filter_map(ignoreitems,\n-        |&&i| attr::get_meta_item_list(i) ));\n+        |&&i| attr::get_meta_item_list(&i) ));\n     return if vec::is_not_empty(ignoreitems) {\n         config::metas_in_cfg(cx.crate.node.config, cfg_metas)\n     } else {"}, {"sha": "36857558fdcf27927897fdfdf6377be3eb0e5c9a", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=90e3665fa79d32c3188169cfa992516fb36b81a8", "patch": "@@ -41,7 +41,7 @@ type cache_entry = {\n     cnum: int,\n     span: span,\n     hash: ~str,\n-    metas: @~[@ast::meta_item]\n+    metas: @~[ast::meta_item]\n };\n \n fn dump_crates(crate_cache: DVec<cache_entry>) {\n@@ -150,7 +150,7 @@ fn visit_item(e: env, i: @ast::item) {\n         }\n \n         for link_args.each |a| {\n-            match attr::get_meta_item_value_str(attr::attr_meta(*a)) {\n+            match attr::get_meta_item_value_str(&attr::attr_meta(*a)) {\n               Some(linkarg) => {\n                 cstore::add_used_link_args(cstore, linkarg);\n               }\n@@ -162,8 +162,8 @@ fn visit_item(e: env, i: @ast::item) {\n     }\n }\n \n-fn metas_with(ident: ~str, key: ~str, metas: ~[@ast::meta_item])\n-    -> ~[@ast::meta_item] {\n+fn metas_with(ident: ~str, key: ~str, metas: ~[ast::meta_item])\n+    -> ~[ast::meta_item] {\n     let name_items = attr::find_meta_items_by_name(metas, key);\n     if name_items.is_empty() {\n         vec::append_one(metas, attr::mk_name_value_item_str(key, ident))\n@@ -172,12 +172,12 @@ fn metas_with(ident: ~str, key: ~str, metas: ~[@ast::meta_item])\n     }\n }\n \n-fn metas_with_ident(ident: ~str, metas: ~[@ast::meta_item])\n-    -> ~[@ast::meta_item] {\n+fn metas_with_ident(ident: ~str, metas: ~[ast::meta_item])\n+    -> ~[ast::meta_item] {\n     metas_with(ident, ~\"name\", metas)\n }\n \n-fn existing_match(e: env, metas: ~[@ast::meta_item], hash: ~str) ->\n+fn existing_match(e: env, metas: ~[ast::meta_item], hash: ~str) ->\n     Option<int> {\n \n     for e.crate_cache.each |c| {\n@@ -189,7 +189,7 @@ fn existing_match(e: env, metas: ~[@ast::meta_item], hash: ~str) ->\n     return None;\n }\n \n-fn resolve_crate(e: env, ident: ast::ident, metas: ~[@ast::meta_item],\n+fn resolve_crate(e: env, ident: ast::ident, metas: ~[ast::meta_item],\n                  hash: ~str, span: span) -> ast::crate_num {\n     let metas = metas_with_ident(*e.intr.get(ident), metas);\n "}, {"sha": "6d2d636cae2be0fc52c25d0431cf5d775fb5bf2a", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=90e3665fa79d32c3188169cfa992516fb36b81a8", "patch": "@@ -108,7 +108,7 @@ fn get_method_names_if_trait(cstore: cstore::cstore, def: ast::def_id)\n \n fn get_item_attrs(cstore: cstore::cstore,\n                   def_id: ast::def_id,\n-                  f: fn(~[@ast::meta_item])) {\n+                  f: fn(~[ast::meta_item])) {\n \n     let cdata = cstore::get_crate_data(cstore, def_id.crate);\n     decoder::get_item_attrs(cdata, def_id.node, f)"}, {"sha": "4c775d87c215e2552874f8f0cef6d56573885499", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=90e3665fa79d32c3188169cfa992516fb36b81a8", "patch": "@@ -742,7 +742,7 @@ fn get_method_names_if_trait(intr: ident_interner, cdata: cmd,\n \n fn get_item_attrs(cdata: cmd,\n                   node_id: ast::node_id,\n-                  f: fn(~[@ast::meta_item])) {\n+                  f: fn(~[ast::meta_item])) {\n \n     let item = lookup_item(node_id, cdata.data);\n     for ebml::tagged_docs(item, tag_attributes) |attributes| {\n@@ -841,8 +841,8 @@ fn item_family_to_str(fam: Family) -> ~str {\n     }\n }\n \n-fn get_meta_items(md: ebml::Doc) -> ~[@ast::meta_item] {\n-    let mut items: ~[@ast::meta_item] = ~[];\n+fn get_meta_items(md: ebml::Doc) -> ~[ast::meta_item] {\n+    let mut items: ~[ast::meta_item] = ~[];\n     for ebml::tagged_docs(md, tag_meta_item_word) |meta_item_doc| {\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = str::from_bytes(ebml::doc_data(nd));\n@@ -877,7 +877,7 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::attribute] {\n             assert (vec::len(meta_items) == 1u);\n             let meta_item = meta_items[0];\n             vec::push(attrs,\n-                      {node: {style: ast::attr_outer, value: *meta_item,\n+                      {node: {style: ast::attr_outer, value: meta_item,\n                               is_sugared_doc: false},\n                        span: ast_util::dummy_sp()});\n         };"}, {"sha": "7f72d52cbfc725d1acefec57b9ecac8065973c60", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=90e3665fa79d32c3188169cfa992516fb36b81a8", "patch": "@@ -947,7 +947,7 @@ fn encode_meta_item(ebml_w: ebml::Writer, mi: meta_item) {\n         ebml_w.writer.write(str::to_bytes(name));\n         ebml_w.end_tag();\n         for items.each |inner_item| {\n-            encode_meta_item(ebml_w, **inner_item);\n+            encode_meta_item(ebml_w, *inner_item);\n         }\n         ebml_w.end_tag();\n       }\n@@ -970,7 +970,7 @@ fn encode_attributes(ebml_w: ebml::Writer, attrs: ~[attribute]) {\n // them in anyway with default values.\n fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> ~[attribute] {\n \n-    fn synthesize_link_attr(ecx: @encode_ctxt, items: ~[@meta_item]) ->\n+    fn synthesize_link_attr(ecx: @encode_ctxt, items: ~[meta_item]) ->\n        attribute {\n \n         assert (ecx.link_meta.name != ~\"\");"}, {"sha": "8813be72653d5d7d3950009039d1ee80ddcae9fe", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=90e3665fa79d32c3188169cfa992516fb36b81a8", "patch": "@@ -31,7 +31,7 @@ type ctxt = {\n     filesearch: filesearch,\n     span: span,\n     ident: ast::ident,\n-    metas: ~[@ast::meta_item],\n+    metas: ~[ast::meta_item],\n     hash: ~str,\n     os: os,\n     static: bool,\n@@ -120,11 +120,11 @@ fn find_library_crate_aux(cx: ctxt,\n     }\n }\n \n-fn crate_name_from_metas(metas: ~[@ast::meta_item]) -> ~str {\n+fn crate_name_from_metas(metas: ~[ast::meta_item]) -> ~str {\n     let name_items = attr::find_meta_items_by_name(metas, ~\"name\");\n     match vec::last_opt(name_items) {\n       Some(i) => {\n-        match attr::get_meta_item_value_str(i) {\n+        match attr::get_meta_item_value_str(&i) {\n           Some(n) => n,\n           // FIXME (#2406): Probably want a warning here since the user\n           // is using the wrong type of meta item.\n@@ -143,7 +143,7 @@ fn note_linkage_attrs(intr: ident_interner, diag: span_handler,\n     }\n }\n \n-fn crate_matches(crate_data: @~[u8], metas: ~[@ast::meta_item],\n+fn crate_matches(crate_data: @~[u8], metas: ~[ast::meta_item],\n                  hash: ~str) -> bool {\n     let attrs = decoder::get_crate_attributes(crate_data);\n     let linkage_metas = attr::find_linkage_metas(attrs);\n@@ -154,14 +154,14 @@ fn crate_matches(crate_data: @~[u8], metas: ~[@ast::meta_item],\n     metadata_matches(linkage_metas, metas)\n }\n \n-fn metadata_matches(extern_metas: ~[@ast::meta_item],\n-                    local_metas: ~[@ast::meta_item]) -> bool {\n+fn metadata_matches(extern_metas: ~[ast::meta_item],\n+                    local_metas: ~[ast::meta_item]) -> bool {\n \n     debug!(\"matching %u metadata requirements against %u items\",\n            vec::len(local_metas), vec::len(extern_metas));\n \n     for local_metas.each |needed| {\n-        if !attr::contains(extern_metas, *needed) {\n+        if !attr::contains(extern_metas, needed) {\n             return false;\n         }\n     }"}, {"sha": "c3511051f65f7ebf682ed63998700c940b170b5a", "filename": "src/rustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Frustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Frustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flang_items.rs?ref=90e3665fa79d32c3188169cfa992516fb36b81a8", "patch": "@@ -208,7 +208,7 @@ impl LanguageItemCollector {\n \n                 do get_item_attrs(crate_store, def_id) |meta_items| {\n                     for meta_items.each |meta_item| {\n-                        self.match_and_collect_meta_item(def_id, **meta_item);\n+                        self.match_and_collect_meta_item(def_id, *meta_item);\n                     }\n                 }\n             }"}, {"sha": "9225e5abf1280f5fc39e24161d97c3d3fc48d0a8", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=90e3665fa79d32c3188169cfa992516fb36b81a8", "patch": "@@ -2368,10 +2368,10 @@ fn gather_local_rtcalls(ccx: @crate_ctxt, crate: @ast::crate) {\n                 let attr_metas = attr::attr_metas(\n                     attr::find_attrs_by_name(item.attrs, ~\"rt\"));\n                 for vec::each(attr_metas) |attr_meta| {\n-                    match attr::get_meta_item_list(*attr_meta) {\n+                    match attr::get_meta_item_list(attr_meta) {\n                         Some(list) => {\n                             let head = vec::head(list);\n-                            let name = attr::get_meta_item_name(head);\n+                            let name = attr::get_meta_item_name(&head);\n                             push_rtcall(ccx, name, {crate: ast::local_crate,\n                                                     node: item.id});\n                         }"}, {"sha": "3ba640f997a20dfc0170f6569370f4aab6eb0201", "filename": "src/rustdoc/attr_parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Frustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90e3665fa79d32c3188169cfa992516fb36b81a8/src%2Frustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_parser.rs?ref=90e3665fa79d32c3188169cfa992516fb36b81a8", "patch": "@@ -37,7 +37,7 @@ mod test {\n \n fn doc_meta(\n     attrs: ~[ast::attribute]\n-) -> Option<@ast::meta_item> {\n+) -> Option<ast::meta_item> {\n \n     /*!\n      * Given a vec of attributes, extract the meta_items contained in the \\\n@@ -58,7 +58,7 @@ fn doc_meta(\n \n fn doc_metas(\n     attrs: ~[ast::attribute]\n-) -> ~[@ast::meta_item] {\n+) -> ~[ast::meta_item] {\n \n     let doc_attrs = attr::find_attrs_by_name(attrs, ~\"doc\");\n     let doc_metas = do doc_attrs.map |attr| {\n@@ -103,7 +103,7 @@ fn should_not_extract_crate_name_if_no_name_value_in_link_attribute() {\n fn parse_desc(attrs: ~[ast::attribute]) -> Option<~str> {\n     match doc_meta(attrs) {\n       Some(meta) => {\n-        attr::get_meta_item_value_str(meta)\n+        attr::get_meta_item_value_str(&meta)\n       }\n       None => None\n     }\n@@ -127,7 +127,7 @@ fn parse_desc_should_parse_simple_doc_attributes() {\n \n fn parse_hidden(attrs: ~[ast::attribute]) -> bool {\n     do doc_metas(attrs).find |meta| {\n-        match attr::get_meta_item_list(meta) {\n+        match attr::get_meta_item_list(&meta) {\n           Some(metas) => {\n             let hiddens = attr::find_meta_items_by_name(metas, ~\"hidden\");\n             vec::is_not_empty(hiddens)"}]}