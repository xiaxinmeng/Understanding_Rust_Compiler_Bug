{"sha": "d1d2184db407dbdc0a0872c9efb4ff58457e1c9a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxZDIxODRkYjQwN2RiZGMwYTA4NzJjOWVmYjRmZjU4NDU3ZTFjOWE=", "commit": {"author": {"name": "Valerii Lashmanov", "email": "vflashm@gmail.com", "date": "2020-10-03T01:13:21Z"}, "committer": {"name": "Valerii Lashmanov", "email": "vflashm@gmail.com", "date": "2020-10-03T01:13:23Z"}, "message": "SsoHashSet/Map - genericiy over Q removed\n\nDue to performance regression, see SsoHashMap comment.", "tree": {"sha": "ef580edd3b5be49aadde1e83a8f785a9145b1726", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef580edd3b5be49aadde1e83a8f785a9145b1726"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1d2184db407dbdc0a0872c9efb4ff58457e1c9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1d2184db407dbdc0a0872c9efb4ff58457e1c9a", "html_url": "https://github.com/rust-lang/rust/commit/d1d2184db407dbdc0a0872c9efb4ff58457e1c9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1d2184db407dbdc0a0872c9efb4ff58457e1c9a/comments", "author": {"login": "VFLashM", "id": 3723853, "node_id": "MDQ6VXNlcjM3MjM4NTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3723853?v=4", "gravatar_id": "", "url": "https://api.github.com/users/VFLashM", "html_url": "https://github.com/VFLashM", "followers_url": "https://api.github.com/users/VFLashM/followers", "following_url": "https://api.github.com/users/VFLashM/following{/other_user}", "gists_url": "https://api.github.com/users/VFLashM/gists{/gist_id}", "starred_url": "https://api.github.com/users/VFLashM/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/VFLashM/subscriptions", "organizations_url": "https://api.github.com/users/VFLashM/orgs", "repos_url": "https://api.github.com/users/VFLashM/repos", "events_url": "https://api.github.com/users/VFLashM/events{/privacy}", "received_events_url": "https://api.github.com/users/VFLashM/received_events", "type": "User", "site_admin": false}, "committer": {"login": "VFLashM", "id": 3723853, "node_id": "MDQ6VXNlcjM3MjM4NTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3723853?v=4", "gravatar_id": "", "url": "https://api.github.com/users/VFLashM", "html_url": "https://github.com/VFLashM", "followers_url": "https://api.github.com/users/VFLashM/followers", "following_url": "https://api.github.com/users/VFLashM/following{/other_user}", "gists_url": "https://api.github.com/users/VFLashM/gists{/gist_id}", "starred_url": "https://api.github.com/users/VFLashM/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/VFLashM/subscriptions", "organizations_url": "https://api.github.com/users/VFLashM/orgs", "repos_url": "https://api.github.com/users/VFLashM/repos", "events_url": "https://api.github.com/users/VFLashM/events{/privacy}", "received_events_url": "https://api.github.com/users/VFLashM/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92a0668c20b8dea00d8739dce2243113f518b427", "url": "https://api.github.com/repos/rust-lang/rust/commits/92a0668c20b8dea00d8739dce2243113f518b427", "html_url": "https://github.com/rust-lang/rust/commit/92a0668c20b8dea00d8739dce2243113f518b427"}], "stats": {"total": 161, "additions": 72, "deletions": 89}, "files": [{"sha": "fa510e58314af06fcdf9c78754f0c78cfc26852d", "filename": "compiler/rustc_data_structures/src/sso/map.rs", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/d1d2184db407dbdc0a0872c9efb4ff58457e1c9a/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d2184db407dbdc0a0872c9efb4ff58457e1c9a/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs?ref=d1d2184db407dbdc0a0872c9efb4ff58457e1c9a", "patch": "@@ -1,7 +1,6 @@\n use super::either_iter::EitherIter;\n use crate::fx::FxHashMap;\n use arrayvec::ArrayVec;\n-use std::borrow::Borrow;\n use std::fmt;\n use std::hash::Hash;\n use std::iter::FromIterator;\n@@ -30,19 +29,45 @@ const SSO_ARRAY_SIZE: usize = 8;\n ///\n /// Stores elements in a small array up to a certain length\n /// and switches to `HashMap` when that length is exceeded.\n-///\n-/// Implements subset of HashMap API.\n-///\n-/// Missing HashMap API:\n-///   all hasher-related\n-///   try_reserve (unstable)\n-///   shrink_to (unstable)\n-///   drain_filter (unstable)\n-///   into_keys/into_values (unstable)\n-///   all raw_entry-related\n-///   PartialEq/Eq (requires sorting the array)\n-///   Entry::or_insert_with_key (unstable)\n-///   Vacant/Occupied entries and related\n+//\n+// FIXME: Implements subset of HashMap API.\n+//\n+// Missing HashMap API:\n+//   all hasher-related\n+//   try_reserve (unstable)\n+//   shrink_to (unstable)\n+//   drain_filter (unstable)\n+//   into_keys/into_values (unstable)\n+//   all raw_entry-related\n+//   PartialEq/Eq (requires sorting the array)\n+//   Entry::or_insert_with_key (unstable)\n+//   Vacant/Occupied entries and related\n+//\n+// FIXME: In HashMap most methods accepting key reference\n+// accept reference to generic `Q` where `K: Borrow<Q>`.\n+//\n+// However, using this approach in `HashMap::get` apparently\n+// breaks inlining and noticeably reduces performance.\n+//\n+// Performance *should* be the same given that borrow is\n+// a NOP in most cases, but in practice that's not the case.\n+//\n+// Further investigation is required.\n+//\n+// Affected methods:\n+//   SsoHashMap::get\n+//   SsoHashMap::get_mut\n+//   SsoHashMap::get_entry\n+//   SsoHashMap::get_key_value\n+//   SsoHashMap::contains_key\n+//   SsoHashMap::remove\n+//   SsoHashMap::remove_entry\n+//   Index::index\n+//   SsoHashSet::take\n+//   SsoHashSet::get\n+//   SsoHashSet::remove\n+//   SsoHashSet::contains\n+\n #[derive(Clone)]\n pub enum SsoHashMap<K, V> {\n     Array(ArrayVec<[(K, V); SSO_ARRAY_SIZE]>),\n@@ -232,14 +257,10 @@ impl<K: Eq + Hash, V> SsoHashMap<K, V> {\n \n     /// Removes a key from the map, returning the value at the key if the key\n     /// was previously in the map.\n-    pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V>\n-    where\n-        K: Borrow<Q>,\n-        Q: Hash + Eq,\n-    {\n+    pub fn remove(&mut self, key: &K) -> Option<V> {\n         match self {\n             SsoHashMap::Array(array) => {\n-                if let Some(index) = array.iter().position(|(k, _v)| k.borrow() == key) {\n+                if let Some(index) = array.iter().position(|(k, _v)| k == key) {\n                     Some(array.swap_remove(index).1)\n                 } else {\n                     None\n@@ -251,14 +272,10 @@ impl<K: Eq + Hash, V> SsoHashMap<K, V> {\n \n     /// Removes a key from the map, returning the stored key and value if the\n     /// key was previously in the map.\n-    pub fn remove_entry<Q: ?Sized>(&mut self, key: &Q) -> Option<(K, V)>\n-    where\n-        K: Borrow<Q>,\n-        Q: Hash + Eq,\n-    {\n+    pub fn remove_entry(&mut self, key: &K) -> Option<(K, V)> {\n         match self {\n             SsoHashMap::Array(array) => {\n-                if let Some(index) = array.iter().position(|(k, _v)| k.borrow() == key) {\n+                if let Some(index) = array.iter().position(|(k, _v)| k == key) {\n                     Some(array.swap_remove(index))\n                 } else {\n                     None\n@@ -269,15 +286,11 @@ impl<K: Eq + Hash, V> SsoHashMap<K, V> {\n     }\n \n     /// Returns a reference to the value corresponding to the key.\n-    pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V>\n-    where\n-        K: Borrow<Q>,\n-        Q: Hash + Eq,\n-    {\n+    pub fn get(&self, key: &K) -> Option<&V> {\n         match self {\n             SsoHashMap::Array(array) => {\n                 for (k, v) in array {\n-                    if k.borrow() == key {\n+                    if k == key {\n                         return Some(v);\n                     }\n                 }\n@@ -288,15 +301,11 @@ impl<K: Eq + Hash, V> SsoHashMap<K, V> {\n     }\n \n     /// Returns a mutable reference to the value corresponding to the key.\n-    pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V>\n-    where\n-        K: Borrow<Q>,\n-        Q: Hash + Eq,\n-    {\n+    pub fn get_mut(&mut self, key: &K) -> Option<&mut V> {\n         match self {\n             SsoHashMap::Array(array) => {\n                 for (k, v) in array {\n-                    if (*k).borrow() == key {\n+                    if k == key {\n                         return Some(v);\n                     }\n                 }\n@@ -307,15 +316,11 @@ impl<K: Eq + Hash, V> SsoHashMap<K, V> {\n     }\n \n     /// Returns the key-value pair corresponding to the supplied key.\n-    pub fn get_key_value<Q: ?Sized>(&self, key: &Q) -> Option<(&K, &V)>\n-    where\n-        K: Borrow<Q>,\n-        Q: Hash + Eq,\n-    {\n+    pub fn get_key_value(&self, key: &K) -> Option<(&K, &V)> {\n         match self {\n             SsoHashMap::Array(array) => {\n                 for (k, v) in array {\n-                    if k.borrow() == key {\n+                    if k == key {\n                         return Some((k, v));\n                     }\n                 }\n@@ -326,13 +331,9 @@ impl<K: Eq + Hash, V> SsoHashMap<K, V> {\n     }\n \n     /// Returns `true` if the map contains a value for the specified key.\n-    pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool\n-    where\n-        K: Borrow<Q>,\n-        Q: Hash + Eq,\n-    {\n+    pub fn contains_key(&self, key: &K) -> bool {\n         match self {\n-            SsoHashMap::Array(array) => array.iter().any(|(k, _v)| k.borrow() == key),\n+            SsoHashMap::Array(array) => array.iter().any(|(k, _v)| k == key),\n             SsoHashMap::Map(map) => map.contains_key(key),\n         }\n     }\n@@ -483,15 +484,14 @@ where\n     }\n }\n \n-impl<'a, K, Q: ?Sized, V> Index<&'a Q> for SsoHashMap<K, V>\n+impl<'a, K, V> Index<&'a K> for SsoHashMap<K, V>\n where\n-    K: Eq + Hash + Borrow<Q>,\n-    Q: Eq + Hash,\n+    K: Eq + Hash,\n {\n     type Output = V;\n \n     #[inline]\n-    fn index(&self, key: &Q) -> &V {\n+    fn index(&self, key: &K) -> &V {\n         self.get(key).expect(\"no entry found for key\")\n     }\n }"}, {"sha": "23cff0206c530367de30922de990535788f63721", "filename": "compiler/rustc_data_structures/src/sso/set.rs", "status": "modified", "additions": 18, "deletions": 35, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/d1d2184db407dbdc0a0872c9efb4ff58457e1c9a/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d2184db407dbdc0a0872c9efb4ff58457e1c9a/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fset.rs?ref=d1d2184db407dbdc0a0872c9efb4ff58457e1c9a", "patch": "@@ -1,4 +1,3 @@\n-use std::borrow::Borrow;\n use std::fmt;\n use std::hash::Hash;\n use std::iter::FromIterator;\n@@ -9,20 +8,20 @@ use super::map::SsoHashMap;\n ///\n /// Stores elements in a small array up to a certain length\n /// and switches to `HashSet` when that length is exceeded.\n-///\n-/// Implements subset of HashSet API.\n-///\n-/// Missing HashSet API:\n-///   all hasher-related\n-///   try_reserve (unstable)\n-///   shrink_to (unstable)\n-///   drain_filter (unstable)\n-///   replace\n-///   get_or_insert/get_or_insert_owned/get_or_insert_with (unstable)\n-///   difference/symmetric_difference/intersection/union\n-///   is_disjoint/is_subset/is_superset\n-///   PartialEq/Eq (requires SsoHashMap implementation)\n-///   BitOr/BitAnd/BitXor/Sub\n+//\n+// FIXME: Implements subset of HashSet API.\n+//\n+// Missing HashSet API:\n+//   all hasher-related\n+//   try_reserve (unstable)\n+//   shrink_to (unstable)\n+//   drain_filter (unstable)\n+//   replace\n+//   get_or_insert/get_or_insert_owned/get_or_insert_with (unstable)\n+//   difference/symmetric_difference/intersection/union\n+//   is_disjoint/is_subset/is_superset\n+//   PartialEq/Eq (requires SsoHashMap implementation)\n+//   BitOr/BitAnd/BitXor/Sub\n #[derive(Clone)]\n pub struct SsoHashSet<T> {\n     map: SsoHashMap<T, ()>,\n@@ -115,21 +114,13 @@ impl<T: Eq + Hash> SsoHashSet<T> {\n \n     /// Removes and returns the value in the set, if any, that is equal to the given one.\n     #[inline]\n-    pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>\n-    where\n-        T: Borrow<Q>,\n-        Q: Hash + Eq,\n-    {\n+    pub fn take(&mut self, value: &T) -> Option<T> {\n         self.map.remove_entry(value).map(entry_to_key)\n     }\n \n     /// Returns a reference to the value in the set, if any, that is equal to the given value.\n     #[inline]\n-    pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>\n-    where\n-        T: Borrow<Q>,\n-        Q: Hash + Eq,\n-    {\n+    pub fn get(&self, value: &T) -> Option<&T> {\n         self.map.get_key_value(value).map(entry_to_key)\n     }\n \n@@ -146,21 +137,13 @@ impl<T: Eq + Hash> SsoHashSet<T> {\n     /// Removes a value from the set. Returns whether the value was\n     /// present in the set.\n     #[inline]\n-    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n-    where\n-        T: Borrow<Q>,\n-        Q: Hash + Eq,\n-    {\n+    pub fn remove(&mut self, value: &T) -> bool {\n         self.map.remove(value).is_some()\n     }\n \n     /// Returns `true` if the set contains a value.\n     #[inline]\n-    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n-    where\n-        T: Borrow<Q>,\n-        Q: Hash + Eq,\n-    {\n+    pub fn contains(&self, value: &T) -> bool {\n         self.map.contains_key(value)\n     }\n }"}]}