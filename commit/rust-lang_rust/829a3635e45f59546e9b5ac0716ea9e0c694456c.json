{"sha": "829a3635e45f59546e9b5ac0716ea9e0c694456c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyOWEzNjM1ZTQ1ZjU5NTQ2ZTliNWFjMDcxNmVhOWUwYzY5NDQ1NmM=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-02-14T22:17:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-14T22:17:47Z"}, "message": "Rollup merge of #68856 - Centril:or-pat-ref-pat, r=matthewjasper\n\ntypeck: clarify def_bm adjustments & add tests for or-patterns\n\nClarify the adjustment algorithm for the expected type / default binding-modes when type checking patterns with more documentation and tweaks that make the algorithm more independent of the pattern forms.\n\nAlso resolve the FIXME noted for or-patterns by deciding that the current implementation is correct, noting the rationale and adding tests for the current implementation.\n\ncc https://github.com/rust-lang/rust/issues/54883\n\nr? @oli-obk @varkor", "tree": {"sha": "4daa78b251fd99934bfcd4144a4d36f281234819", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4daa78b251fd99934bfcd4144a4d36f281234819"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/829a3635e45f59546e9b5ac0716ea9e0c694456c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeRxyLCRBK7hj4Ov3rIwAAdHIIAD1b8saRVRp8Wl+s2B9I6Vh9\n04o2oCGZGPDxJGNZabeegQu5AerOEjck27qP2mhqEqYfY+o4CwcOkDJ9CeN+0V0l\nXsd5pwVzbqVcTIl95ai5gszXAfL9i/BB2k8AQNp08NnzzglSTlGQCUObwaFY/7eD\nVtDVkNpz4fZQjGpthd2y0Z9IbqUIWjQYKyEPyYzeXSWecMD2XPlXUwo78CFaiR3R\nMSbtqm0lW4HX1DviaUSGaXz2Ix9mglFskLKh1uFp8sZ3E9EhihDd2sq1qSCfl2RI\nGvKp4DOEAmEKdpUYELBF7Tezj7Ta8qKtncdZ8YsgmbnurFaC4gQHsDJaIvZnOkQ=\n=vMNB\n-----END PGP SIGNATURE-----\n", "payload": "tree 4daa78b251fd99934bfcd4144a4d36f281234819\nparent 2c5bdee9e4a750355c99a1fbed57b20ba953766b\nparent b5aca3128d5c0ee2441ec9ca9a9c3ae4f391ef16\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1581718667 +0900\ncommitter GitHub <noreply@github.com> 1581718667 +0900\n\nRollup merge of #68856 - Centril:or-pat-ref-pat, r=matthewjasper\n\ntypeck: clarify def_bm adjustments & add tests for or-patterns\n\nClarify the adjustment algorithm for the expected type / default binding-modes when type checking patterns with more documentation and tweaks that make the algorithm more independent of the pattern forms.\n\nAlso resolve the FIXME noted for or-patterns by deciding that the current implementation is correct, noting the rationale and adding tests for the current implementation.\n\ncc https://github.com/rust-lang/rust/issues/54883\n\nr? @oli-obk @varkor\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/829a3635e45f59546e9b5ac0716ea9e0c694456c", "html_url": "https://github.com/rust-lang/rust/commit/829a3635e45f59546e9b5ac0716ea9e0c694456c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/829a3635e45f59546e9b5ac0716ea9e0c694456c/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c5bdee9e4a750355c99a1fbed57b20ba953766b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c5bdee9e4a750355c99a1fbed57b20ba953766b", "html_url": "https://github.com/rust-lang/rust/commit/2c5bdee9e4a750355c99a1fbed57b20ba953766b"}, {"sha": "b5aca3128d5c0ee2441ec9ca9a9c3ae4f391ef16", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5aca3128d5c0ee2441ec9ca9a9c3ae4f391ef16", "html_url": "https://github.com/rust-lang/rust/commit/b5aca3128d5c0ee2441ec9ca9a9c3ae4f391ef16"}], "stats": {"total": 509, "additions": 447, "deletions": 62}, "files": [{"sha": "72a2d56af153f19357d1c20839ff0acff41e0c2c", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 64, "deletions": 49, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/829a3635e45f59546e9b5ac0716ea9e0c694456c/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/829a3635e45f59546e9b5ac0716ea9e0c694456c/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=829a3635e45f59546e9b5ac0716ea9e0c694456c", "patch": "@@ -89,6 +89,18 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n     }\n }\n \n+const INITIAL_BM: BindingMode = BindingMode::BindByValue(hir::Mutability::Not);\n+\n+/// Mode for adjusting the expected type and binding mode.\n+enum AdjustMode {\n+    /// Peel off all immediate reference types.\n+    Peel,\n+    /// Reset binding mode to the inital mode.\n+    Reset,\n+    /// Pass on the input binding mode and expected type.\n+    Pass,\n+}\n+\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Type check the given top level pattern against the `expected` type.\n     ///\n@@ -105,8 +117,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Option<Span>,\n         origin_expr: bool,\n     ) {\n-        let def_bm = BindingMode::BindByValue(hir::Mutability::Not);\n-        self.check_pat(pat, expected, def_bm, TopInfo { expected, origin_expr, span });\n+        self.check_pat(pat, expected, INITIAL_BM, TopInfo { expected, origin_expr, span });\n     }\n \n     /// Type check the given `pat` against the `expected` type\n@@ -123,12 +134,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) {\n         debug!(\"check_pat(pat={:?},expected={:?},def_bm={:?})\", pat, expected, def_bm);\n \n-        let path_resolution = match &pat.kind {\n+        let path_res = match &pat.kind {\n             PatKind::Path(qpath) => Some(self.resolve_ty_and_res_ufcs(qpath, pat.hir_id, pat.span)),\n             _ => None,\n         };\n-        let is_nrp = self.is_non_ref_pat(pat, path_resolution.map(|(res, ..)| res));\n-        let (expected, def_bm) = self.calc_default_binding_mode(pat, expected, def_bm, is_nrp);\n+        let adjust_mode = self.calc_adjust_mode(pat, path_res.map(|(res, ..)| res));\n+        let (expected, def_bm) = self.calc_default_binding_mode(pat, expected, def_bm, adjust_mode);\n \n         let ty = match pat.kind {\n             PatKind::Wild => expected,\n@@ -141,7 +152,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_pat_tuple_struct(pat, qpath, subpats, ddpos, expected, def_bm, ti)\n             }\n             PatKind::Path(ref qpath) => {\n-                self.check_pat_path(pat, path_resolution.unwrap(), qpath, expected)\n+                self.check_pat_path(pat, path_res.unwrap(), qpath, expected)\n             }\n             PatKind::Struct(ref qpath, fields, etc) => {\n                 self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm, ti)\n@@ -223,64 +234,68 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         pat: &'tcx Pat<'tcx>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n-        is_non_ref_pat: bool,\n+        adjust_mode: AdjustMode,\n     ) -> (Ty<'tcx>, BindingMode) {\n-        if is_non_ref_pat {\n-            debug!(\"pattern is non reference pattern\");\n-            self.peel_off_references(pat, expected, def_bm)\n-        } else {\n-            // When you encounter a `&pat` pattern, reset to \"by\n-            // value\". This is so that `x` and `y` here are by value,\n-            // as they appear to be:\n-            //\n-            // ```\n-            // match &(&22, &44) {\n-            //   (&x, &y) => ...\n-            // }\n-            // ```\n-            //\n-            // See issue #46688.\n-            let def_bm = match pat.kind {\n-                PatKind::Ref(..) => ty::BindByValue(hir::Mutability::Not),\n-                _ => def_bm,\n-            };\n-            (expected, def_bm)\n+        match adjust_mode {\n+            AdjustMode::Pass => (expected, def_bm),\n+            AdjustMode::Reset => (expected, INITIAL_BM),\n+            AdjustMode::Peel => self.peel_off_references(pat, expected, def_bm),\n         }\n     }\n \n-    /// Is the pattern a \"non reference pattern\"?\n+    /// How should the binding mode and expected type be adjusted?\n+    ///\n     /// When the pattern is a path pattern, `opt_path_res` must be `Some(res)`.\n-    fn is_non_ref_pat(&self, pat: &'tcx Pat<'tcx>, opt_path_res: Option<Res>) -> bool {\n-        match pat.kind {\n+    fn calc_adjust_mode(&self, pat: &'tcx Pat<'tcx>, opt_path_res: Option<Res>) -> AdjustMode {\n+        match &pat.kind {\n+            // Type checking these product-like types successfully always require\n+            // that the expected type be of those types and not reference types.\n             PatKind::Struct(..)\n             | PatKind::TupleStruct(..)\n             | PatKind::Tuple(..)\n             | PatKind::Box(_)\n             | PatKind::Range(..)\n-            | PatKind::Slice(..) => true,\n-            PatKind::Lit(ref lt) => {\n-                let ty = self.check_expr(lt);\n-                match ty.kind {\n-                    ty::Ref(..) => false,\n-                    _ => true,\n-                }\n-            }\n+            | PatKind::Slice(..) => AdjustMode::Peel,\n+            // String and byte-string literals result in types `&str` and `&[u8]` respectively.\n+            // All other literals result in non-reference types.\n+            // As a result, we allow `if let 0 = &&0 {}` but not `if let \"foo\" = &&\"foo {}`.\n+            PatKind::Lit(lt) => match self.check_expr(lt).kind {\n+                ty::Ref(..) => AdjustMode::Pass,\n+                _ => AdjustMode::Peel,\n+            },\n             PatKind::Path(_) => match opt_path_res.unwrap() {\n-                Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssocConst, _) => false,\n-                _ => true,\n+                // These constants can be of a reference type, e.g. `const X: &u8 = &0;`.\n+                // Peeling the reference types too early will cause type checking failures.\n+                // Although it would be possible to *also* peel the types of the constants too.\n+                Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssocConst, _) => AdjustMode::Pass,\n+                // In the `ValueNS`, we have `SelfCtor(..) | Ctor(_, Const), _)` remaining which\n+                // could successfully compile. The former being `Self` requires a unit struct.\n+                // In either case, and unlike constants, the pattern itself cannot be\n+                // a reference type wherefore peeling doesn't give up any expressivity.\n+                _ => AdjustMode::Peel,\n             },\n-            // FIXME(or_patterns; Centril | dlrobertson): To keep things compiling\n-            // for or-patterns at the top level, we need to make `p_0 | ... | p_n`\n-            // a \"non reference pattern\". For example the following currently compiles:\n+            // When encountering a `& mut? pat` pattern, reset to \"by value\".\n+            // This is so that `x` and `y` here are by value, as they appear to be:\n+            //\n             // ```\n-            // match &1 {\n-            //     e @ &(1...2) | e @ &(3...4) => {}\n-            //     _ => {}\n+            // match &(&22, &44) {\n+            //   (&x, &y) => ...\n             // }\n             // ```\n             //\n-            // We should consider whether we should do something special in nested or-patterns.\n-            PatKind::Or(_) | PatKind::Wild | PatKind::Binding(..) | PatKind::Ref(..) => false,\n+            // See issue #46688.\n+            PatKind::Ref(..) => AdjustMode::Reset,\n+            // A `_` pattern works with any expected type, so there's no need to do anything.\n+            PatKind::Wild\n+            // Bindings also work with whatever the expected type is,\n+            // and moreover if we peel references off, that will give us the wrong binding type.\n+            // Also, we can have a subpattern `binding @ pat`.\n+            // Each side of the `@` should be treated independently (like with OR-patterns).\n+            | PatKind::Binding(..)\n+            // An OR-pattern just propagates to each individual alternative.\n+            // This is maximally flexible, allowing e.g., `Some(mut x) | &Some(mut x)`.\n+            // In that example, `Some(mut x)` results in `Peel` whereas `&Some(mut x)` in `Reset`.\n+            | PatKind::Or(_) => AdjustMode::Pass,\n         }\n     }\n \n@@ -508,7 +523,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let local_ty = self.local_ty(pat.span, pat.hir_id).decl_ty;\n         let eq_ty = match bm {\n             ty::BindByReference(mutbl) => {\n-                // If the binding is like `ref x | ref const x | ref mut x`\n+                // If the binding is like `ref x | ref mut x`,\n                 // then `x` is assigned a value of type `&M T` where M is the\n                 // mutability and T is the expected type.\n                 //"}, {"sha": "973954bca5a5e823877180da26ca2ddf6a82cc87", "filename": "src/test/ui/or-patterns/or-pattern-mismatch.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c5bdee9e4a750355c99a1fbed57b20ba953766b/src%2Ftest%2Fui%2For-patterns%2For-pattern-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c5bdee9e4a750355c99a1fbed57b20ba953766b/src%2Ftest%2Fui%2For-patterns%2For-pattern-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-pattern-mismatch.rs?ref=2c5bdee9e4a750355c99a1fbed57b20ba953766b", "patch": "@@ -1,4 +0,0 @@\n-enum Blah { A(isize, isize, usize), B(isize, isize) }\n-\n-fn main() { match Blah::A(1, 1, 2) { Blah::A(_, x, y) | Blah::B(x, y) => { } } }\n-//~^ ERROR mismatched types"}, {"sha": "bc288e06250751d914801818d0240c36253341cb", "filename": "src/test/ui/or-patterns/or-pattern-mismatch.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2c5bdee9e4a750355c99a1fbed57b20ba953766b/src%2Ftest%2Fui%2For-patterns%2For-pattern-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c5bdee9e4a750355c99a1fbed57b20ba953766b/src%2Ftest%2Fui%2For-patterns%2For-pattern-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-pattern-mismatch.stderr?ref=2c5bdee9e4a750355c99a1fbed57b20ba953766b", "patch": "@@ -1,9 +0,0 @@\n-error[E0308]: mismatched types\n-  --> $DIR/or-pattern-mismatch.rs:3:68\n-   |\n-LL | fn main() { match Blah::A(1, 1, 2) { Blah::A(_, x, y) | Blah::B(x, y) => { } } }\n-   |                   ---------------- this expression has type `Blah` ^ expected `usize`, found `isize`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "5ec7dc6962c18ef3bdf249410856c0802f8a5359", "filename": "src/test/ui/or-patterns/or-patterns-binding-type-mismatch.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/829a3635e45f59546e9b5ac0716ea9e0c694456c/src%2Ftest%2Fui%2For-patterns%2For-patterns-binding-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/829a3635e45f59546e9b5ac0716ea9e0c694456c/src%2Ftest%2Fui%2For-patterns%2For-patterns-binding-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-binding-type-mismatch.rs?ref=829a3635e45f59546e9b5ac0716ea9e0c694456c", "patch": "@@ -0,0 +1,68 @@\n+// Here we test type checking of bindings when combined with or-patterns.\n+// Specifically, we ensure that introducing bindings of different types result in type errors.\n+\n+#![feature(or_patterns)]\n+\n+fn main() {\n+    enum Blah {\n+        A(isize, isize, usize),\n+        B(isize, isize),\n+    }\n+\n+    match Blah::A(1, 1, 2) {\n+        Blah::A(_, x, y) | Blah::B(x, y) => {} //~ ERROR mismatched types\n+    }\n+\n+    match Some(Blah::A(1, 1, 2)) {\n+        Some(Blah::A(_, x, y) | Blah::B(x, y)) => {} //~ ERROR mismatched types\n+    }\n+\n+    match (0u8, 1u16) {\n+        (x, y) | (y, x) => {} //~ ERROR mismatched types\n+                              //~^ ERROR mismatched types\n+    }\n+\n+    match Some((0u8, Some((1u16, 2u32)))) {\n+        Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x)))) => {}\n+        //~^ ERROR mismatched types\n+        //~| ERROR mismatched types\n+        //~| ERROR mismatched types\n+        //~| ERROR mismatched types\n+        _ => {}\n+    }\n+\n+    if let Blah::A(_, x, y) | Blah::B(x, y) = Blah::A(1, 1, 2) {\n+        //~^ ERROR mismatched types\n+    }\n+\n+    if let Some(Blah::A(_, x, y) | Blah::B(x, y)) = Some(Blah::A(1, 1, 2)) {\n+        //~^ ERROR mismatched types\n+    }\n+\n+    if let (x, y) | (y, x) = (0u8, 1u16) {\n+        //~^ ERROR mismatched types\n+        //~| ERROR mismatched types\n+    }\n+\n+    if let Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x))))\n+        //~^ ERROR mismatched types\n+        //~| ERROR mismatched types\n+        //~| ERROR mismatched types\n+        //~| ERROR mismatched types\n+    = Some((0u8, Some((1u16, 2u32))))\n+    {}\n+\n+    let Blah::A(_, x, y) | Blah::B(x, y) = Blah::A(1, 1, 2);\n+    //~^ ERROR mismatched types\n+\n+    let (x, y) | (y, x) = (0u8, 1u16);\n+    //~^ ERROR mismatched types\n+    //~| ERROR mismatched types\n+\n+    fn f1((Blah::A(_, x, y) | Blah::B(x, y)): Blah) {}\n+    //~^ ERROR mismatched types\n+\n+    fn f2(((x, y) | (y, x)): (u8, u16)) {}\n+    //~^ ERROR mismatched types\n+    //~| ERROR mismatched types\n+}"}, {"sha": "5094f04b9204f1d7258a9ad4dde3c6e4b76823b0", "filename": "src/test/ui/or-patterns/or-patterns-binding-type-mismatch.stderr", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/829a3635e45f59546e9b5ac0716ea9e0c694456c/src%2Ftest%2Fui%2For-patterns%2For-patterns-binding-type-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/829a3635e45f59546e9b5ac0716ea9e0c694456c/src%2Ftest%2Fui%2For-patterns%2For-patterns-binding-type-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-binding-type-mismatch.stderr?ref=829a3635e45f59546e9b5ac0716ea9e0c694456c", "patch": "@@ -0,0 +1,183 @@\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:13:39\n+   |\n+LL |     match Blah::A(1, 1, 2) {\n+   |           ---------------- this expression has type `main::Blah`\n+LL |         Blah::A(_, x, y) | Blah::B(x, y) => {}\n+   |                                       ^ expected `usize`, found `isize`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:17:44\n+   |\n+LL |     match Some(Blah::A(1, 1, 2)) {\n+   |           ---------------------- this expression has type `std::option::Option<main::Blah>`\n+LL |         Some(Blah::A(_, x, y) | Blah::B(x, y)) => {}\n+   |                                            ^ expected `usize`, found `isize`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:21:19\n+   |\n+LL |     match (0u8, 1u16) {\n+   |           ----------- this expression has type `(u8, u16)`\n+LL |         (x, y) | (y, x) => {}\n+   |                   ^ expected `u16`, found `u8`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:21:22\n+   |\n+LL |     match (0u8, 1u16) {\n+   |           ----------- this expression has type `(u8, u16)`\n+LL |         (x, y) | (y, x) => {}\n+   |                      ^ expected `u8`, found `u16`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:26:41\n+   |\n+LL |     match Some((0u8, Some((1u16, 2u32)))) {\n+   |           ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n+LL |         Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x)))) => {}\n+   |                                         ^ expected `u16`, found `u8`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:26:50\n+   |\n+LL |     match Some((0u8, Some((1u16, 2u32)))) {\n+   |           ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n+LL |         Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x)))) => {}\n+   |                                                  ^ expected `u8`, found `u16`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:26:59\n+   |\n+LL |     match Some((0u8, Some((1u16, 2u32)))) {\n+   |           ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n+LL |         Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x)))) => {}\n+   |                                                           ^ expected `u32`, found `u16`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:26:62\n+   |\n+LL |     match Some((0u8, Some((1u16, 2u32)))) {\n+   |           ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n+LL |         Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x)))) => {}\n+   |                                                              ^ expected `u8`, found `u32`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:34:42\n+   |\n+LL |     if let Blah::A(_, x, y) | Blah::B(x, y) = Blah::A(1, 1, 2) {\n+   |                                          ^    ---------------- this expression has type `main::Blah`\n+   |                                          |\n+   |                                          expected `usize`, found `isize`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:38:47\n+   |\n+LL |     if let Some(Blah::A(_, x, y) | Blah::B(x, y)) = Some(Blah::A(1, 1, 2)) {\n+   |                                               ^     ---------------------- this expression has type `std::option::Option<main::Blah>`\n+   |                                               |\n+   |                                               expected `usize`, found `isize`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:42:22\n+   |\n+LL |     if let (x, y) | (y, x) = (0u8, 1u16) {\n+   |                      ^       ----------- this expression has type `(u8, u16)`\n+   |                      |\n+   |                      expected `u16`, found `u8`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:42:25\n+   |\n+LL |     if let (x, y) | (y, x) = (0u8, 1u16) {\n+   |                         ^    ----------- this expression has type `(u8, u16)`\n+   |                         |\n+   |                         expected `u8`, found `u16`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:47:44\n+   |\n+LL |     if let Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x))))\n+   |                                            ^ expected `u16`, found `u8`\n+...\n+LL |     = Some((0u8, Some((1u16, 2u32))))\n+   |       ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:47:53\n+   |\n+LL |     if let Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x))))\n+   |                                                     ^ expected `u8`, found `u16`\n+...\n+LL |     = Some((0u8, Some((1u16, 2u32))))\n+   |       ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:47:62\n+   |\n+LL |     if let Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x))))\n+   |                                                              ^ expected `u32`, found `u16`\n+...\n+LL |     = Some((0u8, Some((1u16, 2u32))))\n+   |       ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:47:65\n+   |\n+LL |     if let Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x))))\n+   |                                                                 ^ expected `u8`, found `u32`\n+...\n+LL |     = Some((0u8, Some((1u16, 2u32))))\n+   |       ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:55:39\n+   |\n+LL |     let Blah::A(_, x, y) | Blah::B(x, y) = Blah::A(1, 1, 2);\n+   |                                       ^    ---------------- this expression has type `main::Blah`\n+   |                                       |\n+   |                                       expected `usize`, found `isize`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:58:19\n+   |\n+LL |     let (x, y) | (y, x) = (0u8, 1u16);\n+   |                   ^       ----------- this expression has type `(u8, u16)`\n+   |                   |\n+   |                   expected `u16`, found `u8`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:58:22\n+   |\n+LL |     let (x, y) | (y, x) = (0u8, 1u16);\n+   |                      ^    ----------- this expression has type `(u8, u16)`\n+   |                      |\n+   |                      expected `u8`, found `u16`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:62:42\n+   |\n+LL |     fn f1((Blah::A(_, x, y) | Blah::B(x, y)): Blah) {}\n+   |                                          ^    ---- expected due to this\n+   |                                          |\n+   |                                          expected `usize`, found `isize`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:65:22\n+   |\n+LL |     fn f2(((x, y) | (y, x)): (u8, u16)) {}\n+   |                      ^       --------- expected due to this\n+   |                      |\n+   |                      expected `u16`, found `u8`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:65:25\n+   |\n+LL |     fn f2(((x, y) | (y, x)): (u8, u16)) {}\n+   |                         ^    --------- expected due to this\n+   |                         |\n+   |                         expected `u8`, found `u16`\n+\n+error: aborting due to 22 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "3b6047c7be47df460e07fa2373996df13da5a597", "filename": "src/test/ui/or-patterns/or-patterns-default-binding-modes.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/829a3635e45f59546e9b5ac0716ea9e0c694456c/src%2Ftest%2Fui%2For-patterns%2For-patterns-default-binding-modes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/829a3635e45f59546e9b5ac0716ea9e0c694456c/src%2Ftest%2Fui%2For-patterns%2For-patterns-default-binding-modes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-default-binding-modes.rs?ref=829a3635e45f59546e9b5ac0716ea9e0c694456c", "patch": "@@ -0,0 +1,132 @@\n+// Test that or-patterns are pass-through with respect to default binding modes.\n+\n+// check-pass\n+\n+#![feature(or_patterns)]\n+#![allow(irrefutable_let_patterns)]\n+\n+fn main() {\n+    // A regression test for a mistake we made at one point:\n+    match &1 {\n+        e @ &(1..=2) | e @ &(3..=4) => {}\n+        _ => {}\n+    }\n+\n+    match &0 {\n+        0 | &1 => {}\n+        _ => {}\n+    }\n+\n+    type R<'a> = &'a Result<u8, u8>;\n+\n+    let res: R<'_> = &Ok(0);\n+\n+    match res {\n+        // Alternatives propagate expected type / binding mode independently.\n+        Ok(mut x) | &Err(mut x) => drop::<u8>(x),\n+    }\n+    match res {\n+        &(Ok(x) | Err(x)) => drop::<u8>(x),\n+    }\n+    match res {\n+        Ok(x) | Err(x) => drop::<&u8>(x),\n+    }\n+    if let Ok(mut x) | &Err(mut x) = res {\n+        drop::<u8>(x);\n+    }\n+    if let &(Ok(x) | Err(x)) = res {\n+        drop::<u8>(x);\n+    }\n+    let Ok(mut x) | &Err(mut x) = res;\n+    drop::<u8>(x);\n+    let &(Ok(x) | Err(x)) = res;\n+    drop::<u8>(x);\n+    let Ok(x) | Err(x) = res;\n+    drop::<&u8>(x);\n+    for Ok(mut x) | &Err(mut x) in std::iter::once(res) {\n+        drop::<u8>(x);\n+    }\n+    for &(Ok(x) | Err(x)) in std::iter::once(res) {\n+        drop::<u8>(x);\n+    }\n+    for Ok(x) | Err(x) in std::iter::once(res) {\n+        drop::<&u8>(x);\n+    }\n+    fn f1((Ok(mut x) | &Err(mut x)): R<'_>) {\n+        drop::<u8>(x);\n+    }\n+    fn f2(&(Ok(x) | Err(x)): R<'_>) {\n+        drop::<u8>(x);\n+    }\n+    fn f3((Ok(x) | Err(x)): R<'_>) {\n+        drop::<&u8>(x);\n+    }\n+\n+    // Wrap inside another type (a product for a simplity with irrefutable contexts).\n+    #[derive(Copy, Clone)]\n+    struct Wrap<T>(T);\n+    let wres = Wrap(res);\n+\n+    match wres {\n+        Wrap(Ok(mut x) | &Err(mut x)) => drop::<u8>(x),\n+    }\n+    match wres {\n+        Wrap(&(Ok(x) | Err(x))) => drop::<u8>(x),\n+    }\n+    match wres {\n+        Wrap(Ok(x) | Err(x)) => drop::<&u8>(x),\n+    }\n+    if let Wrap(Ok(mut x) | &Err(mut x)) = wres {\n+        drop::<u8>(x);\n+    }\n+    if let Wrap(&(Ok(x) | Err(x))) = wres {\n+        drop::<u8>(x);\n+    }\n+    if let Wrap(Ok(x) | Err(x)) = wres {\n+        drop::<&u8>(x);\n+    }\n+    let Wrap(Ok(mut x) | &Err(mut x)) = wres;\n+    drop::<u8>(x);\n+    let Wrap(&(Ok(x) | Err(x))) = wres;\n+    drop::<u8>(x);\n+    let Wrap(Ok(x) | Err(x)) = wres;\n+    drop::<&u8>(x);\n+    for Wrap(Ok(mut x) | &Err(mut x)) in std::iter::once(wres) {\n+        drop::<u8>(x);\n+    }\n+    for Wrap(&(Ok(x) | Err(x))) in std::iter::once(wres) {\n+        drop::<u8>(x);\n+    }\n+    for Wrap(Ok(x) | Err(x)) in std::iter::once(wres) {\n+        drop::<&u8>(x);\n+    }\n+    fn fw1(Wrap(Ok(mut x) | &Err(mut x)): Wrap<R<'_>>) {\n+        drop::<u8>(x);\n+    }\n+    fn fw2(Wrap(&(Ok(x) | Err(x))): Wrap<R<'_>>) {\n+        drop::<u8>(x);\n+    }\n+    fn fw3(Wrap(Ok(x) | Err(x)): Wrap<R<'_>>) {\n+        drop::<&u8>(x);\n+    }\n+\n+    // Nest some more:\n+\n+    enum Tri<P> {\n+        A(P),\n+        B(P),\n+        C(P),\n+    }\n+\n+    let tri = &Tri::A(&Ok(0));\n+    let Tri::A(Ok(mut x) | Err(mut x))\n+    | Tri::B(&Ok(mut x) | Err(mut x))\n+    | &Tri::C(Ok(mut x) | Err(mut x)) = tri;\n+    drop::<u8>(x);\n+\n+    match tri {\n+        Tri::A(Ok(mut x) | Err(mut x))\n+        | Tri::B(&Ok(mut x) | Err(mut x))\n+        | &Tri::C(Ok(mut x) | Err(mut x)) => drop::<u8>(x),\n+    }\n+}"}]}