{"sha": "1a64e570c6d3bf19a387f96bcb0bd09e51caee22", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhNjRlNTcwYzZkM2JmMTlhMzg3Zjk2YmNiMGJkMDllNTFjYWVlMjI=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-10-28T00:21:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-28T00:21:21Z"}, "message": "Rollup merge of #78365 - lcnr:const-eval-obj-safety, r=oli-obk\n\ncheck object safety of generic constants\n\nAs `Self` can only be effectively used in constants with `const_evaluatable_checked` this should not matter outside of it.\n\nImplements the first item of #72219\n\n> Object safety interactions with constants\n\nr? @oli-obk for now cc @nikomatsakis", "tree": {"sha": "ca244d6458a56ba27a2d8b69c937865c541868e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca244d6458a56ba27a2d8b69c937865c541868e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a64e570c6d3bf19a387f96bcb0bd09e51caee22", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfmLmCCRBK7hj4Ov3rIwAAdHIIAFPJVHHUBrVMCChcXZu5Szmn\nlbMIsdzAxhgOf4snm+8TfFU0ho1IiwbCXDRPZMv2tQBaDifiHHSIYShP+nQNjSFn\nWOWcyeXcZRcTYLnvqo9pvmqNGbSzxvC0eT76BQntSNbkbky9I7B4+yHlxW7uk+Y0\ncj3ji2fp+GJrr8joEkfnFN6SfZq5pwkgM7gvGeFpCMNCVPD/nfVhgBieJ248+jrd\n/G0Me9jMBeIypws27fn6dePRaWF8gcxv9Dc4uw3TGcQ2OngF3WQxJ3hx9jvTfDMl\nZfrLcZUkh0sPOmvh12kvJAgdIiB9JzzE0bPwHJjJ2OFosVyNxHC6I99FT0Gao1I=\n=ZzPh\n-----END PGP SIGNATURE-----\n", "payload": "tree ca244d6458a56ba27a2d8b69c937865c541868e3\nparent 54ea0f9ccdc16f3d357c296b300606e58c54868d\nparent 60bcc58dcea0f4314a67f80984431f3b4a0588e4\nauthor Dylan DPC <dylan.dpc@gmail.com> 1603844481 +0100\ncommitter GitHub <noreply@github.com> 1603844481 +0100\n\nRollup merge of #78365 - lcnr:const-eval-obj-safety, r=oli-obk\n\ncheck object safety of generic constants\n\nAs `Self` can only be effectively used in constants with `const_evaluatable_checked` this should not matter outside of it.\n\nImplements the first item of #72219\n\n> Object safety interactions with constants\n\nr? @oli-obk for now cc @nikomatsakis\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a64e570c6d3bf19a387f96bcb0bd09e51caee22", "html_url": "https://github.com/rust-lang/rust/commit/1a64e570c6d3bf19a387f96bcb0bd09e51caee22", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a64e570c6d3bf19a387f96bcb0bd09e51caee22/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54ea0f9ccdc16f3d357c296b300606e58c54868d", "url": "https://api.github.com/repos/rust-lang/rust/commits/54ea0f9ccdc16f3d357c296b300606e58c54868d", "html_url": "https://github.com/rust-lang/rust/commit/54ea0f9ccdc16f3d357c296b300606e58c54868d"}, {"sha": "60bcc58dcea0f4314a67f80984431f3b4a0588e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/60bcc58dcea0f4314a67f80984431f3b4a0588e4", "html_url": "https://github.com/rust-lang/rust/commit/60bcc58dcea0f4314a67f80984431f3b4a0588e4"}], "stats": {"total": 296, "additions": 244, "deletions": 52}, "files": [{"sha": "5f6d8ac751e265baa1147406fa9fa4071a7766ca", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 38, "deletions": 23, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1a64e570c6d3bf19a387f96bcb0bd09e51caee22/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a64e570c6d3bf19a387f96bcb0bd09e51caee22/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=1a64e570c6d3bf19a387f96bcb0bd09e51caee22", "patch": "@@ -85,8 +85,10 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n                         } else if leaf.has_param_types_or_consts() {\n                             failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n                         }\n+\n+                        false\n                     }\n-                    Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => (),\n+                    Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => false,\n                 });\n \n                 match failure_kind {\n@@ -194,12 +196,12 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n ///\n /// This is only able to represent a subset of `MIR`,\n /// and should not leak any information about desugarings.\n-#[derive(Clone, Copy)]\n+#[derive(Debug, Clone, Copy)]\n pub struct AbstractConst<'tcx> {\n     // FIXME: Consider adding something like `IndexSlice`\n     // and use this here.\n-    inner: &'tcx [Node<'tcx>],\n-    substs: SubstsRef<'tcx>,\n+    pub inner: &'tcx [Node<'tcx>],\n+    pub substs: SubstsRef<'tcx>,\n }\n \n impl AbstractConst<'tcx> {\n@@ -209,9 +211,21 @@ impl AbstractConst<'tcx> {\n         substs: SubstsRef<'tcx>,\n     ) -> Result<Option<AbstractConst<'tcx>>, ErrorReported> {\n         let inner = tcx.mir_abstract_const_opt_const_arg(def)?;\n+        debug!(\"AbstractConst::new({:?}) = {:?}\", def, inner);\n         Ok(inner.map(|inner| AbstractConst { inner, substs }))\n     }\n \n+    pub fn from_const(\n+        tcx: TyCtxt<'tcx>,\n+        ct: &ty::Const<'tcx>,\n+    ) -> Result<Option<AbstractConst<'tcx>>, ErrorReported> {\n+        match ct.val {\n+            ty::ConstKind::Unevaluated(def, substs, None) => AbstractConst::new(tcx, def, substs),\n+            ty::ConstKind::Error(_) => Err(ErrorReported),\n+            _ => Ok(None),\n+        }\n+    }\n+\n     #[inline]\n     pub fn subtree(self, node: NodeId) -> AbstractConst<'tcx> {\n         AbstractConst { inner: &self.inner[..=node.index()], substs: self.substs }\n@@ -550,31 +564,32 @@ pub(super) fn try_unify_abstract_consts<'tcx>(\n     // on `ErrorReported`.\n }\n \n-fn walk_abstract_const<'tcx, F>(tcx: TyCtxt<'tcx>, ct: AbstractConst<'tcx>, mut f: F)\n+// FIXME: Use `std::ops::ControlFlow` instead of `bool` here.\n+pub fn walk_abstract_const<'tcx, F>(tcx: TyCtxt<'tcx>, ct: AbstractConst<'tcx>, mut f: F) -> bool\n where\n-    F: FnMut(Node<'tcx>),\n+    F: FnMut(Node<'tcx>) -> bool,\n {\n-    recurse(tcx, ct, &mut f);\n-    fn recurse<'tcx>(tcx: TyCtxt<'tcx>, ct: AbstractConst<'tcx>, f: &mut dyn FnMut(Node<'tcx>)) {\n+    fn recurse<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n+        ct: AbstractConst<'tcx>,\n+        f: &mut dyn FnMut(Node<'tcx>) -> bool,\n+    ) -> bool {\n         let root = ct.root();\n-        f(root);\n-        match root {\n-            Node::Leaf(_) => (),\n-            Node::Binop(_, l, r) => {\n-                recurse(tcx, ct.subtree(l), f);\n-                recurse(tcx, ct.subtree(r), f);\n-            }\n-            Node::UnaryOp(_, v) => {\n-                recurse(tcx, ct.subtree(v), f);\n-            }\n-            Node::FunctionCall(func, args) => {\n-                recurse(tcx, ct.subtree(func), f);\n-                for &arg in args {\n-                    recurse(tcx, ct.subtree(arg), f);\n+        f(root)\n+            || match root {\n+                Node::Leaf(_) => false,\n+                Node::Binop(_, l, r) => {\n+                    recurse(tcx, ct.subtree(l), f) || recurse(tcx, ct.subtree(r), f)\n+                }\n+                Node::UnaryOp(_, v) => recurse(tcx, ct.subtree(v), f),\n+                Node::FunctionCall(func, args) => {\n+                    recurse(tcx, ct.subtree(func), f)\n+                        || args.iter().any(|&arg| recurse(tcx, ct.subtree(arg), f))\n                 }\n             }\n-        }\n     }\n+\n+    recurse(tcx, ct, &mut f)\n }\n \n /// Tries to unify two abstract constants using structural equality."}, {"sha": "d2ac24b6100daf81b97b59a3bf93a4042de60228", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 61, "deletions": 24, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/1a64e570c6d3bf19a387f96bcb0bd09e51caee22/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a64e570c6d3bf19a387f96bcb0bd09e51caee22/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=1a64e570c6d3bf19a387f96bcb0bd09e51caee22", "patch": "@@ -11,6 +11,7 @@\n use super::elaborate_predicates;\n \n use crate::infer::TyCtxtInferExt;\n+use crate::traits::const_evaluatable::{self, AbstractConst};\n use crate::traits::query::evaluate_obligation::InferCtxtExt;\n use crate::traits::{self, Obligation, ObligationCause};\n use rustc_errors::FatalError;\n@@ -249,7 +250,7 @@ fn predicates_reference_self(\n     predicates\n         .predicates\n         .iter()\n-        .map(|(predicate, sp)| (predicate.subst_supertrait(tcx, &trait_ref), *sp))\n+        .map(|&(predicate, sp)| (predicate.subst_supertrait(tcx, &trait_ref), sp))\n         .filter_map(|predicate| predicate_references_self(tcx, predicate))\n         .collect()\n }\n@@ -260,7 +261,7 @@ fn bounds_reference_self(tcx: TyCtxt<'_>, trait_def_id: DefId) -> SmallVec<[Span\n         .in_definition_order()\n         .filter(|item| item.kind == ty::AssocKind::Type)\n         .flat_map(|item| tcx.explicit_item_bounds(item.def_id))\n-        .map(|(predicate, sp)| (predicate.subst_supertrait(tcx, &trait_ref), *sp))\n+        .map(|&(predicate, sp)| (predicate.subst_supertrait(tcx, &trait_ref), sp))\n         .filter_map(|predicate| predicate_references_self(tcx, predicate))\n         .collect()\n }\n@@ -415,7 +416,7 @@ fn virtual_call_violation_for_method<'tcx>(\n         ));\n     }\n \n-    for (i, input_ty) in sig.skip_binder().inputs()[1..].iter().enumerate() {\n+    for (i, &input_ty) in sig.skip_binder().inputs()[1..].iter().enumerate() {\n         if contains_illegal_self_type_reference(tcx, trait_def_id, input_ty) {\n             return Some(MethodViolationCode::ReferencesSelfInput(i));\n         }\n@@ -438,10 +439,7 @@ fn virtual_call_violation_for_method<'tcx>(\n         // so outlives predicates will always hold.\n         .cloned()\n         .filter(|(p, _)| p.to_opt_type_outlives().is_none())\n-        .collect::<Vec<_>>()\n-        // Do a shallow visit so that `contains_illegal_self_type_reference`\n-        // may apply it's custom visiting.\n-        .visit_tys_shallow(|t| contains_illegal_self_type_reference(tcx, trait_def_id, t))\n+        .any(|pred| contains_illegal_self_type_reference(tcx, trait_def_id, pred))\n     {\n         return Some(MethodViolationCode::WhereClauseReferencesSelf);\n     }\n@@ -715,10 +713,10 @@ fn receiver_is_dispatchable<'tcx>(\n     })\n }\n \n-fn contains_illegal_self_type_reference<'tcx>(\n+fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n     tcx: TyCtxt<'tcx>,\n     trait_def_id: DefId,\n-    ty: Ty<'tcx>,\n+    value: T,\n ) -> bool {\n     // This is somewhat subtle. In general, we want to forbid\n     // references to `Self` in the argument and return types,\n@@ -761,15 +759,14 @@ fn contains_illegal_self_type_reference<'tcx>(\n \n     struct IllegalSelfTypeVisitor<'tcx> {\n         tcx: TyCtxt<'tcx>,\n-        self_ty: Ty<'tcx>,\n         trait_def_id: DefId,\n         supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>>,\n     }\n \n     impl<'tcx> TypeVisitor<'tcx> for IllegalSelfTypeVisitor<'tcx> {\n         fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n             match t.kind() {\n-                ty::Param(_) => t == self.self_ty,\n+                ty::Param(_) => t == self.tcx.types.self_param,\n                 ty::Projection(ref data) => {\n                     // This is a projected type `<Foo as SomeTrait>::X`.\n \n@@ -802,22 +799,62 @@ fn contains_illegal_self_type_reference<'tcx>(\n             }\n         }\n \n-        fn visit_const(&mut self, _c: &ty::Const<'tcx>) -> bool {\n-            // FIXME(#72219) Look into the unevaluated constants for object safety violations.\n-            // Do not walk substitutions of unevaluated consts, as they contain `Self`, even\n-            // though the const expression doesn't necessary use it. Currently type variables\n-            // inside array length expressions are forbidden, so they can't break the above\n-            // rules.\n-            false\n+        fn visit_const(&mut self, ct: &ty::Const<'tcx>) -> bool {\n+            // First check if the type of this constant references `Self`.\n+            if self.visit_ty(ct.ty) {\n+                return true;\n+            }\n+\n+            // Constants can only influence object safety if they reference `Self`.\n+            // This is only possible for unevaluated constants, so we walk these here.\n+            //\n+            // If `AbstractConst::new` returned an error we already failed compilation\n+            // so we don't have to emit an additional error here.\n+            //\n+            // We currently recurse into abstract consts here but do not recurse in\n+            // `is_const_evaluatable`. This means that the object safety check is more\n+            // liberal than the const eval check.\n+            //\n+            // This shouldn't really matter though as we can't really use any\n+            // constants which are not considered const evaluatable.\n+            use rustc_middle::mir::abstract_const::Node;\n+            if let Ok(Some(ct)) = AbstractConst::from_const(self.tcx, ct) {\n+                const_evaluatable::walk_abstract_const(self.tcx, ct, |node| match node {\n+                    Node::Leaf(leaf) => {\n+                        let leaf = leaf.subst(self.tcx, ct.substs);\n+                        self.visit_const(leaf)\n+                    }\n+                    Node::Binop(..) | Node::UnaryOp(..) | Node::FunctionCall(_, _) => false,\n+                })\n+            } else {\n+                false\n+            }\n+        }\n+\n+        fn visit_predicate(&mut self, pred: ty::Predicate<'tcx>) -> bool {\n+            if let ty::PredicateAtom::ConstEvaluatable(def, substs) = pred.skip_binders() {\n+                // FIXME(const_evaluatable_checked): We should probably deduplicate the logic for\n+                // `AbstractConst`s here, it might make sense to change `ConstEvaluatable` to\n+                // take a `ty::Const` instead.\n+                use rustc_middle::mir::abstract_const::Node;\n+                if let Ok(Some(ct)) = AbstractConst::new(self.tcx, def, substs) {\n+                    const_evaluatable::walk_abstract_const(self.tcx, ct, |node| match node {\n+                        Node::Leaf(leaf) => {\n+                            let leaf = leaf.subst(self.tcx, ct.substs);\n+                            self.visit_const(leaf)\n+                        }\n+                        Node::Binop(..) | Node::UnaryOp(..) | Node::FunctionCall(_, _) => false,\n+                    })\n+                } else {\n+                    false\n+                }\n+            } else {\n+                pred.super_visit_with(self)\n+            }\n         }\n     }\n \n-    ty.visit_with(&mut IllegalSelfTypeVisitor {\n-        tcx,\n-        self_ty: tcx.types.self_param,\n-        trait_def_id,\n-        supertraits: None,\n-    })\n+    value.visit_with(&mut IllegalSelfTypeVisitor { tcx, trait_def_id, supertraits: None })\n }\n \n pub fn provide(providers: &mut ty::query::Providers) {"}, {"sha": "136867d78f57319e063645963356ff9472299de1", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1a64e570c6d3bf19a387f96bcb0bd09e51caee22/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a64e570c6d3bf19a387f96bcb0bd09e51caee22/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=1a64e570c6d3bf19a387f96bcb0bd09e51caee22", "patch": "@@ -2090,25 +2090,25 @@ fn const_evaluatable_predicates_of<'tcx>(\n     if let hir::Node::Item(item) = node {\n         if let hir::ItemKind::Impl { ref of_trait, ref self_ty, .. } = item.kind {\n             if let Some(of_trait) = of_trait {\n-                warn!(\"const_evaluatable_predicates_of({:?}): visit impl trait_ref\", def_id);\n+                debug!(\"const_evaluatable_predicates_of({:?}): visit impl trait_ref\", def_id);\n                 collector.visit_trait_ref(of_trait);\n             }\n \n-            warn!(\"const_evaluatable_predicates_of({:?}): visit_self_ty\", def_id);\n+            debug!(\"const_evaluatable_predicates_of({:?}): visit_self_ty\", def_id);\n             collector.visit_ty(self_ty);\n         }\n     }\n \n     if let Some(generics) = node.generics() {\n-        warn!(\"const_evaluatable_predicates_of({:?}): visit_generics\", def_id);\n+        debug!(\"const_evaluatable_predicates_of({:?}): visit_generics\", def_id);\n         collector.visit_generics(generics);\n     }\n \n     if let Some(fn_sig) = tcx.hir().fn_sig_by_hir_id(hir_id) {\n-        warn!(\"const_evaluatable_predicates_of({:?}): visit_fn_decl\", def_id);\n+        debug!(\"const_evaluatable_predicates_of({:?}): visit_fn_decl\", def_id);\n         collector.visit_fn_decl(fn_sig.decl);\n     }\n-    warn!(\"const_evaluatable_predicates_of({:?}) = {:?}\", def_id, collector.preds);\n+    debug!(\"const_evaluatable_predicates_of({:?}) = {:?}\", def_id, collector.preds);\n \n     collector.preds\n }"}, {"sha": "5be4b41784c270dbd580373ee531709e8593e37e", "filename": "src/test/ui/const-generics/const_evaluatable_checked/object-safety-err-ret.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1a64e570c6d3bf19a387f96bcb0bd09e51caee22/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a64e570c6d3bf19a387f96bcb0bd09e51caee22/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-ret.rs?ref=1a64e570c6d3bf19a387f96bcb0bd09e51caee22", "patch": "@@ -0,0 +1,21 @@\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+\n+const fn bar<T: ?Sized>() -> usize { 7 }\n+\n+trait Foo {\n+    fn test(&self) -> [u8; bar::<Self>()];\n+}\n+\n+impl Foo for () {\n+    fn test(&self) -> [u8; bar::<Self>()] {\n+        [0; bar::<Self>()]\n+    }\n+}\n+\n+fn use_dyn(v: &dyn Foo) { //~ERROR the trait `Foo` cannot be made into an object\n+    v.test();\n+}\n+\n+fn main() {}"}, {"sha": "e0e6029252c00b3471084c478d037e1e4e86f45e", "filename": "src/test/ui/const-generics/const_evaluatable_checked/object-safety-err-ret.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1a64e570c6d3bf19a387f96bcb0bd09e51caee22/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-ret.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1a64e570c6d3bf19a387f96bcb0bd09e51caee22/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-ret.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-ret.stderr?ref=1a64e570c6d3bf19a387f96bcb0bd09e51caee22", "patch": "@@ -0,0 +1,18 @@\n+error[E0038]: the trait `Foo` cannot be made into an object\n+  --> $DIR/object-safety-err-ret.rs:17:15\n+   |\n+LL | fn use_dyn(v: &dyn Foo) {\n+   |               ^^^^^^^^ `Foo` cannot be made into an object\n+   |\n+   = help: consider moving `test` to another trait\n+note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n+  --> $DIR/object-safety-err-ret.rs:8:23\n+   |\n+LL | trait Foo {\n+   |       --- this trait cannot be made into an object...\n+LL |     fn test(&self) -> [u8; bar::<Self>()];\n+   |                       ^^^^^^^^^^^^^^^^^^^ ...because method `test` references the `Self` type in its return type\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0038`."}, {"sha": "5fbd4a5fa2e6434dee7d0d115bcbc6fd587ff789", "filename": "src/test/ui/const-generics/const_evaluatable_checked/object-safety-err-where-bounds.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1a64e570c6d3bf19a387f96bcb0bd09e51caee22/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-where-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a64e570c6d3bf19a387f96bcb0bd09e51caee22/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-where-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-where-bounds.rs?ref=1a64e570c6d3bf19a387f96bcb0bd09e51caee22", "patch": "@@ -0,0 +1,22 @@\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+#![deny(where_clauses_object_safety)]\n+\n+\n+const fn bar<T: ?Sized>() -> usize { 7 }\n+\n+trait Foo {\n+    fn test(&self) where [u8; bar::<Self>()]: Sized;\n+    //~^ ERROR the trait `Foo` cannot be made into an object\n+    //~| WARN this was previously accepted by the compiler but is being phased out\n+}\n+\n+impl Foo for () {\n+    fn test(&self) where [u8; bar::<Self>()]: Sized {}\n+}\n+\n+fn use_dyn(v: &dyn Foo) {\n+    v.test();\n+}\n+\n+fn main() {}"}, {"sha": "45c7d835f339a9321a2f2656939e45c5f8b6de6c", "filename": "src/test/ui/const-generics/const_evaluatable_checked/object-safety-err-where-bounds.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1a64e570c6d3bf19a387f96bcb0bd09e51caee22/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-where-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1a64e570c6d3bf19a387f96bcb0bd09e51caee22/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-where-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-where-bounds.stderr?ref=1a64e570c6d3bf19a387f96bcb0bd09e51caee22", "patch": "@@ -0,0 +1,24 @@\n+error: the trait `Foo` cannot be made into an object\n+  --> $DIR/object-safety-err-where-bounds.rs:9:8\n+   |\n+LL |     fn test(&self) where [u8; bar::<Self>()]: Sized;\n+   |        ^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/object-safety-err-where-bounds.rs:3:9\n+   |\n+LL | #![deny(where_clauses_object_safety)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #51443 <https://github.com/rust-lang/rust/issues/51443>\n+note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n+  --> $DIR/object-safety-err-where-bounds.rs:9:8\n+   |\n+LL | trait Foo {\n+   |       --- this trait cannot be made into an object...\n+LL |     fn test(&self) where [u8; bar::<Self>()]: Sized;\n+   |        ^^^^ ...because method `test` references the `Self` type in its `where` clause\n+   = help: consider moving `test` to another trait\n+\n+error: aborting due to previous error\n+"}, {"sha": "9a95908d59d0d1a56d681dea43558f7be52e11f7", "filename": "src/test/ui/const-generics/const_evaluatable_checked/object-safety-ok-infer-err.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1a64e570c6d3bf19a387f96bcb0bd09e51caee22/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-ok-infer-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a64e570c6d3bf19a387f96bcb0bd09e51caee22/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-ok-infer-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-ok-infer-err.rs?ref=1a64e570c6d3bf19a387f96bcb0bd09e51caee22", "patch": "@@ -0,0 +1,22 @@\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+trait Foo<const N: usize> {\n+    fn test(&self) -> [u8; N + 1];\n+}\n+\n+impl<const N: usize> Foo<N> for () {\n+    fn test(&self) -> [u8; N + 1] {\n+        [0; N + 1]\n+    }\n+}\n+\n+fn use_dyn<const N: usize>(v: &dyn Foo<N>) where [u8; N + 1]: Sized {\n+    assert_eq!(v.test(), [0; N + 1]);\n+}\n+\n+fn main() {\n+    // FIXME(const_evaluatable_checked): Improve the error message here.\n+    use_dyn(&());\n+    //~^ ERROR type annotations needed\n+}"}, {"sha": "dd2c11e42c5d2a2f4b7c783a1c8500e70a0ef030", "filename": "src/test/ui/const-generics/const_evaluatable_checked/object-safety-ok-infer-err.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1a64e570c6d3bf19a387f96bcb0bd09e51caee22/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-ok-infer-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1a64e570c6d3bf19a387f96bcb0bd09e51caee22/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-ok-infer-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-ok-infer-err.stderr?ref=1a64e570c6d3bf19a387f96bcb0bd09e51caee22", "patch": "@@ -0,0 +1,12 @@\n+error[E0284]: type annotations needed: cannot satisfy `the constant `use_dyn::<{_: usize}>::{constant#0}` can be evaluated`\n+  --> $DIR/object-safety-ok-infer-err.rs:20:5\n+   |\n+LL | fn use_dyn<const N: usize>(v: &dyn Foo<N>) where [u8; N + 1]: Sized {\n+   |                                                       ----- required by this bound in `use_dyn`\n+...\n+LL |     use_dyn(&());\n+   |     ^^^^^^^ cannot satisfy `the constant `use_dyn::<{_: usize}>::{constant#0}` can be evaluated`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0284`."}, {"sha": "ae78b7936a289396962203a9ab202ce66be6dec1", "filename": "src/test/ui/const-generics/const_evaluatable_checked/object-safety-ok.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1a64e570c6d3bf19a387f96bcb0bd09e51caee22/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a64e570c6d3bf19a387f96bcb0bd09e51caee22/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-ok.rs?ref=1a64e570c6d3bf19a387f96bcb0bd09e51caee22", "patch": "@@ -0,0 +1,21 @@\n+// run-pass\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+trait Foo<const N: usize> {\n+    fn test(&self) -> [u8; N + 1];\n+}\n+\n+impl<const N: usize> Foo<N> for () {\n+    fn test(&self) -> [u8; N + 1] {\n+        [0; N + 1]\n+    }\n+}\n+\n+fn use_dyn<const N: usize>(v: &dyn Foo<N>) where [u8; N + 1]: Sized {\n+    assert_eq!(v.test(), [0; N + 1]);\n+}\n+\n+fn main() {\n+    use_dyn::<3>(&());\n+}"}]}