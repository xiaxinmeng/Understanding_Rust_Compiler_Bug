{"sha": "d326a29b4b763e2f81ea72996765af3bd7394f8c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzMjZhMjliNGI3NjNlMmY4MWVhNzI5OTY3NjVhZjNiZDczOTRmOGM=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-10-18T02:40:11Z"}, "committer": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-10-18T02:40:11Z"}, "message": "Merge pull request #479 from marcusklaas/moar-types\n\nFormat more type variants", "tree": {"sha": "0c28984242b3db8689981355c19c3d3a4efd2f85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c28984242b3db8689981355c19c3d3a4efd2f85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d326a29b4b763e2f81ea72996765af3bd7394f8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d326a29b4b763e2f81ea72996765af3bd7394f8c", "html_url": "https://github.com/rust-lang/rust/commit/d326a29b4b763e2f81ea72996765af3bd7394f8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d326a29b4b763e2f81ea72996765af3bd7394f8c/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7019ce8976ef1657ff47d021ffc7e31ddadbfe6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7019ce8976ef1657ff47d021ffc7e31ddadbfe6", "html_url": "https://github.com/rust-lang/rust/commit/d7019ce8976ef1657ff47d021ffc7e31ddadbfe6"}, {"sha": "01937061a905d52d4893e31d64c5f8a7d2e5a044", "url": "https://api.github.com/repos/rust-lang/rust/commits/01937061a905d52d4893e31d64c5f8a7d2e5a044", "html_url": "https://github.com/rust-lang/rust/commit/01937061a905d52d4893e31d64c5f8a7d2e5a044"}], "stats": {"total": 177, "additions": 111, "deletions": 66}, "files": [{"sha": "2deaed9609a4b16d915f6adca68f41988ca4bd07", "filename": "src/expr.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d326a29b4b763e2f81ea72996765af3bd7394f8c/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d326a29b4b763e2f81ea72996765af3bd7394f8c/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=d326a29b4b763e2f81ea72996765af3bd7394f8c", "patch": "@@ -161,10 +161,10 @@ impl Rewrite for ast::Expr {\n                 wrap_str(\"return\".to_owned(), context.config.max_width, width, offset)\n             }\n             ast::Expr_::ExprRet(Some(ref expr)) => {\n-                rewrite_unary_prefix(context, \"return \", expr, width, offset)\n+                rewrite_unary_prefix(context, \"return \", &**expr, width, offset)\n             }\n             ast::Expr_::ExprBox(ref expr) => {\n-                rewrite_unary_prefix(context, \"box \", expr, width, offset)\n+                rewrite_unary_prefix(context, \"box \", &**expr, width, offset)\n             }\n             ast::Expr_::ExprAddrOf(mutability, ref expr) => {\n                 rewrite_expr_addrof(context, mutability, expr, width, offset)\n@@ -210,15 +210,15 @@ impl Rewrite for ast::Expr {\n     }\n }\n \n-fn rewrite_pair<LHS, RHS>(lhs: &LHS,\n-                          rhs: &RHS,\n-                          prefix: &str,\n-                          infix: &str,\n-                          suffix: &str,\n-                          context: &RewriteContext,\n-                          width: usize,\n-                          offset: Indent)\n-                          -> Option<String>\n+pub fn rewrite_pair<LHS, RHS>(lhs: &LHS,\n+                              rhs: &RHS,\n+                              prefix: &str,\n+                              infix: &str,\n+                              suffix: &str,\n+                              context: &RewriteContext,\n+                              width: usize,\n+                              offset: Indent)\n+                              -> Option<String>\n     where LHS: Rewrite,\n           RHS: Rewrite\n {\n@@ -1470,16 +1470,16 @@ fn rewrite_binary_op(context: &RewriteContext,\n                  rhs_result))\n }\n \n-fn rewrite_unary_prefix(context: &RewriteContext,\n-                        prefix: &str,\n-                        expr: &ast::Expr,\n-                        width: usize,\n-                        offset: Indent)\n-                        -> Option<String> {\n-    expr.rewrite(context,\n-                 try_opt!(width.checked_sub(prefix.len())),\n-                 offset + prefix.len())\n-        .map(|r| format!(\"{}{}\", prefix, r))\n+pub fn rewrite_unary_prefix<R: Rewrite>(context: &RewriteContext,\n+                                        prefix: &str,\n+                                        rewrite: &R,\n+                                        width: usize,\n+                                        offset: Indent)\n+                                        -> Option<String> {\n+    rewrite.rewrite(context,\n+                    try_opt!(width.checked_sub(prefix.len())),\n+                    offset + prefix.len())\n+           .map(|r| format!(\"{}{}\", prefix, r))\n }\n \n fn rewrite_unary_op(context: &RewriteContext,"}, {"sha": "f2ce2106991a611ff274c42d3754ded3e6d5e35a", "filename": "src/items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d326a29b4b763e2f81ea72996765af3bd7394f8c/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d326a29b4b763e2f81ea72996765af3bd7394f8c/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=d326a29b4b763e2f81ea72996765af3bd7394f8c", "patch": "@@ -521,7 +521,7 @@ impl<'a> FmtVisitor<'a> {\n \n             let variadic_arg = if variadic {\n                 let variadic_span = codemap::mk_sp(args.last().unwrap().ty.span.hi, span.hi);\n-                let variadic_start = span_after(variadic_span, \"...\", self.codemap) - BytePos(1);\n+                let variadic_start = span_after(variadic_span, \"...\", self.codemap) - BytePos(3);\n                 Some(ArgumentKind::Variadic(variadic_start))\n             } else {\n                 None"}, {"sha": "14c0c2669a9d27d90771220083237c193f71bf26", "filename": "src/types.rs", "status": "modified", "additions": 77, "deletions": 43, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/d326a29b4b763e2f81ea72996765af3bd7394f8c/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d326a29b4b763e2f81ea72996765af3bd7394f8c/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=d326a29b4b763e2f81ea72996765af3bd7394f8c", "patch": "@@ -8,14 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use syntax::ast;\n+use syntax::ast::{self, Mutability};\n use syntax::print::pprust;\n use syntax::codemap::{self, Span, BytePos, CodeMap};\n \n use Indent;\n use lists::{format_item_list, itemize_list, format_fn_args, list_helper, ListTactic};\n use rewrite::{Rewrite, RewriteContext};\n use utils::{extra_offset, span_after, format_mutability, wrap_str};\n+use expr::{rewrite_unary_prefix, rewrite_pair};\n \n impl Rewrite for ast::Path {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n@@ -129,21 +130,25 @@ impl<'a> SegmentParam<'a> {\n }\n \n impl<'a> Rewrite for SegmentParam<'a> {\n-    // FIXME: doesn't always use width, offset.\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n-        Some(match *self {\n+        match *self {\n             SegmentParam::LifeTime(ref lt) => {\n-                pprust::lifetime_to_string(lt)\n+                wrap_str(pprust::lifetime_to_string(lt),\n+                         context.config.max_width,\n+                         width,\n+                         offset)\n             }\n             SegmentParam::Type(ref ty) => {\n-                try_opt!(ty.rewrite(context, width, offset))\n+                ty.rewrite(context, width, offset)\n             }\n             SegmentParam::Binding(ref binding) => {\n-                format!(\"{} = {}\",\n-                        binding.ident,\n-                        try_opt!(binding.ty.rewrite(context, width, offset)))\n+                let mut result = format!(\"{} = \", binding.ident);\n+                let budget = try_opt!(width.checked_sub(result.len()));\n+                let rewrite = try_opt!(binding.ty.rewrite(context, budget, offset + result.len()));\n+                result.push_str(&rewrite);\n+                Some(result)\n             }\n-        })\n+        }\n     }\n }\n \n@@ -163,9 +168,7 @@ fn get_path_separator(codemap: &CodeMap,\n     for c in snippet.chars().rev() {\n         if c == ':' {\n             return \"::\";\n-        } else if c.is_whitespace() || c == '<' {\n-            continue;\n-        } else {\n+        } else if !c.is_whitespace() && c != '<' {\n             return \"\";\n         }\n     }\n@@ -271,8 +274,7 @@ fn rewrite_segment(segment: &ast::PathSegment,\n impl Rewrite for ast::WherePredicate {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         // TODO: dead spans?\n-        // TODO: don't assume we'll always fit on one line...\n-        Some(match *self {\n+        let result = match *self {\n             ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate { ref bound_lifetimes,\n                                                                            ref bounded_ty,\n                                                                            ref bounds,\n@@ -335,23 +337,27 @@ impl Rewrite for ast::WherePredicate {\n                 let path_str = try_opt!(path.rewrite(context, budget, offset + used_width));\n                 format!(\"{} = {}\", path_str, ty_str)\n             }\n-        })\n+        };\n+\n+        wrap_str(result, context.config.max_width, width, offset)\n     }\n }\n \n impl Rewrite for ast::LifetimeDef {\n-    fn rewrite(&self, _: &RewriteContext, _: usize, _: Indent) -> Option<String> {\n-        if self.bounds.is_empty() {\n-            Some(pprust::lifetime_to_string(&self.lifetime))\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n+        let result = if self.bounds.is_empty() {\n+            pprust::lifetime_to_string(&self.lifetime)\n         } else {\n-            Some(format!(\"{}: {}\",\n-                         pprust::lifetime_to_string(&self.lifetime),\n-                         self.bounds\n-                             .iter()\n-                             .map(pprust::lifetime_to_string)\n-                             .collect::<Vec<_>>()\n-                             .join(\" + \")))\n-        }\n+            format!(\"{}: {}\",\n+                    pprust::lifetime_to_string(&self.lifetime),\n+                    self.bounds\n+                        .iter()\n+                        .map(pprust::lifetime_to_string)\n+                        .collect::<Vec<_>>()\n+                        .join(\" + \"))\n+        };\n+\n+        wrap_str(result, context.config.max_width, width, offset)\n     }\n }\n \n@@ -366,7 +372,10 @@ impl Rewrite for ast::TyParamBound {\n                 Some(format!(\"?{}\", try_opt!(tref.rewrite(context, budget, offset + 1))))\n             }\n             ast::TyParamBound::RegionTyParamBound(ref l) => {\n-                Some(pprust::lifetime_to_string(l))\n+                wrap_str(pprust::lifetime_to_string(l),\n+                         context.config.max_width,\n+                         width,\n+                         offset)\n             }\n         }\n     }\n@@ -377,11 +386,10 @@ impl Rewrite for ast::TyParamBounds {\n         let strs: Vec<_> = try_opt!(self.iter()\n                                         .map(|b| b.rewrite(context, width, offset))\n                                         .collect());\n-        Some(strs.join(\" + \"))\n+        wrap_str(strs.join(\" + \"), context.config.max_width, width, offset)\n     }\n }\n \n-// FIXME: this assumes everything will fit on one line\n impl Rewrite for ast::TyParam {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         let mut result = String::with_capacity(128);\n@@ -404,11 +412,10 @@ impl Rewrite for ast::TyParam {\n             result.push_str(&rewrite);\n         }\n \n-        Some(result)\n+        wrap_str(result, context.config.max_width, width, offset)\n     }\n }\n \n-// FIXME: this assumes everything will fit on one line\n impl Rewrite for ast::PolyTraitRef {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         if !self.bound_lifetimes.is_empty() {\n@@ -432,12 +439,8 @@ impl Rewrite for ast::PolyTraitRef {\n }\n \n impl Rewrite for ast::Ty {\n-    // FIXME doesn't always use width, offset\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         match self.node {\n-            ast::TyPath(None, ref p) => {\n-                p.rewrite(context, width, offset)\n-            }\n             ast::TyObjectSum(ref ty, ref bounds) => {\n                 let ty_str = try_opt!(ty.rewrite(context, width, offset));\n                 let overhead = ty_str.len() + 3;\n@@ -447,6 +450,14 @@ impl Rewrite for ast::Ty {\n                                                      try_opt!(width.checked_sub(overhead)),\n                                                      offset + overhead))))\n             }\n+            ast::TyPtr(ref mt) => {\n+                let prefix = match mt.mutbl {\n+                    Mutability::MutMutable => \"*mut \",\n+                    Mutability::MutImmutable => \"*const \",\n+                };\n+\n+                rewrite_unary_prefix(context, prefix, &*mt.ty, width, offset)\n+            }\n             ast::TyRptr(ref lifetime, ref mt) => {\n                 let mut_str = format_mutability(mt.mutbl);\n                 let mut_len = mut_str.len();\n@@ -470,37 +481,60 @@ impl Rewrite for ast::Ty {\n                     }\n                 })\n             }\n+            // FIXME: we drop any comments here, even though it's a silly place to put\n+            // comments.\n             ast::TyParen(ref ty) => {\n                 let budget = try_opt!(width.checked_sub(2));\n                 ty.rewrite(context, budget, offset + 1).map(|ty_str| format!(\"({})\", ty_str))\n             }\n-            ast::TyTup(ref tup_ret) => {\n+            ast::TyVec(ref ty) => {\n                 let budget = try_opt!(width.checked_sub(2));\n+                ty.rewrite(context, budget, offset + 1).map(|ty_str| format!(\"[{}]\", ty_str))\n+            }\n+            ast::TyTup(ref tup_ret) => {\n                 if tup_ret.is_empty() {\n-                    Some(\"()\".to_string())\n+                    Some(\"()\".to_owned())\n                 } else if let [ref item] = &**tup_ret {\n+                    let budget = try_opt!(width.checked_sub(3));\n                     let inner = try_opt!(item.rewrite(context, budget, offset + 1));\n                     let ret = format!(\"({},)\", inner);\n                     wrap_str(ret, context.config.max_width, budget, offset + 1)\n                 } else {\n+                    let budget = try_opt!(width.checked_sub(2));\n                     let items = itemize_list(context.codemap,\n                                              tup_ret.iter(),\n                                              \")\",\n                                              |item| item.span.lo,\n                                              |item| item.span.hi,\n                                              |item| item.rewrite(context, budget, offset + 1),\n-                                             tup_ret[0].span.lo,\n+                                             span_after(self.span, \"(\", context.codemap),\n                                              self.span.hi);\n \n-\n                     list_helper(items, budget, offset + 1, context.config, ListTactic::Mixed)\n                         .map(|s| format!(\"({})\", s))\n                 }\n             }\n-            _ => wrap_str(pprust::ty_to_string(self),\n-                          context.config.max_width,\n-                          width,\n-                          offset),\n+            ast::TyPolyTraitRef(ref trait_ref) => trait_ref.rewrite(context, width, offset),\n+            ast::TyPath(ref q_self, ref path) => {\n+                rewrite_path(context, q_self.as_ref(), path, width, offset)\n+            }\n+            ast::TyFixedLengthVec(ref ty, ref repeats) => {\n+                rewrite_pair(&**ty, &**repeats, \"[\", \"; \", \"]\", context, width, offset)\n+            }\n+            ast::TyInfer => {\n+                if width >= 1 {\n+                    Some(\"_\".to_owned())\n+                } else {\n+                    None\n+                }\n+            }\n+            ast::TyBareFn(..) => {\n+                wrap_str(pprust::ty_to_string(self),\n+                         context.config.max_width,\n+                         width,\n+                         offset)\n+            }\n+            ast::TyMac(..) | ast::TyTypeof(..) => unreachable!(),\n         }\n     }\n }"}, {"sha": "0fd749a5471f92f5e141a5de1f5b77336d9eefbb", "filename": "src/utils.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d326a29b4b763e2f81ea72996765af3bd7394f8c/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d326a29b4b763e2f81ea72996765af3bd7394f8c/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=d326a29b4b763e2f81ea72996765af3bd7394f8c", "patch": "@@ -32,8 +32,9 @@ pub fn extra_offset(text: &str, offset: Indent) -> usize {\n #[inline]\n pub fn span_after(original: Span, needle: &str, codemap: &CodeMap) -> BytePos {\n     let snippet = codemap.span_to_snippet(original).unwrap();\n+    let offset = snippet.find_uncommented(needle).unwrap() + needle.len();\n \n-    original.lo + BytePos(snippet.find_uncommented(needle).unwrap() as u32 + 1)\n+    original.lo + BytePos(offset as u32)\n }\n \n #[inline]"}, {"sha": "6059bc7a2462a16a29619249fea0856176598a2b", "filename": "tests/source/type.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d326a29b4b763e2f81ea72996765af3bd7394f8c/tests%2Fsource%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d326a29b4b763e2f81ea72996765af3bd7394f8c/tests%2Fsource%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Ftype.rs?ref=d326a29b4b763e2f81ea72996765af3bd7394f8c", "patch": "@@ -0,0 +1,5 @@\n+fn types() {\n+    let x: [ Vec   < _ > ] = [];\n+    let y:  * mut [ SomeType ; konst_funk() ] = expr();\n+    let z: (/*#digits*/ usize, /*exp*/ i16) = funk();\n+}"}, {"sha": "afcf86123ae5a77097c742e12dba787658879867", "filename": "tests/target/type.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d326a29b4b763e2f81ea72996765af3bd7394f8c/tests%2Ftarget%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d326a29b4b763e2f81ea72996765af3bd7394f8c/tests%2Ftarget%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ftype.rs?ref=d326a29b4b763e2f81ea72996765af3bd7394f8c", "patch": "@@ -0,0 +1,5 @@\n+fn types() {\n+    let x: [Vec<_>] = [];\n+    let y: *mut [SomeType; konst_funk()] = expr();\n+    let z: (/* #digits */ usize, /* exp */ i16) = funk();\n+}"}]}