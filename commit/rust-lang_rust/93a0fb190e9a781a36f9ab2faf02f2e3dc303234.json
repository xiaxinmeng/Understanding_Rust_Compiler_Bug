{"sha": "93a0fb190e9a781a36f9ab2faf02f2e3dc303234", "node_id": "C_kwDOAAsO6NoAKDkzYTBmYjE5MGU5YTc4MWEzNmY5YWIyZmFmMDJmMmUzZGMzMDMyMzQ", "commit": {"author": {"name": "Joshua Nelson", "email": "jnelson@cloudflare.com", "date": "2022-09-12T02:10:53Z"}, "committer": {"name": "Joshua Nelson", "email": "jnelson@cloudflare.com", "date": "2022-09-25T16:56:23Z"}, "message": "Move `DepKindStruct` from rustc_middle to rustc_query_system", "tree": {"sha": "fb2776254a857f14dce96af3d05645668135a167", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb2776254a857f14dce96af3d05645668135a167"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93a0fb190e9a781a36f9ab2faf02f2e3dc303234", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93a0fb190e9a781a36f9ab2faf02f2e3dc303234", "html_url": "https://github.com/rust-lang/rust/commit/93a0fb190e9a781a36f9ab2faf02f2e3dc303234", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93a0fb190e9a781a36f9ab2faf02f2e3dc303234/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4652f5eb25b76c24fc40b7267d87a07d5876901f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4652f5eb25b76c24fc40b7267d87a07d5876901f", "html_url": "https://github.com/rust-lang/rust/commit/4652f5eb25b76c24fc40b7267d87a07d5876901f"}], "stats": {"total": 128, "additions": 65, "deletions": 63}, "files": [{"sha": "32dacc25dcb79376a334074f73785ee9633b0268", "filename": "compiler/rustc_middle/src/dep_graph/dep_node.rs", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/93a0fb190e9a781a36f9ab2faf02f2e3dc303234/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93a0fb190e9a781a36f9ab2faf02f2e3dc303234/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=93a0fb190e9a781a36f9ab2faf02f2e3dc303234", "patch": "@@ -69,67 +69,6 @@ use std::hash::Hash;\n \n pub use rustc_query_system::dep_graph::{DepContext, DepNodeParams};\n \n-/// This struct stores metadata about each DepKind.\n-///\n-/// Information is retrieved by indexing the `DEP_KINDS` array using the integer value\n-/// of the `DepKind`. Overall, this allows to implement `DepContext` using this manual\n-/// jump table instead of large matches.\n-pub struct DepKindStruct<'tcx> {\n-    /// Anonymous queries cannot be replayed from one compiler invocation to the next.\n-    /// When their result is needed, it is recomputed. They are useful for fine-grained\n-    /// dependency tracking, and caching within one compiler invocation.\n-    pub is_anon: bool,\n-\n-    /// Eval-always queries do not track their dependencies, and are always recomputed, even if\n-    /// their inputs have not changed since the last compiler invocation. The result is still\n-    /// cached within one compiler invocation.\n-    pub is_eval_always: bool,\n-\n-    /// Whether the query key can be recovered from the hashed fingerprint.\n-    /// See [DepNodeParams] trait for the behaviour of each key type.\n-    pub fingerprint_style: FingerprintStyle,\n-\n-    /// The red/green evaluation system will try to mark a specific DepNode in the\n-    /// dependency graph as green by recursively trying to mark the dependencies of\n-    /// that `DepNode` as green. While doing so, it will sometimes encounter a `DepNode`\n-    /// where we don't know if it is red or green and we therefore actually have\n-    /// to recompute its value in order to find out. Since the only piece of\n-    /// information that we have at that point is the `DepNode` we are trying to\n-    /// re-evaluate, we need some way to re-run a query from just that. This is what\n-    /// `force_from_dep_node()` implements.\n-    ///\n-    /// In the general case, a `DepNode` consists of a `DepKind` and an opaque\n-    /// GUID/fingerprint that will uniquely identify the node. This GUID/fingerprint\n-    /// is usually constructed by computing a stable hash of the query-key that the\n-    /// `DepNode` corresponds to. Consequently, it is not in general possible to go\n-    /// back from hash to query-key (since hash functions are not reversible). For\n-    /// this reason `force_from_dep_node()` is expected to fail from time to time\n-    /// because we just cannot find out, from the `DepNode` alone, what the\n-    /// corresponding query-key is and therefore cannot re-run the query.\n-    ///\n-    /// The system deals with this case letting `try_mark_green` fail which forces\n-    /// the root query to be re-evaluated.\n-    ///\n-    /// Now, if `force_from_dep_node()` would always fail, it would be pretty useless.\n-    /// Fortunately, we can use some contextual information that will allow us to\n-    /// reconstruct query-keys for certain kinds of `DepNode`s. In particular, we\n-    /// enforce by construction that the GUID/fingerprint of certain `DepNode`s is a\n-    /// valid `DefPathHash`. Since we also always build a huge table that maps every\n-    /// `DefPathHash` in the current codebase to the corresponding `DefId`, we have\n-    /// everything we need to re-run the query.\n-    ///\n-    /// Take the `mir_promoted` query as an example. Like many other queries, it\n-    /// just has a single parameter: the `DefId` of the item it will compute the\n-    /// validated MIR for. Now, when we call `force_from_dep_node()` on a `DepNode`\n-    /// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`\n-    /// is actually a `DefPathHash`, and can therefore just look up the corresponding\n-    /// `DefId` in `tcx.def_path_hash_to_def_id`.\n-    pub force_from_dep_node: Option<fn(tcx: TyCtxt<'tcx>, dep_node: DepNode) -> bool>,\n-\n-    /// Invoke a query to put the on-disk cached value in memory.\n-    pub try_load_from_on_disk_cache: Option<fn(TyCtxt<'tcx>, DepNode)>,\n-}\n-\n impl DepKind {\n     #[inline(always)]\n     pub fn fingerprint_style(self, tcx: TyCtxt<'_>) -> FingerprintStyle {"}, {"sha": "0e9955e2972a7895f947146665759e0dbfbeaa8d", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/93a0fb190e9a781a36f9ab2faf02f2e3dc303234/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93a0fb190e9a781a36f9ab2faf02f2e3dc303234/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=93a0fb190e9a781a36f9ab2faf02f2e3dc303234", "patch": "@@ -11,15 +11,17 @@ pub use rustc_query_system::dep_graph::{\n     SerializedDepNodeIndex, WorkProduct, WorkProductId,\n };\n \n-pub use dep_node::{label_strs, DepKind, DepKindStruct, DepNode, DepNodeExt};\n+pub use dep_node::{label_strs, DepKind, DepNode, DepNodeExt};\n pub(crate) use dep_node::{make_compile_codegen_unit, make_compile_mono_item};\n \n pub type DepGraph = rustc_query_system::dep_graph::DepGraph<DepKind>;\n+\n pub type TaskDeps = rustc_query_system::dep_graph::TaskDeps<DepKind>;\n pub type TaskDepsRef<'a> = rustc_query_system::dep_graph::TaskDepsRef<'a, DepKind>;\n pub type DepGraphQuery = rustc_query_system::dep_graph::DepGraphQuery<DepKind>;\n pub type SerializedDepGraph = rustc_query_system::dep_graph::SerializedDepGraph<DepKind>;\n pub type EdgeFilter = rustc_query_system::dep_graph::debug::EdgeFilter<DepKind>;\n+pub type DepKindStruct<'tcx> = rustc_query_system::dep_graph::DepKindStruct<TyCtxt<'tcx>>;\n \n impl rustc_query_system::dep_graph::DepKind for DepKind {\n     const NULL: Self = DepKind::Null;"}, {"sha": "2a3657780eca539833a3b8277fa9c39bbd7e018c", "filename": "compiler/rustc_query_system/src/dep_graph/dep_node.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/93a0fb190e9a781a36f9ab2faf02f2e3dc303234/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93a0fb190e9a781a36f9ab2faf02f2e3dc303234/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=93a0fb190e9a781a36f9ab2faf02f2e3dc303234", "patch": "@@ -149,6 +149,67 @@ where\n     }\n }\n \n+/// This struct stores metadata about each DepKind.\n+///\n+/// Information is retrieved by indexing the `DEP_KINDS` array using the integer value\n+/// of the `DepKind`. Overall, this allows to implement `DepContext` using this manual\n+/// jump table instead of large matches.\n+pub struct DepKindStruct<CTX: DepContext> {\n+    /// Anonymous queries cannot be replayed from one compiler invocation to the next.\n+    /// When their result is needed, it is recomputed. They are useful for fine-grained\n+    /// dependency tracking, and caching within one compiler invocation.\n+    pub is_anon: bool,\n+\n+    /// Eval-always queries do not track their dependencies, and are always recomputed, even if\n+    /// their inputs have not changed since the last compiler invocation. The result is still\n+    /// cached within one compiler invocation.\n+    pub is_eval_always: bool,\n+\n+    /// Whether the query key can be recovered from the hashed fingerprint.\n+    /// See [DepNodeParams] trait for the behaviour of each key type.\n+    pub fingerprint_style: FingerprintStyle,\n+\n+    /// The red/green evaluation system will try to mark a specific DepNode in the\n+    /// dependency graph as green by recursively trying to mark the dependencies of\n+    /// that `DepNode` as green. While doing so, it will sometimes encounter a `DepNode`\n+    /// where we don't know if it is red or green and we therefore actually have\n+    /// to recompute its value in order to find out. Since the only piece of\n+    /// information that we have at that point is the `DepNode` we are trying to\n+    /// re-evaluate, we need some way to re-run a query from just that. This is what\n+    /// `force_from_dep_node()` implements.\n+    ///\n+    /// In the general case, a `DepNode` consists of a `DepKind` and an opaque\n+    /// GUID/fingerprint that will uniquely identify the node. This GUID/fingerprint\n+    /// is usually constructed by computing a stable hash of the query-key that the\n+    /// `DepNode` corresponds to. Consequently, it is not in general possible to go\n+    /// back from hash to query-key (since hash functions are not reversible). For\n+    /// this reason `force_from_dep_node()` is expected to fail from time to time\n+    /// because we just cannot find out, from the `DepNode` alone, what the\n+    /// corresponding query-key is and therefore cannot re-run the query.\n+    ///\n+    /// The system deals with this case letting `try_mark_green` fail which forces\n+    /// the root query to be re-evaluated.\n+    ///\n+    /// Now, if `force_from_dep_node()` would always fail, it would be pretty useless.\n+    /// Fortunately, we can use some contextual information that will allow us to\n+    /// reconstruct query-keys for certain kinds of `DepNode`s. In particular, we\n+    /// enforce by construction that the GUID/fingerprint of certain `DepNode`s is a\n+    /// valid `DefPathHash`. Since we also always build a huge table that maps every\n+    /// `DefPathHash` in the current codebase to the corresponding `DefId`, we have\n+    /// everything we need to re-run the query.\n+    ///\n+    /// Take the `mir_promoted` query as an example. Like many other queries, it\n+    /// just has a single parameter: the `DefId` of the item it will compute the\n+    /// validated MIR for. Now, when we call `force_from_dep_node()` on a `DepNode`\n+    /// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`\n+    /// is actually a `DefPathHash`, and can therefore just look up the corresponding\n+    /// `DefId` in `tcx.def_path_hash_to_def_id`.\n+    pub force_from_dep_node: Option<fn(tcx: CTX, dep_node: DepNode<CTX::DepKind>) -> bool>,\n+\n+    /// Invoke a query to put the on-disk cached value in memory.\n+    pub try_load_from_on_disk_cache: Option<fn(CTX, DepNode<CTX::DepKind>)>,\n+}\n+\n /// A \"work product\" corresponds to a `.o` (or other) file that we\n /// save in between runs. These IDs do not have a `DefId` but rather\n /// some independent path or string that persists between runs without"}, {"sha": "2b62a9ee42a6f1258190753d64e682f9792f9cf5", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93a0fb190e9a781a36f9ab2faf02f2e3dc303234/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93a0fb190e9a781a36f9ab2faf02f2e3dc303234/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=93a0fb190e9a781a36f9ab2faf02f2e3dc303234", "patch": "@@ -4,7 +4,7 @@ mod graph;\n mod query;\n mod serialized;\n \n-pub use dep_node::{DepNode, DepNodeParams, WorkProductId};\n+pub use dep_node::{DepKindStruct, DepNode, DepNodeParams, WorkProductId};\n pub use graph::{\n     hash_result, DepGraph, DepNodeColor, DepNodeIndex, TaskDeps, TaskDepsRef, WorkProduct,\n };"}]}