{"sha": "06fd8784d7c9c74a9be210c900492430cbe9eb40", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2ZmQ4Nzg0ZDdjOWM3NGE5YmUyMTBjOTAwNDkyNDMwY2JlOWViNDA=", "commit": {"author": {"name": "Jay Hardee", "email": "hardeejj9@gmail.com", "date": "2017-07-30T22:54:56Z"}, "committer": {"name": "Jay Hardee", "email": "hardeejj9@gmail.com", "date": "2017-07-31T23:06:51Z"}, "message": "Loose ends and factor out consistency logic.", "tree": {"sha": "e24fefcfbe865534a8324195d6dbaf4cfeb5fbfa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e24fefcfbe865534a8324195d6dbaf4cfeb5fbfa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06fd8784d7c9c74a9be210c900492430cbe9eb40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06fd8784d7c9c74a9be210c900492430cbe9eb40", "html_url": "https://github.com/rust-lang/rust/commit/06fd8784d7c9c74a9be210c900492430cbe9eb40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06fd8784d7c9c74a9be210c900492430cbe9eb40/comments", "author": {"login": "jayhardee9", "id": 6964208, "node_id": "MDQ6VXNlcjY5NjQyMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/6964208?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jayhardee9", "html_url": "https://github.com/jayhardee9", "followers_url": "https://api.github.com/users/jayhardee9/followers", "following_url": "https://api.github.com/users/jayhardee9/following{/other_user}", "gists_url": "https://api.github.com/users/jayhardee9/gists{/gist_id}", "starred_url": "https://api.github.com/users/jayhardee9/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jayhardee9/subscriptions", "organizations_url": "https://api.github.com/users/jayhardee9/orgs", "repos_url": "https://api.github.com/users/jayhardee9/repos", "events_url": "https://api.github.com/users/jayhardee9/events{/privacy}", "received_events_url": "https://api.github.com/users/jayhardee9/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jayhardee9", "id": 6964208, "node_id": "MDQ6VXNlcjY5NjQyMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/6964208?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jayhardee9", "html_url": "https://github.com/jayhardee9", "followers_url": "https://api.github.com/users/jayhardee9/followers", "following_url": "https://api.github.com/users/jayhardee9/following{/other_user}", "gists_url": "https://api.github.com/users/jayhardee9/gists{/gist_id}", "starred_url": "https://api.github.com/users/jayhardee9/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jayhardee9/subscriptions", "organizations_url": "https://api.github.com/users/jayhardee9/orgs", "repos_url": "https://api.github.com/users/jayhardee9/repos", "events_url": "https://api.github.com/users/jayhardee9/events{/privacy}", "received_events_url": "https://api.github.com/users/jayhardee9/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b5696524210060b75998fea33b83d7e02d84258", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b5696524210060b75998fea33b83d7e02d84258", "html_url": "https://github.com/rust-lang/rust/commit/3b5696524210060b75998fea33b83d7e02d84258"}], "stats": {"total": 51, "additions": 28, "deletions": 23}, "files": [{"sha": "266fd5031b57ed5b48191e94efd4488530c03215", "filename": "clippy_lints/src/literal_digit_grouping.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/06fd8784d7c9c74a9be210c900492430cbe9eb40/clippy_lints%2Fsrc%2Fliteral_digit_grouping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06fd8784d7c9c74a9be210c900492430cbe9eb40/clippy_lints%2Fsrc%2Fliteral_digit_grouping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_digit_grouping.rs?ref=06fd8784d7c9c74a9be210c900492430cbe9eb40", "patch": "@@ -278,33 +278,38 @@ impl LiteralDigitGrouping {\n \n             // Lint integral and fractional parts separately, and then check consistency of digit\n             // groups if both pass.\n-            if let Some(integral_group_size) = LiteralDigitGrouping::do_lint(digits[0], cx, &lit.span) {\n-                if digits.len() > 1 {\n-                    // Lint the fractional part of literal just like integral part, but reversed.\n-                    let fractional_part = &digits[1].chars().rev().collect::<String>();\n-                    if let Some(fractional_group_size) = LiteralDigitGrouping::do_lint(fractional_part, cx, &lit.span) {\n-                        let consistent = match (integral_group_size, fractional_group_size) {\n-                            // No groups on either side of decimal point - good to go.\n-                            (0, 0) => true,\n-                            // Integral part has grouped digits, fractional part does not.\n-                            (_, 0) => digits[1].len() <= integral_group_size,\n-                            // Fractional part has grouped digits, integral part does not.\n-                            (0, _) => digits[0].len() <= fractional_group_size,\n-                            // Both parts have grouped digits. Groups should be the same size.\n-                            (_, _) => integral_group_size == fractional_group_size,\n-                        };\n-\n-                        if !consistent {\n-                            span_help_and_lint(cx, INCONSISTENT_DIGIT_GROUPING, lit.span,\n-                                           \"digits grouped inconsistently by underscores\",\n-                                           \"consider making each group three or four digits\");\n-                        }\n+            let _ = LiteralDigitGrouping::do_lint(parts[0])\n+                .map(|integral_group_size| {\n+                    if parts.len() > 1 {\n+                        // Lint the fractional part of literal just like integral part, but reversed.\n+                        let fractional_part = &parts[1].chars().rev().collect::<String>();\n+                        let _ = LiteralDigitGrouping::do_lint(fractional_part)\n+                            .map(|fractional_group_size| {\n+                                let consistent = LiteralDigitGrouping::parts_consistent(integral_group_size, fractional_group_size, parts[0].len(), parts[1].len());\n+                                if !consistent {\n+                                    WarningType::InconsistentDigitGrouping.display(&digit_info.grouping_hint(), cx, &lit.span);\n+                                }\n+                            })\n+                            .map_err(|warning_type| warning_type.display(&digit_info.grouping_hint(), cx, &lit.span));\n                     }\n-                }\n-            }\n+                })\n+                .map_err(|warning_type| warning_type.display(&digit_info.grouping_hint(), cx, &lit.span));\n         }}\n     }\n \n+    /// Given the sizes of the digit groups of both integral and fractional\n+    /// parts, and the length\n+    /// of both parts, determine if the digits have been grouped consistently.\n+    fn parts_consistent(int_group_size: usize, frac_group_size: usize, int_size: usize, frac_size: usize) -> bool {\n+        match (int_group_size, frac_group_size) {\n+            // No groups on either side of decimal point - trivially consistent.\n+            (0, 0) => true,\n+            // Integral part has grouped digits, fractional part does not.\n+            (_, 0) => frac_size <= int_group_size,\n+            // Fractional part has grouped digits, integral part does not.\n+            (0, _) => int_size <= frac_group_size,\n+            // Both parts have grouped digits. Groups should be the same size.\n+            (_, _) => int_group_size == frac_group_size,\n         }\n     }\n "}]}