{"sha": "92d66764121a719d6755a7c33829598d32c9f4ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyZDY2NzY0MTIxYTcxOWQ2NzU1YTdjMzM4Mjk1OThkMzJjOWY0YmE=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-06-08T22:36:30Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-06-14T20:16:35Z"}, "message": "save-analysis: use a macro for 'downcasting'", "tree": {"sha": "9dcb9459996a7526556a2bc7ff87f9856657a409", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9dcb9459996a7526556a2bc7ff87f9856657a409"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92d66764121a719d6755a7c33829598d32c9f4ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92d66764121a719d6755a7c33829598d32c9f4ba", "html_url": "https://github.com/rust-lang/rust/commit/92d66764121a719d6755a7c33829598d32c9f4ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92d66764121a719d6755a7c33829598d32c9f4ba/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "788fdddf3735f49c06b847578a090a863ed1c32d", "url": "https://api.github.com/repos/rust-lang/rust/commits/788fdddf3735f49c06b847578a090a863ed1c32d", "html_url": "https://github.com/rust-lang/rust/commit/788fdddf3735f49c06b847578a090a863ed1c32d"}], "stats": {"total": 271, "additions": 132, "deletions": 139}, "files": [{"sha": "ffa8c524b58f76233965b22698507038cf25a8e7", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 124, "deletions": 139, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/92d66764121a719d6755a7c33829598d32c9f4ba/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d66764121a719d6755a7c33829598d32c9f4ba/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=92d66764121a719d6755a7c33829598d32c9f4ba", "patch": "@@ -54,6 +54,15 @@ use super::recorder::{Recorder, FmtStrs};\n \n use util::ppaux;\n \n+macro_rules! down_cast_data {\n+    ($id:ident, $kind:ident, $this:ident, $sp:expr) => {\n+        let $id = if let super::Data::$kind(data) = $id {\n+            data\n+        } else {\n+            $this.sess.span_bug($sp, &format!(\"unexpected data kind: {:?}\", $id));\n+        };\n+    };\n+}\n \n pub struct DumpCsvVisitor<'l, 'tcx: 'l> {\n     save_ctxt: SaveContext<'l, 'tcx>,\n@@ -436,17 +445,14 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                                 parent_id: NodeId) {\n         let field_data = self.save_ctxt.get_field_data(field, parent_id);\n         if let Some(field_data) = field_data {\n-            if let super::Data::VariableData(field_data) = field_data {\n-                self.fmt.field_str(field.span,\n-                                   Some(field_data.span),\n-                                   field_data.id,\n-                                   &field_data.name,\n-                                   &field_data.qualname,\n-                                   &field_data.type_value,\n-                                   field_data.scope);\n-            } else {\n-                self.sess.span_bug(field.span, \"expected VariableData\");\n-            }\n+            down_cast_data!(field_data, VariableData, self, field.span);\n+            self.fmt.field_str(field.span,\n+                               Some(field_data.span),\n+                               field_data.id,\n+                               &field_data.name,\n+                               &field_data.qualname,\n+                               &field_data.type_value,\n+                               field_data.scope);\n         }\n     }\n \n@@ -483,19 +489,16 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                   ty_params: &ast::Generics,\n                   body: &ast::Block) {\n         let fn_data = self.save_ctxt.get_item_data(item);\n-        if let super::Data::FunctionData(fn_data) = fn_data {\n-            self.fmt.fn_str(item.span,\n-                            Some(fn_data.span),\n-                            fn_data.id,\n-                            &fn_data.qualname,\n-                            fn_data.scope);\n+        down_cast_data!(fn_data, FunctionData, self, item.span);\n+        self.fmt.fn_str(item.span,\n+                        Some(fn_data.span),\n+                        fn_data.id,\n+                        &fn_data.qualname,\n+                        fn_data.scope);\n \n \n-            self.process_formals(&decl.inputs, &fn_data.qualname);\n-            self.process_generic_params(ty_params, item.span, &fn_data.qualname, item.id);\n-        } else {\n-            self.sess.span_bug(item.span, \"expected FunctionData\");\n-        }\n+        self.process_formals(&decl.inputs, &fn_data.qualname);\n+        self.process_generic_params(ty_params, item.span, &fn_data.qualname, item.id);\n \n         for arg in &decl.inputs {\n             self.visit_ty(&arg.ty);\n@@ -514,18 +517,15 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                                     expr: &ast::Expr)\n     {\n         let var_data = self.save_ctxt.get_item_data(item);\n-        if let super::Data::VariableData(var_data) = var_data {\n-            self.fmt.static_str(item.span,\n-                                Some(var_data.span),\n-                                var_data.id,\n-                                &var_data.name,\n-                                &var_data.qualname,\n-                                &var_data.value,\n-                                &var_data.type_value,\n-                                var_data.scope);\n-        } else {\n-            self.sess.span_bug(item.span, \"expected VariableData\");\n-        }\n+        down_cast_data!(var_data, VariableData, self, item.span);\n+        self.fmt.static_str(item.span,\n+                            Some(var_data.span),\n+                            var_data.id,\n+                            &var_data.name,\n+                            &var_data.qualname,\n+                            &var_data.value,\n+                            &var_data.type_value,\n+                            var_data.scope);\n \n         self.visit_ty(&typ);\n         self.visit_expr(expr);\n@@ -591,60 +591,57 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                     enum_definition: &ast::EnumDef,\n                     ty_params: &ast::Generics) {\n         let enum_data = self.save_ctxt.get_item_data(item);\n-        if let super::Data::EnumData(enum_data) = enum_data {\n-            self.fmt.enum_str(item.span,\n-                              Some(enum_data.span),\n-                              enum_data.id,\n-                              &enum_data.qualname,\n-                              enum_data.scope,\n-                              &enum_data.value);\n-\n-            for variant in &enum_definition.variants {\n-                let name = &get_ident(variant.node.name);\n-                let mut qualname = enum_data.qualname.clone();\n-                qualname.push_str(\"::\");\n-                qualname.push_str(name);\n-                let val = self.span.snippet(variant.span);\n-                match variant.node.kind {\n-                    ast::TupleVariantKind(ref args) => {\n-                        // first ident in span is the variant's name\n-                        self.fmt.tuple_variant_str(variant.span,\n-                                                   self.span.span_for_first_ident(variant.span),\n-                                                   variant.node.id,\n-                                                   name,\n-                                                   &qualname,\n-                                                   &enum_data.qualname,\n-                                                   &val,\n-                                                   enum_data.id);\n-                        for arg in args {\n-                            self.visit_ty(&*arg.ty);\n-                        }\n+        down_cast_data!(enum_data, EnumData, self, item.span);\n+        self.fmt.enum_str(item.span,\n+                          Some(enum_data.span),\n+                          enum_data.id,\n+                          &enum_data.qualname,\n+                          enum_data.scope,\n+                          &enum_data.value);\n+\n+        for variant in &enum_definition.variants {\n+            let name = &get_ident(variant.node.name);\n+            let mut qualname = enum_data.qualname.clone();\n+            qualname.push_str(\"::\");\n+            qualname.push_str(name);\n+            let val = self.span.snippet(variant.span);\n+            match variant.node.kind {\n+                ast::TupleVariantKind(ref args) => {\n+                    // first ident in span is the variant's name\n+                    self.fmt.tuple_variant_str(variant.span,\n+                                               self.span.span_for_first_ident(variant.span),\n+                                               variant.node.id,\n+                                               name,\n+                                               &qualname,\n+                                               &enum_data.qualname,\n+                                               &val,\n+                                               enum_data.id);\n+                    for arg in args {\n+                        self.visit_ty(&*arg.ty);\n                     }\n-                    ast::StructVariantKind(ref struct_def) => {\n-                        let ctor_id = match struct_def.ctor_id {\n-                            Some(node_id) => node_id,\n-                            None => -1,\n-                        };\n-                        self.fmt.struct_variant_str(variant.span,\n-                                                    self.span.span_for_first_ident(variant.span),\n-                                                    variant.node.id,\n-                                                    ctor_id,\n-                                                    &qualname,\n-                                                    &enum_data.qualname,\n-                                                    &val,\n-                                                    enum_data.id);\n-\n-                        for field in &struct_def.fields {\n-                            self.process_struct_field_def(field, variant.node.id);\n-                            self.visit_ty(&*field.node.ty);\n-                        }\n+                }\n+                ast::StructVariantKind(ref struct_def) => {\n+                    let ctor_id = match struct_def.ctor_id {\n+                        Some(node_id) => node_id,\n+                        None => -1,\n+                    };\n+                    self.fmt.struct_variant_str(variant.span,\n+                                                self.span.span_for_first_ident(variant.span),\n+                                                variant.node.id,\n+                                                ctor_id,\n+                                                &qualname,\n+                                                &enum_data.qualname,\n+                                                &val,\n+                                                enum_data.id);\n+\n+                    for field in &struct_def.fields {\n+                        self.process_struct_field_def(field, variant.node.id);\n+                        self.visit_ty(&*field.node.ty);\n                     }\n                 }\n             }\n-            self.process_generic_params(ty_params, item.span, &enum_data.qualname, enum_data.id);\n-        } else {\n-            self.sess.span_bug(item.span, \"expected EnumData\");\n         }\n+        self.process_generic_params(ty_params, item.span, &enum_data.qualname, enum_data.id);\n     }\n \n     fn process_impl(&mut self,\n@@ -654,38 +651,35 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                     typ: &ast::Ty,\n                     impl_items: &[P<ast::ImplItem>]) {\n         let impl_data = self.save_ctxt.get_item_data(item);\n-        if let super::Data::ImplData(impl_data) = impl_data {\n-            match impl_data.self_ref {\n-                Some(ref self_ref) => {\n-                    self.fmt.ref_str(recorder::TypeRef,\n-                                     item.span,\n-                                     Some(self_ref.span),\n-                                     self_ref.ref_id,\n-                                     self_ref.scope);\n-                }\n-                None => {\n-                    self.visit_ty(&typ);\n-                }\n-            }\n-            if let Some(ref trait_ref_data) = impl_data.trait_ref {\n+        down_cast_data!(impl_data, ImplData, self, item.span);\n+        match impl_data.self_ref {\n+            Some(ref self_ref) => {\n                 self.fmt.ref_str(recorder::TypeRef,\n                                  item.span,\n-                                 Some(trait_ref_data.span),\n-                                 trait_ref_data.ref_id,\n-                                 trait_ref_data.scope);\n-                visit::walk_path(self, &trait_ref.as_ref().unwrap().path);\n+                                 Some(self_ref.span),\n+                                 self_ref.ref_id,\n+                                 self_ref.scope);\n             }\n-\n-            self.fmt.impl_str(item.span,\n-                              Some(impl_data.span),\n-                              impl_data.id,\n-                              impl_data.self_ref.map(|data| data.ref_id),\n-                              impl_data.trait_ref.map(|data| data.ref_id),\n-                              impl_data.scope);\n-        } else {\n-            self.sess.span_bug(item.span, \"expected ImplData\");\n+            None => {\n+                self.visit_ty(&typ);\n+            }\n+        }\n+        if let Some(ref trait_ref_data) = impl_data.trait_ref {\n+            self.fmt.ref_str(recorder::TypeRef,\n+                             item.span,\n+                             Some(trait_ref_data.span),\n+                             trait_ref_data.ref_id,\n+                             trait_ref_data.scope);\n+            visit::walk_path(self, &trait_ref.as_ref().unwrap().path);\n         }\n \n+        self.fmt.impl_str(item.span,\n+                          Some(impl_data.span),\n+                          impl_data.id,\n+                          impl_data.self_ref.map(|data| data.ref_id),\n+                          impl_data.trait_ref.map(|data| data.ref_id),\n+                          impl_data.scope);\n+\n         self.process_generic_params(type_parameters, item.span, \"\", item.id);\n         for impl_item in impl_items {\n             self.visit_impl_item(impl_item);\n@@ -746,16 +740,13 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n     fn process_mod(&mut self,\n                    item: &ast::Item) {  // The module in question, represented as an item.\n         let mod_data = self.save_ctxt.get_item_data(item);\n-        if let super::Data::ModData(mod_data) = mod_data {\n-            self.fmt.mod_str(item.span,\n-                             Some(mod_data.span),\n-                             mod_data.id,\n-                             &mod_data.qualname,\n-                             mod_data.scope,\n-                             &mod_data.filename);\n-        } else {\n-            self.sess.span_bug(item.span, \"expected ModData\");\n-        }\n+        down_cast_data!(mod_data, ModData, self, item.span);\n+        self.fmt.mod_str(item.span,\n+                         Some(mod_data.span),\n+                         mod_data.id,\n+                         &mod_data.qualname,\n+                         mod_data.scope,\n+                         &mod_data.filename);\n     }\n \n     fn process_path(&mut self,\n@@ -883,16 +874,13 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         self.write_sub_paths_truncated(path, false);\n \n         let struct_lit_data = self.save_ctxt.get_expr_data(ex);\n-        let struct_def = if let super::Data::TypeRefData(struct_lit_data) = struct_lit_data {\n-            self.fmt.ref_str(recorder::TypeRef,\n-                             ex.span,\n-                             Some(struct_lit_data.span),\n-                             struct_lit_data.ref_id,\n-                             struct_lit_data.scope);\n-            struct_lit_data.ref_id\n-        } else {\n-            self.sess.span_bug(ex.span, \"expected TypeRefData\");\n-        };\n+        down_cast_data!(struct_lit_data, TypeRefData, self, ex.span);\n+        self.fmt.ref_str(recorder::TypeRef,\n+                         ex.span,\n+                         Some(struct_lit_data.span),\n+                         struct_lit_data.ref_id,\n+                         struct_lit_data.scope);\n+        let struct_def = struct_lit_data.ref_id;\n \n         for field in fields {\n             if generated_code(field.ident.span) {\n@@ -1269,15 +1257,12 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 self.visit_expr(&sub_ex);\n \n                 let field_data = self.save_ctxt.get_expr_data(ex);\n-                if let super::Data::VariableRefData(field_data) = field_data {\n-                    self.fmt.ref_str(recorder::VarRef,\n-                                     ex.span,\n-                                     Some(field_data.span),\n-                                     field_data.ref_id,\n-                                     field_data.scope);\n-                } else {\n-                    self.sess.span_bug(ex.span, \"expected VariableRefData\");\n-                }\n+                down_cast_data!(field_data, VariableRefData, self, ex.span);\n+                self.fmt.ref_str(recorder::VarRef,\n+                                 ex.span,\n+                                 Some(field_data.span),\n+                                 field_data.ref_id,\n+                                 field_data.scope);\n             },\n             ast::ExprTupField(ref sub_ex, idx) => {\n                 if generated_code(sub_ex.span) {"}, {"sha": "0e5f83842075dd057d227c4d0e3e6259623db0a0", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92d66764121a719d6755a7c33829598d32c9f4ba/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d66764121a719d6755a7c33829598d32c9f4ba/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=92d66764121a719d6755a7c33829598d32c9f4ba", "patch": "@@ -47,6 +47,7 @@ pub struct CrateData {\n \n /// Data for any entity in the Rust language. The actual data contained varied\n /// with the kind of entity being queried. See the nested structs for details.\n+#[derive(Debug)]\n pub enum Data {\n     /// Data for all kinds of functions and methods.\n     FunctionData(FunctionData),\n@@ -67,6 +68,7 @@ pub enum Data {\n }\n \n /// Data for all kinds of functions and methods.\n+#[derive(Debug)]\n pub struct FunctionData {\n     pub id: NodeId,\n     pub name: String,\n@@ -77,6 +79,7 @@ pub struct FunctionData {\n }\n \n /// Data for local and global variables (consts and statics).\n+#[derive(Debug)]\n pub struct VariableData {\n     pub id: NodeId,\n     pub name: String,\n@@ -88,6 +91,7 @@ pub struct VariableData {\n }\n \n /// Data for modules.\n+#[derive(Debug)]\n pub struct ModData {\n     pub id: NodeId,\n     pub name: String,\n@@ -98,6 +102,7 @@ pub struct ModData {\n }\n \n /// Data for enum declarations.\n+#[derive(Debug)]\n pub struct EnumData {\n     pub id: NodeId,\n     pub value: String,\n@@ -106,6 +111,7 @@ pub struct EnumData {\n     pub scope: NodeId,\n }\n \n+#[derive(Debug)]\n pub struct ImplData {\n     pub id: NodeId,\n     pub span: Span,\n@@ -119,6 +125,7 @@ pub struct ImplData {\n \n /// Data for the use of some item (e.g., the use of a local variable, which\n /// will refere to that variables declaration (by ref_id)).\n+#[derive(Debug)]\n pub struct VariableRefData {\n     pub name: String,\n     pub span: Span,\n@@ -127,6 +134,7 @@ pub struct VariableRefData {\n }\n \n /// Data for a reference to a type or trait.\n+#[derive(Debug)]\n pub struct TypeRefData {\n     pub span: Span,\n     pub scope: NodeId,"}]}