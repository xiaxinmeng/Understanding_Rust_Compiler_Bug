{"sha": "c8422403f775126c40d558838d321c063554c822", "node_id": "C_kwDOAAsO6NoAKGM4NDIyNDAzZjc3NTEyNmM0MGQ1NTg4MzhkMzIxYzA2MzU1NGM4MjI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-16T09:19:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-16T09:19:26Z"}, "message": "Auto merge of #96108 - Dylan-DPC:rollup-t5f2fc9, r=Dylan-DPC\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #93969 (Only add codegen backend to dep info if -Zbinary-dep-depinfo is used)\n - #94605 (Add missing links in platform support docs)\n - #95372 (make unaligned_references lint deny-by-default)\n - #95859 (Improve diagnostics for unterminated nested block comment)\n - #95961 (implement SIMD gather/scatter via vector getelementptr)\n - #96004 (Consider lifetimes when comparing types for equality in MIR validator)\n - #96050 (Remove some now-dead code that was only relevant before deaggregation.)\n - #96070 ([test] Add test cases for untested functions for BTreeMap)\n - #96099 (MaybeUninit array cleanup)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "931c38fb5db853c1a2bbb0d0fa585a533df76b9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/931c38fb5db853c1a2bbb0d0fa585a533df76b9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8422403f775126c40d558838d321c063554c822", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8422403f775126c40d558838d321c063554c822", "html_url": "https://github.com/rust-lang/rust/commit/c8422403f775126c40d558838d321c063554c822", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8422403f775126c40d558838d321c063554c822/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07bb916d44a66d2caba427c7ee132bbeb245977b", "url": "https://api.github.com/repos/rust-lang/rust/commits/07bb916d44a66d2caba427c7ee132bbeb245977b", "html_url": "https://github.com/rust-lang/rust/commit/07bb916d44a66d2caba427c7ee132bbeb245977b"}, {"sha": "f559cf98b5db32942ec9be050fecf58538910648", "url": "https://api.github.com/repos/rust-lang/rust/commits/f559cf98b5db32942ec9be050fecf58538910648", "html_url": "https://github.com/rust-lang/rust/commit/f559cf98b5db32942ec9be050fecf58538910648"}], "stats": {"total": 889, "additions": 797, "deletions": 92}, "files": [{"sha": "cf9cf1b70aaa7b4f672cc973b13554fe3f84ba0d", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -1839,6 +1839,27 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n         simd_neg: Int => neg, Float => fneg;\n     }\n \n+    if name == sym::simd_arith_offset {\n+        // This also checks that the first operand is a ptr type.\n+        let pointee = in_elem.builtin_deref(true).unwrap_or_else(|| {\n+            span_bug!(span, \"must be called with a vector of pointer types as first argument\")\n+        });\n+        let layout = bx.layout_of(pointee.ty);\n+        let ptrs = args[0].immediate();\n+        // The second argument must be a ptr-sized integer.\n+        // (We don't care about the signedness, this is wrapping anyway.)\n+        let (_offsets_len, offsets_elem) = arg_tys[1].simd_size_and_type(bx.tcx());\n+        if !matches!(offsets_elem.kind(), ty::Int(ty::IntTy::Isize) | ty::Uint(ty::UintTy::Usize)) {\n+            span_bug!(\n+                span,\n+                \"must be called with a vector of pointer-sized integers as second argument\"\n+            );\n+        }\n+        let offsets = args[1].immediate();\n+\n+        return Ok(bx.gep(bx.backend_type(layout), ptrs, &[offsets]));\n+    }\n+\n     if name == sym::simd_saturating_add || name == sym::simd_saturating_sub {\n         let lhs = args[0].immediate();\n         let rhs = args[1].immediate();"}, {"sha": "e6dfdf54a32d136c7dbf70edb52ba4c9bbeb9ab3", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -196,27 +196,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.write_immediate(*val, &dest)?;\n             }\n \n-            Aggregate(ref kind, ref operands) => {\n-                // active_field_index is for union initialization.\n-                let (dest, active_field_index) = match **kind {\n-                    mir::AggregateKind::Adt(adt_did, variant_index, _, _, active_field_index) => {\n-                        self.write_discriminant(variant_index, &dest)?;\n-                        if self.tcx.adt_def(adt_did).is_enum() {\n-                            assert!(active_field_index.is_none());\n-                            (self.place_downcast(&dest, variant_index)?, None)\n-                        } else {\n-                            if active_field_index.is_some() {\n-                                assert_eq!(operands.len(), 1);\n-                            }\n-                            (dest, active_field_index)\n-                        }\n-                    }\n-                    _ => (dest, None),\n-                };\n+            Aggregate(box ref kind, ref operands) => {\n+                assert!(matches!(kind, mir::AggregateKind::Array(..)));\n \n-                for (i, operand) in operands.iter().enumerate() {\n+                for (field_index, operand) in operands.iter().enumerate() {\n                     let op = self.eval_operand(operand, None)?;\n-                    let field_index = active_field_index.unwrap_or(i);\n                     let field_dest = self.place_field(&dest, field_index)?;\n                     self.copy_op(&op, &field_dest)?;\n                 }"}, {"sha": "79d427ccc4469c08ef9e82d908063f5c6efca281", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -315,9 +315,8 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                                     | ty::FnPtr(..)\n                             )\n                         }\n-                        // None of the possible types have lifetimes, so we can just compare\n-                        // directly\n-                        if a != b {\n+                        // The function pointer types can have lifetimes\n+                        if !self.mir_assign_valid_types(a, b) {\n                             self.fail(\n                                 location,\n                                 format!(\"Cannot compare unequal types {:?} and {:?}\", a, b),\n@@ -464,7 +463,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 };\n                 // since CopyNonOverlapping is parametrized by 1 type,\n                 // we only need to check that they are equal and not keep an extra parameter.\n-                if op_src_ty != op_dst_ty {\n+                if !self.mir_assign_valid_types(op_src_ty, op_dst_ty) {\n                     self.fail(location, format!(\"bad arg ({:?} != {:?})\", op_src_ty, op_dst_ty));\n                 }\n "}, {"sha": "98d4870e6454efb9214f33c17eec69fc99ae2bea", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -27,7 +27,6 @@\n #![feature(thread_id_value)]\n #![feature(vec_into_raw_parts)]\n #![allow(rustc::default_hash_types)]\n-#![deny(unaligned_references)]\n #![allow(rustc::potential_query_instability)]\n \n #[macro_use]"}, {"sha": "08987dff660a4d78391280df384aa6a6430375f7", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -629,11 +629,15 @@ fn write_out_deps(\n         });\n         files.extend(extra_tracked_files);\n \n-        if let Some(ref backend) = sess.opts.debugging_opts.codegen_backend {\n-            files.push(backend.to_string());\n-        }\n-\n         if sess.binary_dep_depinfo() {\n+            if let Some(ref backend) = sess.opts.debugging_opts.codegen_backend {\n+                if backend.contains('.') {\n+                    // If the backend name contain a `.`, it is the path to an external dynamic\n+                    // library. If not, it is not a path.\n+                    files.push(backend.to_string());\n+                }\n+            }\n+\n             boxed_resolver.borrow_mut().access(|resolver| {\n                 for cnum in resolver.cstore().crates_untracked() {\n                     let source = resolver.cstore().crate_source_untracked(cnum);"}, {"sha": "a42e3d5d9578502a216ce6624e676498139ac99c", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -1110,8 +1110,6 @@ declare_lint! {\n     /// ### Example\n     ///\n     /// ```rust,compile_fail\n-    /// #![deny(unaligned_references)]\n-    ///\n     /// #[repr(packed)]\n     /// pub struct Foo {\n     ///     field1: u64,\n@@ -1139,10 +1137,11 @@ declare_lint! {\n     /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n     /// [issue #82523]: https://github.com/rust-lang/rust/issues/82523\n     pub UNALIGNED_REFERENCES,\n-    Warn,\n+    Deny,\n     \"detects unaligned references to fields of packed structs\",\n     @future_incompatible = FutureIncompatibleInfo {\n         reference: \"issue #82523 <https://github.com/rust-lang/rust/issues/82523>\",\n+        reason: FutureIncompatibilityReason::FutureReleaseErrorReportNow,\n     };\n     report_in_external_macro\n }"}, {"sha": "49769b7ae3d89cdbf58dfb875d8e0eda79cbb882", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -2518,7 +2518,8 @@ pub enum Rvalue<'tcx> {\n     /// * `Offset` has the same semantics as [`offset`](pointer::offset), except that the second\n     ///   parameter may be a `usize` as well.\n     /// * The comparison operations accept `bool`s, `char`s, signed or unsigned integers, floats,\n-    ///   raw pointers, or function pointers of matching types and return a `bool`.\n+    ///   raw pointers, or function pointers and return a `bool`. The types of the operands must be\n+    ///   matching, up to the usual caveat of the lifetimes in function pointers.\n     /// * Left and right shift operations accept signed or unsigned integers not necessarily of the\n     ///   same type and return a value of the same type as their LHS. Like in Rust, the RHS is\n     ///   truncated as needed."}, {"sha": "bfa13ce79bab47c99c376d857ea671ffbbb90d3c", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 50, "deletions": 10, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -182,16 +182,7 @@ impl<'a> StringReader<'a> {\n             }\n             rustc_lexer::TokenKind::BlockComment { doc_style, terminated } => {\n                 if !terminated {\n-                    let msg = match doc_style {\n-                        Some(_) => \"unterminated block doc-comment\",\n-                        None => \"unterminated block comment\",\n-                    };\n-                    let last_bpos = self.pos;\n-                    self.sess.span_diagnostic.span_fatal_with_code(\n-                        self.mk_sp(start, last_bpos),\n-                        msg,\n-                        error_code!(E0758),\n-                    );\n+                    self.report_unterminated_block_comment(start, doc_style);\n                 }\n \n                 // Skip non-doc comments\n@@ -553,6 +544,55 @@ impl<'a> StringReader<'a> {\n         err.emit()\n     }\n \n+    fn report_unterminated_block_comment(&self, start: BytePos, doc_style: Option<DocStyle>) {\n+        let msg = match doc_style {\n+            Some(_) => \"unterminated block doc-comment\",\n+            None => \"unterminated block comment\",\n+        };\n+        let last_bpos = self.pos;\n+        let mut err = self.sess.span_diagnostic.struct_span_fatal_with_code(\n+            self.mk_sp(start, last_bpos),\n+            msg,\n+            error_code!(E0758),\n+        );\n+        let mut nested_block_comment_open_idxs = vec![];\n+        let mut last_nested_block_comment_idxs = None;\n+        let mut content_chars = self.str_from(start).char_indices().peekable();\n+\n+        while let Some((idx, current_char)) = content_chars.next() {\n+            match content_chars.peek() {\n+                Some((_, '*')) if current_char == '/' => {\n+                    nested_block_comment_open_idxs.push(idx);\n+                }\n+                Some((_, '/')) if current_char == '*' => {\n+                    last_nested_block_comment_idxs =\n+                        nested_block_comment_open_idxs.pop().map(|open_idx| (open_idx, idx));\n+                }\n+                _ => {}\n+            };\n+        }\n+\n+        if let Some((nested_open_idx, nested_close_idx)) = last_nested_block_comment_idxs {\n+            err.span_label(self.mk_sp(start, start + BytePos(2)), msg)\n+                .span_label(\n+                    self.mk_sp(\n+                        start + BytePos(nested_open_idx as u32),\n+                        start + BytePos(nested_open_idx as u32 + 2),\n+                    ),\n+                    \"...as last nested comment starts here, maybe you want to close this instead?\",\n+                )\n+                .span_label(\n+                    self.mk_sp(\n+                        start + BytePos(nested_close_idx as u32),\n+                        start + BytePos(nested_close_idx as u32 + 2),\n+                    ),\n+                    \"...and last nested comment terminates here.\",\n+                );\n+        }\n+\n+        err.emit();\n+    }\n+\n     // RFC 3101 introduced the idea of (reserved) prefixes. As of Rust 2021,\n     // using a (unknown) prefix is an error. In earlier editions, however, they\n     // only result in a (allowed by default) lint, and are treated as regular"}, {"sha": "d9bada295894f314be2b5c90268a155a19a0c3b7", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -1247,6 +1247,7 @@ symbols! {\n         simd,\n         simd_add,\n         simd_and,\n+        simd_arith_offset,\n         simd_as,\n         simd_bitmask,\n         simd_cast,"}, {"sha": "0dd8ee88ca2ad772b67b5500d84f20a4ec015aeb", "filename": "compiler/rustc_typeck/src/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -437,6 +437,7 @@ pub fn check_platform_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>)\n         | sym::simd_fpow\n         | sym::simd_saturating_add\n         | sym::simd_saturating_sub => (1, vec![param(0), param(0)], param(0)),\n+        sym::simd_arith_offset => (2, vec![param(0), param(1)], param(0)),\n         sym::simd_neg\n         | sym::simd_fsqrt\n         | sym::simd_fsin"}, {"sha": "47ba1777ae90327e6ead8404c4508a33332d7210", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -1878,6 +1878,96 @@ fn test_first_last_entry() {\n     a.check();\n }\n \n+#[test]\n+fn test_pop_first_last() {\n+    let mut map = BTreeMap::new();\n+    assert_eq!(map.pop_first(), None);\n+    assert_eq!(map.pop_last(), None);\n+\n+    map.insert(1, 10);\n+    map.insert(2, 20);\n+    map.insert(3, 30);\n+    map.insert(4, 40);\n+\n+    assert_eq!(map.len(), 4);\n+\n+    let (key, val) = map.pop_first().unwrap();\n+    assert_eq!(key, 1);\n+    assert_eq!(val, 10);\n+    assert_eq!(map.len(), 3);\n+\n+    let (key, val) = map.pop_first().unwrap();\n+    assert_eq!(key, 2);\n+    assert_eq!(val, 20);\n+    assert_eq!(map.len(), 2);\n+    let (key, val) = map.pop_last().unwrap();\n+    assert_eq!(key, 4);\n+    assert_eq!(val, 40);\n+    assert_eq!(map.len(), 1);\n+\n+    map.insert(5, 50);\n+    map.insert(6, 60);\n+    assert_eq!(map.len(), 3);\n+\n+    let (key, val) = map.pop_first().unwrap();\n+    assert_eq!(key, 3);\n+    assert_eq!(val, 30);\n+    assert_eq!(map.len(), 2);\n+\n+    let (key, val) = map.pop_last().unwrap();\n+    assert_eq!(key, 6);\n+    assert_eq!(val, 60);\n+    assert_eq!(map.len(), 1);\n+\n+    let (key, val) = map.pop_last().unwrap();\n+    assert_eq!(key, 5);\n+    assert_eq!(val, 50);\n+    assert_eq!(map.len(), 0);\n+\n+    assert_eq!(map.pop_first(), None);\n+    assert_eq!(map.pop_last(), None);\n+\n+    map.insert(7, 70);\n+    map.insert(8, 80);\n+\n+    let (key, val) = map.pop_last().unwrap();\n+    assert_eq!(key, 8);\n+    assert_eq!(val, 80);\n+    assert_eq!(map.len(), 1);\n+\n+    let (key, val) = map.pop_last().unwrap();\n+    assert_eq!(key, 7);\n+    assert_eq!(val, 70);\n+    assert_eq!(map.len(), 0);\n+\n+    assert_eq!(map.pop_first(), None);\n+    assert_eq!(map.pop_last(), None);\n+}\n+\n+#[test]\n+fn test_get_key_value() {\n+    let mut map = BTreeMap::new();\n+\n+    assert!(map.is_empty());\n+    assert_eq!(map.get_key_value(&1), None);\n+    assert_eq!(map.get_key_value(&2), None);\n+\n+    map.insert(1, 10);\n+    map.insert(2, 20);\n+    map.insert(3, 30);\n+\n+    assert_eq!(map.len(), 3);\n+    assert_eq!(map.get_key_value(&1), Some((&1, &10)));\n+    assert_eq!(map.get_key_value(&3), Some((&3, &30)));\n+    assert_eq!(map.get_key_value(&4), None);\n+\n+    map.remove(&3);\n+\n+    assert_eq!(map.len(), 2);\n+    assert_eq!(map.get_key_value(&3), None);\n+    assert_eq!(map.get_key_value(&2), Some((&2, &20)));\n+}\n+\n #[test]\n fn test_insert_into_full_height_0() {\n     let size = node::CAPACITY;\n@@ -1904,6 +1994,21 @@ fn test_insert_into_full_height_1() {\n     }\n }\n \n+#[test]\n+fn test_try_insert() {\n+    let mut map = BTreeMap::new();\n+\n+    assert!(map.is_empty());\n+\n+    assert_eq!(map.try_insert(1, 10).unwrap(), &10);\n+    assert_eq!(map.try_insert(2, 20).unwrap(), &20);\n+\n+    let err = map.try_insert(2, 200).unwrap_err();\n+    assert_eq!(err.entry.key(), &2);\n+    assert_eq!(err.entry.get(), &20);\n+    assert_eq!(err.value, 200);\n+}\n+\n macro_rules! create_append_test {\n     ($name:ident, $len:expr) => {\n         #[test]"}, {"sha": "dafd07b161785f87c2fff70e2b9aa6c258b8e8ba", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -117,6 +117,7 @@\n #![feature(const_intrinsic_copy)]\n #![feature(const_intrinsic_forget)]\n #![feature(const_likely)]\n+#![feature(const_maybe_uninit_uninit_array)]\n #![feature(const_maybe_uninit_as_mut_ptr)]\n #![feature(const_maybe_uninit_assume_init)]\n #![feature(const_num_from_num)]"}, {"sha": "cac7f435573a52500efb05f678a6fceda527ff5b", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -350,13 +350,13 @@ impl<T> MaybeUninit<T> {\n     /// let mut buf: [MaybeUninit<u8>; 32] = MaybeUninit::uninit_array();\n     /// let data = read(&mut buf);\n     /// ```\n-    #[unstable(feature = \"maybe_uninit_uninit_array\", issue = \"none\")]\n-    #[rustc_const_unstable(feature = \"maybe_uninit_uninit_array\", issue = \"none\")]\n+    #[unstable(feature = \"maybe_uninit_uninit_array\", issue = \"96097\")]\n+    #[rustc_const_unstable(feature = \"const_maybe_uninit_uninit_array\", issue = \"96097\")]\n     #[must_use]\n     #[inline(always)]\n-    pub const fn uninit_array<const LEN: usize>() -> [Self; LEN] {\n+    pub const fn uninit_array<const N: usize>() -> [Self; N] {\n         // SAFETY: An uninitialized `[MaybeUninit<_>; LEN]` is valid.\n-        unsafe { MaybeUninit::<[MaybeUninit<T>; LEN]>::uninit().assume_init() }\n+        unsafe { MaybeUninit::<[MaybeUninit<T>; N]>::uninit().assume_init() }\n     }\n \n     /// Creates a new `MaybeUninit<T>` in an uninitialized state, with the memory being\n@@ -942,19 +942,24 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// assert_eq!(array, [0, 1, 2]);\n     /// ```\n-    #[unstable(feature = \"maybe_uninit_array_assume_init\", issue = \"80908\")]\n+    #[unstable(feature = \"maybe_uninit_array_assume_init\", issue = \"96097\")]\n+    #[rustc_const_unstable(feature = \"const_maybe_uninit_array_assume_init\", issue = \"96097\")]\n     #[inline(always)]\n     #[track_caller]\n-    pub unsafe fn array_assume_init<const N: usize>(array: [Self; N]) -> [T; N] {\n+    pub const unsafe fn array_assume_init<const N: usize>(array: [Self; N]) -> [T; N] {\n         // SAFETY:\n         // * The caller guarantees that all elements of the array are initialized\n         // * `MaybeUninit<T>` and T are guaranteed to have the same layout\n         // * `MaybeUninit` does not drop, so there are no double-frees\n         // And thus the conversion is safe\n-        unsafe {\n+        let ret = unsafe {\n             intrinsics::assert_inhabited::<[T; N]>();\n             (&array as *const _ as *const [T; N]).read()\n-        }\n+        };\n+\n+        // FIXME: required to avoid `~const Destruct` bound\n+        super::forget(array);\n+        ret\n     }\n \n     /// Assuming all the elements are initialized, get a slice to them."}, {"sha": "82508c6882daba5340e2be67bd87d84b6c2a363c", "filename": "library/portable-simd/crates/core_simd/src/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -61,6 +61,10 @@ extern \"platform-intrinsic\" {\n     /// xor\n     pub(crate) fn simd_xor<T>(x: T, y: T) -> T;\n \n+    /// getelementptr (without inbounds)\n+    #[cfg(not(bootstrap))]\n+    pub(crate) fn simd_arith_offset<T, U>(ptrs: T, offsets: U) -> T;\n+\n     /// fptoui/fptosi/uitofp/sitofp\n     /// casting floats to integers is truncating, so it is safe to convert values like e.g. 1.5\n     /// but the truncated value must fit in the target type or the result is poison."}, {"sha": "68a9c67f795af984749230c2934564cee15bfe16", "filename": "library/portable-simd/crates/core_simd/src/vector/ptr.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -1,5 +1,8 @@\n //! Private implementation details of public gather/scatter APIs.\n+#[cfg(not(bootstrap))]\n+use crate::simd::intrinsics;\n use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n+#[cfg(bootstrap)]\n use core::mem;\n \n /// A vector of *const T.\n@@ -21,12 +24,16 @@ where\n     #[inline]\n     #[must_use]\n     pub fn wrapping_add(self, addend: Simd<usize, LANES>) -> Self {\n+        #[cfg(bootstrap)]\n         // Safety: converting pointers to usize and vice-versa is safe\n         // (even if using that pointer is not)\n         unsafe {\n             let x: Simd<usize, LANES> = mem::transmute_copy(&self);\n             mem::transmute_copy(&{ x + (addend * Simd::splat(mem::size_of::<T>())) })\n         }\n+        #[cfg(not(bootstrap))]\n+        // Safety: this intrinsic doesn't have a precondition\n+        unsafe { intrinsics::simd_arith_offset(self, addend) }\n     }\n }\n \n@@ -49,11 +56,15 @@ where\n     #[inline]\n     #[must_use]\n     pub fn wrapping_add(self, addend: Simd<usize, LANES>) -> Self {\n+        #[cfg(bootstrap)]\n         // Safety: converting pointers to usize and vice-versa is safe\n         // (even if using that pointer is not)\n         unsafe {\n             let x: Simd<usize, LANES> = mem::transmute_copy(&self);\n             mem::transmute_copy(&{ x + (addend * Simd::splat(mem::size_of::<T>())) })\n         }\n+        #[cfg(not(bootstrap))]\n+        // Safety: this intrinsic doesn't have a precondition\n+        unsafe { intrinsics::simd_arith_offset(self, addend) }\n     }\n }"}, {"sha": "952d8ef48fe57d15cb61e613aa3cad12e802b88b", "filename": "src/doc/rustc/src/SUMMARY.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -15,12 +15,15 @@\n - [Platform Support](platform-support.md)\n     - [Template for target-specific documentation](platform-support/TEMPLATE.md)\n     - [aarch64-apple-ios-sim](platform-support/aarch64-apple-ios-sim.md)\n+    - [aarch64-unknown-none-hermitkernel](platform-support/aarch64-unknown-none-hermitkernel.md)\n     - [armv7-unknown-linux-uclibceabi](platform-support/armv7-unknown-linux-uclibceabi.md)\n     - [armv7-unknown-linux-uclibceabihf](platform-support/armv7-unknown-linux-uclibceabihf.md)\n     - [\\*-kmc-solid_\\*](platform-support/kmc-solid.md)\n+    - [m68k-unknown-linux-gnu](platform-support/m68k-unknown-linux-gnu.md)\n+    - [mips64-openwrt-linux-musl](platform-support/mips64-openwrt-linux-musl.md)\n     - [*-unknown-openbsd](platform-support/openbsd.md)\n-    - [x86_64-unknown-none](platform-support/x86_64-unknown-none.md)\n     - [wasm64-unknown-unknown](platform-support/wasm64-unknown-unknown.md)\n+    - [x86_64-unknown-none](platform-support/x86_64-unknown-none.md)\n - [Target Tier Policy](target-tier-policy.md)\n - [Targets](targets/index.md)\n     - [Built-in Targets](targets/built-in.md)"}, {"sha": "12ac575210aa3df68522649f598ec1be30253273", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -248,9 +248,9 @@ target | std | host | notes\n `i686-uwp-windows-gnu` | ? |  |\n `i686-uwp-windows-msvc` | ? |  |\n `i686-wrs-vxworks` | ? |  |\n-`m68k-unknown-linux-gnu` | ? |  | Motorola 680x0 Linux\n+[`m68k-unknown-linux-gnu`](platform-support/m68k-unknown-linux-gnu.md) | ? |  | Motorola 680x0 Linux\n `mips-unknown-linux-uclibc` | \u2713 |  | MIPS Linux with uClibc\n-`mips64-openwrt-linux-musl` | ? |  | MIPS64 for OpenWrt Linux MUSL\n+[`mips64-openwrt-linux-musl`](platform-support/mips64-openwrt-linux-musl.md) | ? |  | MIPS64 for OpenWrt Linux MUSL\n `mipsel-sony-psp` | * |  | MIPS (LE) Sony PlayStation Portable (PSP)\n `mipsel-unknown-linux-uclibc` | \u2713 |  | MIPS (LE) Linux with uClibc\n `mipsel-unknown-none` | * |  | Bare MIPS (LE) softfloat"}, {"sha": "a858270d4e76dffad3d028fd9fcc977078e86bc0", "filename": "src/test/codegen/simd_arith_offset.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fcodegen%2Fsimd_arith_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fcodegen%2Fsimd_arith_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd_arith_offset.rs?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -0,0 +1,26 @@\n+// compile-flags: -C no-prepopulate-passes\n+// only-64bit (because the LLVM type of i64 for usize shows up)\n+//\n+\n+#![crate_type = \"lib\"]\n+#![feature(repr_simd, platform_intrinsics)]\n+\n+extern \"platform-intrinsic\" {\n+    pub(crate) fn simd_arith_offset<T, U>(ptrs: T, offsets: U) -> T;\n+}\n+\n+/// A vector of *const T.\n+#[derive(Debug, Copy, Clone)]\n+#[repr(simd)]\n+pub struct SimdConstPtr<T, const LANES: usize>([*const T; LANES]);\n+\n+#[derive(Debug, Copy, Clone)]\n+#[repr(simd)]\n+pub struct Simd<T, const LANES: usize>([T; LANES]);\n+\n+// CHECK-LABEL: smoke\n+#[no_mangle]\n+pub fn smoke(ptrs: SimdConstPtr<u8, 8>, offsets: Simd<usize, 8>) -> SimdConstPtr<u8, 8> {\n+    // CHECK: getelementptr i8, <8 x i8*> %_3, <8 x i64> %_4\n+    unsafe { simd_arith_offset(ptrs, offsets) }\n+}"}, {"sha": "4cda243ffb5a3d255dcea63e345650b42d861f89", "filename": "src/test/run-make-fulldeps/hotplug_codegen_backend/Makefile", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2FMakefile?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -2,10 +2,25 @@ include ../tools.mk\n \n # ignore-stage1\n \n+# This test both exists as a check that -Zcodegen-backend is capable of loading external codegen\n+# backends and that this external codegen backend is only included in the dep info if\n+# -Zbinary-dep-depinfo is used.\n+\n all:\n \t/bin/echo || exit 0 # This test requires /bin/echo to exist\n \t$(RUSTC) the_backend.rs --crate-name the_backend --crate-type dylib \\\n \t\t-o $(TMPDIR)/the_backend.dylib\n+\n+\t$(RUSTC) some_crate.rs --crate-name some_crate --crate-type lib -o $(TMPDIR)/some_crate \\\n+\t\t-Z codegen-backend=$(TMPDIR)/the_backend.dylib -Z unstable-options \\\n+\t\t--emit link,dep-info\n+\tgrep -x \"This has been \\\"compiled\\\" successfully.\" $(TMPDIR)/libsome_crate.rlib\n+\t# don't declare a dependency on the codegen backend if -Zbinary-dep-depinfo isn't used.\n+\tgrep -v \"the_backend.dylib\" $(TMPDIR)/some_crate.d\n+\t\n \t$(RUSTC) some_crate.rs --crate-name some_crate --crate-type lib -o $(TMPDIR)/some_crate \\\n-\t\t-Z codegen-backend=$(TMPDIR)/the_backend.dylib -Z unstable-options\n-\tgrep -x \"This has been \\\"compiled\\\" successfully.\" $(TMPDIR)/some_crate\n+\t\t-Z codegen-backend=$(TMPDIR)/the_backend.dylib -Z unstable-options \\\n+\t\t--emit link,dep-info -Zbinary-dep-depinfo\n+\tgrep -x \"This has been \\\"compiled\\\" successfully.\" $(TMPDIR)/libsome_crate.rlib\n+\t# but declare a dependency on the codegen backend if -Zbinary-dep-depinfo it used.\n+\tgrep \"the_backend.dylib\" $(TMPDIR)/some_crate.d"}, {"sha": "5042ad024afff00bfabc1e48272c2a46e15c4dcf", "filename": "src/test/ui/binding/issue-53114-safety-checks.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Fbinding%2Fissue-53114-safety-checks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Fbinding%2Fissue-53114-safety-checks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinding%2Fissue-53114-safety-checks.rs?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -20,13 +20,13 @@ fn let_wild_gets_unsafe_field() {\n     let u1 = U { a: I(0) };\n     let u2 = U { a: I(1) };\n     let p = P { a: &2, b: &3 };\n-    let _ = &p.b;  //~ WARN    reference to packed field\n+    let _ = &p.b;  //~ ERROR    reference to packed field\n     //~^  WARN will become a hard error\n     let _ = u1.a;  // #53114: should eventually signal error as well\n     let _ = &u2.a; //~ ERROR  [E0133]\n \n     // variation on above with `_` in substructure\n-    let (_,) = (&p.b,);  //~ WARN     reference to packed field\n+    let (_,) = (&p.b,);  //~ ERROR     reference to packed field\n     //~^  WARN will become a hard error\n     let (_,) = (u1.a,);  //~ ERROR   [E0133]\n     let (_,) = (&u2.a,); //~ ERROR   [E0133]\n@@ -36,13 +36,13 @@ fn match_unsafe_field_to_wild() {\n     let u1 = U { a: I(0) };\n     let u2 = U { a: I(1) };\n     let p = P { a: &2, b: &3 };\n-    match &p.b  { _ => { } } //~ WARN     reference to packed field\n+    match &p.b  { _ => { } } //~ ERROR     reference to packed field\n     //~^  WARN will become a hard error\n     match u1.a  { _ => { } } //~ ERROR   [E0133]\n     match &u2.a { _ => { } } //~ ERROR   [E0133]\n \n     // variation on above with `_` in substructure\n-    match (&p.b,)  { (_,) => { } } //~ WARN     reference to packed field\n+    match (&p.b,)  { (_,) => { } } //~ ERROR     reference to packed field\n     //~^  WARN will become a hard error\n     match (u1.a,)  { (_,) => { } } //~ ERROR   [E0133]\n     match (&u2.a,) { (_,) => { } } //~ ERROR   [E0133]"}, {"sha": "f3840273cfaf7ae4a4c4ad25eb414002649aa827", "filename": "src/test/ui/binding/issue-53114-safety-checks.stderr", "status": "modified", "additions": 58, "deletions": 6, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Fbinding%2Fissue-53114-safety-checks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Fbinding%2Fissue-53114-safety-checks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinding%2Fissue-53114-safety-checks.stderr?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -1,16 +1,16 @@\n-warning: reference to packed field is unaligned\n+error: reference to packed field is unaligned\n   --> $DIR/issue-53114-safety-checks.rs:23:13\n    |\n LL |     let _ = &p.b;\n    |             ^^^^\n    |\n-   = note: `#[warn(unaligned_references)]` on by default\n+   = note: `#[deny(unaligned_references)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n    = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n-warning: reference to packed field is unaligned\n+error: reference to packed field is unaligned\n   --> $DIR/issue-53114-safety-checks.rs:29:17\n    |\n LL |     let (_,) = (&p.b,);\n@@ -21,7 +21,7 @@ LL |     let (_,) = (&p.b,);\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n    = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n-warning: reference to packed field is unaligned\n+error: reference to packed field is unaligned\n   --> $DIR/issue-53114-safety-checks.rs:39:11\n    |\n LL |     match &p.b  { _ => { } }\n@@ -32,7 +32,7 @@ LL |     match &p.b  { _ => { } }\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n    = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n-warning: reference to packed field is unaligned\n+error: reference to packed field is unaligned\n   --> $DIR/issue-53114-safety-checks.rs:45:12\n    |\n LL |     match (&p.b,)  { (_,) => { } }\n@@ -99,6 +99,58 @@ LL |     match (&u2.a,) { (_,) => { } }\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n-error: aborting due to 7 previous errors; 4 warnings emitted\n+error: aborting due to 11 previous errors\n \n For more information about this error, try `rustc --explain E0133`.\n+Future incompatibility report: Future breakage diagnostic:\n+error: reference to packed field is unaligned\n+  --> $DIR/issue-53114-safety-checks.rs:23:13\n+   |\n+LL |     let _ = &p.b;\n+   |             ^^^^\n+   |\n+   = note: `#[deny(unaligned_references)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+\n+Future breakage diagnostic:\n+error: reference to packed field is unaligned\n+  --> $DIR/issue-53114-safety-checks.rs:29:17\n+   |\n+LL |     let (_,) = (&p.b,);\n+   |                 ^^^^\n+   |\n+   = note: `#[deny(unaligned_references)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+\n+Future breakage diagnostic:\n+error: reference to packed field is unaligned\n+  --> $DIR/issue-53114-safety-checks.rs:39:11\n+   |\n+LL |     match &p.b  { _ => { } }\n+   |           ^^^^\n+   |\n+   = note: `#[deny(unaligned_references)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+\n+Future breakage diagnostic:\n+error: reference to packed field is unaligned\n+  --> $DIR/issue-53114-safety-checks.rs:45:12\n+   |\n+LL |     match (&p.b,)  { (_,) => { } }\n+   |            ^^^^\n+   |\n+   = note: `#[deny(unaligned_references)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+"}, {"sha": "1488f329648bb1c4149862a93d0bd288a79be357", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/repr_packed.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Frepr_packed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Frepr_packed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Frepr_packed.rs?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -1,7 +1,5 @@\n // edition:2021\n \n-// check-pass\n-\n // Given how the closure desugaring is implemented (at least at the time of writing this test),\n // we don't need to truncate the captured path to a reference into a packed-struct if the field\n // being referenced will be moved into the closure, since it's safe to move out a field from a\n@@ -11,9 +9,8 @@\n // inlined we will truncate the capture to access just the struct regardless of if the field\n // might get moved into the closure.\n //\n-// It is possible for someone to try writing the code that relies on the desugaring to access a ref\n-// into a packed-struct without explicity using unsafe. Here we test that the compiler warns the\n-// user that such an access is still unsafe.\n+// It is possible for someone to try writing the code that relies on the desugaring to create a ref\n+// into a packed-struct. Here we test that the compiler still detects that case.\n fn test_missing_unsafe_warning_on_repr_packed() {\n     #[repr(packed)]\n     struct Foo { x: String }\n@@ -22,7 +19,7 @@ fn test_missing_unsafe_warning_on_repr_packed() {\n \n     let c = || {\n         println!(\"{}\", foo.x);\n-        //~^ WARNING: reference to packed field is unaligned\n+        //~^ ERROR: reference to packed field is unaligned\n         //~| WARNING: this was previously accepted by the compiler but is being phased out\n         let _z = foo.x;\n     };"}, {"sha": "8629837ba8d344ea0520ff44ffa375260581fd58", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/repr_packed.stderr", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Frepr_packed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Frepr_packed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Frepr_packed.stderr?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -1,15 +1,29 @@\n-warning: reference to packed field is unaligned\n-  --> $DIR/repr_packed.rs:24:24\n+error: reference to packed field is unaligned\n+  --> $DIR/repr_packed.rs:21:24\n    |\n LL |         println!(\"{}\", foo.x);\n    |                        ^^^^^\n    |\n-   = note: `#[warn(unaligned_references)]` on by default\n+   = note: `#[deny(unaligned_references)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n    = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n-   = note: this warning originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-warning: 1 warning emitted\n+error: aborting due to previous error\n+\n+Future incompatibility report: Future breakage diagnostic:\n+error: reference to packed field is unaligned\n+  --> $DIR/repr_packed.rs:21:24\n+   |\n+LL |         println!(\"{}\", foo.x);\n+   |                        ^^^^^\n+   |\n+   = note: `#[deny(unaligned_references)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+   = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)\n "}, {"sha": "1002b359f60bacaee5d0a4658e05c307e695ebcd", "filename": "src/test/ui/derives/deriving-with-repr-packed.stderr", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -45,3 +45,67 @@ LL | #[derive(PartialEq)]\n \n error: aborting due to 4 previous errors\n \n+Future incompatibility report: Future breakage diagnostic:\n+error: `#[derive]` can't be used on a `#[repr(packed)]` struct with type or const parameters (error E0133)\n+  --> $DIR/deriving-with-repr-packed.rs:8:16\n+   |\n+LL | #[derive(Copy, Clone, PartialEq, Eq)]\n+   |                ^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/deriving-with-repr-packed.rs:1:9\n+   |\n+LL | #![deny(unaligned_references)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+Future breakage diagnostic:\n+error: `#[derive]` can't be used on a `#[repr(packed)]` struct with type or const parameters (error E0133)\n+  --> $DIR/deriving-with-repr-packed.rs:8:23\n+   |\n+LL | #[derive(Copy, Clone, PartialEq, Eq)]\n+   |                       ^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/deriving-with-repr-packed.rs:1:9\n+   |\n+LL | #![deny(unaligned_references)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+Future breakage diagnostic:\n+error: `#[derive]` can't be used on a `#[repr(packed)]` struct that does not derive Copy (error E0133)\n+  --> $DIR/deriving-with-repr-packed.rs:16:10\n+   |\n+LL | #[derive(PartialEq, Eq)]\n+   |          ^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/deriving-with-repr-packed.rs:1:9\n+   |\n+LL | #![deny(unaligned_references)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+Future breakage diagnostic:\n+error: `#[derive]` can't be used on a `#[repr(packed)]` struct that does not derive Copy (error E0133)\n+  --> $DIR/deriving-with-repr-packed.rs:25:10\n+   |\n+LL | #[derive(PartialEq)]\n+   |          ^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/deriving-with-repr-packed.rs:1:9\n+   |\n+LL | #![deny(unaligned_references)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n+"}, {"sha": "ed5dd2ec0118160fc835573aa46af434791e118f", "filename": "src/test/ui/lint/unaligned_references.stderr", "status": "modified", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Flint%2Funaligned_references.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Flint%2Funaligned_references.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funaligned_references.stderr?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -82,3 +82,122 @@ LL |         let _ = &packed2.x;\n \n error: aborting due to 7 previous errors\n \n+Future incompatibility report: Future breakage diagnostic:\n+error: reference to packed field is unaligned\n+  --> $DIR/unaligned_references.rs:22:17\n+   |\n+LL |         let _ = &good.ptr;\n+   |                 ^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unaligned_references.rs:1:9\n+   |\n+LL | #![deny(unaligned_references)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+\n+Future breakage diagnostic:\n+error: reference to packed field is unaligned\n+  --> $DIR/unaligned_references.rs:24:17\n+   |\n+LL |         let _ = &good.data;\n+   |                 ^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unaligned_references.rs:1:9\n+   |\n+LL | #![deny(unaligned_references)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+\n+Future breakage diagnostic:\n+error: reference to packed field is unaligned\n+  --> $DIR/unaligned_references.rs:27:17\n+   |\n+LL |         let _ = &good.data as *const _;\n+   |                 ^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unaligned_references.rs:1:9\n+   |\n+LL | #![deny(unaligned_references)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+\n+Future breakage diagnostic:\n+error: reference to packed field is unaligned\n+  --> $DIR/unaligned_references.rs:29:27\n+   |\n+LL |         let _: *const _ = &good.data;\n+   |                           ^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unaligned_references.rs:1:9\n+   |\n+LL | #![deny(unaligned_references)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+\n+Future breakage diagnostic:\n+error: reference to packed field is unaligned\n+  --> $DIR/unaligned_references.rs:32:17\n+   |\n+LL |         let _ = good.data.clone();\n+   |                 ^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unaligned_references.rs:1:9\n+   |\n+LL | #![deny(unaligned_references)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+\n+Future breakage diagnostic:\n+error: reference to packed field is unaligned\n+  --> $DIR/unaligned_references.rs:35:17\n+   |\n+LL |         let _ = &good.data2[0];\n+   |                 ^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unaligned_references.rs:1:9\n+   |\n+LL | #![deny(unaligned_references)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+\n+Future breakage diagnostic:\n+error: reference to packed field is unaligned\n+  --> $DIR/unaligned_references.rs:45:17\n+   |\n+LL |         let _ = &packed2.x;\n+   |                 ^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unaligned_references.rs:1:9\n+   |\n+LL | #![deny(unaligned_references)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+"}, {"sha": "1262c21ee78e236381a39fecc4c703ce90f6089b", "filename": "src/test/ui/lint/unaligned_references_external_macro.stderr", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Flint%2Funaligned_references_external_macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Flint%2Funaligned_references_external_macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funaligned_references_external_macro.stderr?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -29,3 +29,33 @@ LL | | }\n \n error: aborting due to previous error\n \n+Future incompatibility report: Future breakage diagnostic:\n+error: reference to packed field is unaligned\n+  --> $DIR/unaligned_references_external_macro.rs:5:1\n+   |\n+LL | / unaligned_references_external_crate::mac! {\n+LL | |\n+LL | |     #[repr(packed)]\n+LL | |     pub struct X {\n+LL | |         pub field: u16\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unaligned_references_external_macro.rs:5:1\n+   |\n+LL | / unaligned_references_external_crate::mac! {\n+LL | |\n+LL | |     #[repr(packed)]\n+LL | |     pub struct X {\n+LL | |         pub field: u16\n+LL | |     }\n+LL | | }\n+   | |_^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+   = note: this error originates in the macro `unaligned_references_external_crate::mac` (in Nightly builds, run with -Z macro-backtrace for more info)\n+"}, {"sha": "cd6c5bf271935a8b13b76fc8a992e44179f0da9e", "filename": "src/test/ui/mir/issue-95978-validator-lifetime-comparison.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Fmir%2Fissue-95978-validator-lifetime-comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Fmir%2Fissue-95978-validator-lifetime-comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fissue-95978-validator-lifetime-comparison.rs?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -0,0 +1,10 @@\n+// check-pass\n+// compile-flags: -Zvalidate-mir\n+\n+fn foo(_a: &str) {}\n+\n+fn main() {\n+    let x = foo as fn(&'static str);\n+\n+    let _ = x == foo;\n+}"}, {"sha": "667b70afb8787c5c66f41c9ece04c54152f2f0ad", "filename": "src/test/ui/packed/issue-27060-rpass.stderr", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Fpacked%2Fissue-27060-rpass.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Fpacked%2Fissue-27060-rpass.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpacked%2Fissue-27060-rpass.stderr?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -0,0 +1,68 @@\n+Future incompatibility report: Future breakage diagnostic:\n+warning: reference to packed field is unaligned\n+  --> $DIR/issue-27060-rpass.rs:15:13\n+   |\n+LL |     let _ = &good.data; // ok\n+   |             ^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-27060-rpass.rs:11:9\n+   |\n+LL | #[allow(unaligned_references)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+\n+Future breakage diagnostic:\n+warning: reference to packed field is unaligned\n+  --> $DIR/issue-27060-rpass.rs:16:13\n+   |\n+LL |     let _ = &good.data2[0]; // ok\n+   |             ^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-27060-rpass.rs:11:9\n+   |\n+LL | #[allow(unaligned_references)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+\n+Future breakage diagnostic:\n+warning: reference to packed field is unaligned\n+  --> $DIR/issue-27060-rpass.rs:18:13\n+   |\n+LL |     let _ = &good.data;\n+   |             ^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-27060-rpass.rs:11:9\n+   |\n+LL | #[allow(unaligned_references)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+\n+Future breakage diagnostic:\n+warning: reference to packed field is unaligned\n+  --> $DIR/issue-27060-rpass.rs:19:13\n+   |\n+LL |     let _ = &good.data2[0];\n+   |             ^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-27060-rpass.rs:11:9\n+   |\n+LL | #[allow(unaligned_references)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+"}, {"sha": "886a00239f98c5165d80b6ac40d32c75f3b9d661", "filename": "src/test/ui/packed/issue-27060.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Fpacked%2Fissue-27060.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Fpacked%2Fissue-27060.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpacked%2Fissue-27060.rs?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -5,7 +5,6 @@ pub struct Good {\n     aligned: [u8; 32],\n }\n \n-#[deny(unaligned_references)]\n fn main() {\n     let good = Good {\n         data: &0,"}, {"sha": "1bab16e6ddaa38047dba17032d8787d926356c60", "filename": "src/test/ui/packed/issue-27060.stderr", "status": "modified", "additions": 57, "deletions": 9, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Fpacked%2Fissue-27060.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Fpacked%2Fissue-27060.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpacked%2Fissue-27060.stderr?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -1,21 +1,17 @@\n error: reference to packed field is unaligned\n-  --> $DIR/issue-27060.rs:16:13\n+  --> $DIR/issue-27060.rs:15:13\n    |\n LL |     let _ = &good.data;\n    |             ^^^^^^^^^^\n    |\n-note: the lint level is defined here\n-  --> $DIR/issue-27060.rs:8:8\n-   |\n-LL | #[deny(unaligned_references)]\n-   |        ^^^^^^^^^^^^^^^^^^^^\n+   = note: `#[deny(unaligned_references)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n    = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n error: reference to packed field is unaligned\n-  --> $DIR/issue-27060.rs:18:13\n+  --> $DIR/issue-27060.rs:17:13\n    |\n LL |     let _ = &good.data2[0];\n    |             ^^^^^^^^^^^^^^\n@@ -26,7 +22,7 @@ LL |     let _ = &good.data2[0];\n    = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n error: reference to packed field is unaligned\n-  --> $DIR/issue-27060.rs:21:13\n+  --> $DIR/issue-27060.rs:20:13\n    |\n LL |     let _ = &good.data;\n    |             ^^^^^^^^^^\n@@ -37,7 +33,7 @@ LL |     let _ = &good.data;\n    = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n error: reference to packed field is unaligned\n-  --> $DIR/issue-27060.rs:23:13\n+  --> $DIR/issue-27060.rs:22:13\n    |\n LL |     let _ = &good.data2[0];\n    |             ^^^^^^^^^^^^^^\n@@ -49,3 +45,55 @@ LL |     let _ = &good.data2[0];\n \n error: aborting due to 4 previous errors\n \n+Future incompatibility report: Future breakage diagnostic:\n+error: reference to packed field is unaligned\n+  --> $DIR/issue-27060.rs:15:13\n+   |\n+LL |     let _ = &good.data;\n+   |             ^^^^^^^^^^\n+   |\n+   = note: `#[deny(unaligned_references)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+\n+Future breakage diagnostic:\n+error: reference to packed field is unaligned\n+  --> $DIR/issue-27060.rs:17:13\n+   |\n+LL |     let _ = &good.data2[0];\n+   |             ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[deny(unaligned_references)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+\n+Future breakage diagnostic:\n+error: reference to packed field is unaligned\n+  --> $DIR/issue-27060.rs:20:13\n+   |\n+LL |     let _ = &good.data;\n+   |             ^^^^^^^^^^\n+   |\n+   = note: `#[deny(unaligned_references)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+\n+Future breakage diagnostic:\n+error: reference to packed field is unaligned\n+  --> $DIR/issue-27060.rs:22:13\n+   |\n+LL |     let _ = &good.data2[0];\n+   |             ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[deny(unaligned_references)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+"}, {"sha": "d86698cbf3848d50e86ee6d2abfb6673794df0d0", "filename": "src/test/ui/packed/packed-struct-address-of-element.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-address-of-element.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-address-of-element.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-address-of-element.rs?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -1,6 +1,5 @@\n // run-pass\n #![allow(dead_code)]\n-#![deny(unaligned_references)]\n #![feature(raw_ref_op)]\n // ignore-emscripten weird assertion?\n "}, {"sha": "00bddfe40b25b7ae3a4e6a00e473f0608cb308cc", "filename": "src/test/ui/packed/packed-struct-borrow-element-64bit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element-64bit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element-64bit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element-64bit.rs?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -9,6 +9,7 @@ struct Foo4C {\n     baz: usize\n }\n \n+#[warn(unaligned_references)]\n pub fn main() {\n     let foo = Foo4C { bar: 1, baz: 2 };\n     let brw = &foo.baz; //~WARN reference to packed field is unaligned"}, {"sha": "dcd1c19fa16a8344eb9c6638116a665f8adf3962", "filename": "src/test/ui/packed/packed-struct-borrow-element-64bit.stderr", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element-64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element-64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element-64bit.stderr?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -1,14 +1,35 @@\n warning: reference to packed field is unaligned\n-  --> $DIR/packed-struct-borrow-element-64bit.rs:14:15\n+  --> $DIR/packed-struct-borrow-element-64bit.rs:15:15\n    |\n LL |     let brw = &foo.baz;\n    |               ^^^^^^^^\n    |\n-   = note: `#[warn(unaligned_references)]` on by default\n+note: the lint level is defined here\n+  --> $DIR/packed-struct-borrow-element-64bit.rs:12:8\n+   |\n+LL | #[warn(unaligned_references)]\n+   |        ^^^^^^^^^^^^^^^^^^^^\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n    = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n warning: 1 warning emitted\n \n+Future incompatibility report: Future breakage diagnostic:\n+warning: reference to packed field is unaligned\n+  --> $DIR/packed-struct-borrow-element-64bit.rs:15:15\n+   |\n+LL |     let brw = &foo.baz;\n+   |               ^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/packed-struct-borrow-element-64bit.rs:12:8\n+   |\n+LL | #[warn(unaligned_references)]\n+   |        ^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+"}, {"sha": "a6ee90cef44f055abd58354860efc8cc443e741d", "filename": "src/test/ui/packed/packed-struct-borrow-element.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element.rs?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -20,6 +20,7 @@ struct Foo4C {\n     baz: usize\n }\n \n+#[warn(unaligned_references)]\n pub fn main() {\n     let foo = Foo1 { bar: 1, baz: 2 };\n     let brw = &foo.baz; //~WARN reference to packed field is unaligned"}, {"sha": "fb483227e20c124b78bac182246933bccaf44bf0", "filename": "src/test/ui/packed/packed-struct-borrow-element.stderr", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element.stderr?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -1,17 +1,21 @@\n warning: reference to packed field is unaligned\n-  --> $DIR/packed-struct-borrow-element.rs:25:15\n+  --> $DIR/packed-struct-borrow-element.rs:26:15\n    |\n LL |     let brw = &foo.baz;\n    |               ^^^^^^^^\n    |\n-   = note: `#[warn(unaligned_references)]` on by default\n+note: the lint level is defined here\n+  --> $DIR/packed-struct-borrow-element.rs:23:8\n+   |\n+LL | #[warn(unaligned_references)]\n+   |        ^^^^^^^^^^^^^^^^^^^^\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n    = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n warning: reference to packed field is unaligned\n-  --> $DIR/packed-struct-borrow-element.rs:30:15\n+  --> $DIR/packed-struct-borrow-element.rs:31:15\n    |\n LL |     let brw = &foo.baz;\n    |               ^^^^^^^^\n@@ -23,3 +27,37 @@ LL |     let brw = &foo.baz;\n \n warning: 2 warnings emitted\n \n+Future incompatibility report: Future breakage diagnostic:\n+warning: reference to packed field is unaligned\n+  --> $DIR/packed-struct-borrow-element.rs:26:15\n+   |\n+LL |     let brw = &foo.baz;\n+   |               ^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/packed-struct-borrow-element.rs:23:8\n+   |\n+LL | #[warn(unaligned_references)]\n+   |        ^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+\n+Future breakage diagnostic:\n+warning: reference to packed field is unaligned\n+  --> $DIR/packed-struct-borrow-element.rs:31:15\n+   |\n+LL |     let brw = &foo.baz;\n+   |               ^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/packed-struct-borrow-element.rs:23:8\n+   |\n+LL | #[warn(unaligned_references)]\n+   |        ^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+"}, {"sha": "db5f2f3ba1358857690e58e5cb1d205e302f31b8", "filename": "src/test/ui/unterminated-nested-comment.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Funterminated-nested-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Funterminated-nested-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funterminated-nested-comment.rs?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -0,0 +1,4 @@\n+/* //~ ERROR E0758\n+/* */\n+/*\n+*/"}, {"sha": "3653e76c9cbda713c6da614711217e67accbd01f", "filename": "src/test/ui/unterminated-nested-comment.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Funterminated-nested-comment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c8422403f775126c40d558838d321c063554c822/src%2Ftest%2Fui%2Funterminated-nested-comment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funterminated-nested-comment.stderr?ref=c8422403f775126c40d558838d321c063554c822", "patch": "@@ -0,0 +1,21 @@\n+error[E0758]: unterminated block comment\n+  --> $DIR/unterminated-nested-comment.rs:1:1\n+   |\n+LL |   /*\n+   |   ^-\n+   |   |\n+   |  _unterminated block comment\n+   | |\n+LL | | /* */\n+LL | | /*\n+   | | --\n+   | | |\n+   | | ...as last nested comment starts here, maybe you want to close this instead?\n+LL | | */\n+   | |_--^\n+   |   |\n+   |   ...and last nested comment terminates here.\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0758`."}]}