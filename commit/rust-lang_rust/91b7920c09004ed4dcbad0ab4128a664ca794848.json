{"sha": "91b7920c09004ed4dcbad0ab4128a664ca794848", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxYjc5MjBjMDkwMDRlZDRkY2JhZDBhYjQxMjhhNjY0Y2E3OTQ4NDg=", "commit": {"author": {"name": "Taylor Cramer", "email": "cramertj@google.com", "date": "2017-11-17T06:59:45Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-22T17:44:09Z"}, "message": "Implement in-band lifetime bindings", "tree": {"sha": "bb18e5558bcef5aeeadfa70dbac668a980c0e6af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb18e5558bcef5aeeadfa70dbac668a980c0e6af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91b7920c09004ed4dcbad0ab4128a664ca794848", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91b7920c09004ed4dcbad0ab4128a664ca794848", "html_url": "https://github.com/rust-lang/rust/commit/91b7920c09004ed4dcbad0ab4128a664ca794848", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91b7920c09004ed4dcbad0ab4128a664ca794848/comments", "author": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1dc0b573e7ce4314eb196b21b7e0ea4a1bf1f673", "url": "https://api.github.com/repos/rust-lang/rust/commits/1dc0b573e7ce4314eb196b21b7e0ea4a1bf1f673", "html_url": "https://github.com/rust-lang/rust/commit/1dc0b573e7ce4314eb196b21b7e0ea4a1bf1f673"}], "stats": {"total": 1162, "additions": 1026, "deletions": 136}, "files": [{"sha": "8089a88a9e8d483a3b2ca0a1ca612a6282f45b25", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -2051,4 +2051,6 @@ register_diagnostics! {\n     E0631, // type mismatch in closure arguments\n     E0637, // \"'_\" is not a valid lifetime bound\n     E0657, // `impl Trait` can only capture lifetimes bound at the fn level\n+    E0687, // in-band lifetimes cannot be used in `fn`/`Fn` syntax\n+    E0688, // in-band lifetimes cannot be mixed with explicit lifetime binders\n }"}, {"sha": "7fd6f4a8b4278254759cb7d07c41dac62ba8d4e5", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 337, "deletions": 105, "changes": 442, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -106,6 +106,26 @@ pub struct LoweringContext<'a> {\n     is_in_loop_condition: bool,\n     is_in_trait_impl: bool,\n \n+    // Used to create lifetime definitions from in-band lifetime usages.\n+    // e.g. `fn foo(x: &'x u8) -> &'x u8` to `fn foo<'x>(x: &'x u8) -> &'x u8`\n+    // When a named lifetime is encountered in a function or impl header and\n+    // has not been defined\n+    // (i.e. it doesn't appear in the in_scope_lifetimes list), it is added\n+    // to this list. The results of this list are then added to the list of\n+    // lifetime definitions in the corresponding impl or function generics.\n+    lifetimes_to_define: Vec<(Span, Name)>,\n+    // Whether or not in-band lifetimes are being collected. This is used to\n+    // indicate whether or not we're in a place where new lifetimes will result\n+    // in in-band lifetime definitions, such a function or an impl header.\n+    // This will always be false unless the `in_band_lifetimes` feature is\n+    // enabled.\n+    is_collecting_in_band_lifetimes: bool,\n+    // Currently in-scope lifetimes defined in impl headers, fn headers, or HRTB.\n+    // When `is_collectin_in_band_lifetimes` is true, each lifetime is checked\n+    // against this list to see if it is already in-scope, or if a definition\n+    // needs to be created for it.\n+    in_scope_lifetimes: Vec<Name>,\n+\n     type_def_lifetime_params: DefIdMap<usize>,\n \n     current_hir_id_owner: Vec<(DefIndex, u32)>,\n@@ -177,6 +197,9 @@ pub fn lower_crate(sess: &Session,\n         node_id_to_hir_id: IndexVec::new(),\n         is_generator: false,\n         is_in_trait_impl: false,\n+        lifetimes_to_define: Vec::new(),\n+        is_collecting_in_band_lifetimes: false,\n+        in_scope_lifetimes: Vec::new(),\n     }.lower_crate(krate)\n }\n \n@@ -271,13 +294,23 @@ impl<'a> LoweringContext<'a> {\n                 });\n \n                 if item_lowered {\n-                    if let ItemKind::Impl(_,_,_,_,ref opt_trait_ref,_,_) = item.node {\n-                        self.with_trait_impl_ref(opt_trait_ref, |this| {\n-                            visit::walk_item(this, item)\n-                        });\n-                    } else {\n-                        visit::walk_item(self, item);\n-                    }\n+                    let item_lifetimes = match self.lctx.items.get(&item.id).unwrap().node {\n+                        hir::Item_::ItemImpl(_,_,_,ref generics,..) |\n+                        hir::Item_::ItemTrait(_,_,ref generics,..) =>\n+                            generics.lifetimes.clone(),\n+                        _ => Vec::new().into(),\n+                    };\n+\n+                    self.lctx.with_parent_impl_lifetime_defs(&item_lifetimes, |this| {\n+                        let this = &mut ItemLowerer { lctx: this };\n+                        if let ItemKind::Impl(_,_,_,_,ref opt_trait_ref,_,_) = item.node {\n+                            this.with_trait_impl_ref(opt_trait_ref, |this| {\n+                                visit::walk_item(this, item)\n+                            });\n+                        } else {\n+                            visit::walk_item(this, item);\n+                        }\n+                    });\n                 }\n             }\n \n@@ -490,6 +523,124 @@ impl<'a> LoweringContext<'a> {\n         span.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n     }\n \n+    // Creates a new hir::LifetimeDef for every new lifetime encountered\n+    // while evaluating `f`. Definitions are created with the parent provided.\n+    // If no `parent_id` is provided, no definitions will be returned.\n+    fn collect_in_band_lifetime_defs<T, F>(\n+        &mut self,\n+        parent_id: Option<DefId>,\n+        f: F\n+    ) -> (Vec<hir::LifetimeDef>, T) where F: FnOnce(&mut LoweringContext) -> T\n+    {\n+        assert!(!self.is_collecting_in_band_lifetimes);\n+        assert!(self.lifetimes_to_define.is_empty());\n+        self.is_collecting_in_band_lifetimes = self.sess.features.borrow().in_band_lifetimes;\n+\n+        let res = f(self);\n+\n+        self.is_collecting_in_band_lifetimes = false;\n+\n+        let lifetimes_to_define = self.lifetimes_to_define.split_off(0);\n+\n+        let lifetime_defs = match parent_id {\n+            Some(parent_id) => lifetimes_to_define.into_iter().map(|(span, name)| {\n+                    let def_node_id = self.next_id().node_id;\n+\n+                    // Add a definition for the in-band lifetime def\n+                    self.resolver.definitions().create_def_with_parent(\n+                        parent_id.index,\n+                        def_node_id,\n+                        DefPathData::LifetimeDef(name.as_str()),\n+                        DefIndexAddressSpace::High,\n+                        Mark::root()\n+                    );\n+\n+                    hir::LifetimeDef {\n+                        lifetime: hir::Lifetime {\n+                            id: def_node_id,\n+                            span,\n+                            name: hir::LifetimeName::Name(name),\n+                        },\n+                        bounds: Vec::new().into(),\n+                        pure_wrt_drop: false,\n+                        in_band: true,\n+                    }\n+                }).collect(),\n+            None => Vec::new(),\n+        };\n+\n+        (lifetime_defs, res)\n+    }\n+\n+    // Evaluates `f` with the lifetimes in `lt_defs` in-scope.\n+    // This is used to track which lifetimes have already been defined, and\n+    // which are new in-band lifetimes that need to have a definition created\n+    // for them.\n+    fn with_in_scope_lifetime_defs<T, F>(\n+        &mut self,\n+        lt_defs: &[LifetimeDef],\n+        f: F\n+    ) -> T where F: FnOnce(&mut LoweringContext) -> T\n+    {\n+        let old_len = self.in_scope_lifetimes.len();\n+        let lt_def_names = lt_defs.iter().map(|lt_def| lt_def.lifetime.ident.name);\n+        self.in_scope_lifetimes.extend(lt_def_names);\n+\n+        let res = f(self);\n+\n+        self.in_scope_lifetimes.truncate(old_len);\n+        res\n+    }\n+\n+    // Same as the method above, but accepts `hir::LifetimeDef`s\n+    // instead of `ast::LifetimeDef`s.\n+    // This should only be used with generics that have already had their\n+    // in-band lifetimes added. In practice, this means that this function is\n+    // only used when lowering a child item of a trait or impl.\n+    fn with_parent_impl_lifetime_defs<T, F>(\n+        &mut self,\n+        lt_defs: &[hir::LifetimeDef],\n+        f: F\n+    ) -> T where F: FnOnce(&mut LoweringContext) -> T\n+    {\n+        let old_len = self.in_scope_lifetimes.len();\n+        let lt_def_names = lt_defs.iter().map(|lt_def| lt_def.lifetime.name.name());\n+        self.in_scope_lifetimes.extend(lt_def_names);\n+\n+        let res = f(self);\n+\n+        self.in_scope_lifetimes.truncate(old_len);\n+        res\n+    }\n+\n+    // Appends in-band lifetime defs to the existing set of out-of-band lifetime defs.\n+    // Evaluates all within the context of the out-of-band defs.\n+    // If provided, `impl_item_id` is used to find the parent impls of impl items so\n+    // that their generics are not duplicated.\n+    fn add_in_band_lifetime_defs<F, T>(\n+        &mut self,\n+        generics: &Generics,\n+        parent_id: Option<DefId>,\n+        f: F\n+    ) -> (hir::Generics, T)\n+        where F: FnOnce(&mut LoweringContext) -> T\n+    {\n+        let (in_band_defs, (mut lowered_generics, res)) =\n+            self.with_in_scope_lifetime_defs(&generics.lifetimes, |this| {\n+                this.collect_in_band_lifetime_defs(parent_id, |this| {\n+                    (this.lower_generics(generics), f(this))\n+                })\n+            });\n+\n+        lowered_generics.lifetimes =\n+            lowered_generics.lifetimes\n+                .iter().cloned()\n+               .chain(in_band_defs.into_iter())\n+               .collect();\n+\n+        (lowered_generics, res)\n+    }\n+\n     fn with_catch_scope<T, F>(&mut self, catch_id: NodeId, f: F) -> T\n         where F: FnOnce(&mut LoweringContext) -> T\n     {\n@@ -710,13 +861,14 @@ impl<'a> LoweringContext<'a> {\n                 hir::TyRptr(lifetime, self.lower_mt(mt, itctx))\n             }\n             TyKind::BareFn(ref f) => {\n-                hir::TyBareFn(P(hir::BareFnTy {\n-                    lifetimes: self.lower_lifetime_defs(&f.lifetimes),\n-                    unsafety: self.lower_unsafety(f.unsafety),\n-                    abi: f.abi,\n-                    decl: self.lower_fn_decl(&f.decl, None, false),\n-                    arg_names: self.lower_fn_args_to_names(&f.decl),\n-                }))\n+                self.with_in_scope_lifetime_defs(&f.lifetimes, |this|\n+                    hir::TyBareFn(P(hir::BareFnTy {\n+                        lifetimes: this.lower_lifetime_defs(&f.lifetimes),\n+                        unsafety: this.lower_unsafety(f.unsafety),\n+                        abi: f.abi,\n+                        decl: this.lower_fn_decl(&f.decl, None, false),\n+                        arg_names: this.lower_fn_args_to_names(&f.decl),\n+                    })))\n             }\n             TyKind::Never => hir::TyNever,\n             TyKind::Tup(ref tys) => {\n@@ -906,6 +1058,7 @@ impl<'a> LoweringContext<'a> {\n                             lifetime: def_lifetime,\n                             bounds: Vec::new().into(),\n                             pure_wrt_drop: false,\n+                            in_band: false,\n                         });\n                     }\n                 }\n@@ -1344,23 +1497,44 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_lifetime(&mut self, l: &Lifetime) -> hir::Lifetime {\n+        let name = match self.lower_ident(l.ident) {\n+            x if x == \"'_\" => hir::LifetimeName::Underscore,\n+            x if x == \"'static\" => hir::LifetimeName::Static,\n+            name => {\n+                if  self.is_collecting_in_band_lifetimes &&\n+                    !self.in_scope_lifetimes.contains(&name) &&\n+                    self.lifetimes_to_define.iter()\n+                        .find(|&&(_, lt_name)| lt_name == name)\n+                        .is_none()\n+                {\n+                    self.lifetimes_to_define.push((l.span, name));\n+                }\n+\n+                hir::LifetimeName::Name(name)\n+            }\n+        };\n+\n         hir::Lifetime {\n             id: self.lower_node_id(l.id).node_id,\n-            name: match self.lower_ident(l.ident) {\n-                x if x == \"'_\" => hir::LifetimeName::Underscore,\n-                x if x == \"'static\" => hir::LifetimeName::Static,\n-                name => hir::LifetimeName::Name(name),\n-            },\n+            name,\n             span: l.span,\n         }\n     }\n \n     fn lower_lifetime_def(&mut self, l: &LifetimeDef) -> hir::LifetimeDef {\n-        hir::LifetimeDef {\n+        let was_collecting_in_band = self.is_collecting_in_band_lifetimes;\n+        self.is_collecting_in_band_lifetimes = false;\n+\n+        let def = hir::LifetimeDef {\n             lifetime: self.lower_lifetime(&l.lifetime),\n             bounds: self.lower_lifetimes(&l.bounds),\n             pure_wrt_drop: l.attrs.iter().any(|attr| attr.check_name(\"may_dangle\")),\n-        }\n+            in_band: false,\n+        };\n+\n+        self.is_collecting_in_band_lifetimes = was_collecting_in_band;\n+\n+        def\n     }\n \n     fn lower_lifetimes(&mut self, lts: &Vec<Lifetime>) -> hir::HirVec<hir::Lifetime> {\n@@ -1435,15 +1609,19 @@ impl<'a> LoweringContext<'a> {\n                                                                 ref bounded_ty,\n                                                                 ref bounds,\n                                                                 span}) => {\n-                hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n-                    bound_lifetimes: self.lower_lifetime_defs(bound_lifetimes),\n-                    bounded_ty: self.lower_ty(bounded_ty, ImplTraitContext::Disallowed),\n-                    bounds: bounds.iter().filter_map(|bound| match *bound {\n-                        // Ignore `?Trait` bounds, they were copied into type parameters already.\n-                        TraitTyParamBound(_, TraitBoundModifier::Maybe) => None,\n-                        _ => Some(self.lower_ty_param_bound(bound, ImplTraitContext::Disallowed))\n-                    }).collect(),\n-                    span,\n+                self.with_in_scope_lifetime_defs(bound_lifetimes, |this| {\n+                    hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n+                        bound_lifetimes: this.lower_lifetime_defs(bound_lifetimes),\n+                        bounded_ty: this.lower_ty(bounded_ty, ImplTraitContext::Disallowed),\n+                        bounds: bounds.iter().filter_map(|bound| match *bound {\n+                            // Ignore `?Trait` bounds.\n+                            // Tthey were copied into type parameters already.\n+                            TraitTyParamBound(_, TraitBoundModifier::Maybe) => None,\n+                            _ => Some(this.lower_ty_param_bound(\n+                                    bound, ImplTraitContext::Disallowed))\n+                        }).collect(),\n+                        span,\n+                    })\n                 })\n             }\n             WherePredicate::RegionPredicate(WhereRegionPredicate{ ref lifetime,\n@@ -1504,9 +1682,13 @@ impl<'a> LoweringContext<'a> {\n                             p: &PolyTraitRef,\n                             itctx: ImplTraitContext)\n                             -> hir::PolyTraitRef {\n+        let bound_lifetimes = self.lower_lifetime_defs(&p.bound_lifetimes);\n+        let trait_ref = self.with_parent_impl_lifetime_defs(&bound_lifetimes,\n+                                |this| this.lower_trait_ref(&p.trait_ref, itctx));\n+\n         hir::PolyTraitRef {\n-            bound_lifetimes: self.lower_lifetime_defs(&p.bound_lifetimes),\n-            trait_ref: self.lower_trait_ref(&p.trait_ref, itctx),\n+            bound_lifetimes,\n+            trait_ref,\n             span: p.span,\n         }\n     }\n@@ -1678,11 +1860,15 @@ impl<'a> LoweringContext<'a> {\n                         let body = this.lower_block(body, false);\n                         this.expr_block(body, ThinVec::new())\n                     });\n-                    hir::ItemFn(this.lower_fn_decl(decl, fn_def_id, true),\n+                    let (generics, fn_decl) =\n+                        this.add_in_band_lifetime_defs(generics, fn_def_id, |this|\n+                            this.lower_fn_decl(decl, fn_def_id, true));\n+\n+                    hir::ItemFn(fn_decl,\n                                 this.lower_unsafety(unsafety),\n                                 this.lower_constness(constness),\n                                 abi,\n-                                this.lower_generics(generics),\n+                                generics,\n                                 body_id)\n                 })\n             }\n@@ -1723,29 +1909,42 @@ impl<'a> LoweringContext<'a> {\n             ItemKind::Impl(unsafety,\n                            polarity,\n                            defaultness,\n-                           ref generics,\n+                           ref ast_generics,\n                            ref ifce,\n                            ref ty,\n                            ref impl_items) => {\n-                let new_impl_items = impl_items.iter()\n-                                               .map(|item| self.lower_impl_item_ref(item))\n-                                               .collect();\n-                let ifce = ifce.as_ref().map(|trait_ref| {\n-                    self.lower_trait_ref(trait_ref, ImplTraitContext::Disallowed)\n+                let def_id = self.resolver.definitions().opt_local_def_id(id);\n+                let (generics, (ifce, lowered_ty)) =\n+                    self.add_in_band_lifetime_defs(ast_generics, def_id, |this| {\n+                        let ifce = ifce.as_ref().map(|trait_ref| {\n+                            this.lower_trait_ref(trait_ref, ImplTraitContext::Disallowed)\n+                        });\n+\n+                        if let Some(ref trait_ref) = ifce {\n+                            if let Def::Trait(def_id) = trait_ref.path.def {\n+                                this.trait_impls.entry(def_id).or_insert(vec![]).push(id);\n+                            }\n+                        }\n+\n+                        let lowered_ty = this.lower_ty(ty, ImplTraitContext::Disallowed);\n+\n+                        (ifce, lowered_ty)\n+                    });\n+\n+                let new_impl_items = self.with_in_scope_lifetime_defs(\n+                                            &ast_generics.lifetimes, |this| {\n+                    impl_items.iter()\n+                              .map(|item| this.lower_impl_item_ref(item))\n+                              .collect()\n                 });\n \n-                if let Some(ref trait_ref) = ifce {\n-                    if let Def::Trait(def_id) = trait_ref.path.def {\n-                        self.trait_impls.entry(def_id).or_insert(vec![]).push(id);\n-                    }\n-                }\n \n                 hir::ItemImpl(self.lower_unsafety(unsafety),\n                               self.lower_impl_polarity(polarity),\n                               self.lower_defaultness(defaultness, true /* [1] */),\n-                              self.lower_generics(generics),\n+                              generics,\n                               ifce,\n-                              self.lower_ty(ty, ImplTraitContext::Disallowed),\n+                              lowered_ty,\n                               new_impl_items)\n             }\n             ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref items) => {\n@@ -1769,41 +1968,55 @@ impl<'a> LoweringContext<'a> {\n             let LoweredNodeId { node_id, hir_id } = this.lower_node_id(i.id);\n             let fn_def_id = this.resolver.definitions().opt_local_def_id(node_id);\n \n+            let (generics, node) = match i.node {\n+                TraitItemKind::Const(ref ty, ref default) => {\n+                    (\n+                        this.lower_generics(&i.generics),\n+                        hir::TraitItemKind::Const(\n+                            this.lower_ty(ty, ImplTraitContext::Disallowed),\n+                            default.as_ref().map(|x| {\n+                                this.lower_body(None, |this| this.lower_expr(x))\n+                            }))\n+                    )\n+                }\n+                TraitItemKind::Method(ref sig, None) => {\n+                    let names = this.lower_fn_args_to_names(&sig.decl);\n+                    this.add_in_band_lifetime_defs(&i.generics, fn_def_id, |this|\n+                        hir::TraitItemKind::Method(\n+                            this.lower_method_sig(sig, fn_def_id, false),\n+                            hir::TraitMethod::Required(names)))\n+                }\n+                TraitItemKind::Method(ref sig, Some(ref body)) => {\n+                    let body_id = this.lower_body(Some(&sig.decl), |this| {\n+                        let body = this.lower_block(body, false);\n+                        this.expr_block(body, ThinVec::new())\n+                    });\n+\n+                    this.add_in_band_lifetime_defs(&i.generics, fn_def_id, |this|\n+                        hir::TraitItemKind::Method(\n+                            this.lower_method_sig(sig, fn_def_id, false),\n+                           hir::TraitMethod::Provided(body_id)))\n+                }\n+                TraitItemKind::Type(ref bounds, ref default) => {\n+                    (\n+                        this.lower_generics(&i.generics),\n+                        hir::TraitItemKind::Type(\n+                            this.lower_bounds(bounds, ImplTraitContext::Disallowed),\n+                            default.as_ref().map(|x| {\n+                                this.lower_ty(x, ImplTraitContext::Disallowed)\n+                            }))\n+                    )\n+                }\n+                TraitItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n+            };\n+\n             hir::TraitItem {\n                 id: node_id,\n                 hir_id,\n                 name: this.lower_ident(i.ident),\n                 attrs: this.lower_attrs(&i.attrs),\n-                generics: this.lower_generics(&i.generics),\n-                node: match i.node {\n-                    TraitItemKind::Const(ref ty, ref default) => {\n-                        hir::TraitItemKind::Const(this.lower_ty(ty, ImplTraitContext::Disallowed),\n-                                                  default.as_ref().map(|x| {\n-                            this.lower_body(None, |this| this.lower_expr(x))\n-                        }))\n-                    }\n-                    TraitItemKind::Method(ref sig, None) => {\n-                        let names = this.lower_fn_args_to_names(&sig.decl);\n-                        hir::TraitItemKind::Method(this.lower_method_sig(sig, fn_def_id, false),\n-                                                   hir::TraitMethod::Required(names))\n-                    }\n-                    TraitItemKind::Method(ref sig, Some(ref body)) => {\n-                        let body_id = this.lower_body(Some(&sig.decl), |this| {\n-                            let body = this.lower_block(body, false);\n-                            this.expr_block(body, ThinVec::new())\n-                        });\n-                        hir::TraitItemKind::Method(this.lower_method_sig(sig, fn_def_id, false),\n-                                                   hir::TraitMethod::Provided(body_id))\n-                    }\n-                    TraitItemKind::Type(ref bounds, ref default) => {\n-                        hir::TraitItemKind::Type(this.lower_bounds(bounds,\n-                                                                   ImplTraitContext::Disallowed),\n-                                                 default.as_ref().map(|x| {\n-                                                     this.lower_ty(x, ImplTraitContext::Disallowed)\n-                                                 }))\n-                    }\n-                    TraitItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n-                },\n+                generics,\n+                node,\n                 span: i.span,\n             }\n         })\n@@ -1838,37 +2051,46 @@ impl<'a> LoweringContext<'a> {\n             let LoweredNodeId { node_id, hir_id } = this.lower_node_id(i.id);\n             let fn_def_id = this.resolver.definitions().opt_local_def_id(node_id);\n \n+            let (generics, node) = match i.node {\n+                ImplItemKind::Const(ref ty, ref expr) => {\n+                    let body_id = this.lower_body(None, |this| this.lower_expr(expr));\n+                    (\n+                        this.lower_generics(&i.generics),\n+                        hir::ImplItemKind::Const(\n+                            this.lower_ty(ty, ImplTraitContext::Disallowed),\n+                            body_id\n+                        )\n+                    )\n+                }\n+                ImplItemKind::Method(ref sig, ref body) => {\n+                    let body_id = this.lower_body(Some(&sig.decl), |this| {\n+                        let body = this.lower_block(body, false);\n+                        this.expr_block(body, ThinVec::new())\n+                    });\n+                    let impl_trait_return_allow = !this.is_in_trait_impl;\n+\n+                    this.add_in_band_lifetime_defs(&i.generics, fn_def_id, |this|\n+                        hir::ImplItemKind::Method(\n+                            this.lower_method_sig(sig, fn_def_id, impl_trait_return_allow),\n+                            body_id))\n+                }\n+                ImplItemKind::Type(ref ty) => (\n+                    this.lower_generics(&i.generics),\n+                    hir::ImplItemKind::Type(\n+                        this.lower_ty(ty, ImplTraitContext::Disallowed)),\n+                ),\n+                ImplItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n+            };\n+\n             hir::ImplItem {\n                 id: node_id,\n                 hir_id,\n                 name: this.lower_ident(i.ident),\n                 attrs: this.lower_attrs(&i.attrs),\n-                generics: this.lower_generics(&i.generics),\n+                generics,\n                 vis: this.lower_visibility(&i.vis, None),\n                 defaultness: this.lower_defaultness(i.defaultness, true /* [1] */),\n-                node: match i.node {\n-                    ImplItemKind::Const(ref ty, ref expr) => {\n-                        let body_id = this.lower_body(None, |this| this.lower_expr(expr));\n-                        hir::ImplItemKind::Const(\n-                            this.lower_ty(ty, ImplTraitContext::Disallowed),\n-                            body_id\n-                        )\n-                    }\n-                    ImplItemKind::Method(ref sig, ref body) => {\n-                        let body_id = this.lower_body(Some(&sig.decl), |this| {\n-                            let body = this.lower_block(body, false);\n-                            this.expr_block(body, ThinVec::new())\n-                        });\n-                        let impl_trait_return_allow = !this.is_in_trait_impl;\n-                        hir::ImplItemKind::Method(this.lower_method_sig(sig,\n-                                                                        fn_def_id,\n-                                                                        impl_trait_return_allow),\n-                                                  body_id)\n-                    }\n-                    ImplItemKind::Type(ref ty) =>\n-                        hir::ImplItemKind::Type(this.lower_ty(ty, ImplTraitContext::Disallowed)),\n-                    ImplItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n-                },\n+                node,\n                 span: i.span,\n             }\n         })\n@@ -1958,16 +2180,26 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_foreign_item(&mut self, i: &ForeignItem) -> hir::ForeignItem {\n         self.with_parent_def(i.id, |this| {\n+            let node_id = this.lower_node_id(i.id).node_id;\n+            let def_id = this.resolver.definitions().local_def_id(node_id);\n             hir::ForeignItem {\n-                id: this.lower_node_id(i.id).node_id,\n+                id: node_id,\n                 name: i.ident.name,\n                 attrs: this.lower_attrs(&i.attrs),\n                 node: match i.node {\n                     ForeignItemKind::Fn(ref fdec, ref generics) => {\n                         // Disallow impl Trait in foreign items\n-                        hir::ForeignItemFn(this.lower_fn_decl(fdec, None, false),\n-                                           this.lower_fn_args_to_names(fdec),\n-                                           this.lower_generics(generics))\n+                        let (generics, (fn_dec, fn_args)) =\n+                            this.add_in_band_lifetime_defs(\n+                                generics,\n+                                Some(def_id),\n+                                |this| (\n+                                    this.lower_fn_decl(fdec, None, false),\n+                                    this.lower_fn_args_to_names(fdec)\n+                                )\n+                            );\n+\n+                        hir::ForeignItemFn(fn_dec, fn_args, generics)\n                     }\n                     ForeignItemKind::Static(ref t, m) => {\n                         hir::ForeignItemStatic(this.lower_ty(t, ImplTraitContext::Disallowed), m)"}, {"sha": "39ec33eef1fec518542f3001a5335fd914459042", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -222,6 +222,10 @@ pub struct LifetimeDef {\n     pub lifetime: Lifetime,\n     pub bounds: HirVec<Lifetime>,\n     pub pure_wrt_drop: bool,\n+    // Indicates that the lifetime definition was synthetically added\n+    // as a result of an in-band lifetime usage like\n+    // `fn foo(x: &'a u8) -> &'a u8 { x }`\n+    pub in_band: bool,\n }\n \n /// A \"Path\" is essentially Rust's notion of a name; for instance:"}, {"sha": "bccef6dc91bcdfa553f19f6f85b21cf1990a796f", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -157,7 +157,8 @@ impl_stable_hash_for!(struct hir::Lifetime {\n impl_stable_hash_for!(struct hir::LifetimeDef {\n     lifetime,\n     bounds,\n-    pure_wrt_drop\n+    pure_wrt_drop,\n+    in_band\n });\n \n impl_stable_hash_for!(struct hir::Path {"}, {"sha": "45e80b58a4f0d99a04707a787e0d0239480c06ad", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -493,10 +493,15 @@ for ::middle::resolve_lifetime::Set1<T>\n     }\n }\n \n+impl_stable_hash_for!(enum ::middle::resolve_lifetime::LifetimeDefOrigin {\n+    Explicit,\n+    InBand\n+});\n+\n impl_stable_hash_for!(enum ::middle::resolve_lifetime::Region {\n     Static,\n-    EarlyBound(index, decl),\n-    LateBound(db_index, decl),\n+    EarlyBound(index, decl, is_in_band),\n+    LateBound(db_index, decl, is_in_band),\n     LateBoundAnon(db_index, anon_index),\n     Free(call_site_scope_data, decl)\n });"}, {"sha": "cade67a44bb0e40adfff9f003db3ae3bdd264d8e", "filename": "src/librustc/infer/error_reporting/different_lifetimes.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fdifferent_lifetimes.rs?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -281,7 +281,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n                     // Find the index of the named region that was part of the\n                     // error. We will then search the function parameters for a bound\n                     // region at the right depth with the same index\n-                    (Some(rl::Region::EarlyBound(_, id)), ty::BrNamed(def_id, _)) => {\n+                    (Some(rl::Region::EarlyBound(_, id, _)), ty::BrNamed(def_id, _)) => {\n                         debug!(\"EarlyBound self.infcx.tcx.hir.local_def_id(id)={:?} \\\n                                         def_id={:?}\", id, def_id);\n                         if id == def_id {\n@@ -293,7 +293,10 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n                     // Find the index of the named region that was part of the\n                     // error. We will then search the function parameters for a bound\n                     // region at the right depth with the same index\n-                    (Some(rl::Region::LateBound(debruijn_index, id)), ty::BrNamed(def_id, _)) => {\n+                    (\n+                     Some(rl::Region::LateBound(debruijn_index, id, _)),\n+                     ty::BrNamed(def_id, _)\n+                    ) => {\n                         debug!(\"FindNestedTypeVisitor::visit_ty: LateBound depth = {:?}\",\n                                debruijn_index.depth);\n                         debug!(\"self.infcx.tcx.hir.local_def_id(id)={:?}\", id);\n@@ -306,8 +309,8 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n \n                     (Some(rl::Region::Static), _) |\n                     (Some(rl::Region::Free(_, _)), _) |\n-                    (Some(rl::Region::EarlyBound(_, _)), _) |\n-                    (Some(rl::Region::LateBound(_, _)), _) |\n+                    (Some(rl::Region::EarlyBound(_, _, _)), _) |\n+                    (Some(rl::Region::LateBound(_, _, _)), _) |\n                     (Some(rl::Region::LateBoundAnon(_, _)), _) |\n                     (None, _) => {\n                         debug!(\"no arg found\");\n@@ -368,7 +371,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for TyPathVisitor<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            (Some(rl::Region::EarlyBound(_, id)), ty::BrNamed(def_id, _)) => {\n+            (Some(rl::Region::EarlyBound(_, id, _)), ty::BrNamed(def_id, _)) => {\n                 debug!(\"EarlyBound self.infcx.tcx.hir.local_def_id(id)={:?} \\\n                                         def_id={:?}\", id, def_id);\n                 if id == def_id {\n@@ -377,7 +380,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for TyPathVisitor<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            (Some(rl::Region::LateBound(debruijn_index, id)), ty::BrNamed(def_id, _)) => {\n+            (Some(rl::Region::LateBound(debruijn_index, id, _)), ty::BrNamed(def_id, _)) => {\n                 debug!(\"FindNestedTypeVisitor::visit_ty: LateBound depth = {:?}\",\n                        debruijn_index.depth);\n                 debug!(\"id={:?}\", id);\n@@ -389,8 +392,8 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for TyPathVisitor<'a, 'gcx, 'tcx> {\n             }\n \n             (Some(rl::Region::Static), _) |\n-            (Some(rl::Region::EarlyBound(_, _)), _) |\n-            (Some(rl::Region::LateBound(_, _)), _) |\n+            (Some(rl::Region::EarlyBound(_, _, _)), _) |\n+            (Some(rl::Region::LateBound(_, _, _)), _) |\n             (Some(rl::Region::LateBoundAnon(_, _)), _) |\n             (Some(rl::Region::Free(_, _)), _) |\n             (None, _) => {"}, {"sha": "b39975d3ff9198815f708881159b37462251b21a", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 90, "deletions": 15, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -36,11 +36,32 @@ use rustc_back::slice;\n use hir;\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n \n+/// The origin of a named lifetime definition.\n+///\n+/// This is used to prevent the usage of in-band lifetimes in `Fn`/`fn` syntax.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n+pub enum LifetimeDefOrigin {\n+    // Explicit binders like `fn foo<'a>(x: &'a u8)`\n+    Explicit,\n+    // In-band declarations like `fn foo(x: &'a u8)`\n+    InBand,\n+}\n+\n+impl LifetimeDefOrigin {\n+    fn from_is_in_band(is_in_band: bool) -> Self {\n+        if is_in_band {\n+            LifetimeDefOrigin::InBand\n+        } else {\n+            LifetimeDefOrigin::Explicit\n+        }\n+    }\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub enum Region {\n     Static,\n-    EarlyBound(/* index */ u32, /* lifetime decl */ DefId),\n-    LateBound(ty::DebruijnIndex, /* lifetime decl */ DefId),\n+    EarlyBound(/* index */ u32, /* lifetime decl */ DefId, LifetimeDefOrigin),\n+    LateBound(ty::DebruijnIndex, /* lifetime decl */ DefId, LifetimeDefOrigin),\n     LateBoundAnon(ty::DebruijnIndex, /* anon index */ u32),\n     Free(DefId, /* lifetime decl */ DefId),\n }\n@@ -52,14 +73,16 @@ impl Region {\n         let i = *index;\n         *index += 1;\n         let def_id = hir_map.local_def_id(def.lifetime.id);\n+        let origin = LifetimeDefOrigin::from_is_in_band(def.in_band);\n         debug!(\"Region::early: index={} def_id={:?}\", i, def_id);\n-        (def.lifetime.name, Region::EarlyBound(i, def_id))\n+        (def.lifetime.name, Region::EarlyBound(i, def_id, origin))\n     }\n \n     fn late(hir_map: &Map, def: &hir::LifetimeDef) -> (hir::LifetimeName, Region) {\n         let depth = ty::DebruijnIndex::new(1);\n         let def_id = hir_map.local_def_id(def.lifetime.id);\n-        (def.lifetime.name, Region::LateBound(depth, def_id))\n+        let origin = LifetimeDefOrigin::from_is_in_band(def.in_band);\n+        (def.lifetime.name, Region::LateBound(depth, def_id, origin))\n     }\n \n     fn late_anon(index: &Cell<u32>) -> Region {\n@@ -74,16 +97,16 @@ impl Region {\n             Region::Static |\n             Region::LateBoundAnon(..) => None,\n \n-            Region::EarlyBound(_, id) |\n-            Region::LateBound(_, id) |\n+            Region::EarlyBound(_, id, _) |\n+            Region::LateBound(_, id, _) |\n             Region::Free(_, id) => Some(id)\n         }\n     }\n \n     fn shifted(self, amount: u32) -> Region {\n         match self {\n-            Region::LateBound(depth, id) => {\n-                Region::LateBound(depth.shifted(amount), id)\n+            Region::LateBound(depth, id, origin) => {\n+                Region::LateBound(depth.shifted(amount), id, origin)\n             }\n             Region::LateBoundAnon(depth, index) => {\n                 Region::LateBoundAnon(depth.shifted(amount), index)\n@@ -94,10 +117,10 @@ impl Region {\n \n     fn from_depth(self, depth: u32) -> Region {\n         match self {\n-            Region::LateBound(debruijn, id) => {\n+            Region::LateBound(debruijn, id, origin) => {\n                 Region::LateBound(ty::DebruijnIndex {\n                     depth: debruijn.depth - (depth - 1)\n-                }, id)\n+                }, id, origin)\n             }\n             Region::LateBoundAnon(debruijn, index) => {\n                 Region::LateBoundAnon(ty::DebruijnIndex {\n@@ -110,7 +133,7 @@ impl Region {\n \n     fn subst(self, params: &[hir::Lifetime], map: &NamedRegionMap)\n              -> Option<Region> {\n-        if let Region::EarlyBound(index, _) = self {\n+        if let Region::EarlyBound(index, _, _) = self {\n             params.get(index as usize).and_then(|lifetime| {\n                 map.defs.get(&lifetime.id).cloned()\n             })\n@@ -187,6 +210,9 @@ struct LifetimeContext<'a, 'tcx: 'a> {\n     // I'm sorry.\n     trait_ref_hack: bool,\n \n+    // Used to disallow the use of in-band lifetimes in `fn` or `Fn` syntax.\n+    is_in_fn_syntax: bool,\n+\n     // List of labels in the function/method currently under analysis.\n     labels_in_fn: Vec<(ast::Name, Span)>,\n \n@@ -280,6 +306,7 @@ pub fn krate(sess: &Session,\n             map: &mut map,\n             scope: ROOT_SCOPE,\n             trait_ref_hack: false,\n+            is_in_fn_syntax: false,\n             labels_in_fn: vec![],\n             xcrate_object_lifetime_defaults: DefIdMap(),\n         };\n@@ -384,6 +411,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         match ty.node {\n             hir::TyBareFn(ref c) => {\n                 let next_early_index = self.next_early_index();\n+                let was_in_fn_syntax = self.is_in_fn_syntax;\n+                self.is_in_fn_syntax = true;\n                 let scope = Scope::Binder {\n                     lifetimes: c.lifetimes.iter().map(|def| {\n                         Region::late(self.hir_map, def)\n@@ -397,6 +426,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     this.check_lifetime_defs(old_scope, &c.lifetimes);\n                     intravisit::walk_ty(this, ty);\n                 });\n+                self.is_in_fn_syntax = was_in_fn_syntax;\n             }\n             hir::TyTraitObject(ref bounds, ref lifetime) => {\n                 for bound in bounds {\n@@ -430,7 +460,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     // well-supported at the moment, so this doesn't work.\n                     // In the future, this should be fixed and this error should be removed.\n                     let def = self.map.defs.get(&lifetime.id);\n-                    if let Some(&Region::LateBound(_, def_id)) = def {\n+                    if let Some(&Region::LateBound(_, def_id, _)) = def {\n                         if let Some(node_id) = self.hir_map.as_local_node_id(def_id) {\n                             // Ensure that the parent of the def is an item, not HRTB\n                             let parent_id = self.hir_map.get_parent_node(node_id);\n@@ -528,6 +558,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n+        check_mixed_explicit_and_in_band_defs(&self.sess, &generics.lifetimes);\n         for ty_param in generics.ty_params.iter() {\n             walk_list!(self, visit_ty_param_bound, &ty_param.bounds);\n             if let Some(ref ty) = ty_param.default {\n@@ -639,6 +670,22 @@ impl ShadowKind {\n     }\n }\n \n+fn check_mixed_explicit_and_in_band_defs(\n+    sess: &Session,\n+    lifetime_defs: &[hir::LifetimeDef],\n+) {\n+    let oob_def = lifetime_defs.iter().find(|lt| !lt.in_band);\n+    let in_band_def = lifetime_defs.iter().find(|lt| lt.in_band);\n+\n+    if let (Some(oob_def), Some(in_band_def)) = (oob_def, in_band_def) {\n+        struct_span_err!(sess, in_band_def.lifetime.span, E0688,\n+                         \"cannot mix in-band and explicit lifetime definitions\")\n+            .span_label(in_band_def.lifetime.span, \"in-band lifetime definition here\")\n+            .span_label(oob_def.lifetime.span, \"explicit lifetime definition here\")\n+            .emit();\n+    }\n+}\n+\n fn signal_shadowing_problem(sess: &Session, name: ast::Name, orig: Original, shadower: Shadower) {\n     let mut err = if let (ShadowKind::Lifetime, ShadowKind::Lifetime) = (orig.kind, shadower.kind) {\n         // lifetime/lifetime shadowing is an error\n@@ -767,7 +814,7 @@ fn compute_object_lifetime_defaults(sess: &Session, hir_map: &Map)\n                             match *set {\n                                 Set1::Empty => \"BaseDefault\".to_string(),\n                                 Set1::One(Region::Static) => \"'static\".to_string(),\n-                                Set1::One(Region::EarlyBound(i, _)) => {\n+                                Set1::One(Region::EarlyBound(i, _, _)) => {\n                                     generics.lifetimes[i as usize].lifetime.name.name().to_string()\n                                 }\n                                 Set1::One(_) => bug!(),\n@@ -837,7 +884,8 @@ fn object_lifetime_defaults_for_item(hir_map: &Map, generics: &hir::Generics)\n                         def.lifetime.name == name\n                     }).map_or(Set1::Many, |(i, def)| {\n                         let def_id = hir_map.local_def_id(def.lifetime.id);\n-                        Set1::One(Region::EarlyBound(i as u32, def_id))\n+                        let origin = LifetimeDefOrigin::from_is_in_band(def.in_band);\n+                        Set1::One(Region::EarlyBound(i as u32, def_id, origin))\n                     })\n                 }\n             }\n@@ -868,6 +916,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             map: *map,\n             scope: &wrap_scope,\n             trait_ref_hack: self.trait_ref_hack,\n+            is_in_fn_syntax: self.is_in_fn_syntax,\n             labels_in_fn,\n             xcrate_object_lifetime_defaults,\n         };\n@@ -1020,6 +1069,28 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     _ => {}\n                 }\n             }\n+\n+            // Check for fn-syntax conflicts with in-band lifetime definitions\n+            if self.is_in_fn_syntax {\n+                match def {\n+                    Region::EarlyBound(_, _, LifetimeDefOrigin::InBand) |\n+                    Region::LateBound(_, _, LifetimeDefOrigin::InBand) => {\n+                        struct_span_err!(self.sess, lifetime_ref.span, E0687,\n+                            \"lifetimes used in `fn` or `Fn` syntax must be \\\n+                            explicitly declared using `<...>` binders\")\n+                            .span_label(lifetime_ref.span,\n+                                        \"in-band lifetime definition\")\n+                            .emit();\n+                    },\n+\n+                    Region::Static |\n+                    Region::EarlyBound(_, _, LifetimeDefOrigin::Explicit) |\n+                    Region::LateBound(_, _, LifetimeDefOrigin::Explicit) |\n+                    Region::LateBoundAnon(..) |\n+                    Region::Free(..) => {}\n+                }\n+            }\n+\n             self.insert_lifetime(lifetime_ref, def);\n         } else {\n             struct_span_err!(self.sess, lifetime_ref.span, E0261,\n@@ -1033,8 +1104,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                                 def: Def,\n                                 depth: usize,\n                                 params: &'tcx hir::PathParameters) {\n+\n         if params.parenthesized {\n+            let was_in_fn_syntax = self.is_in_fn_syntax;\n+            self.is_in_fn_syntax = true;\n             self.visit_fn_like_elision(params.inputs(), Some(&params.bindings[0].ty));\n+            self.is_in_fn_syntax = was_in_fn_syntax;\n             return;\n         }\n \n@@ -1355,7 +1430,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n                 if let Some(&lifetime) = self.map.defs.get(&lifetime_ref.id) {\n                     match lifetime {\n-                        Region::LateBound(debruijn, _) |\n+                        Region::LateBound(debruijn, _, _) |\n                         Region::LateBoundAnon(debruijn, _)\n                                 if debruijn.depth < self.binder_depth => {\n                             self.have_bound_regions = true;"}, {"sha": "8b849a9e52f3a87976457557748eba659eb1dc3b", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -110,7 +110,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 tcx.types.re_static\n             }\n \n-            Some(rl::Region::LateBound(debruijn, id)) => {\n+            Some(rl::Region::LateBound(debruijn, id, _)) => {\n                 let name = lifetime_name(id);\n                 tcx.mk_region(ty::ReLateBound(debruijn,\n                     ty::BrNamed(id, name)))\n@@ -120,7 +120,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 tcx.mk_region(ty::ReLateBound(debruijn, ty::BrAnon(index)))\n             }\n \n-            Some(rl::Region::EarlyBound(index, id)) => {\n+            Some(rl::Region::EarlyBound(index, id, _)) => {\n                 let name = lifetime_name(id);\n                 tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n                     def_id: id,"}, {"sha": "7de29868d4341afb630b979c2df226b55ba03233", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -784,7 +784,7 @@ fn has_late_bound_regions<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let hir_id = self.tcx.hir.node_to_hir_id(lt.id);\n             match self.tcx.named_region(hir_id) {\n                 Some(rl::Region::Static) | Some(rl::Region::EarlyBound(..)) => {}\n-                Some(rl::Region::LateBound(debruijn, _)) |\n+                Some(rl::Region::LateBound(debruijn, _, _)) |\n                 Some(rl::Region::LateBoundAnon(debruijn, _))\n                     if debruijn.depth < self.binder_depth => {}\n                 _ => self.has_late_bound_regions = Some(lt.span),"}, {"sha": "e20cae036a375ddaa30960618e0202ef8950235a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -1008,8 +1008,8 @@ impl Clean<Lifetime> for hir::Lifetime {\n         let hir_id = cx.tcx.hir.node_to_hir_id(self.id);\n         let def = cx.tcx.named_region(hir_id);\n         match def {\n-            Some(rl::Region::EarlyBound(_, node_id)) |\n-            Some(rl::Region::LateBound(_, node_id)) |\n+            Some(rl::Region::EarlyBound(_, node_id, _)) |\n+            Some(rl::Region::LateBound(_, node_id, _)) |\n             Some(rl::Region::Free(_, node_id)) => {\n                 if let Some(lt) = cx.lt_substs.borrow().get(&node_id).cloned() {\n                     return lt;"}, {"sha": "89d1a3699e8a6dc96a6048cfeb956e961773c435", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -425,6 +425,9 @@ declare_features! (\n \n     // `crate` in paths\n     (active, crate_in_paths, \"1.23.0\", Some(45477)),\n+\n+    // In-band lifetime bindings (e.g. `fn foo(x: &'a u8) -> &'a u8`)\n+    (active, in_band_lifetimes, \"1.23.0\", Some(44524)),\n );\n \n declare_features! ("}, {"sha": "ae1f81c2f5721fd54742b3036ebd2b7d0dcb8b60", "filename": "src/test/compile-fail/feature-gate-in_band_lifetimes.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fcompile-fail%2Ffeature-gate-in_band_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fcompile-fail%2Ffeature-gate-in_band_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-in_band_lifetimes.rs?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -0,0 +1,72 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(warnings)]\n+\n+fn foo(x: &'x u8) -> &'x u8 { x }\n+//~^ ERROR use of undeclared lifetime name\n+//~^^ ERROR use of undeclared lifetime name\n+\n+struct X<'a>(&'a u8);\n+\n+impl<'a> X<'a> {\n+    fn inner(&self) -> &'a u8 {\n+        self.0\n+    }\n+}\n+\n+impl<'a> X<'b> {\n+//~^ ERROR use of undeclared lifetime name\n+    fn inner_2(&self) -> &'b u8 {\n+    //~^ ERROR use of undeclared lifetime name\n+        self.0\n+    }\n+}\n+\n+impl X<'b> {\n+//~^ ERROR use of undeclared lifetime name\n+    fn inner_3(&self) -> &'b u8 {\n+    //~^ ERROR use of undeclared lifetime name\n+        self.0\n+    }\n+}\n+\n+struct Y<T>(T);\n+\n+impl Y<&'a u8> {\n+    //~^ ERROR use of undeclared lifetime name\n+    fn inner(&self) -> &'a u8 {\n+    //~^ ERROR use of undeclared lifetime name\n+        self.0\n+    }\n+}\n+\n+trait MyTrait<'a> {\n+    fn my_lifetime(&self) -> &'a u8;\n+    fn any_lifetime() -> &'b u8;\n+    //~^ ERROR use of undeclared lifetime name\n+    fn borrowed_lifetime(&'b self) -> &'b u8;\n+    //~^ ERROR use of undeclared lifetime name\n+    //~^^ ERROR use of undeclared lifetime name\n+}\n+\n+impl MyTrait<'a> for Y<&'a u8> {\n+//~^ ERROR use of undeclared lifetime name\n+//~^^ ERROR use of undeclared lifetime name\n+    fn my_lifetime(&self) -> &'a u8 { self.0 }\n+    //~^ ERROR use of undeclared lifetime name\n+    fn any_lifetime() -> &'b u8 { &0 }\n+    //~^ ERROR use of undeclared lifetime name\n+    fn borrowed_lifetime(&'b self) -> &'b u8 { &*self.0 }\n+    //~^ ERROR use of undeclared lifetime name\n+    //~^^ ERROR use of undeclared lifetime name\n+}\n+\n+fn main() {}"}, {"sha": "d7a837f23b190db94d15cb96802ff9abbbf57036", "filename": "src/test/run-pass/in-band-lifetimes.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Frun-pass%2Fin-band-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Frun-pass%2Fin-band-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fin-band-lifetimes.rs?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -0,0 +1,84 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(warnings)]\n+#![feature(in_band_lifetimes, universal_impl_trait)]\n+\n+fn foo(x: &'x u8) -> &'x u8 { x }\n+fn foo2(x: &'a u8, y: &u8) -> &'a u8 { x }\n+\n+fn check_in_band_can_be_late_bound() {\n+    let _: for<'x> fn(&'x u8, &u8) -> &'x u8 = foo2;\n+}\n+\n+struct ForInherentNoParams;\n+\n+impl ForInherentNoParams {\n+    fn foo(x: &'a u32, y: &u32) -> &'a u32 { x }\n+}\n+\n+struct X<'a>(&'a u8);\n+\n+impl<'a> X<'a> {\n+    fn inner(&self) -> &'a u8 {\n+        self.0\n+    }\n+\n+    fn same_lifetime_as_parameter(&mut self, x: &'a u8) {\n+        self.0 = x;\n+    }\n+}\n+\n+impl X<'b> {\n+    fn inner_2(&self) -> &'b u8 {\n+        self.0\n+    }\n+\n+    fn reference_already_introduced_in_band_from_method_with_explicit_binders<'a>(\n+        &'b self, x: &'a u32\n+    ) {}\n+}\n+\n+struct Y<T>(T);\n+\n+impl Y<&'a u8> {\n+    fn inner(&self) -> &'a u8 {\n+        self.0\n+    }\n+}\n+\n+trait MyTrait<'a> {\n+    fn my_lifetime(&self) -> &'a u8;\n+    fn any_lifetime() -> &'b u8;\n+    fn borrowed_lifetime(&'b self) -> &'b u8;\n+    fn default_impl(&self, x: &'b u32, y: &u32) -> &'b u32 { x }\n+    fn in_band_def_explicit_impl(&self, x: &'b u8);\n+}\n+\n+impl MyTrait<'a> for Y<&'a u8> {\n+    fn my_lifetime(&self) -> &'a u8 { self.0 }\n+    fn any_lifetime() -> &'b u8 { &0 }\n+    fn borrowed_lifetime(&'b self) -> &'b u8 { &*self.0 }\n+    fn in_band_def_explicit_impl<'b>(&self, x: &'b u8) {}\n+}\n+\n+fn test_hrtb_defined_lifetime_where<F>(_: F) where for<'a> F: Fn(&'a u8) {}\n+fn test_hrtb_defined_lifetime_polytraitref<F>(_: F) where F: for<'a> Fn(&'a u8) {}\n+\n+fn reference_in_band_from_locals(x: &'test u32) -> &'test u32 {\n+    let y: &'test u32 = x;\n+    y\n+}\n+\n+fn in_generics_in_band<T: MyTrait<'a>>(x: &T) {}\n+fn where_clause_in_band<T>(x: &T) where T: MyTrait<'a> {}\n+fn impl_trait_in_band(x: &impl MyTrait<'a>) {}\n+\n+fn main() {}"}, {"sha": "57b355cbb6a3174338945684624af331522f8a60", "filename": "src/test/ui/in-band-lifetimes/E0687.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2FE0687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2FE0687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2FE0687.rs?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(warnings)]\n+#![feature(in_band_lifetimes)]\n+\n+fn foo(x: fn(&'a u32)) {}\n+\n+fn bar(x: &Fn(&'a u32)) {}\n+\n+fn baz(x: fn(&'a u32), y: &'a u32) {}\n+\n+struct Foo<'a> { x: &'a u32 }\n+\n+impl Foo<'a> {\n+    fn bar(&self, x: fn(&'a u32)) {}\n+}\n+\n+fn main() {}"}, {"sha": "14b513fc52aa2ab21105ed05cb650f8c15aa6f23", "filename": "src/test/ui/in-band-lifetimes/E0687.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2FE0687.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2FE0687.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2FE0687.stderr?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -0,0 +1,26 @@\n+error[E0687]: lifetimes used in `fn` or `Fn` syntax must be explicitly declared using `<...>` binders\n+  --> $DIR/E0687.rs:14:15\n+   |\n+14 | fn foo(x: fn(&'a u32)) {}\n+   |               ^^ in-band lifetime definition\n+\n+error[E0687]: lifetimes used in `fn` or `Fn` syntax must be explicitly declared using `<...>` binders\n+  --> $DIR/E0687.rs:16:16\n+   |\n+16 | fn bar(x: &Fn(&'a u32)) {}\n+   |                ^^ in-band lifetime definition\n+\n+error[E0687]: lifetimes used in `fn` or `Fn` syntax must be explicitly declared using `<...>` binders\n+  --> $DIR/E0687.rs:18:15\n+   |\n+18 | fn baz(x: fn(&'a u32), y: &'a u32) {}\n+   |               ^^ in-band lifetime definition\n+\n+error[E0687]: lifetimes used in `fn` or `Fn` syntax must be explicitly declared using `<...>` binders\n+  --> $DIR/E0687.rs:23:26\n+   |\n+23 |     fn bar(&self, x: fn(&'a u32)) {}\n+   |                          ^^ in-band lifetime definition\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "6f04720dd4ace59694451f48c8628c65ef772988", "filename": "src/test/ui/in-band-lifetimes/E0687_where.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2FE0687_where.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2FE0687_where.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2FE0687_where.rs?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(warnings)]\n+#![feature(in_band_lifetimes, universal_impl_trait)]\n+\n+fn bar<F>(x: &F) where F: Fn(&'a u32) {}\n+\n+fn baz(x: &impl Fn(&'a u32)) {}\n+\n+fn main() {}"}, {"sha": "db50076fe7c01539857a2075f42e81f701e571be", "filename": "src/test/ui/in-band-lifetimes/E0687_where.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2FE0687_where.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2FE0687_where.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2FE0687_where.stderr?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -0,0 +1,14 @@\n+error[E0687]: lifetimes used in `fn` or `Fn` syntax must be explicitly declared using `<...>` binders\n+  --> $DIR/E0687_where.rs:14:31\n+   |\n+14 | fn bar<F>(x: &F) where F: Fn(&'a u32) {}\n+   |                               ^^ in-band lifetime definition\n+\n+error[E0687]: lifetimes used in `fn` or `Fn` syntax must be explicitly declared using `<...>` binders\n+  --> $DIR/E0687_where.rs:16:21\n+   |\n+16 | fn baz(x: &impl Fn(&'a u32)) {}\n+   |                     ^^ in-band lifetime definition\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "e6fe4e138e4746bf49b5f4cc752170cc517f2581", "filename": "src/test/ui/in-band-lifetimes/E0688.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2FE0688.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2FE0688.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2FE0688.rs?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(warnings)]\n+#![feature(in_band_lifetimes)]\n+\n+fn foo<'a>(x: &'a u32, y: &'b u32) {}\n+\n+struct Foo<'a> { x: &'a u32 }\n+\n+impl Foo<'a> {\n+    fn bar<'b>(x: &'a u32, y: &'b u32, z: &'c u32) {}\n+}\n+\n+impl<'b> Foo<'a> {\n+    fn baz() {}\n+}\n+\n+fn main() {}"}, {"sha": "1289e7fd01039b3b8aecde94296012e194d1974c", "filename": "src/test/ui/in-band-lifetimes/E0688.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2FE0688.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2FE0688.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2FE0688.stderr?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -0,0 +1,26 @@\n+error[E0688]: cannot mix in-band and explicit lifetime definitions\n+  --> $DIR/E0688.rs:14:28\n+   |\n+14 | fn foo<'a>(x: &'a u32, y: &'b u32) {}\n+   |        --                  ^^ in-band lifetime definition here\n+   |        |\n+   |        explicit lifetime definition here\n+\n+error[E0688]: cannot mix in-band and explicit lifetime definitions\n+  --> $DIR/E0688.rs:19:44\n+   |\n+19 |     fn bar<'b>(x: &'a u32, y: &'b u32, z: &'c u32) {}\n+   |            --                              ^^ in-band lifetime definition here\n+   |            |\n+   |            explicit lifetime definition here\n+\n+error[E0688]: cannot mix in-band and explicit lifetime definitions\n+  --> $DIR/E0688.rs:22:14\n+   |\n+22 | impl<'b> Foo<'a> {\n+   |      --      ^^ in-band lifetime definition here\n+   |      |\n+   |      explicit lifetime definition here\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "6b0a3fedfc5cc946897dc744eb49dbf8cb4ca5f8", "filename": "src/test/ui/in-band-lifetimes/mismatched.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched.rs?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(warnings)]\n+#![feature(in_band_lifetimes)]\n+\n+fn foo(x: &'a u32, y: &u32) -> &'a u32 { y }\n+\n+fn foo2(x: &'a u32, y: &'b u32) -> &'a u32 { y }\n+\n+fn main() {}"}, {"sha": "bbc25869f46c06045231719ba7104a6ebd8482dd", "filename": "src/test/ui/in-band-lifetimes/mismatched.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched.stderr?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -0,0 +1,18 @@\n+error[E0621]: explicit lifetime required in the type of `y`\n+  --> $DIR/mismatched.rs:14:42\n+   |\n+14 | fn foo(x: &'a u32, y: &u32) -> &'a u32 { y }\n+   |                    -                     ^ lifetime `'a` required\n+   |                    |\n+   |                    consider changing the type of `y` to `&'a u32`\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/mismatched.rs:16:46\n+   |\n+16 | fn foo2(x: &'a u32, y: &'b u32) -> &'a u32 { y }\n+   |                        -------     -------   ^ ...but data from `y` is returned here\n+   |                        |\n+   |                        this parameter and the return type are declared with different lifetimes...\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "2e31677040425d217cb4b5c9c684270f4b12fb2b", "filename": "src/test/ui/in-band-lifetimes/mismatched_trait.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched_trait.rs?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(warnings)]\n+#![feature(in_band_lifetimes)]\n+\n+trait Get {\n+    fn baz(&self, x: &'a u32, y: &u32) -> &'a u32 {\n+        y\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "315e881bf0738f47d46b25f5c87132ef019dfcad", "filename": "src/test/ui/in-band-lifetimes/mismatched_trait.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched_trait.stderr?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -0,0 +1,10 @@\n+error[E0621]: explicit lifetime required in the type of `y`\n+  --> $DIR/mismatched_trait.rs:16:9\n+   |\n+15 |     fn baz(&self, x: &'a u32, y: &u32) -> &'a u32 {\n+   |                               - consider changing the type of `y` to `&'a u32`\n+16 |         y\n+   |         ^ lifetime `'a` required\n+\n+error: aborting due to previous error\n+"}, {"sha": "1be32e5c51e717bf7f63c3520bfcf06c682f4af7", "filename": "src/test/ui/in-band-lifetimes/mismatched_trait_impl.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched_trait_impl.rs?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(warnings)]\n+#![feature(in_band_lifetimes)]\n+\n+trait Get {\n+    fn foo(&self, x: &'a u32, y: &u32) -> &'a u32;\n+}\n+\n+impl Get for i32 {\n+    fn foo(&self, x: &u32, y: &'a u32) -> &'a u32 {\n+        x\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "d1f3ae450f8b0ab8af0dadc960f864b083e0d733", "filename": "src/test/ui/in-band-lifetimes/mismatched_trait_impl.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched_trait_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched_trait_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched_trait_impl.stderr?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -0,0 +1,39 @@\n+error[E0495]: cannot infer an appropriate lifetime for lifetime parameter 'a in generic type due to conflicting requirements\n+  --> $DIR/mismatched_trait_impl.rs:19:5\n+   |\n+19 | /     fn foo(&self, x: &u32, y: &'a u32) -> &'a u32 {\n+20 | |         x\n+21 | |     }\n+   | |_____^\n+   |\n+note: first, the lifetime cannot outlive the anonymous lifetime #2 defined on the method body at 19:5...\n+  --> $DIR/mismatched_trait_impl.rs:19:5\n+   |\n+19 | /     fn foo(&self, x: &u32, y: &'a u32) -> &'a u32 {\n+20 | |         x\n+21 | |     }\n+   | |_____^\n+note: ...so that method type is compatible with trait (expected fn(&i32, &'a u32, &u32) -> &'a u32, found fn(&i32, &u32, &u32) -> &u32)\n+  --> $DIR/mismatched_trait_impl.rs:19:5\n+   |\n+19 | /     fn foo(&self, x: &u32, y: &'a u32) -> &'a u32 {\n+20 | |         x\n+21 | |     }\n+   | |_____^\n+note: but, the lifetime must be valid for the lifetime 'a as defined on the method body at 19:5...\n+  --> $DIR/mismatched_trait_impl.rs:19:5\n+   |\n+19 | /     fn foo(&self, x: &u32, y: &'a u32) -> &'a u32 {\n+20 | |         x\n+21 | |     }\n+   | |_____^\n+note: ...so that method type is compatible with trait (expected fn(&i32, &'a u32, &u32) -> &'a u32, found fn(&i32, &u32, &u32) -> &u32)\n+  --> $DIR/mismatched_trait_impl.rs:19:5\n+   |\n+19 | /     fn foo(&self, x: &u32, y: &'a u32) -> &'a u32 {\n+20 | |         x\n+21 | |     }\n+   | |_____^\n+\n+error: aborting due to previous error\n+"}, {"sha": "fabf531968a4c031da4e979e75b6476e64c38a5e", "filename": "src/test/ui/in-band-lifetimes/mut_while_borrow.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmut_while_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmut_while_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmut_while_borrow.rs?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(warnings)]\n+#![feature(in_band_lifetimes)]\n+\n+fn foo(x: &'a u32) -> &'a u32 { x }\n+\n+fn main() {\n+    let mut p = 3;\n+    let r = foo(&p);\n+    p += 1;\n+    println!(\"{}\", r);\n+}"}, {"sha": "4800e39269f0a5756b7e3f3305e3584beddfdd32", "filename": "src/test/ui/in-band-lifetimes/mut_while_borrow.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmut_while_borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmut_while_borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmut_while_borrow.stderr?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -0,0 +1,10 @@\n+error[E0506]: cannot assign to `p` because it is borrowed\n+  --> $DIR/mut_while_borrow.rs:19:5\n+   |\n+18 |     let r = foo(&p);\n+   |                  - borrow of `p` occurs here\n+19 |     p += 1;\n+   |     ^^^^^^ assignment to borrowed `p` occurs here\n+\n+error: aborting due to previous error\n+"}, {"sha": "b421e16092c2b48bdebc3824736fa8ed76a4074a", "filename": "src/test/ui/in-band-lifetimes/no_in_band_in_struct.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fno_in_band_in_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fno_in_band_in_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fno_in_band_in_struct.rs?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(warnings)]\n+#![feature(in_band_lifetimes)]\n+\n+struct Foo {\n+    x: &'test u32,\n+}\n+\n+enum Bar {\n+    Baz(&'test u32),\n+}\n+\n+fn main() {}"}, {"sha": "7ffbfbd89b672531bf94a22e7248221828d5191a", "filename": "src/test/ui/in-band-lifetimes/no_in_band_in_struct.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fno_in_band_in_struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fno_in_band_in_struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fno_in_band_in_struct.stderr?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -0,0 +1,14 @@\n+error[E0261]: use of undeclared lifetime name `'test`\n+  --> $DIR/no_in_band_in_struct.rs:15:9\n+   |\n+15 |     x: &'test u32,\n+   |         ^^^^^ undeclared lifetime\n+\n+error[E0261]: use of undeclared lifetime name `'test`\n+  --> $DIR/no_in_band_in_struct.rs:19:10\n+   |\n+19 |     Baz(&'test u32),\n+   |          ^^^^^ undeclared lifetime\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "a7c9d4ece9569e3c584a7295e42494cde3f376d6", "filename": "src/test/ui/in-band-lifetimes/no_introducing_in_band_in_locals.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fno_introducing_in_band_in_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fno_introducing_in_band_in_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fno_introducing_in_band_in_locals.rs?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(warnings)]\n+#![feature(in_band_lifetimes)]\n+\n+fn foo(x: &u32) {\n+    let y: &'test u32 = x;\n+}\n+\n+fn foo2(x: &u32) {}\n+fn bar() {\n+    let y: fn(&'test u32) = foo2;\n+}\n+\n+fn main() {}"}, {"sha": "a0c2e8199694a045f752e8f61bb4ac60308eb4d6", "filename": "src/test/ui/in-band-lifetimes/no_introducing_in_band_in_locals.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fno_introducing_in_band_in_locals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fno_introducing_in_band_in_locals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fno_introducing_in_band_in_locals.stderr?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -0,0 +1,14 @@\n+error[E0261]: use of undeclared lifetime name `'test`\n+  --> $DIR/no_introducing_in_band_in_locals.rs:15:13\n+   |\n+15 |     let y: &'test u32 = x;\n+   |             ^^^^^ undeclared lifetime\n+\n+error[E0261]: use of undeclared lifetime name `'test`\n+  --> $DIR/no_introducing_in_band_in_locals.rs:20:16\n+   |\n+20 |     let y: fn(&'test u32) = foo2;\n+   |                ^^^^^ undeclared lifetime\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "a9053d09f6c60499e94527d31acc86ec485117f5", "filename": "src/test/ui/in-band-lifetimes/shadow.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fshadow.rs?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(warnings)]\n+#![feature(in_band_lifetimes)]\n+\n+struct Foo<T>(T);\n+\n+impl Foo<&'s u8> {\n+    fn bar<'s>(&self, x: &'s u8) {}\n+    fn baz(x: for<'s> fn(&'s u32)) {}\n+}\n+\n+fn main() {}"}, {"sha": "f05b76fbea4c564471a9e2778401de43e3de1985", "filename": "src/test/ui/in-band-lifetimes/shadow.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fshadow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91b7920c09004ed4dcbad0ab4128a664ca794848/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fshadow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fshadow.stderr?ref=91b7920c09004ed4dcbad0ab4128a664ca794848", "patch": "@@ -0,0 +1,19 @@\n+error[E0496]: lifetime name `'s` shadows a lifetime name that is already in scope\n+  --> $DIR/shadow.rs:17:12\n+   |\n+16 | impl Foo<&'s u8> {\n+   |           -- first declared here\n+17 |     fn bar<'s>(&self, x: &'s u8) {}\n+   |            ^^ lifetime 's already in scope\n+\n+error[E0496]: lifetime name `'s` shadows a lifetime name that is already in scope\n+  --> $DIR/shadow.rs:18:19\n+   |\n+16 | impl Foo<&'s u8> {\n+   |           -- first declared here\n+17 |     fn bar<'s>(&self, x: &'s u8) {}\n+18 |     fn baz(x: for<'s> fn(&'s u32)) {}\n+   |                   ^^ lifetime 's already in scope\n+\n+error: aborting due to 2 previous errors\n+"}]}