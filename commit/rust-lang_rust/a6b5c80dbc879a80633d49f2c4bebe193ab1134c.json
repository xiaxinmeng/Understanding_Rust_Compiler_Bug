{"sha": "a6b5c80dbc879a80633d49f2c4bebe193ab1134c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2YjVjODBkYmM4NzlhODA2MzNkNDlmMmM0YmViZTE5M2FiMTEzNGM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-19T14:00:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-19T14:00:53Z"}, "message": "Rollup merge of #65226 - ssomers:master, r=bluss\n\nBTreeSet symmetric_difference & union optimized\n\nNo scalability changes, but:\n- Grew the cmp_opt function (shared by symmetric_difference & union) into a MergeIter, with less memory overhead than the pairs of Peekable iterators now, speeding up ~20% on my machine (not so clear on Travis though, I actually switched it off there because it wasn't consistent about identical code). Mainly meant to improve readability by sharing code, though it does end up using more lines of code. Extending and reusing the MergeIter in btree_map might be better, but I'm not sure that's possible or desirable. This MergeIter probably pretends to be more generic than it is, yet doesn't declare to be an iterator because there's no need to, it's only there to help construct genuine iterators SymmetricDifference & Union.\n- Compact the code of #64820 by moving if/else into match guards.\n\nr? @bluss", "tree": {"sha": "0671b311bad8e30f076e9f864d0f6ccf43793d93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0671b311bad8e30f076e9f864d0f6ccf43793d93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6b5c80dbc879a80633d49f2c4bebe193ab1134c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdqxcVCRBK7hj4Ov3rIwAAdHIIAFwf3BQDUWk3Wr3Z9tbO0b6s\nA2fdaV7j9uDcpssMa2sDpieOkTOiedlZ5imTgOT5FJHen4mFW0t9y/kiieD3ECcF\nCCTgLzJ+qCKfdZOzueQ7ZoaVjPikXa4LDtElIRl4NOV30oIQi80mzuuMWTeOBilu\nrbnsyjATu6+5ci6pJW87eu/DLEb9X9tBWpsg5bV/HTXiGhxGLJhl86AySuKtRqoF\nudoodQo0qngcg6Pmi3iaNWjdrA5iPkLPBcA64aFHD3uKegnAwVMEIXQ8kFh5DHWh\nNCDe3Tyfy/dAq2Y9tHs4zyZ8Ns2KB7wIWhjU/eST7kg3VGvO74LyR6DGA0WWN6o=\n=PZ81\n-----END PGP SIGNATURE-----\n", "payload": "tree 0671b311bad8e30f076e9f864d0f6ccf43793d93\nparent 7e4ff91403dd4752cc643e9dff55d93076e4802c\nparent 56974329d1eab8dd990d53b6cd6978bbf6a615b7\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1571493653 +0200\ncommitter GitHub <noreply@github.com> 1571493653 +0200\n\nRollup merge of #65226 - ssomers:master, r=bluss\n\nBTreeSet symmetric_difference & union optimized\n\nNo scalability changes, but:\n- Grew the cmp_opt function (shared by symmetric_difference & union) into a MergeIter, with less memory overhead than the pairs of Peekable iterators now, speeding up ~20% on my machine (not so clear on Travis though, I actually switched it off there because it wasn't consistent about identical code). Mainly meant to improve readability by sharing code, though it does end up using more lines of code. Extending and reusing the MergeIter in btree_map might be better, but I'm not sure that's possible or desirable. This MergeIter probably pretends to be more generic than it is, yet doesn't declare to be an iterator because there's no need to, it's only there to help construct genuine iterators SymmetricDifference & Union.\n- Compact the code of #64820 by moving if/else into match guards.\n\nr? @bluss\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6b5c80dbc879a80633d49f2c4bebe193ab1134c", "html_url": "https://github.com/rust-lang/rust/commit/a6b5c80dbc879a80633d49f2c4bebe193ab1134c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6b5c80dbc879a80633d49f2c4bebe193ab1134c/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e4ff91403dd4752cc643e9dff55d93076e4802c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e4ff91403dd4752cc643e9dff55d93076e4802c", "html_url": "https://github.com/rust-lang/rust/commit/7e4ff91403dd4752cc643e9dff55d93076e4802c"}, {"sha": "56974329d1eab8dd990d53b6cd6978bbf6a615b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/56974329d1eab8dd990d53b6cd6978bbf6a615b7", "html_url": "https://github.com/rust-lang/rust/commit/56974329d1eab8dd990d53b6cd6978bbf6a615b7"}], "stats": {"total": 265, "additions": 144, "deletions": 121}, "files": [{"sha": "f0796354e00c384076f8a47a59f62b849556cd1e", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 119, "deletions": 120, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/a6b5c80dbc879a80633d49f2c4bebe193ab1134c/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6b5c80dbc879a80633d49f2c4bebe193ab1134c/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=a6b5c80dbc879a80633d49f2c4bebe193ab1134c", "patch": "@@ -2,7 +2,7 @@\n // to TreeMap\n \n use core::borrow::Borrow;\n-use core::cmp::Ordering::{self, Less, Greater, Equal};\n+use core::cmp::Ordering::{Less, Greater, Equal};\n use core::cmp::{max, min};\n use core::fmt::{self, Debug};\n use core::iter::{Peekable, FromIterator, FusedIterator};\n@@ -109,6 +109,77 @@ pub struct Range<'a, T: 'a> {\n     iter: btree_map::Range<'a, T, ()>,\n }\n \n+/// Core of SymmetricDifference and Union.\n+/// More efficient than btree.map.MergeIter,\n+/// and crucially for SymmetricDifference, nexts() reports on both sides.\n+#[derive(Clone)]\n+struct MergeIterInner<I>\n+    where I: Iterator,\n+          I::Item: Copy,\n+{\n+    a: I,\n+    b: I,\n+    peeked: Option<MergeIterPeeked<I>>,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+enum MergeIterPeeked<I: Iterator> {\n+    A(I::Item),\n+    B(I::Item),\n+}\n+\n+impl<I> MergeIterInner<I>\n+    where I: ExactSizeIterator + FusedIterator,\n+          I::Item: Copy + Ord,\n+{\n+    fn new(a: I, b: I) -> Self {\n+        MergeIterInner { a, b, peeked: None }\n+    }\n+\n+    fn nexts(&mut self) -> (Option<I::Item>, Option<I::Item>) {\n+        let mut a_next = match self.peeked {\n+            Some(MergeIterPeeked::A(next)) => Some(next),\n+            _ => self.a.next(),\n+        };\n+        let mut b_next = match self.peeked {\n+            Some(MergeIterPeeked::B(next)) => Some(next),\n+            _ => self.b.next(),\n+        };\n+        let ord = match (a_next, b_next) {\n+            (None, None) => Equal,\n+            (_, None) => Less,\n+            (None, _) => Greater,\n+            (Some(a1), Some(b1)) => a1.cmp(&b1),\n+        };\n+        self.peeked = match ord {\n+            Less => b_next.take().map(MergeIterPeeked::B),\n+            Equal => None,\n+            Greater => a_next.take().map(MergeIterPeeked::A),\n+        };\n+        (a_next, b_next)\n+    }\n+\n+    fn lens(&self) -> (usize, usize) {\n+        match self.peeked {\n+            Some(MergeIterPeeked::A(_)) => (1 + self.a.len(), self.b.len()),\n+            Some(MergeIterPeeked::B(_)) => (self.a.len(), 1 + self.b.len()),\n+            _ => (self.a.len(), self.b.len()),\n+        }\n+    }\n+}\n+\n+impl<I> Debug for MergeIterInner<I>\n+    where I: Iterator + Debug,\n+          I::Item: Copy + Debug,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"MergeIterInner\")\n+            .field(&self.a)\n+            .field(&self.b)\n+            .finish()\n+    }\n+}\n+\n /// A lazy iterator producing elements in the difference of `BTreeSet`s.\n ///\n /// This `struct` is created by the [`difference`] method on [`BTreeSet`].\n@@ -120,6 +191,7 @@ pub struct Range<'a, T: 'a> {\n pub struct Difference<'a, T: 'a> {\n     inner: DifferenceInner<'a, T>,\n }\n+#[derive(Debug)]\n enum DifferenceInner<'a, T: 'a> {\n     Stitch {\n         // iterate all of self and some of other, spotting matches along the way\n@@ -137,21 +209,7 @@ enum DifferenceInner<'a, T: 'a> {\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Difference<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match &self.inner {\n-            DifferenceInner::Stitch {\n-                self_iter,\n-                other_iter,\n-            } => f\n-                .debug_tuple(\"Difference\")\n-                .field(&self_iter)\n-                .field(&other_iter)\n-                .finish(),\n-            DifferenceInner::Search {\n-                self_iter,\n-                other_set: _,\n-            } => f.debug_tuple(\"Difference\").field(&self_iter).finish(),\n-            DifferenceInner::Iterate(iter) => f.debug_tuple(\"Difference\").field(&iter).finish(),\n-        }\n+        f.debug_tuple(\"Difference\").field(&self.inner).finish()\n     }\n }\n \n@@ -163,18 +221,12 @@ impl<T: fmt::Debug> fmt::Debug for Difference<'_, T> {\n /// [`BTreeSet`]: struct.BTreeSet.html\n /// [`symmetric_difference`]: struct.BTreeSet.html#method.symmetric_difference\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SymmetricDifference<'a, T: 'a> {\n-    a: Peekable<Iter<'a, T>>,\n-    b: Peekable<Iter<'a, T>>,\n-}\n+pub struct SymmetricDifference<'a, T: 'a>(MergeIterInner<Iter<'a, T>>);\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for SymmetricDifference<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"SymmetricDifference\")\n-         .field(&self.a)\n-         .field(&self.b)\n-         .finish()\n+        f.debug_tuple(\"SymmetricDifference\").field(&self.0).finish()\n     }\n }\n \n@@ -189,6 +241,7 @@ impl<T: fmt::Debug> fmt::Debug for SymmetricDifference<'_, T> {\n pub struct Intersection<'a, T: 'a> {\n     inner: IntersectionInner<'a, T>,\n }\n+#[derive(Debug)]\n enum IntersectionInner<'a, T: 'a> {\n     Stitch {\n         // iterate similarly sized sets jointly, spotting matches along the way\n@@ -206,23 +259,7 @@ enum IntersectionInner<'a, T: 'a> {\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Intersection<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match &self.inner {\n-            IntersectionInner::Stitch {\n-                a,\n-                b,\n-            } => f\n-                .debug_tuple(\"Intersection\")\n-                .field(&a)\n-                .field(&b)\n-                .finish(),\n-            IntersectionInner::Search {\n-                small_iter,\n-                large_set: _,\n-            } => f.debug_tuple(\"Intersection\").field(&small_iter).finish(),\n-            IntersectionInner::Answer(answer) => {\n-                f.debug_tuple(\"Intersection\").field(&answer).finish()\n-            }\n-        }\n+        f.debug_tuple(\"Intersection\").field(&self.inner).finish()\n     }\n }\n \n@@ -234,18 +271,12 @@ impl<T: fmt::Debug> fmt::Debug for Intersection<'_, T> {\n /// [`BTreeSet`]: struct.BTreeSet.html\n /// [`union`]: struct.BTreeSet.html#method.union\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Union<'a, T: 'a> {\n-    a: Peekable<Iter<'a, T>>,\n-    b: Peekable<Iter<'a, T>>,\n-}\n+pub struct Union<'a, T: 'a>(MergeIterInner<Iter<'a, T>>);\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Union<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"Union\")\n-         .field(&self.a)\n-         .field(&self.b)\n-         .finish()\n+        f.debug_tuple(\"Union\").field(&self.0).finish()\n     }\n }\n \n@@ -355,19 +386,16 @@ impl<T: Ord> BTreeSet<T> {\n                     self_iter.next_back();\n                     DifferenceInner::Iterate(self_iter)\n                 }\n-                _ => {\n-                    if self.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n-                        DifferenceInner::Search {\n-                            self_iter: self.iter(),\n-                            other_set: other,\n-                        }\n-                    } else {\n-                        DifferenceInner::Stitch {\n-                            self_iter: self.iter(),\n-                            other_iter: other.iter().peekable(),\n-                        }\n+                _ if self.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF => {\n+                    DifferenceInner::Search {\n+                        self_iter: self.iter(),\n+                        other_set: other,\n                     }\n                 }\n+                _ => DifferenceInner::Stitch {\n+                    self_iter: self.iter(),\n+                    other_iter: other.iter().peekable(),\n+                },\n             },\n         }\n     }\n@@ -396,10 +424,7 @@ impl<T: Ord> BTreeSet<T> {\n     pub fn symmetric_difference<'a>(&'a self,\n                                     other: &'a BTreeSet<T>)\n                                     -> SymmetricDifference<'a, T> {\n-        SymmetricDifference {\n-            a: self.iter().peekable(),\n-            b: other.iter().peekable(),\n-        }\n+        SymmetricDifference(MergeIterInner::new(self.iter(), other.iter()))\n     }\n \n     /// Visits the values representing the intersection,\n@@ -447,24 +472,22 @@ impl<T: Ord> BTreeSet<T> {\n                 (Greater, _) | (_, Less) => IntersectionInner::Answer(None),\n                 (Equal, _) => IntersectionInner::Answer(Some(self_min)),\n                 (_, Equal) => IntersectionInner::Answer(Some(self_max)),\n-                _ => {\n-                    if self.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n-                        IntersectionInner::Search {\n-                            small_iter: self.iter(),\n-                            large_set: other,\n-                        }\n-                    } else if other.len() <= self.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n-                        IntersectionInner::Search {\n-                            small_iter: other.iter(),\n-                            large_set: self,\n-                        }\n-                    } else {\n-                        IntersectionInner::Stitch {\n-                            a: self.iter(),\n-                            b: other.iter(),\n-                        }\n+                _ if self.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF => {\n+                    IntersectionInner::Search {\n+                        small_iter: self.iter(),\n+                        large_set: other,\n+                    }\n+                }\n+                _ if other.len() <= self.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF => {\n+                    IntersectionInner::Search {\n+                        small_iter: other.iter(),\n+                        large_set: self,\n                     }\n                 }\n+                _ => IntersectionInner::Stitch {\n+                    a: self.iter(),\n+                    b: other.iter(),\n+                },\n             },\n         }\n     }\n@@ -489,10 +512,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T> {\n-        Union {\n-            a: self.iter().peekable(),\n-            b: other.iter().peekable(),\n-        }\n+        Union(MergeIterInner::new(self.iter(), other.iter()))\n     }\n \n     /// Clears the set, removing all values.\n@@ -1166,15 +1186,6 @@ impl<'a, T> DoubleEndedIterator for Range<'a, T> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for Range<'_, T> {}\n \n-/// Compares `x` and `y`, but return `short` if x is None and `long` if y is None\n-fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>, short: Ordering, long: Ordering) -> Ordering {\n-    match (x, y) {\n-        (None, _) => short,\n-        (_, None) => long,\n-        (Some(x1), Some(y1)) => x1.cmp(y1),\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Difference<'_, T> {\n     fn clone(&self) -> Self {\n@@ -1261,10 +1272,7 @@ impl<T: Ord> FusedIterator for Difference<'_, T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for SymmetricDifference<'_, T> {\n     fn clone(&self) -> Self {\n-        SymmetricDifference {\n-            a: self.a.clone(),\n-            b: self.b.clone(),\n-        }\n+        SymmetricDifference(self.0.clone())\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1273,19 +1281,19 @@ impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n \n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n-            match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n-                Less => return self.a.next(),\n-                Equal => {\n-                    self.a.next();\n-                    self.b.next();\n-                }\n-                Greater => return self.b.next(),\n+            let (a_next, b_next) = self.0.nexts();\n+            if a_next.and(b_next).is_none() {\n+                return a_next.or(b_next);\n             }\n         }\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        (0, Some(self.a.len() + self.b.len()))\n+        let (a_len, b_len) = self.0.lens();\n+        // No checked_add, because even if a and b refer to the same set,\n+        // and T is an empty type, the storage overhead of sets limits\n+        // the number of elements to less than half the range of usize.\n+        (0, Some(a_len + b_len))\n     }\n }\n \n@@ -1311,7 +1319,7 @@ impl<T> Clone for Intersection<'_, T> {\n                     small_iter: small_iter.clone(),\n                     large_set,\n                 },\n-                IntersectionInner::Answer(answer) => IntersectionInner::Answer(answer.clone()),\n+                IntersectionInner::Answer(answer) => IntersectionInner::Answer(*answer),\n             },\n         }\n     }\n@@ -1365,30 +1373,21 @@ impl<T: Ord> FusedIterator for Intersection<'_, T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Union<'_, T> {\n     fn clone(&self) -> Self {\n-        Union {\n-            a: self.a.clone(),\n-            b: self.b.clone(),\n-        }\n+        Union(self.0.clone())\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Ord> Iterator for Union<'a, T> {\n     type Item = &'a T;\n \n     fn next(&mut self) -> Option<&'a T> {\n-        match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n-            Less => self.a.next(),\n-            Equal => {\n-                self.b.next();\n-                self.a.next()\n-            }\n-            Greater => self.b.next(),\n-        }\n+        let (a_next, b_next) = self.0.nexts();\n+        a_next.or(b_next)\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let a_len = self.a.len();\n-        let b_len = self.b.len();\n+        let (a_len, b_len) = self.0.lens();\n+        // No checked_add - see SymmetricDifference::size_hint.\n         (max(a_len, b_len), Some(a_len + b_len))\n     }\n }"}, {"sha": "e4883abc8b56c3362d1fd4726f0d73746f430971", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a6b5c80dbc879a80633d49f2c4bebe193ab1134c/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6b5c80dbc879a80633d49f2c4bebe193ab1134c/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=a6b5c80dbc879a80633d49f2c4bebe193ab1134c", "patch": "@@ -221,6 +221,18 @@ fn test_symmetric_difference() {\n                                &[-2, 1, 5, 11, 14, 22]);\n }\n \n+#[test]\n+fn test_symmetric_difference_size_hint() {\n+    let x: BTreeSet<i32> = [2, 4].iter().copied().collect();\n+    let y: BTreeSet<i32> = [1, 2, 3].iter().copied().collect();\n+    let mut iter = x.symmetric_difference(&y);\n+    assert_eq!(iter.size_hint(), (0, Some(5)));\n+    assert_eq!(iter.next(), Some(&1));\n+    assert_eq!(iter.size_hint(), (0, Some(4)));\n+    assert_eq!(iter.next(), Some(&3));\n+    assert_eq!(iter.size_hint(), (0, Some(1)));\n+}\n+\n #[test]\n fn test_union() {\n     fn check_union(a: &[i32], b: &[i32], expected: &[i32]) {\n@@ -235,6 +247,18 @@ fn test_union() {\n                 &[-2, 1, 3, 5, 9, 11, 13, 16, 19, 24]);\n }\n \n+#[test]\n+fn test_union_size_hint() {\n+    let x: BTreeSet<i32> = [2, 4].iter().copied().collect();\n+    let y: BTreeSet<i32> = [1, 2, 3].iter().copied().collect();\n+    let mut iter = x.union(&y);\n+    assert_eq!(iter.size_hint(), (3, Some(5)));\n+    assert_eq!(iter.next(), Some(&1));\n+    assert_eq!(iter.size_hint(), (2, Some(4)));\n+    assert_eq!(iter.next(), Some(&2));\n+    assert_eq!(iter.size_hint(), (1, Some(2)));\n+}\n+\n #[test]\n // Only tests the simple function definition with respect to intersection\n fn test_is_disjoint() {\n@@ -244,7 +268,7 @@ fn test_is_disjoint() {\n }\n \n #[test]\n-// Also tests the trivial function definition of is_superset\n+// Also implicitly tests the trivial function definition of is_superset\n fn test_is_subset() {\n     fn is_subset(a: &[i32], b: &[i32]) -> bool {\n         let set_a = a.iter().collect::<BTreeSet<_>>();"}]}