{"sha": "eb82facb1626166188d49599a3313fc95201f556", "node_id": "C_kwDOAAsO6NoAKGViODJmYWNiMTYyNjE2NjE4OGQ0OTU5OWEzMzEzZmM5NTIwMWY1NTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-01T21:16:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-01T21:16:41Z"}, "message": "Auto merge of #94883 - cjgillot:flat-metadata, r=oli-obk\n\nEncode even more metadata through tables instead of EntryKind\n\nThis should move us closer to getting rid of `EntryKind`.", "tree": {"sha": "cbccff501be86be4d6106d0544369909f896e413", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbccff501be86be4d6106d0544369909f896e413"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb82facb1626166188d49599a3313fc95201f556", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb82facb1626166188d49599a3313fc95201f556", "html_url": "https://github.com/rust-lang/rust/commit/eb82facb1626166188d49599a3313fc95201f556", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb82facb1626166188d49599a3313fc95201f556/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "297a8018b525c28ef10ee6a91d61954839b508b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/297a8018b525c28ef10ee6a91d61954839b508b9", "html_url": "https://github.com/rust-lang/rust/commit/297a8018b525c28ef10ee6a91d61954839b508b9"}, {"sha": "15b2d1a97c9cefe41bcb61d5faef5682c112172a", "url": "https://api.github.com/repos/rust-lang/rust/commits/15b2d1a97c9cefe41bcb61d5faef5682c112172a", "html_url": "https://github.com/rust-lang/rust/commit/15b2d1a97c9cefe41bcb61d5faef5682c112172a"}], "stats": {"total": 343, "additions": 131, "deletions": 212}, "files": [{"sha": "19a543ae777f046045b494e3f68c23649522fa6d", "filename": "compiler/rustc_const_eval/src/const_eval/fn_queries.rs", "status": "modified", "additions": 35, "deletions": 31, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/eb82facb1626166188d49599a3313fc95201f556/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb82facb1626166188d49599a3313fc95201f556/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs?ref=eb82facb1626166188d49599a3313fc95201f556", "patch": "@@ -1,7 +1,8 @@\n use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{DefIdTree, TyCtxt};\n use rustc_span::symbol::Symbol;\n use rustc_target::spec::abi::Abi;\n \n@@ -16,44 +17,47 @@ pub fn is_unstable_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Symbol> {\n }\n \n pub fn is_parent_const_impl_raw(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-    let parent_id = tcx.hir().get_parent_node(hir_id);\n-    matches!(\n-        tcx.hir().get(parent_id),\n-        hir::Node::Item(hir::Item {\n-            kind: hir::ItemKind::Impl(hir::Impl { constness: hir::Constness::Const, .. }),\n-            ..\n-        })\n-    )\n+    let parent_id = tcx.local_parent(def_id).unwrap();\n+    tcx.def_kind(parent_id) == DefKind::Impl\n+        && tcx.impl_constness(parent_id) == hir::Constness::Const\n }\n \n /// Checks whether the function has a `const` modifier or, in case it is an intrinsic, whether\n /// said intrinsic has a `rustc_const_{un,}stable` attribute.\n-fn is_const_fn_raw(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+fn impl_constness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::Constness {\n     let def_id = def_id.expect_local();\n     let node = tcx.hir().get_by_def_id(def_id);\n \n-    if let hir::Node::ForeignItem(hir::ForeignItem { kind: hir::ForeignItemKind::Fn(..), .. }) =\n-        node\n-    {\n-        // Intrinsics use `rustc_const_{un,}stable` attributes to indicate constness. All other\n-        // foreign items cannot be evaluated at compile-time.\n-        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-        if let Abi::RustIntrinsic | Abi::PlatformIntrinsic = tcx.hir().get_foreign_abi(hir_id) {\n-            tcx.lookup_const_stability(def_id).is_some()\n-        } else {\n-            false\n-        }\n-    } else if let Some(fn_kind) = node.fn_kind() {\n-        if fn_kind.constness() == hir::Constness::Const {\n-            return true;\n+    match node {\n+        hir::Node::Ctor(_) => hir::Constness::Const,\n+        hir::Node::Item(hir::Item { kind: hir::ItemKind::Impl(impl_), .. }) => impl_.constness,\n+        hir::Node::ForeignItem(hir::ForeignItem { kind: hir::ForeignItemKind::Fn(..), .. }) => {\n+            // Intrinsics use `rustc_const_{un,}stable` attributes to indicate constness. All other\n+            // foreign items cannot be evaluated at compile-time.\n+            let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+            let is_const = if let Abi::RustIntrinsic | Abi::PlatformIntrinsic =\n+                tcx.hir().get_foreign_abi(hir_id)\n+            {\n+                tcx.lookup_const_stability(def_id).is_some()\n+            } else {\n+                false\n+            };\n+            if is_const { hir::Constness::Const } else { hir::Constness::NotConst }\n         }\n+        _ => {\n+            if let Some(fn_kind) = node.fn_kind() {\n+                if fn_kind.constness() == hir::Constness::Const {\n+                    return hir::Constness::Const;\n+                }\n \n-        // If the function itself is not annotated with `const`, it may still be a `const fn`\n-        // if it resides in a const trait impl.\n-        is_parent_const_impl_raw(tcx, def_id)\n-    } else {\n-        matches!(node, hir::Node::Ctor(_))\n+                // If the function itself is not annotated with `const`, it may still be a `const fn`\n+                // if it resides in a const trait impl.\n+                let is_const = is_parent_const_impl_raw(tcx, def_id);\n+                if is_const { hir::Constness::Const } else { hir::Constness::NotConst }\n+            } else {\n+                hir::Constness::NotConst\n+            }\n+        }\n     }\n }\n \n@@ -77,5 +81,5 @@ fn is_promotable_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n }\n \n pub fn provide(providers: &mut Providers) {\n-    *providers = Providers { is_const_fn_raw, is_promotable_const_fn, ..*providers };\n+    *providers = Providers { impl_constness, is_promotable_const_fn, ..*providers };\n }"}, {"sha": "046322a42d85b9fb8eac559c722fd27187cf9724", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 11, "deletions": 55, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/eb82facb1626166188d49599a3313fc95201f556/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb82facb1626166188d49599a3313fc95201f556/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=eb82facb1626166188d49599a3313fc95201f556", "patch": "@@ -14,7 +14,6 @@ use rustc_data_structures::sync::{Lock, LockGuard, Lrc, OnceCell};\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_expand::base::{SyntaxExtension, SyntaxExtensionKind};\n use rustc_expand::proc_macro::{AttrProcMacro, BangProcMacro, ProcMacroDerive};\n-use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPath, DefPathData, DefPathHash};\n@@ -909,40 +908,9 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         )\n     }\n \n-    fn get_trait_def(self, item_id: DefIndex, sess: &Session) -> ty::TraitDef {\n-        match self.kind(item_id) {\n-            EntryKind::Trait(data) => {\n-                let data = data.decode((self, sess));\n-                ty::TraitDef::new(\n-                    self.local_def_id(item_id),\n-                    data.unsafety,\n-                    data.paren_sugar,\n-                    data.has_auto_impl,\n-                    data.is_marker,\n-                    data.skip_array_during_method_dispatch,\n-                    data.specialization_kind,\n-                    self.def_path_hash(item_id),\n-                    data.must_implement_one_of,\n-                )\n-            }\n-            EntryKind::TraitAlias => ty::TraitDef::new(\n-                self.local_def_id(item_id),\n-                hir::Unsafety::Normal,\n-                false,\n-                false,\n-                false,\n-                false,\n-                ty::trait_def::TraitSpecializationKind::None,\n-                self.def_path_hash(item_id),\n-                None,\n-            ),\n-            _ => bug!(\"def-index does not refer to trait or trait alias\"),\n-        }\n-    }\n-\n     fn get_variant(self, kind: &EntryKind, index: DefIndex, parent_did: DefId) -> ty::VariantDef {\n         let data = match kind {\n-            EntryKind::Variant(data) | EntryKind::Struct(data, _) | EntryKind::Union(data, _) => {\n+            EntryKind::Variant(data) | EntryKind::Struct(data) | EntryKind::Union(data) => {\n                 data.decode(self)\n             }\n             _ => bug!(),\n@@ -988,12 +956,13 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         let kind = self.kind(item_id);\n         let did = self.local_def_id(item_id);\n \n-        let (adt_kind, repr) = match kind {\n-            EntryKind::Enum(repr) => (ty::AdtKind::Enum, repr),\n-            EntryKind::Struct(_, repr) => (ty::AdtKind::Struct, repr),\n-            EntryKind::Union(_, repr) => (ty::AdtKind::Union, repr),\n+        let adt_kind = match kind {\n+            EntryKind::Enum => ty::AdtKind::Enum,\n+            EntryKind::Struct(_) => ty::AdtKind::Struct,\n+            EntryKind::Union(_) => ty::AdtKind::Union,\n             _ => bug!(\"get_adt_def called on a non-ADT {:?}\", did),\n         };\n+        let repr = self.root.tables.repr_options.get(self, item_id).unwrap().decode(self);\n \n         let variants = if let ty::AdtKind::Enum = adt_kind {\n             self.root\n@@ -1171,7 +1140,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                     callback(exp);\n                 }\n             }\n-            EntryKind::Enum(..) | EntryKind::Trait(..) => {}\n+            EntryKind::Enum | EntryKind::Trait => {}\n             _ => bug!(\"`for_each_module_child` is called on a non-module: {:?}\", self.def_kind(id)),\n         }\n     }\n@@ -1186,7 +1155,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n     fn module_expansion(self, id: DefIndex, sess: &Session) -> ExpnId {\n         match self.kind(id) {\n-            EntryKind::Mod(_) | EntryKind::Enum(_) | EntryKind::Trait(_) => {\n+            EntryKind::Mod(_) | EntryKind::Enum | EntryKind::Trait => {\n                 self.get_expn_that_defined(id, sess)\n             }\n             _ => panic!(\"Expected module, found {:?}\", self.local_def_id(id)),\n@@ -1239,7 +1208,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n     fn get_ctor_def_id_and_kind(self, node_id: DefIndex) -> Option<(DefId, CtorKind)> {\n         match self.kind(node_id) {\n-            EntryKind::Struct(data, _) | EntryKind::Variant(data) => {\n+            EntryKind::Struct(data) | EntryKind::Variant(data) => {\n                 let vdata = data.decode(self);\n                 vdata.ctor.map(|index| (self.local_def_id(index), vdata.ctor_kind))\n             }\n@@ -1395,7 +1364,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             _ => return None,\n         }\n         def_key.parent.and_then(|parent_index| match self.kind(parent_index) {\n-            EntryKind::Trait(_) | EntryKind::TraitAlias => Some(self.local_def_id(parent_index)),\n+            EntryKind::Trait | EntryKind::TraitAlias => Some(self.local_def_id(parent_index)),\n             _ => None,\n         })\n     }\n@@ -1449,22 +1418,9 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    // This replicates some of the logic of the crate-local `is_const_fn_raw` query, because we\n-    // don't serialize constness for tuple variant and tuple struct constructors.\n-    fn is_const_fn_raw(self, id: DefIndex) -> bool {\n-        let constness = match self.kind(id) {\n-            EntryKind::AssocFn(data) => data.decode(self).fn_data.constness,\n-            EntryKind::Fn(data) => data.decode(self).constness,\n-            EntryKind::ForeignFn(data) => data.decode(self).constness,\n-            EntryKind::Variant(..) | EntryKind::Struct(..) => hir::Constness::Const,\n-            _ => hir::Constness::NotConst,\n-        };\n-        constness == hir::Constness::Const\n-    }\n-\n     fn is_foreign_item(self, id: DefIndex) -> bool {\n         match self.kind(id) {\n-            EntryKind::ForeignStatic | EntryKind::ForeignFn(_) => true,\n+            EntryKind::ForeignStatic | EntryKind::ForeignFn => true,\n             _ => false,\n         }\n     }"}, {"sha": "cd3a1d72d41d24d8194adfa14ae6267420f50699", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb82facb1626166188d49599a3313fc95201f556/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb82facb1626166188d49599a3313fc95201f556/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=eb82facb1626166188d49599a3313fc95201f556", "patch": "@@ -153,8 +153,8 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     asyncness => { table }\n     fn_arg_names => { table }\n     generator_kind => { table }\n+    trait_def => { table }\n \n-    trait_def => { cdata.get_trait_def(def_id.index, tcx.sess) }\n     adt_def => { cdata.get_adt_def(def_id.index, tcx) }\n     adt_destructor => {\n         let _ = cdata;\n@@ -163,7 +163,6 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     associated_item_def_ids => { cdata.get_associated_item_def_ids(tcx, def_id.index) }\n     associated_item => { cdata.get_associated_item(def_id.index) }\n     inherent_impls => { cdata.get_inherent_implementations_for_type(tcx, def_id.index) }\n-    is_const_fn_raw => { cdata.is_const_fn_raw(def_id.index) }\n     is_foreign_item => { cdata.is_foreign_item(def_id.index) }\n     item_attrs => { tcx.arena.alloc_from_iter(cdata.get_item_attrs(def_id.index, tcx.sess)) }\n     trait_of_item => { cdata.get_trait_of_item(def_id.index) }"}, {"sha": "6c758b8e5b633544483933bc06f16fa6320a6c31", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 61, "deletions": 70, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/eb82facb1626166188d49599a3313fc95201f556/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb82facb1626166188d49599a3313fc95201f556/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=eb82facb1626166188d49599a3313fc95201f556", "patch": "@@ -1048,6 +1048,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         };\n \n         record!(self.tables.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n+        record!(self.tables.impl_constness[def_id] <- hir::Constness::Const);\n         record!(self.tables.children[def_id] <- variant.fields.iter().map(|f| {\n             assert!(f.did.is_local());\n             f.did.index\n@@ -1077,6 +1078,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         };\n \n         record!(self.tables.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n+        record!(self.tables.impl_constness[def_id] <- hir::Constness::Const);\n         self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n@@ -1154,7 +1156,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n         };\n \n-        record!(self.tables.kind[def_id] <- EntryKind::Struct(self.lazy(data), adt_def.repr()));\n+        record!(self.tables.repr_options[def_id] <- adt_def.repr());\n+        record!(self.tables.impl_constness[def_id] <- hir::Constness::Const);\n+        record!(self.tables.kind[def_id] <- EntryKind::Struct(self.lazy(data)));\n         self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n@@ -1194,22 +1198,18 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 record!(self.tables.rendered_const[def_id] <- rendered);\n             }\n             ty::AssocKind::Fn => {\n-                let fn_data = if let hir::TraitItemKind::Fn(m_sig, m) = &ast_item.kind {\n-                    match *m {\n-                        hir::TraitFn::Required(ref names) => {\n-                            record!(self.tables.fn_arg_names[def_id] <- *names)\n-                        }\n-                        hir::TraitFn::Provided(body) => {\n-                            record!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body))\n-                        }\n-                    };\n-                    record!(self.tables.asyncness[def_id] <- m_sig.header.asyncness);\n-                    FnData { constness: hir::Constness::NotConst }\n-                } else {\n-                    bug!()\n+                let hir::TraitItemKind::Fn(m_sig, m) = &ast_item.kind else { bug!() };\n+                match *m {\n+                    hir::TraitFn::Required(ref names) => {\n+                        record!(self.tables.fn_arg_names[def_id] <- *names)\n+                    }\n+                    hir::TraitFn::Provided(body) => {\n+                        record!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body))\n+                    }\n                 };\n+                record!(self.tables.asyncness[def_id] <- m_sig.header.asyncness);\n+                record!(self.tables.impl_constness[def_id] <- hir::Constness::NotConst);\n                 record!(self.tables.kind[def_id] <- EntryKind::AssocFn(self.lazy(AssocFnData {\n-                    fn_data,\n                     container,\n                     has_self: trait_item.fn_has_self_parameter,\n                 })));\n@@ -1264,22 +1264,17 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 }\n             }\n             ty::AssocKind::Fn => {\n-                let fn_data = if let hir::ImplItemKind::Fn(ref sig, body) = ast_item.kind {\n-                    record!(self.tables.asyncness[def_id] <- sig.header.asyncness);\n-                    record!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body));\n-                    FnData {\n-                        // Can be inside `impl const Trait`, so using sig.header.constness is not reliable\n-                        constness: if self.tcx.is_const_fn_raw(def_id) {\n-                            hir::Constness::Const\n-                        } else {\n-                            hir::Constness::NotConst\n-                        },\n-                    }\n+                let hir::ImplItemKind::Fn(ref sig, body) = ast_item.kind else { bug!() };\n+                record!(self.tables.asyncness[def_id] <- sig.header.asyncness);\n+                record!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body));\n+                // Can be inside `impl const Trait`, so using sig.header.constness is not reliable\n+                let constness = if self.tcx.is_const_fn_raw(def_id) {\n+                    hir::Constness::Const\n                 } else {\n-                    bug!()\n+                    hir::Constness::NotConst\n                 };\n+                record!(self.tables.impl_constness[def_id] <- constness);\n                 record!(self.tables.kind[def_id] <- EntryKind::AssocFn(self.lazy(AssocFnData {\n-                    fn_data,\n                     container,\n                     has_self: impl_item.fn_has_self_parameter,\n                 })));\n@@ -1401,9 +1396,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             hir::ItemKind::Fn(ref sig, .., body) => {\n                 record!(self.tables.asyncness[def_id] <- sig.header.asyncness);\n                 record!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body));\n-                let data = FnData { constness: sig.header.constness };\n-\n-                EntryKind::Fn(self.lazy(data))\n+                record!(self.tables.impl_constness[def_id] <- sig.header.constness);\n+                EntryKind::Fn\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n                 EntryKind::MacroDef(self.lazy(&*macro_def.body), macro_def.macro_rules)\n@@ -1418,10 +1412,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 self.encode_explicit_item_bounds(def_id);\n                 EntryKind::OpaqueTy\n             }\n-            hir::ItemKind::Enum(..) => EntryKind::Enum(self.tcx.adt_def(def_id).repr()),\n+            hir::ItemKind::Enum(..) => {\n+                let adt_def = self.tcx.adt_def(def_id);\n+                record!(self.tables.repr_options[def_id] <- adt_def.repr());\n+                EntryKind::Enum\n+            }\n             hir::ItemKind::Struct(ref struct_def, _) => {\n                 let adt_def = self.tcx.adt_def(def_id);\n-                let variant = adt_def.non_enum_variant();\n+                record!(self.tables.repr_options[def_id] <- adt_def.repr());\n+                record!(self.tables.impl_constness[def_id] <- hir::Constness::Const);\n \n                 // Encode def_ids for each field and method\n                 // for methods, write all the stuff get_trait_method\n@@ -1430,29 +1429,25 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     .ctor_hir_id()\n                     .map(|ctor_hir_id| self.tcx.hir().local_def_id(ctor_hir_id).local_def_index);\n \n-                EntryKind::Struct(\n-                    self.lazy(VariantData {\n-                        ctor_kind: variant.ctor_kind,\n-                        discr: variant.discr,\n-                        ctor,\n-                        is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n-                    }),\n-                    adt_def.repr(),\n-                )\n+                let variant = adt_def.non_enum_variant();\n+                EntryKind::Struct(self.lazy(VariantData {\n+                    ctor_kind: variant.ctor_kind,\n+                    discr: variant.discr,\n+                    ctor,\n+                    is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n+                }))\n             }\n             hir::ItemKind::Union(..) => {\n                 let adt_def = self.tcx.adt_def(def_id);\n-                let variant = adt_def.non_enum_variant();\n+                record!(self.tables.repr_options[def_id] <- adt_def.repr());\n \n-                EntryKind::Union(\n-                    self.lazy(VariantData {\n-                        ctor_kind: variant.ctor_kind,\n-                        discr: variant.discr,\n-                        ctor: None,\n-                        is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n-                    }),\n-                    adt_def.repr(),\n-                )\n+                let variant = adt_def.non_enum_variant();\n+                EntryKind::Union(self.lazy(VariantData {\n+                    ctor_kind: variant.ctor_kind,\n+                    discr: variant.discr,\n+                    ctor: None,\n+                    is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n+                }))\n             }\n             hir::ItemKind::Impl(hir::Impl { defaultness, constness, .. }) => {\n                 record!(self.tables.impl_defaultness[def_id] <- defaultness);\n@@ -1483,19 +1478,16 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             hir::ItemKind::Trait(..) => {\n                 let trait_def = self.tcx.trait_def(def_id);\n-                let data = TraitData {\n-                    unsafety: trait_def.unsafety,\n-                    paren_sugar: trait_def.paren_sugar,\n-                    has_auto_impl: self.tcx.trait_is_auto(def_id),\n-                    is_marker: trait_def.is_marker,\n-                    skip_array_during_method_dispatch: trait_def.skip_array_during_method_dispatch,\n-                    specialization_kind: trait_def.specialization_kind,\n-                    must_implement_one_of: trait_def.must_implement_one_of.clone(),\n-                };\n+                record!(self.tables.trait_def[def_id] <- trait_def);\n+\n+                EntryKind::Trait\n+            }\n+            hir::ItemKind::TraitAlias(..) => {\n+                let trait_def = self.tcx.trait_def(def_id);\n+                record!(self.tables.trait_def[def_id] <- trait_def);\n \n-                EntryKind::Trait(self.lazy(data))\n+                EntryKind::TraitAlias\n             }\n-            hir::ItemKind::TraitAlias(..) => EntryKind::TraitAlias,\n             hir::ItemKind::ExternCrate(_) | hir::ItemKind::Use(..) => {\n                 bug!(\"cannot encode info for item {:?}\", item)\n             }\n@@ -1896,14 +1888,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             hir::ForeignItemKind::Fn(_, ref names, _) => {\n                 record!(self.tables.asyncness[def_id] <- hir::IsAsync::NotAsync);\n                 record!(self.tables.fn_arg_names[def_id] <- *names);\n-                let data = FnData {\n-                    constness: if self.tcx.is_const_fn_raw(def_id) {\n-                        hir::Constness::Const\n-                    } else {\n-                        hir::Constness::NotConst\n-                    },\n+                let constness = if self.tcx.is_const_fn_raw(def_id) {\n+                    hir::Constness::Const\n+                } else {\n+                    hir::Constness::NotConst\n                 };\n-                record!(self.tables.kind[def_id] <- EntryKind::ForeignFn(self.lazy(data)));\n+                record!(self.tables.impl_constness[def_id] <- constness);\n+                record!(self.tables.kind[def_id] <- EntryKind::ForeignFn);\n             }\n             hir::ForeignItemKind::Static(..) => {\n                 record!(self.tables.kind[def_id] <- EntryKind::ForeignStatic);"}, {"sha": "15e8693d71282f1d866b04c445e493dabb671188", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 8, "deletions": 23, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/eb82facb1626166188d49599a3313fc95201f556/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb82facb1626166188d49599a3313fc95201f556/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=eb82facb1626166188d49599a3313fc95201f556", "patch": "@@ -320,11 +320,13 @@ define_tables! {\n     asyncness: Table<DefIndex, Lazy!(hir::IsAsync)>,\n     fn_arg_names: Table<DefIndex, Lazy!([Ident])>,\n     generator_kind: Table<DefIndex, Lazy!(hir::GeneratorKind)>,\n+    trait_def: Table<DefIndex, Lazy!(ty::TraitDef)>,\n \n     trait_item_def_id: Table<DefIndex, Lazy<DefId>>,\n     inherent_impls: Table<DefIndex, Lazy<[DefIndex]>>,\n     expn_that_defined: Table<DefIndex, Lazy<ExpnId>>,\n     unused_generic_params: Table<DefIndex, Lazy<FiniteBitSet<u32>>>,\n+    repr_options: Table<DefIndex, Lazy<ReprOptions>>,\n     // `def_keys` and `def_path_hashes` represent a lazy version of a\n     // `DefPathTable`. This allows us to avoid deserializing an entire\n     // `DefPathTable` up front, since we may only ever use a few\n@@ -347,31 +349,26 @@ enum EntryKind {\n     TypeParam,\n     ConstParam,\n     OpaqueTy,\n-    Enum(ReprOptions),\n+    Enum,\n     Field,\n     Variant(Lazy<VariantData>),\n-    Struct(Lazy<VariantData>, ReprOptions),\n-    Union(Lazy<VariantData>, ReprOptions),\n-    Fn(Lazy<FnData>),\n-    ForeignFn(Lazy<FnData>),\n+    Struct(Lazy<VariantData>),\n+    Union(Lazy<VariantData>),\n+    Fn,\n+    ForeignFn,\n     Mod(Lazy<[ModChild]>),\n     MacroDef(Lazy<ast::MacArgs>, /*macro_rules*/ bool),\n     ProcMacro(MacroKind),\n     Closure,\n     Generator,\n-    Trait(Lazy<TraitData>),\n+    Trait,\n     Impl,\n     AssocFn(Lazy<AssocFnData>),\n     AssocType(AssocContainer),\n     AssocConst(AssocContainer),\n     TraitAlias,\n }\n \n-#[derive(MetadataEncodable, MetadataDecodable)]\n-struct FnData {\n-    constness: hir::Constness,\n-}\n-\n #[derive(TyEncodable, TyDecodable)]\n struct VariantData {\n     ctor_kind: CtorKind,\n@@ -381,17 +378,6 @@ struct VariantData {\n     is_non_exhaustive: bool,\n }\n \n-#[derive(TyEncodable, TyDecodable)]\n-struct TraitData {\n-    unsafety: hir::Unsafety,\n-    paren_sugar: bool,\n-    has_auto_impl: bool,\n-    is_marker: bool,\n-    skip_array_during_method_dispatch: bool,\n-    specialization_kind: ty::trait_def::TraitSpecializationKind,\n-    must_implement_one_of: Option<Box<[Ident]>>,\n-}\n-\n /// Describes whether the container of an associated item\n /// is a trait or an impl and whether, in a trait, it has\n /// a default, or an in impl, whether it's marked \"default\".\n@@ -429,7 +415,6 @@ impl AssocContainer {\n \n #[derive(MetadataEncodable, MetadataDecodable)]\n struct AssocFnData {\n-    fn_data: FnData,\n     container: AssocContainer,\n     has_self: bool,\n }"}, {"sha": "14c11187fc5eecc28b946a5e01a9c14fac1b3fdb", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eb82facb1626166188d49599a3313fc95201f556/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb82facb1626166188d49599a3313fc95201f556/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=eb82facb1626166188d49599a3313fc95201f556", "patch": "@@ -559,7 +559,7 @@ rustc_queries! {\n     ///\n     /// **Do not call this function manually.** It is only meant to cache the base data for the\n     /// `is_const_fn` function.\n-    query is_const_fn_raw(key: DefId) -> bool {\n+    query impl_constness(key: DefId) -> hir::Constness {\n         desc { |tcx| \"checking if item is const fn: `{}`\", tcx.def_path_str(key) }\n         separate_provide_extern\n     }\n@@ -1329,11 +1329,6 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n-    query impl_constness(def_id: DefId) -> hir::Constness {\n-        desc { |tcx| \"looking up whether `{}` is a const impl\", tcx.def_path_str(def_id) }\n-        separate_provide_extern\n-    }\n-\n     query check_item_well_formed(key: LocalDefId) -> () {\n         desc { |tcx| \"checking that `{}` is well-formed\", tcx.def_path_str(key.to_def_id()) }\n     }"}, {"sha": "37425c91157b3a8ce4282a8923d3022f34ec3b32", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eb82facb1626166188d49599a3313fc95201f556/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb82facb1626166188d49599a3313fc95201f556/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=eb82facb1626166188d49599a3313fc95201f556", "patch": "@@ -289,6 +289,11 @@ pub struct ClosureSizeProfileData<'tcx> {\n pub trait DefIdTree: Copy {\n     fn parent(self, id: DefId) -> Option<DefId>;\n \n+    #[inline]\n+    fn local_parent(self, id: LocalDefId) -> Option<LocalDefId> {\n+        Some(self.parent(id.to_def_id())?.expect_local())\n+    }\n+\n     fn is_descendant_of(self, mut descendant: DefId, ancestor: DefId) -> bool {\n         if descendant.krate != ancestor.krate {\n             return false;\n@@ -2256,6 +2261,12 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn is_object_safe(self, key: DefId) -> bool {\n         self.object_safety_violations(key).is_empty()\n     }\n+\n+    #[inline]\n+    pub fn is_const_fn_raw(self, def_id: DefId) -> bool {\n+        matches!(self.def_kind(def_id), DefKind::Fn | DefKind::AssocFn | DefKind::Ctor(..))\n+            && self.impl_constness(def_id) == hir::Constness::Const\n+    }\n }\n \n /// Yields the parent function's `LocalDefId` if `def_id` is an `impl Trait` definition."}, {"sha": "ca6fabf7f401825a99bdb474ed84fa771c0d2ead", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/eb82facb1626166188d49599a3313fc95201f556/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb82facb1626166188d49599a3313fc95201f556/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=eb82facb1626166188d49599a3313fc95201f556", "patch": "@@ -5,18 +5,15 @@ use crate::ty::{Ident, Ty, TyCtxt};\n use hir::def_id::LOCAL_CRATE;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::definitions::DefPathHash;\n use std::iter;\n \n use rustc_data_structures::fx::FxIndexMap;\n use rustc_errors::ErrorGuaranteed;\n use rustc_macros::HashStable;\n \n /// A trait's definition with type information.\n-#[derive(HashStable)]\n+#[derive(HashStable, Encodable, Decodable)]\n pub struct TraitDef {\n-    // We already have the def_path_hash below, no need to hash it twice\n-    #[stable_hasher(ignore)]\n     pub def_id: DefId,\n \n     pub unsafety: hir::Unsafety,\n@@ -43,18 +40,14 @@ pub struct TraitDef {\n     /// on this trait.\n     pub specialization_kind: TraitSpecializationKind,\n \n-    /// The ICH of this trait's DefPath, cached here so it doesn't have to be\n-    /// recomputed all the time.\n-    pub def_path_hash: DefPathHash,\n-\n     /// List of functions from `#[rustc_must_implement_one_of]` attribute one of which\n     /// must be implemented.\n     pub must_implement_one_of: Option<Box<[Ident]>>,\n }\n \n /// Whether this trait is treated specially by the standard library\n /// specialization lint.\n-#[derive(HashStable, PartialEq, Clone, Copy, TyEncodable, TyDecodable)]\n+#[derive(HashStable, PartialEq, Clone, Copy, Encodable, Decodable)]\n pub enum TraitSpecializationKind {\n     /// The default. Specializing on this trait is not allowed.\n     None,\n@@ -92,7 +85,6 @@ impl<'tcx> TraitDef {\n         is_marker: bool,\n         skip_array_during_method_dispatch: bool,\n         specialization_kind: TraitSpecializationKind,\n-        def_path_hash: DefPathHash,\n         must_implement_one_of: Option<Box<[Ident]>>,\n     ) -> TraitDef {\n         TraitDef {\n@@ -103,7 +95,6 @@ impl<'tcx> TraitDef {\n             is_marker,\n             skip_array_during_method_dispatch,\n             specialization_kind,\n-            def_path_hash,\n             must_implement_one_of,\n         }\n     }"}, {"sha": "7ad8748135630747c61b135f84d65760b69255d5", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb82facb1626166188d49599a3313fc95201f556/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb82facb1626166188d49599a3313fc95201f556/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=eb82facb1626166188d49599a3313fc95201f556", "patch": "@@ -1859,7 +1859,7 @@ impl CheckAttrVisitor<'_> {\n     ) -> bool {\n         match target {\n             Target::Fn | Target::Method(_)\n-                if self.tcx.is_const_fn_raw(self.tcx.hir().local_def_id(hir_id)) =>\n+                if self.tcx.is_const_fn_raw(self.tcx.hir().local_def_id(hir_id).to_def_id()) =>\n             {\n                 true\n             }"}, {"sha": "64145bbf189ff43a8acff9e0acaa14326d4e7db6", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eb82facb1626166188d49599a3313fc95201f556/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb82facb1626166188d49599a3313fc95201f556/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=eb82facb1626166188d49599a3313fc95201f556", "patch": "@@ -77,15 +77,6 @@ fn impl_defaultness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::Defaultness {\n     }\n }\n \n-fn impl_constness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::Constness {\n-    let item = tcx.hir().expect_item(def_id.expect_local());\n-    if let hir::ItemKind::Impl(impl_) = &item.kind {\n-        impl_.constness\n-    } else {\n-        bug!(\"`impl_constness` called on {:?}\", item);\n-    }\n-}\n-\n /// Calculates the `Sized` constraint.\n ///\n /// In fact, there are only a few options for the types in the constraint:\n@@ -498,7 +489,6 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         instance_def_size_estimate,\n         issue33140_self_ty,\n         impl_defaultness,\n-        impl_constness,\n         conservative_is_privately_uninhabited: conservative_is_privately_uninhabited_raw,\n         ..*providers\n     };"}, {"sha": "90b880adcd03103025ecd196df2d9f45fd6f8518", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb82facb1626166188d49599a3313fc95201f556/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb82facb1626166188d49599a3313fc95201f556/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=eb82facb1626166188d49599a3313fc95201f556", "patch": "@@ -1218,8 +1218,6 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::TraitDef {\n     } else {\n         ty::trait_def::TraitSpecializationKind::None\n     };\n-    let def_path_hash = tcx.def_path_hash(def_id);\n-\n     let must_implement_one_of = tcx\n         .get_attrs(def_id)\n         .iter()\n@@ -1326,7 +1324,6 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::TraitDef {\n         is_marker,\n         skip_array_during_method_dispatch,\n         spec_kind,\n-        def_path_hash,\n         must_implement_one_of,\n     )\n }"}]}