{"sha": "0fadfc5fb7de47f0ffcb55a8bbfe0a75c2a4dbee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmYWRmYzVmYjdkZTQ3ZjBmZmNiNTVhOGJiZmUwYTc1YzJhNGRiZWU=", "commit": {"author": {"name": "Dmitry Ermolov", "email": "epdmitry@yandex.ru", "date": "2013-08-06T18:43:57Z"}, "committer": {"name": "Dmitry Ermolov", "email": "epdmitry@yandex.ru", "date": "2013-08-06T20:04:28Z"}, "message": "Fix bug in `match`ing struct patterns\n\nCode that collects fields in struct-like patterns used to ignore\nwildcard patterns like `Foo{_}`. But `enter_defaults` considered\nstruct-like patterns as default in order to overcome this\n(accoring to my understanding of situation).\n\nHowever such behaviour caused code like this:\n```\nenum E {\n    Foo{f: int},\n    Bar\n}\nlet e = Bar;\nmatch e {\n    Foo{f: _f} => { /* do something (1) */ }\n    _ => { /* do something (2) */ }\n}\n```\nconsider pattern `Foo{f: _f}` as default. That caused inproper behaviour\nand even segfaults while trying to destruct `Bar` as `Foo{f: _f}`.\nIssues: #5625 , #5530.\n\nThis patch fixes `collect_record_or_struct_fields` to split cases of\nsingle wildcard struct-like pattern and no struct-like pattern at all.\nFormer case resolved with `enter_rec_or_struct` (and not with\n`enter_defaults`).\n\nCloses #5625.\nCloses #5530.", "tree": {"sha": "e1f486734fd0c05d86a85a8f9b2dfbc13807e0d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1f486734fd0c05d86a85a8f9b2dfbc13807e0d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0fadfc5fb7de47f0ffcb55a8bbfe0a75c2a4dbee", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0fadfc5fb7de47f0ffcb55a8bbfe0a75c2a4dbee", "html_url": "https://github.com/rust-lang/rust/commit/0fadfc5fb7de47f0ffcb55a8bbfe0a75c2a4dbee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0fadfc5fb7de47f0ffcb55a8bbfe0a75c2a4dbee/comments", "author": {"login": "dim-an", "id": 88889, "node_id": "MDQ6VXNlcjg4ODg5", "avatar_url": "https://avatars.githubusercontent.com/u/88889?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dim-an", "html_url": "https://github.com/dim-an", "followers_url": "https://api.github.com/users/dim-an/followers", "following_url": "https://api.github.com/users/dim-an/following{/other_user}", "gists_url": "https://api.github.com/users/dim-an/gists{/gist_id}", "starred_url": "https://api.github.com/users/dim-an/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dim-an/subscriptions", "organizations_url": "https://api.github.com/users/dim-an/orgs", "repos_url": "https://api.github.com/users/dim-an/repos", "events_url": "https://api.github.com/users/dim-an/events{/privacy}", "received_events_url": "https://api.github.com/users/dim-an/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dim-an", "id": 88889, "node_id": "MDQ6VXNlcjg4ODg5", "avatar_url": "https://avatars.githubusercontent.com/u/88889?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dim-an", "html_url": "https://github.com/dim-an", "followers_url": "https://api.github.com/users/dim-an/followers", "following_url": "https://api.github.com/users/dim-an/following{/other_user}", "gists_url": "https://api.github.com/users/dim-an/gists{/gist_id}", "starred_url": "https://api.github.com/users/dim-an/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dim-an/subscriptions", "organizations_url": "https://api.github.com/users/dim-an/orgs", "repos_url": "https://api.github.com/users/dim-an/repos", "events_url": "https://api.github.com/users/dim-an/events{/privacy}", "received_events_url": "https://api.github.com/users/dim-an/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1710125f673fe8ca2f1ab76074ca26d6f6acd720", "url": "https://api.github.com/repos/rust-lang/rust/commits/1710125f673fe8ca2f1ab76074ca26d6f6acd720", "html_url": "https://github.com/rust-lang/rust/commit/1710125f673fe8ca2f1ab76074ca26d6f6acd720"}], "stats": {"total": 59, "additions": 35, "deletions": 24}, "files": [{"sha": "327d2e698c1e181915f6bcc41a555479ca967694", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/0fadfc5fb7de47f0ffcb55a8bbfe0a75c2a4dbee/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fadfc5fb7de47f0ffcb55a8bbfe0a75c2a4dbee/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=0fadfc5fb7de47f0ffcb55a8bbfe0a75c2a4dbee", "patch": "@@ -485,7 +485,7 @@ fn enter_default<'r>(bcx: @mut Block,\n \n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n-          ast::pat_wild | ast::pat_tup(_) | ast::pat_struct(*) => Some(~[]),\n+          ast::pat_wild | ast::pat_tup(_) => Some(~[]),\n           ast::pat_ident(_, _, None) if pat_is_binding(dm, p) => Some(~[]),\n           _ => None\n         }\n@@ -947,24 +947,37 @@ fn extract_vec_elems(bcx: @mut Block,\n     ExtractedBlock { vals: elems, bcx: bcx }\n }\n \n-// NB: This function does not collect fields from struct-like enum variants.\n+/// Checks every pattern in `m` at `col` column.\n+/// If there are a struct pattern among them function\n+/// returns list of all fields that are matched in these patterns.\n+/// Function returns None if there is no struct pattern.\n+/// Function doesn't collect fields from struct-like enum variants.\n+/// Function can return empty list if there is only wildcard struct pattern.\n fn collect_record_or_struct_fields(bcx: @mut Block,\n                                        m: &[Match],\n                                        col: uint)\n-                                    -> ~[ast::ident] {\n+                                    -> Option<~[ast::ident]> {\n     let mut fields: ~[ast::ident] = ~[];\n+    let mut found = false;\n     for br in m.iter() {\n         match br.pats[col].node {\n           ast::pat_struct(_, ref fs, _) => {\n             match ty::get(node_id_type(bcx, br.pats[col].id)).sty {\n-              ty::ty_struct(*) => extend(&mut fields, *fs),\n+              ty::ty_struct(*) => {\n+                   extend(&mut fields, *fs);\n+                   found = true;\n+              }\n               _ => ()\n             }\n           }\n           _ => ()\n         }\n     }\n-    return fields;\n+    if found {\n+        return Some(fields);\n+    } else {\n+        return None;\n+    }\n \n     fn extend(idents: &mut ~[ast::ident], field_pats: &[ast::field_pat]) {\n         for field_pat in field_pats.iter() {\n@@ -1336,22 +1349,24 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n     // required to root any values.\n     assert!(any_box_pat(m, col) || !pats_require_rooting(bcx, m, col));\n \n-    let rec_fields = collect_record_or_struct_fields(bcx, m, col);\n-    if rec_fields.len() > 0 {\n-        let pat_ty = node_id_type(bcx, pat_id);\n-        let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n-        do expr::with_field_tys(tcx, pat_ty, None) |discr, field_tys| {\n-            let rec_vals = rec_fields.map(|field_name| {\n-                let ix = ty::field_idx_strict(tcx, *field_name, field_tys);\n-                adt::trans_field_ptr(bcx, pat_repr, val, discr, ix)\n-            });\n-            compile_submatch(\n-                bcx,\n-                enter_rec_or_struct(bcx, dm, m, col, rec_fields, val),\n-                vec::append(rec_vals, vals_left),\n-                chk);\n+    match collect_record_or_struct_fields(bcx, m, col) {\n+        Some(ref rec_fields) => {\n+            let pat_ty = node_id_type(bcx, pat_id);\n+            let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n+            do expr::with_field_tys(tcx, pat_ty, None) |discr, field_tys| {\n+                let rec_vals = rec_fields.map(|field_name| {\n+                        let ix = ty::field_idx_strict(tcx, *field_name, field_tys);\n+                        adt::trans_field_ptr(bcx, pat_repr, val, discr, ix)\n+                        });\n+                compile_submatch(\n+                        bcx,\n+                        enter_rec_or_struct(bcx, dm, m, col, *rec_fields, val),\n+                        vec::append(rec_vals, vals_left),\n+                        chk);\n+            }\n+            return;\n         }\n-        return;\n+        None => {}\n     }\n \n     if any_tup_pat(m, col) {"}, {"sha": "8e55ad90c70441bd6091fc36d2b84d50f0cbfe2d", "filename": "src/test/run-pass/issue-5530.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fadfc5fb7de47f0ffcb55a8bbfe0a75c2a4dbee/src%2Ftest%2Frun-pass%2Fissue-5530.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fadfc5fb7de47f0ffcb55a8bbfe0a75c2a4dbee/src%2Ftest%2Frun-pass%2Fissue-5530.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5530.rs?ref=0fadfc5fb7de47f0ffcb55a8bbfe0a75c2a4dbee", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test\n-\n enum Enum {\n     Foo { foo: uint },\n     Bar { bar: uint }"}, {"sha": "365729ec86054d5f372e80deb7bea4aa655210c9", "filename": "src/test/run-pass/match-enum-struct-0.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fadfc5fb7de47f0ffcb55a8bbfe0a75c2a4dbee/src%2Ftest%2Frun-pass%2Fmatch-enum-struct-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fadfc5fb7de47f0ffcb55a8bbfe0a75c2a4dbee/src%2Ftest%2Frun-pass%2Fmatch-enum-struct-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-enum-struct-0.rs?ref=0fadfc5fb7de47f0ffcb55a8bbfe0a75c2a4dbee", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test\n-\n // regression test for issue #5625\n \n enum E {"}]}