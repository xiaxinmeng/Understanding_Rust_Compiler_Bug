{"sha": "38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4ZDlkMDlhNTg4MDNlYmQxZjViNDQzMmY5ZTQ5ZDAxZDJmY2UwZjE=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-01-24T16:14:17Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-03-09T18:28:01Z"}, "message": "Use BTreeMap to store attributes.", "tree": {"sha": "32e130c3de4903b89e094e5ac5f9170e10130958", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32e130c3de4903b89e094e5ac5f9170e10130958"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1", "html_url": "https://github.com/rust-lang/rust/commit/38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90a562c7ff728d75ba76bdc68aea53d6d0c75ec9", "url": "https://api.github.com/repos/rust-lang/rust/commits/90a562c7ff728d75ba76bdc68aea53d6d0c75ec9", "html_url": "https://github.com/rust-lang/rust/commit/90a562c7ff728d75ba76bdc68aea53d6d0c75ec9"}], "stats": {"total": 164, "additions": 117, "deletions": 47}, "files": [{"sha": "43b93d03ff6fb958f2224cbcc3666e47f798b14c", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1", "patch": "@@ -258,12 +258,18 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         ex.span = e.span;\n                     }\n                     // Merge attributes into the inner expression.\n-                    self.attrs[ex.hir_id] = &*self.arena.alloc_from_iter(\n-                        e.attrs\n-                            .iter()\n-                            .map(|a| self.lower_attr(a))\n-                            .chain(self.attrs[ex.hir_id].iter().cloned()),\n-                    );\n+                    if !e.attrs.is_empty() {\n+                        let old_attrs = self.attrs.get(&ex.hir_id).map(|la| *la).unwrap_or(&[]);\n+                        self.attrs.insert(\n+                            ex.hir_id,\n+                            &*self.arena.alloc_from_iter(\n+                                e.attrs\n+                                    .iter()\n+                                    .map(|a| self.lower_attr(a))\n+                                    .chain(old_attrs.iter().cloned()),\n+                            ),\n+                        );\n+                    }\n                     return ex;\n                 }\n \n@@ -1016,7 +1022,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         // Introduce a `let` for destructuring: `let (lhs1, lhs2) = t`.\n         let destructure_let = self.stmt_let_pat(\n-            &[],\n+            None,\n             whole_span,\n             Some(rhs),\n             pat,\n@@ -1775,7 +1781,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         // `let mut __next`\n         let next_let = self.stmt_let_pat(\n-            &[],\n+            None,\n             desugared_span,\n             None,\n             next_pat,\n@@ -1785,7 +1791,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // `let <pat> = __next`\n         let pat = self.lower_pat(pat);\n         let pat_let = self.stmt_let_pat(\n-            &[],\n+            None,\n             desugared_span,\n             Some(next_expr),\n             pat,"}, {"sha": "777d3a5060b9289605d287767c73d40bc6b9133e", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1", "patch": "@@ -251,7 +251,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         id: NodeId,\n         hir_id: hir::HirId,\n         ident: &mut Ident,\n-        attrs: &'hir [Attribute],\n+        attrs: Option<&'hir [Attribute]>,\n         vis: &mut hir::Visibility<'hir>,\n         i: &ItemKind,\n     ) -> hir::ItemKind<'hir> {\n@@ -502,7 +502,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         id: NodeId,\n         vis: &mut hir::Visibility<'hir>,\n         ident: &mut Ident,\n-        attrs: &'hir [Attribute],\n+        attrs: Option<&'hir [Attribute]>,\n     ) -> hir::ItemKind<'hir> {\n         debug!(\"lower_use_tree(tree={:?})\", tree);\n         debug!(\"lower_use_tree: vis = {:?}\", vis);\n@@ -551,7 +551,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         let path = this.lower_path_extra(res, &path, ParamMode::Explicit, None);\n                         let kind = hir::ItemKind::Use(path, hir::UseKind::Single);\n                         let vis = this.rebuild_vis(&vis);\n-                        this.attrs.push_sparse(new_id, attrs);\n+                        if let Some(attrs) = attrs {\n+                            this.attrs.insert(new_id, attrs);\n+                        }\n \n                         this.insert_item(hir::Item {\n                             def_id: new_id.expect_owner(),\n@@ -623,7 +625,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                         let kind =\n                             this.lower_use_tree(use_tree, &prefix, id, &mut vis, &mut ident, attrs);\n-                        this.attrs.push_sparse(new_hir_id, attrs);\n+                        if let Some(attrs) = attrs {\n+                            this.attrs.insert(new_hir_id, attrs);\n+                        }\n \n                         this.insert_item(hir::Item {\n                             def_id: new_hir_id.expect_owner(),\n@@ -770,7 +774,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             ),\n             VariantData::Tuple(ref fields, id) => {\n                 let ctor_id = self.lower_node_id(id);\n-                self.attrs.push_sparse(ctor_id, self.attrs[parent_id]);\n+                self.alias_attrs(ctor_id, parent_id);\n                 hir::VariantData::Tuple(\n                     self.arena.alloc_from_iter(\n                         fields.iter().enumerate().map(|f| self.lower_struct_field(f)),\n@@ -780,7 +784,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             VariantData::Unit(id) => {\n                 let ctor_id = self.lower_node_id(id);\n-                self.attrs.push_sparse(ctor_id, self.attrs[parent_id]);\n+                self.alias_attrs(ctor_id, parent_id);\n                 hir::VariantData::Unit(ctor_id)\n             }\n         }\n@@ -1168,7 +1172,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 //\n                 // If this is the simple case, this parameter will end up being the same as the\n                 // original parameter, but with a different pattern id.\n-                let stmt_attrs = this.attrs[parameter.hir_id];\n+                let stmt_attrs = this.attrs.get(&parameter.hir_id).copied();\n                 let (new_parameter_pat, new_parameter_id) = this.pat_ident(desugared_span, ident);\n                 let new_parameter = hir::Param {\n                     hir_id: parameter.hir_id,\n@@ -1213,7 +1217,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     );\n                     let move_expr = this.expr_ident(desugared_span, ident, new_parameter_id);\n                     let move_stmt = this.stmt_let_pat(\n-                        &[],\n+                        None,\n                         desugared_span,\n                         Some(move_expr),\n                         move_pat,"}, {"sha": "057e4d81f80fd727072dad606311dc99255b7cfd", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1", "patch": "@@ -114,7 +114,7 @@ struct LoweringContext<'a, 'hir: 'a> {\n \n     generator_kind: Option<hir::GeneratorKind>,\n \n-    attrs: hir::HirIdVec<&'hir [Attribute]>,\n+    attrs: BTreeMap<hir::HirId, &'hir [Attribute]>,\n \n     /// When inside an `async` context, this is the `HirId` of the\n     /// `task_context` local bound to the resume argument of the generator.\n@@ -311,7 +311,7 @@ pub fn lower_crate<'a, 'hir>(\n         bodies: BTreeMap::new(),\n         trait_impls: BTreeMap::new(),\n         modules: BTreeMap::new(),\n-        attrs: hir::HirIdVec::default(),\n+        attrs: BTreeMap::default(),\n         exported_macros: Vec::new(),\n         non_exported_macro_attrs: Vec::new(),\n         catch_scopes: Vec::new(),\n@@ -595,8 +595,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         self.resolver.definitions().init_def_id_to_hir_id_mapping(def_id_to_hir_id);\n \n-        // Not all HIR owners have declared attrs. Complete with empty IndexVecs.\n-        self.attrs.push_owner(Idx::new(self.resolver.definitions().def_index_count() - 1));\n+        #[cfg(debug_assertions)]\n+        for (&id, attrs) in self.attrs.iter() {\n+            // Verify that we do not store empty slices in the map.\n+            if attrs.is_empty() {\n+                panic!(\"Stored empty attributes for {:?}\", id);\n+            }\n+        }\n \n         hir::Crate {\n             item: hir::CrateItem { module, span: c.span },\n@@ -973,10 +978,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         ret\n     }\n \n-    fn lower_attrs(&mut self, id: hir::HirId, attrs: &[Attribute]) -> &'hir [Attribute] {\n-        let ret = self.arena.alloc_from_iter(attrs.iter().map(|a| self.lower_attr(a)));\n-        self.attrs.push_sparse(id, ret);\n-        ret\n+    fn lower_attrs(&mut self, id: hir::HirId, attrs: &[Attribute]) -> Option<&'hir [Attribute]> {\n+        if attrs.is_empty() {\n+            None\n+        } else {\n+            let ret = self.arena.alloc_from_iter(attrs.iter().map(|a| self.lower_attr(a)));\n+            debug_assert!(!ret.is_empty());\n+            self.attrs.insert(id, ret);\n+            Some(ret)\n+        }\n     }\n \n     fn lower_attr(&self, attr: &Attribute) -> Attribute {\n@@ -999,6 +1009,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         Attribute { kind, id: attr.id, style: attr.style, span: attr.span }\n     }\n \n+    fn alias_attrs(&mut self, id: hir::HirId, target_id: hir::HirId) {\n+        if let Some(&a) = self.attrs.get(&target_id) {\n+            debug_assert!(!a.is_empty());\n+            self.attrs.insert(id, a);\n+        }\n+    }\n+\n     fn lower_mac_args(&self, args: &MacArgs) -> MacArgs {\n         match *args {\n             MacArgs::Empty => MacArgs::Empty,\n@@ -2447,7 +2464,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     })\n                     .collect();\n                 let hir_id = self.lower_node_id(s.id);\n-                self.attrs.push_sparse(hir_id, self.attrs[l.hir_id]);\n+                self.alias_attrs(hir_id, l.hir_id);\n                 ids.push({\n                     hir::Stmt {\n                         hir_id,\n@@ -2476,13 +2493,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             StmtKind::Expr(ref e) => {\n                 let e = self.lower_expr(e);\n                 let hir_id = self.lower_node_id(s.id);\n-                self.attrs.push_sparse(hir_id, self.attrs[e.hir_id]);\n+                self.alias_attrs(hir_id, e.hir_id);\n                 (hir_id, hir::StmtKind::Expr(e))\n             }\n             StmtKind::Semi(ref e) => {\n                 let e = self.lower_expr(e);\n                 let hir_id = self.lower_node_id(s.id);\n-                self.attrs.push_sparse(hir_id, self.attrs[e.hir_id]);\n+                self.alias_attrs(hir_id, e.hir_id);\n                 (hir_id, hir::StmtKind::Semi(e))\n             }\n             StmtKind::Empty => return smallvec![],\n@@ -2532,14 +2549,17 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     fn stmt_let_pat(\n         &mut self,\n-        attrs: &'hir [Attribute],\n+        attrs: Option<&'hir [Attribute]>,\n         span: Span,\n         init: Option<&'hir hir::Expr<'hir>>,\n         pat: &'hir hir::Pat<'hir>,\n         source: hir::LocalSource,\n     ) -> hir::Stmt<'hir> {\n         let hir_id = self.next_id();\n-        self.attrs.push_sparse(hir_id, attrs);\n+        if let Some(a) = attrs {\n+            debug_assert!(!a.is_empty());\n+            self.attrs.insert(hir_id, a);\n+        }\n         let local = hir::Local { hir_id, init, pat, source, span, ty: None };\n         self.stmt(span, hir::StmtKind::Local(self.arena.alloc(local)))\n     }"}, {"sha": "8f61adcd8e28870f0c62f1cabd5eeec08cc62976", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1", "patch": "@@ -2,7 +2,7 @@\n use crate::def::{CtorKind, DefKind, Namespace, Res};\n use crate::def_id::DefId;\n crate use crate::hir_id::HirId;\n-use crate::{itemlikevisit, HirIdVec, LangItem};\n+use crate::{itemlikevisit, LangItem};\n \n use rustc_ast::util::parser::ExprPrecedence;\n use rustc_ast::{self as ast, CrateSugar, LlvmAsmDialect};\n@@ -675,7 +675,7 @@ pub struct Crate<'hir> {\n     pub trait_map: BTreeMap<HirId, Vec<TraitCandidate>>,\n \n     /// Collected attributes from HIR nodes.\n-    pub attrs: HirIdVec<&'hir [Attribute]>,\n+    pub attrs: BTreeMap<HirId, &'hir [Attribute]>,\n }\n \n impl Crate<'hir> {"}, {"sha": "df63f0d48c3dd0a6b62349c26fba98f29b4e2d04", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1", "patch": "@@ -477,7 +477,7 @@ pub trait Visitor<'v>: Sized {\n pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate<'v>) {\n     visitor.visit_mod(&krate.item.module, krate.item.span, CRATE_HIR_ID);\n     walk_list!(visitor, visit_macro_def, krate.exported_macros);\n-    for (id, attrs) in krate.attrs.iter_enumerated() {\n+    for (&id, attrs) in krate.attrs.iter() {\n         for a in *attrs {\n             visitor.visit_attribute(id, a)\n         }"}, {"sha": "9c2766a16318db38794b02f148a9893697618926", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1", "patch": "@@ -16,6 +16,7 @@ use rustc_target::spec::abi::Abi;\n \n use std::borrow::Cow;\n use std::cell::Cell;\n+use std::collections::BTreeMap;\n use std::vec;\n \n pub fn id_to_string(map: &dyn rustc_hir::intravisit::Map<'_>, hir_id: hir::HirId) -> String {\n@@ -82,7 +83,7 @@ impl PpAnn for &dyn rustc_hir::intravisit::Map<'_> {\n pub struct State<'a> {\n     pub s: pp::Printer,\n     comments: Option<Comments<'a>>,\n-    attrs: &'a hir::HirIdVec<&'a [ast::Attribute]>,\n+    attrs: &'a BTreeMap<hir::HirId, &'a [ast::Attribute]>,\n     ann: &'a (dyn PpAnn + 'a),\n }\n \n@@ -169,7 +170,7 @@ pub fn print_crate<'a>(\n     // When printing the AST, we sometimes need to inject `#[no_std]` here.\n     // Since you can't compile the HIR, it's not necessary.\n \n-    s.print_mod(&krate.item.module, krate.attrs[hir::CRATE_HIR_ID]);\n+    s.print_mod(&krate.item.module, s.attrs(hir::CRATE_HIR_ID));\n     s.print_remaining_comments();\n     s.s.eof()\n }\n@@ -179,7 +180,7 @@ impl<'a> State<'a> {\n         sm: &'a SourceMap,\n         filename: FileName,\n         input: String,\n-        attrs: &'a hir::HirIdVec<&[ast::Attribute]>,\n+        attrs: &'a BTreeMap<hir::HirId, &[ast::Attribute]>,\n         ann: &'a dyn PpAnn,\n     ) -> State<'a> {\n         State {\n@@ -191,7 +192,7 @@ impl<'a> State<'a> {\n     }\n \n     fn attrs(&self, id: hir::HirId) -> &'a [ast::Attribute] {\n-        self.attrs.get(id).map_or(&[], |la| *la)\n+        self.attrs.get(&id).map_or(&[], |la| *la)\n     }\n }\n \n@@ -200,7 +201,7 @@ where\n     F: FnOnce(&mut State<'_>),\n {\n     let mut printer =\n-        State { s: pp::mk_printer(), comments: None, attrs: &hir::HirIdVec::default(), ann };\n+        State { s: pp::mk_printer(), comments: None, attrs: &BTreeMap::default(), ann };\n     f(&mut printer);\n     printer.s.eof()\n }"}, {"sha": "b1dd405a6be6880187aa759b893d8407ccc9424c", "filename": "compiler/rustc_middle/src/hir/map/collector.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs?ref=38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1", "patch": "@@ -132,11 +132,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             hcx,\n             hir_body_nodes,\n             map: (0..definitions.def_index_count())\n-                .map(|id| HirOwnerData {\n-                    attrs: krate.attrs.get_owner(Idx::new(id)),\n-                    signature: None,\n-                    with_bodies: None,\n-                })\n+                .map(|_| HirOwnerData { signature: None, with_bodies: None })\n                 .collect(),\n         };\n         collector.insert_entry("}, {"sha": "41ecffb9c5604c4c4cc34f9159c8abdcfa62863f", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1", "patch": "@@ -88,7 +88,6 @@ fn is_body_owner<'hir>(node: Node<'hir>, hir_id: HirId) -> bool {\n \n #[derive(Debug)]\n pub(super) struct HirOwnerData<'hir> {\n-    pub(super) attrs: &'hir IndexVec<ItemLocalId, &'hir [ast::Attribute]>,\n     pub(super) signature: Option<&'hir Owner<'hir>>,\n     pub(super) with_bodies: Option<&'hir mut OwnerNodes<'hir>>,\n }\n@@ -851,7 +850,7 @@ impl<'hir> Map<'hir> {\n     /// Given a node ID, gets a list of attributes associated with the AST\n     /// corresponding to the node-ID.\n     pub fn attrs(&self, id: HirId) -> &'hir [ast::Attribute] {\n-        self.tcx.hir_attrs(id.owner).get(id.local_id).copied().unwrap_or(&[])\n+        self.tcx.hir_attrs(id.owner).get(id.local_id)\n     }\n \n     /// Gets the span of the definition of the specified HIR node."}, {"sha": "cf4e473d8aca1691561e553411f63f6634e62be4", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1", "patch": "@@ -9,13 +9,15 @@ pub mod place;\n use crate::ich::StableHashingContext;\n use crate::ty::query::Providers;\n use crate::ty::TyCtxt;\n+use rustc_ast::Attribute;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def_id::{LocalDefId, LOCAL_CRATE};\n use rustc_hir::*;\n use rustc_index::vec::IndexVec;\n use rustc_span::DUMMY_SP;\n+use std::collections::BTreeMap;\n \n #[derive(Debug)]\n pub struct Owner<'tcx> {\n@@ -55,6 +57,48 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for OwnerNodes<'tcx> {\n     }\n }\n \n+#[derive(Copy, Clone)]\n+pub struct AttributeMap<'tcx> {\n+    map: &'tcx BTreeMap<HirId, &'tcx [Attribute]>,\n+    prefix: LocalDefId,\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for AttributeMap<'tcx> {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n+        let range = self.range();\n+\n+        range.clone().count().hash_stable(hcx, hasher);\n+        for (key, value) in range {\n+            key.hash_stable(hcx, hasher);\n+            value.hash_stable(hcx, hasher);\n+        }\n+    }\n+}\n+\n+impl<'tcx> std::fmt::Debug for AttributeMap<'tcx> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        f.debug_struct(\"AttributeMap\")\n+            .field(\"prefix\", &self.prefix)\n+            .field(\"range\", &&self.range().collect::<Vec<_>>()[..])\n+            .finish()\n+    }\n+}\n+\n+impl<'tcx> AttributeMap<'tcx> {\n+    fn get(&self, id: ItemLocalId) -> &'tcx [Attribute] {\n+        self.map.get(&HirId { owner: self.prefix, local_id: id }).copied().unwrap_or(&[])\n+    }\n+\n+    fn range(&self) -> std::collections::btree_map::Range<'_, rustc_hir::HirId, &[Attribute]> {\n+        let local_zero = ItemLocalId::from_u32(0);\n+        let range = HirId { owner: self.prefix, local_id: local_zero }..HirId {\n+            owner: LocalDefId { local_def_index: self.prefix.local_def_index + 1 },\n+            local_id: local_zero,\n+        };\n+        self.map.range(range)\n+    }\n+}\n+\n impl<'tcx> TyCtxt<'tcx> {\n     #[inline(always)]\n     pub fn hir(self) -> map::Map<'tcx> {\n@@ -76,7 +120,7 @@ pub fn provide(providers: &mut Providers) {\n     providers.hir_module_items = |tcx, id| &tcx.untracked_crate.modules[&id];\n     providers.hir_owner = |tcx, id| tcx.index_hir(LOCAL_CRATE).map[id].signature;\n     providers.hir_owner_nodes = |tcx, id| tcx.index_hir(LOCAL_CRATE).map[id].with_bodies.as_deref();\n-    providers.hir_attrs = |tcx, id| &tcx.index_hir(LOCAL_CRATE).map[id].attrs;\n+    providers.hir_attrs = |tcx, id| AttributeMap { map: &tcx.untracked_crate.attrs, prefix: id };\n     providers.def_span = |tcx, def_id| tcx.hir().span_if_local(def_id).unwrap_or(DUMMY_SP);\n     providers.fn_arg_names = |tcx, id| {\n         let hir = tcx.hir();"}, {"sha": "b03b26d64606cf83125138847a029b1daf6fb8b1", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=38d9d09a58803ebd1f5b4432f9e49d01d2fce0f1", "patch": "@@ -65,7 +65,7 @@ rustc_queries! {\n     ///\n     /// This can be conveniently accessed by methods on `tcx.hir()`.\n     /// Avoid calling this query directly.\n-    query hir_attrs(key: LocalDefId) -> &'tcx IndexVec<ItemLocalId, &'tcx [ast::Attribute]> {\n+    query hir_attrs(key: LocalDefId) -> rustc_middle::hir::AttributeMap<'tcx> {\n         eval_always\n         desc { |tcx| \"HIR owner attributes in `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }"}]}