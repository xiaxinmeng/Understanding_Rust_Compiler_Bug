{"sha": "2590701b2ac9004418c5ec49896f2cf2c5016df5", "node_id": "C_kwDOAAsO6NoAKDI1OTA3MDFiMmFjOTAwNDQxOGM1ZWM0OTg5NmYyY2YyYzUwMTZkZjU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-07T20:10:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-07T20:10:07Z"}, "message": "Auto merge of #8400 - Jarcho:split_matches, r=Manishearth\n\nSplit matches\n\nPart of #6680\n\nchangelog: None", "tree": {"sha": "235a41dc13fd77e140964f9ae6fae5dbade5e40d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/235a41dc13fd77e140964f9ae6fae5dbade5e40d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2590701b2ac9004418c5ec49896f2cf2c5016df5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2590701b2ac9004418c5ec49896f2cf2c5016df5", "html_url": "https://github.com/rust-lang/rust/commit/2590701b2ac9004418c5ec49896f2cf2c5016df5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2590701b2ac9004418c5ec49896f2cf2c5016df5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d43826e32a76c86eca768481a08dec434cd28e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d43826e32a76c86eca768481a08dec434cd28e8", "html_url": "https://github.com/rust-lang/rust/commit/3d43826e32a76c86eca768481a08dec434cd28e8"}, {"sha": "c65894cf1a3bc6b111305071942f77e8654a7a6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c65894cf1a3bc6b111305071942f77e8654a7a6a", "html_url": "https://github.com/rust-lang/rust/commit/c65894cf1a3bc6b111305071942f77e8654a7a6a"}], "stats": {"total": 4993, "additions": 2548, "deletions": 2445}, "files": [{"sha": "67fb918d20c0a4e35752e2482140e57c8110dcef", "filename": "clippy_lints/src/matches.rs", "status": "removed", "additions": 0, "deletions": 2445, "changes": 2445, "blob_url": "https://github.com/rust-lang/rust/blob/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d43826e32a76c86eca768481a08dec434cd28e8/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=3d43826e32a76c86eca768481a08dec434cd28e8", "patch": "@@ -1,2445 +0,0 @@\n-use clippy_utils::consts::{constant, constant_full_int, miri_to_const, FullInt};\n-use clippy_utils::diagnostics::{\n-    multispan_sugg, span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then,\n-};\n-use clippy_utils::macros::{is_panic, root_macro_call};\n-use clippy_utils::source::{expr_block, indent_of, snippet, snippet_block, snippet_opt, snippet_with_applicability};\n-use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, match_type, peel_mid_ty_refs};\n-use clippy_utils::visitors::is_local_used;\n-use clippy_utils::{\n-    get_parent_expr, is_lang_ctor, is_lint_allowed, is_refutable, is_unit_expr, is_wild, meets_msrv, msrvs,\n-    path_to_local, path_to_local_id, peel_blocks, peel_hir_pat_refs, peel_n_hir_expr_refs, recurse_or_patterns,\n-    strip_pat_refs,\n-};\n-use clippy_utils::{higher, peel_blocks_with_stmt};\n-use clippy_utils::{paths, search_same, SpanlessEq, SpanlessHash};\n-use core::iter::{once, ExactSizeIterator};\n-use if_chain::if_chain;\n-use rustc_ast::ast::{Attribute, LitKind};\n-use rustc_errors::Applicability;\n-use rustc_hir::def::{CtorKind, DefKind, Res};\n-use rustc_hir::LangItem::{OptionNone, OptionSome};\n-use rustc_hir::{\n-    self as hir, Arm, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, Guard, HirId, Local, MatchSource,\n-    Mutability, Node, Pat, PatKind, PathSegment, QPath, RangeEnd, TyKind,\n-};\n-use rustc_hir::{HirIdMap, HirIdSet};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, Ty, TyS, VariantDef};\n-use rustc_semver::RustcVersion;\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::source_map::{Span, Spanned};\n-use rustc_span::{sym, symbol::kw};\n-use std::cmp::{max, Ordering};\n-use std::collections::hash_map::Entry;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for matches with a single arm where an `if let`\n-    /// will usually suffice.\n-    ///\n-    /// ### Why is this bad?\n-    /// Just readability \u2013 `if let` nests less than a `match`.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # fn bar(stool: &str) {}\n-    /// # let x = Some(\"abc\");\n-    /// // Bad\n-    /// match x {\n-    ///     Some(ref foo) => bar(foo),\n-    ///     _ => (),\n-    /// }\n-    ///\n-    /// // Good\n-    /// if let Some(ref foo) = x {\n-    ///     bar(foo);\n-    /// }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub SINGLE_MATCH,\n-    style,\n-    \"a `match` statement with a single nontrivial arm (i.e., where the other arm is `_ => {}`) instead of `if let`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for matches with two arms where an `if let else` will\n-    /// usually suffice.\n-    ///\n-    /// ### Why is this bad?\n-    /// Just readability \u2013 `if let` nests less than a `match`.\n-    ///\n-    /// ### Known problems\n-    /// Personal style preferences may differ.\n-    ///\n-    /// ### Example\n-    /// Using `match`:\n-    ///\n-    /// ```rust\n-    /// # fn bar(foo: &usize) {}\n-    /// # let other_ref: usize = 1;\n-    /// # let x: Option<&usize> = Some(&1);\n-    /// match x {\n-    ///     Some(ref foo) => bar(foo),\n-    ///     _ => bar(&other_ref),\n-    /// }\n-    /// ```\n-    ///\n-    /// Using `if let` with `else`:\n-    ///\n-    /// ```rust\n-    /// # fn bar(foo: &usize) {}\n-    /// # let other_ref: usize = 1;\n-    /// # let x: Option<&usize> = Some(&1);\n-    /// if let Some(ref foo) = x {\n-    ///     bar(foo);\n-    /// } else {\n-    ///     bar(&other_ref);\n-    /// }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub SINGLE_MATCH_ELSE,\n-    pedantic,\n-    \"a `match` statement with two arms where the second arm's pattern is a placeholder instead of a specific match pattern\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for matches where all arms match a reference,\n-    /// suggesting to remove the reference and deref the matched expression\n-    /// instead. It also checks for `if let &foo = bar` blocks.\n-    ///\n-    /// ### Why is this bad?\n-    /// It just makes the code less readable. That reference\n-    /// destructuring adds nothing to the code.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// // Bad\n-    /// match x {\n-    ///     &A(ref y) => foo(y),\n-    ///     &B => bar(),\n-    ///     _ => frob(&x),\n-    /// }\n-    ///\n-    /// // Good\n-    /// match *x {\n-    ///     A(ref y) => foo(y),\n-    ///     B => bar(),\n-    ///     _ => frob(x),\n-    /// }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub MATCH_REF_PATS,\n-    style,\n-    \"a `match` or `if let` with all arms prefixed with `&` instead of deref-ing the match expression\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for matches where match expression is a `bool`. It\n-    /// suggests to replace the expression with an `if...else` block.\n-    ///\n-    /// ### Why is this bad?\n-    /// It makes the code less readable.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # fn foo() {}\n-    /// # fn bar() {}\n-    /// let condition: bool = true;\n-    /// match condition {\n-    ///     true => foo(),\n-    ///     false => bar(),\n-    /// }\n-    /// ```\n-    /// Use if/else instead:\n-    /// ```rust\n-    /// # fn foo() {}\n-    /// # fn bar() {}\n-    /// let condition: bool = true;\n-    /// if condition {\n-    ///     foo();\n-    /// } else {\n-    ///     bar();\n-    /// }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub MATCH_BOOL,\n-    pedantic,\n-    \"a `match` on a boolean expression instead of an `if..else` block\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for overlapping match arms.\n-    ///\n-    /// ### Why is this bad?\n-    /// It is likely to be an error and if not, makes the code\n-    /// less obvious.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let x = 5;\n-    /// match x {\n-    ///     1..=10 => println!(\"1 ... 10\"),\n-    ///     5..=15 => println!(\"5 ... 15\"),\n-    ///     _ => (),\n-    /// }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub MATCH_OVERLAPPING_ARM,\n-    style,\n-    \"a `match` with overlapping arms\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for arm which matches all errors with `Err(_)`\n-    /// and take drastic actions like `panic!`.\n-    ///\n-    /// ### Why is this bad?\n-    /// It is generally a bad practice, similar to\n-    /// catching all exceptions in java with `catch(Exception)`\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let x: Result<i32, &str> = Ok(3);\n-    /// match x {\n-    ///     Ok(_) => println!(\"ok\"),\n-    ///     Err(_) => panic!(\"err\"),\n-    /// }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub MATCH_WILD_ERR_ARM,\n-    pedantic,\n-    \"a `match` with `Err(_)` arm and take drastic actions\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for match which is used to add a reference to an\n-    /// `Option` value.\n-    ///\n-    /// ### Why is this bad?\n-    /// Using `as_ref()` or `as_mut()` instead is shorter.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let x: Option<()> = None;\n-    ///\n-    /// // Bad\n-    /// let r: Option<&()> = match x {\n-    ///     None => None,\n-    ///     Some(ref v) => Some(v),\n-    /// };\n-    ///\n-    /// // Good\n-    /// let r: Option<&()> = x.as_ref();\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub MATCH_AS_REF,\n-    complexity,\n-    \"a `match` on an Option value instead of using `as_ref()` or `as_mut`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for wildcard enum matches using `_`.\n-    ///\n-    /// ### Why is this bad?\n-    /// New enum variants added by library updates can be missed.\n-    ///\n-    /// ### Known problems\n-    /// Suggested replacements may be incorrect if guards exhaustively cover some\n-    /// variants, and also may not use correct path to enum if it's not present in the current scope.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # enum Foo { A(usize), B(usize) }\n-    /// # let x = Foo::B(1);\n-    /// // Bad\n-    /// match x {\n-    ///     Foo::A(_) => {},\n-    ///     _ => {},\n-    /// }\n-    ///\n-    /// // Good\n-    /// match x {\n-    ///     Foo::A(_) => {},\n-    ///     Foo::B(_) => {},\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.34.0\"]\n-    pub WILDCARD_ENUM_MATCH_ARM,\n-    restriction,\n-    \"a wildcard enum match arm using `_`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for wildcard enum matches for a single variant.\n-    ///\n-    /// ### Why is this bad?\n-    /// New enum variants added by library updates can be missed.\n-    ///\n-    /// ### Known problems\n-    /// Suggested replacements may not use correct path to enum\n-    /// if it's not present in the current scope.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # enum Foo { A, B, C }\n-    /// # let x = Foo::B;\n-    /// // Bad\n-    /// match x {\n-    ///     Foo::A => {},\n-    ///     Foo::B => {},\n-    ///     _ => {},\n-    /// }\n-    ///\n-    /// // Good\n-    /// match x {\n-    ///     Foo::A => {},\n-    ///     Foo::B => {},\n-    ///     Foo::C => {},\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.45.0\"]\n-    pub MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n-    pedantic,\n-    \"a wildcard enum match for a single variant\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for wildcard pattern used with others patterns in same match arm.\n-    ///\n-    /// ### Why is this bad?\n-    /// Wildcard pattern already covers any other pattern as it will match anyway.\n-    /// It makes the code less readable, especially to spot wildcard pattern use in match arm.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// // Bad\n-    /// match \"foo\" {\n-    ///     \"a\" => {},\n-    ///     \"bar\" | _ => {},\n-    /// }\n-    ///\n-    /// // Good\n-    /// match \"foo\" {\n-    ///     \"a\" => {},\n-    ///     _ => {},\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.42.0\"]\n-    pub WILDCARD_IN_OR_PATTERNS,\n-    complexity,\n-    \"a wildcard pattern used with others patterns in same match arm\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for matches being used to destructure a single-variant enum\n-    /// or tuple struct where a `let` will suffice.\n-    ///\n-    /// ### Why is this bad?\n-    /// Just readability \u2013 `let` doesn't nest, whereas a `match` does.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// enum Wrapper {\n-    ///     Data(i32),\n-    /// }\n-    ///\n-    /// let wrapper = Wrapper::Data(42);\n-    ///\n-    /// let data = match wrapper {\n-    ///     Wrapper::Data(i) => i,\n-    /// };\n-    /// ```\n-    ///\n-    /// The correct use would be:\n-    /// ```rust\n-    /// enum Wrapper {\n-    ///     Data(i32),\n-    /// }\n-    ///\n-    /// let wrapper = Wrapper::Data(42);\n-    /// let Wrapper::Data(data) = wrapper;\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub INFALLIBLE_DESTRUCTURING_MATCH,\n-    style,\n-    \"a `match` statement with a single infallible arm instead of a `let`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for useless match that binds to only one value.\n-    ///\n-    /// ### Why is this bad?\n-    /// Readability and needless complexity.\n-    ///\n-    /// ### Known problems\n-    ///  Suggested replacements may be incorrect when `match`\n-    /// is actually binding temporary value, bringing a 'dropped while borrowed' error.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let a = 1;\n-    /// # let b = 2;\n-    ///\n-    /// // Bad\n-    /// match (a, b) {\n-    ///     (c, d) => {\n-    ///         // useless match\n-    ///     }\n-    /// }\n-    ///\n-    /// // Good\n-    /// let (c, d) = (a, b);\n-    /// ```\n-    #[clippy::version = \"1.43.0\"]\n-    pub MATCH_SINGLE_BINDING,\n-    complexity,\n-    \"a match with a single binding instead of using `let` statement\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for unnecessary '..' pattern binding on struct when all fields are explicitly matched.\n-    ///\n-    /// ### Why is this bad?\n-    /// Correctness and readability. It's like having a wildcard pattern after\n-    /// matching all enum variants explicitly.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # struct A { a: i32 }\n-    /// let a = A { a: 5 };\n-    ///\n-    /// // Bad\n-    /// match a {\n-    ///     A { a: 5, .. } => {},\n-    ///     _ => {},\n-    /// }\n-    ///\n-    /// // Good\n-    /// match a {\n-    ///     A { a: 5 } => {},\n-    ///     _ => {},\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.43.0\"]\n-    pub REST_PAT_IN_FULLY_BOUND_STRUCTS,\n-    restriction,\n-    \"a match on a struct that binds all fields but still uses the wildcard pattern\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Lint for redundant pattern matching over `Result`, `Option`,\n-    /// `std::task::Poll` or `std::net::IpAddr`\n-    ///\n-    /// ### Why is this bad?\n-    /// It's more concise and clear to just use the proper\n-    /// utility function\n-    ///\n-    /// ### Known problems\n-    /// This will change the drop order for the matched type. Both `if let` and\n-    /// `while let` will drop the value at the end of the block, both `if` and `while` will drop the\n-    /// value before entering the block. For most types this change will not matter, but for a few\n-    /// types this will not be an acceptable change (e.g. locks). See the\n-    /// [reference](https://doc.rust-lang.org/reference/destructors.html#drop-scopes) for more about\n-    /// drop order.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # use std::task::Poll;\n-    /// # use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n-    /// if let Ok(_) = Ok::<i32, i32>(42) {}\n-    /// if let Err(_) = Err::<i32, i32>(42) {}\n-    /// if let None = None::<()> {}\n-    /// if let Some(_) = Some(42) {}\n-    /// if let Poll::Pending = Poll::Pending::<()> {}\n-    /// if let Poll::Ready(_) = Poll::Ready(42) {}\n-    /// if let IpAddr::V4(_) = IpAddr::V4(Ipv4Addr::LOCALHOST) {}\n-    /// if let IpAddr::V6(_) = IpAddr::V6(Ipv6Addr::LOCALHOST) {}\n-    /// match Ok::<i32, i32>(42) {\n-    ///     Ok(_) => true,\n-    ///     Err(_) => false,\n-    /// };\n-    /// ```\n-    ///\n-    /// The more idiomatic use would be:\n-    ///\n-    /// ```rust\n-    /// # use std::task::Poll;\n-    /// # use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n-    /// if Ok::<i32, i32>(42).is_ok() {}\n-    /// if Err::<i32, i32>(42).is_err() {}\n-    /// if None::<()>.is_none() {}\n-    /// if Some(42).is_some() {}\n-    /// if Poll::Pending::<()>.is_pending() {}\n-    /// if Poll::Ready(42).is_ready() {}\n-    /// if IpAddr::V4(Ipv4Addr::LOCALHOST).is_ipv4() {}\n-    /// if IpAddr::V6(Ipv6Addr::LOCALHOST).is_ipv6() {}\n-    /// Ok::<i32, i32>(42).is_ok();\n-    /// ```\n-    #[clippy::version = \"1.31.0\"]\n-    pub REDUNDANT_PATTERN_MATCHING,\n-    style,\n-    \"use the proper utility function avoiding an `if let`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for `match`  or `if let` expressions producing a\n-    /// `bool` that could be written using `matches!`\n-    ///\n-    /// ### Why is this bad?\n-    /// Readability and needless complexity.\n-    ///\n-    /// ### Known problems\n-    /// This lint falsely triggers, if there are arms with\n-    /// `cfg` attributes that remove an arm evaluating to `false`.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let x = Some(5);\n-    ///\n-    /// // Bad\n-    /// let a = match x {\n-    ///     Some(0) => true,\n-    ///     _ => false,\n-    /// };\n-    ///\n-    /// let a = if let Some(0) = x {\n-    ///     true\n-    /// } else {\n-    ///     false\n-    /// };\n-    ///\n-    /// // Good\n-    /// let a = matches!(x, Some(0));\n-    /// ```\n-    #[clippy::version = \"1.47.0\"]\n-    pub MATCH_LIKE_MATCHES_MACRO,\n-    style,\n-    \"a match that could be written with the matches! macro\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for `match` with identical arm bodies.\n-    ///\n-    /// ### Why is this bad?\n-    /// This is probably a copy & paste error. If arm bodies\n-    /// are the same on purpose, you can factor them\n-    /// [using `|`](https://doc.rust-lang.org/book/patterns.html#multiple-patterns).\n-    ///\n-    /// ### Known problems\n-    /// False positive possible with order dependent `match`\n-    /// (see issue\n-    /// [#860](https://github.com/rust-lang/rust-clippy/issues/860)).\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// match foo {\n-    ///     Bar => bar(),\n-    ///     Quz => quz(),\n-    ///     Baz => bar(), // <= oops\n-    /// }\n-    /// ```\n-    ///\n-    /// This should probably be\n-    /// ```rust,ignore\n-    /// match foo {\n-    ///     Bar => bar(),\n-    ///     Quz => quz(),\n-    ///     Baz => baz(), // <= fixed\n-    /// }\n-    /// ```\n-    ///\n-    /// or if the original code was not a typo:\n-    /// ```rust,ignore\n-    /// match foo {\n-    ///     Bar | Baz => bar(), // <= shows the intent better\n-    ///     Quz => quz(),\n-    /// }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub MATCH_SAME_ARMS,\n-    pedantic,\n-    \"`match` with identical arm bodies\"\n-}\n-\n-#[derive(Default)]\n-pub struct Matches {\n-    msrv: Option<RustcVersion>,\n-    infallible_destructuring_match_linted: bool,\n-}\n-\n-impl Matches {\n-    #[must_use]\n-    pub fn new(msrv: Option<RustcVersion>) -> Self {\n-        Self {\n-            msrv,\n-            ..Matches::default()\n-        }\n-    }\n-}\n-\n-impl_lint_pass!(Matches => [\n-    SINGLE_MATCH,\n-    MATCH_REF_PATS,\n-    MATCH_BOOL,\n-    SINGLE_MATCH_ELSE,\n-    MATCH_OVERLAPPING_ARM,\n-    MATCH_WILD_ERR_ARM,\n-    MATCH_AS_REF,\n-    WILDCARD_ENUM_MATCH_ARM,\n-    MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n-    WILDCARD_IN_OR_PATTERNS,\n-    MATCH_SINGLE_BINDING,\n-    INFALLIBLE_DESTRUCTURING_MATCH,\n-    REST_PAT_IN_FULLY_BOUND_STRUCTS,\n-    REDUNDANT_PATTERN_MATCHING,\n-    MATCH_LIKE_MATCHES_MACRO,\n-    MATCH_SAME_ARMS,\n-]);\n-\n-impl<'tcx> LateLintPass<'tcx> for Matches {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if expr.span.from_expansion() {\n-            return;\n-        }\n-\n-        redundant_pattern_match::check(cx, expr);\n-\n-        if meets_msrv(self.msrv.as_ref(), &msrvs::MATCHES_MACRO) {\n-            if !check_match_like_matches(cx, expr) {\n-                lint_match_arms(cx, expr);\n-            }\n-        } else {\n-            lint_match_arms(cx, expr);\n-        }\n-\n-        if let ExprKind::Match(ex, arms, MatchSource::Normal) = expr.kind {\n-            check_single_match(cx, ex, arms, expr);\n-            check_match_bool(cx, ex, arms, expr);\n-            check_overlapping_arms(cx, ex, arms);\n-            check_wild_err_arm(cx, ex, arms);\n-            check_wild_enum_match(cx, ex, arms);\n-            check_match_as_ref(cx, ex, arms, expr);\n-            check_wild_in_or_pats(cx, arms);\n-\n-            if self.infallible_destructuring_match_linted {\n-                self.infallible_destructuring_match_linted = false;\n-            } else {\n-                check_match_single_binding(cx, ex, arms, expr);\n-            }\n-        }\n-        if let ExprKind::Match(ex, arms, _) = expr.kind {\n-            check_match_ref_pats(cx, ex, arms.iter().map(|el| el.pat), expr);\n-        }\n-    }\n-\n-    fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'_>) {\n-        if_chain! {\n-            if !local.span.from_expansion();\n-            if let Some(expr) = local.init;\n-            if let ExprKind::Match(target, arms, MatchSource::Normal) = expr.kind;\n-            if arms.len() == 1 && arms[0].guard.is_none();\n-            if let PatKind::TupleStruct(\n-                QPath::Resolved(None, variant_name), args, _) = arms[0].pat.kind;\n-            if args.len() == 1;\n-            if let PatKind::Binding(_, arg, ..) = strip_pat_refs(&args[0]).kind;\n-            let body = peel_blocks(arms[0].body);\n-            if path_to_local_id(body, arg);\n-\n-            then {\n-                let mut applicability = Applicability::MachineApplicable;\n-                self.infallible_destructuring_match_linted = true;\n-                span_lint_and_sugg(\n-                    cx,\n-                    INFALLIBLE_DESTRUCTURING_MATCH,\n-                    local.span,\n-                    \"you seem to be trying to use `match` to destructure a single infallible pattern. \\\n-                    Consider using `let`\",\n-                    \"try this\",\n-                    format!(\n-                        \"let {}({}) = {};\",\n-                        snippet_with_applicability(cx, variant_name.span, \"..\", &mut applicability),\n-                        snippet_with_applicability(cx, local.pat.span, \"..\", &mut applicability),\n-                        snippet_with_applicability(cx, target.span, \"..\", &mut applicability),\n-                    ),\n-                    applicability,\n-                );\n-            }\n-        }\n-    }\n-\n-    fn check_pat(&mut self, cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) {\n-        if_chain! {\n-            if !pat.span.from_expansion();\n-            if let PatKind::Struct(QPath::Resolved(_, path), fields, true) = pat.kind;\n-            if let Some(def_id) = path.res.opt_def_id();\n-            let ty = cx.tcx.type_of(def_id);\n-            if let ty::Adt(def, _) = ty.kind();\n-            if def.is_struct() || def.is_union();\n-            if fields.len() == def.non_enum_variant().fields.len();\n-\n-            then {\n-                span_lint_and_help(\n-                    cx,\n-                    REST_PAT_IN_FULLY_BOUND_STRUCTS,\n-                    pat.span,\n-                    \"unnecessary use of `..` pattern in struct binding. All fields were already bound\",\n-                    None,\n-                    \"consider removing `..` from this binding\",\n-                );\n-            }\n-        }\n-    }\n-\n-    extract_msrv_attr!(LateContext);\n-}\n-\n-#[rustfmt::skip]\n-fn check_single_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n-    if arms.len() == 2 && arms[0].guard.is_none() && arms[1].guard.is_none() {\n-        if expr.span.from_expansion() {\n-            // Don't lint match expressions present in\n-            // macro_rules! block\n-            return;\n-        }\n-        if let PatKind::Or(..) = arms[0].pat.kind {\n-            // don't lint for or patterns for now, this makes\n-            // the lint noisy in unnecessary situations\n-            return;\n-        }\n-        let els = arms[1].body;\n-        let els = if is_unit_expr(peel_blocks(els)) {\n-            None\n-        } else if let ExprKind::Block(Block { stmts, expr: block_expr, .. }, _) = els.kind {\n-            if stmts.len() == 1 && block_expr.is_none() || stmts.is_empty() && block_expr.is_some() {\n-                // single statement/expr \"else\" block, don't lint\n-                return;\n-            }\n-            // block with 2+ statements or 1 expr and 1+ statement\n-            Some(els)\n-        } else {\n-            // not a block, don't lint\n-            return;\n-        };\n-\n-        let ty = cx.typeck_results().expr_ty(ex);\n-        if *ty.kind() != ty::Bool || is_lint_allowed(cx, MATCH_BOOL, ex.hir_id) {\n-            check_single_match_single_pattern(cx, ex, arms, expr, els);\n-            check_single_match_opt_like(cx, ex, arms, expr, ty, els);\n-        }\n-    }\n-}\n-\n-fn check_single_match_single_pattern(\n-    cx: &LateContext<'_>,\n-    ex: &Expr<'_>,\n-    arms: &[Arm<'_>],\n-    expr: &Expr<'_>,\n-    els: Option<&Expr<'_>>,\n-) {\n-    if is_wild(arms[1].pat) {\n-        report_single_match_single_pattern(cx, ex, arms, expr, els);\n-    }\n-}\n-\n-fn report_single_match_single_pattern(\n-    cx: &LateContext<'_>,\n-    ex: &Expr<'_>,\n-    arms: &[Arm<'_>],\n-    expr: &Expr<'_>,\n-    els: Option<&Expr<'_>>,\n-) {\n-    let lint = if els.is_some() { SINGLE_MATCH_ELSE } else { SINGLE_MATCH };\n-    let els_str = els.map_or(String::new(), |els| {\n-        format!(\" else {}\", expr_block(cx, els, None, \"..\", Some(expr.span)))\n-    });\n-\n-    let (pat, pat_ref_count) = peel_hir_pat_refs(arms[0].pat);\n-    let (msg, sugg) = if_chain! {\n-        if let PatKind::Path(_) | PatKind::Lit(_) = pat.kind;\n-        let (ty, ty_ref_count) = peel_mid_ty_refs(cx.typeck_results().expr_ty(ex));\n-        if let Some(spe_trait_id) = cx.tcx.lang_items().structural_peq_trait();\n-        if let Some(pe_trait_id) = cx.tcx.lang_items().eq_trait();\n-        if ty.is_integral() || ty.is_char() || ty.is_str()\n-            || (implements_trait(cx, ty, spe_trait_id, &[])\n-                && implements_trait(cx, ty, pe_trait_id, &[ty.into()]));\n-        then {\n-            // scrutinee derives PartialEq and the pattern is a constant.\n-            let pat_ref_count = match pat.kind {\n-                // string literals are already a reference.\n-                PatKind::Lit(Expr { kind: ExprKind::Lit(lit), .. }) if lit.node.is_str() => pat_ref_count + 1,\n-                _ => pat_ref_count,\n-            };\n-            // References are only implicitly added to the pattern, so no overflow here.\n-            // e.g. will work: match &Some(_) { Some(_) => () }\n-            // will not: match Some(_) { &Some(_) => () }\n-            let ref_count_diff = ty_ref_count - pat_ref_count;\n-\n-            // Try to remove address of expressions first.\n-            let (ex, removed) = peel_n_hir_expr_refs(ex, ref_count_diff);\n-            let ref_count_diff = ref_count_diff - removed;\n-\n-            let msg = \"you seem to be trying to use `match` for an equality check. Consider using `if`\";\n-            let sugg = format!(\n-                \"if {} == {}{} {}{}\",\n-                snippet(cx, ex.span, \"..\"),\n-                // PartialEq for different reference counts may not exist.\n-                \"&\".repeat(ref_count_diff),\n-                snippet(cx, arms[0].pat.span, \"..\"),\n-                expr_block(cx, arms[0].body, None, \"..\", Some(expr.span)),\n-                els_str,\n-            );\n-            (msg, sugg)\n-        } else {\n-            let msg = \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\";\n-            let sugg = format!(\n-                \"if let {} = {} {}{}\",\n-                snippet(cx, arms[0].pat.span, \"..\"),\n-                snippet(cx, ex.span, \"..\"),\n-                expr_block(cx, arms[0].body, None, \"..\", Some(expr.span)),\n-                els_str,\n-            );\n-            (msg, sugg)\n-        }\n-    };\n-\n-    span_lint_and_sugg(\n-        cx,\n-        lint,\n-        expr.span,\n-        msg,\n-        \"try this\",\n-        sugg,\n-        Applicability::HasPlaceholders,\n-    );\n-}\n-\n-fn check_single_match_opt_like<'a>(\n-    cx: &LateContext<'a>,\n-    ex: &Expr<'_>,\n-    arms: &[Arm<'_>],\n-    expr: &Expr<'_>,\n-    ty: Ty<'a>,\n-    els: Option<&Expr<'_>>,\n-) {\n-    // list of candidate `Enum`s we know will never get any more members\n-    let candidates = &[\n-        (&paths::COW, \"Borrowed\"),\n-        (&paths::COW, \"Cow::Borrowed\"),\n-        (&paths::COW, \"Cow::Owned\"),\n-        (&paths::COW, \"Owned\"),\n-        (&paths::OPTION, \"None\"),\n-        (&paths::RESULT, \"Err\"),\n-        (&paths::RESULT, \"Ok\"),\n-    ];\n-\n-    // We want to suggest to exclude an arm that contains only wildcards or forms the exhaustive\n-    // match with the second branch, without enum variants in matches.\n-    if !contains_only_wilds(arms[1].pat) && !form_exhaustive_matches(arms[0].pat, arms[1].pat) {\n-        return;\n-    }\n-\n-    let mut paths_and_types = Vec::new();\n-    if !collect_pat_paths(&mut paths_and_types, cx, arms[1].pat, ty) {\n-        return;\n-    }\n-\n-    let in_candidate_enum = |path_info: &(String, &TyS<'_>)| -> bool {\n-        let (path, ty) = path_info;\n-        for &(ty_path, pat_path) in candidates {\n-            if path == pat_path && match_type(cx, ty, ty_path) {\n-                return true;\n-            }\n-        }\n-        false\n-    };\n-    if paths_and_types.iter().all(in_candidate_enum) {\n-        report_single_match_single_pattern(cx, ex, arms, expr, els);\n-    }\n-}\n-\n-/// Collects paths and their types from the given patterns. Returns true if the given pattern could\n-/// be simplified, false otherwise.\n-fn collect_pat_paths<'a>(acc: &mut Vec<(String, Ty<'a>)>, cx: &LateContext<'a>, pat: &Pat<'_>, ty: Ty<'a>) -> bool {\n-    match pat.kind {\n-        PatKind::Wild => true,\n-        PatKind::Tuple(inner, _) => inner.iter().all(|p| {\n-            let p_ty = cx.typeck_results().pat_ty(p);\n-            collect_pat_paths(acc, cx, p, p_ty)\n-        }),\n-        PatKind::TupleStruct(ref path, ..) => {\n-            let path = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n-                s.print_qpath(path, false);\n-            });\n-            acc.push((path, ty));\n-            true\n-        },\n-        PatKind::Binding(BindingAnnotation::Unannotated, .., ident, None) => {\n-            acc.push((ident.to_string(), ty));\n-            true\n-        },\n-        PatKind::Path(ref path) => {\n-            let path = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n-                s.print_qpath(path, false);\n-            });\n-            acc.push((path, ty));\n-            true\n-        },\n-        _ => false,\n-    }\n-}\n-\n-/// Returns true if the given arm of pattern matching contains wildcard patterns.\n-fn contains_only_wilds(pat: &Pat<'_>) -> bool {\n-    match pat.kind {\n-        PatKind::Wild => true,\n-        PatKind::Tuple(inner, _) | PatKind::TupleStruct(_, inner, ..) => inner.iter().all(contains_only_wilds),\n-        _ => false,\n-    }\n-}\n-\n-/// Returns true if the given patterns forms only exhaustive matches that don't contain enum\n-/// patterns without a wildcard.\n-fn form_exhaustive_matches(left: &Pat<'_>, right: &Pat<'_>) -> bool {\n-    match (&left.kind, &right.kind) {\n-        (PatKind::Wild, _) | (_, PatKind::Wild) => true,\n-        (PatKind::Tuple(left_in, left_pos), PatKind::Tuple(right_in, right_pos)) => {\n-            // We don't actually know the position and the presence of the `..` (dotdot) operator\n-            // in the arms, so we need to evaluate the correct offsets here in order to iterate in\n-            // both arms at the same time.\n-            let len = max(\n-                left_in.len() + {\n-                    if left_pos.is_some() { 1 } else { 0 }\n-                },\n-                right_in.len() + {\n-                    if right_pos.is_some() { 1 } else { 0 }\n-                },\n-            );\n-            let mut left_pos = left_pos.unwrap_or(usize::MAX);\n-            let mut right_pos = right_pos.unwrap_or(usize::MAX);\n-            let mut left_dot_space = 0;\n-            let mut right_dot_space = 0;\n-            for i in 0..len {\n-                let mut found_dotdot = false;\n-                if i == left_pos {\n-                    left_dot_space += 1;\n-                    if left_dot_space < len - left_in.len() {\n-                        left_pos += 1;\n-                    }\n-                    found_dotdot = true;\n-                }\n-                if i == right_pos {\n-                    right_dot_space += 1;\n-                    if right_dot_space < len - right_in.len() {\n-                        right_pos += 1;\n-                    }\n-                    found_dotdot = true;\n-                }\n-                if found_dotdot {\n-                    continue;\n-                }\n-                if !contains_only_wilds(&left_in[i - left_dot_space])\n-                    && !contains_only_wilds(&right_in[i - right_dot_space])\n-                {\n-                    return false;\n-                }\n-            }\n-            true\n-        },\n-        _ => false,\n-    }\n-}\n-\n-fn check_match_bool(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n-    // Type of expression is `bool`.\n-    if *cx.typeck_results().expr_ty(ex).kind() == ty::Bool {\n-        span_lint_and_then(\n-            cx,\n-            MATCH_BOOL,\n-            expr.span,\n-            \"you seem to be trying to match on a boolean expression\",\n-            move |diag| {\n-                if arms.len() == 2 {\n-                    // no guards\n-                    let exprs = if let PatKind::Lit(arm_bool) = arms[0].pat.kind {\n-                        if let ExprKind::Lit(ref lit) = arm_bool.kind {\n-                            match lit.node {\n-                                LitKind::Bool(true) => Some((&*arms[0].body, &*arms[1].body)),\n-                                LitKind::Bool(false) => Some((&*arms[1].body, &*arms[0].body)),\n-                                _ => None,\n-                            }\n-                        } else {\n-                            None\n-                        }\n-                    } else {\n-                        None\n-                    };\n-\n-                    if let Some((true_expr, false_expr)) = exprs {\n-                        let sugg = match (is_unit_expr(true_expr), is_unit_expr(false_expr)) {\n-                            (false, false) => Some(format!(\n-                                \"if {} {} else {}\",\n-                                snippet(cx, ex.span, \"b\"),\n-                                expr_block(cx, true_expr, None, \"..\", Some(expr.span)),\n-                                expr_block(cx, false_expr, None, \"..\", Some(expr.span))\n-                            )),\n-                            (false, true) => Some(format!(\n-                                \"if {} {}\",\n-                                snippet(cx, ex.span, \"b\"),\n-                                expr_block(cx, true_expr, None, \"..\", Some(expr.span))\n-                            )),\n-                            (true, false) => {\n-                                let test = Sugg::hir(cx, ex, \"..\");\n-                                Some(format!(\n-                                    \"if {} {}\",\n-                                    !test,\n-                                    expr_block(cx, false_expr, None, \"..\", Some(expr.span))\n-                                ))\n-                            },\n-                            (true, true) => None,\n-                        };\n-\n-                        if let Some(sugg) = sugg {\n-                            diag.span_suggestion(\n-                                expr.span,\n-                                \"consider using an `if`/`else` expression\",\n-                                sugg,\n-                                Applicability::HasPlaceholders,\n-                            );\n-                        }\n-                    }\n-                }\n-            },\n-        );\n-    }\n-}\n-\n-fn check_overlapping_arms<'tcx>(cx: &LateContext<'tcx>, ex: &'tcx Expr<'_>, arms: &'tcx [Arm<'_>]) {\n-    if arms.len() >= 2 && cx.typeck_results().expr_ty(ex).is_integral() {\n-        let ranges = all_ranges(cx, arms, cx.typeck_results().expr_ty(ex));\n-        if !ranges.is_empty() {\n-            if let Some((start, end)) = overlapping(&ranges) {\n-                span_lint_and_note(\n-                    cx,\n-                    MATCH_OVERLAPPING_ARM,\n-                    start.span,\n-                    \"some ranges overlap\",\n-                    Some(end.span),\n-                    \"overlaps with this\",\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-fn check_wild_err_arm<'tcx>(cx: &LateContext<'tcx>, ex: &Expr<'tcx>, arms: &[Arm<'tcx>]) {\n-    let ex_ty = cx.typeck_results().expr_ty(ex).peel_refs();\n-    if is_type_diagnostic_item(cx, ex_ty, sym::Result) {\n-        for arm in arms {\n-            if let PatKind::TupleStruct(ref path, inner, _) = arm.pat.kind {\n-                let path_str = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false));\n-                if path_str == \"Err\" {\n-                    let mut matching_wild = inner.iter().any(is_wild);\n-                    let mut ident_bind_name = kw::Underscore;\n-                    if !matching_wild {\n-                        // Looking for unused bindings (i.e.: `_e`)\n-                        for pat in inner.iter() {\n-                            if let PatKind::Binding(_, id, ident, None) = pat.kind {\n-                                if ident.as_str().starts_with('_') && !is_local_used(cx, arm.body, id) {\n-                                    ident_bind_name = ident.name;\n-                                    matching_wild = true;\n-                                }\n-                            }\n-                        }\n-                    }\n-                    if_chain! {\n-                        if matching_wild;\n-                        if let Some(macro_call) = root_macro_call(peel_blocks_with_stmt(arm.body).span);\n-                        if is_panic(cx, macro_call.def_id);\n-                        then {\n-                            // `Err(_)` or `Err(_e)` arm with `panic!` found\n-                            span_lint_and_note(cx,\n-                                MATCH_WILD_ERR_ARM,\n-                                arm.pat.span,\n-                                &format!(\"`Err({})` matches all errors\", ident_bind_name),\n-                                None,\n-                                \"match each error separately or use the error output, or use `.except(msg)` if the error case is unreachable\",\n-                            );\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-enum CommonPrefixSearcher<'a> {\n-    None,\n-    Path(&'a [PathSegment<'a>]),\n-    Mixed,\n-}\n-impl<'a> CommonPrefixSearcher<'a> {\n-    fn with_path(&mut self, path: &'a [PathSegment<'a>]) {\n-        match path {\n-            [path @ .., _] => self.with_prefix(path),\n-            [] => (),\n-        }\n-    }\n-\n-    fn with_prefix(&mut self, path: &'a [PathSegment<'a>]) {\n-        match self {\n-            Self::None => *self = Self::Path(path),\n-            Self::Path(self_path)\n-                if path\n-                    .iter()\n-                    .map(|p| p.ident.name)\n-                    .eq(self_path.iter().map(|p| p.ident.name)) => {},\n-            Self::Path(_) => *self = Self::Mixed,\n-            Self::Mixed => (),\n-        }\n-    }\n-}\n-\n-fn is_hidden(cx: &LateContext<'_>, variant_def: &VariantDef) -> bool {\n-    let attrs = cx.tcx.get_attrs(variant_def.def_id);\n-    clippy_utils::attrs::is_doc_hidden(attrs) || clippy_utils::attrs::is_unstable(attrs)\n-}\n-\n-#[allow(clippy::too_many_lines)]\n-fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n-    let ty = cx.typeck_results().expr_ty(ex).peel_refs();\n-    let adt_def = match ty.kind() {\n-        ty::Adt(adt_def, _)\n-            if adt_def.is_enum()\n-                && !(is_type_diagnostic_item(cx, ty, sym::Option) || is_type_diagnostic_item(cx, ty, sym::Result)) =>\n-        {\n-            adt_def\n-        },\n-        _ => return,\n-    };\n-\n-    // First pass - check for violation, but don't do much book-keeping because this is hopefully\n-    // the uncommon case, and the book-keeping is slightly expensive.\n-    let mut wildcard_span = None;\n-    let mut wildcard_ident = None;\n-    let mut has_non_wild = false;\n-    for arm in arms {\n-        match peel_hir_pat_refs(arm.pat).0.kind {\n-            PatKind::Wild => wildcard_span = Some(arm.pat.span),\n-            PatKind::Binding(_, _, ident, None) => {\n-                wildcard_span = Some(arm.pat.span);\n-                wildcard_ident = Some(ident);\n-            },\n-            _ => has_non_wild = true,\n-        }\n-    }\n-    let wildcard_span = match wildcard_span {\n-        Some(x) if has_non_wild => x,\n-        _ => return,\n-    };\n-\n-    // Accumulate the variants which should be put in place of the wildcard because they're not\n-    // already covered.\n-    let has_hidden = adt_def.variants.iter().any(|x| is_hidden(cx, x));\n-    let mut missing_variants: Vec<_> = adt_def.variants.iter().filter(|x| !is_hidden(cx, x)).collect();\n-\n-    let mut path_prefix = CommonPrefixSearcher::None;\n-    for arm in arms {\n-        // Guards mean that this case probably isn't exhaustively covered. Technically\n-        // this is incorrect, as we should really check whether each variant is exhaustively\n-        // covered by the set of guards that cover it, but that's really hard to do.\n-        recurse_or_patterns(arm.pat, |pat| {\n-            let path = match &peel_hir_pat_refs(pat).0.kind {\n-                PatKind::Path(path) => {\n-                    #[allow(clippy::match_same_arms)]\n-                    let id = match cx.qpath_res(path, pat.hir_id) {\n-                        Res::Def(\n-                            DefKind::Const | DefKind::ConstParam | DefKind::AnonConst | DefKind::InlineConst,\n-                            _,\n-                        ) => return,\n-                        Res::Def(_, id) => id,\n-                        _ => return,\n-                    };\n-                    if arm.guard.is_none() {\n-                        missing_variants.retain(|e| e.ctor_def_id != Some(id));\n-                    }\n-                    path\n-                },\n-                PatKind::TupleStruct(path, patterns, ..) => {\n-                    if let Some(id) = cx.qpath_res(path, pat.hir_id).opt_def_id() {\n-                        if arm.guard.is_none() && patterns.iter().all(|p| !is_refutable(cx, p)) {\n-                            missing_variants.retain(|e| e.ctor_def_id != Some(id));\n-                        }\n-                    }\n-                    path\n-                },\n-                PatKind::Struct(path, patterns, ..) => {\n-                    if let Some(id) = cx.qpath_res(path, pat.hir_id).opt_def_id() {\n-                        if arm.guard.is_none() && patterns.iter().all(|p| !is_refutable(cx, p.pat)) {\n-                            missing_variants.retain(|e| e.def_id != id);\n-                        }\n-                    }\n-                    path\n-                },\n-                _ => return,\n-            };\n-            match path {\n-                QPath::Resolved(_, path) => path_prefix.with_path(path.segments),\n-                QPath::TypeRelative(\n-                    hir::Ty {\n-                        kind: TyKind::Path(QPath::Resolved(_, path)),\n-                        ..\n-                    },\n-                    _,\n-                ) => path_prefix.with_prefix(path.segments),\n-                _ => (),\n-            }\n-        });\n-    }\n-\n-    let format_suggestion = |variant: &VariantDef| {\n-        format!(\n-            \"{}{}{}{}\",\n-            if let Some(ident) = wildcard_ident {\n-                format!(\"{} @ \", ident.name)\n-            } else {\n-                String::new()\n-            },\n-            if let CommonPrefixSearcher::Path(path_prefix) = path_prefix {\n-                let mut s = String::new();\n-                for seg in path_prefix {\n-                    s.push_str(seg.ident.as_str());\n-                    s.push_str(\"::\");\n-                }\n-                s\n-            } else {\n-                let mut s = cx.tcx.def_path_str(adt_def.did);\n-                s.push_str(\"::\");\n-                s\n-            },\n-            variant.name,\n-            match variant.ctor_kind {\n-                CtorKind::Fn if variant.fields.len() == 1 => \"(_)\",\n-                CtorKind::Fn => \"(..)\",\n-                CtorKind::Const => \"\",\n-                CtorKind::Fictive => \"{ .. }\",\n-            }\n-        )\n-    };\n-\n-    match missing_variants.as_slice() {\n-        [] => (),\n-        [x] if !adt_def.is_variant_list_non_exhaustive() && !has_hidden => span_lint_and_sugg(\n-            cx,\n-            MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n-            wildcard_span,\n-            \"wildcard matches only a single variant and will also match any future added variants\",\n-            \"try this\",\n-            format_suggestion(x),\n-            Applicability::MaybeIncorrect,\n-        ),\n-        variants => {\n-            let mut suggestions: Vec<_> = variants.iter().copied().map(format_suggestion).collect();\n-            let message = if adt_def.is_variant_list_non_exhaustive() || has_hidden {\n-                suggestions.push(\"_\".into());\n-                \"wildcard matches known variants and will also match future added variants\"\n-            } else {\n-                \"wildcard match will also match any future added variants\"\n-            };\n-\n-            span_lint_and_sugg(\n-                cx,\n-                WILDCARD_ENUM_MATCH_ARM,\n-                wildcard_span,\n-                message,\n-                \"try this\",\n-                suggestions.join(\" | \"),\n-                Applicability::MaybeIncorrect,\n-            );\n-        },\n-    };\n-}\n-\n-fn check_match_ref_pats<'a, 'b, I>(cx: &LateContext<'_>, ex: &Expr<'_>, pats: I, expr: &Expr<'_>)\n-where\n-    'b: 'a,\n-    I: Clone + Iterator<Item = &'a Pat<'b>>,\n-{\n-    if !has_multiple_ref_pats(pats.clone()) {\n-        return;\n-    }\n-\n-    let (first_sugg, msg, title);\n-    let span = ex.span.source_callsite();\n-    if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, inner) = ex.kind {\n-        first_sugg = once((span, Sugg::hir_with_macro_callsite(cx, inner, \"..\").to_string()));\n-        msg = \"try\";\n-        title = \"you don't need to add `&` to both the expression and the patterns\";\n-    } else {\n-        first_sugg = once((span, Sugg::hir_with_macro_callsite(cx, ex, \"..\").deref().to_string()));\n-        msg = \"instead of prefixing all patterns with `&`, you can dereference the expression\";\n-        title = \"you don't need to add `&` to all patterns\";\n-    }\n-\n-    let remaining_suggs = pats.filter_map(|pat| {\n-        if let PatKind::Ref(refp, _) = pat.kind {\n-            Some((pat.span, snippet(cx, refp.span, \"..\").to_string()))\n-        } else {\n-            None\n-        }\n-    });\n-\n-    span_lint_and_then(cx, MATCH_REF_PATS, expr.span, title, |diag| {\n-        if !expr.span.from_expansion() {\n-            multispan_sugg(diag, msg, first_sugg.chain(remaining_suggs));\n-        }\n-    });\n-}\n-\n-fn check_match_as_ref(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n-    if arms.len() == 2 && arms[0].guard.is_none() && arms[1].guard.is_none() {\n-        let arm_ref: Option<BindingAnnotation> = if is_none_arm(cx, &arms[0]) {\n-            is_ref_some_arm(cx, &arms[1])\n-        } else if is_none_arm(cx, &arms[1]) {\n-            is_ref_some_arm(cx, &arms[0])\n-        } else {\n-            None\n-        };\n-        if let Some(rb) = arm_ref {\n-            let suggestion = if rb == BindingAnnotation::Ref {\n-                \"as_ref\"\n-            } else {\n-                \"as_mut\"\n-            };\n-\n-            let output_ty = cx.typeck_results().expr_ty(expr);\n-            let input_ty = cx.typeck_results().expr_ty(ex);\n-\n-            let cast = if_chain! {\n-                if let ty::Adt(_, substs) = input_ty.kind();\n-                let input_ty = substs.type_at(0);\n-                if let ty::Adt(_, substs) = output_ty.kind();\n-                let output_ty = substs.type_at(0);\n-                if let ty::Ref(_, output_ty, _) = *output_ty.kind();\n-                if input_ty != output_ty;\n-                then {\n-                    \".map(|x| x as _)\"\n-                } else {\n-                    \"\"\n-                }\n-            };\n-\n-            let mut applicability = Applicability::MachineApplicable;\n-            span_lint_and_sugg(\n-                cx,\n-                MATCH_AS_REF,\n-                expr.span,\n-                &format!(\"use `{}()` instead\", suggestion),\n-                \"try this\",\n-                format!(\n-                    \"{}.{}(){}\",\n-                    snippet_with_applicability(cx, ex.span, \"_\", &mut applicability),\n-                    suggestion,\n-                    cast,\n-                ),\n-                applicability,\n-            );\n-        }\n-    }\n-}\n-\n-fn check_wild_in_or_pats(cx: &LateContext<'_>, arms: &[Arm<'_>]) {\n-    for arm in arms {\n-        if let PatKind::Or(fields) = arm.pat.kind {\n-            // look for multiple fields in this arm that contains at least one Wild pattern\n-            if fields.len() > 1 && fields.iter().any(is_wild) {\n-                span_lint_and_help(\n-                    cx,\n-                    WILDCARD_IN_OR_PATTERNS,\n-                    arm.pat.span,\n-                    \"wildcard pattern covers any other pattern as it will match anyway\",\n-                    None,\n-                    \"consider handling `_` separately\",\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-/// Lint a `match` or `if let .. { .. } else { .. }` expr that could be replaced by `matches!`\n-fn check_match_like_matches<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-    if let Some(higher::IfLet {\n-        let_pat,\n-        let_expr,\n-        if_then,\n-        if_else: Some(if_else),\n-    }) = higher::IfLet::hir(cx, expr)\n-    {\n-        return find_matches_sugg(\n-            cx,\n-            let_expr,\n-            IntoIterator::into_iter([(&[][..], Some(let_pat), if_then, None), (&[][..], None, if_else, None)]),\n-            expr,\n-            true,\n-        );\n-    }\n-\n-    if let ExprKind::Match(scrut, arms, MatchSource::Normal) = expr.kind {\n-        return find_matches_sugg(\n-            cx,\n-            scrut,\n-            arms.iter().map(|arm| {\n-                (\n-                    cx.tcx.hir().attrs(arm.hir_id),\n-                    Some(arm.pat),\n-                    arm.body,\n-                    arm.guard.as_ref(),\n-                )\n-            }),\n-            expr,\n-            false,\n-        );\n-    }\n-\n-    false\n-}\n-\n-/// Lint a `match` or `if let` for replacement by `matches!`\n-fn find_matches_sugg<'a, 'b, I>(\n-    cx: &LateContext<'_>,\n-    ex: &Expr<'_>,\n-    mut iter: I,\n-    expr: &Expr<'_>,\n-    is_if_let: bool,\n-) -> bool\n-where\n-    'b: 'a,\n-    I: Clone\n-        + DoubleEndedIterator\n-        + ExactSizeIterator\n-        + Iterator<\n-            Item = (\n-                &'a [Attribute],\n-                Option<&'a Pat<'b>>,\n-                &'a Expr<'b>,\n-                Option<&'a Guard<'b>>,\n-            ),\n-        >,\n-{\n-    if_chain! {\n-        if iter.len() >= 2;\n-        if cx.typeck_results().expr_ty(expr).is_bool();\n-        if let Some((_, last_pat_opt, last_expr, _)) = iter.next_back();\n-        let iter_without_last = iter.clone();\n-        if let Some((first_attrs, _, first_expr, first_guard)) = iter.next();\n-        if let Some(b0) = find_bool_lit(&first_expr.kind, is_if_let);\n-        if let Some(b1) = find_bool_lit(&last_expr.kind, is_if_let);\n-        if b0 != b1;\n-        if first_guard.is_none() || iter.len() == 0;\n-        if first_attrs.is_empty();\n-        if iter\n-            .all(|arm| {\n-                find_bool_lit(&arm.2.kind, is_if_let).map_or(false, |b| b == b0) && arm.3.is_none() && arm.0.is_empty()\n-            });\n-        then {\n-            if let Some(last_pat) = last_pat_opt {\n-                if !is_wild(last_pat) {\n-                    return false;\n-                }\n-            }\n-\n-            // The suggestion may be incorrect, because some arms can have `cfg` attributes\n-            // evaluated into `false` and so such arms will be stripped before.\n-            let mut applicability = Applicability::MaybeIncorrect;\n-            let pat = {\n-                use itertools::Itertools as _;\n-                iter_without_last\n-                    .filter_map(|arm| {\n-                        let pat_span = arm.1?.span;\n-                        Some(snippet_with_applicability(cx, pat_span, \"..\", &mut applicability))\n-                    })\n-                    .join(\" | \")\n-            };\n-            let pat_and_guard = if let Some(Guard::If(g)) = first_guard {\n-                format!(\"{} if {}\", pat, snippet_with_applicability(cx, g.span, \"..\", &mut applicability))\n-            } else {\n-                pat\n-            };\n-\n-            // strip potential borrows (#6503), but only if the type is a reference\n-            let mut ex_new = ex;\n-            if let ExprKind::AddrOf(BorrowKind::Ref, .., ex_inner) = ex.kind {\n-                if let ty::Ref(..) = cx.typeck_results().expr_ty(ex_inner).kind() {\n-                    ex_new = ex_inner;\n-                }\n-            };\n-            span_lint_and_sugg(\n-                cx,\n-                MATCH_LIKE_MATCHES_MACRO,\n-                expr.span,\n-                &format!(\"{} expression looks like `matches!` macro\", if is_if_let { \"if let .. else\" } else { \"match\" }),\n-                \"try this\",\n-                format!(\n-                    \"{}matches!({}, {})\",\n-                    if b0 { \"\" } else { \"!\" },\n-                    snippet_with_applicability(cx, ex_new.span, \"..\", &mut applicability),\n-                    pat_and_guard,\n-                ),\n-                applicability,\n-            );\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-}\n-\n-/// Extract a `bool` or `{ bool }`\n-fn find_bool_lit(ex: &ExprKind<'_>, is_if_let: bool) -> Option<bool> {\n-    match ex {\n-        ExprKind::Lit(Spanned {\n-            node: LitKind::Bool(b), ..\n-        }) => Some(*b),\n-        ExprKind::Block(\n-            rustc_hir::Block {\n-                stmts: &[],\n-                expr: Some(exp),\n-                ..\n-            },\n-            _,\n-        ) if is_if_let => {\n-            if let ExprKind::Lit(Spanned {\n-                node: LitKind::Bool(b), ..\n-            }) = exp.kind\n-            {\n-                Some(b)\n-            } else {\n-                None\n-            }\n-        },\n-        _ => None,\n-    }\n-}\n-\n-#[allow(clippy::too_many_lines)]\n-fn check_match_single_binding<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n-    if expr.span.from_expansion() || arms.len() != 1 || is_refutable(cx, arms[0].pat) {\n-        return;\n-    }\n-\n-    // HACK:\n-    // This is a hack to deal with arms that are excluded by macros like `#[cfg]`. It is only used here\n-    // to prevent false positives as there is currently no better way to detect if code was excluded by\n-    // a macro. See PR #6435\n-    if_chain! {\n-        if let Some(match_snippet) = snippet_opt(cx, expr.span);\n-        if let Some(arm_snippet) = snippet_opt(cx, arms[0].span);\n-        if let Some(ex_snippet) = snippet_opt(cx, ex.span);\n-        let rest_snippet = match_snippet.replace(&arm_snippet, \"\").replace(&ex_snippet, \"\");\n-        if rest_snippet.contains(\"=>\");\n-        then {\n-            // The code it self contains another thick arrow \"=>\"\n-            // -> Either another arm or a comment\n-            return;\n-        }\n-    }\n-\n-    let matched_vars = ex.span;\n-    let bind_names = arms[0].pat.span;\n-    let match_body = peel_blocks(arms[0].body);\n-    let mut snippet_body = if match_body.span.from_expansion() {\n-        Sugg::hir_with_macro_callsite(cx, match_body, \"..\").to_string()\n-    } else {\n-        snippet_block(cx, match_body.span, \"..\", Some(expr.span)).to_string()\n-    };\n-\n-    // Do we need to add ';' to suggestion ?\n-    match match_body.kind {\n-        ExprKind::Block(block, _) => {\n-            // macro + expr_ty(body) == ()\n-            if block.span.from_expansion() && cx.typeck_results().expr_ty(match_body).is_unit() {\n-                snippet_body.push(';');\n-            }\n-        },\n-        _ => {\n-            // expr_ty(body) == ()\n-            if cx.typeck_results().expr_ty(match_body).is_unit() {\n-                snippet_body.push(';');\n-            }\n-        },\n-    }\n-\n-    let mut applicability = Applicability::MaybeIncorrect;\n-    match arms[0].pat.kind {\n-        PatKind::Binding(..) | PatKind::Tuple(_, _) | PatKind::Struct(..) => {\n-            // If this match is in a local (`let`) stmt\n-            let (target_span, sugg) = if let Some(parent_let_node) = opt_parent_let(cx, ex) {\n-                (\n-                    parent_let_node.span,\n-                    format!(\n-                        \"let {} = {};\\n{}let {} = {};\",\n-                        snippet_with_applicability(cx, bind_names, \"..\", &mut applicability),\n-                        snippet_with_applicability(cx, matched_vars, \"..\", &mut applicability),\n-                        \" \".repeat(indent_of(cx, expr.span).unwrap_or(0)),\n-                        snippet_with_applicability(cx, parent_let_node.pat.span, \"..\", &mut applicability),\n-                        snippet_body\n-                    ),\n-                )\n-            } else {\n-                // If we are in closure, we need curly braces around suggestion\n-                let mut indent = \" \".repeat(indent_of(cx, ex.span).unwrap_or(0));\n-                let (mut cbrace_start, mut cbrace_end) = (\"\".to_string(), \"\".to_string());\n-                if let Some(parent_expr) = get_parent_expr(cx, expr) {\n-                    if let ExprKind::Closure(..) = parent_expr.kind {\n-                        cbrace_end = format!(\"\\n{}}}\", indent);\n-                        // Fix body indent due to the closure\n-                        indent = \" \".repeat(indent_of(cx, bind_names).unwrap_or(0));\n-                        cbrace_start = format!(\"{{\\n{}\", indent);\n-                    }\n-                }\n-                // If the parent is already an arm, and the body is another match statement,\n-                // we need curly braces around suggestion\n-                let parent_node_id = cx.tcx.hir().get_parent_node(expr.hir_id);\n-                if let Node::Arm(arm) = &cx.tcx.hir().get(parent_node_id) {\n-                    if let ExprKind::Match(..) = arm.body.kind {\n-                        cbrace_end = format!(\"\\n{}}}\", indent);\n-                        // Fix body indent due to the match\n-                        indent = \" \".repeat(indent_of(cx, bind_names).unwrap_or(0));\n-                        cbrace_start = format!(\"{{\\n{}\", indent);\n-                    }\n-                }\n-                (\n-                    expr.span,\n-                    format!(\n-                        \"{}let {} = {};\\n{}{}{}\",\n-                        cbrace_start,\n-                        snippet_with_applicability(cx, bind_names, \"..\", &mut applicability),\n-                        snippet_with_applicability(cx, matched_vars, \"..\", &mut applicability),\n-                        indent,\n-                        snippet_body,\n-                        cbrace_end\n-                    ),\n-                )\n-            };\n-            span_lint_and_sugg(\n-                cx,\n-                MATCH_SINGLE_BINDING,\n-                target_span,\n-                \"this match could be written as a `let` statement\",\n-                \"consider using `let` statement\",\n-                sugg,\n-                applicability,\n-            );\n-        },\n-        PatKind::Wild => {\n-            if ex.can_have_side_effects() {\n-                let indent = \" \".repeat(indent_of(cx, expr.span).unwrap_or(0));\n-                let sugg = format!(\n-                    \"{};\\n{}{}\",\n-                    snippet_with_applicability(cx, ex.span, \"..\", &mut applicability),\n-                    indent,\n-                    snippet_body\n-                );\n-                span_lint_and_sugg(\n-                    cx,\n-                    MATCH_SINGLE_BINDING,\n-                    expr.span,\n-                    \"this match could be replaced by its scrutinee and body\",\n-                    \"consider using the scrutinee and body instead\",\n-                    sugg,\n-                    applicability,\n-                );\n-            } else {\n-                span_lint_and_sugg(\n-                    cx,\n-                    MATCH_SINGLE_BINDING,\n-                    expr.span,\n-                    \"this match could be replaced by its body itself\",\n-                    \"consider using the match body instead\",\n-                    snippet_body,\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        },\n-        _ => (),\n-    }\n-}\n-\n-/// Returns true if the `ex` match expression is in a local (`let`) statement\n-fn opt_parent_let<'a>(cx: &LateContext<'a>, ex: &Expr<'a>) -> Option<&'a Local<'a>> {\n-    let map = &cx.tcx.hir();\n-    if_chain! {\n-        if let Some(Node::Expr(parent_arm_expr)) = map.find(map.get_parent_node(ex.hir_id));\n-        if let Some(Node::Local(parent_let_expr)) = map.find(map.get_parent_node(parent_arm_expr.hir_id));\n-        then {\n-            return Some(parent_let_expr);\n-        }\n-    }\n-    None\n-}\n-\n-/// Gets the ranges for each range pattern arm. Applies `ty` bounds for open ranges.\n-fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>) -> Vec<SpannedRange<FullInt>> {\n-    arms.iter()\n-        .filter_map(|arm| {\n-            if let Arm { pat, guard: None, .. } = *arm {\n-                if let PatKind::Range(ref lhs, ref rhs, range_end) = pat.kind {\n-                    let lhs_const = match lhs {\n-                        Some(lhs) => constant(cx, cx.typeck_results(), lhs)?.0,\n-                        None => miri_to_const(ty.numeric_min_val(cx.tcx)?)?,\n-                    };\n-                    let rhs_const = match rhs {\n-                        Some(rhs) => constant(cx, cx.typeck_results(), rhs)?.0,\n-                        None => miri_to_const(ty.numeric_max_val(cx.tcx)?)?,\n-                    };\n-\n-                    let lhs_val = lhs_const.int_value(cx, ty)?;\n-                    let rhs_val = rhs_const.int_value(cx, ty)?;\n-\n-                    let rhs_bound = match range_end {\n-                        RangeEnd::Included => EndBound::Included(rhs_val),\n-                        RangeEnd::Excluded => EndBound::Excluded(rhs_val),\n-                    };\n-                    return Some(SpannedRange {\n-                        span: pat.span,\n-                        node: (lhs_val, rhs_bound),\n-                    });\n-                }\n-\n-                if let PatKind::Lit(value) = pat.kind {\n-                    let value = constant_full_int(cx, cx.typeck_results(), value)?;\n-                    return Some(SpannedRange {\n-                        span: pat.span,\n-                        node: (value, EndBound::Included(value)),\n-                    });\n-                }\n-            }\n-            None\n-        })\n-        .collect()\n-}\n-\n-#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n-pub enum EndBound<T> {\n-    Included(T),\n-    Excluded(T),\n-}\n-\n-#[derive(Debug, Eq, PartialEq)]\n-struct SpannedRange<T> {\n-    pub span: Span,\n-    pub node: (T, EndBound<T>),\n-}\n-\n-// Checks if arm has the form `None => None`\n-fn is_none_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n-    matches!(arm.pat.kind, PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone))\n-}\n-\n-// Checks if arm has the form `Some(ref v) => Some(v)` (checks for `ref` and `ref mut`)\n-fn is_ref_some_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> Option<BindingAnnotation> {\n-    if_chain! {\n-        if let PatKind::TupleStruct(ref qpath, [first_pat, ..], _) = arm.pat.kind;\n-        if is_lang_ctor(cx, qpath, OptionSome);\n-        if let PatKind::Binding(rb, .., ident, _) = first_pat.kind;\n-        if rb == BindingAnnotation::Ref || rb == BindingAnnotation::RefMut;\n-        if let ExprKind::Call(e, args) = peel_blocks(arm.body).kind;\n-        if let ExprKind::Path(ref some_path) = e.kind;\n-        if is_lang_ctor(cx, some_path, OptionSome) && args.len() == 1;\n-        if let ExprKind::Path(QPath::Resolved(_, path2)) = args[0].kind;\n-        if path2.segments.len() == 1 && ident.name == path2.segments[0].ident.name;\n-        then {\n-            return Some(rb)\n-        }\n-    }\n-    None\n-}\n-\n-fn has_multiple_ref_pats<'a, 'b, I>(pats: I) -> bool\n-where\n-    'b: 'a,\n-    I: Iterator<Item = &'a Pat<'b>>,\n-{\n-    let mut ref_count = 0;\n-    for opt in pats.map(|pat| match pat.kind {\n-        PatKind::Ref(..) => Some(true), // &-patterns\n-        PatKind::Wild => Some(false),   // an \"anything\" wildcard is also fine\n-        _ => None,                      // any other pattern is not fine\n-    }) {\n-        if let Some(inner) = opt {\n-            if inner {\n-                ref_count += 1;\n-            }\n-        } else {\n-            return false;\n-        }\n-    }\n-    ref_count > 1\n-}\n-\n-fn overlapping<T>(ranges: &[SpannedRange<T>]) -> Option<(&SpannedRange<T>, &SpannedRange<T>)>\n-where\n-    T: Copy + Ord,\n-{\n-    #[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]\n-    enum BoundKind {\n-        EndExcluded,\n-        Start,\n-        EndIncluded,\n-    }\n-\n-    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-    struct RangeBound<'a, T>(T, BoundKind, &'a SpannedRange<T>);\n-\n-    impl<'a, T: Copy + Ord> PartialOrd for RangeBound<'a, T> {\n-        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-            Some(self.cmp(other))\n-        }\n-    }\n-\n-    impl<'a, T: Copy + Ord> Ord for RangeBound<'a, T> {\n-        fn cmp(&self, RangeBound(other_value, other_kind, _): &Self) -> Ordering {\n-            let RangeBound(self_value, self_kind, _) = *self;\n-            (self_value, self_kind).cmp(&(*other_value, *other_kind))\n-        }\n-    }\n-\n-    let mut values = Vec::with_capacity(2 * ranges.len());\n-\n-    for r @ SpannedRange { node: (start, end), .. } in ranges {\n-        values.push(RangeBound(*start, BoundKind::Start, r));\n-        values.push(match end {\n-            EndBound::Excluded(val) => RangeBound(*val, BoundKind::EndExcluded, r),\n-            EndBound::Included(val) => RangeBound(*val, BoundKind::EndIncluded, r),\n-        });\n-    }\n-\n-    values.sort();\n-\n-    let mut started = vec![];\n-\n-    for RangeBound(_, kind, range) in values {\n-        match kind {\n-            BoundKind::Start => started.push(range),\n-            BoundKind::EndExcluded | BoundKind::EndIncluded => {\n-                let mut overlap = None;\n-\n-                while let Some(last_started) = started.pop() {\n-                    if last_started == range {\n-                        break;\n-                    }\n-                    overlap = Some(last_started);\n-                }\n-\n-                if let Some(first_overlapping) = overlap {\n-                    return Some((range, first_overlapping));\n-                }\n-            },\n-        }\n-    }\n-\n-    None\n-}\n-\n-mod redundant_pattern_match {\n-    use super::REDUNDANT_PATTERN_MATCHING;\n-    use clippy_utils::diagnostics::span_lint_and_then;\n-    use clippy_utils::source::snippet;\n-    use clippy_utils::sugg::Sugg;\n-    use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, is_type_lang_item, match_type};\n-    use clippy_utils::{higher, match_def_path};\n-    use clippy_utils::{is_lang_ctor, is_trait_method, paths};\n-    use if_chain::if_chain;\n-    use rustc_ast::ast::LitKind;\n-    use rustc_data_structures::fx::FxHashSet;\n-    use rustc_errors::Applicability;\n-    use rustc_hir::LangItem::{OptionNone, PollPending};\n-    use rustc_hir::{\n-        intravisit::{walk_expr, Visitor},\n-        Arm, Block, Expr, ExprKind, LangItem, MatchSource, Node, Pat, PatKind, QPath, UnOp,\n-    };\n-    use rustc_lint::LateContext;\n-    use rustc_middle::ty::{self, subst::GenericArgKind, DefIdTree, Ty};\n-    use rustc_span::sym;\n-\n-    pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let Some(higher::IfLet {\n-            if_else,\n-            let_pat,\n-            let_expr,\n-            ..\n-        }) = higher::IfLet::hir(cx, expr)\n-        {\n-            find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"if\", if_else.is_some());\n-        }\n-        if let ExprKind::Match(op, arms, MatchSource::Normal) = &expr.kind {\n-            find_sugg_for_match(cx, expr, op, arms);\n-        }\n-        if let Some(higher::WhileLet { let_pat, let_expr, .. }) = higher::WhileLet::hir(expr) {\n-            find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"while\", false);\n-        }\n-    }\n-\n-    /// Checks if the drop order for a type matters. Some std types implement drop solely to\n-    /// deallocate memory. For these types, and composites containing them, changing the drop order\n-    /// won't result in any observable side effects.\n-    fn type_needs_ordered_drop<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n-        type_needs_ordered_drop_inner(cx, ty, &mut FxHashSet::default())\n-    }\n-\n-    fn type_needs_ordered_drop_inner<'tcx>(\n-        cx: &LateContext<'tcx>,\n-        ty: Ty<'tcx>,\n-        seen: &mut FxHashSet<Ty<'tcx>>,\n-    ) -> bool {\n-        if !seen.insert(ty) {\n-            return false;\n-        }\n-        if !ty.needs_drop(cx.tcx, cx.param_env) {\n-            false\n-        } else if !cx\n-            .tcx\n-            .lang_items()\n-            .drop_trait()\n-            .map_or(false, |id| implements_trait(cx, ty, id, &[]))\n-        {\n-            // This type doesn't implement drop, so no side effects here.\n-            // Check if any component type has any.\n-            match ty.kind() {\n-                ty::Tuple(_) => ty.tuple_fields().any(|ty| type_needs_ordered_drop_inner(cx, ty, seen)),\n-                ty::Array(ty, _) => type_needs_ordered_drop_inner(cx, ty, seen),\n-                ty::Adt(adt, subs) => adt\n-                    .all_fields()\n-                    .map(|f| f.ty(cx.tcx, subs))\n-                    .any(|ty| type_needs_ordered_drop_inner(cx, ty, seen)),\n-                _ => true,\n-            }\n-        }\n-        // Check for std types which implement drop, but only for memory allocation.\n-        else if is_type_diagnostic_item(cx, ty, sym::Vec)\n-            || is_type_lang_item(cx, ty, LangItem::OwnedBox)\n-            || is_type_diagnostic_item(cx, ty, sym::Rc)\n-            || is_type_diagnostic_item(cx, ty, sym::Arc)\n-            || is_type_diagnostic_item(cx, ty, sym::cstring_type)\n-            || is_type_diagnostic_item(cx, ty, sym::BTreeMap)\n-            || is_type_diagnostic_item(cx, ty, sym::LinkedList)\n-            || match_type(cx, ty, &paths::WEAK_RC)\n-            || match_type(cx, ty, &paths::WEAK_ARC)\n-        {\n-            // Check all of the generic arguments.\n-            if let ty::Adt(_, subs) = ty.kind() {\n-                subs.types().any(|ty| type_needs_ordered_drop_inner(cx, ty, seen))\n-            } else {\n-                true\n-            }\n-        } else {\n-            true\n-        }\n-    }\n-\n-    // Extract the generic arguments out of a type\n-    fn try_get_generic_ty(ty: Ty<'_>, index: usize) -> Option<Ty<'_>> {\n-        if_chain! {\n-            if let ty::Adt(_, subs) = ty.kind();\n-            if let Some(sub) = subs.get(index);\n-            if let GenericArgKind::Type(sub_ty) = sub.unpack();\n-            then {\n-                Some(sub_ty)\n-            } else {\n-                None\n-            }\n-        }\n-    }\n-\n-    // Checks if there are any temporaries created in the given expression for which drop order\n-    // matters.\n-    fn temporaries_need_ordered_drop<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-        struct V<'a, 'tcx> {\n-            cx: &'a LateContext<'tcx>,\n-            res: bool,\n-        }\n-        impl<'a, 'tcx> Visitor<'tcx> for V<'a, 'tcx> {\n-            fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-                match expr.kind {\n-                    // Taking the reference of a value leaves a temporary\n-                    // e.g. In `&String::new()` the string is a temporary value.\n-                    // Remaining fields are temporary values\n-                    // e.g. In `(String::new(), 0).1` the string is a temporary value.\n-                    ExprKind::AddrOf(_, _, expr) | ExprKind::Field(expr, _) => {\n-                        if !matches!(expr.kind, ExprKind::Path(_)) {\n-                            if type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(expr)) {\n-                                self.res = true;\n-                            } else {\n-                                self.visit_expr(expr);\n-                            }\n-                        }\n-                    },\n-                    // the base type is alway taken by reference.\n-                    // e.g. In `(vec![0])[0]` the vector is a temporary value.\n-                    ExprKind::Index(base, index) => {\n-                        if !matches!(base.kind, ExprKind::Path(_)) {\n-                            if type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(base)) {\n-                                self.res = true;\n-                            } else {\n-                                self.visit_expr(base);\n-                            }\n-                        }\n-                        self.visit_expr(index);\n-                    },\n-                    // Method calls can take self by reference.\n-                    // e.g. In `String::new().len()` the string is a temporary value.\n-                    ExprKind::MethodCall(_, [self_arg, args @ ..], _) => {\n-                        if !matches!(self_arg.kind, ExprKind::Path(_)) {\n-                            let self_by_ref = self\n-                                .cx\n-                                .typeck_results()\n-                                .type_dependent_def_id(expr.hir_id)\n-                                .map_or(false, |id| self.cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref());\n-                            if self_by_ref\n-                                && type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(self_arg))\n-                            {\n-                                self.res = true;\n-                            } else {\n-                                self.visit_expr(self_arg);\n-                            }\n-                        }\n-                        args.iter().for_each(|arg| self.visit_expr(arg));\n-                    },\n-                    // Either explicitly drops values, or changes control flow.\n-                    ExprKind::DropTemps(_)\n-                    | ExprKind::Ret(_)\n-                    | ExprKind::Break(..)\n-                    | ExprKind::Yield(..)\n-                    | ExprKind::Block(Block { expr: None, .. }, _)\n-                    | ExprKind::Loop(..) => (),\n-\n-                    // Only consider the final expression.\n-                    ExprKind::Block(Block { expr: Some(expr), .. }, _) => self.visit_expr(expr),\n-\n-                    _ => walk_expr(self, expr),\n-                }\n-            }\n-        }\n-\n-        let mut v = V { cx, res: false };\n-        v.visit_expr(expr);\n-        v.res\n-    }\n-\n-    fn find_sugg_for_if_let<'tcx>(\n-        cx: &LateContext<'tcx>,\n-        expr: &'tcx Expr<'_>,\n-        let_pat: &Pat<'_>,\n-        let_expr: &'tcx Expr<'_>,\n-        keyword: &'static str,\n-        has_else: bool,\n-    ) {\n-        // also look inside refs\n-        // if we have &None for example, peel it so we can detect \"if let None = x\"\n-        let check_pat = match let_pat.kind {\n-            PatKind::Ref(inner, _mutability) => inner,\n-            _ => let_pat,\n-        };\n-        let op_ty = cx.typeck_results().expr_ty(let_expr);\n-        // Determine which function should be used, and the type contained by the corresponding\n-        // variant.\n-        let (good_method, inner_ty) = match check_pat.kind {\n-            PatKind::TupleStruct(ref qpath, [sub_pat], _) => {\n-                if let PatKind::Wild = sub_pat.kind {\n-                    let res = cx.typeck_results().qpath_res(qpath, check_pat.hir_id);\n-                    let Some(id) = res.opt_def_id().and_then(|ctor_id| cx.tcx.parent(ctor_id)) else { return };\n-                    let lang_items = cx.tcx.lang_items();\n-                    if Some(id) == lang_items.result_ok_variant() {\n-                        (\"is_ok()\", try_get_generic_ty(op_ty, 0).unwrap_or(op_ty))\n-                    } else if Some(id) == lang_items.result_err_variant() {\n-                        (\"is_err()\", try_get_generic_ty(op_ty, 1).unwrap_or(op_ty))\n-                    } else if Some(id) == lang_items.option_some_variant() {\n-                        (\"is_some()\", op_ty)\n-                    } else if Some(id) == lang_items.poll_ready_variant() {\n-                        (\"is_ready()\", op_ty)\n-                    } else if match_def_path(cx, id, &paths::IPADDR_V4) {\n-                        (\"is_ipv4()\", op_ty)\n-                    } else if match_def_path(cx, id, &paths::IPADDR_V6) {\n-                        (\"is_ipv6()\", op_ty)\n-                    } else {\n-                        return;\n-                    }\n-                } else {\n-                    return;\n-                }\n-            },\n-            PatKind::Path(ref path) => {\n-                let method = if is_lang_ctor(cx, path, OptionNone) {\n-                    \"is_none()\"\n-                } else if is_lang_ctor(cx, path, PollPending) {\n-                    \"is_pending()\"\n-                } else {\n-                    return;\n-                };\n-                // `None` and `Pending` don't have an inner type.\n-                (method, cx.tcx.types.unit)\n-            },\n-            _ => return,\n-        };\n-\n-        // If this is the last expression in a block or there is an else clause then the whole\n-        // type needs to be considered, not just the inner type of the branch being matched on.\n-        // Note the last expression in a block is dropped after all local bindings.\n-        let check_ty = if has_else\n-            || (keyword == \"if\" && matches!(cx.tcx.hir().parent_iter(expr.hir_id).next(), Some((_, Node::Block(..)))))\n-        {\n-            op_ty\n-        } else {\n-            inner_ty\n-        };\n-\n-        // All temporaries created in the scrutinee expression are dropped at the same time as the\n-        // scrutinee would be, so they have to be considered as well.\n-        // e.g. in `if let Some(x) = foo.lock().unwrap().baz.as_ref() { .. }` the lock will be held\n-        // for the duration if body.\n-        let needs_drop = type_needs_ordered_drop(cx, check_ty) || temporaries_need_ordered_drop(cx, let_expr);\n-\n-        // check that `while_let_on_iterator` lint does not trigger\n-        if_chain! {\n-            if keyword == \"while\";\n-            if let ExprKind::MethodCall(method_path, _, _) = let_expr.kind;\n-            if method_path.ident.name == sym::next;\n-            if is_trait_method(cx, let_expr, sym::Iterator);\n-            then {\n-                return;\n-            }\n-        }\n-\n-        let result_expr = match &let_expr.kind {\n-            ExprKind::AddrOf(_, _, borrowed) => borrowed,\n-            ExprKind::Unary(UnOp::Deref, deref) => deref,\n-            _ => let_expr,\n-        };\n-\n-        span_lint_and_then(\n-            cx,\n-            REDUNDANT_PATTERN_MATCHING,\n-            let_pat.span,\n-            &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n-            |diag| {\n-                // if/while let ... = ... { ... }\n-                // ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-                let expr_span = expr.span;\n-\n-                // if/while let ... = ... { ... }\n-                //                 ^^^\n-                let op_span = result_expr.span.source_callsite();\n-\n-                // if/while let ... = ... { ... }\n-                // ^^^^^^^^^^^^^^^^^^^\n-                let span = expr_span.until(op_span.shrink_to_hi());\n-\n-                let app = if needs_drop {\n-                    Applicability::MaybeIncorrect\n-                } else {\n-                    Applicability::MachineApplicable\n-                };\n-\n-                let sugg = Sugg::hir_with_macro_callsite(cx, result_expr, \"_\")\n-                    .maybe_par()\n-                    .to_string();\n-\n-                diag.span_suggestion(span, \"try this\", format!(\"{} {}.{}\", keyword, sugg, good_method), app);\n-\n-                if needs_drop {\n-                    diag.note(\"this will change drop order of the result, as well as all temporaries\");\n-                    diag.note(\"add `#[allow(clippy::redundant_pattern_matching)]` if this is important\");\n-                }\n-            },\n-        );\n-    }\n-\n-    fn find_sugg_for_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op: &Expr<'_>, arms: &[Arm<'_>]) {\n-        if arms.len() == 2 {\n-            let node_pair = (&arms[0].pat.kind, &arms[1].pat.kind);\n-\n-            let found_good_method = match node_pair {\n-                (\n-                    PatKind::TupleStruct(ref path_left, patterns_left, _),\n-                    PatKind::TupleStruct(ref path_right, patterns_right, _),\n-                ) if patterns_left.len() == 1 && patterns_right.len() == 1 => {\n-                    if let (PatKind::Wild, PatKind::Wild) = (&patterns_left[0].kind, &patterns_right[0].kind) {\n-                        find_good_method_for_match(\n-                            cx,\n-                            arms,\n-                            path_left,\n-                            path_right,\n-                            &paths::RESULT_OK,\n-                            &paths::RESULT_ERR,\n-                            \"is_ok()\",\n-                            \"is_err()\",\n-                        )\n-                        .or_else(|| {\n-                            find_good_method_for_match(\n-                                cx,\n-                                arms,\n-                                path_left,\n-                                path_right,\n-                                &paths::IPADDR_V4,\n-                                &paths::IPADDR_V6,\n-                                \"is_ipv4()\",\n-                                \"is_ipv6()\",\n-                            )\n-                        })\n-                    } else {\n-                        None\n-                    }\n-                },\n-                (PatKind::TupleStruct(ref path_left, patterns, _), PatKind::Path(ref path_right))\n-                | (PatKind::Path(ref path_left), PatKind::TupleStruct(ref path_right, patterns, _))\n-                    if patterns.len() == 1 =>\n-                {\n-                    if let PatKind::Wild = patterns[0].kind {\n-                        find_good_method_for_match(\n-                            cx,\n-                            arms,\n-                            path_left,\n-                            path_right,\n-                            &paths::OPTION_SOME,\n-                            &paths::OPTION_NONE,\n-                            \"is_some()\",\n-                            \"is_none()\",\n-                        )\n-                        .or_else(|| {\n-                            find_good_method_for_match(\n-                                cx,\n-                                arms,\n-                                path_left,\n-                                path_right,\n-                                &paths::POLL_READY,\n-                                &paths::POLL_PENDING,\n-                                \"is_ready()\",\n-                                \"is_pending()\",\n-                            )\n-                        })\n-                    } else {\n-                        None\n-                    }\n-                },\n-                _ => None,\n-            };\n-\n-            if let Some(good_method) = found_good_method {\n-                let span = expr.span.to(op.span);\n-                let result_expr = match &op.kind {\n-                    ExprKind::AddrOf(_, _, borrowed) => borrowed,\n-                    _ => op,\n-                };\n-                span_lint_and_then(\n-                    cx,\n-                    REDUNDANT_PATTERN_MATCHING,\n-                    expr.span,\n-                    &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n-                    |diag| {\n-                        diag.span_suggestion(\n-                            span,\n-                            \"try this\",\n-                            format!(\"{}.{}\", snippet(cx, result_expr.span, \"_\"), good_method),\n-                            Applicability::MaybeIncorrect, // snippet\n-                        );\n-                    },\n-                );\n-            }\n-        }\n-    }\n-\n-    #[allow(clippy::too_many_arguments)]\n-    fn find_good_method_for_match<'a>(\n-        cx: &LateContext<'_>,\n-        arms: &[Arm<'_>],\n-        path_left: &QPath<'_>,\n-        path_right: &QPath<'_>,\n-        expected_left: &[&str],\n-        expected_right: &[&str],\n-        should_be_left: &'a str,\n-        should_be_right: &'a str,\n-    ) -> Option<&'a str> {\n-        let left_id = cx\n-            .typeck_results()\n-            .qpath_res(path_left, arms[0].pat.hir_id)\n-            .opt_def_id()?;\n-        let right_id = cx\n-            .typeck_results()\n-            .qpath_res(path_right, arms[1].pat.hir_id)\n-            .opt_def_id()?;\n-        let body_node_pair =\n-            if match_def_path(cx, left_id, expected_left) && match_def_path(cx, right_id, expected_right) {\n-                (&(*arms[0].body).kind, &(*arms[1].body).kind)\n-            } else if match_def_path(cx, right_id, expected_left) && match_def_path(cx, right_id, expected_right) {\n-                (&(*arms[1].body).kind, &(*arms[0].body).kind)\n-            } else {\n-                return None;\n-            };\n-\n-        match body_node_pair {\n-            (ExprKind::Lit(ref lit_left), ExprKind::Lit(ref lit_right)) => match (&lit_left.node, &lit_right.node) {\n-                (LitKind::Bool(true), LitKind::Bool(false)) => Some(should_be_left),\n-                (LitKind::Bool(false), LitKind::Bool(true)) => Some(should_be_right),\n-                _ => None,\n-            },\n-            _ => None,\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_overlapping() {\n-    use rustc_span::source_map::DUMMY_SP;\n-\n-    let sp = |s, e| SpannedRange {\n-        span: DUMMY_SP,\n-        node: (s, e),\n-    };\n-\n-    assert_eq!(None, overlapping::<u8>(&[]));\n-    assert_eq!(None, overlapping(&[sp(1, EndBound::Included(4))]));\n-    assert_eq!(\n-        None,\n-        overlapping(&[sp(1, EndBound::Included(4)), sp(5, EndBound::Included(6))])\n-    );\n-    assert_eq!(\n-        None,\n-        overlapping(&[\n-            sp(1, EndBound::Included(4)),\n-            sp(5, EndBound::Included(6)),\n-            sp(10, EndBound::Included(11))\n-        ],)\n-    );\n-    assert_eq!(\n-        Some((&sp(1, EndBound::Included(4)), &sp(3, EndBound::Included(6)))),\n-        overlapping(&[sp(1, EndBound::Included(4)), sp(3, EndBound::Included(6))])\n-    );\n-    assert_eq!(\n-        Some((&sp(5, EndBound::Included(6)), &sp(6, EndBound::Included(11)))),\n-        overlapping(&[\n-            sp(1, EndBound::Included(4)),\n-            sp(5, EndBound::Included(6)),\n-            sp(6, EndBound::Included(11))\n-        ],)\n-    );\n-}\n-\n-/// Implementation of `MATCH_SAME_ARMS`.\n-fn lint_match_arms<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n-    if let ExprKind::Match(_, arms, MatchSource::Normal) = expr.kind {\n-        let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n-            let mut h = SpanlessHash::new(cx);\n-            h.hash_expr(arm.body);\n-            h.finish()\n-        };\n-\n-        let eq = |&(lindex, lhs): &(usize, &Arm<'_>), &(rindex, rhs): &(usize, &Arm<'_>)| -> bool {\n-            let min_index = usize::min(lindex, rindex);\n-            let max_index = usize::max(lindex, rindex);\n-\n-            let mut local_map: HirIdMap<HirId> = HirIdMap::default();\n-            let eq_fallback = |a: &Expr<'_>, b: &Expr<'_>| {\n-                if_chain! {\n-                    if let Some(a_id) = path_to_local(a);\n-                    if let Some(b_id) = path_to_local(b);\n-                    let entry = match local_map.entry(a_id) {\n-                        Entry::Vacant(entry) => entry,\n-                        // check if using the same bindings as before\n-                        Entry::Occupied(entry) => return *entry.get() == b_id,\n-                    };\n-                    // the names technically don't have to match; this makes the lint more conservative\n-                    if cx.tcx.hir().name(a_id) == cx.tcx.hir().name(b_id);\n-                    if TyS::same_type(cx.typeck_results().expr_ty(a), cx.typeck_results().expr_ty(b));\n-                    if pat_contains_local(lhs.pat, a_id);\n-                    if pat_contains_local(rhs.pat, b_id);\n-                    then {\n-                        entry.insert(b_id);\n-                        true\n-                    } else {\n-                        false\n-                    }\n-                }\n-            };\n-            // Arms with a guard are ignored, those can\u2019t always be merged together\n-            // This is also the case for arms in-between each there is an arm with a guard\n-            (min_index..=max_index).all(|index| arms[index].guard.is_none())\n-                && SpanlessEq::new(cx)\n-                    .expr_fallback(eq_fallback)\n-                    .eq_expr(lhs.body, rhs.body)\n-                // these checks could be removed to allow unused bindings\n-                && bindings_eq(lhs.pat, local_map.keys().copied().collect())\n-                && bindings_eq(rhs.pat, local_map.values().copied().collect())\n-        };\n-\n-        let indexed_arms: Vec<(usize, &Arm<'_>)> = arms.iter().enumerate().collect();\n-        for (&(_, i), &(_, j)) in search_same(&indexed_arms, hash, eq) {\n-            span_lint_and_then(\n-                cx,\n-                MATCH_SAME_ARMS,\n-                j.body.span,\n-                \"this `match` has identical arm bodies\",\n-                |diag| {\n-                    diag.span_note(i.body.span, \"same as this\");\n-\n-                    // Note: this does not use `span_suggestion` on purpose:\n-                    // there is no clean way\n-                    // to remove the other arm. Building a span and suggest to replace it to \"\"\n-                    // makes an even more confusing error message. Also in order not to make up a\n-                    // span for the whole pattern, the suggestion is only shown when there is only\n-                    // one pattern. The user should know about `|` if they are already using it\u2026\n-\n-                    let lhs = snippet(cx, i.pat.span, \"<pat1>\");\n-                    let rhs = snippet(cx, j.pat.span, \"<pat2>\");\n-\n-                    if let PatKind::Wild = j.pat.kind {\n-                        // if the last arm is _, then i could be integrated into _\n-                        // note that i.pat cannot be _, because that would mean that we're\n-                        // hiding all the subsequent arms, and rust won't compile\n-                        diag.span_note(\n-                            i.body.span,\n-                            &format!(\n-                                \"`{}` has the same arm body as the `_` wildcard, consider removing it\",\n-                                lhs\n-                            ),\n-                        );\n-                    } else {\n-                        diag.span_help(i.pat.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs,))\n-                            .help(\"...or consider changing the match arm bodies\");\n-                    }\n-                },\n-            );\n-        }\n-    }\n-}\n-\n-fn pat_contains_local(pat: &Pat<'_>, id: HirId) -> bool {\n-    let mut result = false;\n-    pat.walk_short(|p| {\n-        result |= matches!(p.kind, PatKind::Binding(_, binding_id, ..) if binding_id == id);\n-        !result\n-    });\n-    result\n-}\n-\n-/// Returns true if all the bindings in the `Pat` are in `ids` and vice versa\n-fn bindings_eq(pat: &Pat<'_>, mut ids: HirIdSet) -> bool {\n-    let mut result = true;\n-    pat.each_binding_or_first(&mut |_, id, _, _| result &= ids.remove(&id));\n-    result && ids.is_empty()\n-}"}, {"sha": "2472acb6f6e8b6f974fcf898010e45140bc021ff", "filename": "clippy_lints/src/matches/infalliable_detructuring_match.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Finfalliable_detructuring_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Finfalliable_detructuring_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Finfalliable_detructuring_match.rs?ref=2590701b2ac9004418c5ec49896f2cf2c5016df5", "patch": "@@ -0,0 +1,44 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{path_to_local_id, peel_blocks, strip_pat_refs};\n+use rustc_errors::Applicability;\n+use rustc_hir::{ExprKind, Local, MatchSource, PatKind, QPath};\n+use rustc_lint::LateContext;\n+\n+use super::INFALLIBLE_DESTRUCTURING_MATCH;\n+\n+pub(crate) fn check(cx: &LateContext<'_>, local: &Local<'_>) -> bool {\n+    if_chain! {\n+        if !local.span.from_expansion();\n+        if let Some(expr) = local.init;\n+        if let ExprKind::Match(target, arms, MatchSource::Normal) = expr.kind;\n+        if arms.len() == 1 && arms[0].guard.is_none();\n+        if let PatKind::TupleStruct(\n+            QPath::Resolved(None, variant_name), args, _) = arms[0].pat.kind;\n+        if args.len() == 1;\n+        if let PatKind::Binding(_, arg, ..) = strip_pat_refs(&args[0]).kind;\n+        let body = peel_blocks(arms[0].body);\n+        if path_to_local_id(body, arg);\n+\n+        then {\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                INFALLIBLE_DESTRUCTURING_MATCH,\n+                local.span,\n+                \"you seem to be trying to use `match` to destructure a single infallible pattern. \\\n+                Consider using `let`\",\n+                \"try this\",\n+                format!(\n+                    \"let {}({}) = {};\",\n+                    snippet_with_applicability(cx, variant_name.span, \"..\", &mut applicability),\n+                    snippet_with_applicability(cx, local.pat.span, \"..\", &mut applicability),\n+                    snippet_with_applicability(cx, target.span, \"..\", &mut applicability),\n+                ),\n+                applicability,\n+            );\n+            return true;\n+        }\n+    }\n+    false\n+}"}, {"sha": "d914eba01716b69e6fb182bcede18001c2e6f94b", "filename": "clippy_lints/src/matches/match_as_ref.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs?ref=2590701b2ac9004418c5ec49896f2cf2c5016df5", "patch": "@@ -0,0 +1,85 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{is_lang_ctor, peel_blocks};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Arm, BindingAnnotation, Expr, ExprKind, LangItem, PatKind, QPath};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+\n+use super::MATCH_AS_REF;\n+\n+pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n+    if arms.len() == 2 && arms[0].guard.is_none() && arms[1].guard.is_none() {\n+        let arm_ref: Option<BindingAnnotation> = if is_none_arm(cx, &arms[0]) {\n+            is_ref_some_arm(cx, &arms[1])\n+        } else if is_none_arm(cx, &arms[1]) {\n+            is_ref_some_arm(cx, &arms[0])\n+        } else {\n+            None\n+        };\n+        if let Some(rb) = arm_ref {\n+            let suggestion = if rb == BindingAnnotation::Ref {\n+                \"as_ref\"\n+            } else {\n+                \"as_mut\"\n+            };\n+\n+            let output_ty = cx.typeck_results().expr_ty(expr);\n+            let input_ty = cx.typeck_results().expr_ty(ex);\n+\n+            let cast = if_chain! {\n+                if let ty::Adt(_, substs) = input_ty.kind();\n+                let input_ty = substs.type_at(0);\n+                if let ty::Adt(_, substs) = output_ty.kind();\n+                let output_ty = substs.type_at(0);\n+                if let ty::Ref(_, output_ty, _) = *output_ty.kind();\n+                if input_ty != output_ty;\n+                then {\n+                    \".map(|x| x as _)\"\n+                } else {\n+                    \"\"\n+                }\n+            };\n+\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                MATCH_AS_REF,\n+                expr.span,\n+                &format!(\"use `{}()` instead\", suggestion),\n+                \"try this\",\n+                format!(\n+                    \"{}.{}(){}\",\n+                    snippet_with_applicability(cx, ex.span, \"_\", &mut applicability),\n+                    suggestion,\n+                    cast,\n+                ),\n+                applicability,\n+            );\n+        }\n+    }\n+}\n+\n+// Checks if arm has the form `None => None`\n+fn is_none_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n+    matches!(arm.pat.kind, PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, LangItem::OptionNone))\n+}\n+\n+// Checks if arm has the form `Some(ref v) => Some(v)` (checks for `ref` and `ref mut`)\n+fn is_ref_some_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> Option<BindingAnnotation> {\n+    if_chain! {\n+        if let PatKind::TupleStruct(ref qpath, [first_pat, ..], _) = arm.pat.kind;\n+        if is_lang_ctor(cx, qpath, LangItem::OptionSome);\n+        if let PatKind::Binding(rb, .., ident, _) = first_pat.kind;\n+        if rb == BindingAnnotation::Ref || rb == BindingAnnotation::RefMut;\n+        if let ExprKind::Call(e, args) = peel_blocks(arm.body).kind;\n+        if let ExprKind::Path(ref some_path) = e.kind;\n+        if is_lang_ctor(cx, some_path, LangItem::OptionSome) && args.len() == 1;\n+        if let ExprKind::Path(QPath::Resolved(_, path2)) = args[0].kind;\n+        if path2.segments.len() == 1 && ident.name == path2.segments[0].ident.name;\n+        then {\n+            return Some(rb)\n+        }\n+    }\n+    None\n+}"}, {"sha": "90c50b994d2bfe11245881843feef728b1829ad5", "filename": "clippy_lints/src/matches/match_bool.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Fmatch_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Fmatch_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_bool.rs?ref=2590701b2ac9004418c5ec49896f2cf2c5016df5", "patch": "@@ -0,0 +1,75 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::is_unit_expr;\n+use clippy_utils::source::{expr_block, snippet};\n+use clippy_utils::sugg::Sugg;\n+use rustc_ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Arm, Expr, ExprKind, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+\n+use super::MATCH_BOOL;\n+\n+pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n+    // Type of expression is `bool`.\n+    if *cx.typeck_results().expr_ty(ex).kind() == ty::Bool {\n+        span_lint_and_then(\n+            cx,\n+            MATCH_BOOL,\n+            expr.span,\n+            \"you seem to be trying to match on a boolean expression\",\n+            move |diag| {\n+                if arms.len() == 2 {\n+                    // no guards\n+                    let exprs = if let PatKind::Lit(arm_bool) = arms[0].pat.kind {\n+                        if let ExprKind::Lit(ref lit) = arm_bool.kind {\n+                            match lit.node {\n+                                LitKind::Bool(true) => Some((&*arms[0].body, &*arms[1].body)),\n+                                LitKind::Bool(false) => Some((&*arms[1].body, &*arms[0].body)),\n+                                _ => None,\n+                            }\n+                        } else {\n+                            None\n+                        }\n+                    } else {\n+                        None\n+                    };\n+\n+                    if let Some((true_expr, false_expr)) = exprs {\n+                        let sugg = match (is_unit_expr(true_expr), is_unit_expr(false_expr)) {\n+                            (false, false) => Some(format!(\n+                                \"if {} {} else {}\",\n+                                snippet(cx, ex.span, \"b\"),\n+                                expr_block(cx, true_expr, None, \"..\", Some(expr.span)),\n+                                expr_block(cx, false_expr, None, \"..\", Some(expr.span))\n+                            )),\n+                            (false, true) => Some(format!(\n+                                \"if {} {}\",\n+                                snippet(cx, ex.span, \"b\"),\n+                                expr_block(cx, true_expr, None, \"..\", Some(expr.span))\n+                            )),\n+                            (true, false) => {\n+                                let test = Sugg::hir(cx, ex, \"..\");\n+                                Some(format!(\n+                                    \"if {} {}\",\n+                                    !test,\n+                                    expr_block(cx, false_expr, None, \"..\", Some(expr.span))\n+                                ))\n+                            },\n+                            (true, true) => None,\n+                        };\n+\n+                        if let Some(sugg) = sugg {\n+                            diag.span_suggestion(\n+                                expr.span,\n+                                \"consider using an `if`/`else` expression\",\n+                                sugg,\n+                                Applicability::HasPlaceholders,\n+                            );\n+                        }\n+                    }\n+                }\n+            },\n+        );\n+    }\n+}"}, {"sha": "d605b6d73c09d8b9684e4d2b83a76a91a19b82f2", "filename": "clippy_lints/src/matches/match_like_matches.rs", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs?ref=2590701b2ac9004418c5ec49896f2cf2c5016df5", "patch": "@@ -0,0 +1,166 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{higher, is_wild};\n+use rustc_ast::{Attribute, LitKind};\n+use rustc_errors::Applicability;\n+use rustc_hir::{BorrowKind, Expr, ExprKind, Guard, MatchSource, Pat};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::source_map::Spanned;\n+\n+use super::MATCH_LIKE_MATCHES_MACRO;\n+\n+/// Lint a `match` or `if let .. { .. } else { .. }` expr that could be replaced by `matches!`\n+pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+    if let Some(higher::IfLet {\n+        let_pat,\n+        let_expr,\n+        if_then,\n+        if_else: Some(if_else),\n+    }) = higher::IfLet::hir(cx, expr)\n+    {\n+        return find_matches_sugg(\n+            cx,\n+            let_expr,\n+            IntoIterator::into_iter([(&[][..], Some(let_pat), if_then, None), (&[][..], None, if_else, None)]),\n+            expr,\n+            true,\n+        );\n+    }\n+\n+    if let ExprKind::Match(scrut, arms, MatchSource::Normal) = expr.kind {\n+        return find_matches_sugg(\n+            cx,\n+            scrut,\n+            arms.iter().map(|arm| {\n+                (\n+                    cx.tcx.hir().attrs(arm.hir_id),\n+                    Some(arm.pat),\n+                    arm.body,\n+                    arm.guard.as_ref(),\n+                )\n+            }),\n+            expr,\n+            false,\n+        );\n+    }\n+\n+    false\n+}\n+\n+/// Lint a `match` or `if let` for replacement by `matches!`\n+fn find_matches_sugg<'a, 'b, I>(\n+    cx: &LateContext<'_>,\n+    ex: &Expr<'_>,\n+    mut iter: I,\n+    expr: &Expr<'_>,\n+    is_if_let: bool,\n+) -> bool\n+where\n+    'b: 'a,\n+    I: Clone\n+        + DoubleEndedIterator\n+        + ExactSizeIterator\n+        + Iterator<\n+            Item = (\n+                &'a [Attribute],\n+                Option<&'a Pat<'b>>,\n+                &'a Expr<'b>,\n+                Option<&'a Guard<'b>>,\n+            ),\n+        >,\n+{\n+    if_chain! {\n+        if iter.len() >= 2;\n+        if cx.typeck_results().expr_ty(expr).is_bool();\n+        if let Some((_, last_pat_opt, last_expr, _)) = iter.next_back();\n+        let iter_without_last = iter.clone();\n+        if let Some((first_attrs, _, first_expr, first_guard)) = iter.next();\n+        if let Some(b0) = find_bool_lit(&first_expr.kind, is_if_let);\n+        if let Some(b1) = find_bool_lit(&last_expr.kind, is_if_let);\n+        if b0 != b1;\n+        if first_guard.is_none() || iter.len() == 0;\n+        if first_attrs.is_empty();\n+        if iter\n+            .all(|arm| {\n+                find_bool_lit(&arm.2.kind, is_if_let).map_or(false, |b| b == b0) && arm.3.is_none() && arm.0.is_empty()\n+            });\n+        then {\n+            if let Some(last_pat) = last_pat_opt {\n+                if !is_wild(last_pat) {\n+                    return false;\n+                }\n+            }\n+\n+            // The suggestion may be incorrect, because some arms can have `cfg` attributes\n+            // evaluated into `false` and so such arms will be stripped before.\n+            let mut applicability = Applicability::MaybeIncorrect;\n+            let pat = {\n+                use itertools::Itertools as _;\n+                iter_without_last\n+                    .filter_map(|arm| {\n+                        let pat_span = arm.1?.span;\n+                        Some(snippet_with_applicability(cx, pat_span, \"..\", &mut applicability))\n+                    })\n+                    .join(\" | \")\n+            };\n+            let pat_and_guard = if let Some(Guard::If(g)) = first_guard {\n+                format!(\"{} if {}\", pat, snippet_with_applicability(cx, g.span, \"..\", &mut applicability))\n+            } else {\n+                pat\n+            };\n+\n+            // strip potential borrows (#6503), but only if the type is a reference\n+            let mut ex_new = ex;\n+            if let ExprKind::AddrOf(BorrowKind::Ref, .., ex_inner) = ex.kind {\n+                if let ty::Ref(..) = cx.typeck_results().expr_ty(ex_inner).kind() {\n+                    ex_new = ex_inner;\n+                }\n+            };\n+            span_lint_and_sugg(\n+                cx,\n+                MATCH_LIKE_MATCHES_MACRO,\n+                expr.span,\n+                &format!(\"{} expression looks like `matches!` macro\", if is_if_let { \"if let .. else\" } else { \"match\" }),\n+                \"try this\",\n+                format!(\n+                    \"{}matches!({}, {})\",\n+                    if b0 { \"\" } else { \"!\" },\n+                    snippet_with_applicability(cx, ex_new.span, \"..\", &mut applicability),\n+                    pat_and_guard,\n+                ),\n+                applicability,\n+            );\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+/// Extract a `bool` or `{ bool }`\n+fn find_bool_lit(ex: &ExprKind<'_>, is_if_let: bool) -> Option<bool> {\n+    match ex {\n+        ExprKind::Lit(Spanned {\n+            node: LitKind::Bool(b), ..\n+        }) => Some(*b),\n+        ExprKind::Block(\n+            rustc_hir::Block {\n+                stmts: &[],\n+                expr: Some(exp),\n+                ..\n+            },\n+            _,\n+        ) if is_if_let => {\n+            if let ExprKind::Lit(Spanned {\n+                node: LitKind::Bool(b), ..\n+            }) = exp.kind\n+            {\n+                Some(b)\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    }\n+}"}, {"sha": "80f964ba1b72c4a246f24ee264d3ce5a508276d4", "filename": "clippy_lints/src/matches/match_ref_pats.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Fmatch_ref_pats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Fmatch_ref_pats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_ref_pats.rs?ref=2590701b2ac9004418c5ec49896f2cf2c5016df5", "patch": "@@ -0,0 +1,66 @@\n+use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n+use clippy_utils::source::snippet;\n+use clippy_utils::sugg::Sugg;\n+use core::iter::once;\n+use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability, Pat, PatKind};\n+use rustc_lint::LateContext;\n+\n+use super::MATCH_REF_PATS;\n+\n+pub(crate) fn check<'a, 'b, I>(cx: &LateContext<'_>, ex: &Expr<'_>, pats: I, expr: &Expr<'_>)\n+where\n+    'b: 'a,\n+    I: Clone + Iterator<Item = &'a Pat<'b>>,\n+{\n+    if !has_multiple_ref_pats(pats.clone()) {\n+        return;\n+    }\n+\n+    let (first_sugg, msg, title);\n+    let span = ex.span.source_callsite();\n+    if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, inner) = ex.kind {\n+        first_sugg = once((span, Sugg::hir_with_macro_callsite(cx, inner, \"..\").to_string()));\n+        msg = \"try\";\n+        title = \"you don't need to add `&` to both the expression and the patterns\";\n+    } else {\n+        first_sugg = once((span, Sugg::hir_with_macro_callsite(cx, ex, \"..\").deref().to_string()));\n+        msg = \"instead of prefixing all patterns with `&`, you can dereference the expression\";\n+        title = \"you don't need to add `&` to all patterns\";\n+    }\n+\n+    let remaining_suggs = pats.filter_map(|pat| {\n+        if let PatKind::Ref(refp, _) = pat.kind {\n+            Some((pat.span, snippet(cx, refp.span, \"..\").to_string()))\n+        } else {\n+            None\n+        }\n+    });\n+\n+    span_lint_and_then(cx, MATCH_REF_PATS, expr.span, title, |diag| {\n+        if !expr.span.from_expansion() {\n+            multispan_sugg(diag, msg, first_sugg.chain(remaining_suggs));\n+        }\n+    });\n+}\n+\n+fn has_multiple_ref_pats<'a, 'b, I>(pats: I) -> bool\n+where\n+    'b: 'a,\n+    I: Iterator<Item = &'a Pat<'b>>,\n+{\n+    let mut ref_count = 0;\n+    for opt in pats.map(|pat| match pat.kind {\n+        PatKind::Ref(..) => Some(true), // &-patterns\n+        PatKind::Wild => Some(false),   // an \"anything\" wildcard is also fine\n+        _ => None,                      // any other pattern is not fine\n+    }) {\n+        if let Some(inner) = opt {\n+            if inner {\n+                ref_count += 1;\n+            }\n+        } else {\n+            return false;\n+        }\n+    }\n+    ref_count > 1\n+}"}, {"sha": "7efbd540fdb4d0b1b72e7a435216731015d5eb67", "filename": "clippy_lints/src/matches/match_same_arms.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs?ref=2590701b2ac9004418c5ec49896f2cf2c5016df5", "patch": "@@ -0,0 +1,112 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::source::snippet;\n+use clippy_utils::{path_to_local, search_same, SpanlessEq, SpanlessHash};\n+use rustc_hir::{Arm, Expr, ExprKind, HirId, HirIdMap, HirIdSet, MatchSource, Pat, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::TyS;\n+use std::collections::hash_map::Entry;\n+\n+use super::MATCH_SAME_ARMS;\n+\n+pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n+    if let ExprKind::Match(_, arms, MatchSource::Normal) = expr.kind {\n+        let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n+            let mut h = SpanlessHash::new(cx);\n+            h.hash_expr(arm.body);\n+            h.finish()\n+        };\n+\n+        let eq = |&(lindex, lhs): &(usize, &Arm<'_>), &(rindex, rhs): &(usize, &Arm<'_>)| -> bool {\n+            let min_index = usize::min(lindex, rindex);\n+            let max_index = usize::max(lindex, rindex);\n+\n+            let mut local_map: HirIdMap<HirId> = HirIdMap::default();\n+            let eq_fallback = |a: &Expr<'_>, b: &Expr<'_>| {\n+                if_chain! {\n+                    if let Some(a_id) = path_to_local(a);\n+                    if let Some(b_id) = path_to_local(b);\n+                    let entry = match local_map.entry(a_id) {\n+                        Entry::Vacant(entry) => entry,\n+                        // check if using the same bindings as before\n+                        Entry::Occupied(entry) => return *entry.get() == b_id,\n+                    };\n+                    // the names technically don't have to match; this makes the lint more conservative\n+                    if cx.tcx.hir().name(a_id) == cx.tcx.hir().name(b_id);\n+                    if TyS::same_type(cx.typeck_results().expr_ty(a), cx.typeck_results().expr_ty(b));\n+                    if pat_contains_local(lhs.pat, a_id);\n+                    if pat_contains_local(rhs.pat, b_id);\n+                    then {\n+                        entry.insert(b_id);\n+                        true\n+                    } else {\n+                        false\n+                    }\n+                }\n+            };\n+            // Arms with a guard are ignored, those can\u2019t always be merged together\n+            // This is also the case for arms in-between each there is an arm with a guard\n+            (min_index..=max_index).all(|index| arms[index].guard.is_none())\n+                && SpanlessEq::new(cx)\n+                    .expr_fallback(eq_fallback)\n+                    .eq_expr(lhs.body, rhs.body)\n+                // these checks could be removed to allow unused bindings\n+                && bindings_eq(lhs.pat, local_map.keys().copied().collect())\n+                && bindings_eq(rhs.pat, local_map.values().copied().collect())\n+        };\n+\n+        let indexed_arms: Vec<(usize, &Arm<'_>)> = arms.iter().enumerate().collect();\n+        for (&(_, i), &(_, j)) in search_same(&indexed_arms, hash, eq) {\n+            span_lint_and_then(\n+                cx,\n+                MATCH_SAME_ARMS,\n+                j.body.span,\n+                \"this `match` has identical arm bodies\",\n+                |diag| {\n+                    diag.span_note(i.body.span, \"same as this\");\n+\n+                    // Note: this does not use `span_suggestion` on purpose:\n+                    // there is no clean way\n+                    // to remove the other arm. Building a span and suggest to replace it to \"\"\n+                    // makes an even more confusing error message. Also in order not to make up a\n+                    // span for the whole pattern, the suggestion is only shown when there is only\n+                    // one pattern. The user should know about `|` if they are already using it\u2026\n+\n+                    let lhs = snippet(cx, i.pat.span, \"<pat1>\");\n+                    let rhs = snippet(cx, j.pat.span, \"<pat2>\");\n+\n+                    if let PatKind::Wild = j.pat.kind {\n+                        // if the last arm is _, then i could be integrated into _\n+                        // note that i.pat cannot be _, because that would mean that we're\n+                        // hiding all the subsequent arms, and rust won't compile\n+                        diag.span_note(\n+                            i.body.span,\n+                            &format!(\n+                                \"`{}` has the same arm body as the `_` wildcard, consider removing it\",\n+                                lhs\n+                            ),\n+                        );\n+                    } else {\n+                        diag.span_help(i.pat.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs,))\n+                            .help(\"...or consider changing the match arm bodies\");\n+                    }\n+                },\n+            );\n+        }\n+    }\n+}\n+\n+fn pat_contains_local(pat: &Pat<'_>, id: HirId) -> bool {\n+    let mut result = false;\n+    pat.walk_short(|p| {\n+        result |= matches!(p.kind, PatKind::Binding(_, binding_id, ..) if binding_id == id);\n+        !result\n+    });\n+    result\n+}\n+\n+/// Returns true if all the bindings in the `Pat` are in `ids` and vice versa\n+fn bindings_eq(pat: &Pat<'_>, mut ids: HirIdSet) -> bool {\n+    let mut result = true;\n+    pat.each_binding_or_first(&mut |_, id, _, _| result &= ids.remove(&id));\n+    result && ids.is_empty()\n+}"}, {"sha": "8ae19e03f1a6a5afbfb1016ebd066c4da9d76d0c", "filename": "clippy_lints/src/matches/match_single_binding.rs", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs?ref=2590701b2ac9004418c5ec49896f2cf2c5016df5", "patch": "@@ -0,0 +1,166 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::{indent_of, snippet_block, snippet_opt, snippet_with_applicability};\n+use clippy_utils::sugg::Sugg;\n+use clippy_utils::{get_parent_expr, is_refutable, peel_blocks};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Arm, Expr, ExprKind, Local, Node, PatKind};\n+use rustc_lint::LateContext;\n+\n+use super::MATCH_SINGLE_BINDING;\n+\n+#[allow(clippy::too_many_lines)]\n+pub(crate) fn check<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n+    if expr.span.from_expansion() || arms.len() != 1 || is_refutable(cx, arms[0].pat) {\n+        return;\n+    }\n+\n+    // HACK:\n+    // This is a hack to deal with arms that are excluded by macros like `#[cfg]`. It is only used here\n+    // to prevent false positives as there is currently no better way to detect if code was excluded by\n+    // a macro. See PR #6435\n+    if_chain! {\n+        if let Some(match_snippet) = snippet_opt(cx, expr.span);\n+        if let Some(arm_snippet) = snippet_opt(cx, arms[0].span);\n+        if let Some(ex_snippet) = snippet_opt(cx, ex.span);\n+        let rest_snippet = match_snippet.replace(&arm_snippet, \"\").replace(&ex_snippet, \"\");\n+        if rest_snippet.contains(\"=>\");\n+        then {\n+            // The code it self contains another thick arrow \"=>\"\n+            // -> Either another arm or a comment\n+            return;\n+        }\n+    }\n+\n+    let matched_vars = ex.span;\n+    let bind_names = arms[0].pat.span;\n+    let match_body = peel_blocks(arms[0].body);\n+    let mut snippet_body = if match_body.span.from_expansion() {\n+        Sugg::hir_with_macro_callsite(cx, match_body, \"..\").to_string()\n+    } else {\n+        snippet_block(cx, match_body.span, \"..\", Some(expr.span)).to_string()\n+    };\n+\n+    // Do we need to add ';' to suggestion ?\n+    match match_body.kind {\n+        ExprKind::Block(block, _) => {\n+            // macro + expr_ty(body) == ()\n+            if block.span.from_expansion() && cx.typeck_results().expr_ty(match_body).is_unit() {\n+                snippet_body.push(';');\n+            }\n+        },\n+        _ => {\n+            // expr_ty(body) == ()\n+            if cx.typeck_results().expr_ty(match_body).is_unit() {\n+                snippet_body.push(';');\n+            }\n+        },\n+    }\n+\n+    let mut applicability = Applicability::MaybeIncorrect;\n+    match arms[0].pat.kind {\n+        PatKind::Binding(..) | PatKind::Tuple(_, _) | PatKind::Struct(..) => {\n+            // If this match is in a local (`let`) stmt\n+            let (target_span, sugg) = if let Some(parent_let_node) = opt_parent_let(cx, ex) {\n+                (\n+                    parent_let_node.span,\n+                    format!(\n+                        \"let {} = {};\\n{}let {} = {};\",\n+                        snippet_with_applicability(cx, bind_names, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, matched_vars, \"..\", &mut applicability),\n+                        \" \".repeat(indent_of(cx, expr.span).unwrap_or(0)),\n+                        snippet_with_applicability(cx, parent_let_node.pat.span, \"..\", &mut applicability),\n+                        snippet_body\n+                    ),\n+                )\n+            } else {\n+                // If we are in closure, we need curly braces around suggestion\n+                let mut indent = \" \".repeat(indent_of(cx, ex.span).unwrap_or(0));\n+                let (mut cbrace_start, mut cbrace_end) = (\"\".to_string(), \"\".to_string());\n+                if let Some(parent_expr) = get_parent_expr(cx, expr) {\n+                    if let ExprKind::Closure(..) = parent_expr.kind {\n+                        cbrace_end = format!(\"\\n{}}}\", indent);\n+                        // Fix body indent due to the closure\n+                        indent = \" \".repeat(indent_of(cx, bind_names).unwrap_or(0));\n+                        cbrace_start = format!(\"{{\\n{}\", indent);\n+                    }\n+                }\n+                // If the parent is already an arm, and the body is another match statement,\n+                // we need curly braces around suggestion\n+                let parent_node_id = cx.tcx.hir().get_parent_node(expr.hir_id);\n+                if let Node::Arm(arm) = &cx.tcx.hir().get(parent_node_id) {\n+                    if let ExprKind::Match(..) = arm.body.kind {\n+                        cbrace_end = format!(\"\\n{}}}\", indent);\n+                        // Fix body indent due to the match\n+                        indent = \" \".repeat(indent_of(cx, bind_names).unwrap_or(0));\n+                        cbrace_start = format!(\"{{\\n{}\", indent);\n+                    }\n+                }\n+                (\n+                    expr.span,\n+                    format!(\n+                        \"{}let {} = {};\\n{}{}{}\",\n+                        cbrace_start,\n+                        snippet_with_applicability(cx, bind_names, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, matched_vars, \"..\", &mut applicability),\n+                        indent,\n+                        snippet_body,\n+                        cbrace_end\n+                    ),\n+                )\n+            };\n+            span_lint_and_sugg(\n+                cx,\n+                MATCH_SINGLE_BINDING,\n+                target_span,\n+                \"this match could be written as a `let` statement\",\n+                \"consider using `let` statement\",\n+                sugg,\n+                applicability,\n+            );\n+        },\n+        PatKind::Wild => {\n+            if ex.can_have_side_effects() {\n+                let indent = \" \".repeat(indent_of(cx, expr.span).unwrap_or(0));\n+                let sugg = format!(\n+                    \"{};\\n{}{}\",\n+                    snippet_with_applicability(cx, ex.span, \"..\", &mut applicability),\n+                    indent,\n+                    snippet_body\n+                );\n+                span_lint_and_sugg(\n+                    cx,\n+                    MATCH_SINGLE_BINDING,\n+                    expr.span,\n+                    \"this match could be replaced by its scrutinee and body\",\n+                    \"consider using the scrutinee and body instead\",\n+                    sugg,\n+                    applicability,\n+                );\n+            } else {\n+                span_lint_and_sugg(\n+                    cx,\n+                    MATCH_SINGLE_BINDING,\n+                    expr.span,\n+                    \"this match could be replaced by its body itself\",\n+                    \"consider using the match body instead\",\n+                    snippet_body,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        },\n+        _ => (),\n+    }\n+}\n+\n+/// Returns true if the `ex` match expression is in a local (`let`) statement\n+fn opt_parent_let<'a>(cx: &LateContext<'a>, ex: &Expr<'a>) -> Option<&'a Local<'a>> {\n+    let map = &cx.tcx.hir();\n+    if_chain! {\n+        if let Some(Node::Expr(parent_arm_expr)) = map.find(map.get_parent_node(ex.hir_id));\n+        if let Some(Node::Local(parent_let_expr)) = map.find(map.get_parent_node(parent_arm_expr.hir_id));\n+        then {\n+            return Some(parent_let_expr);\n+        }\n+    }\n+    None\n+}"}, {"sha": "3515286d5b4af8e45596abfc7dd98ce51a1b2521", "filename": "clippy_lints/src/matches/match_wild_enum.rs", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_enum.rs?ref=2590701b2ac9004418c5ec49896f2cf2c5016df5", "patch": "@@ -0,0 +1,198 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{is_refutable, peel_hir_pat_refs, recurse_or_patterns};\n+use rustc_errors::Applicability;\n+use rustc_hir::def::{CtorKind, DefKind, Res};\n+use rustc_hir::{Arm, Expr, PatKind, PathSegment, QPath, Ty, TyKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, VariantDef};\n+use rustc_span::sym;\n+\n+use super::{MATCH_WILDCARD_FOR_SINGLE_VARIANTS, WILDCARD_ENUM_MATCH_ARM};\n+\n+#[allow(clippy::too_many_lines)]\n+pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n+    let ty = cx.typeck_results().expr_ty(ex).peel_refs();\n+    let adt_def = match ty.kind() {\n+        ty::Adt(adt_def, _)\n+            if adt_def.is_enum()\n+                && !(is_type_diagnostic_item(cx, ty, sym::Option) || is_type_diagnostic_item(cx, ty, sym::Result)) =>\n+        {\n+            adt_def\n+        },\n+        _ => return,\n+    };\n+\n+    // First pass - check for violation, but don't do much book-keeping because this is hopefully\n+    // the uncommon case, and the book-keeping is slightly expensive.\n+    let mut wildcard_span = None;\n+    let mut wildcard_ident = None;\n+    let mut has_non_wild = false;\n+    for arm in arms {\n+        match peel_hir_pat_refs(arm.pat).0.kind {\n+            PatKind::Wild => wildcard_span = Some(arm.pat.span),\n+            PatKind::Binding(_, _, ident, None) => {\n+                wildcard_span = Some(arm.pat.span);\n+                wildcard_ident = Some(ident);\n+            },\n+            _ => has_non_wild = true,\n+        }\n+    }\n+    let wildcard_span = match wildcard_span {\n+        Some(x) if has_non_wild => x,\n+        _ => return,\n+    };\n+\n+    // Accumulate the variants which should be put in place of the wildcard because they're not\n+    // already covered.\n+    let has_hidden = adt_def.variants.iter().any(|x| is_hidden(cx, x));\n+    let mut missing_variants: Vec<_> = adt_def.variants.iter().filter(|x| !is_hidden(cx, x)).collect();\n+\n+    let mut path_prefix = CommonPrefixSearcher::None;\n+    for arm in arms {\n+        // Guards mean that this case probably isn't exhaustively covered. Technically\n+        // this is incorrect, as we should really check whether each variant is exhaustively\n+        // covered by the set of guards that cover it, but that's really hard to do.\n+        recurse_or_patterns(arm.pat, |pat| {\n+            let path = match &peel_hir_pat_refs(pat).0.kind {\n+                PatKind::Path(path) => {\n+                    #[allow(clippy::match_same_arms)]\n+                    let id = match cx.qpath_res(path, pat.hir_id) {\n+                        Res::Def(\n+                            DefKind::Const | DefKind::ConstParam | DefKind::AnonConst | DefKind::InlineConst,\n+                            _,\n+                        ) => return,\n+                        Res::Def(_, id) => id,\n+                        _ => return,\n+                    };\n+                    if arm.guard.is_none() {\n+                        missing_variants.retain(|e| e.ctor_def_id != Some(id));\n+                    }\n+                    path\n+                },\n+                PatKind::TupleStruct(path, patterns, ..) => {\n+                    if let Some(id) = cx.qpath_res(path, pat.hir_id).opt_def_id() {\n+                        if arm.guard.is_none() && patterns.iter().all(|p| !is_refutable(cx, p)) {\n+                            missing_variants.retain(|e| e.ctor_def_id != Some(id));\n+                        }\n+                    }\n+                    path\n+                },\n+                PatKind::Struct(path, patterns, ..) => {\n+                    if let Some(id) = cx.qpath_res(path, pat.hir_id).opt_def_id() {\n+                        if arm.guard.is_none() && patterns.iter().all(|p| !is_refutable(cx, p.pat)) {\n+                            missing_variants.retain(|e| e.def_id != id);\n+                        }\n+                    }\n+                    path\n+                },\n+                _ => return,\n+            };\n+            match path {\n+                QPath::Resolved(_, path) => path_prefix.with_path(path.segments),\n+                QPath::TypeRelative(\n+                    Ty {\n+                        kind: TyKind::Path(QPath::Resolved(_, path)),\n+                        ..\n+                    },\n+                    _,\n+                ) => path_prefix.with_prefix(path.segments),\n+                _ => (),\n+            }\n+        });\n+    }\n+\n+    let format_suggestion = |variant: &VariantDef| {\n+        format!(\n+            \"{}{}{}{}\",\n+            if let Some(ident) = wildcard_ident {\n+                format!(\"{} @ \", ident.name)\n+            } else {\n+                String::new()\n+            },\n+            if let CommonPrefixSearcher::Path(path_prefix) = path_prefix {\n+                let mut s = String::new();\n+                for seg in path_prefix {\n+                    s.push_str(seg.ident.as_str());\n+                    s.push_str(\"::\");\n+                }\n+                s\n+            } else {\n+                let mut s = cx.tcx.def_path_str(adt_def.did);\n+                s.push_str(\"::\");\n+                s\n+            },\n+            variant.name,\n+            match variant.ctor_kind {\n+                CtorKind::Fn if variant.fields.len() == 1 => \"(_)\",\n+                CtorKind::Fn => \"(..)\",\n+                CtorKind::Const => \"\",\n+                CtorKind::Fictive => \"{ .. }\",\n+            }\n+        )\n+    };\n+\n+    match missing_variants.as_slice() {\n+        [] => (),\n+        [x] if !adt_def.is_variant_list_non_exhaustive() && !has_hidden => span_lint_and_sugg(\n+            cx,\n+            MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n+            wildcard_span,\n+            \"wildcard matches only a single variant and will also match any future added variants\",\n+            \"try this\",\n+            format_suggestion(x),\n+            Applicability::MaybeIncorrect,\n+        ),\n+        variants => {\n+            let mut suggestions: Vec<_> = variants.iter().copied().map(format_suggestion).collect();\n+            let message = if adt_def.is_variant_list_non_exhaustive() || has_hidden {\n+                suggestions.push(\"_\".into());\n+                \"wildcard matches known variants and will also match future added variants\"\n+            } else {\n+                \"wildcard match will also match any future added variants\"\n+            };\n+\n+            span_lint_and_sugg(\n+                cx,\n+                WILDCARD_ENUM_MATCH_ARM,\n+                wildcard_span,\n+                message,\n+                \"try this\",\n+                suggestions.join(\" | \"),\n+                Applicability::MaybeIncorrect,\n+            );\n+        },\n+    };\n+}\n+\n+enum CommonPrefixSearcher<'a> {\n+    None,\n+    Path(&'a [PathSegment<'a>]),\n+    Mixed,\n+}\n+impl<'a> CommonPrefixSearcher<'a> {\n+    fn with_path(&mut self, path: &'a [PathSegment<'a>]) {\n+        match path {\n+            [path @ .., _] => self.with_prefix(path),\n+            [] => (),\n+        }\n+    }\n+\n+    fn with_prefix(&mut self, path: &'a [PathSegment<'a>]) {\n+        match self {\n+            Self::None => *self = Self::Path(path),\n+            Self::Path(self_path)\n+                if path\n+                    .iter()\n+                    .map(|p| p.ident.name)\n+                    .eq(self_path.iter().map(|p| p.ident.name)) => {},\n+            Self::Path(_) => *self = Self::Mixed,\n+            Self::Mixed => (),\n+        }\n+    }\n+}\n+\n+fn is_hidden(cx: &LateContext<'_>, variant_def: &VariantDef) -> bool {\n+    let attrs = cx.tcx.get_attrs(variant_def.def_id);\n+    clippy_utils::attrs::is_doc_hidden(attrs) || clippy_utils::attrs::is_unstable(attrs)\n+}"}, {"sha": "bc16f17b6196e420184860ce3dd731f9eeeebdbe", "filename": "clippy_lints/src/matches/match_wild_err_arm.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_err_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_err_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_err_arm.rs?ref=2590701b2ac9004418c5ec49896f2cf2c5016df5", "patch": "@@ -0,0 +1,51 @@\n+use clippy_utils::diagnostics::span_lint_and_note;\n+use clippy_utils::macros::{is_panic, root_macro_call};\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::visitors::is_local_used;\n+use clippy_utils::{is_wild, peel_blocks_with_stmt};\n+use rustc_hir::{Arm, Expr, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::{kw, sym};\n+\n+use super::MATCH_WILD_ERR_ARM;\n+\n+pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, ex: &Expr<'tcx>, arms: &[Arm<'tcx>]) {\n+    let ex_ty = cx.typeck_results().expr_ty(ex).peel_refs();\n+    if is_type_diagnostic_item(cx, ex_ty, sym::Result) {\n+        for arm in arms {\n+            if let PatKind::TupleStruct(ref path, inner, _) = arm.pat.kind {\n+                let path_str = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false));\n+                if path_str == \"Err\" {\n+                    let mut matching_wild = inner.iter().any(is_wild);\n+                    let mut ident_bind_name = kw::Underscore;\n+                    if !matching_wild {\n+                        // Looking for unused bindings (i.e.: `_e`)\n+                        for pat in inner.iter() {\n+                            if let PatKind::Binding(_, id, ident, None) = pat.kind {\n+                                if ident.as_str().starts_with('_') && !is_local_used(cx, arm.body, id) {\n+                                    ident_bind_name = ident.name;\n+                                    matching_wild = true;\n+                                }\n+                            }\n+                        }\n+                    }\n+                    if_chain! {\n+                        if matching_wild;\n+                        if let Some(macro_call) = root_macro_call(peel_blocks_with_stmt(arm.body).span);\n+                        if is_panic(cx, macro_call.def_id);\n+                        then {\n+                            // `Err(_)` or `Err(_e)` arm with `panic!` found\n+                            span_lint_and_note(cx,\n+                                MATCH_WILD_ERR_ARM,\n+                                arm.pat.span,\n+                                &format!(\"`Err({})` matches all errors\", ident_bind_name),\n+                                None,\n+                                \"match each error separately or use the error output, or use `.except(msg)` if the error case is unreachable\",\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "b5ee4561f06eceeb346ea5f648adf7357ddb9ea6", "filename": "clippy_lints/src/matches/mod.rs", "status": "added", "additions": 646, "deletions": 0, "changes": 646, "blob_url": "https://github.com/rust-lang/rust/blob/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=2590701b2ac9004418c5ec49896f2cf2c5016df5", "patch": "@@ -0,0 +1,646 @@\n+use clippy_utils::{meets_msrv, msrvs};\n+use rustc_hir::{Expr, ExprKind, Local, MatchSource, Pat};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+\n+mod infalliable_detructuring_match;\n+mod match_as_ref;\n+mod match_bool;\n+mod match_like_matches;\n+mod match_ref_pats;\n+mod match_same_arms;\n+mod match_single_binding;\n+mod match_wild_enum;\n+mod match_wild_err_arm;\n+mod overlapping_arms;\n+mod redundant_pattern_match;\n+mod rest_pat_in_fully_bound_struct;\n+mod single_match;\n+mod wild_in_or_pats;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for matches with a single arm where an `if let`\n+    /// will usually suffice.\n+    ///\n+    /// ### Why is this bad?\n+    /// Just readability \u2013 `if let` nests less than a `match`.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # fn bar(stool: &str) {}\n+    /// # let x = Some(\"abc\");\n+    /// // Bad\n+    /// match x {\n+    ///     Some(ref foo) => bar(foo),\n+    ///     _ => (),\n+    /// }\n+    ///\n+    /// // Good\n+    /// if let Some(ref foo) = x {\n+    ///     bar(foo);\n+    /// }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub SINGLE_MATCH,\n+    style,\n+    \"a `match` statement with a single nontrivial arm (i.e., where the other arm is `_ => {}`) instead of `if let`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for matches with two arms where an `if let else` will\n+    /// usually suffice.\n+    ///\n+    /// ### Why is this bad?\n+    /// Just readability \u2013 `if let` nests less than a `match`.\n+    ///\n+    /// ### Known problems\n+    /// Personal style preferences may differ.\n+    ///\n+    /// ### Example\n+    /// Using `match`:\n+    ///\n+    /// ```rust\n+    /// # fn bar(foo: &usize) {}\n+    /// # let other_ref: usize = 1;\n+    /// # let x: Option<&usize> = Some(&1);\n+    /// match x {\n+    ///     Some(ref foo) => bar(foo),\n+    ///     _ => bar(&other_ref),\n+    /// }\n+    /// ```\n+    ///\n+    /// Using `if let` with `else`:\n+    ///\n+    /// ```rust\n+    /// # fn bar(foo: &usize) {}\n+    /// # let other_ref: usize = 1;\n+    /// # let x: Option<&usize> = Some(&1);\n+    /// if let Some(ref foo) = x {\n+    ///     bar(foo);\n+    /// } else {\n+    ///     bar(&other_ref);\n+    /// }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub SINGLE_MATCH_ELSE,\n+    pedantic,\n+    \"a `match` statement with two arms where the second arm's pattern is a placeholder instead of a specific match pattern\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for matches where all arms match a reference,\n+    /// suggesting to remove the reference and deref the matched expression\n+    /// instead. It also checks for `if let &foo = bar` blocks.\n+    ///\n+    /// ### Why is this bad?\n+    /// It just makes the code less readable. That reference\n+    /// destructuring adds nothing to the code.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// // Bad\n+    /// match x {\n+    ///     &A(ref y) => foo(y),\n+    ///     &B => bar(),\n+    ///     _ => frob(&x),\n+    /// }\n+    ///\n+    /// // Good\n+    /// match *x {\n+    ///     A(ref y) => foo(y),\n+    ///     B => bar(),\n+    ///     _ => frob(x),\n+    /// }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub MATCH_REF_PATS,\n+    style,\n+    \"a `match` or `if let` with all arms prefixed with `&` instead of deref-ing the match expression\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for matches where match expression is a `bool`. It\n+    /// suggests to replace the expression with an `if...else` block.\n+    ///\n+    /// ### Why is this bad?\n+    /// It makes the code less readable.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # fn foo() {}\n+    /// # fn bar() {}\n+    /// let condition: bool = true;\n+    /// match condition {\n+    ///     true => foo(),\n+    ///     false => bar(),\n+    /// }\n+    /// ```\n+    /// Use if/else instead:\n+    /// ```rust\n+    /// # fn foo() {}\n+    /// # fn bar() {}\n+    /// let condition: bool = true;\n+    /// if condition {\n+    ///     foo();\n+    /// } else {\n+    ///     bar();\n+    /// }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub MATCH_BOOL,\n+    pedantic,\n+    \"a `match` on a boolean expression instead of an `if..else` block\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for overlapping match arms.\n+    ///\n+    /// ### Why is this bad?\n+    /// It is likely to be an error and if not, makes the code\n+    /// less obvious.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x = 5;\n+    /// match x {\n+    ///     1..=10 => println!(\"1 ... 10\"),\n+    ///     5..=15 => println!(\"5 ... 15\"),\n+    ///     _ => (),\n+    /// }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub MATCH_OVERLAPPING_ARM,\n+    style,\n+    \"a `match` with overlapping arms\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for arm which matches all errors with `Err(_)`\n+    /// and take drastic actions like `panic!`.\n+    ///\n+    /// ### Why is this bad?\n+    /// It is generally a bad practice, similar to\n+    /// catching all exceptions in java with `catch(Exception)`\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x: Result<i32, &str> = Ok(3);\n+    /// match x {\n+    ///     Ok(_) => println!(\"ok\"),\n+    ///     Err(_) => panic!(\"err\"),\n+    /// }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub MATCH_WILD_ERR_ARM,\n+    pedantic,\n+    \"a `match` with `Err(_)` arm and take drastic actions\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for match which is used to add a reference to an\n+    /// `Option` value.\n+    ///\n+    /// ### Why is this bad?\n+    /// Using `as_ref()` or `as_mut()` instead is shorter.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x: Option<()> = None;\n+    ///\n+    /// // Bad\n+    /// let r: Option<&()> = match x {\n+    ///     None => None,\n+    ///     Some(ref v) => Some(v),\n+    /// };\n+    ///\n+    /// // Good\n+    /// let r: Option<&()> = x.as_ref();\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub MATCH_AS_REF,\n+    complexity,\n+    \"a `match` on an Option value instead of using `as_ref()` or `as_mut`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for wildcard enum matches using `_`.\n+    ///\n+    /// ### Why is this bad?\n+    /// New enum variants added by library updates can be missed.\n+    ///\n+    /// ### Known problems\n+    /// Suggested replacements may be incorrect if guards exhaustively cover some\n+    /// variants, and also may not use correct path to enum if it's not present in the current scope.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # enum Foo { A(usize), B(usize) }\n+    /// # let x = Foo::B(1);\n+    /// // Bad\n+    /// match x {\n+    ///     Foo::A(_) => {},\n+    ///     _ => {},\n+    /// }\n+    ///\n+    /// // Good\n+    /// match x {\n+    ///     Foo::A(_) => {},\n+    ///     Foo::B(_) => {},\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.34.0\"]\n+    pub WILDCARD_ENUM_MATCH_ARM,\n+    restriction,\n+    \"a wildcard enum match arm using `_`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for wildcard enum matches for a single variant.\n+    ///\n+    /// ### Why is this bad?\n+    /// New enum variants added by library updates can be missed.\n+    ///\n+    /// ### Known problems\n+    /// Suggested replacements may not use correct path to enum\n+    /// if it's not present in the current scope.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # enum Foo { A, B, C }\n+    /// # let x = Foo::B;\n+    /// // Bad\n+    /// match x {\n+    ///     Foo::A => {},\n+    ///     Foo::B => {},\n+    ///     _ => {},\n+    /// }\n+    ///\n+    /// // Good\n+    /// match x {\n+    ///     Foo::A => {},\n+    ///     Foo::B => {},\n+    ///     Foo::C => {},\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.45.0\"]\n+    pub MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n+    pedantic,\n+    \"a wildcard enum match for a single variant\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for wildcard pattern used with others patterns in same match arm.\n+    ///\n+    /// ### Why is this bad?\n+    /// Wildcard pattern already covers any other pattern as it will match anyway.\n+    /// It makes the code less readable, especially to spot wildcard pattern use in match arm.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// // Bad\n+    /// match \"foo\" {\n+    ///     \"a\" => {},\n+    ///     \"bar\" | _ => {},\n+    /// }\n+    ///\n+    /// // Good\n+    /// match \"foo\" {\n+    ///     \"a\" => {},\n+    ///     _ => {},\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.42.0\"]\n+    pub WILDCARD_IN_OR_PATTERNS,\n+    complexity,\n+    \"a wildcard pattern used with others patterns in same match arm\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for matches being used to destructure a single-variant enum\n+    /// or tuple struct where a `let` will suffice.\n+    ///\n+    /// ### Why is this bad?\n+    /// Just readability \u2013 `let` doesn't nest, whereas a `match` does.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// enum Wrapper {\n+    ///     Data(i32),\n+    /// }\n+    ///\n+    /// let wrapper = Wrapper::Data(42);\n+    ///\n+    /// let data = match wrapper {\n+    ///     Wrapper::Data(i) => i,\n+    /// };\n+    /// ```\n+    ///\n+    /// The correct use would be:\n+    /// ```rust\n+    /// enum Wrapper {\n+    ///     Data(i32),\n+    /// }\n+    ///\n+    /// let wrapper = Wrapper::Data(42);\n+    /// let Wrapper::Data(data) = wrapper;\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub INFALLIBLE_DESTRUCTURING_MATCH,\n+    style,\n+    \"a `match` statement with a single infallible arm instead of a `let`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for useless match that binds to only one value.\n+    ///\n+    /// ### Why is this bad?\n+    /// Readability and needless complexity.\n+    ///\n+    /// ### Known problems\n+    ///  Suggested replacements may be incorrect when `match`\n+    /// is actually binding temporary value, bringing a 'dropped while borrowed' error.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let a = 1;\n+    /// # let b = 2;\n+    ///\n+    /// // Bad\n+    /// match (a, b) {\n+    ///     (c, d) => {\n+    ///         // useless match\n+    ///     }\n+    /// }\n+    ///\n+    /// // Good\n+    /// let (c, d) = (a, b);\n+    /// ```\n+    #[clippy::version = \"1.43.0\"]\n+    pub MATCH_SINGLE_BINDING,\n+    complexity,\n+    \"a match with a single binding instead of using `let` statement\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for unnecessary '..' pattern binding on struct when all fields are explicitly matched.\n+    ///\n+    /// ### Why is this bad?\n+    /// Correctness and readability. It's like having a wildcard pattern after\n+    /// matching all enum variants explicitly.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # struct A { a: i32 }\n+    /// let a = A { a: 5 };\n+    ///\n+    /// // Bad\n+    /// match a {\n+    ///     A { a: 5, .. } => {},\n+    ///     _ => {},\n+    /// }\n+    ///\n+    /// // Good\n+    /// match a {\n+    ///     A { a: 5 } => {},\n+    ///     _ => {},\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.43.0\"]\n+    pub REST_PAT_IN_FULLY_BOUND_STRUCTS,\n+    restriction,\n+    \"a match on a struct that binds all fields but still uses the wildcard pattern\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Lint for redundant pattern matching over `Result`, `Option`,\n+    /// `std::task::Poll` or `std::net::IpAddr`\n+    ///\n+    /// ### Why is this bad?\n+    /// It's more concise and clear to just use the proper\n+    /// utility function\n+    ///\n+    /// ### Known problems\n+    /// This will change the drop order for the matched type. Both `if let` and\n+    /// `while let` will drop the value at the end of the block, both `if` and `while` will drop the\n+    /// value before entering the block. For most types this change will not matter, but for a few\n+    /// types this will not be an acceptable change (e.g. locks). See the\n+    /// [reference](https://doc.rust-lang.org/reference/destructors.html#drop-scopes) for more about\n+    /// drop order.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # use std::task::Poll;\n+    /// # use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    /// if let Ok(_) = Ok::<i32, i32>(42) {}\n+    /// if let Err(_) = Err::<i32, i32>(42) {}\n+    /// if let None = None::<()> {}\n+    /// if let Some(_) = Some(42) {}\n+    /// if let Poll::Pending = Poll::Pending::<()> {}\n+    /// if let Poll::Ready(_) = Poll::Ready(42) {}\n+    /// if let IpAddr::V4(_) = IpAddr::V4(Ipv4Addr::LOCALHOST) {}\n+    /// if let IpAddr::V6(_) = IpAddr::V6(Ipv6Addr::LOCALHOST) {}\n+    /// match Ok::<i32, i32>(42) {\n+    ///     Ok(_) => true,\n+    ///     Err(_) => false,\n+    /// };\n+    /// ```\n+    ///\n+    /// The more idiomatic use would be:\n+    ///\n+    /// ```rust\n+    /// # use std::task::Poll;\n+    /// # use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    /// if Ok::<i32, i32>(42).is_ok() {}\n+    /// if Err::<i32, i32>(42).is_err() {}\n+    /// if None::<()>.is_none() {}\n+    /// if Some(42).is_some() {}\n+    /// if Poll::Pending::<()>.is_pending() {}\n+    /// if Poll::Ready(42).is_ready() {}\n+    /// if IpAddr::V4(Ipv4Addr::LOCALHOST).is_ipv4() {}\n+    /// if IpAddr::V6(Ipv6Addr::LOCALHOST).is_ipv6() {}\n+    /// Ok::<i32, i32>(42).is_ok();\n+    /// ```\n+    #[clippy::version = \"1.31.0\"]\n+    pub REDUNDANT_PATTERN_MATCHING,\n+    style,\n+    \"use the proper utility function avoiding an `if let`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `match`  or `if let` expressions producing a\n+    /// `bool` that could be written using `matches!`\n+    ///\n+    /// ### Why is this bad?\n+    /// Readability and needless complexity.\n+    ///\n+    /// ### Known problems\n+    /// This lint falsely triggers, if there are arms with\n+    /// `cfg` attributes that remove an arm evaluating to `false`.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x = Some(5);\n+    ///\n+    /// // Bad\n+    /// let a = match x {\n+    ///     Some(0) => true,\n+    ///     _ => false,\n+    /// };\n+    ///\n+    /// let a = if let Some(0) = x {\n+    ///     true\n+    /// } else {\n+    ///     false\n+    /// };\n+    ///\n+    /// // Good\n+    /// let a = matches!(x, Some(0));\n+    /// ```\n+    #[clippy::version = \"1.47.0\"]\n+    pub MATCH_LIKE_MATCHES_MACRO,\n+    style,\n+    \"a match that could be written with the matches! macro\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `match` with identical arm bodies.\n+    ///\n+    /// ### Why is this bad?\n+    /// This is probably a copy & paste error. If arm bodies\n+    /// are the same on purpose, you can factor them\n+    /// [using `|`](https://doc.rust-lang.org/book/patterns.html#multiple-patterns).\n+    ///\n+    /// ### Known problems\n+    /// False positive possible with order dependent `match`\n+    /// (see issue\n+    /// [#860](https://github.com/rust-lang/rust-clippy/issues/860)).\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// match foo {\n+    ///     Bar => bar(),\n+    ///     Quz => quz(),\n+    ///     Baz => bar(), // <= oops\n+    /// }\n+    /// ```\n+    ///\n+    /// This should probably be\n+    /// ```rust,ignore\n+    /// match foo {\n+    ///     Bar => bar(),\n+    ///     Quz => quz(),\n+    ///     Baz => baz(), // <= fixed\n+    /// }\n+    /// ```\n+    ///\n+    /// or if the original code was not a typo:\n+    /// ```rust,ignore\n+    /// match foo {\n+    ///     Bar | Baz => bar(), // <= shows the intent better\n+    ///     Quz => quz(),\n+    /// }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub MATCH_SAME_ARMS,\n+    pedantic,\n+    \"`match` with identical arm bodies\"\n+}\n+\n+#[derive(Default)]\n+pub struct Matches {\n+    msrv: Option<RustcVersion>,\n+    infallible_destructuring_match_linted: bool,\n+}\n+\n+impl Matches {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self {\n+            msrv,\n+            ..Matches::default()\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(Matches => [\n+    SINGLE_MATCH,\n+    MATCH_REF_PATS,\n+    MATCH_BOOL,\n+    SINGLE_MATCH_ELSE,\n+    MATCH_OVERLAPPING_ARM,\n+    MATCH_WILD_ERR_ARM,\n+    MATCH_AS_REF,\n+    WILDCARD_ENUM_MATCH_ARM,\n+    MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n+    WILDCARD_IN_OR_PATTERNS,\n+    MATCH_SINGLE_BINDING,\n+    INFALLIBLE_DESTRUCTURING_MATCH,\n+    REST_PAT_IN_FULLY_BOUND_STRUCTS,\n+    REDUNDANT_PATTERN_MATCHING,\n+    MATCH_LIKE_MATCHES_MACRO,\n+    MATCH_SAME_ARMS,\n+]);\n+\n+impl<'tcx> LateLintPass<'tcx> for Matches {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if expr.span.from_expansion() {\n+            return;\n+        }\n+\n+        redundant_pattern_match::check(cx, expr);\n+\n+        if meets_msrv(self.msrv.as_ref(), &msrvs::MATCHES_MACRO) {\n+            if !match_like_matches::check(cx, expr) {\n+                match_same_arms::check(cx, expr);\n+            }\n+        } else {\n+            match_same_arms::check(cx, expr);\n+        }\n+\n+        if let ExprKind::Match(ex, arms, MatchSource::Normal) = expr.kind {\n+            single_match::check(cx, ex, arms, expr);\n+            match_bool::check(cx, ex, arms, expr);\n+            overlapping_arms::check(cx, ex, arms);\n+            match_wild_err_arm::check(cx, ex, arms);\n+            match_wild_enum::check(cx, ex, arms);\n+            match_as_ref::check(cx, ex, arms, expr);\n+            wild_in_or_pats::check(cx, arms);\n+\n+            if self.infallible_destructuring_match_linted {\n+                self.infallible_destructuring_match_linted = false;\n+            } else {\n+                match_single_binding::check(cx, ex, arms, expr);\n+            }\n+        }\n+        if let ExprKind::Match(ex, arms, _) = expr.kind {\n+            match_ref_pats::check(cx, ex, arms.iter().map(|el| el.pat), expr);\n+        }\n+    }\n+\n+    fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'_>) {\n+        self.infallible_destructuring_match_linted |= infalliable_detructuring_match::check(cx, local);\n+    }\n+\n+    fn check_pat(&mut self, cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) {\n+        rest_pat_in_fully_bound_struct::check(cx, pat);\n+    }\n+\n+    extract_msrv_attr!(LateContext);\n+}"}, {"sha": "7e658126690299787f1410a713533a78d8c60a06", "filename": "clippy_lints/src/matches/overlapping_arms.rs", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs?ref=2590701b2ac9004418c5ec49896f2cf2c5016df5", "patch": "@@ -0,0 +1,181 @@\n+use clippy_utils::consts::{constant, constant_full_int, miri_to_const, FullInt};\n+use clippy_utils::diagnostics::span_lint_and_note;\n+use core::cmp::Ordering;\n+use rustc_hir::{Arm, Expr, PatKind, RangeEnd};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::Ty;\n+use rustc_span::Span;\n+\n+use super::MATCH_OVERLAPPING_ARM;\n+\n+pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, ex: &'tcx Expr<'_>, arms: &'tcx [Arm<'_>]) {\n+    if arms.len() >= 2 && cx.typeck_results().expr_ty(ex).is_integral() {\n+        let ranges = all_ranges(cx, arms, cx.typeck_results().expr_ty(ex));\n+        if !ranges.is_empty() {\n+            if let Some((start, end)) = overlapping(&ranges) {\n+                span_lint_and_note(\n+                    cx,\n+                    MATCH_OVERLAPPING_ARM,\n+                    start.span,\n+                    \"some ranges overlap\",\n+                    Some(end.span),\n+                    \"overlaps with this\",\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+/// Gets the ranges for each range pattern arm. Applies `ty` bounds for open ranges.\n+fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>) -> Vec<SpannedRange<FullInt>> {\n+    arms.iter()\n+        .filter_map(|arm| {\n+            if let Arm { pat, guard: None, .. } = *arm {\n+                if let PatKind::Range(ref lhs, ref rhs, range_end) = pat.kind {\n+                    let lhs_const = match lhs {\n+                        Some(lhs) => constant(cx, cx.typeck_results(), lhs)?.0,\n+                        None => miri_to_const(ty.numeric_min_val(cx.tcx)?)?,\n+                    };\n+                    let rhs_const = match rhs {\n+                        Some(rhs) => constant(cx, cx.typeck_results(), rhs)?.0,\n+                        None => miri_to_const(ty.numeric_max_val(cx.tcx)?)?,\n+                    };\n+\n+                    let lhs_val = lhs_const.int_value(cx, ty)?;\n+                    let rhs_val = rhs_const.int_value(cx, ty)?;\n+\n+                    let rhs_bound = match range_end {\n+                        RangeEnd::Included => EndBound::Included(rhs_val),\n+                        RangeEnd::Excluded => EndBound::Excluded(rhs_val),\n+                    };\n+                    return Some(SpannedRange {\n+                        span: pat.span,\n+                        node: (lhs_val, rhs_bound),\n+                    });\n+                }\n+\n+                if let PatKind::Lit(value) = pat.kind {\n+                    let value = constant_full_int(cx, cx.typeck_results(), value)?;\n+                    return Some(SpannedRange {\n+                        span: pat.span,\n+                        node: (value, EndBound::Included(value)),\n+                    });\n+                }\n+            }\n+            None\n+        })\n+        .collect()\n+}\n+\n+#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+pub enum EndBound<T> {\n+    Included(T),\n+    Excluded(T),\n+}\n+\n+#[derive(Debug, Eq, PartialEq)]\n+struct SpannedRange<T> {\n+    pub span: Span,\n+    pub node: (T, EndBound<T>),\n+}\n+\n+fn overlapping<T>(ranges: &[SpannedRange<T>]) -> Option<(&SpannedRange<T>, &SpannedRange<T>)>\n+where\n+    T: Copy + Ord,\n+{\n+    #[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]\n+    enum BoundKind {\n+        EndExcluded,\n+        Start,\n+        EndIncluded,\n+    }\n+\n+    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+    struct RangeBound<'a, T>(T, BoundKind, &'a SpannedRange<T>);\n+\n+    impl<'a, T: Copy + Ord> PartialOrd for RangeBound<'a, T> {\n+        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+            Some(self.cmp(other))\n+        }\n+    }\n+\n+    impl<'a, T: Copy + Ord> Ord for RangeBound<'a, T> {\n+        fn cmp(&self, RangeBound(other_value, other_kind, _): &Self) -> Ordering {\n+            let RangeBound(self_value, self_kind, _) = *self;\n+            (self_value, self_kind).cmp(&(*other_value, *other_kind))\n+        }\n+    }\n+\n+    let mut values = Vec::with_capacity(2 * ranges.len());\n+\n+    for r @ SpannedRange { node: (start, end), .. } in ranges {\n+        values.push(RangeBound(*start, BoundKind::Start, r));\n+        values.push(match end {\n+            EndBound::Excluded(val) => RangeBound(*val, BoundKind::EndExcluded, r),\n+            EndBound::Included(val) => RangeBound(*val, BoundKind::EndIncluded, r),\n+        });\n+    }\n+\n+    values.sort();\n+\n+    let mut started = vec![];\n+\n+    for RangeBound(_, kind, range) in values {\n+        match kind {\n+            BoundKind::Start => started.push(range),\n+            BoundKind::EndExcluded | BoundKind::EndIncluded => {\n+                let mut overlap = None;\n+\n+                while let Some(last_started) = started.pop() {\n+                    if last_started == range {\n+                        break;\n+                    }\n+                    overlap = Some(last_started);\n+                }\n+\n+                if let Some(first_overlapping) = overlap {\n+                    return Some((range, first_overlapping));\n+                }\n+            },\n+        }\n+    }\n+\n+    None\n+}\n+\n+#[test]\n+fn test_overlapping() {\n+    use rustc_span::source_map::DUMMY_SP;\n+\n+    let sp = |s, e| SpannedRange {\n+        span: DUMMY_SP,\n+        node: (s, e),\n+    };\n+\n+    assert_eq!(None, overlapping::<u8>(&[]));\n+    assert_eq!(None, overlapping(&[sp(1, EndBound::Included(4))]));\n+    assert_eq!(\n+        None,\n+        overlapping(&[sp(1, EndBound::Included(4)), sp(5, EndBound::Included(6))])\n+    );\n+    assert_eq!(\n+        None,\n+        overlapping(&[\n+            sp(1, EndBound::Included(4)),\n+            sp(5, EndBound::Included(6)),\n+            sp(10, EndBound::Included(11))\n+        ],)\n+    );\n+    assert_eq!(\n+        Some((&sp(1, EndBound::Included(4)), &sp(3, EndBound::Included(6)))),\n+        overlapping(&[sp(1, EndBound::Included(4)), sp(3, EndBound::Included(6))])\n+    );\n+    assert_eq!(\n+        Some((&sp(5, EndBound::Included(6)), &sp(6, EndBound::Included(11)))),\n+        overlapping(&[\n+            sp(1, EndBound::Included(4)),\n+            sp(5, EndBound::Included(6)),\n+            sp(6, EndBound::Included(11))\n+        ],)\n+    );\n+}"}, {"sha": "61c5fa0872f6a4527e3a5ef3db62986fb5d2b191", "filename": "clippy_lints/src/matches/redundant_pattern_match.rs", "status": "added", "additions": 436, "deletions": 0, "changes": 436, "blob_url": "https://github.com/rust-lang/rust/blob/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=2590701b2ac9004418c5ec49896f2cf2c5016df5", "patch": "@@ -0,0 +1,436 @@\n+use super::REDUNDANT_PATTERN_MATCHING;\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::source::snippet;\n+use clippy_utils::sugg::Sugg;\n+use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, is_type_lang_item, match_type};\n+use clippy_utils::{higher, match_def_path};\n+use clippy_utils::{is_lang_ctor, is_trait_method, paths};\n+use if_chain::if_chain;\n+use rustc_ast::ast::LitKind;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::Applicability;\n+use rustc_hir::LangItem::{OptionNone, PollPending};\n+use rustc_hir::{\n+    intravisit::{walk_expr, Visitor},\n+    Arm, Block, Expr, ExprKind, LangItem, MatchSource, Node, Pat, PatKind, QPath, UnOp,\n+};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, subst::GenericArgKind, DefIdTree, Ty};\n+use rustc_span::sym;\n+\n+pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+    if let Some(higher::IfLet {\n+        if_else,\n+        let_pat,\n+        let_expr,\n+        ..\n+    }) = higher::IfLet::hir(cx, expr)\n+    {\n+        find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"if\", if_else.is_some());\n+    }\n+    if let ExprKind::Match(op, arms, MatchSource::Normal) = &expr.kind {\n+        find_sugg_for_match(cx, expr, op, arms);\n+    }\n+    if let Some(higher::WhileLet { let_pat, let_expr, .. }) = higher::WhileLet::hir(expr) {\n+        find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"while\", false);\n+    }\n+}\n+\n+/// Checks if the drop order for a type matters. Some std types implement drop solely to\n+/// deallocate memory. For these types, and composites containing them, changing the drop order\n+/// won't result in any observable side effects.\n+fn type_needs_ordered_drop<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+    type_needs_ordered_drop_inner(cx, ty, &mut FxHashSet::default())\n+}\n+\n+fn type_needs_ordered_drop_inner<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, seen: &mut FxHashSet<Ty<'tcx>>) -> bool {\n+    if !seen.insert(ty) {\n+        return false;\n+    }\n+    if !ty.needs_drop(cx.tcx, cx.param_env) {\n+        false\n+    } else if !cx\n+        .tcx\n+        .lang_items()\n+        .drop_trait()\n+        .map_or(false, |id| implements_trait(cx, ty, id, &[]))\n+    {\n+        // This type doesn't implement drop, so no side effects here.\n+        // Check if any component type has any.\n+        match ty.kind() {\n+            ty::Tuple(_) => ty.tuple_fields().any(|ty| type_needs_ordered_drop_inner(cx, ty, seen)),\n+            ty::Array(ty, _) => type_needs_ordered_drop_inner(cx, ty, seen),\n+            ty::Adt(adt, subs) => adt\n+                .all_fields()\n+                .map(|f| f.ty(cx.tcx, subs))\n+                .any(|ty| type_needs_ordered_drop_inner(cx, ty, seen)),\n+            _ => true,\n+        }\n+    }\n+    // Check for std types which implement drop, but only for memory allocation.\n+    else if is_type_diagnostic_item(cx, ty, sym::Vec)\n+        || is_type_lang_item(cx, ty, LangItem::OwnedBox)\n+        || is_type_diagnostic_item(cx, ty, sym::Rc)\n+        || is_type_diagnostic_item(cx, ty, sym::Arc)\n+        || is_type_diagnostic_item(cx, ty, sym::cstring_type)\n+        || is_type_diagnostic_item(cx, ty, sym::BTreeMap)\n+        || is_type_diagnostic_item(cx, ty, sym::LinkedList)\n+        || match_type(cx, ty, &paths::WEAK_RC)\n+        || match_type(cx, ty, &paths::WEAK_ARC)\n+    {\n+        // Check all of the generic arguments.\n+        if let ty::Adt(_, subs) = ty.kind() {\n+            subs.types().any(|ty| type_needs_ordered_drop_inner(cx, ty, seen))\n+        } else {\n+            true\n+        }\n+    } else {\n+        true\n+    }\n+}\n+\n+// Extract the generic arguments out of a type\n+fn try_get_generic_ty(ty: Ty<'_>, index: usize) -> Option<Ty<'_>> {\n+    if_chain! {\n+        if let ty::Adt(_, subs) = ty.kind();\n+        if let Some(sub) = subs.get(index);\n+        if let GenericArgKind::Type(sub_ty) = sub.unpack();\n+        then {\n+            Some(sub_ty)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+// Checks if there are any temporaries created in the given expression for which drop order\n+// matters.\n+fn temporaries_need_ordered_drop<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+    struct V<'a, 'tcx> {\n+        cx: &'a LateContext<'tcx>,\n+        res: bool,\n+    }\n+    impl<'a, 'tcx> Visitor<'tcx> for V<'a, 'tcx> {\n+        fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+            match expr.kind {\n+                // Taking the reference of a value leaves a temporary\n+                // e.g. In `&String::new()` the string is a temporary value.\n+                // Remaining fields are temporary values\n+                // e.g. In `(String::new(), 0).1` the string is a temporary value.\n+                ExprKind::AddrOf(_, _, expr) | ExprKind::Field(expr, _) => {\n+                    if !matches!(expr.kind, ExprKind::Path(_)) {\n+                        if type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(expr)) {\n+                            self.res = true;\n+                        } else {\n+                            self.visit_expr(expr);\n+                        }\n+                    }\n+                },\n+                // the base type is alway taken by reference.\n+                // e.g. In `(vec![0])[0]` the vector is a temporary value.\n+                ExprKind::Index(base, index) => {\n+                    if !matches!(base.kind, ExprKind::Path(_)) {\n+                        if type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(base)) {\n+                            self.res = true;\n+                        } else {\n+                            self.visit_expr(base);\n+                        }\n+                    }\n+                    self.visit_expr(index);\n+                },\n+                // Method calls can take self by reference.\n+                // e.g. In `String::new().len()` the string is a temporary value.\n+                ExprKind::MethodCall(_, [self_arg, args @ ..], _) => {\n+                    if !matches!(self_arg.kind, ExprKind::Path(_)) {\n+                        let self_by_ref = self\n+                            .cx\n+                            .typeck_results()\n+                            .type_dependent_def_id(expr.hir_id)\n+                            .map_or(false, |id| self.cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref());\n+                        if self_by_ref && type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(self_arg)) {\n+                            self.res = true;\n+                        } else {\n+                            self.visit_expr(self_arg);\n+                        }\n+                    }\n+                    args.iter().for_each(|arg| self.visit_expr(arg));\n+                },\n+                // Either explicitly drops values, or changes control flow.\n+                ExprKind::DropTemps(_)\n+                | ExprKind::Ret(_)\n+                | ExprKind::Break(..)\n+                | ExprKind::Yield(..)\n+                | ExprKind::Block(Block { expr: None, .. }, _)\n+                | ExprKind::Loop(..) => (),\n+\n+                // Only consider the final expression.\n+                ExprKind::Block(Block { expr: Some(expr), .. }, _) => self.visit_expr(expr),\n+\n+                _ => walk_expr(self, expr),\n+            }\n+        }\n+    }\n+\n+    let mut v = V { cx, res: false };\n+    v.visit_expr(expr);\n+    v.res\n+}\n+\n+fn find_sugg_for_if_let<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    let_pat: &Pat<'_>,\n+    let_expr: &'tcx Expr<'_>,\n+    keyword: &'static str,\n+    has_else: bool,\n+) {\n+    // also look inside refs\n+    // if we have &None for example, peel it so we can detect \"if let None = x\"\n+    let check_pat = match let_pat.kind {\n+        PatKind::Ref(inner, _mutability) => inner,\n+        _ => let_pat,\n+    };\n+    let op_ty = cx.typeck_results().expr_ty(let_expr);\n+    // Determine which function should be used, and the type contained by the corresponding\n+    // variant.\n+    let (good_method, inner_ty) = match check_pat.kind {\n+        PatKind::TupleStruct(ref qpath, [sub_pat], _) => {\n+            if let PatKind::Wild = sub_pat.kind {\n+                let res = cx.typeck_results().qpath_res(qpath, check_pat.hir_id);\n+                let Some(id) = res.opt_def_id().and_then(|ctor_id| cx.tcx.parent(ctor_id)) else { return };\n+                let lang_items = cx.tcx.lang_items();\n+                if Some(id) == lang_items.result_ok_variant() {\n+                    (\"is_ok()\", try_get_generic_ty(op_ty, 0).unwrap_or(op_ty))\n+                } else if Some(id) == lang_items.result_err_variant() {\n+                    (\"is_err()\", try_get_generic_ty(op_ty, 1).unwrap_or(op_ty))\n+                } else if Some(id) == lang_items.option_some_variant() {\n+                    (\"is_some()\", op_ty)\n+                } else if Some(id) == lang_items.poll_ready_variant() {\n+                    (\"is_ready()\", op_ty)\n+                } else if match_def_path(cx, id, &paths::IPADDR_V4) {\n+                    (\"is_ipv4()\", op_ty)\n+                } else if match_def_path(cx, id, &paths::IPADDR_V6) {\n+                    (\"is_ipv6()\", op_ty)\n+                } else {\n+                    return;\n+                }\n+            } else {\n+                return;\n+            }\n+        },\n+        PatKind::Path(ref path) => {\n+            let method = if is_lang_ctor(cx, path, OptionNone) {\n+                \"is_none()\"\n+            } else if is_lang_ctor(cx, path, PollPending) {\n+                \"is_pending()\"\n+            } else {\n+                return;\n+            };\n+            // `None` and `Pending` don't have an inner type.\n+            (method, cx.tcx.types.unit)\n+        },\n+        _ => return,\n+    };\n+\n+    // If this is the last expression in a block or there is an else clause then the whole\n+    // type needs to be considered, not just the inner type of the branch being matched on.\n+    // Note the last expression in a block is dropped after all local bindings.\n+    let check_ty = if has_else\n+        || (keyword == \"if\" && matches!(cx.tcx.hir().parent_iter(expr.hir_id).next(), Some((_, Node::Block(..)))))\n+    {\n+        op_ty\n+    } else {\n+        inner_ty\n+    };\n+\n+    // All temporaries created in the scrutinee expression are dropped at the same time as the\n+    // scrutinee would be, so they have to be considered as well.\n+    // e.g. in `if let Some(x) = foo.lock().unwrap().baz.as_ref() { .. }` the lock will be held\n+    // for the duration if body.\n+    let needs_drop = type_needs_ordered_drop(cx, check_ty) || temporaries_need_ordered_drop(cx, let_expr);\n+\n+    // check that `while_let_on_iterator` lint does not trigger\n+    if_chain! {\n+        if keyword == \"while\";\n+        if let ExprKind::MethodCall(method_path, _, _) = let_expr.kind;\n+        if method_path.ident.name == sym::next;\n+        if is_trait_method(cx, let_expr, sym::Iterator);\n+        then {\n+            return;\n+        }\n+    }\n+\n+    let result_expr = match &let_expr.kind {\n+        ExprKind::AddrOf(_, _, borrowed) => borrowed,\n+        ExprKind::Unary(UnOp::Deref, deref) => deref,\n+        _ => let_expr,\n+    };\n+\n+    span_lint_and_then(\n+        cx,\n+        REDUNDANT_PATTERN_MATCHING,\n+        let_pat.span,\n+        &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n+        |diag| {\n+            // if/while let ... = ... { ... }\n+            // ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+            let expr_span = expr.span;\n+\n+            // if/while let ... = ... { ... }\n+            //                 ^^^\n+            let op_span = result_expr.span.source_callsite();\n+\n+            // if/while let ... = ... { ... }\n+            // ^^^^^^^^^^^^^^^^^^^\n+            let span = expr_span.until(op_span.shrink_to_hi());\n+\n+            let app = if needs_drop {\n+                Applicability::MaybeIncorrect\n+            } else {\n+                Applicability::MachineApplicable\n+            };\n+\n+            let sugg = Sugg::hir_with_macro_callsite(cx, result_expr, \"_\")\n+                .maybe_par()\n+                .to_string();\n+\n+            diag.span_suggestion(span, \"try this\", format!(\"{} {}.{}\", keyword, sugg, good_method), app);\n+\n+            if needs_drop {\n+                diag.note(\"this will change drop order of the result, as well as all temporaries\");\n+                diag.note(\"add `#[allow(clippy::redundant_pattern_matching)]` if this is important\");\n+            }\n+        },\n+    );\n+}\n+\n+fn find_sugg_for_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op: &Expr<'_>, arms: &[Arm<'_>]) {\n+    if arms.len() == 2 {\n+        let node_pair = (&arms[0].pat.kind, &arms[1].pat.kind);\n+\n+        let found_good_method = match node_pair {\n+            (\n+                PatKind::TupleStruct(ref path_left, patterns_left, _),\n+                PatKind::TupleStruct(ref path_right, patterns_right, _),\n+            ) if patterns_left.len() == 1 && patterns_right.len() == 1 => {\n+                if let (PatKind::Wild, PatKind::Wild) = (&patterns_left[0].kind, &patterns_right[0].kind) {\n+                    find_good_method_for_match(\n+                        cx,\n+                        arms,\n+                        path_left,\n+                        path_right,\n+                        &paths::RESULT_OK,\n+                        &paths::RESULT_ERR,\n+                        \"is_ok()\",\n+                        \"is_err()\",\n+                    )\n+                    .or_else(|| {\n+                        find_good_method_for_match(\n+                            cx,\n+                            arms,\n+                            path_left,\n+                            path_right,\n+                            &paths::IPADDR_V4,\n+                            &paths::IPADDR_V6,\n+                            \"is_ipv4()\",\n+                            \"is_ipv6()\",\n+                        )\n+                    })\n+                } else {\n+                    None\n+                }\n+            },\n+            (PatKind::TupleStruct(ref path_left, patterns, _), PatKind::Path(ref path_right))\n+            | (PatKind::Path(ref path_left), PatKind::TupleStruct(ref path_right, patterns, _))\n+                if patterns.len() == 1 =>\n+            {\n+                if let PatKind::Wild = patterns[0].kind {\n+                    find_good_method_for_match(\n+                        cx,\n+                        arms,\n+                        path_left,\n+                        path_right,\n+                        &paths::OPTION_SOME,\n+                        &paths::OPTION_NONE,\n+                        \"is_some()\",\n+                        \"is_none()\",\n+                    )\n+                    .or_else(|| {\n+                        find_good_method_for_match(\n+                            cx,\n+                            arms,\n+                            path_left,\n+                            path_right,\n+                            &paths::POLL_READY,\n+                            &paths::POLL_PENDING,\n+                            \"is_ready()\",\n+                            \"is_pending()\",\n+                        )\n+                    })\n+                } else {\n+                    None\n+                }\n+            },\n+            _ => None,\n+        };\n+\n+        if let Some(good_method) = found_good_method {\n+            let span = expr.span.to(op.span);\n+            let result_expr = match &op.kind {\n+                ExprKind::AddrOf(_, _, borrowed) => borrowed,\n+                _ => op,\n+            };\n+            span_lint_and_then(\n+                cx,\n+                REDUNDANT_PATTERN_MATCHING,\n+                expr.span,\n+                &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n+                |diag| {\n+                    diag.span_suggestion(\n+                        span,\n+                        \"try this\",\n+                        format!(\"{}.{}\", snippet(cx, result_expr.span, \"_\"), good_method),\n+                        Applicability::MaybeIncorrect, // snippet\n+                    );\n+                },\n+            );\n+        }\n+    }\n+}\n+\n+#[allow(clippy::too_many_arguments)]\n+fn find_good_method_for_match<'a>(\n+    cx: &LateContext<'_>,\n+    arms: &[Arm<'_>],\n+    path_left: &QPath<'_>,\n+    path_right: &QPath<'_>,\n+    expected_left: &[&str],\n+    expected_right: &[&str],\n+    should_be_left: &'a str,\n+    should_be_right: &'a str,\n+) -> Option<&'a str> {\n+    let left_id = cx\n+        .typeck_results()\n+        .qpath_res(path_left, arms[0].pat.hir_id)\n+        .opt_def_id()?;\n+    let right_id = cx\n+        .typeck_results()\n+        .qpath_res(path_right, arms[1].pat.hir_id)\n+        .opt_def_id()?;\n+    let body_node_pair = if match_def_path(cx, left_id, expected_left) && match_def_path(cx, right_id, expected_right) {\n+        (&(*arms[0].body).kind, &(*arms[1].body).kind)\n+    } else if match_def_path(cx, right_id, expected_left) && match_def_path(cx, right_id, expected_right) {\n+        (&(*arms[1].body).kind, &(*arms[0].body).kind)\n+    } else {\n+        return None;\n+    };\n+\n+    match body_node_pair {\n+        (ExprKind::Lit(ref lit_left), ExprKind::Lit(ref lit_right)) => match (&lit_left.node, &lit_right.node) {\n+            (LitKind::Bool(true), LitKind::Bool(false)) => Some(should_be_left),\n+            (LitKind::Bool(false), LitKind::Bool(true)) => Some(should_be_right),\n+            _ => None,\n+        },\n+        _ => None,\n+    }\n+}"}, {"sha": "5076239a57c4d79f707b8aa0655d698ba126faf7", "filename": "clippy_lints/src/matches/rest_pat_in_fully_bound_struct.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Frest_pat_in_fully_bound_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Frest_pat_in_fully_bound_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Frest_pat_in_fully_bound_struct.rs?ref=2590701b2ac9004418c5ec49896f2cf2c5016df5", "patch": "@@ -0,0 +1,29 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use rustc_hir::{Pat, PatKind, QPath};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+\n+use super::REST_PAT_IN_FULLY_BOUND_STRUCTS;\n+\n+pub(crate) fn check(cx: &LateContext<'_>, pat: &Pat<'_>) {\n+    if_chain! {\n+        if !pat.span.from_expansion();\n+        if let PatKind::Struct(QPath::Resolved(_, path), fields, true) = pat.kind;\n+        if let Some(def_id) = path.res.opt_def_id();\n+        let ty = cx.tcx.type_of(def_id);\n+        if let ty::Adt(def, _) = ty.kind();\n+        if def.is_struct() || def.is_union();\n+        if fields.len() == def.non_enum_variant().fields.len();\n+\n+        then {\n+            span_lint_and_help(\n+                cx,\n+                REST_PAT_IN_FULLY_BOUND_STRUCTS,\n+                pat.span,\n+                \"unnecessary use of `..` pattern in struct binding. All fields were already bound\",\n+                None,\n+                \"consider removing `..` from this binding\",\n+            );\n+        }\n+    }\n+}"}, {"sha": "6ba279eaf122433885b17e8dcf592dd88876bf09", "filename": "clippy_lints/src/matches/single_match.rs", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs?ref=2590701b2ac9004418c5ec49896f2cf2c5016df5", "patch": "@@ -0,0 +1,269 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::{expr_block, snippet};\n+use clippy_utils::ty::{implements_trait, match_type, peel_mid_ty_refs};\n+use clippy_utils::{\n+    is_lint_allowed, is_unit_expr, is_wild, paths, peel_blocks, peel_hir_pat_refs, peel_n_hir_expr_refs,\n+};\n+use core::cmp::max;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, Pat, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty, TyS};\n+\n+use super::{MATCH_BOOL, SINGLE_MATCH, SINGLE_MATCH_ELSE};\n+\n+#[rustfmt::skip]\n+pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n+    if arms.len() == 2 && arms[0].guard.is_none() && arms[1].guard.is_none() {\n+        if expr.span.from_expansion() {\n+            // Don't lint match expressions present in\n+            // macro_rules! block\n+            return;\n+        }\n+        if let PatKind::Or(..) = arms[0].pat.kind {\n+            // don't lint for or patterns for now, this makes\n+            // the lint noisy in unnecessary situations\n+            return;\n+        }\n+        let els = arms[1].body;\n+        let els = if is_unit_expr(peel_blocks(els)) {\n+            None\n+        } else if let ExprKind::Block(Block { stmts, expr: block_expr, .. }, _) = els.kind {\n+            if stmts.len() == 1 && block_expr.is_none() || stmts.is_empty() && block_expr.is_some() {\n+                // single statement/expr \"else\" block, don't lint\n+                return;\n+            }\n+            // block with 2+ statements or 1 expr and 1+ statement\n+            Some(els)\n+        } else {\n+            // not a block, don't lint\n+            return;\n+        };\n+\n+        let ty = cx.typeck_results().expr_ty(ex);\n+        if *ty.kind() != ty::Bool || is_lint_allowed(cx, MATCH_BOOL, ex.hir_id) {\n+            check_single_pattern(cx, ex, arms, expr, els);\n+            check_opt_like(cx, ex, arms, expr, ty, els);\n+        }\n+    }\n+}\n+\n+fn check_single_pattern(\n+    cx: &LateContext<'_>,\n+    ex: &Expr<'_>,\n+    arms: &[Arm<'_>],\n+    expr: &Expr<'_>,\n+    els: Option<&Expr<'_>>,\n+) {\n+    if is_wild(arms[1].pat) {\n+        report_single_pattern(cx, ex, arms, expr, els);\n+    }\n+}\n+\n+fn report_single_pattern(\n+    cx: &LateContext<'_>,\n+    ex: &Expr<'_>,\n+    arms: &[Arm<'_>],\n+    expr: &Expr<'_>,\n+    els: Option<&Expr<'_>>,\n+) {\n+    let lint = if els.is_some() { SINGLE_MATCH_ELSE } else { SINGLE_MATCH };\n+    let els_str = els.map_or(String::new(), |els| {\n+        format!(\" else {}\", expr_block(cx, els, None, \"..\", Some(expr.span)))\n+    });\n+\n+    let (pat, pat_ref_count) = peel_hir_pat_refs(arms[0].pat);\n+    let (msg, sugg) = if_chain! {\n+        if let PatKind::Path(_) | PatKind::Lit(_) = pat.kind;\n+        let (ty, ty_ref_count) = peel_mid_ty_refs(cx.typeck_results().expr_ty(ex));\n+        if let Some(spe_trait_id) = cx.tcx.lang_items().structural_peq_trait();\n+        if let Some(pe_trait_id) = cx.tcx.lang_items().eq_trait();\n+        if ty.is_integral() || ty.is_char() || ty.is_str()\n+            || (implements_trait(cx, ty, spe_trait_id, &[])\n+                && implements_trait(cx, ty, pe_trait_id, &[ty.into()]));\n+        then {\n+            // scrutinee derives PartialEq and the pattern is a constant.\n+            let pat_ref_count = match pat.kind {\n+                // string literals are already a reference.\n+                PatKind::Lit(Expr { kind: ExprKind::Lit(lit), .. }) if lit.node.is_str() => pat_ref_count + 1,\n+                _ => pat_ref_count,\n+            };\n+            // References are only implicitly added to the pattern, so no overflow here.\n+            // e.g. will work: match &Some(_) { Some(_) => () }\n+            // will not: match Some(_) { &Some(_) => () }\n+            let ref_count_diff = ty_ref_count - pat_ref_count;\n+\n+            // Try to remove address of expressions first.\n+            let (ex, removed) = peel_n_hir_expr_refs(ex, ref_count_diff);\n+            let ref_count_diff = ref_count_diff - removed;\n+\n+            let msg = \"you seem to be trying to use `match` for an equality check. Consider using `if`\";\n+            let sugg = format!(\n+                \"if {} == {}{} {}{}\",\n+                snippet(cx, ex.span, \"..\"),\n+                // PartialEq for different reference counts may not exist.\n+                \"&\".repeat(ref_count_diff),\n+                snippet(cx, arms[0].pat.span, \"..\"),\n+                expr_block(cx, arms[0].body, None, \"..\", Some(expr.span)),\n+                els_str,\n+            );\n+            (msg, sugg)\n+        } else {\n+            let msg = \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\";\n+            let sugg = format!(\n+                \"if let {} = {} {}{}\",\n+                snippet(cx, arms[0].pat.span, \"..\"),\n+                snippet(cx, ex.span, \"..\"),\n+                expr_block(cx, arms[0].body, None, \"..\", Some(expr.span)),\n+                els_str,\n+            );\n+            (msg, sugg)\n+        }\n+    };\n+\n+    span_lint_and_sugg(\n+        cx,\n+        lint,\n+        expr.span,\n+        msg,\n+        \"try this\",\n+        sugg,\n+        Applicability::HasPlaceholders,\n+    );\n+}\n+\n+fn check_opt_like<'a>(\n+    cx: &LateContext<'a>,\n+    ex: &Expr<'_>,\n+    arms: &[Arm<'_>],\n+    expr: &Expr<'_>,\n+    ty: Ty<'a>,\n+    els: Option<&Expr<'_>>,\n+) {\n+    // list of candidate `Enum`s we know will never get any more members\n+    let candidates = &[\n+        (&paths::COW, \"Borrowed\"),\n+        (&paths::COW, \"Cow::Borrowed\"),\n+        (&paths::COW, \"Cow::Owned\"),\n+        (&paths::COW, \"Owned\"),\n+        (&paths::OPTION, \"None\"),\n+        (&paths::RESULT, \"Err\"),\n+        (&paths::RESULT, \"Ok\"),\n+    ];\n+\n+    // We want to suggest to exclude an arm that contains only wildcards or forms the exhaustive\n+    // match with the second branch, without enum variants in matches.\n+    if !contains_only_wilds(arms[1].pat) && !form_exhaustive_matches(arms[0].pat, arms[1].pat) {\n+        return;\n+    }\n+\n+    let mut paths_and_types = Vec::new();\n+    if !collect_pat_paths(&mut paths_and_types, cx, arms[1].pat, ty) {\n+        return;\n+    }\n+\n+    let in_candidate_enum = |path_info: &(String, &TyS<'_>)| -> bool {\n+        let (path, ty) = path_info;\n+        for &(ty_path, pat_path) in candidates {\n+            if path == pat_path && match_type(cx, ty, ty_path) {\n+                return true;\n+            }\n+        }\n+        false\n+    };\n+    if paths_and_types.iter().all(in_candidate_enum) {\n+        report_single_pattern(cx, ex, arms, expr, els);\n+    }\n+}\n+\n+/// Collects paths and their types from the given patterns. Returns true if the given pattern could\n+/// be simplified, false otherwise.\n+fn collect_pat_paths<'a>(acc: &mut Vec<(String, Ty<'a>)>, cx: &LateContext<'a>, pat: &Pat<'_>, ty: Ty<'a>) -> bool {\n+    match pat.kind {\n+        PatKind::Wild => true,\n+        PatKind::Tuple(inner, _) => inner.iter().all(|p| {\n+            let p_ty = cx.typeck_results().pat_ty(p);\n+            collect_pat_paths(acc, cx, p, p_ty)\n+        }),\n+        PatKind::TupleStruct(ref path, ..) => {\n+            let path = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n+                s.print_qpath(path, false);\n+            });\n+            acc.push((path, ty));\n+            true\n+        },\n+        PatKind::Binding(BindingAnnotation::Unannotated, .., ident, None) => {\n+            acc.push((ident.to_string(), ty));\n+            true\n+        },\n+        PatKind::Path(ref path) => {\n+            let path = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n+                s.print_qpath(path, false);\n+            });\n+            acc.push((path, ty));\n+            true\n+        },\n+        _ => false,\n+    }\n+}\n+\n+/// Returns true if the given arm of pattern matching contains wildcard patterns.\n+fn contains_only_wilds(pat: &Pat<'_>) -> bool {\n+    match pat.kind {\n+        PatKind::Wild => true,\n+        PatKind::Tuple(inner, _) | PatKind::TupleStruct(_, inner, ..) => inner.iter().all(contains_only_wilds),\n+        _ => false,\n+    }\n+}\n+\n+/// Returns true if the given patterns forms only exhaustive matches that don't contain enum\n+/// patterns without a wildcard.\n+fn form_exhaustive_matches(left: &Pat<'_>, right: &Pat<'_>) -> bool {\n+    match (&left.kind, &right.kind) {\n+        (PatKind::Wild, _) | (_, PatKind::Wild) => true,\n+        (PatKind::Tuple(left_in, left_pos), PatKind::Tuple(right_in, right_pos)) => {\n+            // We don't actually know the position and the presence of the `..` (dotdot) operator\n+            // in the arms, so we need to evaluate the correct offsets here in order to iterate in\n+            // both arms at the same time.\n+            let len = max(\n+                left_in.len() + {\n+                    if left_pos.is_some() { 1 } else { 0 }\n+                },\n+                right_in.len() + {\n+                    if right_pos.is_some() { 1 } else { 0 }\n+                },\n+            );\n+            let mut left_pos = left_pos.unwrap_or(usize::MAX);\n+            let mut right_pos = right_pos.unwrap_or(usize::MAX);\n+            let mut left_dot_space = 0;\n+            let mut right_dot_space = 0;\n+            for i in 0..len {\n+                let mut found_dotdot = false;\n+                if i == left_pos {\n+                    left_dot_space += 1;\n+                    if left_dot_space < len - left_in.len() {\n+                        left_pos += 1;\n+                    }\n+                    found_dotdot = true;\n+                }\n+                if i == right_pos {\n+                    right_dot_space += 1;\n+                    if right_dot_space < len - right_in.len() {\n+                        right_pos += 1;\n+                    }\n+                    found_dotdot = true;\n+                }\n+                if found_dotdot {\n+                    continue;\n+                }\n+                if !contains_only_wilds(&left_in[i - left_dot_space])\n+                    && !contains_only_wilds(&right_in[i - right_dot_space])\n+                {\n+                    return false;\n+                }\n+            }\n+            true\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "459513e65bfad1b1aeb7e503a06e9c6949c6f0c3", "filename": "clippy_lints/src/matches/wild_in_or_pats.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Fwild_in_or_pats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2590701b2ac9004418c5ec49896f2cf2c5016df5/clippy_lints%2Fsrc%2Fmatches%2Fwild_in_or_pats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fwild_in_or_pats.rs?ref=2590701b2ac9004418c5ec49896f2cf2c5016df5", "patch": "@@ -0,0 +1,24 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::is_wild;\n+use rustc_hir::{Arm, PatKind};\n+use rustc_lint::LateContext;\n+\n+use super::WILDCARD_IN_OR_PATTERNS;\n+\n+pub(crate) fn check(cx: &LateContext<'_>, arms: &[Arm<'_>]) {\n+    for arm in arms {\n+        if let PatKind::Or(fields) = arm.pat.kind {\n+            // look for multiple fields in this arm that contains at least one Wild pattern\n+            if fields.len() > 1 && fields.iter().any(is_wild) {\n+                span_lint_and_help(\n+                    cx,\n+                    WILDCARD_IN_OR_PATTERNS,\n+                    arm.pat.span,\n+                    \"wildcard pattern covers any other pattern as it will match anyway\",\n+                    None,\n+                    \"consider handling `_` separately\",\n+                );\n+            }\n+        }\n+    }\n+}"}]}