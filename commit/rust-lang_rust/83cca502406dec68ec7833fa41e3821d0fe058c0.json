{"sha": "83cca502406dec68ec7833fa41e3821d0fe058c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzY2NhNTAyNDA2ZGVjNjhlYzc4MzNmYTQxZTM4MjFkMGZlMDU4YzA=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-05-02T23:22:44Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-23T05:29:16Z"}, "message": "std: change tcp_*_result to use result::result.. flatter!", "tree": {"sha": "67501fb778819e0b22f72ada68e33186903e761e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67501fb778819e0b22f72ada68e33186903e761e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83cca502406dec68ec7833fa41e3821d0fe058c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83cca502406dec68ec7833fa41e3821d0fe058c0", "html_url": "https://github.com/rust-lang/rust/commit/83cca502406dec68ec7833fa41e3821d0fe058c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83cca502406dec68ec7833fa41e3821d0fe058c0/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "082a95a0777d03fd7469b8df691e9caa8217f8ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/082a95a0777d03fd7469b8df691e9caa8217f8ac", "html_url": "https://github.com/rust-lang/rust/commit/082a95a0777d03fd7469b8df691e9caa8217f8ac"}], "stats": {"total": 288, "additions": 168, "deletions": 120}, "files": [{"sha": "379c6d1936c85ede2d63195285e6e9392b53ee00", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 168, "deletions": 120, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/83cca502406dec68ec7833fa41e3821d0fe058c0/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83cca502406dec68ec7833fa41e3821d0fe058c0/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=83cca502406dec68ec7833fa41e3821d0fe058c0", "patch": "@@ -4,9 +4,12 @@ High-level interface to libuv's TCP functionality\n \n import ip = net_ip;\n \n-export tcp_err_data, tcp_connect_result, tcp_write_result, tcp_read_start_result;\n-export connect, write;\n+export tcp_socket, tcp_err_data;\n+export connect, write, read_start, read_stop;\n \n+#[doc=\"\n+Encapsulates an open TCP/IP connection through libuv\n+\"]\n resource tcp_socket(socket_data: @tcp_socket_data) unsafe {\n     let closed_po = comm::port::<()>();\n     let closed_ch = comm::chan(closed_po);\n@@ -26,42 +29,14 @@ resource tcp_socket(socket_data: @tcp_socket_data) unsafe {\n     log(debug, \"exiting dtor for tcp_socket\");\n }\n \n+#[doc=\"\n+Contains raw, string-based, error information returned from libuv\n+\"]\n type tcp_err_data = {\n     err_name: str,\n     err_msg: str\n };\n \n-iface to_tcp_err_iface {\n-    fn to_tcp_err() -> tcp_err_data;\n-}\n-\n-impl of to_tcp_err_iface for uv::ll::uv_err_data {\n-    fn to_tcp_err() -> tcp_err_data {\n-        { err_name: self.err_name, err_msg: self.err_msg }\n-    }\n-}\n-\n-enum tcp_connect_result {\n-    tcp_connected(tcp_socket),\n-    tcp_connect_error(tcp_err_data)\n-}\n-\n-enum tcp_write_result {\n-    tcp_write_success,\n-    tcp_write_error(tcp_err_data)\n-}\n-\n-enum tcp_read_start_result {\n-    tcp_read_start_success(comm::port<tcp_read_result>),\n-    tcp_read_start_error(tcp_err_data)\n-}\n-\n-enum tcp_read_result {\n-    tcp_read_data([u8]),\n-    tcp_read_done,\n-    tcp_read_err(tcp_err_data)\n-}\n-\n #[doc=\"\n Initiate a client connection over TCP/IP\n \n@@ -72,10 +47,12 @@ Initiate a client connection over TCP/IP\n \n # Returns\n \n-A `tcp_connect_result` that can be used to determine the connection and,\n-if successful, send and receive data to/from the remote host\n+A `result` that, if the operation succeeds, contains a `tcp_socket` that\n+can be used to send and receive data to/from the remote host. In the event\n+of failure, a `tcp_err_data` will be returned\n \"]\n-fn connect(input_ip: ip::ip_addr, port: uint) -> tcp_connect_result unsafe {\n+fn connect(input_ip: ip::ip_addr, port: uint)\n+    -> result::result<tcp_socket, tcp_err_data> unsafe {\n     let result_po = comm::port::<conn_attempt>();\n     let closed_signal_po = comm::port::<()>();\n     let conn_data = {\n@@ -84,7 +61,7 @@ fn connect(input_ip: ip::ip_addr, port: uint) -> tcp_connect_result unsafe {\n     };\n     let conn_data_ptr = ptr::addr_of(conn_data);\n     let hl_loop = uv::global_loop::get();\n-    let reader_po = comm::port::<tcp_read_result>();\n+    let reader_po = comm::port::<result::result<[u8], tcp_err_data>>();\n     let socket_data = @{\n         reader_po: reader_po,\n         reader_ch: comm::chan(reader_po),\n@@ -161,21 +138,32 @@ fn connect(input_ip: ip::ip_addr, port: uint) -> tcp_connect_result unsafe {\n     alt comm::recv(result_po) {\n       conn_success {\n         log(debug, \"tcp::connect - received success on result_po\");\n-        tcp_connected(tcp_socket(socket_data))\n+        result::ok(tcp_socket(socket_data))\n       }\n       conn_failure(err_data) {\n         comm::recv(closed_signal_po);\n         log(debug, \"tcp::connect - received failure on result_po\");\n-        tcp_connect_error(err_data.to_tcp_err())\n+        result::err(err_data.to_tcp_err())\n       }\n     }\n }\n \n #[doc=\"\n Write binary data to a tcp stream\n+\n+# Arguments\n+\n+* sock - a `tcp_socket` to write to\n+* raw_write_data - a vector of `[u8]` that will be written to the stream.\n+This value must remain valid for the duration of the `write` call\n+\n+# Returns\n+\n+A `result` object with a `()` value, in the event of success, or a\n+`tcp_err_data` value in the event of failure\n \"]\n-fn write(sock: tcp_socket, raw_write_data: [[u8]]) -> tcp_write_result\n-    unsafe {\n+fn write(sock: tcp_socket, raw_write_data: [[u8]])\n+    -> result::result<(), tcp_err_data> unsafe {\n     let socket_data_ptr = ptr::addr_of(**sock);\n     let write_req_ptr = ptr::addr_of((*socket_data_ptr).write_req);\n     let stream_handle_ptr =\n@@ -208,12 +196,28 @@ fn write(sock: tcp_socket, raw_write_data: [[u8]]) -> tcp_write_result\n           }\n         }\n     };\n-    comm::recv(result_po)\n+    alt comm::recv(result_po) {\n+      tcp_write_success { result::ok(()) }\n+      tcp_write_error(err_data) { result::err(err_data.to_tcp_err()) }\n+    }\n }\n \n #[doc=\"\n+Begin reading binary data from an open TCP connection.\n+\n+# Arguments\n+\n+* sock -- a `tcp_socket` for the connection to read from\n+\n+# Returns\n+\n+* A `result` instance that will either contain a\n+`comm::port<tcp_read_result>` that the user can read (and optionally, loop\n+on) from until `read_stop` is called, or a `tcp_err_data` record\n \"]\n-fn read_start(sock: tcp_socket) -> tcp_read_start_result unsafe {\n+fn read_start(sock: tcp_socket)\n+    -> result::result<comm::port<\n+        result::result<[u8], tcp_err_data>>, tcp_err_data> unsafe {\n     let stream_handle_ptr = ptr::addr_of((**sock).stream_handle);\n     let start_po = comm::port::<option<uv::ll::uv_err_data>>();\n     let start_ch = comm::chan(start_po);\n@@ -235,15 +239,19 @@ fn read_start(sock: tcp_socket) -> tcp_read_start_result unsafe {\n     };\n     alt comm::recv(start_po) {\n       some(err_data) {\n-        tcp_read_start_error(err_data.to_tcp_err())\n+        result::err(err_data.to_tcp_err())\n       }\n       none {\n-        tcp_read_start_success((**sock).reader_po)\n+        result::ok((**sock).reader_po)\n       }\n     }\n }\n \n-fn read_stop(sock: tcp_socket) -> option<uv::ll::uv_err_data> unsafe {\n+#[doc=\"\n+Stop reading from an open TCP connection.\n+\"]\n+fn read_stop(sock: tcp_socket) ->\n+    result::result<(), tcp_err_data> unsafe {\n     let stream_handle_ptr = ptr::addr_of((**sock).stream_handle);\n     let stop_po = comm::port::<option<tcp_err_data>>();\n     let stop_ch = comm::chan(stop_po);\n@@ -261,10 +269,49 @@ fn read_stop(sock: tcp_socket) -> option<uv::ll::uv_err_data> unsafe {\n           }\n         }\n     };\n-    comm::recv(stop_po)\n+    alt comm::recv(stop_po) {\n+      some(err_data) {\n+        result::err(err_data.to_tcp_err())\n+      }\n+      none {\n+        result::ok(())\n+      }\n+    }\n }\n \n // INTERNAL API\n+\n+enum tcp_connect_result {\n+    tcp_connected(tcp_socket),\n+    tcp_connect_error(tcp_err_data)\n+}\n+\n+enum tcp_write_result {\n+    tcp_write_success,\n+    tcp_write_error(tcp_err_data)\n+}\n+\n+enum tcp_read_start_result {\n+    tcp_read_start_success(comm::port<tcp_read_result>),\n+    tcp_read_start_error(tcp_err_data)\n+}\n+\n+enum tcp_read_result {\n+    tcp_read_data([u8]),\n+    tcp_read_done,\n+    tcp_read_err(tcp_err_data)\n+}\n+\n+iface to_tcp_err_iface {\n+    fn to_tcp_err() -> tcp_err_data;\n+}\n+\n+impl of to_tcp_err_iface for uv::ll::uv_err_data {\n+    fn to_tcp_err() -> tcp_err_data {\n+        { err_name: self.err_name, err_msg: self.err_msg }\n+    }\n+}\n+\n crust fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n                     nread: libc::ssize_t,\n                     ++buf: uv::ll::uv_buf_t) unsafe {\n@@ -276,7 +323,7 @@ crust fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n       // incoming err.. probably eof\n       -1 {\n         let err_data = uv::ll::get_last_err_data(loop_ptr);\n-        comm::send(reader_ch, tcp_read_err(err_data));\n+        comm::send(reader_ch, result::err(err_data.to_tcp_err()));\n       }\n       // do nothing .. unneeded buf\n       0 {}\n@@ -287,7 +334,7 @@ crust fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n         let buf_base = uv::ll::get_base_from_buf(buf);\n         let buf_len = uv::ll::get_len_from_buf(buf);\n         let new_bytes = vec::unsafe::from_buf(buf_base, buf_len);\n-        comm::send(reader_ch, tcp_read_data(new_bytes));\n+        comm::send(reader_ch, result::ok(new_bytes));\n       }\n     }\n     uv::ll::free_base_of_buf(buf);\n@@ -391,8 +438,8 @@ enum conn_attempt {\n }\n \n type tcp_socket_data = {\n-    reader_po: comm::port<tcp_read_result>,\n-    reader_ch: comm::chan<tcp_read_result>,\n+    reader_po: comm::port<result::result<[u8], tcp_err_data>>,\n+    reader_ch: comm::chan<result::result<[u8], tcp_err_data>>,\n     stream_handle: uv::ll::uv_tcp_t,\n     connect_req: uv::ll::uv_connect_t,\n     write_req: uv::ll::uv_write_t,\n@@ -405,10 +452,14 @@ fn ipv4_ip_addr_to_sockaddr_in(input: ip::ip_addr,\n     uv::ll::ip4_addr(ip::format_addr(input), port as int)\n }\n \n-#[cfg(test)]\n+//#[cfg(test)]\n mod test {\n     #[test]\n     fn test_gl_tcp_ipv4_request() {\n+        impl_gl_tcp_ipv4_request();\n+    }\n+    fn impl_gl_tcp_ipv4_request() {\n+        // pre-connection/input data\n         let ip_str = \"173.194.79.99\";\n         let port = 80u;\n         let expected_read_msg = \"foo\";\n@@ -417,80 +468,77 @@ mod test {\n \n         let data_po = comm::port::<[u8]>();\n         let data_ch = comm::chan(data_po);\n-        \n-        alt connect(host_ip, port) {\n-          tcp_connected(sock) {\n-            log(debug, \"successful tcp connect\");\n-            let mut write_data: [[u8]] = [];\n-            let write_data = [str::as_bytes(actual_write_msg) {|str_bytes|\n-                str_bytes\n-            }];\n-            alt write(sock, write_data) {\n-              tcp_write_success {\n-                log(debug, \"tcp::write successful\");\n-                let mut total_read_data: [u8] = [];\n-                alt read_start(sock) {\n-                  tcp_read_start_success(reader_po) {\n-                    loop {\n-                        alt comm::recv(reader_po) {\n-                          tcp_read_data(new_data) {\n-                            total_read_data += new_data;\n-                            // theoretically, we could keep iterating, if\n-                            // we expect the server on the other end to keep\n-                            // streaming/chunking data to us, but..\n-                            alt read_stop(sock) {\n-                              some(err_data) {\n-                                log(debug, \"error while calling read_stop\");\n-                                log(debug, #fmt(\"read_stop error: %? %?\",\n-                                                err_data.err_name,\n-                                                err_data.err_msg));\n-                                assert false;\n-                              }\n-                              none {\n-                                // exiting the read loop\n-                                break;\n-                              }\n-                            }\n-                          }\n-                          tcp_read_done {\n-                            break;\n-                          }\n-                          tcp_read_err(err_data) {\n-                            log(debug, \"read error data recv'd\");\n-                            log(debug, #fmt(\"read error: %? %?\",\n-                                            err_data.err_name,\n-                                            err_data.err_msg));\n-                            assert false;\n-                          }\n-                        }\n-                    }\n-                    comm::send(data_ch, total_read_data);\n-                  }\n-                  tcp_read_start_error(err_data) {\n-                    log(debug, \"tcp_read_start_error received..\");\n-                    log(debug, #fmt(\"tcp read_start error: %? %?\",\n-                                    err_data.err_name,\n-                                   err_data.err_msg));\n-                    assert false;\n-                  }\n-                }\n-              }\n-              tcp_write_error(err_data) {\n-                log(debug, \"tcp_write_error received..\");\n-                log(debug, #fmt(\"tcp write error: %? %?\", err_data.err_name,\n-                               err_data.err_msg));\n-                assert false;\n-              }\n-            }\n-          }\n-          tcp_connect_error(err_data) {\n+\n+        // connect to remote host\n+        let connect_result = connect(host_ip, port);\n+        if result::is_failure(connect_result) {\n+            let err_data = result::get_err(connect_result);\n             log(debug, \"tcp_connect_error received..\");\n             log(debug, #fmt(\"tcp connect error: %? %?\", err_data.err_name,\n                            err_data.err_msg));\n             assert false;\n-          }\n         }\n \n+        // this is our tcp_socket resource instance. It's dtor will\n+        // clean-up/close the underlying TCP stream when the fn scope\n+        // ends\n+        let sock = result::unwrap(connect_result);\n+        log(debug, \"successful tcp connect\");\n+\n+        // set up write data\n+        let write_data = [str::as_bytes(actual_write_msg) {|str_bytes|\n+            str_bytes\n+        }];\n+\n+        // write data to tcp socket\n+        let write_result = write(sock, write_data);\n+        if result::is_failure(write_result) {\n+            let err_data = result::get_err(write_result);\n+            log(debug, \"tcp_write_error received..\");\n+            log(debug, #fmt(\"tcp write error: %? %?\", err_data.err_name,\n+                           err_data.err_msg));\n+            assert false;\n+        }\n+        log(debug, \"tcp::write successful\");\n+\n+        // set up read data\n+        let mut total_read_data: [u8] = [];\n+        let read_start_result = read_start(sock);\n+        if result::is_failure(read_start_result) {\n+            let err_data = result::get_err(read_start_result);\n+            log(debug, \"tcp read_start err received..\");\n+            log(debug, #fmt(\"read_start error: %? %?\", err_data.err_name,\n+                           err_data.err_msg));\n+            assert false;\n+        }\n+        let reader_po = result::get(read_start_result);\n+        loop {\n+            let read_data_result = comm::recv(reader_po);\n+            if result::is_failure(read_data_result) {\n+                let err_data = result::get_err(read_data_result);\n+                log(debug, \"read error data recv'd\");\n+                log(debug, #fmt(\"read error: %? %?\",\n+                                err_data.err_name,\n+                                err_data.err_msg));\n+                assert false;\n+            }\n+            let new_data = result::unwrap(read_data_result);\n+            total_read_data += new_data;\n+            // theoretically, we could keep iterating, if\n+            // we expect the server on the other end to keep\n+            // streaming/chunking data to us, but..\n+            let read_stop_result = read_stop(sock);\n+            if result::is_failure(read_stop_result) {\n+                let err_data = result::get_err(read_stop_result);\n+                log(debug, \"error while calling read_stop\");\n+                log(debug, #fmt(\"read_stop error: %? %?\",\n+                                err_data.err_name,\n+                                err_data.err_msg));\n+                assert false;\n+            }\n+            break;\n+        }\n+        comm::send(data_ch, total_read_data);\n         let actual_data = comm::recv(data_po);\n         let resp = str::from_bytes(actual_data);\n         log(debug, \"DATA RECEIVED: \"+resp);"}]}