{"sha": "7c78090690cf78b453cf828babd3dd69eb276779", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjNzgwOTA2OTBjZjc4YjQ1M2NmODI4YmFiZDNkZDY5ZWIyNzY3Nzk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-02T11:33:56Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-11T02:17:36Z"}, "message": "get_features -> rustc_parse::config", "tree": {"sha": "a9c09b7e02fd2a84a3190b48042976e94cf0cd3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9c09b7e02fd2a84a3190b48042976e94cf0cd3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c78090690cf78b453cf828babd3dd69eb276779", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c78090690cf78b453cf828babd3dd69eb276779", "html_url": "https://github.com/rust-lang/rust/commit/7c78090690cf78b453cf828babd3dd69eb276779", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c78090690cf78b453cf828babd3dd69eb276779/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c944e6aac197ef37d4554fcc416dcff7ec4085c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/c944e6aac197ef37d4554fcc416dcff7ec4085c4", "html_url": "https://github.com/rust-lang/rust/commit/c944e6aac197ef37d4554fcc416dcff7ec4085c4"}], "stats": {"total": 360, "additions": 182, "deletions": 178}, "files": [{"sha": "df1e62d04d66d19de4a34ca2aa4e29ccd77c2cef", "filename": "src/librustc_parse/config.rs", "status": "modified", "additions": 177, "deletions": 6, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/7c78090690cf78b453cf828babd3dd69eb276779/src%2Flibrustc_parse%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c78090690cf78b453cf828babd3dd69eb276779/src%2Flibrustc_parse%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fconfig.rs?ref=7c78090690cf78b453cf828babd3dd69eb276779", "patch": "@@ -9,15 +9,20 @@\n //! [#64197]: https://github.com/rust-lang/rust/issues/64197\n \n use crate::{parse_in, validate_attr};\n-use rustc_errors::Applicability;\n-use rustc_feature::Features;\n-use rustc_span::edition::Edition;\n-use rustc_span::symbol::sym;\n-use rustc_span::Span;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_error_codes::*;\n+use rustc_errors::{error_code, struct_span_err, Applicability, Handler};\n+use rustc_feature::{Feature, Features, State as FeatureState};\n+use rustc_feature::{\n+    ACCEPTED_FEATURES, ACTIVE_FEATURES, REMOVED_FEATURES, STABLE_REMOVED_FEATURES,\n+};\n+use rustc_span::edition::{Edition, ALL_EDITIONS};\n+use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::{Span, DUMMY_SP};\n use syntax::ast::{self, AttrItem, Attribute, MetaItem};\n use syntax::attr;\n use syntax::attr::HasAttrs;\n-use syntax::feature_gate::{feature_err, get_features};\n+use syntax::feature_gate::feature_err;\n use syntax::mut_visit::*;\n use syntax::ptr::P;\n use syntax::sess::ParseSess;\n@@ -31,6 +36,172 @@ pub struct StripUnconfigured<'a> {\n     pub features: Option<&'a Features>,\n }\n \n+fn get_features(\n+    span_handler: &Handler,\n+    krate_attrs: &[ast::Attribute],\n+    crate_edition: Edition,\n+    allow_features: &Option<Vec<String>>,\n+) -> Features {\n+    fn feature_removed(span_handler: &Handler, span: Span, reason: Option<&str>) {\n+        let mut err = struct_span_err!(span_handler, span, E0557, \"feature has been removed\");\n+        err.span_label(span, \"feature has been removed\");\n+        if let Some(reason) = reason {\n+            err.note(reason);\n+        }\n+        err.emit();\n+    }\n+\n+    fn active_features_up_to(edition: Edition) -> impl Iterator<Item = &'static Feature> {\n+        ACTIVE_FEATURES.iter().filter(move |feature| {\n+            if let Some(feature_edition) = feature.edition {\n+                feature_edition <= edition\n+            } else {\n+                false\n+            }\n+        })\n+    }\n+\n+    let mut features = Features::default();\n+    let mut edition_enabled_features = FxHashMap::default();\n+\n+    for &edition in ALL_EDITIONS {\n+        if edition <= crate_edition {\n+            // The `crate_edition` implies its respective umbrella feature-gate\n+            // (i.e., `#![feature(rust_20XX_preview)]` isn't needed on edition 20XX).\n+            edition_enabled_features.insert(edition.feature_name(), edition);\n+        }\n+    }\n+\n+    for feature in active_features_up_to(crate_edition) {\n+        feature.set(&mut features, DUMMY_SP);\n+        edition_enabled_features.insert(feature.name, crate_edition);\n+    }\n+\n+    // Process the edition umbrella feature-gates first, to ensure\n+    // `edition_enabled_features` is completed before it's queried.\n+    for attr in krate_attrs {\n+        if !attr.check_name(sym::feature) {\n+            continue;\n+        }\n+\n+        let list = match attr.meta_item_list() {\n+            Some(list) => list,\n+            None => continue,\n+        };\n+\n+        for mi in list {\n+            if !mi.is_word() {\n+                continue;\n+            }\n+\n+            let name = mi.name_or_empty();\n+\n+            let edition = ALL_EDITIONS.iter().find(|e| name == e.feature_name()).copied();\n+            if let Some(edition) = edition {\n+                if edition <= crate_edition {\n+                    continue;\n+                }\n+\n+                for feature in active_features_up_to(edition) {\n+                    // FIXME(Manishearth) there is currently no way to set\n+                    // lib features by edition\n+                    feature.set(&mut features, DUMMY_SP);\n+                    edition_enabled_features.insert(feature.name, edition);\n+                }\n+            }\n+        }\n+    }\n+\n+    for attr in krate_attrs {\n+        if !attr.check_name(sym::feature) {\n+            continue;\n+        }\n+\n+        let list = match attr.meta_item_list() {\n+            Some(list) => list,\n+            None => continue,\n+        };\n+\n+        let bad_input = |span| {\n+            struct_span_err!(span_handler, span, E0556, \"malformed `feature` attribute input\")\n+        };\n+\n+        for mi in list {\n+            let name = match mi.ident() {\n+                Some(ident) if mi.is_word() => ident.name,\n+                Some(ident) => {\n+                    bad_input(mi.span())\n+                        .span_suggestion(\n+                            mi.span(),\n+                            \"expected just one word\",\n+                            format!(\"{}\", ident.name),\n+                            Applicability::MaybeIncorrect,\n+                        )\n+                        .emit();\n+                    continue;\n+                }\n+                None => {\n+                    bad_input(mi.span()).span_label(mi.span(), \"expected just one word\").emit();\n+                    continue;\n+                }\n+            };\n+\n+            if let Some(edition) = edition_enabled_features.get(&name) {\n+                let msg =\n+                    &format!(\"the feature `{}` is included in the Rust {} edition\", name, edition);\n+                span_handler.struct_span_warn_with_code(mi.span(), msg, error_code!(E0705)).emit();\n+                continue;\n+            }\n+\n+            if ALL_EDITIONS.iter().any(|e| name == e.feature_name()) {\n+                // Handled in the separate loop above.\n+                continue;\n+            }\n+\n+            let removed = REMOVED_FEATURES.iter().find(|f| name == f.name);\n+            let stable_removed = STABLE_REMOVED_FEATURES.iter().find(|f| name == f.name);\n+            if let Some(Feature { state, .. }) = removed.or(stable_removed) {\n+                if let FeatureState::Removed { reason } | FeatureState::Stabilized { reason } =\n+                    state\n+                {\n+                    feature_removed(span_handler, mi.span(), *reason);\n+                    continue;\n+                }\n+            }\n+\n+            if let Some(Feature { since, .. }) = ACCEPTED_FEATURES.iter().find(|f| name == f.name) {\n+                let since = Some(Symbol::intern(since));\n+                features.declared_lang_features.push((name, mi.span(), since));\n+                continue;\n+            }\n+\n+            if let Some(allowed) = allow_features.as_ref() {\n+                if allowed.iter().find(|&f| name.as_str() == *f).is_none() {\n+                    struct_span_err!(\n+                        span_handler,\n+                        mi.span(),\n+                        E0725,\n+                        \"the feature `{}` is not in the list of allowed features\",\n+                        name\n+                    )\n+                    .emit();\n+                    continue;\n+                }\n+            }\n+\n+            if let Some(f) = ACTIVE_FEATURES.iter().find(|f| name == f.name) {\n+                f.set(&mut features, mi.span());\n+                features.declared_lang_features.push((name, mi.span(), None));\n+                continue;\n+            }\n+\n+            features.declared_lib_features.push((name, mi.span()));\n+        }\n+    }\n+\n+    features\n+}\n+\n // `cfg_attr`-process the crate's attributes and compute the crate's features.\n pub fn features(\n     mut krate: ast::Crate,"}, {"sha": "46a22f12678eecef8c8a5c16d4a2bd2b4a387182", "filename": "src/libsyntax/feature_gate/check.rs", "status": "modified", "additions": 4, "deletions": 171, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/7c78090690cf78b453cf828babd3dd69eb276779/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c78090690cf78b453cf828babd3dd69eb276779/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs?ref=7c78090690cf78b453cf828babd3dd69eb276779", "patch": "@@ -4,18 +4,13 @@ use crate::attr;\n use crate::sess::{feature_err, leveled_feature_err, GateStrength, ParseSess};\n use crate::visit::{self, FnKind, Visitor};\n \n-use rustc_data_structures::fx::FxHashMap;\n use rustc_error_codes::*;\n-use rustc_errors::{error_code, struct_span_err, Applicability, Handler};\n+use rustc_errors::{struct_span_err, Handler};\n use rustc_feature::{AttributeGate, BUILTIN_ATTRIBUTE_MAP};\n-use rustc_feature::{Feature, Features, GateIssue, State as FeatureState, UnstableFeatures};\n-use rustc_feature::{\n-    ACCEPTED_FEATURES, ACTIVE_FEATURES, REMOVED_FEATURES, STABLE_REMOVED_FEATURES,\n-};\n-use rustc_span::edition::{Edition, ALL_EDITIONS};\n+use rustc_feature::{Features, GateIssue, UnstableFeatures};\n use rustc_span::source_map::Spanned;\n-use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::symbol::sym;\n+use rustc_span::Span;\n \n use log::debug;\n \n@@ -659,168 +654,6 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n }\n \n-pub fn get_features(\n-    span_handler: &Handler,\n-    krate_attrs: &[ast::Attribute],\n-    crate_edition: Edition,\n-    allow_features: &Option<Vec<String>>,\n-) -> Features {\n-    fn feature_removed(span_handler: &Handler, span: Span, reason: Option<&str>) {\n-        let mut err = struct_span_err!(span_handler, span, E0557, \"feature has been removed\");\n-        err.span_label(span, \"feature has been removed\");\n-        if let Some(reason) = reason {\n-            err.note(reason);\n-        }\n-        err.emit();\n-    }\n-\n-    let mut features = Features::default();\n-    let mut edition_enabled_features = FxHashMap::default();\n-\n-    for &edition in ALL_EDITIONS {\n-        if edition <= crate_edition {\n-            // The `crate_edition` implies its respective umbrella feature-gate\n-            // (i.e., `#![feature(rust_20XX_preview)]` isn't needed on edition 20XX).\n-            edition_enabled_features.insert(edition.feature_name(), edition);\n-        }\n-    }\n-\n-    for feature in active_features_up_to(crate_edition) {\n-        feature.set(&mut features, DUMMY_SP);\n-        edition_enabled_features.insert(feature.name, crate_edition);\n-    }\n-\n-    // Process the edition umbrella feature-gates first, to ensure\n-    // `edition_enabled_features` is completed before it's queried.\n-    for attr in krate_attrs {\n-        if !attr.check_name(sym::feature) {\n-            continue;\n-        }\n-\n-        let list = match attr.meta_item_list() {\n-            Some(list) => list,\n-            None => continue,\n-        };\n-\n-        for mi in list {\n-            if !mi.is_word() {\n-                continue;\n-            }\n-\n-            let name = mi.name_or_empty();\n-\n-            let edition = ALL_EDITIONS.iter().find(|e| name == e.feature_name()).copied();\n-            if let Some(edition) = edition {\n-                if edition <= crate_edition {\n-                    continue;\n-                }\n-\n-                for feature in active_features_up_to(edition) {\n-                    // FIXME(Manishearth) there is currently no way to set\n-                    // lib features by edition\n-                    feature.set(&mut features, DUMMY_SP);\n-                    edition_enabled_features.insert(feature.name, edition);\n-                }\n-            }\n-        }\n-    }\n-\n-    for attr in krate_attrs {\n-        if !attr.check_name(sym::feature) {\n-            continue;\n-        }\n-\n-        let list = match attr.meta_item_list() {\n-            Some(list) => list,\n-            None => continue,\n-        };\n-\n-        let bad_input = |span| {\n-            struct_span_err!(span_handler, span, E0556, \"malformed `feature` attribute input\")\n-        };\n-\n-        for mi in list {\n-            let name = match mi.ident() {\n-                Some(ident) if mi.is_word() => ident.name,\n-                Some(ident) => {\n-                    bad_input(mi.span())\n-                        .span_suggestion(\n-                            mi.span(),\n-                            \"expected just one word\",\n-                            format!(\"{}\", ident.name),\n-                            Applicability::MaybeIncorrect,\n-                        )\n-                        .emit();\n-                    continue;\n-                }\n-                None => {\n-                    bad_input(mi.span()).span_label(mi.span(), \"expected just one word\").emit();\n-                    continue;\n-                }\n-            };\n-\n-            if let Some(edition) = edition_enabled_features.get(&name) {\n-                let msg =\n-                    &format!(\"the feature `{}` is included in the Rust {} edition\", name, edition);\n-                span_handler.struct_span_warn_with_code(mi.span(), msg, error_code!(E0705)).emit();\n-                continue;\n-            }\n-\n-            if ALL_EDITIONS.iter().any(|e| name == e.feature_name()) {\n-                // Handled in the separate loop above.\n-                continue;\n-            }\n-\n-            let removed = REMOVED_FEATURES.iter().find(|f| name == f.name);\n-            let stable_removed = STABLE_REMOVED_FEATURES.iter().find(|f| name == f.name);\n-            if let Some(Feature { state, .. }) = removed.or(stable_removed) {\n-                if let FeatureState::Removed { reason } | FeatureState::Stabilized { reason } =\n-                    state\n-                {\n-                    feature_removed(span_handler, mi.span(), *reason);\n-                    continue;\n-                }\n-            }\n-\n-            if let Some(Feature { since, .. }) = ACCEPTED_FEATURES.iter().find(|f| name == f.name) {\n-                let since = Some(Symbol::intern(since));\n-                features.declared_lang_features.push((name, mi.span(), since));\n-                continue;\n-            }\n-\n-            if let Some(allowed) = allow_features.as_ref() {\n-                if allowed.iter().find(|&f| name.as_str() == *f).is_none() {\n-                    struct_span_err!(\n-                        span_handler,\n-                        mi.span(),\n-                        E0725,\n-                        \"the feature `{}` is not in the list of allowed features\",\n-                        name\n-                    )\n-                    .emit();\n-                    continue;\n-                }\n-            }\n-\n-            if let Some(f) = ACTIVE_FEATURES.iter().find(|f| name == f.name) {\n-                f.set(&mut features, mi.span());\n-                features.declared_lang_features.push((name, mi.span(), None));\n-                continue;\n-            }\n-\n-            features.declared_lib_features.push((name, mi.span()));\n-        }\n-    }\n-\n-    features\n-}\n-\n-fn active_features_up_to(edition: Edition) -> impl Iterator<Item = &'static Feature> {\n-    ACTIVE_FEATURES.iter().filter(move |feature| {\n-        if let Some(feature_edition) = feature.edition { feature_edition <= edition } else { false }\n-    })\n-}\n-\n pub fn check_crate(\n     krate: &ast::Crate,\n     parse_sess: &ParseSess,"}, {"sha": "d266bf4bde08d78b84cef0c6a24722a9a24d21bf", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c78090690cf78b453cf828babd3dd69eb276779/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c78090690cf78b453cf828babd3dd69eb276779/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=7c78090690cf78b453cf828babd3dd69eb276779", "patch": "@@ -77,7 +77,7 @@ pub mod entry;\n pub mod expand;\n pub mod feature_gate {\n     mod check;\n-    pub use check::{check_attribute, check_crate, get_features};\n+    pub use check::{check_attribute, check_crate};\n     pub use rustc_session::parse::{feature_err, feature_err_issue};\n }\n pub mod mut_visit;"}]}