{"sha": "ec8ec54192cdc47a22f4fec8b636354e8db0b6a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjOGVjNTQxOTJjZGM0N2EyMmY0ZmVjOGI2MzYzNTRlOGRiMGI2YTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-20T05:01:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-20T05:01:21Z"}, "message": "auto merge of #14289 : TyOverby/rust/master, r=alexcrichton\n\nCloses #14278.\r\n\r\nPreviously the type signatures of the ordering functions in `core::iter::order` took two iterators, but only if they were the same type of iterator.  This commit loosens that restriction and allows different kinds of iterators (but with the same type of elements) to be compared.", "tree": {"sha": "e6cccab07037ee68f9480ba6ec693bd8b13135f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6cccab07037ee68f9480ba6ec693bd8b13135f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec8ec54192cdc47a22f4fec8b636354e8db0b6a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec8ec54192cdc47a22f4fec8b636354e8db0b6a7", "html_url": "https://github.com/rust-lang/rust/commit/ec8ec54192cdc47a22f4fec8b636354e8db0b6a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec8ec54192cdc47a22f4fec8b636354e8db0b6a7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffe268606370e67bc312d92ccad39546c7646fdc", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffe268606370e67bc312d92ccad39546c7646fdc", "html_url": "https://github.com/rust-lang/rust/commit/ffe268606370e67bc312d92ccad39546c7646fdc"}, {"sha": "3001450f95912ec541081b512d4a59eb2d1333ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/3001450f95912ec541081b512d4a59eb2d1333ba", "html_url": "https://github.com/rust-lang/rust/commit/3001450f95912ec541081b512d4a59eb2d1333ba"}], "stats": {"total": 26, "additions": 18, "deletions": 8}, "files": [{"sha": "9fc16b55631a4d5d15867b33e7033df4f656f33f", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ec8ec54192cdc47a22f4fec8b636354e8db0b6a7/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec8ec54192cdc47a22f4fec8b636354e8db0b6a7/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=ec8ec54192cdc47a22f4fec8b636354e8db0b6a7", "patch": "@@ -2184,7 +2184,7 @@ pub mod order {\n     use super::Iterator;\n \n     /// Compare `a` and `b` for equality using `TotalEq`\n-    pub fn equals<A: TotalEq, T: Iterator<A>>(mut a: T, mut b: T) -> bool {\n+    pub fn equals<A: TotalEq, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return true,\n@@ -2195,7 +2195,7 @@ pub mod order {\n     }\n \n     /// Order `a` and `b` lexicographically using `TotalOrd`\n-    pub fn cmp<A: TotalOrd, T: Iterator<A>>(mut a: T, mut b: T) -> cmp::Ordering {\n+    pub fn cmp<A: TotalOrd, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> cmp::Ordering {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return cmp::Equal,\n@@ -2210,7 +2210,7 @@ pub mod order {\n     }\n \n     /// Compare `a` and `b` for equality (Using partial equality, `Eq`)\n-    pub fn eq<A: Eq, T: Iterator<A>>(mut a: T, mut b: T) -> bool {\n+    pub fn eq<A: Eq, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return true,\n@@ -2221,7 +2221,7 @@ pub mod order {\n     }\n \n     /// Compare `a` and `b` for nonequality (Using partial equality, `Eq`)\n-    pub fn ne<A: Eq, T: Iterator<A>>(mut a: T, mut b: T) -> bool {\n+    pub fn ne<A: Eq, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return false,\n@@ -2232,7 +2232,7 @@ pub mod order {\n     }\n \n     /// Return `a` < `b` lexicographically (Using partial order, `Ord`)\n-    pub fn lt<A: Ord, T: Iterator<A>>(mut a: T, mut b: T) -> bool {\n+    pub fn lt<A: Ord, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return false,\n@@ -2244,7 +2244,7 @@ pub mod order {\n     }\n \n     /// Return `a` <= `b` lexicographically (Using partial order, `Ord`)\n-    pub fn le<A: Ord, T: Iterator<A>>(mut a: T, mut b: T) -> bool {\n+    pub fn le<A: Ord, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return true,\n@@ -2256,7 +2256,7 @@ pub mod order {\n     }\n \n     /// Return `a` > `b` lexicographically (Using partial order, `Ord`)\n-    pub fn gt<A: Ord, T: Iterator<A>>(mut a: T, mut b: T) -> bool {\n+    pub fn gt<A: Ord, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return false,\n@@ -2268,7 +2268,7 @@ pub mod order {\n     }\n \n     /// Return `a` >= `b` lexicographically (Using partial order, `Ord`)\n-    pub fn ge<A: Ord, T: Iterator<A>>(mut a: T, mut b: T) -> bool {\n+    pub fn ge<A: Ord, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return true,\n@@ -2325,6 +2325,16 @@ pub mod order {\n         assert!(gt(c.iter(), b.iter()) == (c[0] >  b[0]));\n         assert!(ge(c.iter(), b.iter()) == (c[0] >= b[0]));\n     }\n+\n+    #[test]\n+    fn test_multi_iter() {\n+        use slice::ImmutableVector;\n+        use iter::DoubleEndedIterator;\n+        let xs = [1i,2,3,4];\n+        let ys = [4i,3,2,1];\n+        assert!(eq(xs.iter(), ys.iter().rev()));\n+        assert!(lt(xs.iter(), xs.iter().skip(2)));\n+    }\n }\n \n #[cfg(test)]"}]}