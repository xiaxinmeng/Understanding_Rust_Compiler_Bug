{"sha": "5068ae1ca05b2be0c2a98206a58d894aa620b312", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwNjhhZTFjYTA1YjJiZTBjMmE5ODIwNmE1OGQ4OTRhYTYyMGIzMTI=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-06-04T04:19:34Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-06-15T23:50:10Z"}, "message": "[WIP] injects llvm intrinsic instrprof.increment for coverage reports\n\nThis initial version only injects counters at the top of each function.\nRust Coverage will require injecting additional counters at each\nconditional code branch.", "tree": {"sha": "258a6eafab4eeab5d40cf776cc09d9799276787d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/258a6eafab4eeab5d40cf776cc09d9799276787d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5068ae1ca05b2be0c2a98206a58d894aa620b312", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5068ae1ca05b2be0c2a98206a58d894aa620b312", "html_url": "https://github.com/rust-lang/rust/commit/5068ae1ca05b2be0c2a98206a58d894aa620b312", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5068ae1ca05b2be0c2a98206a58d894aa620b312/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "395256a5dd74ccef046083d6e025a6d046379040", "url": "https://api.github.com/repos/rust-lang/rust/commits/395256a5dd74ccef046083d6e025a6d046379040", "html_url": "https://github.com/rust-lang/rust/commit/395256a5dd74ccef046083d6e025a6d046379040"}], "stats": {"total": 2566, "additions": 2561, "deletions": 5}, "files": [{"sha": "abb35e838ea28e46a779108aae957c3d8ae16546", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -1943,6 +1943,15 @@ extern \"rust-intrinsic\" {\n     pub fn miri_start_panic(payload: *mut u8) -> !;\n }\n \n+#[cfg(not(bootstrap))]\n+#[cfg_attr(not(bootstrap), lang = \"count_code_region\")]\n+pub fn count_code_region(_index: u32) {\n+    #[cfg_attr(not(bootstrap), allow(unused_unsafe))] // remove `unsafe` on bootstrap bump\n+    unsafe {\n+        abort()\n+    }\n+}\n+\n // Some functions are defined here because they accidentally got made\n // available in this module on stable. See <https://github.com/rust-lang/rust/issues/15702>.\n // (`transmute` also falls into this category, but it cannot be wrapped due to the"}, {"sha": "ba285b5ef38d12efa9c72d75794080ef9848fa49", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -997,6 +997,33 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         self.call_lifetime_intrinsic(\"llvm.lifetime.end.p0i8\", ptr, size);\n     }\n \n+    fn instrprof_increment(\n+        &mut self,\n+        fn_name: &'ll Value,\n+        hash: &'ll Value,\n+        num_counters: &'ll Value,\n+        index: &'ll Value,\n+    ) -> &'ll Value {\n+        debug!(\n+            \"instrprof_increment() with args ({:?}, {:?}, {:?}, {:?})\",\n+            fn_name, hash, num_counters, index\n+        );\n+\n+        let llfn = unsafe { llvm::LLVMRustGetInstrprofIncrementIntrinsic(self.cx().llmod) };\n+        let args = &[fn_name, hash, num_counters, index];\n+        let args = self.check_call(\"call\", llfn, args);\n+\n+        unsafe {\n+            llvm::LLVMRustBuildCall(\n+                self.llbuilder,\n+                llfn,\n+                args.as_ptr() as *const &llvm::Value,\n+                args.len() as c_uint,\n+                None,\n+            )\n+        }\n+    }\n+\n     fn call(\n         &mut self,\n         llfn: &'ll Value,"}, {"sha": "7ff5ac5cbdc10082bbdc7b54d1115784fd20addf", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -749,6 +749,8 @@ impl CodegenCx<'b, 'tcx> {\n         ifn!(\"llvm.lifetime.start.p0i8\", fn(t_i64, i8p) -> void);\n         ifn!(\"llvm.lifetime.end.p0i8\", fn(t_i64, i8p) -> void);\n \n+        ifn!(\"llvm.instrprof.increment\", fn(i8p, t_i64, t_i32, t_i32) -> void);\n+\n         ifn!(\"llvm.expect.i1\", fn(i1, i1) -> i1);\n         ifn!(\"llvm.eh.typeid.for\", fn(i8p) -> t_i32);\n         ifn!(\"llvm.localescape\", fn(...) -> void);"}, {"sha": "7fddda99185b450aeff3134d2c4250cb47cf771a", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -7,6 +7,8 @@ use crate::type_of::LayoutLlvmExt;\n use crate::va_arg::emit_va_arg;\n use crate::value::Value;\n \n+use log::debug;\n+\n use rustc_ast::ast;\n use rustc_codegen_ssa::base::{compare_simd_types, to_immediate, wants_msvc_seh};\n use rustc_codegen_ssa::common::span_invalid_monomorphization_error;\n@@ -21,6 +23,7 @@ use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n use rustc_middle::ty::{self, Ty};\n use rustc_middle::{bug, span_bug};\n use rustc_span::Span;\n+use rustc_span::Symbol;\n use rustc_target::abi::{self, HasDataLayout, LayoutOf, Primitive};\n use rustc_target::spec::PanicStrategy;\n \n@@ -86,6 +89,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         args: &[OperandRef<'tcx, &'ll Value>],\n         llresult: &'ll Value,\n         span: Span,\n+        caller_instance: ty::Instance<'tcx>,\n     ) {\n         let tcx = self.tcx;\n         let callee_ty = instance.monomorphic_ty(tcx);\n@@ -136,6 +140,23 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 let llfn = self.get_intrinsic(&(\"llvm.debugtrap\"));\n                 self.call(llfn, &[], None)\n             }\n+            \"count_code_region\" => {\n+                if let ty::InstanceDef::Item(fn_def_id) = caller_instance.def {\n+                    let caller_fn_path = tcx.def_path_str(fn_def_id);\n+                    debug!(\n+                        \"count_code_region to llvm.instrprof.increment(fn_name={})\",\n+                        caller_fn_path\n+                    );\n+\n+                    let (fn_name, _len_val) = self.const_str(Symbol::intern(&caller_fn_path));\n+                    let index = args[0].immediate();\n+                    let hash = self.const_u64(1234);\n+                    let num_counters = self.const_u32(1);\n+                    self.instrprof_increment(fn_name, hash, num_counters, index)\n+                } else {\n+                    bug!(\"intrinsic count_code_region: no src.instance\");\n+                }\n+            }\n             \"va_start\" => self.va_start(args[0].immediate()),\n             \"va_end\" => self.va_end(args[0].immediate()),\n             \"va_copy\" => {"}, {"sha": "372fb17573a4bd8069cb6577980168226e7a5efa", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -1360,6 +1360,7 @@ extern \"C\" {\n \n     // Miscellaneous instructions\n     pub fn LLVMBuildPhi(B: &Builder<'a>, Ty: &'a Type, Name: *const c_char) -> &'a Value;\n+    pub fn LLVMRustGetInstrprofIncrementIntrinsic(M: &Module) -> &'a Value;\n     pub fn LLVMRustBuildCall(\n         B: &Builder<'a>,\n         Fn: &'a Value,"}, {"sha": "49054765b9dae73e92aabe78e976b50cd98f41a4", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -175,6 +175,12 @@ impl ModuleConfig {\n                     if sess.opts.debugging_opts.profile && !is_compiler_builtins {\n                         passes.push(\"insert-gcov-profiling\".to_owned());\n                     }\n+\n+                    // The rustc option `-Zinstrument_coverage` injects intrinsic calls to\n+                    // `llvm.instrprof.increment()`, which requires the LLVM `instrprof` pass.\n+                    if sess.opts.debugging_opts.instrument_coverage {\n+                        passes.push(\"instrprof\".to_owned());\n+                    }\n                     passes\n                 },\n                 vec![]"}, {"sha": "d7db65715499313ace29a448c689676bd3dd72e0", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -566,7 +566,10 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         // Handle intrinsics old codegen wants Expr's for, ourselves.\n         let intrinsic = match def {\n-            Some(ty::InstanceDef::Intrinsic(def_id)) => Some(bx.tcx().item_name(def_id).as_str()),\n+            Some(ty::InstanceDef::Intrinsic(def_id))\n+            | Some(ty::InstanceDef::InjectedCode(def_id)) => {\n+                Some(bx.tcx().item_name(def_id).as_str())\n+            }\n             _ => None,\n         };\n         let intrinsic = intrinsic.as_ref().map(|s| &s[..]);\n@@ -693,6 +696,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 &args,\n                 dest,\n                 terminator.source_info.span,\n+                self.instance,\n             );\n \n             if let ReturnDest::IndirectOperand(dst, _) = ret_dest {"}, {"sha": "7ffc9f15bffdc59fb6d529834ab7244b1fee5c06", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -260,6 +260,14 @@ pub trait BuilderMethods<'a, 'tcx>:\n     /// Called for `StorageDead`\n     fn lifetime_end(&mut self, ptr: Self::Value, size: Size);\n \n+    fn instrprof_increment(\n+        &mut self,\n+        fn_name: Self::Value,\n+        hash: Self::Value,\n+        num_counters: Self::Value,\n+        index: Self::Value,\n+    ) -> Self::Value;\n+\n     fn call(\n         &mut self,\n         llfn: Self::Value,"}, {"sha": "f62019498511c48c166b9280c277948444965811", "filename": "src/librustc_codegen_ssa/traits/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -15,6 +15,7 @@ pub trait IntrinsicCallMethods<'tcx>: BackendTypes {\n         args: &[OperandRef<'tcx, Self::Value>],\n         llresult: Self::Value,\n         span: Span,\n+        caller_instance: ty::Instance<'tcx>,\n     );\n \n     fn abort(&mut self);"}, {"sha": "091ded6d74d0feb291a9a06bdb03f894cac21fc3", "filename": "src/librustc_hir/lang_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_hir%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_hir%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flang_items.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -242,6 +242,8 @@ language_item_table! {\n \n     StartFnLangItem,             \"start\",              start_fn,                Target::Fn;\n \n+    CountCodeRegionFnLangItem,   \"count_code_region\",  count_code_region_fn,    Target::Fn;\n+\n     EhPersonalityLangItem,       \"eh_personality\",     eh_personality,          Target::Fn;\n     EhCatchTypeinfoLangItem,     \"eh_catch_typeinfo\",  eh_catch_typeinfo,       Target::Static;\n "}, {"sha": "c2a7d1a4a6102739589de9e3921dc4c277df6c72", "filename": "src/librustc_interface/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_interface%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_interface%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Ftests.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -548,6 +548,7 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(human_readable_cgu_names, true);\n     tracked!(inline_in_all_cgus, Some(true));\n     tracked!(insert_sideeffect, true);\n+    tracked!(instrument_coverage, true);\n     tracked!(instrument_mcount, true);\n     tracked!(link_only, true);\n     tracked!(merge_functions, Some(MergeFunctions::Disabled));"}, {"sha": "b2c00849d9f8384a9493b7954c945b6527828769", "filename": "src/librustc_middle/mir/mono.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_middle%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_middle%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmono.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -352,6 +352,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n                             InstanceDef::VtableShim(..)\n                             | InstanceDef::ReifyShim(..)\n                             | InstanceDef::Intrinsic(..)\n+                            | InstanceDef::InjectedCode(..)\n                             | InstanceDef::FnPtrShim(..)\n                             | InstanceDef::Virtual(..)\n                             | InstanceDef::ClosureOnceShim { .. }"}, {"sha": "4f88e64c5039a86dcc124e97ac51034967703f09", "filename": "src/librustc_middle/ty/instance.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_middle%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_middle%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Finstance.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -21,6 +21,10 @@ pub enum InstanceDef<'tcx> {\n     Item(DefId),\n     Intrinsic(DefId),\n \n+    /// Injected call to a placeholder function that is replaced with\n+    /// For example: `core::intrinsic::count_code_region()` for code coverage.\n+    InjectedCode(DefId),\n+\n     /// `<T as Trait>::method` where `method` receives unsizeable `self: Self`.\n     VtableShim(DefId),\n \n@@ -149,6 +153,7 @@ impl<'tcx> InstanceDef<'tcx> {\n             | InstanceDef::FnPtrShim(def_id, _)\n             | InstanceDef::Virtual(def_id, _)\n             | InstanceDef::Intrinsic(def_id)\n+            | InstanceDef::InjectedCode(def_id)\n             | InstanceDef::ClosureOnceShim { call_once: def_id }\n             | InstanceDef::DropGlue(def_id, _)\n             | InstanceDef::CloneShim(def_id, _) => def_id,\n@@ -236,6 +241,7 @@ impl<'tcx> fmt::Display for Instance<'tcx> {\n             InstanceDef::VtableShim(_) => write!(f, \" - shim(vtable)\"),\n             InstanceDef::ReifyShim(_) => write!(f, \" - shim(reify)\"),\n             InstanceDef::Intrinsic(_) => write!(f, \" - intrinsic\"),\n+            InstanceDef::InjectedCode(_) => write!(f, \" - injected-code\"),\n             InstanceDef::Virtual(_, num) => write!(f, \" - virtual#{}\", num),\n             InstanceDef::FnPtrShim(_, ty) => write!(f, \" - shim({:?})\", ty),\n             InstanceDef::ClosureOnceShim { .. } => write!(f, \" - shim\"),\n@@ -415,6 +421,7 @@ impl<'tcx> Instance<'tcx> {\n             | InstanceDef::FnPtrShim(..)\n             | InstanceDef::Item(_)\n             | InstanceDef::Intrinsic(..)\n+            | InstanceDef::InjectedCode(..)\n             | InstanceDef::ReifyShim(..)\n             | InstanceDef::Virtual(..)\n             | InstanceDef::VtableShim(..) => Some(self.substs),"}, {"sha": "9b1e717731e826d172321eb3b9196ed7bb8b03aa", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -2717,6 +2717,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             ty::InstanceDef::VtableShim(..)\n             | ty::InstanceDef::ReifyShim(..)\n             | ty::InstanceDef::Intrinsic(..)\n+            | ty::InstanceDef::InjectedCode(..)\n             | ty::InstanceDef::FnPtrShim(..)\n             | ty::InstanceDef::Virtual(..)\n             | ty::InstanceDef::ClosureOnceShim { .. }"}, {"sha": "b6cbd2082a5184f3b181f9f98e70cf7695bbd60b", "filename": "src/librustc_middle/ty/structural_impls.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -674,6 +674,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::InstanceDef<'a> {\n             ty::InstanceDef::VtableShim(def_id) => Some(ty::InstanceDef::VtableShim(def_id)),\n             ty::InstanceDef::ReifyShim(def_id) => Some(ty::InstanceDef::ReifyShim(def_id)),\n             ty::InstanceDef::Intrinsic(def_id) => Some(ty::InstanceDef::Intrinsic(def_id)),\n+            ty::InstanceDef::InjectedCode(def_id) => Some(ty::InstanceDef::Intrinsic(def_id)),\n             ty::InstanceDef::FnPtrShim(def_id, ref ty) => {\n                 Some(ty::InstanceDef::FnPtrShim(def_id, tcx.lift(ty)?))\n             }\n@@ -846,6 +847,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::instance::Instance<'tcx> {\n                 VtableShim(did) => VtableShim(did.fold_with(folder)),\n                 ReifyShim(did) => ReifyShim(did.fold_with(folder)),\n                 Intrinsic(did) => Intrinsic(did.fold_with(folder)),\n+                InjectedCode(did) => InjectedCode(did.fold_with(folder)),\n                 FnPtrShim(did, ty) => FnPtrShim(did.fold_with(folder), ty.fold_with(folder)),\n                 Virtual(did, i) => Virtual(did.fold_with(folder), i),\n                 ClosureOnceShim { call_once } => {\n@@ -861,9 +863,12 @@ impl<'tcx> TypeFoldable<'tcx> for ty::instance::Instance<'tcx> {\n         use crate::ty::InstanceDef::*;\n         self.substs.visit_with(visitor)\n             || match self.def {\n-                Item(did) | VtableShim(did) | ReifyShim(did) | Intrinsic(did) | Virtual(did, _) => {\n-                    did.visit_with(visitor)\n-                }\n+                Item(did)\n+                | VtableShim(did)\n+                | ReifyShim(did)\n+                | Intrinsic(did)\n+                | InjectedCode(did)\n+                | Virtual(did, _) => did.visit_with(visitor),\n                 FnPtrShim(did, ty) | CloneShim(did, ty) => {\n                     did.visit_with(visitor) || ty.visit_with(visitor)\n                 }"}, {"sha": "82fa471b54d73b684c12537d631e6baf598a23f0", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -257,6 +257,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 assert!(caller_abi == Abi::RustIntrinsic || caller_abi == Abi::PlatformIntrinsic);\n                 M::call_intrinsic(self, instance, args, ret, unwind)\n             }\n+            ty::InstanceDef::InjectedCode(..) => {\n+                M::call_intrinsic(self, instance, args, ret, unwind)\n+            }\n             ty::InstanceDef::VtableShim(..)\n             | ty::InstanceDef::ReifyShim(..)\n             | ty::InstanceDef::ClosureOnceShim { .. }"}, {"sha": "24c4226bb4e9426d74638afddd01eec3ddc37c6f", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -714,7 +714,9 @@ fn visit_instance_use<'tcx>(\n     }\n \n     match instance.def {\n-        ty::InstanceDef::Virtual(..) | ty::InstanceDef::Intrinsic(_) => {\n+        ty::InstanceDef::Virtual(..)\n+        | ty::InstanceDef::Intrinsic(_)\n+        | ty::InstanceDef::InjectedCode(_) => {\n             if !is_direct_call {\n                 bug!(\"{:?} being reified\", instance);\n             }\n@@ -751,6 +753,7 @@ fn should_monomorphize_locally<'tcx>(tcx: TyCtxt<'tcx>, instance: &Instance<'tcx\n         | ty::InstanceDef::FnPtrShim(..)\n         | ty::InstanceDef::DropGlue(..)\n         | ty::InstanceDef::Intrinsic(_)\n+        | ty::InstanceDef::InjectedCode(_)\n         | ty::InstanceDef::CloneShim(..) => return true,\n     };\n "}, {"sha": "7c97b9d611e15b64865ea2aee08a51783ef2cd00", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -322,6 +322,7 @@ fn mono_item_visibility(\n         | InstanceDef::FnPtrShim(..)\n         | InstanceDef::Virtual(..)\n         | InstanceDef::Intrinsic(..)\n+        | InstanceDef::InjectedCode(..)\n         | InstanceDef::ClosureOnceShim { .. }\n         | InstanceDef::DropGlue(..)\n         | InstanceDef::CloneShim(..) => return Visibility::Hidden,\n@@ -717,6 +718,7 @@ fn characteristic_def_id_of_mono_item<'tcx>(\n                 | ty::InstanceDef::FnPtrShim(..)\n                 | ty::InstanceDef::ClosureOnceShim { .. }\n                 | ty::InstanceDef::Intrinsic(..)\n+                | ty::InstanceDef::InjectedCode(..)\n                 | ty::InstanceDef::DropGlue(..)\n                 | ty::InstanceDef::Virtual(..)\n                 | ty::InstanceDef::CloneShim(..) => return None,"}, {"sha": "b4477d9c86d4370c69977d7c6c955d4e75e8b6b0", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -109,6 +109,9 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> Body<'\n         ty::InstanceDef::Intrinsic(_) => {\n             bug!(\"creating shims from intrinsics ({:?}) is unsupported\", instance)\n         }\n+        ty::InstanceDef::InjectedCode(_) => {\n+            bug!(\"creating shims from injected code ({:?}) is unsupported\", instance)\n+        }\n     };\n     debug!(\"make_shim({:?}) = untransformed {:?}\", instance, result);\n "}, {"sha": "045cd03d1f7da21c12de8e2e58fdf9e4ccd7f522", "filename": "src/librustc_mir/transform/instrument_coverage.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -0,0 +1,100 @@\n+use crate::transform::{MirPass, MirSource};\n+use rustc_index::vec::Idx;\n+use rustc_middle::mir::interpret::Scalar;\n+use rustc_middle::mir::*;\n+use rustc_middle::mir::{Local, LocalDecl};\n+use rustc_middle::ty;\n+use rustc_middle::ty::Ty;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_span::def_id::DefId;\n+use rustc_span::Span;\n+\n+pub struct InstrumentCoverage;\n+\n+/**\n+ * Inserts call to count_code_region() as a placeholder to be replaced during code generation with\n+ * the intrinsic llvm.instrprof.increment.\n+ */\n+\n+// FIXME(richkadel): As a first step, counters are only injected at the top of each function.\n+// The complete solution will inject counters at each conditional code branch.\n+\n+impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+        if tcx.sess.opts.debugging_opts.instrument_coverage {\n+            if let Some(callee_fn_def_id) = tcx.lang_items().count_code_region_fn() {\n+                debug!(\"instrumenting {:?}\", src.def_id());\n+                instrument_coverage(tcx, callee_fn_def_id, body);\n+            }\n+        }\n+    }\n+}\n+\n+pub fn instrument_coverage<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    callee_fn_def_id: DefId,\n+    body: &mut Body<'tcx>,\n+) {\n+    let span = body.span.shrink_to_lo();\n+\n+    let ret_ty = tcx.fn_sig(callee_fn_def_id).output();\n+    let ret_ty = ret_ty.no_bound_vars().unwrap();\n+    let substs = tcx.mk_substs(::std::iter::once(ty::subst::GenericArg::from(ret_ty)));\n+\n+    let count_code_region_fn: Operand<'_> =\n+        Operand::function_handle(tcx, callee_fn_def_id, substs, span);\n+\n+    let index = const_int_operand(tcx, span.clone(), tcx.types.u32, 0);\n+\n+    let args = vec![index];\n+\n+    let source_info = SourceInfo { span: span, scope: OUTERMOST_SOURCE_SCOPE };\n+\n+    let new_block = START_BLOCK + body.basic_blocks().len();\n+\n+    let next_local = body.local_decls.len();\n+    let new_temp = Local::new(next_local);\n+    let unit_temp = Place::from(new_temp);\n+\n+    let storage_live = Statement { source_info, kind: StatementKind::StorageLive(new_temp) };\n+    let storage_dead = Statement { source_info, kind: StatementKind::StorageDead(new_temp) };\n+\n+    let count_code_region_call = TerminatorKind::Call {\n+        func: count_code_region_fn,\n+        args,\n+        destination: Some((unit_temp, new_block)),\n+        cleanup: None,\n+        from_hir_call: false,\n+    };\n+\n+    body.local_decls.push(LocalDecl::new(tcx.mk_unit(), body.span));\n+    body.basic_blocks_mut().push(BasicBlockData {\n+        statements: vec![storage_live],\n+        is_cleanup: false,\n+        terminator: Some(Terminator { source_info, kind: count_code_region_call }),\n+    });\n+\n+    body.basic_blocks_mut().swap(START_BLOCK, new_block);\n+    body[new_block].statements.push(storage_dead);\n+\n+    // FIXME(richkadel): ALSO add each computed Span for each conditional branch to the coverage map\n+    // and provide that map to LLVM to encode in the final binary.\n+}\n+\n+fn const_int_operand<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    span: Span,\n+    ty: Ty<'tcx>,\n+    val: u128,\n+) -> Operand<'tcx> {\n+    let param_env_and_ty = ty::ParamEnv::empty().and(ty);\n+    let size = tcx\n+        .layout_of(param_env_and_ty)\n+        .unwrap_or_else(|e| panic!(\"could not compute layout for {:?}: {:?}\", ty, e))\n+        .size;\n+    Operand::Constant(box Constant {\n+        span,\n+        user_ty: None,\n+        literal: ty::Const::from_scalar(tcx, Scalar::from_uint(val, size), ty),\n+    })\n+}"}, {"sha": "e03ef48f748388478efa6bf97257421a4bf3c0d5", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -28,6 +28,7 @@ pub mod elaborate_drops;\n pub mod generator;\n pub mod inline;\n pub mod instcombine;\n+pub mod instrument_coverage;\n pub mod no_landing_pads;\n pub mod nrvo;\n pub mod promote_consts;\n@@ -287,6 +288,8 @@ fn mir_validated(\n         &[&[\n             // What we need to run borrowck etc.\n             &promote_pass,\n+            // FIXME(richkadel): is this the best place for the InstrumentCoverage pass?\n+            &instrument_coverage::InstrumentCoverage,\n             &simplify::SimplifyCfg::new(\"qualify-consts\"),\n         ]],\n     );"}, {"sha": "599ce595e1314e0c99d2f29a694354b7361feaa9", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -876,6 +876,9 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"fix undefined behavior when a thread doesn't eventually make progress \\\n         (such as entering an empty infinite loop) by inserting llvm.sideeffect \\\n         (default: no)\"),\n+    instrument_coverage: bool = (false, parse_bool, [TRACKED],\n+        \"instrument the generated code with LLVM code region counters for \\\n+        generating coverage reports (default: no)\"),\n     instrument_mcount: bool = (false, parse_bool, [TRACKED],\n         \"insert function instrument code for mcount-based tracing (default: no)\"),\n     keep_hygiene_data: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "623c279734733ae2369a257c3bc53b6ecc686860", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -240,6 +240,7 @@ symbols! {\n         copy_closures,\n         core,\n         core_intrinsics,\n+        count_code_region,\n         crate_id,\n         crate_in_paths,\n         crate_local,"}, {"sha": "d4ceeff324450fa1b35897cfb22ba62a90e8b790", "filename": "src/librustc_ty/instance.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_ty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Flibrustc_ty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Finstance.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -35,6 +35,10 @@ fn resolve_instance<'tcx>(\n                 debug!(\" => intrinsic\");\n                 ty::InstanceDef::Intrinsic(def_id)\n             }\n+            ty::FnDef(def_id, _) if Some(def_id) == tcx.lang_items().count_code_region_fn() => {\n+                debug!(\" => injected placeholder function to be replaced\");\n+                ty::InstanceDef::InjectedCode(def_id)\n+            }\n             ty::FnDef(def_id, substs) if Some(def_id) == tcx.lang_items().drop_in_place_fn() => {\n                 let ty = substs.type_at(0);\n "}, {"sha": "cdb3a157eab97bc408dceb86f44d79d923025db1", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -5,6 +5,7 @@\n #include \"llvm/IR/DiagnosticPrinter.h\"\n #include \"llvm/IR/GlobalVariable.h\"\n #include \"llvm/IR/Instructions.h\"\n+#include \"llvm/IR/Intrinsics.h\"\n #include \"llvm/Object/Archive.h\"\n #include \"llvm/Object/ObjectFile.h\"\n #include \"llvm/Bitcode/BitcodeWriterPass.h\"\n@@ -1364,6 +1365,11 @@ extern \"C\" LLVMValueRef LLVMRustBuildCall(LLVMBuilderRef B, LLVMValueRef Fn,\n       unwrap(Fn), makeArrayRef(unwrap(Args), NumArgs), Bundles));\n }\n \n+extern \"C\" LLVMValueRef LLVMRustGetInstrprofIncrementIntrinsic(LLVMModuleRef M) {\n+  return wrap(llvm::Intrinsic::getDeclaration(unwrap(M),\n+              (llvm::Intrinsic::ID)llvm::Intrinsic::instrprof_increment));\n+}\n+\n extern \"C\" LLVMValueRef LLVMRustBuildMemCpy(LLVMBuilderRef B,\n                                             LLVMValueRef Dst, unsigned DstAlign,\n                                             LLVMValueRef Src, unsigned SrcAlign,"}, {"sha": "132469cbb182c80ac107a76aef6753a8fcbd5448", "filename": "src/test/codegen/coverage-experiments/Cargo.lock", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2FCargo.lock?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -0,0 +1,5 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n+[[package]]\n+name = \"coverage_experiments\"\n+version = \"0.1.0\""}, {"sha": "296a8d5c9af2dff8c722b1470f245533658040c4", "filename": "src/test/codegen/coverage-experiments/Cargo.toml", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2FCargo.toml?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -0,0 +1,103 @@\n+[workspace]\n+\n+[package]\n+name = \"coverage_experiments\"\n+version = \"0.1.0\"\n+license = \"BSD-3-Clause\"\n+authors = [\"rust-fuchsia@fuchsia.com\"]\n+edition = \"2018\"\n+\n+[[bin]]\n+\n+name = \"coverage_injection_test\"\n+path = \"src/coverage_injection_test.rs\"\n+\n+[[bin]]\n+\n+name = \"coverage_injection_test2\"\n+path = \"src/coverage_injection_test2.rs\"\n+\n+[[bin]]\n+\n+name = \"while\"\n+path = \"src/while.rs\"\n+\n+[[bin]]\n+\n+name = \"while_clean\"\n+path = \"src/while_clean.rs\"\n+\n+[[bin]]\n+\n+name = \"while_early_return\"\n+path = \"src/while_early_return.rs\"\n+\n+[[bin]]\n+\n+name = \"if_with_comments\"\n+path = \"src/if_with_comments.rs\"\n+\n+[[bin]]\n+\n+name = \"if\"\n+path = \"src/if.rs\"\n+\n+[[bin]]\n+\n+name = \"increment_intrinsic\"\n+path = \"src/increment_intrinsic.rs\"\n+\n+[[bin]]\n+\n+name = \"just_main\"\n+path = \"src/just_main.rs\"\n+\n+[[bin]]\n+\n+name = \"lazy_boolean\"\n+path = \"src/lazy_boolean.rs\"\n+\n+[[bin]]\n+\n+name = \"match\"\n+path = \"src/match.rs\"\n+\n+[[bin]]\n+\n+name = \"match_without_increment\"\n+path = \"src/match_without_increment.rs\" # identical to -Zunpretty=hir output\n+\n+[[bin]]\n+\n+name = \"match_with_increment\"\n+path = \"src/match_with_increment.rs\"\n+\n+[[bin]]\n+\n+name = \"match_with_increment_alt\"\n+path = \"src/match_with_increment_alt.rs\"\n+\n+[[bin]]\n+\n+name = \"loop_break_value\"\n+path = \"src/loop_break_value.rs\"\n+\n+[[bin]]\n+\n+name = \"for_with_comments\"\n+path = \"src/for_with_comments.rs\"\n+\n+[[bin]]\n+\n+name = \"for\"\n+path = \"src/for.rs\"\n+\n+[[bin]]\n+\n+name = \"drop_trait\"\n+path = \"src/drop_trait.rs\"\n+\n+#[dependencies] # Should not need to manually add coverage dependencies\n+#version = \"0.1.0\"\n+#path = \"../__builtin\" # for mod __builtin::coverage\n+"}, {"sha": "3b69c0a406594aa7f826fe1d2ac11587e18f9a5c", "filename": "src/test/codegen/coverage-experiments/README-THIS-IS-TEMPORARY.md", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2FREADME-THIS-IS-TEMPORARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2FREADME-THIS-IS-TEMPORARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2FREADME-THIS-IS-TEMPORARY.md?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -0,0 +1,157 @@\n+# codegen/coverage-experiments\n+*<h2>THIS DIRECTORY IS TEMPORARY</h2>*\n+\n+This directory contains some work-in-progress (WIP) code used for experimental development and\n+testing of Rust Coverage feature development.\n+\n+The code in this directory will be removed, or migrated into product tests, when the Rust\n+Coverage feature is complete.\n+\n+[TOC]\n+\n+## Development Notes\n+\n+### config.toml\n+\n+config.toml probably requires (I should verify that intrinsic `llvm.instrprof.increment`\n+code generation ONLY works with this config option):\n+\n+  profiler = true\n+\n+## First build\n+\n+```shell\n+./x.py clean\n+./x.py build -i --stage 1 src/libstd\n+```\n+\n+## Incremental builds *IF POSSIBLE!*\n+\n+```shell\n+./x.py build -i --stage 1 src/libstd --keep-stage 1\n+```\n+\n+*Note: Some changes made for Rust Coverage required the full build (without `--keep-stage 1`), and in some cases, required `./x.py clean` first!. Occassionally I would get errors when building or when compiling a test program with `--Zinstrument-coverage` that work correctly only after a full clean and build.*\n+\n+## Compile a test program with LLVM coverage instrumentation\n+\n+*Note: This PR is still a work in progress. At the time of this writing, the `llvm.instrprof.increment` intrinsic is injected, and recognized by the LLVM code generation stage, but it does not appear to be included in the final binary. This is not surprising since other steps are still to be implemented, such as generating the coverage map. See the suggested additional `llvm` flags for ways to verify the `llvm` passes at least get the right intrinsic.*\n+\n+Suggested debug configuration to confirm Rust coverage features:\n+```shell\n+$ export RUSTC_LOG=rustc_codegen_llvm::intrinsic,rustc_mir::transform::instrument_coverage=debug\n+```\n+\n+Ensure the new compiled `rustc` is used (the path below, relative to the `rust` code repository root, is an example only):\n+\n+```shell\n+$ build/x86_64-unknown-linux-gnu/stage1/bin/rustc \\\n+  src/test/codegen/coverage-experiments/just_main.rs \\\n+  -Zinstrument-coverage\n+```\n+\n+### About the test programs in coverage-experiments/src/\n+\n+The `coverage-experiments/src/` directory contains some sample (and very simple) Rust programs used to analyze Rust compiler output at various stages, with or without the Rust code coverage compiler option. For now, these are only used for the in-progress development and will be removed at a future date. (These are *not* formal test programs.)\n+\n+The src director may also contain some snapshots of mir output from experimentation, particularly if the saved snapshots highlight results that are important to the future development, individually or when compared with other output files.\n+\n+Be aware that some of the files and/or comments may be outdated.\n+\n+### Additional `llvm` flags (append to the `rustc` command)\n+\n+These optional flags generate additional files and/or terminal output. LLVM's `-print-before=all` should show the `instrprof.increment` intrinsic with arguments computed by the experimental Rust coverage feature code:\n+\n+```shell\n+  --emit llvm-ir \\\n+  -Zverify-llvm-ir \\\n+  -Zprint-llvm-passes \\\n+  -Csave-temps \\\n+  -Cllvm-args=-print-before-all\n+```\n+\n+### Additional flags for MIR analysis and transforms\n+\n+These optional flags generate a directory with many files representing the MIR as text (`.mir` files) and as a visual graph (`.dot` files) rendered by `graphviz`. (**Some IDEs, such as `VSCode` have `graphviz` extensions.**)\n+\n+```shell\n+  -Zdump-mir=main \\\n+  -Zdump-mir-graphviz\n+```\n+\n+### Flags I've used but appear to be irrelvant to `-Zinstrument-coverage` after all:\n+```shell\n+  # -Zprofile\n+  # -Ccodegen-units=1\n+  # -Cinline-threshold=0\n+  # -Clink-dead-code\n+  # -Coverflow-checks=off\n+```\n+\n+## Run the test program compiled with code coverage instrumentation (maybe):\n+\n+As stated above, at the time of this writing, this work-in-progress seems to generate `llvm.instrprof.increment` intrinsic calls correctly, and are visibile in early `llvm` code generation passes, but are eventually stripped.\n+\n+The test program should run as expected, currently does not generate any coverage output.\n+\n+*Example:*\n+\n+```shell\n+  $ src/test/codegen/coverage-experiments/just_main\n+  hello world! (should be covered)\n+```\n+\n+### Running the coverage-enabled `rustc` compiler in the `lldb` debugger:\n+\n+For example, to verify the intrinsic is codegen'ed, set breakpoint in `lldb` where it validates a certain instruction is the `llvm.instrprof.increment` instruction.\n+\n+First, update config.toml for debugging:\n+\n+```toml\n+  [llvm]\n+  optimize = false\n+  release-debuginfo = true\n+\n+  [rust]\n+  debug = true\n+  debuginfo-level = 2\n+```\n+\n+*(Note, in case this is relevant after all, I also have the following changes; but I don't think I need them:)*\n+\n+```toml\n+  # Add and uncomment these if relevant/useful:\n+  # codegen-units = 0\n+  # python = '/usr/bin/python3.6'\n+```\n+\n+Run the compiler with additional flags as needed:\n+\n+```shell\n+lldb \\\n+  build/x86_64-unknown-linux-gnu/stage1/bin/rustc \\\n+  -- \\\n+  src/test/codegen/coverage-experiments/just_main.rs \\\n+  -Zinstrument-coverage \\\n+  -Zdump-mir=main \\\n+  -Zdump-mir-graphviz\n+```\n+\n+Note the specific line numbers may be different:\n+\n+```c++\n+(lldb) b lib/Transforms/Instrumentation/InstrProfiling.cpp:418\n+(lldb) r\n+\n+Process 93855 stopped\n+* thread #6, name = 'rustc', stop reason = breakpoint 2.1\n+    frame #0: 0x00007fffedff7738 librustc_driver-5a0990d8d18fb2b4.so`llvm::InstrProfiling::lowerIntrinsics(this=0x00007fffcc001d40, F=0x00007fffe4552198) at InstrProfiling.cpp:418:23\n+   415        auto Instr = I++;\n+   416        InstrProfIncrementInst *Inc = castToIncrementInst(&*Instr);\n+   417        if (Inc) {\n+-> 418          lowerIncrement(Inc);\n+   419          MadeChange = true;\n+   420        } else if (auto *Ind = dyn_cast<InstrProfValueProfileInst>(Instr)) {\n+   421          lowerValueProfileInst(Ind);\n+(lldb)\n+```\n\\ No newline at end of file"}, {"sha": "231da1dc1a67f388fe911aefe8bd15ebc3c63fab", "filename": "src/test/codegen/coverage-experiments/src/coverage_injection_test.rs", "status": "added", "additions": 335, "deletions": 0, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fcoverage_injection_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fcoverage_injection_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fcoverage_injection_test.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -0,0 +1,335 @@\n+/*                       */ use std::io::Error;\n+/*                       */ use std::io::ErrorKind;\n+/*                       */\n+/*                       */ /// Align Rust counter increment with with:\n+/*                       */ /// [\u2018llvm.instrprof.increment\u2019 Intrinsic](https://llvm.org/docs/LangRef.html#llvm-instrprof-increment-intrinsic)\n+/*                       */ ///\n+/*                       */ /// declare void @llvm.instrprof.increment(i8* <name>, i64 <hash>, i32 <num-counters>, i32 <index>)\n+/*                       */ ///\n+/*                       */ /// The first argument is a pointer to a global variable containing the name of the entity\n+/*                       */ /// being instrumented. This should generally be the (mangled) function name for a set of\n+/*                       */ /// counters.\n+/*                       */ ///\n+/*                       */ /// The second argument is a hash value that can be used by the consumer of the profile data\n+/*                       */ /// to detect changes to the instrumented source, and the third is the number of counters\n+/*                       */ /// associated with name. It is an error if hash or num-counters differ between two\n+/*                       */ /// instances of instrprof.increment that refer to the same name.\n+/*                       */ ///\n+/*                       */ /// The last argument refers to which of the counters for name should be incremented. It\n+/*                       */ /// should be a value between 0 and num-counters.\n+/*                       */ ///\n+/*                       */ /// # Arguments\n+/*                       */ ///\n+/*                       */ /// `mangled_fn_name` - &'static ref to computed and injected static str, using:\n+/*                       */ ///\n+/*                       */ ///     ```\n+/*                       */ ///     fn rustc_symbol_mangling::compute_symbol_name(\n+/*                       */ ///         tcx: TyCtxt<'tcx>,\n+/*                       */ ///         instance: Instance<'tcx>,\n+/*                       */ ///         compute_instantiating_crate: impl FnOnce() -> CrateNum,\n+/*                       */ ///     ) -> String\n+/*                       */ ///     ```\n+/*                       */ ///\n+/*                       */ /// `source_version_hash` - Compute hash based that only changes if there are \"significant\"\n+/*                       */ /// to control-flow inside the function.\n+/*                       */ ///\n+/*                       */ /// `num_counters` - The total number of counter calls [MAX(counter_index) + 1] within the\n+/*                       */ /// function.\n+/*                       */ ///\n+/*                       */ /// `counter_index` - zero-based counter index scoped by the function. (Ordering of\n+/*                       */ /// counters, relative to the source code location, is apparently not expected.)\n+/*                       */ ///\n+/*                       */ /// # Notes\n+/*                       */ ///\n+/*                       */ /// * The mangled_fn_name may not be computable until generics are monomorphized (see\n+/*                       */ ///   parameters required by rustc_symbol_mangling::compute_symbol_name).\n+/*                       */ /// * The version hash may be computable from AST analysis, and may not benefit from further\n+/*                       */ ///   lowering.\n+/*                       */ /// * num_counters depends on having already identified all counter insertion locations.\n+/*                       */ /// * counter_index can be computed at time of counter insertion (incrementally).\n+/*                       */ /// * Numeric parameters are signed to match the llvm increment intrinsic parameter types.\n+/*                       */ fn __lower_incr_cov(_mangled_fn_name: &'static str, _fn_version_hash: i64, _num_counters: i32, _counter_index: i32) {\n+/*                       */ }\n+/*                       */\n+/*                       */ /// A coverage counter implementation that will work as both an intermediate coverage\n+/*                       */ /// counting and reporting implementation at the AST-level only--for debugging and\n+/*                       */ /// development--but also serves as a \"marker\" to be replaced by calls to LLVM\n+/*                       */ /// intrinsic coverage counter APIs during the lowering process.\n+/*                       */ ///\n+/*                       */ /// Calls to this function will be injected automatically into the AST. When LLVM intrinsics\n+/*                       */ /// are enabled, the counter function calls that were injected into the AST serve as\n+/*                       */ /// placeholders, to be replaced by an alternative, such as:\n+/*                       */ ///\n+/*                       */ ///     * direct invocation of the `llvm.instrprof.increment()` intrinsic; or\n+/*                       */ ///     * the `__lower_incr_cov()` function, defined above, that would invoke the\n+/*                       */ ///       `llvm.instrprof.increment()` intrinsic; or\n+/*                       */ ///     * a similar expression wrapper, with the additional parameters (as defined above\n+/*                       */ ///       for `__lower_incr_cov()`, that invokes `llvm.instrprof.increment()` and returns the\n+/*                       */ ///       result of the wrapped expression)\n+/*                       */ ///\n+/*                       */ /// The first two options would require replacing the inlined wrapper call with something\n+/*                       */ /// like:\n+/*                       */ ///\n+/*                       */ /// ```\n+/*                       */ /// { let result = {expr}; __inlined_incr_cov(context, counter); result }\n+/*                       */ /// ```\n+/*                       */ ///\n+/*                       */ /// But if the lowering process is already unwrapping the inlined call to `__incr_cov()`, then\n+/*                       */ /// it may be a perfect opportunity to replace the function with one of these more\n+/*                       */ /// direct methods.\n+/*                       */ ///\n+/*                       */ #[inline(always)]\n+/*                       */ pub fn __incr_cov<T>(region_loc: &str, /*index: u32,*/ result: T) -> T {\n+/*                       */     // Either call the intermediate non-llvm coverage counter API or\n+/*                       */     // replace the call to this function with the expanded `__lower_incr_cov()` call.\n+/*                       */\n+/*                       */     // let _lock = increment_counter(counter);\n+/*                       */     println!(\"{}\", region_loc);\n+/*                       */\n+/*                       */     result\n+/*                       */ }\n+/*                       */\n+/*                       */ /// Write a report identifying each incremented counter and the number of times each counter\n+/*                       */ /// was incremented.\n+/*                       */ fn __report() {\n+/*                       */     println!(\"WRITE REPORT!\");\n+/*                       */ }\n+/*                       */\n+/*                       */ /// Increment the counter after evaluating the wrapped expression (see `__incr_cov()`), then\n+/*                       */ /// write a report identifying each incremented counter and the number of times each counter\n+/*                       */ /// was incremented.\n+/*                       */ #[inline(always)]\n+/*                       */ pub fn __incr_cov_and_report<T>(region_loc: &str, /*counter: u32,*/ result: T) -> T {\n+/*                       */     __incr_cov(region_loc, /*counter,*/ ());\n+/*                       */     __report();\n+/*                       */     result\n+/*                       */ }\n+/*                       */\n+/*                       */ macro_rules! from {\n+/*                       */     ($from:expr) => { &format!(\"from: {}\\n  to: {}:{}:{}\", $from, file!(), line!(), column!()) };\n+/*                       */ }\n+/*                       */\n+/*                       */ #[derive(Debug)]\n+/*                       */ enum TestEnum {\n+/*                       */     Red,\n+/*                       */     Green,\n+/*                       */     Blue,\n+/*                       */ }\n+/*                       */\n+/*                       */ struct TestStruct {\n+/*                       */     field: i32,\n+/*                       */ }\n+/*                       */\n+/*                       */ // IMPORTANT! IS WRAPPING main() ENOUGH? OR DO I ALSO NEED TO WRAP THREAD FUNCTIONS, ASSUMING\n+/*                       */ // THEY ARE STILL RUNNING WITH MAIN EXITS? (IF THEY CAN). NOT SURE HOW RUST HANDLES THAT.\n+/*                       */\n+/*                       */ // I SUSPECT USING THREAD_LOCAL COUNTERS MAY NOT ACTUALLY BE AN OPTIMIZATION OVER MUTEX LOCKS,\n+/*                       */ // BUT MAYBE I SHOULD ASK.\n+/*                       */\n+/*                       */ impl TestStruct {\n+/*    -                  */     fn new() -> Self {\n+/*    \u2503                  */         __incr_cov(from!(\"fn new()\"),Self::new_with_value(31415)) // function-scoped counter index = 0\n+/*    -                  */     }\n+/*                       */\n+/*    -                  */     fn new_with_value(field: i32) -> Self {\n+/*    \u2503                  */         __incr_cov(from!(\"fn new_with_value()\"),Self {\n+/*    \u2503                  */             field,\n+/*    \u2503                  */         }) // function-scoped counter index = 0\n+/*    -                  */     }\n+/*                       */\n+/*                       */     fn call_closure<F>(&self, closure: F) -> bool\n+/*                       */     where\n+/*                       */         F: FnOnce(\n+/*                       */             i32,\n+/*                       */         ) -> bool,\n+/*    -                  */     {\n+/*    \u2503                  */         __incr_cov(from!(\"fn call_closure()\"),closure(123)) // function-scoped counter index = 0\n+/*    -                  */     }\n+/*                       */\n+/*    -                  */     fn various(&self) -> Result<(),Error> {\n+/*    \u2503                  */         use TestEnum::*;\n+/*    \u2503                  */         let mut color = Red;\n+/*    \u2503                  */         let _ = color;\n+/*    \u2503                  */         color = Blue;\n+/*    \u2503                  */         let _ = color;\n+/*    \u2503                  */         color = Green;\n+/*    \u2503                  */         match __incr_cov(from!(\"fn various\"),color) { // function-scoped counter index = 0\n+/*    :                  */\n+/*    :                  */             // !!! RECORD SPAN FROM START OF INNERMOST CONTAINING BLOCK (THE FUNCTION IN THIS CASE) TO END OF MATCH EXPRESSION\n+/*    :                  */             // If `match`, `while`, `loop`, `for`, `if`, etc. expression has a `return`, `break`, or `continue`\n+/*    :                  */             // (if legal), then RECORD SPAN FROM START OF INNERMOST CONTAINING BLOCK TO END OF `return` EXPRESSION\n+/*    :                  */             // If the expression includes lazy booleans, nest calls to `__incr_cov()`.\n+/*    :   I              */             Red => __incr_cov(from!(\"Red => or end of MatchArmGuard expression inside pattern, if any\"),println!(\"roses\")),\n+/*    :   -              */             Green => {\n+/*    :   \u2503              */                 let spidey = 100;\n+/*    :   \u2503              */                 let goblin = 50;\n+/*    :   \u2503              */                 // if spidey > goblin {__incr_cov(from!(\"\"),{\n+/*    :   \u2503              */                 //     println!(\"what ev\");\n+/*    :   \u2503              */                 // })}\n+/*    :   \u2503              */                 // ACTUALLY, WRAPPING THE ENTIRE IF BLOCK IN `__incr_cov` IS NOT A GREAT GENERAL RULE.\n+/*    :   \u2503              */                 // JUST INSERTING A `return`, `break`, or `continue` IN THAT BLOCK (without an intermediate condition)\n+/*    :   \u2503              */                 // MAKES THE `__incr_cov()` CALL UNREACHABLE!\n+/*    :   \u2503              */                 // MY ORIGINAL SOLUTION WORKS BETTER (WRAP LAST EXPRESSION OR AFTER LAST SEMICOLON STATEMENT IN BLOCK)\n+/*    :   \u2503              */                 // UNLESS THE EXPRESSION IS NOT A BLOCK.\n+/*    :   \u2503   -          */                 if __incr_cov(from!(\"Green => or end of MatchArmGuard expression inside pattern, if any\"),spidey > goblin) {\n+/*    :   :   \u2503          */                     println!(\"spidey beats goblin\");\n+/*    :   :   \u2503          */                     __incr_cov(from!(\"block start\"),());\n+/*    :   \u2503   -          */                 } else if __incr_cov(from!(\"`else if` on this line\"),spidey == goblin) {\n+/*    :   :   \u2503          */                     // COVERAGE NOTE: Do we mark only the expression span (that may be trivial, as in this case),\n+/*    :   :   \u2503          */                     // or associate it with the outer block, similar to how the `if` expression is associated with\n+/*    :   :   \u2503          */                     // the outer block? (Although it is a continuation, in a sense, it is discontiguous in this case,\n+/*    :   :   \u2503          */                     // so I think simpler to just make it its own coverage region.)\n+/*    :   :   \u2503          */                     println!(\"it's a draw\");\n+/*    :   :   \u2503          */                     __incr_cov(from!(\"block start\"),());\n+/*    :   \u2503   -   -   -  */                 } else if if __incr_cov(from!(\"`else if` on this line\"),true) {\n+/*    :   :       :   \u2503  */                             // return __incr_cov(from!(\"after `if true`\"),Ok(()));\n+/*    :   :       :   \u2503  */                             // ACTUALLY, BECAUSE OF `return`, WE DO NOT RECORD THE `if true` EVEN THOUGH WE COVERED IT.\n+/*    :   :       :   \u2503  */                             // IN FACT, IF THIS NESTED CONDITIONAL IN A CONDITIONAL EXPRESSION WAS AN `if` (WITHOUT PRECEDING ELSE)\n+/*    :   :       :   \u2503  */                             // WE WOULD NOT HAVE RECORDED THE COVERAGE OF STATEMENTS LEADING UP TO THE `if`, SO\n+/*    :   :       :   \u2503  */                             // IT SHOULD BE:\n+/*  \u250f-:---:-------:---<  */                             return __incr_cov(from!(\"\"),Ok(()));\n+/*  V :   :       :   :  */                             // NOTE THE `from` STRING IS SAME FOR THE `else if`s `__incr_cov` AND THIS `return`.\n+/*    :   :       :   :  */                             // ONLY ONE OF THESE WILL EXECUTE, TO RECORD COVERAGE FROM THAT SPOT.\n+/*    :   :       \u2503   -  */                         } else {\n+/*    :   :       :   I  */                             __incr_cov(from!(\"`else`\"),false)\n+/*    :   :   -   -      */                         } {\n+/*    :   :   \u2503          */                     println!(\"wierd science\");\n+/*    :   :   \u2503          */                     __incr_cov(from!(\"block start\"),());\n+/*    :   \u2503   -          */                 } else {\n+/*    :   :   \u2503          */                     println!(\"goblin wins\");\n+/*  \u250f-:---:---<          */                     return __incr_cov(from!(\"`else`\"),Ok(())); // THIS COUNTS LAST STATEMENT IN `else` BLOCK\n+/*  V :   :   :          */                     // COVERAGE NOTE: When counting the span for `return`,\n+/*    :   :   :          */                     // `break`, or `continue`, also report the outer spans\n+/*    :   :   :          */                     // got this far--including this `else` block. Record\n+/*    :   :   :          */                     // The start positions for those outer blocks, but:\n+/*    :   :   :          */                     // * For the block containing the `return`, `break`, or\n+/*    :   :   :          */                     //   `continue`, end report the end position is the\n+/*    :   :   :          */                     //   start of the `return` span (or 1 char before it).\n+/*    :   :   :          */                     // * Anything else?\n+/*    :   \u2503   -          */                 }\n+/*    :   \u2503   -          */                 // __incr_cov(from!(\"\"),()); // DO NOT COUNT HERE IF NO STATEMENTS AFTER LAST `if` or `match`\n+/*    :   -              */             },\n+/*    :   I              */             Blue => __incr_cov(from!(\"Blue => or end of MatchArmGuard expression inside pattern, if any\"),println!(\"violets\")),\n+/*    \u2503                  */         }\n+/*    \u2503                  */\n+/*    \u2503                  */         let condition1 = true;\n+/*    \u2503                  */         let condition2 = false;\n+/*    \u2503                  */         let condition3 = true;\n+/*    \u2503                  */\n+/*    \u2503                  */         println!(\"Called `various()` for TestStruct with field={}\", self.field);\n+/*    \u2503                  */\n+/*    \u2503   -              */         if __incr_cov(from!(\"after block end of prior `match` (or `if-else if-else`)\"),condition1) {\n+/*    :   \u2503              */             println!(\"before while loop\");\n+/*    :   \u2503              */             let mut countdown = 10;\n+/*    :   \u2503              */             __incr_cov(from!(\"block start\"),()); // Must increment before repeated while text expression\n+/*    :   :   I          */             while __incr_cov(from!(\"while test\"), countdown > 0) { // span is just the while test expression\n+/*    :   :   \u2503          */                 println!(\"top of `while` loop\");\n+/*    :   :   \u2503          */                 countdown -= 1;\n+/*    :   :   \u2503          */                 // __incr_cov(from!(\"while loop\"),()); // Counter not needed, but span is computed as \"while test\" minus \"block start\"\n+/*    :   :   \u2503          */                                                        // If test expression is 11, and the outer block runs only once, 11-1 = 10\n+/*    :   \u2503   -          */             }\n+/*    :   \u2503              */             println!(\"before for loop\");\n+/*    :   \u2503   -          */             for index in __incr_cov(from!(\"end of while\"),0..10) {\n+/*    :   :   \u2503          */                 println!(\"top of `for` loop\");\n+/*    :   :   \u2503   -      */                 if __incr_cov(from!(\"block start\"),index == 8) {\n+/*    :   :   :   \u2503      */                     println!(\"before break\");\n+/*    :   :   :   \u2503      */                     // note the following is not legal here:\n+/*    :   :   :   \u2503      */                     //   \"can only break with a value inside `loop` or breakable block\"\n+/*    :   :   :   \u2503      */                     // break __incr_cov(from!(\"\"),());\n+/*    :   :   :   \u2503      */                     __incr_cov(from!(\"block start\"),());\n+/*    :   : \u250f-----<      */                     break;\n+/*    :   : V :   :      */\n+/*    :   :   :   :      */                     // FIXME(richkadel): add examples with loop labels, breaking out of inner and outer loop to outer loop label, with expression.\n+/*    :   :   :   :      */                     // May want to record both the span and the start position after the broken out block depdnding on label\n+/*    :   :   \u2503   -      */                 }\n+/*    :   :   \u2503          */                 println!(\"after `break` test\");\n+/*    :   :   \u2503   -      */                 if __incr_cov(from!(\"block end of `if index == 8`\"),condition2) {\n+/*  \u250f-:---:---:---<      */                     return __incr_cov(from!(\"block start\"),Ok(()));\n+/*  V :   :   \u2503   -      */                 }\n+/*    :   :   \u2503          */\n+/*    :   :   \u2503          */                 // BECAUSE THE PREVIOUS COVERAGE REGION HAS A `return`, THEN\n+/*    :   :   \u2503          */                 // IF PREVIOUS COVERAGE REGION IS NOT COUNTED THEN OUTER REGION REACHED HERE.\n+/*    :   :   \u2503          */                 // ADD A COVERAGE REGION FOR THE SPAN FROM JUST AFTER PREVIOUS REGION TO END\n+/*    :   :   \u2503          */                 // OF OUTER SPAN, THEN TRUNCATE TO NEXT REGION NOT REACHED.\n+/*    :   :   \u2503   -      */                 if index % 3 == 2 { // NO __incr_cov() HERE BECAUSE NO STATEMENTS BETWEEN LAST CONDITIONAL BLOCK AND START OF THIS ONE\n+/*    :   : \u039b :   \u2503      */                     __incr_cov(from!(\"block end of `if condition2`\"),());\n+/*    :   : \u2517-----<      */                     continue;\n+/*    :   :   \u2503   -      */                 }\n+/*    :   :   \u2503          */                 println!(\"after `continue` test\");\n+/*    :   :   \u2503          */                 // maybe add a runtime flag for a possible `return` here?\n+/*    :   :   \u2503          */                 __incr_cov(from!(\"for loop\"),());\n+/*    :   \u2503   -          */             }\n+/*    :   \u2503              */             println!(\"after for loop\");\n+/*    :   \u2503              */             let result = if { // START OF NEW CONDITIONAL EXPRESSION. NEXT \"GUARANTEED\" COUNTER SHOULD COUNT FROM END OF LAST CONDITIONAL EXPRESSION\n+/*    :   \u2503              */                               // A \"GUARANTEED\" COUNTER CALL IS ONE THAT WILL BE CALLED REGARDLESS OF OTHER CONDITIONS. THIS INCLUDES:\n+/*    :   \u2503              */                               //   * A CONDITIONAL EXPRESSION THAT IS NOT A BLOCK (OR ANOTHER CONDITIONAL STATEMENT, WHICH WOULD CONTAIN A BLOCK)\n+/*    :   \u2503              */                               //   * OR IF THE NEXT CONDITIONAL EXPRESSION IS A BLOCK OR CONDITIONAL STATEMENT, THEN THE FIRST \"GUARANTEED\" COUNTER IN THAT BLOCK\n+/*    :   \u2503              */                               //   * END OF BLOCK IF THE BLOCK DOES NOT HAVE INNER CONDITIONAL EXPRESSIONS\n+/*    :   \u2503              */                               //   * BRANCHING STATEMENTS (`return`, `break`, `continue`) BY EITHER WRAPPING THE BRANCH STATEMENT NON-BLOCK EXPRESSION,\n+/*    :   \u2503              */                               //     OR PREPENDING A COUNTER WITH EMPTY TUPLE IF NO EXPRESSION, OR IF EXPRESSION IS A BLOCK, THEN THE NEXT \"GUARANTEED\"\n+/*    :   \u2503              */                               //     COUNTER CALL WITHIN THAT BLOCK.\n+/*    :   \u2503              */                               //   BASICALLY, CARRY THE START OF COVERAGE SPAN FORWARD UNTIL THE GUARANTEED COUNTER IS FOUND\n+/*    :   \u2503              */                 println!(\"after result = if ...\");\n+/*    :   \u2503       -      */                 if __incr_cov(from!(\"block end of `for` loop\"),condition2) {\n+/*    :   :       \u2503      */                     println!(\"before first return\");\n+/*  \u250f-:---:-------<      */                     return __incr_cov(from!(\"block start\"),Ok(()));\n+/*  V :   :       -      */                 } else if __incr_cov(from!(\"`else`\"),condition3) {\n+/*    :   :       \u2503      */                     // THE ABOVE COUNTER IS _NOT_ REALLY NECESSARY IF EXPRESSION IS GUARANTEED TO EXECUTE.\n+/*    :   :       \u2503      */                     // IF WE GET COUNTER IN `else if` BLOCK WE COVERED EXPRESSION.\n+/*    :   :       \u2503      */                     // IF WE GET TO ANY REMAINING `else` or `else if` BLOCK WE KNOW WE EVALUATED THIS CONDITION\n+/*    :   :       \u2503      */                     // AND ALL OTHERS UP TO THE EXECUTED BLOCK. BUT THE SPAN WOULD HAVE \"HOLES\" FOR UNEXECUTED BLOCKS.\n+/*    :   :       \u2503      */                     println!(\"not second return\");\n+/*  \u250f-:---:-------<      */                     return __incr_cov(from!(\"block start\"),Ok(()));\n+/*  V :   :       -      */                 } else {\n+/*    :   :       \u2503      */                     println!(\"not returning\");\n+/*    :   :       \u2503      */                     __incr_cov(from!(\"block start\"),false)\n+/*    :   :       -      */                 }\n+/*    :   \u2503              */                 // NO COUNTER HERE BECAUSE NO STATEMENTS AFTER CONDITIONAL BLOCK\n+/*    :   \u2503   -          */             } {\n+/*    :   :   \u2503          */                 println!(\"branched condition returned true\");\n+/*    :   :   \u2503          */                 __incr_cov(from!(\"\"),Ok(()))\n+/*    :   \u2503   -          */             } else if self.call_closure(\n+/*    :   :       -      */                     |closure_param| __incr_cov(from!(\"\"),\n+/*    :   :       \u2503   -  */                         if condition3 {\n+/*    :   :       :   \u2503  */                             println!(\"in closure, captured condition said to print the param {}\", closure_param);\n+/*    :   :       :   \u2503  */                             __incr_cov(from!(\"\"),false)\n+/*    :   :       \u2503   -  */                         } else {\n+/*    :   :       :   \u2503  */                             println!(\"in closure, captured condition was false\");\n+/*    :   :       :   \u2503  */                             __incr_cov(from!(\"\"),true)\n+/*    :   :       \u2503   -  */                         }\n+/*    :   :       -      */                     )\n+/*    :   :   -          */                 ) {\n+/*    :   :   \u2503          */                 println!(\"closure returned true\");\n+/*    :   :   \u2503          */                 __incr_cov(from!(\"\"),Err(Error::new(ErrorKind::Other, \"Result is error if closure returned true\")))\n+/*    :   \u2503   -          */             } else {\n+/*    :   :   \u2503          */                 println!(\"closure returned false\");\n+/*    :   :   \u2503          */                 __incr_cov(from!(\"\"),Err(Error::new(ErrorKind::Other, \"Result is error if closure returned false\")))\n+/*    :   \u2503   -          */             };\n+/*    :   \u2503              */             println!(\"bottom of function might be skipped if early `return`\");\n+/*    :   \u2503              */             __incr_cov(from!(\"if condition1\"),result)\n+/*    \u2503   -              */         } else {\n+/*    :   \u2503              */             println!(\"skipping everything in `various()`\");\n+/*    :   \u2503              */             __incr_cov(from!(\"\"),Ok(()))\n+/*    \u2503   -              */         }\n+/*    \u2503   -              */         // __incr_cov(from!(\"\"),0) // DO NOT COUNT IF NO STATEMENTS AFTER CONDITIONAL BLOCK. ALL COVERAGE IS ALREADY COUNTED\n+/*    -                  */     }\n+/*                       */ }\n+/*                       */\n+/*    -                  */ fn main() -> Result<(), std::io::Error> {\n+/*    \u2503                  */     //let mut status: u8 = 2;\n+/*    \u2503                  */     let mut status: u8 = 1;\n+/*    :       -          */     let result = if status < 2 &&\n+/*    :       \u2503          */             __incr_cov(from!(\"\"),{\n+/*    :       \u2503          */                 status -= 1;\n+/*    :       \u2503          */                 status == 0\n+/*    :   -   -          */             }) {\n+/*    :   \u2503              */         let test_struct = TestStruct::new_with_value(100);\n+/*    :   \u2503              */         let _ = test_struct.various();\n+/*  \u250f-:---<              */         return __incr_cov_and_report(from!(\"\"),Err(Error::new(ErrorKind::Other, format!(\"Error status {}\", status))))\n+/*  V :   -              */     } else {\n+/*    :   \u2503              */         let test_struct = TestStruct::new();\n+/*    :   \u2503              */         __incr_cov(from!(\"\"),test_struct.various())\n+/*    :   -              */     };\n+/*    \u2503                  */     println!(\"done\");\n+/*    \u2503                  */     __incr_cov_and_report(from!(\"\"),result) // function-scoped counter index = 0\n+/*    -                  */ }\n\\ No newline at end of file"}, {"sha": "8f4399ab51d09ab678346c503865f7623baabff6", "filename": "src/test/codegen/coverage-experiments/src/coverage_injection_test2.rs", "status": "added", "additions": 320, "deletions": 0, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fcoverage_injection_test2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fcoverage_injection_test2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fcoverage_injection_test2.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -0,0 +1,320 @@\n+/*                       */ use std::io::Error;\n+/*                       */ use std::io::ErrorKind;\n+/*                       */\n+/*                       */ /// Align Rust counter increment with with:\n+/*                       */ /// [\u2018llvm.instrprof.increment\u2019 Intrinsic](https://llvm.org/docs/LangRef.html#llvm-instrprof-increment-intrinsic)\n+/*                       */ ///\n+/*                       */ /// declare void @llvm.instrprof.increment(i8* <name>, i64 <hash>, i32 <num-counters>, i32 <index>)\n+/*                       */ ///\n+/*                       */ /// The first argument is a pointer to a global variable containing the name of the entity\n+/*                       */ /// being instrumented. This should generally be the (mangled) function name for a set of\n+/*                       */ /// counters.\n+/*                       */ ///\n+/*                       */ /// The second argument is a hash value that can be used by the consumer of the profile data\n+/*                       */ /// to detect changes to the instrumented source, and the third is the number of counters\n+/*                       */ /// associated with name. It is an error if hash or num-counters differ between two\n+/*                       */ /// instances of instrprof.increment that refer to the same name.\n+/*                       */ ///\n+/*                       */ /// The last argument refers to which of the counters for name should be incremented. It\n+/*                       */ /// should be a value between 0 and num-counters.\n+/*                       */ ///\n+/*                       */ /// # Arguments\n+/*                       */ ///\n+/*                       */ /// `mangled_fn_name` - &'static ref to computed and injected static str, using:\n+/*                       */ ///\n+/*                       */ ///     ```\n+/*                       */ ///     fn rustc_symbol_mangling::compute_symbol_name(\n+/*                       */ ///         tcx: TyCtxt<'tcx>,\n+/*                       */ ///         instance: Instance<'tcx>,\n+/*                       */ ///         compute_instantiating_crate: impl FnOnce() -> CrateNum,\n+/*                       */ ///     ) -> String\n+/*                       */ ///     ```\n+/*                       */ ///\n+/*                       */ /// `source_version_hash` - Compute hash based that only changes if there are \"significant\"\n+/*                       */ /// to control-flow inside the function.\n+/*                       */ ///\n+/*                       */ /// `num_counters` - The total number of counter calls [MAX(counter_index) + 1] within the\n+/*                       */ /// function.\n+/*                       */ ///\n+/*                       */ /// `counter_index` - zero-based counter index scoped by the function. (Ordering of\n+/*                       */ /// counters, relative to the source code location, is apparently not expected.)\n+/*                       */ ///\n+/*                       */ /// # Notes\n+/*                       */ ///\n+/*                       */ /// * The mangled_fn_name may not be computable until generics are monomorphized (see\n+/*                       */ ///   parameters required by rustc_symbol_mangling::compute_symbol_name).\n+/*                       */ /// * The version hash may be computable from AST analysis, and may not benefit from further\n+/*                       */ ///   lowering.\n+/*                       */ /// * num_counters depends on having already identified all counter insertion locations.\n+/*                       */ /// * counter_index can be computed at time of counter insertion (incrementally).\n+/*                       */ /// * Numeric parameters are signed to match the llvm increment intrinsic parameter types.\n+/*                       */ fn __lower_incr_cov(_mangled_fn_name: &'static str, _fn_version_hash: i64, _num_counters: i32, _counter_index: i32) {\n+/*                       */ }\n+/*                       */\n+/*                       */ /// A coverage counter implementation that will work as both an intermediate coverage\n+/*                       */ /// counting and reporting implementation at the AST-level only--for debugging and\n+/*                       */ /// development--but also serves as a \"marker\" to be replaced by calls to LLVM\n+/*                       */ /// intrinsic coverage counter APIs during the lowering process.\n+/*                       */ ///\n+/*                       */ /// Calls to this function will be injected automatically into the AST. When LLVM intrinsics\n+/*                       */ /// are enabled, the counter function calls that were injected into the AST serve as\n+/*                       */ /// placeholders, to be replaced by an alternative, such as:\n+/*                       */ ///\n+/*                       */ ///     * direct invocation of the `llvm.instrprof.increment()` intrinsic; or\n+/*                       */ ///     * the `__lower_incr_cov()` function, defined above, that would invoke the\n+/*                       */ ///       `llvm.instrprof.increment()` intrinsic; or\n+/*                       */ ///     * a similar expression wrapper, with the additional parameters (as defined above\n+/*                       */ ///       for `__lower_incr_cov()`, that invokes `llvm.instrprof.increment()` and returns the\n+/*                       */ ///       result of the wrapped expression)\n+/*                       */ ///\n+/*                       */ /// The first two options would require replacing the inlined wrapper call with something\n+/*                       */ /// like:\n+/*                       */ ///\n+/*                       */ /// ```\n+/*                       */ /// { let result = {expr}; __inlined_incr_cov(context, counter); result }\n+/*                       */ /// ```\n+/*                       */ ///\n+/*                       */ /// But if the lowering process is already unwrapping the inlined call to `__incr_cov()`, then\n+/*                       */ /// it may be a perfect opportunity to replace the function with one of these more\n+/*                       */ /// direct methods.\n+/*                       */ ///\n+/*                       */ #[inline(always)]\n+/*                       */ pub fn __incr_cov(region_loc: &str) {\n+/*                       */     // Either call the intermediate non-llvm coverage counter API or\n+/*                       */     // replace the call to this function with the expanded `__lower_incr_cov()` call.\n+/*                       */\n+/*                       */     // let _lock = increment_counter(counter);\n+/*                       */     println!(\"{}\", region_loc);\n+/*                       */ }\n+/*                       */\n+/*                       */ /// Write a report identifying each incremented counter and the number of times each counter\n+/*                       */ /// was incremented.\n+/*                       */ fn __report() {\n+/*                       */     println!(\"WRITE REPORT!\");\n+/*                       */ }\n+/*                       */\n+/*                       */ macro_rules! from {\n+/*                       */     ($from:expr) => { &format!(\"from: {}\\n  to: {}:{}:{}\", $from, file!(), line!(), column!()) };\n+/*                       */ }\n+/*                       */\n+/*                       */ #[derive(Debug)]\n+/*                       */ enum TestEnum {\n+/*                       */     Red,\n+/*                       */     Green,\n+/*                       */     Blue,\n+/*                       */ }\n+/*                       */\n+/*                       */ struct TestStruct {\n+/*                       */     field: i32,\n+/*                       */ }\n+/*                       */\n+/*                       */ // IMPORTANT! IS WRAPPING main() ENOUGH? OR DO I ALSO NEED TO WRAP THREAD FUNCTIONS, ASSUMING\n+/*                       */ // THEY ARE STILL RUNNING WITH MAIN EXITS? (IF THEY CAN). NOT SURE HOW RUST HANDLES THAT.\n+/*                       */\n+/*                       */ // I SUSPECT USING THREAD_LOCAL COUNTERS MAY NOT ACTUALLY BE AN OPTIMIZATION OVER MUTEX LOCKS,\n+/*                       */ // BUT MAYBE I SHOULD ASK.\n+/*                       */\n+/*                       */ impl TestStruct {\n+/*    -                  */     fn new() -> Self {\n+/*    \u2503                  */         let __result = Self::new_with_value(31415); // function-scoped counter index = 0\n+/*    \u2503                  */         __incr_cov(from!(\"fn new()\"));\n+/*    \u2503                  */         __result\n+/*    -                  */     }\n+/*                       */\n+/*    -                  */     fn new_with_value(field: i32) -> Self {\n+/*    \u2503                  */         let __result = Self {\n+/*    \u2503                  */             field,\n+/*    \u2503                  */         };\n+/*    \u2503                  */         __incr_cov(from!(\"fn new_with_value()\")); // function-scoped counter index = 0\n+/*    \u2503                  */         __result\n+/*    -                  */     }\n+/*                       */\n+/*                       */     fn call_closure<F>(&self, closure: F) -> bool\n+/*                       */     where\n+/*                       */         F: FnOnce(\n+/*                       */             i32,\n+/*                       */         ) -> bool,\n+/*    -                  */     {\n+/*    \u2503                  */         let __result = closure(123);\n+/*    \u2503                  */         __incr_cov(from!(\"fn call_closure()\")); // function-scoped counter index = 0\n+/*    \u2503                  */         __result\n+/*    -                  */     }\n+/*                       */\n+/*    -                  */     fn various(&self) -> Result<(),Error> {\n+/*    \u2503                  */         use TestEnum::*;\n+/*    \u2503                  */         let mut color = Red;\n+/*    \u2503                  */         let _ = color;\n+/*    \u2503                  */         color = Blue;\n+/*    \u2503                  */         let _ = color;\n+/*    \u2503                  */         color = Green;\n+/*    \u2503                  */         match { let __result = color; __incr_cov(from!(\"fn various\")); __result } { // function-scoped counter index = 0\n+/*    :                  */\n+/*    :                  */             // !!! RECORD SPAN FROM START OF INNERMOST CONTAINING BLOCK (THE FUNCTION IN THIS CASE) TO END OF MATCH EXPRESSION\n+/*    :                  */             // If `match`, `while`, `loop`, `for`, `if`, etc. expression has a `return`, `break`, or `continue`\n+/*    :                  */             // (if legal), then RECORD SPAN FROM START OF INNERMOST CONTAINING BLOCK TO END OF `return` EXPRESSION\n+/*    :                  */             // If the expression includes lazy booleans, nest calls to `__incr_cov()`.\n+/*    :   I              */             Red => {println!(\"roses\"); __incr_cov(from!(\"Red => or end of MatchArmGuard expression inside pattern, if any\"));}\n+/*    :   -              */             Green => {\n+/*    :   \u2503              */                 let spidey = 100;\n+/*    :   \u2503              */                 let goblin = 50;\n+/*    :   \u2503              */                 // if spidey > goblin {__incr_cov(from!(\"\"),{\n+/*    :   \u2503              */                 //     println!(\"what ev\");\n+/*    :   \u2503              */                 // })}\n+/*    :   \u2503              */                 // ACTUALLY, WRAPPING THE ENTIRE IF BLOCK IN `__incr_cov` IS NOT A GREAT GENERAL RULE.\n+/*    :   \u2503              */                 // JUST INSERTING A `return`, `break`, or `continue` IN THAT BLOCK (without an intermediate condition)\n+/*    :   \u2503              */                 // MAKES THE `__incr_cov()` CALL UNREACHABLE!\n+/*    :   \u2503              */                 // MY ORIGINAL SOLUTION WORKS BETTER (WRAP LAST EXPRESSION OR AFTER LAST SEMICOLON STATEMENT IN BLOCK)\n+/*    :   \u2503              */                 // UNLESS THE EXPRESSION IS NOT A BLOCK.\n+/*    :   \u2503   -          */                 if { let __result = spidey > goblin; __incr_cov(from!(\"Green => or end of MatchArmGuard expression inside pattern, if any\")); __result } {\n+/*    :   :   \u2503          */                     println!(\"spidey beats goblin\");\n+/*    :   :   \u2503          */                     __incr_cov(from!(\"block start\"));\n+/*    :   \u2503   -          */                 } else if { let __result = spidey == goblin; __incr_cov(from!(\"`else if` on this line\")); __result } {\n+/*    :   :   \u2503          */                     // COVERAGE NOTE: Do we mark only the expression span (that may be trivial, as in this case),\n+/*    :   :   \u2503          */                     // or associate it with the outer block, similar to how the `if` expression is associated with\n+/*    :   :   \u2503          */                     // the outer block? (Although it is a continuation, in a sense, it is discontiguous in this case,\n+/*    :   :   \u2503          */                     // so I think simpler to just make it its own coverage region.)\n+/*    :   :   \u2503          */                     println!(\"it's a draw\");\n+/*    :   :   \u2503          */                     __incr_cov(from!(\"block start\"));\n+/*    :   \u2503   -   -   -  */                 } else if if { let __result = true; __incr_cov(from!(\"`else if` on this line\")); __result } {\n+/*    :   :       :   \u2503  */                             // return __incr_cov(from!(\"after `if true`\"),Ok(()));\n+/*    :   :       :   \u2503  */                             // ACTUALLY, BECAUSE OF `return`, WE DO NOT RECORD THE `if true` EVEN THOUGH WE COVERED IT.\n+/*    :   :       :   \u2503  */                             // IN FACT, IF THIS NESTED CONDITIONAL IN A CONDITIONAL EXPRESSION WAS AN `if` (WITHOUT PRECEDING ELSE)\n+/*    :   :       :   \u2503  */                             // WE WOULD NOT HAVE RECORDED THE COVERAGE OF STATEMENTS LEADING UP TO THE `if`, SO\n+/*    :   :       :   \u2503  */                             // IT SHOULD BE:\n+/*  \u250f-:---:-------:---<  */                             return { let __result = Ok(()); __incr_cov(from!(\"\")); __result };\n+/*  V :   :       :   :  */                             // NOTE THE `from` STRING IS SAME FOR THE `else if`s `__incr_cov` AND THIS `return`.\n+/*    :   :       :   :  */                             // ONLY ONE OF THESE WILL EXECUTE, TO RECORD COVERAGE FROM THAT SPOT.\n+/*    :   :       \u2503   -  */                         } else {\n+/*    :   :       :   I  */                             { let __result = false; __incr_cov(from!(\"`else`\")); __result }\n+/*    :   :   -   -      */                         } {\n+/*    :   :   \u2503          */                     println!(\"wierd science\");\n+/*    :   :   \u2503          */                     __incr_cov(from!(\"block start\"));\n+/*    :   \u2503   -          */                 } else {\n+/*    :   :   \u2503          */                     println!(\"goblin wins\");\n+/*  \u250f-:---:---<          */                     return { let __result = Ok(()); __incr_cov(from!(\"`else`\")); __result }; // THIS COUNTS LAST STATEMENT IN `else` BLOCK\n+/*  V :   :   :          */                     // COVERAGE NOTE: When counting the span for `return`,\n+/*    :   :   :          */                     // `break`, or `continue`, also report the outer spans\n+/*    :   :   :          */                     // got this far--including this `else` block. Record\n+/*    :   :   :          */                     // The start positions for those outer blocks, but:\n+/*    :   :   :          */                     // * For the block containing the `return`, `break`, or\n+/*    :   :   :          */                     //   `continue`, end report the end position is the\n+/*    :   :   :          */                     //   start of the `return` span (or 1 char before it).\n+/*    :   :   :          */                     // * Anything else?\n+/*    :   \u2503   -          */                 }\n+/*    :   \u2503   -          */                 // __incr_cov(from!(\"\")); // DO NOT COUNT HERE IF NO STATEMENTS AFTER LAST `if` or `match`\n+/*    :   -              */             },\n+/*    :   I              */             Blue => { println!(\"violets\"); __incr_cov(from!(\"Blue => or end of MatchArmGuard expression inside pattern, if any\")); }\n+/*    \u2503                  */         }\n+/*    \u2503                  */\n+/*    \u2503                  */         let condition1 = true;\n+/*    \u2503                  */         let condition2 = false;\n+/*    \u2503                  */         let condition3 = true;\n+/*    \u2503                  */\n+/*    \u2503                  */         println!(\"Called `various()` for TestStruct with field={}\", self.field);\n+/*    \u2503                  */\n+/*    \u2503   -              */         if { let __result = condition1; __incr_cov(from!(\"after block end of prior `match` (or `if-else if-else`)\")); __result } {\n+/*    :   \u2503              */             println!(\"before for loop\");\n+/*    :   \u2503   -          */             for index in { let __result = 0..10; __incr_cov(from!(\"block start\")); __result } {\n+/*    :   :   \u2503          */                 println!(\"top of `for` loop\");\n+/*    :   :   \u2503   -      */                 if { let __result = index == 8; __incr_cov(from!(\"block start\")); __result } {\n+/*    :   :   :   \u2503      */                     println!(\"before break\");\n+/*    :   :   :   \u2503      */                     // note the following is not legal here:\n+/*    :   :   :   \u2503      */                     //   \"can only break with a value inside `loop` or breakable block\"\n+/*    :   :   :   \u2503      */                     // break __incr_cov(from!(\"\"));\n+/*    :   :   :   \u2503      */                     __incr_cov(from!(\"block start\"));\n+/*    :   : \u250f-----<      */                     break;\n+/*    :   : V :   :      */\n+/*    :   :   :   :      */                     // FIXME(richkadel): add examples with loop labels, breaking out of inner and outer loop to outer loop label, with expression.\n+/*    :   :   :   :      */                     // May want to record both the span and the start position after the broken out block depdnding on label\n+/*    :   :   \u2503   -      */                 }\n+/*    :   :   \u2503          */                 println!(\"after `break` test\");\n+/*    :   :   \u2503   -      */                 if { let __result = condition2; __incr_cov(from!(\"block end of `if index == 8`\")); __result } {\n+/*  \u250f-:---:---:---<      */                     return { let __result = Ok(()); __incr_cov(from!(\"block start\")); __result };\n+/*  V :   :   \u2503   -      */                 }\n+/*    :   :   \u2503          */\n+/*    :   :   \u2503          */                 // BECAUSE THE PREVIOUS COVERAGE REGION HAS A `return`, THEN\n+/*    :   :   \u2503          */                 // IF PREVIOUS COVERAGE REGION IS NOT COUNTED THEN OUTER REGION REACHED HERE.\n+/*    :   :   \u2503          */                 // ADD A COVERAGE REGION FOR THE SPAN FROM JUST AFTER PREVIOUS REGION TO END\n+/*    :   :   \u2503          */                 // OF OUTER SPAN, THEN TRUNCATE TO NEXT REGION NOT REACHED.\n+/*    :   :   \u2503   -      */                 if index % 3 == 2 { // NO __incr_cov() HERE BECAUSE NO STATEMENTS BETWEEN LAST CONDITIONAL BLOCK AND START OF THIS ONE\n+/*    :   : \u039b :   \u2503      */                     __incr_cov(from!(\"block end of `if condition2`\"));\n+/*    :   : \u2517-----<      */                     continue;\n+/*    :   :   \u2503   -      */                 }\n+/*    :   :   \u2503          */                 println!(\"after `continue` test\");\n+/*    :   :   \u2503          */                 // maybe add a runtime flag for a possible `return` here?\n+/*    :   :   \u2503          */                 __incr_cov(from!(\"\"));\n+/*    :   \u2503   -          */             }\n+/*    :   \u2503              */             println!(\"after for loop\");\n+/*    :   \u2503              */             let result = if { // START OF NEW CONDITIONAL EXPRESSION. NEXT \"GUARANTEED\" COUNTER SHOULD COUNT FROM END OF LAST CONDITIONAL EXPRESSION\n+/*    :   \u2503              */                               // A \"GUARANTEED\" COUNTER CALL IS ONE THAT WILL BE CALLED REGARDLESS OF OTHER CONDITIONS. THIS INCLUDES:\n+/*    :   \u2503              */                               //   * A CONDITIONAL EXPRESSION THAT IS NOT A BLOCK (OR ANOTHER CONDITIONAL STATEMENT, WHICH WOULD CONTAIN A BLOCK)\n+/*    :   \u2503              */                               //   * OR IF THE NEXT CONDITIONAL EXPRESSION IS A BLOCK OR CONDITIONAL STATEMENT, THEN THE FIRST \"GUARANTEED\" COUNTER IN THAT BLOCK\n+/*    :   \u2503              */                               //   * END OF BLOCK IF THE BLOCK DOES NOT HAVE INNER CONDITIONAL EXPRESSIONS\n+/*    :   \u2503              */                               //   * BRANCHING STATEMENTS (`return`, `break`, `continue`) BY EITHER WRAPPING THE BRANCH STATEMENT NON-BLOCK EXPRESSION,\n+/*    :   \u2503              */                               //     OR PREPENDING A COUNTER WITH EMPTY TUPLE IF NO EXPRESSION, OR IF EXPRESSION IS A BLOCK, THEN THE NEXT \"GUARANTEED\"\n+/*    :   \u2503              */                               //     COUNTER CALL WITHIN THAT BLOCK.\n+/*    :   \u2503              */                               //   BASICALLY, CARRY THE START OF COVERAGE SPAN FORWARD UNTIL THE GUARANTEED COUNTER IS FOUND\n+/*    :   \u2503              */                 println!(\"after result = if ...\");\n+/*    :   \u2503       -      */                 if { let __result = condition2; __incr_cov(from!(\"block end of `for` loop\")); __result } {\n+/*    :   :       \u2503      */                     println!(\"before first return\");\n+/*  \u250f-:---:-------<      */                     return { let __result = Ok(()); __incr_cov(from!(\"block start\")); __result };\n+/*  V :   :       -      */                 } else if { let __result = condition3; __incr_cov(from!(\"`else`\")); __result } {\n+/*    :   :       \u2503      */                     // THE ABOVE COUNTER IS _NOT_ REALLY NECESSARY IF EXPRESSION IS GUARANTEED TO EXECUTE.\n+/*    :   :       \u2503      */                     // IF WE GET COUNTER IN `else if` BLOCK WE COVERED EXPRESSION.\n+/*    :   :       \u2503      */                     // IF WE GET TO ANY REMAINING `else` or `else if` BLOCK WE KNOW WE EVALUATED THIS CONDITION\n+/*    :   :       \u2503      */                     // AND ALL OTHERS UP TO THE EXECUTED BLOCK. BUT THE SPAN WOULD HAVE \"HOLES\" FOR UNEXECUTED BLOCKS.\n+/*    :   :       \u2503      */                     println!(\"not second return\");\n+/*  \u250f-:---:-------<      */                     return { let __result = Ok(()); __incr_cov(from!(\"block start\")); __result };\n+/*  V :   :       -      */                 } else {\n+/*    :   :       \u2503      */                     println!(\"not returning\");\n+/*    :   :       \u2503      */                     { let __result = false; __incr_cov(from!(\"block start\")); __result }\n+/*    :   :       -      */                 }\n+/*    :   \u2503              */                 // NO COUNTER HERE BECAUSE NO STATEMENTS AFTER CONDITIONAL BLOCK\n+/*    :   \u2503   -          */             } {\n+/*    :   :   \u2503          */                 println!(\"branched condition returned true\");\n+/*    :   :   \u2503          */                 { let __result = Ok(()); __incr_cov(from!(\"\")); __result }\n+/*    :   \u2503   -          */             } else if self.call_closure(\n+/*    :   :       -      */                     |closure_param| {\n+/*    :   :       \u2503   -  */                         let __result = if condition3 {\n+/*    :   :       :   \u2503  */                             println!(\"in closure, captured condition said to print the param {}\", closure_param);\n+/*    :   :       :   \u2503  */                             { let __result = false; __incr_cov(from!(\"\")); __result }\n+/*    :   :       \u2503   -  */                         } else {\n+/*    :   :       :   \u2503  */                             println!(\"in closure, captured condition was false\");\n+/*    :   :       :   \u2503  */                             { let __result = true; __incr_cov(from!(\"\")); __result }\n+/*    :   :       \u2503   -  */                         };\n+/*    :   :       -      */                         __incr_cov(from!(\"\")); __result }\n+/*    :   :   -          */                 ) {\n+/*    :   :   \u2503          */                 println!(\"closure returned true\");\n+/*    :   :   \u2503          */                 { let __result = Err(Error::new(ErrorKind::Other, \"Result is error if closure returned true\")); __incr_cov(from!(\"\")); __result }\n+/*    :   \u2503   -          */             } else {\n+/*    :   :   \u2503          */                 println!(\"closure returned false\");\n+/*    :   :   \u2503          */                 { let __result = Err(Error::new(ErrorKind::Other, \"Result is error if closure returned false\")); __incr_cov(from!(\"\")); __result }\n+/*    :   \u2503   -          */             };\n+/*    :   \u2503              */             println!(\"bottom of function might be skipped if early `return`\");\n+/*    :   \u2503              */             { let __result = result; __incr_cov(from!(\"if condition1\")); __result }\n+/*    \u2503   -              */         } else {\n+/*    :   \u2503              */             println!(\"skipping everything in `various()`\");\n+/*    :   \u2503              */             { let __result = Ok(()); __incr_cov(from!(\"\")); __result }\n+/*    \u2503   -              */         }\n+/*    \u2503   -              */         // __incr_cov(from!(\"\"),0) // DO NOT COUNT IF NO STATEMENTS AFTER CONDITIONAL BLOCK. ALL COVERAGE IS ALREADY COUNTED\n+/*    -                  */     }\n+/*                       */ }\n+/*                       */\n+/*    -                  */ fn main() -> Result<(), std::io::Error> {\n+/*    \u2503                  */     //let mut status: u8 = 2;\n+/*    \u2503                  */     let mut status: u8 = 1;\n+/*    :       -          */     let result = if status < 2 &&\n+/*    :       \u2503          */             { let __result = {\n+/*    :       \u2503          */                 status -= 1;\n+/*    :       \u2503          */                 status == 0\n+/*    :   -   -          */             }; __incr_cov(from!(\"\")); __result } {\n+/*    :   \u2503              */         let test_struct = TestStruct::new_with_value(100);\n+/*    :   \u2503              */         let _ = test_struct.various();\n+/*  \u250f-:---<              */         return { let __result = Err(Error::new(ErrorKind::Other, format!(\"Error status {}\", status))); __incr_cov(from!(\"\")); __report(); __result }\n+/*  V :   -              */     } else {\n+/*    :   \u2503              */         let test_struct = TestStruct::new();\n+/*    :   \u2503              */         { let __result = test_struct.various(); __incr_cov(from!(\"\")); __result }\n+/*    :   -              */     };\n+/*    \u2503                  */     println!(\"done\");\n+/*    \u2503                  */     { let __result = result; __incr_cov(from!(\"\")); __report(); __result }\n+/*    -                  */ }\n\\ No newline at end of file"}, {"sha": "20c4835dd882ec0201785ac0d8e0a8f26b9e7991", "filename": "src/test/codegen/coverage-experiments/src/coverage_injection_test_alt.rs", "status": "added", "additions": 362, "deletions": 0, "changes": 362, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fcoverage_injection_test_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fcoverage_injection_test_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fcoverage_injection_test_alt.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -0,0 +1,362 @@\n+/*                       */ use std::io::Error;\n+/*                       */ use std::io::ErrorKind;\n+/*                       */\n+/*                       */ /// Align Rust counter increment with with:\n+/*                       */ /// [\u2018llvm.instrprof.increment\u2019 Intrinsic](https://llvm.org/docs/LangRef.html#llvm-instrprof-increment-intrinsic)\n+/*                       */ ///\n+/*                       */ /// declare void @llvm.instrprof.increment(i8* <name>, i64 <hash>, i32 <num-counters>, i32 <index>)\n+/*                       */ ///\n+/*                       */ /// The first argument is a pointer to a global variable containing the name of the entity\n+/*                       */ /// being instrumented. This should generally be the (mangled) function name for a set of\n+/*                       */ /// counters.\n+/*                       */ ///\n+/*                       */ /// The second argument is a hash value that can be used by the consumer of the profile data\n+/*                       */ /// to detect changes to the instrumented source, and the third is the number of counters\n+/*                       */ /// associated with name. It is an error if hash or num-counters differ between two\n+/*                       */ /// instances of instrprof.increment that refer to the same name.\n+/*                       */ ///\n+/*                       */ /// The last argument refers to which of the counters for name should be incremented. It\n+/*                       */ /// should be a value between 0 and num-counters.\n+/*                       */ ///\n+/*                       */ /// # Arguments\n+/*                       */ ///\n+/*                       */ /// `mangled_fn_name` - &'static ref to computed and injected static str, using:\n+/*                       */ ///\n+/*                       */ ///     ```\n+/*                       */ ///     fn rustc_symbol_mangling::compute_symbol_name(\n+/*                       */ ///         tcx: TyCtxt<'tcx>,\n+/*                       */ ///         instance: Instance<'tcx>,\n+/*                       */ ///         compute_instantiating_crate: impl FnOnce() -> CrateNum,\n+/*                       */ ///     ) -> String\n+/*                       */ ///     ```\n+/*                       */ ///\n+/*                       */ /// `source_version_hash` - Compute hash based that only changes if there are \"significant\"\n+/*                       */ /// to control-flow inside the function.\n+/*                       */ ///\n+/*                       */ /// `num_counters` - The total number of counter calls [MAX(counter_index) + 1] within the\n+/*                       */ /// function.\n+/*                       */ ///\n+/*                       */ /// `counter_index` - zero-based counter index scoped by the function. (Ordering of\n+/*                       */ /// counters, relative to the source code location, is apparently not expected.)\n+/*                       */ ///\n+/*                       */ /// # Notes\n+/*                       */ ///\n+/*                       */ /// * The mangled_fn_name may not be computable until generics are monomorphized (see\n+/*                       */ ///   parameters required by rustc_symbol_mangling::compute_symbol_name).\n+/*                       */ /// * The version hash may be computable from AST analysis, and may not benefit from further\n+/*                       */ ///   lowering.\n+/*                       */ /// * num_counters depends on having already identified all counter insertion locations.\n+/*                       */ /// * counter_index can be computed at time of counter insertion (incrementally).\n+/*                       */ /// * Numeric parameters are signed to match the llvm increment intrinsic parameter types.\n+/*                       */ fn __lower_incr_cov(_mangled_fn_name: &'static str, _fn_version_hash: i64, _num_counters: i32, _counter_index: i32) {\n+/*                       */ }\n+/*                       */\n+/*                       */ /// A coverage counter implementation that will work as both an intermediate coverage\n+/*                       */ /// counting and reporting implementation at the AST-level only--for debugging and\n+/*                       */ /// development--but also serves as a \"marker\" to be replaced by calls to LLVM\n+/*                       */ /// intrinsic coverage counter APIs during the lowering process.\n+/*                       */ ///\n+/*                       */ /// Calls to this function will be injected automatically into the AST. When LLVM intrinsics\n+/*                       */ /// are enabled, the counter function calls that were injected into the AST serve as\n+/*                       */ /// placeholders, to be replaced by an alternative, such as:\n+/*                       */ ///\n+/*                       */ ///     * direct invocation of the `llvm.instrprof.increment()` intrinsic; or\n+/*                       */ ///     * the `__lower_incr_cov()` function, defined above, that would invoke the\n+/*                       */ ///       `llvm.instrprof.increment()` intrinsic; or\n+/*                       */ ///     * a similar expression wrapper, with the additional parameters (as defined above\n+/*                       */ ///       for `__lower_incr_cov()`, that invokes `llvm.instrprof.increment()` and returns the\n+/*                       */ ///       result of the wrapped expression)\n+/*                       */ ///\n+/*                       */ /// The first two options would require replacing the inlined wrapper call with something\n+/*                       */ /// like:\n+/*                       */ ///\n+/*                       */ /// ```\n+/*                       */ /// { let result = {expr}; __inlined_incr_cov(context, counter); result }\n+/*                       */ /// ```\n+/*                       */ ///\n+/*                       */ /// But if the lowering process is already unwrapping the inlined call to `__incr_cov()`, then\n+/*                       */ /// it may be a perfect opportunity to replace the function with one of these more\n+/*                       */ /// direct methods.\n+/*                       */ ///\n+/*                       */ #[inline(always)]\n+/*                       */ pub fn __incr_cov(region_loc: &str, /*index: u32,*/) {\n+/*                       */     // Either call the intermediate non-llvm coverage counter API or\n+/*                       */     // replace the call to this function with the expanded `__lower_incr_cov()` call.\n+/*                       */\n+/*                       */     // let _lock = increment_counter(counter);\n+/*                       */     println!(\"{}\", region_loc);\n+/*                       */ }\n+/*                       */\n+/*                       */ /// Write a report identifying each incremented counter and the number of times each counter\n+/*                       */ /// was incremented.\n+/*                       */ fn __report() {\n+/*                       */     println!(\"WRITE REPORT!\");\n+/*                       */ }\n+/*                       */\n+/*                       */ /// Increment the counter after evaluating the wrapped expression (see `__incr_cov()`), then\n+/*                       */ /// write a report identifying each incremented counter and the number of times each counter\n+/*                       */ /// was incremented.\n+/*                       */ #[inline(always)]\n+/*                       */ pub fn __incr_cov_and_report<T>(region_loc: &str, /*counter: u32,*/ result: T) -> T {\n+/*                       */     __incr_cov(region_loc, /*counter,*/);\n+/*                       */     __report();\n+/*                       */     result\n+/*                       */ }\n+/*                       */\n+/*                       */ macro_rules! from {\n+/*                       */     ($from:expr) => { &format!(\"from: {}\\n  to: {}:{}:{}\", $from, file!(), line!(), column!()) };\n+/*                       */ }\n+/*                       */\n+/*                       */ macro_rules! to {\n+/*                       */     ($to:expr) => { &format!(\"to: {}\\n  to: {}:{}:{}\", $to, file!(), line!(), column!()) };\n+/*                       */ }\n+/*                       */\n+/*                       */ #[derive(Debug)]\n+/*                       */ enum TestEnum {\n+/*                       */     Red,\n+/*                       */     Green,\n+/*                       */     Blue,\n+/*                       */ }\n+/*                       */\n+/*                       */ struct TestStruct {\n+/*                       */     field: i32,\n+/*                       */ }\n+/*                       */\n+/*                       */ // IMPORTANT! IS WRAPPING main() ENOUGH? OR DO I ALSO NEED TO WRAP THREAD FUNCTIONS, ASSUMING\n+/*                       */ // THEY ARE STILL RUNNING WITH MAIN EXITS? (IF THEY CAN). NOT SURE HOW RUST HANDLES THAT.\n+/*                       */\n+/*                       */ // I SUSPECT USING THREAD_LOCAL COUNTERS MAY NOT ACTUALLY BE AN OPTIMIZATION OVER MUTEX LOCKS,\n+/*                       */ // BUT MAYBE I SHOULD ASK.\n+/*                       */\n+/*                       */ impl TestStruct {\n+/*    -                  */     fn new() -> Self {\n+/*    \u2503                  */         __incr_cov(to!(\"end of fn new()\")); // function-scoped counter index = 0\n+/*    \u2503                  */         Self::new_with_value(31415)\n+/*    -                  */     }\n+/*                       */\n+/*    -                  */     fn new_with_value(field: i32) -> Self {\n+/*    \u2503                  */         __incr_cov(to!(\"end of fn new_with_value()\")); // function-scoped counter index = 0\n+/*    \u2503                  */         Self {\n+/*    \u2503                  */             field,\n+/*    \u2503                  */         }\n+/*    -                  */     }\n+/*                       */\n+/*                       */     fn call_closure<F>(&self, closure: F) -> bool\n+/*                       */     where\n+/*                       */         F: FnOnce(\n+/*                       */             i32,\n+/*                       */         ) -> bool,\n+/*    -                  */     {\n+/*    \u2503                  */         __incr_cov(to!(\"end of fn call_closure()\")); // function-scoped counter index = 0\n+/*    \u2503                  */         closure(123)\n+/*    -                  */     }\n+/*                       */\n+/*    -                  */     fn various(&self) -> Result<(),Error> {\n+/*    \u2503                  */         __incr_cov(to!(\"just before next branch: after `match color`: pattern selection\"));\n+/*    \u2503                  */         use TestEnum::*;\n+/*    \u2503                  */         let mut color = Red;\n+/*    \u2503                  */         let _ = color;\n+/*    \u2503                  */         color = Blue;\n+/*    \u2503                  */         let _ = color;\n+/*    \u2503                  */         color = Green;\n+/*    \u2503                  */         match color { // function-scoped counter index = 0\n+/*    :                  */\n+/*    :                  */             // !!! RECORD SPAN FROM START OF INNERMOST CONTAINING BLOCK (THE FUNCTION IN THIS CASE) TO END OF MATCH EXPRESSION\n+/*    :                  */             // If `match`, `while`, `loop`, `for`, `if`, etc. expression has a `return`, `break`, or `continue`\n+/*    :                  */             // (if legal), then RECORD SPAN FROM START OF INNERMOST CONTAINING BLOCK TO END OF `return` EXPRESSION\n+/*    :                  */             // If the expression includes lazy booleans, nest calls to `__incr_cov()`.\n+/*    :   -              */             Red => {\n+/*    :   \u2503              */                 __incr_cov(to!(\"end of matched Red\"));\n+/*    :   \u2503              */                 println!(\"roses\");\n+/*    :   -              */             }\n+/*    :   -              */             Green => {\n+/*    :   \u2503              */                 __incr_cov(to!(\"just before next branch: after `if spidey > goblin`\"));\n+/*    :   \u2503              */                 let spidey = 100;\n+/*    :   \u2503              */                 let goblin = 50;\n+/*    :   \u2503              */                 // if spidey > goblin {__incr_cov(from!(\"\"),{\n+/*    :   \u2503              */                 //     println!(\"what ev\");\n+/*    :   \u2503              */                 // })}\n+/*    :   \u2503              */                 // ACTUALLY, WRAPPING THE ENTIRE IF BLOCK IN `__incr_cov` IS NOT A GREAT GENERAL RULE.\n+/*    :   \u2503              */                 // JUST INSERTING A `return`, `break`, or `continue` IN THAT BLOCK (without an intermediate condition)\n+/*    :   \u2503              */                 // MAKES THE `__incr_cov()` CALL UNREACHABLE!\n+/*    :   \u2503              */                 // MY ORIGINAL SOLUTION WORKS BETTER (WRAP LAST EXPRESSION OR AFTER LAST SEMICOLON STATEMENT IN BLOCK)\n+/*    :   \u2503              */                 // UNLESS THE EXPRESSION IS NOT A BLOCK.\n+/*    :   \u2503   -          */                 if spidey > goblin {\n+/*    :   :   \u2503          */                     __incr_cov(to!(\"end of if block, if no earlier branch in this scope\"));\n+/*    :   :   \u2503          */                     println!(\"spidey beats goblin\");\n+/*    :   :   \u2503          */\n+/*    :   \u2503   -          */                 } else if {\n+/*    :   :   :          */                     // Make sure we can't compute the coverage count here.\n+/*    :   :   :          */                     // We know the expression executed if the previous if block DID NOT\n+/*    :   :   :          */                     // execute, and either this `else if` block does execute OR any subsequent\n+/*    :   :   :          */                     // `else if` or `else` blocks execute, OR none of the blocks in the\n+/*    :   :   :          */                     // `if`, `else if` or `else` blocks execute.\n+/*    :   :   :          */                     // `if`, `else if` or `else` blocks execute.\n+/*    :   :   \u2503          */                     __incr_cov(to!(\"end of `else if spidey == goblin` expression\"));\n+/*    :   :   \u2503          */                     spidey == goblin\n+/*    :   \u2503   -          */                 } {\n+/*    :   :   \u2503          */                     __incr_cov(to!(\"end of if block, if no earlier branch in this scope\"));\n+/*    :   :   \u2503          */                     // COVERAGE NOTE: Do we mark only the expression span (that may be trivial, as in this case),\n+/*    :   :   \u2503          */                     // or associate it with the outer block, similar to how the `if` expression is associated with\n+/*    :   :   \u2503          */                     // the outer block? (Although it is a continuation, in a sense, it is discontiguous in this case,\n+/*    :   :   \u2503          */                     // so I think simpler to just make it its own coverage region.)\n+/*    :   :   \u2503          */                     println!(\"it's a draw\");\n+/*    :   :   \u2503          */\n+/*    :   \u2503   -   -   -  */                 } else if {\n+/*    :   :   \u2503          */                         __incr_cov(to!(\"end of `if true`\"));\n+/*    :   \u2503   -   -   -  */                         if true {\n+/*    :   :       :   \u2503  */                             __incr_cov(to!(\"end of `return Ok(())`\"));\n+/*  \u250f-:---:-------:---<  */                             return Ok(());\n+/*  V :   :       \u2503   -  */                         } else {\n+/*    :   :       :   \u2503  */                             // __incr_cov(to!(\"end of else block\"));\n+/*    :   :       :   \u2503  */                             // computed counter expression\n+/*    :   :       :   \u2503  */                             false\n+/*    :   :       :   -  */                         }\n+/*    :   :   -   -   -  */                     } {\n+/*    :   :   \u2503          */                     __incr_cov(to!(\"end of if block\"));\n+/*    :   :   \u2503          */                     println!(\"wierd science\");\n+/*    :   \u2503   -          */                 } else {\n+/*    :   :   \u2503          */                     // __incr_cov(to!(\"end of `return Ok(())\"));\n+/*    :   :   \u2503          */                     // counter expression: (start of Green match arm) - (if spidey > goblin) - (previous `} else if {`)\n+/*    :   :   \u2503          */                     println!(\"goblin wins\");\n+/*  \u250f-:---:---<          */                     return Ok(()); // THIS COUNTS LAST STATEMENT IN `else` BLOCK\n+/*  V :   :   :          */                     // COVERAGE NOTE: When counting the span for `return`,\n+/*    :   :   :          */                     // `break`, or `continue`, also report the outer spans\n+/*    :   :   :          */                     // got this far--including this `else` block. Record\n+/*    :   :   :          */                     // The start positions for those outer blocks, but:\n+/*    :   :   :          */                     // * For the block containing the `return`, `break`, or\n+/*    :   :   :          */                     //   `continue`, end report the end position is the\n+/*    :   :   :          */                     //   start of the `return` span (or 1 char before it).\n+/*    :   :   :          */                     // * Anything else?\n+/*    :   \u2503   -          */                 }\n+/*    :   :              */                 // __incr_cov(to!(\"end of matched Green\"));\n+/*    :   :              */                 //  // DO NOT COUNT HERE IF NO STATEMENTS AFTER LAST `if` or `match`\n+/*    :   -              */             },\n+/*    :   -              */             Blue => {\n+/*    :   \u2503              */                 __incr_cov(to!(\"end of matched Blue\"));\n+/*    :   \u2503              */                 println!(\"violets\");\n+/*    :   -              */             }\n+/*    \u2503                  */         }\n+/*    \u2503                  */         __incr_cov(to!(\"just before next branch: after `if condition1` (HIR: 'match condition1')\"));\n+/*    \u2503                  */\n+/*    \u2503                  */         let condition1 = true;\n+/*    \u2503                  */         let condition2 = false;\n+/*    \u2503                  */         let condition3 = true;\n+/*    \u2503                  */\n+/*    \u2503                  */         println!(\"Called `various()` for TestStruct with field={}\", self.field);\n+/*    \u2503                  */\n+/*    \u2503   -              */         if condition1 {\n+/*    :   \u2503              */             println!(\"before while loop\");\n+/*    :   \u2503              */             let mut countdown = 10;\n+/*    :   \u2503              */              // Must increment before repeated while text expression\n+/*    :   :   I          */             while  countdown > 0 { // span is just the while test expression\n+/*    :   :   \u2503          */                 println!(\"top of `while` loop\");\n+/*    :   :   \u2503          */                 countdown -= 1;\n+/*    :   :   \u2503          */                 //  // Counter not needed, but span is computed as \"while test\" minus \"block start\"\n+/*    :   :   \u2503          */                                                        // If test expression is 11, and the outer block runs only once, 11-1 = 10\n+/*    :   \u2503   -          */             }\n+/*    :   \u2503              */             println!(\"before for loop\");\n+/*    :   \u2503   -          */             for index in 0..10 {\n+/*    :   :   \u2503          */                 println!(\"top of `for` loop\");\n+/*    :   :   \u2503   -      */                 if index == 8 {\n+/*    :   :   :   \u2503      */                     println!(\"before break\");\n+/*    :   :   :   \u2503      */                     // note the following is not legal here:\n+/*    :   :   :   \u2503      */                     //   \"can only break with a value inside `loop` or breakable block\"\n+/*    :   :   :   \u2503      */                     // break\n+/*    :   :   :   \u2503      */\n+/*    :   : \u250f-----<      */                     break;\n+/*    :   : V :   :      */\n+/*    :   :   :   :      */                     // FIXME(richkadel): add examples with loop labels, breaking out of inner and outer loop to outer loop label, with expression.\n+/*    :   :   :   :      */                     // May want to record both the span and the start position after the broken out block depdnding on label\n+/*    :   :   \u2503   -      */                 }\n+/*    :   :   \u2503          */                 println!(\"after `break` test\");\n+/*    :   :   \u2503   -      */                 if condition2 {\n+/*  \u250f-:---:---:---<      */                     return Ok(());\n+/*  V :   :   \u2503   -      */                 }\n+/*    :   :   \u2503          */\n+/*    :   :   \u2503          */                 // BECAUSE THE PREVIOUS COVERAGE REGION HAS A `return`, THEN\n+/*    :   :   \u2503          */                 // IF PREVIOUS COVERAGE REGION IS NOT COUNTED THEN OUTER REGION REACHED HERE.\n+/*    :   :   \u2503          */                 // ADD A COVERAGE REGION FOR THE SPAN FROM JUST AFTER PREVIOUS REGION TO END\n+/*    :   :   \u2503          */                 // OF OUTER SPAN, THEN TRUNCATE TO NEXT REGION NOT REACHED.\n+/*    :   :   \u2503   -      */                 if index % 3 == 2 { // NO __incr_cov() HERE BECAUSE NO STATEMENTS BETWEEN LAST CONDITIONAL BLOCK AND START OF THIS ONE\n+/*    :   : \u039b :   \u2503      */\n+/*    :   : \u2517-----<      */                     continue;\n+/*    :   :   \u2503   -      */                 }\n+/*    :   :   \u2503          */                 println!(\"after `continue` test\");\n+/*    :   :   \u2503          */                 // maybe add a runtime flag for a possible `return` here?\n+/*    :   :   \u2503          */\n+/*    :   \u2503   -          */             }\n+/*    :   \u2503              */             println!(\"after for loop\");\n+/*    :   \u2503              */             let result = if { // START OF NEW CONDITIONAL EXPRESSION. NEXT \"GUARANTEED\" COUNTER SHOULD COUNT FROM END OF LAST CONDITIONAL EXPRESSION\n+/*    :   \u2503              */                               // A \"GUARANTEED\" COUNTER CALL IS ONE THAT WILL BE CALLED REGARDLESS OF OTHER CONDITIONS. THIS INCLUDES:\n+/*    :   \u2503              */                               //   * A CONDITIONAL EXPRESSION THAT IS NOT A BLOCK (OR ANOTHER CONDITIONAL STATEMENT, WHICH WOULD CONTAIN A BLOCK)\n+/*    :   \u2503              */                               //   * OR IF THE NEXT CONDITIONAL EXPRESSION IS A BLOCK OR CONDITIONAL STATEMENT, THEN THE FIRST \"GUARANTEED\" COUNTER IN THAT BLOCK\n+/*    :   \u2503              */                               //   * END OF BLOCK IF THE BLOCK DOES NOT HAVE INNER CONDITIONAL EXPRESSIONS\n+/*    :   \u2503              */                               //   * BRANCHING STATEMENTS (`return`, `break`, `continue`) BY EITHER WRAPPING THE BRANCH STATEMENT NON-BLOCK EXPRESSION,\n+/*    :   \u2503              */                               //     OR PREPENDING A COUNTER WITH EMPTY TUPLE IF NO EXPRESSION, OR IF EXPRESSION IS A BLOCK, THEN THE NEXT \"GUARANTEED\"\n+/*    :   \u2503              */                               //     COUNTER CALL WITHIN THAT BLOCK.\n+/*    :   \u2503              */                               //   BASICALLY, CARRY THE START OF COVERAGE SPAN FORWARD UNTIL THE GUARANTEED COUNTER IS FOUND\n+/*    :   \u2503              */                 println!(\"after result = if ...\");\n+/*    :   \u2503       -      */                 if condition2 {\n+/*    :   :       \u2503      */                     println!(\"before first return\");\n+/*  \u250f-:---:-------<      */                     return Ok(());\n+/*  V :   :       -      */                 } else if condition3 {\n+/*    :   :       \u2503      */                     // THE ABOVE COUNTER IS _NOT_ REALLY NECESSARY IF EXPRESSION IS GUARANTEED TO EXECUTE.\n+/*    :   :       \u2503      */                     // IF WE GET COUNTER IN `else if` BLOCK WE COVERED EXPRESSION.\n+/*    :   :       \u2503      */                     // IF WE GET TO ANY REMAINING `else` or `else if` BLOCK WE KNOW WE EVALUATED THIS CONDITION\n+/*    :   :       \u2503      */                     // AND ALL OTHERS UP TO THE EXECUTED BLOCK. BUT THE SPAN WOULD HAVE \"HOLES\" FOR UNEXECUTED BLOCKS.\n+/*    :   :       \u2503      */                     println!(\"not second return\");\n+/*  \u250f-:---:-------<      */                     return Ok(());\n+/*  V :   :       -      */                 } else {\n+/*    :   :       \u2503      */                     println!(\"not returning\");\n+/*    :   :       \u2503      */                     false\n+/*    :   :       -      */                 }\n+/*    :   \u2503              */                 // NO COUNTER HERE BECAUSE NO STATEMENTS AFTER CONDITIONAL BLOCK\n+/*    :   \u2503   -          */             } {\n+/*    :   :   \u2503          */                 println!(\"branched condition returned true\");\n+/*    :   :   \u2503          */                 Ok(())\n+/*    :   \u2503   -          */             } else if self.call_closure(\n+/*    :   :       -      */                     |closure_param|\n+/*    :   :       \u2503   -  */                         if condition3 {\n+/*    :   :       :   \u2503  */                             println!(\"in closure, captured condition said to print the param {}\", closure_param);\n+/*    :   :       :   \u2503  */                             false\n+/*    :   :       \u2503   -  */                         } else {\n+/*    :   :       :   \u2503  */                             println!(\"in closure, captured condition was false\");\n+/*    :   :       :   \u2503  */                             true\n+/*    :   :       \u2503   -  */                         }\n+/*    :   :       -      */\n+/*    :   :   -          */                 ) {\n+/*    :   :   \u2503          */                 println!(\"closure returned true\");\n+/*    :   :   \u2503          */                 Err(Error::new(ErrorKind::Other, \"Result is error if closure returned true\"))\n+/*    :   \u2503   -          */             } else {\n+/*    :   :   \u2503          */                 println!(\"closure returned false\");\n+/*    :   :   \u2503          */                 Err(Error::new(ErrorKind::Other, \"Result is error if closure returned false\"))\n+/*    :   \u2503   -          */             };\n+/*    :   \u2503              */             println!(\"bottom of function might be skipped if early `return`\");\n+/*    :   \u2503              */             result\n+/*    \u2503   -              */         } else {\n+/*    :   \u2503              */             println!(\"skipping everything in `various()`\");\n+/*    :   \u2503              */             Ok(())\n+/*    \u2503   -              */         }\n+/*    \u2503   -              */         // 0 // DO NOT COUNT IF NO STATEMENTS AFTER CONDITIONAL BLOCK. ALL COVERAGE IS ALREADY COUNTED\n+/*    -                  */     }\n+/*                       */ }\n+/*                       */\n+/*    -                  */ fn main() -> Result<(), std::io::Error> {\n+/*    \u2503                  */     //let mut status: u8 = 2;\n+/*    \u2503                  */     let mut status: u8 = 1;\n+/*    :       -          */     let result = if status < 2 &&\n+/*    :       \u2503          */             {\n+/*    :       \u2503          */                 status -= 1;\n+/*    :       \u2503          */                 status == 0\n+/*    :   -   -          */             } {\n+/*    :   \u2503              */         let test_struct = TestStruct::new_with_value(100);\n+/*    :   \u2503              */         let _ = test_struct.various();\n+/*  \u250f-:---<              */         return __incr_cov_and_report(from!(\"\"),Err(Error::new(ErrorKind::Other, format!(\"Error status {}\", status))))\n+/*  V :   -              */     } else {\n+/*    :   \u2503              */         let test_struct = TestStruct::new();\n+/*    :   \u2503              */         test_struct.various()\n+/*    :   -              */     };\n+/*    \u2503                  */     println!(\"done\");\n+/*    \u2503                  */     __incr_cov_and_report(from!(\"\"),result) // function-scoped counter index = 0\n+/*    -                  */ }\n\\ No newline at end of file"}, {"sha": "75400e037e9f09caf45ed9e0b5323485ae2a42ef", "filename": "src/test/codegen/coverage-experiments/src/drop_trait.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fdrop_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fdrop_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fdrop_trait.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -0,0 +1,25 @@\n+#[inline(always)]\n+pub fn __incr_cov<T>(_region_loc: &str, result: T) -> T {\n+    result\n+}\n+\n+struct Firework {\n+    _strength: i32,\n+}\n+\n+impl Drop for Firework {\n+    fn drop(&mut self) {\n+        __incr_cov(\"start of drop()\", ());\n+    }\n+}\n+\n+fn main() -> Result<(),u8> {\n+    let _firecracker = Firework { _strength: 1 };\n+\n+    if __incr_cov(\"start of main()\", true) {\n+        return __incr_cov(\"if true\", { let _t = Err(1); _t });\n+    }\n+\n+    let _tnt = Firework { _strength: 100 };\n+    Ok(())\n+}\n\\ No newline at end of file"}, {"sha": "de9f5d5cb464757f5d5666e288e2017c26ac4225", "filename": "src/test/codegen/coverage-experiments/src/drop_trait_with_comments_prints.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fdrop_trait_with_comments_prints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fdrop_trait_with_comments_prints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fdrop_trait_with_comments_prints.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -0,0 +1,53 @@\n+//\n+//\n+//\n+// It's interesting to speculate if there is a way to leverage the Drop trait functionality\n+// to increment counters when a scope is closed, but I don't think it would help \"out of the box\".\n+//\n+// A `return` or `break` with expression might not need a temp value expression wrapper\n+// such as `return { let _t = result_expression; __incr_counter(...); _t };`\n+//\n+//    ... **if** the __incr_counter() was somehow called from a \"drop()\" trait function.\n+//\n+// The problem is, since the drop call is automatic, there is no way to have argument variants\n+// depending on where the drop() occurs (e.g., from a `return` statement vs. from the end of\n+// the function). We need 2 different code regions though.\n+//\n+//\n+//\n+//\n+\n+#[inline(always)]\n+pub fn __incr_cov<T>(_region_loc: &str, /*index: u32,*/ result: T) -> T {\n+    // println!(\"from: {}\", _region_loc);\n+    result\n+}\n+\n+struct Firework {\n+    strength: i32,\n+}\n+\n+impl Drop for Firework {\n+    fn drop(&mut self) {\n+        println!(\"BOOM times {}!!!\", self.strength);\n+        __incr_cov(\"start of drop()\", ());\n+    }\n+}\n+\n+fn main() -> Result<(),u8> {\n+    let _firecracker = Firework { strength: 1 };\n+\n+    if __incr_cov(\"start of main()\", true) {\n+        return __incr_cov(\"if true\", { let _t = Err(1); println!(\"computing return value\"); _t });\n+    }\n+\n+    let _tnt = Firework { strength: 100 };\n+    // __incr_cov(\"after if block\", Ok(())) // CAN USE COUNTER EXPRESSION: \"start of drop()\" - \"if true\"\n+    Ok(())\n+}\n+\n+// OUTPUT WHEN RUNNING THIS PROGRAM IS AS EXPECTED:\n+\n+// computing return value\n+// BOOM times 1!!!\n+// Error: 1"}, {"sha": "3f44c382a1e3f1bc8232e78b5ef004a5eb421329", "filename": "src/test/codegen/coverage-experiments/src/for.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Ffor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Ffor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Ffor.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -0,0 +1,41 @@\n+#[inline(always)]\n+pub fn __incr_cov<T>(_region_loc: &str, /*index: u32,*/ result: T) -> T {\n+    result\n+}\n+\n+fn main() {\n+    for countdown in __incr_cov(\"start\", 10..0) {\n+        let _ = countdown;\n+        __incr_cov(\"top of for\", ());\n+    }\n+}\n+\n+// LOWERED TO HIR:\n+//\n+// fn main() {\n+//   {\n+//       let _t =\n+//           match ::std::iter::IntoIterator::into_iter(__incr_cov(\"start\",\n+//                                                                 ::std::ops::Range{start:\n+//                                                                                       10,\n+//                                                                                   end:\n+//                                                                                       0,}))\n+//               {\n+//               mut iter =>\n+//               loop  {\n+//                   let mut __next;\n+//                   match ::std::iter::Iterator::next(&mut iter) {\n+//                       ::std::option::Option::Some(val) =>\n+//                       __next = val,\n+//                       ::std::option::Option::None => break ,\n+//                   }\n+//                   let countdown = __next;\n+//                   {\n+//                       let _ = countdown;\n+//                       __incr_cov(\"top of for\", ());\n+//                   }\n+//               },\n+//           };\n+//       _t\n+//   }\n+// }\n\\ No newline at end of file"}, {"sha": "03d11b2c230ca6cf44b80f4e068414596be08b8a", "filename": "src/test/codegen/coverage-experiments/src/for_with_comments.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Ffor_with_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Ffor_with_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Ffor_with_comments.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -0,0 +1,24 @@\n+/*                   */ #[inline(always)]\n+/*                   */ pub fn __incr_cov<T>(_region_loc: &str, /*index: u32,*/ result: T) -> T {\n+/*                   */     result\n+/*                   */ }\n+/*                   */\n+/*    -              */ fn main() {\n+/*    :   I          */     for countdown in __incr_cov(\"start\", 10..0) { // span is just the while test expression\n+/*    :   \u2503          */         let _ = countdown;\n+/*    :   \u2503          */         __incr_cov(\"top of for\", ());\n+/*    \u2503   -          */     }\n+/*    -              */ }\n+\n+\n+// -Z unpretty=val -- present the input source, unstable (and less-pretty) variants;\n+// valid types are any of the types for `--pretty`, as well as:\n+// `expanded`, `expanded,identified`,\n+// `expanded,hygiene` (with internal representations),\n+// `everybody_loops` (all function bodies replaced with `loop {}`),\n+// `hir` (the HIR), `hir,identified`,\n+// `hir,typed` (HIR with types for each node),\n+// `hir-tree` (dump the raw HIR),\n+// `mir` (the MIR), or `mir-cfg` (graphviz formatted MIR)\n+\n+// argument to `pretty` must be one of `normal`, `expanded`, `identified`, or `expanded,identified`"}, {"sha": "ad50f6be190040b503aef689bc0ff43203ad2e40", "filename": "src/test/codegen/coverage-experiments/src/if.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fif.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -0,0 +1,80 @@\n+#![feature(core_intrinsics)]\n+\n+pub fn __llvm_incr_counter(_region_loc: &str) {\n+}\n+\n+#[inline(always)]\n+pub fn __incr_cov<T>(region_loc: &str, result: T) -> T {\n+    __llvm_incr_counter(region_loc);\n+    result\n+}\n+\n+static TEST_FUNC_NAME: &'static [u8; 6] = b\"main()\";\n+\n+fn main() {\n+    let mut countdown = 10;\n+    if __incr_cov(\"start\", countdown > 0) {\n+\n+\n+        // // TEST CALLING INTRINSIC:\n+        unsafe { core::intrinsics::instrprof_increment(TEST_FUNC_NAME as *const u8, 1234 as u64, 314 as u32, 31 as u32) };\n+        // // Results in:\n+        // //   LLVM ERROR: Cannot select: intrinsic %llvm.instrprof.increment\n+        // // I may need to pass one or more of the following flags (or equivalent opts) to LLVM to enable this:\n+        // //   -fprofile-instr-generate -fcoverage-mapping\n+\n+\n+        countdown -= 1;\n+        __incr_cov(\"if block\",());\n+    } else if countdown > 5 {\n+        countdown -= 2;\n+        __incr_cov(\"else if block\",());\n+    } else {\n+        countdown -= 3;\n+    }\n+\n+    let mut countdown = 10;\n+    if { let _tcov = countdown > 0; __llvm_incr_counter(\"start\", ); _tcov } {\n+        countdown -= 1;\n+        __incr_cov(\"if block\",());\n+    } else if countdown > 5 {\n+        countdown -= 2;\n+        __incr_cov(\"else if block\",());\n+    } else {\n+        countdown -= 3;\n+    }\n+}\n+\n+// NOTE: hir REDUNDANTLY lowers the manually inlined counter in the second if block to:\n+//\n+// match {\n+//   let _t =\n+//       {\n+//           let _tcov = countdown > 0;\n+//           __llvm_incr_counter(\"start\");\n+//           _tcov\n+//       };\n+//   _t\n+// } {\n+\n+// I don't know if optimization phases will fix this or not.\n+// Otherwise, a more optimal (but definitely special case) way to handle this would be\n+// to inject the counter between the hir-introduced temp `_t` assignment and the block result\n+// line returning `_t`:\n+//\n+// match {\n+//   let _t = countdown > 0;\n+//   __llvm_incr_counter(\"start\"); // <-- the only thing inserted for coverage here\n+//   _t\n+// }\n+//\n+// UNFORTUNATELY THIS IS NOT A PATTERN WE CAN ALWAYS LEVERAGE, FOR EXPRESSIONS THAT HAVE VALUES\n+// WHERE WE NEED TO INJECT THE COUNTER AFTER THE EXPRESSION BUT BEFORE IT IS USED.\n+//\n+// IT DOES APPEAR TO BE THE CASE FOR WHILE EXPRESSIONS, (BECOMES loop { match { let _t = condition; _t} { true => {...} _ => break, }})\n+// AND IS TRUE FOR IF EXPRESSIONS AS NOTED\n+// BUT NOT FOR RETURN STATEMENT (and I'm guessing not for loop { break value; } ? )\n+//\n+// AND NOT FOR LAZY BOOLEAN EXPRESSIONS!\n+//\n+// AND NOT FOR MATCH EXPRESSIONS IN THE ORIGINAL SOURCE!\n\\ No newline at end of file"}, {"sha": "267e7bca2c5a2e3ec6917e0dd69d1c1c917500af", "filename": "src/test/codegen/coverage-experiments/src/if_with_comments.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fif_with_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fif_with_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fif_with_comments.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -0,0 +1,39 @@\n+/*                   */ #[inline(always)]\n+/*                   */ pub fn __incr_cov<T>(_region_loc: &str, /*index: u32,*/ result: T) -> T {\n+/*                   */     result\n+/*                   */ }\n+/*                   */\n+/*    -              */ fn main() {\n+/*    \u2503              */     let mut countdown = 10;\n+/*    :   I          */     if __incr_cov(\"start\", countdown > 0) { // span is from start of main()\n+/*    :   \u2503          */         countdown -= 1;\n+/*    :   \u2503          */         __incr_cov(\"if block\",());\n+/*    \u2503   -          */     }\n+\n+    let mut countdown = 10;\n+    if __incr_cov(\"start\", countdown > 0) {\n+        countdown -= 1;\n+        __incr_cov(\"if block\",());\n+    } else if countdown > 5 { // counter expression \"start\" - \"if block\"\n+        countdown -= 2;\n+        __incr_cov(\"else if block\",());\n+    } else {\n+        countdown -= 3;\n+        // __incr_cov(\"else block\",()); // counter expression (countdown > 5 counter expression) - \"else if block\"\n+                                        // PLACED AT END OF ELSE BLOCK OR START OF FIRST CONDITIONAL BLOCK, IF ANY (PRESUMING POSSIBLE EARLY EXIT).\n+                                        // IF WE CAN GUARANTEE NO EARLY EXIT IN THIS BLOCK, THEN AT THE END IS FINE EVEN IF ELSE BLOCK CONTAINS OTHER CONDITIONS.\n+    }\n+\n+/*    -              */ }\n+\n+// -Z unpretty=val -- present the input source, unstable (and less-pretty) variants;\n+// valid types are any of the types for `--pretty`, as well as:\n+// `expanded`, `expanded,identified`,\n+// `expanded,hygiene` (with internal representations),\n+// `everybody_loops` (all function bodies replaced with `loop {}`),\n+// `hir` (the HIR), `hir,identified`,\n+// `hir,typed` (HIR with types for each node),\n+// `hir-tree` (dump the raw HIR),\n+// `mir` (the MIR), or `mir-cfg` (graphviz formatted MIR)\n+\n+// argument to `pretty` must be one of `normal`, `expanded`, `identified`, or `expanded,identified`"}, {"sha": "d4708cd367ff66a8a612896fc797125134cb8d92", "filename": "src/test/codegen/coverage-experiments/src/increment_intrinsic.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fincrement_intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fincrement_intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fincrement_intrinsic.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -0,0 +1,11 @@\n+#![feature(core_intrinsics)]\n+\n+pub fn not_instrprof_increment(_hash: u64, _num_counters: u32, _index: u32) {\n+}\n+\n+fn main() {\n+    // COMPARE THIS WITH INTRINSIC INSERTION\n+    //not_instrprof_increment(1234 as u64, 314 as u32, 31 as u32);\n+\n+    unsafe { core::intrinsics::instrprof_increment(1234 as u64, 314 as u32, 31 as u32) };\n+}\n\\ No newline at end of file"}, {"sha": "081e5d72a6e0a9327b4b605a7fe01c00a79b29e6", "filename": "src/test/codegen/coverage-experiments/src/just_main.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fjust_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fjust_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fjust_main.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    println!(\"hello world! (should be covered)\");\n+}"}, {"sha": "263277c7cdc4d69c3e3479048af229e4a35df8a2", "filename": "src/test/codegen/coverage-experiments/src/lazy_boolean.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Flazy_boolean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Flazy_boolean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Flazy_boolean.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -0,0 +1,17 @@\n+pub fn __llvm_incr_counter(_region_loc: &str) {\n+}\n+\n+#[inline(always)]\n+pub fn __incr_cov<T>(region_loc: &str, result: T) -> T {\n+    __llvm_incr_counter(region_loc);\n+    result\n+}\n+\n+fn main() {\n+    let a = 1;\n+    let b = 10;\n+    let c = 100;\n+    let _result = __incr_cov(\"start\", a < b) || __incr_cov(\"or\", b < c);\n+\n+    let _result = { let _t = a < b; __llvm_incr_counter(\"start\"); _t } || { let _t = b < c; __llvm_incr_counter(\"start\"); _t };\n+}\n\\ No newline at end of file"}, {"sha": "76caa833ec4f8073c67aebb5954df8bc48b3642c", "filename": "src/test/codegen/coverage-experiments/src/loop_break_value.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Floop_break_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Floop_break_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Floop_break_value.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -0,0 +1,15 @@\n+pub fn __llvm_incr_counter(_region_loc: &str) {\n+}\n+\n+#[inline(always)]\n+pub fn __incr_cov<T>(region_loc: &str, result: T) -> T {\n+    __llvm_incr_counter(region_loc);\n+    result\n+}\n+\n+fn main() {\n+    __incr_cov(\"start\", ());\n+    let _result = loop {\n+        break __incr_cov(\"top of loop\", true);\n+    };\n+}\n\\ No newline at end of file"}, {"sha": "afbb20888eab5716e73f1bfb0492e06e9adb3f19", "filename": "src/test/codegen/coverage-experiments/src/match.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fmatch.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -0,0 +1,22 @@\n+pub fn __llvm_incr_counter(_region_loc: &str) {\n+}\n+\n+#[inline(always)]\n+pub fn __incr_cov<T>(region_loc: &str, result: T) -> T {\n+    __llvm_incr_counter(region_loc);\n+    result\n+}\n+\n+fn main() {\n+    let a = 1;\n+    let b = 10;\n+    let _result = match a < b {\n+        true => true,\n+        _ => false,\n+    };\n+\n+    let _result = match __incr_cov(\"end of first match\", a < b) {\n+        true => __incr_cov(\"matched true\", true),\n+        _ => false, // counter expression \"end of first match\" - \"matched true\"\n+    };\n+}\n\\ No newline at end of file"}, {"sha": "f618b37ed5247d928fbff6fe37465ab45c292d60", "filename": "src/test/codegen/coverage-experiments/src/match_with_increment.rs", "status": "added", "additions": 305, "deletions": 0, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fmatch_with_increment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fmatch_with_increment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fmatch_with_increment.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -0,0 +1,305 @@\n+#![feature(core_intrinsics)]\n+//static TEST_FUNC_NAME: &'static [u8; 7] = b\"main()\\0\";\n+  static TEST_FUNC_NAME: &'static [u8; 6] = b\"main()\";\n+fn main() {\n+    let a = 1;\n+    let b = 10;\n+    let _result = match {\n+        let _t = a < b;\n+        unsafe { core::intrinsics::instrprof_increment(TEST_FUNC_NAME as *const u8, 1234 as u64, 3 as u32, 0 as u32) };\n+        _t\n+    } {\n+        true => {\n+            let _t = true;\n+            unsafe { core::intrinsics::instrprof_increment(TEST_FUNC_NAME as *const u8, 1234 as u64, 3 as u32, 1 as u32) };\n+            _t\n+        }\n+        _ => false,\n+    };\n+}\n+\n+/*\n+\n+I NEED TO INSERT THE instrprof_increment() CALL:\n+\n+  1. JUST BEFORE THE switchInt(_4) (because we haven't counted entering the function main() yet, deferring that to \"JUST BEFORE FIRST BRANCH\")\n+  2. SOME TIME AFTER THE switchInt(_4), AND JUST BEFORE ANOTHER BRANCH (in this case, before \"goto\")\n+  2.a. NOT BEFORE BOTH GOTO'S AFTER switchInt(_4) (because one can be calculated by counter expression), BUT PERHAPS INSERT A noop PLACEHOLDER\n+       AS A MARKER TO INCLUDE THE COVERAGE REGION AND REFERENCE THE COUNTERS TO BE SUBTRACTED (AND/OR SUMMED)?\n+\n+    WHY DEFER INSERTING COUNTERS TO \"JUST BEFORE FIRST BRANCH\"? We can ignore panic/unwind() and only count if the coverage region ACTUALLY\n+    executed in entirety. BUT IS THAT NECESSARY? IS IT MUCH EASIER TO INSERT COUNTERS AT THE TOP OF A REGION THAT MUST EXECUTE IN ENTIRETY IF\n+    PANIC DOES NOT OCCUR? AND WHAT IF WE ADD SUPPORT FOR PANIC UNWIND (later)?\n+\n+    IS THERE A BENEFIT OF THE DEFERRED APPROACH WHEN CONSIDERING EXPRESSIONS MAY HAVE EARLY RETURNS? (BECAUSE, WE STILL NEED TO COUNT THE REGION\n+    LEADING UP TO THE EXPRESSION ANYWAY)\n+\n+=================================================\n+=================================================\n+\n+To inject an intrinsic after computing a final expression value of a coverage region:\n+\n+Replace the following basic block end (last statement plus terminator):\n+\n+... <statements to compute _4> ...\n+StorageLive(_4)\n+StorageLive(_5)\n+_5 = _1\n+StorageLive(_6)\n+_6 = _2\n+_4 = Lt(move _5, move _6)\n+StorageDead(_6)\n+StorageDead(_5)\n+                             <------ to insert instrprof_increment() here\n+FakeRead(ForMatchedPlace, _4)\n+--------------------------------------------------------------------------------------\n+switchInt(_4)\n+\n+\n+=================================================\n+Insert call to intrinsic with:\n+\n+StorageLive(_4)        # _4 is now meant for deferred FakeRead(ForMatchdPlace, _4) in BasicBlock after increment() call\n+StorageLive(_5)                 # Unchanged except _4 is now _5\n+StorageLive(_6)                 # Unchanged except _5 is now _6\n+_6 = _1                         # Unchanged except _5 is now _6\n+StorageLive(_7)                 # Unchanged except _6 is now _7\n+_7 = _2                         # Unchanged except _6 is now _7\n+_5 = Lt(move _6, move _7)       # Unchanged except _4, _5, _6 is now _5, _6, _7\n+StorageDead(_7)                 # Unchanged except _6 is now _7\n+StorageDead(_6)                 # Unchanged except _5 is now _6\n+\n+FakeRead(ForLet, _5)   # CHANGED ForMatchedPlace to ForLet\n+\n+> # ALL NEW AND NECESSARY TO CALL instrprof_increment()\n+> StorageLive(_8)        # ?? stores function pointer to instrprof_increment function?\n+> StorageLive(_9)\n+> StorageLive(_10)\n+> StorageLive(_11)\n+> _11 = const {alloc1+0: &&[u8; 6]}\n+> _10 = &raw const (*(*_11))\n+> _9 = move _10 as *const u8 (Pointer(ArrayToPointer))\n+> StorageDead(_10)\n+> StorageLive(_12)\n+> _12 = const 1234u64\n+> StorageLive(_13)\n+> _13 = const 3u32\n+> StorageLive(_14)\n+> _14 = const 0u32\n+> --------------------------------------------------------------------------------------\n+> _8 = const std::intrinsics::instrprof_increment(move _9, move _12, move _13, move _14)\n+>\n+> -> return\n+>\n+> StorageDead(_14)\n+> StorageDead(_13)\n+> StorageDead(_12)\n+> StorageDead(_9)\n+> StorageDead(_11)\n+> StorageDead(_8)\n+\n+_4 = _5                         # ARE THESE LINES REDUNDANT? CAN I JUST PASS _5 DIRECTLY TO FakeRead()?\n+StorageDead(_5)                 # DROP \"_t\" temp result of `let _t = a < b`\n+                                # (NOTE THAT IF SO, I CAN REMOVE _5 altogether, and use _4, which coincidentally makes less changes)\n+                                # SEE BELOW\n+\n+FakeRead(ForMatchedPlace, _4)   # Unchanged\n+--------------------------------------------------------------------------------------\n+switchInt(_4)                   # Unchanged\n+\n+\n+=================================================\n+Can I skip the extra variable and insert call to intrinsic with:\n+\n+StorageLive(_4)             # Unchanged\n+StorageLive(_5)             # Unchanged\n+_5 = _1                     # Unchanged\n+StorageLive(_6)             # Unchanged\n+_6 = _2                     # Unchanged\n+_4 = Lt(move _5, move _6)   # Unchanged\n+StorageDead(_6)             # Unchanged\n+StorageDead(_5)             # Unchanged\n+\n+> # ALL NEW AND NECESSARY TO CALL instrprof_increment()\n+> FakeRead(ForLet, _4)   # Save the post-increment result in temp \"_t\"\n+> StorageLive(_8)        # ?? stores function pointer to instrprof_increment function?\n+> StorageLive(_9)\n+> StorageLive(_10)\n+> StorageLive(_11)\n+> _11 = const {alloc1+0: &&[u8; 6]}\n+> _10 = &raw const (*(*_11))\n+> _9 = move _10 as *const u8 (Pointer(ArrayToPointer))\n+> StorageDead(_10)\n+> StorageLive(_12)\n+> _12 = const 1234u64\n+> StorageLive(_13)\n+> _13 = const 3u32\n+> StorageLive(_14)\n+> _14 = const 0u32\n+> --------------------------------------------------------------------------------------\n+> _8 = const std::intrinsics::instrprof_increment(move _9, move _12, move _13, move _14)\n+>\n+> -> return\n+>\n+> StorageDead(_14)\n+> StorageDead(_13)\n+> StorageDead(_12)\n+> StorageDead(_9)\n+> StorageDead(_11)\n+> StorageDead(_8)\n+\n+FakeRead(ForMatchedPlace, _4)   # Unchanged  (PREVIOUSLY USED IN FakeRead(ForLet), is that OK?)\n+--------------------------------------------------------------------------------------\n+switchInt(_4)                   # Unchanged\n+\n+\n+\n+\n+\n+=================================================\n+=================================================\n+\n+For the second inserted call to instrprof_increment, without that call we have:\n+\n+--------------------------------------------------------------------------------------\n+switchInt(_4)                   # From above\n+\n+-> otherwise   # that is, \"NOT false\"\n+\n+_3 = const true\n+                             <------ to insert instrprof_increment() here\n+--------------------------------------------------------------------------------------\n+goto\n+\n+->                              # No label. No condition, and not a \"return\"\n+\n+FakeRead(ForLet, _3)            # NOTE: Unused result\n+StorageDead(_4)\n+_0 = ()\n+StorageDead(_3)\n+StorageDead(_2)\n+StorageDead(_1)\n+--------------------------------------------------------------------------------------\n+goto\n+\n+->                              # No label. No condition, and not a \"return\"\n+\n+return   # from main()\n+\n+\n+=================================================\n+With the call to increment():\n+\n+--------------------------------------------------------------------------------------\n+switchInt(_4)                   # From above\n+\n+-> otherwise   # \"NOT false\"    # UNCHANGED\n+\n+StorageLive(_15)                # CHANGED! Allocated new storage (_15) for the result of match, if true.\n+_15 = const true                # UNCHANGED except _3 is now _15\n+FakeRead(ForLet, _15)           # CHANGED! Assign value to temporary (to be assigned to _3 later) ... Do I need to do this?\n+\n+> # ALL NEW AND NECESSARY TO CALL instrprof_increment()\n+> StorageLive(_16)                # pointer to instrprof_increment() function ?\n+> StorageLive(_17)\n+> StorageLive(_18)\n+> StorageLive(_19)\n+> _19 = const {alloc1+0: &&[u8; 6]}\n+> _18 = &raw const (*(*_19))\n+> _17 = move _18 as *const u8 (Pointer(ArrayToPointer))\n+> StorageDead(_18)\n+> StorageLive(_20)\n+> _20 = const 1234u64\n+> StorageLive(_21)\n+> _21 = const 3u32\n+> StorageLive(_22)\n+> _22 = const 1u32\n+> --------------------------------------------------------------------------------------\n+> _16 = const std::intrinsics::instrprof_increment(move _17, move _20, move _21, move _22)\n+>\n+> ->  return\n+>\n+> StorageDead(_22)\n+> StorageDead(_21)\n+> StorageDead(_20)\n+> StorageDead(_17)\n+> StorageDead(_19)\n+> StorageDead(_16)\n+> _3 = _15\n+> StorageDead(_15)\n+\n+--------------------------------# UNCHANGED-------------------------------------------\n+goto                            # UNCHANGED\n+\n+->                              # UNCHANGED\n+\n+FakeRead(ForLet, _3)            # UNCHANGED\n+StorageDead(_4)                 # UNCHANGED\n+_0 = ()                         # UNCHANGED\n+StorageDead(_3)                 # UNCHANGED\n+StorageDead(_2)                 # UNCHANGED\n+StorageDead(_1)                 # UNCHANGED\n+--------------------------------------------------------------------------------------\n+goto                            # UNCHANGED\n+\n+->                              # UNCHANGED\n+\n+return   # from main()          # UNCHANGED\n+\n+=================================================\n+As before, can I skip the extra variable (_15) and insert the call to intrinsic with _3 directly?:\n+\n+\n+--------------------------------------------------------------------------------------\n+switchInt(_4)                   # From above\n+\n+-> otherwise   # \"NOT false\"    # UNCHANGED\n+\n+_3 = const true                 # UNCHANGED?\n+\n+> # ALL NEW AND NECESSARY TO CALL instrprof_increment()\n+> StorageLive(_16)                # pointer to instrprof_increment() function ?\n+> StorageLive(_17)\n+> StorageLive(_18)\n+> StorageLive(_19)\n+> _19 = const {alloc1+0: &&[u8; 6]}\n+> _18 = &raw const (*(*_19))\n+> _17 = move _18 as *const u8 (Pointer(ArrayToPointer))\n+> StorageDead(_18)\n+> StorageLive(_20)\n+> _20 = const 1234u64\n+> StorageLive(_21)\n+> _21 = const 3u32\n+> StorageLive(_22)\n+> _22 = const 1u32\n+> --------------------------------------------------------------------------------------\n+> _16 = const std::intrinsics::instrprof_increment(move _17, move _20, move _21, move _22)\n+>\n+> ->  return\n+>\n+> StorageDead(_22)\n+> StorageDead(_21)\n+> StorageDead(_20)\n+> StorageDead(_17)\n+> StorageDead(_19)\n+> StorageDead(_16)\n+\n+--------------------------------# UNCHANGED-------------------------------------------\n+goto                            # UNCHANGED\n+\n+->                              # UNCHANGED\n+\n+FakeRead(ForLet, _3)            # UNCHANGED\n+StorageDead(_4)                 # UNCHANGED\n+_0 = ()                         # UNCHANGED\n+StorageDead(_3)                 # UNCHANGED\n+StorageDead(_2)                 # UNCHANGED\n+StorageDead(_1)                 # UNCHANGED\n+--------------------------------------------------------------------------------------\n+goto                            # UNCHANGED\n+\n+->                              # UNCHANGED\n+\n+return   # from main()          # UNCHANGED\n+\n+*/\n\\ No newline at end of file"}, {"sha": "60586967920cb187c29245006e586c48852d93df", "filename": "src/test/codegen/coverage-experiments/src/match_with_increment_alt.rs", "status": "added", "additions": 296, "deletions": 0, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fmatch_with_increment_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fmatch_with_increment_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fmatch_with_increment_alt.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -0,0 +1,296 @@\n+#![feature(core_intrinsics)]\n+//static TEST_FUNC_NAME: &'static [u8; 7] = b\"main()\\0\";\n+  static TEST_FUNC_NAME: &'static [u8; 6] = b\"main()\";\n+fn main() {\n+    unsafe { core::intrinsics::instrprof_increment(TEST_FUNC_NAME as *const u8, 1234 as u64, 3 as u32, 0 as u32) };\n+    let a = 1;\n+    let b = 10;\n+    let _result = match a < b {\n+        true => {\n+            unsafe { core::intrinsics::instrprof_increment(TEST_FUNC_NAME as *const u8, 1234 as u64, 3 as u32, 1 as u32) };\n+            true\n+        }\n+        _ => false,\n+    };\n+}\n+\n+/*\n+\n+ALTERNATE APPROACH:\n+\n+    IS IT MUCH EASIER TO INSERT COUNTERS AT THE TOP OF A REGION THAT MUST EXECUTE IN ENTIRETY IF\n+    PANIC DOES NOT OCCUR? AND WHAT IF WE ADD SUPPORT FOR PANIC UNWIND (later)?\n+\n+    IS THERE A DETRACTOR COMPARED TO THE DEFERRED APPROACH WHEN CONSIDERING EXPRESSIONS MAY HAVE EARLY RETURNS?\n+\n+    (BECAUSE, WE STILL NEED TO COUNT THE REGION LEADING UP TO THE EXPRESSION ANYWAY)\n+\n+=================================================\n+=================================================\n+\n+To inject an intrinsic after computing a final expression value of a coverage region:\n+\n+Replace the following basic block end (last statement plus terminator):\n+\n+... <statements to compute _4> ...\n+StorageLive(_4)\n+StorageLive(_5)\n+_5 = _1\n+StorageLive(_6)\n+_6 = _2\n+_4 = Lt(move _5, move _6)\n+StorageDead(_6)\n+StorageDead(_5)\n+                             <------ to insert instrprof_increment() here\n+FakeRead(ForMatchedPlace, _4)\n+--------------------------------------------------------------------------------------\n+switchInt(_4)\n+\n+\n+=================================================\n+Insert call to intrinsic with:\n+\n+StorageLive(_4)        # _4 is now meant for deferred FakeRead(ForMatchdPlace, _4) in BasicBlock after increment() call\n+StorageLive(_5)                 # Unchanged except _4 is now _5\n+StorageLive(_6)                 # Unchanged except _5 is now _6\n+_6 = _1                         # Unchanged except _5 is now _6\n+StorageLive(_7)                 # Unchanged except _6 is now _7\n+_7 = _2                         # Unchanged except _6 is now _7\n+_5 = Lt(move _6, move _7)       # Unchanged except _4, _5, _6 is now _5, _6, _7\n+StorageDead(_7)                 # Unchanged except _6 is now _7\n+StorageDead(_6)                 # Unchanged except _5 is now _6\n+\n+FakeRead(ForLet, _5)   # CHANGED ForMatchedPlace to ForLet\n+\n+> # ALL NEW AND NECESSARY TO CALL instrprof_increment()\n+> StorageLive(_8)        # ?? stores function pointer to instrprof_increment function?\n+> StorageLive(_9)\n+> StorageLive(_10)\n+> StorageLive(_11)\n+> _11 = const {alloc1+0: &&[u8; 6]}\n+> _10 = &raw const (*(*_11))\n+> _9 = move _10 as *const u8 (Pointer(ArrayToPointer))\n+> StorageDead(_10)\n+> StorageLive(_12)\n+> _12 = const 1234u64\n+> StorageLive(_13)\n+> _13 = const 3u32\n+> StorageLive(_14)\n+> _14 = const 0u32\n+> --------------------------------------------------------------------------------------\n+> _8 = const std::intrinsics::instrprof_increment(move _9, move _12, move _13, move _14)\n+>\n+> -> return\n+>\n+> StorageDead(_14)\n+> StorageDead(_13)\n+> StorageDead(_12)\n+> StorageDead(_9)\n+> StorageDead(_11)\n+> StorageDead(_8)\n+\n+_4 = _5                         # ARE THESE LINES REDUNDANT? CAN I JUST PASS _5 DIRECTLY TO FakeRead()?\n+StorageDead(_5)                 # DROP \"_t\" temp result of `let _t = a < b`\n+                                # (NOTE THAT IF SO, I CAN REMOVE _5 altogether, and use _4, which coincidentally makes less changes)\n+                                # SEE BELOW\n+\n+FakeRead(ForMatchedPlace, _4)   # Unchanged\n+--------------------------------------------------------------------------------------\n+switchInt(_4)                   # Unchanged\n+\n+\n+=================================================\n+Can I skip the extra variable and insert call to intrinsic with:\n+\n+StorageLive(_4)             # Unchanged\n+StorageLive(_5)             # Unchanged\n+_5 = _1                     # Unchanged\n+StorageLive(_6)             # Unchanged\n+_6 = _2                     # Unchanged\n+_4 = Lt(move _5, move _6)   # Unchanged\n+StorageDead(_6)             # Unchanged\n+StorageDead(_5)             # Unchanged\n+\n+> # ALL NEW AND NECESSARY TO CALL instrprof_increment()\n+> FakeRead(ForLet, _4)   # Save the post-increment result in temp \"_t\"\n+> StorageLive(_8)        # ?? stores function pointer to instrprof_increment function?\n+> StorageLive(_9)\n+> StorageLive(_10)\n+> StorageLive(_11)\n+> _11 = const {alloc1+0: &&[u8; 6]}\n+> _10 = &raw const (*(*_11))\n+> _9 = move _10 as *const u8 (Pointer(ArrayToPointer))\n+> StorageDead(_10)\n+> StorageLive(_12)\n+> _12 = const 1234u64\n+> StorageLive(_13)\n+> _13 = const 3u32\n+> StorageLive(_14)\n+> _14 = const 0u32\n+> --------------------------------------------------------------------------------------\n+> _8 = const std::intrinsics::instrprof_increment(move _9, move _12, move _13, move _14)\n+>\n+> -> return\n+>\n+> StorageDead(_14)\n+> StorageDead(_13)\n+> StorageDead(_12)\n+> StorageDead(_9)\n+> StorageDead(_11)\n+> StorageDead(_8)\n+\n+FakeRead(ForMatchedPlace, _4)   # Unchanged  (PREVIOUSLY USED IN FakeRead(ForLet), is that OK?)\n+--------------------------------------------------------------------------------------\n+switchInt(_4)                   # Unchanged\n+\n+\n+\n+\n+\n+=================================================\n+=================================================\n+\n+For the second inserted call to instrprof_increment, without that call we have:\n+\n+--------------------------------------------------------------------------------------\n+switchInt(_4)                   # From above\n+\n+-> otherwise   # that is, \"NOT false\"\n+\n+_3 = const true\n+                             <------ to insert instrprof_increment() here\n+--------------------------------------------------------------------------------------\n+goto\n+\n+->                              # No label. No condition, and not a \"return\"\n+\n+FakeRead(ForLet, _3)            # NOTE: Unused result\n+StorageDead(_4)\n+_0 = ()\n+StorageDead(_3)\n+StorageDead(_2)\n+StorageDead(_1)\n+--------------------------------------------------------------------------------------\n+goto\n+\n+->                              # No label. No condition, and not a \"return\"\n+\n+return   # from main()\n+\n+\n+=================================================\n+With the call to increment():\n+\n+--------------------------------------------------------------------------------------\n+switchInt(_4)                   # From above\n+\n+-> otherwise   # \"NOT false\"    # UNCHANGED\n+\n+StorageLive(_15)                # CHANGED! Allocated new storage (_15) for the result of match, if true.\n+_15 = const true                # UNCHANGED except _3 is now _15\n+FakeRead(ForLet, _15)           # CHANGED! Assign value to temporary (to be assigned to _3 later) ... Do I need to do this?\n+\n+> # ALL NEW AND NECESSARY TO CALL instrprof_increment()\n+> StorageLive(_16)                # pointer to instrprof_increment() function ?\n+> StorageLive(_17)\n+> StorageLive(_18)\n+> StorageLive(_19)\n+> _19 = const {alloc1+0: &&[u8; 6]}\n+> _18 = &raw const (*(*_19))\n+> _17 = move _18 as *const u8 (Pointer(ArrayToPointer))\n+> StorageDead(_18)\n+> StorageLive(_20)\n+> _20 = const 1234u64\n+> StorageLive(_21)\n+> _21 = const 3u32\n+> StorageLive(_22)\n+> _22 = const 1u32\n+> --------------------------------------------------------------------------------------\n+> _16 = const std::intrinsics::instrprof_increment(move _17, move _20, move _21, move _22)\n+>\n+> ->  return\n+>\n+> StorageDead(_22)\n+> StorageDead(_21)\n+> StorageDead(_20)\n+> StorageDead(_17)\n+> StorageDead(_19)\n+> StorageDead(_16)\n+> _3 = _15\n+> StorageDead(_15)\n+\n+--------------------------------# UNCHANGED-------------------------------------------\n+goto                            # UNCHANGED\n+\n+->                              # UNCHANGED\n+\n+FakeRead(ForLet, _3)            # UNCHANGED\n+StorageDead(_4)                 # UNCHANGED\n+_0 = ()                         # UNCHANGED\n+StorageDead(_3)                 # UNCHANGED\n+StorageDead(_2)                 # UNCHANGED\n+StorageDead(_1)                 # UNCHANGED\n+--------------------------------------------------------------------------------------\n+goto                            # UNCHANGED\n+\n+->                              # UNCHANGED\n+\n+return   # from main()          # UNCHANGED\n+\n+=================================================\n+As before, can I skip the extra variable (_15) and insert the call to intrinsic with _3 directly?:\n+\n+\n+--------------------------------------------------------------------------------------\n+switchInt(_4)                   # From above\n+\n+-> otherwise   # \"NOT false\"    # UNCHANGED\n+\n+_3 = const true                 # UNCHANGED?\n+\n+> # ALL NEW AND NECESSARY TO CALL instrprof_increment()\n+> StorageLive(_16)                # pointer to instrprof_increment() function ?\n+> StorageLive(_17)\n+> StorageLive(_18)\n+> StorageLive(_19)\n+> _19 = const {alloc1+0: &&[u8; 6]}\n+> _18 = &raw const (*(*_19))\n+> _17 = move _18 as *const u8 (Pointer(ArrayToPointer))\n+> StorageDead(_18)\n+> StorageLive(_20)\n+> _20 = const 1234u64\n+> StorageLive(_21)\n+> _21 = const 3u32\n+> StorageLive(_22)\n+> _22 = const 1u32\n+> --------------------------------------------------------------------------------------\n+> _16 = const std::intrinsics::instrprof_increment(move _17, move _20, move _21, move _22)\n+>\n+> ->  return\n+>\n+> StorageDead(_22)\n+> StorageDead(_21)\n+> StorageDead(_20)\n+> StorageDead(_17)\n+> StorageDead(_19)\n+> StorageDead(_16)\n+\n+--------------------------------# UNCHANGED-------------------------------------------\n+goto                            # UNCHANGED\n+\n+->                              # UNCHANGED\n+\n+FakeRead(ForLet, _3)            # UNCHANGED\n+StorageDead(_4)                 # UNCHANGED\n+_0 = ()                         # UNCHANGED\n+StorageDead(_3)                 # UNCHANGED\n+StorageDead(_2)                 # UNCHANGED\n+StorageDead(_1)                 # UNCHANGED\n+--------------------------------------------------------------------------------------\n+goto                            # UNCHANGED\n+\n+->                              # UNCHANGED\n+\n+return   # from main()          # UNCHANGED\n+\n+*/\n\\ No newline at end of file"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/codegen/coverage-experiments/src/match_without_increment.mir", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fmatch_without_increment.mir", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fmatch_without_increment.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fmatch_without_increment.mir?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312"}, {"sha": "fa85833e05434df1cc9eb7443f9fba41aa01c44d", "filename": "src/test/codegen/coverage-experiments/src/match_without_increment.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fmatch_without_increment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fmatch_without_increment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fmatch_without_increment.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let a = 1;\n+    let b = 10;\n+    let _result = match a < b { true => true, _ => false, };\n+}\n\\ No newline at end of file"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/codegen/coverage-experiments/src/match_without_increment_alt.mir", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fmatch_without_increment_alt.mir", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fmatch_without_increment_alt.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fmatch_without_increment_alt.mir?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312"}, {"sha": "03d11b2c230ca6cf44b80f4e068414596be08b8a", "filename": "src/test/codegen/coverage-experiments/src/question_mark_err_status_handling_with_comments.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fquestion_mark_err_status_handling_with_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fquestion_mark_err_status_handling_with_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fquestion_mark_err_status_handling_with_comments.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -0,0 +1,24 @@\n+/*                   */ #[inline(always)]\n+/*                   */ pub fn __incr_cov<T>(_region_loc: &str, /*index: u32,*/ result: T) -> T {\n+/*                   */     result\n+/*                   */ }\n+/*                   */\n+/*    -              */ fn main() {\n+/*    :   I          */     for countdown in __incr_cov(\"start\", 10..0) { // span is just the while test expression\n+/*    :   \u2503          */         let _ = countdown;\n+/*    :   \u2503          */         __incr_cov(\"top of for\", ());\n+/*    \u2503   -          */     }\n+/*    -              */ }\n+\n+\n+// -Z unpretty=val -- present the input source, unstable (and less-pretty) variants;\n+// valid types are any of the types for `--pretty`, as well as:\n+// `expanded`, `expanded,identified`,\n+// `expanded,hygiene` (with internal representations),\n+// `everybody_loops` (all function bodies replaced with `loop {}`),\n+// `hir` (the HIR), `hir,identified`,\n+// `hir,typed` (HIR with types for each node),\n+// `hir-tree` (dump the raw HIR),\n+// `mir` (the MIR), or `mir-cfg` (graphviz formatted MIR)\n+\n+// argument to `pretty` must be one of `normal`, `expanded`, `identified`, or `expanded,identified`"}, {"sha": "3cb185eda544fdf44379e4e7a79ecfc0d8bfdbb9", "filename": "src/test/codegen/coverage-experiments/src/while.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fwhile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fwhile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fwhile.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -0,0 +1,23 @@\n+#[inline(always)]\n+pub fn __incr_cov<T>(_region_loc: &str, result: T) -> T {\n+    result\n+}\n+\n+fn main() {\n+    let mut countdown = 10;\n+    __incr_cov(\"block start\",());\n+    while __incr_cov(\"while test\", countdown > 0) {\n+        countdown -= 1;\n+    }\n+\n+    let mut countdown = 10;\n+    __incr_cov(\"after first while loop\",());\n+    while __incr_cov(\"while test\", countdown > 0) {\n+        countdown -= 1;\n+        if countdown < 5 {\n+            __incr_cov(\"top of if countdown < 5\",());\n+            break;\n+        }\n+        countdown -= 2;\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "e9ed1efc220d41a70f8db93a8ddf9325b951a1bd", "filename": "src/test/codegen/coverage-experiments/src/while_clean.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fwhile_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fwhile_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fwhile_clean.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    let mut countdown = 10;\n+    while countdown > 0 {\n+        countdown -= 1;\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "35709ffba3a04251d27d750c285ed87523d7d3c1", "filename": "src/test/codegen/coverage-experiments/src/while_early_return.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fwhile_early_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fwhile_early_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fwhile_early_return.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -0,0 +1,10 @@\n+fn main() -> u8 { // this will lower to HIR but will not compile: `main` can only return types that implement `std::process::Termination`\n+    let mut countdown = 10;\n+    while countdown > 0 {\n+        if false {\n+            return if countdown > 8 { 1 } else { return 2; };\n+        }\n+        countdown -= 1;\n+    }\n+    0\n+}\n\\ No newline at end of file"}, {"sha": "56417fedf00df07dc879c177883b2083591acd83", "filename": "src/test/codegen/coverage-experiments/src/while_with_comments.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fwhile_with_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae1ca05b2be0c2a98206a58d894aa620b312/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fwhile_with_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcoverage-experiments%2Fsrc%2Fwhile_with_comments.rs?ref=5068ae1ca05b2be0c2a98206a58d894aa620b312", "patch": "@@ -0,0 +1,51 @@\n+/*                   */ #[inline(always)]\n+/*                   */ pub fn __incr_cov<T>(_region_loc: &str, /*index: u32,*/ result: T) -> T {\n+/*                   */     result\n+/*                   */ }\n+/*                   */\n+/*    -              */ fn main() {\n+/*    \u2503              */     let mut countdown = 10;\n+/*    \u2503              */     __incr_cov(\"block start\",()); // Must increment before repeated while text expression\n+/*    :   I          */     while __incr_cov(\"while test\", countdown > 0) { // span is just the while test expression\n+/*    :   \u2503          */         countdown -= 1;\n+/*    :   \u2503          */         // __incr_cov(\"while loop\",()); // Counter not needed, but span is computed as \"while test\" minus \"block start\"\n+/*    :   \u2503          */                                         // If while criteria is tested 11 times, and the outer block runs only once, 11-1 = 10\n+/*    :   \u2503          */         // REMOVING COUNTER ASSUMES NO EARLY RETURN THOUGH.\n+/*    :   \u2503          */         // I THINK WE CAN ONLY USE THE COUNTER EXPRESSION UP TO FIRST CONDITIONAL BLOCK, IF ANY (if, match, maybe any loop)\n+/*    \u2503   -          */     }\n+\n+    let mut countdown = 10;\n+    __incr_cov(\"after first while loop\",());\n+    while __incr_cov(\"while test\", countdown > 0) {\n+        countdown -= 1;\n+        // if __incr_cov(\"top of while loop\", countdown < 5) {\n+        if countdown < 5 { // \"top of while loop\" = counter expression \"while test\" - \"after first while loop\"\n+            __incr_cov(\"top of if countdown < 5\",());\n+            break;\n+        }\n+        countdown -= 2;\n+        // __incr_cov(\"after if countdown < 5 block\", ());\n+        // \"after if countdown < 5 block\" = counter expression \"top of while loop\" - \"top of if countdown < 5\"\n+        // HOWEVER, WE CAN ONLY REMOVE THE COUNTER AND USE COUNTER EXPRESSION IF WE **KNOW** THAT THE BODY OF THE IF\n+        // WILL **ALWAYS** BREAK (OR RETURN, OR CONTINUE?)\n+        // AND THUS WE TREAT THE STATEMENTS FOLLOWING THE IF BLOCK AS IF THEY WERE AN ELSE BLOCK.\n+        // THAT'S A LOT TO ASK.\n+\n+        // PERHAPS TREAT EARLY RETURNS AS A SPECIAL KIND OF COUNTER AND IF ANY ARE INVOKED BEFORE STATEMENTS AFTER THE BLOCK THAT CONTAINS THEM,\n+        // THEN SUBTRACT THOSE COUNTS FROM THE COUNT BEFORE THE BLOCK (AS WE DO HERE)? (SO ONE SET OF EXPRESSIONS MUST SUM ALL OF THE EARLY\n+        // RETURNS)\n+    }\n+/*    -              */ }\n+\n+\n+// -Z unpretty=val -- present the input source, unstable (and less-pretty) variants;\n+// valid types are any of the types for `--pretty`, as well as:\n+// `expanded`, `expanded,identified`,\n+// `expanded,hygiene` (with internal representations),\n+// `everybody_loops` (all function bodies replaced with `loop {}`),\n+// `hir` (the HIR), `hir,identified`,\n+// `hir,typed` (HIR with types for each node),\n+// `hir-tree` (dump the raw HIR),\n+// `mir` (the MIR), or `mir-cfg` (graphviz formatted MIR)\n+\n+// argument to `pretty` must be one of `normal`, `expanded`, `identified`, or `expanded,identified`"}]}