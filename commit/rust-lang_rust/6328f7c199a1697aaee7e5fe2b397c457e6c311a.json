{"sha": "6328f7c199a1697aaee7e5fe2b397c457e6c311a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzMjhmN2MxOTlhMTY5N2FhZWU3ZTVmZTJiMzk3YzQ1N2U2YzMxMWE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-23T01:38:59Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-24T23:24:09Z"}, "message": "std: Add timeouts to unix connect/accept\n\nThis adds support for connecting to a unix socket with a timeout (a named pipe\non windows), and accepting a connection with a timeout. The goal is to bring\nunix pipes/named sockets back in line with TCP support for timeouts.\n\nSimilarly to the TCP sockets, all methods are marked #[experimental] due to\nuncertainty about the type of the timeout argument.\n\nThis internally involved a good bit of refactoring to share as much code as\npossible between TCP servers and pipe servers, but the core implementation did\nnot change drastically as part of this commit.\n\ncc #13523", "tree": {"sha": "21b8afe559302ed90be9dbb725c700513d9cfe7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21b8afe559302ed90be9dbb725c700513d9cfe7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6328f7c199a1697aaee7e5fe2b397c457e6c311a", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6328f7c199a1697aaee7e5fe2b397c457e6c311a", "html_url": "https://github.com/rust-lang/rust/commit/6328f7c199a1697aaee7e5fe2b397c457e6c311a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6328f7c199a1697aaee7e5fe2b397c457e6c311a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67ee480936947aa5b1953b7b6e48a0c7a191501e", "url": "https://api.github.com/repos/rust-lang/rust/commits/67ee480936947aa5b1953b7b6e48a0c7a191501e", "html_url": "https://github.com/rust-lang/rust/commit/67ee480936947aa5b1953b7b6e48a0c7a191501e"}], "stats": {"total": 880, "additions": 531, "deletions": 349}, "files": [{"sha": "bebf95a4a3ba6870ef516438dbde82c5a91c3366", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6328f7c199a1697aaee7e5fe2b397c457e6c311a/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6328f7c199a1697aaee7e5fe2b397c457e6c311a/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=6328f7c199a1697aaee7e5fe2b397c457e6c311a", "patch": "@@ -225,7 +225,7 @@ pub use funcs::bsd43::{shutdown};\n #[cfg(windows)] pub use consts::os::extra::{PIPE_UNLIMITED_INSTANCES, ERROR_ACCESS_DENIED};\n #[cfg(windows)] pub use consts::os::extra::{FILE_WRITE_ATTRIBUTES, FILE_READ_ATTRIBUTES};\n #[cfg(windows)] pub use consts::os::extra::{ERROR_PIPE_BUSY, ERROR_IO_PENDING};\n-#[cfg(windows)] pub use consts::os::extra::{ERROR_PIPE_CONNECTED};\n+#[cfg(windows)] pub use consts::os::extra::{ERROR_PIPE_CONNECTED, WAIT_OBJECT_0};\n #[cfg(windows)] pub use types::os::common::bsd44::{SOCKET};\n #[cfg(windows)] pub use types::os::common::posix01::{stat, utimbuf};\n #[cfg(windows)] pub use types::os::arch::extra::{HANDLE, BOOL, LPSECURITY_ATTRIBUTES};"}, {"sha": "6c84424e97a0df4fa0c25e74fc97eaa379fc25dd", "filename": "src/libnative/io/c_win32.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6328f7c199a1697aaee7e5fe2b397c457e6c311a/src%2Flibnative%2Fio%2Fc_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6328f7c199a1697aaee7e5fe2b397c457e6c311a/src%2Flibnative%2Fio%2Fc_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_win32.rs?ref=6328f7c199a1697aaee7e5fe2b397c457e6c311a", "patch": "@@ -59,4 +59,6 @@ extern \"system\" {\n                       optname: libc::c_int,\n                       optval: *mut libc::c_char,\n                       optlen: *mut libc::c_int) -> libc::c_int;\n+\n+    pub fn CancelIo(hFile: libc::HANDLE) -> libc::BOOL;\n }"}, {"sha": "944766e8fd070ca72e161c4ccd0f0ab959ca2240", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6328f7c199a1697aaee7e5fe2b397c457e6c311a/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6328f7c199a1697aaee7e5fe2b397c457e6c311a/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=6328f7c199a1697aaee7e5fe2b397c457e6c311a", "patch": "@@ -44,6 +44,7 @@ pub use self::process::Process;\n pub mod addrinfo;\n pub mod net;\n pub mod process;\n+mod util;\n \n #[cfg(unix)]\n #[path = \"file_unix.rs\"]\n@@ -177,8 +178,9 @@ impl rtio::IoFactory for IoFactory {\n     fn unix_bind(&mut self, path: &CString) -> IoResult<~RtioUnixListener:Send> {\n         pipe::UnixListener::bind(path).map(|s| ~s as ~RtioUnixListener:Send)\n     }\n-    fn unix_connect(&mut self, path: &CString) -> IoResult<~RtioPipe:Send> {\n-        pipe::UnixStream::connect(path).map(|s| ~s as ~RtioPipe:Send)\n+    fn unix_connect(&mut self, path: &CString,\n+                    timeout: Option<u64>) -> IoResult<~RtioPipe:Send> {\n+        pipe::UnixStream::connect(path, timeout).map(|s| ~s as ~RtioPipe:Send)\n     }\n     fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n                           hint: Option<ai::Hint>) -> IoResult<~[ai::Info]> {"}, {"sha": "cc41da846b2b2f127293eaacb0c20a48cd7d386f", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 6, "deletions": 122, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/6328f7c199a1697aaee7e5fe2b397c457e6c311a/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6328f7c199a1697aaee7e5fe2b397c457e6c311a/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=6328f7c199a1697aaee7e5fe2b397c457e6c311a", "patch": "@@ -13,13 +13,12 @@ use std::cast;\n use std::io::net::ip;\n use std::io;\n use std::mem;\n-use std::os;\n-use std::ptr;\n use std::rt::rtio;\n use std::sync::arc::UnsafeArc;\n \n use super::{IoResult, retry, keep_going};\n use super::c;\n+use super::util;\n \n ////////////////////////////////////////////////////////////////////////////////\n // sockaddr and misc bindings\n@@ -118,8 +117,8 @@ fn setsockopt<T>(fd: sock_t, opt: libc::c_int, val: libc::c_int,\n     }\n }\n \n-fn getsockopt<T: Copy>(fd: sock_t, opt: libc::c_int,\n-                       val: libc::c_int) -> IoResult<T> {\n+pub fn getsockopt<T: Copy>(fd: sock_t, opt: libc::c_int,\n+                           val: libc::c_int) -> IoResult<T> {\n     unsafe {\n         let mut slot: T = mem::init();\n         let mut len = mem::size_of::<T>() as libc::socklen_t;\n@@ -145,21 +144,6 @@ fn last_error() -> io::IoError {\n     super::last_error()\n }\n \n-fn ms_to_timeval(ms: u64) -> libc::timeval {\n-    libc::timeval {\n-        tv_sec: (ms / 1000) as libc::time_t,\n-        tv_usec: ((ms % 1000) * 1000) as libc::suseconds_t,\n-    }\n-}\n-\n-fn timeout(desc: &'static str) -> io::IoError {\n-    io::IoError {\n-        kind: io::TimedOut,\n-        desc: desc,\n-        detail: None,\n-    }\n-}\n-\n #[cfg(windows)] unsafe fn close(sock: sock_t) { let _ = libc::closesocket(sock); }\n #[cfg(unix)]    unsafe fn close(sock: sock_t) { let _ = libc::close(sock); }\n \n@@ -270,7 +254,7 @@ impl TcpStream {\n         let addrp = &addr as *_ as *libc::sockaddr;\n         match timeout {\n             Some(timeout) => {\n-                try!(TcpStream::connect_timeout(fd, addrp, len, timeout));\n+                try!(util::connect_timeout(fd, addrp, len, timeout));\n                 Ok(ret)\n             },\n             None => {\n@@ -282,84 +266,6 @@ impl TcpStream {\n         }\n     }\n \n-    // See http://developerweb.net/viewtopic.php?id=3196 for where this is\n-    // derived from.\n-    fn connect_timeout(fd: sock_t,\n-                       addrp: *libc::sockaddr,\n-                       len: libc::socklen_t,\n-                       timeout_ms: u64) -> IoResult<()> {\n-        #[cfg(unix)]    use INPROGRESS = libc::EINPROGRESS;\n-        #[cfg(windows)] use INPROGRESS = libc::WSAEINPROGRESS;\n-        #[cfg(unix)]    use WOULDBLOCK = libc::EWOULDBLOCK;\n-        #[cfg(windows)] use WOULDBLOCK = libc::WSAEWOULDBLOCK;\n-\n-        // Make sure the call to connect() doesn't block\n-        try!(set_nonblocking(fd, true));\n-\n-        let ret = match unsafe { libc::connect(fd, addrp, len) } {\n-            // If the connection is in progress, then we need to wait for it to\n-            // finish (with a timeout). The current strategy for doing this is\n-            // to use select() with a timeout.\n-            -1 if os::errno() as int == INPROGRESS as int ||\n-                  os::errno() as int == WOULDBLOCK as int => {\n-                let mut set: c::fd_set = unsafe { mem::init() };\n-                c::fd_set(&mut set, fd);\n-                match await(fd, &mut set, timeout_ms) {\n-                    0 => Err(timeout(\"connection timed out\")),\n-                    -1 => Err(last_error()),\n-                    _ => {\n-                        let err: libc::c_int = try!(\n-                            getsockopt(fd, libc::SOL_SOCKET, libc::SO_ERROR));\n-                        if err == 0 {\n-                            Ok(())\n-                        } else {\n-                            Err(io::IoError::from_errno(err as uint, true))\n-                        }\n-                    }\n-                }\n-            }\n-\n-            -1 => Err(last_error()),\n-            _ => Ok(()),\n-        };\n-\n-        // be sure to turn blocking I/O back on\n-        try!(set_nonblocking(fd, false));\n-        return ret;\n-\n-        #[cfg(unix)]\n-        fn set_nonblocking(fd: sock_t, nb: bool) -> IoResult<()> {\n-            let set = nb as libc::c_int;\n-            super::mkerr_libc(retry(|| unsafe { c::ioctl(fd, c::FIONBIO, &set) }))\n-        }\n-        #[cfg(windows)]\n-        fn set_nonblocking(fd: sock_t, nb: bool) -> IoResult<()> {\n-            let mut set = nb as libc::c_ulong;\n-            if unsafe { c::ioctlsocket(fd, c::FIONBIO, &mut set) != 0 } {\n-                Err(last_error())\n-            } else {\n-                Ok(())\n-            }\n-        }\n-\n-        #[cfg(unix)]\n-        fn await(fd: sock_t, set: &mut c::fd_set, timeout: u64) -> libc::c_int {\n-            let start = ::io::timer::now();\n-            retry(|| unsafe {\n-                // Recalculate the timeout each iteration (it is generally\n-                // undefined what the value of the 'tv' is after select\n-                // returns EINTR).\n-                let tv = ms_to_timeval(timeout - (::io::timer::now() - start));\n-                c::select(fd + 1, ptr::null(), &*set, ptr::null(), &tv)\n-            })\n-        }\n-        #[cfg(windows)]\n-        fn await(_fd: sock_t, set: &mut c::fd_set, timeout: u64) -> libc::c_int {\n-            let tv = ms_to_timeval(timeout);\n-            unsafe { c::select(1, ptr::null(), &*set, ptr::null(), &tv) }\n-        }\n-    }\n-\n     pub fn fd(&self) -> sock_t {\n         // This unsafety is fine because it's just a read-only arc\n         unsafe { (*self.inner.get()).fd }\n@@ -533,7 +439,7 @@ impl TcpAcceptor {\n \n     pub fn native_accept(&mut self) -> IoResult<TcpStream> {\n         if self.deadline != 0 {\n-            try!(self.accept_deadline());\n+            try!(util::accept_deadline(self.fd(), self.deadline));\n         }\n         unsafe {\n             let mut storage: libc::sockaddr_storage = mem::init();\n@@ -550,25 +456,6 @@ impl TcpAcceptor {\n             }\n         }\n     }\n-\n-    fn accept_deadline(&mut self) -> IoResult<()> {\n-        let mut set: c::fd_set = unsafe { mem::init() };\n-        c::fd_set(&mut set, self.fd());\n-\n-        match retry(|| {\n-            // If we're past the deadline, then pass a 0 timeout to select() so\n-            // we can poll the status of the socket.\n-            let now = ::io::timer::now();\n-            let ms = if self.deadline > now {0} else {self.deadline - now};\n-            let tv = ms_to_timeval(ms);\n-            let n = if cfg!(windows) {1} else {self.fd() as libc::c_int + 1};\n-            unsafe { c::select(n, &set, ptr::null(), ptr::null(), &tv) }\n-        }) {\n-            -1 => Err(last_error()),\n-            0 => Err(timeout(\"accept timed out\")),\n-            _ => return Ok(()),\n-        }\n-    }\n }\n \n impl rtio::RtioSocket for TcpAcceptor {\n@@ -585,10 +472,7 @@ impl rtio::RtioTcpAcceptor for TcpAcceptor {\n     fn accept_simultaneously(&mut self) -> IoResult<()> { Ok(()) }\n     fn dont_accept_simultaneously(&mut self) -> IoResult<()> { Ok(()) }\n     fn set_timeout(&mut self, timeout: Option<u64>) {\n-        self.deadline = match timeout {\n-            None => 0,\n-            Some(t) => ::io::timer::now() + t,\n-        };\n+        self.deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n     }\n }\n "}, {"sha": "190cae05d4343c05d6c5981c22d5ebe63bc33019", "filename": "src/libnative/io/pipe_unix.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/6328f7c199a1697aaee7e5fe2b397c457e6c311a/src%2Flibnative%2Fio%2Fpipe_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6328f7c199a1697aaee7e5fe2b397c457e6c311a/src%2Flibnative%2Fio%2Fpipe_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_unix.rs?ref=6328f7c199a1697aaee7e5fe2b397c457e6c311a", "patch": "@@ -8,16 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use libc;\n use std::c_str::CString;\n use std::cast;\n+use std::intrinsics;\n use std::io;\n-use libc;\n use std::mem;\n use std::rt::rtio;\n use std::sync::arc::UnsafeArc;\n-use std::intrinsics;\n \n use super::{IoResult, retry, keep_going};\n+use super::util;\n use super::file::fd_t;\n \n fn unix_socket(ty: libc::c_int) -> IoResult<fd_t> {\n@@ -52,22 +53,6 @@ fn addr_to_sockaddr_un(addr: &CString) -> IoResult<(libc::sockaddr_storage, uint\n     return Ok((storage, len));\n }\n \n-fn sockaddr_to_unix(storage: &libc::sockaddr_storage,\n-                    len: uint) -> IoResult<CString> {\n-    match storage.ss_family as libc::c_int {\n-        libc::AF_UNIX => {\n-            assert!(len as uint <= mem::size_of::<libc::sockaddr_un>());\n-            let storage: &libc::sockaddr_un = unsafe {\n-                cast::transmute(storage)\n-            };\n-            unsafe {\n-                Ok(CString::new(storage.sun_path.as_ptr(), false).clone())\n-            }\n-        }\n-        _ => Err(io::standard_error(io::InvalidInput))\n-    }\n-}\n-\n struct Inner {\n     fd: fd_t,\n }\n@@ -76,16 +61,24 @@ impl Drop for Inner {\n     fn drop(&mut self) { unsafe { let _ = libc::close(self.fd); } }\n }\n \n-fn connect(addr: &CString, ty: libc::c_int) -> IoResult<Inner> {\n+fn connect(addr: &CString, ty: libc::c_int,\n+           timeout: Option<u64>) -> IoResult<Inner> {\n     let (addr, len) = try!(addr_to_sockaddr_un(addr));\n     let inner = Inner { fd: try!(unix_socket(ty)) };\n-    let addrp = &addr as *libc::sockaddr_storage;\n-    match retry(|| unsafe {\n-        libc::connect(inner.fd, addrp as *libc::sockaddr,\n-                      len as libc::socklen_t)\n-    }) {\n-        -1 => Err(super::last_error()),\n-        _  => Ok(inner)\n+    let addrp = &addr as *_ as *libc::sockaddr;\n+    let len = len as libc::socklen_t;\n+\n+    match timeout {\n+        None => {\n+            match retry(|| unsafe { libc::connect(inner.fd, addrp, len) }) {\n+                -1 => Err(super::last_error()),\n+                _  => Ok(inner)\n+            }\n+        }\n+        Some(timeout_ms) => {\n+            try!(util::connect_timeout(inner.fd, addrp, len, timeout_ms));\n+            Ok(inner)\n+        }\n     }\n }\n \n@@ -110,8 +103,9 @@ pub struct UnixStream {\n }\n \n impl UnixStream {\n-    pub fn connect(addr: &CString) -> IoResult<UnixStream> {\n-        connect(addr, libc::SOCK_STREAM).map(|inner| {\n+    pub fn connect(addr: &CString,\n+                   timeout: Option<u64>) -> IoResult<UnixStream> {\n+        connect(addr, libc::SOCK_STREAM, timeout).map(|inner| {\n             UnixStream { inner: UnsafeArc::new(inner) }\n         })\n     }\n@@ -176,7 +170,7 @@ impl UnixListener {\n     pub fn native_listen(self, backlog: int) -> IoResult<UnixAcceptor> {\n         match unsafe { libc::listen(self.fd(), backlog as libc::c_int) } {\n             -1 => Err(super::last_error()),\n-            _ => Ok(UnixAcceptor { listener: self })\n+            _ => Ok(UnixAcceptor { listener: self, deadline: 0 })\n         }\n     }\n }\n@@ -189,12 +183,16 @@ impl rtio::RtioUnixListener for UnixListener {\n \n pub struct UnixAcceptor {\n     listener: UnixListener,\n+    deadline: u64,\n }\n \n impl UnixAcceptor {\n     fn fd(&self) -> fd_t { self.listener.fd() }\n \n     pub fn native_accept(&mut self) -> IoResult<UnixStream> {\n+        if self.deadline != 0 {\n+            try!(util::accept_deadline(self.fd(), self.deadline));\n+        }\n         let mut storage: libc::sockaddr_storage = unsafe { intrinsics::init() };\n         let storagep = &mut storage as *mut libc::sockaddr_storage;\n         let size = mem::size_of::<libc::sockaddr_storage>();\n@@ -214,6 +212,9 @@ impl rtio::RtioUnixAcceptor for UnixAcceptor {\n     fn accept(&mut self) -> IoResult<~rtio::RtioPipe:Send> {\n         self.native_accept().map(|s| ~s as ~rtio::RtioPipe:Send)\n     }\n+    fn set_timeout(&mut self, timeout: Option<u64>) {\n+        self.deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    }\n }\n \n impl Drop for UnixListener {"}, {"sha": "a4f09ded0ac110095bef3ef0fadb1bfa6b9138b7", "filename": "src/libnative/io/pipe_win32.rs", "status": "modified", "additions": 50, "deletions": 6, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6328f7c199a1697aaee7e5fe2b397c457e6c311a/src%2Flibnative%2Fio%2Fpipe_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6328f7c199a1697aaee7e5fe2b397c457e6c311a/src%2Flibnative%2Fio%2Fpipe_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_win32.rs?ref=6328f7c199a1697aaee7e5fe2b397c457e6c311a", "patch": "@@ -93,6 +93,8 @@ use std::sync::arc::UnsafeArc;\n use std::intrinsics;\n \n use super::IoResult;\n+use super::c;\n+use super::util;\n \n struct Event(libc::HANDLE);\n \n@@ -210,8 +212,9 @@ impl UnixStream {\n         None\n     }\n \n-    pub fn connect(addr: &CString) -> IoResult<UnixStream> {\n+    pub fn connect(addr: &CString, timeout: Option<u64>) -> IoResult<UnixStream> {\n         as_utf16_p(addr.as_str().unwrap(), |p| {\n+            let start = ::io::timer::now();\n             loop {\n                 match UnixStream::try_connect(p) {\n                     Some(handle) => {\n@@ -246,11 +249,26 @@ impl UnixStream {\n                     return Err(super::last_error())\n                 }\n \n-                // An example I found on microsoft's website used 20 seconds,\n-                // libuv uses 30 seconds, hence we make the obvious choice of\n-                // waiting for 25 seconds.\n-                if unsafe { libc::WaitNamedPipeW(p, 25000) } == 0 {\n-                    return Err(super::last_error())\n+                match timeout {\n+                    Some(timeout) => {\n+                        let now = ::io::timer::now();\n+                        let timed_out = (now - start) >= timeout || unsafe {\n+                            let ms = (timeout - (now - start)) as libc::DWORD;\n+                            libc::WaitNamedPipeW(p, ms) == 0\n+                        };\n+                        if timed_out {\n+                            return Err(util::timeout(\"connect timed out\"))\n+                        }\n+                    }\n+\n+                    // An example I found on microsoft's website used 20\n+                    // seconds, libuv uses 30 seconds, hence we make the\n+                    // obvious choice of waiting for 25 seconds.\n+                    None => {\n+                        if unsafe { libc::WaitNamedPipeW(p, 25000) } == 0 {\n+                            return Err(super::last_error())\n+                        }\n+                    }\n                 }\n             }\n         })\n@@ -372,6 +390,7 @@ impl UnixListener {\n         Ok(UnixAcceptor {\n             listener: self,\n             event: try!(Event::new(true, false)),\n+            deadline: 0,\n         })\n     }\n }\n@@ -391,6 +410,7 @@ impl rtio::RtioUnixListener for UnixListener {\n pub struct UnixAcceptor {\n     listener: UnixListener,\n     event: Event,\n+    deadline: u64,\n }\n \n impl UnixAcceptor {\n@@ -438,7 +458,28 @@ impl UnixAcceptor {\n         overlapped.hEvent = self.event.handle();\n         if unsafe { libc::ConnectNamedPipe(handle, &mut overlapped) == 0 } {\n             let mut err = unsafe { libc::GetLastError() };\n+\n             if err == libc::ERROR_IO_PENDING as libc::DWORD {\n+                // If we've got a timeout, use WaitForSingleObject in tandem\n+                // with CancelIo to figure out if we should indeed get the\n+                // result.\n+                if self.deadline != 0 {\n+                    let now = ::io::timer::now();\n+                    let timeout = self.deadline < now || unsafe {\n+                        let ms = (self.deadline - now) as libc::DWORD;\n+                        let r = libc::WaitForSingleObject(overlapped.hEvent,\n+                                                          ms);\n+                        r != libc::WAIT_OBJECT_0\n+                    };\n+                    if timeout {\n+                        unsafe { let _ = c::CancelIo(handle); }\n+                        return Err(util::timeout(\"accept timed out\"))\n+                    }\n+                }\n+\n+                // This will block until the overlapped I/O is completed. The\n+                // timeout was previously handled, so this will either block in\n+                // the normal case or succeed very quickly in the timeout case.\n                 let ret = unsafe {\n                     let mut transfer = 0;\n                     libc::GetOverlappedResult(handle,\n@@ -488,5 +529,8 @@ impl rtio::RtioUnixAcceptor for UnixAcceptor {\n     fn accept(&mut self) -> IoResult<~rtio::RtioPipe:Send> {\n         self.native_accept().map(|s| ~s as ~rtio::RtioPipe:Send)\n     }\n+    fn set_timeout(&mut self, timeout: Option<u64>) {\n+        self.deadline = timeout.map(|i| i + ::io::timer::now()).unwrap_or(0);\n+    }\n }\n "}, {"sha": "0aaac8f8ad81e41b8e733caaf779c307e09d874d", "filename": "src/libnative/io/util.rs", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/6328f7c199a1697aaee7e5fe2b397c457e6c311a/src%2Flibnative%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6328f7c199a1697aaee7e5fe2b397c457e6c311a/src%2Flibnative%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Futil.rs?ref=6328f7c199a1697aaee7e5fe2b397c457e6c311a", "patch": "@@ -0,0 +1,136 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use libc;\n+use std::io::IoResult;\n+use std::io;\n+use std::mem;\n+use std::ptr;\n+\n+use super::c;\n+use super::net;\n+use super::{retry, last_error};\n+\n+pub fn timeout(desc: &'static str) -> io::IoError {\n+    io::IoError {\n+        kind: io::TimedOut,\n+        desc: desc,\n+        detail: None,\n+    }\n+}\n+\n+pub fn ms_to_timeval(ms: u64) -> libc::timeval {\n+    libc::timeval {\n+        tv_sec: (ms / 1000) as libc::time_t,\n+        tv_usec: ((ms % 1000) * 1000) as libc::suseconds_t,\n+    }\n+}\n+\n+// See http://developerweb.net/viewtopic.php?id=3196 for where this is\n+// derived from.\n+pub fn connect_timeout(fd: net::sock_t,\n+                       addrp: *libc::sockaddr,\n+                       len: libc::socklen_t,\n+                       timeout_ms: u64) -> IoResult<()> {\n+    use std::os;\n+    #[cfg(unix)]    use INPROGRESS = libc::EINPROGRESS;\n+    #[cfg(windows)] use INPROGRESS = libc::WSAEINPROGRESS;\n+    #[cfg(unix)]    use WOULDBLOCK = libc::EWOULDBLOCK;\n+    #[cfg(windows)] use WOULDBLOCK = libc::WSAEWOULDBLOCK;\n+\n+    // Make sure the call to connect() doesn't block\n+    try!(set_nonblocking(fd, true));\n+\n+    let ret = match unsafe { libc::connect(fd, addrp, len) } {\n+        // If the connection is in progress, then we need to wait for it to\n+        // finish (with a timeout). The current strategy for doing this is\n+        // to use select() with a timeout.\n+        -1 if os::errno() as int == INPROGRESS as int ||\n+              os::errno() as int == WOULDBLOCK as int => {\n+            let mut set: c::fd_set = unsafe { mem::init() };\n+            c::fd_set(&mut set, fd);\n+            match await(fd, &mut set, timeout_ms) {\n+                0 => Err(timeout(\"connection timed out\")),\n+                -1 => Err(last_error()),\n+                _ => {\n+                    let err: libc::c_int = try!(\n+                        net::getsockopt(fd, libc::SOL_SOCKET, libc::SO_ERROR));\n+                    if err == 0 {\n+                        Ok(())\n+                    } else {\n+                        Err(io::IoError::from_errno(err as uint, true))\n+                    }\n+                }\n+            }\n+        }\n+\n+        -1 => Err(last_error()),\n+        _ => Ok(()),\n+    };\n+\n+    // be sure to turn blocking I/O back on\n+    try!(set_nonblocking(fd, false));\n+    return ret;\n+\n+    #[cfg(unix)]\n+    fn set_nonblocking(fd: net::sock_t, nb: bool) -> IoResult<()> {\n+        let set = nb as libc::c_int;\n+        super::mkerr_libc(retry(|| unsafe { c::ioctl(fd, c::FIONBIO, &set) }))\n+    }\n+\n+    #[cfg(windows)]\n+    fn set_nonblocking(fd: net::sock_t, nb: bool) -> IoResult<()> {\n+        let mut set = nb as libc::c_ulong;\n+        if unsafe { c::ioctlsocket(fd, c::FIONBIO, &mut set) != 0 } {\n+            Err(last_error())\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n+    #[cfg(unix)]\n+    fn await(fd: net::sock_t, set: &mut c::fd_set,\n+             timeout: u64) -> libc::c_int {\n+        let start = ::io::timer::now();\n+        retry(|| unsafe {\n+            // Recalculate the timeout each iteration (it is generally\n+            // undefined what the value of the 'tv' is after select\n+            // returns EINTR).\n+            let tv = ms_to_timeval(timeout - (::io::timer::now() - start));\n+            c::select(fd + 1, ptr::null(), set as *mut _ as *_,\n+                      ptr::null(), &tv)\n+        })\n+    }\n+    #[cfg(windows)]\n+    fn await(_fd: net::sock_t, set: &mut c::fd_set,\n+             timeout: u64) -> libc::c_int {\n+        let tv = ms_to_timeval(timeout);\n+        unsafe { c::select(1, ptr::null(), &*set, ptr::null(), &tv) }\n+    }\n+}\n+\n+pub fn accept_deadline(fd: net::sock_t, deadline: u64) -> IoResult<()> {\n+    let mut set: c::fd_set = unsafe { mem::init() };\n+    c::fd_set(&mut set, fd);\n+\n+    match retry(|| {\n+        // If we're past the deadline, then pass a 0 timeout to select() so\n+        // we can poll the status of the socket.\n+        let now = ::io::timer::now();\n+        let ms = if deadline < now {0} else {deadline - now};\n+        let tv = ms_to_timeval(ms);\n+        let n = if cfg!(windows) {1} else {fd as libc::c_int + 1};\n+        unsafe { c::select(n, &set, ptr::null(), ptr::null(), &tv) }\n+    }) {\n+        -1 => Err(last_error()),\n+        0 => Err(timeout(\"accept timed out\")),\n+        _ => return Ok(()),\n+    }\n+}"}, {"sha": "470a343b84ed662678ef5e5f7bc079f6ea19a0ee", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 180, "deletions": 152, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/6328f7c199a1697aaee7e5fe2b397c457e6c311a/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6328f7c199a1697aaee7e5fe2b397c457e6c311a/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=6328f7c199a1697aaee7e5fe2b397c457e6c311a", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::cast;\n-use std::io::IoError;\n+use std::io::{IoError, IoResult};\n use std::io::net::ip;\n use libc::{size_t, ssize_t, c_int, c_void, c_uint};\n use libc;\n@@ -145,96 +145,43 @@ fn socket_name(sk: SocketNameKind,\n         n => Err(uv_error_to_io_error(UvError(n)))\n     }\n }\n-\n ////////////////////////////////////////////////////////////////////////////////\n-/// TCP implementation\n+// Helpers for handling timeouts, shared for pipes/tcp\n ////////////////////////////////////////////////////////////////////////////////\n \n-pub struct TcpWatcher {\n-    handle: *uvll::uv_tcp_t,\n-    stream: StreamWatcher,\n-    home: HomeHandle,\n-    refcount: Refcount,\n-\n-    // libuv can't support concurrent reads and concurrent writes of the same\n-    // stream object, so we use these access guards in order to arbitrate among\n-    // multiple concurrent reads and writes. Note that libuv *can* read and\n-    // write simultaneously, it just can't read and read simultaneously.\n-    read_access: Access,\n-    write_access: Access,\n-}\n-\n-pub struct TcpListener {\n-    home: HomeHandle,\n-    handle: *uvll::uv_pipe_t,\n-    closing_task: Option<BlockedTask>,\n-    outgoing: Sender<Result<~rtio::RtioTcpStream:Send, IoError>>,\n-    incoming: Receiver<Result<~rtio::RtioTcpStream:Send, IoError>>,\n+pub struct ConnectCtx {\n+    pub status: c_int,\n+    pub task: Option<BlockedTask>,\n+    pub timer: Option<~TimerWatcher>,\n }\n \n-pub struct TcpAcceptor {\n-    listener: ~TcpListener,\n+pub struct AcceptTimeout {\n     timer: Option<TimerWatcher>,\n     timeout_tx: Option<Sender<()>>,\n     timeout_rx: Option<Receiver<()>>,\n }\n \n-// TCP watchers (clients/streams)\n-\n-impl TcpWatcher {\n-    pub fn new(io: &mut UvIoFactory) -> TcpWatcher {\n-        let handle = io.make_handle();\n-        TcpWatcher::new_home(&io.loop_, handle)\n-    }\n-\n-    fn new_home(loop_: &Loop, home: HomeHandle) -> TcpWatcher {\n-        let handle = unsafe { uvll::malloc_handle(uvll::UV_TCP) };\n-        assert_eq!(unsafe {\n-            uvll::uv_tcp_init(loop_.handle, handle)\n-        }, 0);\n-        TcpWatcher {\n-            home: home,\n-            handle: handle,\n-            stream: StreamWatcher::new(handle),\n-            refcount: Refcount::new(),\n-            read_access: Access::new(),\n-            write_access: Access::new(),\n-        }\n-    }\n-\n-    pub fn connect(io: &mut UvIoFactory,\n-                   address: ip::SocketAddr,\n-                   timeout: Option<u64>) -> Result<TcpWatcher, UvError> {\n-        struct Ctx {\n-            status: c_int,\n-            task: Option<BlockedTask>,\n-            timer: Option<~TimerWatcher>,\n-        }\n-\n-        let tcp = TcpWatcher::new(io);\n-        let (addr, _len) = addr_to_sockaddr(address);\n+impl ConnectCtx {\n+    pub fn connect<T>(\n+        mut self, obj: T, timeout: Option<u64>, io: &mut UvIoFactory,\n+        f: |&Request, &T, uvll::uv_connect_cb| -> libc::c_int\n+    ) -> Result<T, UvError> {\n         let mut req = Request::new(uvll::UV_CONNECT);\n-        let result = unsafe {\n-            let addr_p = &addr as *libc::sockaddr_storage;\n-            uvll::uv_tcp_connect(req.handle, tcp.handle,\n-                                 addr_p as *libc::sockaddr,\n-                                 connect_cb)\n-        };\n-        return match result {\n+        let r = f(&req, &obj, connect_cb);\n+        return match r {\n             0 => {\n                 req.defuse(); // uv callback now owns this request\n-                let mut cx = Ctx { status: -1, task: None, timer: None };\n                 match timeout {\n                     Some(t) => {\n                         let mut timer = TimerWatcher::new(io);\n                         timer.start(timer_cb, t, 0);\n-                        cx.timer = Some(timer);\n+                        self.timer = Some(timer);\n                     }\n                     None => {}\n                 }\n-                wait_until_woken_after(&mut cx.task, &io.loop_, || {\n-                    let data = &cx as *_;\n-                    match cx.timer {\n+                wait_until_woken_after(&mut self.task, &io.loop_, || {\n+                    let data = &self as *_;\n+                    match self.timer {\n                         Some(ref mut timer) => unsafe { timer.set_data(data) },\n                         None => {}\n                     }\n@@ -247,9 +194,9 @@ impl TcpWatcher {\n                 // If we failed because of a timeout, drop the TcpWatcher as\n                 // soon as possible because it's data is now set to null and we\n                 // want to cancel the callback ASAP.\n-                match cx.status {\n-                    0 => Ok(tcp),\n-                    n => { drop(tcp); Err(UvError(n)) }\n+                match self.status {\n+                    0 => Ok(obj),\n+                    n => { drop(obj); Err(UvError(n)) }\n                 }\n             }\n             n => Err(UvError(n))\n@@ -258,8 +205,8 @@ impl TcpWatcher {\n         extern fn timer_cb(handle: *uvll::uv_timer_t) {\n             // Don't close the corresponding tcp request, just wake up the task\n             // and let RAII take care of the pending watcher.\n-            let cx: &mut Ctx = unsafe {\n-                &mut *(uvll::get_data_for_uv_handle(handle) as *mut Ctx)\n+            let cx: &mut ConnectCtx = unsafe {\n+                &mut *(uvll::get_data_for_uv_handle(handle) as *mut ConnectCtx)\n             };\n             cx.status = uvll::ECANCELED;\n             wakeup(&mut cx.task);\n@@ -279,7 +226,7 @@ impl TcpWatcher {\n             let data = unsafe { uvll::get_data_for_req(req.handle) };\n             if data.is_null() { return }\n \n-            let cx: &mut Ctx = unsafe { &mut *(data as *mut Ctx) };\n+            let cx: &mut ConnectCtx = unsafe { &mut *(data as *mut ConnectCtx) };\n             cx.status = status;\n             match cx.timer {\n                 Some(ref mut t) => t.stop(),\n@@ -299,6 +246,157 @@ impl TcpWatcher {\n     }\n }\n \n+impl AcceptTimeout {\n+    pub fn new() -> AcceptTimeout {\n+        AcceptTimeout { timer: None, timeout_tx: None, timeout_rx: None }\n+    }\n+\n+    pub fn accept<T: Send>(&mut self, c: &Receiver<IoResult<T>>) -> IoResult<T> {\n+        match self.timeout_rx {\n+            None => c.recv(),\n+            Some(ref rx) => {\n+                use std::comm::Select;\n+\n+                // Poll the incoming channel first (don't rely on the order of\n+                // select just yet). If someone's pending then we should return\n+                // them immediately.\n+                match c.try_recv() {\n+                    Ok(data) => return data,\n+                    Err(..) => {}\n+                }\n+\n+                // Use select to figure out which channel gets ready first. We\n+                // do some custom handling of select to ensure that we never\n+                // actually drain the timeout channel (we'll keep seeing the\n+                // timeout message in the future).\n+                let s = Select::new();\n+                let mut timeout = s.handle(rx);\n+                let mut data = s.handle(c);\n+                unsafe {\n+                    timeout.add();\n+                    data.add();\n+                }\n+                if s.wait() == timeout.id() {\n+                    Err(uv_error_to_io_error(UvError(uvll::ECANCELED)))\n+                } else {\n+                    c.recv()\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn clear(&mut self) {\n+        // Clear any previous timeout by dropping the timer and transmission\n+        // channels\n+        drop((self.timer.take(),\n+              self.timeout_tx.take(),\n+              self.timeout_rx.take()))\n+    }\n+\n+    pub fn set_timeout<U, T: UvHandle<U> + HomingIO>(\n+        &mut self, ms: u64, t: &mut T\n+    ) {\n+        // If we have a timeout, lazily initialize the timer which will be used\n+        // to fire when the timeout runs out.\n+        if self.timer.is_none() {\n+            let _m = t.fire_homing_missile();\n+            let loop_ = Loop::wrap(unsafe {\n+                uvll::get_loop_for_uv_handle(t.uv_handle())\n+            });\n+            let mut timer = TimerWatcher::new_home(&loop_, t.home().clone());\n+            unsafe {\n+                timer.set_data(self as *mut _ as *AcceptTimeout);\n+            }\n+            self.timer = Some(timer);\n+        }\n+\n+        // Once we've got a timer, stop any previous timeout, reset it for the\n+        // current one, and install some new channels to send/receive data on\n+        let timer = self.timer.get_mut_ref();\n+        timer.stop();\n+        timer.start(timer_cb, ms, 0);\n+        let (tx, rx) = channel();\n+        self.timeout_tx = Some(tx);\n+        self.timeout_rx = Some(rx);\n+\n+        extern fn timer_cb(timer: *uvll::uv_timer_t) {\n+            let acceptor: &mut AcceptTimeout = unsafe {\n+                &mut *(uvll::get_data_for_uv_handle(timer) as *mut AcceptTimeout)\n+            };\n+            // This send can never fail because if this timer is active then the\n+            // receiving channel is guaranteed to be alive\n+            acceptor.timeout_tx.get_ref().send(());\n+        }\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+/// TCP implementation\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct TcpWatcher {\n+    handle: *uvll::uv_tcp_t,\n+    stream: StreamWatcher,\n+    home: HomeHandle,\n+    refcount: Refcount,\n+\n+    // libuv can't support concurrent reads and concurrent writes of the same\n+    // stream object, so we use these access guards in order to arbitrate among\n+    // multiple concurrent reads and writes. Note that libuv *can* read and\n+    // write simultaneously, it just can't read and read simultaneously.\n+    read_access: Access,\n+    write_access: Access,\n+}\n+\n+pub struct TcpListener {\n+    home: HomeHandle,\n+    handle: *uvll::uv_pipe_t,\n+    closing_task: Option<BlockedTask>,\n+    outgoing: Sender<Result<~rtio::RtioTcpStream:Send, IoError>>,\n+    incoming: Receiver<Result<~rtio::RtioTcpStream:Send, IoError>>,\n+}\n+\n+pub struct TcpAcceptor {\n+    listener: ~TcpListener,\n+    timeout: AcceptTimeout,\n+}\n+\n+// TCP watchers (clients/streams)\n+\n+impl TcpWatcher {\n+    pub fn new(io: &mut UvIoFactory) -> TcpWatcher {\n+        let handle = io.make_handle();\n+        TcpWatcher::new_home(&io.loop_, handle)\n+    }\n+\n+    fn new_home(loop_: &Loop, home: HomeHandle) -> TcpWatcher {\n+        let handle = unsafe { uvll::malloc_handle(uvll::UV_TCP) };\n+        assert_eq!(unsafe {\n+            uvll::uv_tcp_init(loop_.handle, handle)\n+        }, 0);\n+        TcpWatcher {\n+            home: home,\n+            handle: handle,\n+            stream: StreamWatcher::new(handle),\n+            refcount: Refcount::new(),\n+            read_access: Access::new(),\n+            write_access: Access::new(),\n+        }\n+    }\n+\n+    pub fn connect(io: &mut UvIoFactory,\n+                   address: ip::SocketAddr,\n+                   timeout: Option<u64>) -> Result<TcpWatcher, UvError> {\n+        let tcp = TcpWatcher::new(io);\n+        let cx = ConnectCtx { status: -1, task: None, timer: None };\n+        let (addr, _len) = addr_to_sockaddr(address);\n+        let addr_p = &addr as *_ as *libc::sockaddr;\n+        cx.connect(tcp, timeout, io, |req, tcp, cb| {\n+            unsafe { uvll::uv_tcp_connect(req.handle, tcp.handle, addr_p, cb) }\n+        })\n+    }\n+}\n+\n impl HomingIO for TcpWatcher {\n     fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n }\n@@ -463,9 +561,7 @@ impl rtio::RtioTcpListener for TcpListener {\n         // create the acceptor object from ourselves\n         let mut acceptor = ~TcpAcceptor {\n             listener: self,\n-            timer: None,\n-            timeout_tx: None,\n-            timeout_rx: None,\n+            timeout: AcceptTimeout::new(),\n         };\n \n         let _m = acceptor.fire_homing_missile();\n@@ -516,37 +612,7 @@ impl rtio::RtioSocket for TcpAcceptor {\n \n impl rtio::RtioTcpAcceptor for TcpAcceptor {\n     fn accept(&mut self) -> Result<~rtio::RtioTcpStream:Send, IoError> {\n-        match self.timeout_rx {\n-            None => self.listener.incoming.recv(),\n-            Some(ref rx) => {\n-                use std::comm::Select;\n-\n-                // Poll the incoming channel first (don't rely on the order of\n-                // select just yet). If someone's pending then we should return\n-                // them immediately.\n-                match self.listener.incoming.try_recv() {\n-                    Ok(data) => return data,\n-                    Err(..) => {}\n-                }\n-\n-                // Use select to figure out which channel gets ready first. We\n-                // do some custom handling of select to ensure that we never\n-                // actually drain the timeout channel (we'll keep seeing the\n-                // timeout message in the future).\n-                let s = Select::new();\n-                let mut timeout = s.handle(rx);\n-                let mut data = s.handle(&self.listener.incoming);\n-                unsafe {\n-                    timeout.add();\n-                    data.add();\n-                }\n-                if s.wait() == timeout.id() {\n-                    Err(uv_error_to_io_error(UvError(uvll::ECANCELED)))\n-                } else {\n-                    self.listener.incoming.recv()\n-                }\n-            }\n-        }\n+        self.timeout.accept(&self.listener.incoming)\n     }\n \n     fn accept_simultaneously(&mut self) -> Result<(), IoError> {\n@@ -564,47 +630,9 @@ impl rtio::RtioTcpAcceptor for TcpAcceptor {\n     }\n \n     fn set_timeout(&mut self, ms: Option<u64>) {\n-        // First, if the timeout is none, clear any previous timeout by dropping\n-        // the timer and transmission channels\n-        let ms = match ms {\n-            None => {\n-                return drop((self.timer.take(),\n-                             self.timeout_tx.take(),\n-                             self.timeout_rx.take()))\n-            }\n-            Some(ms) => ms,\n-        };\n-\n-        // If we have a timeout, lazily initialize the timer which will be used\n-        // to fire when the timeout runs out.\n-        if self.timer.is_none() {\n-            let _m = self.fire_homing_missile();\n-            let loop_ = Loop::wrap(unsafe {\n-                uvll::get_loop_for_uv_handle(self.listener.handle)\n-            });\n-            let mut timer = TimerWatcher::new_home(&loop_, self.home().clone());\n-            unsafe {\n-                timer.set_data(self as *mut _ as *TcpAcceptor);\n-            }\n-            self.timer = Some(timer);\n-        }\n-\n-        // Once we've got a timer, stop any previous timeout, reset it for the\n-        // current one, and install some new channels to send/receive data on\n-        let timer = self.timer.get_mut_ref();\n-        timer.stop();\n-        timer.start(timer_cb, ms, 0);\n-        let (tx, rx) = channel();\n-        self.timeout_tx = Some(tx);\n-        self.timeout_rx = Some(rx);\n-\n-        extern fn timer_cb(timer: *uvll::uv_timer_t) {\n-            let acceptor: &mut TcpAcceptor = unsafe {\n-                &mut *(uvll::get_data_for_uv_handle(timer) as *mut TcpAcceptor)\n-            };\n-            // This send can never fail because if this timer is active then the\n-            // receiving channel is guaranteed to be alive\n-            acceptor.timeout_tx.get_ref().send(());\n+        match ms {\n+            None => self.timeout.clear(),\n+            Some(ms) => self.timeout.set_timeout(ms, &mut *self.listener),\n         }\n     }\n }"}, {"sha": "7277be1616b7182653891d5e3bdbcae80beb71af", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 26, "deletions": 33, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/6328f7c199a1697aaee7e5fe2b397c457e6c311a/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6328f7c199a1697aaee7e5fe2b397c457e6c311a/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=6328f7c199a1697aaee7e5fe2b397c457e6c311a", "patch": "@@ -12,14 +12,13 @@ use std::c_str::CString;\n use std::io::IoError;\n use libc;\n use std::rt::rtio::{RtioPipe, RtioUnixListener, RtioUnixAcceptor};\n-use std::rt::task::BlockedTask;\n \n use access::Access;\n use homing::{HomingIO, HomeHandle};\n+use net;\n use rc::Refcount;\n use stream::StreamWatcher;\n-use super::{Loop, UvError, UvHandle, Request, uv_error_to_io_error,\n-            wait_until_woken_after, wakeup};\n+use super::{Loop, UvError, UvHandle, uv_error_to_io_error};\n use uvio::UvIoFactory;\n use uvll;\n \n@@ -43,6 +42,7 @@ pub struct PipeListener {\n \n pub struct PipeAcceptor {\n     listener: ~PipeListener,\n+    timeout: net::AcceptTimeout,\n }\n \n // PipeWatcher implementation and traits\n@@ -84,36 +84,18 @@ impl PipeWatcher {\n         }\n     }\n \n-    pub fn connect(io: &mut UvIoFactory, name: &CString)\n+    pub fn connect(io: &mut UvIoFactory, name: &CString, timeout: Option<u64>)\n         -> Result<PipeWatcher, UvError>\n     {\n-        struct Ctx { task: Option<BlockedTask>, result: libc::c_int, }\n-        let mut cx = Ctx { task: None, result: 0 };\n-        let mut req = Request::new(uvll::UV_CONNECT);\n         let pipe = PipeWatcher::new(io, false);\n-\n-        wait_until_woken_after(&mut cx.task, &io.loop_, || {\n+        let cx = net::ConnectCtx { status: -1, task: None, timer: None };\n+        cx.connect(pipe, timeout, io, |req, pipe, cb| {\n             unsafe {\n-                uvll::uv_pipe_connect(req.handle,\n-                                      pipe.handle(),\n-                                      name.with_ref(|p| p),\n-                                      connect_cb)\n+                uvll::uv_pipe_connect(req.handle, pipe.handle(),\n+                                      name.with_ref(|p| p), cb)\n             }\n-            req.set_data(&cx);\n-            req.defuse(); // uv callback now owns this request\n-        });\n-        return match cx.result {\n-            0 => Ok(pipe),\n-            n => Err(UvError(n))\n-        };\n-\n-        extern fn connect_cb(req: *uvll::uv_connect_t, status: libc::c_int) {;\n-            let req = Request::wrap(req);\n-            assert!(status != uvll::ECANCELED);\n-            let cx: &mut Ctx = unsafe { req.get_data() };\n-            cx.result = status;\n-            wakeup(&mut cx.task);\n-        }\n+            0\n+        })\n     }\n \n     pub fn handle(&self) -> *uvll::uv_pipe_t { self.stream.handle }\n@@ -199,7 +181,10 @@ impl PipeListener {\n impl RtioUnixListener for PipeListener {\n     fn listen(~self) -> Result<~RtioUnixAcceptor:Send, IoError> {\n         // create the acceptor object from ourselves\n-        let mut acceptor = ~PipeAcceptor { listener: self };\n+        let mut acceptor = ~PipeAcceptor {\n+            listener: self,\n+            timeout: net::AcceptTimeout::new(),\n+        };\n \n         let _m = acceptor.fire_homing_missile();\n         // FIXME: the 128 backlog should be configurable\n@@ -247,7 +232,14 @@ impl Drop for PipeListener {\n \n impl RtioUnixAcceptor for PipeAcceptor {\n     fn accept(&mut self) -> Result<~RtioPipe:Send, IoError> {\n-        self.listener.incoming.recv()\n+        self.timeout.accept(&self.listener.incoming)\n+    }\n+\n+    fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n+        match timeout_ms {\n+            None => self.timeout.clear(),\n+            Some(ms) => self.timeout.set_timeout(ms, &mut *self.listener),\n+        }\n     }\n }\n \n@@ -265,7 +257,8 @@ mod tests {\n \n     #[test]\n     fn connect_err() {\n-        match PipeWatcher::connect(local_loop(), &\"path/to/nowhere\".to_c_str()) {\n+        match PipeWatcher::connect(local_loop(), &\"path/to/nowhere\".to_c_str(),\n+                                   None) {\n             Ok(..) => fail!(),\n             Err(..) => {}\n         }\n@@ -312,7 +305,7 @@ mod tests {\n             assert!(client.write([2]).is_ok());\n         });\n         rx.recv();\n-        let mut c = PipeWatcher::connect(local_loop(), &path.to_c_str()).unwrap();\n+        let mut c = PipeWatcher::connect(local_loop(), &path.to_c_str(), None).unwrap();\n         assert!(c.write([1]).is_ok());\n         let mut buf = [0];\n         assert!(c.read(buf).unwrap() == 1);\n@@ -332,7 +325,7 @@ mod tests {\n             drop(p.accept().unwrap());\n         });\n         rx.recv();\n-        let _c = PipeWatcher::connect(local_loop(), &path.to_c_str()).unwrap();\n+        let _c = PipeWatcher::connect(local_loop(), &path.to_c_str(), None).unwrap();\n         fail!()\n \n     }"}, {"sha": "81d7ac6601e2337322e24ed617249f38b0479505", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6328f7c199a1697aaee7e5fe2b397c457e6c311a/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6328f7c199a1697aaee7e5fe2b397c457e6c311a/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=6328f7c199a1697aaee7e5fe2b397c457e6c311a", "patch": "@@ -291,8 +291,9 @@ impl IoFactory for UvIoFactory {\n         }\n     }\n \n-    fn unix_connect(&mut self, path: &CString) -> Result<~rtio::RtioPipe:Send, IoError> {\n-        match PipeWatcher::connect(self, path) {\n+    fn unix_connect(&mut self, path: &CString,\n+                    timeout: Option<u64>) -> Result<~rtio::RtioPipe:Send, IoError> {\n+        match PipeWatcher::connect(self, path, timeout) {\n             Ok(p) => Ok(~p as ~rtio::RtioPipe:Send),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }"}, {"sha": "b75b797e9744f28a38d682ee5f9e4c69ee150993", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 90, "deletions": 1, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/6328f7c199a1697aaee7e5fe2b397c457e6c311a/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6328f7c199a1697aaee7e5fe2b397c457e6c311a/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=6328f7c199a1697aaee7e5fe2b397c457e6c311a", "patch": "@@ -61,7 +61,31 @@ impl UnixStream {\n     /// ```\n     pub fn connect<P: ToCStr>(path: &P) -> IoResult<UnixStream> {\n         LocalIo::maybe_raise(|io| {\n-            io.unix_connect(&path.to_c_str()).map(UnixStream::new)\n+            io.unix_connect(&path.to_c_str(), None).map(UnixStream::new)\n+        })\n+    }\n+\n+    /// Connect to a pipe named by `path`. This will attempt to open a\n+    /// connection to the underlying socket.\n+    ///\n+    /// The returned stream will be closed when the object falls out of scope.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # #![allow(unused_must_use)]\n+    /// use std::io::net::unix::UnixStream;\n+    ///\n+    /// let server = Path::new(\"path/to/my/socket\");\n+    /// let mut stream = UnixStream::connect(&server);\n+    /// stream.write([1, 2, 3]);\n+    /// ```\n+    #[experimental = \"the timeout argument is likely to change types\"]\n+    pub fn connect_timeout<P: ToCStr>(path: &P,\n+                                      timeout_ms: u64) -> IoResult<UnixStream> {\n+        LocalIo::maybe_raise(|io| {\n+            let s = io.unix_connect(&path.to_c_str(), Some(timeout_ms));\n+            s.map(UnixStream::new)\n         })\n     }\n }\n@@ -128,13 +152,33 @@ pub struct UnixAcceptor {\n     obj: ~RtioUnixAcceptor:Send,\n }\n \n+impl UnixAcceptor {\n+    /// Sets a timeout for this acceptor, after which accept() will no longer\n+    /// block indefinitely.\n+    ///\n+    /// The argument specified is the amount of time, in milliseconds, into the\n+    /// future after which all invocations of accept() will not block (and any\n+    /// pending invocation will return). A value of `None` will clear any\n+    /// existing timeout.\n+    ///\n+    /// When using this method, it is likely necessary to reset the timeout as\n+    /// appropriate, the timeout specified is specific to this object, not\n+    /// specific to the next request.\n+    #[experimental = \"the name and arguments to this function are likely \\\n+                      to change\"]\n+    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n+        self.obj.set_timeout(timeout_ms)\n+    }\n+}\n+\n impl Acceptor<UnixStream> for UnixAcceptor {\n     fn accept(&mut self) -> IoResult<UnixStream> {\n         self.obj.accept().map(UnixStream::new)\n     }\n }\n \n #[cfg(test)]\n+#[allow(experimental)]\n mod tests {\n     use prelude::*;\n     use super::*;\n@@ -371,4 +415,49 @@ mod tests {\n         drop(l.listen().unwrap());\n         assert!(!path.exists());\n     } #[cfg(not(windows))])\n+\n+    iotest!(fn accept_timeout() {\n+        let addr = next_test_unix();\n+        let mut a = UnixListener::bind(&addr).unwrap().listen().unwrap();\n+\n+        a.set_timeout(Some(10));\n+\n+        // Make sure we time out once and future invocations also time out\n+        let err = a.accept().err().unwrap();\n+        assert_eq!(err.kind, TimedOut);\n+        let err = a.accept().err().unwrap();\n+        assert_eq!(err.kind, TimedOut);\n+\n+        // Also make sure that even though the timeout is expired that we will\n+        // continue to receive any pending connections.\n+        let l = UnixStream::connect(&addr).unwrap();\n+        for i in range(0, 1001) {\n+            match a.accept() {\n+                Ok(..) => break,\n+                Err(ref e) if e.kind == TimedOut => {}\n+                Err(e) => fail!(\"error: {}\", e),\n+            }\n+            if i == 1000 { fail!(\"should have a pending connection\") }\n+        }\n+        drop(l);\n+\n+        // Unset the timeout and make sure that this always blocks.\n+        a.set_timeout(None);\n+        let addr2 = addr.clone();\n+        spawn(proc() {\n+            drop(UnixStream::connect(&addr2));\n+        });\n+        a.accept().unwrap();\n+    })\n+\n+    iotest!(fn connect_timeout_error() {\n+        let addr = next_test_unix();\n+        assert!(UnixStream::connect_timeout(&addr, 100).is_err());\n+    })\n+\n+    iotest!(fn connect_timeout_success() {\n+        let addr = next_test_unix();\n+        let _a = UnixListener::bind(&addr).unwrap().listen().unwrap();\n+        assert!(UnixStream::connect_timeout(&addr, 100).is_ok());\n+    })\n }"}, {"sha": "f3c7fdaf7105b2115cc8a1f236363c9eff68d915", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6328f7c199a1697aaee7e5fe2b397c457e6c311a/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6328f7c199a1697aaee7e5fe2b397c457e6c311a/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=6328f7c199a1697aaee7e5fe2b397c457e6c311a", "patch": "@@ -152,7 +152,8 @@ pub trait IoFactory {\n     fn udp_bind(&mut self, addr: SocketAddr) -> IoResult<~RtioUdpSocket:Send>;\n     fn unix_bind(&mut self, path: &CString)\n         -> IoResult<~RtioUnixListener:Send>;\n-    fn unix_connect(&mut self, path: &CString) -> IoResult<~RtioPipe:Send>;\n+    fn unix_connect(&mut self, path: &CString,\n+                    timeout: Option<u64>) -> IoResult<~RtioPipe:Send>;\n     fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n                           hint: Option<ai::Hint>) -> IoResult<~[ai::Info]>;\n \n@@ -274,6 +275,7 @@ pub trait RtioUnixListener {\n \n pub trait RtioUnixAcceptor {\n     fn accept(&mut self) -> IoResult<~RtioPipe:Send>;\n+    fn set_timeout(&mut self, timeout: Option<u64>);\n }\n \n pub trait RtioTTY {"}]}