{"sha": "18f898315a6b94fec729da65b536e311bc0a9f3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4Zjg5ODMxNWE2Yjk0ZmVjNzI5ZGE2NWI1MzZlMzExYmMwYTlmM2Q=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-02T06:20:51Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-03T23:38:16Z"}, "message": "core: Reorder declarations in comm so they read well", "tree": {"sha": "cabdcf8f9cc2cc6155ac8d6a93d4f33bb4ea930c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cabdcf8f9cc2cc6155ac8d6a93d4f33bb4ea930c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18f898315a6b94fec729da65b536e311bc0a9f3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18f898315a6b94fec729da65b536e311bc0a9f3d", "html_url": "https://github.com/rust-lang/rust/commit/18f898315a6b94fec729da65b536e311bc0a9f3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18f898315a6b94fec729da65b536e311bc0a9f3d/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "beb1a59f82e7689b72bf10d2a86d0d1b6060983e", "url": "https://api.github.com/repos/rust-lang/rust/commits/beb1a59f82e7689b72bf10d2a86d0d1b6060983e", "html_url": "https://github.com/rust-lang/rust/commit/beb1a59f82e7689b72bf10d2a86d0d1b6060983e"}], "stats": {"total": 152, "additions": 82, "deletions": 70}, "files": [{"sha": "2c1b238d66f9cde9adf6896d5262ea6481fd9050", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 82, "deletions": 70, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/18f898315a6b94fec729da65b536e311bc0a9f3d/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f898315a6b94fec729da65b536e311bc0a9f3d/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=18f898315a6b94fec729da65b536e311bc0a9f3d", "patch": "@@ -26,46 +26,26 @@ io::println(comm::recv(p));\n \n import either::either;\n \n+export port::{};\n+export chan::{};\n export send;\n export recv;\n-export recv_chan;\n export peek;\n+export recv_chan;\n export select2;\n-export chan::{};\n-export port::{};\n \n-enum rust_port {}\n \n-#[abi = \"cdecl\"]\n-native mod rustrt {\n-    fn rust_port_id_send<T: send>(target_port: port_id,\n-                                  data: T) -> libc::uintptr_t;\n-\n-    fn new_port(unit_sz: libc::size_t) -> *rust_port;\n-    fn del_port(po: *rust_port);\n-    fn rust_port_begin_detach(po: *rust_port,\n-                              yield: *libc::uintptr_t);\n-    fn rust_port_end_detach(po: *rust_port);\n-    fn get_port_id(po: *rust_port) -> port_id;\n-    fn rust_port_size(po: *rust_port) -> libc::size_t;\n-    fn port_recv(dptr: *uint, po: *rust_port,\n-                 yield: *libc::uintptr_t);\n-    fn rust_port_select(dptr: **rust_port, ports: **rust_port,\n-                        n_ports: libc::size_t,\n-                        yield: *libc::uintptr_t);\n-    fn rust_port_take(port_id: port_id) -> *rust_port;\n-    fn rust_port_drop(p: *rust_port);\n-    fn rust_port_task(p: *rust_port) -> libc::uintptr_t;\n-    fn get_task_id() -> libc::uintptr_t;\n-}\n+#[doc = \"\n+A communication endpoint that can receive messages\n \n-#[abi = \"rust-intrinsic\"]\n-native mod rusti {\n-    fn init<T>() -> T;\n+Each port has a unique per-task identity and may not be replicated or\n+transmitted. If a port value is copied, both copies refer to the same\n+port.  Ports may be associated with multiple `chan`s.\n+\"]\n+enum port<T: send> {\n+    port_t(@port_ptr<T>)\n }\n \n-type port_id = int;\n-\n // It's critical that this only have one variant, so it has a record\n // layout, and will work in the rust_task structure in task.rs.\n #[doc = \"\n@@ -82,35 +62,18 @@ enum chan<T: send> {\n     chan_t(port_id)\n }\n \n-resource port_ptr<T: send>(po: *rust_port) {\n-    // Once the port is detached it's guaranteed not to receive further\n-    // messages\n-    let yield = 0u;\n-    let yieldp = ptr::addr_of(yield);\n-    rustrt::rust_port_begin_detach(po, yieldp);\n-    if yield != 0u {\n-        // Need to wait for the port to be detached\n-        // FIXME: If this fails then we're going to leave our port\n-        // in a bogus state. (Issue #1988)\n-        task::yield();\n-    }\n-    rustrt::rust_port_end_detach(po);\n-\n-    // Drain the port so that all the still-enqueued items get dropped\n-    while rustrt::rust_port_size(po) > 0u {\n-       recv_::<T>(po);\n-    }\n-    rustrt::del_port(po);\n+#[doc = \"Constructs a port\"]\n+fn port<T: send>() -> port<T> {\n+    port_t(@port_ptr(rustrt::new_port(sys::size_of::<T>())))\n }\n \n #[doc = \"\n-A communication endpoint that can receive messages\n-\n-Each port has a unique per-task identity and may not be replicated or\n-transmitted. If a port value is copied, both copies refer to the same\n-port.  Ports may be associated with multiple `chan`s.\n+Constructs a channel. The channel is bound to the port used to\n+construct it.\n \"]\n-enum port<T: send> { port_t(@port_ptr<T>) }\n+fn chan<T: send>(p: port<T>) -> chan<T> {\n+    chan_t(rustrt::get_port_id(***p))\n+}\n \n #[doc = \"\n Sends data over a channel. The sent data is moved into the channel,\n@@ -126,17 +89,39 @@ fn send<T: send>(ch: chan<T>, -data: T) {\n     task::yield();\n }\n \n-#[doc = \"Constructs a port\"]\n-fn port<T: send>() -> port<T> {\n-    port_t(@port_ptr(rustrt::new_port(sys::size_of::<T>())))\n-}\n-\n #[doc = \"\n Receive from a port.  If no data is available on the port then the\n task will block until data becomes available.\n \"]\n fn recv<T: send>(p: port<T>) -> T { recv_(***p) }\n \n+#[doc = \"Returns true if there are messages available\"]\n+fn peek<T: send>(p: port<T>) -> bool {\n+    rustrt::rust_port_size(***p) != 0u as libc::size_t\n+}\n+\n+resource port_ptr<T: send>(po: *rust_port) {\n+    // Once the port is detached it's guaranteed not to receive further\n+    // messages\n+    let yield = 0u;\n+    let yieldp = ptr::addr_of(yield);\n+    rustrt::rust_port_begin_detach(po, yieldp);\n+    if yield != 0u {\n+        // Need to wait for the port to be detached\n+        // FIXME: If this fails then we're going to leave our port\n+        // in a bogus state. (Issue #1988)\n+        task::yield();\n+    }\n+    rustrt::rust_port_end_detach(po);\n+\n+    // Drain the port so that all the still-enqueued items get dropped\n+    while rustrt::rust_port_size(po) > 0u {\n+       recv_::<T>(po);\n+    }\n+    rustrt::del_port(po);\n+}\n+\n+\n #[doc(hidden)]\n fn recv_chan<T: send>(ch: comm::chan<T>) -> T {\n     resource portref(p: *rust_port) {\n@@ -210,19 +195,46 @@ fn select2<A: send, B: send>(p_a: port<A>, p_b: port<B>)\n     }\n }\n \n-#[doc = \"Returns true if there are messages available\"]\n-fn peek<T: send>(p: port<T>) -> bool {\n-    rustrt::rust_port_size(***p) != 0u as libc::size_t\n+\n+/* Implementation details */\n+\n+\n+enum rust_port {}\n+\n+type port_id = int;\n+\n+#[abi = \"cdecl\"]\n+native mod rustrt {\n+    fn rust_port_id_send<T: send>(target_port: port_id,\n+                                  data: T) -> libc::uintptr_t;\n+\n+    fn new_port(unit_sz: libc::size_t) -> *rust_port;\n+    fn del_port(po: *rust_port);\n+    fn rust_port_begin_detach(po: *rust_port,\n+                              yield: *libc::uintptr_t);\n+    fn rust_port_end_detach(po: *rust_port);\n+    fn get_port_id(po: *rust_port) -> port_id;\n+    fn rust_port_size(po: *rust_port) -> libc::size_t;\n+    fn port_recv(dptr: *uint, po: *rust_port,\n+                 yield: *libc::uintptr_t);\n+    fn rust_port_select(dptr: **rust_port, ports: **rust_port,\n+                        n_ports: libc::size_t,\n+                        yield: *libc::uintptr_t);\n+    fn rust_port_take(port_id: port_id) -> *rust_port;\n+    fn rust_port_drop(p: *rust_port);\n+    fn rust_port_task(p: *rust_port) -> libc::uintptr_t;\n+    fn get_task_id() -> libc::uintptr_t;\n }\n \n-#[doc = \"\n-Constructs a channel. The channel is bound to the port used to\n-construct it.\n-\"]\n-fn chan<T: send>(p: port<T>) -> chan<T> {\n-    chan_t(rustrt::get_port_id(***p))\n+#[abi = \"rust-intrinsic\"]\n+native mod rusti {\n+    fn init<T>() -> T;\n }\n \n+\n+/* Tests */\n+\n+\n #[test]\n fn create_port_and_chan() { let p = port::<int>(); chan(p); }\n "}]}