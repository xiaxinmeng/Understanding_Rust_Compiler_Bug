{"sha": "24782c7f8239db0be625f066befd8ef770b432ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0NzgyYzdmODIzOWRiMGJlNjI1ZjA2NmJlZmQ4ZWY3NzBiNDMyYWM=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-04-27T17:08:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-27T17:08:50Z"}, "message": "Rollup merge of #84613 - lcnr:recursive-types, r=jackh726\n\nmove representability checks to rustc_ty_utils", "tree": {"sha": "9700666efbddb72a2773e56d9028cfdab3d2708e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9700666efbddb72a2773e56d9028cfdab3d2708e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24782c7f8239db0be625f066befd8ef770b432ac", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgiEUiCRBK7hj4Ov3rIwAAwuAIAKsBc8e1h4JT96JxSNlYPTcL\nyG/UjDNdNdTJH+72XR3Eoqo1gmI5c7KCncNBvNltkyiXe3LD+Mu/K9wIimOcd7bP\nd+YQ24hvr9JzSyQmAmRgpMReoQdCqCuAJAUVEnioKFUNZA+sbpDKd/e5FixIKrAF\nbQv1gXQVjcwRtl9cBUCfvrutAVbwvZkVTbNMsfUQC4OUYVa+RVwBM0CjmxXIQ4v8\nBsdIZBzePFiNBAw5FhvqJ0B5PoJd4zY238hsd4annMTbLERuocC5qHhyIIToQFFC\nDopuh8rji7EeB0jEJBWSonuSJzE2Nc6WsKrI0U8H8EGKgoRyfhK8pqHHX0m1HWc=\n=0bij\n-----END PGP SIGNATURE-----\n", "payload": "tree 9700666efbddb72a2773e56d9028cfdab3d2708e\nparent 38e0dbd8eb8ee58c3033f6e8057b7ff80a155b1e\nparent b3629d21ba54c58643d73d9856698fe046c9acbc\nauthor Dylan DPC <dylan.dpc@gmail.com> 1619543330 +0200\ncommitter GitHub <noreply@github.com> 1619543330 +0200\n\nRollup merge of #84613 - lcnr:recursive-types, r=jackh726\n\nmove representability checks to rustc_ty_utils\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24782c7f8239db0be625f066befd8ef770b432ac", "html_url": "https://github.com/rust-lang/rust/commit/24782c7f8239db0be625f066befd8ef770b432ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24782c7f8239db0be625f066befd8ef770b432ac/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38e0dbd8eb8ee58c3033f6e8057b7ff80a155b1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/38e0dbd8eb8ee58c3033f6e8057b7ff80a155b1e", "html_url": "https://github.com/rust-lang/rust/commit/38e0dbd8eb8ee58c3033f6e8057b7ff80a155b1e"}, {"sha": "b3629d21ba54c58643d73d9856698fe046c9acbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3629d21ba54c58643d73d9856698fe046c9acbc", "html_url": "https://github.com/rust-lang/rust/commit/b3629d21ba54c58643d73d9856698fe046c9acbc"}], "stats": {"total": 385, "additions": 194, "deletions": 191}, "files": [{"sha": "985c6bf481f1460317238ea7a59e7322746b8d88", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24782c7f8239db0be625f066befd8ef770b432ac/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/24782c7f8239db0be625f066befd8ef770b432ac/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=24782c7f8239db0be625f066befd8ef770b432ac", "patch": "@@ -4590,6 +4590,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_trait_selection\",\n+ \"rustc_ty_utils\",\n  \"smallvec\",\n  \"tracing\",\n ]"}, {"sha": "e365928c15f918c6e28abcced78c98211a5ca3a7", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 2, "deletions": 189, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/24782c7f8239db0be625f066befd8ef770b432ac/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24782c7f8239db0be625f066befd8ef770b432ac/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=24782c7f8239db0be625f066befd8ef770b432ac", "patch": "@@ -18,10 +18,10 @@ use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::DUMMY_SP;\n use rustc_target::abi::{Integer, Size, TargetDataLayout};\n use smallvec::SmallVec;\n-use std::{cmp, fmt, iter};\n+use std::{fmt, iter};\n \n #[derive(Copy, Clone, Debug)]\n pub struct Discr<'tcx> {\n@@ -135,21 +135,6 @@ impl IntTypeExt for attr::IntType {\n     }\n }\n \n-/// Describes whether a type is representable. For types that are not\n-/// representable, 'SelfRecursive' and 'ContainsRecursive' are used to\n-/// distinguish between types that are recursive with themselves and types that\n-/// contain a different recursive type. These cases can therefore be treated\n-/// differently when reporting errors.\n-///\n-/// The ordering of the cases is significant. They are sorted so that cmp::max\n-/// will keep the \"more erroneous\" of two values.\n-#[derive(Clone, PartialOrd, Ord, Eq, PartialEq, Debug)]\n-pub enum Representability {\n-    Representable,\n-    ContainsRecursive,\n-    SelfRecursive(Vec<Span>),\n-}\n-\n impl<'tcx> TyCtxt<'tcx> {\n     /// Creates a hash of the type `Ty` which will be the same no matter what crate\n     /// context it's calculated within. This is used by the `type_id` intrinsic.\n@@ -870,178 +855,6 @@ impl<'tcx> ty::TyS<'tcx> {\n         }\n     }\n \n-    /// Check whether a type is representable. This means it cannot contain unboxed\n-    /// structural recursion. This check is needed for structs and enums.\n-    pub fn is_representable(&'tcx self, tcx: TyCtxt<'tcx>, sp: Span) -> Representability {\n-        // Iterate until something non-representable is found\n-        fn fold_repr<It: Iterator<Item = Representability>>(iter: It) -> Representability {\n-            iter.fold(Representability::Representable, |r1, r2| match (r1, r2) {\n-                (Representability::SelfRecursive(v1), Representability::SelfRecursive(v2)) => {\n-                    Representability::SelfRecursive(v1.into_iter().chain(v2).collect())\n-                }\n-                (r1, r2) => cmp::max(r1, r2),\n-            })\n-        }\n-\n-        fn are_inner_types_recursive<'tcx>(\n-            tcx: TyCtxt<'tcx>,\n-            sp: Span,\n-            seen: &mut Vec<Ty<'tcx>>,\n-            representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n-            ty: Ty<'tcx>,\n-        ) -> Representability {\n-            match ty.kind() {\n-                Tuple(..) => {\n-                    // Find non representable\n-                    fold_repr(ty.tuple_fields().map(|ty| {\n-                        is_type_structurally_recursive(tcx, sp, seen, representable_cache, ty)\n-                    }))\n-                }\n-                // Fixed-length vectors.\n-                // FIXME(#11924) Behavior undecided for zero-length vectors.\n-                Array(ty, _) => {\n-                    is_type_structurally_recursive(tcx, sp, seen, representable_cache, ty)\n-                }\n-                Adt(def, substs) => {\n-                    // Find non representable fields with their spans\n-                    fold_repr(def.all_fields().map(|field| {\n-                        let ty = field.ty(tcx, substs);\n-                        let span = match field\n-                            .did\n-                            .as_local()\n-                            .map(|id| tcx.hir().local_def_id_to_hir_id(id))\n-                            .and_then(|id| tcx.hir().find(id))\n-                        {\n-                            Some(hir::Node::Field(field)) => field.ty.span,\n-                            _ => sp,\n-                        };\n-                        match is_type_structurally_recursive(\n-                            tcx,\n-                            span,\n-                            seen,\n-                            representable_cache,\n-                            ty,\n-                        ) {\n-                            Representability::SelfRecursive(_) => {\n-                                Representability::SelfRecursive(vec![span])\n-                            }\n-                            x => x,\n-                        }\n-                    }))\n-                }\n-                Closure(..) => {\n-                    // this check is run on type definitions, so we don't expect\n-                    // to see closure types\n-                    bug!(\"requires check invoked on inapplicable type: {:?}\", ty)\n-                }\n-                _ => Representability::Representable,\n-            }\n-        }\n-\n-        fn same_struct_or_enum<'tcx>(ty: Ty<'tcx>, def: &'tcx ty::AdtDef) -> bool {\n-            match *ty.kind() {\n-                Adt(ty_def, _) => ty_def == def,\n-                _ => false,\n-            }\n-        }\n-\n-        // Does the type `ty` directly (without indirection through a pointer)\n-        // contain any types on stack `seen`?\n-        fn is_type_structurally_recursive<'tcx>(\n-            tcx: TyCtxt<'tcx>,\n-            sp: Span,\n-            seen: &mut Vec<Ty<'tcx>>,\n-            representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n-            ty: Ty<'tcx>,\n-        ) -> Representability {\n-            debug!(\"is_type_structurally_recursive: {:?} {:?}\", ty, sp);\n-            if let Some(representability) = representable_cache.get(ty) {\n-                debug!(\n-                    \"is_type_structurally_recursive: {:?} {:?} - (cached) {:?}\",\n-                    ty, sp, representability\n-                );\n-                return representability.clone();\n-            }\n-\n-            let representability =\n-                is_type_structurally_recursive_inner(tcx, sp, seen, representable_cache, ty);\n-\n-            representable_cache.insert(ty, representability.clone());\n-            representability\n-        }\n-\n-        fn is_type_structurally_recursive_inner<'tcx>(\n-            tcx: TyCtxt<'tcx>,\n-            sp: Span,\n-            seen: &mut Vec<Ty<'tcx>>,\n-            representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n-            ty: Ty<'tcx>,\n-        ) -> Representability {\n-            match ty.kind() {\n-                Adt(def, _) => {\n-                    {\n-                        // Iterate through stack of previously seen types.\n-                        let mut iter = seen.iter();\n-\n-                        // The first item in `seen` is the type we are actually curious about.\n-                        // We want to return SelfRecursive if this type contains itself.\n-                        // It is important that we DON'T take generic parameters into account\n-                        // for this check, so that Bar<T> in this example counts as SelfRecursive:\n-                        //\n-                        // struct Foo;\n-                        // struct Bar<T> { x: Bar<Foo> }\n-\n-                        if let Some(&seen_type) = iter.next() {\n-                            if same_struct_or_enum(seen_type, *def) {\n-                                debug!(\"SelfRecursive: {:?} contains {:?}\", seen_type, ty);\n-                                return Representability::SelfRecursive(vec![sp]);\n-                            }\n-                        }\n-\n-                        // We also need to know whether the first item contains other types\n-                        // that are structurally recursive. If we don't catch this case, we\n-                        // will recurse infinitely for some inputs.\n-                        //\n-                        // It is important that we DO take generic parameters into account\n-                        // here, so that code like this is considered SelfRecursive, not\n-                        // ContainsRecursive:\n-                        //\n-                        // struct Foo { Option<Option<Foo>> }\n-\n-                        for &seen_type in iter {\n-                            if ty::TyS::same_type(ty, seen_type) {\n-                                debug!(\"ContainsRecursive: {:?} contains {:?}\", seen_type, ty);\n-                                return Representability::ContainsRecursive;\n-                            }\n-                        }\n-                    }\n-\n-                    // For structs and enums, track all previously seen types by pushing them\n-                    // onto the 'seen' stack.\n-                    seen.push(ty);\n-                    let out = are_inner_types_recursive(tcx, sp, seen, representable_cache, ty);\n-                    seen.pop();\n-                    out\n-                }\n-                _ => {\n-                    // No need to push in other cases.\n-                    are_inner_types_recursive(tcx, sp, seen, representable_cache, ty)\n-                }\n-            }\n-        }\n-\n-        debug!(\"is_type_representable: {:?}\", self);\n-\n-        // To avoid a stack overflow when checking an enum variant or struct that\n-        // contains a different, structurally recursive type, maintain a stack\n-        // of seen types and check recursion for each of them (issues #3008, #3779).\n-        let mut seen: Vec<Ty<'_>> = Vec::new();\n-        let mut representable_cache = FxHashMap::default();\n-        let r = is_type_structurally_recursive(tcx, sp, &mut seen, &mut representable_cache, self);\n-        debug!(\"is_type_representable: {:?} is {:?}\", self, r);\n-        r\n-    }\n-\n     /// Peel off all reference types in this type until there are none left.\n     ///\n     /// This method is idempotent, i.e. `ty.peel_refs().peel_refs() == ty.peel_refs()`."}, {"sha": "67a692eceacc4e99175899ae305f6be39a865709", "filename": "compiler/rustc_ty_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24782c7f8239db0be625f066befd8ef770b432ac/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24782c7f8239db0be625f066befd8ef770b432ac/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs?ref=24782c7f8239db0be625f066befd8ef770b432ac", "patch": "@@ -20,6 +20,7 @@ use rustc_middle::ty::query::Providers;\n mod common_traits;\n pub mod instance;\n mod needs_drop;\n+pub mod representability;\n mod ty;\n \n pub fn provide(providers: &mut Providers) {"}, {"sha": "ca001635a3dc29d0f3f6546e3db9babeb19d56a9", "filename": "compiler/rustc_ty_utils/src/representability.rs", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/24782c7f8239db0be625f066befd8ef770b432ac/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24782c7f8239db0be625f066befd8ef770b432ac/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs?ref=24782c7f8239db0be625f066befd8ef770b432ac", "patch": "@@ -0,0 +1,186 @@\n+//! Check whether a type is representable.\n+use rustc_data_structures::stable_map::FxHashMap;\n+use rustc_hir as hir;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_span::Span;\n+use std::cmp;\n+\n+/// Describes whether a type is representable. For types that are not\n+/// representable, 'SelfRecursive' and 'ContainsRecursive' are used to\n+/// distinguish between types that are recursive with themselves and types that\n+/// contain a different recursive type. These cases can therefore be treated\n+/// differently when reporting errors.\n+///\n+/// The ordering of the cases is significant. They are sorted so that cmp::max\n+/// will keep the \"more erroneous\" of two values.\n+#[derive(Clone, PartialOrd, Ord, Eq, PartialEq, Debug)]\n+pub enum Representability {\n+    Representable,\n+    ContainsRecursive,\n+    SelfRecursive(Vec<Span>),\n+}\n+\n+/// Check whether a type is representable. This means it cannot contain unboxed\n+/// structural recursion. This check is needed for structs and enums.\n+pub fn ty_is_representable<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, sp: Span) -> Representability {\n+    debug!(\"is_type_representable: {:?}\", ty);\n+    // To avoid a stack overflow when checking an enum variant or struct that\n+    // contains a different, structurally recursive type, maintain a stack\n+    // of seen types and check recursion for each of them (issues #3008, #3779).\n+    let mut seen: Vec<Ty<'_>> = Vec::new();\n+    let mut representable_cache = FxHashMap::default();\n+    let r = is_type_structurally_recursive(tcx, sp, &mut seen, &mut representable_cache, ty);\n+    debug!(\"is_type_representable: {:?} is {:?}\", ty, r);\n+    r\n+}\n+\n+// Iterate until something non-representable is found\n+fn fold_repr<It: Iterator<Item = Representability>>(iter: It) -> Representability {\n+    iter.fold(Representability::Representable, |r1, r2| match (r1, r2) {\n+        (Representability::SelfRecursive(v1), Representability::SelfRecursive(v2)) => {\n+            Representability::SelfRecursive(v1.into_iter().chain(v2).collect())\n+        }\n+        (r1, r2) => cmp::max(r1, r2),\n+    })\n+}\n+\n+fn are_inner_types_recursive<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    sp: Span,\n+    seen: &mut Vec<Ty<'tcx>>,\n+    representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n+    ty: Ty<'tcx>,\n+) -> Representability {\n+    match ty.kind() {\n+        ty::Tuple(..) => {\n+            // Find non representable\n+            fold_repr(\n+                ty.tuple_fields().map(|ty| {\n+                    is_type_structurally_recursive(tcx, sp, seen, representable_cache, ty)\n+                }),\n+            )\n+        }\n+        // Fixed-length vectors.\n+        // FIXME(#11924) Behavior undecided for zero-length vectors.\n+        ty::Array(ty, _) => is_type_structurally_recursive(tcx, sp, seen, representable_cache, ty),\n+        ty::Adt(def, substs) => {\n+            // Find non representable fields with their spans\n+            fold_repr(def.all_fields().map(|field| {\n+                let ty = field.ty(tcx, substs);\n+                let span = match field\n+                    .did\n+                    .as_local()\n+                    .map(|id| tcx.hir().local_def_id_to_hir_id(id))\n+                    .and_then(|id| tcx.hir().find(id))\n+                {\n+                    Some(hir::Node::Field(field)) => field.ty.span,\n+                    _ => sp,\n+                };\n+                match is_type_structurally_recursive(tcx, span, seen, representable_cache, ty) {\n+                    Representability::SelfRecursive(_) => {\n+                        Representability::SelfRecursive(vec![span])\n+                    }\n+                    x => x,\n+                }\n+            }))\n+        }\n+        ty::Closure(..) => {\n+            // this check is run on type definitions, so we don't expect\n+            // to see closure types\n+            bug!(\"requires check invoked on inapplicable type: {:?}\", ty)\n+        }\n+        _ => Representability::Representable,\n+    }\n+}\n+\n+fn same_adt<'tcx>(ty: Ty<'tcx>, def: &'tcx ty::AdtDef) -> bool {\n+    match *ty.kind() {\n+        ty::Adt(ty_def, _) => ty_def == def,\n+        _ => false,\n+    }\n+}\n+\n+// Does the type `ty` directly (without indirection through a pointer)\n+// contain any types on stack `seen`?\n+fn is_type_structurally_recursive<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    sp: Span,\n+    seen: &mut Vec<Ty<'tcx>>,\n+    representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n+    ty: Ty<'tcx>,\n+) -> Representability {\n+    debug!(\"is_type_structurally_recursive: {:?} {:?}\", ty, sp);\n+    if let Some(representability) = representable_cache.get(ty) {\n+        debug!(\n+            \"is_type_structurally_recursive: {:?} {:?} - (cached) {:?}\",\n+            ty, sp, representability\n+        );\n+        return representability.clone();\n+    }\n+\n+    let representability =\n+        is_type_structurally_recursive_inner(tcx, sp, seen, representable_cache, ty);\n+\n+    representable_cache.insert(ty, representability.clone());\n+    representability\n+}\n+\n+fn is_type_structurally_recursive_inner<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    sp: Span,\n+    seen: &mut Vec<Ty<'tcx>>,\n+    representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n+    ty: Ty<'tcx>,\n+) -> Representability {\n+    match ty.kind() {\n+        ty::Adt(def, _) => {\n+            {\n+                // Iterate through stack of previously seen types.\n+                let mut iter = seen.iter();\n+\n+                // The first item in `seen` is the type we are actually curious about.\n+                // We want to return SelfRecursive if this type contains itself.\n+                // It is important that we DON'T take generic parameters into account\n+                // for this check, so that Bar<T> in this example counts as SelfRecursive:\n+                //\n+                // struct Foo;\n+                // struct Bar<T> { x: Bar<Foo> }\n+\n+                if let Some(&seen_adt) = iter.next() {\n+                    if same_adt(seen_adt, *def) {\n+                        debug!(\"SelfRecursive: {:?} contains {:?}\", seen_adt, ty);\n+                        return Representability::SelfRecursive(vec![sp]);\n+                    }\n+                }\n+\n+                // We also need to know whether the first item contains other types\n+                // that are structurally recursive. If we don't catch this case, we\n+                // will recurse infinitely for some inputs.\n+                //\n+                // It is important that we DO take generic parameters into account\n+                // here, so that code like this is considered SelfRecursive, not\n+                // ContainsRecursive:\n+                //\n+                // struct Foo { Option<Option<Foo>> }\n+\n+                for &seen_adt in iter {\n+                    if ty::TyS::same_type(ty, seen_adt) {\n+                        debug!(\"ContainsRecursive: {:?} contains {:?}\", seen_adt, ty);\n+                        return Representability::ContainsRecursive;\n+                    }\n+                }\n+            }\n+\n+            // For structs and enums, track all previously seen types by pushing them\n+            // onto the 'seen' stack.\n+            seen.push(ty);\n+            let out = are_inner_types_recursive(tcx, sp, seen, representable_cache, ty);\n+            seen.pop();\n+            out\n+        }\n+        _ => {\n+            // No need to push in other cases.\n+            are_inner_types_recursive(tcx, sp, seen, representable_cache, ty)\n+        }\n+    }\n+}"}, {"sha": "eb55a8a23ad02b80f31929bab9a49281f76c9058", "filename": "compiler/rustc_typeck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24782c7f8239db0be625f066befd8ef770b432ac/compiler%2Frustc_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24782c7f8239db0be625f066befd8ef770b432ac/compiler%2Frustc_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2FCargo.toml?ref=24782c7f8239db0be625f066befd8ef770b432ac", "patch": "@@ -26,3 +26,4 @@ rustc_span = { path = \"../rustc_span\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_infer = { path = \"../rustc_infer\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n+rustc_ty_utils = { path = \"../rustc_ty_utils\" }"}, {"sha": "72c633dcb20c4119db20a04ed5173f0c695ff3ca", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24782c7f8239db0be625f066befd8ef770b432ac/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24782c7f8239db0be625f066befd8ef770b432ac/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=24782c7f8239db0be625f066befd8ef770b432ac", "patch": "@@ -15,7 +15,7 @@ use rustc_infer::infer::{RegionVariableOrigin, TyCtxtInferExt};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::layout::MAX_SIMD_LANES;\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::util::{Discr, IntTypeExt, Representability};\n+use rustc_middle::ty::util::{Discr, IntTypeExt};\n use rustc_middle::ty::{self, ParamEnv, RegionKind, ToPredicate, Ty, TyCtxt};\n use rustc_session::config::EntryFnType;\n use rustc_session::lint::builtin::UNINHABITED_STATIC;\n@@ -25,6 +25,7 @@ use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::opaque_types::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCauseCode};\n+use rustc_ty_utils::representability::{self, Representability};\n \n use std::iter;\n use std::ops::ControlFlow;\n@@ -1188,7 +1189,7 @@ pub(super) fn check_representable(tcx: TyCtxt<'_>, sp: Span, item_def_id: LocalD\n     // recursive type. It is only necessary to throw an error on those that\n     // contain themselves. For case 2, there must be an inner type that will be\n     // caught by case 1.\n-    match rty.is_representable(tcx, sp) {\n+    match representability::ty_is_representable(tcx, rty, sp) {\n         Representability::SelfRecursive(spans) => {\n             recursive_type_with_infinite_size_error(tcx, item_def_id.to_def_id(), spans);\n             return false;"}]}