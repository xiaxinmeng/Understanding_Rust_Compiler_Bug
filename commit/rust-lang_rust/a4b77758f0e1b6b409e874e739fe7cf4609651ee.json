{"sha": "a4b77758f0e1b6b409e874e739fe7cf4609651ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0Yjc3NzU4ZjBlMWI2YjQwOWU4NzRlNzM5ZmU3Y2Y0NjA5NjUxZWU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-19T11:51:20Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-19T12:34:10Z"}, "message": "Move tutorial over to a format similar to the reference doc\n\nAnd adjust highlighting/testing scripts to deal with this.", "tree": {"sha": "b9e698e7299b8535895c15e0b104718b2b2513aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9e698e7299b8535895c15e0b104718b2b2513aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4b77758f0e1b6b409e874e739fe7cf4609651ee", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4b77758f0e1b6b409e874e739fe7cf4609651ee", "html_url": "https://github.com/rust-lang/rust/commit/a4b77758f0e1b6b409e874e739fe7cf4609651ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4b77758f0e1b6b409e874e739fe7cf4609651ee/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d699db699a07d5bb80d5d08508540b0aba6e1026", "url": "https://api.github.com/repos/rust-lang/rust/commits/d699db699a07d5bb80d5d08508540b0aba6e1026", "html_url": "https://github.com/rust-lang/rust/commit/d699db699a07d5bb80d5d08508540b0aba6e1026"}], "stats": {"total": 6734, "additions": 2719, "deletions": 4015}, "files": [{"sha": "88de3f563fb519fd8fa1f4858bcbec34570dfdfa", "filename": "doc/extract-tests.js", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a4b77758f0e1b6b409e874e739fe7cf4609651ee/doc%2Fextract-tests.js", "raw_url": "https://github.com/rust-lang/rust/raw/a4b77758f0e1b6b409e874e739fe7cf4609651ee/doc%2Fextract-tests.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fextract-tests.js?ref=a4b77758f0e1b6b409e874e739fe7cf4609651ee", "patch": "@@ -0,0 +1,44 @@\n+#!/usr/local/bin/node\n+\n+/***\n+ * Script for extracting compilable fragments from markdown\n+ * documentation. See prep.js for a description of the format\n+ * recognized by this tool. Expects a directory fragements/ to exist\n+ * under the current directory, and writes the fragments in there as\n+ * individual .rs files.\n+ */\n+\n+var fs = require(\"fs\");\n+\n+if (!process.argv[2]) {\n+  console.log(\"Please provide an input file name.\");\n+  process.exit(1);\n+}\n+\n+var lines = fs.readFileSync(process.argv[2]).toString().split(/\\n\\r?/g);\n+var cur = 0, line, chapter, chapter_n;\n+\n+while ((line = lines[cur++]) != null) {\n+  var chap = line.match(/^# (.*)/);\n+  if (chap) {\n+    chapter = chap[1].toLowerCase().replace(/\\W/g, \"_\");\n+    chapter_n = 1;\n+  } else if (/^~~~/.test(line)) {\n+    var block = \"\", ignore = false;\n+    while ((line = lines[cur++]) != null) {\n+      if (/^\\s*## (?:notrust|ignore)/.test(line)) ignore = true;\n+      else if (/^~~~/.test(line)) break;\n+      else block += line.replace(/^# /, \"\") + \"\\n\";\n+    }\n+    if (!ignore) {\n+      if (!/\\bfn main\\b/.test(block)) {\n+        if (/(^|\\n) *(native|use|mod|import|export)\\b/.test(block))\n+          block += \"\\nfn main() {}\\n\";\n+        else block = \"fn main() {\\n\" + block + \"\\n}\\n\";\n+      }\n+      if (!/\\buse std\\b/.test(block)) block = \"use std;\\n\" + block;\n+      var filename = \"fragments/\" + chapter + \"_\" + (chapter_n++) + \".rs\";\n+      fs.writeFileSync(filename, block);\n+    }\n+  }\n+}"}, {"sha": "fac4c076d480c868217da4d351dd9f9d83e0f508", "filename": "doc/lib/codemirror-node.js", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a4b77758f0e1b6b409e874e739fe7cf4609651ee/doc%2Flib%2Fcodemirror-node.js", "raw_url": "https://github.com/rust-lang/rust/raw/a4b77758f0e1b6b409e874e739fe7cf4609651ee/doc%2Flib%2Fcodemirror-node.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Flib%2Fcodemirror-node.js?ref=a4b77758f0e1b6b409e874e739fe7cf4609651ee", "previous_filename": "doc/tutorial/lib/codemirror-node.js"}, {"sha": "47fd7696a1d4c1c3013d16055ebbbf5ad0826a3f", "filename": "doc/lib/codemirror-rust.js", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a4b77758f0e1b6b409e874e739fe7cf4609651ee/doc%2Flib%2Fcodemirror-rust.js", "raw_url": "https://github.com/rust-lang/rust/raw/a4b77758f0e1b6b409e874e739fe7cf4609651ee/doc%2Flib%2Fcodemirror-rust.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Flib%2Fcodemirror-rust.js?ref=a4b77758f0e1b6b409e874e739fe7cf4609651ee", "previous_filename": "doc/tutorial/lib/codemirror-rust.js"}, {"sha": "f8876b55020bc62a124adf1fda7855b56efc82e9", "filename": "doc/prep.js", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/a4b77758f0e1b6b409e874e739fe7cf4609651ee/doc%2Fprep.js", "raw_url": "https://github.com/rust-lang/rust/raw/a4b77758f0e1b6b409e874e739fe7cf4609651ee/doc%2Fprep.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fprep.js?ref=a4b77758f0e1b6b409e874e739fe7cf4609651ee", "patch": "@@ -0,0 +1,67 @@\n+#!/usr/local/bin/node\n+\n+/***\n+ * Pandoc-style markdown preprocessor that drops extra directives\n+ * included for running doc code, and that optionally, when\n+ * --highlight is provided, replaces code blocks that are Rust code\n+ * with highlighted HTML blocks. The directives recognized are:\n+ *\n+ * '## ignore' tells the test extractor (extract-tests.js) to ignore\n+ *   the block completely.\n+ * '## notrust' makes the test extractor ignore the block, makes\n+ *   this script not highlight the block.\n+ * '# [any text]' is a line that is stripped out by this script, and\n+ *   converted to a normal line of code (without the leading #) by\n+ *   the test extractor.\n+ */\n+\n+var fs = require(\"fs\");\n+CodeMirror = require(\"./lib/codemirror-node\");\n+require(\"./lib/codemirror-rust\");\n+\n+function help() {\n+  console.log(\"usage: \" + process.argv[0] + \" [--highlight] [-o outfile] [infile]\");\n+  process.exit(1);\n+}\n+\n+var highlight = false, infile, outfile;\n+\n+for (var i = 2; i < process.argv.length; ++i) {\n+  var arg = process.argv[i];\n+  if (arg == \"--highlight\") highlight = true;\n+  else if (arg == \"-o\" && outfile == null && ++i < process.argv.length) outfile = process.argv[i];\n+  else if (arg[0] != \"-\") infile = arg;\n+  else help();\n+}\n+\n+var lines = fs.readFileSync(infile || \"/dev/stdin\").toString().split(/\\n\\r?/g), cur = 0, line;\n+var out = outfile ? fs.createWriteStream(outfile) : process.stdout;\n+\n+while ((line = lines[cur++]) != null) {\n+  if (/^~~~/.test(line)) {\n+    var block = \"\", bline, isRust = true;\n+    while ((bline = lines[cur++]) != null) {\n+      if (/^\\s*## notrust/.test(bline)) isRust = false;\n+      else if (/^~~~/.test(bline)) break;\n+      if (!/^\\s*##? /.test(bline)) block += bline + \"\\n\";\n+    }\n+    if (!highlight || !isRust)\n+      out.write(line + \"\\n\" + block + bline + \"\\n\");\n+    else {\n+      var html = '<pre class=\"cm-s-default\">', curstr = \"\", curstyle = null;\n+      function add(str, style) {\n+        if (style != curstyle) {\n+          if (curstyle) html += '<span class=\"cm-' + curstyle + '\">' + curstr\n+            + \"</span>\";\n+          else if (curstr) html += curstr;\n+          curstr = str; curstyle = style;\n+        } else curstr += str;\n+      }\n+      CodeMirror.runMode(block, \"rust\", add);\n+      add(\"\", \"bogus\"); // Flush pending string.\n+      out.write(html + \"</pre>\\n\");\n+    }\n+  } else {\n+    out.write(line + \"\\n\");\n+  }\n+}"}, {"sha": "a878570f4a9a1ba8e7cc512e55872b94a578d281", "filename": "doc/run-tests.sh", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4b77758f0e1b6b409e874e739fe7cf4609651ee/doc%2Frun-tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a4b77758f0e1b6b409e874e739fe7cf4609651ee/doc%2Frun-tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frun-tests.sh?ref=a4b77758f0e1b6b409e874e739fe7cf4609651ee", "patch": "@@ -1,7 +1,7 @@\n #!/bin/bash\n rm -f fragments/*.rs\n mkdir -p fragments\n-node extract.js\n+node extract-tests.js $1\n for F in `ls fragments/*.rs`; do\n   $RUSTC $F > /dev/null\n   if [[ $? != 0 ]] ; then echo $F; fi", "previous_filename": "doc/tutorial/test.sh"}, {"sha": "e7329802c4ca18f211fde997ad979d98f21a7975", "filename": "doc/rust.css", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a4b77758f0e1b6b409e874e739fe7cf4609651ee/doc%2Frust.css", "raw_url": "https://github.com/rust-lang/rust/raw/a4b77758f0e1b6b409e874e739fe7cf4609651ee/doc%2Frust.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.css?ref=a4b77758f0e1b6b409e874e739fe7cf4609651ee", "patch": "@@ -6,10 +6,14 @@ body {\n \n body {\n   padding: 1em 6em;\n-  max-width: 50em;\n+  max-width: 60em;\n }\n \n-h1 { font-size: 22pt; }\n+h1 {\n+  font-size: 22pt;\n+  margin-top: 2em;\n+  border-bottom: 2px solid silver;\n+}\n h2 { font-size: 17pt; }\n h3 { font-size: 14pt; }\n \n@@ -23,3 +27,27 @@ a, a:visited, a:link {\n   text-decoration: none;\n   color: #00438a;\n }\n+\n+h1 a:link, h1 a:visited, h2 a:link, h2 a:visited,\n+h3 a:link, h3 a:visited { color: black; }\n+\n+/* Code highlighting */\n+.cm-s-default span.cm-keyword {color: #708;}\n+.cm-s-default span.cm-atom {color: #219;}\n+.cm-s-default span.cm-number {color: #164;}\n+.cm-s-default span.cm-def {color: #00f;}\n+.cm-s-default span.cm-variable {color: black;}\n+.cm-s-default span.cm-variable-2 {color: #05a;}\n+.cm-s-default span.cm-variable-3 {color: #085;}\n+.cm-s-default span.cm-property {color: black;}\n+.cm-s-default span.cm-operator {color: black;}\n+.cm-s-default span.cm-comment {color: #a50;}\n+.cm-s-default span.cm-string {color: #a11;}\n+.cm-s-default span.cm-string-2 {color: #f50;}\n+.cm-s-default span.cm-meta {color: #555;}\n+.cm-s-default span.cm-error {color: #f00;}\n+.cm-s-default span.cm-qualifier {color: #555;}\n+.cm-s-default span.cm-builtin {color: #30a;}\n+.cm-s-default span.cm-bracket {color: #cc7;}\n+.cm-s-default span.cm-tag {color: #170;}\n+.cm-s-default span.cm-attribute {color: #00c;}"}, {"sha": "e7aa12456e6527a99046b80c64357f1b8565ab32", "filename": "doc/tutorial.md", "status": "added", "additions": 2556, "deletions": 0, "changes": 2556, "blob_url": "https://github.com/rust-lang/rust/blob/a4b77758f0e1b6b409e874e739fe7cf4609651ee/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/a4b77758f0e1b6b409e874e739fe7cf4609651ee/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=a4b77758f0e1b6b409e874e739fe7cf4609651ee", "patch": "@@ -0,0 +1,2556 @@\n+% Rust Language Tutorial\n+\n+# Introduction\n+\n+## Scope\n+\n+This is a tutorial for the Rust programming language. It assumes the\n+reader is familiar with the basic concepts of programming, and has\n+programmed in one or more other languages before. The tutorial covers\n+the whole language, though not with the depth and precision of the\n+[language reference][1].\n+\n+[1]: http://www.rust-lang.org/doc/rust.html\n+\n+## Disclaimer\n+\n+Rust is a language under development. The general flavor of the\n+language has settled, but details will continue to change as it is\n+further refined. Nothing in this tutorial is final, and though we try\n+to keep it updated, it is possible that the text occasionally does not\n+reflect the actual state of the language.\n+\n+## First Impressions\n+\n+Though syntax is something you get used to, an initial encounter with\n+a language can be made easier if the notation looks familiar. Rust is\n+a curly-brace language in the tradition of C, C++, and JavaScript.\n+\n+~~~~\n+fn fac(n: int) -> int {\n+    let result = 1, i = 1;\n+    while i <= n {\n+        result *= i;\n+        i += 1;\n+    }\n+    ret result;\n+}\n+~~~~\n+\n+Several differences from C stand out. Types do not come before, but\n+after variable names (preceded by a colon). In local variables\n+(introduced with `let`), they are optional, and will be inferred when\n+left off. Constructs like `while` and `if` do not require parenthesis\n+around the condition (though they allow them). Also, there's a\n+tendency towards aggressive abbreviation in the keywords\u2014`fn` for\n+function, `ret` for return.\n+\n+You should, however, not conclude that Rust is simply an evolution of\n+C. As will become clear in the rest of this tutorial, it goes in\n+quite a different direction.\n+\n+## Conventions\n+\n+Throughout the tutorial, words that indicate language keywords or\n+identifiers defined in the example code are displayed in `code font`.\n+\n+Code snippets are indented, and also shown in a monospace font. Not\n+all snippets constitute whole programs. For brevity, we'll often show\n+fragments of programs that don't compile on their own. To try them\n+out, you might have to wrap them in `fn main() { ... }`, and make sure\n+they don't contain references to things that aren't actually defined.\n+\n+# Getting started\n+\n+## Installation\n+\n+FIXME Fill this in when the installation package is finished.\n+\n+## Compiling your first program\n+\n+Rust program files are, by convention, given the extension `.rs`. Say\n+we have a file `hello.rs` containing this program:\n+\n+~~~~\n+use std;\n+fn main(args: [str]) {\n+    std::io::println(\"hello world from '\" + args[0] + \"'!\");\n+}\n+~~~~\n+\n+If the Rust compiler was installed successfully, running `rustc\n+hello.rs` will produce a binary called `hello` (or `hello.exe`).\n+\n+If you modify the program to make it invalid (for example, remove the\n+`use std` line), and then compile it, you'll see an error message like\n+this:\n+\n+~~~~\n+## notrust\n+hello.rs:2:4: 2:20 error: unresolved modulename: std\n+hello.rs:2     std::io::println(\"hello world!\");\n+               ^~~~~~~~~~~~~~~~\n+~~~~\n+\n+The Rust compiler tries to provide useful information when it runs\n+into an error.\n+\n+## Anatomy of a Rust program\n+\n+In its simplest form, a Rust program is simply a `.rs` file with some\n+types and functions defined in it. If it has a `main` function, it can\n+be compiled to an executable. Rust does not allow code that's not a\n+declaration to appear at the top level of the file\u2014all statements must\n+live inside a function.\n+\n+Rust programs can also be compiled as libraries, and included in other\n+programs. The `use std` directive that appears at the top of a lot of\n+examples imports the [standard library][std]. This is described in more\n+detail [later on](mod.html).\n+\n+[std]: http://doc.rust-lang.org/doc/std/index/General.html\n+\n+## Editing Rust code\n+\n+There are Vim highlighting and indentation scrips in the Rust source\n+distribution under `src/etc/vim/`, and an emacs mode under\n+`src/etc/emacs/`.\n+\n+[rust-mode]: https://github.com/marijnh/rust-mode\n+\n+Other editors are not provided for yet. If you end up writing a Rust\n+mode for your favorite editor, let us know so that we can link to it.\n+\n+# Syntax Basics\n+\n+## Braces\n+\n+Assuming you've programmed in any C-family language (C++, Java,\n+JavaScript, C#, or PHP), Rust will feel familiar. The main surface\n+difference to be aware of is that the bodies of `if` statements and of\n+loops *have* to be wrapped in brackets. Single-statement, bracket-less\n+bodies are not allowed.\n+\n+If the verbosity of that bothers you, consider the fact that this\n+allows you to omit the parentheses around the condition in `if`,\n+`while`, and similar constructs. This will save you two characters\n+every time. As a bonus, you no longer have to spend any mental energy\n+on deciding whether you need to add braces or not, or on adding them\n+after the fact when adding a statement to an `if` branch.\n+\n+Accounting for these differences, the surface syntax of Rust\n+statements and expressions is C-like. Function calls are written\n+`myfunc(arg1, arg2)`, operators have mostly the same name and\n+precedence that they have in C, comments look the same, and constructs\n+like `if` and `while` are available:\n+\n+~~~~\n+# fn call_a_function(_a: int) {}\n+fn main() {\n+    if 1 < 2 {\n+        while false { call_a_function(10 * 4); }\n+    } else if 4 < 3 || 3 < 4 {\n+        // Comments are C++-style too\n+    } else {\n+        /* Multi-line comment syntax */\n+    }\n+}\n+~~~~\n+\n+## Expression syntax\n+\n+Though it isn't apparent in all code, there is a fundamental\n+difference between Rust's syntax and the predecessors in this family\n+of languages. A lot of thing that are statements in C are expressions\n+in Rust. This allows for useless things like this (which passes\n+nil\u2014the void type\u2014to a function):\n+\n+~~~~\n+# fn a_function(_a: ()) {}\n+a_function(while false {});\n+~~~~\n+\n+But also useful things like this:\n+\n+~~~~\n+# fn the_stars_align() -> bool { false }\n+# fn something_else() -> bool { true }\n+let x = if the_stars_align() { 4 }\n+        else if something_else() { 3 }\n+        else { 0 };\n+~~~~\n+\n+This piece of code will bind the variable `x` to a value depending on\n+the conditions. Note the condition bodies, which look like `{\n+expression }`. The lack of a semicolon after the last statement in a\n+braced block gives the whole block the value of that last expression.\n+If the branches of the `if` had looked like `{ 4; }`, the above\n+example would simply assign nil (void) to `x`. But without the\n+semicolon, each branch has a different value, and `x` gets the value\n+of the branch that was taken.\n+\n+This also works for function bodies. This function returns a boolean:\n+\n+~~~~\n+fn is_four(x: int) -> bool { x == 4 }\n+~~~~\n+\n+In short, everything that's not a declaration (`let` for variables,\n+`fn` for functions, etcetera) is an expression.\n+\n+If all those things are expressions, you might conclude that you have\n+to add a terminating semicolon after *every* statement, even ones that\n+are not traditionally terminated with a semicolon in C (like `while`).\n+That is not the case, though. Expressions that end in a block only\n+need a semicolon if that block contains a trailing expression. `while`\n+loops do not allow trailing expressions, and `if` statements tend to\n+only have a trailing expression when you want to use their value for\n+something\u2014in which case you'll have embedded it in a bigger statement,\n+like the `let x = ...` example above.\n+\n+## Identifiers\n+\n+Rust identifiers must start with an alphabetic character or an\n+underscore, and after that may contain any alphanumeric character, and\n+more underscores.\n+\n+NOTE: The parser doesn't currently recognize non-ascii alphabetic\n+characters. This is a bug that will eventually be fixed.\n+\n+The double-colon (`::`) is used as a module separator, so\n+`std::io::println` means 'the thing named `println` in the module\n+named `io` in the module named `std`'.\n+\n+Rust will normally emit warning about unused variables. These can be\n+suppressed by using a variable name that starts with an underscore.\n+\n+~~~~\n+fn this_warns(x: int) {}\n+fn this_doesnt(_x: int) {}\n+~~~~\n+\n+## Variable declaration\n+\n+The `let` keyword, as we've seen, introduces a local variable. Global\n+constants can be defined with `const`:\n+\n+~~~~\n+use std;\n+const repeat: uint = 5u;\n+fn main() {\n+    let count = 0u;\n+    while count < repeat {\n+        std::io::println(\"Hi!\");\n+        count += 1u;\n+    }\n+}\n+~~~~\n+\n+## Types\n+\n+The `-> bool` in the `is_four` example is the way a function's return\n+type is written. For functions that do not return a meaningful value\n+(these conceptually return nil in Rust), you can optionally say `->\n+()` (`()` is how nil is written), but usually the return annotation is\n+simply left off, as in the `fn main() { ... }` examples we've seen\n+earlier.\n+\n+Every argument to a function must have its type declared (for example,\n+`x: int`). Inside the function, type inference will be able to\n+automatically deduce the type of most locals (generic functions, which\n+we'll come back to later, will occasionally need additional\n+annotation). Locals can be written either with or without a type\n+annotation:\n+\n+~~~~\n+// The type of this vector will be inferred based on its use.\n+let x = [];\n+# x = [3];\n+// Explicitly say this is a vector of integers.\n+let y: [int] = [];\n+~~~~\n+\n+The basic types are written like this:\n+\n+`()`\n+  : Nil, the type that has only a single value.\n+\n+`bool`\n+  : Boolean type, with values `true` and `false`.\n+\n+`int`\n+  : A machine-pointer-sized integer.\n+\n+`uint`\n+  : A machine-pointer-sized unsigned integer.\n+\n+`i8`, `i16`, `i32`, `i64`\n+  : Signed integers with a specific size (in bits).\n+\n+`u8`, `u16`, `u32`, `u64`\n+  : Unsigned integers with a specific size.\n+\n+`f32`, `f64`\n+  : Floating-point types.\n+\n+`float`\n+  : The largest floating-point type efficiently supported on the target machine.\n+\n+`char`\n+  : A character is a 32-bit Unicode code point.\n+\n+`str`\n+  : String type. A string contains a utf-8 encoded sequence of characters.\n+\n+These can be combined in composite types, which will be described in\n+more detail later on (the `T`s here stand for any other type):\n+\n+`[T]`\n+  : Vector type.\n+\n+`[mutable T]`\n+  : Mutable vector type.\n+\n+`(T1, T2)`\n+  : Tuple type. Any arity above 1 is supported.\n+\n+`{field1: T1, field2: T2}`\n+  : Record type.\n+\n+`fn(arg1: T1, arg2: T2) -> T3`, `lambda()`, `block()`\n+  : Function types.\n+\n+`@T`, `~T`, `*T`\n+  : Pointer types.\n+\n+Types can be given names with `type` declarations:\n+\n+~~~~\n+type monster_size = uint;\n+~~~~\n+\n+This will provide a synonym, `monster_size`, for unsigned integers. It\n+will not actually create a new type\u2014`monster_size` and `uint` can be\n+used interchangeably, and using one where the other is expected is not\n+a type error. Read about [single-variant enums][sve] further on if you\n+need to create a type name that's not just a synonym.\n+\n+[sve]: data.html#single_variant_enum\n+\n+## Literals\n+\n+Integers can be written in decimal (`144`), hexadecimal (`0x90`), and\n+binary (`0b10010000`) base. Without suffix, an integer literal is\n+considered to be of type `int`. Add a `u` (`144u`) to make it a `uint`\n+instead. Literals of the fixed-size integer types can be created by\n+the literal with the type name (`255u8`, `50i64`, etc).\n+\n+Note that, in Rust, no implicit conversion between integer types\n+happens. If you are adding one to a variable of type `uint`, you must\n+type `v += 1u`\u2014saying `+= 1` will give you a type error.\n+\n+Floating point numbers are written `0.0`, `1e6`, or `2.1e-4`. Without\n+suffix, the literal is assumed to be of type `float`. Suffixes `f32`\n+and `f64` can be used to create literals of a specific type. The\n+suffix `f` can be used to write `float` literals without a dot or\n+exponent: `3f`.\n+\n+The nil literal is written just like the type: `()`. The keywords\n+`true` and `false` produce the boolean literals.\n+\n+Character literals are written between single quotes, as in `'x'`. You\n+may put non-ascii characters between single quotes (your source files\n+should be encoded as utf-8). Rust understands a number of\n+character escapes, using the backslash character:\n+\n+`\\n`\n+  : A newline (unicode character 32).\n+\n+`\\r`\n+  : A carriage return (13).\n+\n+`\\t`\n+  : A tab character (9).\n+\n+`\\\\`, `\\'`, `\\\"`\n+  : Simply escapes the following character.\n+\n+`\\xHH`, `\\uHHHH`, `\\UHHHHHHHH`\n+  : Unicode escapes, where the `H` characters are the hexadecimal digits that\n+    form the character code.\n+\n+String literals allow the same escape sequences. They are written\n+between double quotes (`\"hello\"`). Rust strings may contain newlines.\n+When a newline is preceded by a backslash, it, and all white space\n+following it, will not appear in the resulting string literal. So\n+this is equivalent to `\"abc\"`:\n+\n+~~~~\n+let s = \"a\\\n+         b\\\n+         c\";\n+~~~~\n+\n+## Operators\n+\n+Rust's set of operators contains very few surprises. The main\n+difference with C is that `++` and `--` are missing, and that the\n+logical binary operators have higher precedence\u2014in C, `x & 2 > 0`\n+comes out as `x & (2 > 0)`, in Rust, it means `(x & 2) > 0`, which is\n+more likely to be what you expect (unless you are a C veteran).\n+\n+Thus, binary arithmetic is done with `*`, `/`, `%`, `+`, and `-`\n+(multiply, divide, remainder, plus, minus). `-` is also a unary prefix\n+operator (there are no unary postfix operators in Rust) that does\n+negation.\n+\n+Binary shifting is done with `>>` (shift right), `>>>` (arithmetic\n+shift right), and `<<` (shift left). Logical bitwise operators are\n+`&`, `|`, and `^` (and, or, and exclusive or), and unary `!` for\n+bitwise negation (or boolean negation when applied to a boolean\n+value).\n+\n+The comparison operators are the traditional `==`, `!=`, `<`, `>`,\n+`<=`, and `>=`. Short-circuiting (lazy) boolean operators are written\n+`&&` (and) and `||` (or).\n+\n+Rust has a ternary conditional operator `?:`, as in:\n+\n+~~~~\n+let badness = 12;\n+let message = badness < 10 ? \"error\" : \"FATAL ERROR\";\n+~~~~\n+\n+For type casting, Rust uses the binary `as` operator, which has a\n+precedence between the bitwise combination operators (`&`, `|`, `^`)\n+and the comparison operators. It takes an expression on the left side,\n+and a type on the right side, and will, if a meaningful conversion\n+exists, convert the result of the expression to the given type.\n+\n+~~~~\n+let x: float = 4.0;\n+let y: uint = x as uint;\n+assert y == 4u;\n+~~~~\n+\n+## Attributes\n+\n+<a name=\"conditional\"></a>\n+\n+Every definition can be annotated with attributes. Attributes are meta\n+information that can serve a variety of purposes. One of those is\n+conditional compilation:\n+\n+~~~~\n+#[cfg(target_os = \"win32\")]\n+fn register_win_service() { /* ... */ }\n+~~~~\n+\n+This will cause the function to vanish without a trace during\n+compilation on a non-Windows platform, much like `#ifdef` in C (it\n+allows `cfg(flag=value)` and `cfg(flag)` forms, where the second\n+simply checks whether the configuration flag is defined at all). Flags\n+for `target_os` and `target_arch` are set by the compiler. It is\n+possible to set additional flags with the `--cfg` command-line option.\n+\n+Attributes are always wrapped in hash-braces (`#[attr]`). Inside the\n+braces, a small minilanguage is supported, whose interpretation\n+depends on the attribute that's being used. The simplest form is a\n+plain name (as in `#[test]`, which is used by the [built-in test\n+framework](test.html '')). A name-value pair can be provided using an `=`\n+character followed by a literal (as in `#[license = \"BSD\"]`, which is\n+a valid way to annotate a Rust program as being released under a\n+BSD-style license). Finally, you can have a name followed by a\n+comma-separated list of nested attributes, as in the `cfg` example\n+above, or in this [crate](mod.html) metadata declaration:\n+\n+~~~~\n+## ignore\n+#[link(name = \"std\",\n+       vers = \"0.1\",\n+       url = \"http://rust-lang.org/src/std\")];\n+~~~~\n+\n+An attribute without a semicolon following it applies to the\n+definition that follows it. When terminated with a semicolon, it\n+applies to the module or crate in which it appears.\n+\n+## Syntax extensions\n+\n+There are plans to support user-defined syntax (macros) in Rust. This\n+currently only exists in very limited form.\n+\n+The compiler defines a few built-in syntax extensions. The most useful\n+one is `#fmt`, a printf-style text formatting macro that is expanded\n+at compile time.\n+\n+~~~~\n+std::io::println(#fmt(\"%s is %d\", \"the answer\", 42));\n+~~~~\n+\n+`#fmt` supports most of the directives that [printf][pf] supports, but\n+will give you a compile-time error when the types of the directives\n+don't match the types of the arguments.\n+\n+[pf]: http://en.cppreference.com/w/cpp/io/c/fprintf\n+\n+All syntax extensions look like `#word`. Another built-in one is\n+`#env`, which will look up its argument as an environment variable at\n+compile-time.\n+\n+~~~~\n+std::io::println(#env(\"PATH\"));\n+~~~~\n+# Control structures\n+\n+## Conditionals\n+\n+We've seen `if` pass by a few times already. To recap, braces are\n+compulsory, an optional `else` clause can be appended, and multiple\n+`if`/`else` constructs can be chained together:\n+\n+~~~~\n+if false {\n+    std::io::println(\"that's odd\");\n+} else if true {\n+    std::io::println(\"right\");\n+} else {\n+    std::io::println(\"neither true nor false\");\n+}\n+~~~~\n+\n+The condition given to an `if` construct *must* be of type boolean (no\n+implicit conversion happens). If the arms return a value, this value\n+must be of the same type for every arm in which control reaches the\n+end of the block:\n+\n+~~~~\n+fn signum(x: int) -> int {\n+    if x < 0 { -1 }\n+    else if x > 0 { 1 }\n+    else { ret 0; }\n+}\n+~~~~\n+\n+The `ret` (return) and its semicolon could have been left out without\n+changing the meaning of this function, but it illustrates that you\n+will not get a type error in this case, although the last arm doesn't\n+have type `int`, because control doesn't reach the end of that arm\n+(`ret` is jumping out of the function).\n+\n+## Pattern matching\n+\n+Rust's `alt` construct is a generalized, cleaned-up version of C's\n+`switch` construct. You provide it with a value and a number of arms,\n+each labelled with a pattern, and it will execute the arm that matches\n+the value.\n+\n+~~~~\n+# let my_number = 1;\n+alt my_number {\n+  0       { std::io::println(\"zero\"); }\n+  1 | 2   { std::io::println(\"one or two\"); }\n+  3 to 10 { std::io::println(\"three to ten\"); }\n+  _       { std::io::println(\"something else\"); }\n+}\n+~~~~\n+\n+There is no 'falling through' between arms, as in C\u2014only one arm is\n+executed, and it doesn't have to explicitly `break` out of the\n+construct when it is finished.\n+\n+The part to the left of each arm is called the pattern. Literals are\n+valid patterns, and will match only their own value. The pipe operator\n+(`|`) can be used to assign multiple patterns to a single arm. Ranges\n+of numeric literal patterns can be expressed with `to`. The underscore\n+(`_`) is a wildcard pattern that matches everything.\n+\n+If the arm with the wildcard pattern was left off in the above\n+example, running it on a number greater than ten (or negative) would\n+cause a run-time failure. When no arm matches, `alt` constructs do not\n+silently fall through\u2014they blow up instead.\n+\n+A powerful application of pattern matching is *destructuring*, where\n+you use the matching to get at the contents of data types. Remember\n+that `(float, float)` is a tuple of two floats:\n+\n+~~~~\n+fn angle(vec: (float, float)) -> float {\n+    alt vec {\n+      (0f, y) if y < 0f { 1.5 * float::consts::pi }\n+      (0f, y) { 0.5 * float::consts::pi }\n+      (x, y) { float::atan(y / x) }\n+    }\n+}\n+~~~~\n+\n+A variable name in a pattern matches everything, *and* binds that name\n+to the value of the matched thing inside of the arm block. Thus, `(0f,\n+y)` matches any tuple whose first element is zero, and binds `y` to\n+the second element. `(x, y)` matches any tuple, and binds both\n+elements to a variable.\n+\n+Any `alt` arm can have a guard clause (written `if EXPR`), which is\n+an expression of type `bool` that determines, after the pattern is\n+found to match, whether the arm is taken or not. The variables bound\n+by the pattern are available in this guard expression.\n+\n+## Destructuring let\n+\n+To a limited extent, it is possible to use destructuring patterns when\n+declaring a variable with `let`. For example, you can say this to\n+extract the fields from a tuple:\n+\n+~~~~\n+# fn get_tuple_of_two_ints() -> (int, int) { (1, 1) }\n+let (a, b) = get_tuple_of_two_ints();\n+~~~~\n+\n+This will introduce two new variables, `a` and `b`, bound to the\n+content of the tuple.\n+\n+You may only use irrevocable patterns\u2014patterns that can never fail to\n+match\u2014in let bindings, though. Things like literals, which only match\n+a specific value, are not allowed.\n+\n+## Loops\n+\n+`while` produces a loop that runs as long as its given condition\n+(which must have type `bool`) evaluates to true. Inside a loop, the\n+keyword `break` can be used to abort the loop, and `cont` can be used\n+to abort the current iteration and continue with the next.\n+\n+~~~~\n+let x = 5;\n+while true {\n+    x += x - 3;\n+    if x % 5 == 0 { break; }\n+    std::io::println(int::str(x));\n+}\n+~~~~\n+\n+This code prints out a weird sequence of numbers and stops as soon as\n+it finds one that can be divided by five.\n+\n+There's also `while`'s ugly cousin, `do`/`while`, which does not check\n+its condition on the first iteration, using traditional syntax:\n+\n+~~~~\n+# fn eat_cake() {}\n+# fn any_cake_left() -> bool { false }\n+do {\n+    eat_cake();\n+} while any_cake_left();\n+~~~~\n+\n+When iterating over a vector, use `for` instead.\n+\n+~~~~\n+for elt in [\"red\", \"green\", \"blue\"] {\n+    std::io::println(elt);\n+}\n+~~~~\n+\n+This will go over each element in the given vector (a three-element\n+vector of strings, in this case), and repeatedly execute the body with\n+`elt` bound to the current element. You may add an optional type\n+declaration (`elt: str`) for the iteration variable if you want.\n+\n+For more involved iteration, such as going over the elements of a hash\n+table, Rust uses higher-order functions. We'll come back to those in a\n+moment.\n+\n+## Failure\n+\n+The `fail` keyword causes the current [task][tasks] to fail. You use\n+it to indicate unexpected failure, much like you'd use `exit(1)` in a\n+C program, except that in Rust, it is possible for other tasks to\n+handle the failure, allowing the program to continue running.\n+\n+`fail` takes an optional argument, which must have type `str`. Trying\n+to access a vector out of bounds, or running a pattern match with no\n+matching clauses, both result in the equivalent of a `fail`.\n+\n+[tasks]: task.html\n+\n+## Logging\n+\n+Rust has a built-in logging mechanism, using the `log` statement.\n+Logging is polymorphic\u2014any type of value can be logged, and the\n+runtime will do its best to output a textual representation of the\n+value.\n+\n+~~~~\n+log(warn, \"hi\");\n+log(error, (1, [2.5, -1.8]));\n+~~~~\n+\n+The first argument is the log level (levels `info`, `warn`, and\n+`error` are predefined), and the second is the value to log. By\n+default, you *will not* see the output of that first log statement,\n+which has `warn` level. The environment variable `RUST_LOG` controls\n+which log level is used. It can contain a comma-separated list of\n+paths for modules that should be logged. For example, running `rustc`\n+with `RUST_LOG=rustc::front::attr` will turn on logging in its\n+attribute parser. If you compile a program named `foo.rs`, its\n+top-level module will be called `foo`, and you can set `RUST_LOG` to\n+`foo` to enable `warn` and `info` logging for the module.\n+\n+Turned-off `log` statements impose minimal overhead on the code that\n+contains them, so except in code that needs to be really, really fast,\n+you should feel free to scatter around debug logging statements, and\n+leave them in.\n+\n+Three macros that combine text-formatting (as with `#fmt`) and logging\n+are available. These take a string and any number of format arguments,\n+and will log the formatted string:\n+\n+~~~~\n+# fn get_error_string() -> str { \"boo\" }\n+#warn(\"only %d seconds remaining\", 10);\n+#error(\"fatal: %s\", get_error_string());\n+~~~~\n+\n+## Assertions\n+\n+The keyword `assert`, followed by an expression with boolean type,\n+will check that the given expression results in `true`, and cause a\n+failure otherwise. It is typically used to double-check things that\n+*should* hold at a certain point in a program.\n+\n+~~~~\n+let x = 100;\n+while (x > 10) { x -= 10; }\n+assert x == 10;\n+~~~~\n+\n+# Functions\n+\n+Functions (like all other static declarations, such as `type`) can be\n+declared both at the top level and inside other functions (or modules,\n+which we'll come back to in moment).\n+\n+The `ret` keyword immediately returns from a function. It is\n+optionally followed by an expression to return. In functions that\n+return `()`, the returned expression can be left off. A function can\n+also return a value by having its top level block produce an\n+expression (by omitting the final semicolon).\n+\n+Some functions (such as the C function `exit`) never return normally.\n+In Rust, these are annotated with the pseudo-return type '`!`':\n+\n+~~~~\n+fn dead_end() -> ! { fail; }\n+~~~~\n+\n+This helps the compiler avoid spurious error messages. For example,\n+the following code would be a type error if `dead_end` would be\n+expected to return.\n+\n+~~~~\n+# fn can_go_left() -> bool { true }\n+# fn can_go_right() -> bool { true }\n+# enum dir { left; right; }\n+# fn dead_end() -> ! { fail; }\n+let dir = if can_go_left() { left }\n+          else if can_go_right() { right }\n+          else { dead_end(); };\n+~~~~\n+\n+## Closures\n+\n+Named functions, like those in the previous section, do not close over\n+their environment. Rust also includes support for closures, which are\n+functions that can access variables in the scope in which they are\n+created.\n+\n+There are several forms of closures, each with its own role. The most\n+common type is called a 'block', this is a closure which has full\n+access to its environment.\n+\n+~~~~\n+fn call_block_with_ten(b: block(int)) { b(10); }\n+\n+let x = 20;    \n+call_block_with_ten({|arg|\n+    #info(\"x=%d, arg=%d\", x, arg);\n+});\n+~~~~\n+\n+This defines a function that accepts a block, and then calls it with a\n+simple block that executes a log statement, accessing both its\n+argument and the variable `x` from its environment.\n+\n+Blocks can only be used in a restricted way, because it is not allowed\n+to survive the scope in which it was created. They are allowed to\n+appear in function argument position and in call position, but nowhere\n+else.\n+\n+### Boxed closures\n+\n+When you need to store a closure in a data structure, a block will not\n+do, since the compiler will refuse to let you store it. For this\n+purpose, Rust provides a type of closure that has an arbitrary\n+lifetime, written `fn@` (boxed closure, analogous to the `@` pointer\n+type described in the next section).\n+\n+A boxed closure does not directly access its environment, but merely\n+copies out the values that it closes over into a private data\n+structure. This means that it can not assign to these variables, and\n+will not 'see' updates to them.\n+\n+This code creates a closure that adds a given string to its argument,\n+returns it from a function, and then calls it:\n+\n+~~~~\n+use std;\n+\n+fn mk_appender(suffix: str) -> fn@(str) -> str {\n+    let f = fn@(s: str) -> str { s + suffix };\n+    ret f;\n+}\n+\n+fn main() {\n+    let shout = mk_appender(\"!\");\n+    std::io::println(shout(\"hey ho, let's go\"));\n+}\n+~~~~\n+\n+### Closure compatibility\n+\n+A nice property of Rust closures is that you can pass any kind of\n+closure (as long as the arguments and return types match) to functions\n+that expect a `block`. Thus, when writing a higher-order function that\n+wants to do nothing with its function argument beyond calling it, you\n+should almost always specify the type of that argument as `block`, so\n+that callers have the flexibility to pass whatever they want.\n+\n+~~~~\n+fn call_twice(f: block()) { f(); f(); }\n+call_twice({|| \"I am a block\"; });\n+call_twice(fn@() { \"I am a boxed closure\"; });\n+fn bare_function() { \"I am a plain function\"; }\n+call_twice(bare_function);\n+~~~~\n+\n+### Unique closures\n+\n+<a name=\"unique\"></a>\n+\n+Unique closures, written `fn~` in analogy to the `~` pointer type (see\n+next section), hold on to things that can safely be sent between\n+processes. They copy the values they close over, much like boxed\n+closures, but they also 'own' them\u2014meaning no other code can access\n+them. Unique closures mostly exist to for spawning new\n+[tasks](task.html).\n+\n+### Shorthand syntax\n+\n+The compact syntax used for blocks (`{|arg1, arg2| body}`) can also\n+be used to express boxed and unique closures in situations where the\n+closure style can be unambiguously derived from the context. Most\n+notably, when calling a higher-order function you do not have to use\n+the long-hand syntax for the function you're passing, since the\n+compiler can look at the argument type to find out what the parameter\n+types are.\n+\n+As a further simplification, if the final parameter to a function is a\n+closure, the closure need not be placed within parenthesis. You could,\n+for example, write...\n+\n+~~~~\n+let doubled = vec::map([1, 2, 3]) {|x| x*2};\n+~~~~\n+\n+`vec::map` is a function in the core library that applies its last\n+argument to every element of a vector, producing a new vector.\n+\n+Even when a closure takes no parameters, you must still write the bars\n+for the parameter list, as in `{|| ...}`.\n+\n+## Binding\n+\n+Partial application is done using the `bind` keyword in Rust.\n+\n+~~~~\n+let daynum = bind vec::position(_, [\"mo\", \"tu\", \"we\", \"do\",\n+                                    \"fr\", \"sa\", \"su\"]);\n+~~~~\n+\n+Binding a function produces a boxed closure (`fn@` type) in which some\n+of the arguments to the bound function have already been provided.\n+`daynum` will be a function taking a single string argument, and\n+returning the day of the week that string corresponds to (if any).\n+\n+## Iteration\n+\n+Functions taking blocks provide a good way to define non-trivial\n+iteration constructs. For example, this one iterates over a vector\n+of integers backwards:\n+\n+~~~~\n+fn for_rev(v: [int], act: block(int)) {\n+    let i = vec::len(v);\n+    while (i > 0u) {\n+        i -= 1u;\n+        act(v[i]);\n+    }\n+}\n+~~~~\n+\n+To run such an iteration, you could do this:\n+\n+~~~~\n+# fn for_rev(v: [int], act: block(int)) {}\n+for_rev([1, 2, 3], {|n| log(error, n); });\n+~~~~\n+\n+Making use of the shorthand where a final closure argument can be\n+moved outside of the parentheses permits the following, which\n+looks quite like a normal loop:\n+\n+~~~~\n+# fn for_rev(v: [int], act: block(int)) {}\n+for_rev([1, 2, 3]) {|n|\n+    log(error, n);\n+}\n+~~~~\n+\n+Note that, because `for_rev()` returns unit type, no semicolon is\n+needed when the final closure is pulled outside of the parentheses.\n+\n+# Datatypes\n+\n+Rust datatypes are, by default, immutable. The core datatypes of Rust\n+are structural records and 'enums' (tagged unions, algebraic data\n+types).\n+\n+~~~~\n+type point = {x: float, y: float};\n+enum shape {\n+    circle(point, float);\n+    rectangle(point, point);\n+}\n+let my_shape = circle({x: 0.0, y: 0.0}, 10.0);\n+~~~~\n+\n+## Records\n+\n+Rust record types are written `{field1: TYPE, field2: TYPE [, ...]}`,\n+and record literals are written in the same way, but with expressions\n+instead of types. They are quite similar to C structs, and even laid\n+out the same way in memory (so you can read from a Rust struct in C,\n+and vice-versa).\n+\n+The dot operator is used to access record fields (`mypoint.x`).\n+\n+Fields that you want to mutate must be explicitly marked as such. For\n+example...\n+\n+~~~~\n+type stack = {content: [int], mutable head: uint};\n+~~~~\n+\n+With such a type, you can do `mystack.head += 1u`. If `mutable` were\n+omitted from the type, such an assignment would result in a type\n+error.\n+\n+To 'update' an immutable record, you use functional record update\n+syntax, by ending a record literal with the keyword `with`:\n+\n+~~~~\n+let oldpoint = {x: 10f, y: 20f};\n+let newpoint = {x: 0f with oldpoint};\n+assert newpoint == {x: 0f, y: 20f};\n+~~~~\n+\n+This will create a new struct, copying all the fields from `oldpoint`\n+into it, except for the ones that are explicitly set in the literal.\n+\n+Rust record types are *structural*. This means that `{x: float, y:\n+float}` is not just a way to define a new type, but is the actual name\n+of the type. Record types can be used without first defining them. If\n+module A defines `type point = {x: float, y: float}`, and module B,\n+without knowing anything about A, defines a function that returns an\n+`{x: float, y: float}`, you can use that return value as a `point` in\n+module A. (Remember that `type` defines an additional name for a type,\n+not an actual new type.)\n+\n+## Record patterns\n+\n+Records can be destructured on in `alt` patterns. The basic syntax is\n+`{fieldname: pattern, ...}`, but the pattern for a field can be\n+omitted as a shorthand for simply binding the variable with the same\n+name as the field.\n+\n+~~~~\n+# let mypoint = {x: 0f, y: 0f};\n+alt mypoint {\n+    {x: 0f, y: y_name} { /* Provide sub-patterns for fields */ }\n+    {x, y}             { /* Simply bind the fields */ }\n+}\n+~~~~\n+\n+The field names of a record do not have to appear in a pattern in the\n+same order they appear in the type. When you are not interested in all\n+the fields of a record, a record pattern may end with `, _` (as in\n+`{field1, _}`) to indicate that you're ignoring all other fields.\n+\n+## Enums\n+\n+Enums are datatypes that have several different representations. For\n+example, the type shown earlier:\n+\n+~~~~\n+# type point = {x: float, y: float};\n+enum shape {\n+    circle(point, float);\n+    rectangle(point, point);\n+}\n+~~~~\n+\n+A value of this type is either a circle\u00b8 in which case it contains a\n+point record and a float, or a rectangle, in which case it contains\n+two point records. The run-time representation of such a value\n+includes an identifier of the actual form that it holds, much like the\n+'tagged union' pattern in C, but with better ergonomics.\n+\n+The above declaration will define a type `shape` that can be used to\n+refer to such shapes, and two functions, `circle` and `rectangle`,\n+which can be used to construct values of the type (taking arguments of\n+the specified types). So `circle({x: 0f, y: 0f}, 10f)` is the way to\n+create a new circle.\n+\n+Enum variants do not have to have parameters. This, for example, is\n+equivalent to a C enum:\n+\n+~~~~\n+enum direction {\n+    north;\n+    east;\n+    south;\n+    west;\n+}\n+~~~~\n+\n+This will define `north`, `east`, `south`, and `west` as constants,\n+all of which have type `direction`.\n+\n+When the enum is C like, that is none of the variants have parameters,\n+it is possible to explicitly set the discriminator values to an integer\n+value:\n+\n+~~~~\n+enum color {\n+  red = 0xff0000;\n+  green = 0x00ff00;\n+  blue = 0x0000ff;\n+}\n+~~~~\n+\n+If an explicit discriminator is not specified for a variant, the value\n+defaults to the value of the previous variant plus one.  If the first\n+variant does not have a discriminator, it defaults to 0.  For example,\n+the value of `north` is 0, `east` is 1, etc.\n+\n+When an enum is C-like the `as` cast operator can be used to get the\n+discriminator's value.\n+\n+<a name=\"single_variant_enum\"></a>\n+\n+There is a special case for enums with a single variant. These are\n+used to define new types in such a way that the new name is not just a\n+synonym for an existing type, but its own distinct type. If you say:\n+\n+~~~~\n+enum gizmo_id = int;\n+~~~~\n+\n+That is a shorthand for this:\n+\n+~~~~\n+enum gizmo_id { gizmo_id(int); }\n+~~~~\n+\n+Enum types like this can have their content extracted with the\n+dereference (`*`) unary operator:\n+\n+~~~~\n+# enum gizmo_id = int;\n+let my_gizmo_id = gizmo_id(10);\n+let id_int: int = *my_gizmo_id;\n+~~~~\n+\n+## Enum patterns\n+\n+For enum types with multiple variants, destructuring is the only way to\n+get at their contents. All variant constructors can be used as\n+patterns, as in this definition of `area`:\n+\n+~~~~\n+# type point = {x: float, y: float};\n+# enum shape { circle(point, float); rectangle(point, point); }\n+fn area(sh: shape) -> float {\n+    alt sh {\n+        circle(_, size) { float::consts::pi * size * size }\n+        rectangle({x, y}, {x: x2, y: y2}) { (x2 - x) * (y2 - y) }\n+    }\n+}\n+~~~~\n+\n+Another example, matching nullary enum variants:\n+\n+~~~~\n+# type point = {x: float, y: float};\n+# enum direction { north; east; south; west; }\n+fn point_from_direction(dir: direction) -> point {\n+    alt dir {\n+        north { {x:  0f, y:  1f} }\n+        east  { {x:  1f, y:  0f} }\n+        south { {x:  0f, y: -1f} }\n+        west  { {x: -1f, y:  0f} }\n+    }\n+}\n+~~~~\n+\n+## Tuples\n+\n+Tuples in Rust behave exactly like records, except that their fields\n+do not have names (and can thus not be accessed with dot notation).\n+Tuples can have any arity except for 0 or 1 (though you may see nil,\n+`()`, as the empty tuple if you like).\n+\n+~~~~\n+let mytup: (int, int, float) = (10, 20, 30.0);\n+alt mytup {\n+  (a, b, c) { log(info, a + b + (c as int)); }\n+}\n+~~~~\n+\n+## Pointers\n+\n+In contrast to a lot of modern languages, record and enum types in\n+Rust are not represented as pointers to allocated memory. They are,\n+like in C and C++, represented directly. This means that if you `let x\n+= {x: 1f, y: 1f};`, you are creating a record on the stack. If you\n+then copy it into a data structure, the whole record is copied, not\n+just a pointer.\n+\n+For small records like `point`, this is usually more efficient than\n+allocating memory and going through a pointer. But for big records, or\n+records with mutable fields, it can be useful to have a single copy on\n+the heap, and refer to that through a pointer.\n+\n+Rust supports several types of pointers. The simplest is the unsafe\n+pointer, written `*TYPE`, which is a completely unchecked pointer\n+type only used in unsafe code (and thus, in typical Rust code, very\n+rarely). The safe pointer types are `@TYPE` for shared,\n+reference-counted boxes, and `~TYPE`, for uniquely-owned pointers.\n+\n+All pointer types can be dereferenced with the `*` unary operator.\n+\n+### Shared boxes\n+\n+<a name=\"shared-box\"></a>\n+\n+Shared boxes are pointers to heap-allocated, reference counted memory.\n+A cycle collector ensures that circular references do not result in\n+memory leaks.\n+\n+Creating a shared box is done by simply applying the unary `@`\n+operator to an expression. The result of the expression will be boxed,\n+resulting in a box of the right type. For example:\n+\n+~~~~\n+let x = @10; // New box, refcount of 1\n+let y = x; // Copy the pointer, increase refcount\n+// When x and y go out of scope, refcount goes to 0, box is freed\n+~~~~\n+\n+NOTE: We may in the future switch to garbage collection, rather than\n+reference counting, for shared boxes.\n+\n+Shared boxes never cross task boundaries.\n+\n+### Unique boxes\n+\n+<a name=\"unique-box\"></a>\n+\n+In contrast to shared boxes, unique boxes are not reference counted.\n+Instead, it is statically guaranteed that only a single owner of the\n+box exists at any time.\n+\n+~~~~\n+let x = ~10;\n+let y <- x;\n+~~~~\n+\n+This is where the 'move' (`<-`) operator comes in. It is similar to\n+`=`, but it de-initializes its source. Thus, the unique box can move\n+from `x` to `y`, without violating the constraint that it only has a\n+single owner (if you used assignment instead of the move operator, the\n+box would, in principle, be copied).\n+\n+Unique boxes, when they do not contain any shared boxes, can be sent\n+to other tasks. The sending task will give up ownership of the box,\n+and won't be able to access it afterwards. The receiving task will\n+become the sole owner of the box.\n+\n+### Mutability\n+\n+All pointer types have a mutable variant, written `@mutable TYPE` or\n+`~mutable TYPE`. Given such a pointer, you can write to its contents\n+by combining the dereference operator with a mutating action.\n+\n+~~~~\n+fn increase_contents(pt: @mutable int) {\n+    *pt += 1;\n+}\n+~~~~\n+\n+## Vectors\n+\n+Rust vectors are always heap-allocated and unique. A value of type\n+`[TYPE]` is represented by a pointer to a section of heap memory\n+containing any number of `TYPE` values.\n+\n+NOTE: This uniqueness is turning out to be quite awkward in practice,\n+and might change in the future.\n+\n+Vector literals are enclosed in square brackets. Dereferencing is done\n+with square brackets (zero-based):\n+\n+~~~~\n+let myvec = [true, false, true, false];\n+if myvec[1] { std::io::println(\"boom\"); }\n+~~~~\n+\n+By default, vectors are immutable\u2014you can not replace their elements.\n+The type written as `[mutable TYPE]` is a vector with mutable\n+elements. Mutable vector literals are written `[mutable]` (empty) or\n+`[mutable 1, 2, 3]` (with elements).\n+\n+The `+` operator means concatenation when applied to vector types.\n+Growing a vector in Rust is not as inefficient as it looks :\n+\n+~~~~\n+let myvec = [], i = 0;\n+while i < 100 {\n+    myvec += [i];\n+    i += 1;\n+}\n+~~~~\n+\n+Because a vector is unique, replacing it with a longer one (which is\n+what `+= [i]` does) is indistinguishable from appending to it\n+in-place. Vector representations are optimized to grow\n+logarithmically, so the above code generates about the same amount of\n+copying and reallocation as `push` implementations in most other\n+languages.\n+\n+## Strings\n+\n+The `str` type in Rust is represented exactly the same way as a vector\n+of bytes (`[u8]`), except that it is guaranteed to have a trailing\n+null byte (for interoperability with C APIs).\n+\n+This sequence of bytes is interpreted as an UTF-8 encoded sequence of\n+characters. This has the advantage that UTF-8 encoded I/O (which\n+should really be the default for modern systems) is very fast, and\n+that strings have, for most intents and purposes, a nicely compact\n+representation. It has the disadvantage that you only get\n+constant-time access by byte, not by character.\n+\n+A lot of algorithms don't need constant-time indexed access (they\n+iterate over all characters, which `str::chars` helps with), and\n+for those that do, many don't need actual characters, and can operate\n+on bytes. For algorithms that do really need to index by character,\n+there's the option to convert your string to a character vector (using\n+`str::to_chars`).\n+\n+Like vectors, strings are always unique. You can wrap them in a shared\n+box to share them. Unlike vectors, there is no mutable variant of\n+strings. They are always immutable.\n+\n+## Resources\n+\n+Resources are data types that have a destructor associated with them.\n+\n+~~~~\n+# fn close_file_desc(x: int) {}\n+resource file_desc(fd: int) {\n+    close_file_desc(fd);\n+}\n+~~~~\n+\n+This defines a type `file_desc` and a constructor of the same name,\n+which takes an integer. Values of such a type can not be copied, and\n+when they are destroyed (by going out of scope, or, when boxed, when\n+their box is cleaned up), their body runs. In the example above, this\n+would cause the given file descriptor to be closed.\n+\n+NOTE: We're considering alternative approaches for data types with\n+destructors. Resources might go away in the future.\n+\n+# Argument passing\n+\n+Rust datatypes are not trivial to copy (the way, for example,\n+JavaScript values can be copied by simply taking one or two machine\n+words and plunking them somewhere else). Shared boxes require\n+reference count updates, big records, tags, or unique pointers require\n+an arbitrary amount of data to be copied (plus updating the reference\n+counts of shared boxes hanging off them).\n+\n+For this reason, the default calling convention for Rust functions\n+leaves ownership of the arguments with the caller. The caller\n+guarantees that the arguments will outlive the call, the callee merely\n+gets access to them.\n+\n+## Safe references\n+\n+There is one catch with this approach: sometimes the compiler can\n+*not* statically guarantee that the argument value at the caller side\n+will survive to the end of the call. Another argument might indirectly\n+refer to it and be used to overwrite it, or a closure might assign a\n+new value to it.\n+\n+Fortunately, Rust tasks are single-threaded worlds, which share no\n+data with other tasks, and that most data is immutable. This allows\n+most argument-passing situations to be proved safe without further\n+difficulty.\n+\n+Take the following program:\n+\n+~~~~\n+# fn get_really_big_record() -> int { 1 }\n+# fn myfunc(a: int) {}\n+fn main() {\n+    let x = get_really_big_record();\n+    myfunc(x);\n+}\n+~~~~\n+\n+Here we know for sure that no one else has access to the `x` variable\n+in `main`, so we're good. But the call could also look like this:\n+\n+~~~~\n+# fn myfunc(a: int, b: block()) {}\n+# fn get_another_record() -> int { 1 }\n+# let x = 1;\n+myfunc(x, {|| x = get_another_record(); });\n+~~~~\n+\n+Now, if `myfunc` first calls its second argument and then accesses its\n+first argument, it will see a different value from the one that was\n+passed to it.\n+\n+In such a case, the compiler will insert an implicit copy of `x`,\n+*except* if `x` contains something mutable, in which case a copy would\n+result in code that behaves differently. If copying `x` might be\n+expensive (for example, if it holds a vector), the compiler will emit\n+a warning.\n+\n+There are even more tricky cases, in which the Rust compiler is forced\n+to pessimistically assume a value will get mutated, even though it is\n+not sure.\n+\n+~~~~\n+fn for_each(v: [mutable @int], iter: block(@int)) {\n+   for elt in v { iter(elt); }\n+}\n+~~~~\n+\n+For all this function knows, calling `iter` (which is a closure that\n+might have access to the vector that's passed as `v`) could cause the\n+elements in the vector to be mutated, with the effect that it can not\n+guarantee that the boxes will live for the duration of the call. So it\n+has to copy them. In this case, this will happen implicitly (bumping a\n+reference count is considered cheap enough to not warn about it).\n+\n+## The copy operator\n+\n+If the `for_each` function given above were to take a vector of\n+`{mutable a: int}` instead of `@int`, it would not be able to\n+implicitly copy, since if the `iter` function changes a copy of a\n+mutable record, the changes won't be visible in the record itself. If\n+we *do* want to allow copies there, we have to explicitly allow it\n+with the `copy` operator:\n+\n+~~~~\n+type mutrec = {mutable x: int};\n+fn for_each(v: [mutable mutrec], iter: block(mutrec)) {\n+   for elt in v { iter(copy elt); }\n+}\n+~~~~\n+\n+Adding a `copy` operator is also the way to muffle warnings about\n+implicit copies.\n+\n+## Other uses of safe references\n+\n+Safe references are not only used for argument passing. When you\n+destructure on a value in an `alt` expression, or loop over a vector\n+with `for`, variables bound to the inside of the given data structure\n+will use safe references, not copies. This means such references are\n+very cheap, but you'll occasionally have to copy them to ensure\n+safety.\n+\n+~~~~\n+let my_rec = {a: 4, b: [1, 2, 3]};\n+alt my_rec {\n+  {a, b} {\n+    log(info, b); // This is okay\n+    my_rec = {a: a + 1, b: b + [a]};\n+    log(info, b); // Here reference b has become invalid\n+  }\n+}\n+~~~~\n+\n+## Argument passing styles\n+\n+The fact that arguments are conceptually passed by safe reference does\n+not mean all arguments are passed by pointer. Composite types like\n+records and tags *are* passed by pointer, but single-word values, like\n+integers and pointers, are simply passed by value. Most of the time,\n+the programmer does not have to worry about this, as the compiler will\n+simply pick the most efficient passing style. There is one exception,\n+which will be described in the section on [generics](generic.html).\n+\n+To explicitly set the passing-style for a parameter, you prefix the\n+argument name with a sigil. There are two special passing styles that\n+are often useful. The first is by-mutable-pointer, written with a\n+single `&`:\n+\n+~~~~\n+fn vec_push(&v: [int], elt: int) {\n+    v += [elt];\n+}\n+~~~~\n+\n+This allows the function to mutate the value of the argument, *in the\n+caller's context*. Clearly, you are only allowed to pass things that\n+can actually be mutated to such a function.\n+\n+Then there is the by-copy style, written `+`. This indicates that the\n+function wants to take ownership of the argument value. If the caller\n+does not use the argument after the call, it will be 'given' to the\n+callee. Otherwise a copy will be made. This mode is mostly used for\n+functions that construct data structures. The argument will end up\n+being owned by the data structure, so if that can be done without a\n+copy, that's a win.\n+\n+~~~~\n+type person = {name: str, address: str};\n+fn make_person(+name: str, +address: str) -> person {\n+    ret {name: name, address: address};\n+}\n+~~~~\n+\n+# Generics\n+\n+## Generic functions\n+\n+Throughout this tutorial, I've been defining functions like `for_rev`\n+that act only on integers. It is 2012, and we no longer expect to be\n+defining such functions again and again for every type they apply to.\n+Thus, Rust allows functions and datatypes to have type parameters.\n+\n+~~~~\n+fn for_rev<T>(v: [T], act: block(T)) {\n+    let i = vec::len(v);\n+    while i > 0u {\n+        i -= 1u;\n+        act(v[i]);\n+    }\n+}\n+\n+fn map<T, U>(v: [T], f: block(T) -> U) -> [U] {\n+    let acc = [];\n+    for elt in v { acc += [f(elt)]; }\n+    ret acc;\n+}\n+~~~~\n+\n+When defined in this way, these functions can be applied to any type\n+of vector, as long as the type of the block's argument and the type of\n+the vector's content agree with each other.\n+\n+Inside a parameterized (generic) function, the names of the type\n+parameters (capitalized by convention) stand for opaque types. You\n+can't look inside them, but you can pass them around.\n+\n+## Generic datatypes\n+\n+Generic `type` and `enum` declarations follow the same pattern:\n+\n+~~~~\n+type circular_buf<T> = {start: uint,\n+                        end: uint,\n+                        buf: [mutable T]};\n+\n+enum option<T> { some(T); none; }\n+~~~~\n+\n+You can then declare a function to take a `circular_buf<u8>` or return\n+an `option<str>`, or even an `option<T>` if the function itself is\n+generic.\n+\n+The `option` type given above exists in the core library as\n+`option::t`, and is the way Rust programs express the thing that in C\n+would be a nullable pointer. The nice part is that you have to\n+explicitly unpack an `option` type, so accidental null pointer\n+dereferences become impossible.\n+\n+## Type-inference and generics\n+\n+Rust's type inferrer works very well with generics, but there are\n+programs that just can't be typed.\n+\n+~~~~\n+let n = option::none;\n+# n = option::some(1);\n+~~~~\n+\n+If you never do anything else with `n`, the compiler will not be able\n+to assign a type to it. (The same goes for `[]`, the empty vector.) If\n+you really want to have such a statement, you'll have to write it like\n+this:\n+\n+~~~~\n+let n2: option::t<int> = option::none;\n+// or\n+let n = option::none::<int>;\n+~~~~\n+\n+Note that, in a value expression, `<` already has a meaning as a\n+comparison operator, so you'll have to write `::<T>` to explicitly\n+give a type to a name that denotes a generic value. Fortunately, this\n+is rarely necessary.\n+\n+## Polymorphic built-ins\n+\n+There are two built-in operations that, perhaps surprisingly, act on\n+values of any type. It was already mentioned earlier that `log` can\n+take any type of value and output it.\n+\n+More interesting is that Rust also defines an ordering for values of\n+all datatypes, and allows you to meaningfully apply comparison\n+operators (`<`, `>`, `<=`, `>=`, `==`, `!=`) to them. For structural\n+types, the comparison happens left to right, so `\"abc\" < \"bac\"` (but\n+note that `\"bac\" < \"\u00e1c\"`, because the ordering acts on UTF-8 sequences\n+without any sophistication).\n+\n+## Kinds\n+\n+<a name=\"kind\"></a>\n+\n+Perhaps surprisingly, the 'copy' (duplicate) operation is not defined\n+for all Rust types. Resource types (types with destructors) can not be\n+copied, and neither can any type whose copying would require copying a\n+resource (such as records or unique boxes containing a resource).\n+\n+This complicates handling of generic functions. If you have a type\n+parameter `T`, can you copy values of that type? In Rust, you can't,\n+unless you explicitly declare that type parameter to have copyable\n+'kind'. A kind is a type of type.\n+\n+~~~~\n+## ignore\n+// This does not compile\n+fn head_bad<T>(v: [T]) -> T { v[0] }\n+// This does\n+fn head<T: copy>(v: [T]) -> T { v[0] }\n+~~~~\n+\n+When instantiating a generic function, you can only instantiate it\n+with types that fit its kinds. So you could not apply `head` to a\n+resource type.\n+\n+Rust has three kinds: 'noncopyable', 'copyable', and 'sendable'. By\n+default, type parameters are considered to be noncopyable. You can\n+annotate them with the `copy` keyword to declare them copyable, and\n+with the `send` keyword to make them sendable.\n+\n+Sendable types are a subset of copyable types. They are types that do\n+not contain shared (reference counted) types, which are thus uniquely\n+owned by the function that owns them, and can be sent over channels to\n+other tasks. Most of the generic functions in the core `comm` module\n+take sendable types.\n+\n+## Generic functions and argument-passing\n+\n+The previous section mentioned that arguments are passed by pointer or\n+by value based on their type. There is one situation in which this is\n+difficult. If you try this program:\n+\n+~~~~\n+# fn map(f: block(int) -> int, v: [int]) {}\n+fn plus1(x: int) -> int { x + 1 }\n+map(plus1, [1, 2, 3]);\n+~~~~\n+\n+You will get an error message about argument passing styles\n+disagreeing. The reason is that generic types are always passed by\n+pointer, so `map` expects a function that takes its argument by\n+pointer. The `plus1` you defined, however, uses the default, efficient\n+way to pass integers, which is by value. To get around this issue, you\n+have to explicitly mark the arguments to a function that you want to\n+pass to a generic higher-order function as being passed by pointer,\n+using the `&&` sigil:\n+\n+~~~~\n+# fn map<T, U>(f: block(T) -> U, v: [T]) {}\n+fn plus1(&&x: int) -> int { x + 1 }\n+map(plus1, [1, 2, 3]);\n+~~~~\n+\n+NOTE: This is inconvenient, and we are hoping to get rid of this\n+restriction in the future.\n+\n+# Modules and crates\n+\n+The Rust namespace is divided into modules. Each source file starts\n+with its own module.\n+\n+## Local modules\n+\n+The `mod` keyword can be used to open a new, local module. In the\n+example below, `chicken` lives in the module `farm`, so, unless you\n+explicitly import it, you must refer to it by its long name,\n+`farm::chicken`.\n+\n+~~~~\n+mod farm {\n+    fn chicken() -> str { \"cluck cluck\" }\n+    fn cow() -> str { \"mooo\" }\n+}\n+fn main() {\n+    std::io::println(farm::chicken());\n+}\n+~~~~\n+\n+Modules can be nested to arbitrary depth.\n+\n+## Crates\n+\n+The unit of independent compilation in Rust is the crate. Libraries\n+tend to be packaged as crates, and your own programs may consist of\n+one or more crates.\n+\n+When compiling a single `.rs` file, the file acts as the whole crate.\n+You can compile it with the `--lib` compiler switch to create a shared\n+library, or without, provided that your file contains a `fn main`\n+somewhere, to create an executable.\n+\n+It is also possible to include multiple files in a crate. For this\n+purpose, you create a `.rc` crate file, which references any number of\n+`.rs` code files. A crate file could look like this:\n+\n+~~~~\n+## ignore\n+#[link(name = \"farm\", vers = \"2.5\", author = \"mjh\")];\n+mod cow;\n+mod chicken;\n+mod horse;\n+~~~~\n+\n+Compiling this file will cause `rustc` to look for files named\n+`cow.rs`, `chicken.rs`, `horse.rs` in the same directory as the `.rc`\n+file, compile them all together, and, depending on the presence of the\n+`--lib` switch, output a shared library or an executable.\n+\n+The `#[link(...)]` part provides meta information about the module,\n+which other crates can use to load the right module. More about that\n+later.\n+\n+To have a nested directory structure for your source files, you can\n+nest mods in your `.rc` file:\n+\n+~~~~\n+## ignore\n+mod poultry {\n+    mod chicken;\n+    mod turkey;\n+}\n+~~~~\n+\n+The compiler will now look for `poultry/chicken.rs` and\n+`poultry/turkey.rs`, and export their content in `poultry::chicken`\n+and `poultry::turkey`. You can also provide a `poultry.rs` to add\n+content to the `poultry` module itself.\n+\n+## Using other crates\n+\n+Having compiled a crate with `--lib`, you can use it in another crate\n+with a `use` directive. We've already seen `use std` in several of the\n+examples, which loads in the [standard library][std].\n+\n+[std]: http://doc.rust-lang.org/doc/std/index/General.html\n+\n+`use` directives can appear in a crate file, or at the top level of a\n+single-file `.rs` crate. They will cause the compiler to search its\n+library search path (which you can extend with `-L` switch) for a Rust\n+crate library with the right name.\n+\n+It is possible to provide more specific information when using an\n+external crate.\n+\n+~~~~\n+## ignore\n+use myfarm (name = \"farm\", vers = \"2.7\");\n+~~~~\n+\n+When a comma-separated list of name/value pairs is given after `use`,\n+these are matched against the attributes provided in the `link`\n+attribute of the crate file, and a crate is only used when the two\n+match. A `name` value can be given to override the name used to search\n+for the crate. So the above would import the `farm` crate under the\n+local name `myfarm`.\n+\n+Our example crate declared this set of `link` attributes:\n+\n+~~~~\n+## ignore\n+#[link(name = \"farm\", vers = \"2.5\", author = \"mjh\")];\n+~~~~\n+\n+The version does not match the one provided in the `use` directive, so\n+unless the compiler can find another crate with the right version\n+somewhere, it will complain that no matching crate was found.\n+\n+## The core library\n+\n+A set of basic library routines, mostly related to built-in datatypes\n+and the task system, are always implicitly linked and included in any\n+Rust program, unless the `--no-core` compiler switch is given.\n+\n+This library is document [here][core].\n+\n+[core]: http://doc.rust-lang.org/doc/core/index/General.html\n+\n+## A minimal example\n+\n+Now for something that you can actually compile yourself. We have\n+these two files:\n+\n+~~~~\n+// mylib.rs\n+#[link(name = \"mylib\", vers = \"1.0\")];\n+fn world() -> str { \"world\" }\n+~~~~\n+\n+~~~~\n+## ignore\n+// main.rs\n+use mylib;\n+fn main() { std::io::println(\"hello \" + mylib::world()); }\n+~~~~\n+\n+Now compile and run like this (adjust to your platform if necessary):\n+\n+~~~~\n+## notrust\n+> rustc --lib mylib.rs\n+> rustc main.rs -L .\n+> ./main\n+\"hello world\"\n+~~~~\n+\n+## Importing\n+\n+When using identifiers from other modules, it can get tiresome to\n+qualify them with the full module path every time (especially when\n+that path is several modules deep). Rust allows you to import\n+identifiers at the top of a file, module, or block.\n+\n+~~~~\n+use std;\n+import std::io::println;\n+fn main() {\n+    println(\"that was easy\");\n+}\n+~~~~\n+\n+It is also possible to import just the name of a module (`import\n+std::io;`, then use `io::println`), to import all identifiers exported\n+by a given module (`import std::io::*`), or to import a specific set\n+of identifiers (`import math::{min, max, pi}`).\n+\n+You can rename an identifier when importing using the `=` operator:\n+\n+~~~~\n+import prnt = std::io::println;\n+~~~~\n+\n+## Exporting\n+\n+By default, a module exports everything that it defines. This can be\n+restricted with `export` directives at the top of the module or file.\n+\n+~~~~\n+mod enc {\n+    export encrypt, decrypt;\n+    const super_secret_number: int = 10;\n+    fn encrypt(n: int) -> int { n + super_secret_number }\n+    fn decrypt(n: int) -> int { n - super_secret_number }\n+}\n+~~~~\n+\n+This defines a rock-solid encryption algorithm. Code outside of the\n+module can refer to the `enc::encrypt` and `enc::decrypt` identifiers\n+just fine, but it does not have access to `enc::super_secret_number`.\n+\n+## Namespaces\n+\n+Rust uses three different namespaces. One for modules, one for types,\n+and one for values. This means that this code is valid:\n+\n+~~~~\n+mod buffalo {\n+    type buffalo = int;\n+    fn buffalo(buffalo: buffalo) -> buffalo { buffalo }\n+}\n+fn main() {\n+    let buffalo: buffalo::buffalo = 1;\n+    buffalo::buffalo(buffalo::buffalo(buffalo));\n+}\n+~~~~\n+\n+You don't want to write things like that, but it *is* very practical\n+to not have to worry about name clashes between types, values, and\n+modules. This allows us to have a module `core::str`, for example, even\n+though `str` is a built-in type name.\n+\n+## Resolution\n+\n+The resolution process in Rust simply goes up the chain of contexts,\n+looking for the name in each context. Nested functions and modules\n+create new contexts inside their parent function or module. A file\n+that's part of a bigger crate will have that crate's context as parent\n+context.\n+\n+Identifiers can shadow each others. In this program, `x` is of type\n+`int`:\n+\n+~~~~\n+type t = str;\n+fn main() {\n+    type t = int;\n+    let x: t;\n+}\n+~~~~\n+\n+An `import` directive will only import into the namespaces for which\n+identifiers are actually found. Consider this example:\n+\n+~~~~\n+type bar = uint;\n+mod foo { fn bar() {} }\n+mod baz {\n+    import foo::bar;\n+    const x: bar = 20u;\n+}\n+~~~~\n+\n+When resolving the type name `bar` in the `const` definition, the\n+resolver will first look at the module context for `baz`. This has an\n+import named `bar`, but that's a function, not a type, So it continues\n+to the top level and finds a type named `bar` defined there.\n+\n+Normally, multiple definitions of the same identifier in a scope are\n+disallowed. Local variables defined with `let` are an exception to\n+this\u2014multiple `let` directives can redefine the same variable in a\n+single scope. When resolving the name of such a variable, the most\n+recent definition is used.\n+\n+~~~~\n+fn main() {\n+    let x = 10;\n+    let x = x + 10;\n+    assert x == 20;\n+}\n+~~~~\n+\n+This makes it possible to rebind a variable without actually mutating\n+it, which is mostly useful for destructuring (which can rebind, but\n+not assign).\n+\n+# Interfaces\n+\n+Interfaces are Rust's take on value polymorphism\u2014the thing that\n+object-oriented languages tend to solve with methods and inheritance.\n+For example, writing a function that can operate on multiple types of\n+collections.\n+\n+NOTE: This feature is very new, and will need a few extensions to be\n+applicable to more advanced use cases.\n+\n+## Declaration\n+\n+An interface consists of a set of methods. A method is a function that\n+can be applied to a `self` value and a number of arguments, using the\n+dot notation: `self.foo(arg1, arg2)`.\n+\n+For example, we could declare the interface `to_str` for things that\n+can be converted to a string, with a single method of the same name:\n+\n+~~~~\n+iface to_str {\n+    fn to_str() -> str;\n+}\n+~~~~\n+\n+## Implementation\n+\n+To actually implement an interface for a given type, the `impl` form\n+is used. This defines implementations of `to_str` for the `int` and\n+`str` types.\n+\n+~~~~\n+# iface to_str { fn to_str() -> str; }\n+impl of to_str for int {\n+    fn to_str() -> str { int::to_str(self, 10u) }\n+}\n+impl of to_str for str {\n+    fn to_str() -> str { self }\n+}\n+~~~~\n+\n+Given these, we may call `1.to_str()` to get `\"1\"`, or\n+`\"foo\".to_str()` to get `\"foo\"` again. This is basically a form of\n+static overloading\u2014when the Rust compiler sees the `to_str` method\n+call, it looks for an implementation that matches the type with a\n+method that matches the name, and simply calls that.\n+\n+## Scoping\n+\n+Implementations are not globally visible. Resolving a method to an\n+implementation requires that implementation to be in scope. You can\n+import and export implementations using the name of the interface they\n+implement (multiple implementations with the same name can be in scope\n+without problems). Or you can give them an explicit name if you\n+prefer, using this syntax:\n+\n+~~~~\n+# iface to_str { fn to_str() -> str; }\n+impl nil_to_str of to_str for () {\n+    fn to_str() -> str { \"()\" }\n+}\n+~~~~\n+\n+## Bounded type parameters\n+\n+The useful thing about value polymorphism is that it does not have to\n+be static. If object-oriented languages only let you call a method on\n+an object when they knew exactly which sub-type it had, that would not\n+get you very far. To be able to call methods on types that aren't\n+known at compile time, it is possible to specify 'bounds' for type\n+parameters.\n+\n+~~~~\n+# iface to_str { fn to_str() -> str; }\n+fn comma_sep<T: to_str>(elts: [T]) -> str {\n+    let result = \"\", first = true;\n+    for elt in elts {\n+        if first { first = false; }\n+        else { result += \", \"; }\n+        result += elt.to_str();\n+    }\n+    ret result;\n+}\n+~~~~\n+\n+The syntax for this is similar to the syntax for specifying that a\n+parameter type has to be copyable (which is, in principle, another\n+kind of bound). By declaring `T` as conforming to the `to_str`\n+interface, it becomes possible to call methods from that interface on\n+values of that type inside the function. It will also cause a\n+compile-time error when anyone tries to call `comma_sep` on an array\n+whose element type does not have a `to_str` implementation in scope.\n+\n+## Polymorphic interfaces\n+\n+Interfaces may contain type parameters. This defines an interface for\n+generalized sequence types:\n+\n+~~~~\n+iface seq<T> {\n+    fn len() -> uint;\n+    fn iter(block(T));\n+}\n+impl <T> of seq<T> for [T] {\n+    fn len() -> uint { vec::len(self) }\n+    fn iter(b: block(T)) {\n+        for elt in self { b(elt); }\n+    }\n+}\n+~~~~\n+\n+Note that the implementation has to explicitly declare the its\n+parameter `T` before using it to specify its interface type. This is\n+needed because it could also, for example, specify an implementation\n+of `seq<int>`\u2014the `of` clause *refers* to a type, rather than defining\n+one.\n+\n+## Casting to an interface type\n+\n+The above allows us to define functions that polymorphically act on\n+values of *an* unknown type that conforms to a given interface.\n+However, consider this function:\n+\n+~~~~\n+# iface drawable { fn draw(); }\n+fn draw_all<T: drawable>(shapes: [T]) {\n+    for shape in shapes { shape.draw(); }\n+}\n+~~~~\n+\n+You can call that on an array of circles, or an array of squares\n+(assuming those have suitable `drawable` interfaces defined), but not\n+on an array containing both circles and squares.\n+\n+When this is needed, an interface name can be used as a type, causing\n+the function to be written simply like this:\n+\n+~~~~\n+# iface drawable { fn draw(); }\n+fn draw_all(shapes: [drawable]) {\n+    for shape in shapes { shape.draw(); }\n+}\n+~~~~\n+\n+There is no type parameter anymore (since there isn't a single type\n+that we're calling the function on). Instead, the `drawable` type is\n+used to refer to a type that is a reference-counted box containing a\n+value for which a `drawable` implementation exists, combined with\n+information on where to find the methods for this implementation. This\n+is very similar to the 'vtables' used in most object-oriented\n+languages.\n+\n+To construct such a value, you use the `as` operator to cast a value\n+to an interface type:\n+\n+~~~~\n+# type circle = int; type rectangle = int;\n+# iface drawable { fn draw(); }\n+# impl of drawable for int { fn draw() {} }\n+# fn new_circle() -> int { 1 }\n+# fn new_rectangle() -> int { 2 }\n+# fn draw_all(shapes: [drawable]) {}\n+let c: circle = new_circle();\n+let r: rectangle = new_rectangle();\n+draw_all([c as drawable, r as drawable]);\n+~~~~\n+\n+This will store the value into a box, along with information about the\n+implementation (which is looked up in the scope of the cast). The\n+`drawable` type simply refers to such boxes, and calling methods on it\n+always works, no matter what implementations are in scope.\n+\n+Note that the allocation of a box is somewhat more expensive than\n+simply using a type parameter and passing in the value as-is, and much\n+more expensive than statically resolved method calls.\n+\n+## Interface-less implementations\n+\n+If you only intend to use an implementation for static overloading,\n+and there is no interface available that it conforms to, you are free\n+to leave off the `of` clause.\n+\n+~~~~\n+# type currency = ();\n+# fn mk_currency(x: int, s: str) {}\n+impl int_util for int {\n+    fn times(b: block(int)) {\n+        let i = 0;\n+        while i < self { b(i); i += 1; }\n+    }\n+    fn dollars() -> currency {\n+        mk_currency(self, \"USD\")\n+    }\n+}\n+~~~~\n+\n+This allows cutesy things like `send_payment(10.dollars())`. And the\n+nice thing is that it's fully scoped, so the uneasy feeling that\n+anybody with experience in object-oriented languages (with the\n+possible exception of Rubyists) gets at the sight of such things is\n+not justified. It's harmless!\n+\n+# Interacting with foreign code\n+\n+One of Rust's aims, as a system programming language, is to\n+interoperate well with C code.\n+\n+We'll start with an example. It's a bit bigger than usual, and\n+contains a number of new concepts. We'll go over it one piece at a\n+time.\n+\n+This is a program that uses OpenSSL's `SHA1` function to compute the\n+hash of its first command-line argument, which it then converts to a\n+hexadecimal string and prints to standard output. If you have the\n+OpenSSL libraries installed, it should 'just work'.\n+\n+~~~~\n+use std;\n+\n+native mod crypto {\n+    fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n+}\n+\n+fn as_hex(data: [u8]) -> str {\n+    let acc = \"\";\n+    for byte in data { acc += #fmt(\"%02x\", byte as uint); }\n+    ret acc;\n+}\n+\n+fn sha1(data: str) -> str unsafe {\n+    let bytes = str::bytes(data);\n+    let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n+                            vec::len(bytes), ptr::null());\n+    ret as_hex(vec::unsafe::from_buf(hash, 20u));\n+}\n+\n+fn main(args: [str]) {\n+    std::io::println(sha1(args[1]));\n+}\n+~~~~\n+\n+## Native modules\n+\n+Before we can call `SHA1`, we have to declare it. That is what this\n+part of the program is responsible for:\n+\n+~~~~\n+native mod crypto {\n+    fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n+}\n+~~~~\n+\n+A `native` module declaration tells the compiler that the program\n+should be linked with a library by that name, and that the given list\n+of functions are available in that library.\n+\n+In this case, it'll change the name `crypto` to a shared library name\n+in a platform-specific way (`libcrypto.so` on Linux, for example), and\n+link that in. If you want the module to have a different name from the\n+actual library, you can use the `\"link_name\"` attribute, like:\n+\n+~~~~\n+#[link_name = \"crypto\"]\n+native mod something {\n+    fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n+}\n+~~~~\n+\n+## Native calling conventions\n+\n+Most native C code use the cdecl calling convention, so that is what\n+Rust uses by default when calling native functions. Some native functions,\n+most notably the Windows API, use other calling conventions, so Rust\n+provides a way to to hint to the compiler which is expected by using\n+the `\"abi\"` attribute:\n+\n+~~~~\n+#[cfg(target_os = \"win32\")]\n+#[abi = \"stdcall\"]\n+native mod kernel32 {\n+    fn SetEnvironmentVariableA(n: *u8, v: *u8) -> int;\n+}\n+~~~~\n+\n+The `\"abi\"` attribute applies to a native mod (it can not be applied\n+to a single function within a module), and must be either `\"cdecl\"`\n+or `\"stdcall\"`. Other conventions may be defined in the future.\n+\n+## Unsafe pointers\n+\n+The native `SHA1` function is declared to take three arguments, and\n+return a pointer.\n+\n+~~~~\n+# native mod crypto {\n+fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n+# }\n+~~~~\n+\n+When declaring the argument types to a foreign function, the Rust\n+compiler has no way to check whether your declaration is correct, so\n+you have to be careful. If you get the number or types of the\n+arguments wrong, you're likely to get a segmentation fault. Or,\n+probably even worse, your code will work on one platform, but break on\n+another.\n+\n+In this case, `SHA1` is defined as taking two `unsigned char*`\n+arguments and one `unsigned long`. The rust equivalents are `*u8`\n+unsafe pointers and an `uint` (which, like `unsigned long`, is a\n+machine-word-sized type).\n+\n+Unsafe pointers can be created through various functions in the\n+standard lib, usually with `unsafe` somewhere in their name. You can\n+dereference an unsafe pointer with `*` operator, but use\n+caution\u2014unlike Rust's other pointer types, unsafe pointers are\n+completely unmanaged, so they might point at invalid memory, or be\n+null pointers.\n+\n+## Unsafe blocks\n+\n+The `sha1` function is the most obscure part of the program.\n+\n+~~~~\n+# mod crypto { fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8 { out } }\n+# fn as_hex(data: [u8]) -> str { \"hi\" }\n+fn sha1(data: str) -> str unsafe {\n+    let bytes = str::bytes(data);\n+    let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n+                            vec::len(bytes), ptr::null());\n+    ret as_hex(vec::unsafe::from_buf(hash, 20u));\n+}\n+~~~~\n+\n+Firstly, what does the `unsafe` keyword at the top of the function\n+mean? `unsafe` is a block modifier\u2014it declares the block following it\n+to be known to be unsafe.\n+\n+Some operations, like dereferencing unsafe pointers or calling\n+functions that have been marked unsafe, are only allowed inside unsafe\n+blocks. With the `unsafe` keyword, you're telling the compiler 'I know\n+what I'm doing'. The main motivation for such an annotation is that\n+when you have a memory error (and you will, if you're using unsafe\n+constructs), you have some idea where to look\u2014it will most likely be\n+caused by some unsafe code.\n+\n+Unsafe blocks isolate unsafety. Unsafe functions, on the other hand,\n+advertise it to the world. An unsafe function is written like this:\n+\n+~~~~\n+unsafe fn kaboom() { \"I'm harmless!\"; }\n+~~~~\n+\n+This function can only be called from an unsafe block or another\n+unsafe function.\n+\n+## Pointer fiddling\n+\n+The standard library defines a number of helper functions for dealing\n+with unsafe data, casting between types, and generally subverting\n+Rust's safety mechanisms.\n+\n+Let's look at our `sha1` function again.\n+\n+~~~~\n+# mod crypto { fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8 { out } }\n+# fn as_hex(data: [u8]) -> str { \"hi\" }\n+# fn x(data: str) -> str unsafe {\n+let bytes = str::bytes(data);\n+let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n+                        vec::len(bytes), ptr::null());\n+ret as_hex(vec::unsafe::from_buf(hash, 20u));\n+# }\n+~~~~\n+\n+The `str::bytes` function is perfectly safe, it converts a string to\n+an `[u8]`. This byte array is then fed to `vec::unsafe::to_ptr`, which\n+returns an unsafe pointer to its contents.\n+\n+This pointer will become invalid as soon as the vector it points into\n+is cleaned up, so you should be very careful how you use it. In this\n+case, the local variable `bytes` outlives the pointer, so we're good.\n+\n+Passing a null pointer as third argument to `SHA1` causes it to use a\n+static buffer, and thus save us the effort of allocating memory\n+ourselves. `ptr::null` is a generic function that will return an\n+unsafe null pointer of the correct type (Rust generics are awesome\n+like that\u2014they can take the right form depending on the type that they\n+are expected to return).\n+\n+Finally, `vec::unsafe::from_buf` builds up a new `[u8]` from the\n+unsafe pointer that was returned by `SHA1`. SHA1 digests are always\n+twenty bytes long, so we can pass `20u` for the length of the new\n+vector.\n+\n+## Passing structures\n+\n+C functions often take pointers to structs as arguments. Since Rust\n+records are binary-compatible with C structs, Rust programs can call\n+such functions directly.\n+\n+This program uses the Posix function `gettimeofday` to get a\n+microsecond-resolution timer.\n+\n+~~~~\n+use std;\n+type timeval = {mutable tv_sec: u32,\n+                mutable tv_usec: u32};\n+#[nolink]\n+native mod libc {\n+    fn gettimeofday(tv: *timeval, tz: *()) -> i32;\n+}\n+fn unix_time_in_microseconds() -> u64 unsafe {\n+    let x = {mutable tv_sec: 0u32, mutable tv_usec: 0u32};\n+    libc::gettimeofday(ptr::addr_of(x), ptr::null());\n+    ret (x.tv_sec as u64) * 1000_000_u64 + (x.tv_usec as u64);\n+}\n+~~~~\n+\n+The `#[nolink]` attribute indicates that there's no native library to link\n+in. The standard C library is already linked with Rust programs.\n+\n+A `timeval`, in C, is a struct with two 32-bit integers. Thus, we\n+define a record type with the same contents, and declare\n+`gettimeofday` to take a pointer to such a record.\n+\n+The second argument to `gettimeofday` (the time zone) is not used by\n+this program, so it simply declares it to be a pointer to the nil\n+type. Since null pointer look the same, no matter which type they are\n+supposed to point at, this is safe.\n+\n+# Tasks\n+\n+Rust supports a system of lightweight tasks, similar to what is found\n+in Erlang or other actor systems. Rust tasks communicate via messages\n+and do not share data. However, it is possible to send data without\n+copying it by making use of [unique boxes][uniques], which allow the\n+sending task to release ownership of a value, so that the receiving\n+task can keep on using it.\n+\n+[uniques]: data.html#unique-box\n+\n+NOTE: As Rust evolves, we expect the Task API to grow and change\n+somewhat.  The tutorial documents the API as it exists today.\n+\n+## Spawning a task\n+\n+Spawning a task is done using the various spawn functions in the\n+module `task`.  Let's begin with the simplest one, `task::spawn()`:\n+\n+~~~~\n+let some_value = 22;\n+let child_task = task::spawn {||\n+    std::io::println(\"This executes in the child task.\");\n+    std::io::println(#fmt(\"%d\", some_value));\n+};\n+~~~~\n+\n+The argument to `task::spawn()` is a [unique\n+closure](func.html#unique) of type `fn~()`, meaning that it takes no\n+arguments and generates no return value. The effect of `task::spawn()`\n+is to fire up a child task that will execute the closure in parallel\n+with the creator. The result is a task id, here stored into the\n+variable `child_task`.\n+\n+## Ports and channels\n+\n+Now that we have spawned a child task, it would be nice if we could\n+communicate with it.  This is done by creating a *port* with an\n+associated *channel*.  A port is simply a location to receive messages\n+of a particular type.  A channel is used to send messages to a port.\n+For example, imagine we wish to perform two expensive computations\n+in parallel.  We might write something like:\n+\n+~~~~\n+# fn some_expensive_computation() -> int { 42 }\n+# fn some_other_expensive_computation() {}\n+let port = comm::port::<int>();\n+let chan = comm::chan::<int>(port);\n+let child_task = task::spawn {||\n+    let result = some_expensive_computation();\n+    comm::send(chan, result);\n+};\n+some_other_expensive_computation();\n+let result = comm::recv(port);\n+~~~~\n+\n+Let's walk through this code line-by-line.  The first line creates a\n+port for receiving integers:\n+\n+~~~~\n+let port = comm::port::<int>();\n+\n+~~~~\n+This port is where we will receive the message from the child task\n+once it is complete.  The second line creates a channel for sending\n+integers to the port `port`:\n+\n+~~~~\n+# let port = comm::port::<int>();\n+let chan = comm::chan::<int>(port);\n+~~~~\n+\n+The channel will be used by the child to send a message to the port.\n+The next statement actually spawns the child:\n+\n+~~~~\n+# fn some_expensive_computation() -> int { 42 }\n+# let port = comm::port::<int>();\n+# let chan = comm::chan::<int>(port);\n+let child_task = task::spawn {||\n+    let result = some_expensive_computation();\n+    comm::send(chan, result);\n+};\n+~~~~\n+\n+This child will perform the expensive computation send the result\n+over the channel.  Finally, the parent continues by performing\n+some other expensive computation and then waiting for the child's result\n+to arrive on the port:\n+\n+~~~~\n+# fn some_other_expensive_computation() {}\n+# let port = comm::port::<int>();\n+some_other_expensive_computation();\n+let result = comm::recv(port);\n+~~~~\n+\n+## Creating a task with a bi-directional communication path\n+\n+A very common thing to do is to spawn a child task where the parent\n+and child both need to exchange messages with each other. The function\n+`task::spawn_connected()` supports this pattern. We'll look briefly at\n+how it is used.\n+\n+To see how `spawn_connected()` works, we will create a child task\n+which receives `uint` messages, converts them to a string, and sends\n+the string in response.  The child terminates when `0` is received.\n+Here is the function which implements the child task:\n+\n+~~~~\n+fn stringifier(from_par: comm::port<uint>,\n+               to_par: comm::chan<str>) {\n+    let value: uint;\n+    do {\n+        value = comm::recv(from_par);\n+        comm::send(to_par, uint::to_str(value, 10u));\n+    } while value != 0u;\n+}\n+\n+~~~~\n+You can see that the function takes two parameters.  The first is a\n+port used to receive messages from the parent, and the second is a\n+channel used to send messages to the parent.  The body itself simply\n+loops, reading from the `from_par` port and then sending its response\n+to the `to_par` channel.  The actual response itself is simply the\n+strified version of the received value, `uint::to_str(value)`.\n+\n+Here is the code for the parent task:\n+~~~~\n+\n+# fn stringifier(from_par: comm::port<uint>,\n+#                to_par: comm::chan<str>) {}\n+fn main() {\n+    let t = task::spawn_connected(stringifier);\n+    comm::send(t.to_child, 22u);\n+    assert comm::recv(t.from_child) == \"22\";\n+    comm::send(t.to_child, 23u);\n+    assert comm::recv(t.from_child) == \"23\";\n+    comm::send(t.to_child, 0u);\n+    assert comm::recv(t.from_child) == \"0\";\n+}\n+~~~~\n+\n+The call to `spawn_connected()` on the first line will instantiate the\n+various ports and channels and startup the child task.  The returned\n+value, `t`, is a record of type `task::connected_task<uint,str>`.  In\n+addition to the task id of the child, this record defines two fields,\n+`from_child` and `to_child`, which contain the port and channel\n+respectively for communicating with the child.  Those fields are used\n+here to send and receive three messages from the child task.\n+\n+## Joining a task\n+\n+The function `spawn_joinable()` is used to spawn a task that can later\n+be joined. This is implemented by having the child task send a message\n+when it has completed (either successfully or by failing). Therefore,\n+`spawn_joinable()` returns a structure containing both the task ID and\n+the port where this message will be sent---this structure type is\n+called `task::joinable_task`. The structure can be passed to\n+`task::join()`, which simply blocks on the port, waiting to receive\n+the message from the child task.\n+\n+## The supervisor relationship\n+\n+By default, failures in Rust propagate upward through the task tree.\n+We say that each task is supervised by its parent, meaning that if the\n+task fails, that failure is propagated to the parent task, which will\n+fail sometime later.  This propagation can be disabled by using the\n+function `task::unsupervise()`, which disables error propagation from\n+the current task to its parent.\n+\n+# Testing\n+\n+The Rust language has a facility for testing built into the language.\n+Tests can be interspersed with other code, and annotated with the\n+`#[test]` attribute.\n+\n+~~~~\n+use std;\n+\n+fn twice(x: int) -> int { x + x }\n+\n+#[test]\n+fn test_twice() {\n+    let i = -100;\n+    while i < 100 {\n+        assert twice(i) == 2 * i;\n+        i += 1;\n+    }\n+}\n+~~~~\n+\n+When you compile the program normally, the `test_twice` function will\n+not be included. To compile and run such tests, compile with the\n+`--test` flag, and then run the result:\n+\n+~~~~\n+## notrust\n+> rustc --test twice.rs\n+> ./twice\n+running 1 tests\n+test test_twice ... ok\n+result: ok. 1 passed; 0 failed; 0 ignored\n+~~~~\n+\n+Or, if we change the file to fail, for example by replacing `x + x`\n+with `x + 1`:\n+\n+~~~~\n+## notrust\n+running 1 tests\n+test test_twice ... FAILED\n+failures:\n+    test_twice\n+result: FAILED. 0 passed; 1 failed; 0 ignored\n+~~~~\n+\n+You can pass a command-line argument to a program compiled with\n+`--test` to run only the tests whose name matches the given string. If\n+we had, for example, test functions `test_twice`, `test_once_1`, and\n+`test_once_2`, running our program with `./twice test_once` would run\n+the latter two, and running it with `./twice test_once_2` would run\n+only the last.\n+\n+To indicate that a test is supposed to fail instead of pass, you can\n+give it a `#[should_fail]` attribute.\n+\n+~~~~\n+use std;\n+\n+fn divide(a: float, b: float) -> float {\n+    if b == 0f { fail; }\n+    a / b\n+}\n+\n+#[test]\n+#[should_fail]\n+fn divide_by_zero() { divide(1f, 0f); }\n+~~~~\n+\n+To disable a test completely, add an `#[ignore]` attribute. Running a\n+test runner (the program compiled with `--test`) with an `--ignored`\n+command-line flag will cause it to also run the tests labelled as\n+ignored.\n+\n+A program compiled as a test runner will have the configuration flag\n+`test` defined, so that you can add code that won't be included in a\n+normal compile with the `#[cfg(test)]` attribute (see [conditional\n+compilation](syntax.md#conditional))."}, {"sha": "d02e9236c576ecadb8c20cf02a8035cb961db3e2", "filename": "doc/tutorial/args.md", "status": "removed", "additions": 0, "deletions": 139, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Fargs.md", "raw_url": "https://github.com/rust-lang/rust/raw/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Fargs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fargs.md?ref=d699db699a07d5bb80d5d08508540b0aba6e1026", "patch": "@@ -1,139 +0,0 @@\n-# Argument passing\n-\n-Rust datatypes are not trivial to copy (the way, for example,\n-JavaScript values can be copied by simply taking one or two machine\n-words and plunking them somewhere else). Shared boxes require\n-reference count updates, big records, tags, or unique pointers require\n-an arbitrary amount of data to be copied (plus updating the reference\n-counts of shared boxes hanging off them).\n-\n-For this reason, the default calling convention for Rust functions\n-leaves ownership of the arguments with the caller. The caller\n-guarantees that the arguments will outlive the call, the callee merely\n-gets access to them.\n-\n-## Safe references\n-\n-There is one catch with this approach: sometimes the compiler can\n-*not* statically guarantee that the argument value at the caller side\n-will survive to the end of the call. Another argument might indirectly\n-refer to it and be used to overwrite it, or a closure might assign a\n-new value to it.\n-\n-Fortunately, Rust tasks are single-threaded worlds, which share no\n-data with other tasks, and that most data is immutable. This allows\n-most argument-passing situations to be proved safe without further\n-difficulty.\n-\n-Take the following program:\n-\n-    # fn get_really_big_record() -> int { 1 }\n-    # fn myfunc(a: int) {}\n-    fn main() {\n-        let x = get_really_big_record();\n-        myfunc(x);\n-    }\n-\n-Here we know for sure that no one else has access to the `x` variable\n-in `main`, so we're good. But the call could also look like this:\n-\n-    # fn myfunc(a: int, b: block()) {}\n-    # fn get_another_record() -> int { 1 }\n-    # let x = 1;\n-    myfunc(x, {|| x = get_another_record(); });\n-\n-Now, if `myfunc` first calls its second argument and then accesses its\n-first argument, it will see a different value from the one that was\n-passed to it.\n-\n-In such a case, the compiler will insert an implicit copy of `x`,\n-*except* if `x` contains something mutable, in which case a copy would\n-result in code that behaves differently. If copying `x` might be\n-expensive (for example, if it holds a vector), the compiler will emit\n-a warning.\n-\n-There are even more tricky cases, in which the Rust compiler is forced\n-to pessimistically assume a value will get mutated, even though it is\n-not sure.\n-\n-    fn for_each(v: [mutable @int], iter: block(@int)) {\n-       for elt in v { iter(elt); }\n-    }\n-\n-For all this function knows, calling `iter` (which is a closure that\n-might have access to the vector that's passed as `v`) could cause the\n-elements in the vector to be mutated, with the effect that it can not\n-guarantee that the boxes will live for the duration of the call. So it\n-has to copy them. In this case, this will happen implicitly (bumping a\n-reference count is considered cheap enough to not warn about it).\n-\n-## The copy operator\n-\n-If the `for_each` function given above were to take a vector of\n-`{mutable a: int}` instead of `@int`, it would not be able to\n-implicitly copy, since if the `iter` function changes a copy of a\n-mutable record, the changes won't be visible in the record itself. If\n-we *do* want to allow copies there, we have to explicitly allow it\n-with the `copy` operator:\n-\n-    type mutrec = {mutable x: int};\n-    fn for_each(v: [mutable mutrec], iter: block(mutrec)) {\n-       for elt in v { iter(copy elt); }\n-    }\n-\n-Adding a `copy` operator is also the way to muffle warnings about\n-implicit copies.\n-\n-## Other uses of safe references\n-\n-Safe references are not only used for argument passing. When you\n-destructure on a value in an `alt` expression, or loop over a vector\n-with `for`, variables bound to the inside of the given data structure\n-will use safe references, not copies. This means such references are\n-very cheap, but you'll occasionally have to copy them to ensure\n-safety.\n-\n-    let my_rec = {a: 4, b: [1, 2, 3]};\n-    alt my_rec {\n-      {a, b} {\n-        log(info, b); // This is okay\n-        my_rec = {a: a + 1, b: b + [a]};\n-        log(info, b); // Here reference b has become invalid\n-      }\n-    }\n-\n-## Argument passing styles\n-\n-The fact that arguments are conceptually passed by safe reference does\n-not mean all arguments are passed by pointer. Composite types like\n-records and tags *are* passed by pointer, but single-word values, like\n-integers and pointers, are simply passed by value. Most of the time,\n-the programmer does not have to worry about this, as the compiler will\n-simply pick the most efficient passing style. There is one exception,\n-which will be described in the section on [generics](generic.html).\n-\n-To explicitly set the passing-style for a parameter, you prefix the\n-argument name with a sigil. There are two special passing styles that\n-are often useful. The first is by-mutable-pointer, written with a\n-single `&`:\n-\n-    fn vec_push(&v: [int], elt: int) {\n-        v += [elt];\n-    }\n-\n-This allows the function to mutate the value of the argument, *in the\n-caller's context*. Clearly, you are only allowed to pass things that\n-can actually be mutated to such a function.\n-\n-Then there is the by-copy style, written `+`. This indicates that the\n-function wants to take ownership of the argument value. If the caller\n-does not use the argument after the call, it will be 'given' to the\n-callee. Otherwise a copy will be made. This mode is mostly used for\n-functions that construct data structures. The argument will end up\n-being owned by the data structure, so if that can be done without a\n-copy, that's a win.\n-\n-    type person = {name: str, address: str};\n-    fn make_person(+name: str, +address: str) -> person {\n-        ret {name: name, address: address};\n-    }"}, {"sha": "49e3e0a7b860a411f0b91607d45352b9bce588c8", "filename": "doc/tutorial/build.js", "status": "removed", "additions": 0, "deletions": 109, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Fbuild.js", "raw_url": "https://github.com/rust-lang/rust/raw/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Fbuild.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fbuild.js?ref=d699db699a07d5bb80d5d08508540b0aba6e1026", "patch": "@@ -1,109 +0,0 @@\n-var fs = require(\"fs\"), md = require(\"./lib/markdown\");\n-CodeMirror = require(\"./lib/codemirror-node\");\n-require(\"./lib/codemirror-rust\");\n-\n-md.Markdown.dialects.Maruku.block.code = function code(block, next) {\n-  if (block.match(/^    /)) {\n-    var text = String(block);\n-    while (next.length && next[0].match(/^    /)) text += \"\\n\" + String(next.shift());\n-    var leaveAlone, accum = [], curstr = \"\", curstyle = null;\n-    text = text.split(\"\\n\").map(function(line) {\n-      line = line.slice(4);\n-      if (line == \"## notrust\") leaveAlone = true;\n-      return line;\n-    }).filter(function(x) { return !/^##? /.test(x); }).join(\"\\n\");\n-    if (leaveAlone) return [[\"pre\", {}, text]];\n-    function add(str, style) {\n-      if (style != curstyle) {\n-        if (curstyle) accum.push([\"span\", {\"class\": \"cm-\" + curstyle}, curstr]);\n-        else if (curstr) accum.push(curstr);\n-        curstr = str; curstyle = style;\n-      } else curstr += str;\n-    }\n-    CodeMirror.runMode(text, \"rust\", add);\n-    add(\"\", \"bogus\"); // Flush pending string.\n-    return [[\"pre\", {\"class\": \"cm-s-default\"}].concat(accum)];\n-  }\n-};    \n-\n-function markdown(str) { return md.toHTML(str, \"Maruku\"); }\n-\n-function fileDates(file, c) {\n-  function takeTime(str) {\n-    return Number(str.match(/^(\\S+)\\s/)[1]) * 1000;\n-  }\n-  require(\"child_process\").exec(\"git rev-list --timestamp HEAD -- \" + file + \".md\", function(err, stdout) {\n-    if (err != null) { console.log(\"Failed to run git rev-list\"); return; }\n-    var history = stdout.split(\"\\n\");\n-    if (history.length && history[history.length-1] == \"\") history.pop();\n-    var created = history.length ? takeTime(history[history.length-1]) : Date.now();\n-    var modified = created;\n-    if (history.length > 1) modified = takeTime(history[0]);\n-    c(created, modified);\n-  });\n-}\n-\n-function head(title) {\n-  return \"<html><head><link rel='stylesheet' href='style.css' type='text/css'>\" +\n-    \"<link rel='stylesheet' href='default.css' type='text/css'>\" +\n-    \"<meta http-equiv='Content-Type' content='text/html; charset=utf-8'><title>\" +\n-    title + \"</title></head><body>\\n\";\n-}\n-\n-function foot(created, modified) {\n-  var r = \"<p class='head'>\"\n-  var crStr = formatTime(created), modStr = formatTime(modified);\n-  if (created) r += \"Created \" + crStr;\n-  if (crStr != modStr)\n-    r += (created ? \", l\" : \"L\") + \"ast modified on \" + modStr;\n-  return r + \"</p>\";\n-}\n-\n-function formatTime(tm) {\n-  var d = new Date(tm);\n-  var months = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\",\n-                \"September\", \"October\", \"November\", \"December\"];\n-  return months[d.getMonth()] + \" \" + d.getDate() + \", \" + d.getFullYear();\n-}\n-\n-var files = fs.readFileSync(\"order\", \"utf8\").split(\"\\n\").filter(function(x) { return x; });\n-var max_modified = 0;\n-var sections = [];\n-\n-// Querying git for modified dates has to be done async in node it seems...\n-var queried = 0;\n-for (var i = 0; i < files.length; ++i)\n-  (function(i) { // Make lexical i stable\n-    fileDates(files[i], function(ctime, mtime) {\n-      sections[i] = {\n-        text: fs.readFileSync(files[i] + \".md\", \"utf8\"),\n-        ctime: ctime, mtime: mtime,\n-        name: files[i],\n-      };\n-      max_modified = Math.max(mtime, max_modified);\n-      if (++queried == files.length) buildTutorial();\n-    });\n-  })(i);\n-\n-function htmlName(i) { return sections[i].name + \".html\"; }\n-\n-function buildTutorial() {\n-  var index = head(\"Rust language tutorial\") + \"<div id='content'>\" +\n-    markdown(fs.readFileSync(\"index.md\", \"utf8\")) + \"<ol>\";\n-  for (var i = 0; i < sections.length; ++i) {\n-    var s = sections[i];\n-    var html = htmlName(i);\n-    var title = s.text.match(/^# (.*)\\n/)[1];\n-    index += '<li><a href=\"' + html + '\">' + title + \"</a></li>\";\n-    \n-    var nav = '<p class=\"head\">Section ' + (i + 1) + ' of the Rust language tutorial.<br>';\n-    if (i > 0) nav += '<a href=\"' + htmlName(i-1) + '\">\u00ab Section ' + i + \"</a> | \";\n-    nav += '<a href=\"index.html\">Index</a>';\n-    if (i + 1 < sections.length) nav += ' | <a href=\"' + htmlName(i+1) + '\">Section ' + (i + 2) + \" \u00bb</a>\";\n-    nav += \"</p>\";\n-    fs.writeFileSync(\"web/\" + html, head(title) + nav + '<div id=\"content\">' + markdown(s.text) + \"</div>\" +\n-                     nav + foot(s.ctime, s.mtime) + \"</body></html>\");\n-  }\n-  index += \"</ol></div>\" + foot(null, max_modified) + \"</body></html>\";\n-  fs.writeFileSync(\"web/index.html\", index);\n-}"}, {"sha": "e13d976aa794838464097a1d39e21074b54cda90", "filename": "doc/tutorial/control.md", "status": "removed", "additions": 0, "deletions": 200, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Fcontrol.md", "raw_url": "https://github.com/rust-lang/rust/raw/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Fcontrol.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fcontrol.md?ref=d699db699a07d5bb80d5d08508540b0aba6e1026", "patch": "@@ -1,200 +0,0 @@\n-# Control structures\n-\n-## Conditionals\n-\n-We've seen `if` pass by a few times already. To recap, braces are\n-compulsory, an optional `else` clause can be appended, and multiple\n-`if`/`else` constructs can be chained together:\n-\n-    if false {\n-        std::io::println(\"that's odd\");\n-    } else if true {\n-        std::io::println(\"right\");\n-    } else {\n-        std::io::println(\"neither true nor false\");\n-    }\n-\n-The condition given to an `if` construct *must* be of type boolean (no\n-implicit conversion happens). If the arms return a value, this value\n-must be of the same type for every arm in which control reaches the\n-end of the block:\n-\n-    fn signum(x: int) -> int {\n-        if x < 0 { -1 }\n-        else if x > 0 { 1 }\n-        else { ret 0; }\n-    }\n-\n-The `ret` (return) and its semicolon could have been left out without\n-changing the meaning of this function, but it illustrates that you\n-will not get a type error in this case, although the last arm doesn't\n-have type `int`, because control doesn't reach the end of that arm\n-(`ret` is jumping out of the function).\n-\n-## Pattern matching\n-\n-Rust's `alt` construct is a generalized, cleaned-up version of C's\n-`switch` construct. You provide it with a value and a number of arms,\n-each labelled with a pattern, and it will execute the arm that matches\n-the value.\n-\n-    # let my_number = 1;\n-    alt my_number {\n-      0       { std::io::println(\"zero\"); }\n-      1 | 2   { std::io::println(\"one or two\"); }\n-      3 to 10 { std::io::println(\"three to ten\"); }\n-      _       { std::io::println(\"something else\"); }\n-    }\n-\n-There is no 'falling through' between arms, as in C\u2014only one arm is\n-executed, and it doesn't have to explicitly `break` out of the\n-construct when it is finished.\n-\n-The part to the left of each arm is called the pattern. Literals are\n-valid patterns, and will match only their own value. The pipe operator\n-(`|`) can be used to assign multiple patterns to a single arm. Ranges\n-of numeric literal patterns can be expressed with `to`. The underscore\n-(`_`) is a wildcard pattern that matches everything.\n-\n-If the arm with the wildcard pattern was left off in the above\n-example, running it on a number greater than ten (or negative) would\n-cause a run-time failure. When no arm matches, `alt` constructs do not\n-silently fall through\u2014they blow up instead.\n-\n-A powerful application of pattern matching is *destructuring*, where\n-you use the matching to get at the contents of data types. Remember\n-that `(float, float)` is a tuple of two floats:\n-\n-    fn angle(vec: (float, float)) -> float {\n-        alt vec {\n-          (0f, y) if y < 0f { 1.5 * float::consts::pi }\n-          (0f, y) { 0.5 * float::consts::pi }\n-          (x, y) { float::atan(y / x) }\n-        }\n-    }\n-\n-A variable name in a pattern matches everything, *and* binds that name\n-to the value of the matched thing inside of the arm block. Thus, `(0f,\n-y)` matches any tuple whose first element is zero, and binds `y` to\n-the second element. `(x, y)` matches any tuple, and binds both\n-elements to a variable.\n-\n-Any `alt` arm can have a guard clause (written `if EXPR`), which is\n-an expression of type `bool` that determines, after the pattern is\n-found to match, whether the arm is taken or not. The variables bound\n-by the pattern are available in this guard expression.\n-\n-## Destructuring let\n-\n-To a limited extent, it is possible to use destructuring patterns when\n-declaring a variable with `let`. For example, you can say this to\n-extract the fields from a tuple:\n-\n-    # fn get_tuple_of_two_ints() -> (int, int) { (1, 1) }\n-    let (a, b) = get_tuple_of_two_ints();\n-\n-This will introduce two new variables, `a` and `b`, bound to the\n-content of the tuple.\n-\n-You may only use irrevocable patterns\u2014patterns that can never fail to\n-match\u2014in let bindings, though. Things like literals, which only match\n-a specific value, are not allowed.\n-\n-## Loops\n-\n-`while` produces a loop that runs as long as its given condition\n-(which must have type `bool`) evaluates to true. Inside a loop, the\n-keyword `break` can be used to abort the loop, and `cont` can be used\n-to abort the current iteration and continue with the next.\n-\n-    let x = 5;\n-    while true {\n-        x += x - 3;\n-        if x % 5 == 0 { break; }\n-        std::io::println(int::str(x));\n-    }\n-\n-This code prints out a weird sequence of numbers and stops as soon as\n-it finds one that can be divided by five.\n-\n-There's also `while`'s ugly cousin, `do`/`while`, which does not check\n-its condition on the first iteration, using traditional syntax:\n-\n-    # fn eat_cake() {}\n-    # fn any_cake_left() -> bool { false }\n-    do {\n-        eat_cake();\n-    } while any_cake_left();\n-\n-When iterating over a vector, use `for` instead.\n-\n-    for elt in [\"red\", \"green\", \"blue\"] {\n-        std::io::println(elt);\n-    }\n-\n-This will go over each element in the given vector (a three-element\n-vector of strings, in this case), and repeatedly execute the body with\n-`elt` bound to the current element. You may add an optional type\n-declaration (`elt: str`) for the iteration variable if you want.\n-\n-For more involved iteration, such as going over the elements of a hash\n-table, Rust uses higher-order functions. We'll come back to those in a\n-moment.\n-\n-## Failure\n-\n-The `fail` keyword causes the current [task][tasks] to fail. You use\n-it to indicate unexpected failure, much like you'd use `exit(1)` in a\n-C program, except that in Rust, it is possible for other tasks to\n-handle the failure, allowing the program to continue running.\n-\n-`fail` takes an optional argument, which must have type `str`. Trying\n-to access a vector out of bounds, or running a pattern match with no\n-matching clauses, both result in the equivalent of a `fail`.\n-\n-[tasks]: task.html\n-\n-## Logging\n-\n-Rust has a built-in logging mechanism, using the `log` statement.\n-Logging is polymorphic\u2014any type of value can be logged, and the\n-runtime will do its best to output a textual representation of the\n-value.\n-\n-    log(warn, \"hi\");\n-    log(error, (1, [2.5, -1.8]));\n-\n-The first argument is the log level (levels `info`, `warn`, and\n-`error` are predefined), and the second is the value to log. By\n-default, you *will not* see the output of that first log statement,\n-which has `warn` level. The environment variable `RUST_LOG` controls\n-which log level is used. It can contain a comma-separated list of\n-paths for modules that should be logged. For example, running `rustc`\n-with `RUST_LOG=rustc::front::attr` will turn on logging in its\n-attribute parser. If you compile a program named `foo.rs`, its\n-top-level module will be called `foo`, and you can set `RUST_LOG` to\n-`foo` to enable `warn` and `info` logging for the module.\n-\n-Turned-off `log` statements impose minimal overhead on the code that\n-contains them, so except in code that needs to be really, really fast,\n-you should feel free to scatter around debug logging statements, and\n-leave them in.\n-\n-Three macros that combine text-formatting (as with `#fmt`) and logging\n-are available. These take a string and any number of format arguments,\n-and will log the formatted string:\n-\n-    # fn get_error_string() -> str { \"boo\" }\n-    #warn(\"only %d seconds remaining\", 10);\n-    #error(\"fatal: %s\", get_error_string());\n-\n-## Assertions\n-\n-The keyword `assert`, followed by an expression with boolean type,\n-will check that the given expression results in `true`, and cause a\n-failure otherwise. It is typically used to double-check things that\n-*should* hold at a certain point in a program.\n-\n-    let x = 100;\n-    while (x > 10) { x -= 10; }\n-    assert x == 10;"}, {"sha": "79a0cb85ac5ab8e7e261901d2e8801903c94b370", "filename": "doc/tutorial/data.md", "status": "removed", "additions": 0, "deletions": 334, "changes": 334, "blob_url": "https://github.com/rust-lang/rust/blob/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Fdata.md", "raw_url": "https://github.com/rust-lang/rust/raw/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Fdata.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fdata.md?ref=d699db699a07d5bb80d5d08508540b0aba6e1026", "patch": "@@ -1,334 +0,0 @@\n-# Datatypes\n-\n-Rust datatypes are, by default, immutable. The core datatypes of Rust\n-are structural records and 'enums' (tagged unions, algebraic data\n-types).\n-\n-    type point = {x: float, y: float};\n-    enum shape {\n-        circle(point, float);\n-        rectangle(point, point);\n-    }\n-    let my_shape = circle({x: 0.0, y: 0.0}, 10.0);\n-\n-## Records\n-\n-Rust record types are written `{field1: TYPE, field2: TYPE [, ...]}`,\n-and record literals are written in the same way, but with expressions\n-instead of types. They are quite similar to C structs, and even laid\n-out the same way in memory (so you can read from a Rust struct in C,\n-and vice-versa).\n-\n-The dot operator is used to access record fields (`mypoint.x`).\n-\n-Fields that you want to mutate must be explicitly marked as such. For\n-example...\n-\n-    type stack = {content: [int], mutable head: uint};\n-\n-With such a type, you can do `mystack.head += 1u`. If `mutable` were\n-omitted from the type, such an assignment would result in a type\n-error.\n-\n-To 'update' an immutable record, you use functional record update\n-syntax, by ending a record literal with the keyword `with`:\n-\n-    let oldpoint = {x: 10f, y: 20f};\n-    let newpoint = {x: 0f with oldpoint};\n-    assert newpoint == {x: 0f, y: 20f};\n-\n-This will create a new struct, copying all the fields from `oldpoint`\n-into it, except for the ones that are explicitly set in the literal.\n-\n-Rust record types are *structural*. This means that `{x: float, y:\n-float}` is not just a way to define a new type, but is the actual name\n-of the type. Record types can be used without first defining them. If\n-module A defines `type point = {x: float, y: float}`, and module B,\n-without knowing anything about A, defines a function that returns an\n-`{x: float, y: float}`, you can use that return value as a `point` in\n-module A. (Remember that `type` defines an additional name for a type,\n-not an actual new type.)\n-\n-## Record patterns\n-\n-Records can be destructured on in `alt` patterns. The basic syntax is\n-`{fieldname: pattern, ...}`, but the pattern for a field can be\n-omitted as a shorthand for simply binding the variable with the same\n-name as the field.\n-\n-    # let mypoint = {x: 0f, y: 0f};\n-    alt mypoint {\n-        {x: 0f, y: y_name} { /* Provide sub-patterns for fields */ }\n-        {x, y}             { /* Simply bind the fields */ }\n-    }\n-\n-The field names of a record do not have to appear in a pattern in the\n-same order they appear in the type. When you are not interested in all\n-the fields of a record, a record pattern may end with `, _` (as in\n-`{field1, _}`) to indicate that you're ignoring all other fields.\n-\n-## Enums\n-\n-Enums are datatypes that have several different representations. For\n-example, the type shown earlier:\n-\n-    # type point = {x: float, y: float};\n-    enum shape {\n-        circle(point, float);\n-        rectangle(point, point);\n-    }\n-\n-A value of this type is either a circle\u00b8 in which case it contains a\n-point record and a float, or a rectangle, in which case it contains\n-two point records. The run-time representation of such a value\n-includes an identifier of the actual form that it holds, much like the\n-'tagged union' pattern in C, but with better ergonomics.\n-\n-The above declaration will define a type `shape` that can be used to\n-refer to such shapes, and two functions, `circle` and `rectangle`,\n-which can be used to construct values of the type (taking arguments of\n-the specified types). So `circle({x: 0f, y: 0f}, 10f)` is the way to\n-create a new circle.\n-\n-Enum variants do not have to have parameters. This, for example, is\n-equivalent to a C enum:\n-\n-    enum direction {\n-        north;\n-        east;\n-        south;\n-        west;\n-    }\n-\n-This will define `north`, `east`, `south`, and `west` as constants,\n-all of which have type `direction`.\n-\n-When the enum is C like, that is none of the variants have parameters,\n-it is possible to explicitly set the discriminator values to an integer\n-value:\n-\n-    enum color {\n-      red = 0xff0000;\n-      green = 0x00ff00;\n-      blue = 0x0000ff;\n-    }\n-\n-If an explicit discriminator is not specified for a variant, the value\n-defaults to the value of the previous variant plus one.  If the first\n-variant does not have a discriminator, it defaults to 0.  For example,\n-the value of `north` is 0, `east` is 1, etc.\n-\n-When an enum is C-like the `as` cast operator can be used to get the\n-discriminator's value.\n-\n-<a name=\"single_variant_enum\"></a>\n-\n-There is a special case for enums with a single variant. These are\n-used to define new types in such a way that the new name is not just a\n-synonym for an existing type, but its own distinct type. If you say:\n-\n-    enum gizmo_id = int;\n-\n-That is a shorthand for this:\n-\n-    enum gizmo_id { gizmo_id(int); }\n-\n-Enum types like this can have their content extracted with the\n-dereference (`*`) unary operator:\n-\n-    # enum gizmo_id = int;\n-    let my_gizmo_id = gizmo_id(10);\n-    let id_int: int = *my_gizmo_id;\n-\n-## Enum patterns\n-\n-For enum types with multiple variants, destructuring is the only way to\n-get at their contents. All variant constructors can be used as\n-patterns, as in this definition of `area`:\n-\n-    # type point = {x: float, y: float};\n-    # enum shape { circle(point, float); rectangle(point, point); }\n-    fn area(sh: shape) -> float {\n-        alt sh {\n-            circle(_, size) { float::consts::pi * size * size }\n-            rectangle({x, y}, {x: x2, y: y2}) { (x2 - x) * (y2 - y) }\n-        }\n-    }\n-\n-Another example:\n-\n-    # type point = {x: float, y: float};\n-    # enum direction { north; east; south; west; }\n-    fn point_from_direction(dir: direction) -> point {\n-        alt dir {\n-            north { {x:  0f, y:  1f} }\n-            east  { {x:  1f, y:  0f} }\n-            south { {x:  0f, y: -1f} }\n-            west  { {x: -1f, y:  0f} }\n-        }\n-    }\n-\n-## Tuples\n-\n-Tuples in Rust behave exactly like records, except that their fields\n-do not have names (and can thus not be accessed with dot notation).\n-Tuples can have any arity except for 0 or 1 (though you may see nil,\n-`()`, as the empty tuple if you like).\n-\n-    let mytup: (int, int, float) = (10, 20, 30.0);\n-    alt mytup {\n-      (a, b, c) { log(info, a + b + (c as int)); }\n-    }\n-\n-## Pointers\n-\n-In contrast to a lot of modern languages, record and enum types in\n-Rust are not represented as pointers to allocated memory. They are,\n-like in C and C++, represented directly. This means that if you `let x\n-= {x: 1f, y: 1f};`, you are creating a record on the stack. If you\n-then copy it into a data structure, the whole record is copied, not\n-just a pointer.\n-\n-For small records like `point`, this is usually more efficient than\n-allocating memory and going through a pointer. But for big records, or\n-records with mutable fields, it can be useful to have a single copy on\n-the heap, and refer to that through a pointer.\n-\n-Rust supports several types of pointers. The simplest is the unsafe\n-pointer, written `*TYPE`, which is a completely unchecked pointer\n-type only used in unsafe code (and thus, in typical Rust code, very\n-rarely). The safe pointer types are `@TYPE` for shared,\n-reference-counted boxes, and `~TYPE`, for uniquely-owned pointers.\n-\n-All pointer types can be dereferenced with the `*` unary operator.\n-\n-### Shared boxes\n-\n-<a name=\"shared-box\"></a>\n-\n-Shared boxes are pointers to heap-allocated, reference counted memory.\n-A cycle collector ensures that circular references do not result in\n-memory leaks.\n-\n-Creating a shared box is done by simply applying the unary `@`\n-operator to an expression. The result of the expression will be boxed,\n-resulting in a box of the right type. For example:\n-\n-    let x = @10; // New box, refcount of 1\n-    let y = x; // Copy the pointer, increase refcount\n-    // When x and y go out of scope, refcount goes to 0, box is freed\n-\n-NOTE: We may in the future switch to garbage collection, rather than\n-reference counting, for shared boxes.\n-\n-Shared boxes never cross task boundaries.\n-\n-### Unique boxes\n-\n-<a name=\"unique-box\"></a>\n-\n-In contrast to shared boxes, unique boxes are not reference counted.\n-Instead, it is statically guaranteed that only a single owner of the\n-box exists at any time.\n-\n-    let x = ~10;\n-    let y <- x;\n-\n-This is where the 'move' (`<-`) operator comes in. It is similar to\n-`=`, but it de-initializes its source. Thus, the unique box can move\n-from `x` to `y`, without violating the constraint that it only has a\n-single owner (if you used assignment instead of the move operator, the\n-box would, in principle, be copied).\n-\n-Unique boxes, when they do not contain any shared boxes, can be sent\n-to other tasks. The sending task will give up ownership of the box,\n-and won't be able to access it afterwards. The receiving task will\n-become the sole owner of the box.\n-\n-### Mutability\n-\n-All pointer types have a mutable variant, written `@mutable TYPE` or\n-`~mutable TYPE`. Given such a pointer, you can write to its contents\n-by combining the dereference operator with a mutating action.\n-\n-    fn increase_contents(pt: @mutable int) {\n-        *pt += 1;\n-    }\n-\n-## Vectors\n-\n-Rust vectors are always heap-allocated and unique. A value of type\n-`[TYPE]` is represented by a pointer to a section of heap memory\n-containing any number of `TYPE` values.\n-\n-NOTE: This uniqueness is turning out to be quite awkward in practice,\n-and might change in the future.\n-\n-Vector literals are enclosed in square brackets. Dereferencing is done\n-with square brackets (zero-based):\n-\n-    let myvec = [true, false, true, false];\n-    if myvec[1] { std::io::println(\"boom\"); }\n-\n-By default, vectors are immutable\u2014you can not replace their elements.\n-The type written as `[mutable TYPE]` is a vector with mutable\n-elements. Mutable vector literals are written `[mutable]` (empty) or\n-`[mutable 1, 2, 3]` (with elements).\n-\n-The `+` operator means concatenation when applied to vector types.\n-Growing a vector in Rust is not as inefficient as it looks :\n-\n-    let myvec = [], i = 0;\n-    while i < 100 {\n-        myvec += [i];\n-        i += 1;\n-    }\n-\n-Because a vector is unique, replacing it with a longer one (which is\n-what `+= [i]` does) is indistinguishable from appending to it\n-in-place. Vector representations are optimized to grow\n-logarithmically, so the above code generates about the same amount of\n-copying and reallocation as `push` implementations in most other\n-languages.\n-\n-## Strings\n-\n-The `str` type in Rust is represented exactly the same way as a vector\n-of bytes (`[u8]`), except that it is guaranteed to have a trailing\n-null byte (for interoperability with C APIs).\n-\n-This sequence of bytes is interpreted as an UTF-8 encoded sequence of\n-characters. This has the advantage that UTF-8 encoded I/O (which\n-should really be the default for modern systems) is very fast, and\n-that strings have, for most intents and purposes, a nicely compact\n-representation. It has the disadvantage that you only get\n-constant-time access by byte, not by character.\n-\n-A lot of algorithms don't need constant-time indexed access (they\n-iterate over all characters, which `str::chars` helps with), and\n-for those that do, many don't need actual characters, and can operate\n-on bytes. For algorithms that do really need to index by character,\n-there's the option to convert your string to a character vector (using\n-`str::to_chars`).\n-\n-Like vectors, strings are always unique. You can wrap them in a shared\n-box to share them. Unlike vectors, there is no mutable variant of\n-strings. They are always immutable.\n-\n-## Resources\n-\n-Resources are data types that have a destructor associated with them.\n-\n-    # fn close_file_desc(x: int) {}\n-    resource file_desc(fd: int) {\n-        close_file_desc(fd);\n-    }\n-\n-This defines a type `file_desc` and a constructor of the same name,\n-which takes an integer. Values of such a type can not be copied, and\n-when they are destroyed (by going out of scope, or, when boxed, when\n-their box is cleaned up), their body runs. In the example above, this\n-would cause the given file descriptor to be closed.\n-\n-NOTE: We're considering alternative approaches for data types with\n-destructors. Resources might go away in the future."}, {"sha": "e84619675455e396cfbe5b77d26ca4076165c01f", "filename": "doc/tutorial/extract.js", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Fextract.js", "raw_url": "https://github.com/rust-lang/rust/raw/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Fextract.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fextract.js?ref=d699db699a07d5bb80d5d08508540b0aba6e1026", "patch": "@@ -1,42 +0,0 @@\n-var fs = require(\"fs\"), md = require(\"./lib/markdown\");\n-\n-// Runs markdown.js over the tutorial, to find the code blocks in it.\n-// Uses the #-markers in those code blocks, along with some vague\n-// heuristics, to turn them into compilable files. Outputs these files\n-// to fragments/.\n-//\n-// '##ignore' means don't test this block\n-// '##notrust' means the block isn't rust code\n-//     (used by build.js to not highlight it)\n-// '# code' means insert the given code to complete the fragment\n-//     (build.js strips out such lines)\n-\n-var curFile, curFrag;\n-md.Markdown.dialects.Maruku.block.code = function code(block, next) {\n-  if (block.match(/^    /)) {\n-    var ignore, text = String(block);\n-    while (next.length && next[0].match(/^    /)) text += \"\\n\" + String(next.shift());\n-    text = text.split(\"\\n\").map(function(line) {\n-      line = line.slice(4);\n-      if (line == \"## ignore\" || line == \"## notrust\") { ignore = true; line = \"\"; }\n-      if (/^# /.test(line)) line = line.slice(2);\n-      return line;\n-    }).join(\"\\n\");\n-    if (ignore) return;\n-    if (!/\\bfn main\\b/.test(text)) {\n-      if (/(^|\\n) *(native|use|mod|import|export)\\b/.test(text))\n-        text += \"\\nfn main() {}\\n\";\n-      else text = \"fn main() {\\n\" + text + \"\\n}\\n\";\n-    }\n-    if (!/\\buse std\\b/.test(text)) text = \"use std;\\n\" + text;\n-    fs.writeFileSync(\"fragments/\" + curFile + \"_\" + (++curFrag) + \".rs\", text);\n-  }\n-};\n-\n-fs.readFileSync(\"order\", \"utf8\").split(\"\\n\").filter(id).forEach(handle);\n-\n-function id(x) { return x; }\n-function handle(file) {\n-  curFile = file; curFrag = 0;\n-  md.parse(fs.readFileSync(file + \".md\", \"utf8\"), \"Maruku\");\n-}"}, {"sha": "5b6d72933c96c8cd55eaac5beae8a37a627d84d4", "filename": "doc/tutorial/ffi.md", "status": "removed", "additions": 0, "deletions": 209, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fffi.md?ref=d699db699a07d5bb80d5d08508540b0aba6e1026", "patch": "@@ -1,209 +0,0 @@\n-# Interacting with foreign code\n-\n-One of Rust's aims, as a system programming language, is to\n-interoperate well with C code.\n-\n-We'll start with an example. It's a bit bigger than usual, and\n-contains a number of new concepts. We'll go over it one piece at a\n-time.\n-\n-This is a program that uses OpenSSL's `SHA1` function to compute the\n-hash of its first command-line argument, which it then converts to a\n-hexadecimal string and prints to standard output. If you have the\n-OpenSSL libraries installed, it should 'just work'.\n-\n-    use std;\n-    \n-    native mod crypto {\n-        fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n-    }\n-    \n-    fn as_hex(data: [u8]) -> str {\n-        let acc = \"\";\n-        for byte in data { acc += #fmt(\"%02x\", byte as uint); }\n-        ret acc;\n-    }\n-\n-    fn sha1(data: str) -> str unsafe {\n-        let bytes = str::bytes(data);\n-        let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n-                                vec::len(bytes), ptr::null());\n-        ret as_hex(vec::unsafe::from_buf(hash, 20u));\n-    }\n-    \n-    fn main(args: [str]) {\n-        std::io::println(sha1(args[1]));\n-    }\n-\n-## Native modules\n-\n-Before we can call `SHA1`, we have to declare it. That is what this\n-part of the program is responsible for:\n-\n-    native mod crypto {\n-        fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n-    }\n-\n-A `native` module declaration tells the compiler that the program\n-should be linked with a library by that name, and that the given list\n-of functions are available in that library.\n-\n-In this case, it'll change the name `crypto` to a shared library name\n-in a platform-specific way (`libcrypto.so` on Linux, for example), and\n-link that in. If you want the module to have a different name from the\n-actual library, you can use the `\"link_name\"` attribute, like:\n-\n-    #[link_name = \"crypto\"]\n-    native mod something {\n-        fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n-    }\n-\n-## Native calling conventions\n-\n-Most native C code use the cdecl calling convention, so that is what\n-Rust uses by default when calling native functions. Some native functions,\n-most notably the Windows API, use other calling conventions, so Rust\n-provides a way to to hint to the compiler which is expected by using\n-the `\"abi\"` attribute:\n-\n-    #[cfg(target_os = \"win32\")]\n-    #[abi = \"stdcall\"]\n-    native mod kernel32 {\n-        fn SetEnvironmentVariableA(n: *u8, v: *u8) -> int;\n-    }\n-\n-The `\"abi\"` attribute applies to a native mod (it can not be applied\n-to a single function within a module), and must be either `\"cdecl\"`\n-or `\"stdcall\"`. Other conventions may be defined in the future.\n-\n-## Unsafe pointers\n-\n-The native `SHA1` function is declared to take three arguments, and\n-return a pointer.\n-\n-    # native mod crypto {\n-    fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n-    # }\n-\n-When declaring the argument types to a foreign function, the Rust\n-compiler has no way to check whether your declaration is correct, so\n-you have to be careful. If you get the number or types of the\n-arguments wrong, you're likely to get a segmentation fault. Or,\n-probably even worse, your code will work on one platform, but break on\n-another.\n-\n-In this case, `SHA1` is defined as taking two `unsigned char*`\n-arguments and one `unsigned long`. The rust equivalents are `*u8`\n-unsafe pointers and an `uint` (which, like `unsigned long`, is a\n-machine-word-sized type).\n-\n-Unsafe pointers can be created through various functions in the\n-standard lib, usually with `unsafe` somewhere in their name. You can\n-dereference an unsafe pointer with `*` operator, but use\n-caution\u2014unlike Rust's other pointer types, unsafe pointers are\n-completely unmanaged, so they might point at invalid memory, or be\n-null pointers.\n-\n-## Unsafe blocks\n-\n-The `sha1` function is the most obscure part of the program.\n-\n-    # mod crypto { fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8 { out } }\n-    # fn as_hex(data: [u8]) -> str { \"hi\" }\n-    fn sha1(data: str) -> str unsafe {\n-        let bytes = str::bytes(data);\n-        let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n-                                vec::len(bytes), ptr::null());\n-        ret as_hex(vec::unsafe::from_buf(hash, 20u));\n-    }\n-\n-Firstly, what does the `unsafe` keyword at the top of the function\n-mean? `unsafe` is a block modifier\u2014it declares the block following it\n-to be known to be unsafe.\n-\n-Some operations, like dereferencing unsafe pointers or calling\n-functions that have been marked unsafe, are only allowed inside unsafe\n-blocks. With the `unsafe` keyword, you're telling the compiler 'I know\n-what I'm doing'. The main motivation for such an annotation is that\n-when you have a memory error (and you will, if you're using unsafe\n-constructs), you have some idea where to look\u2014it will most likely be\n-caused by some unsafe code.\n-\n-Unsafe blocks isolate unsafety. Unsafe functions, on the other hand,\n-advertise it to the world. An unsafe function is written like this:\n-\n-    unsafe fn kaboom() { \"I'm harmless!\"; }\n-\n-This function can only be called from an unsafe block or another\n-unsafe function.\n-\n-## Pointer fiddling\n-\n-The standard library defines a number of helper functions for dealing\n-with unsafe data, casting between types, and generally subverting\n-Rust's safety mechanisms.\n-\n-Let's look at our `sha1` function again.\n-\n-    # mod crypto { fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8 { out } }\n-    # fn as_hex(data: [u8]) -> str { \"hi\" }\n-    # fn x(data: str) -> str unsafe {\n-    let bytes = str::bytes(data);\n-    let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n-                            vec::len(bytes), ptr::null());\n-    ret as_hex(vec::unsafe::from_buf(hash, 20u));\n-    # }\n-\n-The `str::bytes` function is perfectly safe, it converts a string to\n-an `[u8]`. This byte array is then fed to `vec::unsafe::to_ptr`, which\n-returns an unsafe pointer to its contents.\n-\n-This pointer will become invalid as soon as the vector it points into\n-is cleaned up, so you should be very careful how you use it. In this\n-case, the local variable `bytes` outlives the pointer, so we're good.\n-\n-Passing a null pointer as third argument to `SHA1` causes it to use a\n-static buffer, and thus save us the effort of allocating memory\n-ourselves. `ptr::null` is a generic function that will return an\n-unsafe null pointer of the correct type (Rust generics are awesome\n-like that\u2014they can take the right form depending on the type that they\n-are expected to return).\n-\n-Finally, `vec::unsafe::from_buf` builds up a new `[u8]` from the\n-unsafe pointer that was returned by `SHA1`. SHA1 digests are always\n-twenty bytes long, so we can pass `20u` for the length of the new\n-vector.\n-\n-## Passing structures\n-\n-C functions often take pointers to structs as arguments. Since Rust\n-records are binary-compatible with C structs, Rust programs can call\n-such functions directly.\n-\n-This program uses the Posix function `gettimeofday` to get a\n-microsecond-resolution timer.\n-\n-    use std;\n-    type timeval = {mutable tv_sec: u32,\n-                    mutable tv_usec: u32};\n-    #[nolink]\n-    native mod libc {\n-        fn gettimeofday(tv: *timeval, tz: *()) -> i32;\n-    }\n-    fn unix_time_in_microseconds() -> u64 unsafe {\n-        let x = {mutable tv_sec: 0u32, mutable tv_usec: 0u32};\n-        libc::gettimeofday(ptr::addr_of(x), ptr::null());\n-        ret (x.tv_sec as u64) * 1000_000_u64 + (x.tv_usec as u64);\n-    }\n-\n-The `#[nolink]` attribute indicates that there's no native library to link\n-in. The standard C library is already linked with Rust programs.\n-\n-A `timeval`, in C, is a struct with two 32-bit integers. Thus, we\n-define a record type with the same contents, and declare\n-`gettimeofday` to take a pointer to such a record.\n-\n-The second argument to `gettimeofday` (the time zone) is not used by\n-this program, so it simply declares it to be a pointer to the nil\n-type. Since null pointer look the same, no matter which type they are\n-supposed to point at, this is safe."}, {"sha": "08744a68dd8c45001740f5257b10ab49b69d45fa", "filename": "doc/tutorial/func.md", "status": "removed", "additions": 0, "deletions": 174, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Ffunc.md", "raw_url": "https://github.com/rust-lang/rust/raw/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Ffunc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Ffunc.md?ref=d699db699a07d5bb80d5d08508540b0aba6e1026", "patch": "@@ -1,174 +0,0 @@\n-# Functions\n-\n-Functions (like all other static declarations, such as `type`) can be\n-declared both at the top level and inside other functions (or modules,\n-which we'll come back to in moment).\n-\n-The `ret` keyword immediately returns from a function. It is\n-optionally followed by an expression to return. In functions that\n-return `()`, the returned expression can be left off. A function can\n-also return a value by having its top level block produce an\n-expression (by omitting the final semicolon).\n-\n-Some functions (such as the C function `exit`) never return normally.\n-In Rust, these are annotated with the pseudo-return type '`!`':\n-\n-    fn dead_end() -> ! { fail; }\n-\n-This helps the compiler avoid spurious error messages. For example,\n-the following code would be a type error if `dead_end` would be\n-expected to return.\n-\n-    # fn can_go_left() -> bool { true }\n-    # fn can_go_right() -> bool { true }\n-    # enum dir { left; right; }\n-    # fn dead_end() -> ! { fail; }\n-    let dir = if can_go_left() { left }\n-              else if can_go_right() { right }\n-              else { dead_end(); };\n-\n-## Closures\n-\n-Named functions, like those in the previous section, do not close over\n-their environment. Rust also includes support for closures, which are\n-functions that can access variables in the scope in which they are\n-created.\n-\n-There are several forms of closures, each with its own role. The most\n-common type is called a 'block', this is a closure which has full\n-access to its environment.\n-\n-    fn call_block_with_ten(b: block(int)) { b(10); }\n-    \n-    let x = 20;    \n-    call_block_with_ten({|arg|\n-        #info(\"x=%d, arg=%d\", x, arg);\n-    });\n-\n-This defines a function that accepts a block, and then calls it with a\n-simple block that executes a log statement, accessing both its\n-argument and the variable `x` from its environment.\n-\n-Blocks can only be used in a restricted way, because it is not allowed\n-to survive the scope in which it was created. They are allowed to\n-appear in function argument position and in call position, but nowhere\n-else.\n-\n-### Boxed closures\n-\n-When you need to store a closure in a data structure, a block will not\n-do, since the compiler will refuse to let you store it. For this\n-purpose, Rust provides a type of closure that has an arbitrary\n-lifetime, written `fn@` (boxed closure, analogous to the `@` pointer\n-type described in the next section).\n-\n-A boxed closure does not directly access its environment, but merely\n-copies out the values that it closes over into a private data\n-structure. This means that it can not assign to these variables, and\n-will not 'see' updates to them.\n-\n-This code creates a closure that adds a given string to its argument,\n-returns it from a function, and then calls it:\n-\n-    use std;\n-    \n-    fn mk_appender(suffix: str) -> fn@(str) -> str {\n-        let f = fn@(s: str) -> str { s + suffix };\n-        ret f;\n-    }\n-    \n-    fn main() {\n-        let shout = mk_appender(\"!\");\n-        std::io::println(shout(\"hey ho, let's go\"));\n-    }\n-\n-### Closure compatibility\n-\n-A nice property of Rust closures is that you can pass any kind of\n-closure (as long as the arguments and return types match) to functions\n-that expect a `block`. Thus, when writing a higher-order function that\n-wants to do nothing with its function argument beyond calling it, you\n-should almost always specify the type of that argument as `block`, so\n-that callers have the flexibility to pass whatever they want.\n-\n-    fn call_twice(f: block()) { f(); f(); }\n-    call_twice({|| \"I am a block\"; });\n-    call_twice(fn@() { \"I am a boxed closure\"; });\n-    fn bare_function() { \"I am a plain function\"; }\n-    call_twice(bare_function);\n-\n-### Unique closures\n-\n-<a name=\"unique\"></a>\n-\n-Unique closures, written `fn~` in analogy to the `~` pointer type (see\n-next section), hold on to things that can safely be sent between\n-processes. They copy the values they close over, much like boxed\n-closures, but they also 'own' them\u2014meaning no other code can access\n-them. Unique closures mostly exist to for spawning new\n-[tasks](task.html).\n-\n-### Shorthand syntax\n-\n-The compact syntax used for blocks (`{|arg1, arg2| body}`) can also\n-be used to express boxed and unique closures in situations where the\n-closure style can be unambiguously derived from the context. Most\n-notably, when calling a higher-order function you do not have to use\n-the long-hand syntax for the function you're passing, since the\n-compiler can look at the argument type to find out what the parameter\n-types are.\n-\n-As a further simplification, if the final parameter to a function is a\n-closure, the closure need not be placed within parenthesis. You could,\n-for example, write...\n-\n-    let doubled = vec::map([1, 2, 3]) {|x| x*2};\n-\n-`vec::map` is a function in the core library that applies its last\n-argument to every element of a vector, producing a new vector.\n-\n-Even when a closure takes no parameters, you must still write the bars\n-for the parameter list, as in `{|| ...}`.\n-\n-## Binding\n-\n-Partial application is done using the `bind` keyword in Rust.\n-\n-    let daynum = bind vec::position(_, [\"mo\", \"tu\", \"we\", \"do\",\n-                                        \"fr\", \"sa\", \"su\"]);\n-\n-Binding a function produces a boxed closure (`fn@` type) in which some\n-of the arguments to the bound function have already been provided.\n-`daynum` will be a function taking a single string argument, and\n-returning the day of the week that string corresponds to (if any).\n-\n-## Iteration\n-\n-Functions taking blocks provide a good way to define non-trivial\n-iteration constructs. For example, this one iterates over a vector\n-of integers backwards:\n-\n-    fn for_rev(v: [int], act: block(int)) {\n-        let i = vec::len(v);\n-        while (i > 0u) {\n-            i -= 1u;\n-            act(v[i]);\n-        }\n-    }\n-\n-To run such an iteration, you could do this:\n-\n-    # fn for_rev(v: [int], act: block(int)) {}\n-    for_rev([1, 2, 3], {|n| log(error, n); });\n-\n-Making use of the shorthand where a final closure argument can be\n-moved outside of the parentheses permits the following, which\n-looks quite like a normal loop:\n-\n-    # fn for_rev(v: [int], act: block(int)) {}\n-    for_rev([1, 2, 3]) {|n|\n-        log(error, n);\n-    }\n-\n-Note that, because `for_rev()` returns unit type, no semicolon is\n-needed when the final closure is pulled outside of the parentheses."}, {"sha": "2dc8d5684f3e7205d7955487ca1eb3fd6d2445d6", "filename": "doc/tutorial/generic.md", "status": "removed", "additions": 0, "deletions": 146, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Fgeneric.md", "raw_url": "https://github.com/rust-lang/rust/raw/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Fgeneric.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fgeneric.md?ref=d699db699a07d5bb80d5d08508540b0aba6e1026", "patch": "@@ -1,146 +0,0 @@\n-# Generics\n-\n-## Generic functions\n-\n-Throughout this tutorial, I've been defining functions like `for_rev`\n-that act only on integers. It is 2012, and we no longer expect to be\n-defining such functions again and again for every type they apply to.\n-Thus, Rust allows functions and datatypes to have type parameters.\n-\n-    fn for_rev<T>(v: [T], act: block(T)) {\n-        let i = vec::len(v);\n-        while i > 0u {\n-            i -= 1u;\n-            act(v[i]);\n-        }\n-    }\n-    \n-    fn map<T, U>(v: [T], f: block(T) -> U) -> [U] {\n-        let acc = [];\n-        for elt in v { acc += [f(elt)]; }\n-        ret acc;\n-    }\n-\n-When defined in this way, these functions can be applied to any type\n-of vector, as long as the type of the block's argument and the type of\n-the vector's content agree with each other.\n-\n-Inside a parameterized (generic) function, the names of the type\n-parameters (capitalized by convention) stand for opaque types. You\n-can't look inside them, but you can pass them around.\n-\n-## Generic datatypes\n-\n-Generic `type` and `enum` declarations follow the same pattern:\n-\n-    type circular_buf<T> = {start: uint,\n-                            end: uint,\n-                            buf: [mutable T]};\n-    \n-    enum option<T> { some(T); none; }\n-\n-You can then declare a function to take a `circular_buf<u8>` or return\n-an `option<str>`, or even an `option<T>` if the function itself is\n-generic.\n-\n-The `option` type given above exists in the core library as\n-`option::t`, and is the way Rust programs express the thing that in C\n-would be a nullable pointer. The nice part is that you have to\n-explicitly unpack an `option` type, so accidental null pointer\n-dereferences become impossible.\n-\n-## Type-inference and generics\n-\n-Rust's type inferrer works very well with generics, but there are\n-programs that just can't be typed.\n-\n-    let n = option::none;\n-    # n = option::some(1);\n-\n-If you never do anything else with `n`, the compiler will not be able\n-to assign a type to it. (The same goes for `[]`, the empty vector.) If\n-you really want to have such a statement, you'll have to write it like\n-this:\n-\n-    let n2: option::t<int> = option::none;\n-    // or\n-    let n = option::none::<int>;\n-\n-Note that, in a value expression, `<` already has a meaning as a\n-comparison operator, so you'll have to write `::<T>` to explicitly\n-give a type to a name that denotes a generic value. Fortunately, this\n-is rarely necessary.\n-\n-## Polymorphic built-ins\n-\n-There are two built-in operations that, perhaps surprisingly, act on\n-values of any type. It was already mentioned earlier that `log` can\n-take any type of value and output it.\n-\n-More interesting is that Rust also defines an ordering for values of\n-all datatypes, and allows you to meaningfully apply comparison\n-operators (`<`, `>`, `<=`, `>=`, `==`, `!=`) to them. For structural\n-types, the comparison happens left to right, so `\"abc\" < \"bac\"` (but\n-note that `\"bac\" < \"\u00e1c\"`, because the ordering acts on UTF-8 sequences\n-without any sophistication).\n-\n-## Kinds\n-\n-<a name=\"kind\"></a>\n-\n-Perhaps surprisingly, the 'copy' (duplicate) operation is not defined\n-for all Rust types. Resource types (types with destructors) can not be\n-copied, and neither can any type whose copying would require copying a\n-resource (such as records or unique boxes containing a resource).\n-\n-This complicates handling of generic functions. If you have a type\n-parameter `T`, can you copy values of that type? In Rust, you can't,\n-unless you explicitly declare that type parameter to have copyable\n-'kind'. A kind is a type of type.\n-\n-    ## ignore\n-    // This does not compile\n-    fn head_bad<T>(v: [T]) -> T { v[0] }\n-    // This does\n-    fn head<T: copy>(v: [T]) -> T { v[0] }\n-\n-When instantiating a generic function, you can only instantiate it\n-with types that fit its kinds. So you could not apply `head` to a\n-resource type.\n-\n-Rust has three kinds: 'noncopyable', 'copyable', and 'sendable'. By\n-default, type parameters are considered to be noncopyable. You can\n-annotate them with the `copy` keyword to declare them copyable, and\n-with the `send` keyword to make them sendable.\n-\n-Sendable types are a subset of copyable types. They are types that do\n-not contain shared (reference counted) types, which are thus uniquely\n-owned by the function that owns them, and can be sent over channels to\n-other tasks. Most of the generic functions in the core `comm` module\n-take sendable types.\n-\n-## Generic functions and argument-passing\n-\n-The previous section mentioned that arguments are passed by pointer or\n-by value based on their type. There is one situation in which this is\n-difficult. If you try this program:\n-\n-    # fn map(f: block(int) -> int, v: [int]) {}\n-    fn plus1(x: int) -> int { x + 1 }\n-    map(plus1, [1, 2, 3]);\n-\n-You will get an error message about argument passing styles\n-disagreeing. The reason is that generic types are always passed by\n-pointer, so `map` expects a function that takes its argument by\n-pointer. The `plus1` you defined, however, uses the default, efficient\n-way to pass integers, which is by value. To get around this issue, you\n-have to explicitly mark the arguments to a function that you want to\n-pass to a generic higher-order function as being passed by pointer,\n-using the `&&` sigil:\n-\n-    # fn map<T, U>(f: block(T) -> U, v: [T]) {}\n-    fn plus1(&&x: int) -> int { x + 1 }\n-    map(plus1, [1, 2, 3]);\n-\n-NOTE: This is inconvenient, and we are hoping to get rid of this\n-restriction in the future."}, {"sha": "c047cf06da540a41b0ea3e775ca2fd3b27a43d92", "filename": "doc/tutorial/iface.md", "status": "removed", "additions": 0, "deletions": 183, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Fiface.md", "raw_url": "https://github.com/rust-lang/rust/raw/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Fiface.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fiface.md?ref=d699db699a07d5bb80d5d08508540b0aba6e1026", "patch": "@@ -1,183 +0,0 @@\n-# Interfaces\n-\n-Interfaces are Rust's take on value polymorphism\u2014the thing that\n-object-oriented languages tend to solve with methods and inheritance.\n-For example, writing a function that can operate on multiple types of\n-collections.\n-\n-NOTE: This feature is very new, and will need a few extensions to be\n-applicable to more advanced use cases.\n-\n-## Declaration\n-\n-An interface consists of a set of methods. A method is a function that\n-can be applied to a `self` value and a number of arguments, using the\n-dot notation: `self.foo(arg1, arg2)`.\n-\n-For example, we could declare the interface `to_str` for things that\n-can be converted to a string, with a single method of the same name:\n-\n-    iface to_str {\n-        fn to_str() -> str;\n-    }\n-\n-## Implementation\n-\n-To actually implement an interface for a given type, the `impl` form\n-is used. This defines implementations of `to_str` for the `int` and\n-`str` types.\n-\n-    # iface to_str { fn to_str() -> str; }\n-    impl of to_str for int {\n-        fn to_str() -> str { int::to_str(self, 10u) }\n-    }\n-    impl of to_str for str {\n-        fn to_str() -> str { self }\n-    }\n-\n-Given these, we may call `1.to_str()` to get `\"1\"`, or\n-`\"foo\".to_str()` to get `\"foo\"` again. This is basically a form of\n-static overloading\u2014when the Rust compiler sees the `to_str` method\n-call, it looks for an implementation that matches the type with a\n-method that matches the name, and simply calls that.\n-\n-## Scoping\n-\n-Implementations are not globally visible. Resolving a method to an\n-implementation requires that implementation to be in scope. You can\n-import and export implementations using the name of the interface they\n-implement (multiple implementations with the same name can be in scope\n-without problems). Or you can give them an explicit name if you\n-prefer, using this syntax:\n-\n-    # iface to_str { fn to_str() -> str; }\n-    impl nil_to_str of to_str for () {\n-        fn to_str() -> str { \"()\" }\n-    }\n-\n-## Bounded type parameters\n-\n-The useful thing about value polymorphism is that it does not have to\n-be static. If object-oriented languages only let you call a method on\n-an object when they knew exactly which sub-type it had, that would not\n-get you very far. To be able to call methods on types that aren't\n-known at compile time, it is possible to specify 'bounds' for type\n-parameters.\n-\n-    # iface to_str { fn to_str() -> str; }\n-    fn comma_sep<T: to_str>(elts: [T]) -> str {\n-        let result = \"\", first = true;\n-        for elt in elts {\n-            if first { first = false; }\n-            else { result += \", \"; }\n-            result += elt.to_str();\n-        }\n-        ret result;\n-    }\n-\n-The syntax for this is similar to the syntax for specifying that a\n-parameter type has to be copyable (which is, in principle, another\n-kind of bound). By declaring `T` as conforming to the `to_str`\n-interface, it becomes possible to call methods from that interface on\n-values of that type inside the function. It will also cause a\n-compile-time error when anyone tries to call `comma_sep` on an array\n-whose element type does not have a `to_str` implementation in scope.\n-\n-## Polymorphic interfaces\n-\n-Interfaces may contain type parameters. This defines an interface for\n-generalized sequence types:\n-\n-    iface seq<T> {\n-        fn len() -> uint;\n-        fn iter(block(T));\n-    }\n-    impl <T> of seq<T> for [T] {\n-        fn len() -> uint { vec::len(self) }\n-        fn iter(b: block(T)) {\n-            for elt in self { b(elt); }\n-        }\n-    }\n-\n-Note that the implementation has to explicitly declare the its\n-parameter `T` before using it to specify its interface type. This is\n-needed because it could also, for example, specify an implementation\n-of `seq<int>`\u2014the `of` clause *refers* to a type, rather than defining\n-one.\n-\n-## Casting to an interface type\n-\n-The above allows us to define functions that polymorphically act on\n-values of *an* unknown type that conforms to a given interface.\n-However, consider this function:\n-\n-    # iface drawable { fn draw(); }\n-    fn draw_all<T: drawable>(shapes: [T]) {\n-        for shape in shapes { shape.draw(); }\n-    }\n-\n-You can call that on an array of circles, or an array of squares\n-(assuming those have suitable `drawable` interfaces defined), but not\n-on an array containing both circles and squares.\n-\n-When this is needed, an interface name can be used as a type, causing\n-the function to be written simply like this:\n-\n-    # iface drawable { fn draw(); }\n-    fn draw_all(shapes: [drawable]) {\n-        for shape in shapes { shape.draw(); }\n-    }\n-\n-There is no type parameter anymore (since there isn't a single type\n-that we're calling the function on). Instead, the `drawable` type is\n-used to refer to a type that is a reference-counted box containing a\n-value for which a `drawable` implementation exists, combined with\n-information on where to find the methods for this implementation. This\n-is very similar to the 'vtables' used in most object-oriented\n-languages.\n-\n-To construct such a value, you use the `as` operator to cast a value\n-to an interface type:\n-\n-    # type circle = int; type rectangle = int;\n-    # iface drawable { fn draw(); }\n-    # impl of drawable for int { fn draw() {} }\n-    # fn new_circle() -> int { 1 }\n-    # fn new_rectangle() -> int { 2 }\n-    # fn draw_all(shapes: [drawable]) {}\n-    let c: circle = new_circle();\n-    let r: rectangle = new_rectangle();\n-    draw_all([c as drawable, r as drawable]);\n-\n-This will store the value into a box, along with information about the\n-implementation (which is looked up in the scope of the cast). The\n-`drawable` type simply refers to such boxes, and calling methods on it\n-always works, no matter what implementations are in scope.\n-\n-Note that the allocation of a box is somewhat more expensive than\n-simply using a type parameter and passing in the value as-is, and much\n-more expensive than statically resolved method calls.\n-\n-## Interface-less implementations\n-\n-If you only intend to use an implementation for static overloading,\n-and there is no interface available that it conforms to, you are free\n-to leave off the `of` clause.\n-\n-    # type currency = ();\n-    # fn mk_currency(x: int, s: str) {}\n-    impl int_util for int {\n-        fn times(b: block(int)) {\n-            let i = 0;\n-            while i < self { b(i); i += 1; }\n-        }\n-        fn dollars() -> currency {\n-            mk_currency(self, \"USD\")\n-        }\n-    }\n-\n-This allows cutesy things like `send_payment(10.dollars())`. And the\n-nice thing is that it's fully scoped, so the uneasy feeling that\n-anybody with experience in object-oriented languages (with the\n-possible exception of Rubyists) gets at the sight of such things is\n-not justified. It's harmless!"}, {"sha": "d8c9be5656807be279c1fe6ca374b37f545eb440", "filename": "doc/tutorial/index.md", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Findex.md?ref=d699db699a07d5bb80d5d08508540b0aba6e1026", "patch": "@@ -1 +0,0 @@\n-# Rust language tutorial"}, {"sha": "61510b876755217778f602e2dc9dbde9bd68cc40", "filename": "doc/tutorial/intro.md", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fintro.md?ref=d699db699a07d5bb80d5d08508540b0aba6e1026", "patch": "@@ -1,57 +0,0 @@\n-# Introduction\n-\n-## Scope\n-\n-This is a tutorial for the Rust programming language. It assumes the\n-reader is familiar with the basic concepts of programming, and has\n-programmed in one or more other languages before. The tutorial covers\n-the whole language, though not with the depth and precision of the\n-[language reference][1].\n-\n-[1]: http://www.rust-lang.org/doc/rust.html\n-\n-## Disclaimer\n-\n-Rust is a language under development. The general flavor of the\n-language has settled, but details will continue to change as it is\n-further refined. Nothing in this tutorial is final, and though we try\n-to keep it updated, it is possible that the text occasionally does not\n-reflect the actual state of the language.\n-\n-## First Impressions\n-\n-Though syntax is something you get used to, an initial encounter with\n-a language can be made easier if the notation looks familiar. Rust is\n-a curly-brace language in the tradition of C, C++, and JavaScript.\n-\n-    fn fac(n: int) -> int {\n-        let result = 1, i = 1;\n-        while i <= n {\n-            result *= i;\n-            i += 1;\n-        }\n-        ret result;\n-    }\n-\n-Several differences from C stand out. Types do not come before, but\n-after variable names (preceded by a colon). In local variables\n-(introduced with `let`), they are optional, and will be inferred when\n-left off. Constructs like `while` and `if` do not require parenthesis\n-around the condition (though they allow them). Also, there's a\n-tendency towards aggressive abbreviation in the keywords\u2014`fn` for\n-function, `ret` for return.\n-\n-You should, however, not conclude that Rust is simply an evolution of\n-C. As will become clear in the rest of this tutorial, it goes in\n-quite a different direction.\n-\n-## Conventions\n-\n-Throughout the tutorial, words that indicate language keywords or\n-identifiers defined in the example code are displayed in `code font`.\n-\n-Code snippets are indented, and also shown in a monospace font. Not\n-all snippets constitute whole programs. For brevity, we'll often show\n-fragments of programs that don't compile on their own. To try them\n-out, you might have to wrap them in `fn main() { ... }`, and make sure\n-they don't contain references to things that aren't actually defined."}, {"sha": "a5b1240fc70dda8e6c8437fc3c1d71f1bce3bfca", "filename": "doc/tutorial/lib/markdown.js", "status": "removed", "additions": 0, "deletions": 1469, "changes": 1469, "blob_url": "https://github.com/rust-lang/rust/blob/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Flib%2Fmarkdown.js", "raw_url": "https://github.com/rust-lang/rust/raw/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Flib%2Fmarkdown.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Flib%2Fmarkdown.js?ref=d699db699a07d5bb80d5d08508540b0aba6e1026", "patch": "@@ -1,1469 +0,0 @@\n-// Released under MIT license\n-// Copyright (c) 2009-2010 Dominic Baggott\n-// Copyright (c) 2009-2010 Ash Berlin\n-// Copyright (c) 2011 Christoph Dorn <christoph@christophdorn.com> (http://www.christophdorn.com)\n-\n-(function( expose ) {\n-\n-/**\n- *  class Markdown\n- *\n- *  Markdown processing in Javascript done right. We have very particular views\n- *  on what constitutes 'right' which include:\n- *\n- *  - produces well-formed HTML (this means that em and strong nesting is\n- *    important)\n- *\n- *  - has an intermediate representation to allow processing of parsed data (We\n- *    in fact have two, both as [JsonML]: a markdown tree and an HTML tree).\n- *\n- *  - is easily extensible to add new dialects without having to rewrite the\n- *    entire parsing mechanics\n- *\n- *  - has a good test suite\n- *\n- *  This implementation fulfills all of these (except that the test suite could\n- *  do with expanding to automatically run all the fixtures from other Markdown\n- *  implementations.)\n- *\n- *  ##### Intermediate Representation\n- *\n- *  *TODO* Talk about this :) Its JsonML, but document the node names we use.\n- *\n- *  [JsonML]: http://jsonml.org/ \"JSON Markup Language\"\n- **/\n-var Markdown = expose.Markdown = function Markdown(dialect) {\n-  switch (typeof dialect) {\n-    case \"undefined\":\n-      this.dialect = Markdown.dialects.Gruber;\n-      break;\n-    case \"object\":\n-      this.dialect = dialect;\n-      break;\n-    default:\n-      if (dialect in Markdown.dialects) {\n-        this.dialect = Markdown.dialects[dialect];\n-      }\n-      else {\n-        throw new Error(\"Unknown Markdown dialect '\" + String(dialect) + \"'\");\n-      }\n-      break;\n-  }\n-  this.em_state = [];\n-  this.strong_state = [];\n-  this.debug_indent = \"\";\n-}\n-\n-/**\n- *  parse( markdown, [dialect] ) -> JsonML\n- *  - markdown (String): markdown string to parse\n- *  - dialect (String | Dialect): the dialect to use, defaults to gruber\n- *\n- *  Parse `markdown` and return a markdown document as a Markdown.JsonML tree.\n- **/\n-expose.parse = function( source, dialect ) {\n-  // dialect will default if undefined\n-  var md = new Markdown( dialect );\n-  return md.toTree( source );\n-}\n-\n-/**\n- *  toHTML( markdown, [dialect]  ) -> String\n- *  toHTML( md_tree ) -> String\n- *  - markdown (String): markdown string to parse\n- *  - md_tree (Markdown.JsonML): parsed markdown tree\n- *\n- *  Take markdown (either as a string or as a JsonML tree) and run it through\n- *  [[toHTMLTree]] then turn it into a well-formated HTML fragment.\n- **/\n-expose.toHTML = function toHTML( source , dialect , options ) {\n-  var input = expose.toHTMLTree( source , dialect , options );\n-\n-  return expose.renderJsonML( input );\n-}\n-\n-/**\n- *  toHTMLTree( markdown, [dialect] ) -> JsonML\n- *  toHTMLTree( md_tree ) -> JsonML\n- *  - markdown (String): markdown string to parse\n- *  - dialect (String | Dialect): the dialect to use, defaults to gruber\n- *  - md_tree (Markdown.JsonML): parsed markdown tree\n- *\n- *  Turn markdown into HTML, represented as a JsonML tree. If a string is given\n- *  to this function, it is first parsed into a markdown tree by calling\n- *  [[parse]].\n- **/\n-expose.toHTMLTree = function toHTMLTree( input, dialect , options ) {\n-  // convert string input to an MD tree\n-  if ( typeof input ===\"string\" ) input = this.parse( input, dialect );\n-\n-  // Now convert the MD tree to an HTML tree\n-\n-  // remove references from the tree\n-  var attrs = extract_attr( input ),\n-      refs = {};\n-\n-  if ( attrs && attrs.references ) {\n-    refs = attrs.references;\n-  }\n-\n-  var html = convert_tree_to_html( input, refs , options );\n-  merge_text_nodes( html );\n-  return html;\n-}\n-\n-var mk_block = Markdown.mk_block = function(block, trail, line) {\n-  // Be helpful for default case in tests.\n-  if ( arguments.length == 1 ) trail = \"\\n\\n\";\n-\n-  var s = new String(block);\n-  s.trailing = trail;\n-  // To make it clear its not just a string\n-  s.toSource = function() {\n-    return \"Markdown.mk_block( \" +\n-            uneval(block) +\n-            \", \" +\n-            uneval(trail) +\n-            \", \" +\n-            uneval(line) +\n-            \" )\"\n-  }\n-\n-  if (line != undefined)\n-    s.lineNumber = line;\n-\n-  return s;\n-}\n-\n-function count_lines( str ) {\n-  var n = 0, i = -1;;\n-  while ( ( i = str.indexOf('\\n', i+1) ) != -1) n++;\n-  return n;\n-}\n-\n-// Internal - split source into rough blocks\n-Markdown.prototype.split_blocks = function splitBlocks( input, startLine ) {\n-  // [\\s\\S] matches _anything_ (newline or space)\n-  var re = /([\\s\\S]+?)($|\\n(?:\\s*\\n|$)+)/g,\n-      blocks = [],\n-      m;\n-\n-  var line_no = 1;\n-\n-  if ( ( m = /^(\\s*\\n)/.exec(input) ) != null ) {\n-    // skip (but count) leading blank lines\n-    line_no += count_lines( m[0] );\n-    re.lastIndex = m[0].length;\n-  }\n-\n-  while ( ( m = re.exec(input) ) != null ) {\n-    blocks.push( mk_block( m[1], m[2], line_no ) );\n-    line_no += count_lines( m[0] );\n-  }\n-\n-  return blocks;\n-}\n-\n-/**\n- *  Markdown#processBlock( block, next ) -> undefined | [ JsonML, ... ]\n- *  - block (String): the block to process\n- *  - next (Array): the following blocks\n- *\n- * Process `block` and return an array of JsonML nodes representing `block`.\n- *\n- * It does this by asking each block level function in the dialect to process\n- * the block until one can. Succesful handling is indicated by returning an\n- * array (with zero or more JsonML nodes), failure by a false value.\n- *\n- * Blocks handlers are responsible for calling [[Markdown#processInline]]\n- * themselves as appropriate.\n- *\n- * If the blocks were split incorrectly or adjacent blocks need collapsing you\n- * can adjust `next` in place using shift/splice etc.\n- *\n- * If any of this default behaviour is not right for the dialect, you can\n- * define a `__call__` method on the dialect that will get invoked to handle\n- * the block processing.\n- */\n-Markdown.prototype.processBlock = function processBlock( block, next ) {\n-  var cbs = this.dialect.block,\n-      ord = cbs.__order__;\n-\n-  if ( \"__call__\" in cbs ) {\n-    return cbs.__call__.call(this, block, next);\n-  }\n-\n-  for ( var i = 0; i < ord.length; i++ ) {\n-    //D:this.debug( \"Testing\", ord[i] );\n-    var res = cbs[ ord[i] ].call( this, block, next );\n-    if ( res ) {\n-      //D:this.debug(\"  matched\");\n-      if ( !isArray(res) || ( res.length > 0 && !( isArray(res[0]) ) ) )\n-        this.debug(ord[i], \"didn't return a proper array\");\n-      //D:this.debug( \"\" );\n-      return res;\n-    }\n-  }\n-\n-  // Uhoh! no match! Should we throw an error?\n-  return [];\n-}\n-\n-Markdown.prototype.processInline = function processInline( block ) {\n-  return this.dialect.inline.__call__.call( this, String( block ) );\n-}\n-\n-/**\n- *  Markdown#toTree( source ) -> JsonML\n- *  - source (String): markdown source to parse\n- *\n- *  Parse `source` into a JsonML tree representing the markdown document.\n- **/\n-// custom_tree means set this.tree to `custom_tree` and restore old value on return\n-Markdown.prototype.toTree = function toTree( source, custom_root ) {\n-  var blocks = source instanceof Array\n-             ? source\n-             : this.split_blocks( source );\n-\n-  // Make tree a member variable so its easier to mess with in extensions\n-  var old_tree = this.tree;\n-  try {\n-    this.tree = custom_root || this.tree || [ \"markdown\" ];\n-\n-    blocks:\n-    while ( blocks.length ) {\n-      var b = this.processBlock( blocks.shift(), blocks );\n-\n-      // Reference blocks and the like won't return any content\n-      if ( !b.length ) continue blocks;\n-\n-      this.tree.push.apply( this.tree, b );\n-    }\n-    return this.tree;\n-  }\n-  finally {\n-    if ( custom_root )\n-      this.tree = old_tree;\n-  }\n-\n-}\n-\n-// Noop by default\n-Markdown.prototype.debug = function () {\n-  var args = Array.prototype.slice.call( arguments);\n-  args.unshift(this.debug_indent);\n-  if (typeof console !== \"undefined\" && typeof console.log !== \"undefined\")\n-      console.log.apply( null, args );\n-}\n-\n-Markdown.prototype.loop_re_over_block = function( re, block, cb ) {\n-  // Dont use /g regexps with this\n-  var m,\n-      b = block.valueOf();\n-\n-  while ( b.length && (m = re.exec(b) ) != null) {\n-    b = b.substr( m[0].length );\n-    cb.call(this, m);\n-  }\n-  return b;\n-}\n-\n-/**\n- * Markdown.dialects\n- *\n- * Namespace of built-in dialects.\n- **/\n-Markdown.dialects = {};\n-\n-/**\n- * Markdown.dialects.Gruber\n- *\n- * The default dialect that follows the rules set out by John Gruber's\n- * markdown.pl as closely as possible. Well actually we follow the behaviour of\n- * that script which in some places is not exactly what the syntax web page\n- * says.\n- **/\n-Markdown.dialects.Gruber = {\n-  block: {\n-    atxHeader: function atxHeader( block, next ) {\n-      var m = block.match( /^(#{1,6})\\s*(.*?)\\s*#*\\s*(?:\\n|$)/ );\n-\n-      if ( !m ) return undefined;\n-\n-      var header = [ \"header\", { level: m[ 1 ].length } ];\n-      Array.prototype.push.apply(header, this.processInline(m[ 2 ]));\n-\n-      if ( m[0].length < block.length )\n-        next.unshift( mk_block( block.substr( m[0].length ), block.trailing, block.lineNumber + 2 ) );\n-\n-      return [ header ];\n-    },\n-\n-    setextHeader: function setextHeader( block, next ) {\n-      var m = block.match( /^(.*)\\n([-=])\\2\\2+(?:\\n|$)/ );\n-\n-      if ( !m ) return undefined;\n-\n-      var level = ( m[ 2 ] === \"=\" ) ? 1 : 2;\n-      var header = [ \"header\", { level : level }, m[ 1 ] ];\n-\n-      if ( m[0].length < block.length )\n-        next.unshift( mk_block( block.substr( m[0].length ), block.trailing, block.lineNumber + 2 ) );\n-\n-      return [ header ];\n-    },\n-\n-    code: function code( block, next ) {\n-      // |    Foo\n-      // |bar\n-      // should be a code block followed by a paragraph. Fun\n-      //\n-      // There might also be adjacent code block to merge.\n-\n-      var ret = [],\n-          re = /^(?: {0,3}\\t| {4})(.*)\\n?/,\n-          lines;\n-\n-      // 4 spaces + content\n-      var m = block.match( re );\n-\n-      if ( !m ) return undefined;\n-\n-      block_search:\n-      do {\n-        // Now pull out the rest of the lines\n-        var b = this.loop_re_over_block(\n-                  re, block.valueOf(), function( m ) { ret.push( m[1] ) } );\n-\n-        if (b.length) {\n-          // Case alluded to in first comment. push it back on as a new block\n-          next.unshift( mk_block(b, block.trailing) );\n-          break block_search;\n-        }\n-        else if (next.length) {\n-          // Check the next block - it might be code too\n-          var m = next[0].match( re );\n-\n-          if ( !m ) break block_search;\n-\n-          // Pull how how many blanks lines follow - minus two to account for .join\n-          ret.push ( block.trailing.replace(/[^\\n]/g, '').substring(2) );\n-\n-          block = next.shift();\n-        }\n-        else\n-          break block_search;\n-      } while (true);\n-\n-      return [ [ \"code_block\", ret.join(\"\\n\") ] ];\n-    },\n-\n-    horizRule: function horizRule( block, next ) {\n-      // this needs to find any hr in the block to handle abutting blocks\n-      var m = block.match( /^(?:([\\s\\S]*?)\\n)?[ \\t]*([-_*])(?:[ \\t]*\\2){2,}[ \\t]*(?:\\n([\\s\\S]*))?$/ );\n-\n-      if ( !m ) {\n-        return undefined;\n-      }\n-\n-      var jsonml = [ [ \"hr\" ] ];\n-\n-      // if there's a leading abutting block, process it\n-      if ( m[ 1 ] ) {\n-        jsonml.unshift.apply( jsonml, this.processBlock( m[ 1 ], [] ) );\n-      }\n-\n-      // if there's a trailing abutting block, stick it into next\n-      if ( m[ 3 ] ) {\n-        next.unshift( mk_block( m[ 3 ] ) );\n-      }\n-\n-      return jsonml;\n-    },\n-\n-    // There are two types of lists. Tight and loose. Tight lists have no whitespace\n-    // between the items (and result in text just in the <li>) and loose lists,\n-    // which have an empty line between list items, resulting in (one or more)\n-    // paragraphs inside the <li>.\n-    //\n-    // There are all sorts weird edge cases about the original markdown.pl's\n-    // handling of lists:\n-    //\n-    // * Nested lists are supposed to be indented by four chars per level. But\n-    //   if they aren't, you can get a nested list by indenting by less than\n-    //   four so long as the indent doesn't match an indent of an existing list\n-    //   item in the 'nest stack'.\n-    //\n-    // * The type of the list (bullet or number) is controlled just by the\n-    //    first item at the indent. Subsequent changes are ignored unless they\n-    //    are for nested lists\n-    //\n-    lists: (function( ) {\n-      // Use a closure to hide a few variables.\n-      var any_list = \"[*+-]|\\\\d\\\\.\",\n-          bullet_list = /[*+-]/,\n-          number_list = /\\d+\\./,\n-          // Capture leading indent as it matters for determining nested lists.\n-          is_list_re = new RegExp( \"^( {0,3})(\" + any_list + \")[ \\t]+\" ),\n-          indent_re = \"(?: {0,3}\\\\t| {4})\";\n-\n-      // TODO: Cache this regexp for certain depths.\n-      // Create a regexp suitable for matching an li for a given stack depth\n-      function regex_for_depth( depth ) {\n-\n-        return new RegExp(\n-          // m[1] = indent, m[2] = list_type\n-          \"(?:^(\" + indent_re + \"{0,\" + depth + \"} {0,3})(\" + any_list + \")\\\\s+)|\" +\n-          // m[3] = cont\n-          \"(^\" + indent_re + \"{0,\" + (depth-1) + \"}[ ]{0,4})\"\n-        );\n-      }\n-      function expand_tab( input ) {\n-        return input.replace( / {0,3}\\t/g, \"    \" );\n-      }\n-\n-      // Add inline content `inline` to `li`. inline comes from processInline\n-      // so is an array of content\n-      function add(li, loose, inline, nl) {\n-        if (loose) {\n-            li.push( [ \"para\" ].concat(inline) );\n-          return;\n-        }\n-        // Hmmm, should this be any block level element or just paras?\n-        var add_to = li[li.length -1] instanceof Array && li[li.length - 1][0] == \"para\"\n-                   ? li[li.length -1]\n-                   : li;\n-\n-        // If there is already some content in this list, add the new line in\n-        if (nl && li.length > 1) inline.unshift(nl);\n-\n-        for (var i=0; i < inline.length; i++) {\n-          var what = inline[i],\n-              is_str = typeof what == \"string\";\n-          if (is_str && add_to.length > 1 && typeof add_to[add_to.length-1] == \"string\" )\n-          {\n-            add_to[ add_to.length-1 ] += what;\n-          }\n-          else {\n-            add_to.push( what );\n-          }\n-        }\n-      }\n-\n-      // contained means have an indent greater than the current one. On\n-      // *every* line in the block\n-      function get_contained_blocks( depth, blocks ) {\n-\n-        var re = new RegExp( \"^(\" + indent_re + \"{\" + depth + \"}.*?\\\\n?)*$\" ),\n-            replace = new RegExp(\"^\" + indent_re + \"{\" + depth + \"}\", \"gm\"),\n-            ret = [];\n-\n-        while ( blocks.length > 0 ) {\n-          if ( re.exec( blocks[0] ) ) {\n-            var b = blocks.shift(),\n-                // Now remove that indent\n-                x = b.replace( replace, \"\");\n-\n-            ret.push( mk_block( x, b.trailing, b.lineNumber ) );\n-          }\n-          break;\n-        }\n-        return ret;\n-      }\n-\n-      // passed to stack.forEach to turn list items up the stack into paras\n-      function paragraphify(s, i, stack) {\n-        var list = s.list;\n-        var last_li = list[list.length-1];\n-\n-        if (last_li[1] instanceof Array && last_li[1][0] == \"para\") {\n-          return;\n-        }\n-        if (i+1 == stack.length) {\n-          // Last stack frame\n-          // Keep the same array, but replace the contents\n-          last_li.push( [\"para\"].concat( last_li.splice(1) ) );\n-        }\n-        else {\n-          var sublist = last_li.pop();\n-          last_li.push( [\"para\"].concat( last_li.splice(1) ), sublist );\n-        }\n-      }\n-\n-      // The matcher function\n-      return function( block, next ) {\n-        var m = block.match( is_list_re );\n-        if ( !m ) return undefined;\n-\n-        function make_list( m ) {\n-          var list = bullet_list.exec( m[2] )\n-                   ? [\"bulletlist\"]\n-                   : [\"numberlist\"];\n-\n-          stack.push( { list: list, indent: m[1] } );\n-          return list;\n-        }\n-\n-\n-        var stack = [], // Stack of lists for nesting.\n-            list = make_list( m ),\n-            last_li,\n-            loose = false,\n-            ret = [ stack[0].list ];\n-\n-        // Loop to search over block looking for inner block elements and loose lists\n-        loose_search:\n-        while( true ) {\n-          // Split into lines preserving new lines at end of line\n-          var lines = block.split( /(?=\\n)/ );\n-\n-          // We have to grab all lines for a li and call processInline on them\n-          // once as there are some inline things that can span lines.\n-          var li_accumulate = \"\";\n-\n-          // Loop over the lines in this block looking for tight lists.\n-          tight_search:\n-          for (var line_no=0; line_no < lines.length; line_no++) {\n-            var nl = \"\",\n-                l = lines[line_no].replace(/^\\n/, function(n) { nl = n; return \"\" });\n-\n-            // TODO: really should cache this\n-            var line_re = regex_for_depth( stack.length );\n-\n-            m = l.match( line_re );\n-            //print( \"line:\", uneval(l), \"\\nline match:\", uneval(m) );\n-\n-            // We have a list item\n-            if ( m[1] !== undefined ) {\n-              // Process the previous list item, if any\n-              if ( li_accumulate.length ) {\n-                add( last_li, loose, this.processInline( li_accumulate ), nl );\n-                // Loose mode will have been dealt with. Reset it\n-                loose = false;\n-                li_accumulate = \"\";\n-              }\n-\n-              m[1] = expand_tab( m[1] );\n-              var wanted_depth = Math.floor(m[1].length/4)+1;\n-              //print( \"want:\", wanted_depth, \"stack:\", stack.length);\n-              if ( wanted_depth > stack.length ) {\n-                // Deep enough for a nested list outright\n-                //print ( \"new nested list\" );\n-                list = make_list( m );\n-                last_li.push( list );\n-                last_li = list[1] = [ \"listitem\" ];\n-              }\n-              else {\n-                // We aren't deep enough to be strictly a new level. This is\n-                // where Md.pl goes nuts. If the indent matches a level in the\n-                // stack, put it there, else put it one deeper then the\n-                // wanted_depth deserves.\n-                var found = stack.some(function(s, i) {\n-                  if ( s.indent != m[1] ) return false;\n-                  list = s.list;     // Found the level we want\n-                  stack.splice(i+1); // Remove the others\n-                  //print(\"found\");\n-                  return true;       // And stop looping\n-                });\n-\n-                if (!found) {\n-                  //print(\"not found. l:\", uneval(l));\n-                  wanted_depth++;\n-                  if (wanted_depth <= stack.length) {\n-                    stack.splice(wanted_depth);\n-                    //print(\"Desired depth now\", wanted_depth, \"stack:\", stack.length);\n-                    list = stack[wanted_depth-1].list;\n-                    //print(\"list:\", uneval(list) );\n-                  }\n-                  else {\n-                    //print (\"made new stack for messy indent\");\n-                    list = make_list(m);\n-                    last_li.push(list);\n-                  }\n-                }\n-\n-                //print( uneval(list), \"last\", list === stack[stack.length-1].list );\n-                last_li = [ \"listitem\" ];\n-                list.push(last_li);\n-              } // end depth of shenegains\n-              nl = \"\";\n-            }\n-\n-            // Add content\n-            if (l.length > m[0].length) {\n-              li_accumulate += nl + l.substr( m[0].length );\n-            }\n-          } // tight_search\n-\n-          if ( li_accumulate.length ) {\n-            add( last_li, loose, this.processInline( li_accumulate ), nl );\n-            // Loose mode will have been dealt with. Reset it\n-            loose = false;\n-            li_accumulate = \"\";\n-          }\n-\n-          // Look at the next block - we might have a loose list. Or an extra\n-          // paragraph for the current li\n-          var contained = get_contained_blocks( stack.length, next );\n-\n-          // Deal with code blocks or properly nested lists\n-          if (contained.length > 0) {\n-            // Make sure all listitems up the stack are paragraphs\n-            stack.forEach( paragraphify, this );\n-\n-            last_li.push.apply( last_li, this.toTree( contained, [] ) );\n-          }\n-\n-          var next_block = next[0] && next[0].valueOf() || \"\";\n-\n-          if ( next_block.match(is_list_re) || next_block.match( /^ / ) ) {\n-            block = next.shift();\n-\n-            // Check for an HR following a list: features/lists/hr_abutting\n-            var hr = this.dialect.block.horizRule( block, next );\n-\n-            if (hr) {\n-              ret.push.apply(ret, hr);\n-              break;\n-            }\n-\n-            // Make sure all listitems up the stack are paragraphs\n-            stack.forEach( paragraphify , this );\n-\n-            loose = true;\n-            continue loose_search;\n-          }\n-          break;\n-        } // loose_search\n-\n-        return ret;\n-      }\n-    })(),\n-\n-    blockquote: function blockquote( block, next ) {\n-      if ( !block.match( /^>/m ) )\n-        return undefined;\n-\n-      var jsonml = [];\n-\n-      // separate out the leading abutting block, if any\n-      if ( block[ 0 ] != \">\" ) {\n-        var lines = block.split( /\\n/ ),\n-            prev = [];\n-\n-        // keep shifting lines until you find a crotchet\n-        while ( lines.length && lines[ 0 ][ 0 ] != \">\" ) {\n-            prev.push( lines.shift() );\n-        }\n-\n-        // reassemble!\n-        block = lines.join( \"\\n\" );\n-        jsonml.push.apply( jsonml, this.processBlock( prev.join( \"\\n\" ), [] ) );\n-      }\n-\n-      // if the next block is also a blockquote merge it in\n-      while ( next.length && next[ 0 ][ 0 ] == \">\" ) {\n-        var b = next.shift();\n-        block += block.trailing + b;\n-        block.trailing = b.trailing;\n-      }\n-\n-      // Strip off the leading \"> \" and re-process as a block.\n-      var input = block.replace( /^> ?/gm, '' ),\n-          old_tree = this.tree;\n-      jsonml.push( this.toTree( input, [ \"blockquote\" ] ) );\n-\n-      return jsonml;\n-    },\n-\n-    referenceDefn: function referenceDefn( block, next) {\n-      var re = /^\\s*\\[(.*?)\\]:\\s*(\\S+)(?:\\s+(?:(['\"])(.*?)\\3|\\((.*?)\\)))?\\n?/;\n-      // interesting matches are [ , ref_id, url, , title, title ]\n-\n-      if ( !block.match(re) )\n-        return undefined;\n-\n-      // make an attribute node if it doesn't exist\n-      if ( !extract_attr( this.tree ) ) {\n-        this.tree.splice( 1, 0, {} );\n-      }\n-\n-      var attrs = extract_attr( this.tree );\n-\n-      // make a references hash if it doesn't exist\n-      if ( attrs.references === undefined ) {\n-        attrs.references = {};\n-      }\n-\n-      var b = this.loop_re_over_block(re, block, function( m ) {\n-\n-        if ( m[2] && m[2][0] == '<' && m[2][m[2].length-1] == '>' )\n-          m[2] = m[2].substring( 1, m[2].length - 1 );\n-\n-        var ref = attrs.references[ m[1].toLowerCase() ] = {\n-          href: m[2]\n-        };\n-\n-        if (m[4] !== undefined)\n-          ref.title = m[4];\n-        else if (m[5] !== undefined)\n-          ref.title = m[5];\n-\n-      } );\n-\n-      if (b.length)\n-        next.unshift( mk_block( b, block.trailing ) );\n-\n-      return [];\n-    },\n-\n-    para: function para( block, next ) {\n-      // everything's a para!\n-      return [ [\"para\"].concat( this.processInline( block ) ) ];\n-    }\n-  }\n-}\n-\n-Markdown.dialects.Gruber.inline = {\n-    __call__: function inline( text, patterns ) {\n-      // Hmmm - should this function be directly in Md#processInline, or\n-      // conversely, should Md#processBlock be moved into block.__call__ too\n-      var out = [ ],\n-          m,\n-          // Look for the next occurange of a special character/pattern\n-          re = new RegExp( \"([\\\\s\\\\S]*?)(\" + (patterns.source || patterns) + \")\", \"g\" ),\n-          lastIndex = 0;\n-\n-      //D:var self = this;\n-      //D:self.debug(\"processInline:\", uneval(text) );\n-      function add(x) {\n-        //D:self.debug(\"  adding output\", uneval(x));\n-        if (typeof x == \"string\" && typeof out[out.length-1] == \"string\")\n-          out[ out.length-1 ] += x;\n-        else\n-          out.push(x);\n-      }\n-\n-      while ( ( m = re.exec(text) ) != null) {\n-        if ( m[1] ) add( m[1] ); // Some un-interesting text matched\n-        else        m[1] = { length: 0 }; // Or there was none, but make m[1].length == 0\n-\n-        var res;\n-        if ( m[2] in this.dialect.inline ) {\n-          res = this.dialect.inline[ m[2] ].call(\n-                    this,\n-                    text.substr( m.index + m[1].length ), m, out );\n-        }\n-        // Default for now to make dev easier. just slurp special and output it.\n-        res = res || [ m[2].length, m[2] ];\n-\n-        var len = res.shift();\n-        // Update how much input was consumed\n-        re.lastIndex += ( len - m[2].length );\n-\n-        // Add children\n-        res.forEach(add);\n-\n-        lastIndex = re.lastIndex;\n-      }\n-\n-      // Add last 'boring' chunk\n-      if ( text.length > lastIndex )\n-        add( text.substr( lastIndex ) );\n-\n-      return out;\n-    },\n-\n-    \"\\\\\": function escaped( text ) {\n-      // [ length of input processed, node/children to add... ]\n-      // Only esacape: \\ ` * _ { } [ ] ( ) # * + - . !\n-      if ( text.match( /^\\\\[\\\\`\\*_{}\\[\\]()#\\+.!\\-]/ ) )\n-        return [ 2, text[1] ];\n-      else\n-        // Not an esacpe\n-        return [ 1, \"\\\\\" ];\n-    },\n-\n-    \"![\": function image( text ) {\n-      // ![Alt text](/path/to/img.jpg \"Optional title\")\n-      //      1          2            3       4         <--- captures\n-      var m = text.match( /^!\\[(.*?)\\][ \\t]*\\([ \\t]*(\\S*)(?:[ \\t]+([\"'])(.*?)\\3)?[ \\t]*\\)/ );\n-\n-      if ( m ) {\n-        if ( m[2] && m[2][0] == '<' && m[2][m[2].length-1] == '>' )\n-          m[2] = m[2].substring( 1, m[2].length - 1 );\n-\n-        m[2] == this.dialect.inline.__call__.call( this, m[2], /\\\\/ )[0];\n-\n-        var attrs = { alt: m[1], href: m[2] || \"\" };\n-        if ( m[4] !== undefined)\n-          attrs.title = m[4];\n-\n-        return [ m[0].length, [ \"img\", attrs ] ];\n-      }\n-\n-      // ![Alt text][id]\n-      m = text.match( /^!\\[(.*?)\\][ \\t]*\\[(.*?)\\]/ );\n-\n-      if ( m ) {\n-        // We can't check if the reference is known here as it likely wont be\n-        // found till after. Check it in md tree->hmtl tree conversion\n-        return [ m[0].length, [ \"img_ref\", { alt: m[1], ref: m[2].toLowerCase(), text: m[0] } ] ];\n-      }\n-\n-      // Just consume the '!['\n-      return [ 2, \"![\" ];\n-    },\n-\n-    \"[\": function link( text ) {\n-      // [link text](/path/to/img.jpg \"Optional title\")\n-      //      1          2            3       4         <--- captures\n-      var m = text.match( /^\\[([\\s\\S]*?)\\][ \\t]*\\([ \\t]*(\\S+)(?:[ \\t]+([\"'])(.*?)\\3)?[ \\t]*\\)/ );\n-\n-      if ( m && m[1].indexOf(\"]\") == -1 ) {\n-        if ( m[2] && m[2][0] == '<' && m[2][m[2].length-1] == '>' )\n-          m[2] = m[2].substring( 1, m[2].length - 1 );\n-\n-        // Process escapes only\n-        m[2] = this.dialect.inline.__call__.call( this, m[2], /\\\\/ )[0];\n-\n-        var attrs = { href: m[2] || \"\" };\n-        if ( m[4] !== undefined)\n-          attrs.title = m[4];\n-\n-        var link = [ \"link\", attrs ];\n-        Array.prototype.push.apply( link, this.processInline( m[1] ) );\n-        return [ m[0].length, link ];\n-      }\n-\n-      // [Alt text][id]\n-      // [Alt text] [id]\n-      // [id]\n-      m = text.match( /^\\[([\\s\\S]*?)\\](?: ?\\[(.*?)\\])?/ );\n-\n-      if ( m ) {\n-        // [id] case, text == id\n-        if ( m[2] === undefined || m[2] === \"\" ) m[2] = m[1];\n-\n-        attrs = { ref: m[ 2 ].toLowerCase(),  original: m[ 0 ] };\n-        link = [ \"link_ref\", attrs ];\n-        Array.prototype.push.apply( link, this.processInline( m[1] ) );\n-\n-        // We can't check if the reference is known here as it likely wont be\n-        // found till after. Check it in md tree->hmtl tree conversion.\n-        // Store the original so that conversion can revert if the ref isn't found.\n-        return [\n-          m[ 0 ].length,\n-          link\n-        ];\n-      }\n-\n-      // Just consume the '['\n-      return [ 1, \"[\" ];\n-    },\n-\n-\n-    \"<\": function autoLink( text ) {\n-      var m;\n-\n-      if ( ( m = text.match( /^<(?:((https?|ftp|mailto):[^>]+)|(.*?@.*?\\.[a-zA-Z]+))>/ ) ) != null ) {\n-        if ( m[3] ) {\n-          return [ m[0].length, [ \"link\", { href: \"mailto:\" + m[3] }, m[3] ] ];\n-\n-        }\n-        else if ( m[2] == \"mailto\" ) {\n-          return [ m[0].length, [ \"link\", { href: m[1] }, m[1].substr(\"mailto:\".length ) ] ];\n-        }\n-        else\n-          return [ m[0].length, [ \"link\", { href: m[1] }, m[1] ] ];\n-      }\n-\n-      return [ 1, \"<\" ];\n-    },\n-\n-    \"`\": function inlineCode( text ) {\n-      // Inline code block. as many backticks as you like to start it\n-      // Always skip over the opening ticks.\n-      var m = text.match( /(`+)(([\\s\\S]*?)\\1)/ );\n-\n-      if ( m && m[2] )\n-        return [ m[1].length + m[2].length, [ \"inlinecode\", m[3] ] ];\n-      else {\n-        // TODO: No matching end code found - warn!\n-        return [ 1, \"`\" ];\n-      }\n-    },\n-\n-    \"  \\n\": function lineBreak( text ) {\n-      return [ 3, [ \"linebreak\" ] ];\n-    }\n-\n-}\n-\n-// Meta Helper/generator method for em and strong handling\n-function strong_em( tag, md ) {\n-\n-  var state_slot = tag + \"_state\",\n-      other_slot = tag == \"strong\" ? \"em_state\" : \"strong_state\";\n-\n-  function CloseTag(len) {\n-    this.len_after = len;\n-    this.name = \"close_\" + md;\n-  }\n-\n-  return function ( text, orig_match ) {\n-\n-    if (this[state_slot][0] == md) {\n-      // Most recent em is of this type\n-      //D:this.debug(\"closing\", md);\n-      this[state_slot].shift();\n-\n-      // \"Consume\" everything to go back to the recrusion in the else-block below\n-      return[ text.length, new CloseTag(text.length-md.length) ];\n-    }\n-    else {\n-      // Store a clone of the em/strong states\n-      var other = this[other_slot].slice(),\n-          state = this[state_slot].slice();\n-\n-      this[state_slot].unshift(md);\n-\n-      //D:this.debug_indent += \"  \";\n-\n-      // Recurse\n-      var res = this.processInline( text.substr( md.length ) );\n-      //D:this.debug_indent = this.debug_indent.substr(2);\n-\n-      var last = res[res.length - 1];\n-\n-      //D:this.debug(\"processInline from\", tag + \": \", uneval( res ) );\n-\n-      var check = this[state_slot].shift();\n-      if (last instanceof CloseTag) {\n-        res.pop();\n-        // We matched! Huzzah.\n-        var consumed = text.length - last.len_after;\n-        return [ consumed, [ tag ].concat(res) ];\n-      }\n-      else {\n-        // Restore the state of the other kind. We might have mistakenly closed it.\n-        this[other_slot] = other;\n-        this[state_slot] = state;\n-\n-        // We can't reuse the processed result as it could have wrong parsing contexts in it.\n-        return [ md.length, md ];\n-      }\n-    }\n-  } // End returned function\n-}\n-\n-Markdown.dialects.Gruber.inline[\"**\"] = strong_em(\"strong\", \"**\");\n-Markdown.dialects.Gruber.inline[\"__\"] = strong_em(\"strong\", \"__\");\n-Markdown.dialects.Gruber.inline[\"*\"]  = strong_em(\"em\", \"*\");\n-Markdown.dialects.Gruber.inline[\"_\"]  = strong_em(\"em\", \"_\");\n-\n-\n-// Build default order from insertion order.\n-Markdown.buildBlockOrder = function(d) {\n-  var ord = [];\n-  for ( var i in d ) {\n-    if ( i == \"__order__\" || i == \"__call__\" ) continue;\n-    ord.push( i );\n-  }\n-  d.__order__ = ord;\n-}\n-\n-// Build patterns for inline matcher\n-Markdown.buildInlinePatterns = function(d) {\n-  var patterns = [];\n-\n-  for ( var i in d ) {\n-    if (i == \"__call__\") continue;\n-    var l = i.replace( /([\\\\.*+?|()\\[\\]{}])/g, \"\\\\$1\" )\n-             .replace( /\\n/, \"\\\\n\" );\n-    patterns.push( i.length == 1 ? l : \"(?:\" + l + \")\" );\n-  }\n-\n-  patterns = patterns.join(\"|\");\n-  //print(\"patterns:\", uneval( patterns ) );\n-\n-  var fn = d.__call__;\n-  d.__call__ = function(text, pattern) {\n-    if (pattern != undefined)\n-      return fn.call(this, text, pattern);\n-    else\n-      return fn.call(this, text, patterns);\n-  }\n-}\n-\n-// Helper function to make sub-classing a dialect easier\n-Markdown.subclassDialect = function( d ) {\n-  function Block() {};\n-  Block.prototype = d.block;\n-  function Inline() {};\n-  Inline.prototype = d.inline;\n-\n-  return { block: new Block(), inline: new Inline() };\n-}\n-\n-Markdown.buildBlockOrder ( Markdown.dialects.Gruber.block );\n-Markdown.buildInlinePatterns( Markdown.dialects.Gruber.inline );\n-\n-Markdown.dialects.Maruku = Markdown.subclassDialect( Markdown.dialects.Gruber );\n-\n-Markdown.dialects.Maruku.block.document_meta = function document_meta( block, next ) {\n-  // we're only interested in the first block\n-  if ( block.lineNumber > 1 ) return undefined;\n-\n-  // document_meta blocks consist of one or more lines of `Key: Value\\n`\n-  if ( ! block.match( /^(?:\\w+:.*\\n)*\\w+:.*$/ ) ) return undefined;\n-\n-  // make an attribute node if it doesn't exist\n-  if ( !extract_attr( this.tree ) ) {\n-    this.tree.splice( 1, 0, {} );\n-  }\n-\n-  var pairs = block.split( /\\n/ );\n-  for ( p in pairs ) {\n-    var m = pairs[ p ].match( /(\\w+):\\s*(.*)$/ ),\n-        key = m[ 1 ].toLowerCase(),\n-        value = m[ 2 ];\n-\n-    this.tree[ 1 ][ key ] = value;\n-  }\n-\n-  // document_meta produces no content!\n-  return [];\n-}\n-\n-Markdown.dialects.Maruku.block.block_meta = function block_meta( block, next ) {\n-  // check if the last line of the block is an meta hash\n-  var m = block.match( /(^|\\n) {0,3}\\{:\\s*((?:\\\\\\}|[^\\}])*)\\s*\\}$/ );\n-  if ( !m ) return undefined;\n-\n-  // process the meta hash\n-  var attr = process_meta_hash( m[ 2 ] );\n-\n-  // if we matched ^ then we need to apply meta to the previous block\n-  if ( m[ 1 ] === \"\" ) {\n-    var node = this.tree[ this.tree.length - 1 ],\n-        hash = extract_attr( node );\n-\n-    // if the node is a string (rather than JsonML), bail\n-    if ( typeof node === \"string\" ) return undefined;\n-\n-    // create the attribute hash if it doesn't exist\n-    if ( !hash ) {\n-      hash = {};\n-      node.splice( 1, 0, hash );\n-    }\n-\n-    // add the attributes in\n-    for ( a in attr ) {\n-      hash[ a ] = attr[ a ];\n-    }\n-\n-    // return nothing so the meta hash is removed\n-    return [];\n-  }\n-\n-  // pull the meta hash off the block and process what's left\n-  var b = block.replace( /\\n.*$/, \"\" ),\n-      result = this.processBlock( b, [] );\n-\n-  // get or make the attributes hash\n-  var hash = extract_attr( result[ 0 ] );\n-  if ( !hash ) {\n-    hash = {};\n-    result[ 0 ].splice( 1, 0, hash );\n-  }\n-\n-  // attach the attributes to the block\n-  for ( a in attr ) {\n-    hash[ a ] = attr[ a ];\n-  }\n-\n-  return result;\n-}\n-\n-Markdown.dialects.Maruku.block.definition_list = function definition_list( block, next ) {\n-  // one or more terms followed by one or more definitions, in a single block\n-  var tight = /^((?:[^\\s:].*\\n)+):\\s+([^]+)$/,\n-      list = [ \"dl\" ];\n-\n-  // see if we're dealing with a tight or loose block\n-  if ( ( m = block.match( tight ) ) ) {\n-    // pull subsequent tight DL blocks out of `next`\n-    var blocks = [ block ];\n-    while ( next.length && tight.exec( next[ 0 ] ) ) {\n-      blocks.push( next.shift() );\n-    }\n-\n-    for ( var b = 0; b < blocks.length; ++b ) {\n-      var m = blocks[ b ].match( tight ),\n-          terms = m[ 1 ].replace( /\\n$/, \"\" ).split( /\\n/ ),\n-          defns = m[ 2 ].split( /\\n:\\s+/ );\n-\n-      // print( uneval( m ) );\n-\n-      for ( var i = 0; i < terms.length; ++i ) {\n-        list.push( [ \"dt\" ].concat(this.processInline(terms[i])));\n-      }\n-\n-      for ( var i = 0; i < defns.length; ++i ) {\n-        // run inline processing over the definition\n-        list.push( [ \"dd\" ].concat( this.processInline( defns[ i ].replace( /(\\n)\\s+/, \"$1\" ) ) ) );\n-      }\n-    }\n-  }\n-  else {\n-    return undefined;\n-  }\n-\n-  return [ list ];\n-}\n-\n-Markdown.dialects.Maruku.block.html_paragraph = function html_paragraph( block, next ) {\n-  if (block.match(/^<\\w/)) return [[\"RAW\", block.toString()]];\n-}\n-\n-Markdown.dialects.Maruku.inline[ \"{:\" ] = function inline_meta( text, matches, out ) {\n-  if ( !out.length ) {\n-    return [ 2, \"{:\" ];\n-  }\n-\n-  // get the preceeding element\n-  var before = out[ out.length - 1 ];\n-\n-  if ( typeof before === \"string\" ) {\n-    return [ 2, \"{:\" ];\n-  }\n-\n-  // match a meta hash\n-  var m = text.match( /^\\{:\\s*((?:\\\\\\}|[^\\}])*)\\s*\\}/ );\n-\n-  // no match, false alarm\n-  if ( !m ) {\n-    return [ 2, \"{:\" ];\n-  }\n-\n-  // attach the attributes to the preceeding element\n-  var meta = process_meta_hash( m[ 1 ] ),\n-      attr = extract_attr( before );\n-\n-  if ( !attr ) {\n-    attr = {};\n-    before.splice( 1, 0, attr );\n-  }\n-\n-  for ( var k in meta ) {\n-    attr[ k ] = meta[ k ];\n-  }\n-\n-  // cut out the string and replace it with nothing\n-  return [ m[ 0 ].length, \"\" ];\n-}\n-\n-Markdown.buildBlockOrder ( Markdown.dialects.Maruku.block );\n-Markdown.buildInlinePatterns( Markdown.dialects.Maruku.inline );\n-\n-var isArray = expose.isArray = function(obj) {\n-    return (obj instanceof Array || typeof obj === \"array\" || Array.isArray(obj));\n-}\n-\n-function extract_attr( jsonml ) {\n-  return isArray(jsonml)\n-      && jsonml.length > 1\n-      && typeof jsonml[ 1 ] === \"object\"\n-      && !( isArray(jsonml[ 1 ]) )\n-      ? jsonml[ 1 ]\n-      : undefined;\n-}\n-\n-function process_meta_hash( meta_string ) {\n-  var meta = split_meta_hash( meta_string ),\n-      attr = {};\n-\n-  for ( var i = 0; i < meta.length; ++i ) {\n-    // id: #foo\n-    if ( /^#/.test( meta[ i ] ) ) {\n-      attr.id = meta[ i ].substring( 1 );\n-    }\n-    // class: .foo\n-    else if ( /^\\./.test( meta[ i ] ) ) {\n-      // if class already exists, append the new one\n-      if ( attr['class'] ) {\n-        attr['class'] = attr['class'] + meta[ i ].replace( /./, \" \" );\n-      }\n-      else {\n-        attr['class'] = meta[ i ].substring( 1 );\n-      }\n-    }\n-    // attribute: foo=bar\n-    else if ( /=/.test( meta[ i ] ) ) {\n-      var s = meta[ i ].split( /=/ );\n-      attr[ s[ 0 ] ] = s[ 1 ];\n-    }\n-  }\n-\n-  return attr;\n-}\n-\n-function split_meta_hash( meta_string ) {\n-  var meta = meta_string.split( \"\" ),\n-      parts = [ \"\" ],\n-      in_quotes = false;\n-\n-  while ( meta.length ) {\n-    var letter = meta.shift();\n-    switch ( letter ) {\n-      case \" \" :\n-        // if we're in a quoted section, keep it\n-        if ( in_quotes ) {\n-          parts[ parts.length - 1 ] += letter;\n-        }\n-        // otherwise make a new part\n-        else {\n-          parts.push( \"\" );\n-        }\n-        break;\n-      case \"'\" :\n-      case '\"' :\n-        // reverse the quotes and move straight on\n-        in_quotes = !in_quotes;\n-        break;\n-      case \"\\\\\" :\n-        // shift off the next letter to be used straight away.\n-        // it was escaped so we'll keep it whatever it is\n-        letter = meta.shift();\n-      default :\n-        parts[ parts.length - 1 ] += letter;\n-        break;\n-    }\n-  }\n-\n-  return parts;\n-}\n-\n-/**\n- *  renderJsonML( jsonml[, options] ) -> String\n- *  - jsonml (Array): JsonML array to render to XML\n- *  - options (Object): options\n- *\n- *  Converts the given JsonML into well-formed XML.\n- *\n- *  The options currently understood are:\n- *\n- *  - root (Boolean): wether or not the root node should be included in the\n- *    output, or just its children. The default `false` is to not include the\n- *    root itself.\n- */\n-expose.renderJsonML = function( jsonml, options ) {\n-  options = options || {};\n-  // include the root element in the rendered output?\n-  options.root = options.root || false;\n-\n-  var content = [];\n-\n-  if ( options.root ) {\n-    content.push( render_tree( jsonml ) );\n-  }\n-  else {\n-    jsonml.shift(); // get rid of the tag\n-    if ( jsonml.length && typeof jsonml[ 0 ] === \"object\" && !( jsonml[ 0 ] instanceof Array ) ) {\n-      jsonml.shift(); // get rid of the attributes\n-    }\n-\n-    while ( jsonml.length ) {\n-      content.push( render_tree( jsonml.shift() ) );\n-    }\n-  }\n-\n-  return content.join( \"\\n\\n\" );\n-}\n-\n-function escapeHTML( text ) {\n-  return text.replace( /&/g, \"&amp;\" )\n-             .replace( /</g, \"&lt;\" )\n-             .replace( />/g, \"&gt;\" )\n-             .replace( /\"/g, \"&quot;\" )\n-             .replace( /'/g, \"&#39;\" );\n-}\n-\n-function render_tree( jsonml ) {\n-  // basic case\n-  if ( typeof jsonml === \"string\" ) {\n-    return escapeHTML( jsonml );\n-  }\n-\n-  var tag = jsonml.shift(),\n-      attributes = {},\n-      content = [];\n-  if (tag == \"RAW\") return jsonml[0];\n-\n-  if ( jsonml.length && typeof jsonml[ 0 ] === \"object\" && !( jsonml[ 0 ] instanceof Array ) ) {\n-    attributes = jsonml.shift();\n-  }\n-\n-  while ( jsonml.length ) {\n-    content.push( arguments.callee( jsonml.shift() ) );\n-  }\n-\n-  var tag_attrs = \"\";\n-  for ( var a in attributes ) {\n-    tag_attrs += \" \" + a + '=\"' + escapeHTML( attributes[ a ] ) + '\"';\n-  }\n-\n-  // be careful about adding whitespace here for inline elements\n-  return \"<\"+ tag + tag_attrs + \">\" + content.join( \"\" ) + \"</\" + tag + \">\";\n-}\n-\n-function convert_tree_to_html( tree, references, options ) {\n-  options = options || {};\n-\n-  // shallow clone\n-  var jsonml = tree.slice( 0 );\n-\n-  if (typeof options.preprocessTreeNode === \"function\") {\n-      jsonml = options.preprocessTreeNode(jsonml, references);\n-  }\n-\n-  // Clone attributes if they exist\n-  var attrs = extract_attr( jsonml );\n-  if ( attrs ) {\n-    jsonml[ 1 ] = {};\n-    for ( var i in attrs ) {\n-      jsonml[ 1 ][ i ] = attrs[ i ];\n-    }\n-    attrs = jsonml[ 1 ];\n-  }\n-\n-  // basic case\n-  if ( typeof jsonml === \"string\" ) {\n-    return jsonml;\n-  }\n-\n-  // convert this node\n-  switch ( jsonml[ 0 ] ) {\n-    case \"header\":\n-      jsonml[ 0 ] = \"h\" + jsonml[ 1 ].level;\n-      delete jsonml[ 1 ].level;\n-      break;\n-    case \"bulletlist\":\n-      jsonml[ 0 ] = \"ul\";\n-      break;\n-    case \"numberlist\":\n-      jsonml[ 0 ] = \"ol\";\n-      break;\n-    case \"listitem\":\n-      jsonml[ 0 ] = \"li\";\n-      break;\n-    case \"para\":\n-      jsonml[ 0 ] = \"p\";\n-      break;\n-    case \"markdown\":\n-      jsonml[ 0 ] = \"html\";\n-      if ( attrs ) delete attrs.references;\n-      break;\n-    case \"code_block\":\n-      jsonml[ 0 ] = \"pre\";\n-      var i = attrs ? 2 : 1;\n-      var code = [ \"code\" ];\n-      code.push.apply( code, jsonml.splice( i ) );\n-      jsonml[ i ] = code;\n-      break;\n-    case \"inlinecode\":\n-      jsonml[ 0 ] = \"code\";\n-      break;\n-    case \"img\":\n-      jsonml[ 1 ].src = jsonml[ 1 ].href;\n-      delete jsonml[ 1 ].href;\n-      break;\n-    case \"linebreak\":\n-      jsonml[0] = \"br\";\n-    break;\n-    case \"link\":\n-      jsonml[ 0 ] = \"a\";\n-      break;\n-    case \"link_ref\":\n-      jsonml[ 0 ] = \"a\";\n-\n-      // grab this ref and clean up the attribute node\n-      var ref = references[ attrs.ref ];\n-\n-      // if the reference exists, make the link\n-      if ( ref ) {\n-        delete attrs.ref;\n-\n-        // add in the href and title, if present\n-        attrs.href = ref.href;\n-        if ( ref.title ) {\n-          attrs.title = ref.title;\n-        }\n-\n-        // get rid of the unneeded original text\n-        delete attrs.original;\n-      }\n-      // the reference doesn't exist, so revert to plain text\n-      else {\n-        return attrs.original;\n-      }\n-      break;\n-  }\n-\n-  // convert all the children\n-  var i = 1;\n-\n-  // deal with the attribute node, if it exists\n-  if ( attrs ) {\n-    // if there are keys, skip over it\n-    for ( var key in jsonml[ 1 ] ) {\n-      i = 2;\n-    }\n-    // if there aren't, remove it\n-    if ( i === 1 ) {\n-      jsonml.splice( i, 1 );\n-    }\n-  }\n-\n-  for ( ; i < jsonml.length; ++i ) {\n-    jsonml[ i ] = arguments.callee( jsonml[ i ], references, options );\n-  }\n-\n-  return jsonml;\n-}\n-\n-\n-// merges adjacent text nodes into a single node\n-function merge_text_nodes( jsonml ) {\n-  // skip the tag name and attribute hash\n-  var i = extract_attr( jsonml ) ? 2 : 1;\n-\n-  while ( i < jsonml.length ) {\n-    // if it's a string check the next item too\n-    if ( typeof jsonml[ i ] === \"string\" ) {\n-      if ( i + 1 < jsonml.length && typeof jsonml[ i + 1 ] === \"string\" ) {\n-        // merge the second string into the first and remove it\n-        jsonml[ i ] += jsonml.splice( i + 1, 1 )[ 0 ];\n-      }\n-      else {\n-        ++i;\n-      }\n-    }\n-    // if it's not a string recurse\n-    else {\n-      arguments.callee( jsonml[ i ] );\n-      ++i;\n-    }\n-  }\n-}\n-\n-} )( (function() {\n-  if ( typeof exports === \"undefined\" ) {\n-    window.markdown = {};\n-    return window.markdown;\n-  }\n-  else {\n-    return exports;\n-  }\n-} )() );"}, {"sha": "9251e8fee4b559a0403a6e3dbc12ae71a2ec88dd", "filename": "doc/tutorial/mod.md", "status": "removed", "additions": 0, "deletions": 237, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Fmod.md", "raw_url": "https://github.com/rust-lang/rust/raw/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Fmod.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fmod.md?ref=d699db699a07d5bb80d5d08508540b0aba6e1026", "patch": "@@ -1,237 +0,0 @@\n-# Modules and crates\n-\n-The Rust namespace is divided into modules. Each source file starts\n-with its own module.\n-\n-## Local modules\n-\n-The `mod` keyword can be used to open a new, local module. In the\n-example below, `chicken` lives in the module `farm`, so, unless you\n-explicitly import it, you must refer to it by its long name,\n-`farm::chicken`.\n-\n-    mod farm {\n-        fn chicken() -> str { \"cluck cluck\" }\n-        fn cow() -> str { \"mooo\" }\n-    }\n-    fn main() {\n-        std::io::println(farm::chicken());\n-    }\n-\n-Modules can be nested to arbitrary depth.\n-\n-## Crates\n-\n-The unit of independent compilation in Rust is the crate. Libraries\n-tend to be packaged as crates, and your own programs may consist of\n-one or more crates.\n-\n-When compiling a single `.rs` file, the file acts as the whole crate.\n-You can compile it with the `--lib` compiler switch to create a shared\n-library, or without, provided that your file contains a `fn main`\n-somewhere, to create an executable.\n-\n-It is also possible to include multiple files in a crate. For this\n-purpose, you create a `.rc` crate file, which references any number of\n-`.rs` code files. A crate file could look like this:\n-\n-    ## ignore\n-    #[link(name = \"farm\", vers = \"2.5\", author = \"mjh\")];\n-    mod cow;\n-    mod chicken;\n-    mod horse;\n-\n-Compiling this file will cause `rustc` to look for files named\n-`cow.rs`, `chicken.rs`, `horse.rs` in the same directory as the `.rc`\n-file, compile them all together, and, depending on the presence of the\n-`--lib` switch, output a shared library or an executable.\n-\n-The `#[link(...)]` part provides meta information about the module,\n-which other crates can use to load the right module. More about that\n-later.\n-\n-To have a nested directory structure for your source files, you can\n-nest mods in your `.rc` file:\n-\n-    ## ignore\n-    mod poultry {\n-        mod chicken;\n-        mod turkey;\n-    }\n-\n-The compiler will now look for `poultry/chicken.rs` and\n-`poultry/turkey.rs`, and export their content in `poultry::chicken`\n-and `poultry::turkey`. You can also provide a `poultry.rs` to add\n-content to the `poultry` module itself.\n-\n-## Using other crates\n-\n-Having compiled a crate with `--lib`, you can use it in another crate\n-with a `use` directive. We've already seen `use std` in several of the\n-examples, which loads in the [standard library][std].\n-\n-[std]: http://doc.rust-lang.org/doc/std/index/General.html\n-\n-`use` directives can appear in a crate file, or at the top level of a\n-single-file `.rs` crate. They will cause the compiler to search its\n-library search path (which you can extend with `-L` switch) for a Rust\n-crate library with the right name.\n-\n-It is possible to provide more specific information when using an\n-external crate.\n-\n-    ## ignore\n-    use myfarm (name = \"farm\", vers = \"2.7\");\n-\n-When a comma-separated list of name/value pairs is given after `use`,\n-these are matched against the attributes provided in the `link`\n-attribute of the crate file, and a crate is only used when the two\n-match. A `name` value can be given to override the name used to search\n-for the crate. So the above would import the `farm` crate under the\n-local name `myfarm`.\n-\n-Our example crate declared this set of `link` attributes:\n-\n-    ## ignore\n-    #[link(name = \"farm\", vers = \"2.5\", author = \"mjh\")];\n-\n-The version does not match the one provided in the `use` directive, so\n-unless the compiler can find another crate with the right version\n-somewhere, it will complain that no matching crate was found.\n-\n-## The core library\n-\n-A set of basic library routines, mostly related to built-in datatypes\n-and the task system, are always implicitly linked and included in any\n-Rust program, unless the `--no-core` compiler switch is given.\n-\n-This library is document [here][core].\n-\n-[core]: http://doc.rust-lang.org/doc/core/index/General.html\n-\n-## A minimal example\n-\n-Now for something that you can actually compile yourself. We have\n-these two files:\n-\n-    // mylib.rs\n-    #[link(name = \"mylib\", vers = \"1.0\")];\n-    fn world() -> str { \"world\" }\n-\n-    ## ignore\n-    // main.rs\n-    use mylib;\n-    fn main() { std::io::println(\"hello \" + mylib::world()); }\n-\n-Now compile and run like this (adjust to your platform if necessary):\n-\n-    ## notrust\n-    > rustc --lib mylib.rs\n-    > rustc main.rs -L .\n-    > ./main\n-    \"hello world\"\n-\n-## Importing\n-\n-When using identifiers from other modules, it can get tiresome to\n-qualify them with the full module path every time (especially when\n-that path is several modules deep). Rust allows you to import\n-identifiers at the top of a file, module, or block.\n-\n-    use std;\n-    import std::io::println;\n-    fn main() {\n-        println(\"that was easy\");\n-    }\n-\n-It is also possible to import just the name of a module (`import\n-std::io;`, then use `io::println`), to import all identifiers exported\n-by a given module (`import std::io::*`), or to import a specific set\n-of identifiers (`import math::{min, max, pi}`).\n-\n-You can rename an identifier when importing using the `=` operator:\n-\n-    import prnt = std::io::println;\n-\n-## Exporting\n-\n-By default, a module exports everything that it defines. This can be\n-restricted with `export` directives at the top of the module or file.\n-\n-    mod enc {\n-        export encrypt, decrypt;\n-        const super_secret_number: int = 10;\n-        fn encrypt(n: int) -> int { n + super_secret_number }\n-        fn decrypt(n: int) -> int { n - super_secret_number }\n-    }\n-\n-This defines a rock-solid encryption algorithm. Code outside of the\n-module can refer to the `enc::encrypt` and `enc::decrypt` identifiers\n-just fine, but it does not have access to `enc::super_secret_number`.\n-\n-## Namespaces\n-\n-Rust uses three different namespaces. One for modules, one for types,\n-and one for values. This means that this code is valid:\n-\n-    mod buffalo {\n-        type buffalo = int;\n-        fn buffalo(buffalo: buffalo) -> buffalo { buffalo }\n-    }\n-    fn main() {\n-        let buffalo: buffalo::buffalo = 1;\n-        buffalo::buffalo(buffalo::buffalo(buffalo));\n-    }\n-\n-You don't want to write things like that, but it *is* very practical\n-to not have to worry about name clashes between types, values, and\n-modules. This allows us to have a module `core::str`, for example, even\n-though `str` is a built-in type name.\n-\n-## Resolution\n-\n-The resolution process in Rust simply goes up the chain of contexts,\n-looking for the name in each context. Nested functions and modules\n-create new contexts inside their parent function or module. A file\n-that's part of a bigger crate will have that crate's context as parent\n-context.\n-\n-Identifiers can shadow each others. In this program, `x` is of type\n-`int`:\n-\n-    type t = str;\n-    fn main() {\n-        type t = int;\n-        let x: t;\n-    }\n-\n-An `import` directive will only import into the namespaces for which\n-identifiers are actually found. Consider this example:\n-\n-    type bar = uint;\n-    mod foo { fn bar() {} }\n-    mod baz {\n-        import foo::bar;\n-        const x: bar = 20u;\n-    }\n-\n-When resolving the type name `bar` in the `const` definition, the\n-resolver will first look at the module context for `baz`. This has an\n-import named `bar`, but that's a function, not a type, So it continues\n-to the top level and finds a type named `bar` defined there.\n-\n-Normally, multiple definitions of the same identifier in a scope are\n-disallowed. Local variables defined with `let` are an exception to\n-this\u2014multiple `let` directives can redefine the same variable in a\n-single scope. When resolving the name of such a variable, the most\n-recent definition is used.\n-\n-    fn main() {\n-        let x = 10;\n-        let x = x + 10;\n-        assert x == 20;\n-    }\n-\n-This makes it possible to rebind a variable without actually mutating\n-it, which is mostly useful for destructuring (which can rebind, but\n-not assign)."}, {"sha": "9f751663901b94dbd4318c506a946d660469aa15", "filename": "doc/tutorial/order", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Forder", "raw_url": "https://github.com/rust-lang/rust/raw/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Forder", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Forder?ref=d699db699a07d5bb80d5d08508540b0aba6e1026", "patch": "@@ -1,13 +0,0 @@\n-intro\n-setup\n-syntax\n-control\n-func\n-data\n-args\n-generic\n-mod\n-iface\n-ffi\n-task\n-test"}, {"sha": "f85052961a05b11ac706ffecb5d5b0ab37d0cd43", "filename": "doc/tutorial/setup.md", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Fsetup.md", "raw_url": "https://github.com/rust-lang/rust/raw/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Fsetup.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fsetup.md?ref=d699db699a07d5bb80d5d08508540b0aba6e1026", "patch": "@@ -1,56 +0,0 @@\n-# Getting started\n-\n-## Installation\n-\n-FIXME Fill this in when the installation package is finished.\n-\n-## Compiling your first program\n-\n-Rust program files are, by convention, given the extension `.rs`. Say\n-we have a file `hello.rs` containing this program:\n-\n-    use std;\n-    fn main(args: [str]) {\n-        std::io::println(\"hello world from '\" + args[0] + \"'!\");\n-    }\n-\n-If the Rust compiler was installed successfully, running `rustc\n-hello.rs` will produce a binary called `hello` (or `hello.exe`).\n-\n-If you modify the program to make it invalid (for example, remove the\n-`use std` line), and then compile it, you'll see an error message like\n-this:\n-\n-    ## notrust\n-    hello.rs:2:4: 2:20 error: unresolved modulename: std\n-    hello.rs:2     std::io::println(\"hello world!\");\n-                   ^~~~~~~~~~~~~~~~\n-\n-The Rust compiler tries to provide useful information when it runs\n-into an error.\n-\n-## Anatomy of a Rust program\n-\n-In its simplest form, a Rust program is simply a `.rs` file with some\n-types and functions defined in it. If it has a `main` function, it can\n-be compiled to an executable. Rust does not allow code that's not a\n-declaration to appear at the top level of the file\u2014all statements must\n-live inside a function.\n-\n-Rust programs can also be compiled as libraries, and included in other\n-programs. The `use std` directive that appears at the top of a lot of\n-examples imports the [standard library][std]. This is described in more\n-detail [later on](mod.html).\n-\n-[std]: http://doc.rust-lang.org/doc/std/index/General.html\n-\n-## Editing Rust code\n-\n-There are Vim highlighting and indentation scrips in the Rust source\n-distribution under `src/etc/vim/`, and an emacs mode under\n-`src/etc/emacs/`.\n-\n-[rust-mode]: https://github.com/marijnh/rust-mode\n-\n-Other editors are not provided for yet. If you end up writing a Rust\n-mode for your favorite editor, let us know so that we can link to it."}, {"sha": "b0e3f00219119684bab040a524f7413958ef7578", "filename": "doc/tutorial/syntax.md", "status": "removed", "additions": 0, "deletions": 349, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Fsyntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Fsyntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fsyntax.md?ref=d699db699a07d5bb80d5d08508540b0aba6e1026", "patch": "@@ -1,349 +0,0 @@\n-# Syntax Basics\n-\n-## Braces\n-\n-Assuming you've programmed in any C-family language (C++, Java,\n-JavaScript, C#, or PHP), Rust will feel familiar. The main surface\n-difference to be aware of is that the bodies of `if` statements and of\n-loops *have* to be wrapped in brackets. Single-statement, bracket-less\n-bodies are not allowed.\n-\n-If the verbosity of that bothers you, consider the fact that this\n-allows you to omit the parentheses around the condition in `if`,\n-`while`, and similar constructs. This will save you two characters\n-every time. As a bonus, you no longer have to spend any mental energy\n-on deciding whether you need to add braces or not, or on adding them\n-after the fact when adding a statement to an `if` branch.\n-\n-Accounting for these differences, the surface syntax of Rust\n-statements and expressions is C-like. Function calls are written\n-`myfunc(arg1, arg2)`, operators have mostly the same name and\n-precedence that they have in C, comments look the same, and constructs\n-like `if` and `while` are available:\n-\n-    # fn call_a_function(_a: int) {}\n-    fn main() {\n-        if 1 < 2 {\n-            while false { call_a_function(10 * 4); }\n-        } else if 4 < 3 || 3 < 4 {\n-            // Comments are C++-style too\n-        } else {\n-            /* Multi-line comment syntax */\n-        }\n-    }\n-\n-## Expression syntax\n-\n-Though it isn't apparent in all code, there is a fundamental\n-difference between Rust's syntax and the predecessors in this family\n-of languages. A lot of thing that are statements in C are expressions\n-in Rust. This allows for useless things like this (which passes\n-nil\u2014the void type\u2014to a function):\n-\n-    # fn a_function(_a: ()) {}\n-    a_function(while false {});\n-\n-But also useful things like this:\n-\n-    # fn the_stars_align() -> bool { false }\n-    # fn something_else() -> bool { true }\n-    let x = if the_stars_align() { 4 }\n-            else if something_else() { 3 }\n-            else { 0 };\n-\n-This piece of code will bind the variable `x` to a value depending on\n-the conditions. Note the condition bodies, which look like `{\n-expression }`. The lack of a semicolon after the last statement in a\n-braced block gives the whole block the value of that last expression.\n-If the branches of the `if` had looked like `{ 4; }`, the above\n-example would simply assign nil (void) to `x`. But without the\n-semicolon, each branch has a different value, and `x` gets the value\n-of the branch that was taken.\n-\n-This also works for function bodies. This function returns a boolean:\n-\n-    fn is_four(x: int) -> bool { x == 4 }\n-\n-In short, everything that's not a declaration (`let` for variables,\n-`fn` for functions, etcetera) is an expression.\n-\n-If all those things are expressions, you might conclude that you have\n-to add a terminating semicolon after *every* statement, even ones that\n-are not traditionally terminated with a semicolon in C (like `while`).\n-That is not the case, though. Expressions that end in a block only\n-need a semicolon if that block contains a trailing expression. `while`\n-loops do not allow trailing expressions, and `if` statements tend to\n-only have a trailing expression when you want to use their value for\n-something\u2014in which case you'll have embedded it in a bigger statement,\n-like the `let x = ...` example above.\n-\n-## Identifiers\n-\n-Rust identifiers must start with an alphabetic character or an\n-underscore, and after that may contain any alphanumeric character, and\n-more underscores.\n-\n-NOTE: The parser doesn't currently recognize non-ascii alphabetic\n-characters. This is a bug that will eventually be fixed.\n-\n-The double-colon (`::`) is used as a module separator, so\n-`std::io::println` means 'the thing named `println` in the module\n-named `io` in the module named `std`'.\n-\n-Rust will normally emit warning about unused variables. These can be\n-suppressed by using a variable name that starts with an underscore.\n-\n-    fn this_warns(x: int) {}\n-    fn this_doesnt(_x: int) {}\n-\n-## Variable declaration\n-\n-The `let` keyword, as we've seen, introduces a local variable. Global\n-constants can be defined with `const`:\n-\n-    use std;\n-    const repeat: uint = 5u;\n-    fn main() {\n-        let count = 0u;\n-        while count < repeat {\n-            std::io::println(\"Hi!\");\n-            count += 1u;\n-        }\n-    }\n-\n-## Types\n-\n-The `-> bool` in the `is_four` example is the way a function's return\n-type is written. For functions that do not return a meaningful value\n-(these conceptually return nil in Rust), you can optionally say `->\n-()` (`()` is how nil is written), but usually the return annotation is\n-simply left off, as in the `fn main() { ... }` examples we've seen\n-earlier.\n-\n-Every argument to a function must have its type declared (for example,\n-`x: int`). Inside the function, type inference will be able to\n-automatically deduce the type of most locals (generic functions, which\n-we'll come back to later, will occasionally need additional\n-annotation). Locals can be written either with or without a type\n-annotation:\n-\n-    // The type of this vector will be inferred based on its use.\n-    let x = [];\n-    # x = [3];\n-    // Explicitly say this is a vector of integers.\n-    let y: [int] = [];\n-\n-The basic types are written like this:\n-\n-`()`\n-: Nil, the type that has only a single value.\n-\n-`bool`\n-: Boolean type, with values `true` and `false`.\n-\n-`int`\n-: A machine-pointer-sized integer.\n-\n-`uint`\n-: A machine-pointer-sized unsigned integer.\n-\n-`i8`, `i16`, `i32`, `i64`\n-: Signed integers with a specific size (in bits).\n-\n-`u8`, `u16`, `u32`, `u64`\n-: Unsigned integers with a specific size.\n-\n-`f32`, `f64`\n-: Floating-point types.\n-\n-`float`\n-: The largest floating-point type efficiently supported on the target machine.\n-\n-`char`\n-: A character is a 32-bit Unicode code point.\n-\n-`str`\n-: String type. A string contains a utf-8 encoded sequence of characters.\n-\n-These can be combined in composite types, which will be described in\n-more detail later on (the `T`s here stand for any other type):\n-\n-`[T]`\n-: Vector type.\n-\n-`[mutable T]`\n-: Mutable vector type.\n-\n-`(T1, T2)`\n-: Tuple type. Any arity above 1 is supported.\n-\n-`{field1: T1, field2: T2}`\n-: Record type.\n-\n-`fn(arg1: T1, arg2: T2) -> T3`, `lambda()`, `block()`\n-: Function types.\n-\n-`@T`, `~T`, `*T`\n-: Pointer types.\n-\n-Types can be given names with `type` declarations:\n-\n-    type monster_size = uint;\n-\n-This will provide a synonym, `monster_size`, for unsigned integers. It\n-will not actually create a new type\u2014`monster_size` and `uint` can be\n-used interchangeably, and using one where the other is expected is not\n-a type error. Read about [single-variant enums][sve] further on if you\n-need to create a type name that's not just a synonym.\n-\n-[sve]: data.html#single_variant_enum\n-\n-## Literals\n-\n-Integers can be written in decimal (`144`), hexadecimal (`0x90`), and\n-binary (`0b10010000`) base. Without suffix, an integer literal is\n-considered to be of type `int`. Add a `u` (`144u`) to make it a `uint`\n-instead. Literals of the fixed-size integer types can be created by\n-the literal with the type name (`255u8`, `50i64`, etc).\n-\n-Note that, in Rust, no implicit conversion between integer types\n-happens. If you are adding one to a variable of type `uint`, you must\n-type `v += 1u`\u2014saying `+= 1` will give you a type error.\n-\n-Floating point numbers are written `0.0`, `1e6`, or `2.1e-4`. Without\n-suffix, the literal is assumed to be of type `float`. Suffixes `f32`\n-and `f64` can be used to create literals of a specific type. The\n-suffix `f` can be used to write `float` literals without a dot or\n-exponent: `3f`.\n-\n-The nil literal is written just like the type: `()`. The keywords\n-`true` and `false` produce the boolean literals.\n-\n-Character literals are written between single quotes, as in `'x'`. You\n-may put non-ascii characters between single quotes (your source files\n-should be encoded as utf-8). Rust understands a number of\n-character escapes, using the backslash character:\n-\n-`\\n`\n-: A newline (unicode character 32).\n-\n-`\\r`\n-: A carriage return (13).\n-\n-`\\t`\n-: A tab character (9).\n-\n-`\\\\`, `\\'`, `\\\"`\n-: Simply escapes the following character.\n-\n-`\\xHH`, `\\uHHHH`, `\\UHHHHHHHH`\n-: Unicode escapes, where the `H` characters are the hexadecimal digits that form the character code.\n-\n-String literals allow the same escape sequences. They are written\n-between double quotes (`\"hello\"`). Rust strings may contain newlines.\n-When a newline is preceded by a backslash, it, and all white space\n-following it, will not appear in the resulting string literal. So\n-this is equivalent to `\"abc\"`:\n-\n-    let s = \"a\\\n-             b\\\n-             c\";\n-\n-## Operators\n-\n-Rust's set of operators contains very few surprises. The main\n-difference with C is that `++` and `--` are missing, and that the\n-logical binary operators have higher precedence\u2014in C, `x & 2 > 0`\n-comes out as `x & (2 > 0)`, in Rust, it means `(x & 2) > 0`, which is\n-more likely to be what you expect (unless you are a C veteran).\n-\n-Thus, binary arithmetic is done with `*`, `/`, `%`, `+`, and `-`\n-(multiply, divide, remainder, plus, minus). `-` is also a unary prefix\n-operator (there are no unary postfix operators in Rust) that does\n-negation.\n-\n-Binary shifting is done with `>>` (shift right), `>>>` (arithmetic\n-shift right), and `<<` (shift left). Logical bitwise operators are\n-`&`, `|`, and `^` (and, or, and exclusive or), and unary `!` for\n-bitwise negation (or boolean negation when applied to a boolean\n-value).\n-\n-The comparison operators are the traditional `==`, `!=`, `<`, `>`,\n-`<=`, and `>=`. Short-circuiting (lazy) boolean operators are written\n-`&&` (and) and `||` (or).\n-\n-Rust has a ternary conditional operator `?:`, as in:\n-\n-    let badness = 12;\n-    let message = badness < 10 ? \"error\" : \"FATAL ERROR\";\n-\n-For type casting, Rust uses the binary `as` operator, which has a\n-precedence between the bitwise combination operators (`&`, `|`, `^`)\n-and the comparison operators. It takes an expression on the left side,\n-and a type on the right side, and will, if a meaningful conversion\n-exists, convert the result of the expression to the given type.\n-\n-    let x: float = 4.0;\n-    let y: uint = x as uint;\n-    assert y == 4u;\n-\n-## Attributes\n-\n-<a name=\"conditional\"></a>\n-\n-Every definition can be annotated with attributes. Attributes are meta\n-information that can serve a variety of purposes. One of those is\n-conditional compilation:\n-\n-    #[cfg(target_os = \"win32\")]\n-    fn register_win_service() { /* ... */ }\n-\n-This will cause the function to vanish without a trace during\n-compilation on a non-Windows platform, much like `#ifdef` in C (it\n-allows `cfg(flag=value)` and `cfg(flag)` forms, where the second\n-simply checks whether the configuration flag is defined at all). Flags\n-for `target_os` and `target_arch` are set by the compiler. It is\n-possible to set additional flags with the `--cfg` command-line option.\n-\n-Attributes are always wrapped in hash-braces (`#[attr]`). Inside the\n-braces, a small minilanguage is supported, whose interpretation\n-depends on the attribute that's being used. The simplest form is a\n-plain name (as in `#[test]`, which is used by the [built-in test\n-framework](test.html '')). A name-value pair can be provided using an `=`\n-character followed by a literal (as in `#[license = \"BSD\"]`, which is\n-a valid way to annotate a Rust program as being released under a\n-BSD-style license). Finally, you can have a name followed by a\n-comma-separated list of nested attributes, as in the `cfg` example\n-above, or in this [crate](mod.html) metadata declaration:\n-\n-    ## ignore\n-    #[link(name = \"std\",\n-           vers = \"0.1\",\n-           url = \"http://rust-lang.org/src/std\")];\n-\n-An attribute without a semicolon following it applies to the\n-definition that follows it. When terminated with a semicolon, it\n-applies to the module or crate in which it appears.\n-\n-## Syntax extensions\n-\n-There are plans to support user-defined syntax (macros) in Rust. This\n-currently only exists in very limited form.\n-\n-The compiler defines a few built-in syntax extensions. The most useful\n-one is `#fmt`, a printf-style text formatting macro that is expanded\n-at compile time.\n-\n-    std::io::println(#fmt(\"%s is %d\", \"the answer\", 42));\n-\n-`#fmt` supports most of the directives that [printf][pf] supports, but\n-will give you a compile-time error when the types of the directives\n-don't match the types of the arguments.\n-\n-[pf]: http://en.cppreference.com/w/cpp/io/c/fprintf\n-\n-All syntax extensions look like `#word`. Another built-in one is\n-`#env`, which will look up its argument as an environment variable at\n-compile-time.\n-\n-    std::io::println(#env(\"PATH\"));"}, {"sha": "21cafe91f9564142532fc3c966f01c64204b83f7", "filename": "doc/tutorial/task.md", "status": "removed", "additions": 0, "deletions": 154, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Ftask.md", "raw_url": "https://github.com/rust-lang/rust/raw/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Ftask.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Ftask.md?ref=d699db699a07d5bb80d5d08508540b0aba6e1026", "patch": "@@ -1,154 +0,0 @@\n-# Tasks\n-\n-Rust supports a system of lightweight tasks, similar to what is found\n-in Erlang or other actor systems. Rust tasks communicate via messages\n-and do not share data. However, it is possible to send data without\n-copying it by making use of [unique boxes][uniques], which allow the\n-sending task to release ownership of a value, so that the receiving\n-task can keep on using it.\n-\n-[uniques]: data.html#unique-box\n-\n-NOTE: As Rust evolves, we expect the Task API to grow and change\n-somewhat.  The tutorial documents the API as it exists today.\n-\n-## Spawning a task\n-\n-Spawning a task is done using the various spawn functions in the\n-module `task`.  Let's begin with the simplest one, `task::spawn()`:\n-\n-    let some_value = 22;\n-    let child_task = task::spawn {||\n-        std::io::println(\"This executes in the child task.\");\n-        std::io::println(#fmt(\"%d\", some_value));\n-    };\n-\n-The argument to `task::spawn()` is a [unique\n-closure](func.html#unique) of type `fn~()`, meaning that it takes no\n-arguments and generates no return value. The effect of `task::spawn()`\n-is to fire up a child task that will execute the closure in parallel\n-with the creator. The result is a task id, here stored into the\n-variable `child_task`.\n-\n-## Ports and channels\n-\n-Now that we have spawned a child task, it would be nice if we could\n-communicate with it.  This is done by creating a *port* with an\n-associated *channel*.  A port is simply a location to receive messages\n-of a particular type.  A channel is used to send messages to a port.\n-For example, imagine we wish to perform two expensive computations\n-in parallel.  We might write something like:\n-\n-    # fn some_expensive_computation() -> int { 42 }\n-    # fn some_other_expensive_computation() {}\n-    let port = comm::port::<int>();\n-    let chan = comm::chan::<int>(port);\n-    let child_task = task::spawn {||\n-        let result = some_expensive_computation();\n-        comm::send(chan, result);\n-    };\n-    some_other_expensive_computation();\n-    let result = comm::recv(port);\n-\n-Let's walk through this code line-by-line.  The first line creates a\n-port for receiving integers:\n-\n-    let port = comm::port::<int>();\n-    \n-This port is where we will receive the message from the child task\n-once it is complete.  The second line creates a channel for sending\n-integers to the port `port`:\n-\n-    # let port = comm::port::<int>();\n-    let chan = comm::chan::<int>(port);\n-\n-The channel will be used by the child to send a message to the port.\n-The next statement actually spawns the child:\n-\n-    # fn some_expensive_computation() -> int { 42 }\n-    # let port = comm::port::<int>();\n-    # let chan = comm::chan::<int>(port);\n-    let child_task = task::spawn {||\n-        let result = some_expensive_computation();\n-        comm::send(chan, result);\n-    };\n-\n-This child will perform the expensive computation send the result\n-over the channel.  Finally, the parent continues by performing\n-some other expensive computation and then waiting for the child's result\n-to arrive on the port:\n-\n-    # fn some_other_expensive_computation() {}\n-    # let port = comm::port::<int>();\n-    some_other_expensive_computation();\n-    let result = comm::recv(port);\n-\n-## Creating a task with a bi-directional communication path\n-\n-A very common thing to do is to spawn a child task where the parent\n-and child both need to exchange messages with each other. The function\n-`task::spawn_connected()` supports this pattern. We'll look briefly at\n-how it is used.\n-\n-To see how `spawn_connected()` works, we will create a child task\n-which receives `uint` messages, converts them to a string, and sends\n-the string in response.  The child terminates when `0` is received.\n-Here is the function which implements the child task:\n-\n-    fn stringifier(from_par: comm::port<uint>,\n-                   to_par: comm::chan<str>) {\n-        let value: uint;\n-        do {\n-            value = comm::recv(from_par);\n-            comm::send(to_par, uint::to_str(value, 10u));\n-        } while value != 0u;\n-    }\n-    \n-You can see that the function takes two parameters.  The first is a\n-port used to receive messages from the parent, and the second is a\n-channel used to send messages to the parent.  The body itself simply\n-loops, reading from the `from_par` port and then sending its response\n-to the `to_par` channel.  The actual response itself is simply the\n-strified version of the received value, `uint::to_str(value)`.\n-\n-Here is the code for the parent task:\n-    \n-    # fn stringifier(from_par: comm::port<uint>,\n-    #                to_par: comm::chan<str>) {}\n-    fn main() {\n-        let t = task::spawn_connected(stringifier);\n-        comm::send(t.to_child, 22u);\n-        assert comm::recv(t.from_child) == \"22\";\n-        comm::send(t.to_child, 23u);\n-        assert comm::recv(t.from_child) == \"23\";\n-        comm::send(t.to_child, 0u);\n-        assert comm::recv(t.from_child) == \"0\";\n-    }\n-\n-The call to `spawn_connected()` on the first line will instantiate the\n-various ports and channels and startup the child task.  The returned\n-value, `t`, is a record of type `task::connected_task<uint,str>`.  In\n-addition to the task id of the child, this record defines two fields,\n-`from_child` and `to_child`, which contain the port and channel\n-respectively for communicating with the child.  Those fields are used\n-here to send and receive three messages from the child task.\n-\n-## Joining a task\n-\n-The function `spawn_joinable()` is used to spawn a task that can later\n-be joined. This is implemented by having the child task send a message\n-when it has completed (either successfully or by failing). Therefore,\n-`spawn_joinable()` returns a structure containing both the task ID and\n-the port where this message will be sent---this structure type is\n-called `task::joinable_task`. The structure can be passed to\n-`task::join()`, which simply blocks on the port, waiting to receive\n-the message from the child task.\n-\n-## The supervisor relationship\n-\n-By default, failures in Rust propagate upward through the task tree.\n-We say that each task is supervised by its parent, meaning that if the\n-task fails, that failure is propagated to the parent task, which will\n-fail sometime later.  This propagation can be disabled by using the\n-function `task::unsupervise()`, which disables error propagation from\n-the current task to its parent."}, {"sha": "6adfbdcca96e28106a576e7092f50d1882838ea8", "filename": "doc/tutorial/test.md", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Ftest.md", "raw_url": "https://github.com/rust-lang/rust/raw/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Ftest.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Ftest.md?ref=d699db699a07d5bb80d5d08508540b0aba6e1026", "patch": "@@ -1,70 +0,0 @@\n-# Testing\n-\n-The Rust language has a facility for testing built into the language.\n-Tests can be interspersed with other code, and annotated with the\n-`#[test]` attribute.\n-\n-    use std;\n-    \n-    fn twice(x: int) -> int { x + x }\n-    \n-    #[test]\n-    fn test_twice() {\n-        let i = -100;\n-        while i < 100 {\n-            assert twice(i) == 2 * i;\n-            i += 1;\n-        }\n-    }\n-\n-When you compile the program normally, the `test_twice` function will\n-not be included. To compile and run such tests, compile with the\n-`--test` flag, and then run the result:\n-\n-    ## notrust\n-    > rustc --test twice.rs\n-    > ./twice\n-    running 1 tests\n-    test test_twice ... ok\n-    result: ok. 1 passed; 0 failed; 0 ignored\n-\n-Or, if we change the file to fail, for example by replacing `x + x`\n-with `x + 1`:\n-\n-    ## notrust\n-    running 1 tests\n-    test test_twice ... FAILED\n-    failures:\n-        test_twice\n-    result: FAILED. 0 passed; 1 failed; 0 ignored\n-\n-You can pass a command-line argument to a program compiled with\n-`--test` to run only the tests whose name matches the given string. If\n-we had, for example, test functions `test_twice`, `test_once_1`, and\n-`test_once_2`, running our program with `./twice test_once` would run\n-the latter two, and running it with `./twice test_once_2` would run\n-only the last.\n-\n-To indicate that a test is supposed to fail instead of pass, you can\n-give it a `#[should_fail]` attribute.\n-\n-    use std;\n-    \n-    fn divide(a: float, b: float) -> float {\n-        if b == 0f { fail; }\n-        a / b\n-    }\n-    \n-    #[test]\n-    #[should_fail]\n-    fn divide_by_zero() { divide(1f, 0f); }\n-\n-To disable a test completely, add an `#[ignore]` attribute. Running a\n-test runner (the program compiled with `--test`) with an `--ignored`\n-command-line flag will cause it to also run the tests labelled as\n-ignored.\n-\n-A program compiled as a test runner will have the configuration flag\n-`test` defined, so that you can add code that won't be included in a\n-normal compile with the `#[cfg(test)]` attribute (see [conditional\n-compilation](syntax.md#conditional))."}, {"sha": "aff4f66f3863563a888ae303a5e2045f22c8cc7c", "filename": "doc/tutorial/web/default.css", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Fweb%2Fdefault.css", "raw_url": "https://github.com/rust-lang/rust/raw/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Fweb%2Fdefault.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fweb%2Fdefault.css?ref=d699db699a07d5bb80d5d08508540b0aba6e1026", "patch": "@@ -1,19 +0,0 @@\n-.cm-s-default span.cm-keyword {color: #708;}\n-.cm-s-default span.cm-atom {color: #219;}\n-.cm-s-default span.cm-number {color: #164;}\n-.cm-s-default span.cm-def {color: #00f;}\n-.cm-s-default span.cm-variable {color: black;}\n-.cm-s-default span.cm-variable-2 {color: #05a;}\n-.cm-s-default span.cm-variable-3 {color: #085;}\n-.cm-s-default span.cm-property {color: black;}\n-.cm-s-default span.cm-operator {color: black;}\n-.cm-s-default span.cm-comment {color: #a50;}\n-.cm-s-default span.cm-string {color: #a11;}\n-.cm-s-default span.cm-string-2 {color: #f50;}\n-.cm-s-default span.cm-meta {color: #555;}\n-.cm-s-default span.cm-error {color: #f00;}\n-.cm-s-default span.cm-qualifier {color: #555;}\n-.cm-s-default span.cm-builtin {color: #30a;}\n-.cm-s-default span.cm-bracket {color: #cc7;}\n-.cm-s-default span.cm-tag {color: #170;}\n-.cm-s-default span.cm-attribute {color: #00c;}"}, {"sha": "01f8523819d59fe99f8462ff6639c69d229c6d04", "filename": "doc/tutorial/web/style.css", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Fweb%2Fstyle.css", "raw_url": "https://github.com/rust-lang/rust/raw/d699db699a07d5bb80d5d08508540b0aba6e1026/doc%2Ftutorial%2Fweb%2Fstyle.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fweb%2Fstyle.css?ref=d699db699a07d5bb80d5d08508540b0aba6e1026", "patch": "@@ -1,31 +0,0 @@\n-body {\n-  padding: 1em;\n-  margin: 0;\n-  font-family: \"Helvetica Neue\", Helvetica, sans-serif;\n-}\n-\n-#content {\n-  padding: 1em 6em;\n-  max-width: 50em;\n-}\n-\n-h1 { font-size: 22pt; }\n-h2 { font-size: 17pt; }\n-h3 { font-size: 14pt; }\n-\n-pre {\n-  margin: 1.1em 0;\n-  padding: .4em .4em .4em 1em;\n-  font-size: 120%;\n-}\n-\n-p.head {\n-  font-size: 80%;\n-  font-style: italic;\n-  text-align: right;\n-}\n-\n-a, a:visited, a:link {\n-  text-decoration: none;\n-  color: #00438a;\n-}"}, {"sha": "e565863f107b43aa22d362d0fbf484a4089a78c9", "filename": "mk/docs.mk", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a4b77758f0e1b6b409e874e739fe7cf4609651ee/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/a4b77758f0e1b6b409e874e739fe7cf4609651ee/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=a4b77758f0e1b6b409e874e739fe7cf4609651ee", "patch": "@@ -12,7 +12,7 @@ ifeq ($(CFG_PANDOC),)\n   $(info cfg: no pandoc found, omitting doc/rust.pdf)\n else\n \n-DOCS += doc/rust.html\n+DOCS += doc/rust.html doc/rust.css\n doc/rust.html: rust.md doc/version.md doc/keywords.md\n \t@$(call E, pandoc: $@)\n \t$(Q)$(CFG_PANDOC) \\\n@@ -57,6 +57,26 @@ doc/rust.pdf: doc/rust.tex\n       endif\n     endif\n   endif\n+\n+######################################################################\n+# Node (tutorial related)\n+######################################################################\n+  ifeq ($(CFG_NODE),)\n+    $(info cfg: no node found, omitting doc/tutorial.html)\n+  else\n+\n+DOCS += doc/tutorial.html\n+doc/tutorial.html: $(S)doc/tutorial.md\n+\t@$(call E, cp: $(S)doc/rust.css)\n+\t-$(Q)cp -a $(S)doc/rust.css doc/ 2> /dev/null\n+\t@$(call E, pandoc: $@)\n+\t$(Q)$(CFG_NODE) $(S)doc/prep.js --highlight $< | \\\n+          $(CFG_PANDOC) --standalone --toc \\\n+           --section-divs --number-sections \\\n+           --from=markdown --to=html --css=rust.css \\\n+           --output=$@\n+\n+  endif\n endif\n \n \n@@ -79,25 +99,6 @@ verify-grammar: doc/rust.g\n endif\n \n \n-######################################################################\n-# Node (tutorial related)\n-######################################################################\n-ifeq ($(CFG_NODE),)\n-  $(info cfg: no node found, omitting doc/tutorial/web)\n-else\n-\n-DOCS += doc/tutorial/web/index.html\n-doc/tutorial/web/index.html: \\\n-        $(wildcard $(S)doc/tutorial/*.md)\n-\t@$(call E, cp: $(S)doc/tutorial)\n-\t-$(Q)cp -a $(S)doc/tutorial doc/ 2> /dev/null\n-\t@$(call E, node: build.js)\n-\t$(Q)cd doc/tutorial && $(CFG_NODE) build.js\n-\n-endif\n-\n-\n-\n ######################################################################\n # Naturaldocs (library reference related)\n ######################################################################"}]}