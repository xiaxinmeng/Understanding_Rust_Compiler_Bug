{"sha": "e22873d91206e11349da713017bd67d43d8d535d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyMjg3M2Q5MTIwNmUxMTM0OWRhNzEzMDE3YmQ2N2Q0M2Q4ZDUzNWQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-04-18T20:38:15Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-04-23T08:11:54Z"}, "message": "rustc: make the const-eval cache polymorphic.", "tree": {"sha": "5fd980c06f6c9a31a8da4b34c7599ac3a51b17bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5fd980c06f6c9a31a8da4b34c7599ac3a51b17bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e22873d91206e11349da713017bd67d43d8d535d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e22873d91206e11349da713017bd67d43d8d535d", "html_url": "https://github.com/rust-lang/rust/commit/e22873d91206e11349da713017bd67d43d8d535d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e22873d91206e11349da713017bd67d43d8d535d/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a94124488ae0dba1a8a4552a4724cddf9d266e2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a94124488ae0dba1a8a4552a4724cddf9d266e2f", "html_url": "https://github.com/rust-lang/rust/commit/a94124488ae0dba1a8a4552a4724cddf9d266e2f"}], "stats": {"total": 299, "additions": 150, "deletions": 149}, "files": [{"sha": "9a6574385222a9347841bd8ecc4093fc9ef984e9", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e22873d91206e11349da713017bd67d43d8d535d/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e22873d91206e11349da713017bd67d43d8d535d/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=e22873d91206e11349da713017bd67d43d8d535d", "patch": "@@ -97,7 +97,7 @@ pub enum DepNode<D: Clone + Debug> {\n     TypeckBodiesKrate,\n     TypeckTables(D),\n     UsedTraitImports(D),\n-    MonomorphicConstEval(D),\n+    ConstEval(D),\n \n     // The set of impls for a given trait. Ultimately, it would be\n     // nice to get more fine-grained here (e.g., to include a\n@@ -233,7 +233,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             InherentImpls(ref d) => op(d).map(InherentImpls),\n             TypeckTables(ref d) => op(d).map(TypeckTables),\n             UsedTraitImports(ref d) => op(d).map(UsedTraitImports),\n-            MonomorphicConstEval(ref d) => op(d).map(MonomorphicConstEval),\n+            ConstEval(ref d) => op(d).map(ConstEval),\n             TraitImpls(ref d) => op(d).map(TraitImpls),\n             TraitItems(ref d) => op(d).map(TraitItems),\n             ReprHints(ref d) => op(d).map(ReprHints),"}, {"sha": "50f34723d5019a3d6e92ca780a61f62ebd0eff9d", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e22873d91206e11349da713017bd67d43d8d535d/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e22873d91206e11349da713017bd67d43d8d535d/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=e22873d91206e11349da713017bd67d43d8d535d", "patch": "@@ -227,7 +227,8 @@ pub fn eval_length(tcx: TyCtxt,\n {\n     let count_expr = &tcx.hir.body(count).value;\n     let count_def_id = tcx.hir.body_owner_def_id(count);\n-    match ty::queries::monomorphic_const_eval::get(tcx, count_expr.span, count_def_id) {\n+    let substs = Substs::empty();\n+    match ty::queries::const_eval::get(tcx, count_expr.span, (count_def_id, substs)) {\n         Ok(Integral(Usize(count))) => {\n             let val = count.as_u64(tcx.sess.target.uint_type);\n             assert_eq!(val as usize as u64, val);"}, {"sha": "3251addcb3283310ffaf7b32dcca5f5019c58d95", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e22873d91206e11349da713017bd67d43d8d535d/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e22873d91206e11349da713017bd67d43d8d535d/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=e22873d91206e11349da713017bd67d43d8d535d", "patch": "@@ -249,8 +249,8 @@ pub trait CrateStore {\n     fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro;\n \n     // misc. metadata\n-    fn maybe_get_item_body<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                                     -> Option<&'tcx hir::Body>;\n+    fn item_body<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                           -> &'tcx hir::Body;\n     fn item_body_nested_bodies(&self, def: DefId) -> BTreeMap<hir::BodyId, hir::Body>;\n     fn const_is_rvalue_promotable_to_static(&self, def: DefId) -> bool;\n \n@@ -399,9 +399,9 @@ impl CrateStore for DummyCrateStore {\n     fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro { bug!(\"load_macro\") }\n \n     // misc. metadata\n-    fn maybe_get_item_body<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                                     -> Option<&'tcx hir::Body> {\n-        bug!(\"maybe_get_item_body\")\n+    fn item_body<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                           -> &'tcx hir::Body {\n+        bug!(\"item_body\")\n     }\n     fn item_body_nested_bodies(&self, def: DefId) -> BTreeMap<hir::BodyId, hir::Body> {\n         bug!(\"item_body_nested_bodies\")"}, {"sha": "4247bff0f50268bc8e6cbab39a8b1dcee4a020b4", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e22873d91206e11349da713017bd67d43d8d535d/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e22873d91206e11349da713017bd67d43d8d535d/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=e22873d91206e11349da713017bd67d43d8d535d", "patch": "@@ -16,6 +16,7 @@ use middle::privacy::AccessLevels;\n use mir;\n use session::CompileResult;\n use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n+use ty::subst::Substs;\n use util::nodemap::NodeSet;\n \n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -74,6 +75,15 @@ impl Key for (CrateNum, DefId) {\n     }\n }\n \n+impl<'tcx> Key for (DefId, &'tcx Substs<'tcx>) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.0.krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.0.default_span(tcx)\n+    }\n+}\n+\n trait Value<'tcx>: Sized {\n     fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self;\n }\n@@ -217,6 +227,13 @@ impl<'tcx> QueryDescription for queries::reachable_set<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::const_eval<'tcx> {\n+    fn describe(tcx: TyCtxt, (def_id, _): (DefId, &'tcx Substs<'tcx>)) -> String {\n+        format!(\"const-evaluating `{}`\",\n+                tcx.item_path_str(def_id))\n+    }\n+}\n+\n macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n@@ -446,16 +463,17 @@ define_maps! { <'tcx>\n     /// (Defined only for LOCAL_CRATE)\n     pub crate_inherent_impls_overlap_check: crate_inherent_impls_dep_node(CrateNum) -> (),\n \n-    /// Results of evaluating monomorphic constants embedded in\n-    /// other items, such as enum variant explicit discriminants.\n-    pub monomorphic_const_eval: MonomorphicConstEval(DefId) -> const_val::EvalResult<'tcx>,\n+    /// Results of evaluating const items or constants embedded in\n+    /// other items (such as enum variant explicit discriminants).\n+    pub const_eval: const_eval_dep_node((DefId, &'tcx Substs<'tcx>))\n+        -> const_val::EvalResult<'tcx>,\n \n     /// Performs the privacy check and computes \"access levels\".\n     pub privacy_access_levels: PrivacyAccessLevels(CrateNum) -> Rc<AccessLevels>,\n \n     pub reachable_set: reachability_dep_node(CrateNum) -> Rc<NodeSet>,\n \n-    pub mir_shims: mir_shim(ty::InstanceDef<'tcx>) -> &'tcx RefCell<mir::Mir<'tcx>>\n+    pub mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx RefCell<mir::Mir<'tcx>>\n }\n \n fn coherent_trait_dep_node((_, def_id): (CrateNum, DefId)) -> DepNode<DefId> {\n@@ -470,10 +488,14 @@ fn reachability_dep_node(_: CrateNum) -> DepNode<DefId> {\n     DepNode::Reachability\n }\n \n-fn mir_shim(instance: ty::InstanceDef) -> DepNode<DefId> {\n+fn mir_shim_dep_node(instance: ty::InstanceDef) -> DepNode<DefId> {\n     instance.dep_node()\n }\n \n fn typeck_item_bodies_dep_node(_: CrateNum) -> DepNode<DefId> {\n     DepNode::TypeckBodiesKrate\n }\n+\n+fn const_eval_dep_node((def_id, _): (DefId, &Substs)) -> DepNode<DefId> {\n+    DepNode::ConstEval(def_id)\n+}"}, {"sha": "1588773479c5e8b1fc47acc7dbd4d53f14e36e81", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e22873d91206e11349da713017bd67d43d8d535d/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e22873d91206e11349da713017bd67d43d8d535d/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e22873d91206e11349da713017bd67d43d8d535d", "patch": "@@ -1701,7 +1701,8 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         self.variants.iter().map(move |v| {\n             let mut discr = prev_discr.map_or(initial, |d| d.wrap_incr());\n             if let VariantDiscr::Explicit(expr_did) = v.discr {\n-                match queries::monomorphic_const_eval::get(tcx, DUMMY_SP, expr_did) {\n+                let substs = Substs::empty();\n+                match queries::const_eval::get(tcx, DUMMY_SP, (expr_did, substs)) {\n                     Ok(ConstVal::Integral(v)) => {\n                         discr = v;\n                     }\n@@ -1733,7 +1734,8 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                     explicit_index -= distance;\n                 }\n                 ty::VariantDiscr::Explicit(expr_did) => {\n-                    match queries::monomorphic_const_eval::get(tcx, DUMMY_SP, expr_did) {\n+                    let substs = Substs::empty();\n+                    match queries::const_eval::get(tcx, DUMMY_SP, (expr_did, substs)) {\n                         Ok(ConstVal::Integral(v)) => {\n                             explicit_value = v;\n                             break;"}, {"sha": "37395ca78714d29fa2bce03c21d89998128940c4", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 81, "deletions": 104, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/e22873d91206e11349da713017bd67d43d8d535d/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e22873d91206e11349da713017bd67d43d8d535d/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=e22873d91206e11349da713017bd67d43d8d535d", "patch": "@@ -75,83 +75,34 @@ fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n ///\n /// `substs` is optional and is used for associated constants.\n /// This generally happens in late/trans const evaluation.\n-pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        def_id: DefId,\n-                                        substs: &'tcx Substs<'tcx>)\n-                                        -> Option<(&'tcx Expr,\n-                                                   &'a ty::TypeckTables<'tcx>)> {\n+pub fn lookup_const_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                    def_id: DefId,\n+                                    substs: &'tcx Substs<'tcx>)\n+                                    -> Option<(DefId, &'tcx Substs<'tcx>)> {\n     if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n         match tcx.hir.find(node_id) {\n-            None => None,\n-            Some(hir_map::NodeItem(&hir::Item {\n-                node: hir::ItemConst(_, body), ..\n-            })) |\n-            Some(hir_map::NodeImplItem(&hir::ImplItem {\n-                node: hir::ImplItemKind::Const(_, body), ..\n-            })) => {\n-                Some((&tcx.hir.body(body).value,\n-                      tcx.item_tables(def_id)))\n+            Some(hir_map::NodeTraitItem(_)) => {\n+                // If we have a trait item and the substitutions for it,\n+                // `resolve_trait_associated_const` will select an impl\n+                // or the default.\n+                resolve_trait_associated_const(tcx, def_id, substs)\n             }\n-            Some(hir_map::NodeTraitItem(ti)) => match ti.node {\n-                hir::TraitItemKind::Const(_, default) => {\n-                    // If we have a trait item and the substitutions for it,\n-                    // `resolve_trait_associated_const` will select an impl\n-                    // or the default.\n-                    let trait_id = tcx.hir.get_parent(node_id);\n-                    let trait_id = tcx.hir.local_def_id(trait_id);\n-                    let default_value = default.map(|body| {\n-                        (&tcx.hir.body(body).value,\n-                            tcx.item_tables(def_id))\n-                    });\n-                    resolve_trait_associated_const(tcx, def_id, default_value, trait_id, substs)\n-                }\n-                _ => None\n-            },\n-            Some(_) => None\n+            _ => Some((def_id, substs))\n         }\n     } else {\n-        let expr_and_tables = tcx.sess.cstore.maybe_get_item_body(tcx, def_id).map(|body| {\n-            (&body.value, tcx.item_tables(def_id))\n-        });\n         match tcx.sess.cstore.describe_def(def_id) {\n             Some(Def::AssociatedConst(_)) => {\n-                let trait_id = tcx.sess.cstore.trait_of_item(def_id);\n                 // As mentioned in the comments above for in-crate\n                 // constants, we only try to find the expression for a\n                 // trait-associated const if the caller gives us the\n                 // substitutions for the reference to it.\n-                if let Some(trait_id) = trait_id {\n-                    resolve_trait_associated_const(tcx, def_id, expr_and_tables,\n-                                                   trait_id, substs)\n+                if tcx.sess.cstore.trait_of_item(def_id).is_some() {\n+                    resolve_trait_associated_const(tcx, def_id, substs)\n                 } else {\n-                    expr_and_tables\n+                    Some((def_id, substs))\n                 }\n-            },\n-            Some(Def::Const(..)) => expr_and_tables,\n-            _ => None\n-        }\n-    }\n-}\n-\n-fn lookup_const_fn_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-                                   -> Option<(&'tcx hir::Body, &'a ty::TypeckTables<'tcx>)>\n-{\n-    if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n-        FnLikeNode::from_node(tcx.hir.get(node_id)).and_then(|fn_like| {\n-            if fn_like.constness() == hir::Constness::Const {\n-                Some((tcx.hir.body(fn_like.body()),\n-                      tcx.item_tables(def_id)))\n-            } else {\n-                None\n             }\n-        })\n-    } else {\n-        if tcx.sess.cstore.is_const_fn(def_id) {\n-            tcx.sess.cstore.maybe_get_item_body(tcx, def_id).map(|body| {\n-                (body, tcx.item_tables(def_id))\n-            })\n-        } else {\n-            None\n+            _ => Some((def_id, substs))\n         }\n     }\n }\n@@ -357,21 +308,15 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n           match cx.tables.qpath_def(qpath, e.id) {\n               Def::Const(def_id) |\n               Def::AssociatedConst(def_id) => {\n-                  if let Some((expr, tables)) = lookup_const_by_id(tcx, def_id, substs) {\n-                      let cx = ConstContext::with_tables(tcx, tables);\n-                      match cx.eval(expr) {\n-                          Ok(val) => val,\n-                          Err(ConstEvalErr { kind: TypeckError, .. }) => {\n-                              signal!(e, TypeckError);\n-                          }\n-                          Err(err) => {\n-                              debug!(\"bad reference: {:?}, {:?}\", err.description(), err.span);\n-                              signal!(e, ErroneousReferencedConstant(box err))\n-                          },\n-                      }\n-                  } else {\n-                      signal!(e, TypeckError);\n-                  }\n+                    match ty::queries::const_eval::get(tcx, e.span, (def_id, substs)) {\n+                        Ok(val) => val,\n+                        Err(ConstEvalErr { kind: TypeckError, .. }) => {\n+                            signal!(e, TypeckError);\n+                        }\n+                        Err(err) => {\n+                            debug!(\"bad reference: {:?}, {:?}\", err.description(), err.span);\n+                            signal!(e, ErroneousReferencedConstant(box err))\n+                        },\n               },\n               Def::VariantCtor(variant_def, ..) => {\n                   if let Some((expr, tables)) = lookup_variant_by_id(tcx, variant_def) {\n@@ -407,14 +352,27 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n           }\n       }\n       hir::ExprCall(ref callee, ref args) => {\n-          let (did, substs) = match cx.eval(callee)? {\n-              Function(did, substs) => (did, substs),\n-              Struct(_) => signal!(e, UnimplementedConstVal(\"tuple struct constructors\")),\n+          let (def_id, substs) = match cx.eval(callee)? {\n+              Function(def_id, substs) => (def_id, substs),\n               callee => signal!(e, CallOn(callee)),\n           };\n-          let (body, tables) = match lookup_const_fn_by_id(tcx, did) {\n-              Some(x) => x,\n-              None => signal!(e, NonConstPath),\n+\n+          let body = if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n+            if let Some(fn_like) = FnLikeNode::from_node(tcx.hir.get(node_id)) {\n+                if fn_like.constness() == hir::Constness::Const {\n+                    tcx.hir.body(fn_like.body())\n+                } else {\n+                    signal!(e, TypeckError)\n+                }\n+            } else {\n+                signal!(e, TypeckError)\n+            }\n+          } else {\n+            if tcx.sess.cstore.is_const_fn(def_id) {\n+                tcx.sess.cstore.item_body(tcx, def_id)\n+            } else {\n+                signal!(e, TypeckError)\n+            }\n           };\n \n           let arg_defs = body.arguments.iter().map(|arg| match arg.pat.node {\n@@ -434,7 +392,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n           debug!(\"const call({:?})\", call_args);\n           let callee_cx = ConstContext {\n             tcx: tcx,\n-            tables: tables,\n+            tables: tcx.item_tables(def_id),\n             substs: substs,\n             fn_args: Some(call_args)\n           };\n@@ -532,19 +490,16 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n     Ok(result)\n }\n \n-fn resolve_trait_associated_const<'a, 'tcx: 'a>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    trait_item_id: DefId,\n-    default_value: Option<(&'tcx Expr, &'a ty::TypeckTables<'tcx>)>,\n-    trait_id: DefId,\n-    rcvr_substs: &'tcx Substs<'tcx>\n-) -> Option<(&'tcx Expr, &'a ty::TypeckTables<'tcx>)>\n-{\n-    let trait_ref = ty::Binder(ty::TraitRef::new(trait_id, rcvr_substs));\n+fn resolve_trait_associated_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                            def_id: DefId,\n+                                            substs: &'tcx Substs<'tcx>)\n+                                            -> Option<(DefId, &'tcx Substs<'tcx>)> {\n+    let trait_item = tcx.associated_item(def_id);\n+    let trait_id = trait_item.container.id();\n+    let trait_ref = ty::Binder(ty::TraitRef::new(trait_id, substs));\n     debug!(\"resolve_trait_associated_const: trait_ref={:?}\",\n            trait_ref);\n \n-    tcx.populate_implementations_for_trait_if_necessary(trait_id);\n     tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n         let mut selcx = traits::SelectionContext::new(&infcx);\n         let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n@@ -569,12 +524,20 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(\n         // when constructing the inference context above.\n         match selection {\n             traits::VtableImpl(ref impl_data) => {\n-                let name = tcx.associated_item(trait_item_id).name;\n+                let name = trait_item.name;\n                 let ac = tcx.associated_items(impl_data.impl_def_id)\n                     .find(|item| item.kind == ty::AssociatedKind::Const && item.name == name);\n                 match ac {\n-                    Some(ic) => lookup_const_by_id(tcx, ic.def_id, Substs::empty()),\n-                    None => default_value,\n+                    // FIXME(eddyb) Use proper Instance resolution to\n+                    // get the correct Substs returned from here.\n+                    Some(ic) => Some((ic.def_id, Substs::empty())),\n+                    None => {\n+                        if trait_item.defaultness.has_value() {\n+                            Some((def_id, substs))\n+                        } else {\n+                            None\n+                        }\n+                    }\n                 }\n             }\n             _ => {\n@@ -796,21 +759,35 @@ impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n \n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n-        monomorphic_const_eval,\n+        const_eval,\n         ..*providers\n     };\n }\n \n-fn monomorphic_const_eval<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                    def_id: DefId)\n-                                    -> EvalResult<'tcx> {\n-    let cx = ConstContext::with_tables(tcx, tcx.item_tables(def_id));\n+fn const_eval<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                        (def_id, substs): (DefId, &'tcx Substs<'tcx>))\n+                        -> EvalResult<'tcx> {\n+    let (def_id, substs) = if let Some(resolved) = lookup_const_by_id(tcx, def_id, substs) {\n+        resolved\n+    } else {\n+        return Err(ConstEvalErr {\n+            span: tcx.def_span(def_id),\n+            kind: TypeckError\n+        });\n+    };\n+\n+    let cx = ConstContext {\n+        tcx,\n+        tables: tcx.item_tables(def_id),\n+        substs: substs,\n+        fn_args: None\n+    };\n \n     let body = if let Some(id) = tcx.hir.as_local_node_id(def_id) {\n         ty::queries::mir_const_qualif::get(tcx, DUMMY_SP, def_id);\n         tcx.hir.body(tcx.hir.body_owned_by(id))\n     } else {\n-        tcx.sess.cstore.maybe_get_item_body(tcx, def_id).unwrap()\n+        tcx.sess.cstore.item_body(tcx, def_id)\n     };\n     cx.eval(&body.value)\n }"}, {"sha": "a470d549d05efc2414506f40d72d29c0dcc68e65", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e22873d91206e11349da713017bd67d43d8d535d/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e22873d91206e11349da713017bd67d43d8d535d/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=e22873d91206e11349da713017bd67d43d8d535d", "patch": "@@ -587,11 +587,16 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                 let substs = self.tables.node_id_item_substs(id)\n                     .unwrap_or_else(|| tcx.intern_substs(&[]));\n                 match eval::lookup_const_by_id(tcx, def_id, substs) {\n-                    Some((const_expr, const_tables)) => {\n+                    Some((def_id, _substs)) => {\n                         // Enter the inlined constant's tables temporarily.\n                         let old_tables = self.tables;\n-                        self.tables = const_tables;\n-                        let pat = self.lower_const_expr(const_expr, pat_id, span);\n+                        self.tables = tcx.item_tables(def_id);\n+                        let body = if let Some(id) = tcx.hir.as_local_node_id(def_id) {\n+                            tcx.hir.body(tcx.hir.body_owned_by(id))\n+                        } else {\n+                            tcx.sess.cstore.item_body(tcx, def_id)\n+                        };\n+                        let pat = self.lower_const_expr(&body.value, pat_id, span);\n                         self.tables = old_tables;\n                         return pat;\n                     }"}, {"sha": "9e6a45e7f8b7c68ddfed3850f607392154f616e4", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e22873d91206e11349da713017bd67d43d8d535d/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e22873d91206e11349da713017bd67d43d8d535d/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=e22873d91206e11349da713017bd67d43d8d535d", "patch": "@@ -420,19 +420,18 @@ impl CrateStore for cstore::CStore {\n         })\n     }\n \n-    fn maybe_get_item_body<'a, 'tcx>(&self,\n-                                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     def_id: DefId)\n-                                     -> Option<&'tcx hir::Body>\n-    {\n+    fn item_body<'a, 'tcx>(&self,\n+                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                           def_id: DefId)\n+                           -> &'tcx hir::Body {\n         if let Some(cached) = tcx.hir.get_inlined_body(def_id) {\n-            return Some(cached);\n+            return cached;\n         }\n \n         self.dep_graph.read(DepNode::MetaData(def_id));\n-        debug!(\"maybe_get_item_body({}): inlining item\", tcx.item_path_str(def_id));\n+        debug!(\"item_body({}): inlining item\", tcx.item_path_str(def_id));\n \n-        self.get_crate_data(def_id.krate).maybe_get_item_body(tcx, def_id.index)\n+        self.get_crate_data(def_id.krate).item_body(tcx, def_id.index)\n     }\n \n     fn item_body_nested_bodies(&self, def: DefId) -> BTreeMap<hir::BodyId, hir::Body> {"}, {"sha": "a9eae5281b241fa3ede78cdb699560f798ae501a", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e22873d91206e11349da713017bd67d43d8d535d/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e22873d91206e11349da713017bd67d43d8d535d/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=e22873d91206e11349da713017bd67d43d8d535d", "patch": "@@ -750,16 +750,15 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn maybe_get_item_body(&self,\n-                               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                               id: DefIndex)\n-                               -> Option<&'tcx hir::Body> {\n-        if self.is_proc_macro(id) { return None; }\n-        self.entry(id).ast.map(|ast| {\n-            let def_id = self.local_def_id(id);\n-            let body = ast.decode(self).body.decode(self);\n-            tcx.hir.intern_inlined_body(def_id, body)\n-        })\n+    pub fn item_body(&self,\n+                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                     id: DefIndex)\n+                     -> &'tcx hir::Body {\n+        assert!(!self.is_proc_macro(id));\n+        let ast = self.entry(id).ast.unwrap();\n+        let def_id = self.local_def_id(id);\n+        let body = ast.decode(self).body.decode(self);\n+        tcx.hir.intern_inlined_body(def_id, body)\n     }\n \n     pub fn item_body_tables(&self,"}, {"sha": "736c076ea15446cb4b510cafb72e434290df6fef", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e22873d91206e11349da713017bd67d43d8d535d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e22873d91206e11349da713017bd67d43d8d535d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=e22873d91206e11349da713017bd67d43d8d535d", "patch": "@@ -593,7 +593,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprRepeat(ref v, count) => {\n             let c = &cx.tcx.hir.body(count).value;\n             let def_id = cx.tcx.hir.body_owner_def_id(count);\n-            let count = match ty::queries::monomorphic_const_eval::get(cx.tcx, c.span, def_id) {\n+            let substs = Substs::empty();\n+            let count = match ty::queries::const_eval::get(cx.tcx, c.span, (def_id, substs)) {\n                 Ok(ConstVal::Integral(ConstInt::Usize(u))) => u,\n                 Ok(other) => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n                 Err(s) => cx.fatal_const_eval_err(&s, c.span, \"expression\")"}, {"sha": "660ce837043c1d02d6481d4396325e958730ed27", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e22873d91206e11349da713017bd67d43d8d535d/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e22873d91206e11349da713017bd67d43d8d535d/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e22873d91206e11349da713017bd67d43d8d535d", "patch": "@@ -555,7 +555,8 @@ fn convert_enum_variant_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let wrapped_discr = prev_discr.map_or(initial, |d| d.wrap_incr());\n         prev_discr = Some(if let Some(e) = variant.node.disr_expr {\n             let expr_did = tcx.hir.local_def_id(e.node_id);\n-            let result = ty::queries::monomorphic_const_eval::get(tcx, variant.span, expr_did);\n+            let substs = Substs::empty();\n+            let result = ty::queries::const_eval::get(tcx, variant.span, (expr_did, substs));\n \n             // enum variant evaluation happens before the global constant check\n             // so we need to report the real error"}, {"sha": "6016fd488f56c8938e025e8c1783e85bde6d59ea", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e22873d91206e11349da713017bd67d43d8d535d/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e22873d91206e11349da713017bd67d43d8d535d/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=e22873d91206e11349da713017bd67d43d8d535d", "patch": "@@ -487,7 +487,7 @@ impl hir::print::PpAnn for InlinedConst {\n }\n \n fn print_inlined_const(cx: &DocContext, did: DefId) -> String {\n-    let body = cx.tcx.sess.cstore.maybe_get_item_body(cx.tcx, did).unwrap();\n+    let body = cx.tcx.sess.cstore.item_body(cx.tcx, did);\n     let inlined = InlinedConst {\n         nested_bodies: cx.tcx.sess.cstore.item_body_nested_bodies(did)\n     };"}, {"sha": "0745ac02d0723e620e82856f217cf666e1a21175", "filename": "src/test/compile-fail/const-call.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e22873d91206e11349da713017bd67d43d8d535d/src%2Ftest%2Fcompile-fail%2Fconst-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e22873d91206e11349da713017bd67d43d8d535d/src%2Ftest%2Fcompile-fail%2Fconst-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-call.rs?ref=e22873d91206e11349da713017bd67d43d8d535d", "patch": "@@ -17,6 +17,4 @@ fn f(x: usize) -> usize {\n fn main() {\n     let _ = [0; f(2)];\n     //~^ ERROR calls in constants are limited to constant functions\n-    //~| ERROR constant evaluation error [E0080]\n-    //~| non-constant path in constant expression\n }"}, {"sha": "b7f767f109c0c7437ce421135f1c358bb7c16cfa", "filename": "src/test/compile-fail/issue-39559.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e22873d91206e11349da713017bd67d43d8d535d/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e22873d91206e11349da713017bd67d43d8d535d/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs?ref=e22873d91206e11349da713017bd67d43d8d535d", "patch": "@@ -28,10 +28,6 @@ pub struct Vector<T, D: Dim> {\n fn main() {\n     let array: [usize; Dim3::dim()]\n     //~^ ERROR calls in constants are limited to constant functions\n-    //~| ERROR constant evaluation error\n-    //~| non-constant path in constant expression\n         = [0; Dim3::dim()];\n         //~^ ERROR calls in constants are limited to constant functions\n-        //~| ERROR constant evaluation error\n-        //~| non-constant path in constant expression\n }"}]}