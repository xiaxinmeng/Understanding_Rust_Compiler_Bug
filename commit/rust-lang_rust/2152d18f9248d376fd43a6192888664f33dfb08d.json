{"sha": "2152d18f9248d376fd43a6192888664f33dfb08d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxNTJkMThmOTI0OGQzNzZmZDQzYTYxOTI4ODg2NjRmMzNkZmIwOGQ=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-07-14T09:32:50Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-07-22T21:40:06Z"}, "message": "More BTreeMap test cases, some exposing undefined behaviour", "tree": {"sha": "0242581e4a46390b01215376fea4c26e4899d605", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0242581e4a46390b01215376fea4c26e4899d605"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2152d18f9248d376fd43a6192888664f33dfb08d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2152d18f9248d376fd43a6192888664f33dfb08d", "html_url": "https://github.com/rust-lang/rust/commit/2152d18f9248d376fd43a6192888664f33dfb08d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2152d18f9248d376fd43a6192888664f33dfb08d/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d31ffc1ac9e9ea356e896e63307168a64501b9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d31ffc1ac9e9ea356e896e63307168a64501b9d", "html_url": "https://github.com/rust-lang/rust/commit/7d31ffc1ac9e9ea356e896e63307168a64501b9d"}], "stats": {"total": 80, "additions": 80, "deletions": 0}, "files": [{"sha": "5cd3ce0a2d80dd86a45dffc75a2a54c3542f9b48", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/2152d18f9248d376fd43a6192888664f33dfb08d/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2152d18f9248d376fd43a6192888664f33dfb08d/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=2152d18f9248d376fd43a6192888664f33dfb08d", "patch": "@@ -3,6 +3,7 @@ use std::collections::BTreeMap;\n use std::convert::TryFrom;\n use std::fmt::Debug;\n use std::iter::FromIterator;\n+use std::mem;\n use std::ops::Bound::{self, Excluded, Included, Unbounded};\n use std::ops::RangeBounds;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n@@ -25,6 +26,20 @@ const MIN_INSERTS_HEIGHT_1: usize = NODE_CAPACITY + 1;\n // It's not the minimum size: removing an element from such a tree does not always reduce height.\n const MIN_INSERTS_HEIGHT_2: usize = NODE_CAPACITY + (NODE_CAPACITY + 1) * NODE_CAPACITY + 1;\n \n+// Gather all references from a mutable iterator and make sure Miri notices if\n+// using them is dangerous.\n+fn test_all_refs<'a, T: 'a>(dummy: &mut T, iter: impl Iterator<Item = &'a mut T>) {\n+    // Gather all those references.\n+    let mut refs: Vec<&mut T> = iter.collect();\n+    // Use them all. Twice, to be sure we got all interleavings.\n+    for r in refs.iter_mut() {\n+        mem::swap(dummy, r);\n+    }\n+    for r in refs {\n+        mem::swap(dummy, r);\n+    }\n+}\n+\n #[test]\n fn test_basic_large() {\n     let mut map = BTreeMap::new();\n@@ -268,7 +283,14 @@ fn test_iter_mut_mutation() {\n }\n \n #[test]\n+#[cfg_attr(miri, ignore)] // FIXME: fails in Miri <https://github.com/rust-lang/rust/issues/73915>\n fn test_values_mut() {\n+    let mut a: BTreeMap<_, _> = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i)).collect();\n+    test_all_refs(&mut 13, a.values_mut());\n+}\n+\n+#[test]\n+fn test_values_mut_mutation() {\n     let mut a = BTreeMap::new();\n     a.insert(1, String::from(\"hello\"));\n     a.insert(2, String::from(\"goodbye\"));\n@@ -281,6 +303,36 @@ fn test_values_mut() {\n     assert_eq!(values, [String::from(\"hello!\"), String::from(\"goodbye!\")]);\n }\n \n+#[test]\n+#[cfg_attr(miri, ignore)] // FIXME: fails in Miri <https://github.com/rust-lang/rust/issues/73915>\n+fn test_iter_entering_root_twice() {\n+    let mut map: BTreeMap<_, _> = (0..2).map(|i| (i, i)).collect();\n+    let mut it = map.iter_mut();\n+    let front = it.next().unwrap();\n+    let back = it.next_back().unwrap();\n+    assert_eq!(front, (&0, &mut 0));\n+    assert_eq!(back, (&1, &mut 1));\n+    *front.1 = 24;\n+    *back.1 = 42;\n+    assert_eq!(front, (&0, &mut 24));\n+    assert_eq!(back, (&1, &mut 42));\n+}\n+\n+#[test]\n+#[cfg_attr(miri, ignore)] // FIXME: fails in Miri <https://github.com/rust-lang/rust/issues/73915>\n+fn test_iter_descending_to_same_node_twice() {\n+    let mut map: BTreeMap<_, _> = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i)).collect();\n+    let mut it = map.iter_mut();\n+    // Descend into first child.\n+    let front = it.next().unwrap();\n+    // Descend into first child again, after running through second child.\n+    while it.next_back().is_some() {}\n+    // Check immutable access.\n+    assert_eq!(front, (&0, &mut 0));\n+    // Perform mutable access.\n+    *front.1 = 42;\n+}\n+\n #[test]\n fn test_iter_mixed() {\n     // Miri is too slow\n@@ -1283,6 +1335,34 @@ fn test_split_off_empty_left() {\n     assert!(right.into_iter().eq(data));\n }\n \n+// In a tree with 3 levels, if all but a part of the first leaf node is split off,\n+// make sure fix_top eliminates both top levels.\n+#[test]\n+fn test_split_off_tiny_left_height_2() {\n+    let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n+    let mut left: BTreeMap<_, _> = pairs.clone().collect();\n+    let right = left.split_off(&1);\n+    assert_eq!(left.len(), 1);\n+    assert_eq!(right.len(), MIN_INSERTS_HEIGHT_2 - 1);\n+    assert_eq!(*left.first_key_value().unwrap().0, 0);\n+    assert_eq!(*right.first_key_value().unwrap().0, 1);\n+}\n+\n+// In a tree with 3 levels, if only part of the last leaf node is split off,\n+// make sure fix_top eliminates both top levels.\n+#[test]\n+fn test_split_off_tiny_right_height_2() {\n+    let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n+    let last = MIN_INSERTS_HEIGHT_2 - 1;\n+    let mut left: BTreeMap<_, _> = pairs.clone().collect();\n+    assert_eq!(*left.last_key_value().unwrap().0, last);\n+    let right = left.split_off(&last);\n+    assert_eq!(left.len(), MIN_INSERTS_HEIGHT_2 - 1);\n+    assert_eq!(right.len(), 1);\n+    assert_eq!(*left.last_key_value().unwrap().0, last - 1);\n+    assert_eq!(*right.last_key_value().unwrap().0, last);\n+}\n+\n #[test]\n fn test_split_off_large_random_sorted() {\n     // Miri is too slow"}]}