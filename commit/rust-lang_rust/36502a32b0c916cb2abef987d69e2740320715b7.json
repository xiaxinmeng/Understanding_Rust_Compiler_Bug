{"sha": "36502a32b0c916cb2abef987d69e2740320715b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2NTAyYTMyYjBjOTE2Y2IyYWJlZjk4N2Q2OWUyNzQwMzIwNzE1Yjc=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-07-21T15:25:30Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-08-01T07:56:21Z"}, "message": "Implement the first machine function", "tree": {"sha": "5bb797314b9a0dcfc7f56fe1caf02e85d1290b09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5bb797314b9a0dcfc7f56fe1caf02e85d1290b09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36502a32b0c916cb2abef987d69e2740320715b7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlmANCUACgkQpp+NIls6\n19m/cA//QI9zAlKpdOK9s6lgCJ4VcmRay1+YbDuGsc39SYvN0aoeD1SdgibISch0\nUEzlhXBbnGJt8hL1tQUnZ/yOpZ6HgC6Zyu3VKfX6TFkYWpzS75cCe9YBNT8nWWwz\nxg+B9hz9jCox3eiBMYqJmy+WoRPxVlvRfqCK2Tc7h0ZJ1BCzGgB6sUAfMYgWf1Za\nwS90kP4Y/fW8nYdlr+a7JhowFulkoJSrMKB3gtIS4gHEeTR6sK0wYFJBYmD5Hxi9\nyB9zrWUAwu1psgPkRjewN2UQLX1zsc99SsJELjCekLinwiEXwCzjDBsO7ZxtDoYl\nSqUT9BYQY1FIB6KMmHZdR0+UarE66S9FE6oNcXgIe778F79svPn6utRhxz16n3J+\nzlgfrwx45URY8ygzbOazuVtDSND6uh8sMN+/7De5K0AYVixRtXgsIWfZxXhY+u5V\n0MoulI83bBAds4Lysqi1Pe6elFawzixTlGeBjzK3CXM03ALsw/8F/MWguWSmGR39\ncH1Cs91wxykFjX0w1+mz0Gylbc0j65/XyQuP3VH13P24p9GMHBDZPlfx/cuk4WAK\nY4KCK9Wx+4DASoDKCF4dGJXjPsQ40v57pU0sfXj6dEN0EX7mupsAd8axWp6+LCJI\nOVm2g2iNUnWcENeESA79o7oQcCdjHNshbwfDcmV/rButMiMaWqw=\n=YVD4\n-----END PGP SIGNATURE-----", "payload": "tree 5bb797314b9a0dcfc7f56fe1caf02e85d1290b09\nparent 11e30a65e6f2f18474159df200596e084152951f\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1500650730 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1501574181 +0200\n\nImplement the first machine function\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36502a32b0c916cb2abef987d69e2740320715b7", "html_url": "https://github.com/rust-lang/rust/commit/36502a32b0c916cb2abef987d69e2740320715b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36502a32b0c916cb2abef987d69e2740320715b7/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11e30a65e6f2f18474159df200596e084152951f", "url": "https://api.github.com/repos/rust-lang/rust/commits/11e30a65e6f2f18474159df200596e084152951f", "html_url": "https://github.com/rust-lang/rust/commit/11e30a65e6f2f18474159df200596e084152951f"}], "stats": {"total": 1754, "additions": 958, "deletions": 796}, "files": [{"sha": "e8b3a9fde9cbc856dea13f2057793581a91a15ee", "filename": "miri/lib.rs", "status": "modified", "additions": 779, "deletions": 1, "changes": 780, "blob_url": "https://github.com/rust-lang/rust/blob/36502a32b0c916cb2abef987d69e2740320715b7/miri%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36502a32b0c916cb2abef987d69e2740320715b7/miri%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Flib.rs?ref=36502a32b0c916cb2abef987d69e2740320715b7", "patch": "@@ -1,3 +1,781 @@\n-extern crate rustc_miri;\n+#![feature(\n+    i128_type,\n+    rustc_private,\n+)]\n+\n+// From rustc.\n+#[macro_use]\n+extern crate log;\n+extern crate log_settings;\n+extern crate rustc;\n+extern crate rustc_const_math;\n+extern crate rustc_data_structures;\n+extern crate syntax;\n+\n+use rustc::ty::{self, TyCtxt, Ty};\n+use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n+use rustc::mir;\n+use syntax::attr;\n+use syntax::abi::Abi;\n \n+use std::mem;\n+use std::collections::{\n+    HashMap,\n+    BTreeMap,\n+};\n+\n+extern crate rustc_miri;\n pub use rustc_miri::interpret::*;\n+\n+pub fn eval_main<'a, 'tcx: 'a>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    main_id: DefId,\n+    start_wrapper: Option<DefId>,\n+    limits: ResourceLimits,\n+) {\n+    fn run_main<'a, 'tcx: 'a>(\n+        ecx: &mut rustc_miri::interpret::EvalContext<'a, 'tcx, Evaluator>,\n+        main_id: DefId,\n+        start_wrapper: Option<DefId>,\n+    ) -> EvalResult<'tcx> {\n+        let main_instance = ty::Instance::mono(ecx.tcx, main_id);\n+        let main_mir = ecx.load_mir(main_instance.def)?;\n+        let mut cleanup_ptr = None; // Pointer to be deallocated when we are done\n+\n+        if !main_mir.return_ty.is_nil() || main_mir.arg_count != 0 {\n+            return Err(EvalError::Unimplemented(\"miri does not support main functions without `fn()` type signatures\".to_owned()));\n+        }\n+\n+        if let Some(start_id) = start_wrapper {\n+            let start_instance = ty::Instance::mono(ecx.tcx, start_id);\n+            let start_mir = ecx.load_mir(start_instance.def)?;\n+\n+            if start_mir.arg_count != 3 {\n+                return Err(EvalError::AbiViolation(format!(\"'start' lang item should have three arguments, but has {}\", start_mir.arg_count)));\n+            }\n+\n+            // Return value\n+            let size = ecx.tcx.data_layout.pointer_size.bytes();\n+            let align = ecx.tcx.data_layout.pointer_align.abi();\n+            let ret_ptr = ecx.memory_mut().allocate(size, align, Kind::Stack)?;\n+            cleanup_ptr = Some(ret_ptr);\n+\n+            // Push our stack frame\n+            ecx.push_stack_frame(\n+                start_instance,\n+                start_mir.span,\n+                start_mir,\n+                Lvalue::from_ptr(ret_ptr),\n+                StackPopCleanup::None,\n+            )?;\n+\n+            let mut args = ecx.frame().mir.args_iter();\n+\n+            // First argument: pointer to main()\n+            let main_ptr = ecx.memory_mut().create_fn_alloc(main_instance);\n+            let dest = ecx.eval_lvalue(&mir::Lvalue::Local(args.next().unwrap()))?;\n+            let main_ty = main_instance.def.def_ty(ecx.tcx);\n+            let main_ptr_ty = ecx.tcx.mk_fn_ptr(main_ty.fn_sig(ecx.tcx));\n+            ecx.write_value(Value::ByVal(PrimVal::Ptr(main_ptr)), dest, main_ptr_ty)?;\n+\n+            // Second argument (argc): 0\n+            let dest = ecx.eval_lvalue(&mir::Lvalue::Local(args.next().unwrap()))?;\n+            let ty = ecx.tcx.types.isize;\n+            ecx.write_null(dest, ty)?;\n+\n+            // Third argument (argv): 0\n+            let dest = ecx.eval_lvalue(&mir::Lvalue::Local(args.next().unwrap()))?;\n+            let ty = ecx.tcx.mk_imm_ptr(ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8));\n+            ecx.write_null(dest, ty)?;\n+        } else {\n+            ecx.push_stack_frame(\n+                main_instance,\n+                main_mir.span,\n+                main_mir,\n+                Lvalue::undef(),\n+                StackPopCleanup::None,\n+            )?;\n+        }\n+\n+        while ecx.step()? {}\n+        ecx.finish()?;\n+        if let Some(cleanup_ptr) = cleanup_ptr {\n+            ecx.memory_mut().deallocate(cleanup_ptr, None, Kind::Stack)?;\n+        }\n+        Ok(())\n+    }\n+\n+    let mut ecx = EvalContext::new(tcx, limits, Default::default(), Default::default());\n+    match run_main(&mut ecx, main_id, start_wrapper) {\n+        Ok(()) => {\n+            let leaks = ecx.memory().leak_report();\n+            if leaks != 0 {\n+                tcx.sess.err(\"the evaluated program leaked memory\");\n+            }\n+        }\n+        Err(e) => {\n+            ecx.report(&e);\n+        }\n+    }\n+}\n+\n+struct Evaluator;\n+#[derive(Default)]\n+struct EvaluatorData {\n+    /// Environment variables set by `setenv`\n+    /// Miri does not expose env vars from the host to the emulated program\n+    pub(crate) env_vars: HashMap<Vec<u8>, MemoryPointer>,\n+}\n+\n+pub type TlsKey = usize;\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct TlsEntry<'tcx> {\n+    data: Pointer, // Will eventually become a map from thread IDs to `Pointer`s, if we ever support more than one thread.\n+    dtor: Option<ty::Instance<'tcx>>,\n+}\n+\n+#[derive(Default)]\n+struct MemoryData<'tcx> {\n+    /// The Key to use for the next thread-local allocation.\n+    next_thread_local: TlsKey,\n+\n+    /// pthreads-style thread-local storage.\n+    thread_local: BTreeMap<TlsKey, TlsEntry<'tcx>>,\n+}\n+\n+trait EvalContextExt<'tcx> {\n+    fn call_c_abi(\n+        &mut self,\n+        def_id: DefId,\n+        arg_operands: &[mir::Operand<'tcx>],\n+        dest: Lvalue<'tcx>,\n+        dest_ty: Ty<'tcx>,\n+        dest_block: mir::BasicBlock,\n+    ) -> EvalResult<'tcx>;\n+    fn finish(&mut self) -> EvalResult<'tcx>;\n+\n+    fn resolve_path(&self, path: &[&str]) -> EvalResult<'tcx, ty::Instance<'tcx>>;\n+\n+    fn call_missing_fn(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        arg_operands: &[mir::Operand<'tcx>],\n+        sig: ty::FnSig<'tcx>,\n+        path: String,\n+    ) -> EvalResult<'tcx>;\n+}\n+\n+impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, Evaluator> {\n+    fn call_c_abi(\n+        &mut self,\n+        def_id: DefId,\n+        arg_operands: &[mir::Operand<'tcx>],\n+        dest: Lvalue<'tcx>,\n+        dest_ty: Ty<'tcx>,\n+        dest_block: mir::BasicBlock,\n+    ) -> EvalResult<'tcx> {\n+        let name = self.tcx.item_name(def_id);\n+        let attrs = self.tcx.get_attrs(def_id);\n+        let link_name = attr::first_attr_value_str_by_name(&attrs, \"link_name\")\n+            .unwrap_or(name)\n+            .as_str();\n+\n+        let args_res: EvalResult<Vec<Value>> = arg_operands.iter()\n+            .map(|arg| self.eval_operand(arg))\n+            .collect();\n+        let args = args_res?;\n+\n+        let usize = self.tcx.types.usize;\n+\n+        match &link_name[..] {\n+            \"malloc\" => {\n+                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                if size == 0 {\n+                    self.write_null(dest, dest_ty)?;\n+                } else {\n+                    let align = self.memory.pointer_size();\n+                    let ptr = self.memory.allocate(size, align, Kind::C)?;\n+                    self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n+                }\n+            }\n+\n+            \"free\" => {\n+                let ptr = args[0].into_ptr(&mut self.memory)?;\n+                if !ptr.is_null()? {\n+                    self.memory.deallocate(ptr.to_ptr()?, None, Kind::C)?;\n+                }\n+            }\n+\n+            \"syscall\" => {\n+                match self.value_to_primval(args[0], usize)?.to_u64()? {\n+                    511 => return Err(EvalError::Unimplemented(\"miri does not support random number generators\".to_owned())),\n+                    id => return Err(EvalError::Unimplemented(format!(\"miri does not support syscall id {}\", id))),\n+                }\n+            }\n+\n+            \"dlsym\" => {\n+                let _handle = args[0].into_ptr(&mut self.memory)?;\n+                let symbol = args[1].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let symbol_name = self.memory.read_c_str(symbol)?;\n+                let err = format!(\"bad c unicode symbol: {:?}\", symbol_name);\n+                let symbol_name = ::std::str::from_utf8(symbol_name).unwrap_or(&err);\n+                return Err(EvalError::Unimplemented(format!(\"miri does not support dynamically loading libraries (requested symbol: {})\", symbol_name)));\n+            }\n+\n+            \"__rust_maybe_catch_panic\" => {\n+                // fn __rust_maybe_catch_panic(f: fn(*mut u8), data: *mut u8, data_ptr: *mut usize, vtable_ptr: *mut usize) -> u32\n+                // We abort on panic, so not much is going on here, but we still have to call the closure\n+                let u8_ptr_ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n+                let f = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let data = args[1].into_ptr(&mut self.memory)?;\n+                let f_instance = self.memory.get_fn(f)?;\n+                self.write_null(dest, dest_ty)?;\n+\n+                // Now we make a function call.  TODO: Consider making this re-usable?  EvalContext::step does sth. similar for the TLS dtors,\n+                // and of course eval_main.\n+                let mir = self.load_mir(f_instance.def)?;\n+                self.push_stack_frame(\n+                    f_instance,\n+                    mir.span,\n+                    mir,\n+                    Lvalue::undef(),\n+                    StackPopCleanup::Goto(dest_block),\n+                )?;\n+\n+                let arg_local = self.frame().mir.args_iter().next().ok_or(EvalError::AbiViolation(\"Argument to __rust_maybe_catch_panic does not take enough arguments.\".to_owned()))?;\n+                let arg_dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n+                self.write_ptr(arg_dest, data, u8_ptr_ty)?;\n+\n+                // We ourselves return 0\n+                self.write_null(dest, dest_ty)?;\n+\n+                // Don't fall through\n+                return Ok(());\n+            }\n+\n+            \"__rust_start_panic\" => {\n+                return Err(EvalError::Panic);\n+            }\n+\n+            \"memcmp\" => {\n+                let left = args[0].into_ptr(&mut self.memory)?;\n+                let right = args[1].into_ptr(&mut self.memory)?;\n+                let n = self.value_to_primval(args[2], usize)?.to_u64()?;\n+\n+                let result = {\n+                    let left_bytes = self.memory.read_bytes(left, n)?;\n+                    let right_bytes = self.memory.read_bytes(right, n)?;\n+\n+                    use std::cmp::Ordering::*;\n+                    match left_bytes.cmp(right_bytes) {\n+                        Less => -1i8,\n+                        Equal => 0,\n+                        Greater => 1,\n+                    }\n+                };\n+\n+                self.write_primval(dest, PrimVal::Bytes(result as u128), dest_ty)?;\n+            }\n+\n+            \"memrchr\" => {\n+                let ptr = args[0].into_ptr(&mut self.memory)?;\n+                let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n+                let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().rev().position(|&c| c == val) {\n+                    let new_ptr = ptr.offset(num - idx as u64 - 1, &self)?;\n+                    self.write_ptr(dest, new_ptr, dest_ty)?;\n+                } else {\n+                    self.write_null(dest, dest_ty)?;\n+                }\n+            }\n+\n+            \"memchr\" => {\n+                let ptr = args[0].into_ptr(&mut self.memory)?;\n+                let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n+                let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().position(|&c| c == val) {\n+                    let new_ptr = ptr.offset(idx as u64, &self)?;\n+                    self.write_ptr(dest, new_ptr, dest_ty)?;\n+                } else {\n+                    self.write_null(dest, dest_ty)?;\n+                }\n+            }\n+\n+            \"getenv\" => {\n+                let result = {\n+                    let name_ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                    let name = self.memory.read_c_str(name_ptr)?;\n+                    match self.machine_data.env_vars.get(name) {\n+                        Some(&var) => PrimVal::Ptr(var),\n+                        None => PrimVal::Bytes(0),\n+                    }\n+                };\n+                self.write_primval(dest, result, dest_ty)?;\n+            }\n+\n+            \"unsetenv\" => {\n+                let mut success = None;\n+                {\n+                    let name_ptr = args[0].into_ptr(&mut self.memory)?;\n+                    if !name_ptr.is_null()? {\n+                        let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n+                        if !name.is_empty() && !name.contains(&b'=') {\n+                            success = Some(self.machine_data.env_vars.remove(name));\n+                        }\n+                    }\n+                }\n+                if let Some(old) = success {\n+                    if let Some(var) = old {\n+                        self.memory.deallocate(var, None, Kind::Env)?;\n+                    }\n+                    self.write_null(dest, dest_ty)?;\n+                } else {\n+                    self.write_primval(dest, PrimVal::from_i128(-1), dest_ty)?;\n+                }\n+            }\n+\n+            \"setenv\" => {\n+                let mut new = None;\n+                {\n+                    let name_ptr = args[0].into_ptr(&mut self.memory)?;\n+                    let value_ptr = args[1].into_ptr(&mut self.memory)?.to_ptr()?;\n+                    let value = self.memory.read_c_str(value_ptr)?;\n+                    if !name_ptr.is_null()? {\n+                        let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n+                        if !name.is_empty() && !name.contains(&b'=') {\n+                            new = Some((name.to_owned(), value.to_owned()));\n+                        }\n+                    }\n+                }\n+                if let Some((name, value)) = new {\n+                    // +1 for the null terminator\n+                    let value_copy = self.memory.allocate((value.len() + 1) as u64, 1, Kind::Env)?;\n+                    self.memory.write_bytes(value_copy.into(), &value)?;\n+                    let trailing_zero_ptr = value_copy.offset(value.len() as u64, &self)?.into();\n+                    self.memory.write_bytes(trailing_zero_ptr, &[0])?;\n+                    if let Some(var) = self.machine_data.env_vars.insert(name.to_owned(), value_copy) {\n+                        self.memory.deallocate(var, None, Kind::Env)?;\n+                    }\n+                    self.write_null(dest, dest_ty)?;\n+                } else {\n+                    self.write_primval(dest, PrimVal::from_i128(-1), dest_ty)?;\n+                }\n+            }\n+\n+            \"write\" => {\n+                let fd = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                let buf = args[1].into_ptr(&mut self.memory)?;\n+                let n = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, n);\n+                let result = if fd == 1 || fd == 2 { // stdout/stderr\n+                    use std::io::{self, Write};\n+                \n+                    let buf_cont = self.memory.read_bytes(buf, n)?;\n+                    let res = if fd == 1 { io::stdout().write(buf_cont) } else { io::stderr().write(buf_cont) };\n+                    match res { Ok(n) => n as isize, Err(_) => -1 }\n+                } else {\n+                    info!(\"Ignored output to FD {}\", fd);\n+                    n as isize // pretend it all went well\n+                }; // now result is the value we return back to the program\n+                self.write_primval(dest, PrimVal::Bytes(result as u128), dest_ty)?;\n+            }\n+\n+            \"strlen\" => {\n+                let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let n = self.memory.read_c_str(ptr)?.len();\n+                self.write_primval(dest, PrimVal::Bytes(n as u128), dest_ty)?;\n+            }\n+\n+            // Some things needed for sys::thread initialization to go through\n+            \"signal\" | \"sigaction\" | \"sigaltstack\" => {\n+                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n+            }\n+\n+            \"sysconf\" => {\n+                let name = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                trace!(\"sysconf() called with name {}\", name);\n+                // cache the sysconf integers via miri's global cache\n+                let paths = &[\n+                    (&[\"libc\", \"_SC_PAGESIZE\"], PrimVal::Bytes(4096)),\n+                    (&[\"libc\", \"_SC_GETPW_R_SIZE_MAX\"], PrimVal::from_i128(-1)),\n+                ];\n+                let mut result = None;\n+                for &(path, path_value) in paths {\n+                    if let Ok(instance) = self.resolve_path(path) {\n+                        let cid = GlobalId { instance, promoted: None };\n+                        // compute global if not cached\n+                        let val = match self.globals.get(&cid).map(|glob| glob.value) {\n+                            Some(value) => self.value_to_primval(value, usize)?.to_u64()?,\n+                            None => eval_body_as_primval(self.tcx, instance)?.0.to_u64()?,\n+                        };\n+                        if val == name {\n+                            result = Some(path_value);\n+                            break;\n+                        }\n+                    }\n+                }\n+                if let Some(result) = result {\n+                    self.write_primval(dest, result, dest_ty)?;\n+                } else {\n+                    return Err(EvalError::Unimplemented(format!(\"Unimplemented sysconf name: {}\", name)));\n+                }\n+            }\n+\n+            // Hook pthread calls that go to the thread-local storage memory subsystem\n+            \"pthread_key_create\" => {\n+                let key_ptr = args[0].into_ptr(&mut self.memory)?;\n+\n+                // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n+                let dtor = match args[1].into_ptr(&mut self.memory)?.into_inner_primval() {\n+                    PrimVal::Ptr(dtor_ptr) => Some(self.memory.get_fn(dtor_ptr)?),\n+                    PrimVal::Bytes(0) => None,\n+                    PrimVal::Bytes(_) => return Err(EvalError::ReadBytesAsPointer),\n+                    PrimVal::Undef => return Err(EvalError::ReadUndefBytes),\n+                };\n+\n+                // Figure out how large a pthread TLS key actually is. This is libc::pthread_key_t.\n+                let key_type = self.operand_ty(&arg_operands[0]).builtin_deref(true, ty::LvaluePreference::NoPreference)\n+                                   .ok_or(EvalError::AbiViolation(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))?.ty;\n+                let key_size = {\n+                    let layout = self.type_layout(key_type)?;\n+                    layout.size(&self.tcx.data_layout)\n+                };\n+\n+                // Create key and write it into the memory where key_ptr wants it\n+                let key = self.memory.create_tls_key(dtor) as u128;\n+                if key_size.bits() < 128 && key >= (1u128 << key_size.bits() as u128) {\n+                    return Err(EvalError::OutOfTls);\n+                }\n+                // TODO: Does this need checking for alignment?\n+                self.memory.write_uint(key_ptr.to_ptr()?, key, key_size.bytes())?;\n+\n+                // Return success (0)\n+                self.write_null(dest, dest_ty)?;\n+            }\n+            \"pthread_key_delete\" => {\n+                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n+                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n+                self.memory.delete_tls_key(key)?;\n+                // Return success (0)\n+                self.write_null(dest, dest_ty)?;\n+            }\n+            \"pthread_getspecific\" => {\n+                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n+                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n+                let ptr = self.memory.load_tls(key)?;\n+                self.write_ptr(dest, ptr, dest_ty)?;\n+            }\n+            \"pthread_setspecific\" => {\n+                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n+                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n+                let new_ptr = args[1].into_ptr(&mut self.memory)?;\n+                self.memory.store_tls(key, new_ptr)?;\n+                \n+                // Return success (0)\n+                self.write_null(dest, dest_ty)?;\n+            }\n+\n+            // Stub out all the other pthread calls to just return 0\n+            link_name if link_name.starts_with(\"pthread_\") => {\n+                warn!(\"ignoring C ABI call: {}\", link_name);\n+                self.write_null(dest, dest_ty)?;\n+            },\n+\n+            _ => {\n+                return Err(EvalError::Unimplemented(format!(\"can't call C ABI function: {}\", link_name)));\n+            }\n+        }\n+\n+        // Since we pushed no stack frame, the main loop will act\n+        // as if the call just completed and it's returning to the\n+        // current frame.\n+        self.dump_local(dest);\n+        self.goto_block(dest_block);\n+        Ok(())\n+    }\n+\n+    fn finish(&mut self) -> EvalResult<'tcx> {\n+        let mut dtor = self.memory.fetch_tls_dtor(None)?;\n+        // FIXME: replace loop by some structure that works with stepping\n+        while let Some((instance, ptr, key)) = dtor {\n+            trace!(\"Running TLS dtor {:?} on {:?}\", instance, ptr);\n+            // TODO: Potentially, this has to support all the other possible instances? See eval_fn_call in terminator/mod.rs\n+            let mir = self.load_mir(instance.def)?;\n+            self.push_stack_frame(\n+                instance,\n+                mir.span,\n+                mir,\n+                Lvalue::undef(),\n+                StackPopCleanup::None,\n+            )?;\n+            let arg_local = self.frame().mir.args_iter().next().ok_or(EvalError::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()))?;\n+            let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n+            let ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n+            self.write_ptr(dest, ptr, ty)?;\n+\n+            // step until out of stackframes\n+            while self.step()? {}\n+\n+            dtor = match self.memory.fetch_tls_dtor(Some(key))? {\n+                dtor @ Some(_) => dtor,\n+                None => self.memory.fetch_tls_dtor(None)?,\n+            };\n+        }\n+        Ok(())\n+    }\n+\n+    /// Get an instance for a path.\n+    fn resolve_path(&self, path: &[&str]) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n+        let cstore = &self.tcx.sess.cstore;\n+\n+        let crates = cstore.crates();\n+        crates.iter()\n+            .find(|&&krate| cstore.crate_name(krate) == path[0])\n+            .and_then(|krate| {\n+                let krate = DefId {\n+                    krate: *krate,\n+                    index: CRATE_DEF_INDEX,\n+                };\n+                let mut items = cstore.item_children(krate, self.tcx.sess);\n+                let mut path_it = path.iter().skip(1).peekable();\n+\n+                while let Some(segment) = path_it.next() {\n+                    for item in &mem::replace(&mut items, vec![]) {\n+                        if item.ident.name == *segment {\n+                            if path_it.peek().is_none() {\n+                                return Some(ty::Instance::mono(self.tcx, item.def.def_id()));\n+                            }\n+\n+                            items = cstore.item_children(item.def.def_id(), self.tcx.sess);\n+                            break;\n+                        }\n+                    }\n+                }\n+                None\n+            })\n+            .ok_or_else(|| {\n+                let path = path.iter()\n+                    .map(|&s| s.to_owned())\n+                    .collect();\n+                EvalError::PathNotFound(path)\n+            })\n+    }\n+\n+    fn call_missing_fn(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        arg_operands: &[mir::Operand<'tcx>],\n+        sig: ty::FnSig<'tcx>,\n+        path: String,\n+    ) -> EvalResult<'tcx> {\n+        // In some cases in non-MIR libstd-mode, not having a destination is legit.  Handle these early.\n+        match &path[..] {\n+            \"std::panicking::rust_panic_with_hook\" |\n+            \"std::rt::begin_panic_fmt\" => return Err(EvalError::Panic),\n+            _ => {},\n+        }\n+\n+        let dest_ty = sig.output();\n+        let (dest, dest_block) = destination.ok_or_else(|| EvalError::NoMirFor(path.clone()))?;\n+\n+        if sig.abi == Abi::C {\n+            // An external C function\n+            // TODO: That functions actually has a similar preamble to what follows here.  May make sense to\n+            // unify these two mechanisms for \"hooking into missing functions\".\n+            self.call_c_abi(instance.def_id(), arg_operands, dest, dest_ty, dest_block)?;\n+            return Ok(());\n+        }\n+\n+        let args_res: EvalResult<Vec<Value>> = arg_operands.iter()\n+            .map(|arg| self.eval_operand(arg))\n+            .collect();\n+        let args = args_res?;\n+\n+        let usize = self.tcx.types.usize;\n+    \n+        match &path[..] {\n+            // Allocators are magic.  They have no MIR, even when the rest of libstd does.\n+            \"alloc::heap::::__rust_alloc\" => {\n+                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                if size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n+                let ptr = self.memory.allocate(size, align, Kind::Rust)?;\n+                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n+            }\n+            \"alloc::heap::::__rust_alloc_zeroed\" => {\n+                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                if size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n+                let ptr = self.memory.allocate(size, align, Kind::Rust)?;\n+                self.memory.write_repeat(ptr.into(), 0, size)?;\n+                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n+            }\n+            \"alloc::heap::::__rust_dealloc\" => {\n+                let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                let align = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                if old_size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n+                self.memory.deallocate(ptr, Some((old_size, align)), Kind::Rust)?;\n+            }\n+            \"alloc::heap::::__rust_realloc\" => {\n+                let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                let old_align = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                let new_size = self.value_to_primval(args[3], usize)?.to_u64()?;\n+                let new_align = self.value_to_primval(args[4], usize)?.to_u64()?;\n+                if old_size == 0 || new_size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !old_align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(old_align));\n+                }\n+                if !new_align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(new_align));\n+                }\n+                let new_ptr = self.memory.reallocate(ptr, old_size, old_align, new_size, new_align, Kind::Rust)?;\n+                self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n+            }\n+\n+            // A Rust function is missing, which means we are running with MIR missing for libstd (or other dependencies).\n+            // Still, we can make many things mostly work by \"emulating\" or ignoring some functions.\n+            \"std::io::_print\" => {\n+                trace!(\"Ignoring output.  To run programs that print, make sure you have a libstd with full MIR.\");\n+            }\n+            \"std::thread::Builder::new\" => return Err(EvalError::Unimplemented(\"miri does not support threading\".to_owned())),\n+            \"std::env::args\" => return Err(EvalError::Unimplemented(\"miri does not support program arguments\".to_owned())),\n+            \"std::panicking::panicking\" |\n+            \"std::rt::panicking\" => {\n+                // we abort on panic -> `std::rt::panicking` always returns false\n+                let bool = self.tcx.types.bool;\n+                self.write_primval(dest, PrimVal::from_bool(false), bool)?;\n+            }\n+            _ => return Err(EvalError::NoMirFor(path)),\n+        }\n+\n+        // Since we pushed no stack frame, the main loop will act\n+        // as if the call just completed and it's returning to the\n+        // current frame.\n+        self.dump_local(dest);\n+        self.goto_block(dest_block);\n+        return Ok(());\n+    }\n+}\n+\n+trait MemoryExt<'tcx> {\n+    fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey;\n+    fn delete_tls_key(&mut self, key: TlsKey) -> EvalResult<'tcx>;\n+    fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Pointer>;\n+    fn store_tls(&mut self, key: TlsKey, new_data: Pointer) -> EvalResult<'tcx>;\n+    fn fetch_tls_dtor(&mut self, key: Option<TlsKey>) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, Pointer, TlsKey)>>;\n+}\n+\n+impl<'a, 'tcx: 'a> MemoryExt<'tcx> for Memory<'a, 'tcx, Evaluator> {\n+    fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey {\n+        let new_key = self.data.next_thread_local;\n+        self.data.next_thread_local += 1;\n+        self.data.thread_local.insert(new_key, TlsEntry { data: Pointer::null(), dtor });\n+        trace!(\"New TLS key allocated: {} with dtor {:?}\", new_key, dtor);\n+        return new_key;\n+    }\n+\n+    fn delete_tls_key(&mut self, key: TlsKey) -> EvalResult<'tcx> {\n+        return match self.data.thread_local.remove(&key) {\n+            Some(_) => {\n+                trace!(\"TLS key {} removed\", key);\n+                Ok(())\n+            },\n+            None => Err(EvalError::TlsOutOfBounds)\n+        }\n+    }\n+\n+    fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Pointer> {\n+        return match self.data.thread_local.get(&key) {\n+            Some(&TlsEntry { data, .. }) => {\n+                trace!(\"TLS key {} loaded: {:?}\", key, data);\n+                Ok(data)\n+            },\n+            None => Err(EvalError::TlsOutOfBounds)\n+        }\n+    }\n+\n+    fn store_tls(&mut self, key: TlsKey, new_data: Pointer) -> EvalResult<'tcx> {\n+        return match self.data.thread_local.get_mut(&key) {\n+            Some(&mut TlsEntry { ref mut data, .. }) => {\n+                trace!(\"TLS key {} stored: {:?}\", key, new_data);\n+                *data = new_data;\n+                Ok(())\n+            },\n+            None => Err(EvalError::TlsOutOfBounds)\n+        }\n+    }\n+    \n+    /// Returns a dtor, its argument and its index, if one is supposed to run\n+    ///\n+    /// An optional destructor function may be associated with each key value.\n+    /// At thread exit, if a key value has a non-NULL destructor pointer,\n+    /// and the thread has a non-NULL value associated with that key,\n+    /// the value of the key is set to NULL, and then the function pointed\n+    /// to is called with the previously associated value as its sole argument.\n+    /// The order of destructor calls is unspecified if more than one destructor\n+    /// exists for a thread when it exits.\n+    ///\n+    /// If, after all the destructors have been called for all non-NULL values\n+    /// with associated destructors, there are still some non-NULL values with\n+    /// associated destructors, then the process is repeated.\n+    /// If, after at least {PTHREAD_DESTRUCTOR_ITERATIONS} iterations of destructor\n+    /// calls for outstanding non-NULL values, there are still some non-NULL values\n+    /// with associated destructors, implementations may stop calling destructors,\n+    /// or they may continue calling destructors until no non-NULL values with\n+    /// associated destructors exist, even though this might result in an infinite loop.\n+    fn fetch_tls_dtor(&mut self, key: Option<TlsKey>) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, Pointer, TlsKey)>> {\n+        use std::collections::Bound::*;\n+        let start = match key {\n+            Some(key) => Excluded(key),\n+            None => Unbounded,\n+        };\n+        for (&key, &mut TlsEntry { ref mut data, dtor }) in self.data.thread_local.range_mut((start, Unbounded)) {\n+            if !data.is_null()? {\n+                if let Some(dtor) = dtor {\n+                    let ret = Some((dtor, *data, key));\n+                    *data = Pointer::null();\n+                    return Ok(ret);\n+                }\n+            }\n+        }\n+        return Ok(None);\n+    }\n+}\n+\n+impl<'tcx> Machine<'tcx> for Evaluator {\n+    type Data = EvaluatorData;\n+    type MemoryData = MemoryData<'tcx>;\n+    /// Returns Ok() when the function was handled, fail otherwise\n+    fn call_missing_fn<'a>(\n+        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        instance: ty::Instance<'tcx>,\n+        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        arg_operands: &[mir::Operand<'tcx>],\n+        sig: ty::FnSig<'tcx>,\n+        path: String,\n+    ) -> EvalResult<'tcx> {\n+        ecx.call_missing_fn(instance, destination, arg_operands, sig, path)\n+    }\n+}"}, {"sha": "d69e09313c3fed44711f30740466c0f9e7a01793", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=36502a32b0c916cb2abef987d69e2740320715b7", "patch": "@@ -7,9 +7,10 @@ use super::{\n     EvalResult,\n     EvalError,\n     MemoryPointer, PointerArithmetic,\n+    Machine,\n };\n \n-impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub(super) fn cast_primval(\n         &self,\n         val: PrimVal,"}, {"sha": "7a722b0344f1fd9fa1045a12aa3f956a2e4ce8e2", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=36502a32b0c916cb2abef987d69e2740320715b7", "patch": "@@ -1,5 +1,7 @@\n use rustc::traits::Reveal;\n use rustc::ty::{self, TyCtxt, Ty, Instance};\n+use rustc::mir;\n+\n use syntax::ast::Mutability;\n \n use super::{\n@@ -16,7 +18,7 @@ pub fn eval_body_as_primval<'a, 'tcx>(\n     instance: Instance<'tcx>,\n ) -> EvalResult<'tcx, (PrimVal, Ty<'tcx>)> {\n     let limits = super::ResourceLimits::default();\n-    let mut ecx = EvalContext::new(tcx, limits);\n+    let mut ecx = EvalContext::<Evaluator>::new(tcx, limits, (), ());\n     let cid = GlobalId { instance, promoted: None };\n     if ecx.tcx.has_attr(instance.def_id(), \"linkage\") {\n         return Err(EvalError::NotConst(\"extern global\".to_string()));\n@@ -76,3 +78,21 @@ pub fn eval_body_as_integer<'a, 'tcx>(\n         _ => return Err(EvalError::NeedsRfc(\"evaluating anything other than isize/usize during typeck\".to_string())),\n     })\n }\n+\n+struct Evaluator;\n+\n+impl<'tcx> super::Machine<'tcx> for Evaluator {\n+    type Data = ();\n+    type MemoryData = ();\n+    fn call_missing_fn<'a>(\n+        _ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        _instance: ty::Instance<'tcx>,\n+        _destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        _arg_operands: &[mir::Operand<'tcx>],\n+        _sig: ty::FnSig<'tcx>,\n+        path: String,\n+    ) -> EvalResult<'tcx> {\n+        // some simple things like `malloc` might get accepted in the future\n+        Err(EvalError::NeedsRfc(format!(\"calling extern function `{}`\", path)))\n+    }\n+}"}, {"sha": "c75c98206552655d6d09b56b164116b544cda46a", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 52, "deletions": 164, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=36502a32b0c916cb2abef987d69e2740320715b7", "patch": "@@ -19,27 +19,31 @@ use syntax::abi::Abi;\n use super::{\n     EvalError, EvalResult,\n     Global, GlobalId, Lvalue, LvalueExtra,\n-    Memory, MemoryPointer, TlsKey, HasMemory,\n+    Memory, MemoryPointer, HasMemory,\n     Kind as MemoryKind,\n     operator,\n     PrimVal, PrimValKind, Value, Pointer,\n     ValidationQuery,\n+    Machine,\n };\n \n-pub struct EvalContext<'a, 'tcx: 'a> {\n+pub struct EvalContext<'a, 'tcx: 'a, M: Machine<'tcx>> {\n+    /// Stores data required by the `Machine`\n+    pub machine_data: M::Data,\n+\n     /// The results of the type checker, from rustc.\n-    pub(crate) tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     /// The virtual memory system.\n-    pub(crate) memory: Memory<'a, 'tcx>,\n+    pub memory: Memory<'a, 'tcx, M>,\n \n     #[allow(dead_code)]\n     // FIXME(@RalfJung): validation branch\n     /// Lvalues that were suspended by the validation subsystem, and will be recovered later\n     pub(crate) suspended: HashMap<DynamicLifetime, Vec<ValidationQuery<'tcx>>>,\n \n     /// Precomputed statics, constants and promoteds.\n-    pub(crate) globals: HashMap<GlobalId<'tcx>, Global<'tcx>>,\n+    pub globals: HashMap<GlobalId<'tcx>, Global<'tcx>>,\n \n     /// The virtual call stack.\n     pub(crate) stack: Vec<Frame<'tcx>>,\n@@ -51,10 +55,6 @@ pub struct EvalContext<'a, 'tcx: 'a> {\n     /// This prevents infinite loops and huge computations from freezing up const eval.\n     /// Remove once halting problem is solved.\n     pub(crate) steps_remaining: u64,\n-\n-    /// Environment variables set by `setenv`\n-    /// Miri does not expose env vars from the host to the emulated program\n-    pub(crate) env_vars: HashMap<Vec<u8>, MemoryPointer>,\n }\n \n /// A stack frame.\n@@ -112,11 +112,6 @@ pub enum StackPopCleanup {\n     /// A regular stackframe added due to a function call will need to get forwarded to the next\n     /// block\n     Goto(mir::BasicBlock),\n-    /// After finishing a tls destructor, find the next one instead of starting from the beginning\n-    /// and thus just rerunning the first one until its `data` argument is null\n-    ///\n-    /// The index is the current tls destructor's index\n-    Tls(Option<TlsKey>),\n     /// The main function and diverging functions have nowhere to return to\n     None,\n }\n@@ -150,17 +145,22 @@ pub struct TyAndPacked<'tcx> {\n     pub packed: bool,\n }\n \n-impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, limits: ResourceLimits) -> Self {\n+impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n+    pub fn new(\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        limits: ResourceLimits,\n+        machine_data: M::Data,\n+        memory_data: M::MemoryData,\n+    ) -> Self {\n         EvalContext {\n+            machine_data,\n             tcx,\n-            memory: Memory::new(&tcx.data_layout, limits.memory_size),\n+            memory: Memory::new(&tcx.data_layout, limits.memory_size, memory_data),\n             suspended: HashMap::new(),\n             globals: HashMap::new(),\n             stack: Vec::new(),\n             stack_limit: limits.stack_limit,\n             steps_remaining: limits.step_limit,\n-            env_vars: HashMap::new(),\n         }\n     }\n \n@@ -179,11 +179,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.memory.allocate(size, align, MemoryKind::Stack)\n     }\n \n-    pub fn memory(&self) -> &Memory<'a, 'tcx> {\n+    pub fn memory(&self) -> &Memory<'a, 'tcx, M> {\n         &self.memory\n     }\n \n-    pub fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx> {\n+    pub fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx, M> {\n         &mut self.memory\n     }\n \n@@ -302,7 +302,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.type_layout_with_substs(ty, substs).map(|layout| layout.align(&self.tcx.data_layout).abi())\n     }\n \n-    pub(super) fn type_layout(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, &'tcx Layout> {\n+    pub fn type_layout(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, &'tcx Layout> {\n         self.type_layout_with_substs(ty, self.substs())\n     }\n \n@@ -414,29 +414,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             },\n             StackPopCleanup::Goto(target) => self.goto_block(target),\n             StackPopCleanup::None => {},\n-            StackPopCleanup::Tls(key) => {\n-                // either fetch the next dtor or start new from the beginning, if any are left with a non-null data\n-                let dtor = match self.memory.fetch_tls_dtor(key)? {\n-                    dtor @ Some(_) => dtor,\n-                    None => self.memory.fetch_tls_dtor(None)?,\n-                };\n-                if let Some((instance, ptr, key)) = dtor {\n-                    trace!(\"Running TLS dtor {:?} on {:?}\", instance, ptr);\n-                    // TODO: Potentially, this has to support all the other possible instances? See eval_fn_call in terminator/mod.rs\n-                    let mir = self.load_mir(instance.def)?;\n-                    self.push_stack_frame(\n-                        instance,\n-                        mir.span,\n-                        mir,\n-                        Lvalue::undef(),\n-                        StackPopCleanup::Tls(Some(key)),\n-                    )?;\n-                    let arg_local = self.frame().mir.args_iter().next().ok_or(EvalError::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()))?;\n-                    let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n-                    let ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n-                    self.write_ptr(dest, ptr, ty)?;\n-                }\n-            }\n         }\n         // deallocate all locals that are backed by an allocation\n         for local in frame.locals {\n@@ -999,7 +976,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.value_to_primval(value, ty)\n     }\n \n-    pub(super) fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, Value> {\n         use rustc::mir::Operand::*;\n         match *op {\n             Consume(ref lvalue) => self.eval_and_read_lvalue(lvalue),\n@@ -1030,7 +1007,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn operand_ty(&self, operand: &mir::Operand<'tcx>) -> Ty<'tcx> {\n+    pub fn operand_ty(&self, operand: &mir::Operand<'tcx>) -> Ty<'tcx> {\n         self.monomorphize(operand.ty(self.mir(), self.tcx), self.substs())\n     }\n \n@@ -1101,7 +1078,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn value_to_primval(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+    pub fn value_to_primval(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         match self.follow_by_ref_value(value, ty)? {\n             Value::ByRef{..} => bug!(\"follow_by_ref_value can't result in `ByRef`\"),\n \n@@ -1114,15 +1091,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn write_null(\n+    pub fn write_null(\n         &mut self,\n         dest: Lvalue<'tcx>,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         self.write_primval(dest, PrimVal::Bytes(0), dest_ty)\n     }\n \n-    pub(super) fn write_ptr(\n+    pub fn write_ptr(\n         &mut self,\n         dest: Lvalue<'tcx>,\n         val: Pointer,\n@@ -1131,7 +1108,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.write_value(val.to_value(), dest, dest_ty)\n     }\n \n-    pub(super) fn write_primval(\n+    pub fn write_primval(\n         &mut self,\n         dest: Lvalue<'tcx>,\n         val: PrimVal,\n@@ -1140,7 +1117,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.write_value(Value::ByVal(val), dest, dest_ty)\n     }\n \n-    pub(super) fn write_value(\n+    pub fn write_value(\n         &mut self,\n         src_val: Value,\n         dest: Lvalue<'tcx>,\n@@ -1489,7 +1466,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(Some(Value::ByVal(val)))\n     }\n \n-    pub(super) fn frame(&self) -> &Frame<'tcx> {\n+    pub fn frame(&self) -> &Frame<'tcx> {\n         self.stack.last().expect(\"no call frames exist\")\n     }\n \n@@ -1607,7 +1584,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn dump_local(&self, lvalue: Lvalue<'tcx>) {\n+    pub fn dump_local(&self, lvalue: Lvalue<'tcx>) {\n         // Debug output\n         if let Lvalue::Local { frame, local } = lvalue {\n             let mut allocs = Vec::new();\n@@ -1678,6 +1655,28 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // }\n         Ok(())\n     }\n+\n+    pub fn report(&self, e: &EvalError) {\n+        if let Some(frame) = self.stack().last() {\n+            let block = &frame.mir.basic_blocks()[frame.block];\n+            let span = if frame.stmt < block.statements.len() {\n+                block.statements[frame.stmt].source_info.span\n+            } else {\n+                block.terminator().source_info.span\n+            };\n+            let mut err = self.tcx.sess.struct_span_err(span, &e.to_string());\n+            for &Frame { instance, span, .. } in self.stack().iter().rev() {\n+                if self.tcx.def_key(instance.def_id()).disambiguated_data.data == DefPathData::ClosureExpr {\n+                    err.span_note(span, \"inside call to closure\");\n+                    continue;\n+                }\n+                err.span_note(span, &format!(\"inside call to {}\", instance));\n+            }\n+            err.emit();\n+        } else {\n+            self.tcx.sess.err(&e.to_string());\n+        }\n+    }\n }\n \n impl<'tcx> Frame<'tcx> {\n@@ -1715,117 +1714,6 @@ impl<'tcx> Frame<'tcx> {\n     }\n }\n \n-pub fn eval_main<'a, 'tcx: 'a>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    main_id: DefId,\n-    start_wrapper: Option<DefId>,\n-    limits: ResourceLimits,\n-) {\n-    fn run_main<'a, 'tcx: 'a>(\n-        ecx: &mut EvalContext<'a, 'tcx>,\n-        main_id: DefId,\n-        start_wrapper: Option<DefId>,\n-    ) -> EvalResult<'tcx> {\n-        let main_instance = ty::Instance::mono(ecx.tcx, main_id);\n-        let main_mir = ecx.load_mir(main_instance.def)?;\n-        let mut cleanup_ptr = None; // Pointer to be deallocated when we are done\n-\n-        if !main_mir.return_ty.is_nil() || main_mir.arg_count != 0 {\n-            return Err(EvalError::Unimplemented(\"miri does not support main functions without `fn()` type signatures\".to_owned()));\n-        }\n-\n-        if let Some(start_id) = start_wrapper {\n-            let start_instance = ty::Instance::mono(ecx.tcx, start_id);\n-            let start_mir = ecx.load_mir(start_instance.def)?;\n-\n-            if start_mir.arg_count != 3 {\n-                return Err(EvalError::AbiViolation(format!(\"'start' lang item should have three arguments, but has {}\", start_mir.arg_count)));\n-            }\n-\n-            // Return value\n-            let ret_ptr = ecx.memory.allocate(ecx.tcx.data_layout.pointer_size.bytes(), ecx.tcx.data_layout.pointer_align.abi(), MemoryKind::Stack)?;\n-            cleanup_ptr = Some(ret_ptr);\n-\n-            // Push our stack frame\n-            ecx.push_stack_frame(\n-                start_instance,\n-                start_mir.span,\n-                start_mir,\n-                Lvalue::from_ptr(ret_ptr),\n-                StackPopCleanup::Tls(None),\n-            )?;\n-\n-            let mut args = ecx.frame().mir.args_iter();\n-\n-            // First argument: pointer to main()\n-            let main_ptr = ecx.memory.create_fn_alloc(main_instance);\n-            let dest = ecx.eval_lvalue(&mir::Lvalue::Local(args.next().unwrap()))?;\n-            let main_ty = main_instance.def.def_ty(ecx.tcx);\n-            let main_ptr_ty = ecx.tcx.mk_fn_ptr(main_ty.fn_sig(ecx.tcx));\n-            ecx.write_value(Value::ByVal(PrimVal::Ptr(main_ptr)), dest, main_ptr_ty)?;\n-\n-            // Second argument (argc): 0\n-            let dest = ecx.eval_lvalue(&mir::Lvalue::Local(args.next().unwrap()))?;\n-            let ty = ecx.tcx.types.isize;\n-            ecx.write_null(dest, ty)?;\n-\n-            // Third argument (argv): 0\n-            let dest = ecx.eval_lvalue(&mir::Lvalue::Local(args.next().unwrap()))?;\n-            let ty = ecx.tcx.mk_imm_ptr(ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8));\n-            ecx.write_null(dest, ty)?;\n-        } else {\n-            ecx.push_stack_frame(\n-                main_instance,\n-                main_mir.span,\n-                main_mir,\n-                Lvalue::undef(),\n-                StackPopCleanup::Tls(None),\n-            )?;\n-        }\n-\n-        while ecx.step()? {}\n-        if let Some(cleanup_ptr) = cleanup_ptr {\n-            ecx.memory.deallocate(cleanup_ptr, None, MemoryKind::Stack)?;\n-        }\n-        return Ok(());\n-    }\n-\n-    let mut ecx = EvalContext::new(tcx, limits);\n-    match run_main(&mut ecx, main_id, start_wrapper) {\n-        Ok(()) => {\n-            let leaks = ecx.memory.leak_report();\n-            if leaks != 0 {\n-                tcx.sess.err(\"the evaluated program leaked memory\");\n-            }\n-        }\n-        Err(e) => {\n-            report(tcx, &ecx, &e);\n-        }\n-    }\n-}\n-\n-fn report(tcx: TyCtxt, ecx: &EvalContext, e: &EvalError) {\n-    if let Some(frame) = ecx.stack().last() {\n-        let block = &frame.mir.basic_blocks()[frame.block];\n-        let span = if frame.stmt < block.statements.len() {\n-            block.statements[frame.stmt].source_info.span\n-        } else {\n-            block.terminator().source_info.span\n-        };\n-        let mut err = tcx.sess.struct_span_err(span, &e.to_string());\n-        for &Frame { instance, span, .. } in ecx.stack().iter().rev() {\n-            if tcx.def_key(instance.def_id()).disambiguated_data.data == DefPathData::ClosureExpr {\n-                err.span_note(span, \"inside call to closure\");\n-                continue;\n-            }\n-            err.span_note(span, &format!(\"inside call to {}\", instance));\n-        }\n-        err.emit();\n-    } else {\n-        tcx.sess.err(&e.to_string());\n-    }\n-}\n-\n // TODO(solson): Upstream these methods into rustc::ty::layout.\n \n pub(super) trait IntegerExt {"}, {"sha": "0d0da53985ec9590734738afb45cb127b5246e2e", "filename": "src/librustc_mir/interpret/lvalue.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs?ref=36502a32b0c916cb2abef987d69e2740320715b7", "patch": "@@ -9,6 +9,7 @@ use super::{\n     EvalContext,\n     MemoryPointer,\n     PrimVal, Value, Pointer,\n+    Machine,\n };\n \n #[derive(Copy, Clone, Debug)]\n@@ -48,15 +49,15 @@ pub enum LvalueExtra {\n pub struct GlobalId<'tcx> {\n     /// For a constant or static, the `Instance` of the item itself.\n     /// For a promoted global, the `Instance` of the function they belong to.\n-    pub(super) instance: ty::Instance<'tcx>,\n+    pub instance: ty::Instance<'tcx>,\n \n     /// The index for promoted globals within their function's `Mir`.\n-    pub(super) promoted: Option<mir::Promoted>,\n+    pub promoted: Option<mir::Promoted>,\n }\n \n #[derive(Clone, Debug)]\n pub struct Global<'tcx> {\n-    pub(super) value: Value,\n+    pub value: Value,\n     /// Only used in `force_allocation` to ensure we don't mark the memory\n     /// before the static is initialized. It is possible to convert a\n     /// global which initially is `Value::ByVal(PrimVal::Undef)` and gets\n@@ -76,7 +77,7 @@ impl<'tcx> Lvalue<'tcx> {\n         Lvalue::Ptr { ptr, extra: LvalueExtra::None, aligned: true }\n     }\n \n-    pub(crate) fn from_ptr(ptr: MemoryPointer) -> Self {\n+    pub fn from_ptr(ptr: MemoryPointer) -> Self {\n         Self::from_primval_ptr(ptr.into())\n     }\n \n@@ -132,7 +133,7 @@ impl<'tcx> Global<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     /// Reads a value from the lvalue without going through the intermediate step of obtaining\n     /// a `miri::Lvalue`\n     pub fn try_read_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n@@ -209,7 +210,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn eval_lvalue(&mut self, mir_lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Lvalue<'tcx>> {\n+    pub fn eval_lvalue(&mut self, mir_lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Lvalue<'tcx>> {\n         use rustc::mir::Lvalue::*;\n         let lvalue = match *mir_lvalue {\n             Local(mir::RETURN_POINTER) => self.frame().return_lvalue,"}, {"sha": "c907928ded0aa2e7ca7b92d991fbf316b8570ae7", "filename": "src/librustc_mir/interpret/machine.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=36502a32b0c916cb2abef987d69e2740320715b7", "patch": "@@ -0,0 +1,33 @@\n+//! This module contains everything needed to instantiate an interpreter.\n+//! This separation exists to ensure that no fancy miri features like\n+//! interpreting common C functions leak into CTFE.\n+\n+use super::{\n+    EvalResult,\n+    EvalContext,\n+    Lvalue,\n+};\n+\n+use rustc::{mir, ty};\n+\n+/// Methods of this trait signifies a point where CTFE evaluation would fail\n+/// and some use case dependent behaviour can instead be applied\n+pub trait Machine<'tcx>: Sized {\n+    /// Additional data that can be accessed via the EvalContext\n+    type Data;\n+\n+    /// Additional data that can be accessed via the Memory\n+    type MemoryData;\n+\n+    /// Called when a function's MIR is not found.\n+    /// This will happen for `extern \"C\"` functions.\n+    fn call_missing_fn<'a>(\n+        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        instance: ty::Instance<'tcx>,\n+        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        arg_operands: &[mir::Operand<'tcx>],\n+        sig: ty::FnSig<'tcx>,\n+        path: String,\n+    ) -> EvalResult<'tcx>;\n+}\n+"}, {"sha": "d5b562730d7c7dbc609ae659ed2c9b08f2b79d4d", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 26, "deletions": 112, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=36502a32b0c916cb2abef987d69e2740320715b7", "patch": "@@ -12,6 +12,7 @@ use super::{\n     EvalError, EvalResult,\n     PrimVal, Pointer,\n     EvalContext, DynamicLifetime,\n+    Machine,\n };\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -211,7 +212,7 @@ impl<'tcx> MemoryPointer {\n         (MemoryPointer::new(self.alloc_id, res), over)\n     }\n \n-    pub(crate) fn offset<C: HasDataLayout>(self, i: u64, cx: C) -> EvalResult<'tcx, Self> {\n+    pub fn offset<C: HasDataLayout>(self, i: u64, cx: C) -> EvalResult<'tcx, Self> {\n         Ok(MemoryPointer::new(self.alloc_id, cx.data_layout().offset(self.offset, i)?))\n     }\n }\n@@ -220,15 +221,10 @@ impl<'tcx> MemoryPointer {\n // Top-level interpreter memory\n ////////////////////////////////////////////////////////////////////////////////\n \n-pub type TlsKey = usize;\n+pub struct Memory<'a, 'tcx, M: Machine<'tcx>> {\n+    /// Additional data required by the Machine\n+    pub data: M::MemoryData,\n \n-#[derive(Copy, Clone, Debug)]\n-pub struct TlsEntry<'tcx> {\n-    data: Pointer, // Will eventually become a map from thread IDs to `Pointer`s, if we ever support more than one thread.\n-    dtor: Option<ty::Instance<'tcx>>,\n-}\n-\n-pub struct Memory<'a, 'tcx> {\n     /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations).\n     alloc_map: HashMap<AllocId, Allocation>,\n \n@@ -261,12 +257,6 @@ pub struct Memory<'a, 'tcx> {\n     /// allocations for string and bytestring literals.\n     literal_alloc_cache: HashMap<Vec<u8>, AllocId>,\n \n-    /// pthreads-style thread-local storage.\n-    thread_local: BTreeMap<TlsKey, TlsEntry<'tcx>>,\n-\n-    /// The Key to use for the next thread-local allocation.\n-    next_thread_local: TlsKey,\n-\n     /// To avoid having to pass flags to every single memory access, we have some global state saying whether\n     /// alignment checking is currently enforced for read and/or write accesses.\n     reads_are_aligned: Cell<bool>,\n@@ -276,9 +266,10 @@ pub struct Memory<'a, 'tcx> {\n     cur_frame: usize,\n }\n \n-impl<'a, 'tcx> Memory<'a, 'tcx> {\n-    pub fn new(layout: &'a TargetDataLayout, max_memory: u64) -> Self {\n+impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n+    pub fn new(layout: &'a TargetDataLayout, max_memory: u64, data: M::MemoryData) -> Self {\n         Memory {\n+            data,\n             alloc_map: HashMap::new(),\n             functions: HashMap::new(),\n             function_alloc_cache: HashMap::new(),\n@@ -288,8 +279,6 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             memory_usage: 0,\n             static_alloc: HashSet::new(),\n             literal_alloc_cache: HashMap::new(),\n-            thread_local: BTreeMap::new(),\n-            next_thread_local: 0,\n             reads_are_aligned: Cell::new(true),\n             writes_are_aligned: Cell::new(true),\n             cur_frame: usize::max_value(),\n@@ -457,85 +446,10 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub(crate) fn set_cur_frame(&mut self, cur_frame: usize) {\n         self.cur_frame = cur_frame;\n     }\n-\n-    pub(crate) fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey {\n-        let new_key = self.next_thread_local;\n-        self.next_thread_local += 1;\n-        self.thread_local.insert(new_key, TlsEntry { data: Pointer::null(), dtor });\n-        trace!(\"New TLS key allocated: {} with dtor {:?}\", new_key, dtor);\n-        return new_key;\n-    }\n-\n-    pub(crate) fn delete_tls_key(&mut self, key: TlsKey) -> EvalResult<'tcx> {\n-        return match self.thread_local.remove(&key) {\n-            Some(_) => {\n-                trace!(\"TLS key {} removed\", key);\n-                Ok(())\n-            },\n-            None => Err(EvalError::TlsOutOfBounds)\n-        }\n-    }\n-\n-    pub(crate) fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Pointer> {\n-        return match self.thread_local.get(&key) {\n-            Some(&TlsEntry { data, .. }) => {\n-                trace!(\"TLS key {} loaded: {:?}\", key, data);\n-                Ok(data)\n-            },\n-            None => Err(EvalError::TlsOutOfBounds)\n-        }\n-    }\n-\n-    pub(crate) fn store_tls(&mut self, key: TlsKey, new_data: Pointer) -> EvalResult<'tcx> {\n-        return match self.thread_local.get_mut(&key) {\n-            Some(&mut TlsEntry { ref mut data, .. }) => {\n-                trace!(\"TLS key {} stored: {:?}\", key, new_data);\n-                *data = new_data;\n-                Ok(())\n-            },\n-            None => Err(EvalError::TlsOutOfBounds)\n-        }\n-    }\n-    \n-    /// Returns a dtor, its argument and its index, if one is supposed to run\n-    ///\n-    /// An optional destructor function may be associated with each key value.\n-    /// At thread exit, if a key value has a non-NULL destructor pointer,\n-    /// and the thread has a non-NULL value associated with that key,\n-    /// the value of the key is set to NULL, and then the function pointed\n-    /// to is called with the previously associated value as its sole argument.\n-    /// The order of destructor calls is unspecified if more than one destructor\n-    /// exists for a thread when it exits.\n-    ///\n-    /// If, after all the destructors have been called for all non-NULL values\n-    /// with associated destructors, there are still some non-NULL values with\n-    /// associated destructors, then the process is repeated.\n-    /// If, after at least {PTHREAD_DESTRUCTOR_ITERATIONS} iterations of destructor\n-    /// calls for outstanding non-NULL values, there are still some non-NULL values\n-    /// with associated destructors, implementations may stop calling destructors,\n-    /// or they may continue calling destructors until no non-NULL values with\n-    /// associated destructors exist, even though this might result in an infinite loop.\n-    pub(crate) fn fetch_tls_dtor(&mut self, key: Option<TlsKey>) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, Pointer, TlsKey)>> {\n-        use std::collections::Bound::*;\n-        let start = match key {\n-            Some(key) => Excluded(key),\n-            None => Unbounded,\n-        };\n-        for (&key, &mut TlsEntry { ref mut data, dtor }) in self.thread_local.range_mut((start, Unbounded)) {\n-            if !data.is_null()? {\n-                if let Some(dtor) = dtor {\n-                    let ret = Some((dtor, *data, key));\n-                    *data = Pointer::null();\n-                    return Ok(ret);\n-                }\n-            }\n-        }\n-        return Ok(None);\n-    }\n }\n \n /// Locking\n-impl<'a, 'tcx> Memory<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     pub(crate) fn check_locks(&self, ptr: MemoryPointer, len: u64, access: AccessKind) -> EvalResult<'tcx> {\n         if len == 0 {\n             return Ok(())\n@@ -658,7 +572,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n }\n \n /// Allocation accessors\n-impl<'a, 'tcx> Memory<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation> {\n         match self.alloc_map.get(&id) {\n             Some(alloc) => Ok(alloc),\n@@ -796,7 +710,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n }\n \n /// Byte accessors\n-impl<'a, 'tcx> Memory<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     fn get_bytes_unchecked(&self, ptr: MemoryPointer, size: u64, align: u64) -> EvalResult<'tcx, &[u8]> {\n         // Zero-sized accesses can use dangling pointers, but they still have to be aligned and non-NULL\n         if self.reads_are_aligned.get() {\n@@ -849,7 +763,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n }\n \n /// Reading and writing\n-impl<'a, 'tcx> Memory<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     /// mark an allocation as being the entry point to a static (see `static_alloc` field)\n     pub fn mark_static(&mut self, alloc_id: AllocId) {\n         trace!(\"mark_static: {:?}\", alloc_id);\n@@ -1159,7 +1073,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n }\n \n /// Relocations\n-impl<'a, 'tcx> Memory<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     fn relocations(&self, ptr: MemoryPointer, size: u64)\n         -> EvalResult<'tcx, btree_map::Range<u64, AllocId>>\n     {\n@@ -1214,7 +1128,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n }\n \n /// Undefined bytes\n-impl<'a, 'tcx> Memory<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     // FIXME(solson): This is a very naive, slow version.\n     fn copy_undef_mask(&mut self, src: MemoryPointer, dest: MemoryPointer, size: u64) -> EvalResult<'tcx> {\n         // The bits have to be saved locally before writing to dest in case src and dest overlap.\n@@ -1397,9 +1311,9 @@ fn bit_index(bits: u64) -> (usize, usize) {\n // Unaligned accesses\n ////////////////////////////////////////////////////////////////////////////////\n \n-pub(crate) trait HasMemory<'a, 'tcx> {\n-    fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx>;\n-    fn memory(&self) -> &Memory<'a, 'tcx>;\n+pub(crate) trait HasMemory<'a, 'tcx, M: Machine<'tcx>> {\n+    fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx, M>;\n+    fn memory(&self) -> &Memory<'a, 'tcx, M>;\n \n     // These are not supposed to be overriden.\n     fn read_maybe_aligned<F, T>(&self, aligned: bool, f: F) -> EvalResult<'tcx, T>\n@@ -1436,26 +1350,26 @@ pub(crate) trait HasMemory<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> HasMemory<'a, 'tcx> for Memory<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> HasMemory<'a, 'tcx, M> for Memory<'a, 'tcx, M> {\n     #[inline]\n-    fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx> {\n+    fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx, M> {\n         self\n     }\n \n     #[inline]\n-    fn memory(&self) -> &Memory<'a, 'tcx> {\n+    fn memory(&self) -> &Memory<'a, 'tcx, M> {\n         self\n     }\n }\n \n-impl<'a, 'tcx> HasMemory<'a, 'tcx> for EvalContext<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> HasMemory<'a, 'tcx, M> for EvalContext<'a, 'tcx, M> {\n     #[inline]\n-    fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx> {\n+    fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx, M> {\n         &mut self.memory\n     }\n \n     #[inline]\n-    fn memory(&self) -> &Memory<'a, 'tcx> {\n+    fn memory(&self) -> &Memory<'a, 'tcx, M> {\n         &self.memory\n     }\n }\n@@ -1517,20 +1431,20 @@ pub trait PointerArithmetic : layout::HasDataLayout {\n \n impl<T: layout::HasDataLayout> PointerArithmetic for T {}\n \n-impl<'a, 'tcx> layout::HasDataLayout for &'a Memory<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> layout::HasDataLayout for &'a Memory<'a, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {\n         self.layout\n     }\n }\n-impl<'a, 'tcx> layout::HasDataLayout for &'a EvalContext<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> layout::HasDataLayout for &'a EvalContext<'a, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {\n         self.memory().layout\n     }\n }\n \n-impl<'c, 'b, 'a, 'tcx> layout::HasDataLayout for &'c &'b mut EvalContext<'a, 'tcx> {\n+impl<'c, 'b, 'a, 'tcx, M: Machine<'tcx>> layout::HasDataLayout for &'c &'b mut EvalContext<'a, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {\n         self.memory().layout"}, {"sha": "10a58ce3e0028e266bffeda12524099b1be64f99", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=36502a32b0c916cb2abef987d69e2740320715b7", "patch": "@@ -1,9 +1,12 @@\n+//! An interpreter for MIR used in CTFE and by miri\n+\n mod cast;\n mod const_eval;\n mod error;\n mod eval_context;\n mod lvalue;\n mod validation;\n+mod machine;\n mod memory;\n mod operator;\n mod step;\n@@ -21,7 +24,6 @@ pub use self::eval_context::{\n     Frame,\n     ResourceLimits,\n     StackPopCleanup,\n-    eval_main,\n     DynamicLifetime,\n     TyAndPacked,\n };\n@@ -38,7 +40,6 @@ pub use self::memory::{\n     Memory,\n     MemoryPointer,\n     Kind,\n-    TlsKey,\n };\n \n use self::memory::{\n@@ -57,6 +58,11 @@ pub use self::value::{\n \n pub use self::const_eval::{\n     eval_body_as_integer,\n+    eval_body_as_primval,\n+};\n+\n+pub use self::machine::{\n+    Machine,\n };\n \n pub use self::validation::{"}, {"sha": "62fe5cc33619dda270227f65f8d6403f333ace56", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=36502a32b0c916cb2abef987d69e2740320715b7", "patch": "@@ -6,6 +6,7 @@ use super::{\n     EvalContext,\n     MemoryPointer,\n     Lvalue,\n+    Machine,\n };\n \n use super::value::{\n@@ -18,7 +19,7 @@ use super::value::{\n     f64_to_bytes,\n };\n \n-impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     fn binop_with_overflow(\n         &mut self,\n         op: mir::BinOp,\n@@ -134,7 +135,7 @@ macro_rules! f64_arithmetic {\n     )\n }\n \n-impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     /// Returns the result of the specified operation and whether it overflowed.\n     pub fn binary_op(\n         &self,"}, {"sha": "96879a75618a1005c61e1347eb43641bb683ef6b", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=36502a32b0c916cb2abef987d69e2740320715b7", "patch": "@@ -17,12 +17,13 @@ use super::{\n     Global, GlobalId, Lvalue,\n     Value, PrimVal,\n     HasMemory,\n+    Machine,\n };\n \n use syntax::codemap::Span;\n use syntax::ast::Mutability;\n \n-impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub fn inc_step_counter_and_check_limit(&mut self, n: u64) -> EvalResult<'tcx> {\n         self.steps_remaining = self.steps_remaining.saturating_sub(n);\n         if self.steps_remaining > 0 {\n@@ -160,15 +161,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n // this includes any method that might access the stack\n // basically don't call anything other than `load_mir`, `alloc_ptr`, `push_stack_frame`\n // The reason for this is, that `push_stack_frame` modifies the stack out of obvious reasons\n-struct ConstantExtractor<'a, 'b: 'a, 'tcx: 'b> {\n+struct ConstantExtractor<'a, 'b: 'a, 'tcx: 'b, M: Machine<'tcx> + 'a> {\n     span: Span,\n-    ecx: &'a mut EvalContext<'b, 'tcx>,\n+    ecx: &'a mut EvalContext<'b, 'tcx, M>,\n     mir: &'tcx mir::Mir<'tcx>,\n     instance: ty::Instance<'tcx>,\n     new_constants: &'a mut EvalResult<'tcx, u64>,\n }\n \n-impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n+impl<'a, 'b, 'tcx, M: Machine<'tcx>> ConstantExtractor<'a, 'b, 'tcx, M> {\n     fn global_item(\n         &mut self,\n         def_id: DefId,\n@@ -223,7 +224,7 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n     }\n }\n \n-impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n+impl<'a, 'b, 'tcx, M: Machine<'tcx>> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx, M> {\n     fn visit_constant(&mut self, constant: &mir::Constant<'tcx>, location: mir::Location) {\n         self.super_constant(constant, location);\n         match constant.literal {"}, {"sha": "5f4bc0b1bd9d5258e42dc3e6b0c11a17278b691d", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=36502a32b0c916cb2abef987d69e2740320715b7", "patch": "@@ -7,9 +7,10 @@ use interpret::{\n     EvalContext, StackPopCleanup,\n     Lvalue, LvalueExtra,\n     PrimVal, Value,\n+    Machine,\n };\n \n-impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub(crate) fn drop_lvalue(&mut self, lval: Lvalue<'tcx>, instance: ty::Instance<'tcx>, ty: Ty<'tcx>, span: Span) -> EvalResult<'tcx> {\n         trace!(\"drop_lvalue: {:#?}\", lval);\n         // We take the address of the object.  This may well be unaligned, which is fine for us here."}, {"sha": "116387051041f8de2739fea6f0dc3d9e2214a1fa", "filename": "src/librustc_mir/interpret/terminator/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fintrinsic.rs?ref=36502a32b0c916cb2abef987d69e2740320715b7", "patch": "@@ -10,9 +10,10 @@ use interpret::{\n     Lvalue, LvalueExtra,\n     PrimVal, PrimValKind, Value, Pointer,\n     HasMemory,\n+    Machine,\n };\n \n-impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub(super) fn call_intrinsic(\n         &mut self,\n         instance: ty::Instance<'tcx>,"}, {"sha": "8861d4bfdc960b9cb3ba2fe679a8e766477051e5", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 6, "deletions": 491, "changes": 497, "blob_url": "https://github.com/rust-lang/rust/blob/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=36502a32b0c916cb2abef987d69e2740320715b7", "patch": "@@ -1,31 +1,27 @@\n-use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc::mir;\n use rustc::ty::{self, TypeVariants, Ty};\n use rustc::ty::layout::Layout;\n use syntax::codemap::Span;\n-use syntax::attr;\n use syntax::abi::Abi;\n \n use super::{\n     EvalError, EvalResult,\n     EvalContext, StackPopCleanup, eval_context, TyAndPacked,\n-    Lvalue, GlobalId,\n-    MemoryPointer, TlsKey, Kind,\n+    Lvalue,\n+    MemoryPointer,\n     PrimVal, Value,\n-    const_eval,\n+    Machine,\n     HasMemory,\n };\n use super::eval_context::IntegerExt;\n \n use rustc_data_structures::indexed_vec::Idx;\n \n-use std::mem;\n-\n mod drop;\n mod intrinsic;\n \n-impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n-    pub(super) fn goto_block(&mut self, target: mir::BasicBlock) {\n+impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n+    pub fn goto_block(&mut self, target: mir::BasicBlock) {\n         self.frame_mut().block = target;\n         self.frame_mut().stmt = 0;\n     }\n@@ -443,7 +439,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 if self.const_env() {\n                     return Err(EvalError::NeedsRfc(format!(\"calling extern function `{}`\", path)));\n                 }\n-                self.call_missing_fn(instance, destination, arg_operands, sig, path)?;\n+                M::call_missing_fn(self, instance, destination, arg_operands, sig, path)?;\n                 return Ok(true);\n             },\n             Err(other) => return Err(other),\n@@ -519,485 +515,4 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         assert!(nndiscr == 0 || nndiscr == 1);\n         Ok(if not_null { nndiscr } else { 1 - nndiscr })\n     }\n-    \n-    /// Returns Ok() when the function was handled, fail otherwise\n-    fn call_missing_fn(\n-        &mut self,\n-        instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n-        arg_operands: &[mir::Operand<'tcx>],\n-        sig: ty::FnSig<'tcx>,\n-        path: String,\n-    ) -> EvalResult<'tcx> {\n-        // In some cases in non-MIR libstd-mode, not having a destination is legit.  Handle these early.\n-        match &path[..] {\n-            \"std::panicking::rust_panic_with_hook\" |\n-            \"std::rt::begin_panic_fmt\" => return Err(EvalError::Panic),\n-            _ => {},\n-        }\n-\n-        let dest_ty = sig.output();\n-        let (dest, dest_block) = destination.ok_or_else(|| EvalError::NoMirFor(path.clone()))?;\n-\n-        if sig.abi == Abi::C {\n-            // An external C function\n-            // TODO: That functions actually has a similar preamble to what follows here.  May make sense to\n-            // unify these two mechanisms for \"hooking into missing functions\".\n-            self.call_c_abi(instance.def_id(), arg_operands, dest, dest_ty, dest_block)?;\n-            return Ok(());\n-        }\n-\n-        let args_res: EvalResult<Vec<Value>> = arg_operands.iter()\n-            .map(|arg| self.eval_operand(arg))\n-            .collect();\n-        let args = args_res?;\n-\n-        let usize = self.tcx.types.usize;\n-    \n-        match &path[..] {\n-            // Allocators are magic.  They have no MIR, even when the rest of libstd does.\n-            \"alloc::heap::::__rust_alloc\" => {\n-                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n-                let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n-                if size == 0 {\n-                    return Err(EvalError::HeapAllocZeroBytes);\n-                }\n-                if !align.is_power_of_two() {\n-                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n-                }\n-                let ptr = self.memory.allocate(size, align, Kind::Rust)?;\n-                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n-            }\n-            \"alloc::heap::::__rust_alloc_zeroed\" => {\n-                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n-                let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n-                if size == 0 {\n-                    return Err(EvalError::HeapAllocZeroBytes);\n-                }\n-                if !align.is_power_of_two() {\n-                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n-                }\n-                let ptr = self.memory.allocate(size, align, Kind::Rust)?;\n-                self.memory.write_repeat(ptr.into(), 0, size)?;\n-                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n-            }\n-            \"alloc::heap::::__rust_dealloc\" => {\n-                let ptr = args[0].into_ptr(&self.memory)?.to_ptr()?;\n-                let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n-                let align = self.value_to_primval(args[2], usize)?.to_u64()?;\n-                if old_size == 0 {\n-                    return Err(EvalError::HeapAllocZeroBytes);\n-                }\n-                if !align.is_power_of_two() {\n-                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n-                }\n-                self.memory.deallocate(ptr, Some((old_size, align)), Kind::Rust)?;\n-            }\n-            \"alloc::heap::::__rust_realloc\" => {\n-                let ptr = args[0].into_ptr(&self.memory)?.to_ptr()?;\n-                let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n-                let old_align = self.value_to_primval(args[2], usize)?.to_u64()?;\n-                let new_size = self.value_to_primval(args[3], usize)?.to_u64()?;\n-                let new_align = self.value_to_primval(args[4], usize)?.to_u64()?;\n-                if old_size == 0 || new_size == 0 {\n-                    return Err(EvalError::HeapAllocZeroBytes);\n-                }\n-                if !old_align.is_power_of_two() {\n-                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(old_align));\n-                }\n-                if !new_align.is_power_of_two() {\n-                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(new_align));\n-                }\n-                let new_ptr = self.memory.reallocate(ptr, old_size, old_align, new_size, new_align, Kind::Rust)?;\n-                self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n-            }\n-\n-            // A Rust function is missing, which means we are running with MIR missing for libstd (or other dependencies).\n-            // Still, we can make many things mostly work by \"emulating\" or ignoring some functions.\n-            \"std::io::_print\" => {\n-                trace!(\"Ignoring output.  To run programs that print, make sure you have a libstd with full MIR.\");\n-            }\n-            \"std::thread::Builder::new\" => return Err(EvalError::Unimplemented(\"miri does not support threading\".to_owned())),\n-            \"std::env::args\" => return Err(EvalError::Unimplemented(\"miri does not support program arguments\".to_owned())),\n-            \"std::panicking::panicking\" |\n-            \"std::rt::panicking\" => {\n-                // we abort on panic -> `std::rt::panicking` always returns false\n-                let bool = self.tcx.types.bool;\n-                self.write_primval(dest, PrimVal::from_bool(false), bool)?;\n-            }\n-            _ => return Err(EvalError::NoMirFor(path)),\n-        }\n-\n-        // Since we pushed no stack frame, the main loop will act\n-        // as if the call just completed and it's returning to the\n-        // current frame.\n-        self.dump_local(dest);\n-        self.goto_block(dest_block);\n-        return Ok(());\n-    }\n-\n-    fn call_c_abi(\n-        &mut self,\n-        def_id: DefId,\n-        arg_operands: &[mir::Operand<'tcx>],\n-        dest: Lvalue<'tcx>,\n-        dest_ty: Ty<'tcx>,\n-        dest_block: mir::BasicBlock,\n-    ) -> EvalResult<'tcx> {\n-        let name = self.tcx.item_name(def_id);\n-        let attrs = self.tcx.get_attrs(def_id);\n-        let link_name = attr::first_attr_value_str_by_name(&attrs, \"link_name\")\n-            .unwrap_or(name)\n-            .as_str();\n-\n-        let args_res: EvalResult<Vec<Value>> = arg_operands.iter()\n-            .map(|arg| self.eval_operand(arg))\n-            .collect();\n-        let args = args_res?;\n-\n-        let usize = self.tcx.types.usize;\n-\n-        match &link_name[..] {\n-            \"malloc\" => {\n-                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n-                if size == 0 {\n-                    self.write_null(dest, dest_ty)?;\n-                } else {\n-                    let align = self.memory.pointer_size();\n-                    let ptr = self.memory.allocate(size, align, Kind::C)?;\n-                    self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n-                }\n-            }\n-\n-            \"free\" => {\n-                let ptr = args[0].into_ptr(&self.memory)?;\n-                if !ptr.is_null()? {\n-                    self.memory.deallocate(ptr.to_ptr()?, None, Kind::C)?;\n-                }\n-            }\n-\n-            \"syscall\" => {\n-                match self.value_to_primval(args[0], usize)?.to_u64()? {\n-                    511 => return Err(EvalError::Unimplemented(\"miri does not support random number generators\".to_owned())),\n-                    id => return Err(EvalError::Unimplemented(format!(\"miri does not support syscall id {}\", id))),\n-                }\n-            }\n-\n-            \"dlsym\" => {\n-                let _handle = args[0].into_ptr(&self.memory)?;\n-                let symbol = args[1].into_ptr(&self.memory)?.to_ptr()?;\n-                let symbol_name = self.memory.read_c_str(symbol)?;\n-                let err = format!(\"bad c unicode symbol: {:?}\", symbol_name);\n-                let symbol_name = ::std::str::from_utf8(symbol_name).unwrap_or(&err);\n-                return Err(EvalError::Unimplemented(format!(\"miri does not support dynamically loading libraries (requested symbol: {})\", symbol_name)));\n-            }\n-\n-            \"__rust_maybe_catch_panic\" => {\n-                // fn __rust_maybe_catch_panic(f: fn(*mut u8), data: *mut u8, data_ptr: *mut usize, vtable_ptr: *mut usize) -> u32\n-                // We abort on panic, so not much is going on here, but we still have to call the closure\n-                let u8_ptr_ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n-                let f = args[0].into_ptr(&self.memory)?.to_ptr()?;\n-                let data = args[1].into_ptr(&self.memory)?;\n-                let f_instance = self.memory.get_fn(f)?;\n-                self.write_null(dest, dest_ty)?;\n-\n-                // Now we make a function call.  TODO: Consider making this re-usable?  EvalContext::step does sth. similar for the TLS dtors,\n-                // and of course eval_main.\n-                let mir = self.load_mir(f_instance.def)?;\n-                self.push_stack_frame(\n-                    f_instance,\n-                    mir.span,\n-                    mir,\n-                    Lvalue::undef(),\n-                    StackPopCleanup::Goto(dest_block),\n-                )?;\n-\n-                let arg_local = self.frame().mir.args_iter().next().ok_or(EvalError::AbiViolation(\"Argument to __rust_maybe_catch_panic does not take enough arguments.\".to_owned()))?;\n-                let arg_dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n-                self.write_ptr(arg_dest, data, u8_ptr_ty)?;\n-\n-                // We ourselves return 0\n-                self.write_null(dest, dest_ty)?;\n-\n-                // Don't fall through\n-                return Ok(());\n-            }\n-\n-            \"__rust_start_panic\" => {\n-                return Err(EvalError::Panic);\n-            }\n-\n-            \"memcmp\" => {\n-                let left = args[0].into_ptr(&self.memory)?;\n-                let right = args[1].into_ptr(&self.memory)?;\n-                let n = self.value_to_primval(args[2], usize)?.to_u64()?;\n-\n-                let result = {\n-                    let left_bytes = self.memory.read_bytes(left, n)?;\n-                    let right_bytes = self.memory.read_bytes(right, n)?;\n-\n-                    use std::cmp::Ordering::*;\n-                    match left_bytes.cmp(right_bytes) {\n-                        Less => -1i8,\n-                        Equal => 0,\n-                        Greater => 1,\n-                    }\n-                };\n-\n-                self.write_primval(dest, PrimVal::Bytes(result as u128), dest_ty)?;\n-            }\n-\n-            \"memrchr\" => {\n-                let ptr = args[0].into_ptr(&self.memory)?;\n-                let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n-                let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n-                if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().rev().position(|&c| c == val) {\n-                    let new_ptr = ptr.offset(num - idx as u64 - 1, &self)?;\n-                    self.write_ptr(dest, new_ptr, dest_ty)?;\n-                } else {\n-                    self.write_null(dest, dest_ty)?;\n-                }\n-            }\n-\n-            \"memchr\" => {\n-                let ptr = args[0].into_ptr(&self.memory)?;\n-                let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n-                let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n-                if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().position(|&c| c == val) {\n-                    let new_ptr = ptr.offset(idx as u64, &self)?;\n-                    self.write_ptr(dest, new_ptr, dest_ty)?;\n-                } else {\n-                    self.write_null(dest, dest_ty)?;\n-                }\n-            }\n-\n-            \"getenv\" => {\n-                let result = {\n-                    let name_ptr = args[0].into_ptr(&self.memory)?.to_ptr()?;\n-                    let name = self.memory.read_c_str(name_ptr)?;\n-                    match self.env_vars.get(name) {\n-                        Some(&var) => PrimVal::Ptr(var),\n-                        None => PrimVal::Bytes(0),\n-                    }\n-                };\n-                self.write_primval(dest, result, dest_ty)?;\n-            }\n-\n-            \"unsetenv\" => {\n-                let mut success = None;\n-                {\n-                    let name_ptr = args[0].into_ptr(&self.memory)?;\n-                    if !name_ptr.is_null()? {\n-                        let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n-                        if !name.is_empty() && !name.contains(&b'=') {\n-                            success = Some(self.env_vars.remove(name));\n-                        }\n-                    }\n-                }\n-                if let Some(old) = success {\n-                    if let Some(var) = old {\n-                        self.memory.deallocate(var, None, Kind::Env)?;\n-                    }\n-                    self.write_null(dest, dest_ty)?;\n-                } else {\n-                    self.write_primval(dest, PrimVal::from_i128(-1), dest_ty)?;\n-                }\n-            }\n-\n-            \"setenv\" => {\n-                let mut new = None;\n-                {\n-                    let name_ptr = args[0].into_ptr(&self.memory)?;\n-                    let value_ptr = args[1].into_ptr(&self.memory)?.to_ptr()?;\n-                    let value = self.memory.read_c_str(value_ptr)?;\n-                    if !name_ptr.is_null()? {\n-                        let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n-                        if !name.is_empty() && !name.contains(&b'=') {\n-                            new = Some((name.to_owned(), value.to_owned()));\n-                        }\n-                    }\n-                }\n-                if let Some((name, value)) = new {\n-                    // +1 for the null terminator\n-                    let value_copy = self.memory.allocate((value.len() + 1) as u64, 1, Kind::Env)?;\n-                    self.memory.write_bytes(value_copy.into(), &value)?;\n-                    let trailing_null = value_copy.offset(value.len() as u64, &self)?.into();\n-                    self.memory.write_bytes(trailing_null, &[0])?;\n-                    if let Some(var) = self.env_vars.insert(name.to_owned(), value_copy) {\n-                        self.memory.deallocate(var, None, Kind::Env)?;\n-                    }\n-                    self.write_null(dest, dest_ty)?;\n-                } else {\n-                    self.write_primval(dest, PrimVal::from_i128(-1), dest_ty)?;\n-                }\n-            }\n-\n-            \"write\" => {\n-                let fd = self.value_to_primval(args[0], usize)?.to_u64()?;\n-                let buf = args[1].into_ptr(&self.memory)?;\n-                let n = self.value_to_primval(args[2], usize)?.to_u64()?;\n-                trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, n);\n-                let result = if fd == 1 || fd == 2 { // stdout/stderr\n-                    use std::io::{self, Write};\n-                \n-                    let buf_cont = self.memory.read_bytes(buf, n)?;\n-                    let res = if fd == 1 { io::stdout().write(buf_cont) } else { io::stderr().write(buf_cont) };\n-                    match res { Ok(n) => n as isize, Err(_) => -1 }\n-                } else {\n-                    info!(\"Ignored output to FD {}\", fd);\n-                    n as isize // pretend it all went well\n-                }; // now result is the value we return back to the program\n-                self.write_primval(dest, PrimVal::Bytes(result as u128), dest_ty)?;\n-            }\n-\n-            \"strlen\" => {\n-                let ptr = args[0].into_ptr(&self.memory)?.to_ptr()?;\n-                let n = self.memory.read_c_str(ptr)?.len();\n-                self.write_primval(dest, PrimVal::Bytes(n as u128), dest_ty)?;\n-            }\n-\n-            // Some things needed for sys::thread initialization to go through\n-            \"signal\" | \"sigaction\" | \"sigaltstack\" => {\n-                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n-            }\n-\n-            \"sysconf\" => {\n-                let name = self.value_to_primval(args[0], usize)?.to_u64()?;\n-                trace!(\"sysconf() called with name {}\", name);\n-                // cache the sysconf integers via miri's global cache\n-                let paths = &[\n-                    (&[\"libc\", \"_SC_PAGESIZE\"], PrimVal::Bytes(4096)),\n-                    (&[\"libc\", \"_SC_GETPW_R_SIZE_MAX\"], PrimVal::from_i128(-1)),\n-                ];\n-                let mut result = None;\n-                for &(path, path_value) in paths {\n-                    if let Ok(instance) = self.resolve_path(path) {\n-                        let cid = GlobalId { instance, promoted: None };\n-                        // compute global if not cached\n-                        let val = match self.globals.get(&cid).map(|glob| glob.value) {\n-                            Some(value) => self.value_to_primval(value, usize)?.to_u64()?,\n-                            None => const_eval::eval_body_as_primval(self.tcx, instance)?.0.to_u64()?,\n-                        };\n-                        if val == name {\n-                            result = Some(path_value);\n-                            break;\n-                        }\n-                    }\n-                }\n-                if let Some(result) = result {\n-                    self.write_primval(dest, result, dest_ty)?;\n-                } else {\n-                    return Err(EvalError::Unimplemented(format!(\"Unimplemented sysconf name: {}\", name)));\n-                }\n-            }\n-\n-            // Hook pthread calls that go to the thread-local storage memory subsystem\n-            \"pthread_key_create\" => {\n-                let key_ptr = args[0].into_ptr(&self.memory)?;\n-\n-                // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n-                let dtor = match args[1].into_ptr(&self.memory)?.into_inner_primval() {\n-                    PrimVal::Ptr(dtor_ptr) => Some(self.memory.get_fn(dtor_ptr)?),\n-                    PrimVal::Bytes(0) => None,\n-                    PrimVal::Bytes(_) => return Err(EvalError::ReadBytesAsPointer),\n-                    PrimVal::Undef => return Err(EvalError::ReadUndefBytes),\n-                };\n-\n-                // Figure out how large a pthread TLS key actually is. This is libc::pthread_key_t.\n-                let key_type = self.operand_ty(&arg_operands[0]).builtin_deref(true, ty::LvaluePreference::NoPreference)\n-                                   .ok_or(EvalError::AbiViolation(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))?.ty;\n-                let key_size = {\n-                    let layout = self.type_layout(key_type)?;\n-                    layout.size(&self.tcx.data_layout)\n-                };\n-\n-                // Create key and write it into the memory where key_ptr wants it\n-                let key = self.memory.create_tls_key(dtor) as u128;\n-                if key_size.bits() < 128 && key >= (1u128 << key_size.bits() as u128) {\n-                    return Err(EvalError::OutOfTls);\n-                }\n-                // TODO: Does this need checking for alignment?\n-                self.memory.write_uint(key_ptr.to_ptr()?, key, key_size.bytes())?;\n-\n-                // Return success (0)\n-                self.write_null(dest, dest_ty)?;\n-            }\n-            \"pthread_key_delete\" => {\n-                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n-                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n-                self.memory.delete_tls_key(key)?;\n-                // Return success (0)\n-                self.write_null(dest, dest_ty)?;\n-            }\n-            \"pthread_getspecific\" => {\n-                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n-                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n-                let ptr = self.memory.load_tls(key)?;\n-                self.write_ptr(dest, ptr, dest_ty)?;\n-            }\n-            \"pthread_setspecific\" => {\n-                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n-                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n-                let new_ptr = args[1].into_ptr(&self.memory)?;\n-                self.memory.store_tls(key, new_ptr)?;\n-                \n-                // Return success (0)\n-                self.write_null(dest, dest_ty)?;\n-            }\n-\n-            // Stub out all the other pthread calls to just return 0\n-            link_name if link_name.starts_with(\"pthread_\") => {\n-                warn!(\"ignoring C ABI call: {}\", link_name);\n-                self.write_null(dest, dest_ty)?;\n-            },\n-\n-            _ => {\n-                return Err(EvalError::Unimplemented(format!(\"can't call C ABI function: {}\", link_name)));\n-            }\n-        }\n-\n-        // Since we pushed no stack frame, the main loop will act\n-        // as if the call just completed and it's returning to the\n-        // current frame.\n-        self.dump_local(dest);\n-        self.goto_block(dest_block);\n-        Ok(())\n-    }\n-\n-    /// Get an instance for a path.\n-    fn resolve_path(&self, path: &[&str]) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n-        let cstore = &self.tcx.sess.cstore;\n-\n-        let crates = cstore.crates();\n-        crates.iter()\n-            .find(|&&krate| cstore.crate_name(krate) == path[0])\n-            .and_then(|krate| {\n-                let krate = DefId {\n-                    krate: *krate,\n-                    index: CRATE_DEF_INDEX,\n-                };\n-                let mut items = cstore.item_children(krate, self.tcx.sess);\n-                let mut path_it = path.iter().skip(1).peekable();\n-\n-                while let Some(segment) = path_it.next() {\n-                    for item in &mem::replace(&mut items, vec![]) {\n-                        if item.ident.name == *segment {\n-                            if path_it.peek().is_none() {\n-                                return Some(ty::Instance::mono(self.tcx, item.def.def_id()));\n-                            }\n-\n-                            items = cstore.item_children(item.def.def_id(), self.tcx.sess);\n-                            break;\n-                        }\n-                    }\n-                }\n-                None\n-            })\n-            .ok_or_else(|| {\n-                let path = path.iter()\n-                    .map(|&s| s.to_owned())\n-                    .collect();\n-                EvalError::PathNotFound(path)\n-            })\n-    }\n }"}, {"sha": "903a3040fea3d53ea680aa8ca0717d31d3117f96", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=36502a32b0c916cb2abef987d69e2740320715b7", "patch": "@@ -10,10 +10,10 @@ use super::{\n     EvalContext, eval_context,\n     MemoryPointer, Kind,\n     Value, PrimVal,\n+    Machine,\n };\n \n-impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n-\n+impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub(crate) fn fulfill_obligation(&self, trait_ref: ty::PolyTraitRef<'tcx>) -> traits::Vtable<'tcx, ()> {\n         // Do the initial selection for the obligation. This yields the shallow result we are\n         // looking for -- that is, what specific impl."}, {"sha": "7a2f4c796d30adef740db7e8d61a3ca47ace6f4c", "filename": "src/librustc_mir/interpret/validation.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs?ref=36502a32b0c916cb2abef987d69e2740320715b7", "patch": "@@ -16,6 +16,7 @@ use super::{\n     AccessKind, LockInfo,\n     PrimVal, Value,\n     Lvalue, LvalueExtra,\n+    Machine,\n };\n \n // FIXME remove this once it lands in rustc\n@@ -56,7 +57,7 @@ impl ValidationMode {\n }\n \n // Validity checks\n-impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub(crate) fn validation_op(&mut self, op: ValidationOp, operand: &ValidationOperand<'tcx, mir::Lvalue<'tcx>>) -> EvalResult<'tcx> {\n         // HACK: Determine if this method is whitelisted and hence we do not perform any validation.\n         {"}, {"sha": "fe109dbbd63a7e25d2844e303e83f90bd7862268", "filename": "src/librustc_mir/interpret/value.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36502a32b0c916cb2abef987d69e2740320715b7/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs?ref=36502a32b0c916cb2abef987d69e2740320715b7", "patch": "@@ -5,7 +5,8 @@ use rustc::ty::layout::HasDataLayout;\n \n use super::{\n     EvalError, EvalResult,\n-    Memory, MemoryPointer, HasMemory, PointerArithmetic\n+    Memory, MemoryPointer, HasMemory, PointerArithmetic,\n+    Machine,\n };\n \n pub(super) fn bytes_to_f32(bytes: u128) -> f32 {\n@@ -75,7 +76,7 @@ impl<'tcx> Pointer {\n         }\n     }\n \n-    pub(crate) fn offset<C: HasDataLayout>(self, i: u64, cx: C) -> EvalResult<'tcx, Self> {\n+    pub fn offset<C: HasDataLayout>(self, i: u64, cx: C) -> EvalResult<'tcx, Self> {\n         let layout = cx.data_layout();\n         match self.primval {\n             PrimVal::Bytes(b) => {\n@@ -170,7 +171,7 @@ impl<'a, 'tcx: 'a> Value {\n \n     /// Convert the value into a pointer (or a pointer-sized integer).  If the value is a ByRef,\n     /// this may have to perform a load.\n-    pub(super) fn into_ptr(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, Pointer> {\n+    pub fn into_ptr<M: Machine<'tcx>>(&self, mem: &Memory<'a, 'tcx, M>) -> EvalResult<'tcx, Pointer> {\n         use self::Value::*;\n         match *self {\n             ByRef { ptr, aligned } => {\n@@ -180,9 +181,9 @@ impl<'a, 'tcx: 'a> Value {\n         }\n     }\n \n-    pub(super) fn into_ptr_vtable_pair(\n+    pub(super) fn into_ptr_vtable_pair<M: Machine<'tcx>>(\n         &self,\n-        mem: &Memory<'a, 'tcx>\n+        mem: &Memory<'a, 'tcx, M>\n     ) -> EvalResult<'tcx, (Pointer, MemoryPointer)> {\n         use self::Value::*;\n         match *self {\n@@ -200,7 +201,7 @@ impl<'a, 'tcx: 'a> Value {\n         }\n     }\n \n-    pub(super) fn into_slice(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, (Pointer, u64)> {\n+    pub(super) fn into_slice<M: Machine<'tcx>>(&self, mem: &Memory<'a, 'tcx, M>) -> EvalResult<'tcx, (Pointer, u64)> {\n         use self::Value::*;\n         match *self {\n             ByRef { ptr: ref_ptr, aligned } => {"}]}