{"sha": "3b3ce374d203445eb1d0dce50f4211f4aceb7db6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiM2NlMzc0ZDIwMzQ0NWViMWQwZGNlNTBmNDIxMWY0YWNlYjdkYjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-26T08:04:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-26T08:04:29Z"}, "message": "Auto merge of #88222 - jyn514:shared-cache, r=GuillaumeGomez\n\nrustdoc: Move Cache from Context to SharedContext\n\nr? `@camelid`", "tree": {"sha": "e7e3048619c1120abf3f382c1e751b4849eb9137", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7e3048619c1120abf3f382c1e751b4849eb9137"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b3ce374d203445eb1d0dce50f4211f4aceb7db6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b3ce374d203445eb1d0dce50f4211f4aceb7db6", "html_url": "https://github.com/rust-lang/rust/commit/3b3ce374d203445eb1d0dce50f4211f4aceb7db6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b3ce374d203445eb1d0dce50f4211f4aceb7db6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76e755cf4afc34af586948e7bc25d2f1c589a884", "url": "https://api.github.com/repos/rust-lang/rust/commits/76e755cf4afc34af586948e7bc25d2f1c589a884", "html_url": "https://github.com/rust-lang/rust/commit/76e755cf4afc34af586948e7bc25d2f1c589a884"}, {"sha": "90ac1ab26af51a08f2434b0201b23519013e9160", "url": "https://api.github.com/repos/rust-lang/rust/commits/90ac1ab26af51a08f2434b0201b23519013e9160", "html_url": "https://github.com/rust-lang/rust/commit/90ac1ab26af51a08f2434b0201b23519013e9160"}], "stats": {"total": 87, "additions": 38, "deletions": 49}, "files": [{"sha": "733bedfdde9b487d2eee214069d469513a5fe366", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3b3ce374d203445eb1d0dce50f4211f4aceb7db6/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3ce374d203445eb1d0dce50f4211f4aceb7db6/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=3b3ce374d203445eb1d0dce50f4211f4aceb7db6", "patch": "@@ -62,16 +62,6 @@ crate struct Context<'tcx> {\n     ///\n     /// [#82381]: https://github.com/rust-lang/rust/issues/82381\n     crate shared: Rc<SharedContext<'tcx>>,\n-    /// The [`Cache`] used during rendering.\n-    ///\n-    /// Ideally the cache would be in [`SharedContext`], but it's mutated\n-    /// between when the `SharedContext` is created and when `Context`\n-    /// is created, so more refactoring would be needed.\n-    ///\n-    /// It's immutable once in `Context`, so it's not as bad that it's not in\n-    /// `SharedContext`.\n-    // FIXME: move `cache` to `SharedContext`\n-    crate cache: Rc<Cache>,\n     /// This flag indicates whether `[src]` links should be generated or not. If\n     /// the source files are present in the html rendering, then this will be\n     /// `true`.\n@@ -80,7 +70,7 @@ crate struct Context<'tcx> {\n \n // `Context` is cloned a lot, so we don't want the size to grow unexpectedly.\n #[cfg(target_arch = \"x86_64\")]\n-rustc_data_structures::static_assert_size!(Context<'_>, 112);\n+rustc_data_structures::static_assert_size!(Context<'_>, 104);\n \n /// Shared mutable state used in [`Context`] and elsewhere.\n crate struct SharedContext<'tcx> {\n@@ -132,6 +122,8 @@ crate struct SharedContext<'tcx> {\n     /// Correspondance map used to link types used in the source code pages to allow to click on\n     /// links to jump to the type's definition.\n     crate span_correspondance_map: FxHashMap<rustc_span::Span, LinkFromSrc>,\n+    /// The [`Cache`] used during rendering.\n+    crate cache: Cache,\n }\n \n impl SharedContext<'_> {\n@@ -162,7 +154,7 @@ impl<'tcx> Context<'tcx> {\n     }\n \n     pub(crate) fn cache(&self) -> &Cache {\n-        &self.cache\n+        &self.shared.cache\n     }\n \n     pub(super) fn sess(&self) -> &'tcx Session {\n@@ -237,7 +229,7 @@ impl<'tcx> Context<'tcx> {\n                 &self.shared.style_files,\n             )\n         } else {\n-            if let Some(&(ref names, ty)) = self.cache.paths.get(&it.def_id.expect_def_id()) {\n+            if let Some(&(ref names, ty)) = self.cache().paths.get(&it.def_id.expect_def_id()) {\n                 let mut path = String::new();\n                 for name in &names[..names.len() - 1] {\n                     path.push_str(name);\n@@ -326,7 +318,7 @@ impl<'tcx> Context<'tcx> {\n                 return None;\n             }\n         } else {\n-            let (krate, src_root) = match *self.cache.extern_locations.get(&cnum)? {\n+            let (krate, src_root) = match *self.cache().extern_locations.get(&cnum)? {\n                 ExternalLocation::Local => {\n                     let e = ExternalCrate { crate_num: cnum };\n                     (e.name(self.tcx()), e.src_root(self.tcx()))\n@@ -487,6 +479,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             show_type_layout,\n             templates,\n             span_correspondance_map: matches,\n+            cache,\n         };\n \n         // Add the default themes to the `Vec` of stylepaths\n@@ -511,7 +504,6 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             render_redirect_pages: false,\n             id_map: RefCell::new(id_map),\n             shared: Rc::new(scx),\n-            cache: Rc::new(cache),\n             include_sources,\n         };\n \n@@ -520,7 +512,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n         }\n \n         // Build our search index\n-        let index = build_index(&krate, Rc::get_mut(&mut cx.cache).unwrap(), tcx);\n+        let index = build_index(&krate, &mut Rc::get_mut(&mut cx.shared).unwrap().cache, tcx);\n \n         // Write shared runs within a flock; disable thread dispatching of IO temporarily.\n         Rc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(true);\n@@ -536,7 +528,6 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             render_redirect_pages: self.render_redirect_pages,\n             id_map: RefCell::new(IdMap::new()),\n             shared: Rc::clone(&self.shared),\n-            cache: Rc::clone(&self.cache),\n             include_sources: self.include_sources,\n         }\n     }\n@@ -561,7 +552,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             extra_scripts: &[],\n             static_extra_scripts: &[],\n         };\n-        let sidebar = if let Some(ref version) = self.cache.crate_version {\n+        let sidebar = if let Some(ref version) = self.shared.cache.crate_version {\n             format!(\n                 \"<h2 class=\\\"location\\\">Crate {}</h2>\\\n                      <div class=\\\"block version\\\">\\\n@@ -722,7 +713,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n     }\n \n     fn cache(&self) -> &Cache {\n-        &self.cache\n+        &self.shared.cache\n     }\n }\n "}, {"sha": "7704abc9a72c8e6ef2f445c08f45ec0d4c6946e7", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3b3ce374d203445eb1d0dce50f4211f4aceb7db6/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3ce374d203445eb1d0dce50f4211f4aceb7db6/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=3b3ce374d203445eb1d0dce50f4211f4aceb7db6", "patch": "@@ -1012,11 +1012,11 @@ fn render_assoc_items(\n     what: AssocItemRender<'_>,\n ) {\n     info!(\"Documenting associated items of {:?}\", containing_item.name);\n-    let v = match cx.cache.impls.get(&it) {\n+    let cache = cx.cache();\n+    let v = match cache.impls.get(&it) {\n         Some(v) => v,\n         None => return,\n     };\n-    let cache = cx.cache();\n     let (non_trait, traits): (Vec<_>, _) = v.iter().partition(|i| i.inner_impl().trait_.is_none());\n     if !non_trait.is_empty() {\n         let render_mode = match what {\n@@ -1063,11 +1063,11 @@ fn render_assoc_items(\n     if !traits.is_empty() {\n         let deref_impl = traits\n             .iter()\n-            .find(|t| t.inner_impl().trait_.def_id_full(cache) == cx.cache.deref_trait_did);\n+            .find(|t| t.inner_impl().trait_.def_id_full(cache) == cache.deref_trait_did);\n         if let Some(impl_) = deref_impl {\n             let has_deref_mut = traits\n                 .iter()\n-                .any(|t| t.inner_impl().trait_.def_id_full(cache) == cx.cache.deref_mut_trait_did);\n+                .any(|t| t.inner_impl().trait_.def_id_full(cache) == cache.deref_mut_trait_did);\n             render_deref_methods(w, cx, impl_, containing_item, has_deref_mut);\n         }\n         let (synthetic, concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n@@ -1122,6 +1122,7 @@ fn render_deref_methods(\n     container_item: &clean::Item,\n     deref_mut: bool,\n ) {\n+    let cache = cx.cache();\n     let deref_type = impl_.inner_impl().trait_.as_ref().unwrap();\n     let (target, real_target) = impl_\n         .inner_impl()\n@@ -1138,8 +1139,8 @@ fn render_deref_methods(\n     debug!(\"Render deref methods for {:#?}, target {:#?}\", impl_.inner_impl().for_, target);\n     let what =\n         AssocItemRender::DerefFor { trait_: deref_type, type_: real_target, deref_mut_: deref_mut };\n-    if let Some(did) = target.def_id_full(cx.cache()) {\n-        if let Some(type_did) = impl_.inner_impl().for_.def_id_full(cx.cache()) {\n+    if let Some(did) = target.def_id_full(cache) {\n+        if let Some(type_did) = impl_.inner_impl().for_.def_id_full(cache) {\n             // `impl Deref<Target = S> for S`\n             if did == type_did {\n                 // Avoid infinite cycles\n@@ -1149,7 +1150,7 @@ fn render_deref_methods(\n         render_assoc_items(w, cx, container_item, did, what);\n     } else {\n         if let Some(prim) = target.primitive_type() {\n-            if let Some(&did) = cx.cache.primitive_locations.get(&prim) {\n+            if let Some(&did) = cache.primitive_locations.get(&prim) {\n                 render_assoc_items(w, cx, container_item, did, what);\n             }\n         }\n@@ -1286,7 +1287,7 @@ fn render_impl(\n         let render_method_item = match render_mode {\n             RenderMode::Normal => true,\n             RenderMode::ForDeref { mut_: deref_mut_ } => {\n-                should_render_item(&item, deref_mut_, &cx.cache)\n+                should_render_item(&item, deref_mut_, cx.cache())\n             }\n         };\n \n@@ -1678,7 +1679,7 @@ fn print_sidebar(cx: &Context<'_>, it: &clean::Item, buffer: &mut Buffer) {\n     }\n \n     if it.is_crate() {\n-        if let Some(ref version) = cx.cache.crate_version {\n+        if let Some(ref version) = cx.cache().crate_version {\n             write!(\n                 buffer,\n                 \"<div class=\\\"block version\\\">\\\n@@ -1825,18 +1826,16 @@ fn small_url_encode(s: String) -> String {\n \n fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n     let did = it.def_id.expect_def_id();\n-    if let Some(v) = cx.cache.impls.get(&did) {\n+    let cache = cx.cache();\n+    if let Some(v) = cache.impls.get(&did) {\n         let mut used_links = FxHashSet::default();\n-        let cache = cx.cache();\n \n         {\n             let used_links_bor = &mut used_links;\n             let mut ret = v\n                 .iter()\n                 .filter(|i| i.inner_impl().trait_.is_none())\n-                .flat_map(move |i| {\n-                    get_methods(i.inner_impl(), false, used_links_bor, false, &cx.cache)\n-                })\n+                .flat_map(move |i| get_methods(i.inner_impl(), false, used_links_bor, false, cache))\n                 .collect::<Vec<_>>();\n             if !ret.is_empty() {\n                 // We want links' order to be reproducible so we don't use unstable sort.\n@@ -1857,7 +1856,7 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n             if let Some(impl_) = v\n                 .iter()\n                 .filter(|i| i.inner_impl().trait_.is_some())\n-                .find(|i| i.inner_impl().trait_.def_id_full(cache) == cx.cache.deref_trait_did)\n+                .find(|i| i.inner_impl().trait_.def_id_full(cache) == cache.deref_trait_did)\n             {\n                 sidebar_deref_methods(cx, out, impl_, v);\n             }\n@@ -2117,15 +2116,15 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n         \"</div>\",\n     );\n \n-    if let Some(implementors) = cx.cache.implementors.get(&it.def_id.expect_def_id()) {\n-        let cache = cx.cache();\n+    let cache = cx.cache();\n+    if let Some(implementors) = cache.implementors.get(&it.def_id.expect_def_id()) {\n         let mut res = implementors\n             .iter()\n             .filter(|i| {\n                 i.inner_impl()\n                     .for_\n                     .def_id_full(cache)\n-                    .map_or(false, |d| !cx.cache.paths.contains_key(&d))\n+                    .map_or(false, |d| !cache.paths.contains_key(&d))\n             })\n             .filter_map(|i| extract_for_impl_name(&i.impl_item, cx))\n             .collect::<Vec<_>>();"}, {"sha": "8f4857a693928bce2e982e227044521cfc7e1df3", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3b3ce374d203445eb1d0dce50f4211f4aceb7db6/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3ce374d203445eb1d0dce50f4211f4aceb7db6/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=3b3ce374d203445eb1d0dce50f4211f4aceb7db6", "patch": "@@ -690,7 +690,8 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n     // If there are methods directly on this trait object, render them here.\n     render_assoc_items(w, cx, it, it.def_id.expect_def_id(), AssocItemRender::All);\n \n-    if let Some(implementors) = cx.cache.implementors.get(&it.def_id.expect_def_id()) {\n+    let cache = cx.cache();\n+    if let Some(implementors) = cache.implementors.get(&it.def_id.expect_def_id()) {\n         // The DefId is for the first Type found with that name. The bool is\n         // if any Types with the same name but different DefId have been found.\n         let mut implementor_dups: FxHashMap<Symbol, (DefId, bool)> = FxHashMap::default();\n@@ -712,10 +713,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         }\n \n         let (local, foreign) = implementors.iter().partition::<Vec<_>, _>(|i| {\n-            i.inner_impl()\n-                .for_\n-                .def_id_full(cx.cache())\n-                .map_or(true, |d| cx.cache.paths.contains_key(&d))\n+            i.inner_impl().for_.def_id_full(cache).map_or(true, |d| cache.paths.contains_key(&d))\n         });\n \n         let (mut synthetic, mut concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n@@ -772,7 +770,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n                     it,\n                     w,\n                     &implementor_dups,\n-                    &collect_paths_for_type(implementor.inner_impl().for_.clone(), &cx.cache),\n+                    &collect_paths_for_type(implementor.inner_impl().for_.clone(), cache),\n                 );\n             }\n             w.write_str(\"</div>\");\n@@ -806,7 +804,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         path = if it.def_id.is_local() {\n             cx.current.join(\"/\")\n         } else {\n-            let (ref path, _) = cx.cache.external_paths[&it.def_id.expect_def_id()];\n+            let (ref path, _) = cache.external_paths[&it.def_id.expect_def_id()];\n             path[..path.len() - 1].join(\"/\")\n         },\n         ty = it.type_(),"}, {"sha": "99cd98f7eaeb84592f18d3287bc35f85cef10842", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3b3ce374d203445eb1d0dce50f4211f4aceb7db6/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3ce374d203445eb1d0dce50f4211f4aceb7db6/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=3b3ce374d203445eb1d0dce50f4211f4aceb7db6", "patch": "@@ -518,17 +518,18 @@ pub(super) fn write_shared(\n \n     // Update the list of all implementors for traits\n     let dst = cx.dst.join(\"implementors\");\n-    for (&did, imps) in &cx.cache.implementors {\n+    let cache = cx.cache();\n+    for (&did, imps) in &cache.implementors {\n         // Private modules can leak through to this phase of rustdoc, which\n         // could contain implementations for otherwise private types. In some\n         // rare cases we could find an implementation for an item which wasn't\n         // indexed, so we just skip this step in that case.\n         //\n         // FIXME: this is a vague explanation for why this can't be a `get`, in\n         //        theory it should be...\n-        let &(ref remote_path, remote_item_type) = match cx.cache.paths.get(&did) {\n+        let &(ref remote_path, remote_item_type) = match cache.paths.get(&did) {\n             Some(p) => p,\n-            None => match cx.cache.external_paths.get(&did) {\n+            None => match cache.external_paths.get(&did) {\n                 Some(p) => p,\n                 None => continue,\n             },\n@@ -557,7 +558,7 @@ pub(super) fn write_shared(\n                     Some(Implementor {\n                         text: imp.inner_impl().print(false, cx).to_string(),\n                         synthetic: imp.inner_impl().synthetic,\n-                        types: collect_paths_for_type(imp.inner_impl().for_.clone(), cx.cache()),\n+                        types: collect_paths_for_type(imp.inner_impl().for_.clone(), cache),\n                     })\n                 }\n             })\n@@ -566,7 +567,7 @@ pub(super) fn write_shared(\n         // Only create a js file if we have impls to add to it. If the trait is\n         // documented locally though we always create the file to avoid dead\n         // links.\n-        if implementors.is_empty() && !cx.cache.paths.contains_key(&did) {\n+        if implementors.is_empty() && !cache.paths.contains_key(&did) {\n             continue;\n         }\n "}]}