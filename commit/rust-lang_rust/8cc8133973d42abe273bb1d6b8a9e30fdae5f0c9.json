{"sha": "8cc8133973d42abe273bb1d6b8a9e30fdae5f0c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjYzgxMzM5NzNkNDJhYmUyNzNiYjFkNmI4YTllMzBmZGFlNWYwYzk=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-08T23:16:45Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-10T10:16:06Z"}, "message": "Fix calls to resolver from rustdoc and HIR lowering\n\nCleanup some surrounding code.\nSupport resolution of intra doc links in unnamed block scopes.\n(Paths from rustdoc now use early resolution and no longer need results of late resolution like all the built ribs.)\n\nFix one test hitting file path limits on Windows.", "tree": {"sha": "6ab13161450f533a752f4c260c4e4fd17f7445fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ab13161450f533a752f4c260c4e4fd17f7445fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8cc8133973d42abe273bb1d6b8a9e30fdae5f0c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8cc8133973d42abe273bb1d6b8a9e30fdae5f0c9", "html_url": "https://github.com/rust-lang/rust/commit/8cc8133973d42abe273bb1d6b8a9e30fdae5f0c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8cc8133973d42abe273bb1d6b8a9e30fdae5f0c9/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f360d795f1ac31ed0e4e2f3225f9122db73e1b92", "url": "https://api.github.com/repos/rust-lang/rust/commits/f360d795f1ac31ed0e4e2f3225f9122db73e1b92", "html_url": "https://github.com/rust-lang/rust/commit/f360d795f1ac31ed0e4e2f3225f9122db73e1b92"}], "stats": {"total": 109, "additions": 48, "deletions": 61}, "files": [{"sha": "42acbd1106b6bb3daecdf6c9569b70f85d51193c", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8cc8133973d42abe273bb1d6b8a9e30fdae5f0c9/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cc8133973d42abe273bb1d6b8a9e30fdae5f0c9/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=8cc8133973d42abe273bb1d6b8a9e30fdae5f0c9", "patch": "@@ -37,7 +37,7 @@ use crate::hir::{self, ParamName};\n use crate::hir::HirVec;\n use crate::hir::map::{DefKey, DefPathData, Definitions};\n use crate::hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n-use crate::hir::def::{Res, DefKind, PartialRes, PerNS};\n+use crate::hir::def::{Namespace, Res, DefKind, PartialRes, PerNS};\n use crate::hir::{GenericArg, ConstArg};\n use crate::hir::ptr::P;\n use crate::lint::builtin::{self, PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n@@ -148,13 +148,6 @@ pub struct LoweringContext<'a> {\n }\n \n pub trait Resolver {\n-    /// Resolve a path generated by the lowerer when expanding `for`, `if let`, etc.\n-    fn resolve_ast_path(\n-        &mut self,\n-        path: &ast::Path,\n-        is_value: bool,\n-    ) -> Res<NodeId>;\n-\n     /// Obtain resolution for a `NodeId` with a single resolution.\n     fn get_partial_res(&mut self, id: NodeId) -> Option<PartialRes>;\n \n@@ -175,7 +168,7 @@ pub trait Resolver {\n         span: Span,\n         crate_root: Option<Symbol>,\n         components: &[Symbol],\n-        is_value: bool,\n+        ns: Namespace,\n     ) -> (ast::Path, Res<NodeId>);\n \n     fn has_derives(&self, node_id: NodeId, derives: SpecialDerives) -> bool;\n@@ -5717,8 +5710,8 @@ impl<'a> LoweringContext<'a> {\n         params: Option<P<hir::GenericArgs>>,\n         is_value: bool,\n     ) -> hir::Path {\n-        let (path, res) = self.resolver\n-            .resolve_str_path(span, self.crate_root, components, is_value);\n+        let ns = if is_value { Namespace::ValueNS } else { Namespace::TypeNS };\n+        let (path, res) = self.resolver.resolve_str_path(span, self.crate_root, components, ns);\n \n         let mut segments: Vec<_> = path.segments.iter().map(|segment| {\n             let res = self.expect_full_res(segment.id);"}, {"sha": "7cb11195ee02ba0538dcf2ae06a8877c1969d5a7", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cc8133973d42abe273bb1d6b8a9e30fdae5f0c9/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cc8133973d42abe273bb1d6b8a9e30fdae5f0c9/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=8cc8133973d42abe273bb1d6b8a9e30fdae5f0c9", "patch": "@@ -541,7 +541,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         crate_lint: CrateLint,\n     ) -> PathResult<'a> {\n         self.r.resolve_path_with_ribs(\n-            path, opt_ns, &self.parent_scope, record_used, path_span, crate_lint, &self.ribs\n+            path, opt_ns, &self.parent_scope, record_used, path_span, crate_lint, Some(&self.ribs)\n         )\n     }\n "}, {"sha": "c5aabb5e0686775efde67dbb6a73ccd8ec1d0580", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 34, "deletions": 35, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/8cc8133973d42abe273bb1d6b8a9e30fdae5f0c9/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cc8133973d42abe273bb1d6b8a9e30fdae5f0c9/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8cc8133973d42abe273bb1d6b8a9e30fdae5f0c9", "patch": "@@ -987,26 +987,12 @@ impl<'a, 'b> ty::DefIdTree for &'a Resolver<'b> {\n /// This interface is used through the AST\u2192HIR step, to embed full paths into the HIR. After that\n /// the resolver is no longer needed as all the relevant information is inline.\n impl<'a> hir::lowering::Resolver for Resolver<'a> {\n-    fn resolve_ast_path(\n-        &mut self,\n-        path: &ast::Path,\n-        is_value: bool,\n-    ) -> Res {\n-        match self.resolve_ast_path_inner(path, is_value) {\n-            Ok(r) => r,\n-            Err((span, error)) => {\n-                self.report_error(span, error);\n-                Res::Err\n-            }\n-        }\n-    }\n-\n     fn resolve_str_path(\n         &mut self,\n         span: Span,\n         crate_root: Option<Symbol>,\n         components: &[Symbol],\n-        is_value: bool\n+        ns: Namespace,\n     ) -> (ast::Path, Res) {\n         let root = if crate_root.is_some() {\n             kw::PathRoot\n@@ -1025,7 +1011,14 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n             segments,\n         };\n \n-        let res = self.resolve_ast_path(&path, is_value);\n+        let parent_scope = &self.dummy_parent_scope();\n+        let res = match self.resolve_ast_path(&path, ns, parent_scope) {\n+            Ok(res) => res,\n+            Err((span, error)) => {\n+                self.report_error(span, error);\n+                Res::Err\n+            }\n+        };\n         (path, res)\n     }\n \n@@ -1738,7 +1731,7 @@ impl<'a> Resolver<'a> {\n         crate_lint: CrateLint,\n     ) -> PathResult<'a> {\n         self.resolve_path_with_ribs(\n-            path, opt_ns, parent_scope, record_used, path_span, crate_lint, &Default::default()\n+            path, opt_ns, parent_scope, record_used, path_span, crate_lint, None\n         )\n     }\n \n@@ -1750,7 +1743,7 @@ impl<'a> Resolver<'a> {\n         record_used: bool,\n         path_span: Span,\n         crate_lint: CrateLint,\n-        ribs: &PerNS<Vec<Rib<'a>>>,\n+        ribs: Option<&PerNS<Vec<Rib<'a>>>>,\n     ) -> PathResult<'a> {\n         let mut module = None;\n         let mut allow_super = true;\n@@ -1864,16 +1857,17 @@ impl<'a> Resolver<'a> {\n                 self.resolve_ident_in_module(\n                     module, ident, ns, parent_scope, record_used, path_span\n                 )\n-            } else if opt_ns.is_none() || opt_ns == Some(MacroNS) {\n-                assert!(ns == TypeNS);\n-                let scopes = if opt_ns.is_none() { ScopeSet::Import(ns) } else { ScopeSet::Module };\n+            } else if ribs.is_none() || opt_ns.is_none() || opt_ns == Some(MacroNS) {\n+                // FIXME: Decouple the import property from `ScopeSet`.\n+                let is_import = opt_ns.is_none() || ns != TypeNS;\n+                let scopes = if is_import { ScopeSet::Import(ns) } else { ScopeSet::Module };\n                 self.early_resolve_ident_in_lexical_scope(ident, scopes, parent_scope, record_used,\n                                                           record_used, path_span)\n             } else {\n                 let record_used_id =\n                     if record_used { crate_lint.node_id().or(Some(CRATE_NODE_ID)) } else { None };\n                 match self.resolve_ident_in_lexical_scope(\n-                    ident, ns, parent_scope, record_used_id, path_span, &ribs[ns]\n+                    ident, ns, parent_scope, record_used_id, path_span, &ribs.unwrap()[ns]\n                 ) {\n                     // we found a locally-imported or available item/module\n                     Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n@@ -2639,8 +2633,10 @@ impl<'a> Resolver<'a> {\n     /// isn't something that can be returned because it can't be made to live that long,\n     /// and also it's a private type. Fortunately rustdoc doesn't need to know the error,\n     /// just that an error occurred.\n-    pub fn resolve_str_path_error(&mut self, span: Span, path_str: &str, is_value: bool)\n-        -> Result<(ast::Path, Res), ()> {\n+    // FIXME(Manishearth): intra-doc links won't get warned of epoch changes.\n+    pub fn resolve_str_path_error(\n+        &mut self, span: Span, path_str: &str, ns: Namespace, module_id: NodeId\n+    ) -> Result<(ast::Path, Res), ()> {\n         let path = if path_str.starts_with(\"::\") {\n             ast::Path {\n                 span,\n@@ -2661,28 +2657,31 @@ impl<'a> Resolver<'a> {\n                     .collect(),\n             }\n         };\n-        let res = self.resolve_ast_path_inner(&path, is_value).map_err(|_| ())?;\n+        let module = self.block_map.get(&module_id).copied().unwrap_or_else(|| {\n+            let def_id = self.definitions.local_def_id(module_id);\n+            self.module_map.get(&def_id).copied().unwrap_or(self.graph_root)\n+        });\n+        let parent_scope = &ParentScope { module, ..self.dummy_parent_scope() };\n+        let res = self.resolve_ast_path(&path, ns, parent_scope).map_err(|_| ())?;\n         Ok((path, res))\n     }\n \n-    /// Like `resolve_ast_path`, but takes a callback in case there was an error.\n-    fn resolve_ast_path_inner(\n+    // Resolve a path passed from rustdoc or HIR lowering.\n+    fn resolve_ast_path(\n         &mut self,\n         path: &ast::Path,\n-        is_value: bool,\n+        ns: Namespace,\n+        parent_scope: &ParentScope<'a>,\n     ) -> Result<Res, (Span, ResolutionError<'a>)> {\n-        let namespace = if is_value { ValueNS } else { TypeNS };\n-        let span = path.span;\n-        let path = Segment::from_path(&path);\n-        // FIXME(Manishearth): intra-doc links won't get warned of epoch changes.\n-        let parent_scope = &self.dummy_parent_scope();\n-        match self.resolve_path(&path, Some(namespace), parent_scope, true, span, CrateLint::No) {\n+        match self.resolve_path(\n+            &Segment::from_path(path), Some(ns), parent_scope, true, path.span, CrateLint::No\n+        ) {\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n                 Ok(module.res().unwrap()),\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 =>\n                 Ok(path_res.base_res()),\n             PathResult::NonModule(..) => {\n-                Err((span, ResolutionError::FailedToResolve {\n+                Err((path.span, ResolutionError::FailedToResolve {\n                     label: String::from(\"type-relative paths are not supported in this context\"),\n                     suggestion: None,\n                 }))"}, {"sha": "5c9fac7eab42175ac66f8cfa7c385f222098c22d", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8cc8133973d42abe273bb1d6b8a9e30fdae5f0c9/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cc8133973d42abe273bb1d6b8a9e30fdae5f0c9/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=8cc8133973d42abe273bb1d6b8a9e30fdae5f0c9", "patch": "@@ -61,15 +61,11 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     {\n         let cx = self.cx;\n \n-        // In case we're in a module, try to resolve the relative\n-        // path.\n-        if let Some(id) = parent_id.or(self.mod_ids.last().cloned()) {\n-            // FIXME: `with_scope` requires the `NodeId` of a module.\n-            let node_id = cx.tcx.hir().hir_to_node_id(id);\n+        // In case we're in a module, try to resolve the relative path.\n+        if let Some(module_id) = parent_id.or(self.mod_ids.last().cloned()) {\n+            let module_id = cx.tcx.hir().hir_to_node_id(module_id);\n             let result = cx.enter_resolver(|resolver| {\n-                resolver.with_scope(node_id, |resolver| {\n-                    resolver.resolve_str_path_error(DUMMY_SP, &path_str, ns == ValueNS)\n-                })\n+                resolver.resolve_str_path_error(DUMMY_SP, &path_str, ns, module_id)\n             });\n             let result = match result {\n                 Ok((_, Res::Err)) => Err(()),\n@@ -85,6 +81,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     Res::Def(DefKind::AssocTy, _) => false,\n                     Res::Def(DefKind::Variant, _) => return handle_variant(cx, res),\n                     // Not a trait item; just return what we found.\n+                    Res::PrimTy(..) => return Ok((res, Some(path_str.to_owned()))),\n                     _ => return Ok((res, None))\n                 };\n \n@@ -133,11 +130,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     .ok_or(());\n             }\n \n-            // FIXME: `with_scope` requires the `NodeId` of a module.\n-            let node_id = cx.tcx.hir().hir_to_node_id(id);\n-            let (_, ty_res) = cx.enter_resolver(|resolver| resolver.with_scope(node_id, |resolver| {\n-                    resolver.resolve_str_path_error(DUMMY_SP, &path, false)\n-            }))?;\n+            let (_, ty_res) = cx.enter_resolver(|resolver| {\n+                resolver.resolve_str_path_error(DUMMY_SP, &path, TypeNS, module_id)\n+            })?;\n             if let Res::Err = ty_res {\n                 return Err(());\n             }"}, {"sha": "877940c74037bbf7bad004a631591235a4ffd987", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-pick-original-type-alias-impl-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cc8133973d42abe273bb1d6b8a9e30fdae5f0c9/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original-type-alias-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cc8133973d42abe273bb1d6b8a9e30fdae5f0c9/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original-type-alias-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original-type-alias-impl-trait.rs?ref=8cc8133973d42abe273bb1d6b8a9e30fdae5f0c9", "patch": "@@ -1,5 +1,5 @@\n // edition:2018\n-// build-pass (FIXME(62277): could be check-pass?)\n+// check-pass\n // revisions: migrate mir\n //[mir]compile-flags: -Z borrowck=mir\n "}]}