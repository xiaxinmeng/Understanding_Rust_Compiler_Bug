{"sha": "c8237db3eed2c91c14ce46b482b3d479a39d328d", "node_id": "C_kwDOAAsO6NoAKGM4MjM3ZGIzZWVkMmM5MWMxNGNlNDZiNDgyYjNkNDc5YTM5ZDMyOGQ", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-02-16T01:06:36Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-02-17T11:24:34Z"}, "message": "Clarify iterator interners.\n\nThere are two traits, `InternAs` and `InternIteratorElement`. I found\nthem confusing to use, particularly this:\n```\npub fn mk_tup<I: InternAs<Ty<'tcx>, Ty<'tcx>>>(self, iter: I) -> I::Output {\n    iter.intern_with(|ts| self.intern_tup(ts))\n}\n```\nwhere I thought there might have been two levels of interning going on\n(there isn't) due to the `intern_with`/`InternAs` + `intern_tup` naming.\n\nAnd then I found the actual traits and impls themselves *very*\nconfusing.\n- `InternAs` has a single impl, for iterators, with four type variables.\n- `InternAs` is only implemented for iterators because it wouldn't\n  really make sense to implement for any other type. And you can't\n  really understand the trait without seeing that single impl, which is\n  suspicious.\n- `InternAs` is basically just a wrapper for `InternIteratorElement`\n  which does all the actual work.\n- Neither trait actually does any interning. They just have `Intern` in\n  their name because they are used *by* interning code.\n- There are no comments.\n\nSo this commit improves things.\n- It removes `InternAs` completely. This makes the `mk_*` function\n  signatures slightly more verbose -- two trait bounds instead of one --\n  but much easier to read, because you only need to understand one trait\n  instead of two.\n- It renames `InternIteratorElement` as `CollectAndApply`. Likewise, it\n  renames its method `intern_with` as `collect_and_apply`. These names\n  describe better what's going on: we collect the iterator elements into\n  a slice and then apply a function to the slice.\n- It adds comments, making clear that all this is all there just to\n  provide an optimized version of `f(&iter.collect::<Vec<_>>())`.\n\nIt took me a couple of attempts to come up with this commit. My initial\nattempt kept `InternAs` around, but renamed things and added comments,\nand I wasn't happy with it. I think this version is much better. The\nresulting code is shorter, despite the addition of the comments.", "tree": {"sha": "e99c61c1267e35d7bc1e6e03528989178490745f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e99c61c1267e35d7bc1e6e03528989178490745f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8237db3eed2c91c14ce46b482b3d479a39d328d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8237db3eed2c91c14ce46b482b3d479a39d328d", "html_url": "https://github.com/rust-lang/rust/commit/c8237db3eed2c91c14ce46b482b3d479a39d328d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8237db3eed2c91c14ce46b482b3d479a39d328d/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d5cf0f0bf2f241c2d7a6250ad7f8e3a7dbf3d95", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d5cf0f0bf2f241c2d7a6250ad7f8e3a7dbf3d95", "html_url": "https://github.com/rust-lang/rust/commit/9d5cf0f0bf2f241c2d7a6250ad7f8e3a7dbf3d95"}], "stats": {"total": 157, "additions": 87, "deletions": 70}, "files": [{"sha": "7b4434a3843567d3705c20e3028699d024619f94", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 54, "deletions": 41, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/c8237db3eed2c91c14ce46b482b3d479a39d328d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8237db3eed2c91c14ce46b482b3d479a39d328d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=c8237db3eed2c91c14ce46b482b3d479a39d328d", "patch": "@@ -67,7 +67,7 @@ use rustc_target::abi::{Layout, LayoutS, TargetDataLayout, VariantIdx};\n use rustc_target::spec::abi;\n use rustc_type_ir::sty::TyKind::*;\n use rustc_type_ir::WithCachedTypeInfo;\n-use rustc_type_ir::{DynKind, InternAs, InternIteratorElement, Interner, TypeFlags};\n+use rustc_type_ir::{CollectAndApply, DynKind, Interner, TypeFlags};\n \n use std::any::Any;\n use std::borrow::Borrow;\n@@ -1835,8 +1835,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         if ts.is_empty() { self.types.unit } else { self.mk_ty(Tuple(self.intern_type_list(&ts))) }\n     }\n \n-    pub fn mk_tup<I: InternAs<Ty<'tcx>, Ty<'tcx>>>(self, iter: I) -> I::Output {\n-        iter.intern_with(|ts| self.intern_tup(ts))\n+    pub fn mk_tup<I, T>(self, iter: I) -> T::Output\n+    where\n+        I: Iterator<Item = T>,\n+        T: CollectAndApply<Ty<'tcx>, Ty<'tcx>>,\n+    {\n+        T::collect_and_apply(iter, |ts| self.intern_tup(ts))\n     }\n \n     #[inline]\n@@ -2157,11 +2161,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn mk_const_list<I: InternAs<ty::Const<'tcx>, &'tcx List<ty::Const<'tcx>>>>(\n-        self,\n-        iter: I,\n-    ) -> I::Output {\n-        iter.intern_with(|xs| self.intern_const_list(xs))\n+    pub fn mk_const_list<I, T>(self, iter: I) -> T::Output\n+    where\n+        I: Iterator<Item = T>,\n+        T: CollectAndApply<ty::Const<'tcx>, &'tcx List<ty::Const<'tcx>>>,\n+    {\n+        T::collect_and_apply(iter, |xs| self.intern_const_list(xs))\n     }\n \n     pub fn intern_const_list(self, cs: &[ty::Const<'tcx>]) -> &'tcx List<ty::Const<'tcx>> {\n@@ -2220,48 +2225,57 @@ impl<'tcx> TyCtxt<'tcx> {\n     ) -> T::Output\n     where\n         I: Iterator<Item = T>,\n-        T: InternIteratorElement<Ty<'tcx>, ty::FnSig<'tcx>>,\n+        T: CollectAndApply<Ty<'tcx>, ty::FnSig<'tcx>>,\n     {\n-        inputs.chain(iter::once(output)).intern_with(|xs| ty::FnSig {\n+        T::collect_and_apply(inputs.chain(iter::once(output)), |xs| ty::FnSig {\n             inputs_and_output: self.intern_type_list(xs),\n             c_variadic,\n             unsafety,\n             abi,\n         })\n     }\n \n-    pub fn mk_poly_existential_predicates<\n-        I: InternAs<PolyExistentialPredicate<'tcx>, &'tcx List<PolyExistentialPredicate<'tcx>>>,\n-    >(\n-        self,\n-        iter: I,\n-    ) -> I::Output {\n-        iter.intern_with(|xs| self.intern_poly_existential_predicates(xs))\n+    pub fn mk_poly_existential_predicates<I, T>(self, iter: I) -> T::Output\n+    where\n+        I: Iterator<Item = T>,\n+        T: CollectAndApply<\n+                PolyExistentialPredicate<'tcx>,\n+                &'tcx List<PolyExistentialPredicate<'tcx>>,\n+            >,\n+    {\n+        T::collect_and_apply(iter, |xs| self.intern_poly_existential_predicates(xs))\n     }\n \n-    pub fn mk_predicates<I: InternAs<Predicate<'tcx>, &'tcx List<Predicate<'tcx>>>>(\n-        self,\n-        iter: I,\n-    ) -> I::Output {\n-        iter.intern_with(|xs| self.intern_predicates(xs))\n+    pub fn mk_predicates<I, T>(self, iter: I) -> T::Output\n+    where\n+        I: Iterator<Item = T>,\n+        T: CollectAndApply<Predicate<'tcx>, &'tcx List<Predicate<'tcx>>>,\n+    {\n+        T::collect_and_apply(iter, |xs| self.intern_predicates(xs))\n     }\n \n-    pub fn mk_type_list<I: InternAs<Ty<'tcx>, &'tcx List<Ty<'tcx>>>>(self, iter: I) -> I::Output {\n-        iter.intern_with(|xs| self.intern_type_list(xs))\n+    pub fn mk_type_list<I, T>(self, iter: I) -> T::Output\n+    where\n+        I: Iterator<Item = T>,\n+        T: CollectAndApply<Ty<'tcx>, &'tcx List<Ty<'tcx>>>,\n+    {\n+        T::collect_and_apply(iter, |xs| self.intern_type_list(xs))\n     }\n \n-    pub fn mk_substs<I: InternAs<GenericArg<'tcx>, &'tcx List<GenericArg<'tcx>>>>(\n-        self,\n-        iter: I,\n-    ) -> I::Output {\n-        iter.intern_with(|xs| self.intern_substs(xs))\n+    pub fn mk_substs<I, T>(self, iter: I) -> T::Output\n+    where\n+        I: Iterator<Item = T>,\n+        T: CollectAndApply<GenericArg<'tcx>, &'tcx List<GenericArg<'tcx>>>,\n+    {\n+        T::collect_and_apply(iter, |xs| self.intern_substs(xs))\n     }\n \n-    pub fn mk_place_elems<I: InternAs<PlaceElem<'tcx>, &'tcx List<PlaceElem<'tcx>>>>(\n-        self,\n-        iter: I,\n-    ) -> I::Output {\n-        iter.intern_with(|xs| self.intern_place_elems(xs))\n+    pub fn mk_place_elems<I, T>(self, iter: I) -> T::Output\n+    where\n+        I: Iterator<Item = T>,\n+        T: CollectAndApply<PlaceElem<'tcx>, &'tcx List<PlaceElem<'tcx>>>,\n+    {\n+        T::collect_and_apply(iter, |xs| self.intern_place_elems(xs))\n     }\n \n     pub fn mk_substs_trait(\n@@ -2290,13 +2304,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         ty::AliasTy { def_id, substs, _use_mk_alias_ty_instead: () }\n     }\n \n-    pub fn mk_bound_variable_kinds<\n-        I: InternAs<ty::BoundVariableKind, &'tcx List<ty::BoundVariableKind>>,\n-    >(\n-        self,\n-        iter: I,\n-    ) -> I::Output {\n-        iter.intern_with(|xs| self.intern_bound_variable_kinds(xs))\n+    pub fn mk_bound_variable_kinds<I, T>(self, iter: I) -> T::Output\n+    where\n+        I: Iterator<Item = T>,\n+        T: CollectAndApply<ty::BoundVariableKind, &'tcx List<ty::BoundVariableKind>>,\n+    {\n+        T::collect_and_apply(iter, |xs| self.intern_bound_variable_kinds(xs))\n     }\n \n     /// Emit a lint at `span` from a lint struct (some type that implements `DecorateLint`,"}, {"sha": "5a991e03dee52bcd42a0e6e72a9af0fba945fa7a", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/c8237db3eed2c91c14ce46b482b3d479a39d328d/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8237db3eed2c91c14ce46b482b3d479a39d328d/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=c8237db3eed2c91c14ce46b482b3d479a39d328d", "patch": "@@ -69,38 +69,37 @@ pub trait Interner: Sized {\n     type PlaceholderRegion: Clone + Debug + Hash + Ord;\n }\n \n-pub trait InternAs<T: ?Sized, R> {\n+/// Imagine you have a function `F: FnOnce(&[T]) -> R`, plus an iterator `iter`\n+/// that produces `T` items. You could combine them with\n+/// `f(&iter.collect::<Vec<_>>())`, but this requires allocating memory for the\n+/// `Vec`.\n+///\n+/// This trait allows for faster implementations, intended for cases where the\n+/// number of items produced by the iterator is small. There is a blanket impl\n+/// for `T` items, but there is also a fallible impl for `Result<T, E>` items.\n+pub trait CollectAndApply<T, R>: Sized {\n     type Output;\n-    fn intern_with<F>(self, f: F) -> Self::Output\n+\n+    /// Produce a result of type `Self::Output` from `iter`. The result will\n+    /// typically be produced by applying `f` on the elements produced by\n+    /// `iter`, though this may not happen in some impls, e.g. if an error\n+    /// occured during iteration.\n+    fn collect_and_apply<I, F>(iter: I, f: F) -> Self::Output\n     where\n+        I: Iterator<Item = Self>,\n         F: FnOnce(&[T]) -> R;\n }\n \n-impl<I, T, R, E> InternAs<T, R> for I\n-where\n-    E: InternIteratorElement<T, R>,\n-    I: Iterator<Item = E>,\n-{\n-    type Output = E::Output;\n-    fn intern_with<F>(self, f: F) -> Self::Output\n+/// The blanket impl that always collects all elements and applies `f`.\n+impl<T, R> CollectAndApply<T, R> for T {\n+    type Output = R;\n+\n+    /// Equivalent to `f(&iter.collect::<Vec<_>>())`.\n+    fn collect_and_apply<I, F>(mut iter: I, f: F) -> R\n     where\n+        I: Iterator<Item = T>,\n         F: FnOnce(&[T]) -> R,\n     {\n-        E::intern_with(self, f)\n-    }\n-}\n-\n-pub trait InternIteratorElement<T, R>: Sized {\n-    type Output;\n-    fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(iter: I, f: F) -> Self::Output;\n-}\n-\n-impl<T, R> InternIteratorElement<T, R> for T {\n-    type Output = R;\n-    fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(\n-        mut iter: I,\n-        f: F,\n-    ) -> Self::Output {\n         // This code is hot enough that it's worth specializing for the most\n         // common length lists, to avoid the overhead of `SmallVec` creation.\n         // Lengths 0, 1, and 2 typically account for ~95% of cases. If\n@@ -127,12 +126,17 @@ impl<T, R> InternIteratorElement<T, R> for T {\n     }\n }\n \n-impl<T, R, E> InternIteratorElement<T, R> for Result<T, E> {\n+/// A fallible impl that will fail, without calling `f`, if there are any\n+/// errors during collection.\n+impl<T, R, E> CollectAndApply<T, R> for Result<T, E> {\n     type Output = Result<R, E>;\n-    fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(\n-        mut iter: I,\n-        f: F,\n-    ) -> Self::Output {\n+\n+    /// Equivalent to `Ok(f(&iter.collect::<Result<Vec<_>>>()?))`.\n+    fn collect_and_apply<I, F>(mut iter: I, f: F) -> Result<R, E>\n+    where\n+        I: Iterator<Item = Result<T, E>>,\n+        F: FnOnce(&[T]) -> R,\n+    {\n         // This code is hot enough that it's worth specializing for the most\n         // common length lists, to avoid the overhead of `SmallVec` creation.\n         // Lengths 0, 1, and 2 typically account for ~95% of cases. If"}]}