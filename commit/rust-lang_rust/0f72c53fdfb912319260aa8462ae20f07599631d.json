{"sha": "0f72c53fdfb912319260aa8462ae20f07599631d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmNzJjNTNmZGZiOTEyMzE5MjYwYWE4NDYyYWUyMGYwNzU5OTYzMWQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-12T11:56:23Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-12T12:19:02Z"}, "message": "Go over the tutorial again\n\nEdit some things, make sure all code runs.", "tree": {"sha": "dc362dc8c59c2427a4e694eac28f8437e32016b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc362dc8c59c2427a4e694eac28f8437e32016b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f72c53fdfb912319260aa8462ae20f07599631d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f72c53fdfb912319260aa8462ae20f07599631d", "html_url": "https://github.com/rust-lang/rust/commit/0f72c53fdfb912319260aa8462ae20f07599631d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f72c53fdfb912319260aa8462ae20f07599631d/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44352df57c04996b12d14ba92967d6637d154906", "url": "https://api.github.com/repos/rust-lang/rust/commits/44352df57c04996b12d14ba92967d6637d154906", "html_url": "https://github.com/rust-lang/rust/commit/44352df57c04996b12d14ba92967d6637d154906"}], "stats": {"total": 673, "additions": 343, "deletions": 330}, "files": [{"sha": "d02e9236c576ecadb8c20cf02a8035cb961db3e2", "filename": "doc/tutorial/args.md", "status": "modified", "additions": 69, "deletions": 61, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/0f72c53fdfb912319260aa8462ae20f07599631d/doc%2Ftutorial%2Fargs.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f72c53fdfb912319260aa8462ae20f07599631d/doc%2Ftutorial%2Fargs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fargs.md?ref=0f72c53fdfb912319260aa8462ae20f07599631d", "patch": "@@ -3,36 +3,39 @@\n Rust datatypes are not trivial to copy (the way, for example,\n JavaScript values can be copied by simply taking one or two machine\n words and plunking them somewhere else). Shared boxes require\n-reference count updates, big records or tags require an arbitrary\n-amount of data to be copied (plus updating the reference counts of\n-shared boxes hanging off them), unique pointers require their origin\n-to be de-initialized.\n+reference count updates, big records, tags, or unique pointers require\n+an arbitrary amount of data to be copied (plus updating the reference\n+counts of shared boxes hanging off them).\n \n-For this reason, the way Rust passes arguments to functions is a bit\n-more involved than it is in most languages. It performs some\n-compile-time cleverness to get rid of most of the cost of copying\n-arguments, and forces you to put in explicit copy operators in the\n-places where it can not.\n+For this reason, the default calling convention for Rust functions\n+leaves ownership of the arguments with the caller. The caller\n+guarantees that the arguments will outlive the call, the callee merely\n+gets access to them.\n \n ## Safe references\n \n-The foundation of Rust's argument-passing optimization is the fact\n-that Rust tasks for single-threaded worlds, which share no data with\n-other tasks, and that most data is immutable.\n+There is one catch with this approach: sometimes the compiler can\n+*not* statically guarantee that the argument value at the caller side\n+will survive to the end of the call. Another argument might indirectly\n+refer to it and be used to overwrite it, or a closure might assign a\n+new value to it.\n+\n+Fortunately, Rust tasks are single-threaded worlds, which share no\n+data with other tasks, and that most data is immutable. This allows\n+most argument-passing situations to be proved safe without further\n+difficulty.\n \n Take the following program:\n \n     # fn get_really_big_record() -> int { 1 }\n     # fn myfunc(a: int) {}\n-    let x = get_really_big_record();\n-    myfunc(x);\n-\n-We want to pass `x` to `myfunc` by pointer (which is easy), *and* we\n-want to ensure that `x` stays intact for the duration of the call\n-(which, in this example, is also easy). So we can just use the\n-existing value as the argument, without copying.\n+    fn main() {\n+        let x = get_really_big_record();\n+        myfunc(x);\n+    }\n \n-There are more involved cases. The call could look like this:\n+Here we know for sure that no one else has access to the `x` variable\n+in `main`, so we're good. But the call could also look like this:\n \n     # fn myfunc(a: int, b: block()) {}\n     # fn get_another_record() -> int { 1 }\n@@ -43,14 +46,11 @@ Now, if `myfunc` first calls its second argument and then accesses its\n first argument, it will see a different value from the one that was\n passed to it.\n \n-The compiler will insert an implicit copy of `x` in such a case,\n+In such a case, the compiler will insert an implicit copy of `x`,\n *except* if `x` contains something mutable, in which case a copy would\n-result in code that behaves differently (if you mutate the copy, `x`\n-stays unchanged). That would be bad, so the compiler will disallow\n-such code.\n-\n-When inserting an implicit copy for something big, the compiler will\n-warn, so that you know that the code is not as efficient as it looks.\n+result in code that behaves differently. If copying `x` might be\n+expensive (for example, if it holds a vector), the compiler will emit\n+a warning.\n \n There are even more tricky cases, in which the Rust compiler is forced\n to pessimistically assume a value will get mutated, even though it is\n@@ -81,51 +81,59 @@ with the `copy` operator:\n        for elt in v { iter(copy elt); }\n     }\n \n-## Argument passing styles\n-\n-The fact that arguments are conceptually passed by safe reference does\n-not mean all arguments are passed by pointer. Composite types like\n-records and tags *are* passed by pointer, but others, like integers\n-and pointers, are simply passed by value.\n-\n-It is possible, when defining a function, to specify a passing style\n-for a parameter by prefixing the parameter name with a symbol. The\n-most common special style is by-mutable-reference, written `&`:\n-\n-    fn vec_push(&v: [int], elt: int) {\n-        v += [elt];\n-    }\n-\n-This will make it possible for the function to mutate the parameter.\n-Clearly, you are only allowed to pass things that can actually be\n-mutated to such a function.\n-\n-Another style is by-move, which will cause the argument to become\n-de-initialized on the caller side, and give ownership of it to the\n-called function. This is written `-`.\n-\n-Finally, the default passing styles (by-value for non-structural\n-types, by-reference for structural ones) are written `++` for by-value\n-and `&&` for by(-immutable)-reference. It is sometimes necessary to\n-override the defaults. We'll talk more about this when discussing\n-[generics][gens].\n-\n-[gens]: generic.html\n+Adding a `copy` operator is also the way to muffle warnings about\n+implicit copies.\n \n ## Other uses of safe references\n \n Safe references are not only used for argument passing. When you\n destructure on a value in an `alt` expression, or loop over a vector\n with `for`, variables bound to the inside of the given data structure\n-will use safe references, not copies. This means such references have\n-little overhead, but you'll occasionally have to copy them to ensure\n+will use safe references, not copies. This means such references are\n+very cheap, but you'll occasionally have to copy them to ensure\n safety.\n \n     let my_rec = {a: 4, b: [1, 2, 3]};\n     alt my_rec {\n       {a, b} {\n-        log b; // This is okay\n+        log(info, b); // This is okay\n         my_rec = {a: a + 1, b: b + [a]};\n-        log b; // Here reference b has become invalid\n+        log(info, b); // Here reference b has become invalid\n       }\n     }\n+\n+## Argument passing styles\n+\n+The fact that arguments are conceptually passed by safe reference does\n+not mean all arguments are passed by pointer. Composite types like\n+records and tags *are* passed by pointer, but single-word values, like\n+integers and pointers, are simply passed by value. Most of the time,\n+the programmer does not have to worry about this, as the compiler will\n+simply pick the most efficient passing style. There is one exception,\n+which will be described in the section on [generics](generic.html).\n+\n+To explicitly set the passing-style for a parameter, you prefix the\n+argument name with a sigil. There are two special passing styles that\n+are often useful. The first is by-mutable-pointer, written with a\n+single `&`:\n+\n+    fn vec_push(&v: [int], elt: int) {\n+        v += [elt];\n+    }\n+\n+This allows the function to mutate the value of the argument, *in the\n+caller's context*. Clearly, you are only allowed to pass things that\n+can actually be mutated to such a function.\n+\n+Then there is the by-copy style, written `+`. This indicates that the\n+function wants to take ownership of the argument value. If the caller\n+does not use the argument after the call, it will be 'given' to the\n+callee. Otherwise a copy will be made. This mode is mostly used for\n+functions that construct data structures. The argument will end up\n+being owned by the data structure, so if that can be done without a\n+copy, that's a win.\n+\n+    type person = {name: str, address: str};\n+    fn make_person(+name: str, +address: str) -> person {\n+        ret {name: name, address: address};\n+    }"}, {"sha": "e13d976aa794838464097a1d39e21074b54cda90", "filename": "doc/tutorial/control.md", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0f72c53fdfb912319260aa8462ae20f07599631d/doc%2Ftutorial%2Fcontrol.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f72c53fdfb912319260aa8462ae20f07599631d/doc%2Ftutorial%2Fcontrol.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fcontrol.md?ref=0f72c53fdfb912319260aa8462ae20f07599631d", "patch": "@@ -67,9 +67,9 @@ that `(float, float)` is a tuple of two floats:\n \n     fn angle(vec: (float, float)) -> float {\n         alt vec {\n-          (0f, y) if y < 0f { 1.5 * std::math::pi }\n-          (0f, y) { 0.5 * std::math::pi }\n-          (x, y) { std::math::atan(y / x) }\n+          (0f, y) if y < 0f { 1.5 * float::consts::pi }\n+          (0f, y) { 0.5 * float::consts::pi }\n+          (x, y) { float::atan(y / x) }\n         }\n     }\n \n@@ -79,7 +79,7 @@ y)` matches any tuple whose first element is zero, and binds `y` to\n the second element. `(x, y)` matches any tuple, and binds both\n elements to a variable.\n \n-Any `alt` arm can have a guard clause (written `when EXPR`), which is\n+Any `alt` arm can have a guard clause (written `if EXPR`), which is\n an expression of type `bool` that determines, after the pattern is\n found to match, whether the arm is taken or not. The variables bound\n by the pattern are available in this guard expression.\n@@ -111,7 +111,7 @@ to abort the current iteration and continue with the next.\n     while true {\n         x += x - 3;\n         if x % 5 == 0 { break; }\n-        std::io::println(std::int::str(x));\n+        std::io::println(int::str(x));\n     }\n \n This code prints out a weird sequence of numbers and stops as soon as\n@@ -161,24 +161,32 @@ Logging is polymorphic\u2014any type of value can be logged, and the\n runtime will do its best to output a textual representation of the\n value.\n \n-    log \"hi\";\n-    log (1, [2.5, -1.8]);\n+    log(warn, \"hi\");\n+    log(error, (1, [2.5, -1.8]));\n \n-By default, you *will not* see the output of your log statements. The\n-environment variable `RUST_LOG` controls which log statements actually\n-get output. It can contain a comma-separated list of paths for modules\n-that should be logged. For example, running `rustc` with\n-`RUST_LOG=rustc::front::attr` will turn on logging in its attribute\n-parser. If you compile a program `foo.rs`, you can set `RUST_LOG` to\n-`foo` to enable its logging.\n+The first argument is the log level (levels `info`, `warn`, and\n+`error` are predefined), and the second is the value to log. By\n+default, you *will not* see the output of that first log statement,\n+which has `warn` level. The environment variable `RUST_LOG` controls\n+which log level is used. It can contain a comma-separated list of\n+paths for modules that should be logged. For example, running `rustc`\n+with `RUST_LOG=rustc::front::attr` will turn on logging in its\n+attribute parser. If you compile a program named `foo.rs`, its\n+top-level module will be called `foo`, and you can set `RUST_LOG` to\n+`foo` to enable `warn` and `info` logging for the module.\n \n Turned-off `log` statements impose minimal overhead on the code that\n contains them, so except in code that needs to be really, really fast,\n you should feel free to scatter around debug logging statements, and\n leave them in.\n \n-For interactive debugging, you often want unconditional logging. For\n-this, use `log_err` instead of `log` [FIXME better name].\n+Three macros that combine text-formatting (as with `#fmt`) and logging\n+are available. These take a string and any number of format arguments,\n+and will log the formatted string:\n+\n+    # fn get_error_string() -> str { \"boo\" }\n+    #warn(\"only %d seconds remaining\", 10);\n+    #error(\"fatal: %s\", get_error_string());\n \n ## Assertions\n "}, {"sha": "678714d388bfb76c031b9de7ba26774601ae714d", "filename": "doc/tutorial/data.md", "status": "modified", "additions": 45, "deletions": 48, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/0f72c53fdfb912319260aa8462ae20f07599631d/doc%2Ftutorial%2Fdata.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f72c53fdfb912319260aa8462ae20f07599631d/doc%2Ftutorial%2Fdata.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fdata.md?ref=0f72c53fdfb912319260aa8462ae20f07599631d", "patch": "@@ -1,11 +1,11 @@\n # Datatypes\n \n Rust datatypes are, by default, immutable. The core datatypes of Rust\n-are structural records and 'tags' (tagged unions, algebraic data\n+are structural records and 'enums' (tagged unions, algebraic data\n types).\n \n     type point = {x: float, y: float};\n-    tag shape {\n+    enum shape {\n         circle(point, float);\n         rectangle(point, point);\n     }\n@@ -26,8 +26,8 @@ example...\n \n     type stack = {content: [int], mutable head: uint};\n \n-With such a type, you can do `mystack.head += 1u`. When the `mutable`\n-is omitted from the type, such an assignment would result in a type\n+With such a type, you can do `mystack.head += 1u`. If `mutable` were\n+omitted from the type, such an assignment would result in a type\n error.\n \n To 'update' an immutable record, you use functional record update\n@@ -67,13 +67,13 @@ same order they appear in the type. When you are not interested in all\n the fields of a record, a record pattern may end with `, _` (as in\n `{field1, _}`) to indicate that you're ignoring all other fields.\n \n-## Tags\n+## Enums\n \n-Tags [FIXME terminology] are datatypes that have several different\n-representations. For example, the type shown earlier:\n+Enums are datatypes that have several different representations. For\n+example, the type shown earlier:\n \n     # type point = {x: float, y: float};\n-    tag shape {\n+    enum shape {\n         circle(point, float);\n         rectangle(point, point);\n     }\n@@ -90,10 +90,10 @@ which can be used to construct values of the type (taking arguments of\n the specified types). So `circle({x: 0f, y: 0f}, 10f)` is the way to\n create a new circle.\n \n-Tag variants do not have to have parameters. This, for example, is\n-equivalent to an `enum` in C:\n+Enum variants do not have to have parameters. This, for example, is\n+equivalent to a C enum:\n \n-    tag direction {\n+    enum direction {\n         north;\n         east;\n         south;\n@@ -103,36 +103,36 @@ equivalent to an `enum` in C:\n This will define `north`, `east`, `south`, and `west` as constants,\n all of which have type `direction`.\n \n-<a name=\"single_variant_tag\"></a>\n+<a name=\"single_variant_enum\"></a>\n \n-There is a special case for tags with a single variant. These are used\n-to define new types in such a way that the new name is not just a\n+There is a special case for enums with a single variant. These are\n+used to define new types in such a way that the new name is not just a\n synonym for an existing type, but its own distinct type. If you say:\n \n-    tag gizmo_id = int;\n+    enum gizmo_id = int;\n \n That is a shorthand for this:\n \n-    tag gizmo_id { gizmo_id(int); }\n+    enum gizmo_id { gizmo_id(int); }\n \n-Tag types like this can have their content extracted with the\n+Enum types like this can have their content extracted with the\n dereference (`*`) unary operator:\n \n-    # tag gizmo_id = int;\n+    # enum gizmo_id = int;\n     let my_gizmo_id = gizmo_id(10);\n     let id_int: int = *my_gizmo_id;\n \n-## Tag patterns\n+## Enum patterns\n \n-For tag types with multiple variants, destructuring is the only way to\n+For enum types with multiple variants, destructuring is the only way to\n get at their contents. All variant constructors can be used as\n patterns, as in this definition of `area`:\n \n     # type point = {x: float, y: float};\n-    # tag shape { circle(point, float); rectangle(point, point); }\n+    # enum shape { circle(point, float); rectangle(point, point); }\n     fn area(sh: shape) -> float {\n         alt sh {\n-            circle(_, size) { std::math::pi * size * size }\n+            circle(_, size) { float::consts::pi * size * size }\n             rectangle({x, y}, {x: x2, y: y2}) { (x2 - x) * (y2 - y) }\n         }\n     }\n@@ -142,7 +142,7 @@ a dot at the end) to match them in a pattern. This to prevent\n ambiguity between matching a variant name and binding a new variable.\n \n     # type point = {x: float, y: float};\n-    # tag direction { north; east; south; west; }\n+    # enum direction { north; east; south; west; }\n     fn point_from_direction(dir: direction) -> point {\n         alt dir {\n             north. { {x:  0f, y:  1f} }\n@@ -161,22 +161,22 @@ Tuples can have any arity except for 0 or 1 (though you may see nil,\n \n     let mytup: (int, int, float) = (10, 20, 30.0);\n     alt mytup {\n-      (a, b, c) { log a + b + (c as int); }\n+      (a, b, c) { log(info, a + b + (c as int)); }\n     }\n \n ## Pointers\n \n-In contrast to a lot of modern languages, record and tag types in Rust\n-are not represented as pointers to allocated memory. They are, like in\n-C and C++, represented directly. This means that if you `let x = {x:\n-1f, y: 1f};`, you are creating a record on the stack. If you then copy\n-it into a data structure, the whole record is copied, not just a\n-pointer.\n+In contrast to a lot of modern languages, record and enum types in\n+Rust are not represented as pointers to allocated memory. They are,\n+like in C and C++, represented directly. This means that if you `let x\n+= {x: 1f, y: 1f};`, you are creating a record on the stack. If you\n+then copy it into a data structure, the whole record is copied, not\n+just a pointer.\n \n-For small records like `point`, this is usually still more efficient\n-than allocating memory and going through a pointer. But for big\n-records, or records with mutable fields, it can be useful to have a\n-single copy on the heap, and refer to that through a pointer.\n+For small records like `point`, this is usually more efficient than\n+allocating memory and going through a pointer. But for big records, or\n+records with mutable fields, it can be useful to have a single copy on\n+the heap, and refer to that through a pointer.\n \n Rust supports several types of pointers. The simplest is the unsafe\n pointer, written `*TYPE`, which is a completely unchecked pointer\n@@ -194,7 +194,7 @@ Shared boxes are pointers to heap-allocated, reference counted memory.\n A cycle collector ensures that circular references do not result in\n memory leaks.\n \n-Creating a shared box is done by simply applying the binary `@`\n+Creating a shared box is done by simply applying the unary `@`\n operator to an expression. The result of the expression will be boxed,\n resulting in a box of the right type. For example:\n \n@@ -221,11 +221,8 @@ box exists at any time.\n This is where the 'move' (`<-`) operator comes in. It is similar to\n `=`, but it de-initializes its source. Thus, the unique box can move\n from `x` to `y`, without violating the constraint that it only has a\n-single owner.\n-\n-NOTE: If you do `y = x` instead, the box will be copied. We should\n-emit warning for this, or disallow it entirely, but do not currently\n-do so.\n+single owner (if you used assignment instead of the move operator, the\n+box would, in principle, be copied).\n \n Unique boxes, when they do not contain any shared boxes, can be sent\n to other tasks. The sending task will give up ownership of the box,\n@@ -249,10 +246,10 @@ Rust vectors are always heap-allocated and unique. A value of type\n containing any number of `TYPE` values.\n \n NOTE: This uniqueness is turning out to be quite awkward in practice,\n-and might change.\n+and might change in the future.\n \n Vector literals are enclosed in square brackets. Dereferencing is done\n-with square brackets (and zero-based):\n+with square brackets (zero-based):\n \n     let myvec = [true, false, true, false];\n     if myvec[1] { std::io::println(\"boom\"); }\n@@ -262,8 +259,8 @@ The type written as `[mutable TYPE]` is a vector with mutable\n elements. Mutable vector literals are written `[mutable]` (empty) or\n `[mutable 1, 2, 3]` (with elements).\n \n-Growing a vector in Rust is not as inefficient as it looks (the `+`\n-operator means concatenation when applied to vector types):\n+The `+` operator means concatenation when applied to vector types.\n+Growing a vector in Rust is not as inefficient as it looks :\n \n     let myvec = [], i = 0;\n     while i < 100 {\n@@ -286,17 +283,17 @@ null byte (for interoperability with C APIs).\n \n This sequence of bytes is interpreted as an UTF-8 encoded sequence of\n characters. This has the advantage that UTF-8 encoded I/O (which\n-should really be the goal for modern systems) is very fast, and that\n-strings have, for most intents and purposes, a nicely compact\n+should really be the default for modern systems) is very fast, and\n+that strings have, for most intents and purposes, a nicely compact\n representation. It has the disadvantage that you only get\n constant-time access by byte, not by character.\n \n A lot of algorithms don't need constant-time indexed access (they\n-iterate over all characters, which `std::str::chars` helps with), and\n+iterate over all characters, which `str::chars` helps with), and\n for those that do, many don't need actual characters, and can operate\n on bytes. For algorithms that do really need to index by character,\n there's the option to convert your string to a character vector (using\n-`std::str::to_chars`).\n+`str::to_chars`).\n \n Like vectors, strings are always unique. You can wrap them in a shared\n box to share them. Unlike vectors, there is no mutable variant of"}, {"sha": "54a60809e1c789e0374e3bac406327318ec780de", "filename": "doc/tutorial/ffi.md", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0f72c53fdfb912319260aa8462ae20f07599631d/doc%2Ftutorial%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f72c53fdfb912319260aa8462ae20f07599631d/doc%2Ftutorial%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fffi.md?ref=0f72c53fdfb912319260aa8462ae20f07599631d", "patch": "@@ -13,7 +13,6 @@ hexadecimal string and prints to standard output. If you have the\n OpenSSL libraries installed, it should 'just work'.\n \n     use std;\n-    import std::{vec, str};\n     \n     native mod crypto {\n         fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n@@ -28,7 +27,7 @@ OpenSSL libraries installed, it should 'just work'.\n     fn sha1(data: str) -> str unsafe {\n         let bytes = str::bytes(data);\n         let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n-                                vec::len(bytes), std::ptr::null());\n+                                vec::len(bytes), ptr::null());\n         ret as_hex(vec::unsafe::from_buf(hash, 20u));\n     }\n     \n@@ -109,13 +108,12 @@ null pointers.\n \n The `sha1` function is the most obscure part of the program.\n \n-    # import std::{str, vec};\n     # mod crypto { fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8 { out } }\n     # fn as_hex(data: [u8]) -> str { \"hi\" }\n     fn sha1(data: str) -> str unsafe {\n         let bytes = str::bytes(data);\n         let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n-                                vec::len(bytes), std::ptr::null());\n+                                vec::len(bytes), ptr::null());\n         ret as_hex(vec::unsafe::from_buf(hash, 20u));\n     }\n \n@@ -134,7 +132,7 @@ caused by some unsafe code.\n Unsafe blocks isolate unsafety. Unsafe functions, on the other hand,\n advertise it to the world. An unsafe function is written like this:\n \n-    unsafe fn kaboom() { log \"I'm harmless!\"; }\n+    unsafe fn kaboom() { \"I'm harmless!\"; }\n \n This function can only be called from an unsafe block or another\n unsafe function.\n@@ -147,13 +145,12 @@ Rust's safety mechanisms.\n \n Let's look at our `sha1` function again.\n \n-    # import std::{str, vec};\n     # mod crypto { fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8 { out } }\n     # fn as_hex(data: [u8]) -> str { \"hi\" }\n     # fn x(data: str) -> str unsafe {\n     let bytes = str::bytes(data);\n     let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n-                            vec::len(bytes), std::ptr::null());\n+                            vec::len(bytes), ptr::null());\n     ret as_hex(vec::unsafe::from_buf(hash, 20u));\n     # }\n \n@@ -195,7 +192,7 @@ microsecond-resolution timer.\n     }\n     fn unix_time_in_microseconds() -> u64 unsafe {\n         let x = {mutable tv_sec: 0u32, mutable tv_usec: 0u32};\n-        libc::gettimeofday(std::ptr::addr_of(x), std::ptr::null());\n+        libc::gettimeofday(ptr::addr_of(x), ptr::null());\n         ret (x.tv_sec as u64) * 1000_000_u64 + (x.tv_usec as u64);\n     }\n "}, {"sha": "08744a68dd8c45001740f5257b10ab49b69d45fa", "filename": "doc/tutorial/func.md", "status": "modified", "additions": 96, "deletions": 109, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/0f72c53fdfb912319260aa8462ae20f07599631d/doc%2Ftutorial%2Ffunc.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f72c53fdfb912319260aa8462ae20f07599631d/doc%2Ftutorial%2Ffunc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Ffunc.md?ref=0f72c53fdfb912319260aa8462ae20f07599631d", "patch": "@@ -11,7 +11,7 @@ also return a value by having its top level block produce an\n expression (by omitting the final semicolon).\n \n Some functions (such as the C function `exit`) never return normally.\n-In Rust, these are annotated with return type `!`:\n+In Rust, these are annotated with the pseudo-return type '`!`':\n \n     fn dead_end() -> ! { fail; }\n \n@@ -21,101 +21,121 @@ expected to return.\n \n     # fn can_go_left() -> bool { true }\n     # fn can_go_right() -> bool { true }\n-    # tag dir { left; right; }\n+    # enum dir { left; right; }\n     # fn dead_end() -> ! { fail; }\n     let dir = if can_go_left() { left }\n               else if can_go_right() { right }\n               else { dead_end(); };\n \n ## Closures\n \n-Named rust functions, like those in the previous section, do not close\n-over their environment. Rust also includes support for closures, which\n-are anonymous functions that can access the variables that were in\n-scope at the time the closure was created.  Closures are represented\n-as the pair of a function pointer (as in C) and the environment, which\n-is where the values of the closed over variables are stored.  Rust\n-includes support for three varieties of closure, each with different\n-costs and capabilities:\n-\n-- Stack closures (written `block`) store their environment in the\n-  stack frame of their creator; they are very lightweight but cannot\n-  be stored in a data structure.\n-- Boxed closures (written `fn@`) store their environment in a\n-  [shared box](data#shared-box).  These are good for storing within\n-  data structures but cannot be sent to another task.\n-- Unique closures (written `fn~`) store their environment in a\n-  [unique box](data#unique-box).  These are limited in the kinds of\n-  data that they can close over so that they can be safely sent\n-  between tasks.  As with any unique pointer, copying a unique closure\n-  results in a deep clone of the environment.\n-  \n-Both boxed closures and unique closures are subtypes of stack\n-closures, meaning that wherever a stack closure type appears, a boxed\n-or unique closure value can be used.  This is due to the restrictions\n-placed on the use of stack closures, which ensure that all operations\n-on a stack closure are also safe on any kind of closure.\n-\n-### Working with closures\n-\n-Closures are specified by writing an inline, anonymous function\n-declaration.  For example, the following code creates a boxed closure:\n-\n-    let plus_two = fn@(x: int) -> int {\n-        ret x + 2;\n-    };\n-    \n-Creating a unique closure is very similar:\n+Named functions, like those in the previous section, do not close over\n+their environment. Rust also includes support for closures, which are\n+functions that can access variables in the scope in which they are\n+created.\n+\n+There are several forms of closures, each with its own role. The most\n+common type is called a 'block', this is a closure which has full\n+access to its environment.\n \n-    let plus_two_uniq = fn~(x: int) -> int {\n-        ret x + 2;\n-    };\n+    fn call_block_with_ten(b: block(int)) { b(10); }\n     \n-Stack closures can be created in a similar way; however, because stack\n-closures literally point into their creator's stack frame, they can\n-only be used in a very specific way.  Stack closures may be passed as\n-parameters and they may be called, but they may not be stored into\n-local variables or fields.  Creating a stack closure can therefore be\n-done using a syntax like the following:\n-\n-    let doubled = vec::map([1, 2, 3], block(x: int) -> int {\n-        x * 2\n+    let x = 20;    \n+    call_block_with_ten({|arg|\n+        #info(\"x=%d, arg=%d\", x, arg);\n     });\n+\n+This defines a function that accepts a block, and then calls it with a\n+simple block that executes a log statement, accessing both its\n+argument and the variable `x` from its environment.\n+\n+Blocks can only be used in a restricted way, because it is not allowed\n+to survive the scope in which it was created. They are allowed to\n+appear in function argument position and in call position, but nowhere\n+else.\n+\n+### Boxed closures\n+\n+When you need to store a closure in a data structure, a block will not\n+do, since the compiler will refuse to let you store it. For this\n+purpose, Rust provides a type of closure that has an arbitrary\n+lifetime, written `fn@` (boxed closure, analogous to the `@` pointer\n+type described in the next section).\n+\n+A boxed closure does not directly access its environment, but merely\n+copies out the values that it closes over into a private data\n+structure. This means that it can not assign to these variables, and\n+will not 'see' updates to them.\n+\n+This code creates a closure that adds a given string to its argument,\n+returns it from a function, and then calls it:\n+\n+    use std;\n     \n-Here the `vec::map()` is the standard higher-order map function, which\n-applies the closure to each item in the vector and returns a new\n-vector containing the results.\n+    fn mk_appender(suffix: str) -> fn@(str) -> str {\n+        let f = fn@(s: str) -> str { s + suffix };\n+        ret f;\n+    }\n     \n-### Shorthand syntax\n+    fn main() {\n+        let shout = mk_appender(\"!\");\n+        std::io::println(shout(\"hey ho, let's go\"));\n+    }\n+\n+### Closure compatibility\n+\n+A nice property of Rust closures is that you can pass any kind of\n+closure (as long as the arguments and return types match) to functions\n+that expect a `block`. Thus, when writing a higher-order function that\n+wants to do nothing with its function argument beyond calling it, you\n+should almost always specify the type of that argument as `block`, so\n+that callers have the flexibility to pass whatever they want.\n+\n+    fn call_twice(f: block()) { f(); f(); }\n+    call_twice({|| \"I am a block\"; });\n+    call_twice(fn@() { \"I am a boxed closure\"; });\n+    fn bare_function() { \"I am a plain function\"; }\n+    call_twice(bare_function);\n \n-The syntax in the previous section was very explicit; it fully\n-specifies the kind of closure as well as the type of every parameter\n-and the return type.  In practice, however, closures are often used as\n-parameters to functions, and all of these details can be inferred.\n-Therefore, we support a shorthand syntax similar to Ruby or Smalltalk\n-blocks, which looks as follows:\n+### Unique closures\n \n-    let doubled = vec::map([1, 2, 3], {|x| x*2});\n- \n-Here the vertical bars after the open brace `{` indicate that this is\n-a closure.  A list of parameters appears between the bars.  The bars\n-must always be present: if there are no arguments, then simply write\n-`{||...}`.\n+<a name=\"unique\"></a>\n+\n+Unique closures, written `fn~` in analogy to the `~` pointer type (see\n+next section), hold on to things that can safely be sent between\n+processes. They copy the values they close over, much like boxed\n+closures, but they also 'own' them\u2014meaning no other code can access\n+them. Unique closures mostly exist to for spawning new\n+[tasks](task.html).\n+\n+### Shorthand syntax\n+\n+The compact syntax used for blocks (`{|arg1, arg2| body}`) can also\n+be used to express boxed and unique closures in situations where the\n+closure style can be unambiguously derived from the context. Most\n+notably, when calling a higher-order function you do not have to use\n+the long-hand syntax for the function you're passing, since the\n+compiler can look at the argument type to find out what the parameter\n+types are.\n \n As a further simplification, if the final parameter to a function is a\n-closure, the closure need not be placed within parenthesis.\n-Therefore, one could write\n+closure, the closure need not be placed within parenthesis. You could,\n+for example, write...\n \n     let doubled = vec::map([1, 2, 3]) {|x| x*2};\n-   \n-This form is often easier to parse as it involves less nesting.  \n+\n+`vec::map` is a function in the core library that applies its last\n+argument to every element of a vector, producing a new vector.\n+\n+Even when a closure takes no parameters, you must still write the bars\n+for the parameter list, as in `{|| ...}`.\n \n ## Binding\n \n Partial application is done using the `bind` keyword in Rust.\n \n-    let daynum = bind std::vec::position(_, [\"mo\", \"tu\", \"we\", \"do\",\n-                                             \"fr\", \"sa\", \"su\"]);\n+    let daynum = bind vec::position(_, [\"mo\", \"tu\", \"we\", \"do\",\n+                                        \"fr\", \"sa\", \"su\"]);\n \n Binding a function produces a boxed closure (`fn@` type) in which some\n of the arguments to the bound function have already been provided.\n@@ -129,7 +149,7 @@ iteration constructs. For example, this one iterates over a vector\n of integers backwards:\n \n     fn for_rev(v: [int], act: block(int)) {\n-        let i = std::vec::len(v);\n+        let i = vec::len(v);\n         while (i > 0u) {\n             i -= 1u;\n             act(v[i]);\n@@ -139,49 +159,16 @@ of integers backwards:\n To run such an iteration, you could do this:\n \n     # fn for_rev(v: [int], act: block(int)) {}\n-    for_rev([1, 2, 3], {|n| log n; });\n+    for_rev([1, 2, 3], {|n| log(error, n); });\n \n Making use of the shorthand where a final closure argument can be\n moved outside of the parentheses permits the following, which\n looks quite like a normal loop:\n \n     # fn for_rev(v: [int], act: block(int)) {}\n     for_rev([1, 2, 3]) {|n|\n-        log n;\n+        log(error, n);\n     }\n \n Note that, because `for_rev()` returns unit type, no semicolon is\n needed when the final closure is pulled outside of the parentheses.\n-\n-## Capture clauses\n-\n-When creating a boxed or unique closure, the default is to copy in the\n-values of any closed over variables.  But sometimes, particularly if a\n-value is large or expensive to copy, you would like to *move* the\n-value into the closure instead.  Rust supports this via the use of a\n-capture clause, which lets you specify precisely whether each variable\n-used in the closure is copied or moved.\n-\n-As an example, let's assume we had some type of unique tree type:\n-\n-    tag tree<T> = tree_rec<T>;\n-    type tree_rec<T> = ~{left: option<tree>, right: option<tree>, val: T};\n-\n-Now if we have a function like the following:\n-\n-    let some_tree: tree<T> = ...;\n-    let some_closure = fn~() {\n-        ... use some_tree in some way ...\n-    };\n-    \n-Here the variable `some_tree` is used within the closure body, so a\n-deep copy will be performed.  This can become quite expensive if the\n-tree is large.  If we know that `some_tree` will not be used again,\n-we could avoid this expense by making use of a capture clause like so:\n-\n-    let some_tree: tree<T> = ...;\n-    let some_closure = fn~[move some_tree]() {\n-        ... use some_tree in some way ...\n-    };\n-\n-This is particularly useful when moving data into [child tasks](task)."}, {"sha": "2dc8d5684f3e7205d7955487ca1eb3fd6d2445d6", "filename": "doc/tutorial/generic.md", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/0f72c53fdfb912319260aa8462ae20f07599631d/doc%2Ftutorial%2Fgeneric.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f72c53fdfb912319260aa8462ae20f07599631d/doc%2Ftutorial%2Fgeneric.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fgeneric.md?ref=0f72c53fdfb912319260aa8462ae20f07599631d", "patch": "@@ -2,21 +2,20 @@\n \n ## Generic functions\n \n-Throughout this tutorial, I've been defining functions like `map` and\n-`for_rev` to take vectors of integers. It is 2011, and we no longer\n-expect to be defining such functions again and again for every type\n-they apply to. Thus, Rust allows functions and datatypes to have type\n-parameters.\n+Throughout this tutorial, I've been defining functions like `for_rev`\n+that act only on integers. It is 2012, and we no longer expect to be\n+defining such functions again and again for every type they apply to.\n+Thus, Rust allows functions and datatypes to have type parameters.\n \n     fn for_rev<T>(v: [T], act: block(T)) {\n-        let i = std::vec::len(v);\n+        let i = vec::len(v);\n         while i > 0u {\n             i -= 1u;\n             act(v[i]);\n         }\n     }\n     \n-    fn map<T, U>(f: block(T) -> U, v: [T]) -> [U] {\n+    fn map<T, U>(v: [T], f: block(T) -> U) -> [U] {\n         let acc = [];\n         for elt in v { acc += [f(elt)]; }\n         ret acc;\n@@ -32,21 +31,21 @@ can't look inside them, but you can pass them around.\n \n ## Generic datatypes\n \n-Generic `type` and `tag` declarations follow the same pattern:\n+Generic `type` and `enum` declarations follow the same pattern:\n \n     type circular_buf<T> = {start: uint,\n                             end: uint,\n                             buf: [mutable T]};\n     \n-    tag option<T> { some(T); none; }\n+    enum option<T> { some(T); none; }\n \n You can then declare a function to take a `circular_buf<u8>` or return\n an `option<str>`, or even an `option<T>` if the function itself is\n generic.\n \n-The `option` type given above exists in the standard library as\n-`std::option::t`, and is the way Rust programs express the thing that\n-in C would be a nullable pointer. The nice part is that you have to\n+The `option` type given above exists in the core library as\n+`option::t`, and is the way Rust programs express the thing that in C\n+would be a nullable pointer. The nice part is that you have to\n explicitly unpack an `option` type, so accidental null pointer\n dereferences become impossible.\n \n@@ -55,17 +54,17 @@ dereferences become impossible.\n Rust's type inferrer works very well with generics, but there are\n programs that just can't be typed.\n \n-    let n = std::option::none;\n-    # n = std::option::some(1);\n+    let n = option::none;\n+    # n = option::some(1);\n \n If you never do anything else with `n`, the compiler will not be able\n-to assign a type to it. (The same goes for `[]`, in fact.) If you\n-really want to have such a statement, you'll have to write it like\n+to assign a type to it. (The same goes for `[]`, the empty vector.) If\n+you really want to have such a statement, you'll have to write it like\n this:\n \n-    let n2: std::option::t<int> = std::option::none;\n+    let n2: option::t<int> = option::none;\n     // or\n-    let n = std::option::none::<int>;\n+    let n = option::none::<int>;\n \n Note that, in a value expression, `<` already has a meaning as a\n comparison operator, so you'll have to write `::<T>` to explicitly\n@@ -76,7 +75,7 @@ is rarely necessary.\n \n There are two built-in operations that, perhaps surprisingly, act on\n values of any type. It was already mentioned earlier that `log` can\n-take any type of value and output it as a string.\n+take any type of value and output it.\n \n More interesting is that Rust also defines an ordering for values of\n all datatypes, and allows you to meaningfully apply comparison\n@@ -99,10 +98,11 @@ parameter `T`, can you copy values of that type? In Rust, you can't,\n unless you explicitly declare that type parameter to have copyable\n 'kind'. A kind is a type of type.\n \n+    ## ignore\n     // This does not compile\n     fn head_bad<T>(v: [T]) -> T { v[0] }\n     // This does\n-    fn head<T:copy>(v: [T]) -> T { v[0] }\n+    fn head<T: copy>(v: [T]) -> T { v[0] }\n \n When instantiating a generic function, you can only instantiate it\n with types that fit its kinds. So you could not apply `head` to a\n@@ -116,12 +116,14 @@ with the `send` keyword to make them sendable.\n Sendable types are a subset of copyable types. They are types that do\n not contain shared (reference counted) types, which are thus uniquely\n owned by the function that owns them, and can be sent over channels to\n-other tasks. Most of the generic functions in the `std::comm` module\n+other tasks. Most of the generic functions in the core `comm` module\n take sendable types.\n \n ## Generic functions and argument-passing\n \n-If you try this program:\n+The previous section mentioned that arguments are passed by pointer or\n+by value based on their type. There is one situation in which this is\n+difficult. If you try this program:\n \n     # fn map(f: block(int) -> int, v: [int]) {}\n     fn plus1(x: int) -> int { x + 1 }\n@@ -133,7 +135,8 @@ pointer, so `map` expects a function that takes its argument by\n pointer. The `plus1` you defined, however, uses the default, efficient\n way to pass integers, which is by value. To get around this issue, you\n have to explicitly mark the arguments to a function that you want to\n-pass to a generic higher-order function as being passed by pointer:\n+pass to a generic higher-order function as being passed by pointer,\n+using the `&&` sigil:\n \n     # fn map<T, U>(f: block(T) -> U, v: [T]) {}\n     fn plus1(&&x: int) -> int { x + 1 }"}, {"sha": "61510b876755217778f602e2dc9dbde9bd68cc40", "filename": "doc/tutorial/intro.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f72c53fdfb912319260aa8462ae20f07599631d/doc%2Ftutorial%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f72c53fdfb912319260aa8462ae20f07599631d/doc%2Ftutorial%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fintro.md?ref=0f72c53fdfb912319260aa8462ae20f07599631d", "patch": "@@ -8,8 +8,6 @@ programmed in one or more other languages before. The tutorial covers\n the whole language, though not with the depth and precision of the\n [language reference][1].\n \n-FIXME: maybe also the stdlib?\n-\n [1]: http://www.rust-lang.org/doc/rust.html\n \n ## Disclaimer\n@@ -55,5 +53,5 @@ identifiers defined in the example code are displayed in `code font`.\n Code snippets are indented, and also shown in a monospace font. Not\n all snippets constitute whole programs. For brevity, we'll often show\n fragments of programs that don't compile on their own. To try them\n-out, you'll have to wrap them in `fn main() { ... }`, and make sure\n+out, you might have to wrap them in `fn main() { ... }`, and make sure\n they don't contain references to things that aren't actually defined."}, {"sha": "9251e8fee4b559a0403a6e3dbc12ae71a2ec88dd", "filename": "doc/tutorial/mod.md", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0f72c53fdfb912319260aa8462ae20f07599631d/doc%2Ftutorial%2Fmod.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f72c53fdfb912319260aa8462ae20f07599631d/doc%2Ftutorial%2Fmod.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fmod.md?ref=0f72c53fdfb912319260aa8462ae20f07599631d", "patch": "@@ -1,7 +1,7 @@\n # Modules and crates\n \n The Rust namespace is divided into modules. Each source file starts\n-with its own, empty module.\n+with its own module.\n \n ## Local modules\n \n@@ -15,7 +15,7 @@ explicitly import it, you must refer to it by its long name,\n         fn cow() -> str { \"mooo\" }\n     }\n     fn main() {\n-        log_err farm::chicken();\n+        std::io::println(farm::chicken());\n     }\n \n Modules can be nested to arbitrary depth.\n@@ -48,7 +48,7 @@ file, compile them all together, and, depending on the presence of the\n \n The `#[link(...)]` part provides meta information about the module,\n which other crates can use to load the right module. More about that\n-in a moment.\n+later.\n \n To have a nested directory structure for your source files, you can\n nest mods in your `.rc` file:\n@@ -68,15 +68,14 @@ content to the `poultry` module itself.\n \n Having compiled a crate with `--lib`, you can use it in another crate\n with a `use` directive. We've already seen `use std` in several of the\n-examples, which loads in the standard library.\n+examples, which loads in the [standard library][std].\n+\n+[std]: http://doc.rust-lang.org/doc/std/index/General.html\n \n `use` directives can appear in a crate file, or at the top level of a\n single-file `.rs` crate. They will cause the compiler to search its\n library search path (which you can extend with `-L` switch) for a Rust\n-crate library with the right name. This name is deduced from the crate\n-name in a platform-dependent way. The `farm` library will be called\n-`farm.dll` on Windows, `libfarm.so` on Linux, and `libfarm.dylib` on\n-OS X.\n+crate library with the right name.\n \n It is possible to provide more specific information when using an\n external crate.\n@@ -100,6 +99,16 @@ The version does not match the one provided in the `use` directive, so\n unless the compiler can find another crate with the right version\n somewhere, it will complain that no matching crate was found.\n \n+## The core library\n+\n+A set of basic library routines, mostly related to built-in datatypes\n+and the task system, are always implicitly linked and included in any\n+Rust program, unless the `--no-core` compiler switch is given.\n+\n+This library is document [here][core].\n+\n+[core]: http://doc.rust-lang.org/doc/core/index/General.html\n+\n ## A minimal example\n \n Now for something that you can actually compile yourself. We have\n@@ -112,7 +121,7 @@ these two files:\n     ## ignore\n     // main.rs\n     use mylib;\n-    fn main() { log_err \"hello \" + mylib::world(); }\n+    fn main() { std::io::println(\"hello \" + mylib::world()); }\n \n Now compile and run like this (adjust to your platform if necessary):\n \n@@ -127,7 +136,7 @@ Now compile and run like this (adjust to your platform if necessary):\n When using identifiers from other modules, it can get tiresome to\n qualify them with the full module path every time (especially when\n that path is several modules deep). Rust allows you to import\n-identifiers at the top of a file or module.\n+identifiers at the top of a file, module, or block.\n \n     use std;\n     import std::io::println;\n@@ -136,12 +145,11 @@ identifiers at the top of a file or module.\n     }\n \n It is also possible to import just the name of a module (`import\n-std::io;`, then use `io::println`), import all identifiers exported by\n-a given module (`import std::io::*`), or to import a specific set of\n-identifiers (`import std::math::{min, max, pi}`).\n+std::io;`, then use `io::println`), to import all identifiers exported\n+by a given module (`import std::io::*`), or to import a specific set\n+of identifiers (`import math::{min, max, pi}`).\n \n-It is also possible to rename an identifier when importing, using the\n-`=` operator:\n+You can rename an identifier when importing using the `=` operator:\n \n     import prnt = std::io::println;\n \n@@ -177,7 +185,7 @@ and one for values. This means that this code is valid:\n \n You don't want to write things like that, but it *is* very practical\n to not have to worry about name clashes between types, values, and\n-modules. This allows us to have a module `std::str`, for example, even\n+modules. This allows us to have a module `core::str`, for example, even\n though `str` is a built-in type name.\n \n ## Resolution"}, {"sha": "a1a28d903a035e3d31754cf4500e6cfb424075de", "filename": "doc/tutorial/setup.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f72c53fdfb912319260aa8462ae20f07599631d/doc%2Ftutorial%2Fsetup.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f72c53fdfb912319260aa8462ae20f07599631d/doc%2Ftutorial%2Fsetup.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fsetup.md?ref=0f72c53fdfb912319260aa8462ae20f07599631d", "patch": "@@ -11,7 +11,7 @@ we have a file `hello.rs` containing this program:\n \n     use std;\n     fn main(args: [str]) {\n-        std::io::println(\"hello world from \" + args[0] + \"!\");\n+        std::io::println(\"hello world from '\" + args[0] + \"'!\");\n     }\n \n If the Rust compiler was installed successfully, running `rustc\n@@ -39,9 +39,11 @@ live inside a function.\n \n Rust programs can also be compiled as libraries, and included in other\n programs. The `use std` directive that appears at the top of a lot of\n-examples imports the standard library. This is described in more\n+examples imports the [standard library][std]. This is described in more\n detail [later on](mod.html).\n \n+[std]: http://doc.rust-lang.org/doc/std/index/General.html\n+\n ## Editing Rust code\n \n There are Vim highlighting and indentation scrips in the Rust source"}, {"sha": "b0e3f00219119684bab040a524f7413958ef7578", "filename": "doc/tutorial/syntax.md", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0f72c53fdfb912319260aa8462ae20f07599631d/doc%2Ftutorial%2Fsyntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f72c53fdfb912319260aa8462ae20f07599631d/doc%2Ftutorial%2Fsyntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fsyntax.md?ref=0f72c53fdfb912319260aa8462ae20f07599631d", "patch": "@@ -139,7 +139,7 @@ The basic types are written like this:\n : Nil, the type that has only a single value.\n \n `bool`\n-: Boolean type..\n+: Boolean type, with values `true` and `false`.\n \n `int`\n : A machine-pointer-sized integer.\n@@ -177,7 +177,7 @@ more detail later on (the `T`s here stand for any other type):\n `(T1, T2)`\n : Tuple type. Any arity above 1 is supported.\n \n-`{fname1: T1, fname2: T2}`\n+`{field1: T1, field2: T2}`\n : Record type.\n \n `fn(arg1: T1, arg2: T2) -> T3`, `lambda()`, `block()`\n@@ -186,20 +186,17 @@ more detail later on (the `T`s here stand for any other type):\n `@T`, `~T`, `*T`\n : Pointer types.\n \n-`obj { fn method1() }`\n-: Object type.\n-\n Types can be given names with `type` declarations:\n \n     type monster_size = uint;\n \n This will provide a synonym, `monster_size`, for unsigned integers. It\n will not actually create a new type\u2014`monster_size` and `uint` can be\n used interchangeably, and using one where the other is expected is not\n-a type error. Read about [single-variant tags][svt] further on if you\n+a type error. Read about [single-variant enums][sve] further on if you\n need to create a type name that's not just a synonym.\n \n-[svt]: data.html#single_variant_tag\n+[sve]: data.html#single_variant_enum\n \n ## Literals\n \n@@ -223,8 +220,8 @@ The nil literal is written just like the type: `()`. The keywords\n `true` and `false` produce the boolean literals.\n \n Character literals are written between single quotes, as in `'x'`. You\n-may put non-ascii characters between single quotes (your source file\n-should be encoded as utf-8 in that case). Rust understands a number of\n+may put non-ascii characters between single quotes (your source files\n+should be encoded as utf-8). Rust understands a number of\n character escapes, using the backslash character:\n \n `\\n`\n@@ -308,14 +305,16 @@ simply checks whether the configuration flag is defined at all). Flags\n for `target_os` and `target_arch` are set by the compiler. It is\n possible to set additional flags with the `--cfg` command-line option.\n \n-Attributes always look like `#[attr]`, where `attr` can be simply a\n-name (as in `#[test]`, which is used by the [built-in test\n-framework](test.html)), a name followed by `=` and then a literal (as\n-in `#[license = \"BSD\"]`, which is a valid way to annotate a Rust\n-program as being released under a BSD-style license), or a name\n-followed by a comma-separated list of nested attributes, as in the\n-`cfg` example above, or in this [crate](mod.html) metadata\n-declaration:\n+Attributes are always wrapped in hash-braces (`#[attr]`). Inside the\n+braces, a small minilanguage is supported, whose interpretation\n+depends on the attribute that's being used. The simplest form is a\n+plain name (as in `#[test]`, which is used by the [built-in test\n+framework](test.html '')). A name-value pair can be provided using an `=`\n+character followed by a literal (as in `#[license = \"BSD\"]`, which is\n+a valid way to annotate a Rust program as being released under a\n+BSD-style license). Finally, you can have a name followed by a\n+comma-separated list of nested attributes, as in the `cfg` example\n+above, or in this [crate](mod.html) metadata declaration:\n \n     ## ignore\n     #[link(name = \"std\",\n@@ -324,7 +323,7 @@ declaration:\n \n An attribute without a semicolon following it applies to the\n definition that follows it. When terminated with a semicolon, it\n-applies to the module or crate.\n+applies to the module or crate in which it appears.\n \n ## Syntax extensions\n "}, {"sha": "21cafe91f9564142532fc3c966f01c64204b83f7", "filename": "doc/tutorial/task.md", "status": "modified", "additions": 30, "deletions": 20, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0f72c53fdfb912319260aa8462ae20f07599631d/doc%2Ftutorial%2Ftask.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f72c53fdfb912319260aa8462ae20f07599631d/doc%2Ftutorial%2Ftask.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Ftask.md?ref=0f72c53fdfb912319260aa8462ae20f07599631d", "patch": "@@ -1,10 +1,11 @@\n # Tasks\n \n Rust supports a system of lightweight tasks, similar to what is found\n-in Erlang or other actor systems.  Rust tasks communicate via messages\n-and do not share data.  However, it is possible to send data without\n-copying it by making use of [unique boxes][uniques] (still, the data\n-is owned by only one task at a time).\n+in Erlang or other actor systems. Rust tasks communicate via messages\n+and do not share data. However, it is possible to send data without\n+copying it by making use of [unique boxes][uniques], which allow the\n+sending task to release ownership of a value, so that the receiving\n+task can keep on using it.\n \n [uniques]: data.html#unique-box\n \n@@ -14,20 +15,20 @@ somewhat.  The tutorial documents the API as it exists today.\n ## Spawning a task\n \n Spawning a task is done using the various spawn functions in the\n-module `task`.  We will Let's begin with the simplest one, `task::spawn()`, and\n-later move on to the others:\n+module `task`.  Let's begin with the simplest one, `task::spawn()`:\n \n     let some_value = 22;\n     let child_task = task::spawn {||\n         std::io::println(\"This executes in the child task.\");\n         std::io::println(#fmt(\"%d\", some_value));\n     };\n \n-The argument to `task::spawn()` is a [unique closure](func) of type\n-`fn~()`, meaning that it takes no arguments and generates no return\n-value.  The effect of `task::spawn()` is to fire up a child task that\n-will execute the closure in parallel with the creator.  The result is\n-a task id, here stored into the variable `child_task`.\n+The argument to `task::spawn()` is a [unique\n+closure](func.html#unique) of type `fn~()`, meaning that it takes no\n+arguments and generates no return value. The effect of `task::spawn()`\n+is to fire up a child task that will execute the closure in parallel\n+with the creator. The result is a task id, here stored into the\n+variable `child_task`.\n \n ## Ports and channels\n \n@@ -38,6 +39,8 @@ of a particular type.  A channel is used to send messages to a port.\n For example, imagine we wish to perform two expensive computations\n in parallel.  We might write something like:\n \n+    # fn some_expensive_computation() -> int { 42 }\n+    # fn some_other_expensive_computation() {}\n     let port = comm::port::<int>();\n     let chan = comm::chan::<int>(port);\n     let child_task = task::spawn {||\n@@ -56,11 +59,15 @@ This port is where we will receive the message from the child task\n once it is complete.  The second line creates a channel for sending\n integers to the port `port`:\n \n+    # let port = comm::port::<int>();\n     let chan = comm::chan::<int>(port);\n \n The channel will be used by the child to send a message to the port.\n The next statement actually spawns the child:\n \n+    # fn some_expensive_computation() -> int { 42 }\n+    # let port = comm::port::<int>();\n+    # let chan = comm::chan::<int>(port);\n     let child_task = task::spawn {||\n         let result = some_expensive_computation();\n         comm::send(chan, result);\n@@ -71,15 +78,17 @@ over the channel.  Finally, the parent continues by performing\n some other expensive computation and then waiting for the child's result\n to arrive on the port:\n \n+    # fn some_other_expensive_computation() {}\n+    # let port = comm::port::<int>();\n     some_other_expensive_computation();\n     let result = comm::recv(port);\n \n ## Creating a task with a bi-directional communication path\n \n A very common thing to do is to spawn a child task where the parent\n-and child both need to exchange messages with each other.  The\n-function `task::spawn_connected()` supports this pattern.  We'll look\n-briefly at how it is used.\n+and child both need to exchange messages with each other. The function\n+`task::spawn_connected()` supports this pattern. We'll look briefly at\n+how it is used.\n \n To see how `spawn_connected()` works, we will create a child task\n which receives `uint` messages, converts them to a string, and sends\n@@ -104,6 +113,8 @@ strified version of the received value, `uint::to_str(value)`.\n \n Here is the code for the parent task:\n     \n+    # fn stringifier(from_par: comm::port<uint>,\n+    #                to_par: comm::chan<str>) {}\n     fn main() {\n         let t = task::spawn_connected(stringifier);\n         comm::send(t.to_child, 22u);\n@@ -125,11 +136,11 @@ here to send and receive three messages from the child task.\n ## Joining a task\n \n The function `spawn_joinable()` is used to spawn a task that can later\n-be joined.  This is implemented by having the child task send a\n-message when it has completed (either successfully or by failing).\n-Therefore, `spawn_joinable()` returns a structure containing both the\n-task ID and the port where this message will be sent---this structure\n-type is called `task::joinable_task`.  The structure can be passed to\n+be joined. This is implemented by having the child task send a message\n+when it has completed (either successfully or by failing). Therefore,\n+`spawn_joinable()` returns a structure containing both the task ID and\n+the port where this message will be sent---this structure type is\n+called `task::joinable_task`. The structure can be passed to\n `task::join()`, which simply blocks on the port, waiting to receive\n the message from the child task.\n \n@@ -141,4 +152,3 @@ task fails, that failure is propagated to the parent task, which will\n fail sometime later.  This propagation can be disabled by using the\n function `task::unsupervise()`, which disables error propagation from\n the current task to its parent.\n-"}, {"sha": "6adfbdcca96e28106a576e7092f50d1882838ea8", "filename": "doc/tutorial/test.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f72c53fdfb912319260aa8462ae20f07599631d/doc%2Ftutorial%2Ftest.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f72c53fdfb912319260aa8462ae20f07599631d/doc%2Ftutorial%2Ftest.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Ftest.md?ref=0f72c53fdfb912319260aa8462ae20f07599631d", "patch": "@@ -18,8 +18,8 @@ Tests can be interspersed with other code, and annotated with the\n     }\n \n When you compile the program normally, the `test_twice` function will\n-not be used. To actually run the tests, compile with the `--test`\n-flag:\n+not be included. To compile and run such tests, compile with the\n+`--test` flag, and then run the result:\n \n     ## notrust\n     > rustc --test twice.rs"}, {"sha": null, "filename": "doc/tutorial/test.sh", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f72c53fdfb912319260aa8462ae20f07599631d/doc%2Ftutorial%2Ftest.sh", "raw_url": "https://github.com/rust-lang/rust/raw/0f72c53fdfb912319260aa8462ae20f07599631d/doc%2Ftutorial%2Ftest.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Ftest.sh?ref=0f72c53fdfb912319260aa8462ae20f07599631d"}, {"sha": "01f8523819d59fe99f8462ff6639c69d229c6d04", "filename": "doc/tutorial/web/style.css", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f72c53fdfb912319260aa8462ae20f07599631d/doc%2Ftutorial%2Fweb%2Fstyle.css", "raw_url": "https://github.com/rust-lang/rust/raw/0f72c53fdfb912319260aa8462ae20f07599631d/doc%2Ftutorial%2Fweb%2Fstyle.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fweb%2Fstyle.css?ref=0f72c53fdfb912319260aa8462ae20f07599631d", "patch": "@@ -13,10 +13,6 @@ h1 { font-size: 22pt; }\n h2 { font-size: 17pt; }\n h3 { font-size: 14pt; }\n \n-code {\n-  color: #033;\n-}\n-\n pre {\n   margin: 1.1em 0;\n   padding: .4em .4em .4em 1em;"}]}