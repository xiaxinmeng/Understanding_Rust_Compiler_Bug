{"sha": "653bcc8ad20320742e2011b4ad009b28767bcae2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1M2JjYzhhZDIwMzIwNzQyZTIwMTFiNGFkMDA5YjI4NzY3YmNhZTI=", "commit": {"author": {"name": "Lukas Lueg", "email": "lukas.lueg@gmail.com", "date": "2021-01-18T19:40:25Z"}, "committer": {"name": "Lukas Lueg", "email": "lukas.lueg@gmail.com", "date": "2021-01-21T18:47:57Z"}, "message": "Expand docs on Iterator::intersperse", "tree": {"sha": "5ab196ae93f5db13ec3ec2aeb4168b9b178ebc46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ab196ae93f5db13ec3ec2aeb4168b9b178ebc46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/653bcc8ad20320742e2011b4ad009b28767bcae2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/653bcc8ad20320742e2011b4ad009b28767bcae2", "html_url": "https://github.com/rust-lang/rust/commit/653bcc8ad20320742e2011b4ad009b28767bcae2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/653bcc8ad20320742e2011b4ad009b28767bcae2/comments", "author": {"login": "lukaslueg", "id": 3148704, "node_id": "MDQ6VXNlcjMxNDg3MDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3148704?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lukaslueg", "html_url": "https://github.com/lukaslueg", "followers_url": "https://api.github.com/users/lukaslueg/followers", "following_url": "https://api.github.com/users/lukaslueg/following{/other_user}", "gists_url": "https://api.github.com/users/lukaslueg/gists{/gist_id}", "starred_url": "https://api.github.com/users/lukaslueg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lukaslueg/subscriptions", "organizations_url": "https://api.github.com/users/lukaslueg/orgs", "repos_url": "https://api.github.com/users/lukaslueg/repos", "events_url": "https://api.github.com/users/lukaslueg/events{/privacy}", "received_events_url": "https://api.github.com/users/lukaslueg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lukaslueg", "id": 3148704, "node_id": "MDQ6VXNlcjMxNDg3MDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3148704?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lukaslueg", "html_url": "https://github.com/lukaslueg", "followers_url": "https://api.github.com/users/lukaslueg/followers", "following_url": "https://api.github.com/users/lukaslueg/following{/other_user}", "gists_url": "https://api.github.com/users/lukaslueg/gists{/gist_id}", "starred_url": "https://api.github.com/users/lukaslueg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lukaslueg/subscriptions", "organizations_url": "https://api.github.com/users/lukaslueg/orgs", "repos_url": "https://api.github.com/users/lukaslueg/repos", "events_url": "https://api.github.com/users/lukaslueg/events{/privacy}", "received_events_url": "https://api.github.com/users/lukaslueg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e91c4ecc09312d8b63d250a432b0f3ef83f1df7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e91c4ecc09312d8b63d250a432b0f3ef83f1df7", "html_url": "https://github.com/rust-lang/rust/commit/5e91c4ecc09312d8b63d250a432b0f3ef83f1df7"}], "stats": {"total": 61, "additions": 52, "deletions": 9}, "files": [{"sha": "4a40f8809aec7e43ce34a2176364d4274537a420", "filename": "library/core/src/iter/adapters/intersperse.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/653bcc8ad20320742e2011b4ad009b28767bcae2/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fintersperse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653bcc8ad20320742e2011b4ad009b28767bcae2/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fintersperse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fintersperse.rs?ref=653bcc8ad20320742e2011b4ad009b28767bcae2", "patch": "@@ -151,12 +151,10 @@ where\n {\n     let (lo, hi) = iter.size_hint();\n     let next_is_elem = !needs_sep;\n-    let lo = lo.saturating_sub(next_is_elem as usize).saturating_add(lo);\n-    let hi = match hi {\n-        Some(hi) => hi.saturating_sub(next_is_elem as usize).checked_add(hi),\n-        None => None,\n-    };\n-    (lo, hi)\n+    (\n+        lo.saturating_sub(next_is_elem as usize).saturating_add(lo),\n+        hi.and_then(|hi| hi.saturating_sub(next_is_elem as usize).checked_add(hi)),\n+    )\n }\n \n fn intersperse_fold<I, B, F, G>("}, {"sha": "e3b2c394e544666efee17c3ee0b62339b8b9d8e5", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 48, "deletions": 3, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/653bcc8ad20320742e2011b4ad009b28767bcae2/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653bcc8ad20320742e2011b4ad009b28767bcae2/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=653bcc8ad20320742e2011b4ad009b28767bcae2", "patch": "@@ -569,9 +569,10 @@ pub trait Iterator {\n         Zip::new(self, other.into_iter())\n     }\n \n-    /// Places a copy of `separator` between all elements.\n+    /// Creates a new iterator which places a copy of `separator` between adjacent\n+    /// items of the original iterator.\n     ///\n-    /// In case the separator does not implement [`Clone`] or needs to be\n+    /// In case `separator` does not implement [`Clone`] or needs to be\n     /// computed every time, use [`intersperse_with`].\n     ///\n     /// # Examples\n@@ -581,6 +582,19 @@ pub trait Iterator {\n     /// ```\n     /// #![feature(iter_intersperse)]\n     ///\n+    /// let mut a = [0, 1, 2].iter().intersperse(&100);\n+    /// assert_eq!(a.next(), Some(&0));   // The first element from `a`.\n+    /// assert_eq!(a.next(), Some(&100)); // The separator.\n+    /// assert_eq!(a.next(), Some(&1));   // The next element from `a`.\n+    /// assert_eq!(a.next(), Some(&100)); // The separator.\n+    /// assert_eq!(a.next(), Some(&2));   // The last element from `a`.\n+    /// assert_eq!(a.next(), None);       // The iterator is finished.\n+    /// ```\n+    ///\n+    /// `intersperse` can be very useful to join an iterator's items using a common element:\n+    /// ```\n+    /// #![feature(iter_intersperse)]\n+    ///\n     /// let hello = [\"Hello\", \"World\", \"!\"].iter().copied().intersperse(\" \").collect::<String>();\n     /// assert_eq!(hello, \"Hello World !\");\n     /// ```\n@@ -597,7 +611,16 @@ pub trait Iterator {\n         Intersperse::new(self, separator)\n     }\n \n-    /// Places an element generated by `separator` between all elements.\n+    /// Creates a new iterator which places an item generated by `separator`\n+    /// between adjacent items of the original iterator.\n+    ///\n+    /// The closure will be called exactly once each time an item is placed\n+    /// between two adjacent items from the underlying iterator; specifically,\n+    /// the closure is not called if the underlying iterator yields less than\n+    /// two items and after the last item is yielded.\n+    ///\n+    /// If the iterator's item implements [`Clone`], it may be easier to use\n+    /// [`intersperse`].\n     ///\n     /// # Examples\n     ///\n@@ -606,14 +629,36 @@ pub trait Iterator {\n     /// ```\n     /// #![feature(iter_intersperse)]\n     ///\n+    /// #[derive(PartialEq, Debug)]\n+    /// struct NotClone(usize);\n+    ///\n+    /// let v = vec![NotClone(0), NotClone(1), NotClone(2)];\n+    /// let mut it = v.into_iter().intersperse_with(|| NotClone(99));\n+    ///\n+    /// assert_eq!(it.next(), Some(NotClone(0)));  // The first element from `v`.\n+    /// assert_eq!(it.next(), Some(NotClone(99))); // The separator.\n+    /// assert_eq!(it.next(), Some(NotClone(1)));  // The next element from `v`.\n+    /// assert_eq!(it.next(), Some(NotClone(99))); // The separator.\n+    /// assert_eq!(it.next(), Some(NotClone(2)));  // The last element from from `v`.\n+    /// assert_eq!(it.next(), None);               // The iterator is finished.\n+    /// ```\n+    ///\n+    /// `intersperse_with` can be used in situations where the separator needs\n+    /// to be computed:\n+    /// ```\n+    /// #![feature(iter_intersperse)]\n+    ///\n     /// let src = [\"Hello\", \"to\", \"all\", \"people\", \"!!\"].iter().copied();\n     ///\n+    /// // The closure mutably borrows it's context to generate an item.\n     /// let mut happy_emojis = [\" \u2764\ufe0f \", \" \ud83d\ude00 \"].iter().copied();\n     /// let separator = || happy_emojis.next().unwrap_or(\" \ud83e\udd80 \");\n     ///\n     /// let result = src.intersperse_with(separator).collect::<String>();\n     /// assert_eq!(result, \"Hello \u2764\ufe0f to \ud83d\ude00 all \ud83e\udd80 people \ud83e\udd80 !!\");\n     /// ```\n+    /// [`Clone`]: crate::clone::Clone\n+    /// [`intersperse`]: Iterator::intersperse\n     #[inline]\n     #[unstable(feature = \"iter_intersperse\", reason = \"recently added\", issue = \"79524\")]\n     fn intersperse_with<G>(self, separator: G) -> IntersperseWith<Self, G>"}]}