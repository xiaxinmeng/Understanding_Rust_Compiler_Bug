{"sha": "de2911f45464d595a0fabeedd83338da819ade16", "node_id": "C_kwDOAAsO6NoAKGRlMjkxMWY0NTQ2NGQ1OTVhMGZhYmVlZGQ4MzMzOGRhODE5YWRlMTY", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-06-01T01:23:21Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-06-02T03:07:28Z"}, "message": "Overhaul CGU formation terminology.\n\nCurrently, the code uses multiple words to describe when a mono item `f`\nuses a mono item `g`, all of which have problems.\n\n- `f` references `g`: confusing because there are multiple kinds of use,\n  e.g. \"`f` calls `g`\" is one, but \"`f` takes a (`&T`-style) reference\n  of `g`\" is another, and that's two subtly different meanings of\n  \"reference\" in play.\n\n- `f` accesses `g`: meh, \"accesses\" makes me think of data, and this is\n  code.\n\n- `g` is a neighbor (or neighbour) of `f`: is verbose, and doesn't\n  capture the directionality.\n\nThis commit changes the code to use \"`f` uses `g`\" everywhere. I think\nit's better than the current terminology, and the consistency is\nimportant.\n\nAlso, `InliningMap` is renamed `UsageMap` because (a) it was always\nmostly about usage, and (b) the inlining information it did record was\nremoved in a recent commit.", "tree": {"sha": "4118578ff69b2ad8faa967047349357a804f7b14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4118578ff69b2ad8faa967047349357a804f7b14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de2911f45464d595a0fabeedd83338da819ade16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de2911f45464d595a0fabeedd83338da819ade16", "html_url": "https://github.com/rust-lang/rust/commit/de2911f45464d595a0fabeedd83338da819ade16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de2911f45464d595a0fabeedd83338da819ade16/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f85ab544dfbbce7448993c490ad16c176339b939", "url": "https://api.github.com/repos/rust-lang/rust/commits/f85ab544dfbbce7448993c490ad16c176339b939", "html_url": "https://github.com/rust-lang/rust/commit/f85ab544dfbbce7448993c490ad16c176339b939"}], "stats": {"total": 235, "additions": 115, "deletions": 120}, "files": [{"sha": "345d2e3d906415b0074fda8293ec18403fb3e811", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 83, "deletions": 88, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/de2911f45464d595a0fabeedd83338da819ade16/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2911f45464d595a0fabeedd83338da819ade16/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=de2911f45464d595a0fabeedd83338da819ade16", "patch": "@@ -35,15 +35,15 @@\n //!\n //! - A \"mono item\" is something that results in a function or global in\n //!   the LLVM IR of a codegen unit. Mono items do not stand on their\n-//!   own, they can reference other mono items. For example, if function\n+//!   own, they can use other mono items. For example, if function\n //!   `foo()` calls function `bar()` then the mono item for `foo()`\n-//!   references the mono item for function `bar()`. In general, the\n-//!   definition for mono item A referencing a mono item B is that\n-//!   the LLVM artifact produced for A references the LLVM artifact produced\n+//!   uses the mono item for function `bar()`. In general, the\n+//!   definition for mono item A using a mono item B is that\n+//!   the LLVM artifact produced for A uses the LLVM artifact produced\n //!   for B.\n //!\n-//! - Mono items and the references between them form a directed graph,\n-//!   where the mono items are the nodes and references form the edges.\n+//! - Mono items and the uses between them form a directed graph,\n+//!   where the mono items are the nodes and uses form the edges.\n //!   Let's call this graph the \"mono item graph\".\n //!\n //! - The mono item graph for a program contains all mono items\n@@ -53,12 +53,11 @@\n //! mono item graph for the current crate. It runs in two phases:\n //!\n //! 1. Discover the roots of the graph by traversing the HIR of the crate.\n-//! 2. Starting from the roots, find neighboring nodes by inspecting the MIR\n+//! 2. Starting from the roots, find uses by inspecting the MIR\n //!    representation of the item corresponding to a given node, until no more\n //!    new nodes are found.\n //!\n //! ### Discovering roots\n-//!\n //! The roots of the mono item graph correspond to the public non-generic\n //! syntactic items in the source code. We find them by walking the HIR of the\n //! crate, and whenever we hit upon a public function, method, or static item,\n@@ -69,25 +68,23 @@\n //! specified. Functions marked `#[no_mangle]` and functions called by inlinable\n //! functions also always act as roots.)\n //!\n-//! ### Finding neighbor nodes\n-//! Given a mono item node, we can discover neighbors by inspecting its\n-//! MIR. We walk the MIR and any time we hit upon something that signifies a\n-//! reference to another mono item, we have found a neighbor. Since the\n-//! mono item we are currently at is always monomorphic, we also know the\n-//! concrete type arguments of its neighbors, and so all neighbors again will be\n-//! monomorphic. The specific forms a reference to a neighboring node can take\n-//! in MIR are quite diverse. Here is an overview:\n+//! ### Finding uses\n+//! Given a mono item node, we can discover uses by inspecting its MIR. We walk\n+//! the MIR to find other mono items used by each mono item. Since the mono\n+//! item we are currently at is always monomorphic, we also know the concrete\n+//! type arguments of its used mono items. The specific forms a use can take in\n+//! MIR are quite diverse. Here is an overview:\n //!\n //! #### Calling Functions/Methods\n-//! The most obvious form of one mono item referencing another is a\n+//! The most obvious way for one mono item to use another is a\n //! function or method call (represented by a CALL terminator in MIR). But\n-//! calls are not the only thing that might introduce a reference between two\n+//! calls are not the only thing that might introduce a use between two\n //! function mono items, and as we will see below, they are just a\n //! specialization of the form described next, and consequently will not get any\n //! special treatment in the algorithm.\n //!\n //! #### Taking a reference to a function or method\n-//! A function does not need to actually be called in order to be a neighbor of\n+//! A function does not need to actually be called in order to be used by\n //! another function. It suffices to just take a reference in order to introduce\n //! an edge. Consider the following example:\n //!\n@@ -109,18 +106,18 @@\n //! The MIR of none of these functions will contain an explicit call to\n //! `print_val::<i32>`. Nonetheless, in order to mono this program, we need\n //! an instance of this function. Thus, whenever we encounter a function or\n-//! method in operand position, we treat it as a neighbor of the current\n+//! method in operand position, we treat it as a use of the current\n //! mono item. Calls are just a special case of that.\n //!\n //! #### Drop glue\n //! Drop glue mono items are introduced by MIR drop-statements. The\n-//! generated mono item will again have drop-glue item neighbors if the\n+//! generated mono item will have additional drop-glue item uses if the\n //! type to be dropped contains nested values that also need to be dropped. It\n-//! might also have a function item neighbor for the explicit `Drop::drop`\n+//! might also have a function item use for the explicit `Drop::drop`\n //! implementation of its type.\n //!\n //! #### Unsizing Casts\n-//! A subtle way of introducing neighbor edges is by casting to a trait object.\n+//! A subtle way of introducing use edges is by casting to a trait object.\n //! Since the resulting fat-pointer contains a reference to a vtable, we need to\n //! instantiate all object-safe methods of the trait, as we need to store\n //! pointers to these functions even if they never get called anywhere. This can\n@@ -151,7 +148,7 @@\n //! Mono item collection can be performed in one of two modes:\n //!\n //! - Lazy mode means that items will only be instantiated when actually\n-//!   referenced. The goal is to produce the least amount of machine code\n+//!   used. The goal is to produce the least amount of machine code\n //!   possible.\n //!\n //! - Eager mode is meant to be used in conjunction with incremental compilation\n@@ -211,66 +208,65 @@ pub enum MonoItemCollectionMode {\n     Lazy,\n }\n \n-/// Maps every mono item to all mono items it references in its\n-/// body.\n-pub struct InliningMap<'tcx> {\n-    // Maps a source mono item to the range of mono items\n-    // accessed by it.\n-    // The range selects elements within the `targets` vecs.\n-    index: FxHashMap<MonoItem<'tcx>, Range<usize>>,\n-    targets: Vec<MonoItem<'tcx>>,\n+pub struct UsageMap<'tcx> {\n+    // Maps every mono item to the mono items used by it. Those mono items\n+    // are represented as a range, which indexes into `used_items`.\n+    used_map: FxHashMap<MonoItem<'tcx>, Range<usize>>,\n+\n+    // A mono item that is used by N different other mono items will appear\n+    // here N times. Indexed into by the ranges in `used_map`.\n+    used_items: Vec<MonoItem<'tcx>>,\n }\n \n type MonoItems<'tcx> = Vec<Spanned<MonoItem<'tcx>>>;\n \n-impl<'tcx> InliningMap<'tcx> {\n-    fn new() -> InliningMap<'tcx> {\n-        InliningMap { index: FxHashMap::default(), targets: Vec::new() }\n+impl<'tcx> UsageMap<'tcx> {\n+    fn new() -> UsageMap<'tcx> {\n+        UsageMap { used_map: FxHashMap::default(), used_items: Vec::new() }\n     }\n \n-    fn record_accesses<'a>(\n+    fn record_used<'a>(\n         &mut self,\n-        source: MonoItem<'tcx>,\n-        new_targets: &'a [Spanned<MonoItem<'tcx>>],\n+        user_item: MonoItem<'tcx>,\n+        used_items: &'a [Spanned<MonoItem<'tcx>>],\n     ) where\n         'tcx: 'a,\n     {\n-        let start_index = self.targets.len();\n-        let new_items_count = new_targets.len();\n+        let old_len = self.used_items.len();\n+        let new_len = old_len + used_items.len();\n+        let new_items_range = old_len..new_len;\n \n-        self.targets.reserve(new_items_count);\n+        self.used_items.reserve(used_items.len());\n \n-        for Spanned { node: mono_item, .. } in new_targets.into_iter() {\n-            self.targets.push(*mono_item);\n+        for Spanned { node: used_item, .. } in used_items.into_iter() {\n+            self.used_items.push(*used_item);\n         }\n \n-        let end_index = self.targets.len();\n-        assert!(self.index.insert(source, start_index..end_index).is_none());\n+        assert!(self.used_map.insert(user_item, new_items_range).is_none());\n     }\n \n-    /// Internally iterate over all items referenced by `source` which will be\n-    /// made available for inlining.\n-    pub fn with_inlining_candidates<F>(&self, tcx: TyCtxt<'tcx>, source: MonoItem<'tcx>, mut f: F)\n+    /// Internally iterate over all inlined items used by `item`.\n+    pub fn for_each_inlined_used_item<F>(&self, tcx: TyCtxt<'tcx>, item: MonoItem<'tcx>, mut f: F)\n     where\n         F: FnMut(MonoItem<'tcx>),\n     {\n-        if let Some(range) = self.index.get(&source) {\n-            for candidate in self.targets[range.clone()].iter() {\n-                let is_inlined = candidate.instantiation_mode(tcx) == InstantiationMode::LocalCopy;\n+        if let Some(range) = self.used_map.get(&item) {\n+            for used_item in self.used_items[range.clone()].iter() {\n+                let is_inlined = used_item.instantiation_mode(tcx) == InstantiationMode::LocalCopy;\n                 if is_inlined {\n-                    f(*candidate);\n+                    f(*used_item);\n                 }\n             }\n         }\n     }\n \n-    /// Internally iterate over all items and the things each accesses.\n-    pub fn iter_accesses<F>(&self, mut f: F)\n+    /// Internally iterate over each item and the items used by it.\n+    pub fn for_each_item_and_its_used_items<F>(&self, mut f: F)\n     where\n         F: FnMut(MonoItem<'tcx>, &[MonoItem<'tcx>]),\n     {\n-        for (&accessor, range) in &self.index {\n-            f(accessor, &self.targets[range.clone()])\n+        for (&item, range) in &self.used_map {\n+            f(item, &self.used_items[range.clone()])\n         }\n     }\n }\n@@ -279,7 +275,7 @@ impl<'tcx> InliningMap<'tcx> {\n pub fn collect_crate_mono_items(\n     tcx: TyCtxt<'_>,\n     mode: MonoItemCollectionMode,\n-) -> (FxHashSet<MonoItem<'_>>, InliningMap<'_>) {\n+) -> (FxHashSet<MonoItem<'_>>, UsageMap<'_>) {\n     let _prof_timer = tcx.prof.generic_activity(\"monomorphization_collector\");\n \n     let roots =\n@@ -288,12 +284,12 @@ pub fn collect_crate_mono_items(\n     debug!(\"building mono item graph, beginning at roots\");\n \n     let mut visited = MTLock::new(FxHashSet::default());\n-    let mut inlining_map = MTLock::new(InliningMap::new());\n+    let mut usage_map = MTLock::new(UsageMap::new());\n     let recursion_limit = tcx.recursion_limit();\n \n     {\n         let visited: MTLockRef<'_, _> = &mut visited;\n-        let inlining_map: MTLockRef<'_, _> = &mut inlining_map;\n+        let usage_map: MTLockRef<'_, _> = &mut usage_map;\n \n         tcx.sess.time(\"monomorphization_collector_graph_walk\", || {\n             par_for_each_in(roots, |root| {\n@@ -304,13 +300,13 @@ pub fn collect_crate_mono_items(\n                     visited,\n                     &mut recursion_depths,\n                     recursion_limit,\n-                    inlining_map,\n+                    usage_map,\n                 );\n             });\n         });\n     }\n \n-    (visited.into_inner(), inlining_map.into_inner())\n+    (visited.into_inner(), usage_map.into_inner())\n }\n \n // Find all non-generic items by walking the HIR. These items serve as roots to\n@@ -353,24 +349,23 @@ fn collect_roots(tcx: TyCtxt<'_>, mode: MonoItemCollectionMode) -> Vec<MonoItem<\n \n /// Collect all monomorphized items reachable from `starting_point`, and emit a note diagnostic if a\n /// post-monomorphization error is encountered during a collection step.\n-#[instrument(skip(tcx, visited, recursion_depths, recursion_limit, inlining_map), level = \"debug\")]\n+#[instrument(skip(tcx, visited, recursion_depths, recursion_limit, usage_map), level = \"debug\")]\n fn collect_items_rec<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    starting_point: Spanned<MonoItem<'tcx>>,\n+    starting_item: Spanned<MonoItem<'tcx>>,\n     visited: MTLockRef<'_, FxHashSet<MonoItem<'tcx>>>,\n     recursion_depths: &mut DefIdMap<usize>,\n     recursion_limit: Limit,\n-    inlining_map: MTLockRef<'_, InliningMap<'tcx>>,\n+    usage_map: MTLockRef<'_, UsageMap<'tcx>>,\n ) {\n-    if !visited.lock_mut().insert(starting_point.node) {\n+    if !visited.lock_mut().insert(starting_item.node) {\n         // We've been here already, no need to search again.\n         return;\n     }\n \n-    let mut neighbors = Vec::new();\n+    let mut used_items = Vec::new();\n     let recursion_depth_reset;\n \n-    //\n     // Post-monomorphization errors MVP\n     //\n     // We can encounter errors while monomorphizing an item, but we don't have a good way of\n@@ -396,27 +391,27 @@ fn collect_items_rec<'tcx>(\n     // FIXME: don't rely on global state, instead bubble up errors. Note: this is very hard to do.\n     let error_count = tcx.sess.diagnostic().err_count();\n \n-    match starting_point.node {\n+    match starting_item.node {\n         MonoItem::Static(def_id) => {\n             let instance = Instance::mono(tcx, def_id);\n \n             // Sanity check whether this ended up being collected accidentally\n             debug_assert!(should_codegen_locally(tcx, &instance));\n \n             let ty = instance.ty(tcx, ty::ParamEnv::reveal_all());\n-            visit_drop_use(tcx, ty, true, starting_point.span, &mut neighbors);\n+            visit_drop_use(tcx, ty, true, starting_item.span, &mut used_items);\n \n             recursion_depth_reset = None;\n \n             if let Ok(alloc) = tcx.eval_static_initializer(def_id) {\n                 for &id in alloc.inner().provenance().ptrs().values() {\n-                    collect_miri(tcx, id, &mut neighbors);\n+                    collect_miri(tcx, id, &mut used_items);\n                 }\n             }\n \n             if tcx.needs_thread_local_shim(def_id) {\n-                neighbors.push(respan(\n-                    starting_point.span,\n+                used_items.push(respan(\n+                    starting_item.span,\n                     MonoItem::Fn(Instance {\n                         def: InstanceDef::ThreadLocalShim(def_id),\n                         substs: InternalSubsts::empty(),\n@@ -432,14 +427,14 @@ fn collect_items_rec<'tcx>(\n             recursion_depth_reset = Some(check_recursion_limit(\n                 tcx,\n                 instance,\n-                starting_point.span,\n+                starting_item.span,\n                 recursion_depths,\n                 recursion_limit,\n             ));\n             check_type_length_limit(tcx, instance);\n \n             rustc_data_structures::stack::ensure_sufficient_stack(|| {\n-                collect_neighbours(tcx, instance, &mut neighbors);\n+                collect_used_items(tcx, instance, &mut used_items);\n             });\n         }\n         MonoItem::GlobalAsm(item_id) => {\n@@ -457,13 +452,13 @@ fn collect_items_rec<'tcx>(\n                         hir::InlineAsmOperand::SymFn { anon_const } => {\n                             let fn_ty =\n                                 tcx.typeck_body(anon_const.body).node_type(anon_const.hir_id);\n-                            visit_fn_use(tcx, fn_ty, false, *op_sp, &mut neighbors);\n+                            visit_fn_use(tcx, fn_ty, false, *op_sp, &mut used_items);\n                         }\n                         hir::InlineAsmOperand::SymStatic { path: _, def_id } => {\n                             let instance = Instance::mono(tcx, *def_id);\n                             if should_codegen_locally(tcx, &instance) {\n                                 trace!(\"collecting static {:?}\", def_id);\n-                                neighbors.push(dummy_spanned(MonoItem::Static(*def_id)));\n+                                used_items.push(dummy_spanned(MonoItem::Static(*def_id)));\n                             }\n                         }\n                         hir::InlineAsmOperand::In { .. }\n@@ -483,19 +478,19 @@ fn collect_items_rec<'tcx>(\n     // Check for PMEs and emit a diagnostic if one happened. To try to show relevant edges of the\n     // mono item graph.\n     if tcx.sess.diagnostic().err_count() > error_count\n-        && starting_point.node.is_generic_fn()\n-        && starting_point.node.is_user_defined()\n+        && starting_item.node.is_generic_fn()\n+        && starting_item.node.is_user_defined()\n     {\n-        let formatted_item = with_no_trimmed_paths!(starting_point.node.to_string());\n+        let formatted_item = with_no_trimmed_paths!(starting_item.node.to_string());\n         tcx.sess.emit_note(EncounteredErrorWhileInstantiating {\n-            span: starting_point.span,\n+            span: starting_item.span,\n             formatted_item,\n         });\n     }\n-    inlining_map.lock_mut().record_accesses(starting_point.node, &neighbors);\n+    usage_map.lock_mut().record_used(starting_item.node, &used_items);\n \n-    for neighbour in neighbors {\n-        collect_items_rec(tcx, neighbour, visited, recursion_depths, recursion_limit, inlining_map);\n+    for used_item in used_items {\n+        collect_items_rec(tcx, used_item, visited, recursion_depths, recursion_limit, usage_map);\n     }\n \n     if let Some((def_id, depth)) = recursion_depth_reset {\n@@ -611,14 +606,14 @@ fn check_type_length_limit<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) {\n     }\n }\n \n-struct MirNeighborCollector<'a, 'tcx> {\n+struct MirUsedCollector<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a mir::Body<'tcx>,\n     output: &'a mut MonoItems<'tcx>,\n     instance: Instance<'tcx>,\n }\n \n-impl<'a, 'tcx> MirNeighborCollector<'a, 'tcx> {\n+impl<'a, 'tcx> MirUsedCollector<'a, 'tcx> {\n     pub fn monomorphize<T>(&self, value: T) -> T\n     where\n         T: TypeFoldable<TyCtxt<'tcx>>,\n@@ -632,7 +627,7 @@ impl<'a, 'tcx> MirNeighborCollector<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n+impl<'a, 'tcx> MirVisitor<'tcx> for MirUsedCollector<'a, 'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &mir::Rvalue<'tcx>, location: Location) {\n         debug!(\"visiting rvalue {:?}\", *rvalue);\n \n@@ -1392,13 +1387,13 @@ fn collect_miri<'tcx>(tcx: TyCtxt<'tcx>, alloc_id: AllocId, output: &mut MonoIte\n \n /// Scans the MIR in order to find function calls, closures, and drop-glue.\n #[instrument(skip(tcx, output), level = \"debug\")]\n-fn collect_neighbours<'tcx>(\n+fn collect_used_items<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance: Instance<'tcx>,\n     output: &mut MonoItems<'tcx>,\n ) {\n     let body = tcx.instance_mir(instance.def);\n-    MirNeighborCollector { tcx, body: &body, output, instance }.visit_body(&body);\n+    MirUsedCollector { tcx, body: &body, output, instance }.visit_body(&body);\n }\n \n #[instrument(skip(tcx, output), level = \"debug\")]"}, {"sha": "5d707e62430b0aae02668ae0a2018fb3ef52d112", "filename": "compiler/rustc_monomorphize/src/partitioning.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/de2911f45464d595a0fabeedd83338da819ade16/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2911f45464d595a0fabeedd83338da819ade16/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs?ref=de2911f45464d595a0fabeedd83338da819ade16", "patch": "@@ -115,14 +115,14 @@ use rustc_middle::ty::{self, visit::TypeVisitableExt, InstanceDef, TyCtxt};\n use rustc_session::config::{DumpMonoStatsFormat, SwitchWithOptPath};\n use rustc_span::symbol::Symbol;\n \n-use crate::collector::InliningMap;\n+use crate::collector::UsageMap;\n use crate::collector::{self, MonoItemCollectionMode};\n use crate::errors::{CouldntDumpMonoStats, SymbolAlreadyDefined, UnknownCguCollectionMode};\n \n struct PartitioningCx<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     target_cgu_count: usize,\n-    inlining_map: &'a InliningMap<'tcx>,\n+    usage_map: &'a UsageMap<'tcx>,\n }\n \n struct PlacedRootMonoItems<'tcx> {\n@@ -138,14 +138,14 @@ fn partition<'tcx, I>(\n     tcx: TyCtxt<'tcx>,\n     mono_items: &mut I,\n     max_cgu_count: usize,\n-    inlining_map: &InliningMap<'tcx>,\n+    usage_map: &UsageMap<'tcx>,\n ) -> Vec<CodegenUnit<'tcx>>\n where\n     I: Iterator<Item = MonoItem<'tcx>>,\n {\n     let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning\");\n \n-    let cx = &PartitioningCx { tcx, target_cgu_count: max_cgu_count, inlining_map };\n+    let cx = &PartitioningCx { tcx, target_cgu_count: max_cgu_count, usage_map };\n \n     // In the first step, we place all regular monomorphizations into their\n     // respective 'home' codegen unit. Regular monomorphizations are all\n@@ -405,7 +405,7 @@ fn merge_codegen_units<'tcx>(\n }\n \n /// For symbol internalization, we need to know whether a symbol/mono-item is\n-/// accessed from outside the codegen unit it is defined in. This type is used\n+/// used from outside the codegen unit it is defined in. This type is used\n /// to keep track of that.\n #[derive(Clone, PartialEq, Eq, Debug)]\n enum MonoItemPlacement {\n@@ -426,7 +426,7 @@ fn place_inlined_mono_items<'tcx>(\n         // Collect all items that need to be available in this codegen unit.\n         let mut reachable = FxHashSet::default();\n         for root in old_codegen_unit.items().keys() {\n-            follow_inlining(cx.tcx, *root, cx.inlining_map, &mut reachable);\n+            follow_inlining(cx.tcx, *root, cx.usage_map, &mut reachable);\n         }\n \n         let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name());\n@@ -481,16 +481,16 @@ fn place_inlined_mono_items<'tcx>(\n \n     fn follow_inlining<'tcx>(\n         tcx: TyCtxt<'tcx>,\n-        mono_item: MonoItem<'tcx>,\n-        inlining_map: &InliningMap<'tcx>,\n+        item: MonoItem<'tcx>,\n+        usage_map: &UsageMap<'tcx>,\n         visited: &mut FxHashSet<MonoItem<'tcx>>,\n     ) {\n-        if !visited.insert(mono_item) {\n+        if !visited.insert(item) {\n             return;\n         }\n \n-        inlining_map.with_inlining_candidates(tcx, mono_item, |target| {\n-            follow_inlining(tcx, target, inlining_map, visited);\n+        usage_map.for_each_inlined_used_item(tcx, item, |inlined_item| {\n+            follow_inlining(tcx, inlined_item, usage_map, visited);\n         });\n     }\n }\n@@ -504,7 +504,7 @@ fn internalize_symbols<'tcx>(\n     if codegen_units.len() == 1 {\n         // Fast path for when there is only one codegen unit. In this case we\n         // can internalize all candidates, since there is nowhere else they\n-        // could be accessed from.\n+        // could be used from.\n         for cgu in codegen_units {\n             for candidate in &internalization_candidates {\n                 cgu.items_mut().insert(*candidate, (Linkage::Internal, Visibility::Default));\n@@ -516,43 +516,43 @@ fn internalize_symbols<'tcx>(\n \n     // Build a map from every monomorphization to all the monomorphizations that\n     // reference it.\n-    let mut accessor_map: FxHashMap<MonoItem<'tcx>, Vec<MonoItem<'tcx>>> = Default::default();\n-    cx.inlining_map.iter_accesses(|accessor, accessees| {\n-        for accessee in accessees {\n-            accessor_map.entry(*accessee).or_default().push(accessor);\n+    let mut user_map: FxHashMap<MonoItem<'tcx>, Vec<MonoItem<'tcx>>> = Default::default();\n+    cx.usage_map.for_each_item_and_its_used_items(|user_item, used_items| {\n+        for used_item in used_items {\n+            user_map.entry(*used_item).or_default().push(user_item);\n         }\n     });\n \n     // For each internalization candidates in each codegen unit, check if it is\n-    // accessed from outside its defining codegen unit.\n+    // used from outside its defining codegen unit.\n     for cgu in codegen_units {\n         let home_cgu = MonoItemPlacement::SingleCgu { cgu_name: cgu.name() };\n \n-        for (accessee, linkage_and_visibility) in cgu.items_mut() {\n-            if !internalization_candidates.contains(accessee) {\n+        for (item, linkage_and_visibility) in cgu.items_mut() {\n+            if !internalization_candidates.contains(item) {\n                 // This item is no candidate for internalizing, so skip it.\n                 continue;\n             }\n-            debug_assert_eq!(mono_item_placements[accessee], home_cgu);\n+            debug_assert_eq!(mono_item_placements[item], home_cgu);\n \n-            if let Some(accessors) = accessor_map.get(accessee) {\n-                if accessors\n+            if let Some(user_items) = user_map.get(item) {\n+                if user_items\n                     .iter()\n-                    .filter_map(|accessor| {\n-                        // Some accessors might not have been\n+                    .filter_map(|user_item| {\n+                        // Some user mono items might not have been\n                         // instantiated. We can safely ignore those.\n-                        mono_item_placements.get(accessor)\n+                        mono_item_placements.get(user_item)\n                     })\n                     .any(|placement| *placement != home_cgu)\n                 {\n-                    // Found an accessor from another CGU, so skip to the next\n-                    // item without marking this one as internal.\n+                    // Found a user from another CGU, so skip to the next item\n+                    // without marking this one as internal.\n                     continue;\n                 }\n             }\n \n-            // If we got here, we did not find any accesses from other CGUs,\n-            // so it's fine to make this monomorphization internal.\n+            // If we got here, we did not find any uses from other CGUs, so\n+            // it's fine to make this monomorphization internal.\n             *linkage_and_visibility = (Linkage::Internal, Visibility::Default);\n         }\n     }\n@@ -788,7 +788,7 @@ fn mono_item_visibility<'tcx>(\n     } else {\n         // If this isn't a generic function then we mark this a `Default` if\n         // this is a reachable item, meaning that it's a symbol other crates may\n-        // access when they link to us.\n+        // use when they link to us.\n         if tcx.is_reachable_non_generic(def_id.to_def_id()) {\n             *can_be_internalized = false;\n             debug_assert!(!is_generic);\n@@ -968,7 +968,7 @@ fn collect_and_partition_mono_items(tcx: TyCtxt<'_>, (): ()) -> (&DefIdSet, &[Co\n         }\n     };\n \n-    let (items, inlining_map) = collector::collect_crate_mono_items(tcx, collection_mode);\n+    let (items, usage_map) = collector::collect_crate_mono_items(tcx, collection_mode);\n \n     tcx.sess.abort_if_errors();\n \n@@ -979,7 +979,7 @@ fn collect_and_partition_mono_items(tcx: TyCtxt<'_>, (): ()) -> (&DefIdSet, &[Co\n                     tcx,\n                     &mut items.iter().copied(),\n                     tcx.sess.codegen_units(),\n-                    &inlining_map,\n+                    &usage_map,\n                 );\n                 codegen_units[0].make_primary();\n                 &*tcx.arena.alloc_from_iter(codegen_units)"}]}