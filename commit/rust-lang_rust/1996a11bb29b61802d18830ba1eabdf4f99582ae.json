{"sha": "1996a11bb29b61802d18830ba1eabdf4f99582ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5OTZhMTFiYjI5YjYxODAyZDE4ODMwYmExZWFiZGY0Zjk5NTgyYWU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-04T22:04:11Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-05T00:41:15Z"}, "message": "Cache more results of const_eval\n\nAccording to http://huonw.github.io/isrustfastyet/mem/#012f909, the \"const\nmarking\" pass generates about 400MB of extra memory during compilation. It\nappears that this is due to two different factors:\n\n    1. There is a `ccache` map in the ty::ctxt which is only ever used in this\n       pass, so this commit moves the map out of the ty::ctxt struct and into\n       just this pass's visitor. This turned out to not benefit that much in\n       memory (as indicated by http://i.imgur.com/Eo4iOzK.png), but it's helpful\n       to do nonetheless.\n\n    2. During const_eval, there are a lot of lookups into decoding inlined items\n       from external crates. There is no caching involved here, so the same\n       static or variant could be re-translated many times. After adding\n       separate caches for variants and statics, the memory peak of compiling\n       rustc decreased by 200MB (as evident by http://i.imgur.com/ULAUMtq.png)\n\nThe culmination of this is basically a slight reorganization of a caching map\nfor the const_eval pass along with a 200MB decrease in peak memory usage when\ncompiling librustc.", "tree": {"sha": "f283b2749d0f31613920ce842edb1b3eb8339f18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f283b2749d0f31613920ce842edb1b3eb8339f18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1996a11bb29b61802d18830ba1eabdf4f99582ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1996a11bb29b61802d18830ba1eabdf4f99582ae", "html_url": "https://github.com/rust-lang/rust/commit/1996a11bb29b61802d18830ba1eabdf4f99582ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1996a11bb29b61802d18830ba1eabdf4f99582ae/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8cb3426f16e22215f9a8dd61bb8b965fb9b26023", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cb3426f16e22215f9a8dd61bb8b965fb9b26023", "html_url": "https://github.com/rust-lang/rust/commit/8cb3426f16e22215f9a8dd61bb8b965fb9b26023"}], "stats": {"total": 239, "additions": 124, "deletions": 115}, "files": [{"sha": "cc818c9c00120e886963dcfac770c3bec623d7fa", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 116, "deletions": 111, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/1996a11bb29b61802d18830ba1eabdf4f99582ae/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1996a11bb29b61802d18830ba1eabdf4f99582ae/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=1996a11bb29b61802d18830ba1eabdf4f99582ae", "patch": "@@ -60,6 +60,8 @@ pub enum constness {\n     non_const\n }\n \n+type constness_cache = HashMap<ast::DefId, constness>;\n+\n pub fn join(a: constness, b: constness) -> constness {\n     match (a, b) {\n       (integral_const, integral_const) => integral_const,\n@@ -74,102 +76,12 @@ pub fn join_all<It: Iterator<constness>>(mut cs: It) -> constness {\n     cs.fold(integral_const, |a, b| join(a, b))\n }\n \n-pub fn classify(e: &Expr,\n-                tcx: ty::ctxt)\n-             -> constness {\n-    let did = ast_util::local_def(e.id);\n-    match tcx.ccache.find(&did) {\n-      Some(&x) => x,\n-      None => {\n-        let cn =\n-            match e.node {\n-              ast::ExprLit(lit) => {\n-                match lit.node {\n-                  ast::lit_str(*) |\n-                  ast::lit_float(*) => general_const,\n-                  _ => integral_const\n-                }\n-              }\n-\n-              ast::ExprUnary(_, _, inner) |\n-              ast::ExprParen(inner) => {\n-                classify(inner, tcx)\n-              }\n-\n-              ast::ExprBinary(_, _, a, b) => {\n-                join(classify(a, tcx),\n-                     classify(b, tcx))\n-              }\n-\n-              ast::ExprTup(ref es) |\n-              ast::ExprVec(ref es, ast::MutImmutable) => {\n-                join_all(es.iter().map(|e| classify(*e, tcx)))\n-              }\n-\n-              ast::ExprVstore(e, vstore) => {\n-                  match vstore {\n-                      ast::ExprVstoreSlice => classify(e, tcx),\n-                      ast::ExprVstoreUniq |\n-                      ast::ExprVstoreBox |\n-                      ast::ExprVstoreMutBox |\n-                      ast::ExprVstoreMutSlice => non_const\n-                  }\n-              }\n-\n-              ast::ExprStruct(_, ref fs, None) => {\n-                let cs = do fs.iter().map |f| {\n-                    classify(f.expr, tcx)\n-                };\n-                join_all(cs)\n-              }\n-\n-              ast::ExprCast(base, _) => {\n-                let ty = ty::expr_ty(tcx, e);\n-                let base = classify(base, tcx);\n-                if ty::type_is_integral(ty) {\n-                    join(integral_const, base)\n-                } else if ty::type_is_fp(ty) {\n-                    join(general_const, base)\n-                } else {\n-                    non_const\n-                }\n-              }\n-\n-              ast::ExprField(base, _, _) => {\n-                classify(base, tcx)\n-              }\n-\n-              ast::ExprIndex(_, base, idx) => {\n-                join(classify(base, tcx),\n-                     classify(idx, tcx))\n-              }\n-\n-              ast::ExprAddrOf(ast::MutImmutable, base) => {\n-                classify(base, tcx)\n-              }\n-\n-              // FIXME: (#3728) we can probably do something CCI-ish\n-              // surrounding nonlocal constants. But we don't yet.\n-              ast::ExprPath(_) => {\n-                lookup_constness(tcx, e)\n-              }\n-\n-              ast::ExprRepeat(*) => general_const,\n-\n-              _ => non_const\n-            };\n-        tcx.ccache.insert(did, cn);\n-        cn\n-      }\n-    }\n-}\n-\n pub fn lookup_const(tcx: ty::ctxt, e: &Expr) -> Option<@Expr> {\n     match tcx.def_map.find(&e.id) {\n-        Some(&ast::DefStatic(def_id, false)) => lookup_const_by_id(tcx, def_id),\n-        Some(&ast::DefVariant(enum_def, variant_def, _)) => lookup_variant_by_id(tcx,\n-                                                                               enum_def,\n-                                                                               variant_def),\n+        Some(&ast::DefStatic(def_id, false)) =>\n+            lookup_const_by_id(tcx, def_id),\n+        Some(&ast::DefVariant(enum_def, variant_def, _)) =>\n+            lookup_variant_by_id(tcx, enum_def, variant_def),\n         _ => None\n     }\n }\n@@ -199,14 +111,18 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n             Some(_) => None\n         }\n     } else {\n+        match tcx.extern_const_variants.find(&variant_def) {\n+            Some(&e) => return e,\n+            None => {}\n+        }\n         let maps = astencode::Maps {\n             root_map: @mut HashMap::new(),\n             method_map: @mut HashMap::new(),\n             vtable_map: @mut HashMap::new(),\n             write_guard_map: @mut HashSet::new(),\n             capture_map: @mut HashMap::new()\n         };\n-        match csearch::maybe_get_item_ast(tcx, enum_def,\n+        let e = match csearch::maybe_get_item_ast(tcx, enum_def,\n             |a, b, c, d| astencode::decode_inlined_item(a,\n                                                         b,\n                                                         maps,\n@@ -219,7 +135,9 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n                 _ => None\n             },\n             _ => None\n-        }\n+        };\n+        tcx.extern_const_variants.insert(variant_def, e);\n+        return e;\n     }\n }\n \n@@ -236,49 +154,136 @@ pub fn lookup_const_by_id(tcx: ty::ctxt,\n             Some(_) => None\n         }\n     } else {\n+        match tcx.extern_const_statics.find(&def_id) {\n+            Some(&e) => return e,\n+            None => {}\n+        }\n         let maps = astencode::Maps {\n             root_map: @mut HashMap::new(),\n             method_map: @mut HashMap::new(),\n             vtable_map: @mut HashMap::new(),\n             write_guard_map: @mut HashSet::new(),\n             capture_map: @mut HashMap::new()\n         };\n-        match csearch::maybe_get_item_ast(tcx, def_id,\n+        let e = match csearch::maybe_get_item_ast(tcx, def_id,\n             |a, b, c, d| astencode::decode_inlined_item(a, b, maps, c, d)) {\n             csearch::found(ast::ii_item(item)) => match item.node {\n                 item_static(_, ast::MutImmutable, const_expr) => Some(const_expr),\n                 _ => None\n             },\n             _ => None\n-        }\n+        };\n+        tcx.extern_const_statics.insert(def_id, e);\n+        return e;\n     }\n }\n \n-pub fn lookup_constness(tcx: ty::ctxt, e: &Expr) -> constness {\n-    match lookup_const(tcx, e) {\n-        Some(rhs) => {\n-            let ty = ty::expr_ty(tcx, rhs);\n-            if ty::type_is_integral(ty) {\n-                integral_const\n-            } else {\n-                general_const\n+struct ConstEvalVisitor {\n+    tcx: ty::ctxt,\n+    ccache: constness_cache,\n+}\n+\n+impl ConstEvalVisitor {\n+    fn classify(&mut self, e: &Expr) -> constness {\n+        let did = ast_util::local_def(e.id);\n+        match self.ccache.find(&did) {\n+            Some(&x) => return x,\n+            None => {}\n+        }\n+        let cn = match e.node {\n+            ast::ExprLit(lit) => {\n+                match lit.node {\n+                    ast::lit_str(*) | ast::lit_float(*) => general_const,\n+                    _ => integral_const\n+                }\n+            }\n+\n+            ast::ExprUnary(_, _, inner) | ast::ExprParen(inner) =>\n+                self.classify(inner),\n+\n+            ast::ExprBinary(_, _, a, b) =>\n+                join(self.classify(a), self.classify(b)),\n+\n+            ast::ExprTup(ref es) |\n+            ast::ExprVec(ref es, ast::MutImmutable) =>\n+                join_all(es.iter().map(|e| self.classify(*e))),\n+\n+            ast::ExprVstore(e, vstore) => {\n+                match vstore {\n+                    ast::ExprVstoreSlice => self.classify(e),\n+                    ast::ExprVstoreUniq |\n+                    ast::ExprVstoreBox |\n+                    ast::ExprVstoreMutBox |\n+                    ast::ExprVstoreMutSlice => non_const\n+                }\n+            }\n+\n+            ast::ExprStruct(_, ref fs, None) => {\n+                let cs = do fs.iter().map |f| {\n+                    self.classify(f.expr)\n+                };\n+                join_all(cs)\n+            }\n+\n+            ast::ExprCast(base, _) => {\n+                let ty = ty::expr_ty(self.tcx, e);\n+                let base = self.classify(base);\n+                if ty::type_is_integral(ty) {\n+                    join(integral_const, base)\n+                } else if ty::type_is_fp(ty) {\n+                    join(general_const, base)\n+                } else {\n+                    non_const\n+                }\n+            }\n+\n+            ast::ExprField(base, _, _) => self.classify(base),\n+\n+            ast::ExprIndex(_, base, idx) =>\n+                join(self.classify(base), self.classify(idx)),\n+\n+            ast::ExprAddrOf(ast::MutImmutable, base) => self.classify(base),\n+\n+            // FIXME: (#3728) we can probably do something CCI-ish\n+            // surrounding nonlocal constants. But we don't yet.\n+            ast::ExprPath(_) => self.lookup_constness(e),\n+\n+            ast::ExprRepeat(*) => general_const,\n+\n+            _ => non_const\n+        };\n+        self.ccache.insert(did, cn);\n+        cn\n+    }\n+\n+    fn lookup_constness(&self, e: &Expr) -> constness {\n+        match lookup_const(self.tcx, e) {\n+            Some(rhs) => {\n+                let ty = ty::expr_ty(self.tcx, rhs);\n+                if ty::type_is_integral(ty) {\n+                    integral_const\n+                } else {\n+                    general_const\n+                }\n             }\n+            None => non_const\n         }\n-        None => non_const\n     }\n-}\n \n-struct ConstEvalVisitor { tcx: ty::ctxt }\n+}\n \n impl Visitor<()> for ConstEvalVisitor {\n     fn visit_expr_post(&mut self, e:@Expr, _:()) {\n-        classify(e, self.tcx);\n+        self.classify(e);\n     }\n }\n \n pub fn process_crate(crate: &ast::Crate,\n                      tcx: ty::ctxt) {\n-    let mut v = ConstEvalVisitor { tcx: tcx };\n+    let mut v = ConstEvalVisitor {\n+        tcx: tcx,\n+        ccache: HashMap::new(),\n+    };\n     visit::walk_crate(&mut v, crate, ());\n     tcx.sess.abort_if_errors();\n }"}, {"sha": "d21852751b4594bd31d49b512648463668c60cd2", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1996a11bb29b61802d18830ba1eabdf4f99582ae/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1996a11bb29b61802d18830ba1eabdf4f99582ae/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=1996a11bb29b61802d18830ba1eabdf4f99582ae", "patch": "@@ -290,7 +290,6 @@ struct ctxt_ {\n     freevars: freevars::freevar_map,\n     tcache: type_cache,\n     rcache: creader_cache,\n-    ccache: constness_cache,\n     short_names_cache: @mut HashMap<t, @str>,\n     needs_unwind_cleanup_cache: @mut HashMap<t, bool>,\n     tc_cache: @mut HashMap<uint, TypeContents>,\n@@ -346,6 +345,11 @@ struct ctxt_ {\n     // The set of external traits whose implementations have been read. This\n     // is used for lazy resolution of traits.\n     populated_external_traits: @mut HashSet<ast::DefId>,\n+\n+    // These two caches are used by const_eval when decoding external statics\n+    // and variants that are found.\n+    extern_const_statics: @mut HashMap<ast::DefId, Option<@ast::Expr>>,\n+    extern_const_variants: @mut HashMap<ast::DefId, Option<@ast::Expr>>,\n }\n \n pub enum tbox_flag {\n@@ -897,8 +901,6 @@ pub struct ty_param_substs_and_ty {\n \n type type_cache = @mut HashMap<ast::DefId, ty_param_bounds_and_ty>;\n \n-type constness_cache = @mut HashMap<ast::DefId, const_eval::constness>;\n-\n pub type node_type_table = @mut HashMap<uint,t>;\n \n fn mk_rcache() -> creader_cache {\n@@ -935,7 +937,6 @@ pub fn mk_ctxt(s: session::Session,\n         freevars: freevars,\n         tcache: @mut HashMap::new(),\n         rcache: mk_rcache(),\n-        ccache: @mut HashMap::new(),\n         short_names_cache: new_ty_hash(),\n         needs_unwind_cleanup_cache: new_ty_hash(),\n         tc_cache: @mut HashMap::new(),\n@@ -961,6 +962,9 @@ pub fn mk_ctxt(s: session::Session,\n         impl_vtables: @mut HashMap::new(),\n         populated_external_types: @mut HashSet::new(),\n         populated_external_traits: @mut HashSet::new(),\n+\n+        extern_const_statics: @mut HashMap::new(),\n+        extern_const_variants: @mut HashMap::new(),\n      }\n }\n "}]}