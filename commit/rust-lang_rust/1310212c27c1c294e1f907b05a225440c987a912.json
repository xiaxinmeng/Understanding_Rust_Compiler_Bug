{"sha": "1310212c27c1c294e1f907b05a225440c987a912", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzMTAyMTJjMjdjMWMyOTRlMWY5MDdiMDVhMjI1NDQwYzk4N2E5MTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-10T19:10:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-10T19:10:39Z"}, "message": "auto merge of #7032 : huonw/rust/each-fn-kill, r=thestinger\n\nContinuation of #7015, and #6995.\r\n\r\nRewrites the character-based `each_split` functions in `str` to use an iterator, removes a few redundant methods, and replaces all uses of `len`, `is_empty` and `slice` functions with the methods (and deletes the the functions).\r\n\r\nUpdate: Ok, this has turned into a major makeover for `str`, turning a lot of functions into methods, and removing redundant ones. Each commit is essentially a single such change.\r\n\r\n(Unscientific benchmarks suggest that the external `split_iter` is approximately 10% faster than the internal one. I'm not quite sure why this would be true.)\r\n\r\n(@thestinger is probably interested in this.)", "tree": {"sha": "55be12fd3e32a320f11b3d7cf6125a825aede7c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55be12fd3e32a320f11b3d7cf6125a825aede7c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1310212c27c1c294e1f907b05a225440c987a912", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1310212c27c1c294e1f907b05a225440c987a912", "html_url": "https://github.com/rust-lang/rust/commit/1310212c27c1c294e1f907b05a225440c987a912", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1310212c27c1c294e1f907b05a225440c987a912/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ff6b298c5f23f48aa993fced41b6e29e446b7ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ff6b298c5f23f48aa993fced41b6e29e446b7ce", "html_url": "https://github.com/rust-lang/rust/commit/2ff6b298c5f23f48aa993fced41b6e29e446b7ce"}, {"sha": "e8782eeb6327eb79b132cc3f71bfaf55310dde00", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8782eeb6327eb79b132cc3f71bfaf55310dde00", "html_url": "https://github.com/rust-lang/rust/commit/e8782eeb6327eb79b132cc3f71bfaf55310dde00"}], "stats": {"total": 3889, "additions": 1533, "deletions": 2356}, "files": [{"sha": "3c0828def154ac60d2296f73e4226539e964367a", "filename": "doc/rust.md", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -803,19 +803,14 @@ An example of `use` declarations:\n \n ~~~~\n use std::float::sin;\n-use std::str::{slice, contains};\n-use std::option::Some;\n+use std::option::{Some, None};\n \n fn main() {\n     // Equivalent to 'info!(std::float::sin(1.0));'\n     info!(sin(1.0));\n \n-    // Equivalent to 'info!(std::option::Some(1.0));'\n-    info!(Some(1.0));\n-\n-    // Equivalent to\n-    // 'info!(std::str::contains(std::str::slice(\"foo\", 0, 1), \"oo\"));'\n-    info!(contains(slice(\"foo\", 0, 1), \"oo\"));\n+    // Equivalent to 'info!(~[std::option::Some(1.0), std::option::None]);'\n+    info!(~[Some(1.0), None]);\n }\n ~~~~\n "}, {"sha": "e832534b227a9b6a294c2731bc4cadc9676a9fb2", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -231,11 +231,11 @@ pub fn is_test(config: &config, testfile: &Path) -> bool {\n     let mut valid = false;\n \n     for valid_extensions.each |ext| {\n-        if str::ends_with(name, *ext) { valid = true; }\n+        if name.ends_with(*ext) { valid = true; }\n     }\n \n     for invalid_prefixes.each |pre| {\n-        if str::starts_with(name, *pre) { valid = false; }\n+        if name.starts_with(*pre) { valid = false; }\n     }\n \n     return valid;"}, {"sha": "cdc0defcbcab08c3bd9ffb00f857cb628be6c4bc", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -11,7 +11,6 @@\n use core::prelude::*;\n \n use core::io;\n-use core::str;\n \n pub struct ExpectedError { line: uint, kind: ~str, msg: ~str }\n \n@@ -31,15 +30,15 @@ pub fn load_errors(testfile: &Path) -> ~[ExpectedError] {\n fn parse_expected(line_num: uint, line: ~str) -> ~[ExpectedError] {\n     let error_tag = ~\"//~\";\n     let mut idx;\n-    match str::find_str(line, error_tag) {\n+    match line.find_str(error_tag) {\n       None => return ~[],\n-      Some(nn) => { idx = (nn as uint) + str::len(error_tag); }\n+      Some(nn) => { idx = (nn as uint) + error_tag.len(); }\n     }\n \n     // \"//~^^^ kind msg\" denotes a message expected\n     // three lines above current line:\n     let mut adjust_line = 0u;\n-    let len = str::len(line);\n+    let len = line.len();\n     while idx < len && line[idx] == ('^' as u8) {\n         adjust_line += 1u;\n         idx += 1u;\n@@ -52,12 +51,12 @@ fn parse_expected(line_num: uint, line: ~str) -> ~[ExpectedError] {\n \n     // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use\n     // to_ascii_consume and to_str_consume to not do a unnecessary copy.\n-    let kind = str::slice(line, start_kind, idx);\n+    let kind = line.slice(start_kind, idx);\n     let kind = kind.to_ascii().to_lower().to_str_ascii();\n \n     // Extract msg:\n     while idx < len && line[idx] == (' ' as u8) { idx += 1u; }\n-    let msg = str::slice(line, idx, len).to_owned();\n+    let msg = line.slice(idx, len).to_owned();\n \n     debug!(\"line=%u kind=%s msg=%s\", line_num - adjust_line, kind, msg);\n "}, {"sha": "2888d4223b714ab3816c963e74c50f2596ab74fc", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -13,9 +13,9 @@ use core::prelude::*;\n use common::config;\n use common;\n \n+use core::iterator::IteratorUtil;\n use core::io;\n use core::os;\n-use core::str;\n \n pub struct TestProps {\n     // Lines that should be expected, in order, on standard out\n@@ -111,7 +111,7 @@ fn iter_header(testfile: &Path, it: &fn(~str) -> bool) -> bool {\n         // Assume that any directives will be found before the first\n         // module or function. This doesn't seem to be an optimization\n         // with a warm page cache. Maybe with a cold one.\n-        if str::starts_with(ln, \"fn\") || str::starts_with(ln, \"mod\") {\n+        if ln.starts_with(\"fn\") || ln.starts_with(\"mod\") {\n             return false;\n         } else { if !(it(ln)) { return false; } }\n     }\n@@ -141,8 +141,8 @@ fn parse_check_line(line: &str) -> Option<~str> {\n fn parse_exec_env(line: &str) -> Option<(~str, ~str)> {\n     do parse_name_value_directive(line, ~\"exec-env\").map |nv| {\n         // nv is either FOO or FOO=BAR\n-        let mut strs = ~[];\n-        for str::each_splitn_char(*nv, '=', 1u) |s| { strs.push(s.to_owned()); }\n+        let mut strs: ~[~str] = nv.splitn_iter('=', 1).transform(|s| s.to_owned()).collect();\n+\n         match strs.len() {\n           1u => (strs.pop(), ~\"\"),\n           2u => {\n@@ -168,16 +168,16 @@ fn parse_pp_exact(line: &str, testfile: &Path) -> Option<Path> {\n }\n \n fn parse_name_directive(line: &str, directive: &str) -> bool {\n-    str::contains(line, directive)\n+    line.contains(directive)\n }\n \n fn parse_name_value_directive(line: &str,\n                               directive: ~str) -> Option<~str> {\n     let keycolon = directive + \":\";\n-    match str::find_str(line, keycolon) {\n+    match line.find_str(keycolon) {\n         Some(colon) => {\n-            let value = str::slice(line, colon + str::len(keycolon),\n-                                   str::len(line)).to_owned();\n+            let value = line.slice(colon + keycolon.len(),\n+                                   line.len()).to_owned();\n             debug!(\"%s: %s\", directive,  value);\n             Some(value)\n         }"}, {"sha": "87188100f4c52c39d57ab24708fcdb7d268cbffa", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -28,7 +28,7 @@ fn target_env(lib_path: &str, prog: &str) -> ~[(~str,~str)] {\n         if k == ~\"PATH\" { (~\"PATH\", v + \";\" + lib_path + \";\" + aux_path) }\n         else { (k,v) }\n     };\n-    if str::ends_with(prog, \"rustc.exe\") {\n+    if prog.ends_with(\"rustc.exe\") {\n         env.push((~\"RUST_THREADS\", ~\"1\"));\n     }\n     return env;"}, {"sha": "7159e51e3b6f329d7dcd2e0e79634bee0a0c617e", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -244,7 +244,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n         None => copy *config\n     };\n     let config = &mut config;\n-    let cmds = str::connect(props.debugger_cmds, \"\\n\");\n+    let cmds = props.debugger_cmds.connect(\"\\n\");\n     let check_lines = copy props.check_lines;\n \n     // compile test file (it shoud have 'compile-flags:-g' in the header)\n@@ -278,7 +278,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n         // check if each line in props.check_lines appears in the\n         // output (in order)\n         let mut i = 0u;\n-        for str::each_line(ProcRes.stdout) |line| {\n+        for ProcRes.stdout.line_iter().advance |line| {\n             if check_lines[i].trim() == line.trim() {\n                 i += 1u;\n             }\n@@ -308,8 +308,8 @@ fn check_error_patterns(props: &TestProps,\n     let mut next_err_idx = 0u;\n     let mut next_err_pat = &props.error_patterns[next_err_idx];\n     let mut done = false;\n-    for str::each_line(ProcRes.stderr) |line| {\n-        if str::contains(line, *next_err_pat) {\n+    for ProcRes.stderr.line_iter().advance |line| {\n+        if line.contains(*next_err_pat) {\n             debug!(\"found error pattern %s\", *next_err_pat);\n             next_err_idx += 1u;\n             if next_err_idx == props.error_patterns.len() {\n@@ -358,15 +358,15 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n     //    filename:line1:col1: line2:col2: *warning:* msg\n     // where line1:col1: is the starting point, line2:col2:\n     // is the ending point, and * represents ANSI color codes.\n-    for str::each_line(ProcRes.stderr) |line| {\n+    for ProcRes.stderr.line_iter().advance |line| {\n         let mut was_expected = false;\n         for vec::eachi(expected_errors) |i, ee| {\n             if !found_flags[i] {\n                 debug!(\"prefix=%s ee.kind=%s ee.msg=%s line=%s\",\n                        prefixes[i], ee.kind, ee.msg, line);\n-                if (str::starts_with(line, prefixes[i]) &&\n-                    str::contains(line, ee.kind) &&\n-                    str::contains(line, ee.msg)) {\n+                if (line.starts_with(prefixes[i]) &&\n+                    line.contains(ee.kind) &&\n+                    line.contains(ee.msg)) {\n                     found_flags[i] = true;\n                     was_expected = true;\n                     break;\n@@ -375,7 +375,7 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n         }\n \n         // ignore this msg which gets printed at the end\n-        if str::contains(line, \"aborting due to\") {\n+        if line.contains(\"aborting due to\") {\n             was_expected = true;\n         }\n \n@@ -417,7 +417,7 @@ fn scan_until_char(haystack: &str, needle: char, idx: &mut uint) -> bool {\n     if *idx >= haystack.len() {\n         return false;\n     }\n-    let opt = str::find_char_from(haystack, needle, *idx);\n+    let opt = haystack.slice_from(*idx).find(needle);\n     if opt.is_none() {\n         return false;\n     }\n@@ -429,7 +429,7 @@ fn scan_char(haystack: &str, needle: char, idx: &mut uint) -> bool {\n     if *idx >= haystack.len() {\n         return false;\n     }\n-    let range = str::char_range_at(haystack, *idx);\n+    let range = haystack.char_range_at(*idx);\n     if range.ch != needle {\n         return false;\n     }\n@@ -440,7 +440,7 @@ fn scan_char(haystack: &str, needle: char, idx: &mut uint) -> bool {\n fn scan_integer(haystack: &str, idx: &mut uint) -> bool {\n     let mut i = *idx;\n     while i < haystack.len() {\n-        let range = str::char_range_at(haystack, i);\n+        let range = haystack.char_range_at(i);\n         if range.ch < '0' || '9' < range.ch {\n             break;\n         }\n@@ -460,7 +460,7 @@ fn scan_string(haystack: &str, needle: &str, idx: &mut uint) -> bool {\n         if haystack_i >= haystack.len() {\n             return false;\n         }\n-        let range = str::char_range_at(haystack, haystack_i);\n+        let range = haystack.char_range_at(haystack_i);\n         haystack_i = range.next;\n         if !scan_char(needle, range.ch, &mut needle_i) {\n             return false;\n@@ -612,15 +612,11 @@ fn make_run_args(config: &config, _props: &TestProps, testfile: &Path) ->\n }\n \n fn split_maybe_args(argstr: &Option<~str>) -> ~[~str] {\n-    fn rm_whitespace(v: ~[~str]) -> ~[~str] {\n-        v.filtered(|s| !str::is_whitespace(*s))\n-    }\n-\n     match *argstr {\n         Some(ref s) => {\n-            let mut ss = ~[];\n-            for str::each_split_char(*s, ' ') |s| { ss.push(s.to_owned()) }\n-            rm_whitespace(ss)\n+            s.split_iter(' ')\n+                .filter_map(|s| if s.is_whitespace() {None} else {Some(s.to_owned())})\n+                .collect()\n         }\n         None => ~[]\n     }\n@@ -649,13 +645,13 @@ fn program_output(config: &config, testfile: &Path, lib_path: &str, prog: ~str,\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n fn make_cmdline(_libpath: &str, prog: &str, args: &[~str]) -> ~str {\n-    fmt!(\"%s %s\", prog, str::connect(args, \" \"))\n+    fmt!(\"%s %s\", prog, args.connect(\" \"))\n }\n \n #[cfg(target_os = \"win32\")]\n fn make_cmdline(libpath: &str, prog: &str, args: &[~str]) -> ~str {\n     fmt!(\"%s %s %s\", lib_path_cmd_prefix(libpath), prog,\n-         str::connect(args, \" \"))\n+         args.connect(\" \"))\n }\n \n // Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n@@ -739,8 +735,7 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n     let cmdline = make_cmdline(\"\", args.prog, args.args);\n \n     // get bare program string\n-    let mut tvec = ~[];\n-    for str::each_split_char(args.prog, '/') |ts| { tvec.push(ts.to_owned()) }\n+    let mut tvec: ~[~str] = args.prog.split_iter('/').transform(|ts| ts.to_owned()).collect();\n     let prog_short = tvec.pop();\n \n     // copy to target"}, {"sha": "1b6b656e398a46997c300b18fccacaf19ac4cbdc", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -46,7 +46,6 @@ use sync::{Mutex, mutex_with_condvars, RWlock, rwlock_with_condvars};\n \n use core::cast;\n use core::unstable::sync::UnsafeAtomicRcBox;\n-use core::ptr;\n use core::task;\n use core::borrow;\n "}, {"sha": "62d4a32b8e239b3de576d2653b3f6b272147a2f6", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -49,7 +49,7 @@ impl<'self> ToBase64 for &'self [u8] {\n     fn to_base64(&self) -> ~str {\n         let mut s = ~\"\";\n         let len = self.len();\n-        str::reserve(&mut s, ((len + 3u) / 4u) * 3u);\n+        s.reserve(((len + 3u) / 4u) * 3u);\n \n         let mut i = 0u;\n \n@@ -59,10 +59,10 @@ impl<'self> ToBase64 for &'self [u8] {\n                     (self[i + 2u] as uint);\n \n             // This 24-bit number gets separated into four 6-bit numbers.\n-            str::push_char(&mut s, CHARS[(n >> 18u) & 63u]);\n-            str::push_char(&mut s, CHARS[(n >> 12u) & 63u]);\n-            str::push_char(&mut s, CHARS[(n >> 6u) & 63u]);\n-            str::push_char(&mut s, CHARS[n & 63u]);\n+            s.push_char(CHARS[(n >> 18u) & 63u]);\n+            s.push_char(CHARS[(n >> 12u) & 63u]);\n+            s.push_char(CHARS[(n >> 6u) & 63u]);\n+            s.push_char(CHARS[n & 63u]);\n \n             i += 3u;\n         }\n@@ -73,18 +73,18 @@ impl<'self> ToBase64 for &'self [u8] {\n           0 => (),\n           1 => {\n             let n = (self[i] as uint) << 16u;\n-            str::push_char(&mut s, CHARS[(n >> 18u) & 63u]);\n-            str::push_char(&mut s, CHARS[(n >> 12u) & 63u]);\n-            str::push_char(&mut s, '=');\n-            str::push_char(&mut s, '=');\n+            s.push_char(CHARS[(n >> 18u) & 63u]);\n+            s.push_char(CHARS[(n >> 12u) & 63u]);\n+            s.push_char('=');\n+            s.push_char('=');\n           }\n           2 => {\n             let n = (self[i] as uint) << 16u |\n                 (self[i + 1u] as uint) << 8u;\n-            str::push_char(&mut s, CHARS[(n >> 18u) & 63u]);\n-            str::push_char(&mut s, CHARS[(n >> 12u) & 63u]);\n-            str::push_char(&mut s, CHARS[(n >> 6u) & 63u]);\n-            str::push_char(&mut s, '=');\n+            s.push_char(CHARS[(n >> 18u) & 63u]);\n+            s.push_char(CHARS[(n >> 12u) & 63u]);\n+            s.push_char(CHARS[(n >> 6u) & 63u]);\n+            s.push_char('=');\n           }\n           _ => fail!(\"Algebra is broken, please alert the math police\")\n         }"}, {"sha": "add857ca9ed07fd0793eaa2410f7608003e7d093", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -416,7 +416,6 @@ mod test {\n \n     use core::iterator::IteratorUtil;\n     use core::io;\n-    use core::str;\n     use core::uint;\n     use core::vec;\n \n@@ -527,9 +526,7 @@ mod test {\n         }\n \n         for input_vec_state(filenames) |line, state| {\n-            let nums = do vec::build |p| {\n-                for str::each_split_char(line, ' ') |s| { p(s.to_owned()); }\n-            };\n+            let nums: ~[&str] = line.split_iter(' ').collect();\n             let file_num = uint::from_str(nums[0]).get();\n             let line_num = uint::from_str(nums[1]).get();\n             assert_eq!(line_num, state.line_num_file);"}, {"sha": "44b56590083550ead5e0db4c7926d2dc1ecbd444", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -82,6 +82,7 @@\n \n use core::prelude::*;\n \n+use core::iterator::IteratorUtil;\n use core::cmp::Eq;\n use core::result::{Err, Ok};\n use core::result;\n@@ -111,7 +112,7 @@ pub struct Opt {\n \n fn mkname(nm: &str) -> Name {\n   if nm.len() == 1u {\n-      Short(str::char_at(nm, 0u))\n+      Short(nm.char_at(0u))\n   } else {\n       Long(nm.to_owned())\n   }\n@@ -246,22 +247,21 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n             let mut names;\n             let mut i_arg = None;\n             if cur[1] == '-' as u8 {\n-                let tail = str::slice(cur, 2, curlen);\n-                let mut tail_eq = ~[];\n-                for str::each_splitn_char(tail, '=', 1) |s| { tail_eq.push(s.to_owned()) }\n+                let tail = cur.slice(2, curlen);\n+                let tail_eq: ~[&str] = tail.split_iter('=').collect();\n                 if tail_eq.len() <= 1 {\n                     names = ~[Long(tail.to_owned())];\n                 } else {\n                     names =\n-                        ~[Long(copy tail_eq[0])];\n-                    i_arg = Some(copy tail_eq[1]);\n+                        ~[Long(tail_eq[0].to_owned())];\n+                    i_arg = Some(tail_eq[1].to_owned());\n                 }\n             } else {\n                 let mut j = 1;\n                 let mut last_valid_opt_id = None;\n                 names = ~[];\n                 while j < curlen {\n-                    let range = str::char_range_at(cur, j);\n+                    let range = cur.char_range_at(j);\n                     let opt = Short(range.ch);\n \n                     /* In a series of potential options (eg. -aheJ), if we\n@@ -565,11 +565,11 @@ pub mod groups {\n                            hasarg: hasarg,\n                            occur: occur}],\n \n-           (1,0) => ~[Opt {name: Short(str::char_at(short_name, 0)),\n+           (1,0) => ~[Opt {name: Short(short_name.char_at(0)),\n                            hasarg: hasarg,\n                            occur: occur}],\n \n-           (1,_) => ~[Opt {name: Short(str::char_at(short_name, 0)),\n+           (1,_) => ~[Opt {name: Short(short_name.char_at(0)),\n                            hasarg: hasarg,\n                            occur:  occur},\n                       Opt {name:   Long((long_name)),\n@@ -635,7 +635,7 @@ pub mod groups {\n \n             // Normalize desc to contain words separated by one space character\n             let mut desc_normalized_whitespace = ~\"\";\n-            for str::each_word(desc) |word| {\n+            for desc.word_iter().advance |word| {\n                 desc_normalized_whitespace.push_str(word);\n                 desc_normalized_whitespace.push_char(' ');\n             }\n@@ -648,14 +648,14 @@ pub mod groups {\n \n             // FIXME: #5516\n             // wrapped description\n-            row += str::connect(desc_rows, desc_sep);\n+            row += desc_rows.connect(desc_sep);\n \n             row\n         });\n \n         return str::to_owned(brief) +\n                \"\\n\\nOptions:\\n\" +\n-               str::connect(rows, \"\\n\") +\n+               rows.connect(\"\\n\") +\n                \"\\n\\n\";\n     }\n } // end groups module"}, {"sha": "1e9ec48aff32d5f61686b328c90465fb3de5a1f0", "filename": "src/libextra/json.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -79,7 +79,7 @@ fn escape_str(s: &str) -> ~str {\n \n fn spaces(n: uint) -> ~str {\n     let mut ss = ~\"\";\n-    for n.times { str::push_str(&mut ss, \" \"); }\n+    for n.times { ss.push_str(\" \"); }\n     return ss;\n }\n \n@@ -567,7 +567,7 @@ impl Parser {\n     }\n \n     fn parse_ident(&mut self, ident: &str, value: Json) -> Result<Json, Error> {\n-        if str::all(ident, |c| c == self.next_char()) {\n+        if ident.iter().all(|c| c == self.next_char()) {\n             self.bump();\n             Ok(value)\n         } else {\n@@ -712,14 +712,14 @@ impl Parser {\n \n             if (escape) {\n                 match self.ch {\n-                  '\"' => str::push_char(&mut res, '\"'),\n-                  '\\\\' => str::push_char(&mut res, '\\\\'),\n-                  '/' => str::push_char(&mut res, '/'),\n-                  'b' => str::push_char(&mut res, '\\x08'),\n-                  'f' => str::push_char(&mut res, '\\x0c'),\n-                  'n' => str::push_char(&mut res, '\\n'),\n-                  'r' => str::push_char(&mut res, '\\r'),\n-                  't' => str::push_char(&mut res, '\\t'),\n+                  '\"' => res.push_char('\"'),\n+                  '\\\\' => res.push_char('\\\\'),\n+                  '/' => res.push_char('/'),\n+                  'b' => res.push_char('\\x08'),\n+                  'f' => res.push_char('\\x0c'),\n+                  'n' => res.push_char('\\n'),\n+                  'r' => res.push_char('\\r'),\n+                  't' => res.push_char('\\t'),\n                   'u' => {\n                       // Parse \\u1234.\n                       let mut i = 0u;\n@@ -748,7 +748,7 @@ impl Parser {\n                             ~\"invalid \\\\u escape (not four digits)\");\n                       }\n \n-                      str::push_char(&mut res, n as char);\n+                      res.push_char(n as char);\n                   }\n                   _ => return self.error(~\"invalid escape\")\n                 }\n@@ -760,7 +760,7 @@ impl Parser {\n                     self.bump();\n                     return Ok(res);\n                 }\n-                str::push_char(&mut res, self.ch);\n+                res.push_char(self.ch);\n             }\n         }\n "}, {"sha": "760fc7485e069684dcf11d824a9d950ccd9f0511", "filename": "src/libextra/net_ip.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_ip.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -14,6 +14,7 @@\n \n use core::prelude::*;\n \n+use core::iterator::IteratorUtil;\n use core::libc;\n use core::comm::{stream, SharedChan};\n use core::ptr;\n@@ -158,9 +159,7 @@ pub mod v4 {\n \n     use core::cast::transmute;\n     use core::result;\n-    use core::str;\n     use core::uint;\n-    use core::vec;\n \n     /**\n      * Convert a str to `ip_addr`\n@@ -199,14 +198,12 @@ pub mod v4 {\n         }\n     }\n     pub fn parse_to_ipv4_rep(ip: &str) -> result::Result<Ipv4Rep, ~str> {\n-        let mut parts = ~[];\n-        for str::each_split_char(ip, '.') |s| { parts.push(s.to_owned()) }\n-        let parts = vec::map(parts, |s| {\n-            match uint::from_str(*s) {\n-              Some(n) if n <= 255 => n,\n-              _ => 256\n+        let parts: ~[uint] = ip.split_iter('.').transform(|s| {\n+            match uint::from_str(s) {\n+                Some(n) if n <= 255 => n,\n+                _ => 256\n             }\n-        });\n+        }).collect();\n         if parts.len() != 4 {\n             Err(fmt!(\"'%s' doesn't have 4 parts\", ip))\n         } else if parts.contains(&256) {"}, {"sha": "3ea085f5e86f10fce87023f4fc6fbb8c653decde", "filename": "src/libextra/net_tcp.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_tcp.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -1597,8 +1597,8 @@ mod test {\n                        expected_req, actual_req);\n         debug!(\"RESP: expected: '%s' actual: '%s'\",\n                        expected_resp, actual_resp);\n-        assert!(str::contains(actual_req, expected_req));\n-        assert!(str::contains(actual_resp, expected_resp));\n+        assert!(actual_req.contains(expected_req));\n+        assert!(actual_resp.contains(expected_resp));\n     }\n     pub fn impl_gl_tcp_ipv4_get_peer_addr() {\n         let hl_loop = &uv::global_loop::get();\n@@ -1765,8 +1765,8 @@ mod test {\n                        expected_req, actual_req);\n         debug!(\"RESP: expected: '%s' actual: '%s'\",\n                        expected_resp, actual_resp);\n-        assert!(str::contains(actual_req, expected_req));\n-        assert!(str::contains(actual_resp, expected_resp));\n+        assert!(actual_req.contains(expected_req));\n+        assert!(actual_resp.contains(expected_resp));\n     }\n \n     pub fn impl_tcp_socket_impl_reader_handles_eof() {\n@@ -1809,7 +1809,7 @@ mod test {\n     }\n \n     fn buf_write<W:io::Writer>(w: &W, val: &str) {\n-        debug!(\"BUF_WRITE: val len %?\", str::len(val));\n+        debug!(\"BUF_WRITE: val len %?\", val.len());\n         do str::byte_slice(val) |b_slice| {\n             debug!(\"BUF_WRITE: b_slice len %?\",\n                             b_slice.len());"}, {"sha": "83cda31c68089d84d499f0ad05a68102de29707a", "filename": "src/libextra/net_url.rs", "status": "modified", "additions": 44, "deletions": 45, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_url.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -19,7 +19,6 @@ use core::cmp::Eq;\n use core::io::{Reader, ReaderUtil};\n use core::io;\n use core::hashmap::HashMap;\n-use core::str;\n use core::to_bytes;\n use core::uint;\n \n@@ -81,7 +80,7 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n               'a' .. 'z' |\n               '0' .. '9' |\n               '-' | '.' | '_' | '~' => {\n-                str::push_char(&mut out, ch);\n+                out.push_char(ch);\n               }\n               _ => {\n                   if full_url {\n@@ -92,7 +91,7 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n                       // sub-delims:\n                       '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n                       '+' | ',' | ';' | '=' => {\n-                        str::push_char(&mut out, ch);\n+                        out.push_char(ch);\n                       }\n \n                       _ => out += fmt!(\"%%%X\", ch as uint)\n@@ -148,18 +147,18 @@ fn decode_inner(s: &str, full_url: bool) -> ~str {\n                       // sub-delims:\n                       '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n                       '+' | ',' | ';' | '=' => {\n-                        str::push_char(&mut out, '%');\n-                        str::push_char(&mut out, bytes[0u] as char);\n-                        str::push_char(&mut out, bytes[1u] as char);\n+                        out.push_char('%');\n+                        out.push_char(bytes[0u] as char);\n+                        out.push_char(bytes[1u] as char);\n                       }\n \n-                      ch => str::push_char(&mut out, ch)\n+                      ch => out.push_char(ch)\n                     }\n                 } else {\n-                      str::push_char(&mut out, ch);\n+                      out.push_char(ch);\n                 }\n               }\n-              ch => str::push_char(&mut out, ch)\n+              ch => out.push_char(ch)\n             }\n         }\n \n@@ -191,9 +190,9 @@ fn encode_plus(s: &str) -> ~str {\n             let ch = rdr.read_byte() as char;\n             match ch {\n               'A' .. 'Z' | 'a' .. 'z' | '0' .. '9' | '_' | '.' | '-' => {\n-                str::push_char(&mut out, ch);\n+                out.push_char(ch);\n               }\n-              ' ' => str::push_char(&mut out, '+'),\n+              ' ' => out.push_char('+'),\n               _ => out += fmt!(\"%%%X\", ch as uint)\n             }\n         }\n@@ -216,7 +215,7 @@ pub fn encode_form_urlencoded(m: &HashMap<~str, ~[~str]>) -> ~str {\n             if first {\n                 first = false;\n             } else {\n-                str::push_char(&mut out, '&');\n+                out.push_char('&');\n                 first = false;\n             }\n \n@@ -267,9 +266,9 @@ pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<~str, ~[~str]> {\n                     };\n \n                     if parsing_key {\n-                        str::push_char(&mut key, ch)\n+                        key.push_char(ch)\n                     } else {\n-                        str::push_char(&mut value, ch)\n+                        value.push_char(ch)\n                     }\n                 }\n             }\n@@ -291,7 +290,7 @@ pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<~str, ~[~str]> {\n \n \n fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n-    let len = str::len(s);\n+    let len = s.len();\n     let mut index = len;\n     let mut mat = 0;\n     do io::with_str_reader(s) |rdr| {\n@@ -307,16 +306,16 @@ fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n         }\n     }\n     if index+mat == len {\n-        return (str::slice(s, 0, index).to_owned(), ~\"\");\n+        return (s.slice(0, index).to_owned(), ~\"\");\n     } else {\n-        return (str::slice(s, 0, index).to_owned(),\n-             str::slice(s, index + mat, str::len(s)).to_owned());\n+        return (s.slice(0, index).to_owned(),\n+             s.slice(index + mat, s.len()).to_owned());\n     }\n }\n \n fn userinfo_from_str(uinfo: &str) -> UserInfo {\n     let (user, p) = split_char_first(uinfo, ':');\n-    let pass = if str::len(p) == 0 {\n+    let pass = if p.is_empty() {\n         None\n     } else {\n         Some(p)\n@@ -333,8 +332,8 @@ fn userinfo_to_str(userinfo: &UserInfo) -> ~str {\n \n fn query_from_str(rawquery: &str) -> Query {\n     let mut query: Query = ~[];\n-    if str::len(rawquery) != 0 {\n-        for str::each_split_char(rawquery, '&') |p| {\n+    if !rawquery.is_empty() {\n+        for rawquery.split_iter('&').advance |p| {\n             let (k, v) = split_char_first(p, '=');\n             query.push((decode_component(k), decode_component(v)));\n         };\n@@ -354,7 +353,7 @@ pub fn query_to_str(query: &Query) -> ~str {\n             }\n         }\n     }\n-    return str::connect(strvec, \"&\");\n+    return strvec.connect(\"&\");\n }\n \n // returns the scheme and the rest of the url, or a parsing error\n@@ -373,7 +372,7 @@ pub fn get_scheme(rawurl: &str) -> Result<(~str, ~str), ~str> {\n                 return Err(~\"url: Scheme cannot be empty.\");\n             } else {\n                 return Ok((rawurl.slice(0,i).to_owned(),\n-                                rawurl.slice(i+1,str::len(rawurl)).to_owned()));\n+                                rawurl.slice(i+1,rawurl.len()).to_owned()));\n             }\n           }\n           _ => {\n@@ -394,7 +393,7 @@ enum Input {\n // returns userinfo, host, port, and unparsed part, or an error\n fn get_authority(rawurl: &str) ->\n     Result<(Option<UserInfo>, ~str, Option<~str>, ~str), ~str> {\n-    if !str::starts_with(rawurl, \"//\") {\n+    if !rawurl.starts_with(\"//\") {\n         // there is no authority.\n         return Ok((None, ~\"\", None, rawurl.to_str()));\n     }\n@@ -475,7 +474,7 @@ fn get_authority(rawurl: &str) ->\n               }\n               Ip6Host => {\n                 if colon_count > 7 {\n-                    host = str::slice(rawurl, begin, i).to_owned();\n+                    host = rawurl.slice(begin, i).to_owned();\n                     pos = i;\n                     st = InPort;\n                 }\n@@ -492,13 +491,13 @@ fn get_authority(rawurl: &str) ->\n             colon_count = 0; // reset count\n             match st {\n               Start => {\n-                let user = str::slice(rawurl, begin, i).to_owned();\n+                let user = rawurl.slice(begin, i).to_owned();\n                 userinfo = Some(UserInfo::new(user, None));\n                 st = InHost;\n               }\n               PassHostPort => {\n-                let user = str::slice(rawurl, begin, pos).to_owned();\n-                let pass = str::slice(rawurl, pos+1, i).to_owned();\n+                let user = rawurl.slice(begin, pos).to_owned();\n+                let pass = rawurl.slice(pos+1, i).to_owned();\n                 userinfo = Some(UserInfo::new(user, Some(pass)));\n                 st = InHost;\n               }\n@@ -529,39 +528,39 @@ fn get_authority(rawurl: &str) ->\n     match st {\n       Start => {\n         if host_is_end_plus_one() {\n-            host = str::slice(rawurl, begin, end+1).to_owned();\n+            host = rawurl.slice(begin, end+1).to_owned();\n         } else {\n-            host = str::slice(rawurl, begin, end).to_owned();\n+            host = rawurl.slice(begin, end).to_owned();\n         }\n       }\n       PassHostPort | Ip6Port => {\n         if in != Digit {\n             return Err(~\"Non-digit characters in port.\");\n         }\n-        host = str::slice(rawurl, begin, pos).to_owned();\n-        port = Some(str::slice(rawurl, pos+1, end).to_owned());\n+        host = rawurl.slice(begin, pos).to_owned();\n+        port = Some(rawurl.slice(pos+1, end).to_owned());\n       }\n       Ip6Host | InHost => {\n-        host = str::slice(rawurl, begin, end).to_owned();\n+        host = rawurl.slice(begin, end).to_owned();\n       }\n       InPort => {\n         if in != Digit {\n             return Err(~\"Non-digit characters in port.\");\n         }\n-        port = Some(str::slice(rawurl, pos+1, end).to_owned());\n+        port = Some(rawurl.slice(pos+1, end).to_owned());\n       }\n     }\n \n     let rest = if host_is_end_plus_one() { ~\"\" }\n-    else { str::slice(rawurl, end, len).to_owned() };\n+    else { rawurl.slice(end, len).to_owned() };\n     return Ok((userinfo, host, port, rest));\n }\n \n \n // returns the path and unparsed part of url, or an error\n fn get_path(rawurl: &str, authority: bool) ->\n     Result<(~str, ~str), ~str> {\n-    let len = str::len(rawurl);\n+    let len = rawurl.len();\n     let mut end = len;\n     for rawurl.iter().enumerate().advance |(i,c)| {\n         match c {\n@@ -579,31 +578,31 @@ fn get_path(rawurl: &str, authority: bool) ->\n     }\n \n     if authority {\n-        if end != 0 && !str::starts_with(rawurl, \"/\") {\n+        if end != 0 && !rawurl.starts_with(\"/\") {\n             return Err(~\"Non-empty path must begin with\\\n                                '/' in presence of authority.\");\n         }\n     }\n \n-    return Ok((decode_component(str::slice(rawurl, 0, end)),\n-                    str::slice(rawurl, end, len).to_owned()));\n+    return Ok((decode_component(rawurl.slice(0, end)),\n+                    rawurl.slice(end, len).to_owned()));\n }\n \n // returns the parsed query and the fragment, if present\n fn get_query_fragment(rawurl: &str) ->\n     Result<(Query, Option<~str>), ~str> {\n-    if !str::starts_with(rawurl, \"?\") {\n-        if str::starts_with(rawurl, \"#\") {\n-            let f = decode_component(str::slice(rawurl,\n+    if !rawurl.starts_with(\"?\") {\n+        if rawurl.starts_with(\"#\") {\n+            let f = decode_component(rawurl.slice(\n                                                 1,\n-                                                str::len(rawurl)));\n+                                                rawurl.len()));\n             return Ok((~[], Some(f)));\n         } else {\n             return Ok((~[], None));\n         }\n     }\n-    let (q, r) = split_char_first(str::slice(rawurl, 1, rawurl.len()), '#');\n-    let f = if str::len(r) != 0 {\n+    let (q, r) = split_char_first(rawurl.slice(1, rawurl.len()), '#');\n+    let f = if r.len() != 0 {\n         Some(decode_component(r)) } else { None };\n     return Ok((query_from_str(q), f));\n }"}, {"sha": "c6e7592a314e13c707bccd027573381032628203", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -520,11 +520,11 @@ impl ToStrRadix for BigUint {\n \n         fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str {\n             if v.is_empty() { return ~\"0\" }\n-            let s = str::concat(vec::reversed(v).map(|n| {\n+            let s = vec::reversed(v).map(|n| {\n                 let s = uint::to_str_radix(*n as uint, radix);\n                 str::from_chars(vec::from_elem(l - s.len(), '0')) + s\n-            }));\n-            str::trim_left_chars(s, ['0']).to_owned()\n+            }).concat();\n+            s.trim_left_chars(['0']).to_owned()\n         }\n     }\n }"}, {"sha": "08fbb8aacc9306d2161dfb2b02a117ea0d45dc99", "filename": "src/libextra/num/rational.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Frational.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -12,11 +12,10 @@\n \n use core::prelude::*;\n \n+use core::iterator::IteratorUtil;\n use core::cmp;\n use core::from_str::FromStr;\n use core::num::{Zero,One,ToStrRadix,FromStrRadix,Round};\n-use core::str;\n-use core::vec;\n use super::bigint::BigInt;\n \n /// Represents the ratio between 2 numbers.\n@@ -252,11 +251,7 @@ impl<T: FromStr + Clone + Integer + Ord>\n     FromStr for Ratio<T> {\n     /// Parses `numer/denom`.\n     fn from_str(s: &str) -> Option<Ratio<T>> {\n-        let split = vec::build(|push| {\n-            for str::each_splitn_char(s, '/', 1) |s| {\n-                push(s.to_owned());\n-            }\n-        });\n+        let split: ~[&str] = s.splitn_iter('/', 1).collect();\n         if split.len() < 2 { return None; }\n         do FromStr::from_str::<T>(split[0]).chain |a| {\n             do FromStr::from_str::<T>(split[1]).chain |b| {\n@@ -269,11 +264,7 @@ impl<T: FromStrRadix + Clone + Integer + Ord>\n     FromStrRadix for Ratio<T> {\n     /// Parses `numer/denom` where the numbers are in base `radix`.\n     fn from_str_radix(s: &str, radix: uint) -> Option<Ratio<T>> {\n-        let split = vec::build(|push| {\n-            for str::each_splitn_char(s, '/', 1) |s| {\n-                push(s.to_owned());\n-            }\n-        });\n+        let split: ~[&str] = s.splitn_iter('/', 1).collect();\n         if split.len() < 2 { None }\n         else {\n             do FromStrRadix::from_str_radix::<T>(split[0], radix).chain |a| {"}, {"sha": "de54964142349c70b7097118440fb4bdc1127970", "filename": "src/libextra/rope.rs", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frope.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -37,9 +37,10 @@\n \n use core::prelude::*;\n \n-use core::str;\n+use core::iterator::IteratorUtil;\n use core::uint;\n use core::vec;\n+use core::str;\n \n /// The type of ropes.\n pub type Rope = node::Root;\n@@ -71,7 +72,7 @@ pub fn empty() -> Rope {\n  * * the function runs in linear time.\n  */\n pub fn of_str(str: @~str) -> Rope {\n-    return of_substr(str, 0u, str::len(*str));\n+    return of_substr(str, 0u, str.len());\n }\n \n /**\n@@ -83,9 +84,9 @@ pub fn of_str(str: @~str) -> Rope {\n  *\n  * # Return value\n  *\n- * A rope representing the same string as `str::substr(str, byte_offset,\n- * byte_len)`.  Depending on `byte_len`, this rope may be empty, flat or\n- * complex.\n+ * A rope representing the same string as `str.substr(byte_offset,\n+ * byte_len)`.  Depending on `byte_len`, this rope may be empty, flat\n+ * or complex.\n  *\n  * # Performance note\n  *\n@@ -98,7 +99,7 @@ pub fn of_str(str: @~str) -> Rope {\n  */\n pub fn of_substr(str: @~str, byte_offset: uint, byte_len: uint) -> Rope {\n     if byte_len == 0u { return node::Empty; }\n-    if byte_offset + byte_len  > str::len(*str) { fail!(); }\n+    if byte_offset + byte_len  > str.len() { fail!(); }\n     return node::Content(node::of_substr(str, byte_offset, byte_len));\n }\n \n@@ -657,7 +658,7 @@ pub mod node {\n      * the length of `str`.\n      */\n     pub fn of_str(str: @~str) -> @Node {\n-        return of_substr(str, 0u, str::len(*str));\n+        return of_substr(str, 0u, str.len());\n     }\n \n     /**\n@@ -705,7 +706,7 @@ pub mod node {\n      */\n     pub fn of_substr_unsafer(str: @~str, byte_start: uint, byte_len: uint,\n                              char_len: uint) -> @Node {\n-        assert!((byte_start + byte_len <= str::len(*str)));\n+        assert!((byte_start + byte_len <= str.len()));\n         let candidate = @Leaf(Leaf {\n             byte_offset: byte_start,\n             byte_len: byte_len,\n@@ -1079,9 +1080,7 @@ pub mod node {\n \n     pub fn loop_chars(node: @Node, it: &fn(c: char) -> bool) -> bool {\n         return loop_leaves(node,|leaf| {\n-            str::all_between(*leaf.content,\n-                             leaf.byte_offset,\n-                             leaf.byte_len, it)\n+            leaf.content.slice(leaf.byte_offset, leaf.byte_len).iter().all(it)\n         });\n     }\n \n@@ -1133,7 +1132,7 @@ pub mod node {\n     pub fn char_at(mut node: @Node, mut pos: uint) -> char {\n         loop {\n             match *node {\n-              Leaf(x) => return str::char_at(*x.content, pos),\n+              Leaf(x) => return x.content.char_at(pos),\n               Concat(Concat {left, right, _}) => {\n                 let left_len = char_len(left);\n                 node = if left_len > pos { left }\n@@ -1189,8 +1188,6 @@ pub mod node {\n     pub mod char_iterator {\n         use core::prelude::*;\n \n-        use core::str;\n-\n         use rope::node::{Leaf, Node};\n         use rope::node::leaf_iterator;\n \n@@ -1258,8 +1255,7 @@ pub mod node {\n                     return None\n                 } else {\n                     let range =\n-                        str::char_range_at(*aleaf.content,\n-                                     (*it).leaf_byte_pos + aleaf.byte_offset);\n+                        aleaf.content.char_range_at((*it).leaf_byte_pos + aleaf.byte_offset);\n                     let ch = range.ch;\n                     let next = range.next;\n                     (*it).leaf_byte_pos = next - aleaf.byte_offset;\n@@ -1290,11 +1286,7 @@ mod tests {\n             fn aux(str: &mut ~str, node: @node::Node) {\n                 match (*node) {\n                     node::Leaf(x) => {\n-                        str::push_str(\n-                            str,\n-                            str::slice(\n-                                *x.content, x.byte_offset,\n-                                x.byte_offset + x.byte_len));\n+                        str.push_str(x.content.slice(x.byte_offset, x.byte_offset + x.byte_len));\n                     }\n                     node::Concat(ref x) => {\n                         aux(str, x.left);\n@@ -1340,7 +1332,7 @@ mod tests {\n         assert!(rope_to_string(r) == *sample);\n \n         let mut string_iter = 0u;\n-        let string_len = str::len(*sample);\n+        let string_len = sample.len();\n         let mut rope_iter = iterator::char::start(r);\n         let mut equal = true;\n         while equal {\n@@ -1350,7 +1342,7 @@ mod tests {\n                     equal = false;\n                 } break; }\n               Some(c) => {\n-                let range = str::char_range_at(*sample, string_iter);\n+                let range = sample.char_range_at(string_iter);\n                 string_iter = range.next;\n                 if range.ch != c { equal = false; break; }\n               }"}, {"sha": "3ab8bb1f60bc2b3fba7c73650163ad3b9fc91d1c", "filename": "src/libextra/semver.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsemver.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -14,12 +14,12 @@\n \n use core::prelude::*;\n \n+use core::iterator::IteratorUtil;\n use core::char;\n use core::cmp;\n use core::io::{ReaderUtil};\n use core::io;\n use core::option::{Option, Some, None};\n-use core::str;\n use core::to_str::ToStr;\n use core::uint;\n \n@@ -80,12 +80,12 @@ impl ToStr for Version {\n         let s = if self.pre.is_empty() {\n             s\n         } else {\n-            s + \"-\" + str::connect(self.pre.map(|i| i.to_str()), \".\")\n+            s + \"-\" + self.pre.map(|i| i.to_str()).connect(\".\")\n         };\n         if self.build.is_empty() {\n             s\n         } else {\n-            s + \"+\" + str::connect(self.build.map(|i| i.to_str()), \".\")\n+            s + \"+\" + self.build.map(|i| i.to_str()).connect(\".\")\n         }\n     }\n }\n@@ -148,7 +148,7 @@ fn take_nonempty_prefix(rdr: @io::Reader,\n     let mut buf = ~\"\";\n     let mut ch = ch;\n     while pred(ch) {\n-        str::push_char(&mut buf, ch);\n+        buf.push_char(ch);\n         ch = rdr.read_char();\n     }\n     if buf.is_empty() {\n@@ -168,7 +168,7 @@ fn take_num(rdr: @io::Reader, ch: char) -> (uint, char) {\n \n fn take_ident(rdr: @io::Reader, ch: char) -> (Identifier, char) {\n     let (s,ch) = take_nonempty_prefix(rdr, ch, char::is_alphanumeric);\n-    if s.all(char::is_digit) {\n+    if s.iter().all(char::is_digit) {\n         match uint::from_str(s) {\n             None => { bad_parse::cond.raise(()); (Numeric(0), ch) },\n             Some(i) => (Numeric(i), ch)"}, {"sha": "658621e25bdf1976ecc9bead3e42a6a2035665ed", "filename": "src/libextra/sha1.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsha1.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -281,7 +281,6 @@ pub fn sha1() -> @Sha1 {\n mod tests {\n     use sha1;\n \n-    use core::str;\n     use core::vec;\n \n     #[test]\n@@ -396,7 +395,7 @@ mod tests {\n \n         // Test that it works when accepting the message in pieces\n         for tests.each |t| {\n-            let len = str::len(t.input);\n+            let len = t.input.len();\n             let mut left = len;\n             while left > 0u {\n                 let take = (left + 1u) / 2u;"}, {"sha": "c239e65e2d9a9a931a376b33f21526169ed98895", "filename": "src/libextra/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftempfile.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -42,7 +42,7 @@ mod tests {\n     fn test_mkdtemp() {\n         let p = mkdtemp(&Path(\".\"), \"foobar\").unwrap();\n         os::remove_dir(&p);\n-        assert!(str::ends_with(p.to_str(), \"foobar\"));\n+        assert!(p.to_str().ends_with(\"foobar\"));\n     }\n \n     // Ideally these would be in core::os but then core would need"}, {"sha": "690596e6248e99e4ef48106a20bd1c43a6df740b", "filename": "src/libextra/terminfo/parser/compiled.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -14,6 +14,7 @@ use core::prelude::*;\n \n use core::{vec, int, str};\n use core::io::Reader;\n+use core::iterator::IteratorUtil;\n use core::hashmap::HashMap;\n use super::super::TermInfo;\n \n@@ -212,11 +213,8 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n         return Err(~\"incompatible file: more string offsets than expected\");\n     }\n \n-    let mut term_names: ~[~str] = vec::with_capacity(2);\n     let names_str = str::from_bytes(file.read_bytes(names_bytes as uint - 1)); // don't read NUL\n-    for names_str.each_split_char('|') |s| {\n-        term_names.push(s.to_owned());\n-    }\n+    let term_names: ~[~str] = names_str.split_iter('|').transform(|s| s.to_owned()).collect();\n \n     file.read_byte(); // consume NUL\n "}, {"sha": "d109bb12e02288f391bb61db0cc65546877c6566", "filename": "src/libextra/terminfo/searcher.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fsearcher.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -12,9 +12,10 @@\n /// Does not support hashed database, only filesystem!\n \n use core::prelude::*;\n-use core::{os, str};\n+use core::{os};\n use core::os::getenv;\n use core::io::{file_reader, Reader};\n+use core::iterator::IteratorUtil;\n use path = core::path::Path;\n \n /// Return path to database entry for `term`\n@@ -36,7 +37,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~path> {\n                 dirs_to_search.push(homedir.unwrap().push(\".terminfo\")); // ncurses compatability\n             }\n             match getenv(\"TERMINFO_DIRS\") {\n-                Some(dirs) => for str::each_split_char(dirs, ':') |i| {\n+                Some(dirs) => for dirs.split_iter(':').advance |i| {\n                     if i == \"\" {\n                         dirs_to_search.push(path(\"/usr/share/terminfo\"));\n                     } else {"}, {"sha": "406dfb086eaceb8d334ac3a290c68adaefd05afa", "filename": "src/libextra/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -407,8 +407,8 @@ fn should_sort_failures_before_printing_them() {\n         print_failures(st);\n     };\n \n-    let apos = str::find_str(s, \"a\").get();\n-    let bpos = str::find_str(s, \"b\").get();\n+    let apos = s.find_str(\"a\").get();\n+    let bpos = s.find_str(\"b\").get();\n     assert!(apos < bpos);\n }\n \n@@ -514,7 +514,7 @@ pub fn filter_tests(\n \n         fn filter_fn(test: TestDescAndFn, filter_str: &str) ->\n             Option<TestDescAndFn> {\n-            if str::contains(test.desc.name.to_str(), filter_str) {\n+            if test.desc.name.to_str().contains(filter_str) {\n                 return option::Some(test);\n             } else { return option::None; }\n         }"}, {"sha": "caaa2994405e01b984c3eca0eb7194bed2de06da", "filename": "src/libextra/time.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -279,7 +279,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n             match strs[i] { // can't use let due to stage0 bugs\n                 (ref needle, value) => {\n                     if match_str(ss, pos, *needle) {\n-                        return Some((value, pos + str::len(*needle)));\n+                        return Some((value, pos + needle.len()));\n                     }\n                 }\n             }\n@@ -296,7 +296,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n \n         let mut i = 0u;\n         while i < digits {\n-            let range = str::char_range_at(ss, pos);\n+            let range = ss.char_range_at(pos);\n             pos = range.next;\n \n             match range.ch {\n@@ -323,7 +323,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n     }\n \n     fn parse_char(s: &str, pos: uint, c: char) -> Result<uint, ~str> {\n-        let range = str::char_range_at(s, pos);\n+        let range = s.char_range_at(pos);\n \n         if c == range.ch {\n             Ok(range.next)\n@@ -598,9 +598,9 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                 // It's odd, but to maintain compatibility with c's\n                 // strptime we ignore the timezone.\n                 let mut pos = pos;\n-                let len = str::len(s);\n+                let len = s.len();\n                 while pos < len {\n-                    let range = str::char_range_at(s, pos);\n+                    let range = s.char_range_at(pos);\n                     pos = range.next;\n                     if range.ch == ' ' { break; }\n                 }\n@@ -609,7 +609,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n             }\n           }\n           'z' => {\n-            let range = str::char_range_at(s, pos);\n+            let range = s.char_range_at(pos);\n \n             if range.ch == '+' || range.ch == '-' {\n                 match match_digits(s, range.next, 4u, false) {\n@@ -651,11 +651,11 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n             tm_nsec: 0_i32,\n         };\n         let mut pos = 0u;\n-        let len = str::len(s);\n+        let len = s.len();\n         let mut result = Err(~\"Invalid time\");\n \n         while !rdr.eof() && pos < len {\n-            let range = str::char_range_at(s, pos);\n+            let range = s.char_range_at(pos);\n             let ch = range.ch;\n             let next = range.next;\n \n@@ -851,7 +851,7 @@ priv fn do_strftime(format: &str, tm: &Tm) -> ~str {\n         while !rdr.eof() {\n             match rdr.read_char() {\n                 '%' => buf += parse_type(rdr.read_char(), tm),\n-                ch => str::push_char(&mut buf, ch)\n+                ch => buf.push_char(ch)\n             }\n         }\n     }"}, {"sha": "187960b91016a9622a3f1036c722919a5f2ff969", "filename": "src/libextra/uv_ll.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibextra%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuv_ll.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -1480,7 +1480,7 @@ mod test {\n \n                 let server_kill_msg = copy (*client_data).server_kill_msg;\n                 let write_req = (*client_data).server_write_req;\n-                if str::contains(request_str, server_kill_msg) {\n+                if request_str.contains(server_kill_msg) {\n                     debug!(~\"SERVER: client req contains kill_msg!\");\n                     debug!(~\"SERVER: sending response to client\");\n                     read_stop(client_stream_ptr);\n@@ -1753,8 +1753,8 @@ mod test {\n         let msg_from_client = server_port.recv();\n         let msg_from_server = client_port.recv();\n \n-        assert!(str::contains(msg_from_client, kill_server_msg));\n-        assert!(str::contains(msg_from_server, server_resp_msg));\n+        assert!(msg_from_client.contains(kill_server_msg));\n+        assert!(msg_from_server.contains(server_resp_msg));\n     }\n \n     // FIXME don't run on fbsd or linux 32 bit(#2064)"}, {"sha": "dbeea417a3dd9f5b44ffb3b5812533575a9f721c", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -37,7 +37,6 @@ use std::result;\n use std::run;\n use std::str;\n use std::uint;\n-use std::vec;\n \n use syntax::diagnostic;\n use syntax::parse::token::ident_interner;\n@@ -57,7 +56,7 @@ pub fn write_file(filename: &Path, content: &str) {\n }\n \n pub fn contains(haystack: &str, needle: &str) -> bool {\n-    str::contains(haystack, needle)\n+    haystack.contains(needle)\n }\n \n pub fn find_rust_files(files: &mut ~[Path], path: &Path) {\n@@ -375,8 +374,8 @@ pub fn check_variants_T<T:Copy>(crate: @ast::crate,\n }\n \n pub fn last_part(filename: ~str) -> ~str {\n-    let ix = str::rfind_char(filename, '/').get();\n-    str::slice(filename, ix + 1u, str::len(filename) - 3u).to_owned()\n+    let ix = filename.rfind('/').get();\n+    filename.slice(ix + 1u, filename.len() - 3u).to_owned()\n }\n \n pub enum happiness {\n@@ -434,7 +433,7 @@ pub fn check_running(exe_filename: &Path) -> happiness {\n         \"/Users/jruderman/scripts/timed_run_rust_program.py\",\n         [exe_filename.to_str()]);\n     let comb = str::from_bytes(p.output) + \"\\n\" + str::from_bytes(p.error);\n-    if str::len(comb) > 1u {\n+    if comb.len() > 1u {\n         error!(\"comb comb comb: %?\", comb);\n     }\n \n@@ -712,4 +711,3 @@ pub mod core {\n     pub use std::cmp;\n     pub use std::sys;\n }\n-"}, {"sha": "496c1f88a6c8a2ec3d59ac5bc405672637379bfc", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -394,7 +394,7 @@ pub mod write {\n             sess.err(fmt!(\"building with `%s` failed with code %d\",\n                         cc_prog, prog.status));\n             sess.note(fmt!(\"%s arguments: %s\",\n-                        cc_prog, str::connect(cc_args, \" \")));\n+                        cc_prog, cc_args.connect(\" \")));\n             sess.note(str::from_bytes(prog.error + prog.output));\n             sess.abort_if_errors();\n         }\n@@ -686,7 +686,7 @@ pub fn mangle(sess: Session, ss: path) -> ~str {\n     for ss.each |s| {\n         match *s { path_name(s) | path_mod(s) => {\n           let sani = sanitize(*sess.str_of(s));\n-          n += fmt!(\"%u%s\", str::len(sani), sani);\n+          n += fmt!(\"%u%s\", sani.len(), sani);\n         } }\n     }\n     n += \"E\"; // End name-sequence.\n@@ -809,14 +809,14 @@ pub fn link_binary(sess: Session,\n \n     debug!(\"output: %s\", output.to_str());\n     let cc_args = link_args(sess, obj_filename, out_filename, lm);\n-    debug!(\"%s link args: %s\", cc_prog, str::connect(cc_args, \" \"));\n+    debug!(\"%s link args: %s\", cc_prog, cc_args.connect(\" \"));\n     // We run 'cc' here\n     let prog = run::process_output(cc_prog, cc_args);\n     if 0 != prog.status {\n         sess.err(fmt!(\"linking with `%s` failed with code %d\",\n                       cc_prog, prog.status));\n         sess.note(fmt!(\"%s arguments: %s\",\n-                       cc_prog, str::connect(cc_args, \" \")));\n+                       cc_prog, cc_args.connect(\" \")));\n         sess.note(str::from_bytes(prog.error + prog.output));\n         sess.abort_if_errors();\n     }"}, {"sha": "5e5e0067afa418508062291bb2eb68a1a38b0b81", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -240,7 +240,7 @@ mod test {\n         debug!(\"test_prefix_path: %s vs. %s\",\n                res.to_str(),\n                d.to_str());\n-        assert!(str::ends_with(res.to_str(), d.to_str()));\n+        assert!(res.to_str().ends_with(d.to_str()));\n     }\n \n     #[test]"}, {"sha": "ef5670da4558739de9df13250164c9af447ca470", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -24,6 +24,7 @@ use middle;\n use util::common::time;\n use util::ppaux;\n \n+use core::iterator::IteratorUtil;\n use core::hashmap::HashMap;\n use core::int;\n use core::io;\n@@ -327,8 +328,8 @@ pub fn compile_rest(sess: Session,\n \n     let outputs = outputs.get_ref();\n     if (sess.opts.debugging_opts & session::print_link_args) != 0 {\n-        io::println(str::connect(link::link_args(sess,\n-            &outputs.obj_filename, &outputs.out_filename, link_meta), \" \"));\n+        io::println(link::link_args(sess, &outputs.obj_filename,\n+                                    &outputs.out_filename, link_meta).connect(\" \"));\n     }\n \n     // NB: Android hack\n@@ -464,33 +465,33 @@ pub fn pretty_print_input(sess: Session, cfg: ast::crate_cfg, input: &input,\n }\n \n pub fn get_os(triple: &str) -> Option<session::os> {\n-    if str::contains(triple, \"win32\") ||\n-               str::contains(triple, \"mingw32\") {\n+    if triple.contains(\"win32\") ||\n+               triple.contains(\"mingw32\") {\n             Some(session::os_win32)\n-        } else if str::contains(triple, \"darwin\") {\n+        } else if triple.contains(\"darwin\") {\n             Some(session::os_macos)\n-        } else if str::contains(triple, \"android\") {\n+        } else if triple.contains(\"android\") {\n             Some(session::os_android)\n-        } else if str::contains(triple, \"linux\") {\n+        } else if triple.contains(\"linux\") {\n             Some(session::os_linux)\n-        } else if str::contains(triple, \"freebsd\") {\n+        } else if triple.contains(\"freebsd\") {\n             Some(session::os_freebsd)\n         } else { None }\n }\n \n pub fn get_arch(triple: &str) -> Option<abi::Architecture> {\n-    if str::contains(triple, \"i386\") ||\n-        str::contains(triple, \"i486\") ||\n-               str::contains(triple, \"i586\") ||\n-               str::contains(triple, \"i686\") ||\n-               str::contains(triple, \"i786\") {\n+    if triple.contains(\"i386\") ||\n+        triple.contains(\"i486\") ||\n+               triple.contains(\"i586\") ||\n+               triple.contains(\"i686\") ||\n+               triple.contains(\"i786\") {\n             Some(abi::X86)\n-        } else if str::contains(triple, \"x86_64\") {\n+        } else if triple.contains(\"x86_64\") {\n             Some(abi::X86_64)\n-        } else if str::contains(triple, \"arm\") ||\n-                      str::contains(triple, \"xscale\") {\n+        } else if triple.contains(\"arm\") ||\n+                      triple.contains(\"xscale\") {\n             Some(abi::Arm)\n-        } else if str::contains(triple, \"mips\") {\n+        } else if triple.contains(\"mips\") {\n             Some(abi::Mips)\n         } else { None }\n }\n@@ -684,11 +685,7 @@ pub fn build_session_options(binary: @~str,\n     let addl_lib_search_paths = getopts::opt_strs(matches, \"L\").map(|s| Path(*s));\n     let linker = getopts::opt_maybe_str(matches, \"linker\");\n     let linker_args = getopts::opt_strs(matches, \"link-args\").flat_map( |a| {\n-        let mut args = ~[];\n-        for str::each_split_char(*a, ' ') |arg| {\n-            args.push(str::to_owned(arg));\n-        }\n-        args\n+        a.split_iter(' ').transform(|arg| arg.to_owned()).collect()\n     });\n \n     let cfg = parse_cfgspecs(getopts::opt_strs(matches, \"cfg\"), demitter);\n@@ -699,12 +696,9 @@ pub fn build_session_options(binary: @~str,\n     let custom_passes = match getopts::opt_maybe_str(matches, \"passes\") {\n         None => ~[],\n         Some(s) => {\n-            let mut o = ~[];\n-            for s.each_split(|c| c == ' ' || c == ',') |s| {\n-                let s = s.trim().to_owned();\n-                o.push(s);\n-            }\n-            o\n+            s.split_iter(|c: char| c == ' ' || c == ',').transform(|s| {\n+                s.trim().to_owned()\n+            }).collect()\n         }\n     };\n "}, {"sha": "f0cabe5045587e71eb5ea5c82c21617016eb5bac", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -17,6 +17,7 @@ use core::prelude::*;\n use metadata::cstore;\n use metadata::decoder;\n \n+use core::iterator::IteratorUtil;\n use core::hashmap::HashMap;\n use core::vec;\n use extra;\n@@ -114,7 +115,7 @@ pub fn get_used_libraries(cstore: &CStore) -> ~[~str] {\n }\n \n pub fn add_used_link_args(cstore: &mut CStore, args: &str) {\n-    for args.each_split_char(' ') |s| {\n+    for args.split_iter(' ').advance |s| {\n         cstore.used_link_args.push(s.to_owned());\n     }\n }"}, {"sha": "6314cb6269768d666117bfc7d9a9b8d21edf1f2b", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -186,7 +186,7 @@ fn get_rustpkg_lib_path_nearest() -> Result<Path, ~str> {\n // On Unix should be \"lib\", on windows \"bin\"\n pub fn libdir() -> ~str {\n    let libdir = env!(\"CFG_LIBDIR\");\n-   if str::is_empty(libdir) {\n+   if libdir.is_empty() {\n       fail!(\"rustc compiled without CFG_LIBDIR environment variable\");\n    }\n    libdir.to_owned()"}, {"sha": "79f5b7984b6a4b35dd9ee8d784e970fe7cedfcc3", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -26,7 +26,6 @@ use middle;\n use util::ppaux::ty_to_str;\n \n use core::at_vec;\n-use core::str;\n use core::uint;\n use extra::ebml::reader;\n use extra::ebml;\n@@ -980,7 +979,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n         fn type_string(doc: ebml::Doc) -> ~str {\n             let mut str = ~\"\";\n             for uint::range(doc.start, doc.end) |i| {\n-                str::push_char(&mut str, doc.data[i] as char);\n+                str.push_char(doc.data[i] as char);\n             }\n             str\n         }"}, {"sha": "da3c5e43606fe4ef49597df73412502d8c95b115", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -25,7 +25,6 @@ use core::hashmap::{HashSet, HashMap};\n use core::io;\n use core::ops::{BitOr, BitAnd};\n use core::result::{Result};\n-use core::str;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::visit;\n@@ -694,9 +693,9 @@ impl BorrowckCtxt {\n                                                  out: &mut ~str) {\n         match *loan_path {\n             LpExtend(_, _, LpDeref) => {\n-                str::push_char(out, '(');\n+                out.push_char('(');\n                 self.append_loan_path_to_str(loan_path, out);\n-                str::push_char(out, ')');\n+                out.push_char(')');\n             }\n             LpExtend(_, _, LpInterior(_)) |\n             LpVar(_) => {\n@@ -712,7 +711,7 @@ impl BorrowckCtxt {\n             LpVar(id) => {\n                 match self.tcx.items.find(&id) {\n                     Some(&ast_map::node_local(ref ident)) => {\n-                        str::push_str(out, *token::ident_to_str(ident));\n+                        out.push_str(*token::ident_to_str(ident));\n                     }\n                     r => {\n                         self.tcx.sess.bug(\n@@ -726,23 +725,23 @@ impl BorrowckCtxt {\n                 self.append_loan_path_to_str_from_interior(lp_base, out);\n                 match fname {\n                     mc::NamedField(ref fname) => {\n-                        str::push_char(out, '.');\n-                        str::push_str(out, *token::ident_to_str(fname));\n+                        out.push_char('.');\n+                        out.push_str(*token::ident_to_str(fname));\n                     }\n                     mc::PositionalField(idx) => {\n-                        str::push_char(out, '#'); // invent a notation here\n-                        str::push_str(out, idx.to_str());\n+                        out.push_char('#'); // invent a notation here\n+                        out.push_str(idx.to_str());\n                     }\n                 }\n             }\n \n             LpExtend(lp_base, _, LpInterior(mc::InteriorElement(_))) => {\n                 self.append_loan_path_to_str_from_interior(lp_base, out);\n-                str::push_str(out, \"[]\");\n+                out.push_str(\"[]\");\n             }\n \n             LpExtend(lp_base, _, LpDeref) => {\n-                str::push_char(out, '*');\n+                out.push_char('*');\n                 self.append_loan_path_to_str(lp_base, out);\n             }\n         }"}, {"sha": "c528bad0b070b95d4f2116f54013443ca654af00", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -21,7 +21,6 @@ use core::prelude::*;\n use core::iterator::IteratorUtil;\n use core::cast;\n use core::io;\n-use core::str;\n use core::uint;\n use core::vec;\n use syntax::ast;\n@@ -947,13 +946,13 @@ fn bits_to_str(words: &[uint]) -> ~str {\n     for words.each |&word| {\n         let mut v = word;\n         for uint::range(0, uint::bytes) |_| {\n-            str::push_char(&mut result, sep);\n-            str::push_str(&mut result, fmt!(\"%02x\", v & 0xFF));\n+            result.push_char(sep);\n+            result.push_str(fmt!(\"%02x\", v & 0xFF));\n             v >>= 8;\n             sep = '-';\n         }\n     }\n-    str::push_char(&mut result, ']');\n+    result.push_char(']');\n     return result;\n }\n "}, {"sha": "2907e53cd4c2f27883d671c6438f3778f17cf018", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -17,7 +17,6 @@ use middle::resolve;\n use middle::ty;\n \n use core::hashmap::HashMap;\n-use core::vec;\n use syntax::codemap::span;\n use syntax::{ast, ast_util, visit};\n "}, {"sha": "92147bf4e0f7237ed2a4cb163148fd70c1cae610", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -841,26 +841,11 @@ fn check_item_non_camel_case_types(cx: &Context, it: @ast::item) {\n     fn is_camel_case(cx: ty::ctxt, ident: ast::ident) -> bool {\n         let ident = cx.sess.str_of(ident);\n         assert!(!ident.is_empty());\n-        let ident = ident_without_trailing_underscores(*ident);\n-        let ident = ident_without_leading_underscores(ident);\n-        char::is_uppercase(str::char_at(ident, 0)) &&\n+        let ident = ident.trim_chars(&['_']);\n+        char::is_uppercase(ident.char_at(0)) &&\n             !ident.contains_char('_')\n     }\n \n-    fn ident_without_trailing_underscores<'r>(ident: &'r str) -> &'r str {\n-        match str::rfind(ident, |c| c != '_') {\n-            Some(idx) => str::slice(ident, 0, idx + 1),\n-            None => ident, // all underscores\n-        }\n-    }\n-\n-    fn ident_without_leading_underscores<'r>(ident: &'r str) -> &'r str {\n-        match str::find(ident, |c| c != '_') {\n-            Some(idx) => str::slice(ident, idx, ident.len()),\n-            None => ident // all underscores\n-        }\n-    }\n-\n     fn check_case(cx: &Context, ident: ast::ident, span: span) {\n         if !is_camel_case(cx.tcx, ident) {\n             cx.span_lint(non_camel_case_types, span,"}, {"sha": "96838c32266a844e4cda1ddf28eedfe25a9f6385", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -40,7 +40,7 @@ use syntax::visit::{visit_foreign_item, visit_item};\n use syntax::visit::{visit_mod, visit_ty, vt};\n use syntax::opt_vec::OptVec;\n \n-use core::str::each_split_str;\n+use core::iterator::IteratorUtil;\n use core::str;\n use core::uint;\n use core::vec;\n@@ -1737,8 +1737,7 @@ impl Resolver {\n                         entry: %s (%?)\",\n                     path_string, def_like);\n \n-            let mut pieces = ~[];\n-            for each_split_str(path_string, \"::\") |s| { pieces.push(s.to_owned()) }\n+            let mut pieces: ~[&str] = path_string.split_str_iter(\"::\").collect();\n             let final_ident_str = pieces.pop();\n             let final_ident = self.session.ident_of(final_ident_str);\n \n@@ -2575,7 +2574,7 @@ impl Resolver {\n                     if \"???\" == module_name {\n                         let span = span {\n                             lo: span.lo,\n-                            hi: span.lo + BytePos(str::len(*segment_name)),\n+                            hi: span.lo + BytePos(segment_name.len()),\n                             expn_info: span.expn_info,\n                         };\n                         self.session.span_err(span,\n@@ -2682,14 +2681,14 @@ impl Resolver {\n         match module_prefix_result {\n             Failed => {\n                 let mpath = self.idents_to_str(module_path);\n-                match str::rfind(self.idents_to_str(module_path), |c| { c == ':' }) {\n+                match self.idents_to_str(module_path).rfind(':') {\n                     Some(idx) => {\n                         self.session.span_err(span, fmt!(\"unresolved import: could not find `%s` \\\n-                                                         in `%s`\", str::substr(mpath, idx,\n-                                                                               mpath.len() - idx),\n+                                                         in `%s`\", mpath.substr(idx,\n+                                                                                mpath.len() - idx),\n                                                          // idx - 1 to account for the extra\n                                                          // colon\n-                                                         str::substr(mpath, 0, idx - 1)));\n+                                                         mpath.substr(0, idx - 1)));\n                     },\n                     None => (),\n                 };\n@@ -3100,7 +3099,7 @@ impl Resolver {\n         let import_count = imports.len();\n         if index != import_count {\n             let sn = self.session.codemap.span_to_snippet(imports[index].span);\n-            if str::contains(sn, \"::\") {\n+            if sn.contains(\"::\") {\n                 self.session.span_err(imports[index].span, \"unresolved import\");\n             } else {\n                 let err = fmt!(\"unresolved import (maybe you meant `%s::*`?)\",\n@@ -4830,7 +4829,7 @@ impl Resolver {\n \n         if values.len() > 0 &&\n             values[smallest] != uint::max_value &&\n-            values[smallest] < str::len(name) + 2 &&\n+            values[smallest] < name.len() + 2 &&\n             values[smallest] <= max_distance &&\n             maybes[smallest] != name.to_owned() {\n "}, {"sha": "833146a935e8f305ad3c5fad63944c50f63fa5c8", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -87,7 +87,7 @@ pub fn trans_inline_asm(bcx: block, ia: &ast::inline_asm) -> block {\n         revoke_clean(bcx, *c);\n     }\n \n-    let mut constraints = str::connect(constraints, \",\");\n+    let mut constraints = constraints.connect(\",\");\n \n     let mut clobbers = getClobbers();\n     if *ia.clobbers != ~\"\" && clobbers != ~\"\" {"}, {"sha": "8e015d9a677e151ab4198d4a10065d75374cc8b6", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -1995,7 +1995,7 @@ pub fn trans_enum_variant(ccx: @CrateContext,\n \n     debug!(\"trans_enum_variant: name=%s tps=%s repr=%? enum_ty=%s\",\n            unsafe { str::raw::from_c_str(llvm::LLVMGetValueName(llfndecl)) },\n-           ~\"[\" + str::connect(ty_param_substs.map(|&t| ty_to_str(ccx.tcx, t)), \", \") + \"]\",\n+           ~\"[\" + ty_param_substs.map(|&t| ty_to_str(ccx.tcx, t)).connect(\", \") + \"]\",\n            repr, ty_to_str(ccx.tcx, enum_ty));\n \n     adt::trans_start_init(bcx, repr, fcx.llretptr.get(), disr);"}, {"sha": "8b2814875046ab13104bc7d77d99e89d842f0e32", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -192,9 +192,7 @@ pub fn Invoke(cx: block,\n     terminate(cx, \"Invoke\");\n     debug!(\"Invoke(%s with arguments (%s))\",\n            val_str(cx.ccx().tn, Fn),\n-           str::connect(vec::map(Args, |a| val_str(cx.ccx().tn,\n-                                                   *a).to_owned()),\n-                        \", \"));\n+           Args.map(|a| val_str(cx.ccx().tn, *a).to_owned()).connect(\", \"));\n     unsafe {\n         count_insn(cx, \"invoke\");\n         llvm::LLVMBuildInvoke(B(cx),"}, {"sha": "b29972f039b1936a564209c2fdfca257a8d5d915", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -44,7 +44,6 @@ use core::cast;\n use core::hash;\n use core::hashmap::{HashMap, HashSet};\n use core::libc::{c_uint, c_longlong, c_ulonglong};\n-use core::ptr;\n use core::str;\n use core::to_bytes;\n use core::vec::raw::to_ptr;\n@@ -1221,7 +1220,7 @@ pub fn C_estr_slice(cx: @CrateContext, s: @~str) -> ValueRef {\n pub fn C_postr(s: &str) -> ValueRef {\n     unsafe {\n         return do str::as_c_str(s) |buf| {\n-            llvm::LLVMConstString(buf, str::len(s) as c_uint, False)\n+            llvm::LLVMConstString(buf, s.len() as c_uint, False)\n         };\n     }\n }\n@@ -1484,7 +1483,7 @@ pub fn node_id_type_params(bcx: block, id: ast::node_id) -> ~[ty::t] {\n     if !params.all(|t| !ty::type_needs_infer(*t)) {\n         bcx.sess().bug(\n             fmt!(\"Type parameters for node %d include inference types: %s\",\n-                 id, str::connect(params.map(|t| bcx.ty_to_str(*t)), \",\")));\n+                 id, params.map(|t| bcx.ty_to_str(*t)).connect(\",\")));\n     }\n \n     match bcx.fcx.param_substs {"}, {"sha": "ce93cad73b6f3cc88c4756d1cd00b322762413aa", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -244,9 +244,9 @@ fn get_cache(cx: @CrateContext) -> metadata_cache {\n }\n \n fn get_file_path_and_dir(work_dir: &str, full_path: &str) -> (~str, ~str) {\n-    (if str::starts_with(full_path, work_dir) {\n-        str::slice(full_path, str::len(work_dir) + 1u,\n-                   str::len(full_path)).to_owned()\n+    (if full_path.starts_with(work_dir) {\n+        full_path.slice(work_dir.len() + 1u,\n+                   full_path.len()).to_owned()\n     } else {\n         full_path.to_owned()\n     }, work_dir.to_owned())"}, {"sha": "b12b1499759f9ca5a9fe37f39e6b1ebf0041b98e", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -115,7 +115,6 @@ use core::iterator::IteratorUtil;\n use core::cast::transmute;\n use core::hashmap::HashMap;\n use core::result;\n-use core::str;\n use core::util::replace;\n use core::vec;\n use extra::list::Nil;\n@@ -1879,7 +1878,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                        } else {\n                                            \"s\"\n                                        },\n-                                       str::connect(missing_fields, \", \")));\n+                                       missing_fields.connect(\", \")));\n              }\n         }\n "}, {"sha": "0db9d16adf3c0186c0b681dd38e22b654aabf777", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -100,7 +100,7 @@ impl Env {\n         return match search_mod(self, &self.crate.node.module, 0, names) {\n             Some(id) => id,\n             None => {\n-                fail!(\"No item found: `%s`\", str::connect(names, \"::\"));\n+                fail!(\"No item found: `%s`\", names.connect(\"::\"));\n             }\n         };\n "}, {"sha": "364d8b2d052c3e6d67faccb91e1841a3ffa518b2", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -18,7 +18,6 @@ use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::unify::{Redirect, Root, VarValue};\n use util::ppaux::{mt_to_str, ty_to_str, trait_ref_to_str};\n \n-use core::str;\n use core::uint;\n use syntax::ast;\n \n@@ -35,7 +34,7 @@ impl InferStr for ty::t {\n impl InferStr for FnSig {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n         fmt!(\"(%s) -> %s\",\n-             str::connect(self.inputs.map(|a| a.inf_str(cx)), \", \"),\n+             self.inputs.map(|a| a.inf_str(cx)).connect(\", \"),\n              self.output.inf_str(cx))\n     }\n }"}, {"sha": "9556fd3e2574d053846a6dbe4db3962b0eed2148", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -16,7 +16,6 @@ use syntax::visit;\n \n use core::hashmap::HashSet;\n use core::io;\n-use core::str;\n use extra;\n \n pub fn time<T>(do_it: bool, what: ~str, thunk: &fn() -> T) -> T {\n@@ -111,7 +110,7 @@ pub fn local_rhs_span(l: @ast::local, def: span) -> span {\n \n pub fn pluralize(n: uint, s: ~str) -> ~str {\n     if n == 1 { s }\n-    else { str::concat([s, ~\"s\"]) }\n+    else { fmt!(\"%ss\", s) }\n }\n \n // A set of node IDs (used to keep track of which node IDs are for statements)"}, {"sha": "b5e6e7e119488cb7222fe37df1d589d62b8cf4c7", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -281,7 +281,7 @@ pub fn vstore_ty_to_str(cx: ctxt, mt: &mt, vs: ty::vstore) -> ~str {\n \n pub fn tys_to_str(cx: ctxt, ts: &[t]) -> ~str {\n     let tstrs = ts.map(|t| ty_to_str(cx, *t));\n-    fmt!(\"(%s)\", str::connect(tstrs, \", \"))\n+    fmt!(\"(%s)\", tstrs.connect(\", \"))\n }\n \n pub fn fn_sig_to_str(cx: ctxt, typ: &ty::FnSig) -> ~str {\n@@ -369,7 +369,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n     fn push_sig_to_str(cx: ctxt, s: &mut ~str, sig: &ty::FnSig) {\n         s.push_char('(');\n         let strs = sig.inputs.map(|a| fn_input_to_str(cx, *a));\n-        s.push_str(str::connect(strs, \", \"));\n+        s.push_str(strs.connect(\", \"));\n         s.push_char(')');\n         if ty::get(sig.output).sty != ty_nil {\n             s.push_str(\" -> \");\n@@ -420,7 +420,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       ty_type => ~\"type\",\n       ty_tup(ref elems) => {\n         let strs = elems.map(|elem| ty_to_str(cx, *elem));\n-        ~\"(\" + str::connect(strs, \",\") + \")\"\n+        ~\"(\" + strs.connect(\",\") + \")\"\n       }\n       ty_closure(ref f) => {\n           closure_to_str(cx, f)\n@@ -477,15 +477,15 @@ pub fn parameterized(cx: ctxt,\n \n     if tps.len() > 0u {\n         let strs = vec::map(tps, |t| ty_to_str(cx, *t));\n-        fmt!(\"%s%s<%s>\", base, r_str, str::connect(strs, \",\"))\n+        fmt!(\"%s%s<%s>\", base, r_str, strs.connect(\",\"))\n     } else {\n         fmt!(\"%s%s\", base, r_str)\n     }\n }\n \n pub fn ty_to_short_str(cx: ctxt, typ: t) -> ~str {\n     let mut s = encoder::encoded_ty(cx, typ);\n-    if str::len(s) >= 32u { s = str::slice(s, 0u, 32u).to_owned(); }\n+    if s.len() >= 32u { s = s.slice(0u, 32u).to_owned(); }\n     return s;\n }\n \n@@ -515,7 +515,7 @@ impl<T:Repr> Repr for ~T {\n */\n \n fn repr_vec<T:Repr>(tcx: ctxt, v: &[T]) -> ~str {\n-    fmt!(\"[%s]\", str::connect(v.map(|t| t.repr(tcx)), \",\"))\n+    fmt!(\"[%s]\", v.map(|t| t.repr(tcx)).connect(\",\"))\n }\n \n impl<'self, T:Repr> Repr for &'self [T] {\n@@ -569,7 +569,7 @@ impl Repr for ty::ParamBounds {\n         for self.trait_bounds.each |t| {\n             res.push(t.repr(tcx));\n         }\n-        str::connect(res, \"+\")\n+        res.connect(\"+\")\n     }\n }\n \n@@ -787,7 +787,7 @@ impl UserString for ty::BuiltinBounds {\n             for self.each |bb| {\n                 result.push(bb.user_string(tcx));\n             }\n-            str::connect(result, \"+\")\n+            result.connect(\"+\")\n         }\n     }\n }"}, {"sha": "47c54ee8e8f4560f0b6d006567d648d61d0dc15c", "filename": "src/librustdoc/attr_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_parser.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -53,7 +53,7 @@ pub fn parse_desc(attrs: ~[ast::attribute]) -> Option<~str> {\n     if doc_strs.is_empty() {\n         None\n     } else {\n-        Some(str::connect(doc_strs, \"\\n\"))\n+        Some(doc_strs.connect(\"\\n\"))\n     }\n }\n "}, {"sha": "f018a237b7e298bc0a625e40bc6d4ba53db9ec7f", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -94,7 +94,7 @@ fn parse_desc(desc: ~str) -> Option<~str> {\n \n     match first_sentence(copy desc) {\n       Some(first_sentence) => {\n-        if str::len(first_sentence) <= max_brief_len {\n+        if first_sentence.len() <= max_brief_len {\n             Some(first_sentence)\n         } else {\n             None\n@@ -118,25 +118,23 @@ fn first_sentence_(s: &str) -> ~str {\n     let mut dotcount = 0;\n     // The index of the character following a single dot. This allows\n     // Things like [0..1) to appear in the brief description\n-    let idx = do str::find(s) |ch| {\n+    let idx = s.find(|ch: char| {\n         if ch == '.' {\n             dotcount += 1;\n             false\n+        } else if dotcount == 1 {\n+            true\n         } else {\n-            if dotcount == 1 {\n-                true\n-            } else {\n-                dotcount = 0;\n-                false\n-            }\n+            dotcount = 0;\n+            false\n         }\n-    };\n+    });\n     match idx {\n         Some(idx) if idx > 2u => {\n-            str::to_owned(str::slice(s, 0, idx - 1))\n+            str::to_owned(s.slice(0, idx - 1))\n         }\n         _ => {\n-            if str::ends_with(s, \".\") {\n+            if s.ends_with(\".\") {\n                 str::to_owned(s)\n             } else {\n                 str::to_owned(s)\n@@ -153,7 +151,7 @@ pub fn paragraphs(s: &str) -> ~[~str] {\n     let paras = do lines.iter().fold(~[]) |paras, line| {\n         let mut res = paras;\n \n-        if str::is_whitespace(*line) {\n+        if line.is_whitespace() {\n             whitespace_lines += 1;\n         } else {\n             if whitespace_lines > 0 {\n@@ -165,7 +163,7 @@ pub fn paragraphs(s: &str) -> ~[~str] {\n \n             whitespace_lines = 0;\n \n-            accum = if str::is_empty(accum) {\n+            accum = if accum.is_empty() {\n                 copy *line\n             } else {\n                 accum + \"\\n\" + *line"}, {"sha": "36eb5e77ad6510a5211b8907e32ba9aab1fcdb8f", "filename": "src/librustdoc/markdown_index_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_index_pass.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -152,7 +152,7 @@ pub fn pandoc_header_id(header: &str) -> ~str {\n         // Collapse sequences of whitespace to a single dash\n         // XXX: Hacky implementation here that only covers\n         // one or two spaces.\n-        let s = str::trim(s);\n+        let s = s.trim();\n         let s = str::replace(s, \"  \", \"-\");\n         let s = str::replace(s, \" \", \"-\");\n         return s;"}, {"sha": "b6917f527a1ff9c96d04130ef8534f27835e42de", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 47, "deletions": 53, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -173,7 +173,7 @@ pub fn header_kind(doc: doc::ItemTag) -> ~str {\n }\n \n pub fn header_name(doc: doc::ItemTag) -> ~str {\n-    let fullpath = str::connect(doc.path() + [doc.name()], \"::\");\n+    let fullpath = (doc.path() + [doc.name()]).connect(\"::\");\n     match &doc {\n         &doc::ModTag(_) if doc.id() != syntax::ast::crate_node_id => {\n             fullpath\n@@ -414,7 +414,7 @@ fn code_block_indent(s: ~str) -> ~str {\n     for str::each_line_any(s) |line| {\n         indented.push(fmt!(\"    %s\", line));\n     }\n-    str::connect(indented, \"\\n\")\n+    indented.connect(\"\\n\")\n }\n \n fn write_const(\n@@ -476,7 +476,7 @@ fn list_item_indent(item: &str) -> ~str {\n     // separate markdown elements within `*` lists must be indented by four\n     // spaces, or they will escape the list context. indenting everything\n     // seems fine though.\n-    str::connect_slices(indented, \"\\n    \")\n+    indented.connect(\"\\n    \")\n }\n \n fn write_trait(ctxt: &Ctxt, doc: doc::TraitDoc) {\n@@ -607,13 +607,13 @@ mod test {\n     #[test]\n     fn write_markdown_should_write_mod_headers() {\n         let markdown = render(~\"mod moo { }\");\n-        assert!(str::contains(markdown, \"# Module `moo`\"));\n+        assert!(markdown.contains(\"# Module `moo`\"));\n     }\n \n     #[test]\n     fn should_leave_blank_line_after_header() {\n         let markdown = render(~\"mod morp { }\");\n-        assert!(str::contains(markdown, \"Module `morp`\\n\\n\"));\n+        assert!(markdown.contains(\"Module `morp`\\n\\n\"));\n     }\n \n     #[test]\n@@ -633,10 +633,10 @@ mod test {\n               fn d() { }\"\n         );\n \n-        let idx_a = str::find_str(markdown, \"# Module `a`\").get();\n-        let idx_b = str::find_str(markdown, \"## Function `b`\").get();\n-        let idx_c = str::find_str(markdown, \"# Module `c`\").get();\n-        let idx_d = str::find_str(markdown, \"## Function `d`\").get();\n+        let idx_a = markdown.find_str(\"# Module `a`\").get();\n+        let idx_b = markdown.find_str(\"## Function `b`\").get();\n+        let idx_c = markdown.find_str(\"# Module `c`\").get();\n+        let idx_d = markdown.find_str(\"## Function `d`\").get();\n \n         assert!(idx_b < idx_d);\n         assert!(idx_d < idx_a);\n@@ -669,10 +669,10 @@ mod test {\n             let (page, markdown) = po.recv();\n             match page {\n                 doc::CratePage(_) => {\n-                    assert!(str::contains(markdown, \"% Crate core\"));\n+                    assert!(markdown.contains(\"% Crate core\"));\n                 }\n                 doc::ItemPage(_) => {\n-                    assert!(str::contains(markdown, \"% Module a\"));\n+                    assert!(markdown.contains(\"% Module a\"));\n                 }\n             }\n         }\n@@ -681,7 +681,7 @@ mod test {\n     #[test]\n     fn should_write_full_path_to_mod() {\n         let markdown = render(~\"mod a { mod b { mod c { } } }\");\n-        assert!(str::contains(markdown, \"# Module `a::b::c`\"));\n+        assert!(markdown.contains(\"# Module `a::b::c`\"));\n     }\n \n     #[test]\n@@ -692,21 +692,20 @@ mod test {\n               Body\\\"]\\\n               mod a {\n }\");\n-        assert!(str::contains(markdown, \"#### Header\\n\\nBody\\n\\n\"));\n+        assert!(markdown.contains(\"#### Header\\n\\nBody\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_crate_description() {\n         let markdown = render(~\"#[doc = \\\"this is the crate\\\"];\");\n-        assert!(str::contains(markdown, \"this is the crate\"));\n+        assert!(markdown.contains(\"this is the crate\"));\n     }\n \n \n     #[test]\n     fn should_write_index() {\n         let markdown = render(~\"mod a { } mod b { }\");\n-        assert!(str::contains(\n-            markdown,\n+        assert!(markdown.contains(\n             \"\\n\\n* [Module `a`](#module-a)\\n\\\n              * [Module `b`](#module-b)\\n\\n\"\n         ));\n@@ -715,20 +714,19 @@ mod test {\n     #[test]\n     fn should_write_index_brief() {\n         let markdown = render(~\"#[doc = \\\"test\\\"] mod a { }\");\n-        assert!(str::contains(markdown, \"(#module-a) - test\\n\"));\n+        assert!(markdown.contains(\"(#module-a) - test\\n\"));\n     }\n \n     #[test]\n     fn should_not_write_index_if_no_entries() {\n         let markdown = render(~\"\");\n-        assert!(!str::contains(markdown, \"\\n\\n\\n\"));\n+        assert!(!markdown.contains(\"\\n\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_index_for_foreign_mods() {\n         let markdown = render(~\"extern { fn a(); }\");\n-        assert!(str::contains(\n-            markdown,\n+        assert!(markdown.contains(\n             \"\\n\\n* [Function `a`](#function-a)\\n\\n\"\n         ));\n     }\n@@ -737,32 +735,32 @@ mod test {\n     fn should_write_foreign_fns() {\n         let markdown = render(\n             ~\"extern { #[doc = \\\"test\\\"] fn a(); }\");\n-        assert!(str::contains(markdown, \"test\"));\n+        assert!(markdown.contains(\"test\"));\n     }\n \n     #[test]\n     fn should_write_foreign_fn_headers() {\n         let markdown = render(\n             ~\"extern { #[doc = \\\"test\\\"] fn a(); }\");\n-        assert!(str::contains(markdown, \"## Function `a`\"));\n+        assert!(markdown.contains(\"## Function `a`\"));\n     }\n \n     #[test]\n     fn write_markdown_should_write_function_header() {\n         let markdown = render(~\"fn func() { }\");\n-        assert!(str::contains(markdown, \"## Function `func`\"));\n+        assert!(markdown.contains(\"## Function `func`\"));\n     }\n \n     #[test]\n     fn should_write_the_function_signature() {\n         let markdown = render(~\"#[doc = \\\"f\\\"] fn a() { }\");\n-        assert!(str::contains(markdown, \"\\n    fn a()\\n\"));\n+        assert!(markdown.contains(\"\\n    fn a()\\n\"));\n     }\n \n     #[test]\n     fn should_insert_blank_line_after_fn_signature() {\n         let markdown = render(~\"#[doc = \\\"f\\\"] fn a() { }\");\n-        assert!(str::contains(markdown, \"fn a()\\n\\n\"));\n+        assert!(markdown.contains(\"fn a()\\n\\n\"));\n     }\n \n     #[test]\n@@ -783,39 +781,39 @@ mod test {\n             ]\n         };\n         let markdown = write_markdown_str(doc);\n-        assert!(str::contains(markdown, \"    line 1\\n    line 2\"));\n+        assert!(markdown.contains(\"    line 1\\n    line 2\"));\n     }\n \n     #[test]\n     fn should_leave_blank_line_between_fn_header_and_sig() {\n         let markdown = render(~\"fn a() { }\");\n-        assert!(str::contains(markdown, \"Function `a`\\n\\n    fn a()\"));\n+        assert!(markdown.contains(\"Function `a`\\n\\n    fn a()\"));\n     }\n \n     #[test]\n     fn should_write_const_header() {\n         let markdown = render(~\"static a: bool = true;\");\n-        assert!(str::contains(markdown, \"## Const `a`\\n\\n\"));\n+        assert!(markdown.contains(\"## Const `a`\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_const_description() {\n         let markdown = render(\n             ~\"#[doc = \\\"b\\\"]\\\n               static a: bool = true;\");\n-        assert!(str::contains(markdown, \"\\n\\nb\\n\\n\"));\n+        assert!(markdown.contains(\"\\n\\nb\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_enum_header() {\n         let markdown = render(~\"enum a { b }\");\n-        assert!(str::contains(markdown, \"## Enum `a`\\n\\n\"));\n+        assert!(markdown.contains(\"## Enum `a`\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_enum_description() {\n         let markdown = render(~\"#[doc = \\\"b\\\"] enum a { b }\");\n-        assert!(str::contains(markdown, \"\\n\\nb\\n\\n\"));\n+        assert!(markdown.contains(\"\\n\\nb\\n\\n\"));\n     }\n \n     #[test]\n@@ -824,8 +822,7 @@ mod test {\n             ~\"enum a { \\\n               #[doc = \\\"test\\\"] b, \\\n               #[doc = \\\"test\\\"] c }\");\n-        assert!(str::contains(\n-            markdown,\n+        assert!(markdown.contains(\n             \"\\n\\n#### Variants\\n\\\n              \\n\\\n              \\n* `b` - test\\\n@@ -836,8 +833,7 @@ mod test {\n     #[test]\n     fn should_write_variant_list_without_descs() {\n         let markdown = render(~\"enum a { b, c }\");\n-        assert!(str::contains(\n-            markdown,\n+        assert!(markdown.contains(\n             \"\\n\\n#### Variants\\n\\\n              \\n\\\n              \\n* `b`\\\n@@ -849,8 +845,7 @@ mod test {\n     fn should_write_variant_list_with_indent() {\n         let markdown = render(\n             ~\"enum a { #[doc = \\\"line 1\\\\n\\\\nline 2\\\"] b, c }\");\n-        assert!(str::contains(\n-            markdown,\n+        assert!(markdown.contains(\n             \"\\n\\n#### Variants\\n\\\n              \\n\\\n              \\n* `b` - line 1\\\n@@ -863,8 +858,7 @@ mod test {\n     #[test]\n     fn should_write_variant_list_with_signatures() {\n         let markdown = render(~\"enum a { b(int), #[doc = \\\"a\\\"] c(int) }\");\n-        assert!(str::contains(\n-            markdown,\n+        assert!(markdown.contains(\n             \"\\n\\n#### Variants\\n\\\n              \\n\\\n              \\n* `b(int)`\\\n@@ -875,89 +869,89 @@ mod test {\n     #[test]\n     fn should_write_trait_header() {\n         let markdown = render(~\"trait i { fn a(); }\");\n-        assert!(str::contains(markdown, \"## Trait `i`\"));\n+        assert!(markdown.contains(\"## Trait `i`\"));\n     }\n \n     #[test]\n     fn should_write_trait_desc() {\n         let markdown = render(~\"#[doc = \\\"desc\\\"] trait i { fn a(); }\");\n-        assert!(str::contains(markdown, \"desc\"));\n+        assert!(markdown.contains(\"desc\"));\n     }\n \n     #[test]\n     fn should_write_trait_method_header() {\n         let markdown = render(~\"trait i { fn a(); }\");\n-        assert!(str::contains(markdown, \"### Method `a`\"));\n+        assert!(markdown.contains(\"### Method `a`\"));\n     }\n \n     #[test]\n     fn should_write_trait_method_signature() {\n         let markdown = render(~\"trait i { fn a(&self); }\");\n-        assert!(str::contains(markdown, \"\\n    fn a(&self)\"));\n+        assert!(markdown.contains(\"\\n    fn a(&self)\"));\n     }\n \n     #[test]\n     fn should_write_impl_header() {\n         let markdown = render(~\"impl int { fn a() { } }\");\n-        assert!(str::contains(markdown, \"## Implementation for `int`\"));\n+        assert!(markdown.contains(\"## Implementation for `int`\"));\n     }\n \n     #[test]\n     fn should_write_impl_header_with_bounds() {\n         let markdown = render(~\"impl <T> int<T> { }\");\n-        assert!(str::contains(markdown, \"## Implementation for `int<T>` where `<T>`\"));\n+        assert!(markdown.contains(\"## Implementation for `int<T>` where `<T>`\"));\n     }\n \n     #[test]\n     fn should_write_impl_header_with_trait() {\n         let markdown = render(~\"impl j for int { fn a() { } }\");\n-        assert!(str::contains(markdown,\n+        assert!(markdown.contains(\n                               \"## Implementation of `j` for `int`\"));\n     }\n \n     #[test]\n     fn should_write_impl_desc() {\n         let markdown = render(\n             ~\"#[doc = \\\"desc\\\"] impl int { fn a() { } }\");\n-        assert!(str::contains(markdown, \"desc\"));\n+        assert!(markdown.contains(\"desc\"));\n     }\n \n     #[test]\n     fn should_write_impl_method_header() {\n         let markdown = render(\n             ~\"impl int { fn a() { } }\");\n-        assert!(str::contains(markdown, \"### Method `a`\"));\n+        assert!(markdown.contains(\"### Method `a`\"));\n     }\n \n     #[test]\n     fn should_write_impl_method_signature() {\n         let markdown = render(\n             ~\"impl int { fn a(&mut self) { } }\");\n-        assert!(str::contains(markdown, \"\\n    fn a(&mut self)\"));\n+        assert!(markdown.contains(\"\\n    fn a(&mut self)\"));\n     }\n \n     #[test]\n     fn should_write_type_header() {\n         let markdown = render(~\"type t = int;\");\n-        assert!(str::contains(markdown, \"## Type `t`\"));\n+        assert!(markdown.contains(\"## Type `t`\"));\n     }\n \n     #[test]\n     fn should_write_type_desc() {\n         let markdown = render(\n             ~\"#[doc = \\\"desc\\\"] type t = int;\");\n-        assert!(str::contains(markdown, \"\\n\\ndesc\\n\\n\"));\n+        assert!(markdown.contains(\"\\n\\ndesc\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_type_signature() {\n         let markdown = render(~\"type t = int;\");\n-        assert!(str::contains(markdown, \"\\n\\n    type t = int\\n\\n\"));\n+        assert!(markdown.contains(\"\\n\\n    type t = int\\n\\n\"));\n     }\n \n     #[test]\n     fn should_put_struct_header() {\n         let markdown = render(~\"struct S { field: () }\");\n-        assert!(str::contains(markdown, \"## Struct `S`\\n\\n\"));\n+        assert!(markdown.contains(\"## Struct `S`\\n\\n\"));\n     }\n }"}, {"sha": "353152763267cc5ece79a75071620145ac27307e", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -107,7 +107,7 @@ fn pandoc_writer(\n         use core::io::WriterUtil;\n \n         debug!(\"pandoc cmd: %s\", pandoc_cmd);\n-        debug!(\"pandoc args: %s\", str::connect(pandoc_args, \" \"));\n+        debug!(\"pandoc args: %s\", pandoc_args.connect(\" \"));\n \n         let mut proc = run::Process::new(pandoc_cmd, pandoc_args, run::ProcessOptions::new());\n \n@@ -164,7 +164,7 @@ pub fn make_filename(\n             }\n           }\n           doc::ItemPage(doc) => {\n-            str::connect(doc.path() + [doc.name()], \"_\")\n+            (doc.path() + [doc.name()]).connect(\"_\")\n           }\n         }\n     };"}, {"sha": "8716f823848e27c91eb1ca7ee56e48dd93c316c1", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -153,8 +153,8 @@ fn sectionalize(desc: Option<~str>) -> (Option<~str>, ~[doc::Section]) {\n }\n \n fn parse_header(line: ~str) -> Option<~str> {\n-    if str::starts_with(line, \"# \") {\n-        Some(str::slice(line, 2u, str::len(line)).to_owned())\n+    if line.starts_with(\"# \") {\n+        Some(line.slice(2u, line.len()).to_owned())\n     } else {\n         None\n     }\n@@ -191,9 +191,7 @@ mod test {\n               Body\\\"]\\\n               mod a {\n }\");\n-        assert!(str::contains(\n-            doc.cratemod().mods()[0].item.sections[0].header,\n-            \"Header\"));\n+        assert!(doc.cratemod().mods()[0].item.sections[0].header.contains(\"Header\"));\n     }\n \n     #[test]\n@@ -204,9 +202,7 @@ mod test {\n               Body\\\"]\\\n               mod a {\n }\");\n-        assert!(str::contains(\n-            doc.cratemod().mods()[0].item.sections[0].body,\n-            \"Body\"));\n+        assert!(doc.cratemod().mods()[0].item.sections[0].body.contains(\"Body\"));\n     }\n \n     #[test]\n@@ -229,12 +225,8 @@ mod test {\n               Body\\\"]\\\n               mod a {\n }\");\n-        assert!(!str::contains(\n-            doc.cratemod().mods()[0].desc().get(),\n-            \"Header\"));\n-        assert!(!str::contains(\n-            doc.cratemod().mods()[0].desc().get(),\n-            \"Body\"));\n+        assert!(!doc.cratemod().mods()[0].desc().get().contains(\"Header\"));\n+        assert!(!doc.cratemod().mods()[0].desc().get().contains(\"Body\"));\n     }\n \n     #[test]"}, {"sha": "1f7a71e0fd8963fbecf7c90fb807ff5bb552ed0b", "filename": "src/librustdoc/text_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftext_pass.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -157,7 +157,7 @@ mod test {\n             let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n             let doc = (desc_to_brief_pass::mk_pass().f)(srv.clone(), doc);\n             let doc = (sectionalize_pass::mk_pass().f)(srv.clone(), doc);\n-            (mk_pass(~\"\", |s| str::trim(s).to_owned() ).f)(srv.clone(), doc)\n+            (mk_pass(~\"\", |s| s.trim().to_owned() ).f)(srv.clone(), doc)\n         }\n     }\n "}, {"sha": "beb246857be725db87d586e334e129e3bd1d5d88", "filename": "src/librustdoc/unindent_pass.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Funindent_pass.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -46,7 +46,7 @@ fn unindent(s: &str) -> ~str {\n         let ignore_previous_indents =\n             saw_first_line &&\n             !saw_second_line &&\n-            !str::is_whitespace(*line);\n+            !line.is_whitespace();\n \n         let min_indent = if ignore_previous_indents {\n             uint::max_value\n@@ -58,12 +58,12 @@ fn unindent(s: &str) -> ~str {\n             saw_second_line = true;\n         }\n \n-        if str::is_whitespace(*line) {\n+        if line.is_whitespace() {\n             min_indent\n         } else {\n             saw_first_line = true;\n             let mut spaces = 0;\n-            do str::all(*line) |char| {\n+            do line.iter().all |char| {\n                 // Only comparing against space because I wouldn't\n                 // know what to do with mixed whitespace chars\n                 if char == ' ' {\n@@ -80,14 +80,14 @@ fn unindent(s: &str) -> ~str {\n     if !lines.is_empty() {\n         let unindented = ~[lines.head().trim().to_owned()]\n             + do lines.tail().map |line| {\n-            if str::is_whitespace(*line) {\n+            if line.is_whitespace() {\n                 copy *line\n             } else {\n-                assert!(str::len(*line) >= min_indent);\n-                str::slice(*line, min_indent, str::len(*line)).to_owned()\n+                assert!(line.len() >= min_indent);\n+                line.slice(min_indent, line.len()).to_owned()\n             }\n         };\n-        str::connect(unindented, \"\\n\")\n+        unindented.connect(\"\\n\")\n     } else {\n         s.to_str()\n     }"}, {"sha": "9cb98dd8c2d83a90abdbf611858c991e005b94d2", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -308,7 +308,7 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n                 println(\"no crates loaded\");\n             } else {\n                 println(fmt!(\"crates loaded: %s\",\n-                                 str::connect(loaded_crates, \", \")));\n+                                 loaded_crates.connect(\", \")));\n             }\n         }\n         ~\"{\" => {\n@@ -318,7 +318,7 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n                 match get_line(use_rl, \"rusti| \") {\n                     None => fail!(\"unterminated multiline command :{ .. :}\"),\n                     Some(line) => {\n-                        if str::trim(line) == \":}\" {\n+                        if line.trim() == \":}\" {\n                             end_multiline = true;\n                         } else {\n                             multiline_cmd += line + \"\\n\";\n@@ -339,9 +339,11 @@ pub fn run_line(repl: &mut Repl, in: @io::Reader, out: @io::Writer, line: ~str,\n                 use_rl: bool)\n     -> Option<Repl> {\n     if line.starts_with(\":\") {\n+        // FIXME #5898: conflicts with Cell.take(), so can't be at the top level\n+        use core::iterator::IteratorUtil;\n+\n         let full = line.substr(1, line.len() - 1);\n-        let mut split = ~[];\n-        for str::each_word(full) |word| { split.push(word.to_owned()) }\n+        let split: ~[~str] = full.word_iter().transform(|s| s.to_owned()).collect();\n         let len = split.len();\n \n         if len > 0 {"}, {"sha": "c039eeacbe47a96a85e88700dde576ea6937a327", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -17,6 +17,7 @@ pub use target::{OutputType, Main, Lib, Test, Bench, Target, Build, Install};\n use core::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n use core::os::mkdir_recursive;\n use core::os;\n+use core::iterator::IteratorUtil;\n \n /// Returns the value of RUST_PATH, as a list\n /// of Paths. In general this should be read from the\n@@ -166,7 +167,7 @@ fn library_in_workspace(full_name: &str, short_name: &str, where: Target,\n         let f_name = match p_path.filename() {\n             Some(s) => s, None => loop\n         };\n-        for f_name.each_split_char('-') |piece| {\n+        for f_name.split_iter('-').advance |piece| {\n             debug!(\"a piece = %s\", piece);\n             if which == 0 && piece != lib_prefix {\n                 break;"}, {"sha": "2db51fe969fc415d8061f96d803947d8053545f6", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -29,6 +29,7 @@ extern mod syntax;\n \n use core::prelude::*;\n use core::*;\n+use core::iterator::IteratorUtil;\n pub use core::path::Path;\n use core::hashmap::HashMap;\n use rustc::driver::{driver, session};\n@@ -161,10 +162,8 @@ impl<'self> PkgScript<'self> {\n                            exe.to_str(), root.to_str(), \"configs\");\n                     let output = run::process_output(exe.to_str(), [root.to_str(), ~\"configs\"]);\n                     // Run the configs() function to get the configs\n-                    let mut cfgs = ~[];\n-                    for str::each_word(str::from_bytes(output.output)) |w| {\n-                        cfgs.push(w.to_owned());\n-                    }\n+                    let cfgs = str::from_bytes_slice(output.output).word_iter()\n+                        .transform(|w| w.to_owned()).collect();\n                     (cfgs, output.status)\n                 }\n             }"}, {"sha": "75e2c3fd4645495f7c1d55486094cb6a5a6208a5", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -207,8 +207,8 @@ pub fn compile_input(ctxt: &Ctx,\n \n     let binary = @(copy os::args()[0]);\n \n-    debug!(\"flags: %s\", str::connect(flags, \" \"));\n-    debug!(\"cfgs: %s\", str::connect(cfgs, \" \"));\n+    debug!(\"flags: %s\", flags.connect(\" \"));\n+    debug!(\"cfgs: %s\", cfgs.connect(\" \"));\n     debug!(\"compile_input's sysroot = %?\", ctxt.sysroot_opt);\n \n     let crate_type = match what {"}, {"sha": "0900d93e498f354bbda22955364b09467d57dc28", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -15,6 +15,7 @@ extern mod std;\n \n use extra::semver;\n use core::prelude::*;\n+use core::iterator::IteratorUtil;\n use core::{char, os, result, run, str};\n use package_path::RemotePath;\n use extra::tempfile::mkdtemp;\n@@ -112,7 +113,7 @@ pub fn try_getting_version(remote_path: &RemotePath) -> Option<Version> {\n                                             ~\"tag\", ~\"-l\"]);\n             let output_text = str::from_bytes(outp.output);\n             debug!(\"Full output: ( %s ) [%?]\", output_text, outp.status);\n-            for output_text.each_split_char('\\n') |l| {\n+            for output_text.line_iter().advance |l| {\n                 debug!(\"A line of output: %s\", l);\n                 if !l.is_whitespace() {\n                     output = Some(l);\n@@ -142,8 +143,7 @@ fn try_parsing_version(s: &str) -> Option<Version> {\n     let s = s.trim();\n     debug!(\"Attempting to parse: %s\", s);\n     let mut parse_state = Start;\n-    // I gave up on using external iterators (tjc)\n-    for str::to_chars(s).each() |&c| {\n+    for s.iter().advance |c| {\n         if char::is_digit(c) {\n             parse_state = SawDigit;\n         }\n@@ -162,22 +162,19 @@ fn try_parsing_version(s: &str) -> Option<Version> {\n \n /// Just an approximation\n fn is_url_like(p: &RemotePath) -> bool {\n-    let mut n = 0;\n-    for p.to_str().each_split_char('/') |_| {\n-        n += 1;\n-    }\n-    n > 2\n+    let str = p.to_str();\n+    str.split_iter('/').count() > 2\n }\n \n /// If s is of the form foo#bar, where bar is a valid version\n /// number, return the prefix before the # and the version.\n /// Otherwise, return None.\n pub fn split_version<'a>(s: &'a str) -> Option<(&'a str, Version)> {\n     // reject strings with multiple '#'s\n-    if { let mut i: uint = 0; for str::to_chars(s).each |&c| { if c == '#' { i += 1; } }; i > 1 } {\n+    if s.splitn_iter('#', 2).count() > 2 {\n         return None;\n     }\n-    match str::rfind_char(s, '#') {\n+    match s.rfind('#') {\n         Some(i) => {\n             debug!(\"in %s, i = %?\", s, i);\n             let path = s.slice(0, i);"}, {"sha": "58711360c35644189f96e1de26a73c69169ec96c", "filename": "src/libstd/io.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -672,7 +672,7 @@ impl<T:Reader> ReaderUtil for T {\n                     val <<= 6;\n                     val += (next & 63) as uint;\n                 }\n-                // See str::char_at\n+                // See str::StrSlice::char_at\n                 val += ((b0 << ((w + 1) as u8)) as uint)\n                     << (w - 1) * 6 - w - 1u;\n                 chars.push(val as char);\n@@ -748,7 +748,7 @@ impl<T:Reader> ReaderUtil for T {\n             if self.eof() && line.is_empty() { break; }\n \n             // trim the \\n, so that each_line is consistent with read_line\n-            let n = str::len(line);\n+            let n = line.len();\n             if line[n-1] == '\\n' as u8 {\n                 unsafe { str::raw::set_len(&mut line, n-1); }\n             }\n@@ -1836,7 +1836,6 @@ mod tests {\n     use io;\n     use path::Path;\n     use result;\n-    use str;\n     use u64;\n     use vec;\n \n@@ -1979,7 +1978,7 @@ mod tests {\n     fn file_writer_bad_name() {\n         match io::file_writer(&Path(\"?/?\"), []) {\n           result::Err(e) => {\n-            assert!(str::starts_with(e, \"error opening\"));\n+            assert!(e.starts_with(\"error opening\"));\n           }\n           result::Ok(_) => fail!()\n         }\n@@ -1989,7 +1988,7 @@ mod tests {\n     fn buffered_file_writer_bad_name() {\n         match io::buffered_file_writer(&Path(\"?/?\")) {\n           result::Err(e) => {\n-            assert!(str::starts_with(e, \"error opening\"));\n+            assert!(e.starts_with(\"error opening\"));\n           }\n           result::Ok(_) => fail!()\n         }"}, {"sha": "ab8965a679691ba01e1945db6f197f33bfa46397", "filename": "src/libstd/os.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -30,6 +30,7 @@\n \n use cast;\n use io;\n+use iterator::IteratorUtil;\n use libc;\n use libc::{c_char, c_void, c_int, size_t};\n use libc::{mode_t, FILE};\n@@ -224,12 +225,11 @@ pub fn env() -> ~[(~str,~str)] {\n         fn env_convert(input: ~[~str]) -> ~[(~str, ~str)] {\n             let mut pairs = ~[];\n             for input.each |p| {\n-                let mut vs = ~[];\n-                for str::each_splitn_char(*p, '=', 1) |s| { vs.push(s.to_owned()) }\n+                let vs: ~[&str] = p.splitn_iter('=', 1).collect();\n                 debug!(\"splitting: len: %u\",\n                     vs.len());\n                 assert_eq!(vs.len(), 2);\n-                pairs.push((copy vs[0], copy vs[1]));\n+                pairs.push((vs[0].to_owned(), vs[1].to_owned()));\n             }\n             pairs\n         }\n@@ -525,7 +525,7 @@ pub fn self_exe_path() -> Option<Path> {\n  */\n pub fn homedir() -> Option<Path> {\n     return match getenv(\"HOME\") {\n-        Some(ref p) => if !str::is_empty(*p) {\n+        Some(ref p) => if !p.is_empty() {\n           Some(Path(*p))\n         } else {\n           secondary()\n@@ -541,7 +541,7 @@ pub fn homedir() -> Option<Path> {\n     #[cfg(windows)]\n     fn secondary() -> Option<Path> {\n         do getenv(~\"USERPROFILE\").chain |p| {\n-            if !str::is_empty(p) {\n+            if !p.is_empty() {\n                 Some(Path(p))\n             } else {\n                 None\n@@ -566,7 +566,7 @@ pub fn tmpdir() -> Path {\n     fn getenv_nonempty(v: &str) -> Option<Path> {\n         match getenv(v) {\n             Some(x) =>\n-                if str::is_empty(x) {\n+                if x.is_empty() {\n                     None\n                 } else {\n                     Some(Path(x))\n@@ -1449,6 +1449,7 @@ mod tests {\n     use rand;\n     use run;\n     use str;\n+    use str::StrSlice;\n     use vec;\n     use libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n \n@@ -1606,7 +1607,7 @@ mod tests {\n \n     #[test]\n     fn tmpdir() {\n-        assert!(!str::is_empty(os::tmpdir().to_str()));\n+        assert!(!os::tmpdir().to_str().is_empty());\n     }\n \n     // Issue #712\n@@ -1671,7 +1672,7 @@ mod tests {\n         unsafe {\n           let tempdir = getcwd(); // would like to use $TMPDIR,\n                                   // doesn't seem to work on Linux\n-          assert!((str::len(tempdir.to_str()) > 0u));\n+          assert!((tempdir.to_str().len() > 0u));\n           let in = tempdir.push(\"in.txt\");\n           let out = tempdir.push(\"out.txt\");\n \n@@ -1686,7 +1687,7 @@ mod tests {\n           let mut buf = str::to_bytes(s) + [0 as u8];\n           do vec::as_mut_buf(buf) |b, _len| {\n               assert!((libc::fwrite(b as *c_void, 1u as size_t,\n-                                   (str::len(s) + 1u) as size_t, ostream)\n+                                   (s.len() + 1u) as size_t, ostream)\n                       == buf.len() as size_t))\n           }\n           assert_eq!(libc::fclose(ostream), (0u as c_int));"}, {"sha": "d62fc8c2cbafdadfdc1282d785e89aecff1d10aa", "filename": "src/libstd/path.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -18,10 +18,11 @@ Cross-platform file path handling\n \n use container::Container;\n use cmp::Eq;\n+use iterator::IteratorUtil;\n use libc;\n use option::{None, Option, Some};\n use str;\n-use str::StrSlice;\n+use str::{StrSlice, StrVector};\n use to_str::ToStr;\n use ascii::{AsciiCast, AsciiStr};\n use old_iter::BaseIter;\n@@ -441,18 +442,17 @@ impl ToStr for PosixPath {\n         if self.is_absolute {\n             s += \"/\";\n         }\n-        s + str::connect(self.components, \"/\")\n+        s + self.components.connect(\"/\")\n     }\n }\n \n // FIXME (#3227): when default methods in traits are working, de-duplicate\n // PosixPath and WindowsPath, most of their methods are common.\n impl GenericPath for PosixPath {\n     fn from_str(s: &str) -> PosixPath {\n-        let mut components = ~[];\n-        for str::each_split_nonempty(s, |c| c == '/') |s| {\n-            components.push(s.to_owned())\n-        }\n+        let components = s.split_iter('/')\n+            .filter_map(|s| if s.is_empty() {None} else {Some(s.to_owned())})\n+            .collect();\n         let is_absolute = (s.len() != 0 && s[0] == '/' as u8);\n         PosixPath {\n             is_absolute: is_absolute,\n@@ -479,8 +479,8 @@ impl GenericPath for PosixPath {\n         match self.filename() {\n             None => None,\n             Some(ref f) => {\n-                match str::rfind_char(*f, '.') {\n-                    Some(p) => Some(f.slice(0, p).to_owned()),\n+                match f.rfind('.') {\n+                    Some(p) => Some(f.slice_to(p).to_owned()),\n                     None => Some(copy *f),\n                 }\n             }\n@@ -491,8 +491,8 @@ impl GenericPath for PosixPath {\n         match self.filename() {\n             None => None,\n             Some(ref f) => {\n-                match str::rfind_char(*f, '.') {\n-                    Some(p) if p < f.len() => Some(f.slice(p, f.len()).to_owned()),\n+                match f.rfind('.') {\n+                    Some(p) if p < f.len() => Some(f.slice_from(p).to_owned()),\n                     _ => None,\n                 }\n             }\n@@ -508,7 +508,7 @@ impl GenericPath for PosixPath {\n     }\n \n     fn with_filename(&self, f: &str) -> PosixPath {\n-        assert!(! str::any(f, |c| windows::is_sep(c as u8)));\n+        assert!(! f.iter().all(windows::is_sep));\n         self.dir_path().push(f)\n     }\n \n@@ -569,11 +569,11 @@ impl GenericPath for PosixPath {\n     fn push_many(&self, cs: &[~str]) -> PosixPath {\n         let mut v = copy self.components;\n         for cs.each |e| {\n-            let mut ss = ~[];\n-            for str::each_split_nonempty(*e, |c| windows::is_sep(c as u8)) |s| {\n-                ss.push(s.to_owned())\n+            for e.split_iter(windows::is_sep).advance |s| {\n+                if !s.is_empty() {\n+                    v.push(s.to_owned())\n+                }\n             }\n-            v.push_all_move(ss);\n         }\n         PosixPath {\n             is_absolute: self.is_absolute,\n@@ -583,11 +583,11 @@ impl GenericPath for PosixPath {\n \n     fn push(&self, s: &str) -> PosixPath {\n         let mut v = copy self.components;\n-        let mut ss = ~[];\n-        for str::each_split_nonempty(s, |c| windows::is_sep(c as u8)) |s| {\n-            ss.push(s.to_owned())\n+        for s.split_iter(windows::is_sep).advance |s| {\n+            if !s.is_empty() {\n+                v.push(s.to_owned())\n+            }\n         }\n-        v.push_all_move(ss);\n         PosixPath { components: v, ..copy *self }\n     }\n \n@@ -629,7 +629,7 @@ impl ToStr for WindowsPath {\n         if self.is_absolute {\n             s += \"\\\\\";\n         }\n-        s + str::connect(self.components, \"\\\\\")\n+        s + self.components.connect(\"\\\\\")\n     }\n }\n \n@@ -661,11 +661,11 @@ impl GenericPath for WindowsPath {\n             }\n         }\n \n-        let mut components = ~[];\n-        for str::each_split_nonempty(rest, |c| windows::is_sep(c as u8)) |s| {\n-            components.push(s.to_owned())\n-        }\n-        let is_absolute = (rest.len() != 0 && windows::is_sep(rest[0]));\n+        let components = rest.split_iter(windows::is_sep)\n+            .filter_map(|s| if s.is_empty() {None} else {Some(s.to_owned())})\n+            .collect();\n+\n+        let is_absolute = (rest.len() != 0 && windows::is_sep(rest[0] as char));\n         WindowsPath {\n             host: host,\n             device: device,\n@@ -693,8 +693,8 @@ impl GenericPath for WindowsPath {\n         match self.filename() {\n             None => None,\n             Some(ref f) => {\n-                match str::rfind_char(*f, '.') {\n-                    Some(p) => Some(f.slice(0, p).to_owned()),\n+                match f.rfind('.') {\n+                    Some(p) => Some(f.slice_to(p).to_owned()),\n                     None => Some(copy *f),\n                 }\n             }\n@@ -705,8 +705,8 @@ impl GenericPath for WindowsPath {\n         match self.filename() {\n           None => None,\n           Some(ref f) => {\n-            match str::rfind_char(*f, '.') {\n-                Some(p) if p < f.len() => Some(f.slice(p, f.len()).to_owned()),\n+            match f.rfind('.') {\n+                Some(p) if p < f.len() => Some(f.slice_from(p).to_owned()),\n                 _ => None,\n             }\n           }\n@@ -722,7 +722,7 @@ impl GenericPath for WindowsPath {\n     }\n \n     fn with_filename(&self, f: &str) -> WindowsPath {\n-        assert!(! str::any(f, |c| windows::is_sep(c as u8)));\n+        assert!(! f.iter().all(windows::is_sep));\n         self.dir_path().push(f)\n     }\n \n@@ -826,11 +826,11 @@ impl GenericPath for WindowsPath {\n     fn push_many(&self, cs: &[~str]) -> WindowsPath {\n         let mut v = copy self.components;\n         for cs.each |e| {\n-            let mut ss = ~[];\n-            for str::each_split_nonempty(*e, |c| windows::is_sep(c as u8)) |s| {\n-                ss.push(s.to_owned())\n+            for e.split_iter(windows::is_sep).advance |s| {\n+                if !s.is_empty() {\n+                    v.push(s.to_owned())\n+                }\n             }\n-            v.push_all_move(ss);\n         }\n         // tedious, but as-is, we can't use ..self\n         WindowsPath {\n@@ -843,11 +843,11 @@ impl GenericPath for WindowsPath {\n \n     fn push(&self, s: &str) -> WindowsPath {\n         let mut v = copy self.components;\n-        let mut ss = ~[];\n-        for str::each_split_nonempty(s, |c| windows::is_sep(c as u8)) |s| {\n-            ss.push(s.to_owned())\n+        for s.split_iter(windows::is_sep).advance |s| {\n+            if !s.is_empty() {\n+                v.push(s.to_owned())\n+            }\n         }\n-        v.push_all_move(ss);\n         WindowsPath { components: v, ..copy *self }\n     }\n \n@@ -905,8 +905,8 @@ pub mod windows {\n     use option::{None, Option, Some};\n \n     #[inline(always)]\n-    pub fn is_sep(u: u8) -> bool {\n-        u == '/' as u8 || u == '\\\\' as u8\n+    pub fn is_sep(u: char) -> bool {\n+        u == '/' || u == '\\\\'\n     }\n \n     pub fn extract_unc_prefix(s: &str) -> Option<(~str,~str)> {\n@@ -915,7 +915,7 @@ pub mod windows {\n             s[0] == s[1]) {\n             let mut i = 2;\n             while i < s.len() {\n-                if is_sep(s[i]) {\n+                if is_sep(s[i] as char) {\n                     let pre = s.slice(2, i).to_owned();\n                     let rest = s.slice(i, s.len()).to_owned();\n                     return Some((pre, rest));"}, {"sha": "41bc573f10d3f3cdbe309100efb6394292d8e7a2", "filename": "src/libstd/run.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -12,6 +12,7 @@\n \n #[allow(missing_doc)];\n \n+use iterator::IteratorUtil;\n use cast;\n use comm::{stream, SharedChan, GenericChan, GenericPort};\n use int;\n@@ -588,7 +589,7 @@ pub fn make_command_line(prog: &str, args: &[~str]) -> ~str {\n     return cmd;\n \n     fn append_arg(cmd: &mut ~str, arg: &str) {\n-        let quote = arg.any(|c| c == ' ' || c == '\\t');\n+        let quote = arg.iter().any(|c| c == ' ' || c == '\\t');\n         if quote {\n             cmd.push_char('\"');\n         }"}, {"sha": "8cd69f32e4969b1dcdbc112edd1a8148ea8e6014", "filename": "src/libstd/str.rs", "status": "modified", "additions": 1023, "deletions": 1746, "changes": 2769, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=1310212c27c1c294e1f907b05a225440c987a912"}, {"sha": "618d5095777a91ccb6b3766e0b0262ad7fb46b2a", "filename": "src/libstd/str/ascii.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibstd%2Fstr%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibstd%2Fstr%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr%2Fascii.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -202,7 +202,6 @@ impl ToStrConsume for ~[Ascii] {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use str;\n \n     macro_rules! v2ascii (\n         ( [$($e:expr),*]) => ( [$(Ascii{chr:$e}),*]);\n@@ -226,8 +225,8 @@ mod tests {\n         assert_eq!('`'.to_ascii().to_upper().to_char(), '`');\n         assert_eq!('{'.to_ascii().to_upper().to_char(), '{');\n \n-        assert!(str::all(\"banana\", |c| c.is_ascii()));\n-        assert!(! str::all(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", |c| c.is_ascii()));\n+        assert!(\"banana\".iter().all(|c| c.is_ascii()));\n+        assert!(!\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".iter().all(|c| c.is_ascii()));\n     }\n \n     #[test]"}, {"sha": "9b74119b08cb5a9a0ed9bf22c733ffa35ba53f3c", "filename": "src/libstd/unstable/extfmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibstd%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibstd%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fextfmt.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -547,7 +547,7 @@ pub mod rt {\n         let unpadded = match cv.precision {\n           CountImplied => s,\n           CountIs(max) => if (max as uint) < str::char_len(s) {\n-            str::slice(s, 0, max as uint)\n+            s.slice(0, max as uint)\n           } else {\n             s\n           }"}, {"sha": "e75cf2c01c6755bc8658975b21939ed6503d7dd7", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -136,10 +136,10 @@ unsafe fn fail_borrowed(box: *mut BoxRepr, file: *c_char, line: size_t) {\n             let mut sep = \" at \";\n             for borrow_list.rev_iter().advance |entry| {\n                 if entry.box == box {\n-                    str::push_str(&mut msg, sep);\n+                    msg.push_str(sep);\n                     let filename = str::raw::from_c_str(entry.file);\n-                    str::push_str(&mut msg, filename);\n-                    str::push_str(&mut msg, fmt!(\":%u\", entry.line as uint));\n+                    msg.push_str(filename);\n+                    msg.push_str(fmt!(\":%u\", entry.line as uint));\n                     sep = \" and at \";\n                 }\n             }"}, {"sha": "53729dbd1157d2c3ebf7fd63b1624eeb09c625f0", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -10,7 +10,6 @@\n \n use core::prelude::*;\n \n-use core::str;\n use core::to_bytes;\n \n #[deriving(Eq)]\n@@ -267,7 +266,7 @@ impl ToStr for AbiSet {\n         for self.each |abi| {\n             strs.push(abi.data().name);\n         }\n-        fmt!(\"\\\"%s\\\"\", str::connect_slices(strs, \" \"))\n+        fmt!(\"\\\"%s\\\"\", strs.connect(\" \"))\n     }\n }\n "}, {"sha": "2e60f7d02dfbc56ab2f86ac8aa94ad637e87255d", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -24,7 +24,6 @@ use syntax::parse::token::special_idents;\n \n use core::cmp;\n use core::hashmap::HashMap;\n-use core::str;\n use core::vec;\n \n pub enum path_elt {\n@@ -62,7 +61,7 @@ pub fn path_to_str_with_sep(p: &[path_elt], sep: &str, itr: @ident_interner)\n           path_name(s) => copy *itr.get(s.name)\n         }\n     };\n-    str::connect(strs, sep)\n+    strs.connect(sep)\n }\n \n pub fn path_ident_to_str(p: &path, i: ident, itr: @ident_interner) -> ~str {"}, {"sha": "3d6269942fd5b4b2f837c40d24201ff0f8600333", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -23,12 +23,11 @@ use visit;\n use core::hashmap::HashMap;\n use core::int;\n use core::option;\n-use core::str;\n use core::to_bytes;\n \n pub fn path_name_i(idents: &[ident]) -> ~str {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n-    str::connect(idents.map(|i| copy *token::interner_get(i.name)), \"::\")\n+    idents.map(|i| copy *token::interner_get(i.name)).connect(\"::\")\n }\n \n pub fn path_to_ident(p: @Path) -> ident { copy *p.idents.last() }"}, {"sha": "68403b2c608598f78d2ad24e4a74a7e2cd1812e0", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -24,7 +24,6 @@ source code snippets, etc.\n use core::prelude::*;\n \n use core::cmp;\n-use core::str;\n use core::to_bytes;\n use core::uint;\n use extra::serialize::{Encodable, Decodable, Encoder, Decoder};\n@@ -288,11 +287,11 @@ impl FileMap {\n     pub fn get_line(&self, line: int) -> ~str {\n         let begin: BytePos = self.lines[line] - self.start_pos;\n         let begin = begin.to_uint();\n-        let end = match str::find_char_from(*self.src, '\\n', begin) {\n-            Some(e) => e,\n-            None => str::len(*self.src)\n-        };\n-        str::slice(*self.src, begin, end).to_owned()\n+        let slice = self.src.slice_from(begin);\n+        match slice.find('\\n') {\n+            Some(e) => slice.slice_to(e).to_owned(),\n+            None => slice.to_owned()\n+        }\n     }\n \n     pub fn record_multibyte_char(&self, pos: BytePos, bytes: uint) {\n@@ -418,7 +417,7 @@ impl CodeMap {\n         let begin = self.lookup_byte_offset(sp.lo);\n         let end = self.lookup_byte_offset(sp.hi);\n         assert_eq!(begin.fm.start_pos, end.fm.start_pos);\n-        return str::slice(*begin.fm.src,\n+        return begin.fm.src.slice(\n                           begin.pos.to_uint(), end.pos.to_uint()).to_owned();\n     }\n "}, {"sha": "58b01fe78e7b8dcc020cb5df633e89ca9aace28c", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -14,7 +14,6 @@ use codemap::{Pos, span};\n use codemap;\n \n use core::io;\n-use core::str;\n use core::uint;\n use core::vec;\n use extra::term;\n@@ -259,7 +258,7 @@ fn highlight_lines(cm: @codemap::CodeMap,\n     if elided {\n         let last_line = display_lines[display_lines.len() - 1u];\n         let s = fmt!(\"%s:%u \", fm.name, last_line + 1u);\n-        let mut indent = str::len(s);\n+        let mut indent = s.len();\n         let mut out = ~\"\";\n         while indent > 0u { out += \" \"; indent -= 1u; }\n         out += \"...\\n\";\n@@ -277,11 +276,11 @@ fn highlight_lines(cm: @codemap::CodeMap,\n         while num > 0u { num /= 10u; digits += 1u; }\n \n         // indent past |name:## | and the 0-offset column location\n-        let left = str::len(fm.name) + digits + lo.col.to_uint() + 3u;\n+        let left = fm.name.len() + digits + lo.col.to_uint() + 3u;\n         let mut s = ~\"\";\n         // Skip is the number of characters we need to skip because they are\n         // part of the 'filename:line ' part of the previous line.\n-        let skip = str::len(fm.name) + digits + 3u;\n+        let skip = fm.name.len() + digits + 3u;\n         for skip.times() {\n             s += \" \";\n         }"}, {"sha": "d3efd07aa045d5d372f647411564ea2a7ab6104c", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -21,7 +21,6 @@ use ext::base::*;\n use parse;\n use parse::token;\n \n-use core::str;\n use core::vec;\n \n enum State {\n@@ -120,7 +119,7 @@ pub fn expand_asm(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n                     clobs.push(clob);\n                 }\n \n-                cons = str::connect(clobs, \",\");\n+                cons = clobs.connect(\",\");\n             }\n             Options => {\n                 let option = p.parse_str();"}, {"sha": "b2ec3684b70e0c64c05b72570ed49f58bad08fc0", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -276,6 +276,9 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n                     stms.push(cx.stmt_let(fmt_sp, npieces > 1,\n                                           ident, cx.expr_str_uniq(fmt_sp, s)));\n                 } else {\n+                    // we call the push_str function because the\n+                    // bootstrap doesnt't seem to work if we call the\n+                    // method.\n                     let args = ~[cx.expr_mut_addr_of(fmt_sp, buf()), cx.expr_str(fmt_sp, s)];\n                     let call = cx.expr_call_global(fmt_sp,\n                                                    ~[core_ident,"}, {"sha": "1076c5d0b98f593e5e93471a7772cb232ea221de", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -42,7 +42,6 @@ use core::prelude::*;\n use ext::base::ExtCtxt;\n use ext::pipes::proto::{protocol_};\n \n-use core::str;\n use extra::bitv::Bitv;\n \n pub fn analyze(proto: @mut protocol_, _cx: @ExtCtxt) {\n@@ -88,7 +87,7 @@ pub fn analyze(proto: @mut protocol_, _cx: @ExtCtxt) {\n     }\n \n     if self_live.len() > 0 {\n-        let states = str::connect(self_live.map(|s| copy s.name), \" \");\n+        let states = self_live.map(|s| copy s.name).connect(\" \");\n \n         debug!(\"protocol %s is unbounded due to loops involving: %s\",\n                copy proto.name, states);"}, {"sha": "304c496bbf4d8f3a99cb1462eb9662d2a1301a0d", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -24,7 +24,6 @@ use opt_vec;\n use opt_vec::OptVec;\n \n use core::iterator::IteratorUtil;\n-use core::str;\n use core::vec;\n \n pub trait gen_send {\n@@ -100,9 +99,9 @@ impl gen_send for message {\n             }\n             body += fmt!(\"let message = %s(%s);\\n\",\n                          name,\n-                         str::connect(vec::append_one(\n-                           arg_names.map(|x| cx.str_of(*x)),\n-                             ~\"s\"), \", \"));\n+                         vec::append_one(\n+                             arg_names.map(|x| cx.str_of(*x)),\n+                             ~\"s\").connect(\", \"));\n \n             if !try {\n                 body += fmt!(\"::std::pipes::send(pipe, message);\\n\");\n@@ -155,8 +154,7 @@ impl gen_send for message {\n                     ~\"\"\n                 }\n                 else {\n-                    ~\"(\" + str::connect(arg_names.map(|x| copy *x),\n-                                        \", \") + \")\"\n+                    ~\"(\" + arg_names.map(|x| copy *x).connect(\", \") + \")\"\n                 };\n \n                 let mut body = ~\"{ \";"}, {"sha": "2c6f40091ac9f0e120a1eeb6301362a0561c5bc0", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -92,7 +92,7 @@ pub mod rt {\n \n     impl<'self> ToSource for &'self [@ast::item] {\n         fn to_source(&self) -> ~str {\n-            str::connect(self.map(|i| i.to_source()), \"\\n\\n\")\n+            self.map(|i| i.to_source()).connect(\"\\n\\n\")\n         }\n     }\n \n@@ -104,7 +104,7 @@ pub mod rt {\n \n     impl<'self> ToSource for &'self [@ast::Ty] {\n         fn to_source(&self) -> ~str {\n-            str::connect(self.map(|i| i.to_source()), \", \")\n+            self.map(|i| i.to_source()).connect(\", \")\n         }\n     }\n "}, {"sha": "79018ebd1eadcc9c2768b43682c3ed82d238dc26", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -23,7 +23,6 @@ use print::pprust;\n \n use core::io;\n use core::result;\n-use core::str;\n use core::vec;\n \n // These macros all relate to the file system; they either return\n@@ -74,8 +73,7 @@ pub fn expand_mod(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n     base::MRExpr(cx.expr_str(sp,\n-                              str::connect(cx.mod_path().map(\n-                                  |x| cx.str_of(*x)), \"::\")))\n+                             cx.mod_path().map(|x| cx.str_of(*x)).connect(\"::\")))\n }\n \n // include! : parse the given file as an expr"}, {"sha": "e5a77cc21fb8df7151764cd246252694475231e4", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -24,7 +24,6 @@ use parse::token;\n \n use core::iterator::IteratorUtil;\n use core::hashmap::HashMap;\n-use core::str;\n use core::uint;\n use core::vec;\n \n@@ -371,14 +370,14 @@ pub fn parse(\n         } else {\n             if (bb_eis.len() > 0u && next_eis.len() > 0u)\n                 || bb_eis.len() > 1u {\n-                let nts = str::connect(vec::map(bb_eis, |ei| {\n+                let nts = bb_eis.map(|ei| {\n                     match ei.elts[ei.idx].node {\n                       match_nonterminal(ref bind,ref name,_) => {\n                         fmt!(\"%s ('%s')\", *ident_to_str(name),\n                              *ident_to_str(bind))\n                       }\n                       _ => fail!()\n-                    } }), \" or \");\n+                    } }).connect(\" or \");\n                 return error(sp, fmt!(\n                     \"Local ambiguity: multiple parsing options: \\\n                      built-in NTs %s or %u other options.\","}, {"sha": "a6933c1648313a25c50d17377143331094d62e94", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -116,7 +116,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n         let lines = block_trim(lines, ~\"\\t \", None);\n         let lines = block_trim(lines, ~\"*\", Some(1u));\n         let lines = block_trim(lines, ~\"\\t \", None);\n-        return str::connect(lines, \"\\n\");\n+        return lines.connect(\"\\n\");\n     }\n \n     fail!(\"not a doc-comment: %s\", comment);\n@@ -125,7 +125,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n fn read_to_eol(rdr: @mut StringReader) -> ~str {\n     let mut val = ~\"\";\n     while rdr.curr != '\\n' && !is_eof(rdr) {\n-        str::push_char(&mut val, rdr.curr);\n+        val.push_char(rdr.curr);\n         bump(rdr);\n     }\n     if rdr.curr == '\\n' { bump(rdr); }\n@@ -215,7 +215,7 @@ fn trim_whitespace_prefix_and_push_line(lines: &mut ~[~str],\n     let col = col.to_uint();\n     let s1 = if all_whitespace(s, 0, uint::min(len, col)) {\n         if col < len {\n-            str::slice(s, col, len).to_owned()\n+            s.slice(col, len).to_owned()\n         } else {  ~\"\" }\n     } else { s };\n     debug!(\"pushing line: %s\", s1);\n@@ -237,7 +237,7 @@ fn read_block_comment(rdr: @mut StringReader,\n     // doc-comments are not really comments, they are attributes\n     if rdr.curr == '*' || rdr.curr == '!' {\n         while !(rdr.curr == '*' && nextch(rdr) == '/') && !is_eof(rdr) {\n-            str::push_char(&mut curr_line, rdr.curr);\n+            curr_line.push_char(rdr.curr);\n             bump(rdr);\n         }\n         if !is_eof(rdr) {\n@@ -261,7 +261,7 @@ fn read_block_comment(rdr: @mut StringReader,\n                 curr_line = ~\"\";\n                 bump(rdr);\n             } else {\n-                str::push_char(&mut curr_line, rdr.curr);\n+                curr_line.push_char(rdr.curr);\n                 if rdr.curr == '/' && nextch(rdr) == '*' {\n                     bump(rdr);\n                     bump(rdr);\n@@ -277,7 +277,7 @@ fn read_block_comment(rdr: @mut StringReader,\n                 }\n             }\n         }\n-        if str::len(curr_line) != 0 {\n+        if curr_line.len() != 0 {\n             trim_whitespace_prefix_and_push_line(&mut lines, curr_line, col);\n         }\n     }"}, {"sha": "002a6caf85c5f420e23ab70f7088af724c1fde02", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -19,9 +19,9 @@ use ext::tt::transcribe::{dup_tt_reader};\n use parse::token;\n use parse::token::{str_to_ident};\n \n+use core::iterator::IteratorUtil;\n use core::char;\n use core::either;\n-use core::str;\n use core::u64;\n \n pub use ext::tt::transcribe::{TtReader, new_tt_reader};\n@@ -179,7 +179,7 @@ pub fn bump(rdr: &mut StringReader) {\n     if current_byte_offset < (*rdr.src).len() {\n         assert!(rdr.curr != -1 as char);\n         let last_char = rdr.curr;\n-        let next = str::char_range_at(*rdr.src, current_byte_offset);\n+        let next = rdr.src.char_range_at(current_byte_offset);\n         let byte_offset_diff = next.next - current_byte_offset;\n         rdr.pos = rdr.pos + BytePos(byte_offset_diff);\n         rdr.curr = next.ch;\n@@ -203,7 +203,7 @@ pub fn is_eof(rdr: @mut StringReader) -> bool {\n pub fn nextch(rdr: @mut StringReader) -> char {\n     let offset = byte_offset(rdr, rdr.pos).to_uint();\n     if offset < (*rdr.src).len() {\n-        return str::char_at(*rdr.src, offset);\n+        return rdr.src.char_at(offset);\n     } else { return -1 as char; }\n }\n \n@@ -245,7 +245,7 @@ fn consume_whitespace_and_comments(rdr: @mut StringReader)\n \n pub fn is_line_non_doc_comment(s: &str) -> bool {\n     let s = s.trim_right();\n-    s.len() > 3 && s.all(|ch| ch == '/')\n+    s.len() > 3 && s.iter().all(|ch| ch == '/')\n }\n \n // PRECONDITION: rdr.curr is not whitespace\n@@ -306,7 +306,7 @@ fn consume_any_line_comment(rdr: @mut StringReader)\n \n pub fn is_block_non_doc_comment(s: &str) -> bool {\n     assert!(s.len() >= 1u);\n-    str::all_between(s, 1u, s.len() - 1u, |ch| ch == '*')\n+    s.slice(1u, s.len() - 1u).iter().all(|ch| ch == '*')\n }\n \n // might return a sugared-doc-attr\n@@ -357,15 +357,15 @@ fn scan_exponent(rdr: @mut StringReader) -> Option<~str> {\n     let mut c = rdr.curr;\n     let mut rslt = ~\"\";\n     if c == 'e' || c == 'E' {\n-        str::push_char(&mut rslt, c);\n+        rslt.push_char(c);\n         bump(rdr);\n         c = rdr.curr;\n         if c == '-' || c == '+' {\n-            str::push_char(&mut rslt, c);\n+            rslt.push_char(c);\n             bump(rdr);\n         }\n         let exponent = scan_digits(rdr, 10u);\n-        if str::len(exponent) > 0u {\n+        if exponent.len() > 0u {\n             return Some(rslt + exponent);\n         } else { rdr.fatal(~\"scan_exponent: bad fp literal\"); }\n     } else { return None::<~str>; }\n@@ -378,7 +378,7 @@ fn scan_digits(rdr: @mut StringReader, radix: uint) -> ~str {\n         if c == '_' { bump(rdr); loop; }\n         match char::to_digit(c, radix) {\n           Some(_) => {\n-            str::push_char(&mut rslt, c);\n+            rslt.push_char(c);\n             bump(rdr);\n           }\n           _ => return rslt\n@@ -433,7 +433,7 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n             tp = if signed { either::Left(ast::ty_i64) }\n                       else { either::Right(ast::ty_u64) };\n         }\n-        if str::len(num_str) == 0u {\n+        if num_str.len() == 0u {\n             rdr.fatal(~\"no valid digits found for number\");\n         }\n         let parsed = match u64::from_str_radix(num_str, base as uint) {\n@@ -498,7 +498,7 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n         }\n         return token::LIT_FLOAT_UNSUFFIXED(str_to_ident(num_str));\n     } else {\n-        if str::len(num_str) == 0u {\n+        if num_str.len() == 0u {\n             rdr.fatal(~\"no valid digits found for number\");\n         }\n         let parsed = match u64::from_str_radix(num_str, base as uint) {\n@@ -547,7 +547,7 @@ fn ident_continue(c: char) -> bool {\n // EFFECT: advances the input past that token\n // EFFECT: updates the interner\n fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n-    let mut c = rdr.curr;\n+    let c = rdr.curr;\n     if ident_start(c) {\n         let start = rdr.last_pos;\n         while ident_continue(rdr.curr) {\n@@ -720,31 +720,28 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n                 let escaped = rdr.curr;\n                 bump(rdr);\n                 match escaped {\n-                  'n' => str::push_char(&mut accum_str, '\\n'),\n-                  'r' => str::push_char(&mut accum_str, '\\r'),\n-                  't' => str::push_char(&mut accum_str, '\\t'),\n-                  '\\\\' => str::push_char(&mut accum_str, '\\\\'),\n-                  '\\'' => str::push_char(&mut accum_str, '\\''),\n-                  '\"' => str::push_char(&mut accum_str, '\"'),\n+                  'n' => accum_str.push_char('\\n'),\n+                  'r' => accum_str.push_char('\\r'),\n+                  't' => accum_str.push_char('\\t'),\n+                  '\\\\' => accum_str.push_char('\\\\'),\n+                  '\\'' => accum_str.push_char('\\''),\n+                  '\"' => accum_str.push_char('\"'),\n                   '\\n' => consume_whitespace(rdr),\n                   'x' => {\n-                    str::push_char(&mut accum_str,\n-                                   scan_numeric_escape(rdr, 2u));\n+                    accum_str.push_char(scan_numeric_escape(rdr, 2u));\n                   }\n                   'u' => {\n-                    str::push_char(&mut accum_str,\n-                                   scan_numeric_escape(rdr, 4u));\n+                    accum_str.push_char(scan_numeric_escape(rdr, 4u));\n                   }\n                   'U' => {\n-                    str::push_char(&mut accum_str,\n-                                   scan_numeric_escape(rdr, 8u));\n+                    accum_str.push_char(scan_numeric_escape(rdr, 8u));\n                   }\n                   c2 => {\n                     rdr.fatal(fmt!(\"unknown string escape: %d\", c2 as int));\n                   }\n                 }\n               }\n-              _ => str::push_char(&mut accum_str, ch)\n+              _ => accum_str.push_char(ch)\n             }\n         }\n         bump(rdr);"}, {"sha": "03b4c0c5ca1c2686045f116d06a54f82a9fecc3b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -92,6 +92,7 @@ use parse::{new_sub_parser_from_file, next_node_id, ParseSess};\n use opt_vec;\n use opt_vec::OptVec;\n \n+use core::iterator::IteratorUtil;\n use core::either::Either;\n use core::either;\n use core::hashmap::HashSet;\n@@ -3981,17 +3982,15 @@ impl Parser {\n             token::LIT_STR(s) => {\n                 self.bump();\n                 let the_string = ident_to_str(&s);\n-                let mut words = ~[];\n-                for str::each_word(*the_string) |s| { words.push(s) }\n                 let mut abis = AbiSet::empty();\n-                for words.each |word| {\n-                    match abi::lookup(*word) {\n+                for the_string.word_iter().advance |word| {\n+                    match abi::lookup(word) {\n                         Some(abi) => {\n                             if abis.contains(abi) {\n                                 self.span_err(\n                                     *self.span,\n                                     fmt!(\"ABI `%s` appears twice\",\n-                                         *word));\n+                                         word));\n                             } else {\n                                 abis.add(abi);\n                             }\n@@ -4003,10 +4002,8 @@ impl Parser {\n                                 fmt!(\"illegal ABI: \\\n                                       expected one of [%s], \\\n                                       found `%s`\",\n-                                     str::connect_slices(\n-                                         abi::all_names(),\n-                                         \", \"),\n-                                     *word));\n+                                     abi::all_names().connect(\", \"),\n+                                     word));\n                         }\n                     }\n                 }"}, {"sha": "2157fec835eaf2ab1c917a376efaffd8a51da9ce", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -34,7 +34,6 @@ use core::io;\n use core::str;\n use core::u64;\n use core::uint;\n-use core::vec;\n \n // The @ps is stored here to prevent recursive type.\n pub enum ann_node<'self> {\n@@ -249,7 +248,7 @@ pub fn head(s: @ps, w: &str) {\n     // outer-box is consistent\n     cbox(s, indent_unit);\n     // head-box is inconsistent\n-    ibox(s, str::len(w) + 1);\n+    ibox(s, w.len() + 1);\n     // keyword that starts the head\n     if !w.is_empty() {\n         word_nbsp(s, w);"}, {"sha": "5c77e698bec8b3866007c8e6c4658c83403e3f3a", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -79,29 +79,29 @@ fn make_random_fasta(wr: @io::Writer,\n     };\n     let mut op: ~str = ~\"\";\n     for uint::range(0u, n as uint) |_i| {\n-        str::push_char(&mut op, select_random(myrandom_next(rng, 100u32),\n+        op.push_char(select_random(myrandom_next(rng, 100u32),\n                                               copy genelist));\n-        if str::len(op) >= LINE_LENGTH() {\n+        if op.len() >= LINE_LENGTH() {\n             wr.write_line(op);\n             op = ~\"\";\n         }\n     }\n-    if str::len(op) > 0u { wr.write_line(op); }\n+    if op.len() > 0u { wr.write_line(op); }\n }\n \n fn make_repeat_fasta(wr: @io::Writer, id: ~str, desc: ~str, s: ~str, n: int) {\n     unsafe {\n         wr.write_line(~\">\" + id + \" \" + desc);\n         let mut op: ~str = ~\"\";\n-        let sl: uint = str::len(s);\n+        let sl: uint = s.len();\n         for uint::range(0u, n as uint) |i| {\n             str::raw::push_byte(&mut op, s[i % sl]);\n-            if str::len(op) >= LINE_LENGTH() {\n+            if op.len() >= LINE_LENGTH() {\n                 wr.write_line(op);\n                 op = ~\"\";\n             }\n         }\n-        if str::len(op) > 0u { wr.write_line(op); }\n+        if op.len() > 0u { wr.write_line(op); }\n     }\n }\n "}, {"sha": "9ba9b9759fd1122ac43195276a7b27c485b8cb8e", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -191,13 +191,13 @@ fn main() {\n    while !rdr.eof() {\n       let line: ~str = rdr.read_line();\n \n-      if str::len(line) == 0u { loop; }\n+      if line.len() == 0u { loop; }\n \n       match (line[0] as char, proc_mode) {\n \n          // start processing if this is the one\n          ('>', false) => {\n-            match str::find_str_from(line, ~\"THREE\", 1u) {\n+            match line.slice_from(1).find_str(~\"THREE\") {\n                option::Some(_) => { proc_mode = true; }\n                option::None    => { }\n             }"}, {"sha": "d05edef25a6e2a6dbfe778df647e2b5ae69f75a7", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -14,6 +14,7 @@ extern mod extra;\n \n use std::io::{ReaderUtil, WriterUtil};\n use std::io;\n+use std::iterator::IteratorUtil;\n use std::os;\n use std::str;\n use std::u8;\n@@ -73,8 +74,8 @@ impl Sudoku {\n         let mut g = vec::from_fn(10u, { |_i| ~[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8] });\n         while !reader.eof() {\n             let line = reader.read_line();\n-            let mut comps = ~[];\n-            for str::each_split_char(line.trim(), ',') |s| { comps.push(s.to_owned()) }\n+            let comps: ~[&str] = line.trim().split_iter(',').collect();\n+\n             if comps.len() == 3u {\n                 let row     = uint::from_str(comps[0]).get() as u8;\n                 let col     = uint::from_str(comps[1]).get() as u8;"}, {"sha": "40a4232717db2af5088138d4cbeef24d43df3e45", "filename": "src/test/compile-fail/die-not-static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Ftest%2Fcompile-fail%2Fdie-not-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Ftest%2Fcompile-fail%2Fdie-not-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdie-not-static.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -2,7 +2,7 @@ use std::str;\n \n fn main() {\n     let v = ~\"test\";\n-    let sslice = str::slice(v, 0, v.len());\n+    let sslice = v.slice(0, v.len());\n     //~^ ERROR borrowed value does not live long enough\n     fail!(sslice);\n }"}, {"sha": "6e1af6ff7e095c184906c412e6a50d5d7413cbe6", "filename": "src/test/run-fail/task-spawn-barefn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Ftest%2Frun-fail%2Ftask-spawn-barefn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Ftest%2Frun-fail%2Ftask-spawn-barefn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftask-spawn-barefn.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -20,5 +20,5 @@ fn main() {\n }\n \n fn startfn() {\n-    assert!(str::is_empty(~\"Ensure that the child task runs by failing\"));\n+    assert!(\"Ensure that the child task runs by failing\".is_empty());\n }"}, {"sha": "368725607160df4bb33ba7bc71528d169083687d", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -120,7 +120,7 @@ impl ToStr for AsciiArt {\n         let lines = do self.lines.map |line| {str::from_chars(*line)};\n \n         // Concatenate the lines together using a new-line.\n-        str::connect(lines, \"\\n\")\n+        lines.connect(\"\\n\")\n     }\n }\n "}, {"sha": "23e5f3945b12dfdb0efa7e959c0df2da44feaa6b", "filename": "src/test/run-pass/issue-4241.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4241.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -95,11 +95,11 @@ priv fn parse_response(io: @io::Reader) -> Result {\n \n priv fn cmd_to_str(cmd: ~[~str]) -> ~str {\n   let mut res = ~\"*\";\n-  str::push_str(&mut res, cmd.len().to_str());\n-  str::push_str(&mut res, \"\\r\\n\");\n+  res.push_str(cmd.len().to_str());\n+  res.push_str(\"\\r\\n\");\n     for cmd.each |s| {\n-    str::push_str(&mut res, str::concat(~[~\"$\", s.len().to_str(), ~\"\\r\\n\",\n-                                          copy *s, ~\"\\r\\n\"]));\n+    res.push_str([~\"$\", s.len().to_str(), ~\"\\r\\n\",\n+                  copy *s, ~\"\\r\\n\"].concat()));\n     }\n   res\n }"}, {"sha": "a3c2872803adce3cdb62aa6881d2f3b5c4954db7", "filename": "src/test/run-pass/move-out-of-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Ftest%2Frun-pass%2Fmove-out-of-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Ftest%2Frun-pass%2Fmove-out-of-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-out-of-field.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -6,7 +6,7 @@ struct StringBuffer {\n \n impl StringBuffer {\n     pub fn append(&mut self, v: &str) {\n-        str::push_str(&mut self.s, v);\n+        self.s.push_str(v);\n     }\n }\n "}, {"sha": "f37f40935abe74ec82ea764952bd7a849f3d345f", "filename": "src/test/run-pass/option-ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Ftest%2Frun-pass%2Foption-ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Ftest%2Frun-pass%2Foption-ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foption-ext.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -12,7 +12,7 @@ use std::str;\n \n pub fn main() {\n     let thing = ~\"{{ f }}\";\n-    let f = str::find_str(thing, ~\"{{\");\n+    let f = thing.find_str(~\"{{\");\n \n     if f.is_none() {\n         println(~\"None!\");"}, {"sha": "e01b2a42f61392685a4870d05bc14eb49b6e0a34", "filename": "src/test/run-pass/string-self-append.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Ftest%2Frun-pass%2Fstring-self-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Ftest%2Frun-pass%2Fstring-self-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstring-self-append.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -18,8 +18,8 @@ pub fn main() {\n     let mut i = 20;\n     let mut expected_len = 1u;\n     while i > 0 {\n-        error!(str::len(a));\n-        assert_eq!(str::len(a), expected_len);\n+        error!(a.len());\n+        assert_eq!(a.len(), expected_len);\n         a = a + a; // FIXME(#3387)---can't write a += a\n         i -= 1;\n         expected_len *= 2u;"}, {"sha": "4029bd18338c33d28c13a1882ac3faaa559dc2b3", "filename": "src/test/run-pass/trait-to-str.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -14,7 +14,8 @@\n \n extern mod std;\n \n-use std::{str, int, vec};\n+use std::str::StrVector;\n+use std::{int, vec};\n \n trait to_str {\n     fn to_str(&self) -> ~str;\n@@ -26,7 +27,7 @@ impl to_str for int {\n \n impl<T:to_str> to_str for ~[T] {\n     fn to_str(&self) -> ~str {\n-        ~\"[\" + str::connect(vec::map(*self, |e| e.to_str() ), \", \") + \"]\"\n+        ~\"[\" + vec::map(*self, |e| e.to_str()).connect(\", \") + \"]\"\n     }\n }\n "}, {"sha": "d3bfd9b0164d5eb2e7fe12e64f1d6270daddf52c", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1310212c27c1c294e1f907b05a225440c987a912/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1310212c27c1c294e1f907b05a225440c987a912/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=1310212c27c1c294e1f907b05a225440c987a912", "patch": "@@ -10,20 +10,22 @@\n \n extern mod extra;\n \n+use std::iterator::IteratorUtil;\n use std::str;\n use std::vec;\n \n pub fn main() {\n     // Chars of 1, 2, 3, and 4 bytes\n     let chs: ~[char] = ~['e', '\u00e9', '\u20ac', 0x10000 as char];\n     let s: ~str = str::from_chars(chs);\n+    let schs: ~[char] = s.iter().collect();\n \n-    assert!(str::len(s) == 10u);\n+    assert!(s.len() == 10u);\n     assert!(str::char_len(s) == 4u);\n-    assert!(str::to_chars(s).len() == 4u);\n-    assert!(str::from_chars(str::to_chars(s)) == s);\n-    assert!(str::char_at(s, 0u) == 'e');\n-    assert!(str::char_at(s, 1u) == '\u00e9');\n+    assert!(schs.len() == 4u);\n+    assert!(str::from_chars(schs) == s);\n+    assert!(s.char_at(0u) == 'e');\n+    assert!(s.char_at(1u) == '\u00e9');\n \n     assert!((str::is_utf8(str::to_bytes(s))));\n     assert!((!str::is_utf8(~[0x80_u8])));\n@@ -33,7 +35,7 @@ pub fn main() {\n     let mut stack = ~\"a\u00d7c\u20ac\";\n     assert_eq!(str::pop_char(&mut stack), '\u20ac');\n     assert_eq!(str::pop_char(&mut stack), 'c');\n-    str::push_char(&mut stack, 'u');\n+    stack.push_char('u');\n     assert!(stack == ~\"a\u00d7u\");\n     assert_eq!(str::shift_char(&mut stack), 'a');\n     assert_eq!(str::shift_char(&mut stack), '\u00d7');"}]}