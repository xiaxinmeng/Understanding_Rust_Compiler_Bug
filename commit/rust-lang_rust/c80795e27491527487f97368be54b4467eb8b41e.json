{"sha": "c80795e27491527487f97368be54b4467eb8b41e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4MDc5NWUyNzQ5MTUyNzQ4N2Y5NzM2OGJlNTRiNDQ2N2ViOGI0MWU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-09T15:47:46Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-09T15:47:46Z"}, "message": "Move generated tokens to a separate file", "tree": {"sha": "4812317fc06bc8f54796f4fde4cb043b2be54418", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4812317fc06bc8f54796f4fde4cb043b2be54418"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c80795e27491527487f97368be54b4467eb8b41e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c80795e27491527487f97368be54b4467eb8b41e", "html_url": "https://github.com/rust-lang/rust/commit/c80795e27491527487f97368be54b4467eb8b41e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c80795e27491527487f97368be54b4467eb8b41e/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59b6b2278b7f7d2089b5caf6fcfd57528d9aafd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/59b6b2278b7f7d2089b5caf6fcfd57528d9aafd0", "html_url": "https://github.com/rust-lang/rust/commit/59b6b2278b7f7d2089b5caf6fcfd57528d9aafd0"}], "stats": {"total": 6213, "additions": 3121, "deletions": 3092}, "files": [{"sha": "a42eec91a9c20965dcb8955c8d37026a4068d547", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80795e27491527487f97368be54b4467eb8b41e/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80795e27491527487f97368be54b4467eb8b41e/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=c80795e27491527487f97368be54b4467eb8b41e", "patch": "@@ -21,7 +21,7 @@ pub use self::{\n         AttrKind, FieldKind, PathSegmentKind, SelfParamKind, SlicePatComponents, StructKind,\n         TypeBoundKind, VisibilityKind,\n     },\n-    generated::nodes::*,\n+    generated::{nodes::*, tokens::*},\n     tokens::*,\n     traits::*,\n };"}, {"sha": "7d74c9fc947be99b3fa29e524c45ee1296e50bbd", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 1, "deletions": 3053, "changes": 3054, "blob_url": "https://github.com/rust-lang/rust/blob/c80795e27491527487f97368be54b4467eb8b41e/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80795e27491527487f97368be54b4467eb8b41e/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=c80795e27491527487f97368be54b4467eb8b41e"}, {"sha": "27b2d29771d991e29be3aa719c937e79b33f93ae", "filename": "crates/ra_syntax/src/ast/generated/tokens.rs", "status": "modified", "additions": 3058, "deletions": 1, "changes": 3059, "blob_url": "https://github.com/rust-lang/rust/blob/c80795e27491527487f97368be54b4467eb8b41e/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Ftokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80795e27491527487f97368be54b4467eb8b41e/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Ftokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Ftokens.rs?ref=c80795e27491527487f97368be54b4467eb8b41e"}, {"sha": "683901a0a4bf2c67cc8a99ddeb9a0bb04e5e1e4c", "filename": "xtask/src/codegen/gen_syntax.rs", "status": "modified", "additions": 61, "deletions": 37, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/c80795e27491527487f97368be54b4467eb8b41e/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80795e27491527487f97368be54b4467eb8b41e/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs?ref=c80795e27491527487f97368be54b4467eb8b41e", "patch": "@@ -23,11 +23,11 @@ pub fn generate_syntax(mode: Mode) -> Result<()> {\n     update(syntax_kinds_file.as_path(), &syntax_kinds, mode)?;\n \n     let ast_nodes_file = project_root().join(codegen::AST_NODES);\n-    let contents = generate_ast(KINDS_SRC, AST_SRC)?;\n+    let contents = generate_nodes(KINDS_SRC, AST_SRC)?;\n     update(ast_nodes_file.as_path(), &contents, mode)?;\n \n     let ast_tokens_file = project_root().join(codegen::AST_TOKENS);\n-    let contents = \"//! Generated file, do not edit by hand, see `xtask/src/codegen`\";\n+    let contents = generate_tokens(KINDS_SRC, AST_SRC)?;\n     update(ast_tokens_file.as_path(), &contents, mode)?;\n \n     Ok(())\n@@ -40,7 +40,62 @@ struct ElementKinds {\n     has_tokens: bool,\n }\n \n-fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n+fn generate_tokens(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n+    let all_token_kinds: Vec<_> = kinds\n+        .punct\n+        .into_iter()\n+        .map(|(_, kind)| kind)\n+        .copied()\n+        .map(|x| x.into())\n+        .chain(\n+            kinds\n+                .keywords\n+                .into_iter()\n+                .chain(kinds.contextual_keywords.into_iter())\n+                .map(|name| Cow::Owned(format!(\"{}_KW\", to_upper_snake_case(&name)))),\n+        )\n+        .chain(kinds.literals.into_iter().copied().map(|x| x.into()))\n+        .chain(kinds.tokens.into_iter().copied().map(|x| x.into()))\n+        .collect();\n+    let tokens = all_token_kinds.iter().map(|kind_str| {\n+        let kind_str = &**kind_str;\n+        let kind = format_ident!(\"{}\", kind_str);\n+        let name = format_ident!(\"{}\", to_pascal_case(kind_str));\n+        quote! {\n+            #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+            pub struct #name {\n+                pub(crate) syntax: SyntaxToken,\n+            }\n+\n+            impl std::fmt::Display for #name {\n+                fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+                    std::fmt::Display::fmt(&self.syntax, f)\n+                }\n+            }\n+\n+            impl AstToken for #name {\n+                fn can_cast(kind: SyntaxKind) -> bool {\n+                    match kind {\n+                        #kind => true,\n+                        _ => false,\n+                    }\n+                }\n+                fn cast(syntax: SyntaxToken) -> Option<Self> {\n+                    if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }\n+                }\n+                fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+            }\n+        }\n+    });\n+\n+    crate::reformat(quote! {\n+        use crate::{SyntaxToken, SyntaxKind::{self, *}, ast::AstToken};\n+\n+        #(#tokens)*\n+    })\n+}\n+\n+fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n     let all_token_kinds: Vec<_> = kinds\n         .punct\n         .into_iter()\n@@ -98,37 +153,6 @@ fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n         element_kinds_map.insert(en.name.to_string(), element_kinds);\n     }\n \n-    let tokens = all_token_kinds.iter().map(|kind_str| {\n-        let kind_str = &**kind_str;\n-        let kind = format_ident!(\"{}\", kind_str);\n-        let name = format_ident!(\"{}\", to_pascal_case(kind_str));\n-        quote! {\n-            #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-            pub struct #name {\n-                pub(crate) syntax: SyntaxToken,\n-            }\n-\n-            impl std::fmt::Display for #name {\n-                fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-                    std::fmt::Display::fmt(&self.syntax, f)\n-                }\n-            }\n-\n-            impl AstToken for #name {\n-                fn can_cast(kind: SyntaxKind) -> bool {\n-                    match kind {\n-                        #kind => true,\n-                        _ => false,\n-                    }\n-                }\n-                fn cast(syntax: SyntaxToken) -> Option<Self> {\n-                    if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }\n-                }\n-                fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-            }\n-        }\n-    });\n-\n     let nodes = grammar.nodes.iter().map(|node| {\n         let name = format_ident!(\"{}\", node.name);\n         let kind = format_ident!(\"{}\", to_upper_snake_case(&name.to_string()));\n@@ -301,13 +325,13 @@ fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n     }\n \n     let ast = quote! {\n-        #[allow(unused_imports)]\n         use crate::{\n-            SyntaxNode, SyntaxToken, SyntaxElement, NodeOrToken, SyntaxKind::{self, *},\n+            SyntaxNode, SyntaxToken, SyntaxKind::{self, *},\n             ast::{self, AstNode, AstToken, AstChildren, support},\n         };\n \n-        #(#tokens)*\n+        use super::tokens::*;\n+\n         #(#nodes)*\n         #(#enums)*\n     };"}]}