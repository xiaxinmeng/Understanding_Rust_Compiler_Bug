{"sha": "f513380cf51eb5fd977b8815a7acd999e424dc93", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1MTMzODBjZjUxZWI1ZmQ5NzdiODgxNWE3YWNkOTk5ZTQyNGRjOTM=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-03-29T23:11:11Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-03-30T12:10:45Z"}, "message": "Address Issue 14270 by making `cmt::freely_aliasable` result more fine-grained.\n\nInstead of encoding the aliasability (i.e. whether the cmt is uniquely\nwritable or not) as an option, now pass back an enum indicating\neither: 1. freely-aliasable (thus not uniquely-writable),\n2. non-aliasble (thus uniquely writable), or 3. unique but immutable\n(and thus not uniquely writable, according to proposal from issue\n14270.)\n\nThis is all of course a giant hack that will hopefully go away with an\neventually removal of special treatment of `Box<T>` (aka `ty_unique`)\nfrom the compiler.", "tree": {"sha": "f34be5c0599b0c1764d88abed2139a894db1df83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f34be5c0599b0c1764d88abed2139a894db1df83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f513380cf51eb5fd977b8815a7acd999e424dc93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f513380cf51eb5fd977b8815a7acd999e424dc93", "html_url": "https://github.com/rust-lang/rust/commit/f513380cf51eb5fd977b8815a7acd999e424dc93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f513380cf51eb5fd977b8815a7acd999e424dc93/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "492b3b163fc003658eece850fc241248dd66db02", "url": "https://api.github.com/repos/rust-lang/rust/commits/492b3b163fc003658eece850fc241248dd66db02", "html_url": "https://github.com/rust-lang/rust/commit/492b3b163fc003658eece850fc241248dd66db02"}], "stats": {"total": 83, "additions": 64, "deletions": 19}, "files": [{"sha": "b213d71a78d14961550b1fcc97ad9d273c0b23aa", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f513380cf51eb5fd977b8815a7acd999e424dc93/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f513380cf51eb5fd977b8815a7acd999e424dc93/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=f513380cf51eb5fd977b8815a7acd999e424dc93", "patch": "@@ -71,6 +71,8 @@ pub use self::Note::*;\n pub use self::deref_kind::*;\n pub use self::categorization::*;\n \n+use self::Aliasability::*;\n+\n use middle::check_const;\n use middle::def;\n use middle::region;\n@@ -1387,17 +1389,25 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     }\n }\n \n-#[derive(Copy)]\n+#[derive(Copy, Clone, Debug)]\n pub enum InteriorSafety {\n     InteriorUnsafe,\n     InteriorSafe\n }\n \n-#[derive(Copy)]\n+#[derive(Clone, Debug)]\n+pub enum Aliasability {\n+    FreelyAliasable(AliasableReason),\n+    NonAliasable,\n+    ImmutableUnique(Box<Aliasability>),\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n pub enum AliasableReason {\n     AliasableBorrowed,\n     AliasableClosure(ast::NodeId), // Aliasable due to capture Fn closure env\n     AliasableOther,\n+    UnaliasableImmutable, // Created as needed upon seeing ImmutableUnique\n     AliasableStatic(InteriorSafety),\n     AliasableStaticMut(InteriorSafety),\n }\n@@ -1426,9 +1436,9 @@ impl<'tcx> cmt_<'tcx> {\n         }\n     }\n \n-    /// Returns `Some(_)` if this lvalue represents a freely aliasable pointer type.\n+    /// Returns `FreelyAliasable(_)` if this lvalue represents a freely aliasable pointer type.\n     pub fn freely_aliasable(&self, ctxt: &ty::ctxt<'tcx>)\n-                            -> Option<AliasableReason> {\n+                            -> Aliasability {\n         // Maybe non-obvious: copied upvars can only be considered\n         // non-aliasable in once closures, since any other kind can be\n         // aliased and eventually recused.\n@@ -1439,17 +1449,27 @@ impl<'tcx> cmt_<'tcx> {\n             cat_deref(ref b, _, BorrowedPtr(ty::UniqueImmBorrow, _)) |\n             cat_deref(ref b, _, Implicit(ty::UniqueImmBorrow, _)) |\n             cat_downcast(ref b, _) |\n-            cat_deref(ref b, _, Unique) |\n             cat_interior(ref b, _) => {\n                 // Aliasability depends on base cmt\n                 b.freely_aliasable(ctxt)\n             }\n \n+            cat_deref(ref b, _, Unique) => {\n+                let sub = b.freely_aliasable(ctxt);\n+                if b.mutbl.is_mutable() {\n+                    // Aliasability depends on base cmt alone\n+                    sub\n+                } else {\n+                    // Do not allow mutation through an immutable box.\n+                    ImmutableUnique(Box::new(sub))\n+                }\n+            }\n+\n             cat_rvalue(..) |\n             cat_local(..) |\n             cat_upvar(..) |\n             cat_deref(_, _, UnsafePtr(..)) => { // yes, it's aliasable, but...\n-                None\n+                NonAliasable\n             }\n \n             cat_static_item(..) => {\n@@ -1460,17 +1480,18 @@ impl<'tcx> cmt_<'tcx> {\n                 };\n \n                 if self.mutbl.is_mutable() {\n-                    Some(AliasableStaticMut(int_safe))\n+                    FreelyAliasable(AliasableStaticMut(int_safe))\n                 } else {\n-                    Some(AliasableStatic(int_safe))\n+                    FreelyAliasable(AliasableStatic(int_safe))\n                 }\n             }\n \n             cat_deref(ref base, _, BorrowedPtr(ty::ImmBorrow, _)) |\n             cat_deref(ref base, _, Implicit(ty::ImmBorrow, _)) => {\n                 match base.cat {\n-                    cat_upvar(Upvar{ id, .. }) => Some(AliasableClosure(id.closure_expr_id)),\n-                    _ => Some(AliasableBorrowed)\n+                    cat_upvar(Upvar{ id, .. }) =>\n+                        FreelyAliasable(AliasableClosure(id.closure_expr_id)),\n+                    _ => FreelyAliasable(AliasableBorrowed)\n                 }\n             }\n         }"}, {"sha": "2187494caff940959a327671f765a0792ecd5f70", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f513380cf51eb5fd977b8815a7acd999e424dc93/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f513380cf51eb5fd977b8815a7acd999e424dc93/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=f513380cf51eb5fd977b8815a7acd999e424dc93", "patch": "@@ -943,13 +943,20 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                                       cmt: mc::cmt<'tcx>)\n                                                       -> bool {\n             match cmt.freely_aliasable(this.tcx()) {\n-                None => {\n+                mc::Aliasability::NonAliasable => {\n                     return true;\n                 }\n-                Some(mc::AliasableStaticMut(..)) => {\n+                mc::Aliasability::FreelyAliasable(mc::AliasableStaticMut(..)) => {\n                     return true;\n                 }\n-                Some(cause) => {\n+                mc::Aliasability::ImmutableUnique(_) => {\n+                    this.bccx.report_aliasability_violation(\n+                        span,\n+                        MutabilityViolation,\n+                        mc::AliasableReason::UnaliasableImmutable);\n+                    return false;\n+                }\n+                mc::Aliasability::FreelyAliasable(cause) => {\n                     this.bccx.report_aliasability_violation(\n                         span,\n                         MutabilityViolation,"}, {"sha": "7788a2a7471a91846dea22f5bedf471838dfb3c6", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f513380cf51eb5fd977b8815a7acd999e424dc93/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f513380cf51eb5fd977b8815a7acd999e424dc93/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=f513380cf51eb5fd977b8815a7acd999e424dc93", "patch": "@@ -182,12 +182,16 @@ fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                 req_kind: ty::BorrowKind)\n                                 -> Result<(),()> {\n \n-    match (cmt.freely_aliasable(bccx.tcx), req_kind) {\n-        (None, _) => {\n+    let aliasability = cmt.freely_aliasable(bccx.tcx);\n+    debug!(\"check_aliasability aliasability={:?} req_kind={:?}\",\n+           aliasability, req_kind);\n+\n+    match (aliasability, req_kind) {\n+        (mc::Aliasability::NonAliasable, _) => {\n             /* Uniquely accessible path -- OK for `&` and `&mut` */\n             Ok(())\n         }\n-        (Some(mc::AliasableStatic(safety)), ty::ImmBorrow) => {\n+        (mc::Aliasability::FreelyAliasable(mc::AliasableStatic(safety)), ty::ImmBorrow) => {\n             // Borrow of an immutable static item:\n             match safety {\n                 mc::InteriorUnsafe => {\n@@ -203,13 +207,20 @@ fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                 }\n             }\n         }\n-        (Some(mc::AliasableStaticMut(..)), _) => {\n+        (mc::Aliasability::FreelyAliasable(mc::AliasableStaticMut(..)), _) => {\n             // Even touching a static mut is considered unsafe. We assume the\n             // user knows what they're doing in these cases.\n             Ok(())\n         }\n-        (Some(alias_cause), ty::UniqueImmBorrow) |\n-        (Some(alias_cause), ty::MutBorrow) => {\n+        (mc::Aliasability::ImmutableUnique(_), ty::MutBorrow) => {\n+            bccx.report_aliasability_violation(\n+                        borrow_span,\n+                        BorrowViolation(loan_cause),\n+                        mc::AliasableReason::UnaliasableImmutable);\n+            Err(())\n+        }\n+        (mc::Aliasability::FreelyAliasable(alias_cause), ty::UniqueImmBorrow) |\n+        (mc::Aliasability::FreelyAliasable(alias_cause), ty::MutBorrow) => {\n             bccx.report_aliasability_violation(\n                         borrow_span,\n                         BorrowViolation(loan_cause),"}, {"sha": "a748d94e08d63a60f4b3dbb07954821cb93e8fe1", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f513380cf51eb5fd977b8815a7acd999e424dc93/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f513380cf51eb5fd977b8815a7acd999e424dc93/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=f513380cf51eb5fd977b8815a7acd999e424dc93", "patch": "@@ -844,6 +844,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     &format!(\"{} in an aliasable location\",\n                              prefix));\n             }\n+            mc::AliasableReason::UnaliasableImmutable => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    &format!(\"{} in an immutable container\",\n+                             prefix));\n+            }\n             mc::AliasableClosure(id) => {\n                 self.tcx.sess.span_err(span,\n                                        &format!(\"{} in a captured outer \\"}]}