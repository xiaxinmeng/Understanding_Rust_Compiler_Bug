{"sha": "d08cc0ba67d9989548ae163083b7e3a3dec6b9a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwOGNjMGJhNjdkOTk4OTU0OGFlMTYzMDgzYjdlM2EzZGVjNmI5YTI=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-21T08:28:37Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-23T22:16:35Z"}, "message": "Put extract_def_id back on DepNode.", "tree": {"sha": "cbb09fb89219b64baac9c343aa5a9fa91889b73a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbb09fb89219b64baac9c343aa5a9fa91889b73a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d08cc0ba67d9989548ae163083b7e3a3dec6b9a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d08cc0ba67d9989548ae163083b7e3a3dec6b9a2", "html_url": "https://github.com/rust-lang/rust/commit/d08cc0ba67d9989548ae163083b7e3a3dec6b9a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d08cc0ba67d9989548ae163083b7e3a3dec6b9a2/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a8bb20230c4bb8f40aeca1d6ca3dea048b9e2e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a8bb20230c4bb8f40aeca1d6ca3dea048b9e2e3", "html_url": "https://github.com/rust-lang/rust/commit/3a8bb20230c4bb8f40aeca1d6ca3dea048b9e2e3"}], "stats": {"total": 68, "additions": 28, "deletions": 40}, "files": [{"sha": "fdcc1a0db0538236e8ffd1ff2d07dea2c7512391", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d08cc0ba67d9989548ae163083b7e3a3dec6b9a2/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08cc0ba67d9989548ae163083b7e3a3dec6b9a2/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=d08cc0ba67d9989548ae163083b7e3a3dec6b9a2", "patch": "@@ -220,6 +220,18 @@ macro_rules! define_dep_nodes {\n             /// single DefId/DefPathHash parameter.\n             fn from_def_path_hash(def_path_hash: DefPathHash, kind: DepKind) -> Self;\n \n+            /// Extracts the DefId corresponding to this DepNode. This will work\n+            /// if two conditions are met:\n+            ///\n+            /// 1. The Fingerprint of the DepNode actually is a DefPathHash, and\n+            /// 2. the item that the DefPath refers to exists in the current tcx.\n+            ///\n+            /// Condition (1) is determined by the DepKind variant of the\n+            /// DepNode. Condition (2) might not be fulfilled if a DepNode\n+            /// refers to something from the previous compilation session that\n+            /// has been removed.\n+            fn extract_def_id(&self, tcx: TyCtxt<'_>) -> Option<DefId>;\n+\n             /// Used in testing\n             fn from_label_string(label: &str, def_path_hash: DefPathHash)\n                 -> Result<Self, ()>;\n@@ -250,6 +262,15 @@ macro_rules! define_dep_nodes {\n             /// DepNode. Condition (2) might not be fulfilled if a DepNode\n             /// refers to something from the previous compilation session that\n             /// has been removed.\n+            fn extract_def_id(&self, tcx: TyCtxt<'tcx>) -> Option<DefId> {\n+                if self.kind.can_reconstruct_query_key() {\n+                    let def_path_hash = DefPathHash(self.hash);\n+                    tcx.def_path_hash_to_def_id.as_ref()?.get(&def_path_hash).cloned()\n+                } else {\n+                    None\n+                }\n+            }\n+\n             /// Used in testing\n             fn from_label_string(label: &str, def_path_hash: DefPathHash) -> Result<DepNode, ()> {\n                 let kind = match label {\n@@ -316,7 +337,7 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for DefId {\n     }\n \n     fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n-        tcx.extract_def_id(dep_node)\n+        dep_node.extract_def_id(tcx)\n     }\n }\n \n@@ -332,7 +353,7 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for LocalDefId {\n     }\n \n     fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n-        tcx.extract_def_id(dep_node).map(|id| id.expect_local())\n+        dep_node.extract_def_id(tcx).map(|id| id.expect_local())\n     }\n }\n \n@@ -349,7 +370,7 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for CrateNum {\n     }\n \n     fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n-        tcx.extract_def_id(dep_node).map(|id| id.krate)\n+        dep_node.extract_def_id(tcx).map(|id| id.krate)\n     }\n }\n "}, {"sha": "47cc5f58559dfd9ceda4cb1d0aeb8a8856a8d8e9", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d08cc0ba67d9989548ae163083b7e3a3dec6b9a2/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08cc0ba67d9989548ae163083b7e3a3dec6b9a2/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=d08cc0ba67d9989548ae163083b7e3a3dec6b9a2", "patch": "@@ -1,4 +1,3 @@\n-use crate::hir::map::definitions::DefPathHash;\n use crate::ich::StableHashingContext;\n use crate::ty::{self, TyCtxt};\n use rustc_data_structures::profiling::SelfProfilerRef;\n@@ -46,7 +45,7 @@ impl rustc_query_system::dep_graph::DepKind for DepKind {\n \n         ty::tls::with_opt(|opt_tcx| {\n             if let Some(tcx) = opt_tcx {\n-                if let Some(def_id) = tcx.extract_def_id(node) {\n+                if let Some(def_id) = node.extract_def_id(tcx) {\n                     write!(f, \"{}\", tcx.def_path_debug_str(def_id))?;\n                 } else if let Some(ref s) = tcx.dep_graph.dep_node_debug_str(*node) {\n                     write!(f, \"{}\", s)?;\n@@ -92,32 +91,13 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n         TyCtxt::create_stable_hashing_context(*self)\n     }\n \n-    /// Extracts the DefId corresponding to this DepNode. This will work\n-    /// if two conditions are met:\n-    ///\n-    /// 1. The Fingerprint of the DepNode actually is a DefPathHash, and\n-    /// 2. the item that the DefPath refers to exists in the current tcx.\n-    ///\n-    /// Condition (1) is determined by the DepKind variant of the\n-    /// DepNode. Condition (2) might not be fulfilled if a DepNode\n-    /// refers to something from the previous compilation session that\n-    /// has been removed.\n-    fn extract_def_id(&self, node: &DepNode) -> Option<DefId> {\n-        if node.kind.can_reconstruct_query_key() {\n-            let def_path_hash = DefPathHash(node.hash);\n-            self.def_path_hash_to_def_id.as_ref()?.get(&def_path_hash).cloned()\n-        } else {\n-            None\n-        }\n-    }\n-\n     fn try_force_previous_green(&self, dep_dep_node: &DepNode) -> bool {\n         // FIXME: This match is just a workaround for incremental bugs and should\n         // be removed. https://github.com/rust-lang/rust/issues/62649 is one such\n         // bug that must be fixed before removing this.\n         match dep_dep_node.kind {\n             DepKind::hir_owner | DepKind::hir_owner_nodes | DepKind::CrateMetadata => {\n-                if let Some(def_id) = self.extract_def_id(dep_dep_node) {\n+                if let Some(def_id) = dep_dep_node.extract_def_id(*self) {\n                     if def_id_corresponds_to_hir_dep_node(*self, def_id) {\n                         if dep_dep_node.kind == DepKind::CrateMetadata {\n                             // The `DefPath` has corresponding node,"}, {"sha": "9ddd238afff2bb7e2d2d193817e085cb913f8299", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08cc0ba67d9989548ae163083b7e3a3dec6b9a2/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08cc0ba67d9989548ae163083b7e3a3dec6b9a2/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=d08cc0ba67d9989548ae163083b7e3a3dec6b9a2", "patch": "@@ -13,7 +13,7 @@\n //! Errors are reported if we are in the suitable configuration but\n //! the required condition is not met.\n \n-use rustc::dep_graph::{label_strs, DepContext, DepNode, DepNodeExt};\n+use rustc::dep_graph::{label_strs, DepNode, DepNodeExt};\n use rustc::hir::map::Map;\n use rustc::ty::TyCtxt;\n use rustc_ast::ast::{self, Attribute, NestedMetaItem};\n@@ -382,7 +382,7 @@ impl DirtyCleanVisitor<'tcx> {\n     }\n \n     fn dep_node_str(&self, dep_node: &DepNode) -> String {\n-        if let Some(def_id) = self.tcx.extract_def_id(dep_node) {\n+        if let Some(def_id) = dep_node.extract_def_id(self.tcx) {\n             format!(\"{:?}({})\", dep_node.kind, self.tcx.def_path_str(def_id))\n         } else {\n             format!(\"{:?}({:?})\", dep_node.kind, dep_node.hash)"}, {"sha": "a54b8497fdef6d98ff11ef72055e50e716cdfaee", "filename": "src/librustc_query_system/dep_graph/mod.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d08cc0ba67d9989548ae163083b7e3a3dec6b9a2/src%2Flibrustc_query_system%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08cc0ba67d9989548ae163083b7e3a3dec6b9a2/src%2Flibrustc_query_system%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fmod.rs?ref=d08cc0ba67d9989548ae163083b7e3a3dec6b9a2", "patch": "@@ -19,7 +19,6 @@ use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::Diagnostic;\n-use rustc_hir::def_id::DefId;\n \n use std::fmt;\n use std::hash::Hash;\n@@ -34,18 +33,6 @@ pub trait DepContext: Copy {\n     /// Try to force a dep node to execute and see if it's green.\n     fn try_force_previous_green(&self, node: &DepNode<Self::DepKind>) -> bool;\n \n-    /// Extracts the DefId corresponding to this DepNode. This will work\n-    /// if two conditions are met:\n-    ///\n-    /// 1. The Fingerprint of the DepNode actually is a DefPathHash, and\n-    /// 2. the item that the DefPath refers to exists in the current tcx.\n-    ///\n-    /// Condition (1) is determined by the DepKind variant of the\n-    /// DepNode. Condition (2) might not be fulfilled if a DepNode\n-    /// refers to something from the previous compilation session that\n-    /// has been removed.\n-    fn extract_def_id(&self, node: &DepNode<Self::DepKind>) -> Option<DefId>;\n-\n     /// Return whether the current session is tainted by errors.\n     fn has_errors_or_delayed_span_bugs(&self) -> bool;\n "}]}