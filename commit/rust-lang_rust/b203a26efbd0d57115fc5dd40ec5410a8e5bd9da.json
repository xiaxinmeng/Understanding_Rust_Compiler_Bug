{"sha": "b203a26efbd0d57115fc5dd40ec5410a8e5bd9da", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyMDNhMjZlZmJkMGQ1NzExNWZjNWRkNDBlYzU0MTBhOGU1YmQ5ZGE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-24T09:12:26Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:33Z"}, "message": "rustc: generalize layout::Variants::NicheFilling to niches other than 0.", "tree": {"sha": "cf52f4cf12b494479a0f1a4d9e306473a1f70c5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf52f4cf12b494479a0f1a4d9e306473a1f70c5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b203a26efbd0d57115fc5dd40ec5410a8e5bd9da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b203a26efbd0d57115fc5dd40ec5410a8e5bd9da", "html_url": "https://github.com/rust-lang/rust/commit/b203a26efbd0d57115fc5dd40ec5410a8e5bd9da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b203a26efbd0d57115fc5dd40ec5410a8e5bd9da/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0190f270c1501ecb7f1b1829dcac16af8b4981e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0190f270c1501ecb7f1b1829dcac16af8b4981e1", "html_url": "https://github.com/rust-lang/rust/commit/0190f270c1501ecb7f1b1829dcac16af8b4981e1"}], "stats": {"total": 232, "additions": 146, "deletions": 86}, "files": [{"sha": "d52721bc17ab3608187d5934f54c18eb3ba78b88", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 61, "deletions": 39, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/b203a26efbd0d57115fc5dd40ec5410a8e5bd9da/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b203a26efbd0d57115fc5dd40ec5410a8e5bd9da/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=b203a26efbd0d57115fc5dd40ec5410a8e5bd9da", "patch": "@@ -790,17 +790,18 @@ pub enum Variants {\n         variants: Vec<CachedLayout>,\n     },\n \n-    /// Two cases distinguished by a niche: the case with discriminant\n-    /// `nndiscr` is represented by the struct `nonnull`, where field `0`\n-    /// is known to be nonnull due to its type; if that field is null, then\n-    /// it represents the other case, which is known to be zero sized.\n+    /// Two cases distinguished by a niche (a value invalid for a type):\n+    /// the variant `dataful_variant` contains a niche at an arbitrary\n+    /// offset (field 0 of the enum), which is set to `niche_value`\n+    /// for the other variant.\n     ///\n-    /// For example, `std::option::Option` instantiated at a safe pointer type\n-    /// is represented such that `None` is a null pointer and `Some` is the\n-    /// identity function.\n+    /// For example, `Option<(usize, &T)>`  is represented such that\n+    /// `None` has a null pointer for the second tuple field, and\n+    /// `Some` is the identity function (with a non-null reference).\n     NicheFilling {\n-        nndiscr: u64,\n-        discr: Primitive,\n+        dataful_variant: usize,\n+        niche: Primitive,\n+        niche_value: u128,\n         variants: Vec<CachedLayout>,\n     }\n }\n@@ -1323,7 +1324,7 @@ impl<'a, 'tcx> CachedLayout {\n                         }\n \n                         for (field_index, field) in variants[i].iter().enumerate() {\n-                            if let Some((offset, discr)) = field.non_zero_field(cx)? {\n+                            if let Some((offset, niche, niche_value)) = field.find_niche(cx)? {\n                                 let mut st = vec![\n                                     univariant_uninterned(&variants[0],\n                                         &def.repr, StructKind::AlwaysSized)?,\n@@ -1342,23 +1343,23 @@ impl<'a, 'tcx> CachedLayout {\n                                     ..\n                                 } = st[i];\n \n-                                let mut discr_align = discr.align(dl);\n-                                if offset.bytes() == 0 && discr.size(dl) == size {\n-                                    abi = Abi::Scalar(discr);\n+                                let mut niche_align = niche.align(dl);\n+                                if offset.bytes() == 0 && niche.size(dl) == size {\n+                                    abi = Abi::Scalar(niche);\n                                 } else if let Abi::Aggregate { ref mut packed, .. } = abi {\n-                                    if offset.abi_align(discr_align) != offset {\n+                                    if offset.abi_align(niche_align) != offset {\n                                         *packed = true;\n-                                        discr_align = dl.i8_align;\n+                                        niche_align = dl.i8_align;\n                                     }\n                                 }\n-                                align = align.max(discr_align);\n-                                primitive_align = primitive_align.max(discr_align);\n+                                align = align.max(niche_align);\n+                                primitive_align = primitive_align.max(niche_align);\n \n                                 return Ok(tcx.intern_layout(CachedLayout {\n                                     variants: Variants::NicheFilling {\n-                                        nndiscr: i as u64,\n-\n-                                        discr,\n+                                        dataful_variant: i,\n+                                        niche,\n+                                        niche_value,\n                                         variants: st,\n                                     },\n                                     fields: FieldPlacement::Arbitrary {\n@@ -2048,7 +2049,7 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n \n                     // Discriminant field for enums (where applicable).\n                     Variants::Tagged { discr, .. } |\n-                    Variants::NicheFilling { discr, .. } => {\n+                    Variants::NicheFilling { niche: discr, .. } => {\n                         return cx.layout_of([discr.to_ty(tcx)][i]);\n                     }\n                 }\n@@ -2084,30 +2085,48 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n         (self.size, self.align)\n     }\n \n-    /// Find the offset of a non-zero leaf field, starting from\n+    /// Find the offset of a niche leaf field, starting from\n     /// the given type and recursing through aggregates.\n-    /// The tuple is `(offset, primitive, source_path)`.\n+    /// The tuple is `(offset, primitive, niche_value)`.\n     // FIXME(eddyb) track value ranges and traverse already optimized enums.\n-    fn non_zero_field<C>(&self, cx: C)\n-        -> Result<Option<(Size, Primitive)>, LayoutError<'tcx>>\n+    fn find_niche<C>(&self, cx: C)\n+        -> Result<Option<(Size, Primitive, u128)>, LayoutError<'tcx>>\n         where C: LayoutOf<Ty<'tcx>, TyLayout = Result<Self, LayoutError<'tcx>>> +\n                  HasTyCtxt<'tcx>\n     {\n         let tcx = cx.tcx();\n         match (&self.variants, self.abi, &self.ty.sty) {\n             // FIXME(eddyb) check this via value ranges on scalars.\n+            (_, Abi::Scalar(Int(I1, _)), _) => {\n+                Ok(Some((Size::from_bytes(0), Int(I8, false), 2)))\n+            }\n+            (_, Abi::Scalar(Int(I32, _)), &ty::TyChar) => {\n+                Ok(Some((Size::from_bytes(0), Int(I32, false), 0x10FFFF+1)))\n+            }\n             (_, Abi::Scalar(Pointer), &ty::TyRef(..)) |\n             (_, Abi::Scalar(Pointer), &ty::TyFnPtr(..)) => {\n-                Ok(Some((Size::from_bytes(0), Pointer)))\n+                Ok(Some((Size::from_bytes(0), Pointer, 0)))\n             }\n             (_, Abi::Scalar(Pointer), &ty::TyAdt(def, _)) if def.is_box() => {\n-                Ok(Some((Size::from_bytes(0), Pointer)))\n+                Ok(Some((Size::from_bytes(0), Pointer, 0)))\n             }\n \n             // FIXME(eddyb) check this via value ranges on scalars.\n-            (&Variants::Tagged { discr, .. }, _, &ty::TyAdt(def, _)) => {\n-                if def.discriminants(tcx).all(|d| d.to_u128_unchecked() != 0) {\n-                    Ok(Some((self.fields.offset(0), discr)))\n+            (&Variants::Tagged { discr, ref discr_range, .. }, _, _) => {\n+                // FIXME(eddyb) support negative/wrap-around discriminant ranges.\n+                if discr_range.start < discr_range.end {\n+                    if discr_range.start > 0 {\n+                        Ok(Some((self.fields.offset(0), discr, 0)))\n+                    } else {\n+                        let bits = discr.size(tcx).bits();\n+                        assert!(bits <= 128);\n+                        let max_value = !0u128 >> (128 - bits);\n+                        if discr_range.end < max_value {\n+                            Ok(Some((self.fields.offset(0), discr, discr_range.end + 1)))\n+                        } else {\n+                            Ok(None)\n+                        }\n+                    }\n                 } else {\n                     Ok(None)\n                 }\n@@ -2118,7 +2137,7 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n                 let field = self.field(cx, 0)?;\n                 let offset = self.fields.offset(0);\n                 if let Abi::Scalar(value) = field.abi {\n-                    Ok(Some((offset, value)))\n+                    Ok(Some((offset, value, 0)))\n                 } else {\n                     Ok(None)\n                 }\n@@ -2128,13 +2147,14 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n             _ => {\n                 if let FieldPlacement::Array { count, .. } = self.fields {\n                     if count > 0 {\n-                        return self.field(cx, 0)?.non_zero_field(cx);\n+                        return self.field(cx, 0)?.find_niche(cx);\n                     }\n                 }\n                 for i in 0..self.fields.count() {\n-                    let r = self.field(cx, i)?.non_zero_field(cx)?;\n-                    if let Some((offset, primitive)) = r {\n-                        return Ok(Some((self.fields.offset(i) + offset, primitive)));\n+                    let r = self.field(cx, i)?.find_niche(cx)?;\n+                    if let Some((offset, primitive, niche_value)) = r {\n+                        let offset = self.fields.offset(i) + offset;\n+                        return Ok(Some((offset, primitive, niche_value)));\n                     }\n                 }\n                 Ok(None)\n@@ -2165,13 +2185,15 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Variants {\n                 variants.hash_stable(hcx, hasher);\n             }\n             NicheFilling {\n-                nndiscr,\n+                dataful_variant,\n+                ref niche,\n+                niche_value,\n                 ref variants,\n-                ref discr,\n             } => {\n-                nndiscr.hash_stable(hcx, hasher);\n+                dataful_variant.hash_stable(hcx, hasher);\n+                niche.hash_stable(hcx, hasher);\n+                niche_value.hash_stable(hcx, hasher);\n                 variants.hash_stable(hcx, hasher);\n-                discr.hash_stable(hcx, hasher);\n             }\n         }\n     }"}, {"sha": "2768c7fb5772f0292734cb6f432494f734817b1d", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b203a26efbd0d57115fc5dd40ec5410a8e5bd9da/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b203a26efbd0d57115fc5dd40ec5410a8e5bd9da/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=b203a26efbd0d57115fc5dd40ec5410a8e5bd9da", "patch": "@@ -1191,17 +1191,13 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     }\n                 }).collect()\n             }\n-            layout::Variants::NicheFilling {\n-                nndiscr,\n-                discr,\n-                ..\n-            } => {\n-                let variant = self.layout.for_variant(nndiscr as usize);\n+            layout::Variants::NicheFilling { dataful_variant, .. } => {\n+                let variant = self.layout.for_variant(dataful_variant);\n                 // Create a description of the non-null variant\n                 let (variant_type_metadata, member_description_factory) =\n                     describe_enum_variant(cx,\n                                           variant,\n-                                          &adt.variants[nndiscr as usize],\n+                                          &adt.variants[dataful_variant],\n                                           OptimizedDiscriminant,\n                                           self.containing_scope,\n                                           self.span);\n@@ -1239,8 +1235,8 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 compute_field_path(cx, &mut name,\n                                    self.layout,\n                                    self.layout.fields.offset(0),\n-                                   discr.size(cx));\n-                name.push_str(&adt.variants[(1 - nndiscr) as usize].name.as_str());\n+                                   self.layout.field(cx, 0).size);\n+                name.push_str(&adt.variants[1 - dataful_variant].name.as_str());\n \n                 // Create the (singleton) list of descriptions of union members.\n                 vec!["}, {"sha": "cf6f72d21d6d17838fd927c8802eb8dd51102bad", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b203a26efbd0d57115fc5dd40ec5410a8e5bd9da/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b203a26efbd0d57115fc5dd40ec5410a8e5bd9da/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=b203a26efbd0d57115fc5dd40ec5410a8e5bd9da", "patch": "@@ -1122,22 +1122,29 @@ fn trans_const_adt<'a, 'tcx>(\n                 },\n                 _ => 0,\n             };\n-            let discr_ty = l.field(ccx, 0).ty;\n-            let discr = C_int(ccx.layout_of(discr_ty).llvm_type(ccx), discr as i64);\n+            let discr_field = l.field(ccx, 0);\n+            let discr = C_int(discr_field.llvm_type(ccx), discr as i64);\n             if let layout::Abi::Scalar(_) = l.abi {\n                 Const::new(discr, t)\n             } else {\n-                let discr = Const::new(discr, discr_ty);\n+                let discr = Const::new(discr, discr_field.ty);\n                 build_const_struct(ccx, l.for_variant(variant_index), vals, Some(discr))\n             }\n         }\n-        layout::Variants::NicheFilling { nndiscr, .. } => {\n-            if variant_index as u64 == nndiscr {\n-                build_const_struct(ccx, l.for_variant(variant_index), vals, None)\n+        layout::Variants::NicheFilling { dataful_variant, niche_value, .. } => {\n+            if variant_index == dataful_variant {\n+                build_const_struct(ccx, l.for_variant(dataful_variant), vals, None)\n             } else {\n-                // Always use null even if it's not the `discrfield`th\n-                // field; see #8506.\n-                Const::new(C_null(ccx.layout_of(t).llvm_type(ccx)), t)\n+                let niche = l.field(ccx, 0);\n+                let niche_llty = niche.llvm_type(ccx);\n+                // FIXME(eddyb) Check the actual primitive type here.\n+                let niche_llval = if niche_value == 0 {\n+                    // HACK(eddyb) Using `C_null` as it works on all types.\n+                    C_null(niche_llty)\n+                } else {\n+                    C_uint_big(niche_llty, niche_value)\n+                };\n+                build_const_struct(ccx, l, &[Const::new(niche_llval, niche.ty)], None)\n             }\n         }\n     }"}, {"sha": "1f8209c7066a958a19d7e67f2ccffc3d7d27f702", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/b203a26efbd0d57115fc5dd40ec5410a8e5bd9da/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b203a26efbd0d57115fc5dd40ec5410a8e5bd9da/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=b203a26efbd0d57115fc5dd40ec5410a8e5bd9da", "patch": "@@ -16,7 +16,7 @@ use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n use base;\n use builder::Builder;\n-use common::{self, CrateContext, C_usize, C_u8, C_u32, C_uint, C_int, C_null};\n+use common::{self, CrateContext, C_usize, C_u8, C_u32, C_uint, C_int, C_null, C_uint_big};\n use consts;\n use type_of::LayoutLlvmExt;\n use type_::Type;\n@@ -72,10 +72,6 @@ impl Alignment {\n     }\n }\n \n-fn target_sets_discr_via_memset<'a, 'tcx>(bcx: &Builder<'a, 'tcx>) -> bool {\n-    bcx.sess().target.target.arch == \"arm\" || bcx.sess().target.target.arch == \"aarch64\"\n-}\n-\n #[derive(Copy, Clone, Debug)]\n pub struct LvalueRef<'tcx> {\n     /// Pointer to the contents of the lvalue\n@@ -325,51 +321,60 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                 };\n                 bcx.intcast(lldiscr, cast_to, signed)\n             }\n-            layout::Variants::NicheFilling { nndiscr, .. } => {\n-                let cmp = if nndiscr == 0 { llvm::IntEQ } else { llvm::IntNE };\n-                let zero = C_null(discr.layout.llvm_type(bcx.ccx));\n-                bcx.intcast(bcx.icmp(cmp, lldiscr, zero), cast_to, false)\n+            layout::Variants::NicheFilling { dataful_variant, niche_value, .. } => {\n+                let niche_llty = discr.layout.llvm_type(bcx.ccx);\n+                // FIXME(eddyb) Check the actual primitive type here.\n+                let niche_llval = if niche_value == 0 {\n+                    // HACK(eddyb) Using `C_null` as it works on all types.\n+                    C_null(niche_llty)\n+                } else {\n+                    C_uint_big(niche_llty, niche_value)\n+                };\n+                let cmp = if dataful_variant == 0 { llvm::IntEQ } else { llvm::IntNE };\n+                bcx.intcast(bcx.icmp(cmp, lldiscr, niche_llval), cast_to, false)\n             }\n         }\n     }\n \n     /// Set the discriminant for a new value of the given case of the given\n     /// representation.\n     pub fn trans_set_discr(&self, bcx: &Builder<'a, 'tcx>, variant_index: usize) {\n-        let to = self.layout.ty.ty_adt_def().unwrap()\n-            .discriminant_for_variant(bcx.tcx(), variant_index)\n-            .to_u128_unchecked() as u64;\n         match self.layout.variants {\n             layout::Variants::Single { index } => {\n-                assert_eq!(to, 0);\n                 assert_eq!(variant_index, index);\n             }\n             layout::Variants::Tagged { .. } => {\n                 let ptr = self.project_field(bcx, 0);\n+                let to = self.layout.ty.ty_adt_def().unwrap()\n+                    .discriminant_for_variant(bcx.tcx(), variant_index)\n+                    .to_u128_unchecked() as u64;\n                 bcx.store(C_int(ptr.layout.llvm_type(bcx.ccx), to as i64),\n                     ptr.llval, ptr.alignment.non_abi());\n             }\n-            layout::Variants::NicheFilling { nndiscr, .. } => {\n-                if to != nndiscr {\n-                    let use_memset = match self.layout.abi {\n-                        layout::Abi::Scalar(_) => false,\n-                        _ => target_sets_discr_via_memset(bcx)\n-                    };\n-                    if use_memset {\n-                        // Issue #34427: As workaround for LLVM bug on\n-                        // ARM, use memset of 0 on whole struct rather\n-                        // than storing null to single target field.\n+            layout::Variants::NicheFilling { dataful_variant, niche_value, .. } => {\n+                if variant_index != dataful_variant {\n+                    if bcx.sess().target.target.arch == \"arm\" ||\n+                       bcx.sess().target.target.arch == \"aarch64\" {\n+                        // Issue #34427: As workaround for LLVM bug on ARM,\n+                        // use memset of 0 before assigning niche value.\n                         let llptr = bcx.pointercast(self.llval, Type::i8(bcx.ccx).ptr_to());\n                         let fill_byte = C_u8(bcx.ccx, 0);\n                         let (size, align) = self.layout.size_and_align();\n                         let size = C_usize(bcx.ccx, size.bytes());\n                         let align = C_u32(bcx.ccx, align.abi() as u32);\n                         base::call_memset(bcx, llptr, fill_byte, size, align, false);\n-                    } else {\n-                        let ptr = self.project_field(bcx, 0);\n-                        bcx.store(C_null(ptr.layout.llvm_type(bcx.ccx)),\n-                            ptr.llval, ptr.alignment.non_abi());\n                     }\n+\n+                    let niche = self.project_field(bcx, 0);\n+                    let niche_llty = niche.layout.llvm_type(bcx.ccx);\n+                    // FIXME(eddyb) Check the actual primitive type here.\n+                    let niche_llval = if niche_value == 0 {\n+                        // HACK(eddyb) Using `C_null` as it works on all types.\n+                        C_null(niche_llty)\n+                    } else {\n+                        C_uint_big(niche_llty, niche_value)\n+                    };\n+                    bcx.store(niche_llval, niche.llval, niche.alignment.non_abi());\n                 }\n             }\n         }"}, {"sha": "dfa7b8aae31ebc225166d23ed47da8fb66f15b34", "filename": "src/test/ui/print_type_sizes/niche-filling.rs", "status": "renamed", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b203a26efbd0d57115fc5dd40ec5410a8e5bd9da/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b203a26efbd0d57115fc5dd40ec5410a8e5bd9da/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.rs?ref=b203a26efbd0d57115fc5dd40ec5410a8e5bd9da", "patch": "@@ -10,8 +10,8 @@\n \n // compile-flags: -Z print-type-sizes\n \n-// This file illustrates how enums with a non-null field are handled,\n-// modelled after cases like `Option<&u32>` and such.\n+// This file illustrates how niche-filling enums are handled,\n+// modelled after cases like `Option<&u32>`, `Option<bool>` and such.\n //\n // It uses NonZero directly, rather than `&_` or `Unique<_>`, because\n // the test is not set up to deal with target-dependent pointer width.\n@@ -72,4 +72,8 @@ pub fn main() {\n     let _x: MyOption<NonZero<u32>> = Default::default();\n     let _y: EmbeddedDiscr = Default::default();\n     let _z: MyOption<IndirectNonZero<u32>> = Default::default();\n+    let _a: MyOption<bool> = Default::default();\n+    let _b: MyOption<char> = Default::default();\n+    let _c: MyOption<std::cmp::Ordering> = Default::default();\n+    let _b: MyOption<MyOption<u8>> = Default::default();\n }", "previous_filename": "src/test/ui/print_type_sizes/nullable.rs"}, {"sha": "668b31e413f6456dafbbab19c2b424a6af41b708", "filename": "src/test/ui/print_type_sizes/niche-filling.stdout", "status": "renamed", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b203a26efbd0d57115fc5dd40ec5410a8e5bd9da/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/b203a26efbd0d57115fc5dd40ec5410a8e5bd9da/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.stdout?ref=b203a26efbd0d57115fc5dd40ec5410a8e5bd9da", "patch": "@@ -19,9 +19,35 @@ print-type-size     field `.val`: 4 bytes\n print-type-size     field `.post`: 2 bytes\n print-type-size     field `.pre`: 1 bytes\n print-type-size     end padding: 1 bytes\n+print-type-size type: `MyOption<char>`: 4 bytes, alignment: 4 bytes\n+print-type-size     variant `None`: 0 bytes\n+print-type-size     variant `Some`: 4 bytes\n+print-type-size         field `.0`: 4 bytes\n print-type-size type: `MyOption<core::nonzero::NonZero<u32>>`: 4 bytes, alignment: 4 bytes\n print-type-size     variant `None`: 0 bytes\n print-type-size     variant `Some`: 4 bytes\n print-type-size         field `.0`: 4 bytes\n print-type-size type: `core::nonzero::NonZero<u32>`: 4 bytes, alignment: 4 bytes\n print-type-size     field `.0`: 4 bytes\n+print-type-size type: `MyOption<MyOption<u8>>`: 2 bytes, alignment: 1 bytes\n+print-type-size     variant `None`: 0 bytes\n+print-type-size     variant `Some`: 2 bytes\n+print-type-size         field `.0`: 2 bytes\n+print-type-size type: `MyOption<u8>`: 2 bytes, alignment: 1 bytes\n+print-type-size     discriminant: 1 bytes\n+print-type-size     variant `None`: 0 bytes\n+print-type-size     variant `Some`: 1 bytes\n+print-type-size         field `.0`: 1 bytes\n+print-type-size type: `MyOption<bool>`: 1 bytes, alignment: 1 bytes\n+print-type-size     variant `None`: 0 bytes\n+print-type-size     variant `Some`: 1 bytes\n+print-type-size         field `.0`: 1 bytes\n+print-type-size type: `MyOption<core::cmp::Ordering>`: 1 bytes, alignment: 1 bytes\n+print-type-size     variant `None`: 0 bytes\n+print-type-size     variant `Some`: 1 bytes\n+print-type-size         field `.0`: 1 bytes\n+print-type-size type: `core::cmp::Ordering`: 1 bytes, alignment: 1 bytes\n+print-type-size     discriminant: 1 bytes\n+print-type-size     variant `Less`: 0 bytes\n+print-type-size     variant `Equal`: 0 bytes\n+print-type-size     variant `Greater`: 0 bytes", "previous_filename": "src/test/ui/print_type_sizes/nullable.stdout"}]}