{"sha": "2ffccb76cea6acb1772fbbf6e78b7d7608d650f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmZmNjYjc2Y2VhNmFjYjE3NzJmYmJmNmU3OGI3ZDc2MDhkNjUwZjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-22T16:11:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-22T16:11:14Z"}, "message": "auto merge of #15857 : treeman/rust/doc-dijkstra-example, r=alexcrichton\n\nI wanted to have a slightly larger example compared to the method examples, but I'm unsure how it worked out.\r\n\r\nFeedback would nice.", "tree": {"sha": "6327bc3d8b79c63898180960e6c9ed10fc0fabde", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6327bc3d8b79c63898180960e6c9ed10fc0fabde"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ffccb76cea6acb1772fbbf6e78b7d7608d650f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ffccb76cea6acb1772fbbf6e78b7d7608d650f2", "html_url": "https://github.com/rust-lang/rust/commit/2ffccb76cea6acb1772fbbf6e78b7d7608d650f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ffccb76cea6acb1772fbbf6e78b7d7608d650f2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d3aaa87f89fc3618a39a1f67d901fed8dc91741", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d3aaa87f89fc3618a39a1f67d901fed8dc91741", "html_url": "https://github.com/rust-lang/rust/commit/5d3aaa87f89fc3618a39a1f67d901fed8dc91741"}, {"sha": "94500b84d4355e322efafc4f21c9d29ffc676826", "url": "https://api.github.com/repos/rust-lang/rust/commits/94500b84d4355e322efafc4f21c9d29ffc676826", "html_url": "https://github.com/rust-lang/rust/commit/94500b84d4355e322efafc4f21c9d29ffc676826"}], "stats": {"total": 138, "additions": 137, "deletions": 1}, "files": [{"sha": "9451f2521c89a67e263e7c269405be245cd14aa2", "filename": "src/libcollections/priority_queue.rs", "status": "modified", "additions": 137, "deletions": 1, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/2ffccb76cea6acb1772fbbf6e78b7d7608d650f2/src%2Flibcollections%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ffccb76cea6acb1772fbbf6e78b7d7608d650f2/src%2Flibcollections%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fpriority_queue.rs?ref=2ffccb76cea6acb1772fbbf6e78b7d7608d650f2", "patch": "@@ -8,7 +8,143 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A priority queue implemented with a binary heap\n+//! A priority queue implemented with a binary heap.\n+//!\n+//! # Example\n+//!\n+//! This is a larger example which implements [Dijkstra's algorithm][dijkstra]\n+//! to solve the [shortest path problem][sssp] on a [directed graph][dir_graph].\n+//! It showcases how to use the `PriorityQueue` with custom types.\n+//!\n+//! [dijkstra]: http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\n+//! [sssp]: http://en.wikipedia.org/wiki/Shortest_path_problem\n+//! [dir_graph]: http://en.wikipedia.org/wiki/Directed_graph\n+//!\n+//! ```\n+//! use std::collections::PriorityQueue;\n+//! use std::uint;\n+//!\n+//! #[deriving(Eq, PartialEq)]\n+//! struct State {\n+//!     cost: uint,\n+//!     position: uint\n+//! }\n+//!\n+//! // The priority queue depends on `Ord`.\n+//! // Explicitly implement the trait so the queue becomes a min-heap\n+//! // instead of a max-heap.\n+//! impl Ord for State {\n+//!     fn cmp(&self, other: &State) -> Ordering {\n+//!         // Notice that the we flip the ordering here\n+//!         other.cost.cmp(&self.cost)\n+//!     }\n+//! }\n+//!\n+//! // `PartialOrd` needs to be implemented as well.\n+//! impl PartialOrd for State {\n+//!     fn partial_cmp(&self, other: &State) -> Option<Ordering> {\n+//!         Some(self.cmp(other))\n+//!     }\n+//! }\n+//!\n+//! // Each node is represented as an `uint`, for a shorter implementation.\n+//! struct Edge {\n+//!     node: uint,\n+//!     cost: uint\n+//! }\n+//!\n+//! // Dijkstra's shortest path algorithm.\n+//!\n+//! // Start at `start` and use `dist` to track the current shortest distance\n+//! // to each node. This implementation isn't memory efficient as it may leave duplicate\n+//! // nodes in the queue. It also uses `uint::MAX` as a sentinel value,\n+//! // for a simpler implementation.\n+//! fn shortest_path(adj_list: &Vec<Vec<Edge>>, start: uint, goal: uint) -> uint {\n+//!     // dist[node] = current shortest distance from `start` to `node`\n+//!     let mut dist = Vec::from_elem(adj_list.len(), uint::MAX);\n+//!\n+//!     let mut pq = PriorityQueue::new();\n+//!\n+//!     // We're at `start`, with a zero cost\n+//!     *dist.get_mut(start) = 0u;\n+//!     pq.push(State { cost: 0u, position: start });\n+//!\n+//!     // Examine the frontier with lower cost nodes first (min-heap)\n+//!     loop {\n+//!         let State { cost, position } = match pq.pop() {\n+//!             None => break, // empty\n+//!             Some(s) => s\n+//!         };\n+//!\n+//!         // Alternatively we could have continued to find all shortest paths\n+//!         if position == goal { return cost }\n+//!\n+//!         // Important as we may have already found a better way\n+//!         if cost > dist[position] { continue }\n+//!\n+//!         // For each node we can reach, see if we can find a way with\n+//!         // a lower cost going through this node\n+//!         for edge in adj_list[position].iter() {\n+//!             let next = State { cost: cost + edge.cost, position: edge.node };\n+//!\n+//!             // If so, add it to the frontier and continue\n+//!             if next.cost < dist[next.position] {\n+//!                 pq.push(next);\n+//!                 // Relaxation, we have now found a better way\n+//!                 *dist.get_mut(next.position) = next.cost;\n+//!             }\n+//!         }\n+//!     }\n+//!\n+//!     // Goal not reachable\n+//!     uint::MAX\n+//! }\n+//!\n+//! fn main() {\n+//!     // This is the directed graph we're going to use.\n+//!     // The node numbers correspond to the different states,\n+//!     // and the edge weights symbolises the cost of moving\n+//!     // from one node to another.\n+//!     // Note that the edges are one-way.\n+//!     //\n+//!     //                  7\n+//!     //          +-----------------+\n+//!     //          |                 |\n+//!     //          v   1        2    |\n+//!     //          0 -----> 1 -----> 3 ---> 4\n+//!     //          |        ^        ^      ^\n+//!     //          |        | 1      |      |\n+//!     //          |        |        | 3    | 1\n+//!     //          +------> 2 -------+      |\n+//!     //           10      |               |\n+//!     //                   +---------------+\n+//!     //\n+//!     // The graph is represented as an adjecency list where each index,\n+//!     // corresponding to a node value, has a list of outgoing edges.\n+//!     // Chosen for it's efficiency.\n+//!     let graph = vec![\n+//!         // Node 0\n+//!         vec![Edge { node: 2, cost: 10 },\n+//!              Edge { node: 1, cost: 1 }],\n+//!         // Node 1\n+//!         vec![Edge { node: 3, cost: 2 }],\n+//!         // Node 2\n+//!         vec![Edge { node: 1, cost: 1 },\n+//!              Edge { node: 3, cost: 3 },\n+//!              Edge { node: 4, cost: 1 }],\n+//!         // Node 3\n+//!         vec![Edge { node: 0, cost: 7 },\n+//!              Edge { node: 4, cost: 2 }],\n+//!         // Node 4\n+//!         vec![]];\n+//!\n+//!     assert_eq!(shortest_path(&graph, 0, 1), 1);\n+//!     assert_eq!(shortest_path(&graph, 0, 3), 3);\n+//!     assert_eq!(shortest_path(&graph, 3, 0), 7);\n+//!     assert_eq!(shortest_path(&graph, 0, 4), 5);\n+//!     assert_eq!(shortest_path(&graph, 4, 0), uint::MAX);\n+//! }\n+//! ```\n \n #![allow(missing_doc)]\n "}]}