{"sha": "0807104c8fa90b084748940f7a7980b5a765264e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4MDcxMDRjOGZhOTBiMDg0NzQ4OTQwZjdhNzk4MGI1YTc2NTI2NGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-28T04:12:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-28T04:12:11Z"}, "message": "Auto merge of #38579 - whitequark:min_atomic_width, r=alexcrichton\n\nAdd a min_atomic_width target option, like max_atomic_width\n\nRationale: some ISAs, e.g. OR1K, do not have atomic instructions\nfor byte and halfword access, and at the same time do not have\na fixed endianness, which makes it unreasonable to implement these\nthrough word-sized atomic accesses.", "tree": {"sha": "9c52c367fbe10fb11264fc1bf7b1a96b1551ef1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c52c367fbe10fb11264fc1bf7b1a96b1551ef1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0807104c8fa90b084748940f7a7980b5a765264e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0807104c8fa90b084748940f7a7980b5a765264e", "html_url": "https://github.com/rust-lang/rust/commit/0807104c8fa90b084748940f7a7980b5a765264e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0807104c8fa90b084748940f7a7980b5a765264e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9ab7788150d19e44419c3b153336aa24ad830b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9ab7788150d19e44419c3b153336aa24ad830b9", "html_url": "https://github.com/rust-lang/rust/commit/a9ab7788150d19e44419c3b153336aa24ad830b9"}, {"sha": "5b0700ef314c428b2533a02171e0566f70599222", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b0700ef314c428b2533a02171e0566f70599222", "html_url": "https://github.com/rust-lang/rust/commit/5b0700ef314c428b2533a02171e0566f70599222"}], "stats": {"total": 15, "additions": 14, "deletions": 1}, "files": [{"sha": "a78482171a0de501abaa1d0f40ffd6292e995807", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0807104c8fa90b084748940f7a7980b5a765264e/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0807104c8fa90b084748940f7a7980b5a765264e/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=0807104c8fa90b084748940f7a7980b5a765264e", "patch": "@@ -943,6 +943,7 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     let os = &sess.target.target.target_os;\n     let env = &sess.target.target.target_env;\n     let vendor = &sess.target.target.target_vendor;\n+    let min_atomic_width = sess.target.target.min_atomic_width();\n     let max_atomic_width = sess.target.target.max_atomic_width();\n \n     let mut ret = HashSet::new();\n@@ -963,7 +964,7 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n         ret.insert((Symbol::intern(\"target_thread_local\"), None));\n     }\n     for &i in &[8, 16, 32, 64, 128] {\n-        if i <= max_atomic_width {\n+        if i >= min_atomic_width && i <= max_atomic_width {\n             let s = i.to_string();\n             ret.insert((Symbol::intern(\"target_has_atomic\"), Some(Symbol::intern(&s))));\n             if &s == wordsz {"}, {"sha": "6a409edf0feccbf564f38d91cfbbf24888e29765", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0807104c8fa90b084748940f7a7980b5a765264e/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0807104c8fa90b084748940f7a7980b5a765264e/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=0807104c8fa90b084748940f7a7980b5a765264e", "patch": "@@ -376,6 +376,9 @@ pub struct TargetOptions {\n     // file\n     pub no_integrated_as: bool,\n \n+    /// Don't use this field; instead use the `.min_atomic_width()` method.\n+    pub min_atomic_width: Option<u64>,\n+\n     /// Don't use this field; instead use the `.max_atomic_width()` method.\n     pub max_atomic_width: Option<u64>,\n \n@@ -439,6 +442,7 @@ impl Default for TargetOptions {\n             has_elf_tls: false,\n             obj_is_bitcode: false,\n             no_integrated_as: false,\n+            min_atomic_width: None,\n             max_atomic_width: None,\n             panic_strategy: PanicStrategy::Unwind,\n             abi_blacklist: vec![],\n@@ -462,6 +466,12 @@ impl Target {\n         }\n     }\n \n+    /// Minimum integer size in bits that this target can perform atomic\n+    /// operations on.\n+    pub fn min_atomic_width(&self) -> u64 {\n+        self.options.min_atomic_width.unwrap_or(8)\n+    }\n+\n     /// Maximum integer size in bits that this target can perform atomic\n     /// operations on.\n     pub fn max_atomic_width(&self) -> u64 {\n@@ -604,6 +614,7 @@ impl Target {\n         key!(obj_is_bitcode, bool);\n         key!(no_integrated_as, bool);\n         key!(max_atomic_width, Option<u64>);\n+        key!(min_atomic_width, Option<u64>);\n         try!(key!(panic_strategy, PanicStrategy));\n         key!(crt_static_default, bool);\n \n@@ -766,6 +777,7 @@ impl ToJson for Target {\n         target_option_val!(has_elf_tls);\n         target_option_val!(obj_is_bitcode);\n         target_option_val!(no_integrated_as);\n+        target_option_val!(min_atomic_width);\n         target_option_val!(max_atomic_width);\n         target_option_val!(panic_strategy);\n         target_option_val!(crt_static_default);"}]}