{"sha": "73a7672b8d9ddab92c91d1b343535b9a9a765b68", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczYTc2NzJiOGQ5ZGRhYjkyYzkxZDFiMzQzNTM1YjlhOWE3NjViNjg=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-02-05T00:48:52Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-02-05T00:48:52Z"}, "message": "std: Stamp out structural records\n\nSee #4665", "tree": {"sha": "03632c94b76aeb4e2f6c75996fd033961557ebb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03632c94b76aeb4e2f6c75996fd033961557ebb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73a7672b8d9ddab92c91d1b343535b9a9a765b68", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73a7672b8d9ddab92c91d1b343535b9a9a765b68", "html_url": "https://github.com/rust-lang/rust/commit/73a7672b8d9ddab92c91d1b343535b9a9a765b68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73a7672b8d9ddab92c91d1b343535b9a9a765b68/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27e1ac5bb93626da70135e167a6596d854e7e679", "url": "https://api.github.com/repos/rust-lang/rust/commits/27e1ac5bb93626da70135e167a6596d854e7e679", "html_url": "https://github.com/rust-lang/rust/commit/27e1ac5bb93626da70135e167a6596d854e7e679"}], "stats": {"total": 145, "additions": 74, "deletions": 71}, "files": [{"sha": "17920f5de3fedec9cb33047cd18ea5d55d1b0ba2", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/73a7672b8d9ddab92c91d1b343535b9a9a765b68/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a7672b8d9ddab92c91d1b343535b9a9a765b68/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=73a7672b8d9ddab92c91d1b343535b9a9a765b68", "patch": "@@ -46,11 +46,11 @@ use core::task;\n /**\n  * The type representing a foreign chunk of memory\n  *\n- * Wrapped in a enum for opacity; FIXME #818 when it is possible to have\n- * truly opaque types, this should be revisited.\n  */\n-pub enum CVec<T> {\n-    CVecCtor({ base: *mut T, len: uint, rsrc: @DtorRes})\n+pub struct CVec<T> {\n+    priv base: *mut T,\n+    priv len: uint,\n+    priv rsrc: @DtorRes\n }\n \n struct DtorRes {\n@@ -85,11 +85,11 @@ fn DtorRes(dtor: Option<fn@()>) -> DtorRes {\n  * * len - The number of elements in the buffer\n  */\n pub unsafe fn CVec<T>(base: *mut T, len: uint) -> CVec<T> {\n-    return CVecCtor({\n+    return CVec{\n         base: base,\n         len: len,\n         rsrc: @DtorRes(option::None)\n-    });\n+    };\n }\n \n /**\n@@ -105,11 +105,11 @@ pub unsafe fn CVec<T>(base: *mut T, len: uint) -> CVec<T> {\n  */\n pub unsafe fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: fn@())\n   -> CVec<T> {\n-    return CVecCtor({\n+    return CVec{\n         base: base,\n         len: len,\n         rsrc: @DtorRes(option::Some(dtor))\n-    });\n+    };\n }\n \n /*\n@@ -123,7 +123,7 @@ pub unsafe fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: fn@())\n  */\n pub fn get<T: Copy>(t: CVec<T>, ofs: uint) -> T {\n     assert ofs < len(t);\n-    return unsafe { *ptr::mut_offset((*t).base, ofs) };\n+    return unsafe { *ptr::mut_offset(t.base, ofs) };\n }\n \n /**\n@@ -133,22 +133,18 @@ pub fn get<T: Copy>(t: CVec<T>, ofs: uint) -> T {\n  */\n pub fn set<T: Copy>(t: CVec<T>, ofs: uint, v: T) {\n     assert ofs < len(t);\n-    unsafe { *ptr::mut_offset((*t).base, ofs) = v };\n+    unsafe { *ptr::mut_offset(t.base, ofs) = v };\n }\n \n /*\n  Section: Elimination forms\n  */\n \n /// Returns the length of the vector\n-pub pure fn len<T>(t: CVec<T>) -> uint {\n-    return (*t).len;\n-}\n+pub pure fn len<T>(t: CVec<T>) -> uint { t.len }\n \n /// Returns a pointer to the first element of the vector\n-pub unsafe fn ptr<T>(t: CVec<T>) -> *mut T {\n-    return (*t).base;\n-}\n+pub unsafe fn ptr<T>(t: CVec<T>) -> *mut T { t.base }\n \n #[cfg(test)]\n mod tests {"}, {"sha": "aaeecfb330210803c219ae791ca0319a6ac2c30b", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/73a7672b8d9ddab92c91d1b343535b9a9a765b68/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a7672b8d9ddab92c91d1b343535b9a9a765b68/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=73a7672b8d9ddab92c91d1b343535b9a9a765b68", "patch": "@@ -84,22 +84,27 @@ pub mod reader {\n         }\n     }\n \n-    fn vuint_at(data: &[u8], start: uint) -> {val: uint, next: uint} {\n+    struct Res {\n+        val: uint,\n+        next: uint\n+    }\n+\n+    fn vuint_at(data: &[u8], start: uint) -> Res {\n         let a = data[start];\n         if a & 0x80u8 != 0u8 {\n-            return {val: (a & 0x7fu8) as uint, next: start + 1u};\n+            return Res {val: (a & 0x7fu8) as uint, next: start + 1u};\n         }\n         if a & 0x40u8 != 0u8 {\n-            return {val: ((a & 0x3fu8) as uint) << 8u |\n+            return Res {val: ((a & 0x3fu8) as uint) << 8u |\n                         (data[start + 1u] as uint),\n                     next: start + 2u};\n         } else if a & 0x20u8 != 0u8 {\n-            return {val: ((a & 0x1fu8) as uint) << 16u |\n+            return Res {val: ((a & 0x1fu8) as uint) << 16u |\n                         (data[start + 1u] as uint) << 8u |\n                         (data[start + 2u] as uint),\n                     next: start + 3u};\n         } else if a & 0x10u8 != 0u8 {\n-            return {val: ((a & 0x0fu8) as uint) << 24u |\n+            return Res {val: ((a & 0x0fu8) as uint) << 24u |\n                         (data[start + 1u] as uint) << 16u |\n                         (data[start + 2u] as uint) << 8u |\n                         (data[start + 3u] as uint),"}, {"sha": "718e805b5d925a14922af4670bb989e55593ff7a", "filename": "src/libstd/md4.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/73a7672b8d9ddab92c91d1b343535b9a9a765b68/src%2Flibstd%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a7672b8d9ddab92c91d1b343535b9a9a765b68/src%2Flibstd%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmd4.rs?ref=73a7672b8d9ddab92c91d1b343535b9a9a765b68", "patch": "@@ -14,7 +14,14 @@ use core::str;\n use core::uint;\n use core::vec;\n \n-pub pure fn md4(msg: &[u8]) -> {a: u32, b: u32, c: u32, d: u32} {\n+struct Quad {\n+    a: u32,\n+    b: u32,\n+    c: u32,\n+    d: u32\n+}\n+\n+pub pure fn md4(msg: &[u8]) -> Quad {\n     // subtle: if orig_len is merely uint, then the code below\n     // which performs shifts by 32 bits or more has undefined\n     // results.\n@@ -95,11 +102,11 @@ pub pure fn md4(msg: &[u8]) -> {a: u32, b: u32, c: u32, d: u32} {\n         a += aa; b += bb; c += cc; d += dd;\n         i += 64u;\n     }\n-    return {a: a, b: b, c: c, d: d};\n+    return Quad {a: a, b: b, c: c, d: d};\n }\n \n pub pure fn md4_str(msg: &[u8]) -> ~str {\n-    let {a, b, c, d} = md4(msg);\n+    let Quad {a, b, c, d} = md4(msg);\n     pure fn app(a: u32, b: u32, c: u32, d: u32, f: fn(u32)) {\n         f(a); f(b); f(c); f(d);\n     }"}, {"sha": "5fb7d892c58cabbdbf2885916066b44336147576", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73a7672b8d9ddab92c91d1b343535b9a9a765b68/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a7672b8d9ddab92c91d1b343535b9a9a765b68/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=73a7672b8d9ddab92c91d1b343535b9a9a765b68", "patch": "@@ -66,7 +66,7 @@ const k3: u32 = 0xCA62C1D6u32;\n \n /// Construct a `sha` object\n pub fn sha1() -> Sha1 {\n-    type Sha1State =\n+    struct Sha1State\n         {h: ~[mut u32],\n          mut len_low: u32,\n          mut len_high: u32,\n@@ -258,7 +258,7 @@ pub fn sha1() -> Sha1 {\n             return s;\n         }\n     }\n-    let st = {\n+    let st = Sha1State {\n         h: vec::cast_to_mut(vec::from_elem(digest_buf_len, 0u32)),\n         mut len_low: 0u32,\n         mut len_high: 0u32,"}, {"sha": "a2fbc8b1db1e296b6f877b6f8edb0125ae2df032", "filename": "src/libstd/std.rc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73a7672b8d9ddab92c91d1b343535b9a9a765b68/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/73a7672b8d9ddab92c91d1b343535b9a9a765b68/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=73a7672b8d9ddab92c91d1b343535b9a9a765b68", "patch": "@@ -34,10 +34,6 @@ not required in or otherwise suitable for the core library.\n #[forbid(deprecated_pattern)];\n #[allow(deprecated_self)];\n \n-\n-// Transitional\n-#[legacy_records];\n-\n #[no_core];\n \n extern mod core(vers = \"0.6\");"}, {"sha": "4f0b7da89aa813d394ef35419b5dba7423c2d59f", "filename": "src/libstd/test.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/73a7672b8d9ddab92c91d1b343535b9a9a765b68/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a7672b8d9ddab92c91d1b343535b9a9a765b68/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=73a7672b8d9ddab92c91d1b343535b9a9a765b68", "patch": "@@ -92,7 +92,7 @@ pub fn parse_opts(args: &[~str]) -> OptRes {\n         };\n \n     let filter =\n-        if vec::len(matches.free) > 0u {\n+        if vec::len(matches.free) > 0 {\n             option::Some(matches.free[0])\n         } else { option::None };\n \n@@ -111,26 +111,27 @@ pub fn parse_opts(args: &[~str]) -> OptRes {\n #[deriving_eq]\n pub enum TestResult { TrOk, TrFailed, TrIgnored, }\n \n-type ConsoleTestState =\n-    @{out: io::Writer,\n-      log_out: Option<io::Writer>,\n-      use_color: bool,\n-      mut total: uint,\n-      mut passed: uint,\n-      mut failed: uint,\n-      mut ignored: uint,\n-      mut failures: ~[TestDesc]};\n+struct ConsoleTestState {\n+    out: io::Writer,\n+    log_out: Option<io::Writer>,\n+    use_color: bool,\n+    mut total: uint,\n+    mut passed: uint,\n+    mut failed: uint,\n+    mut ignored: uint,\n+    mut failures: ~[TestDesc]\n+}\n \n // A simple console test runner\n pub fn run_tests_console(opts: &TestOpts,\n                      tests: &[TestDesc]) -> bool {\n \n-    fn callback(event: &TestEvent, st: ConsoleTestState) {\n+    fn callback(event: &TestEvent, st: @ConsoleTestState) {\n         debug!(\"callback(event=%?)\", event);\n         match *event {\n           TeFiltered(ref filtered_tests) => {\n             st.total = filtered_tests.len();\n-            let noun = if st.total != 1u { ~\"tests\" } else { ~\"test\" };\n+            let noun = if st.total != 1 { ~\"tests\" } else { ~\"test\" };\n             st.out.write_line(fmt!(\"\\nrunning %u %s\", st.total, noun));\n           }\n           TeWait(ref test) => st.out.write_str(\n@@ -142,18 +143,18 @@ pub fn run_tests_console(opts: &TestOpts,\n             }\n             match result {\n               TrOk => {\n-                st.passed += 1u;\n+                st.passed += 1;\n                 write_ok(st.out, st.use_color);\n                 st.out.write_line(~\"\");\n               }\n               TrFailed => {\n-                st.failed += 1u;\n+                st.failed += 1;\n                 write_failed(st.out, st.use_color);\n                 st.out.write_line(~\"\");\n                 st.failures.push(move test);\n               }\n               TrIgnored => {\n-                st.ignored += 1u;\n+                st.ignored += 1;\n                 write_ignored(st.out, st.use_color);\n                 st.out.write_line(~\"\");\n               }\n@@ -174,19 +175,19 @@ pub fn run_tests_console(opts: &TestOpts,\n     };\n \n     let st =\n-        @{out: io::stdout(),\n+        @ConsoleTestState{out: io::stdout(),\n           log_out: log_out,\n           use_color: use_color(),\n-          mut total: 0u,\n-          mut passed: 0u,\n-          mut failed: 0u,\n-          mut ignored: 0u,\n+          mut total: 0,\n+          mut passed: 0,\n+          mut failed: 0,\n+          mut ignored: 0,\n           mut failures: ~[]};\n \n     run_tests(opts, tests, |x| callback(&x, st));\n \n     assert (st.passed + st.failed + st.ignored == st.total);\n-    let success = st.failed == 0u;\n+    let success = st.failed == 0;\n \n     if !success {\n         print_failures(st);\n@@ -234,7 +235,7 @@ pub fn run_tests_console(opts: &TestOpts,\n     }\n }\n \n-fn print_failures(st: ConsoleTestState) {\n+fn print_failures(st: @ConsoleTestState) {\n     st.out.write_line(~\"\\nfailures:\");\n     let failures = copy st.failures;\n     let failures = vec::map(failures, |test| test.name);\n@@ -262,13 +263,13 @@ fn should_sort_failures_before_printing_them() {\n         };\n \n         let st =\n-            @{out: wr,\n+            @ConsoleTestState{out: wr,\n               log_out: option::None,\n               use_color: false,\n-              mut total: 0u,\n-              mut passed: 0u,\n-              mut failed: 0u,\n-              mut ignored: 0u,\n+              mut total: 0,\n+              mut passed: 0,\n+              mut failed: 0,\n+              mut ignored: 0,\n               mut failures: ~[move test_b, move test_a]};\n \n         print_failures(st);\n@@ -279,7 +280,7 @@ fn should_sort_failures_before_printing_them() {\n     assert apos < bpos;\n }\n \n-fn use_color() -> bool { return get_concurrency() == 1u; }\n+fn use_color() -> bool { return get_concurrency() == 1; }\n \n enum TestEvent {\n     TeFiltered(~[TestDesc]),\n@@ -334,15 +335,15 @@ fn run_tests(opts: &TestOpts,\n \n // Windows tends to dislike being overloaded with threads.\n #[cfg(windows)]\n-const sched_overcommit : uint = 1u;\n+const sched_overcommit : uint = 1;\n \n #[cfg(unix)]\n const sched_overcommit : uint = 4u;\n \n fn get_concurrency() -> uint {\n     unsafe {\n         let threads = rustrt::rust_sched_threads() as uint;\n-        if threads == 1u { 1u }\n+        if threads == 1 { 1 }\n         else { threads * sched_overcommit }\n     }\n }\n@@ -556,7 +557,7 @@ mod tests {\n         ];\n         let filtered = filter_tests(&opts, tests);\n \n-        assert (vec::len(filtered) == 1u);\n+        assert (vec::len(filtered) == 1);\n         assert (filtered[0].name == ~\"1\");\n         assert (filtered[0].ignore == false);\n     }"}, {"sha": "fe4137f76be9a42defe046b4a576ddbed4dfc6b0", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/73a7672b8d9ddab92c91d1b343535b9a9a765b68/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a7672b8d9ddab92c91d1b343535b9a9a765b68/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=73a7672b8d9ddab92c91d1b343535b9a9a765b68", "patch": "@@ -27,19 +27,17 @@ use core::task::TaskBuilder;\n use core::task;\n \n /// Used to abstract-away direct interaction with a libuv loop.\n-pub enum IoTask {\n-    IoTask_({\n-        async_handle: *ll::uv_async_t,\n-        op_chan: SharedChan<IoTaskMsg>\n-    })\n+pub struct IoTask {\n+    async_handle: *ll::uv_async_t,\n+    op_chan: SharedChan<IoTaskMsg>\n }\n \n impl IoTask: Clone {\n     fn clone(&self) -> IoTask {\n-        IoTask_({\n+        IoTask{\n             async_handle: self.async_handle,\n             op_chan: self.op_chan.clone()\n-        })\n+        }\n     }\n }\n \n@@ -131,10 +129,10 @@ fn run_loop(iotask_ch: &Chan<IoTask>) {\n \n         // Send out a handle through which folks can talk to us\n         // while we dwell in the I/O loop\n-        let iotask = IoTask_({\n+        let iotask = IoTask{\n             async_handle: async_handle,\n             op_chan: SharedChan(msg_ch)\n-        });\n+        };\n         iotask_ch.send(iotask);\n \n         log(debug, ~\"about to run uv loop\");"}, {"sha": "ca5a821921a7de3819712c582ffb0bd09f244c04", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73a7672b8d9ddab92c91d1b343535b9a9a765b68/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a7672b8d9ddab92c91d1b343535b9a9a765b68/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=73a7672b8d9ddab92c91d1b343535b9a9a765b68", "patch": "@@ -1543,7 +1543,7 @@ pub mod test {\n             let continue_async_handle_ptr =\n                 ptr::addr_of(&continue_async_handle);\n             let async_data =\n-                { continue_chan: continue_chan };\n+                async_handle_data { continue_chan: continue_chan };\n             let async_data_ptr = ptr::addr_of(&async_data);\n \n             let server_data = tcp_server_data {"}]}