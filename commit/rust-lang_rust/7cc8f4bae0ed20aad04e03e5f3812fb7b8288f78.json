{"sha": "7cc8f4bae0ed20aad04e03e5f3812fb7b8288f78", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjYzhmNGJhZTBlZDIwYWFkMDRlMDNlNWYzODEyZmI3YjgyODhmNzg=", "commit": {"author": {"name": "G\u00e1bor Horv\u00e1th", "email": "xazax.hun@gmail.com", "date": "2013-07-25T08:46:31Z"}, "committer": {"name": "G\u00e1bor Horv\u00e1th", "email": "xazax.hun@gmail.com", "date": "2013-07-25T08:46:31Z"}, "message": "Added some more atomic operations.", "tree": {"sha": "6acc60128a118c71ed6cafa7430734f53f97cf3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6acc60128a118c71ed6cafa7430734f53f97cf3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7cc8f4bae0ed20aad04e03e5f3812fb7b8288f78", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7cc8f4bae0ed20aad04e03e5f3812fb7b8288f78", "html_url": "https://github.com/rust-lang/rust/commit/7cc8f4bae0ed20aad04e03e5f3812fb7b8288f78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7cc8f4bae0ed20aad04e03e5f3812fb7b8288f78/comments", "author": {"login": "Xazax-hun", "id": 922897, "node_id": "MDQ6VXNlcjkyMjg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/922897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xazax-hun", "html_url": "https://github.com/Xazax-hun", "followers_url": "https://api.github.com/users/Xazax-hun/followers", "following_url": "https://api.github.com/users/Xazax-hun/following{/other_user}", "gists_url": "https://api.github.com/users/Xazax-hun/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xazax-hun/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xazax-hun/subscriptions", "organizations_url": "https://api.github.com/users/Xazax-hun/orgs", "repos_url": "https://api.github.com/users/Xazax-hun/repos", "events_url": "https://api.github.com/users/Xazax-hun/events{/privacy}", "received_events_url": "https://api.github.com/users/Xazax-hun/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Xazax-hun", "id": 922897, "node_id": "MDQ6VXNlcjkyMjg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/922897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xazax-hun", "html_url": "https://github.com/Xazax-hun", "followers_url": "https://api.github.com/users/Xazax-hun/followers", "following_url": "https://api.github.com/users/Xazax-hun/following{/other_user}", "gists_url": "https://api.github.com/users/Xazax-hun/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xazax-hun/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xazax-hun/subscriptions", "organizations_url": "https://api.github.com/users/Xazax-hun/orgs", "repos_url": "https://api.github.com/users/Xazax-hun/repos", "events_url": "https://api.github.com/users/Xazax-hun/events{/privacy}", "received_events_url": "https://api.github.com/users/Xazax-hun/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "467d381d3afce474309d6ba9a334fa9b463c3a7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/467d381d3afce474309d6ba9a334fa9b463c3a7f", "html_url": "https://github.com/rust-lang/rust/commit/467d381d3afce474309d6ba9a334fa9b463c3a7f"}], "stats": {"total": 186, "additions": 184, "deletions": 2}, "files": [{"sha": "712c32d2436623f4049934f83108c429beb4b9d6", "filename": "src/libstd/unstable/atomics.rs", "status": "modified", "additions": 184, "deletions": 2, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/7cc8f4bae0ed20aad04e03e5f3812fb7b8288f78/src%2Flibstd%2Funstable%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cc8f4bae0ed20aad04e03e5f3812fb7b8288f78/src%2Flibstd%2Funstable%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fatomics.rs?ref=7cc8f4bae0ed20aad04e03e5f3812fb7b8288f78", "patch": "@@ -96,7 +96,7 @@ impl AtomicFlag {\n      */\n     #[inline]\n     pub fn test_and_set(&mut self, order: Ordering) -> bool {\n-        unsafe {atomic_compare_and_swap(&mut self.v, 0, 1, order) > 0}\n+        unsafe { atomic_compare_and_swap(&mut self.v, 0, 1, order) > 0 }\n     }\n }\n \n@@ -121,7 +121,7 @@ impl AtomicBool {\n     pub fn swap(&mut self, val: bool, order: Ordering) -> bool {\n         let val = if val { 1 } else { 0 };\n \n-        unsafe { atomic_swap(&mut self.v, val, order) > 0}\n+        unsafe { atomic_swap(&mut self.v, val, order) > 0 }\n     }\n \n     #[inline]\n@@ -131,6 +131,38 @@ impl AtomicBool {\n \n         unsafe { atomic_compare_and_swap(&mut self.v, old, new, order) > 0 }\n     }\n+\n+    /// Returns the old value\n+    #[inline]\n+    pub fn fetch_and(&mut self, val: bool, order: Ordering) -> bool {\n+        let val = if val { 1 } else { 0 };\n+\n+        unsafe { atomic_and(&mut self.v, val, order) > 0 }\n+    }\n+\n+    /// Returns the old value\n+    #[inline]\n+    pub fn fetch_nand(&mut self, val: bool, order: Ordering) -> bool {\n+        let val = if val { 1 } else { 0 };\n+\n+        unsafe { atomic_nand(&mut self.v, val, order) > 0 }\n+    }\n+\n+    /// Returns the old value\n+    #[inline]\n+    pub fn fetch_or(&mut self, val: bool, order: Ordering) -> bool {\n+        let val = if val { 1 } else { 0 };\n+\n+        unsafe { atomic_or(&mut self.v, val, order) > 0 }\n+    }\n+\n+    /// Returns the old value\n+    #[inline]\n+    pub fn fetch_xor(&mut self, val: bool, order: Ordering) -> bool {\n+        let val = if val { 1 } else { 0 };\n+\n+        unsafe { atomic_xor(&mut self.v, val, order) > 0 }\n+    }\n }\n \n impl AtomicInt {\n@@ -169,6 +201,18 @@ impl AtomicInt {\n     pub fn fetch_sub(&mut self, val: int, order: Ordering) -> int {\n         unsafe { atomic_sub(&mut self.v, val, order) }\n     }\n+\n+    /// Returns the old value\n+    #[inline]\n+    pub fn fetch_min(&mut self, val: int, order: Ordering) -> int {\n+        unsafe { atomic_min(&mut self.v, val, order) }\n+    }\n+\n+    /// Returns the old value\n+    #[inline]\n+    pub fn fetch_max(&mut self, val: int, order: Ordering) -> int {\n+        unsafe { atomic_max(&mut self.v, val, order) }\n+    }\n }\n \n impl AtomicUint {\n@@ -207,6 +251,18 @@ impl AtomicUint {\n     pub fn fetch_sub(&mut self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_sub(&mut self.v, val, order) }\n     }\n+\n+    /// Returns the old value\n+    #[inline]\n+    pub fn fetch_min(&mut self, val: uint, order: Ordering) -> uint {\n+        unsafe { atomic_umin(&mut self.v, val, order) }\n+    }\n+\n+    /// Returns the old value\n+    #[inline]\n+    pub fn fetch_max(&mut self, val: uint, order: Ordering) -> uint {\n+        unsafe { atomic_umax(&mut self.v, val, order) }\n+    }\n }\n \n impl<T> AtomicPtr<T> {\n@@ -395,6 +451,125 @@ pub unsafe fn atomic_compare_and_swap<T>(dst:&mut T, old:T, new:T, order: Orderi\n     })\n }\n \n+#[inline]\n+pub unsafe fn atomic_and<T>(dst: &mut T, val: T, order: Ordering) -> T {\n+    let dst = cast::transmute(dst);\n+    let val = cast::transmute(val);\n+\n+    cast::transmute(match order {\n+        Acquire => intrinsics::atomic_and_acq(dst, val),\n+        Release => intrinsics::atomic_and_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_and_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_and_relaxed(dst, val),\n+        _       => intrinsics::atomic_and(dst, val)\n+    })\n+}\n+\n+\n+#[inline]\n+pub unsafe fn atomic_nand<T>(dst: &mut T, val: T, order: Ordering) -> T {\n+    let dst = cast::transmute(dst);\n+    let val = cast::transmute(val);\n+\n+    cast::transmute(match order {\n+        Acquire => intrinsics::atomic_nand_acq(dst, val),\n+        Release => intrinsics::atomic_nand_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_nand_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_nand_relaxed(dst, val),\n+        _       => intrinsics::atomic_nand(dst, val)\n+    })\n+}\n+\n+\n+#[inline]\n+pub unsafe fn atomic_or<T>(dst: &mut T, val: T, order: Ordering) -> T {\n+    let dst = cast::transmute(dst);\n+    let val = cast::transmute(val);\n+\n+    cast::transmute(match order {\n+        Acquire => intrinsics::atomic_or_acq(dst, val),\n+        Release => intrinsics::atomic_or_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_or_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_or_relaxed(dst, val),\n+        _       => intrinsics::atomic_or(dst, val)\n+    })\n+}\n+\n+\n+#[inline]\n+pub unsafe fn atomic_xor<T>(dst: &mut T, val: T, order: Ordering) -> T {\n+    let dst = cast::transmute(dst);\n+    let val = cast::transmute(val);\n+\n+    cast::transmute(match order {\n+        Acquire => intrinsics::atomic_xor_acq(dst, val),\n+        Release => intrinsics::atomic_xor_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_xor_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_xor_relaxed(dst, val),\n+        _       => intrinsics::atomic_xor(dst, val)\n+    })\n+}\n+\n+\n+#[inline]\n+pub unsafe fn atomic_max<T>(dst: &mut T, val: T, order: Ordering) -> T {\n+    let dst = cast::transmute(dst);\n+    let val = cast::transmute(val);\n+\n+    cast::transmute(match order {\n+        Acquire => intrinsics::atomic_max_acq(dst, val),\n+        Release => intrinsics::atomic_max_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_max_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_max_relaxed(dst, val),\n+        _       => intrinsics::atomic_max(dst, val)\n+    })\n+}\n+\n+\n+#[inline]\n+pub unsafe fn atomic_min<T>(dst: &mut T, val: T, order: Ordering) -> T {\n+    let dst = cast::transmute(dst);\n+    let val = cast::transmute(val);\n+\n+    cast::transmute(match order {\n+        Acquire => intrinsics::atomic_min_acq(dst, val),\n+        Release => intrinsics::atomic_min_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_min_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_min_relaxed(dst, val),\n+        _       => intrinsics::atomic_min(dst, val)\n+    })\n+}\n+\n+#[inline]\n+pub unsafe fn atomic_umax<T>(dst: &mut T, val: T, order: Ordering) -> T {\n+    let dst = cast::transmute(dst);\n+    let val = cast::transmute(val);\n+\n+    cast::transmute(match order {\n+        Acquire => intrinsics::atomic_umax_acq(dst, val),\n+        Release => intrinsics::atomic_umax_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_umax_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_umax_relaxed(dst, val),\n+        _       => intrinsics::atomic_umax(dst, val)\n+    })\n+}\n+\n+\n+#[inline]\n+pub unsafe fn atomic_umin<T>(dst: &mut T, val: T, order: Ordering) -> T {\n+    let dst = cast::transmute(dst);\n+    let val = cast::transmute(val);\n+\n+    cast::transmute(match order {\n+        Acquire => intrinsics::atomic_umin_acq(dst, val),\n+        Release => intrinsics::atomic_umin_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_umin_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_umin_relaxed(dst, val),\n+        _       => intrinsics::atomic_umin(dst, val)\n+    })\n+}\n+\n+\n #[cfg(test)]\n mod test {\n     use option::*;\n@@ -448,4 +623,11 @@ mod test {\n         assert!(p.fill(~2, SeqCst).is_none()); // shouldn't fail\n         assert_eq!(p.take(SeqCst), Some(~2));\n     }\n+\n+    #[test]\n+    fn bool_and() {\n+        let mut a = AtomicBool::new(true);\n+        assert_eq!(a.fetch_and(false, SeqCst),true);\n+        assert_eq!(a.load(SeqCst),false);\n+    }\n }"}]}