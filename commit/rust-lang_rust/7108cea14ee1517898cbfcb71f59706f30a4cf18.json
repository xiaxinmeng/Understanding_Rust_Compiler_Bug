{"sha": "7108cea14ee1517898cbfcb71f59706f30a4cf18", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxMDhjZWExNGVlMTUxNzg5OGNiZmNiNzFmNTk3MDZmMzBhNGNmMTg=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-03-02T17:32:12Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-03-26T23:20:00Z"}, "message": "Move `BottomValue` into `framework/mod.rs`", "tree": {"sha": "495c0e028f3239a879fa8a28d4ff4b584876b79e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/495c0e028f3239a879fa8a28d4ff4b584876b79e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7108cea14ee1517898cbfcb71f59706f30a4cf18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7108cea14ee1517898cbfcb71f59706f30a4cf18", "html_url": "https://github.com/rust-lang/rust/commit/7108cea14ee1517898cbfcb71f59706f30a4cf18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7108cea14ee1517898cbfcb71f59706f30a4cf18/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8cc89f97566521cd54ea424eea09099b2531b03", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8cc89f97566521cd54ea424eea09099b2531b03", "html_url": "https://github.com/rust-lang/rust/commit/a8cc89f97566521cd54ea424eea09099b2531b03"}], "stats": {"total": 90, "additions": 43, "deletions": 47}, "files": [{"sha": "345fb665b32d69359e3be3ac4ac3368288743323", "filename": "src/librustc_mir/dataflow/framework/mod.rs", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7108cea14ee1517898cbfcb71f59706f30a4cf18/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7108cea14ee1517898cbfcb71f59706f30a4cf18/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fmod.rs?ref=7108cea14ee1517898cbfcb71f59706f30a4cf18", "patch": "@@ -41,8 +41,6 @@ use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::{BitSet, HybridBitSet};\n use rustc_index::vec::{Idx, IndexVec};\n \n-use crate::dataflow::BottomValue;\n-\n mod cursor;\n mod engine;\n mod graphviz;\n@@ -95,6 +93,47 @@ where\n     }\n }\n \n+/// Parameterization for the precise form of data flow that is used.\n+///\n+/// `BottomValue` determines whether the initial entry set for each basic block is empty or full.\n+/// This also determines the semantics of the lattice `join` operator used to merge dataflow\n+/// results, since dataflow works by starting at the bottom and moving monotonically to a fixed\n+/// point.\n+///\n+/// This means, for propagation across the graph, that you either want to start at all-zeroes and\n+/// then use Union as your merge when propagating, or you start at all-ones and then use Intersect\n+/// as your merge when propagating.\n+pub trait BottomValue {\n+    /// Specifies the initial value for each bit in the entry set for each basic block.\n+    const BOTTOM_VALUE: bool;\n+\n+    /// Merges `in_set` into `inout_set`, returning `true` if `inout_set` changed.\n+    ///\n+    /// It is almost certainly wrong to override this, since it automatically applies\n+    /// * `inout_set & in_set` if `BOTTOM_VALUE == true`\n+    /// * `inout_set | in_set` if `BOTTOM_VALUE == false`\n+    ///\n+    /// This means that if a bit is not `BOTTOM_VALUE`, it is propagated into all target blocks.\n+    /// For clarity, the above statement again from a different perspective:\n+    /// A bit in the block's entry set is `!BOTTOM_VALUE` if *any* predecessor block's bit value is\n+    /// `!BOTTOM_VALUE`.\n+    ///\n+    /// There are situations where you want the opposite behaviour: propagate only if *all*\n+    /// predecessor blocks's value is `!BOTTOM_VALUE`.\n+    /// E.g. if you want to know whether a bit is *definitely* set at a specific location. This\n+    /// means that all code paths leading to the location must have set the bit, instead of any\n+    /// code path leading there.\n+    ///\n+    /// If you want this kind of \"definitely set\" analysis, you need to\n+    /// 1. Invert `BOTTOM_VALUE`\n+    /// 2. Reset the `entry_set` in `start_block_effect` to `!BOTTOM_VALUE`\n+    /// 3. Override `join` to do the opposite from what it's doing now.\n+    #[inline]\n+    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n+        if !Self::BOTTOM_VALUE { inout_set.union(in_set) } else { inout_set.intersect(in_set) }\n+    }\n+}\n+\n /// Define the domain of a dataflow problem.\n ///\n /// This trait specifies the lattice on which this analysis operates. For now, this must be a"}, {"sha": "d13dfb2698033f0de11dce9c638c170002bd219b", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 2, "deletions": 45, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7108cea14ee1517898cbfcb71f59706f30a4cf18/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7108cea14ee1517898cbfcb71f59706f30a4cf18/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=7108cea14ee1517898cbfcb71f59706f30a4cf18", "patch": "@@ -1,13 +1,11 @@\n use rustc::ty;\n use rustc_ast::ast::{self, MetaItem};\n-use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::Idx;\n use rustc_span::symbol::{sym, Symbol};\n \n pub(crate) use self::drop_flag_effects::*;\n pub use self::framework::{\n-    visit_results, Analysis, AnalysisDomain, BorrowckFlowState, BorrowckResults, Engine, GenKill,\n-    GenKillAnalysis, Results, ResultsCursor, ResultsRefCursor, ResultsVisitor,\n+    visit_results, Analysis, AnalysisDomain, BorrowckFlowState, BorrowckResults, BottomValue,\n+    Engine, GenKill, GenKillAnalysis, Results, ResultsCursor, ResultsRefCursor, ResultsVisitor,\n };\n pub use self::impls::{\n     borrows::Borrows, DefinitelyInitializedPlaces, EverInitializedPlaces, MaybeBorrowedLocals,\n@@ -48,44 +46,3 @@ pub(crate) fn has_rustc_mir_with(attrs: &[ast::Attribute], name: Symbol) -> Opti\n     }\n     None\n }\n-\n-/// Parameterization for the precise form of data flow that is used.\n-///\n-/// `BottomValue` determines whether the initial entry set for each basic block is empty or full.\n-/// This also determines the semantics of the lattice `join` operator used to merge dataflow\n-/// results, since dataflow works by starting at the bottom and moving monotonically to a fixed\n-/// point.\n-///\n-/// This means, for propagation across the graph, that you either want to start at all-zeroes and\n-/// then use Union as your merge when propagating, or you start at all-ones and then use Intersect\n-/// as your merge when propagating.\n-pub trait BottomValue {\n-    /// Specifies the initial value for each bit in the entry set for each basic block.\n-    const BOTTOM_VALUE: bool;\n-\n-    /// Merges `in_set` into `inout_set`, returning `true` if `inout_set` changed.\n-    ///\n-    /// It is almost certainly wrong to override this, since it automatically applies\n-    /// * `inout_set & in_set` if `BOTTOM_VALUE == true`\n-    /// * `inout_set | in_set` if `BOTTOM_VALUE == false`\n-    ///\n-    /// This means that if a bit is not `BOTTOM_VALUE`, it is propagated into all target blocks.\n-    /// For clarity, the above statement again from a different perspective:\n-    /// A bit in the block's entry set is `!BOTTOM_VALUE` if *any* predecessor block's bit value is\n-    /// `!BOTTOM_VALUE`.\n-    ///\n-    /// There are situations where you want the opposite behaviour: propagate only if *all*\n-    /// predecessor blocks's value is `!BOTTOM_VALUE`.\n-    /// E.g. if you want to know whether a bit is *definitely* set at a specific location. This\n-    /// means that all code paths leading to the location must have set the bit, instead of any\n-    /// code path leading there.\n-    ///\n-    /// If you want this kind of \"definitely set\" analysis, you need to\n-    /// 1. Invert `BOTTOM_VALUE`\n-    /// 2. Reset the `entry_set` in `start_block_effect` to `!BOTTOM_VALUE`\n-    /// 3. Override `join` to do the opposite from what it's doing now.\n-    #[inline]\n-    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n-        if !Self::BOTTOM_VALUE { inout_set.union(in_set) } else { inout_set.intersect(in_set) }\n-    }\n-}"}]}