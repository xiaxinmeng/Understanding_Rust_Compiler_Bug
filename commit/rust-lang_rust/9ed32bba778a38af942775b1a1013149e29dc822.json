{"sha": "9ed32bba778a38af942775b1a1013149e29dc822", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllZDMyYmJhNzc4YTM4YWY5NDI3NzViMWExMDEzMTQ5ZTI5ZGM4MjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-18T21:56:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-18T21:56:51Z"}, "message": "Auto merge of #29117 - mseri:patch-5a, r=nrc\n\nr? @nrc\r\n\r\nRe-submission of the closed PR #29054 with the additional rustfmt-zation of the full librand.", "tree": {"sha": "04f53d6c6d66cd0e4366a68d65d0e39cf60f3cbd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04f53d6c6d66cd0e4366a68d65d0e39cf60f3cbd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ed32bba778a38af942775b1a1013149e29dc822", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ed32bba778a38af942775b1a1013149e29dc822", "html_url": "https://github.com/rust-lang/rust/commit/9ed32bba778a38af942775b1a1013149e29dc822", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ed32bba778a38af942775b1a1013149e29dc822/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3f497861d426c8724dd84f161ca21f274663963", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3f497861d426c8724dd84f161ca21f274663963", "html_url": "https://github.com/rust-lang/rust/commit/d3f497861d426c8724dd84f161ca21f274663963"}, {"sha": "8a0b9c0542d42ecb495eece68a62feab43e85182", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a0b9c0542d42ecb495eece68a62feab43e85182", "html_url": "https://github.com/rust-lang/rust/commit/8a0b9c0542d42ecb495eece68a62feab43e85182"}], "stats": {"total": 406, "additions": 261, "deletions": 145}, "files": [{"sha": "411ca8360805440c215a76c437a461558d6e0fdf", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9ed32bba778a38af942775b1a1013149e29dc822/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ed32bba778a38af942775b1a1013149e29dc822/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=9ed32bba778a38af942775b1a1013149e29dc822", "patch": "@@ -27,15 +27,15 @@ const CHACHA_ROUNDS: usize = 20; // Cryptographically secure from 8 upwards as o\n /// Salsa20*](http://cr.yp.to/chacha.html)\n #[derive(Copy, Clone)]\n pub struct ChaChaRng {\n-    buffer:  [u32; STATE_WORDS], // Internal buffer of output\n-    state:   [u32; STATE_WORDS], // Initial state\n-    index:   usize,                 // Index into state\n+    buffer: [u32; STATE_WORDS], // Internal buffer of output\n+    state: [u32; STATE_WORDS], // Initial state\n+    index: usize, // Index into state\n }\n \n static EMPTY: ChaChaRng = ChaChaRng {\n-    buffer:  [0; STATE_WORDS],\n-    state:   [0; STATE_WORDS],\n-    index:   STATE_WORDS\n+    buffer: [0; STATE_WORDS],\n+    state: [0; STATE_WORDS],\n+    index: STATE_WORDS,\n };\n \n \n@@ -95,9 +95,9 @@ impl ChaChaRng {\n     /// associated with a particular nonce can call this function with\n     /// arguments `0, desired_nonce`.\n     pub fn set_counter(&mut self, counter_low: u64, counter_high: u64) {\n-        self.state[12] = (counter_low >>  0) as u32;\n+        self.state[12] = (counter_low >> 0) as u32;\n         self.state[13] = (counter_low >> 32) as u32;\n-        self.state[14] = (counter_high >>  0) as u32;\n+        self.state[14] = (counter_high >> 0) as u32;\n         self.state[15] = (counter_high >> 32) as u32;\n         self.index = STATE_WORDS; // force recomputation\n     }\n@@ -127,7 +127,7 @@ impl ChaChaRng {\n         self.state[3] = 0x6B206574;\n \n         for i in 0..KEY_WORDS {\n-            self.state[4+i] = key[i];\n+            self.state[4 + i] = key[i];\n         }\n \n         self.state[12] = 0;\n@@ -144,11 +144,17 @@ impl ChaChaRng {\n         self.index = 0;\n         // update 128-bit counter\n         self.state[12] += 1;\n-        if self.state[12] != 0 { return };\n+        if self.state[12] != 0 {\n+            return;\n+        }\n         self.state[13] += 1;\n-        if self.state[13] != 0 { return };\n+        if self.state[13] != 0 {\n+            return;\n+        }\n         self.state[14] += 1;\n-        if self.state[14] != 0 { return };\n+        if self.state[14] != 0 {\n+            return;\n+        }\n         self.state[15] += 1;\n     }\n }\n@@ -172,7 +178,7 @@ impl<'a> SeedableRng<&'a [u32]> for ChaChaRng {\n         // reset state\n         self.init(&[0; KEY_WORDS]);\n         // set key in place\n-        let key = &mut self.state[4 .. 4+KEY_WORDS];\n+        let key = &mut self.state[4..4 + KEY_WORDS];\n         for (k, s) in key.iter_mut().zip(seed) {\n             *k = *s;\n         }\n@@ -191,7 +197,7 @@ impl<'a> SeedableRng<&'a [u32]> for ChaChaRng {\n \n impl Rand for ChaChaRng {\n     fn rand<R: Rng>(other: &mut R) -> ChaChaRng {\n-        let mut key : [u32; KEY_WORDS] = [0; KEY_WORDS];\n+        let mut key: [u32; KEY_WORDS] = [0; KEY_WORDS];\n         for word in &mut key {\n             *word = other.gen();\n         }\n@@ -219,7 +225,7 @@ mod tests {\n \n     #[test]\n     fn test_rng_seeded() {\n-        let seed : &[_] = &[0,1,2,3,4,5,6,7];\n+        let seed: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n         let mut ra: ChaChaRng = SeedableRng::from_seed(seed);\n         let mut rb: ChaChaRng = SeedableRng::from_seed(seed);\n         assert!(order::equals(ra.gen_ascii_chars().take(100),\n@@ -239,10 +245,11 @@ mod tests {\n     }\n \n     #[test]\n+    #[rustfmt_skip]\n     fn test_rng_true_values() {\n         // Test vectors 1 and 2 from\n         // http://tools.ietf.org/html/draft-nir-cfrg-chacha20-poly1305-04\n-        let seed : &[_] = &[0; 8];\n+        let seed: &[_] = &[0; 8];\n         let mut ra: ChaChaRng = SeedableRng::from_seed(seed);\n \n         let v = (0..16).map(|_| ra.next_u32()).collect::<Vec<_>>();\n@@ -260,12 +267,12 @@ mod tests {\n                         0x281fed31, 0x45fb0a51, 0x1f0ae1ac, 0x6f4d794b));\n \n \n-        let seed : &[_] = &[0,1,2,3,4,5,6,7];\n+        let seed: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n         let mut ra: ChaChaRng = SeedableRng::from_seed(seed);\n \n         // Store the 17*i-th 32-bit word,\n         // i.e., the i-th word of the i-th 16-word block\n-        let mut v : Vec<u32> = Vec::new();\n+        let mut v: Vec<u32> = Vec::new();\n         for _ in 0..16 {\n             v.push(ra.next_u32());\n             for _ in 0..16 {\n@@ -282,7 +289,7 @@ mod tests {\n \n     #[test]\n     fn test_rng_clone() {\n-        let seed : &[_] = &[0; 8];\n+        let seed: &[_] = &[0; 8];\n         let mut rng: ChaChaRng = SeedableRng::from_seed(seed);\n         let mut clone = rng.clone();\n         for _ in 0..16 {"}, {"sha": "39e01431983e30c193a88b2bbbdf3c5589dbc166", "filename": "src/librand/distributions/exponential.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9ed32bba778a38af942775b1a1013149e29dc822/src%2Flibrand%2Fdistributions%2Fexponential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ed32bba778a38af942775b1a1013149e29dc822/src%2Flibrand%2Fdistributions%2Fexponential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fexponential.rs?ref=9ed32bba778a38af942775b1a1013149e29dc822", "patch": "@@ -35,20 +35,22 @@ pub struct Exp1(pub f64);\n // This could be done via `-rng.gen::<f64>().ln()` but that is slower.\n impl Rand for Exp1 {\n     #[inline]\n-    fn rand<R:Rng>(rng: &mut R) -> Exp1 {\n+    fn rand<R: Rng>(rng: &mut R) -> Exp1 {\n         #[inline]\n         fn pdf(x: f64) -> f64 {\n             (-x).exp()\n         }\n         #[inline]\n-        fn zero_case<R:Rng>(rng: &mut R, _u: f64) -> f64 {\n+        fn zero_case<R: Rng>(rng: &mut R, _u: f64) -> f64 {\n             ziggurat_tables::ZIG_EXP_R - rng.gen::<f64>().ln()\n         }\n \n-        Exp1(ziggurat(rng, false,\n+        Exp1(ziggurat(rng,\n+                      false,\n                       &ziggurat_tables::ZIG_EXP_X,\n                       &ziggurat_tables::ZIG_EXP_F,\n-                      pdf, zero_case))\n+                      pdf,\n+                      zero_case))\n     }\n }\n \n@@ -59,7 +61,7 @@ impl Rand for Exp1 {\n #[derive(Copy, Clone)]\n pub struct Exp {\n     /// `lambda` stored as `1/lambda`, since this is what we scale by.\n-    lambda_inverse: f64\n+    lambda_inverse: f64,\n }\n \n impl Exp {\n@@ -72,7 +74,9 @@ impl Exp {\n }\n \n impl Sample<f64> for Exp {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 { self.ind_sample(rng) }\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 {\n+        self.ind_sample(rng)\n+    }\n }\n impl IndependentSample<f64> for Exp {\n     fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {"}, {"sha": "47fa142059aae8d0f5f5f059cfbe12546b6ff38e", "filename": "src/librand/distributions/gamma.rs", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9ed32bba778a38af942775b1a1013149e29dc822/src%2Flibrand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ed32bba778a38af942775b1a1013149e29dc822/src%2Flibrand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fgamma.rs?ref=9ed32bba778a38af942775b1a1013149e29dc822", "patch": "@@ -46,7 +46,7 @@ pub struct Gamma {\n enum GammaRepr {\n     Large(GammaLargeShape),\n     One(Exp),\n-    Small(GammaSmallShape)\n+    Small(GammaSmallShape),\n }\n \n // These two helpers could be made public, but saving the\n@@ -65,7 +65,7 @@ enum GammaRepr {\n /// shape parameters.\n struct GammaSmallShape {\n     inv_shape: f64,\n-    large_shape: GammaLargeShape\n+    large_shape: GammaLargeShape,\n }\n \n /// Gamma distribution where the shape parameter is larger than 1.\n@@ -75,7 +75,7 @@ struct GammaSmallShape {\n struct GammaLargeShape {\n     scale: f64,\n     c: f64,\n-    d: f64\n+    d: f64,\n }\n \n impl Gamma {\n@@ -88,9 +88,9 @@ impl Gamma {\n         assert!(scale > 0.0, \"Gamma::new called with scale <= 0\");\n \n         let repr = match shape {\n-            1.0         => One(Exp::new(1.0 / scale)),\n+            1.0 => One(Exp::new(1.0 / scale)),\n             0.0 ... 1.0 => Small(GammaSmallShape::new_raw(shape, scale)),\n-            _           => Large(GammaLargeShape::new_raw(shape, scale))\n+            _ => Large(GammaLargeShape::new_raw(shape, scale)),\n         };\n         Gamma { repr: repr }\n     }\n@@ -100,7 +100,7 @@ impl GammaSmallShape {\n     fn new_raw(shape: f64, scale: f64) -> GammaSmallShape {\n         GammaSmallShape {\n             inv_shape: 1. / shape,\n-            large_shape: GammaLargeShape::new_raw(shape + 1.0, scale)\n+            large_shape: GammaLargeShape::new_raw(shape + 1.0, scale),\n         }\n     }\n }\n@@ -111,19 +111,25 @@ impl GammaLargeShape {\n         GammaLargeShape {\n             scale: scale,\n             c: 1. / (9. * d).sqrt(),\n-            d: d\n+            d: d,\n         }\n     }\n }\n \n impl Sample<f64> for Gamma {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 { self.ind_sample(rng) }\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 {\n+        self.ind_sample(rng)\n+    }\n }\n impl Sample<f64> for GammaSmallShape {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 { self.ind_sample(rng) }\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 {\n+        self.ind_sample(rng)\n+    }\n }\n impl Sample<f64> for GammaLargeShape {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 { self.ind_sample(rng) }\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 {\n+        self.ind_sample(rng)\n+    }\n }\n \n impl IndependentSample<f64> for Gamma {\n@@ -148,16 +154,16 @@ impl IndependentSample<f64> for GammaLargeShape {\n             let StandardNormal(x) = rng.gen::<StandardNormal>();\n             let v_cbrt = 1.0 + self.c * x;\n             if v_cbrt <= 0.0 { // a^3 <= 0 iff a <= 0\n-                continue\n+                continue;\n             }\n \n             let v = v_cbrt * v_cbrt * v_cbrt;\n             let Open01(u) = rng.gen::<Open01<f64>>();\n \n             let x_sqr = x * x;\n             if u < 1.0 - 0.0331 * x_sqr * x_sqr ||\n-                u.ln() < 0.5 * x_sqr + self.d * (1.0 - v + v.ln()) {\n-                return self.d * v * self.scale\n+               u.ln() < 0.5 * x_sqr + self.d * (1.0 - v + v.ln()) {\n+                return self.d * v * self.scale;\n             }\n         }\n     }\n@@ -196,7 +202,9 @@ impl ChiSquared {\n     }\n }\n impl Sample<f64> for ChiSquared {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 { self.ind_sample(rng) }\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 {\n+        self.ind_sample(rng)\n+    }\n }\n impl IndependentSample<f64> for ChiSquared {\n     fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n@@ -206,7 +214,7 @@ impl IndependentSample<f64> for ChiSquared {\n                 let StandardNormal(norm) = rng.gen::<StandardNormal>();\n                 norm * norm\n             }\n-            DoFAnythingElse(ref g) => g.ind_sample(rng)\n+            DoFAnythingElse(ref g) => g.ind_sample(rng),\n         }\n     }\n }\n@@ -234,12 +242,14 @@ impl FisherF {\n         FisherF {\n             numer: ChiSquared::new(m),\n             denom: ChiSquared::new(n),\n-            dof_ratio: n / m\n+            dof_ratio: n / m,\n         }\n     }\n }\n impl Sample<f64> for FisherF {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 { self.ind_sample(rng) }\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 {\n+        self.ind_sample(rng)\n+    }\n }\n impl IndependentSample<f64> for FisherF {\n     fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n@@ -251,7 +261,7 @@ impl IndependentSample<f64> for FisherF {\n /// freedom.\n pub struct StudentT {\n     chi: ChiSquared,\n-    dof: f64\n+    dof: f64,\n }\n \n impl StudentT {\n@@ -261,12 +271,14 @@ impl StudentT {\n         assert!(n > 0.0, \"StudentT::new called with `n <= 0`\");\n         StudentT {\n             chi: ChiSquared::new(n),\n-            dof: n\n+            dof: n,\n         }\n     }\n }\n impl Sample<f64> for StudentT {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 { self.ind_sample(rng) }\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 {\n+        self.ind_sample(rng)\n+    }\n }\n impl IndependentSample<f64> for StudentT {\n     fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {"}, {"sha": "695933370ec3ed3c6e9a9eff27322c53be5aa817", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 74, "deletions": 47, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/9ed32bba778a38af942775b1a1013149e29dc822/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ed32bba778a38af942775b1a1013149e29dc822/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=9ed32bba778a38af942775b1a1013149e29dc822", "patch": "@@ -54,7 +54,9 @@ pub trait IndependentSample<Support>: Sample<Support> {\n \n /// A wrapper for generating types that implement `Rand` via the\n /// `Sample` & `IndependentSample` traits.\n-pub struct RandSample<Sup> { _marker: PhantomData<Sup> }\n+pub struct RandSample<Sup> {\n+    _marker: PhantomData<Sup>,\n+}\n \n impl<Sup> RandSample<Sup> {\n     pub fn new() -> RandSample<Sup> {\n@@ -63,7 +65,9 @@ impl<Sup> RandSample<Sup> {\n }\n \n impl<Sup: Rand> Sample<Sup> for RandSample<Sup> {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> Sup { self.ind_sample(rng) }\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> Sup {\n+        self.ind_sample(rng)\n+    }\n }\n \n impl<Sup: Rand> IndependentSample<Sup> for RandSample<Sup> {\n@@ -89,9 +93,9 @@ pub struct Weighted<T> {\n /// `IndependentSample` traits. Note that `&T` is (cheaply) `Clone` for\n /// all `T`, as is `usize`, so one can store references or indices into\n /// another vector.\n-pub struct WeightedChoice<'a, T:'a> {\n+pub struct WeightedChoice<'a, T: 'a> {\n     items: &'a mut [Weighted<T>],\n-    weight_range: Range<usize>\n+    weight_range: Range<usize>,\n }\n \n impl<'a, T: Clone> WeightedChoice<'a, T> {\n@@ -103,7 +107,8 @@ impl<'a, T: Clone> WeightedChoice<'a, T> {\n     /// - the total weight is larger than a `usize` can contain.\n     pub fn new(items: &'a mut [Weighted<T>]) -> WeightedChoice<'a, T> {\n         // strictly speaking, this is subsumed by the total weight == 0 case\n-        assert!(!items.is_empty(), \"WeightedChoice::new called with no items\");\n+        assert!(!items.is_empty(),\n+                \"WeightedChoice::new called with no items\");\n \n         let mut running_total = 0_usize;\n \n@@ -113,25 +118,28 @@ impl<'a, T: Clone> WeightedChoice<'a, T> {\n         for item in &mut *items {\n             running_total = match running_total.checked_add(item.weight) {\n                 Some(n) => n,\n-                None => panic!(\"WeightedChoice::new called with a total weight \\\n-                               larger than a usize can contain\")\n+                None => panic!(\"WeightedChoice::new called with a total weight larger than a \\\n+                                usize can contain\"),\n             };\n \n             item.weight = running_total;\n         }\n-        assert!(running_total != 0, \"WeightedChoice::new called with a total weight of 0\");\n+        assert!(running_total != 0,\n+                \"WeightedChoice::new called with a total weight of 0\");\n \n         WeightedChoice {\n             items: items,\n             // we're likely to be generating numbers in this range\n             // relatively often, so might as well cache it\n-            weight_range: Range::new(0, running_total)\n+            weight_range: Range::new(0, running_total),\n         }\n     }\n }\n \n impl<'a, T: Clone> Sample<T> for WeightedChoice<'a, T> {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> T { self.ind_sample(rng) }\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> T {\n+        self.ind_sample(rng)\n+    }\n }\n \n impl<'a, T: Clone> IndependentSample<T> for WeightedChoice<'a, T> {\n@@ -195,14 +203,16 @@ mod ziggurat_tables;\n // the perf improvement (25-50%) is definitely worth the extra code\n // size from force-inlining.\n #[inline(always)]\n-fn ziggurat<R: Rng, P, Z>(\n-            rng: &mut R,\n-            symmetric: bool,\n-            x_tab: ziggurat_tables::ZigTable,\n-            f_tab: ziggurat_tables::ZigTable,\n-            mut pdf: P,\n-            mut zero_case: Z)\n-            -> f64 where P: FnMut(f64) -> f64, Z: FnMut(&mut R, f64) -> f64 {\n+fn ziggurat<R: Rng, P, Z>(rng: &mut R,\n+                          symmetric: bool,\n+                          x_tab: ziggurat_tables::ZigTable,\n+                          f_tab: ziggurat_tables::ZigTable,\n+                          mut pdf: P,\n+                          mut zero_case: Z)\n+                          -> f64\n+    where P: FnMut(f64) -> f64,\n+          Z: FnMut(&mut R, f64) -> f64\n+{\n     const SCALE: f64 = (1u64 << 53) as f64;\n     loop {\n         // reimplement the f64 generation as an optimisation suggested\n@@ -224,10 +234,18 @@ fn ziggurat<R: Rng, P, Z>(\n \n         // u is either U(-1, 1) or U(0, 1) depending on if this is a\n         // symmetric distribution or not.\n-        let u = if symmetric {2.0 * f - 1.0} else {f};\n+        let u = if symmetric {\n+            2.0 * f - 1.0\n+        } else {\n+            f\n+        };\n         let x = u * x_tab[i];\n \n-        let test_x = if symmetric { x.abs() } else {x};\n+        let test_x = if symmetric {\n+            x.abs()\n+        } else {\n+            x\n+        };\n \n         // algebraically equivalent to |u| < x_tab[i+1]/x_tab[i] (or u < x_tab[i+1]/x_tab[i])\n         if test_x < x_tab[i + 1] {\n@@ -259,7 +277,9 @@ mod tests {\n     }\n \n     // 0, 1, 2, 3, ...\n-    struct CountingRng { i: u32 }\n+    struct CountingRng {\n+        i: u32,\n+    }\n     impl Rng for CountingRng {\n         fn next_u32(&mut self) -> u32 {\n             self.i += 1;\n@@ -278,6 +298,7 @@ mod tests {\n         assert_eq!(rand_sample.ind_sample(&mut ::test::rng()), ConstRand(0));\n     }\n     #[test]\n+    #[rustfmt_skip]\n     fn test_weighted_choice() {\n         // this makes assumptions about the internal implementation of\n         // WeightedChoice, specifically: it doesn't reorder the items,\n@@ -298,49 +319,55 @@ mod tests {\n             }}\n         }\n \n-        t!(vec!(Weighted { weight: 1, item: 10}), [10]);\n+        t!(vec!(Weighted { weight: 1, item: 10 }),\n+           [10]);\n \n         // skip some\n-        t!(vec!(Weighted { weight: 0, item: 20},\n-                Weighted { weight: 2, item: 21},\n-                Weighted { weight: 0, item: 22},\n-                Weighted { weight: 1, item: 23}),\n-           [21,21, 23]);\n+        t!(vec!(Weighted { weight: 0, item: 20 },\n+                Weighted { weight: 2, item: 21 },\n+                Weighted { weight: 0, item: 22 },\n+                Weighted { weight: 1, item: 23 }),\n+           [21, 21, 23]);\n \n         // different weights\n-        t!(vec!(Weighted { weight: 4, item: 30},\n-                Weighted { weight: 3, item: 31}),\n-           [30,30,30,30, 31,31,31]);\n+        t!(vec!(Weighted { weight: 4, item: 30 },\n+                Weighted { weight: 3, item: 31 }),\n+           [30, 30, 30, 30, 31, 31, 31]);\n \n         // check that we're binary searching\n         // correctly with some vectors of odd\n         // length.\n-        t!(vec!(Weighted { weight: 1, item: 40},\n-                Weighted { weight: 1, item: 41},\n-                Weighted { weight: 1, item: 42},\n-                Weighted { weight: 1, item: 43},\n-                Weighted { weight: 1, item: 44}),\n+        t!(vec!(Weighted { weight: 1, item: 40 },\n+                Weighted { weight: 1, item: 41 },\n+                Weighted { weight: 1, item: 42 },\n+                Weighted { weight: 1, item: 43 },\n+                Weighted { weight: 1, item: 44 }),\n            [40, 41, 42, 43, 44]);\n-        t!(vec!(Weighted { weight: 1, item: 50},\n-                Weighted { weight: 1, item: 51},\n-                Weighted { weight: 1, item: 52},\n-                Weighted { weight: 1, item: 53},\n-                Weighted { weight: 1, item: 54},\n-                Weighted { weight: 1, item: 55},\n-                Weighted { weight: 1, item: 56}),\n+        t!(vec!(Weighted { weight: 1, item: 50 },\n+                Weighted { weight: 1, item: 51 },\n+                Weighted { weight: 1, item: 52 },\n+                Weighted { weight: 1, item: 53 },\n+                Weighted { weight: 1, item: 54 },\n+                Weighted { weight: 1, item: 55 },\n+                Weighted { weight: 1, item: 56 }),\n            [50, 51, 52, 53, 54, 55, 56]);\n     }\n \n-    #[test] #[should_panic]\n+    #[test]\n+    #[should_panic]\n     fn test_weighted_choice_no_items() {\n         WeightedChoice::<isize>::new(&mut []);\n     }\n-    #[test] #[should_panic]\n+    #[test]\n+    #[should_panic]\n+    #[rustfmt_skip]\n     fn test_weighted_choice_zero_weight() {\n-        WeightedChoice::new(&mut [Weighted { weight: 0, item: 0},\n-                                  Weighted { weight: 0, item: 1}]);\n+        WeightedChoice::new(&mut [Weighted { weight: 0, item: 0 },\n+                                  Weighted { weight: 0, item: 1 }]);\n     }\n-    #[test] #[should_panic]\n+    #[test]\n+    #[should_panic]\n+    #[rustfmt_skip]\n     fn test_weighted_choice_weight_overflows() {\n         let x = (!0) as usize / 2; // x + x + 2 is the overflow\n         WeightedChoice::new(&mut [Weighted { weight: x, item: 0 },"}, {"sha": "c2ce2d7e102e59ece2ea43557b371ff478727ac9", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9ed32bba778a38af942775b1a1013149e29dc822/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ed32bba778a38af942775b1a1013149e29dc822/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=9ed32bba778a38af942775b1a1013149e29dc822", "patch": "@@ -32,7 +32,7 @@ use distributions::{Sample, IndependentSample};\n pub struct Range<X> {\n     low: X,\n     range: X,\n-    accept_zone: X\n+    accept_zone: X,\n }\n \n impl<X: SampleRange + PartialOrd> Range<X> {\n@@ -46,7 +46,9 @@ impl<X: SampleRange + PartialOrd> Range<X> {\n \n impl<Sup: SampleRange> Sample<Sup> for Range<Sup> {\n     #[inline]\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> Sup { self.ind_sample(rng) }\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> Sup {\n+        self.ind_sample(rng)\n+    }\n }\n impl<Sup: SampleRange> IndependentSample<Sup> for Range<Sup> {\n     fn ind_sample<R: Rng>(&self, rng: &mut R) -> Sup {\n@@ -148,7 +150,7 @@ float_impl! { f64 }\n mod tests {\n     use std::prelude::v1::*;\n     use distributions::{Sample, IndependentSample};\n-    use super::Range as Range;\n+    use super::Range;\n \n     #[should_panic]\n     #[test]\n@@ -182,8 +184,7 @@ mod tests {\n                  )*\n             }}\n         }\n-        t!(i8, i16, i32, i64, isize,\n-           u8, u16, u32, u64, usize)\n+        t!(i8, i16, i32, i64, isize, u8, u16, u32, u64, usize)\n     }\n \n     #[test]"}, {"sha": "7dfb0f131a2c50bde150dbc0ebcee01859b49c53", "filename": "src/librand/distributions/ziggurat_tables.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ed32bba778a38af942775b1a1013149e29dc822/src%2Flibrand%2Fdistributions%2Fziggurat_tables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ed32bba778a38af942775b1a1013149e29dc822/src%2Flibrand%2Fdistributions%2Fziggurat_tables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fziggurat_tables.rs?ref=9ed32bba778a38af942775b1a1013149e29dc822", "patch": "@@ -13,6 +13,7 @@\n \n pub type ZigTable = &'static [f64; 257];\n pub const ZIG_NORM_R: f64 = 3.654152885361008796;\n+#[rustfmt_skip]\n pub static ZIG_NORM_X: [f64; 257] =\n     [3.910757959537090045, 3.654152885361008796, 3.449278298560964462, 3.320244733839166074,\n      3.224575052047029100, 3.147889289517149969, 3.083526132001233044, 3.027837791768635434,\n@@ -79,6 +80,7 @@ pub static ZIG_NORM_X: [f64; 257] =\n      0.487443966121754335, 0.463634336771763245, 0.437518402186662658, 0.408389134588000746,\n      0.375121332850465727, 0.335737519180459465, 0.286174591747260509, 0.215241895913273806,\n      0.000000000000000000];\n+#[rustfmt_skip]\n pub static ZIG_NORM_F: [f64; 257] =\n     [0.000477467764586655, 0.001260285930498598, 0.002609072746106363, 0.004037972593371872,\n      0.005522403299264754, 0.007050875471392110, 0.008616582769422917, 0.010214971439731100,\n@@ -146,6 +148,7 @@ pub static ZIG_NORM_F: [f64; 257] =\n      0.932060075968990209, 0.945198953453078028, 0.959879091812415930, 0.977101701282731328,\n      1.000000000000000000];\n pub const ZIG_EXP_R: f64 = 7.697117470131050077;\n+#[rustfmt_skip]\n pub static ZIG_EXP_X: [f64; 257] =\n     [8.697117470131052741, 7.697117470131050077, 6.941033629377212577, 6.478378493832569696,\n      6.144164665772472667, 5.882144315795399869, 5.666410167454033697, 5.482890627526062488,\n@@ -212,6 +215,7 @@ pub static ZIG_EXP_X: [f64; 257] =\n      0.253658363385912022, 0.233790483059674731, 0.212671510630966620, 0.189958689622431842,\n      0.165127622564187282, 0.137304980940012589, 0.104838507565818778, 0.063852163815001570,\n      0.000000000000000000];\n+#[rustfmt_skip]\n pub static ZIG_EXP_F: [f64; 257] =\n     [0.000167066692307963, 0.000454134353841497, 0.000967269282327174, 0.001536299780301573,\n      0.002145967743718907, 0.002788798793574076, 0.003460264777836904, 0.004157295120833797,"}, {"sha": "ac2b9b07ffd13ceb4f995ce25ec24f8f1e424f48", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 72, "deletions": 31, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/9ed32bba778a38af942775b1a1013149e29dc822/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ed32bba778a38af942775b1a1013149e29dc822/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=9ed32bba778a38af942775b1a1013149e29dc822", "patch": "@@ -48,7 +48,9 @@ static EMPTY: IsaacRng = IsaacRng {\n     cnt: 0,\n     rsl: [w(0); RAND_SIZE_USIZE],\n     mem: [w(0); RAND_SIZE_USIZE],\n-    a: w(0), b: w(0), c: w(0),\n+    a: w(0),\n+    b: w(0),\n+    c: w(0),\n };\n \n impl IsaacRng {\n@@ -95,15 +97,23 @@ impl IsaacRng {\n             macro_rules! memloop {\n                 ($arr:expr) => {{\n                     for i in (0..RAND_SIZE_USIZE).step_by(8) {\n-                        a=a+$arr[i  ]; b=b+$arr[i+1];\n-                        c=c+$arr[i+2]; d=d+$arr[i+3];\n-                        e=e+$arr[i+4]; f=f+$arr[i+5];\n-                        g=g+$arr[i+6]; h=h+$arr[i+7];\n+                        a = a + $arr[i];\n+                        b = b + $arr[i + 1];\n+                        c = c + $arr[i + 2];\n+                        d = d + $arr[i + 3];\n+                        e = e + $arr[i + 4];\n+                        f = f + $arr[i + 5];\n+                        g = g + $arr[i + 6];\n+                        h = h + $arr[i + 7];\n                         mix!();\n-                        self.mem[i  ]=a; self.mem[i+1]=b;\n-                        self.mem[i+2]=c; self.mem[i+3]=d;\n-                        self.mem[i+4]=e; self.mem[i+5]=f;\n-                        self.mem[i+6]=g; self.mem[i+7]=h;\n+                        self.mem[i] = a;\n+                        self.mem[i + 1] = b;\n+                        self.mem[i + 2] = c;\n+                        self.mem[i + 3] = d;\n+                        self.mem[i + 4] = e;\n+                        self.mem[i + 5] = f;\n+                        self.mem[i + 6] = g;\n+                        self.mem[i + 7] = h;\n                     }\n                 }}\n             }\n@@ -113,10 +123,14 @@ impl IsaacRng {\n         } else {\n             for i in (0..RAND_SIZE_USIZE).step_by(8) {\n                 mix!();\n-                self.mem[i  ]=a; self.mem[i+1]=b;\n-                self.mem[i+2]=c; self.mem[i+3]=d;\n-                self.mem[i+4]=e; self.mem[i+5]=f;\n-                self.mem[i+6]=g; self.mem[i+7]=h;\n+                self.mem[i] = a;\n+                self.mem[i + 1] = b;\n+                self.mem[i + 2] = c;\n+                self.mem[i + 3] = d;\n+                self.mem[i + 4] = e;\n+                self.mem[i + 5] = f;\n+                self.mem[i + 6] = g;\n+                self.mem[i + 7] = h;\n             }\n         }\n \n@@ -290,7 +304,9 @@ static EMPTY_64: Isaac64Rng = Isaac64Rng {\n     cnt: 0,\n     rsl: [w(0); RAND_SIZE_64],\n     mem: [w(0); RAND_SIZE_64],\n-    a: w(0), b: w(0), c: w(0),\n+    a: w(0),\n+    b: w(0),\n+    c: w(0),\n };\n \n impl Isaac64Rng {\n@@ -311,8 +327,14 @@ impl Isaac64Rng {\n                 let mut $var = w(0x9e3779b97f4a7c13);\n             )\n         }\n-        init!(a); init!(b); init!(c); init!(d);\n-        init!(e); init!(f); init!(g); init!(h);\n+        init!(a);\n+        init!(b);\n+        init!(c);\n+        init!(d);\n+        init!(e);\n+        init!(f);\n+        init!(g);\n+        init!(h);\n \n         macro_rules! mix {\n             () => {{\n@@ -335,15 +357,23 @@ impl Isaac64Rng {\n             macro_rules! memloop {\n                 ($arr:expr) => {{\n                     for i in (0..RAND_SIZE_64 / 8).map(|i| i * 8) {\n-                        a=a+$arr[i  ]; b=b+$arr[i+1];\n-                        c=c+$arr[i+2]; d=d+$arr[i+3];\n-                        e=e+$arr[i+4]; f=f+$arr[i+5];\n-                        g=g+$arr[i+6]; h=h+$arr[i+7];\n+                        a = a + $arr[i];\n+                        b = b + $arr[i + 1];\n+                        c = c + $arr[i + 2];\n+                        d = d + $arr[i + 3];\n+                        e = e + $arr[i + 4];\n+                        f = f + $arr[i + 5];\n+                        g = g + $arr[i + 6];\n+                        h = h + $arr[i + 7];\n                         mix!();\n-                        self.mem[i  ]=a; self.mem[i+1]=b;\n-                        self.mem[i+2]=c; self.mem[i+3]=d;\n-                        self.mem[i+4]=e; self.mem[i+5]=f;\n-                        self.mem[i+6]=g; self.mem[i+7]=h;\n+                        self.mem[i] = a;\n+                        self.mem[i + 1] = b;\n+                        self.mem[i + 2] = c;\n+                        self.mem[i + 3] = d;\n+                        self.mem[i + 4] = e;\n+                        self.mem[i + 5] = f;\n+                        self.mem[i + 6] = g;\n+                        self.mem[i + 7] = h;\n                     }\n                 }}\n             }\n@@ -353,10 +383,14 @@ impl Isaac64Rng {\n         } else {\n             for i in (0..RAND_SIZE_64 / 8).map(|i| i * 8) {\n                 mix!();\n-                self.mem[i  ]=a; self.mem[i+1]=b;\n-                self.mem[i+2]=c; self.mem[i+3]=d;\n-                self.mem[i+4]=e; self.mem[i+5]=f;\n-                self.mem[i+6]=g; self.mem[i+7]=h;\n+                self.mem[i] = a;\n+                self.mem[i + 1] = b;\n+                self.mem[i + 2] = c;\n+                self.mem[i + 3] = d;\n+                self.mem[i + 4] = e;\n+                self.mem[i + 5] = f;\n+                self.mem[i + 6] = g;\n+                self.mem[i + 7] = h;\n             }\n         }\n \n@@ -370,7 +404,7 @@ impl Isaac64Rng {\n         let mut a = self.a;\n         let mut b = self.b + self.c;\n         const MIDPOINT: usize =  RAND_SIZE_64 / 2;\n-        const MP_VEC: [(usize, usize); 2] = [(0,MIDPOINT), (MIDPOINT, 0)];\n+        const MP_VEC: [(usize, usize); 2] = [(0, MIDPOINT), (MIDPOINT, 0)];\n         macro_rules! ind {\n             ($x:expr) => {\n                 *self.mem.get_unchecked((($x >> 3).0 as usize) & (RAND_SIZE_64 - 1))\n@@ -573,6 +607,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[rustfmt_skip]\n     fn test_rng_32_true_values() {\n         let seed: &[_] = &[1, 23, 456, 7890, 12345];\n         let mut ra: IsaacRng = SeedableRng::from_seed(seed);\n@@ -585,14 +620,17 @@ mod tests {\n         let seed: &[_] = &[12345, 67890, 54321, 9876];\n         let mut rb: IsaacRng = SeedableRng::from_seed(seed);\n         // skip forward to the 10000th number\n-        for _ in 0..10000 { rb.next_u32(); }\n+        for _ in 0..10000 {\n+            rb.next_u32();\n+        }\n \n         let v = (0..10).map(|_| rb.next_u32()).collect::<Vec<_>>();\n         assert_eq!(v,\n                    vec!(3676831399, 3183332890, 2834741178, 3854698763, 2717568474,\n                         1576568959, 3507990155, 179069555, 141456972, 2478885421));\n     }\n     #[test]\n+    #[rustfmt_skip]\n     fn test_rng_64_true_values() {\n         let seed: &[_] = &[1, 23, 456, 7890, 12345];\n         let mut ra: Isaac64Rng = SeedableRng::from_seed(seed);\n@@ -607,14 +645,17 @@ mod tests {\n         let seed: &[_] = &[12345, 67890, 54321, 9876];\n         let mut rb: Isaac64Rng = SeedableRng::from_seed(seed);\n         // skip forward to the 10000th number\n-        for _ in 0..10000 { rb.next_u64(); }\n+        for _ in 0..10000 {\n+            rb.next_u64();\n+        }\n \n         let v = (0..10).map(|_| rb.next_u64()).collect::<Vec<_>>();\n         assert_eq!(v,\n                    vec!(18143823860592706164, 8491801882678285927, 2699425367717515619,\n                         17196852593171130876, 2606123525235546165, 15790932315217671084,\n                         596345674630742204, 9947027391921273664, 11788097613744130851,\n                         10391409374914919106));\n+\n     }\n \n     #[test]"}, {"sha": "e99d82f5858124730665b15354e4b8ddd7b34e75", "filename": "src/librand/lib.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9ed32bba778a38af942775b1a1013149e29dc822/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ed32bba778a38af942775b1a1013149e29dc822/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=9ed32bba778a38af942775b1a1013149e29dc822", "patch": "@@ -36,13 +36,19 @@\n #![feature(num_bits_bytes)]\n #![feature(staged_api)]\n #![feature(step_by)]\n+#![feature(custom_attribute)]\n+#![allow(unused_attributes)]\n \n #![cfg_attr(test, feature(test, rand, rustc_private, iter_order))]\n \n #![allow(deprecated)]\n \n-#[cfg(test)] #[macro_use] extern crate std;\n-#[cfg(test)] #[macro_use] extern crate log;\n+#[cfg(test)]\n+#[macro_use]\n+extern crate std;\n+#[cfg(test)]\n+#[macro_use]\n+extern crate log;\n \n use core::f64;\n use core::intrinsics;\n@@ -217,7 +223,10 @@ pub trait Rng : Sized {\n     /// Return an iterator that will yield an infinite number of randomly\n     /// generated items.\n     fn gen_iter<'a, T: Rand>(&'a mut self) -> Generator<'a, T, Self> {\n-        Generator { rng: self, _marker: PhantomData }\n+        Generator {\n+            rng: self,\n+            _marker: PhantomData,\n+        }\n     }\n \n     /// Generate a random value in the range [`low`, `high`).\n@@ -272,9 +281,9 @@ pub trait Rng : Sized {\n /// Iterator which will generate a stream of random items.\n ///\n /// This iterator is created via the `gen_iter` method on `Rng`.\n-pub struct Generator<'a, T, R:'a> {\n+pub struct Generator<'a, T, R: 'a> {\n     rng: &'a mut R,\n-    _marker: PhantomData<T>\n+    _marker: PhantomData<T>,\n }\n \n impl<'a, T: Rand, R: Rng> Iterator for Generator<'a, T, R> {\n@@ -288,7 +297,7 @@ impl<'a, T: Rand, R: Rng> Iterator for Generator<'a, T, R> {\n /// Iterator which will continuously generate random ascii characters.\n ///\n /// This iterator is created via the `gen_ascii_chars` method on `Rng`.\n-pub struct AsciiGenerator<'a, R:'a> {\n+pub struct AsciiGenerator<'a, R: 'a> {\n     rng: &'a mut R,\n }\n \n@@ -384,7 +393,7 @@ impl SeedableRng<[u32; 4]> for XorShiftRng {\n             x: seed[0],\n             y: seed[1],\n             z: seed[2],\n-            w: seed[3]\n+            w: seed[3],\n         }\n     }\n }\n@@ -396,7 +405,12 @@ impl Rand for XorShiftRng {\n             tuple = rng.gen();\n         }\n         let (x, y, z, w) = tuple;\n-        XorShiftRng { x: x, y: y, z: z, w: w }\n+        XorShiftRng {\n+            x: x,\n+            y: y,\n+            z: z,\n+            w: w,\n+        }\n     }\n }\n \n@@ -420,7 +434,9 @@ pub struct Closed01<F>(pub F);\n mod test {\n     use std::__rand as rand;\n \n-    pub struct MyRng<R> { inner: R }\n+    pub struct MyRng<R> {\n+        inner: R,\n+    }\n \n     impl<R: rand::Rng> ::Rng for MyRng<R> {\n         fn next_u32(&mut self) -> u32 {"}, {"sha": "726a4554626f538345581d95b87315f860931587", "filename": "src/librand/rand_impls.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ed32bba778a38af942775b1a1013149e29dc822/src%2Flibrand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ed32bba778a38af942775b1a1013149e29dc822/src%2Flibrand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Frand_impls.rs?ref=9ed32bba778a38af942775b1a1013149e29dc822", "patch": "@@ -14,7 +14,7 @@ use core::char;\n use core::isize;\n use core::usize;\n \n-use {Rand,Rng};\n+use {Rand, Rng};\n \n impl Rand for isize {\n     #[inline]\n@@ -185,7 +185,9 @@ macro_rules! tuple_impl {\n \n impl Rand for () {\n     #[inline]\n-    fn rand<R: Rng>(_: &mut R) -> () { () }\n+    fn rand<R: Rng>(_: &mut R) -> () {\n+        ()\n+    }\n }\n tuple_impl!{A}\n tuple_impl!{A, B}"}, {"sha": "db3d690461c1783cace79130c49135316bb3f6e5", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9ed32bba778a38af942775b1a1013149e29dc822/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ed32bba778a38af942775b1a1013149e29dc822/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=9ed32bba778a38af942775b1a1013149e29dc822", "patch": "@@ -35,12 +35,12 @@ impl<R: Rng, Rsdr: Reseeder<R>> ReseedingRng<R, Rsdr> {\n     /// * `rng`: the random number generator to use.\n     /// * `generation_threshold`: the number of bytes of entropy at which to reseed the RNG.\n     /// * `reseeder`: the reseeding object to use.\n-    pub fn new(rng: R, generation_threshold: usize, reseeder: Rsdr) -> ReseedingRng<R,Rsdr> {\n+    pub fn new(rng: R, generation_threshold: usize, reseeder: Rsdr) -> ReseedingRng<R, Rsdr> {\n         ReseedingRng {\n             rng: rng,\n             generation_threshold: generation_threshold,\n             bytes_generated: 0,\n-            reseeder: reseeder\n+            reseeder: reseeder,\n         }\n     }\n \n@@ -90,7 +90,7 @@ impl<S, R: SeedableRng<S>, Rsdr: Reseeder<R> + Default>\n             rng: SeedableRng::from_seed(seed),\n             generation_threshold: DEFAULT_GENERATION_THRESHOLD,\n             bytes_generated: 0,\n-            reseeder: rsdr\n+            reseeder: rsdr,\n         }\n     }\n }\n@@ -114,7 +114,9 @@ impl<R: Rng + Default> Reseeder<R> for ReseedWithDefault {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for ReseedWithDefault {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn default() -> ReseedWithDefault { ReseedWithDefault }\n+    fn default() -> ReseedWithDefault {\n+        ReseedWithDefault\n+    }\n }\n \n #[cfg(test)]\n@@ -126,7 +128,7 @@ mod tests {\n     use {SeedableRng, Rng};\n \n     struct Counter {\n-        i: u32\n+        i: u32,\n     }\n \n     impl Rng for Counter {\n@@ -153,7 +155,7 @@ mod tests {\n \n     #[test]\n     fn test_reseeding() {\n-        let mut rs = ReseedingRng::new(Counter {i:0}, 400, ReseedWithDefault);\n+        let mut rs = ReseedingRng::new(Counter { i: 0 }, 400, ReseedWithDefault);\n \n         let mut i = 0;\n         for _ in 0..1000 {"}]}