{"sha": "1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlNWExMTI5MjJmYmFjMmE2ZjJkMGFhOWU2ZWI5MGJjM2E0NDIyYTU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-21T09:04:35Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-22T16:14:52Z"}, "message": "rustc: remove ty::Impl.", "tree": {"sha": "a0886cf39d3cb85d54f6acec572da5772e5f44d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0886cf39d3cb85d54f6acec572da5772e5f44d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5", "html_url": "https://github.com/rust-lang/rust/commit/1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f3cfe064bf4669082ec2d195f214cc36b36b568", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f3cfe064bf4669082ec2d195f214cc36b36b568", "html_url": "https://github.com/rust-lang/rust/commit/8f3cfe064bf4669082ec2d195f214cc36b36b568"}], "stats": {"total": 345, "additions": 156, "deletions": 189}, "files": [{"sha": "a01e088a9f4cde78e2a20b22a7f2732a1938b526", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5", "patch": "@@ -114,10 +114,10 @@ pub fn get_enum_variants(tcx: &ty::ctxt, def: ast::DefId)\n }\n \n /// Returns information about the given implementation.\n-pub fn get_impl(tcx: &ty::ctxt, impl_def_id: ast::DefId)\n-                -> ty::Impl {\n-    let cdata = tcx.sess.cstore.get_crate_data(impl_def_id.krate);\n-    decoder::get_impl(tcx.sess.cstore.intr.clone(), &*cdata, impl_def_id.node, tcx)\n+pub fn get_impl_methods(cstore: &cstore::CStore, impl_def_id: ast::DefId)\n+                        -> Vec<ast::DefId> {\n+    let cdata = cstore.get_crate_data(impl_def_id.krate);\n+    decoder::get_impl_methods(&*cdata, impl_def_id.node)\n }\n \n pub fn get_method(tcx: &ty::ctxt, def: ast::DefId) -> ty::Method {"}, {"sha": "74156510fac535c342d29586ef8d9b60d452d49f", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5", "patch": "@@ -733,32 +733,17 @@ fn get_explicit_self(item: ebml::Doc) -> ast::ExplicitSelf_ {\n     }\n }\n \n-fn item_impl_methods(intr: Rc<IdentInterner>, cdata: Cmd, item: ebml::Doc,\n-                     tcx: &ty::ctxt) -> Vec<@ty::Method> {\n-    let mut rslt = Vec::new();\n-    reader::tagged_docs(item, tag_item_impl_method, |doc| {\n+/// Returns information about the given implementation.\n+pub fn get_impl_methods(cdata: Cmd, impl_id: ast::NodeId) -> Vec<ast::DefId> {\n+    let mut methods = Vec::new();\n+    reader::tagged_docs(lookup_item(impl_id, cdata.data()),\n+                        tag_item_impl_method, |doc| {\n         let m_did = reader::with_doc_data(doc, parse_def_id);\n-        rslt.push(@get_method(intr.clone(), cdata, m_did.node, tcx));\n+        methods.push(translate_def_id(cdata, m_did));\n         true\n     });\n \n-    rslt\n-}\n-\n-/// Returns information about the given implementation.\n-pub fn get_impl(intr: Rc<IdentInterner>, cdata: Cmd, impl_id: ast::NodeId,\n-               tcx: &ty::ctxt)\n-                -> ty::Impl {\n-    let data = cdata.data();\n-    let impl_item = lookup_item(impl_id, data);\n-    ty::Impl {\n-        did: ast::DefId {\n-            krate: cdata.cnum,\n-            node: impl_id,\n-        },\n-        ident: item_name(&*intr, impl_item),\n-        methods: item_impl_methods(intr, cdata, impl_item, tcx),\n-    }\n+    methods\n }\n \n pub fn get_method_name_and_explicit_self("}, {"sha": "a3f32cb93ac8affec8438637bc1e80ef96c506f4", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5", "patch": "@@ -398,10 +398,12 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n                                          ebml_w: &mut Encoder,\n                                          exp: &middle::resolve::Export2)\n                                          -> bool {\n+    let impl_methods = ecx.tcx.impl_methods.borrow();\n     match ecx.tcx.inherent_impls.borrow().find(&exp.def_id) {\n         Some(implementations) => {\n-            for &base_impl in implementations.borrow().iter() {\n-                for &m in base_impl.methods.iter() {\n+            for base_impl_did in implementations.borrow().iter() {\n+                for &method_did in impl_methods.get(base_impl_did).iter() {\n+                    let m = ty::method(ecx.tcx, method_did);\n                     if m.explicit_self == ast::SelfStatic {\n                         encode_reexported_static_method(ebml_w, exp, m.def_id, m.ident);\n                     }\n@@ -822,9 +824,9 @@ fn encode_inherent_implementations(ecx: &EncodeContext,\n     match ecx.tcx.inherent_impls.borrow().find(&def_id) {\n         None => {}\n         Some(implementations) => {\n-            for implementation in implementations.borrow().iter() {\n+            for &impl_def_id in implementations.borrow().iter() {\n                 ebml_w.start_tag(tag_items_data_item_inherent_impl);\n-                encode_def_id(ebml_w, implementation.did);\n+                encode_def_id(ebml_w, impl_def_id);\n                 ebml_w.end_tag();\n             }\n         }\n@@ -838,9 +840,9 @@ fn encode_extension_implementations(ecx: &EncodeContext,\n     match ecx.tcx.trait_impls.borrow().find(&trait_def_id) {\n         None => {}\n         Some(implementations) => {\n-            for implementation in implementations.borrow().iter() {\n+            for &impl_def_id in implementations.borrow().iter() {\n                 ebml_w.start_tag(tag_items_data_item_extension_impl);\n-                encode_def_id(ebml_w, implementation.did);\n+                encode_def_id(ebml_w, impl_def_id);\n                 ebml_w.end_tag();\n             }\n         }\n@@ -1028,8 +1030,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n       ItemImpl(_, ref opt_trait, ty, ref ast_methods) => {\n         // We need to encode information about the default methods we\n         // have inherited, so we drive this based on the impl structure.\n-        let impls = tcx.impls.borrow();\n-        let imp = impls.get(&def_id);\n+        let impl_methods = tcx.impl_methods.borrow();\n+        let methods = impl_methods.get(&def_id);\n \n         add_to_index(item, ebml_w, index);\n         ebml_w.start_tag(tag_items_data_item);\n@@ -1046,9 +1048,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n             _ => {}\n         }\n-        for method in imp.methods.iter() {\n+        for &method_def_id in methods.iter() {\n             ebml_w.start_tag(tag_item_impl_method);\n-            let s = def_to_str(method.def_id);\n+            let s = def_to_str(method_def_id);\n             ebml_w.writer.write(s.as_bytes());\n             ebml_w.end_tag();\n         }\n@@ -1067,18 +1069,19 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // appear first in the impl structure, in the same order they do\n         // in the ast. This is a little sketchy.\n         let num_implemented_methods = ast_methods.len();\n-        for (i, m) in imp.methods.iter().enumerate() {\n+        for (i, &method_def_id) in methods.iter().enumerate() {\n             let ast_method = if i < num_implemented_methods {\n                 Some(*ast_methods.get(i))\n             } else { None };\n \n             index.push(entry {\n-                val: m.def_id.node as i64,\n+                val: method_def_id.node as i64,\n                 pos: ebml_w.writer.tell().unwrap(),\n             });\n+            let m = ty::method(tcx, method_def_id);\n             encode_info_for_method(ecx,\n                                    ebml_w,\n-                                   *m,\n+                                   m,\n                                    path.clone(),\n                                    false,\n                                    item.id,"}, {"sha": "74355357fe72c5c971bd3f94f8cc7733a6e86205", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5", "patch": "@@ -336,13 +336,13 @@ impl<'a> DeadVisitor<'a> {\n         // This is done to handle the case where, for example, the static\n         // method of a private type is used, but the type itself is never\n         // called directly.\n-        let def_id = local_def(id);\n-        match self.tcx.inherent_impls.borrow().find(&def_id) {\n+        let impl_methods = self.tcx.impl_methods.borrow();\n+        match self.tcx.inherent_impls.borrow().find(&local_def(id)) {\n             None => (),\n             Some(impl_list) => {\n-                for impl_ in impl_list.borrow().iter() {\n-                    for method in impl_.methods.iter() {\n-                        if self.live_symbols.contains(&method.def_id.node) {\n+                for impl_did in impl_list.borrow().iter() {\n+                    for method_did in impl_methods.get(impl_did).iter() {\n+                        if self.live_symbols.contains(&method_did.node) {\n                             return true;\n                         }\n                     }"}, {"sha": "d122edb7678576e1cecf41257ca1d93cf5c71cf1", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5", "patch": "@@ -221,22 +221,22 @@ pub fn trans_static_method_callee(bcx: &Block,\n     }\n }\n \n-pub fn method_with_name(ccx: &CrateContext,\n-                        impl_id: ast::DefId,\n-                        name: ast::Name) -> ast::DefId {\n+fn method_with_name(ccx: &CrateContext,\n+                    impl_id: ast::DefId,\n+                    name: ast::Name) -> ast::DefId {\n     match ccx.impl_method_cache.borrow().find_copy(&(impl_id, name)) {\n         Some(m) => return m,\n         None => {}\n     }\n \n-    let imp = ccx.tcx.impls.borrow();\n-    let imp = imp.find(&impl_id)\n-                 .expect(\"could not find impl while translating\");\n-    let meth = imp.methods.iter().find(|m| m.ident.name == name)\n-                  .expect(\"could not find method while translating\");\n+    let methods = ccx.tcx.impl_methods.borrow();\n+    let methods = methods.find(&impl_id)\n+                         .expect(\"could not find impl while translating\");\n+    let meth_did = methods.iter().find(|&did| ty::method(&ccx.tcx, *did).ident.name == name)\n+                                 .expect(\"could not find method while translating\");\n \n-    ccx.impl_method_cache.borrow_mut().insert((impl_id, name), meth.def_id);\n-    meth.def_id\n+    ccx.impl_method_cache.borrow_mut().insert((impl_id, name), *meth_did);\n+    *meth_did\n }\n \n fn trans_monomorphized_callee<'a>(bcx: &'a Block<'a>,"}, {"sha": "865d82b6779928afd7d7a2a78e08902367286bd1", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 25, "deletions": 36, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5", "patch": "@@ -116,12 +116,6 @@ impl Method {\n     }\n }\n \n-pub struct Impl {\n-    pub did: DefId,\n-    pub ident: Ident,\n-    pub methods: Vec<@Method>,\n-}\n-\n #[deriving(Clone, Eq, TotalEq, Hash)]\n pub struct mt {\n     pub ty: t,\n@@ -320,18 +314,18 @@ pub struct ctxt {\n     pub destructors: RefCell<DefIdSet>,\n \n     // Maps a trait onto a list of impls of that trait.\n-    pub trait_impls: RefCell<DefIdMap<@RefCell<Vec<@Impl>>>>,\n+    pub trait_impls: RefCell<DefIdMap<@RefCell<Vec<ast::DefId>>>>,\n \n-    // Maps a def_id of a type to a list of its inherent impls.\n+    // Maps a DefId of a type to a list of its inherent impls.\n     // Contains implementations of methods that are inherent to a type.\n     // Methods in these implementations don't need to be exported.\n-    pub inherent_impls: RefCell<DefIdMap<@RefCell<Vec<@Impl>>>>,\n+    pub inherent_impls: RefCell<DefIdMap<@RefCell<Vec<ast::DefId>>>>,\n \n-    // Maps a def_id of an impl to an Impl structure.\n+    // Maps a DefId of an impl to a list of its methods.\n     // Note that this contains all of the impls that we know about,\n     // including ones in other crates. It's not clear that this is the best\n     // way to do it.\n-    pub impls: RefCell<DefIdMap<@Impl>>,\n+    pub impl_methods: RefCell<DefIdMap<Vec<ast::DefId>>>,\n \n     // Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n     // present in this set can be warned about.\n@@ -1126,7 +1120,7 @@ pub fn mk_ctxt(s: Session,\n         destructors: RefCell::new(DefIdSet::new()),\n         trait_impls: RefCell::new(DefIdMap::new()),\n         inherent_impls: RefCell::new(DefIdMap::new()),\n-        impls: RefCell::new(DefIdMap::new()),\n+        impl_methods: RefCell::new(DefIdMap::new()),\n         used_unsafe: RefCell::new(NodeSet::new()),\n         used_mut_nodes: RefCell::new(NodeSet::new()),\n         impl_vtables: RefCell::new(DefIdMap::new()),\n@@ -4384,15 +4378,15 @@ pub fn item_variances(tcx: &ctxt, item_id: ast::DefId) -> @ItemVariances {\n /// Records a trait-to-implementation mapping.\n pub fn record_trait_implementation(tcx: &ctxt,\n                                    trait_def_id: DefId,\n-                                   implementation: @Impl) {\n+                                   impl_def_id: DefId) {\n     match tcx.trait_impls.borrow().find(&trait_def_id) {\n         Some(impls_for_trait) => {\n-            impls_for_trait.borrow_mut().push(implementation);\n+            impls_for_trait.borrow_mut().push(impl_def_id);\n             return;\n         }\n         None => {}\n     }\n-    tcx.trait_impls.borrow_mut().insert(trait_def_id, @RefCell::new(vec!(implementation)));\n+    tcx.trait_impls.borrow_mut().insert(trait_def_id, @RefCell::new(vec!(impl_def_id)));\n }\n \n /// Populates the type context with all the implementations for the given type\n@@ -4407,40 +4401,36 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n     }\n \n     csearch::each_implementation_for_type(&tcx.sess.cstore, type_id,\n-            |implementation_def_id| {\n-        let implementation = @csearch::get_impl(tcx, implementation_def_id);\n+            |impl_def_id| {\n+        let methods = csearch::get_impl_methods(&tcx.sess.cstore, impl_def_id);\n \n         // Record the trait->implementation mappings, if applicable.\n-        let associated_traits = csearch::get_impl_trait(tcx,\n-                                                        implementation.did);\n+        let associated_traits = csearch::get_impl_trait(tcx, impl_def_id);\n         for trait_ref in associated_traits.iter() {\n-            record_trait_implementation(tcx,\n-                                        trait_ref.def_id,\n-                                        implementation);\n+            record_trait_implementation(tcx, trait_ref.def_id, impl_def_id);\n         }\n \n         // For any methods that use a default implementation, add them to\n         // the map. This is a bit unfortunate.\n-        for method in implementation.methods.iter() {\n-            for source in method.provided_source.iter() {\n-                tcx.provided_method_sources.borrow_mut()\n-                   .insert(method.def_id, *source);\n+        for &method_def_id in methods.iter() {\n+            for &source in ty::method(tcx, method_def_id).provided_source.iter() {\n+                tcx.provided_method_sources.borrow_mut().insert(method_def_id, source);\n             }\n         }\n \n         // Store the implementation info.\n-        tcx.impls.borrow_mut().insert(implementation_def_id, implementation);\n+        tcx.impl_methods.borrow_mut().insert(impl_def_id, methods);\n \n         // If this is an inherent implementation, record it.\n         if associated_traits.is_none() {\n             match tcx.inherent_impls.borrow().find(&type_id) {\n                 Some(implementation_list) => {\n-                    implementation_list.borrow_mut().push(implementation);\n+                    implementation_list.borrow_mut().push(impl_def_id);\n                     return;\n                 }\n                 None => {}\n             }\n-            tcx.inherent_impls.borrow_mut().insert(type_id, @RefCell::new(vec!(implementation)));\n+            tcx.inherent_impls.borrow_mut().insert(type_id, @RefCell::new(vec!(impl_def_id)));\n         }\n     });\n \n@@ -4461,22 +4451,21 @@ pub fn populate_implementations_for_trait_if_necessary(\n \n     csearch::each_implementation_for_trait(&tcx.sess.cstore, trait_id,\n             |implementation_def_id| {\n-        let implementation = @csearch::get_impl(tcx, implementation_def_id);\n+        let methods = csearch::get_impl_methods(&tcx.sess.cstore, implementation_def_id);\n \n         // Record the trait->implementation mapping.\n-        record_trait_implementation(tcx, trait_id, implementation);\n+        record_trait_implementation(tcx, trait_id, implementation_def_id);\n \n         // For any methods that use a default implementation, add them to\n         // the map. This is a bit unfortunate.\n-        for method in implementation.methods.iter() {\n-            for source in method.provided_source.iter() {\n-                tcx.provided_method_sources.borrow_mut()\n-                   .insert(method.def_id, *source);\n+        for &method_def_id in methods.iter() {\n+            for &source in ty::method(tcx, method_def_id).provided_source.iter() {\n+                tcx.provided_method_sources.borrow_mut().insert(method_def_id, source);\n             }\n         }\n \n         // Store the implementation info.\n-        tcx.impls.borrow_mut().insert(implementation_def_id, implementation);\n+        tcx.impl_methods.borrow_mut().insert(implementation_def_id, methods);\n     });\n \n     tcx.populated_external_traits.borrow_mut().insert(trait_id);"}, {"sha": "b2b0054fb4d35d1f1e3cd4026eb84bc1f31c2d74", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5", "patch": "@@ -468,9 +468,11 @@ impl<'a> LookupContext<'a> {\n         ty::populate_implementations_for_trait_if_necessary(self.tcx(), trait_did);\n \n         // Look for explicit implementations.\n+        let impl_methods = self.tcx().impl_methods.borrow();\n         for impl_infos in self.tcx().trait_impls.borrow().find(&trait_did).iter() {\n-            for impl_info in impl_infos.borrow().iter() {\n-                self.push_candidates_from_impl(*impl_info, true);\n+            for impl_did in impl_infos.borrow().iter() {\n+                let methods = impl_methods.get(impl_did);\n+                self.push_candidates_from_impl(*impl_did, methods.as_slice(), true);\n             }\n         }\n     }\n@@ -643,48 +645,43 @@ impl<'a> LookupContext<'a> {\n         // metadata if necessary.\n         ty::populate_implementations_for_type_if_necessary(self.tcx(), did);\n \n+        let impl_methods = self.tcx().impl_methods.borrow();\n         for impl_infos in self.tcx().inherent_impls.borrow().find(&did).iter() {\n-            for impl_info in impl_infos.borrow().iter() {\n-                self.push_candidates_from_impl(*impl_info, false);\n+            for impl_did in impl_infos.borrow().iter() {\n+                let methods = impl_methods.get(impl_did);\n+                self.push_candidates_from_impl(*impl_did, methods.as_slice(), false);\n             }\n         }\n     }\n \n     fn push_candidates_from_impl(&mut self,\n-                                 impl_info: &ty::Impl,\n+                                 impl_did: DefId,\n+                                 impl_methods: &[DefId],\n                                  is_extension: bool) {\n-        if !self.impl_dups.insert(impl_info.did) {\n+        if !self.impl_dups.insert(impl_did) {\n             return; // already visited\n         }\n \n-        debug!(\"push_candidates_from_impl: {} {} {}\",\n+        debug!(\"push_candidates_from_impl: {} {}\",\n                token::get_name(self.m_name),\n-               impl_info.ident.repr(self.tcx()),\n-               impl_info.methods.iter()\n-                                .map(|m| m.ident)\n-                                .collect::<Vec<ast::Ident>>()\n-                                .repr(self.tcx()));\n-\n-        let idx = {\n-            match impl_info.methods\n-                           .iter()\n-                           .position(|m| m.ident.name == self.m_name) {\n-                Some(idx) => idx,\n-                None => { return; } // No method with the right name.\n-            }\n+               impl_methods.iter().map(|&did| ty::method(self.tcx(), did).ident)\n+                                 .collect::<Vec<ast::Ident>>()\n+                                 .repr(self.tcx()));\n+\n+        let method = match impl_methods.iter().map(|&did| ty::method(self.tcx(), did))\n+                                              .find(|m| m.ident.name == self.m_name) {\n+            Some(method) => method,\n+            None => { return; } // No method with the right name.\n         };\n \n-        let method = ty::method(self.tcx(),\n-                                impl_info.methods.get(idx).def_id);\n-\n         // determine the `self` of the impl with fresh\n         // variables for each parameter:\n         let span = self.self_expr.map_or(self.span, |e| e.span);\n         let vcx = self.fcx.vtable_context();\n         let ty::ty_param_substs_and_ty {\n             substs: impl_substs,\n             ty: impl_ty\n-        } = impl_self_ty(&vcx, span, impl_info.did);\n+        } = impl_self_ty(&vcx, span, impl_did);\n \n         let candidates = if is_extension {\n             &mut self.extension_candidates"}, {"sha": "792c89e43f9c04a9665d6840d7e4cf2ad2a5d4d7", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5", "patch": "@@ -325,21 +325,21 @@ fn search_for_vtable(vcx: &VtableContext,\n         }\n     };\n     // impls is the list of all impls in scope for trait_ref.\n-    for im in impls.borrow().iter() {\n+    for &impl_did in impls.borrow().iter() {\n         // im is one specific impl of trait_ref.\n \n         // First, ensure we haven't processed this impl yet.\n-        if impls_seen.contains(&im.did) {\n+        if impls_seen.contains(&impl_did) {\n             continue;\n         }\n-        impls_seen.insert(im.did);\n+        impls_seen.insert(impl_did);\n \n         // ty::impl_traits gives us the trait im implements.\n         //\n         // If foo implements a trait t, and if t is the same trait as\n         // trait_ref, we need to unify it with trait_ref in order to\n         // get all the ty vars sorted out.\n-        let r = ty::impl_trait_ref(tcx, im.did);\n+        let r = ty::impl_trait_ref(tcx, impl_did);\n         let of_trait_ref = r.expect(\"trait_ref missing on trait impl\");\n         if of_trait_ref.def_id != trait_ref.def_id { continue; }\n \n@@ -362,7 +362,7 @@ fn search_for_vtable(vcx: &VtableContext,\n         let ty::ty_param_substs_and_ty {\n             substs: substs,\n             ty: for_ty\n-        } = impl_self_ty(vcx, span, im.did);\n+        } = impl_self_ty(vcx, span, impl_did);\n         match infer::mk_subty(vcx.infcx,\n                               false,\n                               infer::RelateSelfType(span),\n@@ -405,7 +405,7 @@ fn search_for_vtable(vcx: &VtableContext,\n         // type variables in substs. This might still be OK: the\n         // process of looking up bounds might constrain some of them.\n         let im_generics =\n-            ty::lookup_item_type(tcx, im.did).generics;\n+            ty::lookup_item_type(tcx, impl_did).generics;\n         let subres = lookup_vtables(vcx, span,\n                                     im_generics.type_param_defs(), &substs,\n                                     is_early);\n@@ -438,12 +438,12 @@ fn search_for_vtable(vcx: &VtableContext,\n         // I am a little confused about this, since it seems to be\n         // very similar to the relate_trait_refs we already do,\n         // but problems crop up if it is removed, so... -sully\n-        connect_trait_tps(vcx, span, &substs_f, trait_ref, im.did);\n+        connect_trait_tps(vcx, span, &substs_f, trait_ref, impl_did);\n \n         // Finally, we register that we found a matching impl, and\n         // record the def ID of the impl as well as the resolved list\n         // of type substitutions for the target trait.\n-        found.push(vtable_static(im.did, substs_f.tps.clone(), subres));\n+        found.push(vtable_static(impl_did, substs_f.tps.clone(), subres));\n     }\n \n     match found.len() {"}, {"sha": "1ee227089bc02dfecb2240790af7fd3ecc7341ae", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 60, "deletions": 67, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5", "patch": "@@ -27,7 +27,6 @@ use middle::ty::{ty_uint, ty_uniq, ty_bare_fn, ty_closure};\n use middle::ty::type_is_ty_var;\n use middle::subst::Subst;\n use middle::ty;\n-use middle::ty::{Impl, Method};\n use middle::typeck::CrateCtxt;\n use middle::typeck::infer::combine::Combine;\n use middle::typeck::infer::InferCtxt;\n@@ -252,7 +251,8 @@ impl<'a> CoherenceChecker<'a> {\n     fn check_implementation(&self, item: &Item,\n                             associated_traits: &[TraitRef]) {\n         let tcx = self.crate_context.tcx;\n-        let self_type = ty::lookup_item_type(tcx, local_def(item.id));\n+        let impl_did = local_def(item.id);\n+        let self_type = ty::lookup_item_type(tcx, impl_did);\n \n         // If there are no traits, then this implementation must have a\n         // base type.\n@@ -276,7 +276,7 @@ impl<'a> CoherenceChecker<'a> {\n             }\n         }\n \n-        let implementation = self.create_impl_from_item(item);\n+        let impl_methods = self.create_impl_from_item(item);\n \n         for associated_trait in associated_traits.iter() {\n             let trait_ref = ty::node_id_to_trait_ref(\n@@ -285,7 +285,7 @@ impl<'a> CoherenceChecker<'a> {\n                    trait_ref.repr(self.crate_context.tcx),\n                    token::get_ident(item.ident));\n \n-            self.add_trait_impl(trait_ref.def_id, implementation);\n+            self.add_trait_impl(trait_ref.def_id, impl_did);\n         }\n \n         // Add the implementation to the mapping from implementation to base\n@@ -300,20 +300,20 @@ impl<'a> CoherenceChecker<'a> {\n             Some(base_type_def_id) => {\n                 // FIXME: Gather up default methods?\n                 if associated_traits.len() == 0 {\n-                    self.add_inherent_impl(base_type_def_id, implementation);\n+                    self.add_inherent_impl(base_type_def_id, impl_did);\n                 }\n             }\n         }\n \n-        tcx.impls.borrow_mut().insert(implementation.did, implementation);\n+        tcx.impl_methods.borrow_mut().insert(impl_did, impl_methods);\n     }\n \n     // Creates default method IDs and performs type substitutions for an impl\n     // and trait pair. Then, for each provided method in the trait, inserts a\n     // `ProvidedMethodInfo` instance into the `provided_method_sources` map.\n-    fn instantiate_default_methods(&self, impl_id: ast::DefId,\n+    fn instantiate_default_methods(&self, impl_id: DefId,\n                                    trait_ref: &ty::TraitRef,\n-                                   all_methods: &mut Vec<@Method> ) {\n+                                   all_methods: &mut Vec<DefId>) {\n         let tcx = self.crate_context.tcx;\n         debug!(\"instantiate_default_methods(impl_id={:?}, trait_ref={})\",\n                impl_id, trait_ref.repr(tcx));\n@@ -339,7 +339,7 @@ impl<'a> CoherenceChecker<'a> {\n                     Some(trait_method.def_id));\n \n             debug!(\"new_method_ty={}\", new_method_ty.repr(tcx));\n-            all_methods.push(new_method_ty);\n+            all_methods.push(new_did);\n \n             // construct the polytype for the method based on the method_ty\n             let new_generics = ty::Generics {\n@@ -366,23 +366,23 @@ impl<'a> CoherenceChecker<'a> {\n         }\n     }\n \n-    fn add_inherent_impl(&self, base_def_id: DefId, implementation: @Impl) {\n+    fn add_inherent_impl(&self, base_def_id: DefId, impl_def_id: DefId) {\n         let tcx = self.crate_context.tcx;\n         match tcx.inherent_impls.borrow().find(&base_def_id) {\n             Some(implementation_list) => {\n-                implementation_list.borrow_mut().push(implementation);\n+                implementation_list.borrow_mut().push(impl_def_id);\n                 return;\n             }\n             None => {}\n         }\n \n-        tcx.inherent_impls.borrow_mut().insert(base_def_id, @RefCell::new(vec!(implementation)));\n+        tcx.inherent_impls.borrow_mut().insert(base_def_id, @RefCell::new(vec!(impl_def_id)));\n     }\n \n-    fn add_trait_impl(&self, base_def_id: DefId, implementation: @Impl) {\n+    fn add_trait_impl(&self, base_def_id: DefId, impl_def_id: DefId) {\n         ty::record_trait_implementation(self.crate_context.tcx,\n                                         base_def_id,\n-                                        implementation);\n+                                        impl_def_id);\n     }\n \n     fn check_implementation_coherence(&self) {\n@@ -393,34 +393,32 @@ impl<'a> CoherenceChecker<'a> {\n \n     fn check_implementation_coherence_of(&self, trait_def_id: DefId) {\n         // Unify pairs of polytypes.\n-        self.iter_impls_of_trait_local(trait_def_id, |a| {\n-            let implementation_a = a;\n+        self.iter_impls_of_trait_local(trait_def_id, |impl_a| {\n             let polytype_a =\n-                self.get_self_type_for_implementation(implementation_a);\n+                self.get_self_type_for_implementation(impl_a);\n \n             // \"We have an impl of trait <trait_def_id> for type <polytype_a>,\n-            // and that impl is <implementation_a>\"\n-            self.iter_impls_of_trait(trait_def_id, |b| {\n-                let implementation_b = b;\n+            // and that impl is <impl_a>\"\n+            self.iter_impls_of_trait(trait_def_id, |impl_b| {\n \n                 // An impl is coherent with itself\n-                if a.did != b.did {\n+                if impl_a != impl_b {\n                     let polytype_b = self.get_self_type_for_implementation(\n-                            implementation_b);\n+                            impl_b);\n \n                     if self.polytypes_unify(polytype_a.clone(), polytype_b) {\n                         let session = &self.crate_context.tcx.sess;\n                         session.span_err(\n-                            self.span_of_impl(implementation_a),\n+                            self.span_of_impl(impl_a),\n                             format!(\"conflicting implementations for trait `{}`\",\n                                  ty::item_path_str(self.crate_context.tcx,\n                                                    trait_def_id)));\n-                        if implementation_b.did.krate == LOCAL_CRATE {\n-                            session.span_note(self.span_of_impl(implementation_b),\n+                        if impl_b.krate == LOCAL_CRATE {\n+                            session.span_note(self.span_of_impl(impl_b),\n                                               \"note conflicting implementation here\");\n                         } else {\n                             let crate_store = &self.crate_context.tcx.sess.cstore;\n-                            let cdata = crate_store.get_crate_data(implementation_b.did.krate);\n+                            let cdata = crate_store.get_crate_data(impl_b.krate);\n                             session.note(\n                                 \"conflicting implementation in crate `\" + cdata.name + \"`\");\n                         }\n@@ -430,7 +428,7 @@ impl<'a> CoherenceChecker<'a> {\n         })\n     }\n \n-    fn iter_impls_of_trait(&self, trait_def_id: DefId, f: |@Impl|) {\n+    fn iter_impls_of_trait(&self, trait_def_id: DefId, f: |DefId|) {\n         self.iter_impls_of_trait_local(trait_def_id, |x| f(x));\n \n         if trait_def_id.krate == LOCAL_CRATE {\n@@ -439,17 +437,17 @@ impl<'a> CoherenceChecker<'a> {\n \n         let crate_store = &self.crate_context.tcx.sess.cstore;\n         csearch::each_implementation_for_trait(crate_store, trait_def_id, |impl_def_id| {\n-            let implementation = @csearch::get_impl(self.crate_context.tcx, impl_def_id);\n-            let _ = lookup_item_type(self.crate_context.tcx, implementation.did);\n-            f(implementation);\n+            // Is this actually necessary?\n+            let _ = lookup_item_type(self.crate_context.tcx, impl_def_id);\n+            f(impl_def_id);\n         });\n     }\n \n-    fn iter_impls_of_trait_local(&self, trait_def_id: DefId, f: |@Impl|) {\n+    fn iter_impls_of_trait_local(&self, trait_def_id: DefId, f: |DefId|) {\n         match self.crate_context.tcx.trait_impls.borrow().find(&trait_def_id) {\n             Some(impls) => {\n-                for &im in impls.borrow().iter() {\n-                    f(im);\n+                for &impl_did in impls.borrow().iter() {\n+                    f(impl_did);\n                 }\n             }\n             None => { /* no impls? */ }\n@@ -509,9 +507,9 @@ impl<'a> CoherenceChecker<'a> {\n                             b.monotype).is_ok()\n     }\n \n-    fn get_self_type_for_implementation(&self, implementation: @Impl)\n+    fn get_self_type_for_implementation(&self, impl_did: DefId)\n                                         -> ty_param_bounds_and_ty {\n-        self.crate_context.tcx.tcache.borrow().get_copy(&implementation.did)\n+        self.crate_context.tcx.tcache.borrow().get_copy(&impl_did)\n     }\n \n     // Privileged scope checking\n@@ -563,15 +561,13 @@ impl<'a> CoherenceChecker<'a> {\n         }\n     }\n \n-    // Converts an implementation in the AST to an Impl structure.\n-    fn create_impl_from_item(&self, item: &Item) -> @Impl {\n-        let tcx = self.crate_context.tcx;\n+    // Converts an implementation in the AST to a vector of methods.\n+    fn create_impl_from_item(&self, item: &Item) -> Vec<DefId> {\n         match item.node {\n             ItemImpl(_, ref trait_refs, _, ref ast_methods) => {\n-                let mut methods = Vec::new();\n-                for ast_method in ast_methods.iter() {\n-                    methods.push(ty::method(tcx, local_def(ast_method.id)));\n-                }\n+                let mut methods: Vec<DefId> = ast_methods.iter().map(|ast_method| {\n+                    local_def(ast_method.id)\n+                }).collect();\n \n                 for trait_ref in trait_refs.iter() {\n                     let ty_trait_ref = ty::node_id_to_trait_ref(\n@@ -583,11 +579,7 @@ impl<'a> CoherenceChecker<'a> {\n                                                      &mut methods);\n                 }\n \n-                return @Impl {\n-                    did: local_def(item.id),\n-                    ident: item.ident,\n-                    methods: methods\n-                };\n+                methods\n             }\n             _ => {\n                 self.crate_context.tcx.sess.span_bug(item.span,\n@@ -596,9 +588,9 @@ impl<'a> CoherenceChecker<'a> {\n         }\n     }\n \n-    fn span_of_impl(&self, implementation: @Impl) -> Span {\n-        assert_eq!(implementation.did.krate, LOCAL_CRATE);\n-        self.crate_context.tcx.map.span(implementation.did.node)\n+    fn span_of_impl(&self, impl_did: DefId) -> Span {\n+        assert_eq!(impl_did.krate, LOCAL_CRATE);\n+        self.crate_context.tcx.map.span(impl_did.node)\n     }\n \n     // External crate handling\n@@ -607,36 +599,35 @@ impl<'a> CoherenceChecker<'a> {\n                          impls_seen: &mut HashSet<DefId>,\n                          impl_def_id: DefId) {\n         let tcx = self.crate_context.tcx;\n-        let implementation = @csearch::get_impl(tcx, impl_def_id);\n+        let methods = csearch::get_impl_methods(&tcx.sess.cstore, impl_def_id);\n \n         // Make sure we don't visit the same implementation multiple times.\n-        if !impls_seen.insert(implementation.did) {\n+        if !impls_seen.insert(impl_def_id) {\n             // Skip this one.\n             return\n         }\n         // Good. Continue.\n \n-        let _ = lookup_item_type(tcx, implementation.did);\n-        let associated_traits = get_impl_trait(tcx, implementation.did);\n+        let _ = lookup_item_type(tcx, impl_def_id);\n+        let associated_traits = get_impl_trait(tcx, impl_def_id);\n \n         // Do a sanity check.\n         assert!(associated_traits.is_some());\n \n         // Record all the trait methods.\n         for trait_ref in associated_traits.iter() {\n-              self.add_trait_impl(trait_ref.def_id, implementation);\n+            self.add_trait_impl(trait_ref.def_id, impl_def_id);\n         }\n \n         // For any methods that use a default implementation, add them to\n         // the map. This is a bit unfortunate.\n-        for method in implementation.methods.iter() {\n-            for source in method.provided_source.iter() {\n-                tcx.provided_method_sources.borrow_mut()\n-                   .insert(method.def_id, *source);\n+        for &method_def_id in methods.iter() {\n+            for &source in ty::method(tcx, method_def_id).provided_source.iter() {\n+                tcx.provided_method_sources.borrow_mut().insert(method_def_id, source);\n             }\n         }\n \n-        tcx.impls.borrow_mut().insert(implementation.did, implementation);\n+        tcx.impl_methods.borrow_mut().insert(impl_def_id, methods);\n     }\n \n     // Adds implementations and traits from external crates to the coherence\n@@ -663,19 +654,21 @@ impl<'a> CoherenceChecker<'a> {\n             Some(id) => id, None => { return }\n         };\n \n-        let impls = match tcx.trait_impls.borrow().find_copy(&drop_trait) {\n+        let impl_methods = tcx.impl_methods.borrow();\n+        let trait_impls = match tcx.trait_impls.borrow().find_copy(&drop_trait) {\n             None => return, // No types with (new-style) dtors present.\n             Some(found_impls) => found_impls\n         };\n \n-        for impl_info in impls.borrow().iter() {\n-            if impl_info.methods.len() < 1 {\n+        for &impl_did in trait_impls.borrow().iter() {\n+            let methods = impl_methods.get(&impl_did);\n+            if methods.len() < 1 {\n                 // We'll error out later. For now, just don't ICE.\n                 continue;\n             }\n-            let method_def_id = impl_info.methods.get(0).def_id;\n+            let method_def_id = *methods.get(0);\n \n-            let self_type = self.get_self_type_for_implementation(*impl_info);\n+            let self_type = self.get_self_type_for_implementation(impl_did);\n             match ty::get(self_type.ty).sty {\n                 ty::ty_enum(type_def_id, _) |\n                 ty::ty_struct(type_def_id, _) => {\n@@ -685,9 +678,9 @@ impl<'a> CoherenceChecker<'a> {\n                 }\n                 _ => {\n                     // Destructors only work on nominal types.\n-                    if impl_info.did.krate == ast::LOCAL_CRATE {\n+                    if impl_did.krate == ast::LOCAL_CRATE {\n                         {\n-                            match tcx.map.find(impl_info.did.node) {\n+                            match tcx.map.find(impl_did.node) {\n                                 Some(ast_map::NodeItem(item)) => {\n                                     tcx.sess.span_err((*item).span,\n                                                       \"the Drop trait may \\"}]}