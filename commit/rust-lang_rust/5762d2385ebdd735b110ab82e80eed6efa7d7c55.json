{"sha": "5762d2385ebdd735b110ab82e80eed6efa7d7c55", "node_id": "C_kwDOAAsO6NoAKDU3NjJkMjM4NWViZGQ3MzViMTEwYWI4MmU4MGVlZDZlZmE3ZDdjNTU", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-06-28T03:10:36Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-07-04T08:34:20Z"}, "message": "Avoid unnecessary blocks in derive output.\n\nBy not committing to either block form or expression form until\nnecessary, we can avoid lots of unnecessary blocks.", "tree": {"sha": "02329e165795ab5529d63de46fbdbcb0e441bd74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02329e165795ab5529d63de46fbdbcb0e441bd74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5762d2385ebdd735b110ab82e80eed6efa7d7c55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5762d2385ebdd735b110ab82e80eed6efa7d7c55", "html_url": "https://github.com/rust-lang/rust/commit/5762d2385ebdd735b110ab82e80eed6efa7d7c55", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5762d2385ebdd735b110ab82e80eed6efa7d7c55/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4ecc4fb5cd82a9298956538c6d6574f7792810f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4ecc4fb5cd82a9298956538c6d6574f7792810f", "html_url": "https://github.com/rust-lang/rust/commit/d4ecc4fb5cd82a9298956538c6d6574f7792810f"}], "stats": {"total": 833, "additions": 406, "deletions": 427}, "files": [{"sha": "b37b82dd089ca450145d58776568f6541e271d9e", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5762d2385ebdd735b110ab82e80eed6efa7d7c55/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5762d2385ebdd735b110ab82e80eed6efa7d7c55/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=5762d2385ebdd735b110ab82e80eed6efa7d7c55", "patch": "@@ -2,8 +2,7 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::path_std;\n \n-use rustc_ast::ptr::P;\n-use rustc_ast::{self as ast, Expr, Generics, ItemKind, MetaItem, VariantData};\n+use rustc_ast::{self as ast, Generics, ItemKind, MetaItem, VariantData};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n@@ -98,7 +97,7 @@ fn cs_clone_simple(\n     trait_span: Span,\n     substr: &Substructure<'_>,\n     is_union: bool,\n-) -> P<Expr> {\n+) -> BlockOrExpr {\n     let mut stmts = Vec::new();\n     let mut process_variant = |variant: &VariantData| {\n         for field in variant.fields() {\n@@ -139,16 +138,15 @@ fn cs_clone_simple(\n             ),\n         }\n     }\n-    stmts.push(cx.stmt_expr(cx.expr_deref(trait_span, cx.expr_self(trait_span))));\n-    cx.expr_block(cx.block(trait_span, stmts))\n+    BlockOrExpr::new_mixed(stmts, cx.expr_deref(trait_span, cx.expr_self(trait_span)))\n }\n \n fn cs_clone(\n     name: &str,\n     cx: &mut ExtCtxt<'_>,\n     trait_span: Span,\n     substr: &Substructure<'_>,\n-) -> P<Expr> {\n+) -> BlockOrExpr {\n     let ctor_path;\n     let all_fields;\n     let fn_path = cx.std_path(&[sym::clone, sym::Clone, sym::clone]);\n@@ -177,7 +175,7 @@ fn cs_clone(\n         }\n     }\n \n-    match *vdata {\n+    let expr = match *vdata {\n         VariantData::Struct(..) => {\n             let fields = all_fields\n                 .iter()\n@@ -201,5 +199,6 @@ fn cs_clone(\n             cx.expr_call(trait_span, path, subcalls)\n         }\n         VariantData::Unit(..) => cx.expr_path(ctor_path),\n-    }\n+    };\n+    BlockOrExpr::new_expr(expr)\n }"}, {"sha": "59f8fbc4a08ef85187cf89f3df0448c1fc37c1d4", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/eq.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5762d2385ebdd735b110ab82e80eed6efa7d7c55/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5762d2385ebdd735b110ab82e80eed6efa7d7c55/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs?ref=5762d2385ebdd735b110ab82e80eed6efa7d7c55", "patch": "@@ -2,8 +2,7 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::path_std;\n \n-use rustc_ast::ptr::P;\n-use rustc_ast::{self as ast, Expr, MetaItem};\n+use rustc_ast::{self as ast, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n@@ -52,7 +51,7 @@ fn cs_total_eq_assert(\n     cx: &mut ExtCtxt<'_>,\n     trait_span: Span,\n     substr: &Substructure<'_>,\n-) -> P<Expr> {\n+) -> BlockOrExpr {\n     let mut stmts = Vec::new();\n     let mut process_variant = |variant: &ast::VariantData| {\n         for field in variant.fields() {\n@@ -78,5 +77,5 @@ fn cs_total_eq_assert(\n         }\n         _ => cx.span_bug(trait_span, \"unexpected substructure in `derive(Eq)`\"),\n     }\n-    cx.expr_block(cx.block(trait_span, stmts))\n+    BlockOrExpr::new_stmts(stmts)\n }"}, {"sha": "4795b72a7805670c09e72e2540e74dbb930c58e6", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5762d2385ebdd735b110ab82e80eed6efa7d7c55/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5762d2385ebdd735b110ab82e80eed6efa7d7c55/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=5762d2385ebdd735b110ab82e80eed6efa7d7c55", "patch": "@@ -3,7 +3,7 @@ use crate::deriving::generic::*;\n use crate::deriving::path_std;\n \n use rustc_ast::ptr::P;\n-use rustc_ast::{self as ast, Expr, MetaItem};\n+use rustc_ast::{self as ast, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n@@ -51,7 +51,7 @@ pub fn ordering_collapsed(\n     cx.expr_call_global(span, fn_cmp_path, vec![lft, rgt])\n }\n \n-pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {\n+pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> BlockOrExpr {\n     let test_id = Ident::new(sym::cmp, span);\n     let equals_path = cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::Equal]));\n \n@@ -70,7 +70,7 @@ pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<\n     // cmp => cmp\n     // }\n     //\n-    cs_fold(\n+    let expr = cs_fold(\n         // foldr nests the if-elses correctly, leaving the first field\n         // as the outermost one, and the last as the innermost.\n         false,\n@@ -107,5 +107,6 @@ pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<\n         cx,\n         span,\n         substr,\n-    )\n+    );\n+    BlockOrExpr::new_expr(expr)\n }"}, {"sha": "f58e303b8f085c33f00c37d9b7ff4670e94c5518", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5762d2385ebdd735b110ab82e80eed6efa7d7c55/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5762d2385ebdd735b110ab82e80eed6efa7d7c55/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=5762d2385ebdd735b110ab82e80eed6efa7d7c55", "patch": "@@ -15,16 +15,14 @@ pub fn expand_deriving_partial_eq(\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n ) {\n-    // structures are equal if all fields are equal, and non equal, if\n-    // any fields are not equal or if the enum variants are different\n     fn cs_op(\n         cx: &mut ExtCtxt<'_>,\n         span: Span,\n         substr: &Substructure<'_>,\n         op: BinOpKind,\n         combiner: BinOpKind,\n         base: bool,\n-    ) -> P<Expr> {\n+    ) -> BlockOrExpr {\n         let op = |cx: &mut ExtCtxt<'_>, span: Span, self_f: P<Expr>, other_fs: &[P<Expr>]| {\n             let [other_f] = other_fs else {\n                 cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\");\n@@ -33,7 +31,7 @@ pub fn expand_deriving_partial_eq(\n             cx.expr_binary(span, op, self_f, other_f.clone())\n         };\n \n-        cs_fold1(\n+        let expr = cs_fold1(\n             true, // use foldl\n             |cx, span, subexpr, self_f, other_fs| {\n                 let eq = op(cx, span, self_f, other_fs);\n@@ -52,13 +50,14 @@ pub fn expand_deriving_partial_eq(\n             cx,\n             span,\n             substr,\n-        )\n+        );\n+        BlockOrExpr::new_expr(expr)\n     }\n \n-    fn cs_eq(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {\n+    fn cs_eq(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> BlockOrExpr {\n         cs_op(cx, span, substr, BinOpKind::Eq, BinOpKind::And, true)\n     }\n-    fn cs_ne(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {\n+    fn cs_ne(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> BlockOrExpr {\n         cs_op(cx, span, substr, BinOpKind::Ne, BinOpKind::Or, false)\n     }\n "}, {"sha": "891485ab8ffe7dd8a5ba6bf6897af619cd039b13", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5762d2385ebdd735b110ab82e80eed6efa7d7c55/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5762d2385ebdd735b110ab82e80eed6efa7d7c55/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=5762d2385ebdd735b110ab82e80eed6efa7d7c55", "patch": "@@ -2,8 +2,7 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::{path_std, pathvec_std};\n \n-use rustc_ast::ptr::P;\n-use rustc_ast::{Expr, MetaItem};\n+use rustc_ast::MetaItem;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n@@ -48,7 +47,7 @@ pub fn expand_deriving_partial_ord(\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {\n+pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> BlockOrExpr {\n     let test_id = Ident::new(sym::cmp, span);\n     let ordering = cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::Equal]));\n     let ordering_expr = cx.expr_path(ordering.clone());\n@@ -69,7 +68,7 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_\n     // cmp => cmp\n     // }\n     //\n-    cs_fold(\n+    let expr = cs_fold(\n         // foldr nests the if-elses correctly, leaving the first field\n         // as the outermost one, and the last as the innermost.\n         false,\n@@ -110,5 +109,6 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_\n         cx,\n         span,\n         substr,\n-    )\n+    );\n+    BlockOrExpr::new_expr(expr)\n }"}, {"sha": "e04898287608b756523f714298de5b43b525d0cd", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5762d2385ebdd735b110ab82e80eed6efa7d7c55/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5762d2385ebdd735b110ab82e80eed6efa7d7c55/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=5762d2385ebdd735b110ab82e80eed6efa7d7c55", "patch": "@@ -2,8 +2,7 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::path_std;\n \n-use rustc_ast::ptr::P;\n-use rustc_ast::{self as ast, Expr, MetaItem};\n+use rustc_ast::{self as ast, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n@@ -42,7 +41,7 @@ pub fn expand_deriving_debug(\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {\n+fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> BlockOrExpr {\n     let (ident, vdata, fields) = match substr.fields {\n         Struct(vdata, fields) => (substr.type_ident, *vdata, fields),\n         EnumMatching(_, _, v, fields) => (v.ident, &v.data, fields),\n@@ -74,7 +73,8 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     if fields.is_empty() {\n         // Special case for no fields.\n         let fn_path_write_str = cx.std_path(&[sym::fmt, sym::Formatter, sym::write_str]);\n-        cx.expr_call_global(span, fn_path_write_str, vec![fmt, name])\n+        let expr = cx.expr_call_global(span, fn_path_write_str, vec![fmt, name]);\n+        BlockOrExpr::new_expr(expr)\n     } else if fields.len() <= CUTOFF {\n         // Few enough fields that we can use a specific-length method.\n         let debug = if is_struct {\n@@ -100,7 +100,8 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n             let field = cx.expr_addr_of(field.span, field);\n             args.push(field);\n         }\n-        cx.expr_call_global(span, fn_path_debug, args)\n+        let expr = cx.expr_call_global(span, fn_path_debug, args);\n+        BlockOrExpr::new_expr(expr)\n     } else {\n         // Enough fields that we must use the any-length method.\n         let mut name_exprs = Vec::with_capacity(fields.len());\n@@ -176,8 +177,6 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n             stmts.push(names_let.unwrap());\n         }\n         stmts.push(values_let);\n-        stmts.push(cx.stmt_expr(expr));\n-\n-        cx.expr_block(cx.block(span, stmts))\n+        BlockOrExpr::new_mixed(stmts, expr)\n     }\n }"}, {"sha": "b9f2a75082224a5647b856ca092cc165ea205c30", "filename": "compiler/rustc_builtin_macros/src/deriving/decodable.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5762d2385ebdd735b110ab82e80eed6efa7d7c55/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5762d2385ebdd735b110ab82e80eed6efa7d7c55/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs?ref=5762d2385ebdd735b110ab82e80eed6efa7d7c55", "patch": "@@ -62,7 +62,7 @@ fn decodable_substructure(\n     trait_span: Span,\n     substr: &Substructure<'_>,\n     krate: Symbol,\n-) -> P<Expr> {\n+) -> BlockOrExpr {\n     let decoder = substr.nonself_args[0].clone();\n     let recurse = vec![\n         Ident::new(krate, trait_span),\n@@ -74,7 +74,7 @@ fn decodable_substructure(\n     let blkarg = Ident::new(sym::_d, trait_span);\n     let blkdecoder = cx.expr_ident(trait_span, blkarg);\n \n-    match *substr.fields {\n+    let expr = match *substr.fields {\n         StaticStruct(_, ref summary) => {\n             let nfields = match *summary {\n                 Unnamed(ref fields, _) => fields.len(),\n@@ -173,7 +173,8 @@ fn decodable_substructure(\n             )\n         }\n         _ => cx.bug(\"expected StaticEnum or StaticStruct in derive(Decodable)\"),\n-    }\n+    };\n+    BlockOrExpr::new_expr(expr)\n }\n \n /// Creates a decoder for a single enum variant/struct:"}, {"sha": "90d5cdbc0a0783ac494e2b7941859875f1734f5b", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5762d2385ebdd735b110ab82e80eed6efa7d7c55/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5762d2385ebdd735b110ab82e80eed6efa7d7c55/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=5762d2385ebdd735b110ab82e80eed6efa7d7c55", "patch": "@@ -1,11 +1,10 @@\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n \n-use rustc_ast::ptr::P;\n+use rustc_ast as ast;\n use rustc_ast::walk_list;\n use rustc_ast::EnumDef;\n use rustc_ast::VariantData;\n-use rustc_ast::{Expr, MetaItem};\n use rustc_errors::Applicability;\n use rustc_expand::base::{Annotatable, DummyResult, ExtCtxt};\n use rustc_span::symbol::Ident;\n@@ -16,7 +15,7 @@ use smallvec::SmallVec;\n pub fn expand_deriving_default(\n     cx: &mut ExtCtxt<'_>,\n     span: Span,\n-    mitem: &MetaItem,\n+    mitem: &ast::MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n ) {\n@@ -59,12 +58,12 @@ fn default_struct_substructure(\n     trait_span: Span,\n     substr: &Substructure<'_>,\n     summary: &StaticFields,\n-) -> P<Expr> {\n+) -> BlockOrExpr {\n     // Note that `kw::Default` is \"default\" and `sym::Default` is \"Default\"!\n     let default_ident = cx.std_path(&[kw::Default, sym::Default, kw::Default]);\n     let default_call = |span| cx.expr_call_global(span, default_ident.clone(), Vec::new());\n \n-    match summary {\n+    let expr = match summary {\n         Unnamed(ref fields, is_tuple) => {\n             if !is_tuple {\n                 cx.expr_ident(trait_span, substr.type_ident)\n@@ -80,31 +79,27 @@ fn default_struct_substructure(\n                 .collect();\n             cx.expr_struct_ident(trait_span, substr.type_ident, default_fields)\n         }\n-    }\n+    };\n+    BlockOrExpr::new_expr(expr)\n }\n \n fn default_enum_substructure(\n     cx: &mut ExtCtxt<'_>,\n     trait_span: Span,\n     enum_def: &EnumDef,\n-) -> P<Expr> {\n-    let Ok(default_variant) = extract_default_variant(cx, enum_def, trait_span) else {\n-        return DummyResult::raw_expr(trait_span, true);\n+) -> BlockOrExpr {\n+    let expr = if let Ok(default_variant) = extract_default_variant(cx, enum_def, trait_span)\n+        && let Ok(_) = validate_default_attribute(cx, default_variant)\n+    {\n+        // We now know there is exactly one unit variant with exactly one `#[default]` attribute.\n+        cx.expr_path(cx.path(\n+            default_variant.span,\n+            vec![Ident::new(kw::SelfUpper, default_variant.span), default_variant.ident],\n+        ))\n+    } else {\n+        DummyResult::raw_expr(trait_span, true)\n     };\n-\n-    // At this point, we know that there is exactly one variant with a `#[default]` attribute. The\n-    // attribute hasn't yet been validated.\n-\n-    if let Err(()) = validate_default_attribute(cx, default_variant) {\n-        return DummyResult::raw_expr(trait_span, true);\n-    }\n-\n-    // We now know there is exactly one unit variant with exactly one `#[default]` attribute.\n-\n-    cx.expr_path(cx.path(\n-        default_variant.span,\n-        vec![Ident::new(kw::SelfUpper, default_variant.span), default_variant.ident],\n-    ))\n+    BlockOrExpr::new_expr(expr)\n }\n \n fn extract_default_variant<'a>("}, {"sha": "0dfce114bfc5399af72a809b64cc3d80721cc0e3", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5762d2385ebdd735b110ab82e80eed6efa7d7c55/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5762d2385ebdd735b110ab82e80eed6efa7d7c55/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=5762d2385ebdd735b110ab82e80eed6efa7d7c55", "patch": "@@ -89,8 +89,7 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::pathvec_std;\n \n-use rustc_ast::ptr::P;\n-use rustc_ast::{Expr, ExprKind, MetaItem, Mutability};\n+use rustc_ast::{ExprKind, MetaItem, Mutability};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n@@ -147,7 +146,7 @@ fn encodable_substructure(\n     trait_span: Span,\n     substr: &Substructure<'_>,\n     krate: Symbol,\n-) -> P<Expr> {\n+) -> BlockOrExpr {\n     let encoder = substr.nonself_args[0].clone();\n     // throw an underscore in front to suppress unused variable warnings\n     let blkarg = Ident::new(sym::_e, trait_span);\n@@ -208,7 +207,7 @@ fn encodable_substructure(\n             let fn_emit_struct_path =\n                 cx.def_site_path(&[sym::rustc_serialize, sym::Encoder, sym::emit_struct]);\n \n-            cx.expr_call_global(\n+            let expr = cx.expr_call_global(\n                 trait_span,\n                 fn_emit_struct_path,\n                 vec![\n@@ -217,7 +216,8 @@ fn encodable_substructure(\n                     cx.expr_usize(trait_span, fields.len()),\n                     blk,\n                 ],\n-            )\n+            );\n+            BlockOrExpr::new_expr(expr)\n         }\n \n         EnumMatching(idx, _, variant, ref fields) => {\n@@ -279,12 +279,12 @@ fn encodable_substructure(\n             let blk = cx.lambda1(trait_span, call, blkarg);\n             let fn_emit_enum_path: Vec<_> =\n                 cx.def_site_path(&[sym::rustc_serialize, sym::Encoder, sym::emit_enum]);\n-            let ret = cx.expr_call_global(\n+            let expr = cx.expr_call_global(\n                 trait_span,\n                 fn_emit_enum_path,\n                 vec![encoder, cx.expr_str(trait_span, substr.type_ident.name), blk],\n             );\n-            cx.expr_block(cx.block(trait_span, vec![me, cx.stmt_expr(ret)]))\n+            BlockOrExpr::new_mixed(vec![me], expr)\n         }\n \n         _ => cx.bug(\"expected Struct or EnumMatching in derive(Encodable)\"),"}, {"sha": "e2d82b181a193840893f484a9456af6ac36bcfe6", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 77, "deletions": 37, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/5762d2385ebdd735b110ab82e80eed6efa7d7c55/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5762d2385ebdd735b110ab82e80eed6efa7d7c55/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=5762d2385ebdd735b110ab82e80eed6efa7d7c55", "patch": "@@ -296,7 +296,7 @@ pub enum SubstructureFields<'a> {\n /// Combine the values of all the fields together. The last argument is\n /// all the fields of all the structures.\n pub type CombineSubstructureFunc<'a> =\n-    Box<dyn FnMut(&mut ExtCtxt<'_>, Span, &Substructure<'_>) -> P<Expr> + 'a>;\n+    Box<dyn FnMut(&mut ExtCtxt<'_>, Span, &Substructure<'_>) -> BlockOrExpr + 'a>;\n \n /// Deal with non-matching enum variants. The slice is the identifiers holding\n /// the variant index value for each of the `Self` arguments.\n@@ -314,6 +314,48 @@ struct TypeParameter {\n     ty: P<ast::Ty>,\n }\n \n+// The code snippets built up for derived code are sometimes used as blocks\n+// (e.g. in a function body) and sometimes used as expressions (e.g. in a match\n+// arm). This structure avoids committing to either form until necessary,\n+// avoiding the insertion of any unnecessary blocks.\n+//\n+// The statements come before the expression.\n+pub struct BlockOrExpr(Vec<ast::Stmt>, Option<P<Expr>>);\n+\n+impl BlockOrExpr {\n+    pub fn new_stmts(stmts: Vec<ast::Stmt>) -> BlockOrExpr {\n+        BlockOrExpr(stmts, None)\n+    }\n+\n+    pub fn new_expr(expr: P<Expr>) -> BlockOrExpr {\n+        BlockOrExpr(vec![], Some(expr))\n+    }\n+\n+    pub fn new_mixed(stmts: Vec<ast::Stmt>, expr: P<Expr>) -> BlockOrExpr {\n+        BlockOrExpr(stmts, Some(expr))\n+    }\n+\n+    // Converts it into a block.\n+    fn into_block(mut self, cx: &ExtCtxt<'_>, span: Span) -> P<ast::Block> {\n+        if let Some(expr) = self.1 {\n+            self.0.push(cx.stmt_expr(expr));\n+        }\n+        cx.block(span, self.0)\n+    }\n+\n+    // Converts it into an expression.\n+    fn into_expr(self, cx: &ExtCtxt<'_>, span: Span) -> P<Expr> {\n+        if self.0.is_empty() {\n+            match self.1 {\n+                None => cx.expr_block(cx.block(span, vec![])),\n+                Some(expr) => expr,\n+            }\n+        } else {\n+            cx.expr_block(self.into_block(cx, span))\n+        }\n+    }\n+}\n+\n /// This method helps to extract all the type parameters referenced from a\n /// type. For a type parameter `<T>`, it looks for either a `TyPath` that\n /// is not global and starts with `T`, or a `TyQPath`.\n@@ -827,7 +869,7 @@ impl<'a> MethodDef<'a> {\n         type_ident: Ident,\n         nonself_args: &[P<Expr>],\n         fields: &SubstructureFields<'_>,\n-    ) -> P<Expr> {\n+    ) -> BlockOrExpr {\n         let span = trait_.span;\n         let substructure = Substructure { type_ident, nonself_args, fields };\n         let mut f = self.combine_substructure.borrow_mut();\n@@ -902,7 +944,7 @@ impl<'a> MethodDef<'a> {\n         generics: &Generics,\n         explicit_self: Option<ast::ExplicitSelf>,\n         arg_types: Vec<(Ident, P<ast::Ty>)>,\n-        body: P<Expr>,\n+        body: BlockOrExpr,\n     ) -> P<ast::AssocItem> {\n         let span = trait_.span;\n         // Create the generics that aren't for `Self`.\n@@ -921,7 +963,7 @@ impl<'a> MethodDef<'a> {\n \n         let method_ident = Ident::new(self.name, span);\n         let fn_decl = cx.fn_decl(args, ast::FnRetTy::Ty(ret_type));\n-        let body_block = cx.block_expr(body);\n+        let body_block = body.into_block(cx, span);\n \n         let trait_lo_sp = span.shrink_to_lo();\n \n@@ -986,7 +1028,7 @@ impl<'a> MethodDef<'a> {\n         nonself_args: &[P<Expr>],\n         use_temporaries: bool,\n         is_packed: bool,\n-    ) -> P<Expr> {\n+    ) -> BlockOrExpr {\n         let mut raw_fields = Vec::new(); // Vec<[fields of self], [fields of next Self arg], [etc]>\n         let span = trait_.span;\n         let mut patterns = Vec::new();\n@@ -1047,16 +1089,14 @@ impl<'a> MethodDef<'a> {\n         );\n \n         if !is_packed {\n-            body.span = span;\n             body\n         } else {\n             // Do the let-destructuring.\n             let mut stmts: Vec<_> = iter::zip(self_args, patterns)\n                 .map(|(arg_expr, pat)| cx.stmt_let_pat(span, pat, arg_expr.clone()))\n                 .collect();\n-            stmts.push(cx.stmt_expr(body));\n-\n-            cx.expr_block(cx.block(span, stmts))\n+            stmts.extend(std::mem::take(&mut body.0));\n+            BlockOrExpr(stmts, body.1)\n         }\n     }\n \n@@ -1067,7 +1107,7 @@ impl<'a> MethodDef<'a> {\n         struct_def: &VariantData,\n         type_ident: Ident,\n         nonself_args: &[P<Expr>],\n-    ) -> P<Expr> {\n+    ) -> BlockOrExpr {\n         let summary = trait_.summarise_struct(cx, struct_def);\n \n         self.call_substructure_method(\n@@ -1130,7 +1170,7 @@ impl<'a> MethodDef<'a> {\n         type_ident: Ident,\n         mut self_args: Vec<P<Expr>>,\n         nonself_args: &[P<Expr>],\n-    ) -> P<Expr> {\n+    ) -> BlockOrExpr {\n         let span = trait_.span;\n         let variants = &enum_def.variants;\n \n@@ -1253,13 +1293,9 @@ impl<'a> MethodDef<'a> {\n                 // Self arg, assuming all are instances of VariantK.\n                 // Build up code associated with such a case.\n                 let substructure = EnumMatching(index, variants.len(), variant, field_tuples);\n-                let arm_expr = self.call_substructure_method(\n-                    cx,\n-                    trait_,\n-                    type_ident,\n-                    nonself_args,\n-                    &substructure,\n-                );\n+                let arm_expr = self\n+                    .call_substructure_method(cx, trait_, type_ident, nonself_args, &substructure)\n+                    .into_expr(cx, span);\n \n                 cx.arm(span, single_pat, arm_expr)\n             })\n@@ -1271,13 +1307,16 @@ impl<'a> MethodDef<'a> {\n                 // The index and actual variant aren't meaningful in this case,\n                 // so just use whatever\n                 let substructure = EnumMatching(0, variants.len(), v, Vec::new());\n-                Some(self.call_substructure_method(\n-                    cx,\n-                    trait_,\n-                    type_ident,\n-                    nonself_args,\n-                    &substructure,\n-                ))\n+                Some(\n+                    self.call_substructure_method(\n+                        cx,\n+                        trait_,\n+                        type_ident,\n+                        nonself_args,\n+                        &substructure,\n+                    )\n+                    .into_expr(cx, span),\n+                )\n             }\n             _ if variants.len() > 1 && self_args.len() > 1 => {\n                 // Since we know that all the arguments will match if we reach\n@@ -1341,13 +1380,15 @@ impl<'a> MethodDef<'a> {\n                 }\n             }\n \n-            let arm_expr = self.call_substructure_method(\n-                cx,\n-                trait_,\n-                type_ident,\n-                nonself_args,\n-                &catch_all_substructure,\n-            );\n+            let arm_expr = self\n+                .call_substructure_method(\n+                    cx,\n+                    trait_,\n+                    type_ident,\n+                    nonself_args,\n+                    &catch_all_substructure,\n+                )\n+                .into_expr(cx, span);\n \n             // Final wrinkle: the self_args are expressions that deref\n             // down to desired places, but we cannot actually deref\n@@ -1371,8 +1412,7 @@ impl<'a> MethodDef<'a> {\n             //  }\n             let all_match = cx.expr_match(span, match_arg, match_arms);\n             let arm_expr = cx.expr_if(span, discriminant_test, all_match, Some(arm_expr));\n-            index_let_stmts.push(cx.stmt_expr(arm_expr));\n-            cx.expr_block(cx.block(span, index_let_stmts))\n+            BlockOrExpr(index_let_stmts, Some(arm_expr))\n         } else if variants.is_empty() {\n             // As an additional wrinkle, For a zero-variant enum A,\n             // currently the compiler\n@@ -1423,7 +1463,7 @@ impl<'a> MethodDef<'a> {\n             // derive Debug on such a type could here generate code\n             // that needs the feature gate enabled.)\n \n-            deriving::call_unreachable(cx, span)\n+            BlockOrExpr(vec![], Some(deriving::call_unreachable(cx, span)))\n         } else {\n             // Final wrinkle: the self_args are expressions that deref\n             // down to desired places, but we cannot actually deref\n@@ -1432,7 +1472,7 @@ impl<'a> MethodDef<'a> {\n             // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n             self_args.map_in_place(|self_arg| cx.expr_addr_of(span, self_arg));\n             let match_arg = cx.expr(span, ast::ExprKind::Tup(self_args));\n-            cx.expr_match(span, match_arg, match_arms)\n+            BlockOrExpr(vec![], Some(cx.expr_match(span, match_arg, match_arms)))\n         }\n     }\n \n@@ -1443,7 +1483,7 @@ impl<'a> MethodDef<'a> {\n         enum_def: &EnumDef,\n         type_ident: Ident,\n         nonself_args: &[P<Expr>],\n-    ) -> P<Expr> {\n+    ) -> BlockOrExpr {\n         let summary = enum_def\n             .variants\n             .iter()"}, {"sha": "c3f7d09886b3a23681dc8e6f5e2f7bee1a5370d9", "filename": "compiler/rustc_builtin_macros/src/deriving/hash.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5762d2385ebdd735b110ab82e80eed6efa7d7c55/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5762d2385ebdd735b110ab82e80eed6efa7d7c55/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs?ref=5762d2385ebdd735b110ab82e80eed6efa7d7c55", "patch": "@@ -2,8 +2,7 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::{self, path_std, pathvec_std};\n \n-use rustc_ast::ptr::P;\n-use rustc_ast::{Expr, MetaItem, Mutability};\n+use rustc_ast::{MetaItem, Mutability};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n@@ -45,7 +44,11 @@ pub fn expand_deriving_hash(\n     hash_trait_def.expand(cx, mitem, item, push);\n }\n \n-fn hash_substructure(cx: &mut ExtCtxt<'_>, trait_span: Span, substr: &Substructure<'_>) -> P<Expr> {\n+fn hash_substructure(\n+    cx: &mut ExtCtxt<'_>,\n+    trait_span: Span,\n+    substr: &Substructure<'_>,\n+) -> BlockOrExpr {\n     let [state_expr] = substr.nonself_args else {\n         cx.span_bug(trait_span, \"incorrect number of arguments in `derive(Hash)`\");\n     };\n@@ -81,6 +84,5 @@ fn hash_substructure(cx: &mut ExtCtxt<'_>, trait_span: Span, substr: &Substructu\n     stmts.extend(\n         fields.iter().map(|FieldInfo { ref self_, span, .. }| call_hash(*span, self_.clone())),\n     );\n-\n-    cx.expr_block(cx.block(trait_span, stmts))\n+    BlockOrExpr::new_stmts(stmts)\n }"}, {"sha": "fb5965858ccdfc965c7dd5fb12d22e264c66ba13", "filename": "src/test/ui/deriving/deriving-all-codegen.stdout", "status": "modified", "additions": 260, "deletions": 316, "changes": 576, "blob_url": "https://github.com/rust-lang/rust/blob/5762d2385ebdd735b110ab82e80eed6efa7d7c55/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/5762d2385ebdd735b110ab82e80eed6efa7d7c55/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout?ref=5762d2385ebdd735b110ab82e80eed6efa7d7c55", "patch": "@@ -28,7 +28,7 @@ struct Empty;\n #[allow(unused_qualifications)]\n impl ::core::clone::Clone for Empty {\n     #[inline]\n-    fn clone(&self) -> Empty { { *self } }\n+    fn clone(&self) -> Empty { *self }\n }\n #[automatically_derived]\n #[allow(unused_qualifications)]\n@@ -49,7 +49,7 @@ impl ::core::default::Default for Empty {\n #[automatically_derived]\n #[allow(unused_qualifications)]\n impl ::core::hash::Hash for Empty {\n-    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () { {} }\n+    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}\n }\n impl ::core::marker::StructuralPartialEq for Empty {}\n #[automatically_derived]\n@@ -65,7 +65,7 @@ impl ::core::cmp::Eq for Empty {\n     #[inline]\n     #[doc(hidden)]\n     #[no_coverage]\n-    fn assert_receiver_is_total_eq(&self) -> () { {} }\n+    fn assert_receiver_is_total_eq(&self) -> () {}\n }\n #[automatically_derived]\n #[allow(unused_qualifications)]\n@@ -95,11 +95,9 @@ struct Point {\n impl ::core::clone::Clone for Point {\n     #[inline]\n     fn clone(&self) -> Point {\n-        {\n-            let _: ::core::clone::AssertParamIsClone<u32>;\n-            let _: ::core::clone::AssertParamIsClone<u32>;\n-            *self\n-        }\n+        let _: ::core::clone::AssertParamIsClone<u32>;\n+        let _: ::core::clone::AssertParamIsClone<u32>;\n+        *self\n     }\n }\n #[automatically_derived]\n@@ -128,10 +126,8 @@ impl ::core::default::Default for Point {\n #[allow(unused_qualifications)]\n impl ::core::hash::Hash for Point {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n-        {\n-            ::core::hash::Hash::hash(&self.x, state);\n-            ::core::hash::Hash::hash(&self.y, state)\n-        }\n+        ::core::hash::Hash::hash(&self.x, state);\n+        ::core::hash::Hash::hash(&self.y, state)\n     }\n }\n impl ::core::marker::StructuralPartialEq for Point {}\n@@ -155,10 +151,8 @@ impl ::core::cmp::Eq for Point {\n     #[doc(hidden)]\n     #[no_coverage]\n     fn assert_receiver_is_total_eq(&self) -> () {\n-        {\n-            let _: ::core::cmp::AssertParamIsEq<u32>;\n-            let _: ::core::cmp::AssertParamIsEq<u32>;\n-        }\n+        let _: ::core::cmp::AssertParamIsEq<u32>;\n+        let _: ::core::cmp::AssertParamIsEq<u32>;\n     }\n }\n #[automatically_derived]\n@@ -229,15 +223,13 @@ impl ::core::clone::Clone for Big {\n #[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Big {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n-        {\n-            let names: &'static _ =\n-                &[\"b1\", \"b2\", \"b3\", \"b4\", \"b5\", \"b6\", \"b7\", \"b8\"];\n-            let values: &[&dyn ::core::fmt::Debug] =\n-                &[&&self.b1, &&self.b2, &&self.b3, &&self.b4, &&self.b5,\n-                            &&self.b6, &&self.b7, &&self.b8];\n-            ::core::fmt::Formatter::debug_struct_fields_finish(f, \"Big\",\n-                names, values)\n-        }\n+        let names: &'static _ =\n+            &[\"b1\", \"b2\", \"b3\", \"b4\", \"b5\", \"b6\", \"b7\", \"b8\"];\n+        let values: &[&dyn ::core::fmt::Debug] =\n+            &[&&self.b1, &&self.b2, &&self.b3, &&self.b4, &&self.b5,\n+                        &&self.b6, &&self.b7, &&self.b8];\n+        ::core::fmt::Formatter::debug_struct_fields_finish(f, \"Big\", names,\n+            values)\n     }\n }\n #[automatically_derived]\n@@ -261,16 +253,14 @@ impl ::core::default::Default for Big {\n #[allow(unused_qualifications)]\n impl ::core::hash::Hash for Big {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n-        {\n-            ::core::hash::Hash::hash(&self.b1, state);\n-            ::core::hash::Hash::hash(&self.b2, state);\n-            ::core::hash::Hash::hash(&self.b3, state);\n-            ::core::hash::Hash::hash(&self.b4, state);\n-            ::core::hash::Hash::hash(&self.b5, state);\n-            ::core::hash::Hash::hash(&self.b6, state);\n-            ::core::hash::Hash::hash(&self.b7, state);\n-            ::core::hash::Hash::hash(&self.b8, state)\n-        }\n+        ::core::hash::Hash::hash(&self.b1, state);\n+        ::core::hash::Hash::hash(&self.b2, state);\n+        ::core::hash::Hash::hash(&self.b3, state);\n+        ::core::hash::Hash::hash(&self.b4, state);\n+        ::core::hash::Hash::hash(&self.b5, state);\n+        ::core::hash::Hash::hash(&self.b6, state);\n+        ::core::hash::Hash::hash(&self.b7, state);\n+        ::core::hash::Hash::hash(&self.b8, state)\n     }\n }\n impl ::core::marker::StructuralPartialEq for Big {}\n@@ -300,16 +290,14 @@ impl ::core::cmp::Eq for Big {\n     #[doc(hidden)]\n     #[no_coverage]\n     fn assert_receiver_is_total_eq(&self) -> () {\n-        {\n-            let _: ::core::cmp::AssertParamIsEq<u32>;\n-            let _: ::core::cmp::AssertParamIsEq<u32>;\n-            let _: ::core::cmp::AssertParamIsEq<u32>;\n-            let _: ::core::cmp::AssertParamIsEq<u32>;\n-            let _: ::core::cmp::AssertParamIsEq<u32>;\n-            let _: ::core::cmp::AssertParamIsEq<u32>;\n-            let _: ::core::cmp::AssertParamIsEq<u32>;\n-            let _: ::core::cmp::AssertParamIsEq<u32>;\n-        }\n+        let _: ::core::cmp::AssertParamIsEq<u32>;\n+        let _: ::core::cmp::AssertParamIsEq<u32>;\n+        let _: ::core::cmp::AssertParamIsEq<u32>;\n+        let _: ::core::cmp::AssertParamIsEq<u32>;\n+        let _: ::core::cmp::AssertParamIsEq<u32>;\n+        let _: ::core::cmp::AssertParamIsEq<u32>;\n+        let _: ::core::cmp::AssertParamIsEq<u32>;\n+        let _: ::core::cmp::AssertParamIsEq<u32>;\n     }\n }\n #[automatically_derived]\n@@ -416,7 +404,8 @@ struct Packed(u32);\n impl ::core::clone::Clone for Packed {\n     #[inline]\n     fn clone(&self) -> Packed {\n-        { let _: ::core::clone::AssertParamIsClone<u32>; *self }\n+        let _: ::core::clone::AssertParamIsClone<u32>;\n+        *self\n     }\n }\n #[automatically_derived]\n@@ -426,11 +415,9 @@ impl ::core::marker::Copy for Packed { }\n #[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Packed {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n-        {\n-            let Self(__self_0_0) = *self;\n-            ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"Packed\",\n-                &&__self_0_0)\n-        }\n+        let Self(__self_0_0) = *self;\n+        ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"Packed\",\n+            &&__self_0_0)\n     }\n }\n #[automatically_derived]\n@@ -443,10 +430,8 @@ impl ::core::default::Default for Packed {\n #[allow(unused_qualifications)]\n impl ::core::hash::Hash for Packed {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n-        {\n-            let Self(__self_0_0) = *self;\n-            { ::core::hash::Hash::hash(&__self_0_0, state) }\n-        }\n+        let Self(__self_0_0) = *self;\n+        ::core::hash::Hash::hash(&__self_0_0, state)\n     }\n }\n impl ::core::marker::StructuralPartialEq for Packed {}\n@@ -455,19 +440,15 @@ impl ::core::marker::StructuralPartialEq for Packed {}\n impl ::core::cmp::PartialEq for Packed {\n     #[inline]\n     fn eq(&self, other: &Packed) -> bool {\n-        {\n-            let Self(__self_0_0) = *self;\n-            let Self(__self_1_0) = *other;\n-            __self_0_0 == __self_1_0\n-        }\n+        let Self(__self_0_0) = *self;\n+        let Self(__self_1_0) = *other;\n+        __self_0_0 == __self_1_0\n     }\n     #[inline]\n     fn ne(&self, other: &Packed) -> bool {\n-        {\n-            let Self(__self_0_0) = *self;\n-            let Self(__self_1_0) = *other;\n-            __self_0_0 != __self_1_0\n-        }\n+        let Self(__self_0_0) = *self;\n+        let Self(__self_1_0) = *other;\n+        __self_0_0 != __self_1_0\n     }\n }\n impl ::core::marker::StructuralEq for Packed {}\n@@ -478,7 +459,7 @@ impl ::core::cmp::Eq for Packed {\n     #[doc(hidden)]\n     #[no_coverage]\n     fn assert_receiver_is_total_eq(&self) -> () {\n-        { let _: ::core::cmp::AssertParamIsEq<u32>; }\n+        let _: ::core::cmp::AssertParamIsEq<u32>;\n     }\n }\n #[automatically_derived]\n@@ -487,15 +468,12 @@ impl ::core::cmp::PartialOrd for Packed {\n     #[inline]\n     fn partial_cmp(&self, other: &Packed)\n         -> ::core::option::Option<::core::cmp::Ordering> {\n-        {\n-            let Self(__self_0_0) = *self;\n-            let Self(__self_1_0) = *other;\n-            match ::core::cmp::PartialOrd::partial_cmp(&__self_0_0,\n-                    &__self_1_0) {\n-                ::core::option::Option::Some(::core::cmp::Ordering::Equal) =>\n-                    ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                cmp => cmp,\n-            }\n+        let Self(__self_0_0) = *self;\n+        let Self(__self_1_0) = *other;\n+        match ::core::cmp::PartialOrd::partial_cmp(&__self_0_0, &__self_1_0) {\n+            ::core::option::Option::Some(::core::cmp::Ordering::Equal) =>\n+                ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+            cmp => cmp,\n         }\n     }\n }\n@@ -504,13 +482,11 @@ impl ::core::cmp::PartialOrd for Packed {\n impl ::core::cmp::Ord for Packed {\n     #[inline]\n     fn cmp(&self, other: &Packed) -> ::core::cmp::Ordering {\n-        {\n-            let Self(__self_0_0) = *self;\n-            let Self(__self_1_0) = *other;\n-            match ::core::cmp::Ord::cmp(&__self_0_0, &__self_1_0) {\n-                ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,\n-                cmp => cmp,\n-            }\n+        let Self(__self_0_0) = *self;\n+        let Self(__self_1_0) = *other;\n+        match ::core::cmp::Ord::cmp(&__self_0_0, &__self_1_0) {\n+            ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,\n+            cmp => cmp,\n         }\n     }\n }\n@@ -521,7 +497,7 @@ enum Enum0 {}\n #[allow(unused_qualifications)]\n impl ::core::clone::Clone for Enum0 {\n     #[inline]\n-    fn clone(&self) -> Enum0 { { *self } }\n+    fn clone(&self) -> Enum0 { *self }\n }\n #[automatically_derived]\n #[allow(unused_qualifications)]\n@@ -556,7 +532,7 @@ impl ::core::cmp::Eq for Enum0 {\n     #[inline]\n     #[doc(hidden)]\n     #[no_coverage]\n-    fn assert_receiver_is_total_eq(&self) -> () { {} }\n+    fn assert_receiver_is_total_eq(&self) -> () {}\n }\n #[automatically_derived]\n #[allow(unused_qualifications)]\n@@ -642,7 +618,7 @@ impl ::core::cmp::Eq for Enum1 {\n     #[doc(hidden)]\n     #[no_coverage]\n     fn assert_receiver_is_total_eq(&self) -> () {\n-        { let _: ::core::cmp::AssertParamIsEq<u32>; }\n+        let _: ::core::cmp::AssertParamIsEq<u32>;\n     }\n }\n #[automatically_derived]\n@@ -693,7 +669,7 @@ enum Fieldless {\n #[allow(unused_qualifications)]\n impl ::core::clone::Clone for Fieldless {\n     #[inline]\n-    fn clone(&self) -> Fieldless { { *self } }\n+    fn clone(&self) -> Fieldless { *self }\n }\n #[automatically_derived]\n #[allow(unused_qualifications)]\n@@ -733,13 +709,11 @@ impl ::core::marker::StructuralPartialEq for Fieldless {}\n impl ::core::cmp::PartialEq for Fieldless {\n     #[inline]\n     fn eq(&self, other: &Fieldless) -> bool {\n-        {\n-            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if __self_vi == __arg_1_vi {\n-                    match (&*self, &*other) { _ => true, }\n-                } else { false }\n-        }\n+        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        if __self_vi == __arg_1_vi {\n+                match (&*self, &*other) { _ => true, }\n+            } else { false }\n     }\n }\n impl ::core::marker::StructuralEq for Fieldless {}\n@@ -749,43 +723,36 @@ impl ::core::cmp::Eq for Fieldless {\n     #[inline]\n     #[doc(hidden)]\n     #[no_coverage]\n-    fn assert_receiver_is_total_eq(&self) -> () { {} }\n+    fn assert_receiver_is_total_eq(&self) -> () {}\n }\n #[automatically_derived]\n #[allow(unused_qualifications)]\n impl ::core::cmp::PartialOrd for Fieldless {\n     #[inline]\n     fn partial_cmp(&self, other: &Fieldless)\n         -> ::core::option::Option<::core::cmp::Ordering> {\n-        {\n-            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if __self_vi == __arg_1_vi {\n-                    match (&*self, &*other) {\n-                        _ =>\n-                            ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                    }\n-                } else {\n-                   ::core::cmp::PartialOrd::partial_cmp(&__self_vi,\n-                       &__arg_1_vi)\n-               }\n-        }\n+        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        if __self_vi == __arg_1_vi {\n+                match (&*self, &*other) {\n+                    _ =>\n+                        ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                }\n+            } else {\n+               ::core::cmp::PartialOrd::partial_cmp(&__self_vi, &__arg_1_vi)\n+           }\n     }\n }\n #[automatically_derived]\n #[allow(unused_qualifications)]\n impl ::core::cmp::Ord for Fieldless {\n     #[inline]\n     fn cmp(&self, other: &Fieldless) -> ::core::cmp::Ordering {\n-        {\n-            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if __self_vi == __arg_1_vi {\n-                    match (&*self, &*other) {\n-                        _ => ::core::cmp::Ordering::Equal,\n-                    }\n-                } else { ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi) }\n-        }\n+        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        if __self_vi == __arg_1_vi {\n+                match (&*self, &*other) { _ => ::core::cmp::Ordering::Equal, }\n+            } else { ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi) }\n     }\n }\n \n@@ -806,12 +773,10 @@ enum Mixed {\n impl ::core::clone::Clone for Mixed {\n     #[inline]\n     fn clone(&self) -> Mixed {\n-        {\n-            let _: ::core::clone::AssertParamIsClone<u32>;\n-            let _: ::core::clone::AssertParamIsClone<u32>;\n-            let _: ::core::clone::AssertParamIsClone<u32>;\n-            *self\n-        }\n+        let _: ::core::clone::AssertParamIsClone<u32>;\n+        let _: ::core::clone::AssertParamIsClone<u32>;\n+        let _: ::core::clone::AssertParamIsClone<u32>;\n+        *self\n     }\n }\n #[automatically_derived]\n@@ -868,37 +833,33 @@ impl ::core::marker::StructuralPartialEq for Mixed {}\n impl ::core::cmp::PartialEq for Mixed {\n     #[inline]\n     fn eq(&self, other: &Mixed) -> bool {\n-        {\n-            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if __self_vi == __arg_1_vi {\n-                    match (&*self, &*other) {\n-                        (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n-                            *__self_0 == *__arg_1_0,\n-                        (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n-                            &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n-                            *__self_0 == *__arg_1_0 && *__self_1 == *__arg_1_1,\n-                        _ => true,\n-                    }\n-                } else { false }\n-        }\n+        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        if __self_vi == __arg_1_vi {\n+                match (&*self, &*other) {\n+                    (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n+                        *__self_0 == *__arg_1_0,\n+                    (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n+                        &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n+                        *__self_0 == *__arg_1_0 && *__self_1 == *__arg_1_1,\n+                    _ => true,\n+                }\n+            } else { false }\n     }\n     #[inline]\n     fn ne(&self, other: &Mixed) -> bool {\n-        {\n-            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if __self_vi == __arg_1_vi {\n-                    match (&*self, &*other) {\n-                        (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n-                            *__self_0 != *__arg_1_0,\n-                        (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n-                            &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n-                            *__self_0 != *__arg_1_0 || *__self_1 != *__arg_1_1,\n-                        _ => false,\n-                    }\n-                } else { true }\n-        }\n+        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        if __self_vi == __arg_1_vi {\n+                match (&*self, &*other) {\n+                    (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n+                        *__self_0 != *__arg_1_0,\n+                    (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n+                        &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n+                        *__self_0 != *__arg_1_0 || *__self_1 != *__arg_1_1,\n+                    _ => false,\n+                }\n+            } else { true }\n     }\n }\n impl ::core::marker::StructuralEq for Mixed {}\n@@ -909,11 +870,9 @@ impl ::core::cmp::Eq for Mixed {\n     #[doc(hidden)]\n     #[no_coverage]\n     fn assert_receiver_is_total_eq(&self) -> () {\n-        {\n-            let _: ::core::cmp::AssertParamIsEq<u32>;\n-            let _: ::core::cmp::AssertParamIsEq<u32>;\n-            let _: ::core::cmp::AssertParamIsEq<u32>;\n-        }\n+        let _: ::core::cmp::AssertParamIsEq<u32>;\n+        let _: ::core::cmp::AssertParamIsEq<u32>;\n+        let _: ::core::cmp::AssertParamIsEq<u32>;\n     }\n }\n #[automatically_derived]\n@@ -922,75 +881,70 @@ impl ::core::cmp::PartialOrd for Mixed {\n     #[inline]\n     fn partial_cmp(&self, other: &Mixed)\n         -> ::core::option::Option<::core::cmp::Ordering> {\n-        {\n-            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if __self_vi == __arg_1_vi {\n-                    match (&*self, &*other) {\n-                        (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n-                            match ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n-                                    &*__arg_1_0) {\n-                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n-                                    =>\n-                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                                cmp => cmp,\n-                            },\n-                        (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n-                            &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n-                            match ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n-                                    &*__arg_1_0) {\n-                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n-                                    =>\n-                                    match ::core::cmp::PartialOrd::partial_cmp(&*__self_1,\n-                                            &*__arg_1_1) {\n-                                        ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n-                                            =>\n-                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                                        cmp => cmp,\n-                                    },\n-                                cmp => cmp,\n-                            },\n-                        _ =>\n-                            ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                    }\n-                } else {\n-                   ::core::cmp::PartialOrd::partial_cmp(&__self_vi,\n-                       &__arg_1_vi)\n-               }\n-        }\n+        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        if __self_vi == __arg_1_vi {\n+                match (&*self, &*other) {\n+                    (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n+                        match ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n+                                &*__arg_1_0) {\n+                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                =>\n+                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                            cmp => cmp,\n+                        },\n+                    (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n+                        &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n+                        match ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n+                                &*__arg_1_0) {\n+                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                =>\n+                                match ::core::cmp::PartialOrd::partial_cmp(&*__self_1,\n+                                        &*__arg_1_1) {\n+                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                        =>\n+                                        ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                                    cmp => cmp,\n+                                },\n+                            cmp => cmp,\n+                        },\n+                    _ =>\n+                        ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                }\n+            } else {\n+               ::core::cmp::PartialOrd::partial_cmp(&__self_vi, &__arg_1_vi)\n+           }\n     }\n }\n #[automatically_derived]\n #[allow(unused_qualifications)]\n impl ::core::cmp::Ord for Mixed {\n     #[inline]\n     fn cmp(&self, other: &Mixed) -> ::core::cmp::Ordering {\n-        {\n-            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if __self_vi == __arg_1_vi {\n-                    match (&*self, &*other) {\n-                        (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n-                            match ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0) {\n-                                ::core::cmp::Ordering::Equal =>\n-                                    ::core::cmp::Ordering::Equal,\n-                                cmp => cmp,\n-                            },\n-                        (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n-                            &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n-                            match ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0) {\n-                                ::core::cmp::Ordering::Equal =>\n-                                    match ::core::cmp::Ord::cmp(&*__self_1, &*__arg_1_1) {\n-                                        ::core::cmp::Ordering::Equal =>\n-                                            ::core::cmp::Ordering::Equal,\n-                                        cmp => cmp,\n-                                    },\n-                                cmp => cmp,\n-                            },\n-                        _ => ::core::cmp::Ordering::Equal,\n-                    }\n-                } else { ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi) }\n-        }\n+        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        if __self_vi == __arg_1_vi {\n+                match (&*self, &*other) {\n+                    (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n+                        match ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0) {\n+                            ::core::cmp::Ordering::Equal =>\n+                                ::core::cmp::Ordering::Equal,\n+                            cmp => cmp,\n+                        },\n+                    (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n+                        &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n+                        match ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0) {\n+                            ::core::cmp::Ordering::Equal =>\n+                                match ::core::cmp::Ord::cmp(&*__self_1, &*__arg_1_1) {\n+                                    ::core::cmp::Ordering::Equal =>\n+                                        ::core::cmp::Ordering::Equal,\n+                                    cmp => cmp,\n+                                },\n+                            cmp => cmp,\n+                        },\n+                    _ => ::core::cmp::Ordering::Equal,\n+                }\n+            } else { ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi) }\n     }\n }\n \n@@ -1058,39 +1012,35 @@ impl ::core::marker::StructuralPartialEq for Fielded {}\n impl ::core::cmp::PartialEq for Fielded {\n     #[inline]\n     fn eq(&self, other: &Fielded) -> bool {\n-        {\n-            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if __self_vi == __arg_1_vi {\n-                    match (&*self, &*other) {\n-                        (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n-                            *__self_0 == *__arg_1_0,\n-                        (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n-                            *__self_0 == *__arg_1_0,\n-                        (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n-                            *__self_0 == *__arg_1_0,\n-                        _ => unsafe { ::core::intrinsics::unreachable() }\n-                    }\n-                } else { false }\n-        }\n+        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        if __self_vi == __arg_1_vi {\n+                match (&*self, &*other) {\n+                    (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n+                        *__self_0 == *__arg_1_0,\n+                    (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n+                        *__self_0 == *__arg_1_0,\n+                    (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n+                        *__self_0 == *__arg_1_0,\n+                    _ => unsafe { ::core::intrinsics::unreachable() }\n+                }\n+            } else { false }\n     }\n     #[inline]\n     fn ne(&self, other: &Fielded) -> bool {\n-        {\n-            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if __self_vi == __arg_1_vi {\n-                    match (&*self, &*other) {\n-                        (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n-                            *__self_0 != *__arg_1_0,\n-                        (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n-                            *__self_0 != *__arg_1_0,\n-                        (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n-                            *__self_0 != *__arg_1_0,\n-                        _ => unsafe { ::core::intrinsics::unreachable() }\n-                    }\n-                } else { true }\n-        }\n+        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        if __self_vi == __arg_1_vi {\n+                match (&*self, &*other) {\n+                    (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n+                        *__self_0 != *__arg_1_0,\n+                    (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n+                        *__self_0 != *__arg_1_0,\n+                    (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n+                        *__self_0 != *__arg_1_0,\n+                    _ => unsafe { ::core::intrinsics::unreachable() }\n+                }\n+            } else { true }\n     }\n }\n impl ::core::marker::StructuralEq for Fielded {}\n@@ -1101,11 +1051,9 @@ impl ::core::cmp::Eq for Fielded {\n     #[doc(hidden)]\n     #[no_coverage]\n     fn assert_receiver_is_total_eq(&self) -> () {\n-        {\n-            let _: ::core::cmp::AssertParamIsEq<u32>;\n-            let _: ::core::cmp::AssertParamIsEq<bool>;\n-            let _: ::core::cmp::AssertParamIsEq<Option<i32>>;\n-        }\n+        let _: ::core::cmp::AssertParamIsEq<u32>;\n+        let _: ::core::cmp::AssertParamIsEq<bool>;\n+        let _: ::core::cmp::AssertParamIsEq<Option<i32>>;\n     }\n }\n #[automatically_derived]\n@@ -1114,76 +1062,71 @@ impl ::core::cmp::PartialOrd for Fielded {\n     #[inline]\n     fn partial_cmp(&self, other: &Fielded)\n         -> ::core::option::Option<::core::cmp::Ordering> {\n-        {\n-            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if __self_vi == __arg_1_vi {\n-                    match (&*self, &*other) {\n-                        (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n-                            match ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n-                                    &*__arg_1_0) {\n-                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n-                                    =>\n-                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                                cmp => cmp,\n-                            },\n-                        (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n-                            match ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n-                                    &*__arg_1_0) {\n-                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n-                                    =>\n-                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                                cmp => cmp,\n-                            },\n-                        (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n-                            match ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n-                                    &*__arg_1_0) {\n-                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n-                                    =>\n-                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-                                cmp => cmp,\n-                            },\n-                        _ => unsafe { ::core::intrinsics::unreachable() }\n-                    }\n-                } else {\n-                   ::core::cmp::PartialOrd::partial_cmp(&__self_vi,\n-                       &__arg_1_vi)\n-               }\n-        }\n+        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        if __self_vi == __arg_1_vi {\n+                match (&*self, &*other) {\n+                    (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n+                        match ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n+                                &*__arg_1_0) {\n+                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                =>\n+                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                            cmp => cmp,\n+                        },\n+                    (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n+                        match ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n+                                &*__arg_1_0) {\n+                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                =>\n+                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                            cmp => cmp,\n+                        },\n+                    (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n+                        match ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n+                                &*__arg_1_0) {\n+                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                =>\n+                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                            cmp => cmp,\n+                        },\n+                    _ => unsafe { ::core::intrinsics::unreachable() }\n+                }\n+            } else {\n+               ::core::cmp::PartialOrd::partial_cmp(&__self_vi, &__arg_1_vi)\n+           }\n     }\n }\n #[automatically_derived]\n #[allow(unused_qualifications)]\n impl ::core::cmp::Ord for Fielded {\n     #[inline]\n     fn cmp(&self, other: &Fielded) -> ::core::cmp::Ordering {\n-        {\n-            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if __self_vi == __arg_1_vi {\n-                    match (&*self, &*other) {\n-                        (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n-                            match ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0) {\n-                                ::core::cmp::Ordering::Equal =>\n-                                    ::core::cmp::Ordering::Equal,\n-                                cmp => cmp,\n-                            },\n-                        (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n-                            match ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0) {\n-                                ::core::cmp::Ordering::Equal =>\n-                                    ::core::cmp::Ordering::Equal,\n-                                cmp => cmp,\n-                            },\n-                        (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n-                            match ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0) {\n-                                ::core::cmp::Ordering::Equal =>\n-                                    ::core::cmp::Ordering::Equal,\n-                                cmp => cmp,\n-                            },\n-                        _ => unsafe { ::core::intrinsics::unreachable() }\n-                    }\n-                } else { ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi) }\n-        }\n+        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        if __self_vi == __arg_1_vi {\n+                match (&*self, &*other) {\n+                    (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n+                        match ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0) {\n+                            ::core::cmp::Ordering::Equal =>\n+                                ::core::cmp::Ordering::Equal,\n+                            cmp => cmp,\n+                        },\n+                    (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n+                        match ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0) {\n+                            ::core::cmp::Ordering::Equal =>\n+                                ::core::cmp::Ordering::Equal,\n+                            cmp => cmp,\n+                        },\n+                    (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n+                        match ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0) {\n+                            ::core::cmp::Ordering::Equal =>\n+                                ::core::cmp::Ordering::Equal,\n+                            cmp => cmp,\n+                        },\n+                    _ => unsafe { ::core::intrinsics::unreachable() }\n+                }\n+            } else { ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi) }\n     }\n }\n \n@@ -1198,7 +1141,8 @@ pub union Union {\n impl ::core::clone::Clone for Union {\n     #[inline]\n     fn clone(&self) -> Union {\n-        { let _: ::core::clone::AssertParamIsCopy<Self>; *self }\n+        let _: ::core::clone::AssertParamIsCopy<Self>;\n+        *self\n     }\n }\n #[automatically_derived]"}]}