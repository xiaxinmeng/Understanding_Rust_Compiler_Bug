{"sha": "3f3fc52bfa255e68d84ca40a497137f5c6bae4a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmM2ZjNTJiZmEyNTVlNjhkODRjYTQwYTQ5NzEzN2Y1YzZiYWU0YTg=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-09-05T14:05:58Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-09-05T21:48:03Z"}, "message": "Simplify std lib injection", "tree": {"sha": "78f2bf2042fd12712d9be62d5c51b9c285fc9846", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78f2bf2042fd12712d9be62d5c51b9c285fc9846"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f3fc52bfa255e68d84ca40a497137f5c6bae4a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f3fc52bfa255e68d84ca40a497137f5c6bae4a8", "html_url": "https://github.com/rust-lang/rust/commit/3f3fc52bfa255e68d84ca40a497137f5c6bae4a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f3fc52bfa255e68d84ca40a497137f5c6bae4a8/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e552840e79330f8a1f36fc676b71fa38b3123a50", "url": "https://api.github.com/repos/rust-lang/rust/commits/e552840e79330f8a1f36fc676b71fa38b3123a50", "html_url": "https://github.com/rust-lang/rust/commit/e552840e79330f8a1f36fc676b71fa38b3123a50"}], "stats": {"total": 178, "additions": 52, "deletions": 126}, "files": [{"sha": "48c3ddf39a22b15cb6abba162a74751a1fccdb04", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f3fc52bfa255e68d84ca40a497137f5c6bae4a8/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f3fc52bfa255e68d84ca40a497137f5c6bae4a8/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=3f3fc52bfa255e68d84ca40a497137f5c6bae4a8", "patch": "@@ -366,8 +366,8 @@ fn configure_and_expand_inner<'a>(\n         let (krate, name) = syntax_ext::standard_library_imports::inject(\n             krate,\n             &mut resolver,\n+            &sess.parse_sess,\n             alt_std_name,\n-            sess.edition(),\n         );\n         if let Some(name) = name {\n             sess.parse_sess.injected_crate_name.set(name);"}, {"sha": "c479912b4ef814949d839341736555384865445f", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f3fc52bfa255e68d84ca40a497137f5c6bae4a8/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f3fc52bfa255e68d84ca40a497137f5c6bae4a8/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=3f3fc52bfa255e68d84ca40a497137f5c6bae4a8", "patch": "@@ -604,6 +604,14 @@ impl<'a> Resolver<'a> {\n         if lookup_ident.span.rust_2018() {\n             let extern_prelude_names = self.extern_prelude.clone();\n             for (ident, _) in extern_prelude_names.into_iter() {\n+                if ident.span.from_expansion() {\n+                    // Idents are adjusted to the root context before being\n+                    // resolved in the extern prelude, so reporting this to the\n+                    // user is no help. This skips the injected\n+                    // `extern crate std` in the 2018 edition, which would\n+                    // otherwise cause duplicate suggestions.\n+                    continue;\n+                }\n                 if let Some(crate_id) = self.crate_loader.maybe_process_path_extern(ident.name,\n                                                                                     ident.span) {\n                     let crate_root = self.get_module(DefId {"}, {"sha": "cf99663beaf4810ae1d5f6f5909507cef8baf7a2", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3f3fc52bfa255e68d84ca40a497137f5c6bae4a8/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f3fc52bfa255e68d84ca40a497137f5c6bae4a8/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=3f3fc52bfa255e68d84ca40a497137f5c6bae4a8", "patch": "@@ -128,9 +128,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n         }\n     }\n \n-    // Create a Span with modern hygiene with a definition site of the provided\n-    // module, or a fake empty `#[no_implicit_prelude]` module if no module is\n-    // provided.\n+    // Create a new Expansion with a definition site of the provided module, or\n+    // a fake empty `#[no_implicit_prelude]` module if no module is provided.\n     fn expansion_for_ast_pass(\n         &mut self,\n         call_site: Span,"}, {"sha": "ca189e71800b36a4a9d7f59296d024e64c6ebb00", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f3fc52bfa255e68d84ca40a497137f5c6bae4a8/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f3fc52bfa255e68d84ca40a497137f5c6bae4a8/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=3f3fc52bfa255e68d84ca40a497137f5c6bae4a8", "patch": "@@ -1307,8 +1307,11 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 None => continue,\n             };\n \n-            // Filter away ambiguous imports.\n-            let is_good_import = binding.is_import() && !binding.is_ambiguity();\n+            // Filter away ambiguous imports and anything that has def-site\n+            // hygiene.\n+            // FIXME: Implement actual cross-crate hygiene.\n+            let is_good_import = binding.is_import() && !binding.is_ambiguity()\n+                && !ident.span.modern().from_expansion();\n             if is_good_import || binding.is_macro_def() {\n                 let res = binding.res();\n                 if res != Res::Err {"}, {"sha": "31d32d23a645ebd3b1a7109b0d0226323f7de770", "filename": "src/libsyntax_ext/proc_macro_harness.rs", "status": "modified", "additions": 5, "deletions": 27, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3f3fc52bfa255e68d84ca40a497137f5c6bae4a8/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f3fc52bfa255e68d84ca40a497137f5c6bae4a8/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_harness.rs?ref=3f3fc52bfa255e68d84ca40a497137f5c6bae4a8", "patch": "@@ -392,41 +392,19 @@ fn mk_decls(\n         i\n     });\n \n-    let block = P(ast::Expr {\n-        id: ast::DUMMY_NODE_ID,\n-        attrs: syntax::ThinVec::new(),\n-        node: ast::ExprKind::Block(P(ast::Block {\n-            id: ast::DUMMY_NODE_ID,\n-            rules: ast::BlockCheckMode::Default,\n-            stmts: vec![\n-                ast::Stmt {\n-                    id: ast::DUMMY_NODE_ID,\n-                    node: ast::StmtKind::Item(krate),\n-                    span,\n-                },\n-                ast::Stmt {\n-                    id: ast::DUMMY_NODE_ID,\n-                    node: ast::StmtKind::Item(decls_static),\n-                    span,\n-                }\n-            ],\n-            span,\n-        }), None),\n+    let block = cx.expr_block(cx.block(\n         span,\n-    });\n+        vec![cx.stmt_item(span, krate), cx.stmt_item(span, decls_static)],\n+    ));\n \n     let anon_constant = cx.item_const(\n         span,\n         ast::Ident::new(kw::Underscore, span),\n-        P(ast::Ty {\n-            id: ast::DUMMY_NODE_ID,\n-            node: ast::TyKind::Tup(Vec::new()),\n-            span,\n-        }),\n+        cx.ty(span, ast::TyKind::Tup(Vec::new())),\n         block,\n     );\n \n-    // Integrate the new module into existing module structures.\n+    // Integrate the new item into existing module structures.\n     let items = AstFragment::Items(smallvec![anon_constant]);\n     cx.monotonic_expander().fully_expand_fragment(items).make_items().pop().unwrap()\n }"}, {"sha": "c577b1e33cfebab0f18d8fc90d33d569bcaa051f", "filename": "src/libsyntax_ext/standard_library_imports.rs", "status": "modified", "additions": 31, "deletions": 93, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/3f3fc52bfa255e68d84ca40a497137f5c6bae4a8/src%2Flibsyntax_ext%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f3fc52bfa255e68d84ca40a497137f5c6bae4a8/src%2Flibsyntax_ext%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fstandard_library_imports.rs?ref=3f3fc52bfa255e68d84ca40a497137f5c6bae4a8", "patch": "@@ -1,19 +1,20 @@\n use syntax::{ast, attr};\n use syntax::edition::Edition;\n+use syntax::ext::expand::ExpansionConfig;\n use syntax::ext::hygiene::AstPass;\n-use syntax::ext::base::Resolver;\n+use syntax::ext::base::{ExtCtxt, Resolver};\n+use syntax::parse::ParseSess;\n use syntax::ptr::P;\n-use syntax::source_map::respan;\n use syntax::symbol::{Ident, Symbol, kw, sym};\n use syntax_pos::DUMMY_SP;\n \n pub fn inject(\n     mut krate: ast::Crate,\n     resolver: &mut dyn Resolver,\n+    sess: &ParseSess,\n     alt_std_name: Option<Symbol>,\n-    edition: Edition,\n ) -> (ast::Crate, Option<Symbol>) {\n-    let rust_2018 = edition >= Edition::Edition2018;\n+    let rust_2018 = sess.edition >= Edition::Edition2018;\n \n     // the first name in this list is the crate name of the crate with the prelude\n     let names: &[Symbol] = if attr::contains_name(&krate.attrs, sym::no_core) {\n@@ -37,112 +38,49 @@ pub fn inject(\n     let span = DUMMY_SP.with_def_site_ctxt(expn_id);\n     let call_site = DUMMY_SP.with_call_site_ctxt(expn_id);\n \n+    let ecfg = ExpansionConfig::default(\"std_lib_injection\".to_string());\n+    let cx = ExtCtxt::new(sess, ecfg, resolver);\n+\n+\n     // .rev() to preserve ordering above in combination with insert(0, ...)\n-    for &orig_name_sym in names.iter().rev() {\n-        let (rename, orig_name) = if rust_2018 {\n-            (Ident::new(kw::Underscore, span), Some(orig_name_sym))\n+    for &name in names.iter().rev() {\n+        let ident = if rust_2018 {\n+            Ident::new(name, span)\n         } else {\n-            (Ident::new(orig_name_sym, call_site), None)\n+            Ident::new(name, call_site)\n         };\n-        krate.module.items.insert(0, P(ast::Item {\n-            attrs: vec![attr::mk_attr_outer(\n-                attr::mk_word_item(ast::Ident::new(sym::macro_use, span))\n-            )],\n-            vis: respan(span, ast::VisibilityKind::Inherited),\n-            node: ast::ItemKind::ExternCrate(alt_std_name.or(orig_name)),\n-            ident: rename,\n-            id: ast::DUMMY_NODE_ID,\n+        krate.module.items.insert(0, cx.item(\n             span,\n-            tokens: None,\n-        }));\n+            ident,\n+            vec![cx.attribute(cx.meta_word(span, sym::macro_use))],\n+            ast::ItemKind::ExternCrate(alt_std_name),\n+        ));\n     }\n \n-    // the crates have been injected, the assumption is that the first one is the one with\n-    // the prelude.\n+    // The crates have been injected, the assumption is that the first one is\n+    // the one with the prelude.\n     let name = names[0];\n \n-    let segments = if rust_2018 {\n+    let import_path = if rust_2018 {\n         [name, sym::prelude, sym::v1].iter()\n-            .map(|symbol| ast::PathSegment::from_ident(ast::Ident::new(*symbol, span)))\n-            .collect()\n+            .map(|symbol| ast::Ident::new(*symbol, span)).collect()\n     } else {\n         [kw::PathRoot, name, sym::prelude, sym::v1].iter()\n-            .map(|symbol| ast::PathSegment::from_ident(ast::Ident::new(*symbol, call_site)))\n-            .collect()\n+            .map(|symbol| ast::Ident::new(*symbol, span)).collect()\n     };\n \n-    let use_item = P(ast::Item {\n-        attrs: vec![attr::mk_attr_outer(\n-            attr::mk_word_item(ast::Ident::new(sym::prelude_import, span)))],\n-        vis: respan(span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n-        node: ast::ItemKind::Use(P(ast::UseTree {\n-            prefix: ast::Path { segments, span },\n+    let use_item = cx.item(\n+        span,\n+        ast::Ident::invalid(),\n+        vec![cx.attribute(cx.meta_word(span, sym::prelude_import))],\n+        ast::ItemKind::Use(P(ast::UseTree {\n+            prefix: cx.path(span, import_path),\n             kind: ast::UseTreeKind::Glob,\n             span,\n         })),\n-        id: ast::DUMMY_NODE_ID,\n-        ident: ast::Ident::invalid(),\n-        span,\n-        tokens: None,\n-    });\n-\n-    let prelude_import_item = if rust_2018 {\n-        let hygienic_extern_crate = P(ast::Item {\n-            attrs: vec![],\n-            vis: respan(span, ast::VisibilityKind::Inherited),\n-            node: ast::ItemKind::ExternCrate(alt_std_name),\n-            ident: ast::Ident::new(name, span),\n-            id: ast::DUMMY_NODE_ID,\n-            span,\n-            tokens: None,\n-        });\n-\n-        // Use an anonymous const to hide `extern crate std as hygienic_std`\n-        // FIXME: Once inter-crate hygiene exists, this can just be `use_item`.\n-        P(ast::Item {\n-            attrs: Vec::new(),\n-            vis: respan(span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n-            node: ast::ItemKind::Const(\n-                P(ast::Ty {\n-                    id: ast::DUMMY_NODE_ID,\n-                    node: ast::TyKind::Tup(Vec::new()),\n-                    span,\n-                }),\n-                P(ast::Expr {\n-                    id: ast::DUMMY_NODE_ID,\n-                    attrs: syntax::ThinVec::new(),\n-                    node: ast::ExprKind::Block(P(ast::Block {\n-                        id: ast::DUMMY_NODE_ID,\n-                        rules: ast::BlockCheckMode::Default,\n-                        stmts: vec![\n-                            ast::Stmt {\n-                                id: ast::DUMMY_NODE_ID,\n-                                node: ast::StmtKind::Item(use_item),\n-                                span,\n-                            },\n-                            ast::Stmt {\n-                                id: ast::DUMMY_NODE_ID,\n-                                node: ast::StmtKind::Item(hygienic_extern_crate),\n-                                span,\n-                            }\n-                        ],\n-                        span,\n-                    }), None),\n-                    span,\n-                })\n-            ),\n-            id: ast::DUMMY_NODE_ID,\n-            ident: ast::Ident::new(kw::Underscore, span),\n-            span,\n-            tokens: None,\n-        })\n-    } else {\n-        // Have `extern crate std` at the root, so don't need to create a named\n-        // extern crate item.\n-        use_item\n-    };\n+    );\n \n-    krate.module.items.insert(0, prelude_import_item);\n+    krate.module.items.insert(0, use_item);\n \n     (krate, Some(name))\n }"}]}