{"sha": "5c029265465301fe9cb3960ce2a5da6c99b8dcf2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjMDI5MjY1NDY1MzAxZmU5Y2IzOTYwY2UyYTVkYTZjOTliOGRjZjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-11T19:36:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-11T19:36:54Z"}, "message": "Auto merge of #84904 - ssomers:btree_drop_kv_in_place, r=Mark-Simulacrum\n\nBTree: no longer copy keys and values before dropping them\n\nWhen dropping BTreeMap or BTreeSet instances, keys-value pairs are up to now each copied and then dropped, at least according to source code. This is because the code for dropping and for iterators is shared.\n\nThis PR postpones the treatment of doomed key-value pairs from the intermediate functions `deallocating_next`(`_back`) to the last minute, so the we can drop the keys and values in place. According to the library/alloc benchmarks, this does make a difference, (and a positive difference with an `#[inline]` on `drop_key_val`). It does not change anything for #81444 though.\n\nr? `@Mark-Simulacrum`", "tree": {"sha": "71a8a2d6ea621adaed0eaaa8e21231eeeebd40c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71a8a2d6ea621adaed0eaaa8e21231eeeebd40c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c029265465301fe9cb3960ce2a5da6c99b8dcf2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c029265465301fe9cb3960ce2a5da6c99b8dcf2", "html_url": "https://github.com/rust-lang/rust/commit/5c029265465301fe9cb3960ce2a5da6c99b8dcf2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c029265465301fe9cb3960ce2a5da6c99b8dcf2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba8d7e2cb7cfc87070585c17cd0aa4ae7f091a08", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba8d7e2cb7cfc87070585c17cd0aa4ae7f091a08", "html_url": "https://github.com/rust-lang/rust/commit/ba8d7e2cb7cfc87070585c17cd0aa4ae7f091a08"}, {"sha": "728204b40efe11ecc866387924a57c684786e2b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/728204b40efe11ecc866387924a57c684786e2b9", "html_url": "https://github.com/rust-lang/rust/commit/728204b40efe11ecc866387924a57c684786e2b9"}], "stats": {"total": 140, "additions": 95, "deletions": 45}, "files": [{"sha": "30194aa446f4b43f089c8e61a443f5adc0d68f68", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5c029265465301fe9cb3960ce2a5da6c99b8dcf2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c029265465301fe9cb3960ce2a5da6c99b8dcf2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=5c029265465301fe9cb3960ce2a5da6c99b8dcf2", "patch": "@@ -1439,7 +1439,10 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n impl<K, V> Drop for Dropper<K, V> {\n     fn drop(&mut self) {\n         // Similar to advancing a non-fusing iterator.\n-        fn next_or_end<K, V>(this: &mut Dropper<K, V>) -> Option<(K, V)> {\n+        fn next_or_end<K, V>(\n+            this: &mut Dropper<K, V>,\n+        ) -> Option<Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV>>\n+        {\n             if this.remaining_length == 0 {\n                 unsafe { ptr::read(&this.front).deallocating_end() }\n                 None\n@@ -1455,13 +1458,15 @@ impl<K, V> Drop for Dropper<K, V> {\n             fn drop(&mut self) {\n                 // Continue the same loop we perform below. This only runs when unwinding, so we\n                 // don't have to care about panics this time (they'll abort).\n-                while let Some(_pair) = next_or_end(&mut self.0) {}\n+                while let Some(kv) = next_or_end(&mut self.0) {\n+                    kv.drop_key_val();\n+                }\n             }\n         }\n \n-        while let Some(pair) = next_or_end(self) {\n+        while let Some(kv) = next_or_end(self) {\n             let guard = DropGuard(self);\n-            drop(pair);\n+            kv.drop_key_val();\n             mem::forget(guard);\n         }\n     }\n@@ -1485,7 +1490,9 @@ impl<K, V> Iterator for IntoIter<K, V> {\n             None\n         } else {\n             self.length -= 1;\n-            Some(unsafe { self.range.front.as_mut().unwrap().deallocating_next_unchecked() })\n+            let front = self.range.front.as_mut().unwrap();\n+            let kv = unsafe { front.deallocating_next_unchecked() };\n+            Some(kv.into_key_val())\n         }\n     }\n \n@@ -1501,7 +1508,9 @@ impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n             None\n         } else {\n             self.length -= 1;\n-            Some(unsafe { self.range.back.as_mut().unwrap().deallocating_next_back_unchecked() })\n+            let back = self.range.back.as_mut().unwrap();\n+            let kv = unsafe { back.deallocating_next_back_unchecked() };\n+            Some(kv.into_key_val())\n         }\n     }\n }"}, {"sha": "563c070dd0f1f81cc0c38b72bbc6a3fdcbfc2cc7", "filename": "library/alloc/src/collections/btree/navigate.rs", "status": "modified", "additions": 44, "deletions": 36, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/5c029265465301fe9cb3960ce2a5da6c99b8dcf2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c029265465301fe9cb3960ce2a5da6c99b8dcf2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=5c029265465301fe9cb3960ce2a5da6c99b8dcf2", "patch": "@@ -237,25 +237,27 @@ impl<BorrowType: marker::BorrowType, K, V>\n \n impl<K, V> Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge> {\n     /// Given a leaf edge handle into a dying tree, returns the next leaf edge\n-    /// on the right side, and the key-value pair in between, which is either\n-    /// in the same leaf node, in an ancestor node, or non-existent.\n+    /// on the right side, and the key-value pair in between, if they exist.\n     ///\n-    /// This method also deallocates any node(s) it reaches the end of. This\n-    /// implies that if no more key-value pair exists, the entire remainder of\n-    /// the tree will have been deallocated and there is nothing left to return.\n+    /// If the given edge is the last one in a leaf, this method deallocates\n+    /// the leaf, as well as any ancestor nodes whose last edge was reached.\n+    /// This implies that if no more key-value pair follows, the entire tree\n+    /// will have been deallocated and there is nothing left to return.\n     ///\n     /// # Safety\n-    /// The given edge must not have been previously returned by counterpart\n-    /// `deallocating_next_back`.\n-    unsafe fn deallocating_next(self) -> Option<(Self, (K, V))> {\n+    /// - The given edge must not have been previously returned by counterpart\n+    ///   `deallocating_next_back`.\n+    /// - The returned KV handle is only valid to access the key and value,\n+    ///   and only valid until the next call to this method or counterpart\n+    ///   `deallocating_next_back`.\n+    pub unsafe fn deallocating_next(\n+        self,\n+    ) -> Option<(Self, Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV>)>\n+    {\n         let mut edge = self.forget_node_type();\n         loop {\n             edge = match edge.right_kv() {\n-                Ok(kv) => {\n-                    let k = unsafe { ptr::read(kv.reborrow().into_kv().0) };\n-                    let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n-                    return Some((kv.next_leaf_edge(), (k, v)));\n-                }\n+                Ok(kv) => return Some((unsafe { ptr::read(&kv) }.next_leaf_edge(), kv)),\n                 Err(last_edge) => match unsafe { last_edge.into_node().deallocate_and_ascend() } {\n                     Some(parent_edge) => parent_edge.forget_node_type(),\n                     None => return None,\n@@ -265,25 +267,27 @@ impl<K, V> Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge> {\n     }\n \n     /// Given a leaf edge handle into a dying tree, returns the next leaf edge\n-    /// on the left side, and the key-value pair in between, which is either\n-    /// in the same leaf node, in an ancestor node, or non-existent.\n+    /// on the left side, and the key-value pair in between, if they exist.\n     ///\n-    /// This method also deallocates any node(s) it reaches the end of. This\n-    /// implies that if no more key-value pair exists, the entire remainder of\n-    /// the tree will have been deallocated and there is nothing left to return.\n+    /// If the given edge is the first one in a leaf, this method deallocates\n+    /// the leaf, as well as any ancestor nodes whose first edge was reached.\n+    /// This implies that if no more key-value pair follows, the entire tree\n+    /// will have been deallocated and there is nothing left to return.\n     ///\n     /// # Safety\n-    /// The given edge must not have been previously returned by counterpart\n-    /// `deallocating_next`.\n-    unsafe fn deallocating_next_back(self) -> Option<(Self, (K, V))> {\n+    /// - The given edge must not have been previously returned by counterpart\n+    ///   `deallocating_next`.\n+    /// - The returned KV handle is only valid to access the key and value,\n+    ///   and only valid until the next call to this method or counterpart\n+    ///   `deallocating_next`.\n+    unsafe fn deallocating_next_back(\n+        self,\n+    ) -> Option<(Self, Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV>)>\n+    {\n         let mut edge = self.forget_node_type();\n         loop {\n             edge = match edge.left_kv() {\n-                Ok(kv) => {\n-                    let k = unsafe { ptr::read(kv.reborrow().into_kv().0) };\n-                    let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n-                    return Some((kv.next_back_leaf_edge(), (k, v)));\n-                }\n+                Ok(kv) => return Some((unsafe { ptr::read(&kv) }.next_back_leaf_edge(), kv)),\n                 Err(last_edge) => match unsafe { last_edge.into_node().deallocate_and_ascend() } {\n                     Some(parent_edge) => parent_edge.forget_node_type(),\n                     None => return None,\n@@ -373,13 +377,15 @@ impl<K, V> Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge> {\n     ///\n     /// # Safety\n     /// - There must be another KV in the direction travelled.\n-    /// - That KV was not previously returned by counterpart `next_back_unchecked`\n-    ///   on any copy of the handles being used to traverse the tree.\n+    /// - That KV was not previously returned by counterpart\n+    ///   `deallocating_next_back_unchecked` on any copy of the handles\n+    ///   being used to traverse the tree.\n     ///\n     /// The only safe way to proceed with the updated handle is to compare it, drop it,\n-    /// call this method again subject to its safety conditions, or call counterpart\n-    /// `next_back_unchecked` subject to its safety conditions.\n-    pub unsafe fn deallocating_next_unchecked(&mut self) -> (K, V) {\n+    /// or call this method or counterpart `deallocating_next_back_unchecked` again.\n+    pub unsafe fn deallocating_next_unchecked(\n+        &mut self,\n+    ) -> Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV> {\n         super::mem::replace(self, |leaf_edge| unsafe {\n             leaf_edge.deallocating_next().unwrap_unchecked()\n         })\n@@ -391,13 +397,15 @@ impl<K, V> Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge> {\n     ///\n     /// # Safety\n     /// - There must be another KV in the direction travelled.\n-    /// - That leaf edge was not previously returned by counterpart `next_unchecked`\n-    ///   on any copy of the handles being used to traverse the tree.\n+    /// - That leaf edge was not previously returned by counterpart\n+    ///   `deallocating_next_unchecked` on any copy of the handles\n+    ///   being used to traverse the tree.\n     ///\n     /// The only safe way to proceed with the updated handle is to compare it, drop it,\n-    /// call this method again subject to its safety conditions, or call counterpart\n-    /// `next_unchecked` subject to its safety conditions.\n-    pub unsafe fn deallocating_next_back_unchecked(&mut self) -> (K, V) {\n+    /// or call this method or counterpart `deallocating_next_unchecked` again.\n+    pub unsafe fn deallocating_next_back_unchecked(\n+        &mut self,\n+    ) -> Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV> {\n         super::mem::replace(self, |leaf_edge| unsafe {\n             leaf_edge.deallocating_next_back().unwrap_unchecked()\n         })"}, {"sha": "3c453529ba84d3d93794c7da6602c9289955d3ec", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5c029265465301fe9cb3960ce2a5da6c99b8dcf2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c029265465301fe9cb3960ce2a5da6c99b8dcf2/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=5c029265465301fe9cb3960ce2a5da6c99b8dcf2", "patch": "@@ -422,21 +422,30 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n     }\n \n-    /// Borrows exclusive access to the leaf portion of any leaf or internal node.\n+    /// Borrows exclusive access to the leaf portion of a leaf or internal node.\n     fn as_leaf_mut(&mut self) -> &mut LeafNode<K, V> {\n         let ptr = Self::as_leaf_ptr(self);\n         // SAFETY: we have exclusive access to the entire node.\n         unsafe { &mut *ptr }\n     }\n \n-    /// Offers exclusive access to the leaf portion of any leaf or internal node.\n+    /// Offers exclusive access to the leaf portion of a leaf or internal node.\n     fn into_leaf_mut(mut self) -> &'a mut LeafNode<K, V> {\n         let ptr = Self::as_leaf_ptr(&mut self);\n         // SAFETY: we have exclusive access to the entire node.\n         unsafe { &mut *ptr }\n     }\n }\n \n+impl<K, V, Type> NodeRef<marker::Dying, K, V, Type> {\n+    /// Borrows exclusive access to the leaf portion of a dying leaf or internal node.\n+    fn as_leaf_dying(&mut self) -> &mut LeafNode<K, V> {\n+        let ptr = Self::as_leaf_ptr(self);\n+        // SAFETY: we have exclusive access to the entire node.\n+        unsafe { &mut *ptr }\n+    }\n+}\n+\n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     /// Borrows exclusive access to an element of the key storage area.\n     ///\n@@ -1040,13 +1049,37 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>\n         }\n     }\n \n-    /// Replace the key and value that the KV handle refers to.\n+    /// Replaces the key and value that the KV handle refers to.\n     pub fn replace_kv(&mut self, k: K, v: V) -> (K, V) {\n         let (key, val) = self.kv_mut();\n         (mem::replace(key, k), mem::replace(val, v))\n     }\n }\n \n+impl<K, V, NodeType> Handle<NodeRef<marker::Dying, K, V, NodeType>, marker::KV> {\n+    /// Extracts the key and value that the KV handle refers to.\n+    pub fn into_key_val(mut self) -> (K, V) {\n+        debug_assert!(self.idx < self.node.len());\n+        let leaf = self.node.as_leaf_dying();\n+        unsafe {\n+            let key = leaf.keys.get_unchecked_mut(self.idx).assume_init_read();\n+            let val = leaf.vals.get_unchecked_mut(self.idx).assume_init_read();\n+            (key, val)\n+        }\n+    }\n+\n+    /// Drops the key and value that the KV handle refers to.\n+    #[inline]\n+    pub fn drop_key_val(mut self) {\n+        debug_assert!(self.idx < self.node.len());\n+        let leaf = self.node.as_leaf_dying();\n+        unsafe {\n+            leaf.keys.get_unchecked_mut(self.idx).assume_init_drop();\n+            leaf.vals.get_unchecked_mut(self.idx).assume_init_drop();\n+        }\n+    }\n+}\n+\n impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n     /// Helps implementations of `split` for a particular `NodeType`,\n     /// by taking care of leaf data."}]}