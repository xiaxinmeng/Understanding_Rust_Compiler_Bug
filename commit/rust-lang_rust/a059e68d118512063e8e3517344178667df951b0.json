{"sha": "a059e68d118512063e8e3517344178667df951b0", "node_id": "C_kwDOAAsO6NoAKGEwNTllNjhkMTE4NTEyMDYzZThlMzUxNzM0NDE3ODY2N2RmOTUxYjA", "commit": {"author": {"name": "Jamie Cunliffe", "email": "Jamie.Cunliffe@arm.com", "date": "2023-05-22T13:46:40Z"}, "committer": {"name": "Jamie Cunliffe", "email": "Jamie.Cunliffe@arm.com", "date": "2023-05-22T13:46:40Z"}, "message": "Create a structure to define the features from to_llvm_features.\n\nRather than returning an array of features from to_llvm_features, return a structure that contains\nthe dependencies. This also contains metadata on how the features depend on each other to allow for\nthe correct enabling and disabling.", "tree": {"sha": "2ac58edacfffa829bf81e1710ac4ba7e49fe7860", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ac58edacfffa829bf81e1710ac4ba7e49fe7860"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a059e68d118512063e8e3517344178667df951b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a059e68d118512063e8e3517344178667df951b0", "html_url": "https://github.com/rust-lang/rust/commit/a059e68d118512063e8e3517344178667df951b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a059e68d118512063e8e3517344178667df951b0/comments", "author": {"login": "JamieCunliffe", "id": 29557119, "node_id": "MDQ6VXNlcjI5NTU3MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/29557119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JamieCunliffe", "html_url": "https://github.com/JamieCunliffe", "followers_url": "https://api.github.com/users/JamieCunliffe/followers", "following_url": "https://api.github.com/users/JamieCunliffe/following{/other_user}", "gists_url": "https://api.github.com/users/JamieCunliffe/gists{/gist_id}", "starred_url": "https://api.github.com/users/JamieCunliffe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JamieCunliffe/subscriptions", "organizations_url": "https://api.github.com/users/JamieCunliffe/orgs", "repos_url": "https://api.github.com/users/JamieCunliffe/repos", "events_url": "https://api.github.com/users/JamieCunliffe/events{/privacy}", "received_events_url": "https://api.github.com/users/JamieCunliffe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JamieCunliffe", "id": 29557119, "node_id": "MDQ6VXNlcjI5NTU3MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/29557119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JamieCunliffe", "html_url": "https://github.com/JamieCunliffe", "followers_url": "https://api.github.com/users/JamieCunliffe/followers", "following_url": "https://api.github.com/users/JamieCunliffe/following{/other_user}", "gists_url": "https://api.github.com/users/JamieCunliffe/gists{/gist_id}", "starred_url": "https://api.github.com/users/JamieCunliffe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JamieCunliffe/subscriptions", "organizations_url": "https://api.github.com/users/JamieCunliffe/orgs", "repos_url": "https://api.github.com/users/JamieCunliffe/repos", "events_url": "https://api.github.com/users/JamieCunliffe/events{/privacy}", "received_events_url": "https://api.github.com/users/JamieCunliffe/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d51db4275b5271b0349b3d6f21e5eea2d0ee62fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/d51db4275b5271b0349b3d6f21e5eea2d0ee62fc", "html_url": "https://github.com/rust-lang/rust/commit/d51db4275b5271b0349b3d6f21e5eea2d0ee62fc"}], "stats": {"total": 203, "additions": 133, "deletions": 70}, "files": [{"sha": "805843e5863e641de8cd1b315c801ad1dd601c48", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a059e68d118512063e8e3517344178667df951b0/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a059e68d118512063e8e3517344178667df951b0/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=a059e68d118512063e8e3517344178667df951b0", "patch": "@@ -10,6 +10,7 @@\n #![feature(iter_intersperse)]\n #![feature(let_chains)]\n #![feature(never_type)]\n+#![feature(impl_trait_in_assoc_type)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n #![deny(rustc::untranslatable_diagnostic)]"}, {"sha": "03be0654b50bbb94c577ed36e86c596db7d864e3", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 127, "deletions": 65, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/a059e68d118512063e8e3517344178667df951b0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a059e68d118512063e8e3517344178667df951b0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=a059e68d118512063e8e3517344178667df951b0", "patch": "@@ -16,7 +16,6 @@ use rustc_session::config::PrintRequest;\n use rustc_session::Session;\n use rustc_span::symbol::Symbol;\n use rustc_target::spec::{MergeFunctions, PanicStrategy};\n-use smallvec::{smallvec, SmallVec};\n use std::ffi::{CStr, CString};\n \n use std::path::Path;\n@@ -132,6 +131,60 @@ pub fn time_trace_profiler_finish(file_name: &Path) {\n     }\n }\n \n+pub enum TargetFeatureFoldStrength<'a> {\n+    // The feature is only tied when enabling the feature, disabling\n+    // this feature shouldn't disable the tied feature.\n+    EnableOnly(&'a str),\n+    // The feature is tied for both enabling and disabling this feature.\n+    Both(&'a str),\n+}\n+\n+impl<'a> TargetFeatureFoldStrength<'a> {\n+    fn as_str(&self) -> &'a str {\n+        match self {\n+            TargetFeatureFoldStrength::EnableOnly(feat) => feat,\n+            TargetFeatureFoldStrength::Both(feat) => feat,\n+        }\n+    }\n+}\n+\n+pub struct LLVMFeature<'a> {\n+    pub llvm_feature_name: &'a str,\n+    pub dependency: Option<TargetFeatureFoldStrength<'a>>,\n+}\n+\n+impl<'a> LLVMFeature<'a> {\n+    pub fn new(llvm_feature_name: &'a str) -> Self {\n+        Self { llvm_feature_name, dependency: None }\n+    }\n+\n+    pub fn with_dependency(\n+        llvm_feature_name: &'a str,\n+        dependency: TargetFeatureFoldStrength<'a>,\n+    ) -> Self {\n+        Self { llvm_feature_name, dependency: Some(dependency) }\n+    }\n+\n+    pub fn contains(&self, feat: &str) -> bool {\n+        self.iter().any(|dep| dep == feat)\n+    }\n+\n+    pub fn iter(&'a self) -> impl Iterator<Item = &'a str> {\n+        let dependencies = self.dependency.iter().map(|feat| feat.as_str());\n+        std::iter::once(self.llvm_feature_name).chain(dependencies)\n+    }\n+}\n+\n+impl<'a> IntoIterator for LLVMFeature<'a> {\n+    type Item = &'a str;\n+    type IntoIter = impl Iterator<Item = &'a str>;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        let dependencies = self.dependency.into_iter().map(|feat| feat.as_str());\n+        std::iter::once(self.llvm_feature_name).chain(dependencies)\n+    }\n+}\n+\n // WARNING: the features after applying `to_llvm_features` must be known\n // to LLVM or the feature detection code will walk past the end of the feature\n // array, leading to crashes.\n@@ -147,58 +200,65 @@ pub fn time_trace_profiler_finish(file_name: &Path) {\n // Though note that Rust can also be build with an external precompiled version of LLVM\n // which might lead to failures if the oldest tested / supported LLVM version\n // doesn't yet support the relevant intrinsics\n-//\n-// Note: The first feature in the list that is returned is the mapping to the feature that is\n-// provided from the `s` parameter.\n-pub fn to_llvm_features<'a>(sess: &Session, s: &'a str) -> SmallVec<[&'a str; 2]> {\n+pub fn to_llvm_features<'a>(sess: &Session, s: &'a str) -> LLVMFeature<'a> {\n     let arch = if sess.target.arch == \"x86_64\" { \"x86\" } else { &*sess.target.arch };\n     match (arch, s) {\n-        (\"x86\", \"sse4.2\") => smallvec![\"sse4.2\", \"crc32\"],\n-        (\"x86\", \"pclmulqdq\") => smallvec![\"pclmul\"],\n-        (\"x86\", \"rdrand\") => smallvec![\"rdrnd\"],\n-        (\"x86\", \"bmi1\") => smallvec![\"bmi\"],\n-        (\"x86\", \"cmpxchg16b\") => smallvec![\"cx16\"],\n-        (\"aarch64\", \"rcpc2\") => smallvec![\"rcpc-immo\"],\n-        (\"aarch64\", \"dpb\") => smallvec![\"ccpp\"],\n-        (\"aarch64\", \"dpb2\") => smallvec![\"ccdp\"],\n-        (\"aarch64\", \"frintts\") => smallvec![\"fptoint\"],\n-        (\"aarch64\", \"fcma\") => smallvec![\"complxnum\"],\n-        (\"aarch64\", \"pmuv3\") => smallvec![\"perfmon\"],\n-        (\"aarch64\", \"paca\") => smallvec![\"pauth\"],\n-        (\"aarch64\", \"pacg\") => smallvec![\"pauth\"],\n+        (\"x86\", \"sse4.2\") => {\n+            LLVMFeature::with_dependency(\"sse4.2\", TargetFeatureFoldStrength::EnableOnly(\"crc32\"))\n+        }\n+        (\"x86\", \"pclmulqdq\") => LLVMFeature::new(\"pclmul\"),\n+        (\"x86\", \"rdrand\") => LLVMFeature::new(\"rdrnd\"),\n+        (\"x86\", \"bmi1\") => LLVMFeature::new(\"bmi\"),\n+        (\"x86\", \"cmpxchg16b\") => LLVMFeature::new(\"cx16\"),\n+        (\"aarch64\", \"rcpc2\") => LLVMFeature::new(\"rcpc-immo\"),\n+        (\"aarch64\", \"dpb\") => LLVMFeature::new(\"ccpp\"),\n+        (\"aarch64\", \"dpb2\") => LLVMFeature::new(\"ccdp\"),\n+        (\"aarch64\", \"frintts\") => LLVMFeature::new(\"fptoint\"),\n+        (\"aarch64\", \"fcma\") => LLVMFeature::new(\"complxnum\"),\n+        (\"aarch64\", \"pmuv3\") => LLVMFeature::new(\"perfmon\"),\n+        (\"aarch64\", \"paca\") => LLVMFeature::new(\"pauth\"),\n+        (\"aarch64\", \"pacg\") => LLVMFeature::new(\"pauth\"),\n         // Rust ties fp and neon together.\n-        (\"aarch64\", \"neon\") => smallvec![\"neon\", \"fp-armv8\"],\n+        (\"aarch64\", \"neon\") => {\n+            LLVMFeature::with_dependency(\"neon\", TargetFeatureFoldStrength::Both(\"fp-armv8\"))\n+        }\n         // In LLVM neon implicitly enables fp, but we manually enable\n         // neon when a feature only implicitly enables fp\n-        (\"aarch64\", \"f32mm\") => smallvec![\"f32mm\", \"neon\"],\n-        (\"aarch64\", \"f64mm\") => smallvec![\"f64mm\", \"neon\"],\n-        (\"aarch64\", \"fhm\") => smallvec![\"fp16fml\", \"neon\"],\n-        (\"aarch64\", \"fp16\") => smallvec![\"fullfp16\", \"neon\"],\n-        (\"aarch64\", \"jsconv\") => smallvec![\"jsconv\", \"neon\"],\n-        (\"aarch64\", \"sve\") => smallvec![\"sve\", \"neon\"],\n-        (\"aarch64\", \"sve2\") => smallvec![\"sve2\", \"neon\"],\n-        (\"aarch64\", \"sve2-aes\") => smallvec![\"sve2-aes\", \"neon\"],\n-        (\"aarch64\", \"sve2-sm4\") => smallvec![\"sve2-sm4\", \"neon\"],\n-        (\"aarch64\", \"sve2-sha3\") => smallvec![\"sve2-sha3\", \"neon\"],\n-        (\"aarch64\", \"sve2-bitperm\") => smallvec![\"sve2-bitperm\", \"neon\"],\n-        (_, s) => smallvec![s],\n-    }\n-}\n-\n-pub enum TargetFeatureFoldStrength {\n-    // The feature is only tied when enabling the feature, disabling\n-    // this feature shouldn't disable the tied feature.\n-    EnableOnly,\n-    // The feature is tied for both enabling and disabling this feature.\n-    Both,\n-}\n-\n-// Determines how the features are folded together, some features are\n-// linked a lot more than some others.\n-pub fn feature_fold_strength<'a>(feats: &SmallVec<[&'a str; 2]>) -> TargetFeatureFoldStrength {\n-    match (feats.get(0), feats.get(1)) {\n-        (Some(&\"neon\"), Some(&\"fp-armv8\")) => TargetFeatureFoldStrength::Both,\n-        _ => TargetFeatureFoldStrength::EnableOnly,\n+        (\"aarch64\", \"f32mm\") => {\n+            LLVMFeature::with_dependency(\"f32mm\", TargetFeatureFoldStrength::EnableOnly(\"neon\"))\n+        }\n+        (\"aarch64\", \"f64mm\") => {\n+            LLVMFeature::with_dependency(\"f64mm\", TargetFeatureFoldStrength::EnableOnly(\"neon\"))\n+        }\n+        (\"aarch64\", \"fhm\") => {\n+            LLVMFeature::with_dependency(\"fp16fml\", TargetFeatureFoldStrength::EnableOnly(\"neon\"))\n+        }\n+        (\"aarch64\", \"fp16\") => {\n+            LLVMFeature::with_dependency(\"fullfp16\", TargetFeatureFoldStrength::EnableOnly(\"neon\"))\n+        }\n+        (\"aarch64\", \"jsconv\") => {\n+            LLVMFeature::with_dependency(\"jsconv\", TargetFeatureFoldStrength::EnableOnly(\"neon\"))\n+        }\n+        (\"aarch64\", \"sve\") => {\n+            LLVMFeature::with_dependency(\"sve\", TargetFeatureFoldStrength::EnableOnly(\"neon\"))\n+        }\n+        (\"aarch64\", \"sve2\") => {\n+            LLVMFeature::with_dependency(\"sve2\", TargetFeatureFoldStrength::EnableOnly(\"neon\"))\n+        }\n+        (\"aarch64\", \"sve2-aes\") => {\n+            LLVMFeature::with_dependency(\"sve2-aes\", TargetFeatureFoldStrength::EnableOnly(\"neon\"))\n+        }\n+        (\"aarch64\", \"sve2-sm4\") => {\n+            LLVMFeature::with_dependency(\"sve2-sm4\", TargetFeatureFoldStrength::EnableOnly(\"neon\"))\n+        }\n+        (\"aarch64\", \"sve2-sha3\") => {\n+            LLVMFeature::with_dependency(\"sve2-sha3\", TargetFeatureFoldStrength::EnableOnly(\"neon\"))\n+        }\n+        (\"aarch64\", \"sve2-bitperm\") => LLVMFeature::with_dependency(\n+            \"sve2-bitperm\",\n+            TargetFeatureFoldStrength::EnableOnly(\"neon\"),\n+        ),\n+        (_, s) => LLVMFeature::new(s),\n     }\n }\n \n@@ -296,18 +356,17 @@ fn print_target_features(sess: &Session, tm: &llvm::TargetMachine) {\n     let mut rustc_target_features = supported_target_features(sess)\n         .iter()\n         .map(|(feature, _gate)| {\n-            let desc = if let Some(llvm_feature) = to_llvm_features(sess, *feature).first() {\n-                // LLVM asserts that these are sorted. LLVM and Rust both use byte comparison for these strings.\n+            // LLVM asserts that these are sorted. LLVM and Rust both use byte comparison for these strings.\n+            let llvm_feature = to_llvm_features(sess, *feature).llvm_feature_name;\n+            let desc =\n                 match llvm_target_features.binary_search_by_key(&llvm_feature, |(f, _d)| f).ok() {\n                     Some(index) => {\n                         known_llvm_target_features.insert(llvm_feature);\n                         llvm_target_features[index].1\n                     }\n                     None => \"\",\n-                }\n-            } else {\n-                \"\"\n-            };\n+                };\n+\n             (*feature, desc)\n         })\n         .collect::<Vec<_>>();\n@@ -491,17 +550,20 @@ pub(crate) fn global_llvm_features(sess: &Session, diagnostics: bool) -> Vec<Str\n             // passing requests down to LLVM. This means that all in-language\n             // features also work on the command line instead of having two\n             // different names when the LLVM name and the Rust name differ.\n-            let llvm_features = to_llvm_features(sess, feature);\n-            Some(to_llvm_features(sess, feature).into_iter().enumerate().filter_map(\n-                move |(idx, f)| match (enable_disable, feature_fold_strength(&llvm_features)) {\n-                    ('-' | '+', TargetFeatureFoldStrength::Both)\n-                    | ('+', TargetFeatureFoldStrength::EnableOnly) => {\n-                        Some(format!(\"{}{}\", enable_disable, f))\n-                    }\n-                    _ if idx == 0 => Some(format!(\"{}{}\", enable_disable, f)),\n-                    _ => None,\n-                },\n-            ))\n+            let llvm_feature = to_llvm_features(sess, feature);\n+\n+            Some(\n+                std::iter::once(format!(\"{}{}\", enable_disable, llvm_feature.llvm_feature_name))\n+                    .chain(llvm_feature.dependency.into_iter().filter_map(move |feat| {\n+                        match (enable_disable, feat) {\n+                            ('-' | '+', TargetFeatureFoldStrength::Both(f))\n+                            | ('+', TargetFeatureFoldStrength::EnableOnly(f)) => {\n+                                Some(format!(\"{}{}\", enable_disable, f))\n+                            }\n+                            _ => None,\n+                        }\n+                    })),\n+            )\n         })\n         .flatten();\n     features.extend(feats);"}, {"sha": "51334c121582765a10009712bbdfcb818a7d6351", "filename": "tests/codegen/tied-features-strength.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a059e68d118512063e8e3517344178667df951b0/tests%2Fcodegen%2Ftied-features-strength.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a059e68d118512063e8e3517344178667df951b0/tests%2Fcodegen%2Ftied-features-strength.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Ftied-features-strength.rs?ref=a059e68d118512063e8e3517344178667df951b0", "patch": "@@ -5,19 +5,19 @@\n \n // The \"+v8a\" feature is matched as optional as it isn't added when we\n // are targeting older LLVM versions. Once the min supported version\n-// is LLVM-14 we can remove the regex matching for this feature.\n+// is LLVM-14 we can remove the optional regex matching for this feature.\n \n // [ENABLE_SVE] compile-flags: -C target-feature=+sve\n-// ENABLE_SVE: attributes #0 = { {{.*}} \"target-features\"=\"+outline-atomics,+sve,+neon{{(,\\+v8a)?}}\" }\n+// ENABLE_SVE: attributes #0 = { {{.*}} \"target-features\"=\"{{((\\+outline-atomics,?)|(\\+v8a,?)?|(\\+sve,?)|(\\+neon,?))*}}\" }\n \n // [DISABLE_SVE] compile-flags: -C target-feature=-sve\n-// DISABLE_SVE: attributes #0 = { {{.*}} \"target-features\"=\"+outline-atomics,-sve{{(,\\+v8a)?}}\" }\n+// DISABLE_SVE: attributes #0 = { {{.*}} \"target-features\"=\"{{((\\+outline-atomics,?)|(\\+v8a,?)?|(-sve,?)|(\\+neon,?))*}}\" }\n \n // [DISABLE_NEON] compile-flags: -C target-feature=-neon\n-// DISABLE_NEON: attributes #0 = { {{.*}} \"target-features\"=\"+outline-atomics,-neon,-fp-armv8{{(,\\+v8a)?}}\" }\n+// DISABLE_NEON: attributes #0 = { {{.*}} \"target-features\"=\"{{((\\+outline-atomics,?)|(\\+v8a,?)?|(-fp-armv8,?)|(-neon,?))*}}\" }\n \n // [ENABLE_NEON] compile-flags: -C target-feature=+neon\n-// ENABLE_NEON: attributes #0 = { {{.*}} \"target-features\"=\"+outline-atomics,+neon,+fp-armv8{{(,\\+v8a)?}}\" }\n+// ENABLE_NEON: attributes #0 = { {{.*}} \"target-features\"=\"{{((\\+outline-atomics,?)|(\\+v8a,?)?|(\\+fp-armv8,?)|(\\+neon,?))*}}\" }\n \n \n #![feature(no_core, lang_items)]"}]}