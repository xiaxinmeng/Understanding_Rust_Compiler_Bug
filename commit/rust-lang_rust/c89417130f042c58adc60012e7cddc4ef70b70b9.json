{"sha": "c89417130f042c58adc60012e7cddc4ef70b70b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4OTQxNzEzMGYwNDJjNThhZGM2MDAxMmU3Y2RkYzRlZjcwYjcwYjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-02T21:56:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-02T21:56:13Z"}, "message": "auto merge of #20436 : alexcrichton/rust/rollup, r=alexcrichton", "tree": {"sha": "344f3d621e187b41d23ef01f621ff68ebe810a03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/344f3d621e187b41d23ef01f621ff68ebe810a03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c89417130f042c58adc60012e7cddc4ef70b70b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c89417130f042c58adc60012e7cddc4ef70b70b9", "html_url": "https://github.com/rust-lang/rust/commit/c89417130f042c58adc60012e7cddc4ef70b70b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c89417130f042c58adc60012e7cddc4ef70b70b9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b40bc85cbc1d072179c92ce01655db0272aa598", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b40bc85cbc1d072179c92ce01655db0272aa598", "html_url": "https://github.com/rust-lang/rust/commit/4b40bc85cbc1d072179c92ce01655db0272aa598"}, {"sha": "340f3fd7a909b30509a63916df06f2b885d113f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/340f3fd7a909b30509a63916df06f2b885d113f7", "html_url": "https://github.com/rust-lang/rust/commit/340f3fd7a909b30509a63916df06f2b885d113f7"}], "stats": {"total": 11488, "additions": 6697, "deletions": 4791}, "files": [{"sha": "03e38f4e0c1ac03ac0bf020f4292bb22132b2de5", "filename": ".travis.yml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -2,6 +2,7 @@\n # RVM/bundler/ruby and whatnot. Right now 'rust' as a language actually\n # downloads a rust/cargo snapshot, which we don't really want for building rust.\n language: c\n+sudo: false\n \n # The test suite is in general way too stressful for travis, especially in\n # terms of time limit and reliability. In the past we've tried to scale things"}, {"sha": "6986746a1179040c0ccf6ec59eb3863eb90d0d57", "filename": "mk/dist.mk", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -212,7 +212,7 @@ distcheck-osx: dist-osx\n # Unix binary installer tarballs\n ######################################################################\n \n-NON_INSTALLED_PREFIXES=COPYRIGHT,LICENSE-APACHE,LICENSE-MIT,README.md,doc\n+NON_INSTALLED_PREFIXES=COPYRIGHT,LICENSE-APACHE,LICENSE-MIT,README.md,version\n \n define DEF_INSTALLER\n \n@@ -236,6 +236,8 @@ dist-install-dir-$(1): prepare-base-dir-$(1) docs compiler-docs\n \t$$(Q)$$(PREPARE_MAN_CMD) $$(S)LICENSE-APACHE $$(PREPARE_DEST_DIR)/share/doc/rust\n \t$$(Q)$$(PREPARE_MAN_CMD) $$(S)LICENSE-MIT $$(PREPARE_DEST_DIR)/share/doc/rust\n \t$$(Q)$$(PREPARE_MAN_CMD) $$(S)README.md $$(PREPARE_DEST_DIR)/share/doc/rust\n+# This tiny morsel of metadata is used by rust-packaging\n+\t$$(Q)echo \"$(CFG_VERSION)\" > $$(PREPARE_DEST_DIR)/version\n \n dist/$$(PKG_NAME)-$(1).tar.gz: dist-install-dir-$(1)\n \t@$(call E, build: $$@)"}, {"sha": "a8dfdffb59d1a3390f0c06374f771c9f0b85a6aa", "filename": "mk/install.mk", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/mk%2Finstall.mk", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/mk%2Finstall.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Finstall.mk?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -28,7 +28,11 @@ endif\n # Remove tmp files because it's a decent amount of disk space\n \t$(Q)rm -R tmp/dist\n \n+ifeq ($(CFG_DISABLE_DOCS),)\n+prepare_install: dist/$(PKG_NAME)-$(CFG_BUILD).tar.gz dist/$(DOC_PKG_NAME)-$(CFG_BUILD).tar.gz | tmp/empty_dir\n+else\n prepare_install: dist/$(PKG_NAME)-$(CFG_BUILD).tar.gz | tmp/empty_dir\n+endif\n \n uninstall:\n ifeq (root user, $(USER) $(patsubst %,user,$(SUDO_USER)))"}, {"sha": "ad1264828cb9679506e13084c82d97633b93009e", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -22,8 +22,8 @@ extern crate regex;\n use std::os;\n use std::io;\n use std::io::fs;\n-use std::str::FromStr;\n-use std::thunk::{Thunk};\n+use std::str::{FromStr, from_str};\n+use std::thunk::Thunk;\n use getopts::{optopt, optflag, reqopt};\n use common::Config;\n use common::{Pretty, DebugInfoGdb, DebugInfoLldb, Codegen};"}, {"sha": "b8808eaf57d93e076b5b90829ecd0d45b5317202", "filename": "src/doc/guide-ffi.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Fdoc%2Fguide-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Fdoc%2Fguide-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ffi.md?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -450,6 +450,8 @@ them.\n \n ~~~no_run\n extern crate libc;\n+\n+use std::c_str::ToCStr;\n use std::ptr;\n \n #[link(name = \"readline\")]"}, {"sha": "8eb13187e5841b8d1595ca846b0d9606be8c2ef8", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -206,6 +206,7 @@ getting the result later.\n The basic example below illustrates this.\n \n ```{rust,ignore}\n+# #![allow(deprecated)]\n use std::sync::Future;\n \n # fn main() {\n@@ -233,6 +234,7 @@ Here is another example showing how futures allow you to background\n computations. The workload will be distributed on the available cores.\n \n ```{rust,ignore}\n+# #![allow(deprecated)]\n # use std::num::Float;\n # use std::sync::Future;\n fn partial_sum(start: uint) -> f64 {"}, {"sha": "55465651cfb4b30db1b3df20cf582b8e2e803714", "filename": "src/doc/guide.md", "status": "modified", "additions": 249, "deletions": 233, "changes": 482, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -26,7 +26,7 @@ in the `$`s, they just indicate the start of each command):\n curl -L https://static.rust-lang.org/rustup.sh | sudo sh\n ```\n \n-If you're concerned about the [potential insecurity](http://curlpipesh.tumblr.com/) of using `curl | sudo sh`, \n+If you're concerned about the [potential insecurity](http://curlpipesh.tumblr.com/) of using `curl | sudo sh`,\n please keep reading and see our disclaimer below. And feel free to use a two-step version of the installation and examine our installation script:\n \n ```bash\n@@ -1106,13 +1106,21 @@ enum Ordering {\n ```\n \n An `Ordering` can only be _one_ of `Less`, `Equal`, or `Greater` at any given\n-time. Here's an example:\n+time.\n+\n+Because `Ordering` is provided by the standard library, we can use the `use`\n+keyword to use it in our code. We'll learn more about `use` later, but it's\n+used to bring names into scope.\n+\n+Here's an example of how to use `Ordering`:\n \n ```{rust}\n+use std::cmp::Ordering;\n+\n fn cmp(a: int, b: int) -> Ordering {\n-    if a < b { Less }\n-    else if a > b { Greater }\n-    else { Equal }\n+    if a < b { Ordering::Less }\n+    else if a > b { Ordering::Greater }\n+    else { Ordering::Equal }\n }\n \n fn main() {\n@@ -1121,28 +1129,35 @@ fn main() {\n \n     let ordering = cmp(x, y); // ordering: Ordering\n \n-    if ordering == Less {\n+    if ordering == Ordering::Less {\n         println!(\"less\");\n-    } else if ordering == Greater {\n+    } else if ordering == Ordering::Greater {\n         println!(\"greater\");\n-    } else if ordering == Equal {\n+    } else if ordering == Ordering::Equal {\n         println!(\"equal\");\n     }\n }\n ```\n \n-`cmp` is a function that compares two things, and returns an `Ordering`. We\n-return either `Less`, `Greater`, or `Equal`, depending on if the two values\n-are greater, less, or equal.\n+There's a symbol here we haven't seen before: the double colon (`::`).\n+This is used to indicate a namesapce. In this case, `Ordering` lives in\n+the `cmp` submodule of the `std` module. We'll talk more about modules\n+later in the guide. For now, all you need to know is that you can `use`\n+things from the standard library if you need them.\n \n-The `ordering` variable has the type `Ordering`, and so contains one of the\n-three values. We can then do a bunch of `if`/`else` comparisons to check\n-which one it is.\n+Okay, let's talk about the actual code in the example. `cmp` is a function that\n+compares two things, and returns an `Ordering`. We return either\n+`Ordering::Less`, `Ordering::Greater`, or `Ordering::Equal`, depending on if\n+the two values are greater, less, or equal. Note that each variant of the\n+`enum` is namespaced under the `enum` itself: it's `Ordering::Greater` not\n+`Greater`.\n \n-However, repeated `if`/`else` comparisons get quite tedious. Rust has a feature\n-that not only makes them nicer to read, but also makes sure that you never\n-miss a case. Before we get to that, though, let's talk about another kind of\n-enum: one with values.\n+The `ordering` variable has the type `Ordering`, and so contains one of the\n+three values. We can then do a bunch of `if`/`else` comparisons to check which\n+one it is. However, repeated `if`/`else` comparisons get quite tedious. Rust\n+has a feature that not only makes them nicer to read, but also makes sure that\n+you never miss a case. Before we get to that, though, let's talk about another\n+kind of enum: one with values.\n \n This enum has two variants, one of which has a value:\n \n@@ -1175,18 +1190,19 @@ enum StringResult {\n     ErrorReason(String),\n }\n ```\n-Where a `StringResult` is either a `StringOK`, with the result of a computation, or an\n-`ErrorReason` with a `String` explaining what caused the computation to fail. These kinds of\n-`enum`s are actually very useful and are even part of the standard library.\n+Where a `StringResult` is either a `StringResult::StringOK`, with the result of\n+a computation, or an `StringResult::ErrorReason` with a `String` explaining\n+what caused the computation to fail. These kinds of `enum`s are actually very\n+useful and are even part of the standard library.\n \n-Enum variants are namespaced under the enum names. For example, here is an example of using\n-our `StringResult`:\n+Here is an example of using our `StringResult`:\n \n ```rust\n-# enum StringResult {\n-#     StringOK(String),\n-#     ErrorReason(String),\n-# }\n+enum StringResult {\n+    StringOK(String),\n+    ErrorReason(String),\n+}\n+\n fn respond(greeting: &str) -> StringResult {\n     if greeting == \"Hello\" {\n         StringResult::StringOK(\"Good morning!\".to_string())\n@@ -1196,10 +1212,7 @@ fn respond(greeting: &str) -> StringResult {\n }\n ```\n \n-Notice that we need both the enum name and the variant name: `StringResult::StringOK`, but\n-we didn't need to with `Ordering` \u2013 we just said `Greater` rather than `Ordering::Greater`.\n-There's a reason: the Rust prelude imports the variants of `Ordering` as well as the enum\n-itself. We can use the `use` keyword to do something similar with `StringResult`:\n+That's a lot of typing! We can use the `use` keyword to make it shorter:\n \n ```rust\n use StringResult::StringOK;\n@@ -1221,12 +1234,11 @@ fn respond(greeting: &str) -> StringResult {\n }\n ```\n \n-We'll learn more about `use` later, but it's used to bring names into scope. `use` declarations\n-must come before anything else, which looks a little strange in this example, since we `use`\n-the variants before we define them. Anyway, in the body of `respond`, we can just say `StringOK`\n-now, rather than the full `StringResult::StringOK`. Importing variants can be convenient, but can\n-also cause name conflicts, so do this with caution. It's considered good style to rarely import\n-variants for this reason.\n+`use` declarations must come before anything else, which looks a little strange in this example,\n+since we `use` the variants before we define them. Anyway, in the body of `respond`, we can just\n+say `StringOK` now, rather than the full `StringResult::StringOK`. Importing variants can be\n+convenient, but can also cause name conflicts, so do this with caution. It's considered good style\n+to rarely import variants for this reason.\n \n As you can see, `enum`s with values are quite a powerful tool for data representation,\n and can be even more useful when they're generic across types. Before we get to generics,\n@@ -1280,10 +1292,12 @@ for every possible value of `x`, and so our program will compile successfully.\n section on enums?\n \n ```{rust}\n+use std::cmp::Ordering;\n+\n fn cmp(a: int, b: int) -> Ordering {\n-    if a < b { Less }\n-    else if a > b { Greater }\n-    else { Equal }\n+    if a < b { Ordering::Less }\n+    else if a > b { Ordering::Greater }\n+    else { Ordering::Equal }\n }\n \n fn main() {\n@@ -1292,11 +1306,11 @@ fn main() {\n \n     let ordering = cmp(x, y);\n \n-    if ordering == Less {\n+    if ordering == Ordering::Less {\n         println!(\"less\");\n-    } else if ordering == Greater {\n+    } else if ordering == Ordering::Greater {\n         println!(\"greater\");\n-    } else if ordering == Equal {\n+    } else if ordering == Ordering::Equal {\n         println!(\"equal\");\n     }\n }\n@@ -1305,20 +1319,22 @@ fn main() {\n We can re-write this as a `match`:\n \n ```{rust}\n+use std::cmp::Ordering;\n+\n fn cmp(a: int, b: int) -> Ordering {\n-    if a < b { Less }\n-    else if a > b { Greater }\n-    else { Equal }\n+    if a < b { Ordering::Less }\n+    else if a > b { Ordering::Greater }\n+    else { Ordering::Equal }\n }\n \n fn main() {\n     let x = 5i;\n     let y = 10i;\n \n     match cmp(x, y) {\n-        Less    => println!(\"less\"),\n-        Greater => println!(\"greater\"),\n-        Equal   => println!(\"equal\"),\n+        Ordering::Less    => println!(\"less\"),\n+        Ordering::Greater => println!(\"greater\"),\n+        Ordering::Equal   => println!(\"equal\"),\n     }\n }\n ```\n@@ -1365,20 +1381,22 @@ side of a `let` binding or directly where an expression is used. We could\n also implement the previous line like this:\n \n ```{rust}\n+use std::cmp::Ordering;\n+\n fn cmp(a: int, b: int) -> Ordering {\n-    if a < b { Less }\n-    else if a > b { Greater }\n-    else { Equal }\n+    if a < b { Ordering::Less }\n+    else if a > b { Ordering::Greater }\n+    else { Ordering::Equal }\n }\n \n fn main() {\n     let x = 5i;\n     let y = 10i;\n \n     println!(\"{}\", match cmp(x, y) {\n-        Less    => \"less\",\n-        Greater => \"greater\",\n-        Equal   => \"equal\",\n+        Ordering::Less    => \"less\",\n+        Ordering::Greater => \"greater\",\n+        Ordering::Equal   => \"equal\",\n     });\n }\n ```\n@@ -2139,6 +2157,7 @@ guess to the secret number:\n ```{rust,ignore}\n use std::io;\n use std::rand;\n+use std::cmp::Ordering;\n \n fn main() {\n     println!(\"Guess the number!\");\n@@ -2157,16 +2176,16 @@ fn main() {\n     println!(\"You guessed: {}\", input);\n \n     match cmp(input, secret_number) {\n-        Less    => println!(\"Too small!\"),\n-        Greater => println!(\"Too big!\"),\n-        Equal   => println!(\"You win!\"),\n+        Ordering::Less    => println!(\"Too small!\"),\n+        Ordering::Greater => println!(\"Too big!\"),\n+        Ordering::Equal   => println!(\"You win!\"),\n     }\n }\n \n fn cmp(a: int, b: int) -> Ordering {\n-    if a < b { Less }\n-    else if a > b { Greater }\n-    else { Equal }\n+    if a < b { Ordering::Less }\n+    else if a > b { Ordering::Greater }\n+    else { Ordering::Equal }\n }\n ```\n \n@@ -2193,6 +2212,7 @@ we wrote the `cmp` function! Let's change it to take `uint`s:\n ```{rust,ignore}\n use std::io;\n use std::rand;\n+use std::cmp::Ordering;\n \n fn main() {\n     println!(\"Guess the number!\");\n@@ -2211,16 +2231,16 @@ fn main() {\n     println!(\"You guessed: {}\", input);\n \n     match cmp(input, secret_number) {\n-        Less    => println!(\"Too small!\"),\n-        Greater => println!(\"Too big!\"),\n-        Equal   => println!(\"You win!\"),\n+        Ordering::Less    => println!(\"Too small!\"),\n+        Ordering::Greater => println!(\"Too big!\"),\n+        Ordering::Equal   => println!(\"You win!\"),\n     }\n }\n \n fn cmp(a: uint, b: uint) -> Ordering {\n-    if a < b { Less }\n-    else if a > b { Greater }\n-    else { Equal }\n+    if a < b { Ordering::Less }\n+    else if a > b { Ordering::Greater }\n+    else { Ordering::Equal }\n }\n ```\n \n@@ -2290,6 +2310,7 @@ Anyway, with us now converting our input to a number, our code looks like this:\n ```{rust,ignore}\n use std::io;\n use std::rand;\n+use std::cmp::Ordering;\n \n fn main() {\n     println!(\"Guess the number!\");\n@@ -2308,16 +2329,16 @@ fn main() {\n     println!(\"You guessed: {}\", input_num);\n \n     match cmp(input_num, secret_number) {\n-        Less    => println!(\"Too small!\"),\n-        Greater => println!(\"Too big!\"),\n-        Equal   => println!(\"You win!\"),\n+        Ordering::Less    => println!(\"Too small!\"),\n+        Ordering::Greater => println!(\"Too big!\"),\n+        Ordering::Equal   => println!(\"You win!\"),\n     }\n }\n \n fn cmp(a: uint, b: uint) -> Ordering {\n-    if a < b { Less }\n-    else if a > b { Greater }\n-    else { Equal }\n+    if a < b { Ordering::Less }\n+    else if a > b { Ordering::Greater }\n+    else { Ordering::Equal }\n }\n ```\n \n@@ -2339,6 +2360,7 @@ to do that. Try this code:\n ```{rust,no_run}\n use std::io;\n use std::rand;\n+use std::cmp::Ordering;\n \n fn main() {\n     println!(\"Guess the number!\");\n@@ -2366,16 +2388,16 @@ fn main() {\n     println!(\"You guessed: {}\", num);\n \n     match cmp(num, secret_number) {\n-        Less    => println!(\"Too small!\"),\n-        Greater => println!(\"Too big!\"),\n-        Equal   => println!(\"You win!\"),\n+        Ordering::Less    => println!(\"Too small!\"),\n+        Ordering::Greater => println!(\"Too big!\"),\n+        Ordering::Equal   => println!(\"You win!\"),\n     }\n }\n \n fn cmp(a: uint, b: uint) -> Ordering {\n-    if a < b { Less }\n-    else if a > b { Greater }\n-    else { Equal }\n+    if a < b { Ordering::Less }\n+    else if a > b { Ordering::Greater }\n+    else { Ordering::Equal }\n }\n ```\n \n@@ -2405,6 +2427,7 @@ code looks like this:\n ```{rust,no_run}\n use std::io;\n use std::rand;\n+use std::cmp::Ordering;\n \n fn main() {\n     println!(\"Guess the number!\");\n@@ -2432,16 +2455,16 @@ fn main() {\n     println!(\"You guessed: {}\", num);\n \n     match cmp(num, secret_number) {\n-        Less    => println!(\"Too small!\"),\n-        Greater => println!(\"Too big!\"),\n-        Equal   => println!(\"You win!\"),\n+        Ordering::Less    => println!(\"Too small!\"),\n+        Ordering::Greater => println!(\"Too big!\"),\n+        Ordering::Equal   => println!(\"You win!\"),\n     }\n }\n \n fn cmp(a: uint, b: uint) -> Ordering {\n-    if a < b { Less }\n-    else if a > b { Greater }\n-    else { Equal }\n+    if a < b { Ordering::Less }\n+    else if a > b { Ordering::Greater }\n+    else { Ordering::Equal }\n }\n ```\n \n@@ -2478,6 +2501,7 @@ Let's add that in:\n ```{rust,no_run}\n use std::io;\n use std::rand;\n+use std::cmp::Ordering;\n \n fn main() {\n     println!(\"Guess the number!\");\n@@ -2507,17 +2531,17 @@ fn main() {\n         println!(\"You guessed: {}\", num);\n \n         match cmp(num, secret_number) {\n-            Less    => println!(\"Too small!\"),\n-            Greater => println!(\"Too big!\"),\n-            Equal   => println!(\"You win!\"),\n+            Ordering::Less    => println!(\"Too small!\"),\n+            Ordering::Greater => println!(\"Too big!\"),\n+            Ordering::Equal   => println!(\"You win!\"),\n         }\n     }\n }\n \n fn cmp(a: uint, b: uint) -> Ordering {\n-    if a < b { Less }\n-    else if a > b { Greater }\n-    else { Equal }\n+    if a < b { Ordering::Less }\n+    else if a > b { Ordering::Greater }\n+    else { Ordering::Equal }\n }\n ```\n \n@@ -2553,6 +2577,7 @@ suboptimal to say the least. First, let's actually quit when you win the game:\n ```{rust,no_run}\n use std::io;\n use std::rand;\n+use std::cmp::Ordering;\n \n fn main() {\n     println!(\"Guess the number!\");\n@@ -2582,9 +2607,9 @@ fn main() {\n         println!(\"You guessed: {}\", num);\n \n         match cmp(num, secret_number) {\n-            Less    => println!(\"Too small!\"),\n-            Greater => println!(\"Too big!\"),\n-            Equal   => {\n+            Ordering::Less    => println!(\"Too small!\"),\n+            Ordering::Greater => println!(\"Too big!\"),\n+            Ordering::Equal   => {\n                 println!(\"You win!\");\n                 return;\n             },\n@@ -2593,9 +2618,9 @@ fn main() {\n }\n \n fn cmp(a: uint, b: uint) -> Ordering {\n-    if a < b { Less }\n-    else if a > b { Greater }\n-    else { Equal }\n+    if a < b { Ordering::Less }\n+    else if a > b { Ordering::Greater }\n+    else { Ordering::Equal }\n }\n ```\n \n@@ -2608,6 +2633,7 @@ we don't want to quit, we just want to ignore it. Change that `return` to\n ```{rust,no_run}\n use std::io;\n use std::rand;\n+use std::cmp::Ordering;\n \n fn main() {\n     println!(\"Guess the number!\");\n@@ -2637,9 +2663,9 @@ fn main() {\n         println!(\"You guessed: {}\", num);\n \n         match cmp(num, secret_number) {\n-            Less    => println!(\"Too small!\"),\n-            Greater => println!(\"Too big!\"),\n-            Equal   => {\n+            Ordering::Less    => println!(\"Too small!\"),\n+            Ordering::Greater => println!(\"Too big!\"),\n+            Ordering::Equal   => {\n                 println!(\"You win!\");\n                 return;\n             },\n@@ -2648,9 +2674,9 @@ fn main() {\n }\n \n fn cmp(a: uint, b: uint) -> Ordering {\n-    if a < b { Less }\n-    else if a > b { Greater }\n-    else { Equal }\n+    if a < b { Ordering::Less }\n+    else if a > b { Ordering::Greater }\n+    else { Ordering::Equal }\n }\n ```\n \n@@ -2686,6 +2712,7 @@ It was good for testing, but it kind of ruins the game. Here's our final source:\n ```{rust,no_run}\n use std::io;\n use std::rand;\n+use std::cmp::Ordering;\n \n fn main() {\n     println!(\"Guess the number!\");\n@@ -2713,9 +2740,9 @@ fn main() {\n         println!(\"You guessed: {}\", num);\n \n         match cmp(num, secret_number) {\n-            Less    => println!(\"Too small!\"),\n-            Greater => println!(\"Too big!\"),\n-            Equal   => {\n+            Ordering::Less    => println!(\"Too small!\"),\n+            Ordering::Greater => println!(\"Too big!\"),\n+            Ordering::Equal   => {\n                 println!(\"You win!\");\n                 return;\n             },\n@@ -2724,9 +2751,9 @@ fn main() {\n }\n \n fn cmp(a: uint, b: uint) -> Ordering {\n-    if a < b { Less }\n-    else if a > b { Greater }\n-    else { Equal }\n+    if a < b { Ordering::Less }\n+    else if a > b { Ordering::Greater }\n+    else { Ordering::Equal }\n }\n ```\n \n@@ -4154,7 +4181,7 @@ We've made a struct that represents a circle. We then write an `impl` block,\n and inside it, define a method, `area`. Methods take a  special first\n parameter, `&self`. There are three variants: `self`, `&self`, and `&mut self`.\n You can think of this first parameter as being the `x` in `x.foo()`. The three\n-variants correspond to the three kinds of thing `x` could be: `self` if it's\n+variants correspond to the three kinds of things `x` could be: `self` if it's\n just a value on the stack, `&self` if it's a reference, and `&mut self` if it's\n a mutable reference. We should default to using `&self`, as it's the most\n common.\n@@ -4742,13 +4769,13 @@ enum OptionalFloat64 {\n }\n ```\n \n-This is really unfortunate. Luckily, Rust has a feature that gives us a better\n-way: generics. Generics are called **parametric polymorphism** in type theory,\n-which means that they are types or functions that have multiple forms (\"poly\"\n-is multiple, \"morph\" is form) over a given parameter (\"parametric\").\n+Such repetition is unfortunate. Luckily, Rust has a feature that gives us a\n+better way: **generics**. Generics are called **parametric polymorphism** in\n+type theory, which means that they are types or functions that have multiple\n+forms over a given parameter (\"parametric\").\n \n-Anyway, enough with type theory declarations, let's check out the generic form\n-of `OptionalInt`. It is actually provided by Rust itself, and looks like this:\n+Let's see how generics help us escape `OptionalInt`. `Option` is already\n+provided in Rust's standard library and looks like this:\n \n ```rust\n enum Option<T> {\n@@ -4757,25 +4784,27 @@ enum Option<T> {\n }\n ```\n \n-The `<T>` part, which you've seen a few times before, indicates that this is\n-a generic data type. Inside the declaration of our enum, wherever we see a `T`,\n-we substitute that type for the same type used in the generic. Here's an\n-example of using `Option<T>`, with some extra type annotations:\n+The `<T>` part, which you've seen a few times before, indicates that this is a\n+generic data type. `T` is called a **type parameter**. When we create instances\n+of `Option`, we need to provide a concrete type in place of the type\n+parameter. For example, if we wanted something like our `OptionalInt`, we would\n+need to instantiate an `Option<int>`. Inside the declaration of our enum,\n+wherever we see a `T`, we replace it with the type specified (or inferred by the\n+the compiler).\n \n ```{rust}\n let x: Option<int> = Some(5i);\n ```\n \n-In the type declaration, we say `Option<int>`. Note how similar this looks to\n-`Option<T>`. So, in this particular `Option`, `T` has the value of `int`. On\n-the right-hand side of the binding, we do make a `Some(T)`, where `T` is `5i`.\n-Since that's an `int`, the two sides match, and Rust is happy. If they didn't\n-match, we'd get an error:\n+In this particular `Option`, `T` has the value of `int`. On the right-hand side\n+of the binding, we do make a `Some(T)`, where `T` is `5i`.  Since that's an\n+`int`, the two sides match, and Rust is happy. If they didn't match, we'd get an\n+error:\n \n ```{rust,ignore}\n let x: Option<f64> = Some(5i);\n-// error: mismatched types: expected `core::option::Option<f64>`\n-// but found `core::option::Option<int>` (expected f64 but found int)\n+// error: mismatched types: expected `core::option::Option<f64>`,\n+// found `core::option::Option<int>` (expected f64, found int)\n ```\n \n That doesn't mean we can't make `Option<T>`s that hold an `f64`! They just have to\n@@ -4786,8 +4815,6 @@ let x: Option<int> = Some(5i);\n let y: Option<f64> = Some(5.0f64);\n ```\n \n-This is just fine. One definition, multiple uses.\n-\n Generics don't have to only be generic over one type. Consider Rust's built-in\n `Result<T, E>` type:\n \n@@ -4808,20 +4835,20 @@ enum Result<H, N> {\n }\n ```\n \n-if we wanted to. Convention says that the first generic parameter should be\n-`T`, for 'type,' and that we use `E` for 'error'. Rust doesn't care, however.\n+Convention says that the first generic parameter should be `T`, for \"type,\" and\n+that we use `E` for \"error.\"\n \n-The `Result<T, E>` type is intended to\n-be used to return the result of a computation, and to have the ability to\n-return an error if it didn't work out. Here's an example:\n+The `Result<T, E>` type is intended to be used to return the result of a\n+computation and to have the ability to return an error if it didn't work\n+out. Here's an example:\n \n ```{rust}\n let x: Result<f64, String> = Ok(2.3f64);\n let y: Result<f64, String> = Err(\"There was an error.\".to_string());\n ```\n \n-This particular Result will return an `f64` if there's a success, and a\n-`String` if there's a failure. Let's write a function that uses `Result<T, E>`:\n+This particular `Result` will return an `f64` upon success and a `String` if\n+there's a failure. Let's write a function that uses `Result<T, E>`:\n \n ```{rust}\n fn inverse(x: f64) -> Result<f64, String> {\n@@ -4831,17 +4858,18 @@ fn inverse(x: f64) -> Result<f64, String> {\n }\n ```\n \n-We don't want to take the inverse of zero, so we check to make sure that we\n-weren't passed zero. If we were, then we return an `Err`, with a message. If\n-it's okay, we return an `Ok`, with the answer.\n+We want to indicate that `inverse(0.0f64)` is undefined or is an erroneous usage\n+of the function, so we check to make sure that we weren't passed zero. If we\n+were, we return an `Err` with a message. If it's okay, we return an `Ok` with\n+the answer.\n \n Why does this matter? Well, remember how `match` does exhaustive matches?\n Here's how this function gets used:\n \n ```{rust}\n # fn inverse(x: f64) -> Result<f64, String> {\n-#     if x == 0.0f64 { return Err(\"x cannot be zero!\".to_string()); }\n-#     Ok(1.0f64 / x)\n+# if x == 0.0f64 { return Err(\"x cannot be zero!\".to_string()); }\n+# Ok(1.0f64 / x)\n # }\n let x = inverse(25.0f64);\n \n@@ -4862,8 +4890,8 @@ println!(\"{}\", x + 2.0f64); // error: binary operation `+` cannot be applied\n ```\n \n This function is great, but there's one other problem: it only works for 64 bit\n-floating point values. What if we wanted to handle 32 bit floating point as\n-well? We'd have to write this:\n+floating point values. If we wanted to handle 32 bit floating point values we'd\n+have to write this:\n \n ```{rust}\n fn inverse32(x: f32) -> Result<f32, String> {\n@@ -4873,9 +4901,9 @@ fn inverse32(x: f32) -> Result<f32, String> {\n }\n ```\n \n-Bummer. What we need is a **generic function**. Luckily, we can write one!\n-However, it won't _quite_ work yet. Before we get into that, let's talk syntax.\n-A generic version of `inverse` would look something like this:\n+What we need is a **generic function**. We can do that with Rust! However, it\n+won't _quite_ work yet. We need to talk about syntax. A first attempt at a\n+generic version of `inverse` might look something like this:\n \n ```{rust,ignore}\n fn inverse<T>(x: T) -> Result<T, String> {\n@@ -4885,24 +4913,34 @@ fn inverse<T>(x: T) -> Result<T, String> {\n }\n ```\n \n-Just like how we had `Option<T>`, we use a similar syntax for `inverse<T>`.\n-We can then use `T` inside the rest of the signature: `x` has type `T`, and half\n-of the `Result` has type `T`. However, if we try to compile that example, we'll get\n-an error:\n+Just like how we had `Option<T>`, we use a similar syntax for `inverse<T>`.  We\n+can then use `T` inside the rest of the signature: `x` has type `T`, and half of\n+the `Result` has type `T`. However, if we try to compile that example, we'll get\n+some errors:\n \n ```text\n error: binary operation `==` cannot be applied to type `T`\n+     if x == 0.0 { return Err(\"x cannot be zero!\".to_string()); }\n+                ^~~~~~~~\n+error: mismatched types: expected `_`, found `T` (expected floating-point variable, found type parameter)\n+     Ok(1.0 / x)\n+              ^\n+error: mismatched types: expected `core::result::Result<T, collections::string::String>`, found `core::result::Result<_, _>` (expected type parameter, found floating-point variable)\n+     Ok(1.0 / x)\n+     ^~~~~~~~~~~\n ```\n \n-Because `T` can be _any_ type, it may be a type that doesn't implement `==`,\n-and therefore, the first line would be wrong. What do we do?\n+The problem is that `T` is unconstrained: it can be _any_ type. It could be a\n+`String`, and the expression `1.0 / x` has no meaning if `x` is a `String`. It\n+may be a type that doesn't implement `==`, and the first line would be\n+wrong. What do we do?\n \n-To fix this example, we need to learn about another Rust feature: traits.\n+To fix this example, we need to learn about another Rust feature: **traits**.\n \n # Traits\n \n-Do you remember the `impl` keyword, used to call a function with method\n-syntax?\n+Our discussion of **traits** begins with the `impl` keyword. We used it before\n+to specify methods.\n \n ```{rust}\n struct Circle {\n@@ -4918,8 +4956,8 @@ impl Circle {\n }\n ```\n \n-Traits are similar, except that we define a trait with just the method\n-signature, then implement the trait for that struct. Like this:\n+We define a trait in terms of its methods. We then `impl` a trait `for` a type\n+(or many types).\n \n ```{rust}\n struct Circle {\n@@ -4939,19 +4977,18 @@ impl HasArea for Circle {\n }\n ```\n \n-As you can see, the `trait` block looks very similar to the `impl` block,\n-but we don't define a body, just a type signature. When we `impl` a trait,\n-we use `impl Trait for Item`, rather than just `impl Item`.\n+The `trait` block defines only type signatures. When we `impl` a trait, we use\n+`impl Trait for Item`, rather than just `impl Item`.\n \n-So what's the big deal? Remember the error we were getting with our generic\n-`inverse` function?\n+The first of the three errors we got with our generic `inverse` function was\n+this:\n \n ```text\n error: binary operation `==` cannot be applied to type `T`\n ```\n \n-We can use traits to constrain our generics. Consider this function, which\n-does not compile, and gives us a similar error:\n+We can use traits to constrain generic type parameters. Consider this function,\n+which does not compile, and gives us a similar error:\n \n ```{rust,ignore}\n fn print_area<T>(shape: T) {\n@@ -4966,8 +5003,9 @@ error: type `T` does not implement any method in scope named `area`\n ```\n \n Because `T` can be any type, we can't be sure that it implements the `area`\n-method. But we can add a **trait constraint** to our generic `T`, ensuring\n-that it does:\n+method. But we can add a **trait constraint** to our generic `T`, ensuring that\n+we can only compile the function if it's called with types which `impl` the\n+`HasArea` trait:\n \n ```{rust}\n # trait HasArea {\n@@ -4978,9 +5016,9 @@ fn print_area<T: HasArea>(shape: T) {\n }\n ```\n \n-The syntax `<T: HasArea>` means `any type that implements the HasArea trait`.\n-Because traits define function type signatures, we can be sure that any type\n-which implements `HasArea` will have an `.area()` method.\n+The syntax `<T: HasArea>` means \"any type that implements the HasArea trait.\"\n+Because traits define method signatures, we can be sure that any type which\n+implements `HasArea` will have an `area` method.\n \n Here's an extended example of how this works:\n \n@@ -5078,55 +5116,22 @@ impl HasArea for int {\n It is considered poor style to implement methods on such primitive types, even\n though it is possible.\n \n-This may seem like the Wild West, but there are two other restrictions around\n-implementing traits that prevent this from getting out of hand. First, traits\n-must be `use`d in any scope where you wish to use the trait's method. So for\n-example, this does not work:\n-\n-```{rust,ignore}\n-mod shapes {\n-    use std::f64::consts;\n-\n-    trait HasArea {\n-        fn area(&self) -> f64;\n-    }\n-\n-    struct Circle {\n-        x: f64,\n-        y: f64,\n-        radius: f64,\n-    }\n-\n-    impl HasArea for Circle {\n-        fn area(&self) -> f64 {\n-            consts::PI * (self.radius * self.radius)\n-        }\n-    }\n-}\n-\n-fn main() {\n-    let c = shapes::Circle {\n-        x: 0.0f64,\n-        y: 0.0f64,\n-        radius: 1.0f64,\n-    };\n+## Scoped Method Resolution and Orphan `impl`s\n \n-    println!(\"{}\", c.area());\n-}\n-```\n+There are two restrictions for implementing traits that prevent this from\n+getting out of hand.\n \n-Now that we've moved the structs and traits into their own module, we get an\n-error:\n+1. **Scope-based Method Resolution**: Traits must be `use`d in any scope where\n+   you wish to use the trait's methods\n+2. **No Orphan `impl`s**: Either the trait or the type you're writing the `impl`\n+   for must be inside your crate.\n \n-```text\n-error: type `shapes::Circle` does not implement any method in scope named `area`\n-```\n-\n-If we add a `use` line right above `main` and make the right things public,\n-everything is fine:\n+If we organize our crate differently by using modules, we'll need to ensure both\n+of the conditions are satisfied. Don't worry, you can lean on the compiler since\n+it won't let you get away with violating them.\n \n ```{rust}\n-use shapes::HasArea;\n+use shapes::HasArea; // satisfies #1\n \n mod shapes {\n     use std::f64::consts;\n@@ -5148,8 +5153,8 @@ mod shapes {\n     }\n }\n \n-\n fn main() {\n+    // use shapes::HasArea; // This would satisfy #1, too\n     let c = shapes::Circle {\n         x: 0.0f64,\n         y: 0.0f64,\n@@ -5160,18 +5165,25 @@ fn main() {\n }\n ```\n \n-This means that even if someone does something bad like add methods to `int`,\n-it won't affect you, unless you `use` that trait.\n+Requiring us to `use` traits whose methods we want means that even if someone\n+does something bad like add methods to `int`, it won't affect us, unless you\n+`use` that trait.\n \n-There's one more restriction on implementing traits. Either the trait or the\n-type you're writing the `impl` for must be inside your crate. So, we could\n-implement the `HasArea` type for `int`, because `HasArea` is in our crate.  But\n-if we tried to implement `Float`, a trait provided by Rust, for `int`, we could\n-not, because both the trait and the type aren't in our crate.\n+The second condition allows us to `impl` built-in `trait`s for types we define,\n+or allows us to `impl` our own `trait`s for built-in types, but restricts us\n+from mixing and matching third party or built-in `impl`s with third party or\n+built-in types.\n \n-One last thing about traits: generic functions with a trait bound use\n-**monomorphization** (\"mono\": one, \"morph\": form), so they are statically\n-dispatched. What's that mean? Well, let's take a look at `print_area` again:\n+We could `impl` the `HasArea` trait for `int`, because `HasArea` is in our\n+crate. But if we tried to implement `Float`, a standard library `trait`, for\n+`int`, we could not, because neither the `trait` nor the `type` are in our\n+crate.\n+\n+## Monomorphization\n+\n+One last thing about generics and traits: the compiler performs\n+**monomorphization** on generic functions so they are statically dispatched. To\n+see what that means, let's take a look at `print_area` again:\n \n ```{rust,ignore}\n fn print_area<T: HasArea>(shape: T) {\n@@ -5188,10 +5200,11 @@ fn main() {\n }\n ```\n \n-When we use this trait with `Circle` and `Square`, Rust ends up generating\n-two different functions with the concrete type, and replacing the call sites with\n-calls to the concrete implementations. In other words, you get something like\n-this:\n+Because we have called `print_area` with two different types in place of its\n+type paramater `T`, Rust will generate two versions of the function with the\n+appropriate concrete types, replacing the call sites with calls to the concrete\n+implementations. In other words, the compiler will actually compile something\n+more like this:\n \n ```{rust,ignore}\n fn __print_area_circle(shape: Circle) {\n@@ -5212,12 +5225,14 @@ fn main() {\n }\n ```\n \n-The names don't actually change to this, it's just for illustration. But\n-as you can see, there's no overhead of deciding which version to call here,\n-hence 'statically dispatched'. The downside is that we have two copies of\n-the same function, so our binary is a little bit larger.\n+These names are for illustration; the compiler will generate its own cryptic\n+names for internal uses. The point is that there is no runtime overhead of\n+deciding which version to call. The function to be called is determined\n+statically, at compile time. Thus, generic functions are **statically\n+dispatched**. The downside is that we have two similar functions, so our binary\n+is larger.\n \n-# Threads \n+# Threads\n \n Concurrency and parallelism are topics that are of increasing interest to a\n broad subsection of software developers. Modern computers are often multi-core,\n@@ -5312,6 +5327,7 @@ example, if you wish to compute some value in the background, `Future` is\n a useful thing to use:\n \n ```{rust}\n+# #![allow(deprecated)]\n use std::sync::Future;\n \n let mut delayed_value = Future::spawn(move || {"}, {"sha": "a8abb595034b5d7b54fb0b7e94d4d736cdbac314", "filename": "src/doc/reference.md", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -1480,9 +1480,9 @@ data are being stored, or single-address and mutability properties are required.\n ```\n use std::sync::atomic;\n \n-// Note that INIT_ATOMIC_UINT is a *const*, but it may be used to initialize a\n+// Note that ATOMIC_UINT_INIT is a *const*, but it may be used to initialize a\n // static. This static can be modified, so it is not placed in read-only memory.\n-static COUNTER: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+static COUNTER: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n \n // This table is a candidate to be placed in read-only memory.\n static TABLE: &'static [uint] = &[1, 2, 3, /* ... */];\n@@ -2561,6 +2561,9 @@ The currently implemented features of the reference compiler are:\n                 if the system linker is not used then specifying custom flags\n                 doesn't have much meaning.\n \n+* `link_llvm_intrinsics` \u2013 Allows linking to LLVM intrinsics via\n+                           `#[link_name=\"llvm.*\"]`.\n+\n * `linkage` - Allows use of the `linkage` attribute, which is not portable.\n \n * `log_syntax` - Allows use of the `log_syntax` macro attribute, which is a\n@@ -4149,11 +4152,11 @@ Unwinding the stack of a thread is done by the thread itself, on its own control\n stack. If a value with a destructor is freed during unwinding, the code for the\n destructor is run, also on the thread's control stack. Running the destructor\n code causes a temporary transition to a *running* state, and allows the\n-destructor code to cause any subsequent state transitions. The original thread \n+destructor code to cause any subsequent state transitions. The original thread\n of unwinding and panicking thereby may suspend temporarily, and may involve\n (recursive) unwinding of the stack of a failed destructor. Nonetheless, the\n outermost unwinding activity will continue until the stack is unwound and the\n-thread transitions to the *dead* state. There is no way to \"recover\" from thread \n+thread transitions to the *dead* state. There is no way to \"recover\" from thread\n panics. Once a thread has temporarily suspended its unwinding in the *panicking*\n state, a panic occurring from within this destructor results in *hard* panic.\n A hard panic currently results in the process aborting."}, {"sha": "9ac0acc38a73e8b61c47694177aee91c87c95f6e", "filename": "src/etc/licenseck.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Fetc%2Flicenseck.py", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Fetc%2Flicenseck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flicenseck.py?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -38,8 +38,8 @@\n     \"rt/isaac/randport.cpp\", # public domain\n     \"rt/isaac/rand.h\", # public domain\n     \"rt/isaac/standard.h\", # public domain\n-    \"libstd/comm/mpsc_queue.rs\", # BSD\n-    \"libstd/comm/spsc_queue.rs\", # BSD\n+    \"libstd/sync/mpsc/mpsc_queue.rs\", # BSD\n+    \"libstd/sync/mpsc/spsc_queue.rs\", # BSD\n     \"test/bench/shootout-binarytrees.rs\", # BSD\n     \"test/bench/shootout-chameneos-redux.rs\", # BSD\n     \"test/bench/shootout-fannkuch-redux.rs\", # BSD"}, {"sha": "59106aa97772a4da6f0697d19092e8abd03c0509", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -247,7 +247,9 @@ impl<T> BorrowFrom<Arc<T>> for T {\n }\n \n #[experimental = \"Deref is experimental.\"]\n-impl<T> Deref<T> for Arc<T> {\n+impl<T> Deref for Arc<T> {\n+    type Target = T;\n+\n     #[inline]\n     fn deref(&self) -> &T {\n         &self.inner().data\n@@ -593,7 +595,7 @@ impl<T: Default + Sync + Send> Default for Arc<T> {\n #[allow(experimental)]\n mod tests {\n     use std::clone::Clone;\n-    use std::comm::channel;\n+    use std::sync::mpsc::channel;\n     use std::mem::drop;\n     use std::ops::Drop;\n     use std::option::Option;\n@@ -630,11 +632,11 @@ mod tests {\n         let (tx, rx) = channel();\n \n         task::spawn(move || {\n-            let arc_v: Arc<Vec<int>> = rx.recv();\n+            let arc_v: Arc<Vec<int>> = rx.recv().unwrap();\n             assert_eq!((*arc_v)[3], 4);\n         });\n \n-        tx.send(arc_v.clone());\n+        tx.send(arc_v.clone()).unwrap();\n \n         assert_eq!((*arc_v)[2], 3);\n         assert_eq!((*arc_v)[4], 5);"}, {"sha": "e836b08459bb8032a67e0b4033031b44c52ee2f6", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -10,6 +10,8 @@\n \n //! A unique pointer type.\n \n+#![stable]\n+\n use core::any::{Any, AnyRefExt};\n use core::clone::Clone;\n use core::cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering};\n@@ -44,7 +46,7 @@ pub static HEAP: () = ();\n \n /// A type that represents a uniquely-owned value.\n #[lang = \"owned_box\"]\n-#[unstable = \"custom allocators will add an additional type parameter (with default)\"]\n+#[stable]\n pub struct Box<T>(Unique<T>);\n \n #[stable]\n@@ -111,20 +113,20 @@ impl<S: hash::Writer, Sized? T: Hash<S>> Hash<S> for Box<T> {\n     }\n }\n \n-\n /// Extension methods for an owning `Any` trait object.\n #[unstable = \"post-DST and coherence changes, this will not be a trait but \\\n               rather a direct `impl` on `Box<Any>`\"]\n pub trait BoxAny {\n     /// Returns the boxed value if it is of type `T`, or\n     /// `Err(Self)` if it isn't.\n-    #[unstable = \"naming conventions around accessing innards may change\"]\n+    #[stable]\n     fn downcast<T: 'static>(self) -> Result<Box<T>, Self>;\n }\n \n-#[stable]\n impl BoxAny for Box<Any> {\n     #[inline]\n+    #[unstable = \"method may be renamed with respect to other downcasting \\\n+                  methods\"]\n     fn downcast<T: 'static>(self) -> Result<Box<T>, Box<Any>> {\n         if self.is::<T>() {\n             unsafe {\n@@ -147,17 +149,19 @@ impl<Sized? T: fmt::Show> fmt::Show for Box<T> {\n     }\n }\n \n-impl fmt::Show for Box<Any+'static> {\n+impl fmt::Show for Box<Any> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"Box<Any>\")\n     }\n }\n \n-impl<Sized? T> Deref<T> for Box<T> {\n+impl<Sized? T> Deref for Box<T> {\n+    type Target = T;\n+\n     fn deref(&self) -> &T { &**self }\n }\n \n-impl<Sized? T> DerefMut<T> for Box<T> {\n+impl<Sized? T> DerefMut for Box<T> {\n     fn deref_mut(&mut self) -> &mut T { &mut **self }\n }\n \n@@ -210,7 +214,7 @@ mod test {\n \n     #[test]\n     fn deref() {\n-        fn homura<T: Deref<i32>>(_: T) { }\n+        fn homura<T: Deref<Target=i32>>(_: T) { }\n         homura(box 765i32);\n     }\n }"}, {"sha": "aab513ddeb7b1fc0a1302e12da4c430a34aba9aa", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -64,7 +64,9 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![no_std]\n-#![feature(lang_items, phase, unsafe_destructor, default_type_params)]\n+#![allow(unknown_features)]\n+#![feature(lang_items, phase, unsafe_destructor, default_type_params, old_orphan_check)]\n+#![feature(associated_types)]\n \n #[phase(plugin, link)]\n extern crate core;"}, {"sha": "c57231fc434cd5701d9a01840bdcfacf04d22e60", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -355,7 +355,9 @@ impl<T> BorrowFrom<Rc<T>> for T {\n }\n \n #[experimental = \"Deref is experimental.\"]\n-impl<T> Deref<T> for Rc<T> {\n+impl<T> Deref for Rc<T> {\n+    type Target = T;\n+\n     #[inline(always)]\n     fn deref(&self) -> &T {\n         &self.inner().value"}, {"sha": "f748c8ad1eb2a24b10628eb0a1276e84a744a3d1", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -26,6 +26,7 @@\n //! [dir_graph]: http://en.wikipedia.org/wiki/Directed_graph\n //!\n //! ```\n+//! use std::cmp::Ordering;\n //! use std::collections::BinaryHeap;\n //! use std::uint;\n //!\n@@ -151,6 +152,7 @@\n use core::prelude::*;\n \n use core::default::Default;\n+use core::iter::FromIterator;\n use core::mem::{zeroed, replace, swap};\n use core::ptr;\n "}, {"sha": "6ea624df0343994e4705eba76774dce842ac30c5", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -82,17 +82,20 @@\n \n use core::prelude::*;\n \n+use core::cmp::Ordering;\n use core::cmp;\n use core::default::Default;\n use core::fmt;\n-use core::iter::{Cloned, Chain, Enumerate, Repeat, Skip, Take, repeat};\n-use core::iter;\n+use core::hash;\n+use core::iter::RandomAccessIterator;\n+use core::iter::{Chain, Enumerate, Repeat, Skip, Take, repeat, Cloned};\n+use core::iter::{mod, FromIterator};\n use core::num::Int;\n+use core::ops::Index;\n use core::slice;\n use core::{u8, u32, uint};\n use bitv_set; //so meta\n \n-use core::hash;\n use Vec;\n \n type Blocks<'a> = Cloned<slice::Iter<'a, u32>>;\n@@ -2507,7 +2510,7 @@ mod tests {\n \n #[cfg(test)]\n mod bitv_bench {\n-    use std::prelude::*;\n+    use std::prelude::v1::*;\n     use std::rand;\n     use std::rand::Rng;\n     use std::u32;\n@@ -3002,7 +3005,7 @@ mod bitv_set_test {\n \n #[cfg(test)]\n mod bitv_set_bench {\n-    use std::prelude::*;\n+    use std::prelude::v1::*;\n     use std::rand;\n     use std::rand::Rng;\n     use std::u32;"}, {"sha": "da98c19e888fa3e1785eac81aac82e01bf409459", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -19,21 +19,23 @@ pub use self::Entry::*;\n \n use core::prelude::*;\n \n-use self::StackOp::*;\n-use super::node::{mod, Node, Found, GoDown};\n-use super::node::{Traversal, MutTraversal, MoveTraversal};\n-use super::node::TraversalItem::{mod, Elem, Edge};\n-use super::node::ForceResult::{Leaf, Internal};\n use core::borrow::BorrowFrom;\n-use std::hash::{Writer, Hash};\n+use core::cmp::Ordering;\n use core::default::Default;\n-use core::{iter, fmt, mem};\n use core::fmt::Show;\n-use core::iter::Map;\n+use core::hash::{Writer, Hash};\n+use core::iter::{Map, FromIterator};\n+use core::ops::{Index, IndexMut};\n+use core::{iter, fmt, mem};\n \n use ring_buf::RingBuf;\n \n use self::Continuation::{Continue, Finished};\n+use self::StackOp::*;\n+use super::node::ForceResult::{Leaf, Internal};\n+use super::node::TraversalItem::{mod, Elem, Edge};\n+use super::node::{Traversal, MutTraversal, MoveTraversal};\n+use super::node::{mod, Node, Found, GoDown};\n \n // FIXME(conventions): implement bounded iterators\n \n@@ -501,6 +503,7 @@ mod stack {\n     use core::prelude::*;\n     use core::kinds::marker;\n     use core::mem;\n+    use core::ops::{Deref, DerefMut};\n     use super::BTreeMap;\n     use super::super::node::{mod, Node, Fit, Split, Internal, Leaf};\n     use super::super::node::handle;\n@@ -515,13 +518,15 @@ mod stack {\n         marker: marker::InvariantLifetime<'id>\n     }\n \n-    impl<'id, T> Deref<T> for IdRef<'id, T> {\n+    impl<'id, T> Deref for IdRef<'id, T> {\n+        type Target = T;\n+\n         fn deref(&self) -> &T {\n             &*self.inner\n         }\n     }\n \n-    impl<'id, T> DerefMut<T> for IdRef<'id, T> {\n+    impl<'id, T> DerefMut for IdRef<'id, T> {\n         fn deref_mut(&mut self) -> &mut T {\n             &mut *self.inner\n         }"}, {"sha": "3dddcae11ce7cb982e63ba583172646b10e5cc60", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -18,10 +18,12 @@ pub use self::TraversalItem::*;\n \n use core::prelude::*;\n \n-use core::{slice, mem, ptr, cmp, num, raw};\n-use core::iter::Zip;\n use core::borrow::BorrowFrom;\n+use core::cmp::Ordering::{Greater, Less, Equal};\n+use core::iter::Zip;\n+use core::ops::{Deref, DerefMut};\n use core::ptr::Unique;\n+use core::{slice, mem, ptr, cmp, num, raw};\n use alloc::heap;\n \n /// Represents the result of an Insertion: either the item fit, or the node had to split\n@@ -455,7 +457,9 @@ impl<K: Clone, V: Clone> Clone for Node<K, V> {\n ///     flag: &'a Cell<bool>,\n /// }\n ///\n-/// impl<'a> Deref<Node<uint, uint>> for Nasty<'a> {\n+/// impl<'a> Deref for Nasty<'a> {\n+///     type Target = Node<uint, uint>;\n+///\n ///     fn deref(&self) -> &Node<uint, uint> {\n ///         if self.flag.get() {\n ///             &*self.second\n@@ -511,7 +515,7 @@ impl<K: Ord, V> Node<K, V> {\n     /// Searches for the given key in the node. If it finds an exact match,\n     /// `Found` will be yielded with the matching index. If it doesn't find an exact match,\n     /// `GoDown` will be yielded with the index of the subtree the key must lie in.\n-    pub fn search<Sized? Q, NodeRef: Deref<Node<K, V>>>(node: NodeRef, key: &Q)\n+    pub fn search<Sized? Q, NodeRef: Deref<Target=Node<K, V>>>(node: NodeRef, key: &Q)\n                   -> SearchResult<NodeRef> where Q: BorrowFrom<K> + Ord {\n         // FIXME(Gankro): Tune when to search linear or binary based on B (and maybe K/V).\n         // For the B configured as of this writing (B = 6), binary search was *significantly*\n@@ -588,7 +592,7 @@ impl <K, V> Node<K, V> {\n     }\n }\n \n-impl<K, V, NodeRef: Deref<Node<K, V>>, Type, NodeType> Handle<NodeRef, Type, NodeType> {\n+impl<K, V, NodeRef: Deref<Target=Node<K, V>>, Type, NodeType> Handle<NodeRef, Type, NodeType> {\n     /// Returns a reference to the node that contains the pointed-to edge or key/value pair. This\n     /// is very different from `edge` and `edge_mut` because those return children of the node\n     /// returned by `node`.\n@@ -597,7 +601,9 @@ impl<K, V, NodeRef: Deref<Node<K, V>>, Type, NodeType> Handle<NodeRef, Type, Nod\n     }\n }\n \n-impl<K, V, NodeRef: DerefMut<Node<K, V>>, Type, NodeType> Handle<NodeRef, Type, NodeType> {\n+impl<K, V, NodeRef, Type, NodeType> Handle<NodeRef, Type, NodeType> where\n+    NodeRef: Deref<Target=Node<K, V>> + DerefMut,\n+{\n     /// Converts a handle into one that stores the same information using a raw pointer. This can\n     /// be useful in conjunction with `from_raw` when the type system is insufficient for\n     /// determining the lifetimes of the nodes.\n@@ -653,7 +659,7 @@ impl<'a, K: 'a, V: 'a> Handle<&'a mut Node<K, V>, handle::Edge, handle::Internal\n     }\n }\n \n-impl<K, V, NodeRef: Deref<Node<K, V>>> Handle<NodeRef, handle::Edge, handle::Internal> {\n+impl<K, V, NodeRef: Deref<Target=Node<K, V>>> Handle<NodeRef, handle::Edge, handle::Internal> {\n     // This doesn't exist because there are no uses for it,\n     // but is fine to add, analagous to edge_mut.\n     //\n@@ -667,7 +673,7 @@ pub enum ForceResult<NodeRef, Type> {\n     Internal(Handle<NodeRef, Type, handle::Internal>)\n }\n \n-impl<K, V, NodeRef: Deref<Node<K, V>>, Type> Handle<NodeRef, Type, handle::LeafOrInternal> {\n+impl<K, V, NodeRef: Deref<Target=Node<K, V>>, Type> Handle<NodeRef, Type, handle::LeafOrInternal> {\n     /// Figure out whether this handle is pointing to something in a leaf node or to something in\n     /// an internal node, clarifying the type according to the result.\n     pub fn force(self) -> ForceResult<NodeRef, Type> {\n@@ -684,8 +690,9 @@ impl<K, V, NodeRef: Deref<Node<K, V>>, Type> Handle<NodeRef, Type, handle::LeafO\n         }\n     }\n }\n-\n-impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, handle::Edge, handle::Leaf> {\n+impl<K, V, NodeRef> Handle<NodeRef, handle::Edge, handle::Leaf> where\n+    NodeRef: Deref<Target=Node<K, V>> + DerefMut,\n+{\n     /// Tries to insert this key-value pair at the given index in this leaf node\n     /// If the node is full, we have to split it.\n     ///\n@@ -717,7 +724,9 @@ impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, handle::Edge, handle::\n     }\n }\n \n-impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, handle::Edge, handle::Internal> {\n+impl<K, V, NodeRef> Handle<NodeRef, handle::Edge, handle::Internal> where\n+    NodeRef: Deref<Target=Node<K, V>> + DerefMut,\n+{\n     /// Returns a mutable reference to the edge pointed-to by this handle. This should not be\n     /// confused with `node`, which references the parent node of what is returned here.\n     pub fn edge_mut(&mut self) -> &mut Node<K, V> {\n@@ -800,7 +809,9 @@ impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, handle::Edge, handle::\n     }\n }\n \n-impl<K, V, NodeRef: DerefMut<Node<K, V>>, NodeType> Handle<NodeRef, handle::Edge, NodeType> {\n+impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::Edge, NodeType> where\n+    NodeRef: Deref<Target=Node<K, V>> + DerefMut,\n+{\n     /// Gets the handle pointing to the key/value pair just to the left of the pointed-to edge.\n     /// This is unsafe because the handle might point to the first edge in the node, which has no\n     /// pair to its left.\n@@ -862,7 +873,7 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a mut Node<K, V>, handle::KV, NodeType\n     }\n }\n \n-impl<'a, K: 'a, V: 'a, NodeRef: Deref<Node<K, V>> + 'a, NodeType> Handle<NodeRef, handle::KV,\n+impl<'a, K: 'a, V: 'a, NodeRef: Deref<Target=Node<K, V>> + 'a, NodeType> Handle<NodeRef, handle::KV,\n                                                                          NodeType> {\n     // These are fine to include, but are currently unneeded.\n     //\n@@ -881,8 +892,9 @@ impl<'a, K: 'a, V: 'a, NodeRef: Deref<Node<K, V>> + 'a, NodeType> Handle<NodeRef\n     // }\n }\n \n-impl<'a, K: 'a, V: 'a, NodeRef: DerefMut<Node<K, V>> + 'a, NodeType> Handle<NodeRef, handle::KV,\n-                                                                            NodeType> {\n+impl<'a, K: 'a, V: 'a, NodeRef, NodeType> Handle<NodeRef, handle::KV, NodeType> where\n+    NodeRef: 'a + Deref<Target=Node<K, V>> + DerefMut,\n+{\n     /// Returns a mutable reference to the key pointed-to by this handle. This doesn't return a\n     /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n     /// handle.\n@@ -898,7 +910,9 @@ impl<'a, K: 'a, V: 'a, NodeRef: DerefMut<Node<K, V>> + 'a, NodeType> Handle<Node\n     }\n }\n \n-impl<K, V, NodeRef: DerefMut<Node<K, V>>, NodeType> Handle<NodeRef, handle::KV, NodeType> {\n+impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::KV, NodeType> where\n+    NodeRef: Deref<Target=Node<K, V>> + DerefMut,\n+{\n     /// Gets the handle pointing to the edge immediately to the left of the key/value pair pointed\n     /// to by this handle.\n     pub fn left_edge<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::Edge, NodeType> {\n@@ -918,7 +932,9 @@ impl<K, V, NodeRef: DerefMut<Node<K, V>>, NodeType> Handle<NodeRef, handle::KV,\n     }\n }\n \n-impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, handle::KV, handle::Leaf> {\n+impl<K, V, NodeRef> Handle<NodeRef, handle::KV, handle::Leaf> where\n+    NodeRef: Deref<Target=Node<K, V>> + DerefMut,\n+{\n     /// Removes the key/value pair at the handle's location.\n     ///\n     /// # Panics (in debug build)\n@@ -929,7 +945,9 @@ impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, handle::KV, handle::Le\n     }\n }\n \n-impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, handle::KV, handle::Internal> {\n+impl<K, V, NodeRef> Handle<NodeRef, handle::KV, handle::Internal> where\n+    NodeRef: Deref<Target=Node<K, V>> + DerefMut\n+{\n     /// Steal! Stealing is roughly analogous to a binary tree rotation.\n     /// In this case, we're \"rotating\" right.\n     unsafe fn steal_rightward(&mut self) {"}, {"sha": "3e8988530e63e147302f2f7b38ae6860bc6b791c", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -13,13 +13,16 @@\n \n use core::prelude::*;\n \n-use btree_map::{BTreeMap, Keys};\n-use std::hash::Hash;\n use core::borrow::BorrowFrom;\n+use core::cmp::Ordering::{mod, Less, Greater, Equal};\n use core::default::Default;\n-use core::fmt;\n-use core::iter::{Peekable, Map};\n use core::fmt::Show;\n+use core::fmt;\n+use core::hash::Hash;\n+use core::iter::{Peekable, Map, FromIterator};\n+use core::ops::{BitOr, BitAnd, BitXor, Sub};\n+\n+use btree_map::{BTreeMap, Keys};\n \n // FIXME(conventions): implement bounded iterators\n "}, {"sha": "68acbfcb3c3c80d412811d4341e25db7887d59b6", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -22,12 +22,13 @@\n use core::prelude::*;\n \n use alloc::boxed::Box;\n+use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt;\n-use core::iter;\n+use core::hash::{Writer, Hash};\n+use core::iter::{mod, FromIterator};\n use core::mem;\n use core::ptr;\n-use std::hash::{Writer, Hash};\n \n /// A doubly-linked list.\n #[stable]"}, {"sha": "ea3d8659f54a471706edc038ffa5174a7dd0f885", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -16,6 +16,8 @@\n use core::prelude::*;\n use core::fmt;\n use core::num::Int;\n+use core::iter::FromIterator;\n+use core::ops::{Sub, BitOr, BitAnd, BitXor};\n \n // FIXME(contentions): implement union family of methods? (general design may be wrong here)\n "}, {"sha": "fac9ab8107a72fbc5578b7c1e144123660b4766d", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -25,6 +25,8 @@\n #![feature(macro_rules, default_type_params, phase, globs)]\n #![feature(unsafe_destructor, slicing_syntax)]\n #![feature(unboxed_closures)]\n+#![feature(old_orphan_check)]\n+#![feature(associated_types)]\n #![no_std]\n \n #[phase(plugin, link)] extern crate core;\n@@ -120,7 +122,6 @@ mod prelude {\n     pub use core::result::Result::{Ok, Err};\n \n     // in core and collections (may differ).\n-    pub use slice::{PartialEqSliceExt, OrdSliceExt};\n     pub use slice::{AsSlice, SliceExt};\n     pub use str::{from_str, Str, StrExt};\n \n@@ -129,7 +130,7 @@ mod prelude {\n     pub use unicode::char::UnicodeChar;\n \n     // from collections.\n-    pub use slice::{CloneSliceExt, SliceConcatExt};\n+    pub use slice::SliceConcatExt;\n     pub use str::IntoMaybeOwned;\n     pub use string::{String, ToString};\n     pub use vec::Vec;"}, {"sha": "e4c9e51a8455b46f4eb7e31e312527d8056fac39", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -14,14 +14,16 @@\n \n use core::prelude::*;\n \n+use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt;\n-use core::iter;\n-use core::raw::Slice as RawSlice;\n-use core::ptr;\n+use core::iter::{mod, FromIterator, RandomAccessIterator};\n use core::kinds::marker;\n use core::mem;\n use core::num::{Int, UnsignedInt};\n+use core::ops::{Index, IndexMut};\n+use core::ptr;\n+use core::raw::Slice as RawSlice;\n \n use std::hash::{Writer, Hash};\n use std::cmp;"}, {"sha": "1c1b48f8cef678d05dae6d9751564dbadd8b102d", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 269, "deletions": 242, "changes": 511, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -89,22 +89,26 @@\n \n use alloc::boxed::Box;\n use core::borrow::{BorrowFrom, BorrowFromMut, ToOwned};\n-use core::cmp;\n-use core::iter::{range_step, MultiplicativeIterator};\n+use core::clone::Clone;\n+use core::cmp::Ordering::{mod, Greater, Less};\n+use core::cmp::{mod, Ord, PartialEq};\n+use core::iter::{Iterator, IteratorExt, IteratorCloneExt};\n+use core::iter::{range, range_step, MultiplicativeIterator};\n use core::kinds::Sized;\n use core::mem::size_of;\n use core::mem;\n-use core::ops::{FnMut,SliceMut};\n-use core::prelude::{Clone, Greater, Iterator, IteratorExt, Less, None, Option};\n-use core::prelude::{Ord, Ordering, PtrExt, Some, range, IteratorCloneExt, Result};\n+use core::ops::{FnMut, SliceMut};\n+use core::option::Option::{mod, Some, None};\n+use core::ptr::PtrExt;\n use core::ptr;\n+use core::result::Result;\n use core::slice as core_slice;\n use self::Direction::*;\n \n use vec::Vec;\n \n pub use core::slice::{Chunks, AsSlice, Windows};\n-pub use core::slice::{Iter, IterMut, PartialEqSliceExt};\n+pub use core::slice::{Iter, IterMut};\n pub use core::slice::{IntSliceExt, SplitMut, ChunksMut, Split};\n pub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};\n pub use core::slice::{bytes, mut_ref_slice, ref_slice};\n@@ -122,7 +126,9 @@ pub type MutItems<'a, T:'a> = IterMut<'a, T>;\n \n /// Allocating extension methods for slices.\n #[unstable = \"needs associated types, may merge with other traits\"]\n-pub trait SliceExt<T> for Sized? {\n+pub trait SliceExt for Sized? {\n+    type Item;\n+\n     /// Sorts the slice, in place, using `compare` to compare\n     /// elements.\n     ///\n@@ -141,7 +147,7 @@ pub trait SliceExt<T> for Sized? {\n     /// assert!(v == [5, 4, 3, 2, 1]);\n     /// ```\n     #[stable]\n-    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering;\n+    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&Self::Item, &Self::Item) -> Ordering;\n \n     /// Consumes `src` and moves as many elements as it can into `self`\n     /// from the range [start,end).\n@@ -165,7 +171,7 @@ pub trait SliceExt<T> for Sized? {\n     /// assert!(a == [6i, 7, 8, 4, 5]);\n     /// ```\n     #[experimental = \"uncertain about this API approach\"]\n-    fn move_from(&mut self, src: Vec<T>, start: uint, end: uint) -> uint;\n+    fn move_from(&mut self, src: Vec<Self::Item>, start: uint, end: uint) -> uint;\n \n     /// Returns a subslice spanning the interval [`start`, `end`).\n     ///\n@@ -174,23 +180,23 @@ pub trait SliceExt<T> for Sized? {\n     ///\n     /// Slicing with `start` equal to `end` yields an empty slice.\n     #[experimental = \"will be replaced by slice syntax\"]\n-    fn slice(&self, start: uint, end: uint) -> &[T];\n+    fn slice(&self, start: uint, end: uint) -> &[Self::Item];\n \n     /// Returns a subslice from `start` to the end of the slice.\n     ///\n     /// Panics when `start` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing from `self.len()` yields an empty slice.\n     #[experimental = \"will be replaced by slice syntax\"]\n-    fn slice_from(&self, start: uint) -> &[T];\n+    fn slice_from(&self, start: uint) -> &[Self::Item];\n \n     /// Returns a subslice from the start of the slice to `end`.\n     ///\n     /// Panics when `end` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing to `0` yields an empty slice.\n     #[experimental = \"will be replaced by slice syntax\"]\n-    fn slice_to(&self, end: uint) -> &[T];\n+    fn slice_to(&self, end: uint) -> &[Self::Item];\n \n     /// Divides one slice into two at an index.\n     ///\n@@ -200,32 +206,32 @@ pub trait SliceExt<T> for Sized? {\n     ///\n     /// Panics if `mid > len`.\n     #[stable]\n-    fn split_at(&self, mid: uint) -> (&[T], &[T]);\n+    fn split_at(&self, mid: uint) -> (&[Self::Item], &[Self::Item]);\n \n     /// Returns an iterator over the slice\n     #[stable]\n-    fn iter(&self) -> Iter<T>;\n+    fn iter(&self) -> Iter<Self::Item>;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`.  The matched element is not contained in the subslices.\n     #[stable]\n-    fn split<F>(&self, pred: F) -> Split<T, F>\n-                where F: FnMut(&T) -> bool;\n+    fn split<F>(&self, pred: F) -> Split<Self::Item, F>\n+                where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`, limited to splitting at most `n` times.  The matched element is\n     /// not contained in the subslices.\n     #[stable]\n-    fn splitn<F>(&self, n: uint, pred: F) -> SplitN<T, F>\n-                 where F: FnMut(&T) -> bool;\n+    fn splitn<F>(&self, n: uint, pred: F) -> SplitN<Self::Item, F>\n+                 where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to splitting at most `n` times. This starts at the end of\n     /// the slice and works backwards.  The matched element is not contained in\n     /// the subslices.\n     #[stable]\n-    fn rsplitn<F>(&self, n: uint, pred: F) -> RSplitN<T, F>\n-                  where F: FnMut(&T) -> bool;\n+    fn rsplitn<F>(&self, n: uint, pred: F) -> RSplitN<Self::Item, F>\n+                  where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over all contiguous windows of length\n     /// `size`. The windows overlap. If the slice is shorter than\n@@ -247,7 +253,7 @@ pub trait SliceExt<T> for Sized? {\n     /// }\n     /// ```\n     #[stable]\n-    fn windows(&self, size: uint) -> Windows<T>;\n+    fn windows(&self, size: uint) -> Windows<Self::Item>;\n \n     /// Returns an iterator over `size` elements of the slice at a\n     /// time. The chunks do not overlap. If `size` does not divide the\n@@ -270,41 +276,41 @@ pub trait SliceExt<T> for Sized? {\n     /// }\n     /// ```\n     #[stable]\n-    fn chunks(&self, size: uint) -> Chunks<T>;\n+    fn chunks(&self, size: uint) -> Chunks<Self::Item>;\n \n     /// Returns the element of a slice at the given index, or `None` if the\n     /// index is out of bounds.\n     #[stable]\n-    fn get(&self, index: uint) -> Option<&T>;\n+    fn get(&self, index: uint) -> Option<&Self::Item>;\n \n     /// Returns the first element of a slice, or `None` if it is empty.\n     #[stable]\n-    fn first(&self) -> Option<&T>;\n+    fn first(&self) -> Option<&Self::Item>;\n \n     /// Deprecated: renamed to `first`.\n     #[deprecated = \"renamed to `first`\"]\n-    fn head(&self) -> Option<&T> { self.first() }\n+    fn head(&self) -> Option<&Self::Item> { self.first() }\n \n     /// Returns all but the first element of a slice.\n     #[experimental = \"likely to be renamed\"]\n-    fn tail(&self) -> &[T];\n+    fn tail(&self) -> &[Self::Item];\n \n     /// Returns all but the last element of a slice.\n     #[experimental = \"likely to be renamed\"]\n-    fn init(&self) -> &[T];\n+    fn init(&self) -> &[Self::Item];\n \n     /// Returns the last element of a slice, or `None` if it is empty.\n     #[stable]\n-    fn last(&self) -> Option<&T>;\n+    fn last(&self) -> Option<&Self::Item>;\n \n     /// Returns a pointer to the element at the given index, without doing\n     /// bounds checking.\n     #[stable]\n-    unsafe fn get_unchecked(&self, index: uint) -> &T;\n+    unsafe fn get_unchecked(&self, index: uint) -> &Self::Item;\n \n     /// Deprecated: renamed to `get_unchecked`.\n     #[deprecated = \"renamed to get_unchecked\"]\n-    unsafe fn unsafe_get(&self, index: uint) -> &T {\n+    unsafe fn unsafe_get(&self, index: uint) -> &Self::Item {\n         self.get_unchecked(index)\n     }\n \n@@ -316,7 +322,7 @@ pub trait SliceExt<T> for Sized? {\n     /// Modifying the slice may cause its buffer to be reallocated, which\n     /// would also make any pointers to it invalid.\n     #[stable]\n-    fn as_ptr(&self) -> *const T;\n+    fn as_ptr(&self) -> *const Self::Item;\n \n     /// Binary search a sorted slice with a comparator function.\n     ///\n@@ -352,7 +358,7 @@ pub trait SliceExt<T> for Sized? {\n     /// ```\n     #[stable]\n     fn binary_search_by<F>(&self, f: F) -> Result<uint, uint> where\n-        F: FnMut(&T) -> Ordering;\n+        F: FnMut(&Self::Item) -> Ordering;\n \n     /// Return the number of elements in the slice\n     ///\n@@ -379,12 +385,12 @@ pub trait SliceExt<T> for Sized? {\n     /// Returns a mutable reference to the element at the given index,\n     /// or `None` if the index is out of bounds\n     #[stable]\n-    fn get_mut(&mut self, index: uint) -> Option<&mut T>;\n+    fn get_mut(&mut self, index: uint) -> Option<&mut Self::Item>;\n \n     /// Work with `self` as a mut slice.\n     /// Primarily intended for getting a &mut [T] from a [T; N].\n     #[stable]\n-    fn as_mut_slice(&mut self) -> &mut [T];\n+    fn as_mut_slice(&mut self) -> &mut [Self::Item];\n \n     /// Returns a mutable subslice spanning the interval [`start`, `end`).\n     ///\n@@ -393,70 +399,70 @@ pub trait SliceExt<T> for Sized? {\n     ///\n     /// Slicing with `start` equal to `end` yields an empty slice.\n     #[experimental = \"will be replaced by slice syntax\"]\n-    fn slice_mut(&mut self, start: uint, end: uint) -> &mut [T];\n+    fn slice_mut(&mut self, start: uint, end: uint) -> &mut [Self::Item];\n \n     /// Returns a mutable subslice from `start` to the end of the slice.\n     ///\n     /// Panics when `start` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing from `self.len()` yields an empty slice.\n     #[experimental = \"will be replaced by slice syntax\"]\n-    fn slice_from_mut(&mut self, start: uint) -> &mut [T];\n+    fn slice_from_mut(&mut self, start: uint) -> &mut [Self::Item];\n \n     /// Returns a mutable subslice from the start of the slice to `end`.\n     ///\n     /// Panics when `end` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing to `0` yields an empty slice.\n     #[experimental = \"will be replaced by slice syntax\"]\n-    fn slice_to_mut(&mut self, end: uint) -> &mut [T];\n+    fn slice_to_mut(&mut self, end: uint) -> &mut [Self::Item];\n \n     /// Returns an iterator that allows modifying each value\n     #[stable]\n-    fn iter_mut(&mut self) -> IterMut<T>;\n+    fn iter_mut(&mut self) -> IterMut<Self::Item>;\n \n     /// Returns a mutable pointer to the first element of a slice, or `None` if it is empty\n     #[stable]\n-    fn first_mut(&mut self) -> Option<&mut T>;\n+    fn first_mut(&mut self) -> Option<&mut Self::Item>;\n \n     /// Depreated: renamed to `first_mut`.\n     #[deprecated = \"renamed to first_mut\"]\n-    fn head_mut(&mut self) -> Option<&mut T> {\n+    fn head_mut(&mut self) -> Option<&mut Self::Item> {\n         self.first_mut()\n     }\n \n     /// Returns all but the first element of a mutable slice\n     #[experimental = \"likely to be renamed or removed\"]\n-    fn tail_mut(&mut self) -> &mut [T];\n+    fn tail_mut(&mut self) -> &mut [Self::Item];\n \n     /// Returns all but the last element of a mutable slice\n     #[experimental = \"likely to be renamed or removed\"]\n-    fn init_mut(&mut self) -> &mut [T];\n+    fn init_mut(&mut self) -> &mut [Self::Item];\n \n     /// Returns a mutable pointer to the last item in the slice.\n     #[stable]\n-    fn last_mut(&mut self) -> Option<&mut T>;\n+    fn last_mut(&mut self) -> Option<&mut Self::Item>;\n \n     /// Returns an iterator over mutable subslices separated by elements that\n     /// match `pred`.  The matched element is not contained in the subslices.\n     #[stable]\n-    fn split_mut<F>(&mut self, pred: F) -> SplitMut<T, F>\n-                    where F: FnMut(&T) -> bool;\n+    fn split_mut<F>(&mut self, pred: F) -> SplitMut<Self::Item, F>\n+                    where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`, limited to splitting at most `n` times.  The matched element is\n     /// not contained in the subslices.\n     #[stable]\n-    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitNMut<T, F>\n-                     where F: FnMut(&T) -> bool;\n+    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitNMut<Self::Item, F>\n+                     where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to splitting at most `n` times. This starts at the end of\n     /// the slice and works backwards.  The matched element is not contained in\n     /// the subslices.\n     #[stable]\n-    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> RSplitNMut<T, F>\n-                      where F: FnMut(&T) -> bool;\n+    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> RSplitNMut<Self::Item, F>\n+                      where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time.\n     /// The chunks are mutable and do not overlap. If `chunk_size` does\n@@ -467,7 +473,7 @@ pub trait SliceExt<T> for Sized? {\n     ///\n     /// Panics if `chunk_size` is 0.\n     #[stable]\n-    fn chunks_mut(&mut self, chunk_size: uint) -> ChunksMut<T>;\n+    fn chunks_mut(&mut self, chunk_size: uint) -> ChunksMut<Self::Item>;\n \n     /// Swaps two elements in a slice.\n     ///\n@@ -525,7 +531,7 @@ pub trait SliceExt<T> for Sized? {\n     /// }\n     /// ```\n     #[stable]\n-    fn split_at_mut(&mut self, mid: uint) -> (&mut [T], &mut [T]);\n+    fn split_at_mut(&mut self, mid: uint) -> (&mut [Self::Item], &mut [Self::Item]);\n \n     /// Reverse the order of elements in a slice, in place.\n     ///\n@@ -541,11 +547,11 @@ pub trait SliceExt<T> for Sized? {\n \n     /// Returns an unsafe mutable pointer to the element in index\n     #[stable]\n-    unsafe fn get_unchecked_mut(&mut self, index: uint) -> &mut T;\n+    unsafe fn get_unchecked_mut(&mut self, index: uint) -> &mut Self::Item;\n \n     /// Deprecated: renamed to `get_unchecked_mut`.\n     #[deprecated = \"renamed to get_unchecked_mut\"]\n-    unsafe fn unchecked_mut(&mut self, index: uint) -> &mut T {\n+    unsafe fn unchecked_mut(&mut self, index: uint) -> &mut Self::Item {\n         self.get_unchecked_mut(index)\n     }\n \n@@ -558,11 +564,179 @@ pub trait SliceExt<T> for Sized? {\n     /// would also make any pointers to it invalid.\n     #[inline]\n     #[stable]\n-    fn as_mut_ptr(&mut self) -> *mut T;\n+    fn as_mut_ptr(&mut self) -> *mut Self::Item;\n+\n+    /// Copies `self` into a new `Vec`.\n+    #[stable]\n+    fn to_vec(&self) -> Vec<Self::Item> where Self::Item: Clone;\n+\n+    /// Deprecated: use `iter().cloned().partition(f)` instead.\n+    #[deprecated = \"use iter().cloned().partition(f) instead\"]\n+    fn partitioned<F>(&self, f: F) -> (Vec<Self::Item>, Vec<Self::Item>) where\n+        Self::Item: Clone,\n+        F: FnMut(&Self::Item) -> bool;\n+\n+    /// Creates an iterator that yields every possible permutation of the\n+    /// vector in succession.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// let v = [1i, 2, 3];\n+    /// let mut perms = v.permutations();\n+    ///\n+    /// for p in perms {\n+    ///   println!(\"{}\", p);\n+    /// }\n+    /// ```\n+    ///\n+    /// Iterating through permutations one by one.\n+    ///\n+    /// ```rust\n+    /// let v = [1i, 2, 3];\n+    /// let mut perms = v.permutations();\n+    ///\n+    /// assert_eq!(Some(vec![1i, 2, 3]), perms.next());\n+    /// assert_eq!(Some(vec![1i, 3, 2]), perms.next());\n+    /// assert_eq!(Some(vec![3i, 1, 2]), perms.next());\n+    /// ```\n+    #[unstable]\n+    fn permutations(&self) -> Permutations<Self::Item> where Self::Item: Clone;\n+\n+    /// Copies as many elements from `src` as it can into `self` (the\n+    /// shorter of `self.len()` and `src.len()`). Returns the number\n+    /// of elements copied.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut dst = [0i, 0, 0];\n+    /// let src = [1i, 2];\n+    ///\n+    /// assert!(dst.clone_from_slice(&src) == 2);\n+    /// assert!(dst == [1, 2, 0]);\n+    ///\n+    /// let src2 = [3i, 4, 5, 6];\n+    /// assert!(dst.clone_from_slice(&src2) == 3);\n+    /// assert!(dst == [3i, 4, 5]);\n+    /// ```\n+    #[experimental]\n+    fn clone_from_slice(&mut self, &[Self::Item]) -> uint where Self::Item: Clone;\n+\n+    /// Sorts the slice, in place.\n+    ///\n+    /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// let mut v = [-5i, 4, 1, -3, 2];\n+    ///\n+    /// v.sort();\n+    /// assert!(v == [-5i, -3, 1, 2, 4]);\n+    /// ```\n+    #[stable]\n+    fn sort(&mut self) where Self::Item: Ord;\n+\n+    /// Binary search a sorted slice for a given element.\n+    ///\n+    /// If the value is found then `Ok` is returned, containing the\n+    /// index of the matching element; if the value is not found then\n+    /// `Err` is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n+    ///\n+    /// # Example\n+    ///\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1,4]`.\n+    ///\n+    /// ```rust\n+    /// let s = [0i, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n+    /// let s = s.as_slice();\n+    ///\n+    /// assert_eq!(s.binary_search(&13),  Ok(9));\n+    /// assert_eq!(s.binary_search(&4),   Err(7));\n+    /// assert_eq!(s.binary_search(&100), Err(13));\n+    /// let r = s.binary_search(&1);\n+    /// assert!(match r { Ok(1...4) => true, _ => false, });\n+    /// ```\n+    #[stable]\n+    fn binary_search(&self, x: &Self::Item) -> Result<uint, uint> where Self::Item: Ord;\n+\n+    /// Deprecated: use `binary_search` instead.\n+    #[deprecated = \"use binary_search instead\"]\n+    fn binary_search_elem(&self, x: &Self::Item) -> Result<uint, uint> where Self::Item: Ord {\n+        self.binary_search(x)\n+    }\n+\n+    /// Mutates the slice to the next lexicographic permutation.\n+    ///\n+    /// Returns `true` if successful and `false` if the slice is at the\n+    /// last-ordered permutation.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: &mut [_] = &mut [0i, 1, 2];\n+    /// v.next_permutation();\n+    /// let b: &mut [_] = &mut [0i, 2, 1];\n+    /// assert!(v == b);\n+    /// v.next_permutation();\n+    /// let b: &mut [_] = &mut [1i, 0, 2];\n+    /// assert!(v == b);\n+    /// ```\n+    #[unstable = \"uncertain if this merits inclusion in std\"]\n+    fn next_permutation(&mut self) -> bool where Self::Item: Ord;\n+\n+    /// Mutates the slice to the previous lexicographic permutation.\n+    ///\n+    /// Returns `true` if successful and `false` if the slice is at the\n+    /// first-ordered permutation.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: &mut [_] = &mut [1i, 0, 2];\n+    /// v.prev_permutation();\n+    /// let b: &mut [_] = &mut [0i, 2, 1];\n+    /// assert!(v == b);\n+    /// v.prev_permutation();\n+    /// let b: &mut [_] = &mut [0i, 1, 2];\n+    /// assert!(v == b);\n+    /// ```\n+    #[unstable = \"uncertain if this merits inclusion in std\"]\n+    fn prev_permutation(&mut self) -> bool where Self::Item: Ord;\n+\n+    /// Find the first index containing a matching value.\n+    #[experimental]\n+    fn position_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n+\n+    /// Find the last index containing a matching value.\n+    #[experimental]\n+    fn rposition_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n+\n+    /// Return true if the slice contains an element with the given value.\n+    #[stable]\n+    fn contains(&self, x: &Self::Item) -> bool where Self::Item: PartialEq;\n+\n+    /// Returns true if `needle` is a prefix of the slice.\n+    #[stable]\n+    fn starts_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n+\n+    /// Returns true if `needle` is a suffix of the slice.\n+    #[stable]\n+    fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n+\n+    /// Convert `self` into a vector without clones or allocation.\n+    #[experimental]\n+    fn into_vec(self: Box<Self>) -> Vec<Self::Item>;\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<T> SliceExt<T> for [T] {\n+impl<T> SliceExt for [T] {\n+    type Item = T;\n+\n     #[inline]\n     fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering {\n         merge_sort(self, compare)\n@@ -777,229 +951,82 @@ impl<T> SliceExt<T> for [T] {\n     fn as_mut_ptr(&mut self) -> *mut T {\n         core_slice::SliceExt::as_mut_ptr(self)\n     }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Extension traits for slices over specifc kinds of data\n-////////////////////////////////////////////////////////////////////////////////\n-\n-/// Extension methods for boxed slices.\n-#[experimental = \"likely to merge into SliceExt if it survives\"]\n-pub trait BoxedSliceExt<T> {\n-    /// Convert `self` into a vector without clones or allocation.\n-    #[experimental]\n-    fn into_vec(self) -> Vec<T>;\n-}\n-\n-#[experimental = \"trait is experimental\"]\n-impl<T> BoxedSliceExt<T> for Box<[T]> {\n-    fn into_vec(mut self) -> Vec<T> {\n-        unsafe {\n-            let xs = Vec::from_raw_parts(self.as_mut_ptr(), self.len(), self.len());\n-            mem::forget(self);\n-            xs\n-        }\n-    }\n-}\n-\n-/// Allocating extension methods for slices containing `Clone` elements.\n-#[unstable = \"likely to be merged into SliceExt\"]\n-pub trait CloneSliceExt<T> for Sized? {\n-    /// Copies `self` into a new `Vec`.\n-    #[stable]\n-    fn to_vec(&self) -> Vec<T>;\n-\n-    /// Deprecated: use `iter().cloned().partition(f)` instead.\n-    #[deprecated = \"use iter().cloned().partition(f) instead\"]\n-    fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool;\n-\n-    /// Creates an iterator that yields every possible permutation of the\n-    /// vector in succession.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// let v = [1i, 2, 3];\n-    /// let mut perms = v.permutations();\n-    ///\n-    /// for p in perms {\n-    ///   println!(\"{}\", p);\n-    /// }\n-    /// ```\n-    ///\n-    /// Iterating through permutations one by one.\n-    ///\n-    /// ```rust\n-    /// let v = [1i, 2, 3];\n-    /// let mut perms = v.permutations();\n-    ///\n-    /// assert_eq!(Some(vec![1i, 2, 3]), perms.next());\n-    /// assert_eq!(Some(vec![1i, 3, 2]), perms.next());\n-    /// assert_eq!(Some(vec![3i, 1, 2]), perms.next());\n-    /// ```\n-    #[unstable]\n-    fn permutations(&self) -> Permutations<T>;\n-\n-    /// Copies as many elements from `src` as it can into `self` (the\n-    /// shorter of `self.len()` and `src.len()`). Returns the number\n-    /// of elements copied.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut dst = [0i, 0, 0];\n-    /// let src = [1i, 2];\n-    ///\n-    /// assert!(dst.clone_from_slice(&src) == 2);\n-    /// assert!(dst == [1, 2, 0]);\n-    ///\n-    /// let src2 = [3i, 4, 5, 6];\n-    /// assert!(dst.clone_from_slice(&src2) == 3);\n-    /// assert!(dst == [3i, 4, 5]);\n-    /// ```\n-    #[experimental]\n-    fn clone_from_slice(&mut self, &[T]) -> uint;\n-}\n-\n \n-#[unstable = \"trait is unstable\"]\n-impl<T: Clone> CloneSliceExt<T> for [T] {\n     /// Returns a copy of `v`.\n     #[inline]\n-    fn to_vec(&self) -> Vec<T> {\n+    fn to_vec(&self) -> Vec<T> where T: Clone {\n         let mut vector = Vec::with_capacity(self.len());\n         vector.push_all(self);\n         vector\n     }\n \n \n     #[inline]\n-    fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n+    fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool, T: Clone {\n         self.iter().cloned().partition(f)\n     }\n \n     /// Returns an iterator over all permutations of a vector.\n-    fn permutations(&self) -> Permutations<T> {\n+    fn permutations(&self) -> Permutations<T> where T: Clone {\n         Permutations{\n             swaps: ElementSwaps::new(self.len()),\n             v: self.to_vec(),\n         }\n     }\n \n-    fn clone_from_slice(&mut self, src: &[T]) -> uint {\n-        core_slice::CloneSliceExt::clone_from_slice(self, src)\n+    fn clone_from_slice(&mut self, src: &[T]) -> uint where T: Clone {\n+        core_slice::SliceExt::clone_from_slice(self, src)\n     }\n-}\n \n-/// Allocating extension methods for slices on Ord values.\n-#[unstable = \"likely to merge with SliceExt\"]\n-pub trait OrdSliceExt<T> for Sized? {\n-    /// Sorts the slice, in place.\n-    ///\n-    /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// let mut v = [-5i, 4, 1, -3, 2];\n-    ///\n-    /// v.sort();\n-    /// assert!(v == [-5i, -3, 1, 2, 4]);\n-    /// ```\n-    #[stable]\n-    fn sort(&mut self);\n+    #[inline]\n+    fn sort(&mut self) where T: Ord {\n+        self.sort_by(|a, b| a.cmp(b))\n+    }\n \n-    /// Binary search a sorted slice for a given element.\n-    ///\n-    /// If the value is found then `Ok` is returned, containing the\n-    /// index of the matching element; if the value is not found then\n-    /// `Err` is returned, containing the index where a matching\n-    /// element could be inserted while maintaining sorted order.\n-    ///\n-    /// # Example\n-    ///\n-    /// Looks up a series of four elements. The first is found, with a\n-    /// uniquely determined position; the second and third are not\n-    /// found; the fourth could match any position in `[1,4]`.\n-    ///\n-    /// ```rust\n-    /// let s = [0i, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n-    /// let s = s.as_slice();\n-    ///\n-    /// assert_eq!(s.binary_search(&13),  Ok(9));\n-    /// assert_eq!(s.binary_search(&4),   Err(7));\n-    /// assert_eq!(s.binary_search(&100), Err(13));\n-    /// let r = s.binary_search(&1);\n-    /// assert!(match r { Ok(1...4) => true, _ => false, });\n-    /// ```\n-    #[stable]\n-    fn binary_search(&self, x: &T) -> Result<uint, uint>;\n+    fn binary_search(&self, x: &T) -> Result<uint, uint> where T: Ord {\n+        core_slice::SliceExt::binary_search(self, x)\n+    }\n \n-    /// Deprecated: use `binary_search` instead.\n-    #[deprecated = \"use binary_search instead\"]\n-    fn binary_search_elem(&self, x: &T) -> Result<uint, uint> {\n-        self.binary_search(x)\n+    fn next_permutation(&mut self) -> bool where T: Ord {\n+        core_slice::SliceExt::next_permutation(self)\n     }\n \n-    /// Mutates the slice to the next lexicographic permutation.\n-    ///\n-    /// Returns `true` if successful and `false` if the slice is at the\n-    /// last-ordered permutation.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: &mut [_] = &mut [0i, 1, 2];\n-    /// v.next_permutation();\n-    /// let b: &mut [_] = &mut [0i, 2, 1];\n-    /// assert!(v == b);\n-    /// v.next_permutation();\n-    /// let b: &mut [_] = &mut [1i, 0, 2];\n-    /// assert!(v == b);\n-    /// ```\n-    #[unstable = \"uncertain if this merits inclusion in std\"]\n-    fn next_permutation(&mut self) -> bool;\n+    fn prev_permutation(&mut self) -> bool where T: Ord {\n+        core_slice::SliceExt::prev_permutation(self)\n+    }\n \n-    /// Mutates the slice to the previous lexicographic permutation.\n-    ///\n-    /// Returns `true` if successful and `false` if the slice is at the\n-    /// first-ordered permutation.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: &mut [_] = &mut [1i, 0, 2];\n-    /// v.prev_permutation();\n-    /// let b: &mut [_] = &mut [0i, 2, 1];\n-    /// assert!(v == b);\n-    /// v.prev_permutation();\n-    /// let b: &mut [_] = &mut [0i, 1, 2];\n-    /// assert!(v == b);\n-    /// ```\n-    #[unstable = \"uncertain if this merits inclusion in std\"]\n-    fn prev_permutation(&mut self) -> bool;\n-}\n+    fn position_elem(&self, t: &T) -> Option<uint> where T: PartialEq {\n+        core_slice::SliceExt::position_elem(self, t)\n+    }\n \n-#[unstable = \"trait is unstable\"]\n-impl<T: Ord> OrdSliceExt<T> for [T] {\n-    #[inline]\n-    fn sort(&mut self) {\n-        self.sort_by(|a, b| a.cmp(b))\n+    fn rposition_elem(&self, t: &T) -> Option<uint> where T: PartialEq {\n+        core_slice::SliceExt::rposition_elem(self, t)\n     }\n \n-    fn binary_search(&self, x: &T) -> Result<uint, uint> {\n-        core_slice::OrdSliceExt::binary_search(self, x)\n+    fn contains(&self, x: &T) -> bool where T: PartialEq {\n+        core_slice::SliceExt::contains(self, x)\n     }\n \n-    fn next_permutation(&mut self) -> bool {\n-        core_slice::OrdSliceExt::next_permutation(self)\n+    fn starts_with(&self, needle: &[T]) -> bool where T: PartialEq {\n+        core_slice::SliceExt::starts_with(self, needle)\n     }\n \n-    fn prev_permutation(&mut self) -> bool {\n-        core_slice::OrdSliceExt::prev_permutation(self)\n+    fn ends_with(&self, needle: &[T]) -> bool where T: PartialEq {\n+        core_slice::SliceExt::ends_with(self, needle)\n+    }\n+\n+    fn into_vec(mut self: Box<Self>) -> Vec<T> {\n+        unsafe {\n+            let xs = Vec::from_raw_parts(self.as_mut_ptr(), self.len(), self.len());\n+            mem::forget(self);\n+            xs\n+        }\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// Extension traits for slices over specifc kinds of data\n+////////////////////////////////////////////////////////////////////////////////\n #[unstable = \"U should be an associated type\"]\n /// An extension trait for concatenating slices\n pub trait SliceConcatExt<Sized? T, U> for Sized? {\n@@ -1419,7 +1446,7 @@ mod tests {\n     use std::boxed::Box;\n     use prelude::{Some, None, range, Vec, ToString, Clone, Greater, Less, Equal};\n     use prelude::{SliceExt, Iterator, IteratorExt, DoubleEndedIteratorExt};\n-    use prelude::{OrdSliceExt, CloneSliceExt, PartialEqSliceExt, AsSlice};\n+    use prelude::AsSlice;\n     use prelude::{RandomAccessIterator, Ord, SliceConcatExt};\n     use core::cell::Cell;\n     use core::default::Default;"}, {"sha": "769679ec4d448e99335814f22fe4d76e0d79dadf", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -17,17 +17,18 @@\n use core::prelude::*;\n \n use core::borrow::{Cow, IntoCow};\n+use core::cmp::Equiv;\n use core::default::Default;\n use core::fmt;\n use core::hash;\n+use core::iter::FromIterator;\n use core::mem;\n+use core::ops::{mod, Deref, Add};\n use core::ptr;\n-use core::ops;\n use core::raw::Slice as RawSlice;\n use unicode::str as unicode_str;\n use unicode::str::Utf16Item;\n \n-use slice::CloneSliceExt;\n use str::{mod, CharRange, FromStr, Utf8Error};\n use vec::{DerefVec, Vec, as_vec};\n \n@@ -94,7 +95,7 @@ impl String {\n     #[inline]\n     #[experimental = \"needs investigation to see if to_string() can match perf\"]\n     pub fn from_str(string: &str) -> String {\n-        String { vec: string.as_bytes().to_vec() }\n+        String { vec: ::slice::SliceExt::to_vec(string.as_bytes()) }\n     }\n \n     /// Returns the vector as a string buffer, if possible, taking care not to\n@@ -141,14 +142,18 @@ impl String {\n     /// ```\n     #[stable]\n     pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> CowString<'a> {\n+        let mut i = 0;\n         match str::from_utf8(v) {\n             Ok(s) => return Cow::Borrowed(s),\n-            Err(..) => {}\n+            Err(e) => {\n+                if let Utf8Error::InvalidByte(firstbad) = e {\n+                    i = firstbad;\n+                }\n+            }\n         }\n \n         static TAG_CONT_U8: u8 = 128u8;\n         static REPLACEMENT: &'static [u8] = b\"\\xEF\\xBF\\xBD\"; // U+FFFD in UTF-8\n-        let mut i = 0;\n         let total = v.len();\n         fn unsafe_get(xs: &[u8], i: uint) -> u8 {\n             unsafe { *xs.get_unchecked(i) }\n@@ -172,7 +177,7 @@ impl String {\n         // subseqidx is the index of the first byte of the subsequence we're looking at.\n         // It's used to copy a bunch of contiguous good codepoints at once instead of copying\n         // them one by one.\n-        let mut subseqidx = 0;\n+        let mut subseqidx = i;\n \n         while i < total {\n             let i_ = i;\n@@ -936,7 +941,9 @@ impl ops::Slice<uint, str> for String {\n }\n \n #[experimental = \"waiting on Deref stabilization\"]\n-impl ops::Deref<str> for String {\n+impl ops::Deref for String {\n+    type Target = str;\n+\n     fn deref<'a>(&'a self) -> &'a str {\n         unsafe { mem::transmute(self.vec[]) }\n     }\n@@ -948,7 +955,9 @@ pub struct DerefString<'a> {\n     x: DerefVec<'a, u8>\n }\n \n-impl<'a> Deref<String> for DerefString<'a> {\n+impl<'a> Deref for DerefString<'a> {\n+    type Target = String;\n+\n     fn deref<'b>(&'b self) -> &'b String {\n         unsafe { mem::transmute(&*self.x) }\n     }\n@@ -995,9 +1004,11 @@ pub trait ToString {\n \n impl<T: fmt::Show> ToString for T {\n     fn to_string(&self) -> String {\n-        let mut buf = Vec::<u8>::new();\n-        let _ = fmt::write(&mut buf, format_args!(\"{}\", *self));\n-        String::from_utf8(buf).unwrap()\n+        use core::fmt::Writer;\n+        let mut buf = String::new();\n+        let _ = buf.write_fmt(format_args!(\"{}\", self));\n+        buf.shrink_to_fit();\n+        buf\n     }\n }\n \n@@ -1073,6 +1084,13 @@ impl<'a> Str for CowString<'a> {\n     }\n }\n \n+impl fmt::Writer for String {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        self.push_str(s);\n+        Ok(())\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use prelude::*;"}, {"sha": "7e36792742171166fceba37d7f735f4c4b0bc3e7", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -50,21 +50,21 @@ use alloc::boxed::Box;\n use alloc::heap::{EMPTY, allocate, reallocate, deallocate};\n use core::borrow::{Cow, IntoCow};\n use core::cmp::max;\n+use core::cmp::{Equiv, Ordering};\n use core::default::Default;\n use core::fmt;\n use core::hash::{mod, Hash};\n-use core::iter::repeat;\n+use core::iter::{repeat, FromIterator};\n use core::kinds::marker::{ContravariantLifetime, InvariantType};\n use core::mem;\n use core::nonzero::NonZero;\n use core::num::{Int, UnsignedInt};\n+use core::ops::{Index, IndexMut, Deref, Add};\n use core::ops;\n use core::ptr;\n use core::raw::Slice as RawSlice;\n use core::uint;\n \n-use slice::CloneSliceExt;\n-\n /// A growable list type, written `Vec<T>` but pronounced 'vector.'\n ///\n /// # Examples\n@@ -1218,7 +1218,7 @@ unsafe fn dealloc<T>(ptr: *mut T, len: uint) {\n \n #[unstable]\n impl<T:Clone> Clone for Vec<T> {\n-    fn clone(&self) -> Vec<T> { self.as_slice().to_vec() }\n+    fn clone(&self) -> Vec<T> { ::slice::SliceExt::to_vec(self.as_slice()) }\n \n     fn clone_from(&mut self, other: &Vec<T>) {\n         // drop anything in self that will not be overwritten\n@@ -1303,12 +1303,14 @@ impl<T> ops::SliceMut<uint, [T]> for Vec<T> {\n }\n \n #[experimental = \"waiting on Deref stability\"]\n-impl<T> ops::Deref<[T]> for Vec<T> {\n+impl<T> ops::Deref for Vec<T> {\n+    type Target = [T];\n+\n     fn deref<'a>(&'a self) -> &'a [T] { self.as_slice() }\n }\n \n #[experimental = \"waiting on DerefMut stability\"]\n-impl<T> ops::DerefMut<[T]> for Vec<T> {\n+impl<T> ops::DerefMut for Vec<T> {\n     fn deref_mut<'a>(&'a mut self) -> &'a mut [T] { self.as_mut_slice() }\n }\n \n@@ -1488,9 +1490,9 @@ impl<T:fmt::Show> fmt::Show for Vec<T> {\n     }\n }\n \n-impl<'a> fmt::FormatWriter for Vec<u8> {\n-    fn write(&mut self, buf: &[u8]) -> fmt::Result {\n-        self.push_all(buf);\n+impl<'a> fmt::Writer for Vec<u8> {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        self.push_all(s.as_bytes());\n         Ok(())\n     }\n }\n@@ -1718,7 +1720,9 @@ pub struct DerefVec<'a, T> {\n }\n \n #[experimental]\n-impl<'a, T> Deref<Vec<T>> for DerefVec<'a, T> {\n+impl<'a, T> Deref for DerefVec<'a, T> {\n+    type Target = Vec<T>;\n+\n     fn deref<'b>(&'b self) -> &'b Vec<T> {\n         &self.x\n     }\n@@ -2263,7 +2267,7 @@ mod tests {\n             }\n         }\n         const NUM_ELEMENTS: uint = 2;\n-        static DROP_COUNTER: AtomicUint = atomic::INIT_ATOMIC_UINT;\n+        static DROP_COUNTER: AtomicUint = atomic::ATOMIC_UINT_INIT;\n \n         let v = Vec::from_elem(NUM_ELEMENTS, Nothing);\n "}, {"sha": "172fd56ed3962bca413debf9c4256224dedadb16", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -15,12 +15,14 @@\n \n use core::prelude::*;\n \n+use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt;\n use core::hash::{Hash, Writer};\n+use core::iter::{Enumerate, FilterMap, Map, FromIterator};\n use core::iter;\n-use core::iter::{Enumerate, FilterMap, Map};\n use core::mem::replace;\n+use core::ops::{Index, IndexMut};\n \n use {vec, slice};\n use vec::Vec;"}, {"sha": "ba7714ad9bc8cb321b9a1db2eb0d89eac3bf9e61", "filename": "src/libcore/array.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -54,7 +54,7 @@ macro_rules! array_impls {\n             #[stable]\n             impl<'a, A, B, Rhs> PartialEq<Rhs> for [A; $N] where\n                 A: PartialEq<B>,\n-                Rhs: Deref<[B]>,\n+                Rhs: Deref<Target=[B]>,\n             {\n                 #[inline(always)]\n                 fn eq(&self, other: &Rhs) -> bool { PartialEq::eq(self[], &**other) }\n@@ -65,7 +65,7 @@ macro_rules! array_impls {\n             #[stable]\n             impl<'a, A, B, Lhs> PartialEq<[B; $N]> for Lhs where\n                 A: PartialEq<B>,\n-                Lhs: Deref<[A]>\n+                Lhs: Deref<Target=[A]>\n             {\n                 #[inline(always)]\n                 fn eq(&self, other: &[B; $N]) -> bool { PartialEq::eq(&**self, other[]) }"}, {"sha": "f653998c9bf5d471db0b65a7856614ee9634da7a", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -89,17 +89,27 @@ pub enum Ordering {\n \n /// An `AtomicBool` initialized to `false`.\n #[unstable = \"may be renamed, pending conventions for static initalizers\"]\n-pub const INIT_ATOMIC_BOOL: AtomicBool =\n+pub const ATOMIC_BOOL_INIT: AtomicBool =\n         AtomicBool { v: UnsafeCell { value: 0 } };\n /// An `AtomicInt` initialized to `0`.\n #[unstable = \"may be renamed, pending conventions for static initalizers\"]\n-pub const INIT_ATOMIC_INT: AtomicInt =\n+pub const ATOMIC_INT_INIT: AtomicInt =\n         AtomicInt { v: UnsafeCell { value: 0 } };\n /// An `AtomicUint` initialized to `0`.\n #[unstable = \"may be renamed, pending conventions for static initalizers\"]\n-pub const INIT_ATOMIC_UINT: AtomicUint =\n+pub const ATOMIC_UINT_INIT: AtomicUint =\n         AtomicUint { v: UnsafeCell { value: 0, } };\n \n+/// Deprecated\n+#[deprecated = \"renamed to ATOMIC_BOOL_INIT\"]\n+pub const INIT_ATOMIC_BOOL: AtomicBool = ATOMIC_BOOL_INIT;\n+/// Deprecated\n+#[deprecated = \"renamed to ATOMIC_INT_INIT\"]\n+pub const INIT_ATOMIC_INT: AtomicInt = ATOMIC_INT_INIT;\n+/// Deprecated\n+#[deprecated = \"renamed to ATOMIC_UINT_INIT\"]\n+pub const INIT_ATOMIC_UINT: AtomicUint = ATOMIC_UINT_INIT;\n+\n // NB: Needs to be -1 (0b11111111...) to make fetch_nand work correctly\n const UINT_TRUE: uint = -1;\n "}, {"sha": "7e4d73d598d8d8227bed2325082170b019a34f15", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -191,7 +191,9 @@ impl<'a, T, Sized? B> Cow<'a, T, B> where B: ToOwned<T> {\n     }\n }\n \n-impl<'a, T, Sized? B> Deref<B> for Cow<'a, T, B> where B: ToOwned<T>  {\n+impl<'a, T, Sized? B> Deref for Cow<'a, T, B> where B: ToOwned<T>  {\n+    type Target = B;\n+\n     fn deref(&self) -> &B {\n         match *self {\n             Borrowed(borrowed) => borrowed,"}, {"sha": "47204dfc422f4eb778d7cd5d13d77dd1b5f3e22e", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -155,6 +155,8 @@\n // FIXME: Can't be shared between threads. Dynamic borrows\n // FIXME: Relationship to Atomic types and RWLock\n \n+#![stable]\n+\n use clone::Clone;\n use cmp::PartialEq;\n use default::Default;\n@@ -422,7 +424,9 @@ pub struct Ref<'b, T:'b> {\n }\n \n #[unstable = \"waiting for `Deref` to become stable\"]\n-impl<'b, T> Deref<T> for Ref<'b, T> {\n+impl<'b, T> Deref for Ref<'b, T> {\n+    type Target = T;\n+\n     #[inline]\n     fn deref<'a>(&'a self) -> &'a T {\n         self._value\n@@ -478,15 +482,17 @@ pub struct RefMut<'b, T:'b> {\n }\n \n #[unstable = \"waiting for `Deref` to become stable\"]\n-impl<'b, T> Deref<T> for RefMut<'b, T> {\n+impl<'b, T> Deref for RefMut<'b, T> {\n+    type Target = T;\n+\n     #[inline]\n     fn deref<'a>(&'a self) -> &'a T {\n         self._value\n     }\n }\n \n #[unstable = \"waiting for `DerefMut` to become stable\"]\n-impl<'b, T> DerefMut<T> for RefMut<'b, T> {\n+impl<'b, T> DerefMut for RefMut<'b, T> {\n     #[inline]\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n         self._value"}, {"sha": "159c2a505d51b89c1b06b062b4b7d6ab70e41872", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -25,7 +25,7 @@ use kinds::Sized;\n \n /// A common trait for cloning an object.\n #[stable]\n-pub trait Clone {\n+pub trait Clone : Sized {\n     /// Returns a copy of the value.\n     #[stable]\n     fn clone(&self) -> Self;"}, {"sha": "38906892a339f24a3c5ab81b0ab470c5929ec202", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -125,11 +125,12 @@ impl Ordering {\n     /// # Example\n     ///\n     /// ```rust\n+    /// use std::cmp::Ordering::{Less, Equal, Greater};\n+    ///\n     /// assert_eq!(Less.reverse(), Greater);\n     /// assert_eq!(Equal.reverse(), Equal);\n     /// assert_eq!(Greater.reverse(), Less);\n     ///\n-    ///\n     /// let mut data: &mut [_] = &mut [2u, 10, 5, 8];\n     ///\n     /// // sort the array from largest to smallest.\n@@ -170,6 +171,8 @@ pub trait Ord for Sized?: Eq + PartialOrd<Self> {\n     /// the expression `self <operator> other` if true.  For example:\n     ///\n     /// ```\n+    /// use std::cmp::Ordering::{Less, Equal, Greater};\n+    ///\n     /// assert_eq!( 5u.cmp(&10), Less);     // because 5 < 10\n     /// assert_eq!(10u.cmp(&5),  Greater);  // because 10 > 5\n     /// assert_eq!( 5u.cmp(&5),  Equal);    // because 5 == 5"}, {"sha": "a39168ec1ec82bd0a33eb5dc060c9db1f9ee3e72", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -23,7 +23,7 @@ use num::FpCategory as Fp;\n use ops::FnOnce;\n use result::Result::Ok;\n use slice::{mod, SliceExt};\n-use str::StrExt;\n+use str::{mod, StrExt};\n \n /// A flag that specifies whether to use exponential (scientific) notation.\n pub enum ExponentFormat {\n@@ -95,7 +95,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n     exp_upper: bool,\n     f: F\n ) -> U where\n-    F: FnOnce(&[u8]) -> U,\n+    F: FnOnce(&str) -> U,\n {\n     assert!(2 <= radix && radix <= 36);\n     match exp_format {\n@@ -109,12 +109,12 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n     let _1: T = Float::one();\n \n     match num.classify() {\n-        Fp::Nan => return f(\"NaN\".as_bytes()),\n+        Fp::Nan => return f(\"NaN\"),\n         Fp::Infinite if num > _0 => {\n-            return f(\"inf\".as_bytes());\n+            return f(\"inf\");\n         }\n         Fp::Infinite if num < _0 => {\n-            return f(\"-inf\".as_bytes());\n+            return f(\"-inf\");\n         }\n         _ => {}\n     }\n@@ -314,11 +314,11 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n                 end: &'a mut uint,\n             }\n \n-            impl<'a> fmt::FormatWriter for Filler<'a> {\n-                fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n+            impl<'a> fmt::Writer for Filler<'a> {\n+                fn write_str(&mut self, s: &str) -> fmt::Result {\n                     slice::bytes::copy_memory(self.buf.slice_from_mut(*self.end),\n-                                              bytes);\n-                    *self.end += bytes.len();\n+                                              s.as_bytes());\n+                    *self.end += s.len();\n                     Ok(())\n                 }\n             }\n@@ -332,5 +332,5 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n         }\n     }\n \n-    f(buf[..end])\n+    f(unsafe { str::from_utf8_unchecked(buf[..end]) })\n }"}, {"sha": "13fbf5232f8dc58dc41a0e96bae6ed5d7d2d3f36", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 53, "deletions": 42, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -24,7 +24,7 @@ use result::Result::{Ok, Err};\n use result;\n use slice::SliceExt;\n use slice;\n-use str::{StrExt, Utf8Error};\n+use str::{mod, StrExt, Utf8Error};\n \n pub use self::num::radix;\n pub use self::num::Radix;\n@@ -57,7 +57,7 @@ pub struct Error;\n /// library. The `write!` macro accepts an instance of `io::Writer`, and the\n /// `io::Writer` trait is favored over implementing this trait.\n #[experimental = \"waiting for core and I/O reconciliation\"]\n-pub trait FormatWriter {\n+pub trait Writer {\n     /// Writes a slice of bytes into this writer, returning whether the write\n     /// succeeded.\n     ///\n@@ -68,13 +68,32 @@ pub trait FormatWriter {\n     /// # Errors\n     ///\n     /// This function will return an instance of `FormatError` on error.\n-    fn write(&mut self, bytes: &[u8]) -> Result;\n+    fn write_str(&mut self, s: &str) -> Result;\n \n     /// Glue for usage of the `write!` macro with implementers of this trait.\n     ///\n     /// This method should generally not be invoked manually, but rather through\n     /// the `write!` macro itself.\n-    fn write_fmt(&mut self, args: Arguments) -> Result { write(self, args) }\n+    fn write_fmt(&mut self, args: Arguments) -> Result {\n+        // This Adapter is needed to allow `self` (of type `&mut\n+        // Self`) to be cast to a FormatWriter (below) without\n+        // requiring a `Sized` bound.\n+        struct Adapter<'a,Sized? T:'a>(&'a mut T);\n+\n+        impl<'a, Sized? T> Writer for Adapter<'a, T>\n+            where T: Writer\n+        {\n+            fn write_str(&mut self, s: &str) -> Result {\n+                self.0.write_str(s)\n+            }\n+\n+            fn write_fmt(&mut self, args: Arguments) -> Result {\n+                self.0.write_fmt(args)\n+            }\n+        }\n+\n+        write(&mut Adapter(self), args)\n+    }\n }\n \n /// A struct to represent both where to emit formatting strings to and how they\n@@ -88,7 +107,7 @@ pub struct Formatter<'a> {\n     width: Option<uint>,\n     precision: Option<uint>,\n \n-    buf: &'a mut (FormatWriter+'a),\n+    buf: &'a mut (Writer+'a),\n     curarg: slice::Iter<'a, Argument<'a>>,\n     args: &'a [Argument<'a>],\n }\n@@ -258,17 +277,6 @@ pub trait UpperExp for Sized? {\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n-static DEFAULT_ARGUMENT: rt::Argument<'static> = rt::Argument {\n-    position: rt::ArgumentNext,\n-    format: rt::FormatSpec {\n-        fill: ' ',\n-        align: rt::AlignUnknown,\n-        flags: 0,\n-        precision: rt::CountImplied,\n-        width: rt::CountImplied,\n-    }\n-};\n-\n /// The `write` function takes an output stream, a precompiled format string,\n /// and a list of arguments. The arguments will be formatted according to the\n /// specified format string into the output stream provided.\n@@ -279,7 +287,7 @@ static DEFAULT_ARGUMENT: rt::Argument<'static> = rt::Argument {\n ///   * args - the precompiled arguments generated by `format_args!`\n #[experimental = \"libcore and I/O have yet to be reconciled, and this is an \\\n                   implementation detail which should not otherwise be exported\"]\n-pub fn write(output: &mut FormatWriter, args: Arguments) -> Result {\n+pub fn write(output: &mut Writer, args: Arguments) -> Result {\n     let mut formatter = Formatter {\n         flags: 0,\n         width: None,\n@@ -296,16 +304,16 @@ pub fn write(output: &mut FormatWriter, args: Arguments) -> Result {\n     match args.fmt {\n         None => {\n             // We can use default formatting parameters for all arguments.\n-            for _ in range(0, args.args.len()) {\n-                try!(formatter.buf.write(pieces.next().unwrap().as_bytes()));\n-                try!(formatter.run(&DEFAULT_ARGUMENT));\n+            for (arg, piece) in args.args.iter().zip(pieces.by_ref()) {\n+                try!(formatter.buf.write_str(*piece));\n+                try!((arg.formatter)(arg.value, &mut formatter));\n             }\n         }\n         Some(fmt) => {\n             // Every spec has a corresponding argument that is preceded by\n             // a string piece.\n             for (arg, piece) in fmt.iter().zip(pieces.by_ref()) {\n-                try!(formatter.buf.write(piece.as_bytes()));\n+                try!(formatter.buf.write_str(*piece));\n                 try!(formatter.run(arg));\n             }\n         }\n@@ -314,7 +322,7 @@ pub fn write(output: &mut FormatWriter, args: Arguments) -> Result {\n     // There can be only one trailing string piece left.\n     match pieces.next() {\n         Some(piece) => {\n-            try!(formatter.buf.write(piece.as_bytes()));\n+            try!(formatter.buf.write_str(*piece));\n         }\n         None => {}\n     }\n@@ -378,7 +386,7 @@ impl<'a> Formatter<'a> {\n     pub fn pad_integral(&mut self,\n                         is_positive: bool,\n                         prefix: &str,\n-                        buf: &[u8])\n+                        buf: &str)\n                         -> Result {\n         use char::Char;\n         use fmt::rt::{FlagAlternate, FlagSignPlus, FlagSignAwareZeroPad};\n@@ -402,9 +410,10 @@ impl<'a> Formatter<'a> {\n             for c in sign.into_iter() {\n                 let mut b = [0; 4];\n                 let n = c.encode_utf8(&mut b).unwrap_or(0);\n-                try!(f.buf.write(b[..n]));\n+                let b = unsafe { str::from_utf8_unchecked(b[0..n]) };\n+                try!(f.buf.write_str(b));\n             }\n-            if prefixed { f.buf.write(prefix.as_bytes()) }\n+            if prefixed { f.buf.write_str(prefix) }\n             else { Ok(()) }\n         };\n \n@@ -413,24 +422,26 @@ impl<'a> Formatter<'a> {\n             // If there's no minimum length requirements then we can just\n             // write the bytes.\n             None => {\n-                try!(write_prefix(self)); self.buf.write(buf)\n+                try!(write_prefix(self)); self.buf.write_str(buf)\n             }\n             // Check if we're over the minimum width, if so then we can also\n             // just write the bytes.\n             Some(min) if width >= min => {\n-                try!(write_prefix(self)); self.buf.write(buf)\n+                try!(write_prefix(self)); self.buf.write_str(buf)\n             }\n             // The sign and prefix goes before the padding if the fill character\n             // is zero\n             Some(min) if self.flags & (1 << (FlagSignAwareZeroPad as uint)) != 0 => {\n                 self.fill = '0';\n                 try!(write_prefix(self));\n-                self.with_padding(min - width, rt::AlignRight, |f| f.buf.write(buf))\n+                self.with_padding(min - width, rt::AlignRight, |f| {\n+                    f.buf.write_str(buf)\n+                })\n             }\n             // Otherwise, the sign and prefix goes after the padding\n             Some(min) => {\n                 self.with_padding(min - width, rt::AlignRight, |f| {\n-                    try!(write_prefix(f)); f.buf.write(buf)\n+                    try!(write_prefix(f)); f.buf.write_str(buf)\n                 })\n             }\n         }\n@@ -451,7 +462,7 @@ impl<'a> Formatter<'a> {\n     pub fn pad(&mut self, s: &str) -> Result {\n         // Make sure there's a fast path up front\n         if self.width.is_none() && self.precision.is_none() {\n-            return self.buf.write(s.as_bytes());\n+            return self.buf.write_str(s);\n         }\n         // The `precision` field can be interpreted as a `max-width` for the\n         // string being formatted\n@@ -463,7 +474,7 @@ impl<'a> Formatter<'a> {\n                 let char_len = s.char_len();\n                 if char_len >= max {\n                     let nchars = ::cmp::min(max, char_len);\n-                    return self.buf.write(s.slice_chars(0, nchars).as_bytes());\n+                    return self.buf.write_str(s.slice_chars(0, nchars));\n                 }\n             }\n             None => {}\n@@ -472,17 +483,17 @@ impl<'a> Formatter<'a> {\n         match self.width {\n             // If we're under the maximum length, and there's no minimum length\n             // requirements, then we can just emit the string\n-            None => self.buf.write(s.as_bytes()),\n+            None => self.buf.write_str(s),\n             // If we're under the maximum width, check if we're over the minimum\n             // width, if so it's as easy as just emitting the string.\n             Some(width) if s.char_len() >= width => {\n-                self.buf.write(s.as_bytes())\n+                self.buf.write_str(s)\n             }\n             // If we're under both the maximum and the minimum width, then fill\n             // up the minimum width with the specified string + some alignment.\n             Some(width) => {\n                 self.with_padding(width - s.char_len(), rt::AlignLeft, |me| {\n-                    me.buf.write(s.as_bytes())\n+                    me.buf.write_str(s)\n                 })\n             }\n         }\n@@ -507,15 +518,16 @@ impl<'a> Formatter<'a> {\n \n         let mut fill = [0u8; 4];\n         let len = self.fill.encode_utf8(&mut fill).unwrap_or(0);\n+        let fill = unsafe { str::from_utf8_unchecked(fill[..len]) };\n \n         for _ in range(0, pre_pad) {\n-            try!(self.buf.write(fill[..len]));\n+            try!(self.buf.write_str(fill));\n         }\n \n         try!(f(self));\n \n         for _ in range(0, post_pad) {\n-            try!(self.buf.write(fill[..len]));\n+            try!(self.buf.write_str(fill));\n         }\n \n         Ok(())\n@@ -524,8 +536,8 @@ impl<'a> Formatter<'a> {\n     /// Writes some data to the underlying buffer contained within this\n     /// formatter.\n     #[unstable = \"reconciling core and I/O may alter this definition\"]\n-    pub fn write(&mut self, data: &[u8]) -> Result {\n-        self.buf.write(data)\n+    pub fn write_str(&mut self, data: &str) -> Result {\n+        self.buf.write_str(data)\n     }\n \n     /// Writes some formatted information into this instance\n@@ -586,9 +598,6 @@ impl<'a, Sized? T: Show> Show for &'a T {\n impl<'a, Sized? T: Show> Show for &'a mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result { (**self).fmt(f) }\n }\n-impl<'a> Show for &'a (Show+'a) {\n-    fn fmt(&self, f: &mut Formatter) -> Result { (*self).fmt(f) }\n-}\n \n impl Show for bool {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n@@ -616,7 +625,9 @@ impl Show for char {\n impl<T> Pointer for *const T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.flags |= 1 << (rt::FlagAlternate as uint);\n-        LowerHex::fmt(&(*self as uint), f)\n+        let ret = LowerHex::fmt(&(*self as uint), f);\n+        f.flags &= !(1 << (rt::FlagAlternate as uint));\n+        ret\n     }\n }\n "}, {"sha": "4f0cecbb24353abc591c84fea56ef35fda598c25", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -18,6 +18,7 @@ use fmt;\n use iter::DoubleEndedIteratorExt;\n use num::{Int, cast};\n use slice::SliceExt;\n+use str;\n \n /// A type that represents a specific radix\n #[doc(hidden)]\n@@ -60,7 +61,8 @@ trait GenericRadix {\n                 if x == zero { break };                   // No more digits left to accumulate.\n             }\n         }\n-        f.pad_integral(is_positive, self.prefix(), buf[curr..])\n+        let buf = unsafe { str::from_utf8_unchecked(buf[curr..]) };\n+        f.pad_integral(is_positive, self.prefix(), buf)\n     }\n }\n "}, {"sha": "d7a675b3104ecb4287e520dce800fa2c315d4824", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -54,7 +54,7 @@\n //!\n //! This `for` loop syntax can be applied to any iterator over any type.\n \n-pub use self::MinMaxResult::*;\n+use self::MinMaxResult::*;\n \n use clone::Clone;\n use cmp;\n@@ -65,6 +65,7 @@ use num::{ToPrimitive, Int};\n use ops::{Add, Deref, FnMut};\n use option::Option;\n use option::Option::{Some, None};\n+use std::kinds::Sized;\n use uint;\n \n #[deprecated = \"renamed to Extend\"] pub use self::Extend as Extendable;\n@@ -109,7 +110,7 @@ pub trait Extend<A> {\n \n #[unstable = \"new convention for extension traits\"]\n /// An extension trait providing numerous methods applicable to all iterators.\n-pub trait IteratorExt<A>: Iterator<A> {\n+pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// Chain this iterator with another, returning a new iterator that will\n     /// finish iterating over the current iterator, and then iterate\n     /// over the other specified iterator.\n@@ -692,7 +693,7 @@ impl<A, I> IteratorExt<A> for I where I: Iterator<A> {}\n \n /// Extention trait for iterators of pairs.\n #[unstable = \"newly added trait, likely to be merged with IteratorExt\"]\n-pub trait IteratorPairExt<A, B>: Iterator<(A, B)> {\n+pub trait IteratorPairExt<A, B>: Iterator<(A, B)> + Sized {\n     /// Converts an iterator of pairs into a pair of containers.\n     ///\n     /// Loops through the entire iterator, collecting the first component of\n@@ -738,7 +739,7 @@ pub trait DoubleEndedIterator<A>: Iterator<A> {\n \n /// Extension methods for double-ended iterators.\n #[unstable = \"new extension trait convention\"]\n-pub trait DoubleEndedIteratorExt<A>: DoubleEndedIterator<A> {\n+pub trait DoubleEndedIteratorExt<A>: DoubleEndedIterator<A> + Sized {\n     /// Change the direction of the iterator\n     ///\n     /// The flipped iterator swaps the ends on an iterator that can already\n@@ -1035,7 +1036,7 @@ pub trait IteratorOrdExt<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::iter::{NoElements, OneElement, MinMax};\n+    /// use std::iter::MinMaxResult::{NoElements, OneElement, MinMax};\n     ///\n     /// let v: [int; 0] = [];\n     /// assert_eq!(v.iter().min_max(), NoElements);\n@@ -1145,7 +1146,7 @@ impl<T: Clone> MinMaxResult<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::iter::{NoElements, OneElement, MinMax, MinMaxResult};\n+    /// use std::iter::MinMaxResult::{mod, NoElements, OneElement, MinMax};\n     ///\n     /// let r: MinMaxResult<int> = NoElements;\n     /// assert_eq!(r.into_option(), None);\n@@ -1174,7 +1175,7 @@ pub trait IteratorCloneExt<A> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A: Clone, D: Deref<A>, I: Iterator<D>> IteratorCloneExt<A> for I {\n+impl<A: Clone, D: Deref<Target=A>, I: Iterator<D>> IteratorCloneExt<A> for I {\n     fn cloned(self) -> Cloned<I> {\n         Cloned { it: self }\n     }\n@@ -1185,7 +1186,7 @@ pub struct Cloned<I> {\n     it: I,\n }\n \n-impl<A: Clone, D: Deref<A>, I: Iterator<D>> Iterator<A> for Cloned<I> {\n+impl<A: Clone, D: Deref<Target=A>, I: Iterator<D>> Iterator<A> for Cloned<I> {\n     fn next(&mut self) -> Option<A> {\n         self.it.next().cloned()\n     }\n@@ -1195,15 +1196,15 @@ impl<A: Clone, D: Deref<A>, I: Iterator<D>> Iterator<A> for Cloned<I> {\n     }\n }\n \n-impl<A: Clone, D: Deref<A>, I: DoubleEndedIterator<D>>\n+impl<A: Clone, D: Deref<Target=A>, I: DoubleEndedIterator<D>>\n         DoubleEndedIterator<A> for Cloned<I> {\n     fn next_back(&mut self) -> Option<A> {\n         self.it.next_back().cloned()\n     }\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A: Clone, D: Deref<A>, I: ExactSizeIterator<D>> ExactSizeIterator<A> for Cloned<I> {}\n+impl<A: Clone, D: Deref<Target=A>, I: ExactSizeIterator<D>> ExactSizeIterator<A> for Cloned<I> {}\n \n #[unstable = \"recently renamed for extension trait conventions\"]\n /// An extension trait for cloneable iterators."}, {"sha": "ba9103520d8751f5e3e1751f0ce6cdfeec42f553", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -44,7 +44,9 @@ impl<T: Zeroable> NonZero<T> {\n     }\n }\n \n-impl<T: Zeroable> Deref<T> for NonZero<T> {\n+impl<T: Zeroable> Deref for NonZero<T> {\n+    type Target = T;\n+\n     #[inline]\n     fn deref<'a>(&'a self) -> &'a T {\n         let NonZero(ref inner) = *self;"}, {"sha": "d16478dd6cc7ee290f5187dabff5905c3f9de72f", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -980,7 +980,7 @@ impl_to_primitive_float! { f64 }\n \n /// A generic trait for converting a number to a value.\n #[experimental = \"trait is likely to be removed\"]\n-pub trait FromPrimitive {\n+pub trait FromPrimitive : ::kinds::Sized {\n     /// Convert an `int` to return an optional value of this type. If the\n     /// value cannot be represented by this value, the `None` is returned.\n     #[inline]"}, {"sha": "b51d4d91c2f55d090ee67a2f92fce2146815d187", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 66, "deletions": 14, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -25,6 +25,8 @@\n //! demonstrates adding and subtracting two `Point`s.\n //!\n //! ```rust\n+//! use std::ops::{Add, Sub};\n+//!\n //! #[deriving(Show)]\n //! struct Point {\n //!     x: int,\n@@ -68,13 +70,13 @@ use option::Option::{mod, Some, None};\n /// struct HasDrop;\n ///\n /// impl Drop for HasDrop {\n-///   fn drop(&mut self) {\n-///       println!(\"Dropping!\");\n-///   }\n+///     fn drop(&mut self) {\n+///         println!(\"Dropping!\");\n+///     }\n /// }\n ///\n /// fn main() {\n-///   let _x = HasDrop;\n+///     let _x = HasDrop;\n /// }\n /// ```\n #[lang=\"drop\"]\n@@ -91,6 +93,8 @@ pub trait Drop {\n /// calling `add`, and therefore, `main` prints `Adding!`.\n ///\n /// ```rust\n+/// use std::ops::Add;\n+///\n /// #[deriving(Copy)]\n /// struct Foo;\n ///\n@@ -130,6 +134,8 @@ add_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// calling `sub`, and therefore, `main` prints `Subtracting!`.\n ///\n /// ```rust\n+/// use std::ops::Sub;\n+///\n /// #[deriving(Copy)]\n /// struct Foo;\n ///\n@@ -169,6 +175,8 @@ sub_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// calling `mul`, and therefore, `main` prints `Multiplying!`.\n ///\n /// ```rust\n+/// use std::ops::Mul;\n+///\n /// #[deriving(Copy)]\n /// struct Foo;\n ///\n@@ -208,6 +216,8 @@ mul_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// calling `div`, and therefore, `main` prints `Dividing!`.\n ///\n /// ```\n+/// use std::ops::Div;\n+///\n /// #[deriving(Copy)]\n /// struct Foo;\n ///\n@@ -247,6 +257,8 @@ div_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// calling `rem`, and therefore, `main` prints `Remainder-ing!`.\n ///\n /// ```\n+/// use std::ops::Rem;\n+///\n /// #[deriving(Copy)]\n /// struct Foo;\n ///\n@@ -300,6 +312,8 @@ rem_float_impl! { f64, fmod }\n /// `neg`, and therefore, `main` prints `Negating!`.\n ///\n /// ```\n+/// use std::ops::Neg;\n+///\n /// struct Foo;\n ///\n /// impl Copy for Foo {}\n@@ -356,6 +370,8 @@ neg_uint_impl! { u64, i64 }\n /// `not`, and therefore, `main` prints `Not-ing!`.\n ///\n /// ```\n+/// use std::ops::Not;\n+///\n /// struct Foo;\n ///\n /// impl Copy for Foo {}\n@@ -396,6 +412,8 @@ not_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// calling `bitand`, and therefore, `main` prints `Bitwise And-ing!`.\n ///\n /// ```\n+/// use std::ops::BitAnd;\n+///\n /// #[deriving(Copy)]\n /// struct Foo;\n ///\n@@ -435,6 +453,8 @@ bitand_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// calling `bitor`, and therefore, `main` prints `Bitwise Or-ing!`.\n ///\n /// ```\n+/// use std::ops::BitOr;\n+///\n /// #[deriving(Copy)]\n /// struct Foo;\n ///\n@@ -474,6 +494,8 @@ bitor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// calling `bitxor`, and therefore, `main` prints `Bitwise Xor-ing!`.\n ///\n /// ```\n+/// use std::ops::BitXor;\n+///\n /// #[deriving(Copy)]\n /// struct Foo;\n ///\n@@ -513,6 +535,8 @@ bitxor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// calling `shl`, and therefore, `main` prints `Shifting left!`.\n ///\n /// ```\n+/// use std::ops::Shl;\n+///\n /// #[deriving(Copy)]\n /// struct Foo;\n ///\n@@ -554,6 +578,8 @@ shl_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// calling `shr`, and therefore, `main` prints `Shifting right!`.\n ///\n /// ```\n+/// use std::ops::Shr;\n+///\n /// #[deriving(Copy)]\n /// struct Foo;\n ///\n@@ -594,6 +620,8 @@ shr_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// calling `index`, and therefore, `main` prints `Indexing!`.\n ///\n /// ```\n+/// use std::ops::Index;\n+///\n /// #[deriving(Copy)]\n /// struct Foo;\n ///\n@@ -623,6 +651,8 @@ pub trait Index<Sized? Index, Sized? Result> for Sized? {\n /// calling `index_mut`, and therefore, `main` prints `Indexing!`.\n ///\n /// ```\n+/// use std::ops::IndexMut;\n+///\n /// #[deriving(Copy)]\n /// struct Foo;\n ///\n@@ -652,6 +682,8 @@ pub trait IndexMut<Sized? Index, Sized? Result> for Sized? {\n /// calling `slice_to`, and therefore, `main` prints `Slicing!`.\n ///\n /// ```ignore\n+/// use std::ops::Slice;\n+///\n /// #[deriving(Copy)]\n /// struct Foo;\n ///\n@@ -699,6 +731,8 @@ pub trait Slice<Sized? Idx, Sized? Result> for Sized? {\n /// calling `slice_from_mut`, and therefore, `main` prints `Slicing!`.\n ///\n /// ```ignore\n+/// use std::ops::SliceMut;\n+///\n /// #[deriving(Copy)]\n /// struct Foo;\n ///\n@@ -827,11 +861,17 @@ pub struct RangeTo<Idx> {\n /// struct.\n ///\n /// ```\n+/// #![feature(associated_types)]\n+///\n+/// use std::ops::Deref;\n+///\n /// struct DerefExample<T> {\n ///     value: T\n /// }\n ///\n-/// impl<T> Deref<T> for DerefExample<T> {\n+/// impl<T> Deref for DerefExample<T> {\n+///     type Target = T;\n+///\n ///     fn deref<'a>(&'a self) -> &'a T {\n ///         &self.value\n ///     }\n@@ -843,16 +883,22 @@ pub struct RangeTo<Idx> {\n /// }\n /// ```\n #[lang=\"deref\"]\n-pub trait Deref<Sized? Result> for Sized? {\n+pub trait Deref for Sized? {\n+    type Sized? Target;\n+\n     /// The method called to dereference a value\n-    fn deref<'a>(&'a self) -> &'a Result;\n+    fn deref<'a>(&'a self) -> &'a Self::Target;\n }\n \n-impl<'a, Sized? T> Deref<T> for &'a T {\n+impl<'a, Sized? T> Deref for &'a T {\n+    type Target = T;\n+\n     fn deref(&self) -> &T { *self }\n }\n \n-impl<'a, Sized? T> Deref<T> for &'a mut T {\n+impl<'a, Sized? T> Deref for &'a mut T {\n+    type Target = T;\n+\n     fn deref(&self) -> &T { *self }\n }\n \n@@ -865,17 +911,23 @@ impl<'a, Sized? T> Deref<T> for &'a mut T {\n /// struct.\n ///\n /// ```\n+/// #![feature(associated_types)]\n+///\n+/// use std::ops::{Deref, DerefMut};\n+///\n /// struct DerefMutExample<T> {\n ///     value: T\n /// }\n ///\n-/// impl<T> Deref<T> for DerefMutExample<T> {\n+/// impl<T> Deref for DerefMutExample<T> {\n+///     type Target = T;\n+///\n ///     fn deref<'a>(&'a self) -> &'a T {\n ///         &self.value\n ///     }\n /// }\n ///\n-/// impl<T> DerefMut<T> for DerefMutExample<T> {\n+/// impl<T> DerefMut for DerefMutExample<T> {\n ///     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n ///         &mut self.value\n ///     }\n@@ -888,12 +940,12 @@ impl<'a, Sized? T> Deref<T> for &'a mut T {\n /// }\n /// ```\n #[lang=\"deref_mut\"]\n-pub trait DerefMut<Sized? Result> for Sized? : Deref<Result> {\n+pub trait DerefMut for Sized? : Deref {\n     /// The method called to mutably dereference a value\n-    fn deref_mut<'a>(&'a mut self) -> &'a mut Result;\n+    fn deref_mut<'a>(&'a mut self) -> &'a mut <Self as Deref>::Target;\n }\n \n-impl<'a, Sized? T> DerefMut<T> for &'a mut T {\n+impl<'a, Sized? T> DerefMut for &'a mut T {\n     fn deref_mut(&mut self) -> &mut T { *self }\n }\n "}, {"sha": "b9749f57d5832edda48e425a4f6d81bcc0d1c81f", "filename": "src/libcore/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -699,7 +699,7 @@ impl<T> Option<T> {\n     }\n }\n \n-impl<'a, T: Clone, D: Deref<T>> Option<D> {\n+impl<'a, T: Clone, D: Deref<Target=T>> Option<D> {\n     /// Maps an Option<D> to an Option<T> by dereffing and cloning the contents of the Option.\n     /// Useful for converting an Option<&T> to an Option<T>.\n     #[unstable = \"recently added as part of collections reform\"]"}, {"sha": "8cb631380095f06b26025d8bc9d47b68c03b1aac", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 8, "deletions": 24, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -30,39 +30,23 @@\n \n // Reexported core operators\n pub use kinds::{Copy, Send, Sized, Sync};\n-pub use ops::{Add, Sub, Mul, Div, Rem, Neg, Not};\n-pub use ops::{BitAnd, BitOr, BitXor};\n-pub use ops::{Drop, Deref, DerefMut};\n-pub use ops::{Shl, Shr};\n-pub use ops::{Index, IndexMut};\n-pub use ops::{Slice, SliceMut};\n-pub use ops::{Fn, FnMut, FnOnce};\n+pub use ops::{Drop, Fn, FnMut, FnOnce};\n \n // Reexported functions\n pub use iter::range;\n pub use mem::drop;\n-pub use str::from_str;\n \n // Reexported types and traits\n \n pub use char::Char;\n pub use clone::Clone;\n pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n-pub use cmp::{Ordering, Equiv};\n-pub use cmp::Ordering::{Less, Equal, Greater};\n-pub use iter::{FromIterator, Extend, IteratorExt};\n-pub use iter::{Iterator, DoubleEndedIterator, DoubleEndedIteratorExt, RandomAccessIterator};\n-pub use iter::{IteratorCloneExt, CloneIteratorExt, IteratorPairExt};\n-pub use iter::{IteratorOrdExt, MutableDoubleEndedIterator, ExactSizeIterator};\n-pub use num::{ToPrimitive, FromPrimitive};\n-pub use option::Option;\n-pub use option::Option::{Some, None};\n+pub use iter::{Extend, IteratorExt};\n+pub use iter::{Iterator, DoubleEndedIterator, DoubleEndedIteratorExt};\n+pub use iter::{IteratorCloneExt, CloneIteratorExt};\n+pub use iter::{IteratorOrdExt, ExactSizeIterator, IteratorPairExt};\n+pub use option::Option::{mod, Some, None};\n pub use ptr::{PtrExt, MutPtrExt};\n-pub use result::Result;\n-pub use result::Result::{Ok, Err};\n-pub use str::{Str, StrExt};\n-pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n-pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n-pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};\n-pub use slice::{PartialEqSliceExt, OrdSliceExt};\n+pub use result::Result::{mod, Ok, Err};\n pub use slice::{AsSlice, SliceExt};\n+pub use str::{Str, StrExt};"}, {"sha": "f29d75181492b0b31df14ddd5af4d45a197779f6", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -92,7 +92,7 @@ use mem;\n use clone::Clone;\n use intrinsics;\n use option::Option::{mod, Some, None};\n-use kinds::{Send, Sync};\n+use kinds::{Send, Sized, Sync};\n \n use cmp::{PartialEq, Eq, Ord, PartialOrd, Equiv};\n use cmp::Ordering::{mod, Less, Equal, Greater};\n@@ -243,7 +243,9 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n \n /// Methods on raw pointers\n #[stable]\n-pub trait PtrExt<T> {\n+pub trait PtrExt: Sized {\n+    type Target;\n+\n     /// Returns the null pointer.\n     #[deprecated = \"call ptr::null instead\"]\n     fn null() -> Self;\n@@ -271,7 +273,7 @@ pub trait PtrExt<T> {\n     /// memory.\n     #[unstable = \"Option is not clearly the right return type, and we may want \\\n                   to tie the return lifetime to a borrow of the raw pointer\"]\n-    unsafe fn as_ref<'a>(&self) -> Option<&'a T>;\n+    unsafe fn as_ref<'a>(&self) -> Option<&'a Self::Target>;\n \n     /// Calculates the offset from a pointer. `count` is in units of T; e.g. a\n     /// `count` of 3 represents a pointer offset of `3 * sizeof::<T>()` bytes.\n@@ -287,7 +289,9 @@ pub trait PtrExt<T> {\n \n /// Methods on mutable raw pointers\n #[stable]\n-pub trait MutPtrExt<T>{\n+pub trait MutPtrExt {\n+    type Target;\n+\n     /// Returns `None` if the pointer is null, or else returns a mutable\n     /// reference to the value wrapped in `Some`.\n     ///\n@@ -297,11 +301,13 @@ pub trait MutPtrExt<T>{\n     /// of the returned pointer.\n     #[unstable = \"Option is not clearly the right return type, and we may want \\\n                   to tie the return lifetime to a borrow of the raw pointer\"]\n-    unsafe fn as_mut<'a>(&self) -> Option<&'a mut T>;\n+    unsafe fn as_mut<'a>(&self) -> Option<&'a mut Self::Target>;\n }\n \n #[stable]\n-impl<T> PtrExt<T> for *const T {\n+impl<T> PtrExt for *const T {\n+    type Target = T;\n+\n     #[inline]\n     #[deprecated = \"call ptr::null instead\"]\n     fn null() -> *const T { null() }\n@@ -333,7 +339,9 @@ impl<T> PtrExt<T> for *const T {\n }\n \n #[stable]\n-impl<T> PtrExt<T> for *mut T {\n+impl<T> PtrExt for *mut T {\n+    type Target = T;\n+\n     #[inline]\n     #[deprecated = \"call ptr::null instead\"]\n     fn null() -> *mut T { null_mut() }\n@@ -365,7 +373,9 @@ impl<T> PtrExt<T> for *mut T {\n }\n \n #[stable]\n-impl<T> MutPtrExt<T> for *mut T {\n+impl<T> MutPtrExt for *mut T {\n+    type Target = T;\n+\n     #[inline]\n     #[unstable = \"return value does not necessarily convey all possible \\\n                   information\"]"}, {"sha": "07addf7a56969cd75af39cf38ac68b9dd2698384", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 145, "deletions": 174, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -64,57 +64,77 @@ use raw::Slice as RawSlice;\n \n /// Extension methods for slices.\n #[allow(missing_docs)] // docs in libcollections\n-pub trait SliceExt<T> for Sized? {\n-    fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T];\n-    fn slice_from<'a>(&'a self, start: uint) -> &'a [T];\n-    fn slice_to<'a>(&'a self, end: uint) -> &'a [T];\n-    fn split_at<'a>(&'a self, mid: uint) -> (&'a [T], &'a [T]);\n-    fn iter<'a>(&'a self) -> Iter<'a, T>;\n-    fn split<'a, P>(&'a self, pred: P) -> Split<'a, T, P>\n-                    where P: FnMut(&T) -> bool;\n-    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitN<'a, T, P>\n-                     where P: FnMut(&T) -> bool;\n-    fn rsplitn<'a, P>(&'a self,  n: uint, pred: P) -> RSplitN<'a, T, P>\n-                      where P: FnMut(&T) -> bool;\n-    fn windows<'a>(&'a self, size: uint) -> Windows<'a, T>;\n-    fn chunks<'a>(&'a self, size: uint) -> Chunks<'a, T>;\n-    fn get<'a>(&'a self, index: uint) -> Option<&'a T>;\n-    fn first<'a>(&'a self) -> Option<&'a T>;\n-    fn tail<'a>(&'a self) -> &'a [T];\n-    fn init<'a>(&'a self) -> &'a [T];\n-    fn last<'a>(&'a self) -> Option<&'a T>;\n-    unsafe fn get_unchecked<'a>(&'a self, index: uint) -> &'a T;\n-    fn as_ptr(&self) -> *const T;\n+pub trait SliceExt for Sized? {\n+    type Item;\n+\n+    fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [Self::Item];\n+    fn slice_from<'a>(&'a self, start: uint) -> &'a [Self::Item];\n+    fn slice_to<'a>(&'a self, end: uint) -> &'a [Self::Item];\n+    fn split_at<'a>(&'a self, mid: uint) -> (&'a [Self::Item], &'a [Self::Item]);\n+    fn iter<'a>(&'a self) -> Iter<'a, Self::Item>;\n+    fn split<'a, P>(&'a self, pred: P) -> Split<'a, Self::Item, P>\n+                    where P: FnMut(&Self::Item) -> bool;\n+    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitN<'a, Self::Item, P>\n+                     where P: FnMut(&Self::Item) -> bool;\n+    fn rsplitn<'a, P>(&'a self,  n: uint, pred: P) -> RSplitN<'a, Self::Item, P>\n+                      where P: FnMut(&Self::Item) -> bool;\n+    fn windows<'a>(&'a self, size: uint) -> Windows<'a, Self::Item>;\n+    fn chunks<'a>(&'a self, size: uint) -> Chunks<'a, Self::Item>;\n+    fn get<'a>(&'a self, index: uint) -> Option<&'a Self::Item>;\n+    fn first<'a>(&'a self) -> Option<&'a Self::Item>;\n+    fn tail<'a>(&'a self) -> &'a [Self::Item];\n+    fn init<'a>(&'a self) -> &'a [Self::Item];\n+    fn last<'a>(&'a self) -> Option<&'a Self::Item>;\n+    unsafe fn get_unchecked<'a>(&'a self, index: uint) -> &'a Self::Item;\n+    fn as_ptr(&self) -> *const Self::Item;\n     fn binary_search_by<F>(&self, f: F) -> Result<uint, uint> where\n-        F: FnMut(&T) -> Ordering;\n+        F: FnMut(&Self::Item) -> Ordering;\n     fn len(&self) -> uint;\n     fn is_empty(&self) -> bool { self.len() == 0 }\n-    fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut T>;\n-    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T];\n-    fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [T];\n-    fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T];\n-    fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T];\n-    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T>;\n-    fn first_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n-    fn tail_mut<'a>(&'a mut self) -> &'a mut [T];\n-    fn init_mut<'a>(&'a mut self) -> &'a mut [T];\n-    fn last_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n-    fn split_mut<'a, P>(&'a mut self, pred: P) -> SplitMut<'a, T, P>\n-                        where P: FnMut(&T) -> bool;\n-    fn splitn_mut<P>(&mut self, n: uint, pred: P) -> SplitNMut<T, P>\n-                     where P: FnMut(&T) -> bool;\n-    fn rsplitn_mut<P>(&mut self,  n: uint, pred: P) -> RSplitNMut<T, P>\n-                      where P: FnMut(&T) -> bool;\n-    fn chunks_mut<'a>(&'a mut self, chunk_size: uint) -> ChunksMut<'a, T>;\n+    fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut Self::Item>;\n+    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [Self::Item];\n+    fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [Self::Item];\n+    fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [Self::Item];\n+    fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [Self::Item];\n+    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, Self::Item>;\n+    fn first_mut<'a>(&'a mut self) -> Option<&'a mut Self::Item>;\n+    fn tail_mut<'a>(&'a mut self) -> &'a mut [Self::Item];\n+    fn init_mut<'a>(&'a mut self) -> &'a mut [Self::Item];\n+    fn last_mut<'a>(&'a mut self) -> Option<&'a mut Self::Item>;\n+    fn split_mut<'a, P>(&'a mut self, pred: P) -> SplitMut<'a, Self::Item, P>\n+                        where P: FnMut(&Self::Item) -> bool;\n+    fn splitn_mut<P>(&mut self, n: uint, pred: P) -> SplitNMut<Self::Item, P>\n+                     where P: FnMut(&Self::Item) -> bool;\n+    fn rsplitn_mut<P>(&mut self,  n: uint, pred: P) -> RSplitNMut<Self::Item, P>\n+                      where P: FnMut(&Self::Item) -> bool;\n+    fn chunks_mut<'a>(&'a mut self, chunk_size: uint) -> ChunksMut<'a, Self::Item>;\n     fn swap(&mut self, a: uint, b: uint);\n-    fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]);\n+    fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [Self::Item], &'a mut [Self::Item]);\n     fn reverse(&mut self);\n-    unsafe fn get_unchecked_mut<'a>(&'a mut self, index: uint) -> &'a mut T;\n-    fn as_mut_ptr(&mut self) -> *mut T;\n+    unsafe fn get_unchecked_mut<'a>(&'a mut self, index: uint) -> &'a mut Self::Item;\n+    fn as_mut_ptr(&mut self) -> *mut Self::Item;\n+\n+    fn position_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n+\n+    fn rposition_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n+\n+    fn contains(&self, x: &Self::Item) -> bool where Self::Item: PartialEq;\n+\n+    fn starts_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n+\n+    fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n+\n+    fn binary_search(&self, x: &Self::Item) -> Result<uint, uint> where Self::Item: Ord;\n+    fn next_permutation(&mut self) -> bool where Self::Item: Ord;\n+    fn prev_permutation(&mut self) -> bool where Self::Item: Ord;\n+\n+    fn clone_from_slice(&mut self, &[Self::Item]) -> uint where Self::Item: Clone;\n }\n \n #[unstable]\n-impl<T> SliceExt<T> for [T] {\n+impl<T> SliceExt for [T] {\n+    type Item = T;\n+\n     #[inline]\n     fn slice(&self, start: uint, end: uint) -> &[T] {\n         assert!(start <= end);\n@@ -404,153 +424,41 @@ impl<T> SliceExt<T> for [T] {\n     fn as_mut_ptr(&mut self) -> *mut T {\n         self.repr().data as *mut T\n     }\n-}\n-\n-impl<T> ops::Index<uint, T> for [T] {\n-    fn index(&self, &index: &uint) -> &T {\n-        assert!(index < self.len());\n-\n-        unsafe { mem::transmute(self.repr().data.offset(index as int)) }\n-    }\n-}\n-\n-impl<T> ops::IndexMut<uint, T> for [T] {\n-    fn index_mut(&mut self, &index: &uint) -> &mut T {\n-        assert!(index < self.len());\n-\n-        unsafe { mem::transmute(self.repr().data.offset(index as int)) }\n-    }\n-}\n-\n-impl<T> ops::Slice<uint, [T]> for [T] {\n-    #[inline]\n-    fn as_slice_<'a>(&'a self) -> &'a [T] {\n-        self\n-    }\n-\n-    #[inline]\n-    fn slice_from_or_fail<'a>(&'a self, start: &uint) -> &'a [T] {\n-        self.slice_or_fail(start, &self.len())\n-    }\n-\n-    #[inline]\n-    fn slice_to_or_fail<'a>(&'a self, end: &uint) -> &'a [T] {\n-        self.slice_or_fail(&0, end)\n-    }\n-    #[inline]\n-    fn slice_or_fail<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n-        assert!(*start <= *end);\n-        assert!(*end <= self.len());\n-        unsafe {\n-            transmute(RawSlice {\n-                    data: self.as_ptr().offset(*start as int),\n-                    len: (*end - *start)\n-                })\n-        }\n-    }\n-}\n-\n-impl<T> ops::SliceMut<uint, [T]> for [T] {\n-    #[inline]\n-    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n-        self\n-    }\n-\n-    #[inline]\n-    fn slice_from_or_fail_mut<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n-        let len = &self.len();\n-        self.slice_or_fail_mut(start, len)\n-    }\n-\n-    #[inline]\n-    fn slice_to_or_fail_mut<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n-        self.slice_or_fail_mut(&0, end)\n-    }\n-    #[inline]\n-    fn slice_or_fail_mut<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n-        assert!(*start <= *end);\n-        assert!(*end <= self.len());\n-        unsafe {\n-            transmute(RawSlice {\n-                    data: self.as_ptr().offset(*start as int),\n-                    len: (*end - *start)\n-                })\n-        }\n-    }\n-}\n-\n-/// Extension methods for slices containing `PartialEq` elements.\n-#[unstable = \"may merge with SliceExt\"]\n-pub trait PartialEqSliceExt<T: PartialEq> for Sized? {\n-    /// Find the first index containing a matching value.\n-    #[experimental]\n-    fn position_elem(&self, t: &T) -> Option<uint>;\n-\n-    /// Find the last index containing a matching value.\n-    #[experimental]\n-    fn rposition_elem(&self, t: &T) -> Option<uint>;\n-\n-    /// Return true if the slice contains an element with the given value.\n-    #[stable]\n-    fn contains(&self, x: &T) -> bool;\n-\n-    /// Returns true if `needle` is a prefix of the slice.\n-    #[stable]\n-    fn starts_with(&self, needle: &[T]) -> bool;\n-\n-    /// Returns true if `needle` is a suffix of the slice.\n-    #[stable]\n-    fn ends_with(&self, needle: &[T]) -> bool;\n-}\n \n-#[unstable = \"trait is unstable\"]\n-impl<T: PartialEq> PartialEqSliceExt<T> for [T] {\n     #[inline]\n-    fn position_elem(&self, x: &T) -> Option<uint> {\n+    fn position_elem(&self, x: &T) -> Option<uint> where T: PartialEq {\n         self.iter().position(|y| *x == *y)\n     }\n \n     #[inline]\n-    fn rposition_elem(&self, t: &T) -> Option<uint> {\n+    fn rposition_elem(&self, t: &T) -> Option<uint> where T: PartialEq {\n         self.iter().rposition(|x| *x == *t)\n     }\n \n     #[inline]\n-    fn contains(&self, x: &T) -> bool {\n+    fn contains(&self, x: &T) -> bool where T: PartialEq {\n         self.iter().any(|elt| *x == *elt)\n     }\n \n     #[inline]\n-    fn starts_with(&self, needle: &[T]) -> bool {\n+    fn starts_with(&self, needle: &[T]) -> bool where T: PartialEq {\n         let n = needle.len();\n         self.len() >= n && needle == self[..n]\n     }\n \n     #[inline]\n-    fn ends_with(&self, needle: &[T]) -> bool {\n+    fn ends_with(&self, needle: &[T]) -> bool where T: PartialEq {\n         let (m, n) = (self.len(), needle.len());\n         m >= n && needle == self[m-n..]\n     }\n-}\n \n-/// Extension methods for slices containing `Ord` elements.\n-#[unstable = \"may merge with other traits\"]\n-#[allow(missing_docs)] // docs in libcollections\n-pub trait OrdSliceExt<T: Ord> for Sized? {\n-    fn binary_search(&self, x: &T) -> Result<uint, uint>;\n-    fn next_permutation(&mut self) -> bool;\n-    fn prev_permutation(&mut self) -> bool;\n-}\n-\n-#[unstable = \"trait is unstable\"]\n-impl<T: Ord> OrdSliceExt<T> for [T] {\n     #[unstable]\n-    fn binary_search(&self, x: &T) -> Result<uint, uint> {\n+    fn binary_search(&self, x: &T) -> Result<uint, uint> where T: Ord {\n         self.binary_search_by(|p| p.cmp(x))\n     }\n \n     #[experimental]\n-    fn next_permutation(&mut self) -> bool {\n+    fn next_permutation(&mut self) -> bool where T: Ord {\n         // These cases only have 1 permutation each, so we can't do anything.\n         if self.len() < 2 { return false; }\n \n@@ -581,7 +489,7 @@ impl<T: Ord> OrdSliceExt<T> for [T] {\n     }\n \n     #[experimental]\n-    fn prev_permutation(&mut self) -> bool {\n+    fn prev_permutation(&mut self) -> bool where T: Ord {\n         // These cases only have 1 permutation each, so we can't do anything.\n         if self.len() < 2 { return false; }\n \n@@ -610,19 +518,9 @@ impl<T: Ord> OrdSliceExt<T> for [T] {\n \n         true\n     }\n-}\n \n-/// Extension methods for slices on Clone elements\n-#[unstable = \"may merge with other traits\"]\n-#[allow(missing_docs)] // docs in libcollections\n-pub trait CloneSliceExt<T> for Sized? {\n-    fn clone_from_slice(&mut self, &[T]) -> uint;\n-}\n-\n-#[unstable = \"trait is unstable\"]\n-impl<T: Clone> CloneSliceExt<T> for [T] {\n     #[inline]\n-    fn clone_from_slice(&mut self, src: &[T]) -> uint {\n+    fn clone_from_slice(&mut self, src: &[T]) -> uint where T: Clone {\n         let min = cmp::min(self.len(), src.len());\n         let dst = self.slice_to_mut(min);\n         let src = src.slice_to(min);\n@@ -633,6 +531,79 @@ impl<T: Clone> CloneSliceExt<T> for [T] {\n     }\n }\n \n+impl<T> ops::Index<uint, T> for [T] {\n+    fn index(&self, &index: &uint) -> &T {\n+        assert!(index < self.len());\n+\n+        unsafe { mem::transmute(self.repr().data.offset(index as int)) }\n+    }\n+}\n+\n+impl<T> ops::IndexMut<uint, T> for [T] {\n+    fn index_mut(&mut self, &index: &uint) -> &mut T {\n+        assert!(index < self.len());\n+\n+        unsafe { mem::transmute(self.repr().data.offset(index as int)) }\n+    }\n+}\n+\n+impl<T> ops::Slice<uint, [T]> for [T] {\n+    #[inline]\n+    fn as_slice_<'a>(&'a self) -> &'a [T] {\n+        self\n+    }\n+\n+    #[inline]\n+    fn slice_from_or_fail<'a>(&'a self, start: &uint) -> &'a [T] {\n+        self.slice_or_fail(start, &self.len())\n+    }\n+\n+    #[inline]\n+    fn slice_to_or_fail<'a>(&'a self, end: &uint) -> &'a [T] {\n+        self.slice_or_fail(&0, end)\n+    }\n+    #[inline]\n+    fn slice_or_fail<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n+        assert!(*start <= *end);\n+        assert!(*end <= self.len());\n+        unsafe {\n+            transmute(RawSlice {\n+                    data: self.as_ptr().offset(*start as int),\n+                    len: (*end - *start)\n+                })\n+        }\n+    }\n+}\n+\n+impl<T> ops::SliceMut<uint, [T]> for [T] {\n+    #[inline]\n+    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n+        self\n+    }\n+\n+    #[inline]\n+    fn slice_from_or_fail_mut<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n+        let len = &self.len();\n+        self.slice_or_fail_mut(start, len)\n+    }\n+\n+    #[inline]\n+    fn slice_to_or_fail_mut<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n+        self.slice_or_fail_mut(&0, end)\n+    }\n+    #[inline]\n+    fn slice_or_fail_mut<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n+        assert!(*start <= *end);\n+        assert!(*end <= self.len());\n+        unsafe {\n+            transmute(RawSlice {\n+                    data: self.as_ptr().offset(*start as int),\n+                    len: (*end - *start)\n+                })\n+        }\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Common traits\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "ad2323296d97f5dcfb8d24700e4b852e1a33c7d8", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -32,35 +32,6 @@\n //! * `PartialOrd`\n //! * `Ord`\n //! * `Default`\n-//!\n-//! # Examples\n-//!\n-//! Using methods:\n-//!\n-//! ```\n-//! #[allow(deprecated)]\n-//! # fn main() {\n-//! let pair = (\"pi\", 3.14f64);\n-//! assert_eq!(pair.val0(), \"pi\");\n-//! assert_eq!(pair.val1(), 3.14f64);\n-//! # }\n-//! ```\n-//!\n-//! Using traits implemented for tuples:\n-//!\n-//! ```\n-//! use std::default::Default;\n-//!\n-//! let a = (1i, 2i);\n-//! let b = (3i, 4i);\n-//! assert!(a != b);\n-//!\n-//! let c = b.clone();\n-//! assert!(b == c);\n-//!\n-//! let d : (u32, f32) = Default::default();\n-//! assert_eq!(d, (0u32, 0.0f32));\n-//! ```\n \n #![stable]\n "}, {"sha": "f8e943ec9f651a9bef01e5e5c2388dc6b24beabb", "filename": "src/libcoretest/atomic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcoretest%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcoretest%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fatomic.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -70,9 +70,9 @@ fn int_xor() {\n     assert_eq!(x.load(SeqCst), 0xf731 ^ 0x137f);\n }\n \n-static S_BOOL : AtomicBool = INIT_ATOMIC_BOOL;\n-static S_INT  : AtomicInt  = INIT_ATOMIC_INT;\n-static S_UINT : AtomicUint = INIT_ATOMIC_UINT;\n+static S_BOOL : AtomicBool = ATOMIC_BOOL_INIT;\n+static S_INT  : AtomicInt  = ATOMIC_INT_INIT;\n+static S_UINT : AtomicUint = ATOMIC_UINT_INIT;\n \n #[test]\n fn static_init() {"}, {"sha": "992c99f1f9fe0a609ee8e12a542ff96f0a062a92", "filename": "src/libcoretest/cmp.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcoretest%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcoretest%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcmp.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::cmp::{ partial_min, partial_max };\n+use core::cmp::{partial_min, partial_max};\n+use core::cmp::Ordering::{Less, Greater, Equal};\n \n #[test]\n fn test_int_totalord() {"}, {"sha": "7952c96a117cf77d30c3a57858b315d82d6fa312", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -10,6 +10,7 @@\n \n use core::iter::*;\n use core::iter::order::*;\n+use core::iter::MinMaxResult::*;\n use core::num::SignedInt;\n use core::uint;\n use core::cmp;"}, {"sha": "e409dc61510f6e3ecc5a0a9f37271eaa62bd80ab", "filename": "src/libcoretest/num/int_macros.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fint_macros.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -17,6 +17,7 @@ mod tests {\n     use core::int;\n     use core::num::{FromStrRadix, Int, SignedInt};\n     use core::str::from_str;\n+    use core::ops::{Shl, Shr, Not, BitXor, BitAnd, BitOr};\n     use num;\n \n     #[test]"}, {"sha": "82e91c5b7120a6af93dc5812ba68e01e8f2357cb", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -13,6 +13,7 @@ use core::fmt::Show;\n use core::num::{NumCast, cast};\n use core::ops::{Add, Sub, Mul, Div, Rem};\n use core::kinds::Copy;\n+use std::str::from_str;\n \n mod int_macros;\n mod i8;\n@@ -54,6 +55,7 @@ mod test {\n     use core::option::Option::{Some, None};\n     use core::num::Float;\n     use core::num::from_str_radix;\n+    use core::str::from_str;\n \n     #[test]\n     fn from_str_issue7588() {"}, {"sha": "2311c19d5573ae0200d571f7c922ff15a237f2a8", "filename": "src/libcoretest/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fuint_macros.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -16,6 +16,7 @@ mod tests {\n     use core::$T_i::*;\n     use core::num::Int;\n     use num;\n+    use core::ops::{BitOr, BitAnd, BitXor, Shl, Shr, Not};\n \n     #[test]\n     fn test_overflows() {"}, {"sha": "fc02f46724fb8a5c466a968b89af00434da7ac1a", "filename": "src/libcoretest/str.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcoretest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcoretest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fstr.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::str::from_str;\n+\n #[test]\n fn test_bool_from_str() {\n     assert_eq!(from_str::<bool>(\"true\"), Some(true));"}, {"sha": "c3bc38a6614b8ce270ccd214cfddb212d0581151", "filename": "src/libcoretest/tuple.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcoretest%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibcoretest%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ftuple.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::cmp::Ordering::{Equal, Less, Greater};\n+\n #[test]\n fn test_clone() {\n     let a = (1i, \"2\");"}, {"sha": "01e55fb2edd9a9e58ab807e543d55fbf39378f25", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -47,6 +47,7 @@\n //! which is cyclic.\n //!\n //! ```rust\n+//! use std::borrow::IntoCow;\n //! use graphviz as dot;\n //!\n //! type Nd = int;\n@@ -146,6 +147,7 @@\n //! entity `&sube`).\n //!\n //! ```rust\n+//! use std::borrow::IntoCow;\n //! use graphviz as dot;\n //!\n //! type Nd = uint;\n@@ -201,6 +203,7 @@\n //! Hasse-diagram for the subsets of the set `{x, y}`.\n //!\n //! ```rust\n+//! use std::borrow::IntoCow;\n //! use graphviz as dot;\n //!\n //! type Nd<'a> = (uint, &'a str);\n@@ -273,6 +276,7 @@\n \n pub use self::LabelText::*;\n \n+use std::borrow::IntoCow;\n use std::io;\n use std::str::CowString;\n use std::vec::CowVec;\n@@ -586,6 +590,7 @@ mod tests {\n     use super::{Nodes, Edges, GraphWalk, render};\n     use std::io::IoResult;\n     use std::str;\n+    use std::borrow::IntoCow;\n \n     /// each node is an index in a vector in the graph.\n     type Node = uint;"}, {"sha": "d0396ddc7adcc21504039c20f8a9f484a0e2e08a", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -12,8 +12,10 @@\n \n pub use self::MaybeOwnedVector::*;\n \n+use std::cmp::{Equiv, Ordering};\n use std::default::Default;\n use std::fmt;\n+use std::iter::FromIterator;\n use std::path::BytesContainer;\n use std::slice;\n \n@@ -96,9 +98,9 @@ impl<'a, T: Ord> Ord for MaybeOwnedVector<'a, T> {\n }\n \n #[allow(deprecated)]\n-impl<'a, T: PartialEq, Sized? V: AsSlice<T>> Equiv<V> for MaybeOwnedVector<'a, T> {\n-    fn equiv(&self, other: &V) -> bool {\n-        self.as_slice() == other.as_slice()\n+impl<'a, T: PartialEq> Equiv<[T]> for MaybeOwnedVector<'a, T> {\n+    fn equiv(&self, other: &[T]) -> bool {\n+        self.as_slice() == other\n     }\n }\n \n@@ -125,7 +127,7 @@ impl<'a,T> FromIterator<T> for MaybeOwnedVector<'a,T> {\n     fn from_iter<I:Iterator<T>>(iterator: I) -> MaybeOwnedVector<'a,T> {\n         // If we are building from scratch, might as well build the\n         // most flexible variant.\n-        Growable(FromIterator::from_iter(iterator))\n+        Growable(iterator.collect())\n     }\n }\n "}, {"sha": "4ee5b2d5e834991db0dcde74e74ceef76a1d92f2", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -352,7 +352,7 @@ pub struct LogLocation {\n #[doc(hidden)]\n pub fn mod_enabled(level: u32, module: &str) -> bool {\n     static INIT: Once = ONCE_INIT;\n-    INIT.doit(init);\n+    INIT.call_once(init);\n \n     // It's possible for many threads are in this function, only one of them\n     // will perform the global initialization, but all of them will need to check"}, {"sha": "8e6c7de305f823edc50450f7055d633aeb7f14e8", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -206,7 +206,7 @@ impl Rand for ChaChaRng {\n \n #[cfg(test)]\n mod test {\n-    use std::prelude::*;\n+    use std::prelude::v1::*;\n \n     use core::iter::order;\n     use {Rng, SeedableRng};"}, {"sha": "981b0eeee53e0c55187dcbe2409ab26c3fefde29", "filename": "src/librand/distributions/exponential.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrand%2Fdistributions%2Fexponential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrand%2Fdistributions%2Fexponential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fexponential.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -94,7 +94,7 @@ impl IndependentSample<f64> for Exp {\n \n #[cfg(test)]\n mod test {\n-    use std::prelude::*;\n+    use std::prelude::v1::*;\n \n     use distributions::{Sample, IndependentSample};\n     use super::Exp;\n@@ -124,7 +124,7 @@ mod test {\n mod bench {\n     extern crate test;\n \n-    use std::prelude::*;\n+    use std::prelude::v1::*;\n \n     use self::test::Bencher;\n     use std::mem::size_of;"}, {"sha": "378029d1f9b377df231d85969c8d23f6cb5a074e", "filename": "src/librand/distributions/gamma.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fgamma.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -323,7 +323,7 @@ impl IndependentSample<f64> for StudentT {\n \n #[cfg(test)]\n mod test {\n-    use std::prelude::*;\n+    use std::prelude::v1::*;\n \n     use distributions::{Sample, IndependentSample};\n     use super::{ChiSquared, StudentT, FisherF};\n@@ -385,7 +385,7 @@ mod test {\n #[cfg(test)]\n mod bench {\n     extern crate test;\n-    use std::prelude::*;\n+    use std::prelude::v1::*;\n     use self::test::Bencher;\n     use std::mem::size_of;\n     use distributions::IndependentSample;"}, {"sha": "d0123d9c76c997f8206341d6125f8e817fc3fb23", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -258,7 +258,7 @@ fn ziggurat<R: Rng, P, Z>(\n \n #[cfg(test)]\n mod tests {\n-    use std::prelude::*;\n+    use std::prelude::v1::*;\n \n     use {Rng, Rand};\n     use super::{RandSample, WeightedChoice, Weighted, Sample, IndependentSample};"}, {"sha": "543e236f96dd2ab0c451b4120b35cd54696a1f33", "filename": "src/librand/distributions/normal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrand%2Fdistributions%2Fnormal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrand%2Fdistributions%2Fnormal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fnormal.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -160,7 +160,7 @@ impl IndependentSample<f64> for LogNormal {\n \n #[cfg(test)]\n mod tests {\n-    use std::prelude::*;\n+    use std::prelude::v1::*;\n \n     use distributions::{Sample, IndependentSample};\n     use super::{Normal, LogNormal};\n@@ -200,7 +200,7 @@ mod tests {\n #[cfg(test)]\n mod bench {\n     extern crate test;\n-    use std::prelude::*;\n+    use std::prelude::v1::*;\n     use self::test::Bencher;\n     use std::mem::size_of;\n     use distributions::{Sample};"}, {"sha": "558fa2012567591e312d39a657e2f9480bc0337c", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -164,7 +164,7 @@ float_impl! { f64 }\n #[cfg(test)]\n mod tests {\n     use std::num::Int;\n-    use std::prelude::*;\n+    use std::prelude::v1::*;\n     use distributions::{Sample, IndependentSample};\n     use super::Range;\n "}, {"sha": "1ea4784407592d44b95bbe4dea2da79619cf9db8", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -487,7 +487,7 @@ impl Rand for Isaac64Rng {\n \n #[cfg(test)]\n mod test {\n-    use std::prelude::*;\n+    use std::prelude::v1::*;\n \n     use core::iter::order;\n     use {Rng, SeedableRng};"}, {"sha": "bbcd99afdea9331330a1349e565f19964ada79f4", "filename": "src/librand/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -52,14 +52,14 @@ pub mod reseeding;\n mod rand_impls;\n \n /// A type that can be randomly generated using an `Rng`.\n-pub trait Rand {\n+pub trait Rand : Sized {\n     /// Generates a random instance of this type using the specified source of\n     /// randomness.\n     fn rand<R: Rng>(rng: &mut R) -> Self;\n }\n \n /// A random number generator.\n-pub trait Rng {\n+pub trait Rng : Sized {\n     /// Return the next random u32.\n     ///\n     /// This rarely needs to be called directly, prefer `r.gen()` to"}, {"sha": "c331807c1b9d3d0acb3175635a1e1000cbbe31bc", "filename": "src/librand/rand_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Frand_impls.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -214,7 +214,7 @@ impl<T:Rand> Rand for Option<T> {\n \n #[cfg(test)]\n mod tests {\n-    use std::prelude::*;\n+    use std::prelude::v1::*;\n     use std::rand::{Rng, thread_rng, Open01, Closed01};\n \n     struct ConstantRng(u64);"}, {"sha": "46371d427e63fba95ad0cd60f01f00d9d5102fee", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -149,7 +149,7 @@ impl Default for ReseedWithDefault {\n \n #[cfg(test)]\n mod test {\n-    use std::prelude::*;\n+    use std::prelude::v1::*;\n \n     use core::iter::order;\n     use super::{ReseedingRng, ReseedWithDefault};"}, {"sha": "3171966a596dbad5e8167493154847818c8e6296", "filename": "src/libregex/re.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -11,6 +11,7 @@\n pub use self::NamesIter::*;\n pub use self::Regex::*;\n \n+use std::borrow::IntoCow;\n use std::collections::HashMap;\n use std::fmt;\n use std::str::CowString;"}, {"sha": "603ca57d15d5bc010ae1575ca2a5cb28889c0b2d", "filename": "src/libregex/vm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibregex%2Fvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibregex%2Fvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fvm.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -37,6 +37,7 @@ pub use self::MatchKind::*;\n pub use self::StepState::*;\n \n use std::cmp;\n+use std::cmp::Ordering::{mod, Less, Equal, Greater};\n use std::mem;\n use std::iter::repeat;\n use std::slice::SliceExt;"}, {"sha": "cdc27244dde6ea6dde1650a75750bf0fd5944939", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -22,10 +22,12 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n+#![allow(unknown_features)]\n #![feature(default_type_params, globs, macro_rules, phase, quote)]\n #![feature(slicing_syntax, unsafe_destructor)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(unboxed_closures)]\n+#![feature(old_orphan_check)]\n \n extern crate arena;\n extern crate flate;\n@@ -98,6 +100,7 @@ pub mod middle {\n     pub mod traits;\n     pub mod ty;\n     pub mod ty_fold;\n+    pub mod ty_walk;\n     pub mod weak_lang_items;\n }\n "}, {"sha": "c314fba91d59e1d16cf64d237f580c2c6afebf47", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -36,10 +36,11 @@ use util::ppaux::{ty_to_string};\n use util::nodemap::{FnvHashMap, NodeSet};\n use lint::{Context, LintPass, LintArray};\n \n-use std::{cmp, slice};\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::num::SignedInt;\n+use std::{cmp, slice};\n use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n+\n use syntax::{abi, ast, ast_map};\n use syntax::ast_util::is_shift_binop;\n use syntax::attr::{mod, AttrMetaMethods};"}, {"sha": "a25b6d8b8fa4688a0821bc8285699ba4188e41c3", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -32,13 +32,15 @@ use middle::ty::{ImplContainer, TraitContainer};\n use middle::ty::{mod, Ty};\n use middle::astencode::vtable_decoder_helpers;\n \n+use std::collections::HashMap;\n use std::hash::Hash;\n use std::hash;\n use std::io::extensions::u64_from_be_bytes;\n use std::io;\n-use std::collections::hash_map::HashMap;\n+use std::num::FromPrimitive;\n use std::rc::Rc;\n use std::str;\n+\n use rbml::reader;\n use rbml;\n use serialize::Decodable;\n@@ -441,9 +443,15 @@ pub fn get_impl_trait<'tcx>(cdata: Cmd,\n                             -> Option<Rc<ty::TraitRef<'tcx>>>\n {\n     let item_doc = lookup_item(id, cdata.data());\n-    reader::maybe_get_doc(item_doc, tag_item_trait_ref).map(|tp| {\n-        doc_trait_ref(tp, tcx, cdata)\n-    })\n+    let fam = item_family(item_doc);\n+    match fam {\n+        Family::Impl => {\n+            reader::maybe_get_doc(item_doc, tag_item_trait_ref).map(|tp| {\n+                doc_trait_ref(tp, tcx, cdata)\n+            })\n+        }\n+        _ => None\n+    }\n }\n \n pub fn get_impl_vtables<'tcx>(cdata: Cmd,\n@@ -1273,9 +1281,9 @@ pub fn each_impl<F>(cdata: Cmd, mut callback: F) where\n }\n \n pub fn each_implementation_for_type<F>(cdata: Cmd,\n-                                    id: ast::NodeId,\n-                                    mut callback: F) where\n-    F: FnMut(ast::DefId),\n+                                       id: ast::NodeId,\n+                                       mut callback: F)\n+    where F: FnMut(ast::DefId),\n {\n     let item_doc = lookup_item(id, cdata.data());\n     reader::tagged_docs(item_doc,"}, {"sha": "10383b901f38a1ad4b097946ed7d28dc47332bf7", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -1222,8 +1222,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_attributes(rbml_w, item.attrs[]);\n         encode_unsafety(rbml_w, unsafety);\n         match ty.node {\n-            ast::TyPath(ref path, _) if path.segments\n-                                                        .len() == 1 => {\n+            ast::TyPath(ref path, _) if path.segments.len() == 1 => {\n                 let ident = path.segments.last().unwrap().identifier;\n                 encode_impl_type_basename(rbml_w, ident);\n             }\n@@ -1351,6 +1350,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // Encode the implementations of this trait.\n         encode_extension_implementations(ecx, rbml_w, def_id);\n \n+        // Encode inherent implementations for this trait.\n+        encode_inherent_implementations(ecx, rbml_w, def_id);\n+\n         rbml_w.end_tag();\n \n         // Now output the trait item info for each trait item.\n@@ -1453,9 +1455,6 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n             rbml_w.end_tag();\n         }\n-\n-        // Encode inherent implementations for this trait.\n-        encode_inherent_implementations(ecx, rbml_w, def_id);\n       }\n       ast::ItemMac(..) => {\n         // macros are encoded separately"}, {"sha": "2d3ff95ffa66e64b2085d3289d6e832201740229", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -25,7 +25,6 @@ use middle::ty::{mod, AsPredicate, Ty};\n \n use std::rc::Rc;\n use std::str;\n-use std::string::String;\n use syntax::abi;\n use syntax::ast;\n use syntax::parse::token;"}, {"sha": "06fef66c1e0033609f053b0e8ca3b6190f3c2c9f", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -11,7 +11,9 @@\n /// This module provides linkage between rustc::middle::graph and\n /// libgraphviz traits.\n \n-/// For clarity, rename the graphviz crate locally to dot.\n+use std::borrow::IntoCow;\n+\n+// For clarity, rename the graphviz crate locally to dot.\n use graphviz as dot;\n \n use syntax::ast;"}, {"sha": "d16224ec5b8ac19c79b2db17bb51b382bd96b25d", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -24,8 +24,7 @@ use middle::pat_util::*;\n use middle::ty::*;\n use middle::ty;\n use std::fmt;\n-use std::iter::AdditiveIterator;\n-use std::iter::{range_inclusive, repeat};\n+use std::iter::{range_inclusive, AdditiveIterator, FromIterator, repeat};\n use std::num::Float;\n use std::slice;\n use syntax::ast::{mod, DUMMY_NODE_ID, NodeId, Pat};"}, {"sha": "9fc5cb03353138b46ef8dba1d5717fd4b6532da5", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -27,8 +27,8 @@ use syntax::ptr::P;\n use syntax::visit::{mod, Visitor};\n use syntax::{ast_map, ast_util, codemap};\n \n-use std::rc::Rc;\n use std::collections::hash_map::Entry::Vacant;\n+use std::rc::Rc;\n \n //\n // This pass classifies expressions by their constant-ness."}, {"sha": "ab6f6b601f6d039c4afbee04ec68dd5e0cb5d802", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -57,7 +57,7 @@ use syntax::ast;\n use syntax::abi;\n use syntax::codemap::Span;\n \n-pub trait Combine<'tcx> {\n+pub trait Combine<'tcx> : Sized {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx>;\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.infcx().tcx }\n     fn tag(&self) -> String;"}, {"sha": "b6020fe5ce38bf3d142ff2b826ac408914e6235c", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -73,7 +73,7 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n     let output_path = {\n         let output_template = match requested_output {\n             Some(ref s) if s.as_slice() == \"help\" => {\n-                static PRINTED_YET : atomic::AtomicBool = atomic::INIT_ATOMIC_BOOL;\n+                static PRINTED_YET : atomic::AtomicBool = atomic::ATOMIC_BOOL_INIT;\n                 if !PRINTED_YET.load(atomic::SeqCst) {\n                     print_help_message();\n                     PRINTED_YET.store(true, atomic::SeqCst);"}, {"sha": "6ac1c5470cc755f2abda790cc38f69ff7421bebb", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -33,8 +33,9 @@ use util::nodemap::{FnvHashMap, FnvHashSet};\n use util::ppaux::Repr;\n \n use std::cell::{Cell, RefCell};\n-use std::u32;\n+use std::cmp::Ordering::{mod, Less, Greater, Equal};\n use std::iter::repeat;\n+use std::u32;\n use syntax::ast;\n \n mod doc;"}, {"sha": "78fabcd588a28353ea6021f9535895089971f516", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -36,6 +36,7 @@ use syntax::visit::Visitor;\n use syntax::visit;\n \n use std::iter::Enumerate;\n+use std::num::FromPrimitive;\n use std::slice;\n \n // The actual lang items defined come at the end of this file in one handy table."}, {"sha": "0e47f338bb91a653dea2ee42c2289544e4dcfaa6", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -649,7 +649,10 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n         Some(ref expr) => {\n             record_rvalue_scope_if_borrow_expr(visitor, &**expr, blk_scope);\n \n-            if is_binding_pat(&*local.pat) || is_borrowed_ty(&*local.ty) {\n+            let is_borrow =\n+                if let Some(ref ty) = local.ty { is_borrowed_ty(&**ty) } else { false };\n+\n+            if is_binding_pat(&*local.pat) || is_borrow {\n                 record_rvalue_scope(visitor, &**expr, blk_scope);\n             }\n         }"}, {"sha": "505352fa1234462801e06c5d95abbece2acce6d7", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -11,7 +11,8 @@\n //! A pass that annotates every item and method with its stability level,\n //! propagating default levels lexically from parent to children ast nodes.\n \n-use util::nodemap::{NodeMap, DefIdMap};\n+use middle::ty;\n+use metadata::csearch;\n use syntax::codemap::Span;\n use syntax::{attr, visit};\n use syntax::ast;\n@@ -21,8 +22,8 @@ use syntax::ast::{TypeMethod, Method, Generics, StructField, TypeTraitItem};\n use syntax::ast_util::is_local;\n use syntax::attr::Stability;\n use syntax::visit::{FnKind, FkMethod, Visitor};\n-use middle::ty;\n-use metadata::csearch;\n+use util::nodemap::{NodeMap, DefIdMap};\n+use util::ppaux::Repr;\n \n use std::mem::replace;\n \n@@ -154,10 +155,13 @@ impl Index {\n /// Lookup the stability for a node, loading external crate\n /// metadata as necessary.\n pub fn lookup(tcx: &ty::ctxt, id: DefId) -> Option<Stability> {\n+    debug!(\"lookup(id={})\",\n+           id.repr(tcx));\n+\n     // is this definition the implementation of a trait method?\n     match ty::trait_item_of_item(tcx, id) {\n-        Some(ty::MethodTraitItemId(trait_method_id))\n-                if trait_method_id != id => {\n+        Some(ty::MethodTraitItemId(trait_method_id)) if trait_method_id != id => {\n+            debug!(\"lookup: trait_method_id={}\", trait_method_id);\n             return lookup(tcx, trait_method_id)\n         }\n         _ => {}\n@@ -178,6 +182,7 @@ pub fn lookup(tcx: &ty::ctxt, id: DefId) -> Option<Stability> {\n             // stability of the trait to determine the stability of any\n             // unmarked impls for it. See FIXME above for more details.\n \n+            debug!(\"lookup: trait_id={}\", trait_id);\n             lookup(tcx, trait_id)\n         } else {\n             None"}, {"sha": "97e74b9f6bbb9ecb8987db0c2534da9a5ba10e32", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -519,7 +519,7 @@ impl<'a,T> Iterator<(ParamSpace, uint, &'a T)> for EnumeratedItems<'a,T> {\n // `foo`. Or use `foo.subst_spanned(tcx, substs, Some(span))` when\n // there is more information available (for better errors).\n \n-pub trait Subst<'tcx> {\n+pub trait Subst<'tcx> : Sized {\n     fn subst(&self, tcx: &ty::ctxt<'tcx>, substs: &Substs<'tcx>) -> Self {\n         self.subst_spanned(tcx, substs, None)\n     }"}, {"sha": "4aff36c2624958764c83996cbe82af71f682efaa", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 82, "deletions": 71, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -14,10 +14,10 @@ use super::SelectionContext;\n use super::{Obligation, ObligationCause};\n use super::util;\n \n-use middle::subst;\n use middle::subst::Subst;\n use middle::ty::{mod, Ty};\n use middle::infer::InferCtxt;\n+use std::collections::HashSet;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::DUMMY_SP;\n@@ -52,9 +52,21 @@ pub fn impl_can_satisfy(infcx: &InferCtxt,\n     selcx.evaluate_impl(impl2_def_id, &obligation)\n }\n \n-pub fn impl_is_local(tcx: &ty::ctxt,\n-                     impl_def_id: ast::DefId)\n-                     -> bool\n+#[allow(missing_copy_implementations)]\n+pub enum OrphanCheckErr {\n+    NoLocalInputType,\n+    UncoveredTypeParameter(ty::ParamTy),\n+}\n+\n+/// Checks the coherence orphan rules. `impl_def_id` should be the\n+/// def-id of a trait impl. To pass, either the trait must be local, or else\n+/// two conditions must be satisfied:\n+///\n+/// 1. At least one of the input types must involve a local type.\n+/// 2. All type parameters must be covered by a local type.\n+pub fn orphan_check(tcx: &ty::ctxt,\n+                    impl_def_id: ast::DefId)\n+                    -> Result<(), OrphanCheckErr>\n {\n     debug!(\"impl_is_local({})\", impl_def_id.repr(tcx));\n \n@@ -63,99 +75,74 @@ pub fn impl_is_local(tcx: &ty::ctxt,\n     let trait_ref = ty::impl_trait_ref(tcx, impl_def_id).unwrap();\n     debug!(\"trait_ref={}\", trait_ref.repr(tcx));\n \n-    // If the trait is local to the crate, ok.\n+    // If the *trait* is local to the crate, ok.\n     if trait_ref.def_id.krate == ast::LOCAL_CRATE {\n         debug!(\"trait {} is local to current crate\",\n                trait_ref.def_id.repr(tcx));\n-        return true;\n+        return Ok(());\n     }\n \n-    // Otherwise, at least one of the input types must be local to the\n-    // crate.\n-    trait_ref.input_types().iter().any(|&t| ty_is_local(tcx, t))\n+    // Check condition 1: at least one type must be local.\n+    if !trait_ref.input_types().iter().any(|&t| ty_reaches_local(tcx, t)) {\n+        return Err(OrphanCheckErr::NoLocalInputType);\n+    }\n+\n+    // Check condition 2: type parameters must be \"covered\" by a local type.\n+    let covered_params: HashSet<_> =\n+        trait_ref.input_types().iter()\n+                               .flat_map(|&t| type_parameters_covered_by_ty(tcx, t).into_iter())\n+                               .collect();\n+    let all_params: HashSet<_> =\n+        trait_ref.input_types().iter()\n+                               .flat_map(|&t| type_parameters_reachable_from_ty(t).into_iter())\n+                               .collect();\n+    for &param in all_params.difference(&covered_params) {\n+        return Err(OrphanCheckErr::UncoveredTypeParameter(param));\n+    }\n+\n+    return Ok(());\n+}\n+\n+fn ty_reaches_local<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n+    ty.walk().any(|t| ty_is_local_constructor(tcx, t))\n }\n \n-pub fn ty_is_local<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    debug!(\"ty_is_local({})\", ty.repr(tcx));\n+fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n+    debug!(\"ty_is_local_constructor({})\", ty.repr(tcx));\n \n     match ty.sty {\n         ty::ty_bool |\n         ty::ty_char |\n         ty::ty_int(..) |\n         ty::ty_uint(..) |\n         ty::ty_float(..) |\n-        ty::ty_str(..) => {\n-            false\n-        }\n-\n-        ty::ty_unboxed_closure(..) => {\n-            // This routine is invoked on types specified by users as\n-            // part of an impl and hence an unboxed closure type\n-            // cannot appear.\n-            tcx.sess.bug(\"ty_is_local applied to unboxed closure type\")\n-        }\n-\n+        ty::ty_str(..) |\n         ty::ty_bare_fn(..) |\n-        ty::ty_closure(..) => {\n+        ty::ty_closure(..) |\n+        ty::ty_vec(..) |\n+        ty::ty_ptr(..) |\n+        ty::ty_rptr(..) |\n+        ty::ty_tup(..) |\n+        ty::ty_param(..) |\n+        ty::ty_projection(..) => {\n             false\n         }\n \n-        ty::ty_uniq(t) => {\n-            let krate = tcx.lang_items.owned_box().map(|d| d.krate);\n-            krate == Some(ast::LOCAL_CRATE) || ty_is_local(tcx, t)\n-        }\n-\n-        ty::ty_vec(t, _) |\n-        ty::ty_ptr(ty::mt { ty: t, .. }) |\n-        ty::ty_rptr(_, ty::mt { ty: t, .. }) => {\n-            ty_is_local(tcx, t)\n-        }\n-\n-        ty::ty_tup(ref ts) => {\n-            ts.iter().any(|&t| ty_is_local(tcx, t))\n+        ty::ty_enum(def_id, _) |\n+        ty::ty_struct(def_id, _) => {\n+            def_id.krate == ast::LOCAL_CRATE\n         }\n \n-        ty::ty_enum(def_id, ref substs) |\n-        ty::ty_struct(def_id, ref substs) => {\n-            def_id.krate == ast::LOCAL_CRATE || {\n-                let variances = ty::item_variances(tcx, def_id);\n-                subst::ParamSpace::all().iter().any(|&space| {\n-                    substs.types.get_slice(space).iter().enumerate().any(\n-                        |(i, &t)| {\n-                            match *variances.types.get(space, i) {\n-                                ty::Bivariant => {\n-                                    // If Foo<T> is bivariant with respect to\n-                                    // T, then it doesn't matter whether T is\n-                                    // local or not, because `Foo<U>` for any\n-                                    // U will be a subtype of T.\n-                                    false\n-                                }\n-                                ty::Contravariant |\n-                                ty::Covariant |\n-                                ty::Invariant => {\n-                                    ty_is_local(tcx, t)\n-                                }\n-                            }\n-                        })\n-                })\n-            }\n+        ty::ty_uniq(_) => { // treat ~T like Box<T>\n+            let krate = tcx.lang_items.owned_box().map(|d| d.krate);\n+            krate == Some(ast::LOCAL_CRATE)\n         }\n \n         ty::ty_trait(ref tt) => {\n             tt.principal_def_id().krate == ast::LOCAL_CRATE\n         }\n \n-        // Type parameters may be bound to types that are not local to\n-        // the crate.\n-        ty::ty_param(..) => {\n-            false\n-        }\n-\n-        // Associated types could be anything, I guess.\n-        ty::ty_projection(..) => {\n-            false\n-        }\n-\n+        ty::ty_unboxed_closure(..) |\n         ty::ty_infer(..) |\n         ty::ty_open(..) |\n         ty::ty_err => {\n@@ -165,3 +152,27 @@ pub fn ty_is_local<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         }\n     }\n }\n+\n+fn type_parameters_covered_by_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                 ty: Ty<'tcx>)\n+                                 -> HashSet<ty::ParamTy>\n+{\n+    if ty_is_local_constructor(tcx, ty) {\n+        type_parameters_reachable_from_ty(ty)\n+    } else {\n+        ty.walk_children().flat_map(|t| type_parameters_covered_by_ty(tcx, t).into_iter()).collect()\n+    }\n+}\n+\n+/// All type parameters reachable from `ty`\n+fn type_parameters_reachable_from_ty<'tcx>(ty: Ty<'tcx>) -> HashSet<ty::ParamTy> {\n+    ty.walk()\n+        .filter_map(|t| {\n+            match t.sty {\n+                ty::ty_param(ref param_ty) => Some(param_ty.clone()),\n+                _ => None,\n+            }\n+        })\n+        .collect()\n+}\n+"}, {"sha": "c83898bcd8ade03d40abe184647606cf88ddef70", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -25,24 +25,33 @@ use syntax::codemap::{Span, DUMMY_SP};\n use util::ppaux::Repr;\n \n pub use self::error_reporting::report_fulfillment_errors;\n+pub use self::coherence::orphan_check;\n+pub use self::coherence::OrphanCheckErr;\n pub use self::fulfill::{FulfillmentContext, RegionObligation};\n pub use self::project::MismatchedProjectionTypes;\n pub use self::project::normalize;\n pub use self::project::Normalized;\n+pub use self::object_safety::is_object_safe;\n+pub use self::object_safety::object_safety_violations;\n+pub use self::object_safety::ObjectSafetyViolation;\n+pub use self::object_safety::MethodViolationCode;\n pub use self::select::SelectionContext;\n pub use self::select::SelectionCache;\n pub use self::select::{MethodMatchResult, MethodMatched, MethodAmbiguous, MethodDidNotMatch};\n pub use self::select::{MethodMatchedData}; // intentionally don't export variants\n pub use self::util::elaborate_predicates;\n+pub use self::util::get_vtable_index_of_object_method;\n pub use self::util::trait_ref_for_builtin_bound;\n pub use self::util::supertraits;\n pub use self::util::Supertraits;\n pub use self::util::transitive_bounds;\n+pub use self::util::upcast;\n \n mod coherence;\n mod error_reporting;\n mod fulfill;\n mod project;\n+mod object_safety;\n mod select;\n mod util;\n \n@@ -210,6 +219,9 @@ pub enum Vtable<'tcx, N> {\n     /// for some type parameter.\n     VtableParam,\n \n+    /// Virtual calls through an object\n+    VtableObject(VtableObjectData<'tcx>),\n+\n     /// Successful resolution for a builtin trait.\n     VtableBuiltin(VtableBuiltinData<N>),\n \n@@ -245,13 +257,11 @@ pub struct VtableBuiltinData<N> {\n     pub nested: subst::VecPerParamSpace<N>\n }\n \n-/// True if neither the trait nor self type is local. Note that `impl_def_id` must refer to an impl\n-/// of a trait, not an inherent impl.\n-pub fn is_orphan_impl(tcx: &ty::ctxt,\n-                      impl_def_id: ast::DefId)\n-                      -> bool\n-{\n-    !coherence::impl_is_local(tcx, impl_def_id)\n+/// A vtable for some object-safe trait `Foo` automatically derived\n+/// for the object type `Foo`.\n+#[deriving(PartialEq,Eq,Clone)]\n+pub struct VtableObjectData<'tcx> {\n+    pub object_ty: Ty<'tcx>,\n }\n \n /// True if there exist types that satisfy both of the two given impls.\n@@ -365,6 +375,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableFnPointer(..) => (&[]).iter(),\n             VtableUnboxedClosure(..) => (&[]).iter(),\n             VtableParam => (&[]).iter(),\n+            VtableObject(_) => (&[]).iter(),\n             VtableBuiltin(ref i) => i.iter_nested(),\n         }\n     }\n@@ -375,6 +386,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableFnPointer(ref sig) => VtableFnPointer((*sig).clone()),\n             VtableUnboxedClosure(d, ref s) => VtableUnboxedClosure(d, s.clone()),\n             VtableParam => VtableParam,\n+            VtableObject(ref p) => VtableObject(p.clone()),\n             VtableBuiltin(ref b) => VtableBuiltin(b.map_nested(op)),\n         }\n     }\n@@ -387,6 +399,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableFnPointer(sig) => VtableFnPointer(sig),\n             VtableUnboxedClosure(d, s) => VtableUnboxedClosure(d, s),\n             VtableParam => VtableParam,\n+            VtableObject(p) => VtableObject(p),\n             VtableBuiltin(no) => VtableBuiltin(no.map_move_nested(op)),\n         }\n     }"}, {"sha": "6b7bf82af929355c76e38504f6aa9d95ba192b1f", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -0,0 +1,301 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! \"Object safety\" refers to the ability for a trait to be converted\n+//! to an object. In general, traits may only be converted to an\n+//! object if all of their methods meet certain criteria. In particular,\n+//! they must:\n+//!\n+//!   - have a suitable receiver from which we can extract a vtable;\n+//!   - not reference the erased type `Self` except for in this receiver;\n+//!   - not have generic type parameters\n+\n+use super::supertraits;\n+use super::elaborate_predicates;\n+\n+use middle::subst::{mod, SelfSpace};\n+use middle::traits;\n+use middle::ty::{mod, Ty};\n+use std::rc::Rc;\n+use syntax::ast;\n+use util::ppaux::Repr;\n+\n+pub enum ObjectSafetyViolation<'tcx> {\n+    /// Self : Sized declared on the trait\n+    SizedSelf,\n+\n+    /// Method has someting illegal\n+    Method(Rc<ty::Method<'tcx>>, MethodViolationCode),\n+}\n+\n+/// Reasons a method might not be object-safe.\n+#[deriving(Copy,Clone,Show)]\n+pub enum MethodViolationCode {\n+    /// e.g., `fn(self)`\n+    ByValueSelf,\n+\n+    /// e.g., `fn foo()`\n+    StaticMethod,\n+\n+    /// e.g., `fn foo(&self, x: Self)` or `fn foo(&self) -> Self`\n+    ReferencesSelf,\n+\n+    /// e.g., `fn foo<A>()`\n+    Generic,\n+}\n+\n+pub fn is_object_safe<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                            trait_ref: ty::PolyTraitRef<'tcx>)\n+                            -> bool\n+{\n+    // Because we query yes/no results frequently, we keep a cache:\n+    let cached_result =\n+        tcx.object_safety_cache.borrow().get(&trait_ref.def_id()).map(|&r| r);\n+\n+    let result =\n+        cached_result.unwrap_or_else(|| {\n+            let result = object_safety_violations(tcx, trait_ref.clone()).is_empty();\n+\n+            // Record just a yes/no result in the cache; this is what is\n+            // queried most frequently. Note that this may overwrite a\n+            // previous result, but always with the same thing.\n+            tcx.object_safety_cache.borrow_mut().insert(trait_ref.def_id(), result);\n+\n+            result\n+        });\n+\n+    debug!(\"is_object_safe({}) = {}\", trait_ref.repr(tcx), result);\n+\n+    result\n+}\n+\n+pub fn object_safety_violations<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                      sub_trait_ref: ty::PolyTraitRef<'tcx>)\n+                                      -> Vec<ObjectSafetyViolation<'tcx>>\n+{\n+    supertraits(tcx, sub_trait_ref)\n+        .flat_map(|tr| object_safety_violations_for_trait(tcx, tr.def_id()).into_iter())\n+        .collect()\n+}\n+\n+fn object_safety_violations_for_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                            trait_def_id: ast::DefId)\n+                                            -> Vec<ObjectSafetyViolation<'tcx>>\n+{\n+    // Check methods for violations.\n+    let mut violations: Vec<_> =\n+        ty::trait_items(tcx, trait_def_id).iter()\n+        .flat_map(|item| {\n+            match *item {\n+                ty::MethodTraitItem(ref m) => {\n+                    object_safety_violations_for_method(tcx, trait_def_id, &**m)\n+                        .map(|code| ObjectSafetyViolation::Method(m.clone(), code))\n+                        .into_iter()\n+                }\n+                ty::TypeTraitItem(_) => {\n+                    None.into_iter()\n+                }\n+            }\n+        })\n+        .collect();\n+\n+    // Check the trait itself.\n+    if trait_has_sized_self(tcx, trait_def_id) {\n+        violations.push(ObjectSafetyViolation::SizedSelf);\n+    }\n+\n+    debug!(\"object_safety_violations_for_trait(trait_def_id={}) = {}\",\n+           trait_def_id.repr(tcx),\n+           violations.repr(tcx));\n+\n+    violations\n+}\n+\n+fn trait_has_sized_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                              trait_def_id: ast::DefId)\n+                              -> bool\n+{\n+    let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n+    let param_env = ty::construct_parameter_environment(tcx,\n+                                                        &trait_def.generics,\n+                                                        ast::DUMMY_NODE_ID);\n+    let predicates = param_env.caller_bounds.predicates.as_slice().to_vec();\n+    let sized_def_id = match tcx.lang_items.sized_trait() {\n+        Some(def_id) => def_id,\n+        None => { return false; /* No Sized trait, can't require it! */ }\n+    };\n+\n+    // Search for a predicate like `Self : Sized` amongst the trait bounds.\n+    elaborate_predicates(tcx, predicates)\n+        .any(|predicate| {\n+            match predicate {\n+                ty::Predicate::Trait(ref trait_pred) if trait_pred.def_id() == sized_def_id => {\n+                    let self_ty = trait_pred.0.self_ty();\n+                    match self_ty.sty {\n+                        ty::ty_param(ref data) => data.space == subst::SelfSpace,\n+                        _ => false,\n+                    }\n+                }\n+                ty::Predicate::Projection(..) |\n+                ty::Predicate::Trait(..) |\n+                ty::Predicate::Equate(..) |\n+                ty::Predicate::RegionOutlives(..) |\n+                ty::Predicate::TypeOutlives(..) => {\n+                    false\n+                }\n+            }\n+        })\n+}\n+\n+fn object_safety_violations_for_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                             trait_def_id: ast::DefId,\n+                                             method: &ty::Method<'tcx>)\n+                                             -> Option<MethodViolationCode>\n+{\n+    // The method's first parameter must be something that derefs to\n+    // `&self`. For now, we only accept `&self` and `Box<Self>`.\n+    match method.explicit_self {\n+        ty::ByValueExplicitSelfCategory => {\n+            return Some(MethodViolationCode::ByValueSelf);\n+        }\n+\n+        ty::StaticExplicitSelfCategory => {\n+            return Some(MethodViolationCode::StaticMethod);\n+        }\n+\n+        ty::ByReferenceExplicitSelfCategory(..) |\n+        ty::ByBoxExplicitSelfCategory => {\n+        }\n+    }\n+\n+    // The `Self` type is erased, so it should not appear in list of\n+    // arguments or return type apart from the receiver.\n+    let ref sig = method.fty.sig;\n+    for &input_ty in sig.0.inputs[1..].iter() {\n+        if contains_illegal_self_type_reference(tcx, trait_def_id, input_ty) {\n+            return Some(MethodViolationCode::ReferencesSelf);\n+        }\n+    }\n+    if let ty::FnConverging(result_type) = sig.0.output {\n+        if contains_illegal_self_type_reference(tcx, trait_def_id, result_type) {\n+            return Some(MethodViolationCode::ReferencesSelf);\n+        }\n+    }\n+\n+    // We can't monomorphize things like `fn foo<A>(...)`.\n+    if !method.generics.types.is_empty_in(subst::FnSpace) {\n+        return Some(MethodViolationCode::Generic);\n+    }\n+\n+    None\n+}\n+\n+fn contains_illegal_self_type_reference<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                              trait_def_id: ast::DefId,\n+                                              ty: Ty<'tcx>)\n+                                              -> bool\n+{\n+    // This is somewhat subtle. In general, we want to forbid\n+    // references to `Self` in the argument and return types,\n+    // since the value of `Self` is erased. However, there is one\n+    // exception: it is ok to reference `Self` in order to access\n+    // an associated type of the current trait, since we retain\n+    // the value of those associated types in the object type\n+    // itself.\n+    //\n+    // ```rust\n+    // trait SuperTrait {\n+    //     type X;\n+    // }\n+    //\n+    // trait Trait : SuperTrait {\n+    //     type Y;\n+    //     fn foo(&self, x: Self) // bad\n+    //     fn foo(&self) -> Self // bad\n+    //     fn foo(&self) -> Option<Self> // bad\n+    //     fn foo(&self) -> Self::Y // OK, desugars to next example\n+    //     fn foo(&self) -> <Self as Trait>::Y // OK\n+    //     fn foo(&self) -> Self::X // OK, desugars to next example\n+    //     fn foo(&self) -> <Self as SuperTrait>::X // OK\n+    // }\n+    // ```\n+    //\n+    // However, it is not as simple as allowing `Self` in a projected\n+    // type, because there are illegal ways to use `Self` as well:\n+    //\n+    // ```rust\n+    // trait Trait : SuperTrait {\n+    //     ...\n+    //     fn foo(&self) -> <Self as SomeOtherTrait>::X;\n+    // }\n+    // ```\n+    //\n+    // Here we will not have the type of `X` recorded in the\n+    // object type, and we cannot resolve `Self as SomeOtherTrait`\n+    // without knowing what `Self` is.\n+\n+    let mut supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>> = None;\n+    let mut error = false;\n+    ty::maybe_walk_ty(ty, |ty| {\n+        match ty.sty {\n+            ty::ty_param(ref param_ty) => {\n+                if param_ty.space == SelfSpace {\n+                    error = true;\n+                }\n+\n+                false // no contained types to walk\n+            }\n+\n+            ty::ty_projection(ref data) => {\n+                // This is a projected type `<Foo as SomeTrait>::X`.\n+\n+                // Compute supertraits of current trait lazilly.\n+                if supertraits.is_none() {\n+                    let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n+                    let trait_ref = ty::Binder(trait_def.trait_ref.clone());\n+                    supertraits = Some(traits::supertraits(tcx, trait_ref).collect());\n+                }\n+\n+                // Determine whether the trait reference `Foo as\n+                // SomeTrait` is in fact a supertrait of the\n+                // current trait. In that case, this type is\n+                // legal, because the type `X` will be specified\n+                // in the object type.  Note that we can just use\n+                // direct equality here because all of these types\n+                // are part of the formal parameter listing, and\n+                // hence there should be no inference variables.\n+                let projection_trait_ref = ty::Binder(data.trait_ref.clone());\n+                let is_supertrait_of_current_trait =\n+                    supertraits.as_ref().unwrap().contains(&projection_trait_ref);\n+\n+                if is_supertrait_of_current_trait {\n+                    false // do not walk contained types, do not report error, do collect $200\n+                } else {\n+                    true // DO walk contained types, POSSIBLY reporting an error\n+                }\n+            }\n+\n+            _ => true, // walk contained types, if any\n+        }\n+    });\n+\n+    error\n+}\n+\n+impl<'tcx> Repr<'tcx> for ObjectSafetyViolation<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        match *self {\n+            ObjectSafetyViolation::SizedSelf =>\n+                format!(\"SizedSelf\"),\n+            ObjectSafetyViolation::Method(ref m, code) =>\n+                format!(\"Method({},{})\", m.repr(tcx), code),\n+        }\n+    }\n+}"}, {"sha": "d7f570df07278b3ba3f3d85917644a4d095eeed4", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 51, "deletions": 31, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -21,8 +21,10 @@ use super::VtableImplData;\n \n use middle::infer;\n use middle::subst::Subst;\n-use middle::ty::{mod, AsPredicate, RegionEscape, HasProjectionTypes, ToPolyTraitRef, Ty};\n+use middle::ty::{mod, AsPredicate, ReferencesError, RegionEscape,\n+                 HasProjectionTypes, ToPolyTraitRef, Ty};\n use middle::ty_fold::{mod, TypeFoldable, TypeFolder};\n+use std::rc::Rc;\n use util::ppaux::Repr;\n \n pub type PolyProjectionObligation<'tcx> =\n@@ -372,25 +374,30 @@ fn project_type<'cx,'tcx>(\n         return Err(ProjectionTyError::TraitSelectionError(Overflow));\n     }\n \n+    let obligation_trait_ref =\n+        selcx.infcx().resolve_type_vars_if_possible(&obligation.predicate.trait_ref);\n+\n+    debug!(\"project: obligation_trait_ref={}\", obligation_trait_ref.repr(selcx.tcx()));\n+\n+    if obligation_trait_ref.references_error() {\n+        return Ok(ProjectedTy::Progress(selcx.tcx().types.err, vec!()));\n+    }\n+\n     let mut candidates = ProjectionTyCandidateSet {\n         vec: Vec::new(),\n         ambiguous: false,\n     };\n \n-    assemble_candidates_from_object_type(selcx,\n-                                         obligation,\n-                                         &mut candidates);\n+    assemble_candidates_from_param_env(selcx,\n+                                       obligation,\n+                                       &obligation_trait_ref,\n+                                       &mut candidates);\n \n-    if candidates.vec.is_empty() {\n-        assemble_candidates_from_param_env(selcx,\n-                                           obligation,\n-                                           &mut candidates);\n-\n-        if let Err(e) = assemble_candidates_from_impls(selcx,\n-                                                       obligation,\n-                                                       &mut candidates) {\n-            return Err(ProjectionTyError::TraitSelectionError(e));\n-        }\n+    if let Err(e) = assemble_candidates_from_impls(selcx,\n+                                                   obligation,\n+                                                   &obligation_trait_ref,\n+                                                   &mut candidates) {\n+        return Err(ProjectionTyError::TraitSelectionError(e));\n     }\n \n     debug!(\"{} candidates, ambiguous={}\",\n@@ -421,17 +428,20 @@ fn project_type<'cx,'tcx>(\n /// there that can answer this question.\n fn assemble_candidates_from_param_env<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n-    obligation:  &ProjectionTyObligation<'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n {\n     let env_predicates = selcx.param_env().caller_bounds.predicates.clone();\n     let env_predicates = env_predicates.iter().cloned().collect();\n-    assemble_candidates_from_predicates(selcx, obligation, candidate_set, env_predicates);\n+    assemble_candidates_from_predicates(selcx, obligation, obligation_trait_ref,\n+                                        candidate_set, env_predicates);\n }\n \n fn assemble_candidates_from_predicates<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n-    obligation:  &ProjectionTyObligation<'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n     env_predicates: Vec<ty::Predicate<'tcx>>)\n {\n@@ -445,7 +455,7 @@ fn assemble_candidates_from_predicates<'cx,'tcx>(\n                 let is_match = infcx.probe(|_| {\n                     let origin = infer::Misc(obligation.cause.span);\n                     let obligation_poly_trait_ref =\n-                        obligation.predicate.trait_ref.to_poly_trait_ref();\n+                        obligation_trait_ref.to_poly_trait_ref();\n                     let data_poly_trait_ref =\n                         data.to_poly_trait_ref();\n                     infcx.sub_poly_trait_refs(false,\n@@ -467,36 +477,41 @@ fn assemble_candidates_from_predicates<'cx,'tcx>(\n fn assemble_candidates_from_object_type<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation:  &ProjectionTyObligation<'tcx>,\n-    candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n+    obligation_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n+    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n+    object_ty: Ty<'tcx>)\n {\n     let infcx = selcx.infcx();\n-    let trait_ref = infcx.resolve_type_vars_if_possible(&obligation.predicate.trait_ref);\n-    debug!(\"assemble_candidates_from_object_type(trait_ref={})\",\n-           trait_ref.repr(infcx.tcx));\n-    let self_ty = trait_ref.self_ty();\n-    let data = match self_ty.sty {\n+    debug!(\"assemble_candidates_from_object_type(object_ty={})\",\n+           object_ty.repr(infcx.tcx));\n+    let data = match object_ty.sty {\n         ty::ty_trait(ref data) => data,\n-        _ => { return; }\n+        _ => {\n+            selcx.tcx().sess.span_bug(\n+                obligation.cause.span,\n+                format!(\"assemble_candidates_from_object_type called with non-object: {}\",\n+                        object_ty.repr(selcx.tcx()))[]);\n+        }\n     };\n-    let projection_bounds = data.projection_bounds_with_self_ty(selcx.tcx(), self_ty);\n+    let projection_bounds = data.projection_bounds_with_self_ty(selcx.tcx(), object_ty);\n     let env_predicates = projection_bounds.iter()\n                                           .map(|p| p.as_predicate())\n                                           .collect();\n-    assemble_candidates_from_predicates(selcx, obligation, candidate_set, env_predicates)\n+    assemble_candidates_from_predicates(selcx, obligation, obligation_trait_ref,\n+                                        candidate_set, env_predicates)\n }\n \n fn assemble_candidates_from_impls<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n     -> Result<(), SelectionError<'tcx>>\n {\n     // If we are resolving `<T as TraitRef<...>>::Item == Type`,\n     // start out by selecting the predicate `T as TraitRef<...>`:\n-    let trait_ref =\n-        obligation.predicate.trait_ref.to_poly_trait_ref();\n-    let trait_obligation =\n-        obligation.with(trait_ref.to_poly_trait_predicate());\n+    let poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n+    let trait_obligation = obligation.with(poly_trait_ref.to_poly_trait_predicate());\n     let vtable = match selcx.select(&trait_obligation) {\n         Ok(Some(vtable)) => vtable,\n         Ok(None) => {\n@@ -515,6 +530,11 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n             candidate_set.vec.push(\n                 ProjectionTyCandidate::Impl(data));\n         }\n+        super::VtableObject(data) => {\n+            assemble_candidates_from_object_type(\n+                selcx, obligation, obligation_trait_ref, candidate_set,\n+                data.object_ty);\n+        }\n         super::VtableParam(..) => {\n             // This case tell us nothing about the value of an\n             // associated type. Consider:"}, {"sha": "d09f2a250b0339bb88582569898793ef8e8c3958", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 154, "deletions": 21, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -24,8 +24,10 @@ use super::{ObligationCauseCode, BuiltinDerivedObligation};\n use super::{SelectionError, Unimplemented, Overflow, OutputTypeParameterMismatch};\n use super::{Selection};\n use super::{SelectionResult};\n-use super::{VtableBuiltin, VtableImpl, VtableParam, VtableUnboxedClosure, VtableFnPointer};\n-use super::{VtableImplData, VtableBuiltinData};\n+use super::{VtableBuiltin, VtableImpl, VtableParam, VtableUnboxedClosure,\n+            VtableFnPointer, VtableObject};\n+use super::{VtableImplData, VtableObjectData, VtableBuiltinData};\n+use super::object_safety;\n use super::{util};\n \n use middle::fast_reject;\n@@ -147,6 +149,8 @@ enum SelectionCandidate<'tcx> {\n     /// types generated for a fn pointer type (e.g., `fn(int)->int`)\n     FnPointerCandidate,\n \n+    ObjectCandidate,\n+\n     ErrorCandidate,\n }\n \n@@ -289,6 +293,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n+    fn evaluate_predicates_recursively<'a,'o,I>(&mut self,\n+                                                stack: Option<&TraitObligationStack<'o, 'tcx>>,\n+                                                mut predicates: I)\n+                                                -> EvaluationResult<'tcx>\n+        where I : Iterator<&'a PredicateObligation<'tcx>>, 'tcx:'a\n+    {\n+        let mut result = EvaluatedToOk;\n+        for obligation in predicates {\n+            match self.evaluate_predicate_recursively(stack, obligation) {\n+                EvaluatedToErr(e) => { return EvaluatedToErr(e); }\n+                EvaluatedToAmbig => { result = EvaluatedToAmbig; }\n+                EvaluatedToOk => { }\n+            }\n+        }\n+        result\n+    }\n+\n     fn evaluate_predicate_recursively<'o>(&mut self,\n                                           previous_stack: Option<&TraitObligationStack<'o, 'tcx>>,\n                                           obligation: &PredicateObligation<'tcx>)\n@@ -320,9 +341,22 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 EvaluatedToOk\n             }\n \n-            ty::Predicate::Projection(..) => {\n-                // FIXME(#20296) -- we should be able to give a more precise answer here\n-                EvaluatedToAmbig\n+            ty::Predicate::Projection(ref data) => {\n+                self.infcx.probe(|_| {\n+                    let project_obligation = obligation.with(data.clone());\n+                    match project::poly_project_and_unify_type(self, &project_obligation) {\n+                        Ok(Some(subobligations)) => {\n+                            self.evaluate_predicates_recursively(previous_stack,\n+                                                                 subobligations.iter())\n+                        }\n+                        Ok(None) => {\n+                            EvaluatedToAmbig\n+                        }\n+                        Err(_) => {\n+                            EvaluatedToErr(Unimplemented)\n+                        }\n+                    }\n+                })\n             }\n         }\n     }\n@@ -717,6 +751,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 try!(self.assemble_unboxed_closure_candidates(obligation, &mut candidates));\n                 try!(self.assemble_fn_pointer_candidates(obligation, &mut candidates));\n                 try!(self.assemble_candidates_from_impls(obligation, &mut candidates.vec));\n+                self.assemble_candidates_from_object_ty(obligation, &mut candidates);\n             }\n         }\n \n@@ -878,7 +913,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let matching_bounds =\n             all_bounds.filter(\n                 |bound| self.infcx.probe(\n-                    |_| self.match_where_clause(obligation, bound.clone())).is_ok());\n+                    |_| self.match_poly_trait_ref(obligation, bound.clone())).is_ok());\n \n         let param_candidates =\n             matching_bounds.map(|bound| ParamCandidate(bound));\n@@ -945,7 +980,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n         match self_ty.sty {\n-            ty::ty_infer(..) => {\n+            ty::ty_infer(ty::TyVar(_)) => {\n                 candidates.ambiguous = true; // could wind up being a fn() type\n             }\n \n@@ -991,6 +1026,62 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         Ok(())\n     }\n \n+    /// Search for impls that might apply to `obligation`.\n+    fn assemble_candidates_from_object_ty(&mut self,\n+                                          obligation: &TraitObligation<'tcx>,\n+                                          candidates: &mut SelectionCandidateSet<'tcx>)\n+    {\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+\n+        debug!(\"assemble_candidates_from_object_ty(self_ty={})\",\n+               self_ty.repr(self.tcx()));\n+\n+        // Object-safety candidates are only applicable to object-safe\n+        // traits. Including this check is useful because it helps\n+        // inference in cases of traits like `BorrowFrom`, which are\n+        // not object-safe, and which rely on being able to infer the\n+        // self-type from one of the other inputs. Without this check,\n+        // these cases wind up being considered ambiguous due to a\n+        // (spurious) ambiguity introduced here.\n+        if !object_safety::is_object_safe(self.tcx(), obligation.predicate.to_poly_trait_ref()) {\n+            return;\n+        }\n+\n+        let poly_trait_ref = match self_ty.sty {\n+            ty::ty_trait(ref data) => {\n+                data.principal_trait_ref_with_self_ty(self.tcx(), self_ty)\n+            }\n+            ty::ty_infer(ty::TyVar(_)) => {\n+                debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n+                candidates.ambiguous = true; // could wind up being an object type\n+                return;\n+            }\n+            _ => {\n+                return;\n+            }\n+        };\n+\n+        debug!(\"assemble_candidates_from_object_ty: poly_trait_ref={}\",\n+               poly_trait_ref.repr(self.tcx()));\n+\n+        // see whether the object trait can be upcast to the trait we are looking for\n+        let obligation_def_id = obligation.predicate.def_id();\n+        let upcast_trait_ref = match util::upcast(self.tcx(), poly_trait_ref, obligation_def_id) {\n+            Some(r) => r,\n+            None => { return; }\n+        };\n+\n+        debug!(\"assemble_candidates_from_object_ty: upcast_trait_ref={}\",\n+               upcast_trait_ref.repr(self.tcx()));\n+\n+        // check whether the upcast version of the trait-ref matches what we are looking for\n+        if let Ok(()) = self.infcx.probe(|_| self.match_poly_trait_ref(obligation,\n+                                                                       upcast_trait_ref.clone())) {\n+            debug!(\"assemble_candidates_from_object_ty: matched, pushing candidate\");\n+            candidates.vec.push(ObjectCandidate);\n+        }\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // WINNOW\n     //\n@@ -1026,15 +1117,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             selection: Selection<'tcx>)\n                             -> EvaluationResult<'tcx>\n     {\n-        let mut result = EvaluatedToOk;\n-        for obligation in selection.iter_nested() {\n-            match self.evaluate_predicate_recursively(stack, obligation) {\n-                EvaluatedToErr(e) => { return EvaluatedToErr(e); }\n-                EvaluatedToAmbig => { result = EvaluatedToAmbig; }\n-                EvaluatedToOk => { }\n-            }\n-        }\n-        result\n+        self.evaluate_predicates_recursively(stack, selection.iter_nested())\n     }\n \n     /// Returns true if `candidate_i` should be dropped in favor of `candidate_j`.\n@@ -1544,6 +1627,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(VtableUnboxedClosure(closure_def_id, substs))\n             }\n \n+            ObjectCandidate => {\n+                let data = self.confirm_object_candidate(obligation);\n+                Ok(VtableObject(data))\n+            }\n+\n             FnPointerCandidate => {\n                 let fn_type =\n                     try!(self.confirm_fn_pointer_candidate(obligation));\n@@ -1727,6 +1815,48 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                          nested: impl_predicates }\n     }\n \n+    fn confirm_object_candidate(&mut self,\n+                                obligation: &TraitObligation<'tcx>)\n+                                -> VtableObjectData<'tcx>\n+    {\n+        debug!(\"confirm_object_candidate({})\",\n+               obligation.repr(self.tcx()));\n+\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        let poly_trait_ref = match self_ty.sty {\n+            ty::ty_trait(ref data) => {\n+                data.principal_trait_ref_with_self_ty(self.tcx(), self_ty)\n+            }\n+            _ => {\n+                self.tcx().sess.span_bug(obligation.cause.span,\n+                                         \"object candidate with non-object\");\n+            }\n+        };\n+\n+        let obligation_def_id = obligation.predicate.def_id();\n+        let upcast_trait_ref = match util::upcast(self.tcx(),\n+                                                  poly_trait_ref.clone(),\n+                                                  obligation_def_id) {\n+            Some(r) => r,\n+            None => {\n+                self.tcx().sess.span_bug(obligation.cause.span,\n+                                         format!(\"unable to upcast from {} to {}\",\n+                                                 poly_trait_ref.repr(self.tcx()),\n+                                                 obligation_def_id.repr(self.tcx())).as_slice());\n+            }\n+        };\n+\n+        match self.match_poly_trait_ref(obligation, upcast_trait_ref) {\n+            Ok(()) => { }\n+            Err(()) => {\n+                self.tcx().sess.span_bug(obligation.cause.span,\n+                                         \"failed to match trait refs\");\n+            }\n+        }\n+\n+        VtableObjectData { object_ty: self_ty }\n+    }\n+\n     fn confirm_fn_pointer_candidate(&mut self,\n                                     obligation: &TraitObligation<'tcx>)\n                                     -> Result<ty::Ty<'tcx>,SelectionError<'tcx>>\n@@ -1962,12 +2092,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             })\n     }\n \n-    fn match_where_clause(&mut self,\n-                          obligation: &TraitObligation<'tcx>,\n-                          where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n-                        -> Result<(),()>\n+    fn match_poly_trait_ref(&mut self,\n+                            obligation: &TraitObligation<'tcx>,\n+                            where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n+                            -> Result<(),()>\n     {\n-        debug!(\"match_where_clause: obligation={} where_clause_trait_ref={}\",\n+        debug!(\"match_poly_trait_ref: obligation={} where_clause_trait_ref={}\",\n                obligation.repr(self.tcx()),\n                where_clause_trait_ref.repr(self.tcx()));\n \n@@ -2161,6 +2291,9 @@ impl<'tcx> Repr<'tcx> for SelectionCandidate<'tcx> {\n             ImplCandidate(a) => format!(\"ImplCandidate({})\", a.repr(tcx)),\n             ProjectionCandidate => format!(\"ProjectionCandidate\"),\n             FnPointerCandidate => format!(\"FnPointerCandidate\"),\n+            ObjectCandidate => {\n+                format!(\"ObjectCandidate\")\n+            }\n             UnboxedClosureCandidate(c, ref s) => {\n                 format!(\"UnboxedClosureCandidate({},{})\", c, s.repr(tcx))\n             }"}, {"sha": "41a59d6a5d84679b63d9a3c056bb9463a457bb87", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -238,6 +238,12 @@ impl<'tcx, N> fmt::Show for VtableImplData<'tcx, N> {\n     }\n }\n \n+impl<'tcx> fmt::Show for super::VtableObjectData<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableObject(...)\")\n+    }\n+}\n+\n /// See `super::obligations_for_generics`\n pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      cause: ObligationCause<'tcx>,\n@@ -291,6 +297,58 @@ pub fn predicate_for_builtin_bound<'tcx>(\n     })\n }\n \n+/// Cast a trait reference into a reference to one of its super\n+/// traits; returns `None` if `target_trait_def_id` is not a\n+/// supertrait.\n+pub fn upcast<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                    source_trait_ref: ty::PolyTraitRef<'tcx>,\n+                    target_trait_def_id: ast::DefId)\n+                    -> Option<ty::PolyTraitRef<'tcx>>\n+{\n+    if source_trait_ref.def_id() == target_trait_def_id {\n+        return Some(source_trait_ref); // shorcut the most common case\n+    }\n+\n+    for super_trait_ref in supertraits(tcx, source_trait_ref) {\n+        if super_trait_ref.def_id() == target_trait_def_id {\n+            return Some(super_trait_ref);\n+        }\n+    }\n+\n+    None\n+}\n+\n+/// Given an object of type `object_trait_ref`, returns the index of\n+/// the method `n_method` found in the trait `trait_def_id` (which\n+/// should be a supertrait of `object_trait_ref`) within the vtable\n+/// for `object_trait_ref`.\n+pub fn get_vtable_index_of_object_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                               object_trait_ref: ty::PolyTraitRef<'tcx>,\n+                                               trait_def_id: ast::DefId,\n+                                               method_index_in_trait: uint) -> uint {\n+    // We need to figure the \"real index\" of the method in a\n+    // listing of all the methods of an object. We do this by\n+    // iterating down the supertraits of the object's trait until\n+    // we find the trait the method came from, counting up the\n+    // methods from them.\n+    let mut method_count = 0;\n+    ty::each_bound_trait_and_supertraits(tcx, &[object_trait_ref], |bound_ref| {\n+        if bound_ref.def_id() == trait_def_id {\n+            false\n+        } else {\n+            let trait_items = ty::trait_items(tcx, bound_ref.def_id());\n+            for trait_item in trait_items.iter() {\n+                match *trait_item {\n+                    ty::MethodTraitItem(_) => method_count += 1,\n+                    ty::TypeTraitItem(_) => {}\n+                }\n+            }\n+            true\n+        }\n+    });\n+    method_count + method_index_in_trait\n+}\n+\n impl<'tcx,O:Repr<'tcx>> Repr<'tcx> for super::Obligation<'tcx, O> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"Obligation(predicate={},depth={})\",\n@@ -314,6 +372,10 @@ impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::Vtable<'tcx, N> {\n                 format!(\"VtableFnPointer({})\",\n                         d.repr(tcx)),\n \n+            super::VtableObject(ref d) =>\n+                format!(\"VtableObject({})\",\n+                        d.repr(tcx)),\n+\n             super::VtableParam =>\n                 format!(\"VtableParam\"),\n \n@@ -339,6 +401,13 @@ impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::VtableBuiltinData<N> {\n     }\n }\n \n+impl<'tcx> Repr<'tcx> for super::VtableObjectData<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        format!(\"VtableObject(object_ty={})\",\n+                self.object_ty.repr(tcx))\n+    }\n+}\n+\n impl<'tcx> Repr<'tcx> for super::SelectionError<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {"}, {"sha": "999bc23c27049c486bae9299948e39491549ce76", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 71, "deletions": 75, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -59,6 +59,7 @@ use middle::subst::{mod, Subst, Substs, VecPerParamSpace};\n use middle::traits;\n use middle::ty;\n use middle::ty_fold::{mod, TypeFoldable, TypeFolder};\n+use middle::ty_walk::TypeWalker;\n use util::ppaux::{note_and_explain_region, bound_region_ptr_to_string};\n use util::ppaux::{trait_store_to_string, ty_to_string};\n use util::ppaux::{Repr, UserString};\n@@ -69,7 +70,7 @@ use util::nodemap::{FnvHashMap};\n use arena::TypedArena;\n use std::borrow::BorrowFrom;\n use std::cell::{Cell, RefCell};\n-use std::cmp;\n+use std::cmp::{mod, Ordering};\n use std::fmt::{mod, Show};\n use std::hash::{Hash, sip, Writer};\n use std::mem;\n@@ -128,7 +129,7 @@ impl ImplOrTraitItemContainer {\n     }\n }\n \n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub enum ImplOrTraitItem<'tcx> {\n     MethodTraitItem(Rc<Method<'tcx>>),\n     TypeTraitItem(Rc<AssociatedType>),\n@@ -173,7 +174,7 @@ impl<'tcx> ImplOrTraitItem<'tcx> {\n     }\n }\n \n-#[deriving(Clone, Copy)]\n+#[deriving(Clone, Copy, Show)]\n pub enum ImplOrTraitItemId {\n     MethodTraitItemId(ast::DefId),\n     TypeTraitItemId(ast::DefId),\n@@ -232,7 +233,7 @@ impl<'tcx> Method<'tcx> {\n     }\n }\n \n-#[deriving(Clone, Copy)]\n+#[deriving(Clone, Copy, Show)]\n pub struct AssociatedType {\n     pub name: ast::Name,\n     pub vis: ast::Visibility,\n@@ -827,6 +828,9 @@ pub struct ctxt<'tcx> {\n     /// parameters are never placed into this cache, because their\n     /// results are dependent on the parameter environment.\n     pub type_impls_sized_cache: RefCell<HashMap<Ty<'tcx>,bool>>,\n+\n+    /// Caches whether traits are object safe\n+    pub object_safety_cache: RefCell<DefIdMap<bool>>,\n }\n \n // Flags that we track on types. These flags are propagated upwards\n@@ -2384,6 +2388,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         repr_hint_cache: RefCell::new(DefIdMap::new()),\n         type_impls_copy_cache: RefCell::new(HashMap::new()),\n         type_impls_sized_cache: RefCell::new(HashMap::new()),\n+        object_safety_cache: RefCell::new(DefIdMap::new()),\n    }\n }\n \n@@ -2831,59 +2836,61 @@ pub fn mk_param_from_def<'tcx>(cx: &ctxt<'tcx>, def: &TypeParameterDef) -> Ty<'t\n \n pub fn mk_open<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> { mk_t(cx, ty_open(ty)) }\n \n-pub fn walk_ty<'tcx, F>(ty: Ty<'tcx>, mut f: F) where\n-    F: FnMut(Ty<'tcx>),\n+impl<'tcx> TyS<'tcx> {\n+    /// Iterator that walks `self` and any types reachable from\n+    /// `self`, in depth-first order. Note that just walks the types\n+    /// that appear in `self`, it does not descend into the fields of\n+    /// structs or variants. For example:\n+    ///\n+    /// ```notrust\n+    /// int => { int }\n+    /// Foo<Bar<int>> => { Foo<Bar<int>>, Bar<int>, int }\n+    /// [int] => { [int], int }\n+    /// ```\n+    pub fn walk(&'tcx self) -> TypeWalker<'tcx> {\n+        TypeWalker::new(self)\n+    }\n+\n+    /// Iterator that walks types reachable from `self`, in\n+    /// depth-first order. Note that this is a shallow walk. For\n+    /// example:\n+    ///\n+    /// ```notrust\n+    /// int => { }\n+    /// Foo<Bar<int>> => { Bar<int>, int }\n+    /// [int] => { int }\n+    /// ```\n+    pub fn walk_children(&'tcx self) -> TypeWalker<'tcx> {\n+        // Walks type reachable from `self` but not `self\n+        let mut walker = self.walk();\n+        let r = walker.next();\n+        assert_eq!(r, Some(self));\n+        walker\n+    }\n+}\n+\n+pub fn walk_ty<'tcx, F>(ty_root: Ty<'tcx>, mut f: F)\n+    where F: FnMut(Ty<'tcx>),\n {\n-    maybe_walk_ty(ty, |ty| { f(ty); true });\n+    for ty in ty_root.walk() {\n+        f(ty);\n+    }\n }\n \n-pub fn maybe_walk_ty<'tcx, F>(ty: Ty<'tcx>, mut f: F) where F: FnMut(Ty<'tcx>) -> bool {\n-    // FIXME(#19596) This is a workaround, but there should be a better way to do this\n-    fn maybe_walk_ty_<'tcx, F>(ty: Ty<'tcx>, f: &mut F) where F: FnMut(Ty<'tcx>) -> bool {\n-        if !(*f)(ty) {\n-            return;\n-        }\n-        match ty.sty {\n-            ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n-            ty_str | ty_infer(_) | ty_param(_) | ty_err => {}\n-            ty_uniq(ty) | ty_vec(ty, _) | ty_open(ty) => maybe_walk_ty_(ty, f),\n-            ty_ptr(ref tm) | ty_rptr(_, ref tm) => {\n-                maybe_walk_ty_(tm.ty, f);\n-            }\n-            ty_trait(box TyTrait { ref principal, .. }) => {\n-                for subty in principal.0.substs.types.iter() {\n-                    maybe_walk_ty_(*subty, f);\n-                }\n-            }\n-            ty_projection(ProjectionTy { ref trait_ref, .. }) => {\n-                for subty in trait_ref.substs.types.iter() {\n-                    maybe_walk_ty_(*subty, f);\n-                }\n-            }\n-            ty_enum(_, ref substs) |\n-            ty_struct(_, ref substs) |\n-            ty_unboxed_closure(_, _, ref substs) => {\n-                for subty in substs.types.iter() {\n-                    maybe_walk_ty_(*subty, f);\n-                }\n-            }\n-            ty_tup(ref ts) => { for tt in ts.iter() { maybe_walk_ty_(*tt, f); } }\n-            ty_bare_fn(_, ref ft) => {\n-                for a in ft.sig.0.inputs.iter() { maybe_walk_ty_(*a, f); }\n-                if let ty::FnConverging(output) = ft.sig.0.output {\n-                    maybe_walk_ty_(output, f);\n-                }\n-            }\n-            ty_closure(ref ft) => {\n-                for a in ft.sig.0.inputs.iter() { maybe_walk_ty_(*a, f); }\n-                if let ty::FnConverging(output) = ft.sig.0.output {\n-                    maybe_walk_ty_(output, f);\n-                }\n-            }\n+/// Walks `ty` and any types appearing within `ty`, invoking the\n+/// callback `f` on each type. If the callback returns false, then the\n+/// children of the current type are ignored.\n+///\n+/// Note: prefer `ty.walk()` where possible.\n+pub fn maybe_walk_ty<'tcx,F>(ty_root: Ty<'tcx>, mut f: F)\n+    where F : FnMut(Ty<'tcx>) -> bool\n+{\n+    let mut walker = ty_root.walk();\n+    while let Some(ty) = walker.next() {\n+        if !f(ty) {\n+            walker.skip_current_subtree();\n         }\n     }\n-\n-    maybe_walk_ty_(ty, &mut f);\n }\n \n // Folds types from the bottom up.\n@@ -4960,10 +4967,11 @@ pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n     }\n }\n \n-/// Helper for looking things up in the various maps that are populated during typeck::collect\n-/// (e.g., `cx.impl_or_trait_items`, `cx.tcache`, etc).  All of these share the pattern that if the\n-/// id is local, it should have been loaded into the map by the `typeck::collect` phase.  If the\n-/// def-id is external, then we have to go consult the crate loading code (and cache the result for\n+/// Helper for looking things up in the various maps that are populated during\n+/// typeck::collect (e.g., `cx.impl_or_trait_items`, `cx.tcache`, etc).  All of\n+/// these share the pattern that if the id is local, it should have been loaded\n+/// into the map by the `typeck::collect` phase.  If the def-id is external,\n+/// then we have to go consult the crate loading code (and cache the result for\n /// the future).\n fn lookup_locally_or_in_crate_store<V, F>(descr: &str,\n                                           def_id: ast::DefId,\n@@ -6034,11 +6042,12 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n         return\n     }\n \n+    debug!(\"populate_implementations_for_type_if_necessary: searching for {}\", type_id);\n+\n     let mut inherent_impls = Vec::new();\n     csearch::each_implementation_for_type(&tcx.sess.cstore, type_id,\n             |impl_def_id| {\n-        let impl_items = csearch::get_impl_items(&tcx.sess.cstore,\n-                                                 impl_def_id);\n+        let impl_items = csearch::get_impl_items(&tcx.sess.cstore, impl_def_id);\n \n         // Record the trait->implementation mappings, if applicable.\n         let associated_traits = csearch::get_impl_trait(tcx, impl_def_id);\n@@ -6120,22 +6129,9 @@ pub fn populate_implementations_for_trait_if_necessary(\n /// Given the def_id of an impl, return the def_id of the trait it implements.\n /// If it implements no trait, return `None`.\n pub fn trait_id_of_impl(tcx: &ctxt,\n-                        def_id: ast::DefId) -> Option<ast::DefId> {\n-    let node = match tcx.map.find(def_id.node) {\n-        Some(node) => node,\n-        None => return None\n-    };\n-    match node {\n-        ast_map::NodeItem(item) => {\n-            match item.node {\n-                ast::ItemImpl(_, _, Some(ref trait_ref), _, _) => {\n-                    Some(node_id_to_trait_ref(tcx, trait_ref.ref_id).def_id)\n-                }\n-                _ => None\n-            }\n-        }\n-        _ => None\n-    }\n+                        def_id: ast::DefId)\n+                        -> Option<ast::DefId> {\n+    ty::impl_trait_ref(tcx, def_id).map(|tr| tr.def_id)\n }\n \n /// If the given def ID describes a method belonging to an impl, return the\n@@ -7269,7 +7265,7 @@ impl<T:ReferencesError> ReferencesError for Binder<T> {\n \n impl<T:ReferencesError> ReferencesError for Rc<T> {\n     fn references_error(&self) -> bool {\n-        (&*self).references_error()\n+        (&**self).references_error()\n     }\n }\n "}, {"sha": "abbf530529bb2fd41959cb259c4dc90e5a04db15", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -56,7 +56,7 @@ pub trait TypeFoldable<'tcx> {\n /// default implementation that does an \"identity\" fold. Within each\n /// identity fold, it should invoke `foo.fold_with(self)` to fold each\n /// sub-item.\n-pub trait TypeFolder<'tcx> {\n+pub trait TypeFolder<'tcx> : Sized {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n \n     /// Invoked by the `super_*` routines when we enter a region\n@@ -503,6 +503,15 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N>\n             }\n             traits::VtableParam => traits::VtableParam,\n             traits::VtableBuiltin(ref d) => traits::VtableBuiltin(d.fold_with(folder)),\n+            traits::VtableObject(ref d) => traits::VtableObject(d.fold_with(folder)),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableObjectData<'tcx> {\n+        traits::VtableObjectData {\n+            object_ty: self.object_ty.fold_with(folder)\n         }\n     }\n }"}, {"sha": "406ebf4bc38a40288f08ac3e234b653e9a0dd6b4", "filename": "src/librustc/middle/ty_walk.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_walk.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -0,0 +1,112 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! An iterator over the type substructure.\n+\n+use middle::ty::{mod, Ty};\n+use std::iter::Iterator;\n+\n+pub struct TypeWalker<'tcx> {\n+    stack: Vec<Ty<'tcx>>,\n+    last_subtree: uint,\n+}\n+\n+impl<'tcx> TypeWalker<'tcx> {\n+    pub fn new(ty: Ty<'tcx>) -> TypeWalker<'tcx> {\n+        TypeWalker { stack: vec!(ty), last_subtree: 1, }\n+    }\n+\n+    fn push_subtypes(&mut self, parent_ty: Ty<'tcx>) {\n+        match parent_ty.sty {\n+            ty::ty_bool | ty::ty_char | ty::ty_int(_) | ty::ty_uint(_) | ty::ty_float(_) |\n+            ty::ty_str | ty::ty_infer(_) | ty::ty_param(_) | ty::ty_err => {\n+            }\n+            ty::ty_uniq(ty) | ty::ty_vec(ty, _) | ty::ty_open(ty) => {\n+                self.stack.push(ty);\n+            }\n+            ty::ty_ptr(ref mt) | ty::ty_rptr(_, ref mt) => {\n+                self.stack.push(mt.ty);\n+            }\n+            ty::ty_projection(ref data) => {\n+                self.push_reversed(data.trait_ref.substs.types.as_slice());\n+            }\n+            ty::ty_trait(box ty::TyTrait { ref principal, .. }) => {\n+                self.push_reversed(principal.substs().types.as_slice());\n+            }\n+            ty::ty_enum(_, ref substs) |\n+            ty::ty_struct(_, ref substs) |\n+            ty::ty_unboxed_closure(_, _, ref substs) => {\n+                self.push_reversed(substs.types.as_slice());\n+            }\n+            ty::ty_tup(ref ts) => {\n+                self.push_reversed(ts.as_slice());\n+            }\n+            ty::ty_bare_fn(_, ref ft) => {\n+                self.push_sig_subtypes(&ft.sig);\n+            }\n+            ty::ty_closure(ref ft) => {\n+                self.push_sig_subtypes(&ft.sig);\n+            }\n+        }\n+    }\n+\n+    fn push_sig_subtypes(&mut self, sig: &ty::PolyFnSig<'tcx>) {\n+        match sig.0.output {\n+            ty::FnConverging(output) => { self.stack.push(output); }\n+            ty::FnDiverging => { }\n+        }\n+        self.push_reversed(sig.0.inputs.as_slice());\n+    }\n+\n+    fn push_reversed(&mut self, tys: &[Ty<'tcx>]) {\n+        // We push slices on the stack in reverse order so as to\n+        // maintain a pre-order traversal. As of the time of this\n+        // writing, the fact that the traversal is pre-order is not\n+        // known to be significant to any code, but it seems like the\n+        // natural order one would expect (basically, the order of the\n+        // types as they are written).\n+        for &ty in tys.iter().rev() {\n+            self.stack.push(ty);\n+        }\n+    }\n+\n+    /// Skips the subtree of types corresponding to the last type\n+    /// returned by `next()`.\n+    ///\n+    /// Example: Imagine you are walking `Foo<Bar<int>, uint>`.\n+    ///\n+    /// ```rust\n+    /// let mut iter: TypeWalker = ...;\n+    /// iter.next(); // yields Foo\n+    /// iter.next(); // yields Bar<int>\n+    /// iter.skip_current_subtree(); // skips int\n+    /// iter.next(); // yields uint\n+    /// ```\n+    pub fn skip_current_subtree(&mut self) {\n+        self.stack.truncate(self.last_subtree);\n+    }\n+}\n+\n+impl<'tcx> Iterator<Ty<'tcx>> for TypeWalker<'tcx> {\n+    fn next(&mut self) -> Option<Ty<'tcx>> {\n+        debug!(\"next(): stack={}\", self.stack);\n+        match self.stack.pop() {\n+            None => {\n+                return None;\n+            }\n+            Some(ty) => {\n+                self.last_subtree = self.stack.len();\n+                self.push_subtypes(ty);\n+                debug!(\"next: stack={}\", self.stack);\n+                Some(ty)\n+            }\n+        }\n+    }\n+}"}, {"sha": "f299ea939ed2b02061c9b1b62c44e6e69d04c00a", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -394,6 +394,7 @@ macro_rules! cgoptions {\n \n     mod cgsetters {\n         use super::{CodegenOptions, Passes, SomePasses, AllPasses};\n+        use std::str::from_str;\n \n         $(\n             pub fn $opt(cg: &mut CodegenOptions, v: Option<&str>) -> bool {\n@@ -743,7 +744,7 @@ pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n         opt::multi(\"l\", \"\",   \"Link the generated crate(s) to the specified native\n                              library NAME. The optional KIND can be one of,\n                              static, dylib, or framework. If omitted, dylib is\n-                             assumed.\", \"NAME[:KIND]\"),\n+                             assumed.\", \"[KIND=]NAME\"),\n         opt::multi(\"\", \"crate-type\", \"Comma separated list of types of crates\n                                     for the compiler to emit\",\n                    \"[bin|lib|rlib|dylib|staticlib]\"),\n@@ -1016,6 +1017,24 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     }\n \n     let libs = matches.opt_strs(\"l\").into_iter().map(|s| {\n+        let mut parts = s.splitn(1, '=');\n+        let kind = parts.next().unwrap();\n+        if let Some(name) = parts.next() {\n+            let kind = match kind {\n+                \"dylib\" => cstore::NativeUnknown,\n+                \"framework\" => cstore::NativeFramework,\n+                \"static\" => cstore::NativeStatic,\n+                s => {\n+                    early_error(format!(\"unknown library kind `{}`, expected \\\n+                                         one of dylib, framework, or static\",\n+                                        s)[]);\n+                }\n+            };\n+            return (name.to_string(), kind)\n+        }\n+\n+        // FIXME(acrichto) remove this once crates have stopped using it, this\n+        //                 is deprecated behavior now.\n         let mut parts = s.rsplitn(1, ':');\n         let kind = parts.next().unwrap();\n         let (name, kind) = match (parts.next(), kind) {"}, {"sha": "56b4cae2e43cfdc5e015251e12e01fb9c726e60b", "filename": "src/librustc/session/search_paths.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fsearch_paths.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -34,15 +34,14 @@ impl SearchPaths {\n     }\n \n     pub fn add_path(&mut self, path: &str) {\n-        let (kind, path) = if path.ends_with(\":native\") {\n-            (PathKind::Native, path.slice_to(path.len() - \":native\".len()))\n-        } else if path.ends_with(\":crate\") {\n-            (PathKind::Crate, path.slice_to(path.len() - \":crate\".len()))\n-        } else if path.ends_with(\":dependency\") {\n-            (PathKind::Dependency,\n-             path.slice_to(path.len() - \":dependency\".len()))\n-        } else if path.ends_with(\":all\") {\n-            (PathKind::All, path.slice_to(path.len() - \":all\".len()))\n+        let (kind, path) = if path.starts_with(\"native=\") {\n+            (PathKind::Native, path.slice_from(\"native=\".len()))\n+        } else if path.starts_with(\"crate=\") {\n+            (PathKind::Crate, path.slice_from(\"crate=\".len()))\n+        } else if path.starts_with(\"dependency=\") {\n+            (PathKind::Dependency, path.slice_from(\"dependency=\".len()))\n+        } else if path.starts_with(\"all=\") {\n+            (PathKind::All, path.slice_from(\"all=\".len()))\n         } else {\n             (PathKind::All, path)\n         };"}, {"sha": "2bb99a7141f7098c8d74ad9375eb66ad193ce83e", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -32,6 +32,7 @@\n #![allow(unknown_features)]\n #![feature(globs, phase, macro_rules, slicing_syntax)]\n #![feature(unboxed_closures)]\n+#![feature(old_orphan_check)]\n \n #[phase(plugin, link)]\n extern crate log;"}, {"sha": "8d3aa397f306163063c5aeee492f0f05b2297eba", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -33,7 +33,7 @@ impl<'tcx> MoveErrorCollector<'tcx> {\n     }\n \n     pub fn report_potential_errors<'a>(&self, bccx: &BorrowckCtxt<'a, 'tcx>) {\n-        report_move_errors(bccx, self.errors.borrow().deref())\n+        report_move_errors(bccx, &*self.errors.borrow())\n     }\n }\n "}, {"sha": "ac6b962d6470448e43958c0eb41109df4d5732c3", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -24,6 +24,7 @@ use rustc::middle::cfg::{CFGIndex};\n use rustc::middle::dataflow::{DataFlowOperator, DataFlowContext, EntryOrExit};\n use rustc::middle::dataflow;\n use std::rc::Rc;\n+use std::borrow::IntoCow;\n \n #[deriving(Show, Copy)]\n pub enum Variant {"}, {"sha": "b886883c73ad21c989cf14d10f0d6e9e8c401f35", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -16,10 +16,12 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n+#![allow(unknown_features)]\n #![feature(default_type_params, globs, macro_rules, phase, quote)]\n #![feature(slicing_syntax, unsafe_destructor)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(unboxed_closures)]\n+#![feature(old_orphan_check)]\n #![allow(non_camel_case_types)]\n \n #[phase(plugin, link)] extern crate log;"}, {"sha": "a92c2fe2ccbd8105b0fc05b588d322081d31c164", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -28,7 +28,7 @@ use rustc_trans::save;\n use rustc_trans::trans;\n use rustc_typeck as typeck;\n \n-use serialize::{json, Encodable};\n+use serialize::json;\n \n use std::io;\n use std::io::fs;\n@@ -143,10 +143,7 @@ pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input)\n     });\n \n     if sess.opts.debugging_opts & config::AST_JSON_NOEXPAND != 0 {\n-        let mut stdout = io::BufferedWriter::new(io::stdout());\n-        let mut json = json::PrettyEncoder::new(&mut stdout);\n-        // unwrapping so IoError isn't ignored\n-        krate.encode(&mut json).unwrap();\n+        println!(\"{}\", json::as_json(&krate));\n     }\n \n     if sess.show_span() {\n@@ -338,10 +335,7 @@ pub fn assign_node_ids_and_map<'ast>(sess: &Session,\n                    ast_map::map_crate(forest, NodeIdAssigner { sess: sess }));\n \n     if sess.opts.debugging_opts & config::AST_JSON != 0 {\n-        let mut stdout = io::BufferedWriter::new(io::stdout());\n-        let mut json = json::PrettyEncoder::new(&mut stdout);\n-        // unwrapping so IoError isn't ignored\n-        map.krate().encode(&mut json).unwrap();\n+        println!(\"{}\", json::as_json(map.krate()));\n     }\n \n     map"}, {"sha": "be55da8c59da2f92e8058946b5da302220fa9b22", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -54,9 +54,11 @@ use rustc::metadata;\n use rustc::DIAGNOSTICS;\n \n use std::any::AnyRefExt;\n+use std::cmp::Ordering::Equal;\n use std::io;\n use std::iter::repeat;\n use std::os;\n+use std::sync::mpsc::channel;\n use std::thread;\n \n use rustc::session::early_error;"}, {"sha": "a046d9d5d39c5e5323fc2c4e5fbfc6383173f269", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -154,7 +154,7 @@ trait PrinterSupport<'ast>: pprust::PpAnn {\n     ///\n     /// (Rust does not yet support upcasting from a trait object to\n     /// an object for one of its super-traits.)\n-    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self as &pprust::PpAnn }\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn;\n }\n \n struct NoAnn<'ast> {\n@@ -168,6 +168,8 @@ impl<'ast> PrinterSupport<'ast> for NoAnn<'ast> {\n     fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'ast>> {\n         self.ast_map.as_ref()\n     }\n+\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self }\n }\n \n impl<'ast> pprust::PpAnn for NoAnn<'ast> {}\n@@ -183,6 +185,8 @@ impl<'ast> PrinterSupport<'ast> for IdentifiedAnnotation<'ast> {\n     fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'ast>> {\n         self.ast_map.as_ref()\n     }\n+\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self }\n }\n \n impl<'ast> pprust::PpAnn for IdentifiedAnnotation<'ast> {\n@@ -232,6 +236,8 @@ impl<'ast> PrinterSupport<'ast> for HygieneAnnotation<'ast> {\n     fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'ast>> {\n         self.ast_map.as_ref()\n     }\n+\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self }\n }\n \n impl<'ast> pprust::PpAnn for HygieneAnnotation<'ast> {\n@@ -265,6 +271,8 @@ impl<'tcx> PrinterSupport<'tcx> for TypedAnnotation<'tcx> {\n     fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'tcx>> {\n         Some(&self.analysis.ty_cx.map)\n     }\n+\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self }\n }\n \n impl<'tcx> pprust::PpAnn for TypedAnnotation<'tcx> {"}, {"sha": "eddcc75006899bf74bfda8acc8cd238ae283bd1b", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -34,8 +34,6 @@ use syntax::codemap::{Span, CodeMap, DUMMY_SP};\n use syntax::diagnostic::{Level, RenderSpan, Bug, Fatal, Error, Warning, Note, Help};\n use syntax::parse::token;\n \n-use arena::TypedArena;\n-\n struct Env<'a, 'tcx: 'a> {\n     infcx: &'a infer::InferCtxt<'a, 'tcx>,\n }\n@@ -831,3 +829,57 @@ fn subst_region_renumber_region() {\n         assert_eq!(t_substituted, t_expected);\n     })\n }\n+\n+#[test]\n+fn walk_ty() {\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        let tcx = env.infcx.tcx;\n+        let int_ty = tcx.types.int;\n+        let uint_ty = tcx.types.uint;\n+        let tup1_ty = ty::mk_tup(tcx, vec!(int_ty, uint_ty, int_ty, uint_ty));\n+        let tup2_ty = ty::mk_tup(tcx, vec!(tup1_ty, tup1_ty, uint_ty));\n+        let uniq_ty = ty::mk_uniq(tcx, tup2_ty);\n+        let walked: Vec<_> = uniq_ty.walk().collect();\n+        assert_eq!(vec!(uniq_ty,\n+                        tup2_ty,\n+                        tup1_ty, int_ty, uint_ty, int_ty, uint_ty,\n+                        tup1_ty, int_ty, uint_ty, int_ty, uint_ty,\n+                        uint_ty),\n+                   walked);\n+    })\n+}\n+\n+#[test]\n+fn walk_ty_skip_subtree() {\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        let tcx = env.infcx.tcx;\n+        let int_ty = tcx.types.int;\n+        let uint_ty = tcx.types.uint;\n+        let tup1_ty = ty::mk_tup(tcx, vec!(int_ty, uint_ty, int_ty, uint_ty));\n+        let tup2_ty = ty::mk_tup(tcx, vec!(tup1_ty, tup1_ty, uint_ty));\n+        let uniq_ty = ty::mk_uniq(tcx, tup2_ty);\n+\n+        // types we expect to see (in order), plus a boolean saying\n+        // whether to skip the subtree.\n+        let mut expected = vec!((uniq_ty, false),\n+                                (tup2_ty, false),\n+                                (tup1_ty, false),\n+                                (int_ty, false),\n+                                (uint_ty, false),\n+                                (int_ty, false),\n+                                (uint_ty, false),\n+                                (tup1_ty, true), // skip the int/uint/int/uint\n+                                (uint_ty, false));\n+        expected.reverse();\n+\n+        let mut walker = uniq_ty.walk();\n+        while let Some(t) = walker.next() {\n+            debug!(\"walked to {}\", t);\n+            let (expected_ty, skip) = expected.pop().unwrap();\n+            assert_eq!(t, expected_ty);\n+            if skip { walker.skip_current_subtree(); }\n+        }\n+\n+        assert!(expected.is_empty());\n+    })\n+}"}, {"sha": "53992d4567a34915148e2c9e87957e05cbc81517", "filename": "src/librustc_llvm/archive_ro.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_llvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_llvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Farchive_ro.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -13,8 +13,9 @@\n use libc;\n use ArchiveRef;\n \n-use std::raw;\n+use std::c_str::ToCStr;\n use std::mem;\n+use std::raw;\n \n pub struct ArchiveRO {\n     ptr: ArchiveRef,"}, {"sha": "aa3ac83c0275f44dbe3c38b62a72de789894343a", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -61,8 +61,9 @@ use syntax::parse::token::{mod, special_idents};\n use syntax::codemap::{Span, DUMMY_SP};\n use syntax::visit::{mod, Visitor};\n \n-use std::rc::Rc;\n use std::mem::replace;\n+use std::ops::{Deref, DerefMut};\n+use std::rc::Rc;\n \n // Specifies how duplicates should be handled when adding a child item if\n // another item exists with the same name in some namespace.\n@@ -95,13 +96,15 @@ struct GraphBuilder<'a, 'b:'a, 'tcx:'b> {\n     resolver: &'a mut Resolver<'b, 'tcx>\n }\n \n-impl<'a, 'b:'a, 'tcx:'b> Deref<Resolver<'b, 'tcx>> for GraphBuilder<'a, 'b, 'tcx> {\n+impl<'a, 'b:'a, 'tcx:'b> Deref for GraphBuilder<'a, 'b, 'tcx> {\n+    type Target = Resolver<'b, 'tcx>;\n+\n     fn deref(&self) -> &Resolver<'b, 'tcx> {\n         &*self.resolver\n     }\n }\n \n-impl<'a, 'b:'a, 'tcx:'b> DerefMut<Resolver<'b, 'tcx>> for GraphBuilder<'a, 'b, 'tcx> {\n+impl<'a, 'b:'a, 'tcx:'b> DerefMut for GraphBuilder<'a, 'b, 'tcx> {\n     fn deref_mut(&mut self) -> &mut Resolver<'b, 'tcx> {\n         &mut *self.resolver\n     }"}, {"sha": "1bfe4c0407afbb03222caf20c9fd5ff7e9d8a008", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -17,6 +17,8 @@\n // `use` directives.\n //\n \n+use std::ops::{Deref, DerefMut};\n+\n use Resolver;\n use Namespace::{TypeNS, ValueNS};\n \n@@ -33,13 +35,15 @@ struct UnusedImportCheckVisitor<'a, 'b:'a, 'tcx:'b> {\n }\n \n // Deref and DerefMut impls allow treating UnusedImportCheckVisitor as Resolver.\n-impl<'a, 'b, 'tcx:'b> Deref<Resolver<'b, 'tcx>> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n+impl<'a, 'b, 'tcx:'b> Deref for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n+    type Target = Resolver<'b, 'tcx>;\n+\n     fn deref<'c>(&'c self) -> &'c Resolver<'b, 'tcx> {\n         &*self.resolver\n     }\n }\n \n-impl<'a, 'b, 'tcx:'b> DerefMut<Resolver<'b, 'tcx>> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n+impl<'a, 'b, 'tcx:'b> DerefMut for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n     fn deref_mut<'c>(&'c mut self) -> &'c mut Resolver<'b, 'tcx> {\n         &mut *self.resolver\n     }"}, {"sha": "4ac9224969ca280214b95e650d63799c784dc3d6", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -18,6 +18,7 @@\n \n #![feature(globs, phase, slicing_syntax)]\n #![feature(rustc_diagnostic_macros)]\n+#![feature(associated_types)]\n \n #[phase(plugin, link)] extern crate log;\n #[phase(plugin, link)] extern crate syntax;\n@@ -3402,7 +3403,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn resolve_local(&mut self, local: &Local) {\n         // Resolve the type.\n-        self.resolve_type(&*local.ty);\n+        if let Some(ref ty) = local.ty {\n+            self.resolve_type(&**ty);\n+        }\n \n         // Resolve the initializer, if necessary.\n         match local.init {"}, {"sha": "ff415750d648179f6c8b47e574d2f73c2091a2e5", "filename": "src/librustc_resolve/record_exports.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_resolve%2Frecord_exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_resolve%2Frecord_exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Frecord_exports.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -27,20 +27,23 @@ use rustc::middle::def::Export;\n use syntax::ast;\n use syntax::parse::token;\n \n+use std::ops::{Deref, DerefMut};\n use std::rc::Rc;\n \n struct ExportRecorder<'a, 'b:'a, 'tcx:'b> {\n     resolver: &'a mut Resolver<'b, 'tcx>\n }\n \n // Deref and DerefMut impls allow treating ExportRecorder as Resolver.\n-impl<'a, 'b, 'tcx:'b> Deref<Resolver<'b, 'tcx>> for ExportRecorder<'a, 'b, 'tcx> {\n+impl<'a, 'b, 'tcx:'b> Deref for ExportRecorder<'a, 'b, 'tcx> {\n+    type Target = Resolver<'b, 'tcx>;\n+\n     fn deref<'c>(&'c self) -> &'c Resolver<'b, 'tcx> {\n         &*self.resolver\n     }\n }\n \n-impl<'a, 'b, 'tcx:'b> DerefMut<Resolver<'b, 'tcx>> for ExportRecorder<'a, 'b, 'tcx> {\n+impl<'a, 'b, 'tcx:'b> DerefMut for ExportRecorder<'a, 'b, 'tcx> {\n     fn deref_mut<'c>(&'c mut self) -> &'c mut Resolver<'b, 'tcx> {\n         &mut *self.resolver\n     }"}, {"sha": "7cf4bafe032e0728d0cde8ba8ebe8415e49faa29", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -20,6 +20,7 @@ use rustc::util::common::time;\n use libc;\n use flate;\n \n+use std::c_str::ToCStr;\n use std::iter;\n use std::mem;\n use std::num::Int;"}, {"sha": "5cd62675c1dc3c53da7f6067f5e11d8c2a09911f", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -30,6 +30,7 @@ use std::ptr;\n use std::str;\n use std::mem;\n use std::sync::{Arc, Mutex};\n+use std::sync::mpsc::channel;\n use std::thread;\n use libc::{c_uint, c_int, c_void};\n \n@@ -928,13 +929,13 @@ fn run_work_multithreaded(sess: &Session,\n                 }\n             }\n \n-            tx.take().unwrap().send(());\n+            tx.take().unwrap().send(()).unwrap();\n         }).detach();\n     }\n \n     let mut panicked = false;\n     for rx in futures.into_iter() {\n-        match rx.recv_opt() {\n+        match rx.recv() {\n             Ok(()) => {},\n             Err(_) => {\n                 panicked = true;\n@@ -1009,7 +1010,7 @@ unsafe fn configure_llvm(sess: &Session) {\n         }\n     }\n \n-    INIT.doit(|| {\n+    INIT.call_once(|| {\n         llvm::LLVMInitializePasses();\n \n         // Only initialize the platforms supported by Rust here, because"}, {"sha": "5ffe9b2d6471acc1a2ceaa5d20a1f69f1ec073a9", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -22,10 +22,12 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n+#![allow(unknown_features)]\n #![feature(default_type_params, globs, macro_rules, phase, quote)]\n #![feature(slicing_syntax, unsafe_destructor)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(unboxed_closures)]\n+#![feature(old_orphan_check)]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "73961f00d703ac8b5d04ba57be78fa232c157aa4", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -1202,8 +1202,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                         let glob_map = &self.analysis.glob_map;\n                         let glob_map = glob_map.as_ref().unwrap();\n                         if glob_map.contains_key(&id) {\n-                            let names = glob_map.index(&id);\n-                            for n in names.iter() {\n+                            for n in glob_map[id].iter() {\n                                 if name_string.len() > 0 {\n                                     name_string.push_str(\", \");\n                                 }\n@@ -1496,7 +1495,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         self.collected_paths.clear();\n \n         // Just walk the initialiser and type (don't want to walk the pattern again).\n-        self.visit_ty(&*l.ty);\n+        visit::walk_ty_opt(self, &l.ty);\n         visit::walk_expr_opt(self, &l.init);\n     }\n }"}, {"sha": "bf53885e9e50d83ae7590d97b669997831b9fca0", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -3097,7 +3097,7 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n         use std::sync::{Once, ONCE_INIT};\n         static INIT: Once = ONCE_INIT;\n         static mut POISONED: bool = false;\n-        INIT.doit(|| {\n+        INIT.call_once(|| {\n             if llvm::LLVMStartMultithreaded() != 1 {\n                 // use an extra bool to make sure that all future usage of LLVM\n                 // cannot proceed despite the Once not running more than once."}, {"sha": "97f0b92a290f839ab9871f6819dce94038bef53f", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -20,7 +20,7 @@ use trans::machine::llalign_of_pref;\n use trans::type_::Type;\n use util::nodemap::FnvHashMap;\n use libc::{c_uint, c_char};\n-use std::string::String;\n+use std::c_str::ToCStr;\n use syntax::codemap::Span;\n \n pub struct Builder<'a, 'tcx: 'a> {"}, {"sha": "1a0007cf0fcdd1307546c337c134917eb0a46b15", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -853,7 +853,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n /// local in `bcx.fcx.lllocals`.\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n-    if fn_should_be_ignored(bcx.fcx) {\n+    if bcx.unreachable.get() || fn_should_be_ignored(bcx.fcx) {\n         return;\n     }\n \n@@ -897,7 +897,7 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                 env_index: uint,\n                                                 captured_by_ref: bool,\n                                                 span: Span) {\n-    if fn_should_be_ignored(bcx.fcx) {\n+    if bcx.unreachable.get() || fn_should_be_ignored(bcx.fcx) {\n         return;\n     }\n \n@@ -980,7 +980,7 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn create_match_binding_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                  variable_ident: ast::Ident,\n                                                  binding: BindingInfo<'tcx>) {\n-    if fn_should_be_ignored(bcx.fcx) {\n+    if bcx.unreachable.get() || fn_should_be_ignored(bcx.fcx) {\n         return;\n     }\n \n@@ -1020,7 +1020,7 @@ pub fn create_match_binding_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// argument in `bcx.fcx.lllocals`.\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n-    if fn_should_be_ignored(bcx.fcx) {\n+    if bcx.unreachable.get() || fn_should_be_ignored(bcx.fcx) {\n         return;\n     }\n \n@@ -1074,7 +1074,7 @@ pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n /// loop variable in `bcx.fcx.lllocals`.\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_for_loop_var_metadata(bcx: Block, pat: &ast::Pat) {\n-    if fn_should_be_ignored(bcx.fcx) {\n+    if bcx.unreachable.get() || fn_should_be_ignored(bcx.fcx) {\n         return;\n     }\n "}, {"sha": "99dc971ed945d15e4bdc7025f175cb08062a78a4", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -26,6 +26,7 @@ use trans::type_of;\n use middle::ty::{mod, Ty};\n use middle::subst::{Substs};\n use std::cmp;\n+use std::c_str::ToCStr;\n use libc::c_uint;\n use syntax::abi::{Cdecl, Aapcs, C, Win64, Abi};\n use syntax::abi::{RustIntrinsic, Rust, RustCall, Stdcall, Fastcall, System};"}, {"sha": "99624f1b1e7d8197a36e4a12e91a161a35c9c621", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 147, "deletions": 4, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use arena::TypedArena;\n use back::abi;\n-use llvm;\n-use llvm::ValueRef;\n+use back::link;\n+use llvm::{mod, ValueRef, get_param};\n use metadata::csearch;\n-use middle::subst::{Substs};\n+use middle::subst::{Subst, Substs};\n use middle::subst::VecPerParamSpace;\n use middle::subst;\n use middle::traits;\n@@ -370,6 +370,10 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let llfn = trans_fn_pointer_shim(bcx.ccx(), fn_ty);\n             Callee { bcx: bcx, data: Fn(llfn) }\n         }\n+        traits::VtableObject(ref data) => {\n+            let llfn = trans_object_shim(bcx.ccx(), data.object_ty, trait_id, n_method);\n+            Callee { bcx: bcx, data: Fn(llfn) }\n+        }\n         traits::VtableBuiltin(..) |\n         traits::VtableParam(..) => {\n             bcx.sess().bug(\n@@ -503,6 +507,137 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     };\n }\n \n+/// Generate a shim function that allows an object type like `SomeTrait` to\n+/// implement the type `SomeTrait`. Imagine a trait definition:\n+///\n+///    trait SomeTrait { fn get(&self) -> int; ... }\n+///\n+/// And a generic bit of code:\n+///\n+///    fn foo<T:SomeTrait>(t: &T) {\n+///        let x = SomeTrait::get;\n+///        x(t)\n+///    }\n+///\n+/// What is the value of `x` when `foo` is invoked with `T=SomeTrait`?\n+/// The answer is that it it is a shim function generate by this\n+/// routine:\n+///\n+///    fn shim(t: &SomeTrait) -> int {\n+///        // ... call t.get() virtually ...\n+///    }\n+///\n+/// In fact, all virtual calls can be thought of as normal trait calls\n+/// that go through this shim function.\n+pub fn trans_object_shim<'a, 'tcx>(\n+    ccx: &'a CrateContext<'a, 'tcx>,\n+    object_ty: Ty<'tcx>,\n+    trait_id: ast::DefId,\n+    method_offset_in_trait: uint)\n+    -> ValueRef\n+{\n+    let _icx = push_ctxt(\"trans_object_shim\");\n+    let tcx = ccx.tcx();\n+\n+    debug!(\"trans_object_shim(object_ty={}, trait_id={}, n_method={})\",\n+           object_ty.repr(tcx),\n+           trait_id.repr(tcx),\n+           method_offset_in_trait);\n+\n+    let object_trait_ref =\n+        match object_ty.sty {\n+            ty::ty_trait(ref data) => {\n+                data.principal_trait_ref_with_self_ty(tcx, object_ty)\n+            }\n+            _ => {\n+                tcx.sess.bug(format!(\"trans_object_shim() called on non-object: {}\",\n+                                     object_ty.repr(tcx)).as_slice());\n+            }\n+        };\n+\n+    // Upcast to the trait in question and extract out the substitutions.\n+    let upcast_trait_ref = traits::upcast(ccx.tcx(), object_trait_ref.clone(), trait_id).unwrap();\n+    let object_substs = upcast_trait_ref.substs().clone().erase_regions();\n+    debug!(\"trans_object_shim: object_substs={}\", object_substs.repr(tcx));\n+\n+    // Lookup the type of this method as deeclared in the trait and apply substitutions.\n+    let method_ty = match ty::trait_item(tcx, trait_id, method_offset_in_trait) {\n+        ty::MethodTraitItem(method) => method,\n+        ty::TypeTraitItem(_) => {\n+            tcx.sess.bug(\"can't create a method shim for an associated type\")\n+        }\n+    };\n+    let fty = method_ty.fty.subst(tcx, &object_substs);\n+    let fty = tcx.mk_bare_fn(fty);\n+    debug!(\"trans_object_shim: fty={}\", fty.repr(tcx));\n+\n+    //\n+    let method_bare_fn_ty =\n+        ty::mk_bare_fn(tcx, None, fty);\n+    let function_name =\n+        link::mangle_internal_name_by_type_and_seq(ccx, method_bare_fn_ty, \"object_shim\");\n+    let llfn =\n+        decl_internal_rust_fn(ccx, method_bare_fn_ty, function_name.as_slice());\n+\n+    //\n+    let block_arena = TypedArena::new();\n+    let empty_substs = Substs::trans_empty();\n+    let fcx = new_fn_ctxt(ccx,\n+                          llfn,\n+                          ast::DUMMY_NODE_ID,\n+                          false,\n+                          fty.sig.0.output,\n+                          &empty_substs,\n+                          None,\n+                          &block_arena);\n+    let mut bcx = init_function(&fcx, false, fty.sig.0.output);\n+\n+    // the first argument (`self`) will be a trait object\n+    let llobject = get_param(fcx.llfn, fcx.arg_pos(0) as u32);\n+\n+    debug!(\"trans_object_shim: llobject={}\",\n+           bcx.val_to_string(llobject));\n+\n+    // the remaining arguments will be, well, whatever they are\n+    let llargs: Vec<_> =\n+        fty.sig.0.inputs[1..].iter()\n+        .enumerate()\n+        .map(|(i, _)| {\n+            let llarg = get_param(fcx.llfn, fcx.arg_pos(i+1) as u32);\n+            debug!(\"trans_object_shim: input #{} == {}\",\n+                   i, bcx.val_to_string(llarg));\n+            llarg\n+        })\n+        .collect();\n+    assert!(!fcx.needs_ret_allocas);\n+\n+    let dest =\n+        fcx.llretslotptr.get().map(\n+            |_| expr::SaveIn(fcx.get_ret_slot(bcx, fty.sig.0.output, \"ret_slot\")));\n+\n+    let method_offset_in_vtable =\n+        traits::get_vtable_index_of_object_method(bcx.tcx(),\n+                                                  object_trait_ref.clone(),\n+                                                  trait_id,\n+                                                  method_offset_in_trait);\n+    debug!(\"trans_object_shim: method_offset_in_vtable={}\",\n+           method_offset_in_vtable);\n+\n+    bcx = trans_call_inner(bcx,\n+                           None,\n+                           method_bare_fn_ty,\n+                           |bcx, _| trans_trait_callee_from_llval(bcx,\n+                                                                  method_bare_fn_ty,\n+                                                                  method_offset_in_vtable,\n+                                                                  llobject),\n+                           ArgVals(llargs.as_slice()),\n+                           dest).bcx;\n+\n+    finish_fn(&fcx, bcx, fty.sig.0.output);\n+\n+    llfn\n+}\n+\n /// Creates a returns a dynamic vtable for the given type and vtable origin.\n /// This is used only for objects.\n ///\n@@ -560,6 +695,14 @@ pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 let llfn = vec![trans_fn_pointer_shim(bcx.ccx(), bare_fn_ty)];\n                 llfn.into_iter()\n             }\n+            traits::VtableObject(ref data) => {\n+                // this would imply that the Self type being erased is\n+                // an object type; this cannot happen because we\n+                // cannot cast an unsized type into a trait object\n+                bcx.sess().bug(\n+                    format!(\"cannot get vtable for an object type: {}\",\n+                            data.repr(bcx.tcx())).as_slice());\n+            }\n             traits::VtableParam => {\n                 bcx.sess().bug(\n                     format!(\"resolved vtable for {} to bad vtable {} in trans\","}, {"sha": "ee859bbe8f52da9d88d5bec1cad4f9113df6f9dc", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -633,17 +633,16 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n               target_trait_def_id: ast::DefId)\n               -> ty::PolyTraitRef<'tcx>\n     {\n-        for super_trait_ref in traits::supertraits(self.tcx(), source_trait_ref.clone()) {\n-            if super_trait_ref.def_id() == target_trait_def_id {\n-                return super_trait_ref;\n+        match traits::upcast(self.tcx(), source_trait_ref.clone(), target_trait_def_id) {\n+            Some(super_trait_ref) => super_trait_ref,\n+            None => {\n+                self.tcx().sess.span_bug(\n+                    self.span,\n+                    format!(\"cannot upcast `{}` to `{}`\",\n+                            source_trait_ref.repr(self.tcx()),\n+                            target_trait_def_id.repr(self.tcx()))[]);\n             }\n         }\n-\n-        self.tcx().sess.span_bug(\n-            self.span,\n-            format!(\"cannot upcast `{}` to `{}`\",\n-                    source_trait_ref.repr(self.tcx()),\n-                    target_trait_def_id.repr(self.tcx()))[]);\n     }\n \n     fn replace_late_bound_regions_with_fresh_var<T>(&self, value: &ty::Binder<T>) -> T"}, {"sha": "52860abb6f938acbfd7e0be106e7774625bd1139", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 8, "deletions": 31, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -267,6 +267,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             return; // already visited\n         }\n \n+        debug!(\"assemble_inherent_impl_probe {}\", impl_def_id);\n+\n         let method = match impl_method(self.tcx(), impl_def_id, self.method_name) {\n             Some(m) => m,\n             None => { return; } // No method with correct name on this impl\n@@ -308,7 +310,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         let trait_ref = data.principal_trait_ref_with_self_ty(self.tcx(), self_ty);\n         self.elaborate_bounds(&[trait_ref.clone()], false, |this, new_trait_ref, m, method_num| {\n             let vtable_index =\n-                get_method_index(tcx, &new_trait_ref, trait_ref.clone(), method_num);\n+                traits::get_vtable_index_of_object_method(tcx,\n+                                                          trait_ref.clone(),\n+                                                          new_trait_ref.def_id(),\n+                                                          method_num);\n \n             let xform_self_ty = this.xform_self_ty(&m, new_trait_ref.substs());\n \n@@ -432,7 +437,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     }\n \n     fn assemble_extension_candidates_for_trait(&mut self,\n-                                           trait_def_id: ast::DefId) {\n+                                               trait_def_id: ast::DefId) {\n         debug!(\"assemble_extension_candidates_for_trait: trait_def_id={}\",\n                trait_def_id.repr(self.tcx()));\n \n@@ -984,6 +989,7 @@ fn trait_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                       -> Option<(uint, Rc<ty::Method<'tcx>>)>\n {\n     let trait_items = ty::trait_items(tcx, trait_def_id);\n+    debug!(\"trait_method; items: {}\", trait_items);\n     trait_items\n         .iter()\n         .filter(|item|\n@@ -996,35 +1002,6 @@ fn trait_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         .and_then(|(idx, item)| item.as_opt_method().map(|m| (idx, m)))\n }\n \n-// Determine the index of a method in the list of all methods belonging\n-// to a trait and its supertraits.\n-fn get_method_index<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                          trait_ref: &ty::PolyTraitRef<'tcx>,\n-                          subtrait: ty::PolyTraitRef<'tcx>,\n-                          n_method: uint) -> uint {\n-    // We need to figure the \"real index\" of the method in a\n-    // listing of all the methods of an object. We do this by\n-    // iterating down the supertraits of the object's trait until\n-    // we find the trait the method came from, counting up the\n-    // methods from them.\n-    let mut method_count = n_method;\n-    ty::each_bound_trait_and_supertraits(tcx, &[subtrait], |bound_ref| {\n-        if bound_ref.def_id() == trait_ref.def_id() {\n-            false\n-        } else {\n-            let trait_items = ty::trait_items(tcx, bound_ref.def_id());\n-            for trait_item in trait_items.iter() {\n-                match *trait_item {\n-                    ty::MethodTraitItem(_) => method_count += 1,\n-                    ty::TypeTraitItem(_) => {}\n-                }\n-            }\n-            true\n-        }\n-    });\n-    method_count\n-}\n-\n impl<'tcx> Candidate<'tcx> {\n     fn to_unadjusted_pick(&self) -> Pick<'tcx> {\n         Pick {"}, {"sha": "19ec85dc61eaec9123482fc8a67dbe537b5e1068", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -507,9 +507,9 @@ impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx> {\n impl<'a, 'tcx, 'v> Visitor<'v> for GatherLocalsVisitor<'a, 'tcx> {\n     // Add explicitly-declared locals.\n     fn visit_local(&mut self, local: &ast::Local) {\n-        let o_ty = match local.ty.node {\n-            ast::TyInfer => None,\n-            _ => Some(self.fcx.to_ty(&*local.ty))\n+        let o_ty = match local.ty {\n+            Some(ref ty) => Some(self.fcx.to_ty(&**ty)),\n+            None => None\n         };\n         self.assign(local.span, local.id, o_ty);\n         debug!(\"Local variable {} is assigned type {}\","}, {"sha": "1ef6c1140321846dc53f24970f355a5f0c57af51", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 76, "deletions": 200, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -9,8 +9,7 @@\n // except according to those terms.\n \n use check::{FnCtxt, structurally_resolved_type};\n-use middle::subst::{FnSpace, SelfSpace};\n-use middle::traits;\n+use middle::traits::{mod, ObjectSafetyViolation, MethodViolationCode};\n use middle::traits::{Obligation, ObligationCause};\n use middle::traits::report_fulfillment_errors;\n use middle::ty::{mod, Ty, AsPredicate};\n@@ -133,217 +132,56 @@ pub fn check_object_safety<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                  object_trait: &ty::TyTrait<'tcx>,\n                                  span: Span)\n {\n-    // Also check that the type `object_trait` specifies all\n-    // associated types for all supertraits.\n-    let mut associated_types: FnvHashSet<(ast::DefId, ast::Name)> = FnvHashSet::new();\n-\n     let object_trait_ref =\n         object_trait.principal_trait_ref_with_self_ty(tcx, tcx.types.err);\n-    for tr in traits::supertraits(tcx, object_trait_ref.clone()) {\n-        check_object_safety_inner(tcx, &tr, span);\n-\n-        let trait_def = ty::lookup_trait_def(tcx, object_trait_ref.def_id());\n-        for &associated_type_name in trait_def.associated_type_names.iter() {\n-            associated_types.insert((object_trait_ref.def_id(), associated_type_name));\n-        }\n-    }\n \n-    for projection_bound in object_trait.bounds.projection_bounds.iter() {\n-        let pair = (projection_bound.0.projection_ty.trait_ref.def_id,\n-                    projection_bound.0.projection_ty.item_name);\n-        associated_types.remove(&pair);\n+    if traits::is_object_safe(tcx, object_trait_ref.clone()) {\n+        return;\n     }\n \n-    for (trait_def_id, name) in associated_types.into_iter() {\n-        tcx.sess.span_err(\n-            span,\n-            format!(\"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n-                    name.user_string(tcx),\n-                    ty::item_path_str(tcx, trait_def_id)).as_slice());\n-    }\n-}\n-\n-fn check_object_safety_inner<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                   object_trait: &ty::PolyTraitRef<'tcx>,\n-                                   span: Span) {\n-    let trait_items = ty::trait_items(tcx, object_trait.def_id());\n-\n-    let mut errors = Vec::new();\n-    for item in trait_items.iter() {\n-        match *item {\n-            ty::MethodTraitItem(ref m) => {\n-                errors.push(check_object_safety_of_method(tcx, object_trait, &**m))\n+    span_err!(tcx.sess, span, E0038,\n+              \"cannot convert to a trait object because trait `{}` is not object-safe\",\n+              ty::item_path_str(tcx, object_trait_ref.def_id()));\n+\n+    let violations = traits::object_safety_violations(tcx, object_trait_ref.clone());\n+    for violation in violations.into_iter() {\n+        match violation {\n+            ObjectSafetyViolation::SizedSelf => {\n+                tcx.sess.span_note(\n+                    span,\n+                    \"the trait cannot require that `Self : Sized`\");\n             }\n-            ty::TypeTraitItem(_) => {}\n-        }\n-    }\n-\n-    let mut errors = errors.iter().flat_map(|x| x.iter()).peekable();\n-    if errors.peek().is_some() {\n-        let trait_name = ty::item_path_str(tcx, object_trait.def_id());\n-        span_err!(tcx.sess, span, E0038,\n-            \"cannot convert to a trait object because trait `{}` is not object-safe\",\n-            trait_name);\n-\n-        for msg in errors {\n-            tcx.sess.note(msg[]);\n-        }\n-    }\n \n-    /// Returns a vec of error messages. If the vec is empty - no errors!\n-    ///\n-    /// There are some limitations to calling functions through an object, because (a) the self\n-    /// type is not known (that's the whole point of a trait instance, after all, to obscure the\n-    /// self type), (b) the call must go through a vtable and hence cannot be monomorphized and\n-    /// (c) the trait contains static methods which can't be called because we don't know the\n-    /// concrete type.\n-    fn check_object_safety_of_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                           object_trait: &ty::PolyTraitRef<'tcx>,\n-                                           method: &ty::Method<'tcx>)\n-                                           -> Vec<String> {\n-        let mut msgs = Vec::new();\n-\n-        let method_name = method.name.repr(tcx);\n-\n-        match method.explicit_self {\n-            ty::ByValueExplicitSelfCategory => { // reason (a) above\n-                msgs.push(format!(\"cannot call a method (`{}`) with a by-value \\\n-                                   receiver through a trait object\", method_name))\n+            ObjectSafetyViolation::Method(method, MethodViolationCode::ByValueSelf) => {\n+                tcx.sess.span_note(\n+                    span,\n+                    format!(\"method `{}` has a receiver type of `Self`, \\\n+                             which cannot be used with a trait object\",\n+                            method.name.user_string(tcx)).as_slice());\n             }\n \n-            ty::StaticExplicitSelfCategory => {\n-                // Static methods are never object safe (reason (c)).\n-                msgs.push(format!(\"cannot call a static method (`{}`) \\\n-                                   through a trait object\",\n-                                  method_name));\n-                return msgs;\n+            ObjectSafetyViolation::Method(method, MethodViolationCode::StaticMethod) => {\n+                tcx.sess.span_note(\n+                    span,\n+                    format!(\"method `{}` has no receiver\",\n+                            method.name.user_string(tcx)).as_slice());\n             }\n-            ty::ByReferenceExplicitSelfCategory(..) |\n-            ty::ByBoxExplicitSelfCategory => {}\n-        }\n \n-        // reason (a) above\n-        let check_for_self_ty = |&: ty| {\n-            if contains_illegal_self_type_reference(tcx, object_trait.def_id(), ty) {\n-                Some(format!(\n-                    \"cannot call a method (`{}`) whose type contains \\\n-                     a self-type (`{}`) through a trait object\",\n-                    method_name, ty.user_string(tcx)))\n-            } else {\n-                None\n-            }\n-        };\n-        let ref sig = method.fty.sig;\n-        for &input_ty in sig.0.inputs[1..].iter() {\n-            if let Some(msg) = check_for_self_ty(input_ty) {\n-                msgs.push(msg);\n-            }\n-        }\n-        if let ty::FnConverging(result_type) = sig.0.output {\n-            if let Some(msg) = check_for_self_ty(result_type) {\n-                msgs.push(msg);\n+            ObjectSafetyViolation::Method(method, MethodViolationCode::ReferencesSelf) => {\n+                tcx.sess.span_note(\n+                    span,\n+                    format!(\"method `{}` references the `Self` type \\\n+                             in its arguments or return type\",\n+                            method.name.user_string(tcx)).as_slice());\n             }\n-        }\n-\n-        if method.generics.has_type_params(FnSpace) {\n-            // reason (b) above\n-            msgs.push(format!(\"cannot call a generic method (`{}`) through a trait object\",\n-                              method_name));\n-        }\n-\n-        msgs\n-    }\n \n-    fn contains_illegal_self_type_reference<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                                  trait_def_id: ast::DefId,\n-                                                  ty: Ty<'tcx>)\n-                                                  -> bool\n-    {\n-        // This is somewhat subtle. In general, we want to forbid\n-        // references to `Self` in the argument and return types,\n-        // since the value of `Self` is erased. However, there is one\n-        // exception: it is ok to reference `Self` in order to access\n-        // an associated type of the current trait, since we retain\n-        // the value of those associated types in the object type\n-        // itself.\n-        //\n-        // ```rust\n-        // trait SuperTrait {\n-        //     type X;\n-        // }\n-        //\n-        // trait Trait : SuperTrait {\n-        //     type Y;\n-        //     fn foo(&self, x: Self) // bad\n-        //     fn foo(&self) -> Self // bad\n-        //     fn foo(&self) -> Option<Self> // bad\n-        //     fn foo(&self) -> Self::Y // OK, desugars to next example\n-        //     fn foo(&self) -> <Self as Trait>::Y // OK\n-        //     fn foo(&self) -> Self::X // OK, desugars to next example\n-        //     fn foo(&self) -> <Self as SuperTrait>::X // OK\n-        // }\n-        // ```\n-        //\n-        // However, it is not as simple as allowing `Self` in a projected\n-        // type, because there are illegal ways to use `Self` as well:\n-        //\n-        // ```rust\n-        // trait Trait : SuperTrait {\n-        //     ...\n-        //     fn foo(&self) -> <Self as SomeOtherTrait>::X;\n-        // }\n-        // ```\n-        //\n-        // Here we will not have the type of `X` recorded in the\n-        // object type, and we cannot resolve `Self as SomeOtherTrait`\n-        // without knowing what `Self` is.\n-\n-        let mut supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>> = None;\n-        let mut error = false;\n-        ty::maybe_walk_ty(ty, |ty| {\n-            match ty.sty {\n-                ty::ty_param(ref param_ty) => {\n-                    if param_ty.space == SelfSpace {\n-                        error = true;\n-                    }\n-\n-                    false // no contained types to walk\n-                }\n-\n-                ty::ty_projection(ref data) => {\n-                    // This is a projected type `<Foo as SomeTrait>::X`.\n-\n-                    // Compute supertraits of current trait lazilly.\n-                    if supertraits.is_none() {\n-                        let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n-                        let trait_ref = ty::Binder(trait_def.trait_ref.clone());\n-                        supertraits = Some(traits::supertraits(tcx, trait_ref).collect());\n-                    }\n-\n-                    // Determine whether the trait reference `Foo as\n-                    // SomeTrait` is in fact a supertrait of the\n-                    // current trait. In that case, this type is\n-                    // legal, because the type `X` will be specified\n-                    // in the object type.  Note that we can just use\n-                    // direct equality here because all of these types\n-                    // are part of the formal parameter listing, and\n-                    // hence there should be no inference variables.\n-                    let projection_trait_ref = ty::Binder(data.trait_ref.clone());\n-                    let is_supertrait_of_current_trait =\n-                        supertraits.as_ref().unwrap().contains(&projection_trait_ref);\n-\n-                    if is_supertrait_of_current_trait {\n-                        false // do not walk contained types, do not report error, do collect $200\n-                    } else {\n-                        true // DO walk contained types, POSSIBLY reporting an error\n-                    }\n-                }\n-\n-                _ => true, // walk contained types, if any\n+            ObjectSafetyViolation::Method(method, MethodViolationCode::Generic) => {\n+                tcx.sess.span_note(\n+                    span,\n+                    format!(\"method `{}` has generic type parameters\",\n+                            method.name.user_string(tcx)).as_slice());\n             }\n-        });\n-\n-        error\n+        }\n     }\n }\n \n@@ -392,7 +230,7 @@ pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             cause.clone());\n     }\n \n-    // Finally, create obligations for the projection predicates.\n+    // Create obligations for the projection predicates.\n     let projection_bounds =\n         object_trait.projection_bounds_with_self_ty(fcx.tcx(), referent_ty);\n     for projection_bound in projection_bounds.iter() {\n@@ -401,9 +239,47 @@ pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.register_predicate(projection_obligation);\n     }\n \n+    // Finally, check that there IS a projection predicate for every associated type.\n+    check_object_type_binds_all_associated_types(fcx.tcx(),\n+                                                 span,\n+                                                 object_trait);\n+\n     object_trait_ref\n }\n \n+fn check_object_type_binds_all_associated_types<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                                      span: Span,\n+                                                      object_trait: &ty::TyTrait<'tcx>)\n+{\n+    let object_trait_ref =\n+        object_trait.principal_trait_ref_with_self_ty(tcx, tcx.types.err);\n+\n+    let mut associated_types: FnvHashSet<(ast::DefId, ast::Name)> =\n+        traits::supertraits(tcx, object_trait_ref.clone())\n+        .flat_map(|tr| {\n+            let trait_def = ty::lookup_trait_def(tcx, tr.def_id());\n+            trait_def.associated_type_names\n+                .clone()\n+                .into_iter()\n+                .map(move |associated_type_name| (tr.def_id(), associated_type_name))\n+        })\n+        .collect();\n+\n+    for projection_bound in object_trait.bounds.projection_bounds.iter() {\n+        let pair = (projection_bound.0.projection_ty.trait_ref.def_id,\n+                    projection_bound.0.projection_ty.item_name);\n+        associated_types.remove(&pair);\n+    }\n+\n+    for (trait_def_id, name) in associated_types.into_iter() {\n+        tcx.sess.span_err(\n+            span,\n+            format!(\"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n+                    name.user_string(tcx),\n+                    ty::item_path_str(tcx, trait_def_id)).as_slice());\n+    }\n+}\n+\n pub fn select_all_fcx_obligations_or_error(fcx: &FnCtxt) {\n     debug!(\"select_all_fcx_obligations_or_error\");\n "}, {"sha": "1da49799712bd6e3166639e85819b35fe57688da", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -18,7 +18,7 @@ use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::Span;\n use syntax::visit;\n-use util::ppaux::Repr;\n+use util::ppaux::{Repr, UserString};\n \n pub fn check(tcx: &ty::ctxt) {\n     let mut orphan = OrphanChecker { tcx: tcx };\n@@ -57,6 +57,11 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n                     ty::ty_trait(ref data) => {\n                         self.check_def_id(item.span, data.principal_def_id());\n                     }\n+                    ty::ty_uniq(..) => {\n+                        self.check_def_id(item.span,\n+                                          self.tcx.lang_items.owned_box()\n+                                              .unwrap());\n+                    }\n                     _ => {\n                         span_err!(self.tcx.sess, item.span, E0118,\n                                   \"no base type found for inherent implementation; \\\n@@ -67,10 +72,27 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n             ast::ItemImpl(_, _, Some(_), _, _) => {\n                 // \"Trait\" impl\n                 debug!(\"coherence2::orphan check: trait impl {}\", item.repr(self.tcx));\n-                if traits::is_orphan_impl(self.tcx, def_id) {\n-                    span_err!(self.tcx.sess, item.span, E0117,\n-                              \"cannot provide an extension implementation \\\n-                               where both trait and type are not defined in this crate\");\n+                match traits::orphan_check(self.tcx, def_id) {\n+                    Ok(()) => { }\n+                    Err(traits::OrphanCheckErr::NoLocalInputType) => {\n+                        span_err!(self.tcx.sess, item.span, E0117,\n+                                  \"cannot provide an extension implementation \\\n+                                   where both trait and type are not defined in this crate\");\n+                    }\n+                    Err(traits::OrphanCheckErr::UncoveredTypeParameter(param_ty)) => {\n+                        if !self.tcx.sess.features.borrow().old_orphan_check {\n+                            self.tcx.sess.span_err(\n+                                item.span,\n+                                format!(\"type parameter `{}` must also appear as a type parameter \\\n+                                         of some type defined within this crate\",\n+                                        param_ty.user_string(self.tcx)).as_slice());\n+                            self.tcx.sess.span_note(\n+                                item.span,\n+                                format!(\"for a limited time, you can add \\\n+                                         `#![feature(old_orphan_check)]` to your crate \\\n+                                         to disable this rule\").as_slice());\n+                        }\n+                    }\n                 }\n             }\n             _ => {"}, {"sha": "fe61b3de2cf6f0c5253620ed5521236c7466b87f", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -843,6 +843,7 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let bounds = compute_bounds(ccx,\n                                 self_param_ty.to_ty(ccx.tcx),\n                                 bounds.as_slice(),\n+                                SizedByDefault::No,\n                                 it.span);\n \n     let associated_type_names: Vec<_> =\n@@ -1098,6 +1099,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 let bounds = compute_bounds(ccx,\n                                             assoc_ty,\n                                             assoc_type_def.bounds.as_slice(),\n+                                            SizedByDefault::Yes,\n                                             assoc_type_def.span);\n \n                 ty::predicates(ccx.tcx, assoc_ty, &bounds).into_iter()\n@@ -1306,6 +1308,7 @@ fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n     let bounds = compute_bounds(this,\n                                 param_ty.to_ty(this.tcx()),\n                                 param.bounds[],\n+                                SizedByDefault::Yes,\n                                 param.span);\n     let default = match param.default {\n         None => None,\n@@ -1342,29 +1345,35 @@ fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n     def\n }\n \n+enum SizedByDefault { Yes, No }\n+\n /// Translate the AST's notion of ty param bounds (which are an enum consisting of a newtyped Ty or\n /// a region) to ty's notion of ty param bounds, which can either be user-defined traits, or the\n /// built-in trait (formerly known as kind): Send.\n fn compute_bounds<'tcx,AC>(this: &AC,\n                            param_ty: ty::Ty<'tcx>,\n                            ast_bounds: &[ast::TyParamBound],\n+                           sized_by_default: SizedByDefault,\n                            span: Span)\n                            -> ty::ParamBounds<'tcx>\n-                           where AC: AstConv<'tcx> {\n+                           where AC: AstConv<'tcx>\n+{\n     let mut param_bounds = conv_param_bounds(this,\n                                              span,\n                                              param_ty,\n                                              ast_bounds);\n \n-    add_unsized_bound(this,\n-                      &mut param_bounds.builtin_bounds,\n-                      ast_bounds,\n-                      span);\n+    if let SizedByDefault::Yes = sized_by_default {\n+        add_unsized_bound(this,\n+                          &mut param_bounds.builtin_bounds,\n+                          ast_bounds,\n+                          span);\n \n-    check_bounds_compatible(this.tcx(),\n-                            param_ty,\n-                            &param_bounds,\n-                            span);\n+        check_bounds_compatible(this.tcx(),\n+                                param_ty,\n+                                &param_bounds,\n+                                span);\n+    }\n \n     param_bounds.trait_bounds.sort_by(|a,b| a.def_id().cmp(&b.def_id()));\n "}, {"sha": "0f0dbf6a24dffc7de58cbf2bdeb6a4fc18a8870c", "filename": "src/librustdoc/flock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustdoc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustdoc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fflock.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -18,10 +18,10 @@\n \n pub use self::imp::Lock;\n \n-\n #[cfg(unix)]\n mod imp {\n     use libc;\n+    use std::c_str::ToCStr;\n \n     #[cfg(target_os = \"linux\")]\n     mod os {"}, {"sha": "4f277cc868a1a04873ed3abbcbc2a04e57e689ae", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -12,7 +12,7 @@ use clean::*;\n use std::iter::Extend;\n use std::mem::{replace, swap};\n \n-pub trait DocFolder {\n+pub trait DocFolder : Sized {\n     fn fold_item(&mut self, item: Item) -> Option<Item> {\n         self.fold_item_recur(item)\n     }"}, {"sha": "b4afb67170bbdb9df8854a2f6981bf2da1e6ace8", "filename": "src/librustdoc/html/escape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -29,7 +29,7 @@ impl<'a> fmt::Show for Escape<'a> {\n         for (i, ch) in s.bytes().enumerate() {\n             match ch as char {\n                 '<' | '>' | '&' | '\\'' | '\"' => {\n-                    try!(fmt.write(pile_o_bits.slice(last, i).as_bytes()));\n+                    try!(fmt.write_str(pile_o_bits.slice(last, i)));\n                     let s = match ch as char {\n                         '>' => \"&gt;\",\n                         '<' => \"&lt;\",\n@@ -38,15 +38,15 @@ impl<'a> fmt::Show for Escape<'a> {\n                         '\"' => \"&quot;\",\n                         _ => unreachable!()\n                     };\n-                    try!(fmt.write(s.as_bytes()));\n+                    try!(fmt.write_str(s));\n                     last = i + 1;\n                 }\n                 _ => {}\n             }\n         }\n \n         if last < s.len() {\n-            try!(fmt.write(pile_o_bits.slice_from(last).as_bytes()));\n+            try!(fmt.write_str(pile_o_bits.slice_from(last)));\n         }\n         Ok(())\n     }"}, {"sha": "36619566f8c8af67be8f4572a6b4131543305146", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -69,7 +69,7 @@ impl<'a> fmt::Show for TyParamBounds<'a> {\n         let &TyParamBounds(bounds) = self;\n         for (i, bound) in bounds.iter().enumerate() {\n             if i > 0 {\n-                try!(f.write(\" + \".as_bytes()));\n+                try!(f.write_str(\" + \"));\n             }\n             try!(write!(f, \"{}\", *bound));\n         }\n@@ -80,24 +80,24 @@ impl<'a> fmt::Show for TyParamBounds<'a> {\n impl fmt::Show for clean::Generics {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.lifetimes.len() == 0 && self.type_params.len() == 0 { return Ok(()) }\n-        try!(f.write(\"&lt;\".as_bytes()));\n+        try!(f.write_str(\"&lt;\"));\n \n         for (i, life) in self.lifetimes.iter().enumerate() {\n             if i > 0 {\n-                try!(f.write(\", \".as_bytes()));\n+                try!(f.write_str(\", \"));\n             }\n             try!(write!(f, \"{}\", *life));\n         }\n \n         if self.type_params.len() > 0 {\n             if self.lifetimes.len() > 0 {\n-                try!(f.write(\", \".as_bytes()));\n+                try!(f.write_str(\", \"));\n             }\n             for (i, tp) in self.type_params.iter().enumerate() {\n                 if i > 0 {\n-                    try!(f.write(\", \".as_bytes()))\n+                    try!(f.write_str(\", \"))\n                 }\n-                try!(f.write(tp.name.as_bytes()));\n+                try!(f.write_str(tp.name[]));\n \n                 if tp.bounds.len() > 0 {\n                     try!(write!(f, \": {}\", TyParamBounds(tp.bounds.as_slice())));\n@@ -109,7 +109,7 @@ impl fmt::Show for clean::Generics {\n                 };\n             }\n         }\n-        try!(f.write(\"&gt;\".as_bytes()));\n+        try!(f.write_str(\"&gt;\"));\n         Ok(())\n     }\n }\n@@ -120,10 +120,10 @@ impl<'a> fmt::Show for WhereClause<'a> {\n         if gens.where_predicates.len() == 0 {\n             return Ok(());\n         }\n-        try!(f.write(\" <span class='where'>where \".as_bytes()));\n+        try!(f.write_str(\" <span class='where'>where \"));\n         for (i, pred) in gens.where_predicates.iter().enumerate() {\n             if i > 0 {\n-                try!(f.write(\", \".as_bytes()));\n+                try!(f.write_str(\", \"));\n             }\n             match pred {\n                 &clean::WherePredicate::BoundPredicate { ref ty, ref bounds } => {\n@@ -135,7 +135,7 @@ impl<'a> fmt::Show for WhereClause<'a> {\n                     try!(write!(f, \"{}: \", lifetime));\n                     for (i, lifetime) in bounds.iter().enumerate() {\n                         if i > 0 {\n-                            try!(f.write(\" + \".as_bytes()));\n+                            try!(f.write_str(\" + \"));\n                         }\n \n                         try!(write!(f, \"{}\", lifetime));\n@@ -146,29 +146,29 @@ impl<'a> fmt::Show for WhereClause<'a> {\n                 }\n             }\n         }\n-        try!(f.write(\"</span>\".as_bytes()));\n+        try!(f.write_str(\"</span>\"));\n         Ok(())\n     }\n }\n \n impl fmt::Show for clean::Lifetime {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(f.write(self.get_ref().as_bytes()));\n+        try!(f.write_str(self.get_ref()));\n         Ok(())\n     }\n }\n \n impl fmt::Show for clean::PolyTrait {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.lifetimes.len() > 0 {\n-            try!(f.write(\"for&lt;\".as_bytes()));\n+            try!(f.write_str(\"for&lt;\"));\n             for (i, lt) in self.lifetimes.iter().enumerate() {\n                 if i > 0 {\n-                    try!(f.write(\", \".as_bytes()));\n+                    try!(f.write_str(\", \"));\n                 }\n                 try!(write!(f, \"{}\", lt));\n             }\n-            try!(f.write(\"&gt; \".as_bytes()));\n+            try!(f.write_str(\"&gt; \"));\n         }\n         write!(f, \"{}\", self.trait_)\n     }\n@@ -196,38 +196,38 @@ impl fmt::Show for clean::PathParameters {\n         match *self {\n             clean::PathParameters::AngleBracketed { ref lifetimes, ref types } => {\n                 if lifetimes.len() > 0 || types.len() > 0 {\n-                    try!(f.write(\"&lt;\".as_bytes()));\n+                    try!(f.write_str(\"&lt;\"));\n                     let mut comma = false;\n                     for lifetime in lifetimes.iter() {\n                         if comma {\n-                            try!(f.write(\", \".as_bytes()));\n+                            try!(f.write_str(\", \"));\n                         }\n                         comma = true;\n                         try!(write!(f, \"{}\", *lifetime));\n                     }\n                     for ty in types.iter() {\n                         if comma {\n-                            try!(f.write(\", \".as_bytes()));\n+                            try!(f.write_str(\", \"));\n                         }\n                         comma = true;\n                         try!(write!(f, \"{}\", *ty));\n                     }\n-                    try!(f.write(\"&gt;\".as_bytes()));\n+                    try!(f.write_str(\"&gt;\"));\n                 }\n             }\n             clean::PathParameters::Parenthesized { ref inputs, ref output } => {\n-                try!(f.write(\"(\".as_bytes()));\n+                try!(f.write_str(\"(\"));\n                 let mut comma = false;\n                 for ty in inputs.iter() {\n                     if comma {\n-                        try!(f.write(\", \".as_bytes()));\n+                        try!(f.write_str(\", \"));\n                     }\n                     comma = true;\n                     try!(write!(f, \"{}\", *ty));\n                 }\n-                try!(f.write(\")\".as_bytes()));\n+                try!(f.write_str(\")\"));\n                 if let Some(ref ty) = *output {\n-                    try!(f.write(\" -&gt; \".as_bytes()));\n+                    try!(f.write_str(\" -&gt; \"));\n                     try!(write!(f, \"{}\", ty));\n                 }\n             }\n@@ -238,20 +238,20 @@ impl fmt::Show for clean::PathParameters {\n \n impl fmt::Show for clean::PathSegment {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(f.write(self.name.as_bytes()));\n+        try!(f.write_str(self.name.as_slice()));\n         write!(f, \"{}\", self.params)\n     }\n }\n \n impl fmt::Show for clean::Path {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.global {\n-            try!(f.write(\"::\".as_bytes()))\n+            try!(f.write_str(\"::\"))\n         }\n \n         for (i, seg) in self.segments.iter().enumerate() {\n             if i > 0 {\n-                try!(f.write(\"::\".as_bytes()))\n+                try!(f.write_str(\"::\"))\n             }\n             try!(write!(f, \"{}\", seg));\n         }\n@@ -433,10 +433,10 @@ impl fmt::Show for clean::Type {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             clean::TyParamBinder(id) => {\n-                f.write(cache().typarams[ast_util::local_def(id)].as_bytes())\n+                f.write_str(cache().typarams[ast_util::local_def(id)][])\n             }\n             clean::Generic(ref name) => {\n-                f.write(name.as_bytes())\n+                f.write_str(name.as_slice())\n             }\n             clean::ResolvedPath{ did, ref typarams, ref path } => {\n                 try!(resolved_path(f, did, path, false));\n@@ -522,7 +522,7 @@ impl fmt::Show for clean::Type {\n                 primitive_link(f, clean::Slice,\n                                format!(\"[{}, ..{}]\", **t, *s).as_slice())\n             }\n-            clean::Bottom => f.write(\"!\".as_bytes()),\n+            clean::Bottom => f.write_str(\"!\"),\n             clean::RawPointer(m, ref t) => {\n                 write!(f, \"*{}{}\", RawMutableSpace(m), **t)\n             }"}, {"sha": "1fce5d5969819d8341a5141f83efd0db4bb4b8ec", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -29,11 +29,12 @@\n \n use libc;\n use std::ascii::AsciiExt;\n+use std::c_str::ToCStr;\n use std::cell::{RefCell, Cell};\n+use std::collections::HashMap;\n use std::fmt;\n use std::slice;\n use std::str;\n-use std::collections::HashMap;\n \n use html::toc::TocBuilder;\n use html::highlight;\n@@ -302,7 +303,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n \n         if ret.is_ok() {\n             let buf = slice::from_raw_buf(&(*ob).data, (*ob).size as uint);\n-            ret = w.write(buf);\n+            ret = w.write_str(str::from_utf8(buf).unwrap());\n         }\n         hoedown_buffer_free(ob);\n         ret"}, {"sha": "0cfc1042ae605eb7522aae14473cdbc233027543", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -35,6 +35,7 @@\n pub use self::ExternalLocation::*;\n \n use std::cell::RefCell;\n+use std::cmp::Ordering::{mod, Less, Greater, Equal};\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::collections::{HashMap, HashSet};\n use std::default::Default;\n@@ -49,7 +50,6 @@ use std::sync::Arc;\n use externalfiles::ExternalHtml;\n \n use serialize::json;\n-use serialize::Encodable;\n use serialize::json::ToJson;\n use syntax::ast;\n use syntax::ast_util;\n@@ -1095,7 +1095,7 @@ impl Context {\n         try!(self.recurse(stability.name.clone(), |this| {\n             let json_dst = &this.dst.join(\"stability.json\");\n             let mut json_out = BufferedWriter::new(try!(File::create(json_dst)));\n-            try!(stability.encode(&mut json::Encoder::new(&mut json_out)));\n+            try!(write!(&mut json_out, \"{}\", json::as_json(&stability)));\n \n             let mut title = stability.name.clone();\n             title.push_str(\" - Stability dashboard\");\n@@ -1311,7 +1311,8 @@ impl<'a> Item<'a> {\n         // has anchors for the line numbers that we're linking to.\n         if ast_util::is_local(self.item.def_id) {\n             let mut path = Vec::new();\n-            clean_srcpath(&cx.src_root, self.item.source.filename.as_bytes(), |component| {\n+            clean_srcpath(&cx.src_root, self.item.source.filename.as_bytes(),\n+                          |component| {\n                 path.push(component.to_string());\n             });\n             let href = if self.item.source.loline == self.item.source.hiline {\n@@ -1713,15 +1714,15 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             try!(write!(w, \";\\n\"));\n         }\n         if types.len() > 0 && required.len() > 0 {\n-            try!(w.write(\"\\n\".as_bytes()));\n+            try!(w.write_str(\"\\n\"));\n         }\n         for m in required.iter() {\n             try!(write!(w, \"    \"));\n             try!(render_method(w, m.item()));\n             try!(write!(w, \";\\n\"));\n         }\n         if required.len() > 0 && provided.len() > 0 {\n-            try!(w.write(\"\\n\".as_bytes()));\n+            try!(w.write_str(\"\\n\"));\n         }\n         for m in provided.iter() {\n             try!(write!(w, \"    \"));\n@@ -1811,6 +1812,18 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     Ok(())\n }\n \n+fn assoc_type(w: &mut fmt::Formatter, it: &clean::Item,\n+              typ: &clean::TyParam) -> fmt::Result {\n+    try!(write!(w, \"type {}\", it.name.as_ref().unwrap()));\n+    if typ.bounds.len() > 0 {\n+        try!(write!(w, \": {}\", TyParamBounds(&*typ.bounds)))\n+    }\n+    if let Some(ref default) = typ.default {\n+        try!(write!(w, \" = {}\", default));\n+    }\n+    Ok(())\n+}\n+\n fn render_method(w: &mut fmt::Formatter, meth: &clean::Item) -> fmt::Result {\n     fn method(w: &mut fmt::Formatter, it: &clean::Item, unsafety: ast::Unsafety,\n            g: &clean::Generics, selfty: &clean::SelfTy,\n@@ -1827,17 +1840,6 @@ fn render_method(w: &mut fmt::Formatter, meth: &clean::Item) -> fmt::Result {\n                decl = Method(selfty, d),\n                where_clause = WhereClause(g))\n     }\n-    fn assoc_type(w: &mut fmt::Formatter, it: &clean::Item,\n-                  typ: &clean::TyParam) -> fmt::Result {\n-        try!(write!(w, \"type {}\", it.name.as_ref().unwrap()));\n-        if typ.bounds.len() > 0 {\n-            try!(write!(w, \": {}\", TyParamBounds(&*typ.bounds)))\n-        }\n-        if let Some(ref default) = typ.default {\n-            try!(write!(w, \" = {}\", default));\n-        }\n-        Ok(())\n-    }\n     match meth.inner {\n         clean::TyMethodItem(ref m) => {\n             method(w, meth, m.unsafety, &m.generics, &m.self_, &m.decl)\n@@ -2122,6 +2124,15 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl) -> fmt::Result {\n                 try!(write!(w, \"type {} = {}\", name, tydef.type_));\n                 try!(write!(w, \"</code></h4>\\n\"));\n             }\n+            clean::AssociatedTypeItem(ref typaram) => {\n+                let name = item.name.as_ref().unwrap();\n+                try!(write!(w, \"<h4 id='assoc_type.{}' class='{}'>{}<code>\",\n+                            *name,\n+                            shortty(item),\n+                            ConciseStability(&item.stability)));\n+                try!(assoc_type(w, item, typaram));\n+                try!(write!(w, \"</code></h4>\\n\"));\n+            }\n             _ => panic!(\"can't make docs for trait item with name {}\", item.name)\n         }\n         match item.doc_value() {\n@@ -2260,8 +2271,9 @@ impl<'a> fmt::Show for Source<'a> {\n \n fn item_macro(w: &mut fmt::Formatter, it: &clean::Item,\n               t: &clean::Macro) -> fmt::Result {\n-    try!(w.write(highlight::highlight(t.source.as_slice(), Some(\"macro\"),\n-                                      None).as_bytes()));\n+    try!(w.write_str(highlight::highlight(t.source.as_slice(),\n+                                          Some(\"macro\"),\n+                                          None)[]));\n     document(w, it)\n }\n "}, {"sha": "1beeeaf629dbf0e724acd1ab807ce91deeac363c", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -20,6 +20,7 @@\n #![allow(unknown_features)]\n #![feature(globs, macro_rules, phase, slicing_syntax)]\n #![feature(unboxed_closures)]\n+#![feature(old_orphan_check)]\n \n extern crate arena;\n extern crate getopts;\n@@ -41,7 +42,7 @@ use std::io::File;\n use std::io;\n use std::rc::Rc;\n use externalfiles::ExternalHtml;\n-use serialize::{Decodable, Encodable};\n+use serialize::Decodable;\n use serialize::json::{mod, Json};\n use rustc::session::search_paths::SearchPaths;\n \n@@ -493,14 +494,7 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n \n     // FIXME #8335: yuck, Rust -> str -> JSON round trip! No way to .encode\n     // straight to the Rust JSON representation.\n-    let crate_json_str = {\n-        let mut w = Vec::new();\n-        {\n-            let mut encoder = json::Encoder::new(&mut w as &mut io::Writer);\n-            krate.encode(&mut encoder).unwrap();\n-        }\n-        String::from_utf8(w).unwrap()\n-    };\n+    let crate_json_str = format!(\"{}\", json::as_json(&krate));\n     let crate_json = match json::from_str(crate_json_str.as_slice()) {\n         Ok(j) => j,\n         Err(e) => panic!(\"Rust generated JSON is invalid: {}\", e)\n@@ -510,5 +504,5 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n     json.insert(\"plugins\".to_string(), Json::Object(plugins_json));\n \n     let mut file = try!(File::create(&dst));\n-    Json::Object(json).to_writer(&mut file)\n+    write!(&mut file, \"{}\", Json::Object(json))\n }"}, {"sha": "058a7acd4550b7874be6c7090df920d72d1ac12c", "filename": "src/librustdoc/stability_summary.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustdoc%2Fstability_summary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustdoc%2Fstability_summary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fstability_summary.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -13,8 +13,9 @@\n //! hierarchy, with item counts for every stability level per module. A parent\n //! module's count includes its children's.\n \n-use std::ops::Add;\n+use std::cmp::Ordering;\n use std::num::Zero;\n+use std::ops::Add;\n \n use syntax::attr::{Deprecated, Experimental, Unstable, Stable, Frozen, Locked};\n use syntax::ast::Public;"}, {"sha": "743c8b240d125a0b8f68cda808bf5c8cdfa8aa1d", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -9,14 +9,14 @@\n // except according to those terms.\n \n use std::cell::RefCell;\n+use std::sync::mpsc::channel;\n use std::dynamic_lib::DynamicLibrary;\n use std::io::{Command, TempDir};\n use std::io;\n use std::os;\n use std::str;\n-use std::string::String;\n-use std::thunk::Thunk;\n use std::thread::Thread;\n+use std::thunk::Thunk;\n \n use std::collections::{HashSet, HashMap};\n use testing;"}, {"sha": "a87044bb3b3ba02e9ebe7902ea3ebd0bb1447ec8", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 153, "deletions": 137, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -76,12 +76,13 @@\n //! Create a struct called `TestStruct` and serialize and deserialize it to and from JSON using the\n //! serialization API, using the derived serialization code.\n //!\n-//! ```rust\n+//! ```notrust\n+//! // FIXME(#19470): this cannot be ```rust``` because it fails orphan checking at the moment\n //! extern crate serialize;\n //! use serialize::json;\n //!\n //! // Automatically generate `Decodable` and `Encodable` trait implementations\n-//! #[deriving(Decodable, Encodable)]\n+//! #[deriving(RustcDecodable, RustcEncodable)]\n //! pub struct TestStruct  {\n //!     data_int: u8,\n //!     data_str: String,\n@@ -110,7 +111,8 @@\n //!\n //! ### Simple example of `ToJson` usage\n //!\n-//! ```rust\n+//! ```notrust\n+//! // FIXME(#19470): this cannot be ```rust``` because it fails orphan checking at the moment\n //! extern crate serialize;\n //! use serialize::json::{mod, ToJson, Json};\n //!\n@@ -149,7 +151,8 @@\n //!\n //! ### Verbose example of `ToJson` usage\n //!\n-//! ```rust\n+//! ```notrust\n+//! // FIXME(#19470): this cannot be ```rust``` because it fails orphan checking at the moment\n //! extern crate serialize;\n //! use std::collections::BTreeMap;\n //! use serialize::json::{mod, Json, ToJson};\n@@ -227,6 +230,11 @@ pub enum Json {\n pub type Array = Vec<Json>;\n pub type Object = BTreeMap<string::String, Json>;\n \n+pub struct PrettyJson<'a> { inner: &'a Json }\n+\n+pub struct AsJson<'a, T: 'a> { inner: &'a T }\n+pub struct AsPrettyJson<'a, T: 'a> { inner: &'a T, indent: Option<uint> }\n+\n /// The errors that can arise while parsing a JSON stream.\n #[deriving(Clone, Copy, PartialEq)]\n pub enum ErrorCode {\n@@ -303,9 +311,15 @@ pub fn decode<T: ::Decodable<Decoder, DecoderError>>(s: &str) -> DecodeResult<T>\n }\n \n /// Shortcut function to encode a `T` into a JSON `String`\n-pub fn encode<'a, T: Encodable<Encoder<'a>, io::IoError>>(object: &T) -> string::String {\n-    let buff = Encoder::buffer_encode(object);\n-    string::String::from_utf8(buff).unwrap()\n+pub fn encode<T>(object: &T) -> string::String\n+                 where T: for<'a> Encodable<Encoder<'a>, fmt::Error>\n+{\n+    let mut s = String::new();\n+    {\n+        let mut encoder = Encoder::new(&mut s);\n+        let _ = object.encode(&mut encoder);\n+    }\n+    s\n }\n \n impl fmt::Show for ErrorCode {\n@@ -323,16 +337,16 @@ impl std::error::Error for DecoderError {\n     fn detail(&self) -> Option<std::string::String> { Some(self.to_string()) }\n }\n \n-pub type EncodeResult = io::IoResult<()>;\n+pub type EncodeResult = fmt::Result;\n pub type DecodeResult<T> = Result<T, DecoderError>;\n \n-pub fn escape_bytes(wr: &mut io::Writer, bytes: &[u8]) -> Result<(), io::IoError> {\n+fn escape_str(wr: &mut fmt::Writer, v: &str) -> fmt::Result {\n     try!(wr.write_str(\"\\\"\"));\n \n     let mut start = 0;\n \n-    for (i, byte) in bytes.iter().enumerate() {\n-        let escaped = match *byte {\n+    for (i, byte) in v.bytes().enumerate() {\n+        let escaped = match byte {\n             b'\"' => \"\\\\\\\"\",\n             b'\\\\' => \"\\\\\\\\\",\n             b'\\x00' => \"\\\\u0000\",\n@@ -372,42 +386,38 @@ pub fn escape_bytes(wr: &mut io::Writer, bytes: &[u8]) -> Result<(), io::IoError\n         };\n \n         if start < i {\n-            try!(wr.write(bytes[start..i]));\n+            try!(wr.write_str(v[start..i]));\n         }\n \n         try!(wr.write_str(escaped));\n \n         start = i + 1;\n     }\n \n-    if start != bytes.len() {\n-        try!(wr.write(bytes[start..]));\n+    if start != v.len() {\n+        try!(wr.write_str(v[start..]));\n     }\n \n     wr.write_str(\"\\\"\")\n }\n \n-fn escape_str(writer: &mut io::Writer, v: &str) -> Result<(), io::IoError> {\n-    escape_bytes(writer, v.as_bytes())\n-}\n-\n-fn escape_char(writer: &mut io::Writer, v: char) -> Result<(), io::IoError> {\n+fn escape_char(writer: &mut fmt::Writer, v: char) -> fmt::Result {\n     let mut buf = [0; 4];\n-    let len = v.encode_utf8(&mut buf).unwrap();\n-    escape_bytes(writer, buf[mut ..len])\n+    let n = v.encode_utf8(&mut buf).unwrap();\n+    let buf = unsafe { str::from_utf8_unchecked(buf[0..n]) };\n+    escape_str(writer, buf)\n }\n \n-fn spaces(wr: &mut io::Writer, mut n: uint) -> Result<(), io::IoError> {\n-    const LEN: uint = 16;\n-    static BUF: [u8; LEN] = [b' '; LEN];\n+fn spaces(wr: &mut fmt::Writer, mut n: uint) -> fmt::Result {\n+    const BUF: &'static str = \"                \";\n \n-    while n >= LEN {\n-        try!(wr.write(&BUF));\n-        n -= LEN;\n+    while n >= BUF.len() {\n+        try!(wr.write_str(BUF));\n+        n -= BUF.len();\n     }\n \n     if n > 0 {\n-        wr.write(BUF[..n])\n+        wr.write_str(BUF[..n])\n     } else {\n         Ok(())\n     }\n@@ -423,31 +433,18 @@ fn fmt_number_or_null(v: f64) -> string::String {\n \n /// A structure for implementing serialization to JSON.\n pub struct Encoder<'a> {\n-    writer: &'a mut (io::Writer+'a),\n+    writer: &'a mut (fmt::Writer+'a),\n }\n \n impl<'a> Encoder<'a> {\n     /// Creates a new JSON encoder whose output will be written to the writer\n     /// specified.\n-    pub fn new(writer: &'a mut io::Writer) -> Encoder<'a> {\n+    pub fn new(writer: &'a mut fmt::Writer) -> Encoder<'a> {\n         Encoder { writer: writer }\n     }\n-\n-    /// Encode the specified struct into a json [u8]\n-    pub fn buffer_encode<T: Encodable<Encoder<'a>, io::IoError>>(object: &T) -> Vec<u8>  {\n-        //Serialize the object in a string using a writer\n-        let mut m = Vec::new();\n-        // FIXME(14302) remove the transmute and unsafe block.\n-        unsafe {\n-            let mut encoder = Encoder::new(&mut m as &mut io::Writer);\n-            // Vec<u8> never Errs\n-            let _ = object.encode(transmute(&mut encoder));\n-        }\n-        m\n-    }\n }\n \n-impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n+impl<'a> ::Encoder<fmt::Error> for Encoder<'a> {\n     fn emit_nil(&mut self) -> EncodeResult { write!(self.writer, \"null\") }\n \n     fn emit_uint(&mut self, v: uint) -> EncodeResult { write!(self.writer, \"{}\", v) }\n@@ -646,14 +643,14 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n /// Another encoder for JSON, but prints out human-readable JSON instead of\n /// compact data\n pub struct PrettyEncoder<'a> {\n-    writer: &'a mut (io::Writer+'a),\n+    writer: &'a mut (fmt::Writer+'a),\n     curr_indent: uint,\n     indent: uint,\n }\n \n impl<'a> PrettyEncoder<'a> {\n     /// Creates a new encoder whose output will be written to the specified writer\n-    pub fn new(writer: &'a mut io::Writer) -> PrettyEncoder<'a> {\n+    pub fn new(writer: &'a mut fmt::Writer) -> PrettyEncoder<'a> {\n         PrettyEncoder { writer: writer, curr_indent: 0, indent: 2, }\n     }\n \n@@ -667,7 +664,7 @@ impl<'a> PrettyEncoder<'a> {\n     }\n }\n \n-impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n+impl<'a> ::Encoder<fmt::Error> for PrettyEncoder<'a> {\n     fn emit_nil(&mut self) -> EncodeResult { write!(self.writer, \"null\") }\n \n     fn emit_uint(&mut self, v: uint) -> EncodeResult { write!(self.writer, \"{}\", v) }\n@@ -927,25 +924,23 @@ impl<E: ::Encoder<S>, S> Encodable<E, S> for Json {\n     }\n }\n \n-impl Json {\n-    /// Encodes a json value into an io::writer. Uses a single line.\n-    pub fn to_writer(&self, writer: &mut io::Writer) -> EncodeResult {\n-        let mut encoder = Encoder::new(writer);\n-        self.encode(&mut encoder)\n-    }\n+/// Create an `AsJson` wrapper which can be used to print a value as JSON\n+/// on-the-fly via `write!`\n+pub fn as_json<T>(t: &T) -> AsJson<T> {\n+    AsJson { inner: t }\n+}\n \n-    /// Encodes a json value into an io::writer.\n-    /// Pretty-prints in a more readable format.\n-    pub fn to_pretty_writer(&self, writer: &mut io::Writer) -> EncodeResult {\n-        let mut encoder = PrettyEncoder::new(writer);\n-        self.encode(&mut encoder)\n-    }\n+/// Create an `AsPrettyJson` wrapper which can be used to print a value as JSON\n+/// on-the-fly via `write!`\n+pub fn as_pretty_json<T>(t: &T) -> AsPrettyJson<T> {\n+    AsPrettyJson { inner: t, indent: None }\n+}\n \n-    /// Encodes a json value into a string\n-    pub fn to_pretty_str(&self) -> string::String {\n-        let mut s = Vec::new();\n-        self.to_pretty_writer(&mut s as &mut io::Writer).unwrap();\n-        string::String::from_utf8(s).unwrap()\n+impl Json {\n+    /// Borrow this json object as a pretty object to generate a pretty\n+    /// representation for it via `Show`.\n+    pub fn pretty(&self) -> PrettyJson {\n+        PrettyJson { inner: self }\n     }\n \n      /// If the Json value is an Object, returns the value associated with the provided key.\n@@ -2424,10 +2419,65 @@ impl<A:ToJson> ToJson for Option<A> {\n     }\n }\n \n+struct FormatShim<'a, 'b: 'a> {\n+    inner: &'a mut fmt::Formatter<'b>,\n+}\n+\n+impl<'a, 'b> fmt::Writer for FormatShim<'a, 'b> {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        self.inner.write_str(s)\n+    }\n+}\n+\n impl fmt::Show for Json {\n     /// Encodes a json value into a string\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.to_writer(f).map_err(|_| fmt::Error)\n+        let mut shim = FormatShim { inner: f };\n+        let mut encoder = Encoder::new(&mut shim);\n+        self.encode(&mut encoder)\n+    }\n+}\n+\n+impl<'a> fmt::Show for PrettyJson<'a> {\n+    /// Encodes a json value into a string\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let mut shim = FormatShim { inner: f };\n+        let mut encoder = PrettyEncoder::new(&mut shim);\n+        self.inner.encode(&mut encoder)\n+    }\n+}\n+\n+impl<'a, T> fmt::Show for AsJson<'a, T>\n+    where T: for<'b> Encodable<Encoder<'b>, fmt::Error>\n+{\n+    /// Encodes a json value into a string\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let mut shim = FormatShim { inner: f };\n+        let mut encoder = Encoder::new(&mut shim);\n+        self.inner.encode(&mut encoder)\n+    }\n+}\n+\n+impl<'a, T> AsPrettyJson<'a, T> {\n+    /// Set the indentation level for the emitted JSON\n+    pub fn indent(mut self, indent: uint) -> AsPrettyJson<'a, T> {\n+        self.indent = Some(indent);\n+        self\n+    }\n+}\n+\n+impl<'a, T> fmt::Show for AsPrettyJson<'a, T>\n+    where T: for<'b> Encodable<PrettyEncoder<'b>, fmt::Error>\n+{\n+    /// Encodes a json value into a string\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let mut shim = FormatShim { inner: f };\n+        let mut encoder = PrettyEncoder::new(&mut shim);\n+        match self.indent {\n+            Some(n) => encoder.set_indent(n),\n+            None => {}\n+        }\n+        self.inner.encode(&mut encoder)\n     }\n }\n \n@@ -2450,9 +2500,9 @@ mod tests {\n     use super::DecoderError::*;\n     use super::JsonEvent::*;\n     use super::StackElement::*;\n-    use super::{PrettyEncoder, Json, from_str, DecodeResult, DecoderError, JsonEvent, Parser,\n-                StackElement, Stack, Encoder, Decoder};\n-    use std::{i64, u64, f32, f64, io};\n+    use super::{Json, from_str, DecodeResult, DecoderError, JsonEvent, Parser,\n+                StackElement, Stack, Decoder};\n+    use std::{i64, u64, f32, f64};\n     use std::collections::BTreeMap;\n     use std::num::Float;\n     use std::string;\n@@ -2523,74 +2573,74 @@ mod tests {\n     #[test]\n     fn test_write_null() {\n         assert_eq!(Null.to_string(), \"null\");\n-        assert_eq!(Null.to_pretty_str(), \"null\");\n+        assert_eq!(Null.pretty().to_string(), \"null\");\n     }\n \n     #[test]\n     fn test_write_i64() {\n         assert_eq!(U64(0).to_string(), \"0\");\n-        assert_eq!(U64(0).to_pretty_str(), \"0\");\n+        assert_eq!(U64(0).pretty().to_string(), \"0\");\n \n         assert_eq!(U64(1234).to_string(), \"1234\");\n-        assert_eq!(U64(1234).to_pretty_str(), \"1234\");\n+        assert_eq!(U64(1234).pretty().to_string(), \"1234\");\n \n         assert_eq!(I64(-5678).to_string(), \"-5678\");\n-        assert_eq!(I64(-5678).to_pretty_str(), \"-5678\");\n+        assert_eq!(I64(-5678).pretty().to_string(), \"-5678\");\n \n         assert_eq!(U64(7650007200025252000).to_string(), \"7650007200025252000\");\n-        assert_eq!(U64(7650007200025252000).to_pretty_str(), \"7650007200025252000\");\n+        assert_eq!(U64(7650007200025252000).pretty().to_string(), \"7650007200025252000\");\n     }\n \n     #[test]\n     fn test_write_f64() {\n         assert_eq!(F64(3.0).to_string(), \"3.0\");\n-        assert_eq!(F64(3.0).to_pretty_str(), \"3.0\");\n+        assert_eq!(F64(3.0).pretty().to_string(), \"3.0\");\n \n         assert_eq!(F64(3.1).to_string(), \"3.1\");\n-        assert_eq!(F64(3.1).to_pretty_str(), \"3.1\");\n+        assert_eq!(F64(3.1).pretty().to_string(), \"3.1\");\n \n         assert_eq!(F64(-1.5).to_string(), \"-1.5\");\n-        assert_eq!(F64(-1.5).to_pretty_str(), \"-1.5\");\n+        assert_eq!(F64(-1.5).pretty().to_string(), \"-1.5\");\n \n         assert_eq!(F64(0.5).to_string(), \"0.5\");\n-        assert_eq!(F64(0.5).to_pretty_str(), \"0.5\");\n+        assert_eq!(F64(0.5).pretty().to_string(), \"0.5\");\n \n         assert_eq!(F64(f64::NAN).to_string(), \"null\");\n-        assert_eq!(F64(f64::NAN).to_pretty_str(), \"null\");\n+        assert_eq!(F64(f64::NAN).pretty().to_string(), \"null\");\n \n         assert_eq!(F64(f64::INFINITY).to_string(), \"null\");\n-        assert_eq!(F64(f64::INFINITY).to_pretty_str(), \"null\");\n+        assert_eq!(F64(f64::INFINITY).pretty().to_string(), \"null\");\n \n         assert_eq!(F64(f64::NEG_INFINITY).to_string(), \"null\");\n-        assert_eq!(F64(f64::NEG_INFINITY).to_pretty_str(), \"null\");\n+        assert_eq!(F64(f64::NEG_INFINITY).pretty().to_string(), \"null\");\n     }\n \n     #[test]\n     fn test_write_str() {\n         assert_eq!(String(\"\".to_string()).to_string(), \"\\\"\\\"\");\n-        assert_eq!(String(\"\".to_string()).to_pretty_str(), \"\\\"\\\"\");\n+        assert_eq!(String(\"\".to_string()).pretty().to_string(), \"\\\"\\\"\");\n \n         assert_eq!(String(\"homura\".to_string()).to_string(), \"\\\"homura\\\"\");\n-        assert_eq!(String(\"madoka\".to_string()).to_pretty_str(), \"\\\"madoka\\\"\");\n+        assert_eq!(String(\"madoka\".to_string()).pretty().to_string(), \"\\\"madoka\\\"\");\n     }\n \n     #[test]\n     fn test_write_bool() {\n         assert_eq!(Boolean(true).to_string(), \"true\");\n-        assert_eq!(Boolean(true).to_pretty_str(), \"true\");\n+        assert_eq!(Boolean(true).pretty().to_string(), \"true\");\n \n         assert_eq!(Boolean(false).to_string(), \"false\");\n-        assert_eq!(Boolean(false).to_pretty_str(), \"false\");\n+        assert_eq!(Boolean(false).pretty().to_string(), \"false\");\n     }\n \n     #[test]\n     fn test_write_array() {\n         assert_eq!(Array(vec![]).to_string(), \"[]\");\n-        assert_eq!(Array(vec![]).to_pretty_str(), \"[]\");\n+        assert_eq!(Array(vec![]).pretty().to_string(), \"[]\");\n \n         assert_eq!(Array(vec![Boolean(true)]).to_string(), \"[true]\");\n         assert_eq!(\n-            Array(vec![Boolean(true)]).to_pretty_str(),\n+            Array(vec![Boolean(true)]).pretty().to_string(),\n             \"\\\n             [\\n  \\\n                 true\\n\\\n@@ -2605,7 +2655,7 @@ mod tests {\n         assert_eq!(long_test_array.to_string(),\n             \"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\");\n         assert_eq!(\n-            long_test_array.to_pretty_str(),\n+            long_test_array.pretty().to_string(),\n             \"\\\n             [\\n  \\\n                 false,\\n  \\\n@@ -2621,7 +2671,7 @@ mod tests {\n     #[test]\n     fn test_write_object() {\n         assert_eq!(mk_object(&[]).to_string(), \"{}\");\n-        assert_eq!(mk_object(&[]).to_pretty_str(), \"{}\");\n+        assert_eq!(mk_object(&[]).pretty().to_string(), \"{}\");\n \n         assert_eq!(\n             mk_object(&[\n@@ -2630,7 +2680,7 @@ mod tests {\n             \"{\\\"a\\\":true}\"\n         );\n         assert_eq!(\n-            mk_object(&[(\"a\".to_string(), Boolean(true))]).to_pretty_str(),\n+            mk_object(&[(\"a\".to_string(), Boolean(true))]).pretty().to_string(),\n             \"\\\n             {\\n  \\\n                 \\\"a\\\": true\\n\\\n@@ -2654,7 +2704,7 @@ mod tests {\n             }\"\n         );\n         assert_eq!(\n-            complex_obj.to_pretty_str(),\n+            complex_obj.pretty().to_string(),\n             \"\\\n             {\\n  \\\n                 \\\"b\\\": [\\n    \\\n@@ -2678,48 +2728,29 @@ mod tests {\n \n         // We can't compare the strings directly because the object fields be\n         // printed in a different order.\n-        assert_eq!(a.clone(), from_str(a.to_string().as_slice()).unwrap());\n-        assert_eq!(a.clone(),\n-                   from_str(a.to_pretty_str().as_slice()).unwrap());\n-    }\n-\n-    fn with_str_writer<F>(f: F) -> string::String where F: FnOnce(&mut io::Writer){\n-        let mut m = Vec::new();\n-        f(&mut m as &mut io::Writer);\n-        string::String::from_utf8(m).unwrap()\n+        assert_eq!(a.clone(), a.to_string().parse().unwrap());\n+        assert_eq!(a.clone(), a.pretty().to_string().parse().unwrap());\n     }\n \n     #[test]\n     fn test_write_enum() {\n         let animal = Dog;\n         assert_eq!(\n-            with_str_writer(|writer| {\n-                let mut encoder = Encoder::new(writer);\n-                animal.encode(&mut encoder).unwrap();\n-            }),\n+            format!(\"{}\", super::as_json(&animal)),\n             \"\\\"Dog\\\"\"\n         );\n         assert_eq!(\n-            with_str_writer(|writer| {\n-                let mut encoder = PrettyEncoder::new(writer);\n-                animal.encode(&mut encoder).unwrap();\n-            }),\n+            format!(\"{}\", super::as_pretty_json(&animal)),\n             \"\\\"Dog\\\"\"\n         );\n \n         let animal = Frog(\"Henry\".to_string(), 349);\n         assert_eq!(\n-            with_str_writer(|writer| {\n-                let mut encoder = Encoder::new(writer);\n-                animal.encode(&mut encoder).unwrap();\n-            }),\n+            format!(\"{}\", super::as_json(&animal)),\n             \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\"\n         );\n         assert_eq!(\n-            with_str_writer(|writer| {\n-                let mut encoder = PrettyEncoder::new(writer);\n-                animal.encode(&mut encoder).unwrap();\n-            }),\n+            format!(\"{}\", super::as_pretty_json(&animal)),\n             \"{\\n  \\\n                \\\"variant\\\": \\\"Frog\\\",\\n  \\\n                \\\"fields\\\": [\\n    \\\n@@ -2732,16 +2763,10 @@ mod tests {\n \n     macro_rules! check_encoder_for_simple {\n         ($value:expr, $expected:expr) => ({\n-            let s = with_str_writer(|writer| {\n-                let mut encoder = Encoder::new(writer);\n-                $value.encode(&mut encoder).unwrap();\n-            });\n+            let s = format!(\"{}\", super::as_json(&$value));\n             assert_eq!(s, $expected);\n \n-            let s = with_str_writer(|writer| {\n-                let mut encoder = PrettyEncoder::new(writer);\n-                $value.encode(&mut encoder).unwrap();\n-            });\n+            let s = format!(\"{}\", super::as_pretty_json(&$value));\n             assert_eq!(s, $expected);\n         })\n     }\n@@ -3320,10 +3345,7 @@ mod tests {\n         let mut hm: HashMap<uint, bool> = HashMap::new();\n         hm.insert(1, true);\n         let mut mem_buf = Vec::new();\n-        {\n-            let mut encoder = Encoder::new(&mut mem_buf as &mut io::Writer);\n-            hm.encode(&mut encoder).unwrap();\n-        }\n+        write!(&mut mem_buf, \"{}\", super::as_pretty_json(&hm)).unwrap();\n         let json_str = from_utf8(mem_buf[]).unwrap();\n         match from_str(json_str) {\n             Err(_) => panic!(\"Unable to parse json_str: {}\", json_str),\n@@ -3339,10 +3361,7 @@ mod tests {\n         let mut hm: HashMap<uint, bool> = HashMap::new();\n         hm.insert(1, true);\n         let mut mem_buf = Vec::new();\n-        {\n-            let mut encoder = PrettyEncoder::new(&mut mem_buf as &mut io::Writer);\n-            hm.encode(&mut encoder).unwrap()\n-        }\n+        write!(&mut mem_buf, \"{}\", super::as_pretty_json(&hm)).unwrap();\n         let json_str = from_utf8(mem_buf[]).unwrap();\n         match from_str(json_str) {\n             Err(_) => panic!(\"Unable to parse json_str: {}\", json_str),\n@@ -3373,18 +3392,15 @@ mod tests {\n \n         // Helper function for counting indents\n         fn indents(source: &str) -> uint {\n-            let trimmed = source.trim_left_chars(' ');\n+            let trimmed = source.trim_left_matches(' ');\n             source.len() - trimmed.len()\n         }\n \n         // Test up to 4 spaces of indents (more?)\n         for i in range(0, 4u) {\n             let mut writer = Vec::new();\n-            {\n-                let ref mut encoder = PrettyEncoder::new(&mut writer);\n-                encoder.set_indent(i);\n-                json.encode(encoder).unwrap();\n-            }\n+            write!(&mut writer, \"{}\",\n+                   super::as_pretty_json(&json).indent(i)).unwrap();\n \n             let printed = from_utf8(writer[]).unwrap();\n "}, {"sha": "857a7072009bdb6119fc4284fc17b499de009d4d", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -315,8 +315,8 @@ static ASCII_UPPERCASE_MAP: [u8; 256] = [\n \n #[cfg(test)]\n mod tests {\n+    use prelude::v1::*;\n     use super::*;\n-    use prelude::*;\n     use char::from_u32;\n \n     #[test]"}, {"sha": "c07531d3f32d65ab17df599bfca4d1172b76a265", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -209,39 +209,39 @@ macro_rules! bitflags {\n             }\n         }\n \n-        impl BitOr<$BitFlags, $BitFlags> for $BitFlags {\n+        impl ::std::ops::BitOr<$BitFlags, $BitFlags> for $BitFlags {\n             /// Returns the union of the two sets of flags.\n             #[inline]\n             fn bitor(self, other: $BitFlags) -> $BitFlags {\n                 $BitFlags { bits: self.bits | other.bits }\n             }\n         }\n \n-        impl BitXor<$BitFlags, $BitFlags> for $BitFlags {\n+        impl ::std::ops::BitXor<$BitFlags, $BitFlags> for $BitFlags {\n             /// Returns the left flags, but with all the right flags toggled.\n             #[inline]\n             fn bitxor(self, other: $BitFlags) -> $BitFlags {\n                 $BitFlags { bits: self.bits ^ other.bits }\n             }\n         }\n \n-        impl BitAnd<$BitFlags, $BitFlags> for $BitFlags {\n+        impl ::std::ops::BitAnd<$BitFlags, $BitFlags> for $BitFlags {\n             /// Returns the intersection between the two sets of flags.\n             #[inline]\n             fn bitand(self, other: $BitFlags) -> $BitFlags {\n                 $BitFlags { bits: self.bits & other.bits }\n             }\n         }\n \n-        impl Sub<$BitFlags, $BitFlags> for $BitFlags {\n+        impl ::std::ops::Sub<$BitFlags, $BitFlags> for $BitFlags {\n             /// Returns the set difference of the two sets of flags.\n             #[inline]\n             fn sub(self, other: $BitFlags) -> $BitFlags {\n                 $BitFlags { bits: self.bits & !other.bits }\n             }\n         }\n \n-        impl Not<$BitFlags> for $BitFlags {\n+        impl ::std::ops::Not<$BitFlags> for $BitFlags {\n             /// Returns the complement of this set of flags.\n             #[inline]\n             fn not(self) -> $BitFlags {\n@@ -266,7 +266,6 @@ macro_rules! bitflags {\n mod tests {\n     use hash;\n     use option::Option::{Some, None};\n-    use ops::{BitOr, BitAnd, BitXor, Sub, Not};\n \n     bitflags! {\n         #[doc = \"> The first principle is that you must not fool yourself \u2014 and\"]"}, {"sha": "b1433ad7fdc625d249da00d8e076177b9153c576", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -45,6 +45,8 @@\n //! ```rust\n //! extern crate libc;\n //!\n+//! use std::c_str::ToCStr;\n+//!\n //! extern {\n //!     fn puts(s: *const libc::c_char);\n //! }\n@@ -70,6 +72,7 @@\n use core::prelude::*;\n use libc;\n \n+use cmp::Ordering;\n use fmt;\n use hash;\n use mem;\n@@ -155,6 +158,8 @@ impl CString {\n     /// one).\n     ///\n     /// ```rust\n+    /// use std::c_str::ToCStr;\n+    ///\n     /// let foo = \"some string\";\n     ///\n     /// // right\n@@ -170,6 +175,8 @@ impl CString {\n     /// ```rust\n     /// extern crate libc;\n     ///\n+    /// use std::c_str::ToCStr;\n+    ///\n     /// fn main() {\n     ///     let c_str = \"foo bar\".to_c_str();\n     ///     unsafe {\n@@ -189,6 +196,8 @@ impl CString {\n     /// one).\n     ///\n     /// ```rust\n+    /// use std::c_str::ToCStr;\n+    ///\n     /// let foo = \"some string\";\n     ///\n     /// // right\n@@ -309,6 +318,8 @@ pub trait ToCStr for Sized? {\n     /// ```rust\n     /// extern crate libc;\n     ///\n+    /// use std::c_str::ToCStr;\n+    ///\n     /// fn main() {\n     ///     let s = \"PATH\".with_c_str(|path| unsafe {\n     ///         libc::getenv(path)\n@@ -538,9 +549,8 @@ pub unsafe fn from_c_multistring<F>(buf: *const libc::c_char,\n \n #[cfg(test)]\n mod tests {\n+    use prelude::v1::*;\n     use super::*;\n-    use prelude::{spawn, Some, None, Option, FnOnce, ToString, CloneSliceExt};\n-    use prelude::{Clone, PtrExt, Iterator, SliceExt, StrExt};\n     use ptr;\n     use thread::Thread;\n     use libc;\n@@ -613,7 +623,7 @@ mod tests {\n     #[test]\n     fn test_unwrap() {\n         let c_str = \"hello\".to_c_str();\n-        unsafe { libc::free(c_str.unwrap() as *mut libc::c_void) }\n+        unsafe { libc::free(c_str.into_inner() as *mut libc::c_void) }\n     }\n \n     #[test]\n@@ -732,9 +742,10 @@ mod tests {\n mod bench {\n     extern crate test;\n \n+    use prelude::v1::*;\n     use self::test::Bencher;\n     use libc;\n-    use prelude::*;\n+    use c_str::ToCStr;\n \n     #[inline]\n     fn check(s: &str, c_str: *const libc::c_char) {"}, {"sha": "40942f1b987988564211856e27092930da7b91a7", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -172,7 +172,7 @@ impl<T> AsSlice<T> for CVec<T> {\n \n #[cfg(test)]\n mod tests {\n-    use prelude::*;\n+    use prelude::v1::*;\n \n     use super::CVec;\n     use libc;\n@@ -228,7 +228,7 @@ mod tests {\n             let cv = CVec::new_with_dtor(1 as *mut int,\n                                          0,\n                                          move|:| panic!(\"Don't run this destructor!\"));\n-            let p = cv.unwrap();\n+            let p = cv.into_inner();\n             assert_eq!(p, 1 as *mut int);\n         }\n     }"}, {"sha": "28689767cb0e3524323238c3f7fdc10893b769ab", "filename": "src/libstd/collections/hash/bench.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -11,7 +11,7 @@\n #![cfg(test)]\n \n extern crate test;\n-use prelude::*;\n+use prelude::v1::*;\n \n use self::test::Bencher;\n use iter::{range_inclusive};"}, {"sha": "d4fc4150fae9143877fa8e772875fb9e976215f9", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -87,7 +87,7 @@ impl DefaultResizePolicy {\n \n #[test]\n fn test_resize_policy() {\n-    use prelude::*;\n+    use prelude::v1::*;\n     let rp = DefaultResizePolicy;\n     for n in range(0u, 1000) {\n         assert!(rp.min_capacity(rp.usable_capacity(n)) <= n);\n@@ -311,7 +311,7 @@ fn search_hashed<K, V, M, F>(table: M,\n                              hash: SafeHash,\n                              mut is_match: F)\n                              -> SearchResult<K, V, M> where\n-    M: Deref<RawTable<K, V>>,\n+    M: Deref<Target=RawTable<K, V>>,\n     F: FnMut(&K) -> bool,\n {\n     let size = table.size();\n@@ -1530,8 +1530,9 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Extend<(K, V)> for HashMap<K\n \n #[cfg(test)]\n mod test_map {\n-    use prelude::*;\n+    use prelude::v1::*;\n \n+    use cmp::Equiv;\n     use super::HashMap;\n     use super::Entry::{Occupied, Vacant};\n     use hash;\n@@ -1541,6 +1542,7 @@ mod test_map {\n \n     struct KindaIntLike(int);\n \n+    #[allow(deprecated)]\n     impl Equiv<int> for KindaIntLike {\n         fn equiv(&self, other: &int) -> bool {\n             let KindaIntLike(this) = *self;\n@@ -1868,7 +1870,7 @@ mod test_map {\n     }\n \n     #[test]\n-    #[allow(experimental)]\n+    #[allow(deprecated)]\n     fn test_pop_equiv() {\n         let mut m = HashMap::new();\n         m.insert(1i, 2i);"}, {"sha": "6132d288da2799ca4698acf467c3ab6db7cb935e", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -866,7 +866,7 @@ impl<'a, T, S, H> Iterator<&'a T> for Union<'a, T, H>\n \n #[cfg(test)]\n mod test_set {\n-    use prelude::*;\n+    use prelude::v1::*;\n \n     use super::HashSet;\n "}, {"sha": "a687ba3da8d7fc648936c4203aa8819413415867", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -210,7 +210,7 @@ impl<K, V, M> Bucket<K, V, M> {\n     }\n }\n \n-impl<K, V, M: Deref<RawTable<K, V>>> Bucket<K, V, M> {\n+impl<K, V, M: Deref<Target=RawTable<K, V>>> Bucket<K, V, M> {\n     pub fn new(table: M, hash: SafeHash) -> Bucket<K, V, M> {\n         Bucket::at_index(table, hash.inspect() as uint)\n     }\n@@ -279,7 +279,7 @@ impl<K, V, M: Deref<RawTable<K, V>>> Bucket<K, V, M> {\n     }\n }\n \n-impl<K, V, M: Deref<RawTable<K, V>>> EmptyBucket<K, V, M> {\n+impl<K, V, M: Deref<Target=RawTable<K, V>>> EmptyBucket<K, V, M> {\n     #[inline]\n     pub fn next(self) -> Bucket<K, V, M> {\n         let mut bucket = self.into_bucket();\n@@ -315,7 +315,7 @@ impl<K, V, M: Deref<RawTable<K, V>>> EmptyBucket<K, V, M> {\n     }\n }\n \n-impl<K, V, M: DerefMut<RawTable<K, V>>> EmptyBucket<K, V, M> {\n+impl<K, V, M: Deref<Target=RawTable<K, V>> + DerefMut> EmptyBucket<K, V, M> {\n     /// Puts given key and value pair, along with the key's hash,\n     /// into this bucket in the hashtable. Note how `self` is 'moved' into\n     /// this function, because this slot will no longer be empty when\n@@ -337,7 +337,7 @@ impl<K, V, M: DerefMut<RawTable<K, V>>> EmptyBucket<K, V, M> {\n     }\n }\n \n-impl<K, V, M: Deref<RawTable<K, V>>> FullBucket<K, V, M> {\n+impl<K, V, M: Deref<Target=RawTable<K, V>>> FullBucket<K, V, M> {\n     #[inline]\n     pub fn next(self) -> Bucket<K, V, M> {\n         let mut bucket = self.into_bucket();\n@@ -384,7 +384,7 @@ impl<K, V, M: Deref<RawTable<K, V>>> FullBucket<K, V, M> {\n     }\n }\n \n-impl<K, V, M: DerefMut<RawTable<K, V>>> FullBucket<K, V, M> {\n+impl<K, V, M: Deref<Target=RawTable<K, V>> + DerefMut> FullBucket<K, V, M> {\n     /// Removes this bucket's key and value from the hashtable.\n     ///\n     /// This works similarly to `put`, building an `EmptyBucket` out of the\n@@ -428,7 +428,7 @@ impl<K, V, M: DerefMut<RawTable<K, V>>> FullBucket<K, V, M> {\n     }\n }\n \n-impl<'t, K, V, M: Deref<RawTable<K, V>> + 't> FullBucket<K, V, M> {\n+impl<'t, K, V, M: Deref<Target=RawTable<K, V>> + 't> FullBucket<K, V, M> {\n     /// Exchange a bucket state for immutable references into the table.\n     /// Because the underlying reference to the table is also consumed,\n     /// no further changes to the structure of the table are possible;\n@@ -442,7 +442,7 @@ impl<'t, K, V, M: Deref<RawTable<K, V>> + 't> FullBucket<K, V, M> {\n     }\n }\n \n-impl<'t, K, V, M: DerefMut<RawTable<K, V>> + 't> FullBucket<K, V, M> {\n+impl<'t, K, V, M: Deref<Target=RawTable<K, V>> + DerefMut + 't> FullBucket<K, V, M> {\n     /// This works similarly to `into_refs`, exchanging a bucket state\n     /// for mutable references into the table.\n     pub fn into_mut_refs(self) -> (&'t mut K, &'t mut V) {\n@@ -463,7 +463,7 @@ impl<K, V, M> BucketState<K, V, M> {\n     }\n }\n \n-impl<K, V, M: Deref<RawTable<K, V>>> GapThenFull<K, V, M> {\n+impl<K, V, M: Deref<Target=RawTable<K, V>>> GapThenFull<K, V, M> {\n     #[inline]\n     pub fn full(&self) -> &FullBucket<K, V, M> {\n         &self.full"}, {"sha": "ecfe2d15ae1c26deb2ab5d5adb65fdf13323e27a", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -15,7 +15,9 @@\n #![experimental]\n #![allow(missing_docs)]\n \n-use prelude::*;\n+use prelude::v1::*;\n+\n+use c_str::ToCStr;\n use mem;\n use os;\n use str;\n@@ -146,7 +148,7 @@ impl DynamicLibrary {\n #[cfg(all(test, not(target_os = \"ios\")))]\n mod test {\n     use super::*;\n-    use prelude::*;\n+    use prelude::v1::*;\n     use libc;\n     use mem;\n \n@@ -202,8 +204,8 @@ mod test {\n pub mod dl {\n     use self::Rtld::*;\n \n-    use prelude::*;\n-    use c_str::CString;\n+    use prelude::v1::*;\n+    use c_str::{CString, ToCStr};\n     use libc;\n     use ptr;\n "}, {"sha": "32e1922ae74fd62a92261c95f5fb0451da6088db", "filename": "src/libstd/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -78,7 +78,7 @@\n //! }\n //! ```\n \n-use prelude::*;\n+use prelude::v1::*;\n \n use str::Utf8Error;\n use string::{FromUtf8Error, FromUtf16Error};"}, {"sha": "d3bcdbf1a53e792c84bcff22662555c2efa32622", "filename": "src/libstd/failure.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffailure.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -10,11 +10,10 @@\n \n #![experimental]\n \n-use prelude::*;\n+use prelude::v1::*;\n \n use any::{Any, AnyRefExt};\n use cell::RefCell;\n-use fmt;\n use io::IoResult;\n use rt::{backtrace, unwind};\n use rt::util::{Stderr, Stdio};\n@@ -29,10 +28,7 @@ thread_local! {\n \n impl Writer for Stdio {\n     fn write(&mut self, bytes: &[u8]) -> IoResult<()> {\n-        fn fmt_write<F: fmt::FormatWriter>(f: &mut F, bytes: &[u8]) {\n-            let _ = f.write(bytes);\n-        }\n-        fmt_write(self, bytes);\n+        let _ = self.write_bytes(bytes);\n         Ok(())\n     }\n }"}, {"sha": "32f5f2d45363fdee716e3350d2780c41fb9a7c21", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -201,7 +201,7 @@\n //!         // for details, and the function `pad` can be used to pad strings.\n //!         let decimals = f.precision().unwrap_or(3);\n //!         let string = f64::to_str_exact(magnitude, decimals);\n-//!         f.pad_integral(true, \"\", string.as_bytes())\n+//!         f.pad_integral(true, \"\", string.as_slice())\n //!     }\n //! }\n //!\n@@ -390,13 +390,9 @@\n \n #![experimental]\n \n-use io::Writer;\n-use io;\n-use result::Result::{Ok, Err};\n use string;\n-use vec::Vec;\n \n-pub use core::fmt::{Formatter, Result, FormatWriter, rt};\n+pub use core::fmt::{Formatter, Result, Writer, rt};\n pub use core::fmt::{Show, Octal, Binary};\n pub use core::fmt::{LowerHex, UpperHex, Pointer};\n pub use core::fmt::{LowerExp, UpperExp};\n@@ -424,16 +420,7 @@ pub use core::fmt::{argument, argumentuint};\n #[experimental = \"this is an implementation detail of format! and should not \\\n                   be called directly\"]\n pub fn format(args: Arguments) -> string::String {\n-    let mut output = Vec::new();\n-    let _ = write!(&mut output as &mut Writer, \"{}\", args);\n-    string::String::from_utf8(output).unwrap()\n-}\n-\n-impl<'a> Writer for Formatter<'a> {\n-    fn write(&mut self, b: &[u8]) -> io::IoResult<()> {\n-        match (*self).write(b) {\n-            Ok(()) => Ok(()),\n-            Err(Error) => Err(io::standard_error(io::OtherIoError))\n-        }\n-    }\n+    let mut output = string::String::new();\n+    let _ = write!(&mut output, \"{}\", args);\n+    output\n }"}, {"sha": "852cab500f6731e714534f0e1efb369f05bf0d8a", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -22,7 +22,6 @@ use result::Result::{Ok, Err};\n use slice::{SliceExt};\n use slice;\n use vec::Vec;\n-use kinds::{Send,Sync};\n \n /// Wraps a Reader and buffers input from it\n ///\n@@ -52,11 +51,6 @@ pub struct BufferedReader<R> {\n     cap: uint,\n }\n \n-\n-unsafe impl<R: Send> Send for BufferedReader<R> {}\n-unsafe impl<R: Send+Sync> Sync for BufferedReader<R> {}\n-\n-\n impl<R: Reader> BufferedReader<R> {\n     /// Creates a new `BufferedReader` with the specified buffer capacity\n     pub fn with_capacity(cap: uint, inner: R) -> BufferedReader<R> {\n@@ -410,7 +404,7 @@ impl<S: Stream> Writer for BufferedStream<S> {\n mod test {\n     extern crate test;\n     use io;\n-    use prelude::*;\n+    use prelude::v1::*;\n     use super::*;\n     use super::super::{IoResult, EndOfFile};\n     use super::super::mem::MemReader;\n@@ -534,7 +528,7 @@ mod test {\n         w.write(&[0, 1]).unwrap();\n         let a: &[_] = &[];\n         assert_eq!(a, w.get_ref()[]);\n-        let w = w.unwrap();\n+        let w = w.into_inner();\n         let a: &[_] = &[0, 1];\n         assert_eq!(a, w[]);\n     }"}, {"sha": "f47f6237b72910e46568e246a5c8a2175b729d07", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -10,11 +10,11 @@\n \n use clone::Clone;\n use cmp;\n-use comm::{Sender, Receiver};\n+use sync::mpsc::{Sender, Receiver};\n use io;\n use option::Option::{None, Some};\n use result::Result::{Ok, Err};\n-use slice::{bytes, CloneSliceExt, SliceExt};\n+use slice::{bytes, SliceExt};\n use super::{Buffer, Reader, Writer, IoResult};\n use vec::Vec;\n \n@@ -23,6 +23,7 @@ use vec::Vec;\n /// # Example\n ///\n /// ```\n+/// use std::sync::mpsc::channel;\n /// use std::io::ChanReader;\n ///\n /// let (tx, rx) = channel();\n@@ -58,11 +59,11 @@ impl Buffer for ChanReader {\n     fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos >= self.buf.len() {\n             self.pos = 0;\n-            match self.rx.recv_opt() {\n+            match self.rx.recv() {\n                 Ok(bytes) => {\n                     self.buf = bytes;\n                 },\n-                Err(()) => {\n+                Err(..) => {\n                     self.closed = true;\n                     self.buf = Vec::new();\n                 }\n@@ -114,6 +115,7 @@ impl Reader for ChanReader {\n ///\n /// ```\n /// # #![allow(unused_must_use)]\n+/// use std::sync::mpsc::channel;\n /// use std::io::ChanWriter;\n ///\n /// let (tx, rx) = channel();\n@@ -141,7 +143,7 @@ impl Clone for ChanWriter {\n \n impl Writer for ChanWriter {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.tx.send_opt(buf.to_vec()).map_err(|_| {\n+        self.tx.send(buf.to_vec()).map_err(|_| {\n             io::IoError {\n                 kind: io::BrokenPipe,\n                 desc: \"Pipe closed\",\n@@ -154,7 +156,9 @@ impl Writer for ChanWriter {\n \n #[cfg(test)]\n mod test {\n-    use prelude::*;\n+    use prelude::v1::*;\n+\n+    use sync::mpsc::channel;\n     use super::*;\n     use io;\n     use thread::Thread;\n@@ -163,11 +167,11 @@ mod test {\n     fn test_rx_reader() {\n         let (tx, rx) = channel();\n         Thread::spawn(move|| {\n-          tx.send(vec![1u8, 2u8]);\n-          tx.send(vec![]);\n-          tx.send(vec![3u8, 4u8]);\n-          tx.send(vec![5u8, 6u8]);\n-          tx.send(vec![7u8, 8u8]);\n+          tx.send(vec![1u8, 2u8]).unwrap();\n+          tx.send(vec![]).unwrap();\n+          tx.send(vec![3u8, 4u8]).unwrap();\n+          tx.send(vec![5u8, 6u8]).unwrap();\n+          tx.send(vec![7u8, 8u8]).unwrap();\n         }).detach();\n \n         let mut reader = ChanReader::new(rx);\n@@ -205,12 +209,12 @@ mod test {\n     fn test_rx_buffer() {\n         let (tx, rx) = channel();\n         Thread::spawn(move|| {\n-          tx.send(b\"he\".to_vec());\n-          tx.send(b\"llo wo\".to_vec());\n-          tx.send(b\"\".to_vec());\n-          tx.send(b\"rld\\nhow \".to_vec());\n-          tx.send(b\"are you?\".to_vec());\n-          tx.send(b\"\".to_vec());\n+          tx.send(b\"he\".to_vec()).unwrap();\n+          tx.send(b\"llo wo\".to_vec()).unwrap();\n+          tx.send(b\"\".to_vec()).unwrap();\n+          tx.send(b\"rld\\nhow \".to_vec()).unwrap();\n+          tx.send(b\"are you?\".to_vec()).unwrap();\n+          tx.send(b\"\".to_vec()).unwrap();\n         }).detach();\n \n         let mut reader = ChanReader::new(rx);\n@@ -230,7 +234,7 @@ mod test {\n         writer.write_be_u32(42).unwrap();\n \n         let wanted = vec![0u8, 0u8, 0u8, 42u8];\n-        let got = match Thread::spawn(move|| { rx.recv() }).join() {\n+        let got = match Thread::spawn(move|| { rx.recv().unwrap() }).join() {\n             Ok(got) => got,\n             Err(_) => panic!(),\n         };"}, {"sha": "94dba1f7cc70a1f539d7e78f783ce5b7afb149e1", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -175,7 +175,7 @@ pub fn u64_from_be_bytes(data: &[u8], start: uint, size: uint) -> u64 {\n \n #[cfg(test)]\n mod test {\n-    use prelude::*;\n+    use prelude::v1::*;\n     use io;\n     use io::{MemReader, BytesReader};\n \n@@ -507,7 +507,7 @@ mod test {\n mod bench {\n     extern crate test;\n \n-    use prelude::*;\n+    use prelude::v1::*;\n     use self::test::Bencher;\n \n     // why is this a macro? wouldn't an inlined function work just as well?"}, {"sha": "7fa5b3cfac7e254e2c4cd5075a3653dd2ab3efed", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -819,7 +819,7 @@ fn access_string(access: FileAccess) -> &'static str {\n #[allow(unused_variables)]\n #[allow(unused_mut)]\n mod test {\n-    use prelude::*;\n+    use prelude::v1::*;\n     use io::{SeekSet, SeekCur, SeekEnd, Read, Open, ReadWrite, FileType};\n     use io;\n     use str;"}, {"sha": "ad921e43c0cc58b4be584052b2ad1a5303a14803", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -399,9 +399,10 @@ impl<'a> Buffer for BufReader<'a> {\n #[cfg(test)]\n mod test {\n     extern crate \"test\" as test_crate;\n+    use prelude::v1::*;\n+\n     use super::*;\n-    use io::{SeekSet, SeekCur, SeekEnd, Reader, Writer, Seek};\n-    use prelude::{Ok, Err, range,  Vec, Buffer,  AsSlice, SliceExt, IteratorExt, CloneSliceExt};\n+    use io::{SeekSet, SeekCur, SeekEnd};\n     use io;\n     use self::test_crate::Bencher;\n "}, {"sha": "0a7815aeb53671ccbaf7878012f51a1a2bf408ce", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 31, "deletions": 8, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -232,8 +232,9 @@ use error::{FromError, Error};\n use fmt;\n use int;\n use iter::{Iterator, IteratorExt};\n+use kinds::Sized;\n use mem::transmute;\n-use ops::{BitOr, BitXor, BitAnd, Sub, Not, FnOnce};\n+use ops::FnOnce;\n use option::Option;\n use option::Option::{Some, None};\n use os;\n@@ -1028,16 +1029,30 @@ pub trait Writer {\n     ///\n     /// This function will return any I/O error reported while formatting.\n     fn write_fmt(&mut self, fmt: fmt::Arguments) -> IoResult<()> {\n-        // Create a shim which translates a Writer to a FormatWriter and saves\n+        // Create a shim which translates a Writer to a fmt::Writer and saves\n         // off I/O errors. instead of discarding them\n-        struct Adaptor<'a, T:'a> {\n+        struct Adaptor<'a, Sized? T:'a> {\n             inner: &'a mut T,\n             error: IoResult<()>,\n         }\n \n-        impl<'a, T: Writer> fmt::FormatWriter for Adaptor<'a, T> {\n-            fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n-                match self.inner.write(bytes) {\n+        #[cfg(not(stage0))]\n+        impl<'a, Sized? T: Writer> fmt::Writer for Adaptor<'a, T> {\n+            fn write_str(&mut self, s: &str) -> fmt::Result {\n+                match self.inner.write(s.as_bytes()) {\n+                    Ok(()) => Ok(()),\n+                    Err(e) => {\n+                        self.error = Err(e);\n+                        Err(fmt::Error)\n+                    }\n+                }\n+            }\n+        }\n+\n+        #[cfg(stage0)]\n+        impl<'a, T: Writer> fmt::Writer for Adaptor<'a, T> {\n+            fn write_str(&mut self, s: &str) -> fmt::Result {\n+                match self.inner.write(s.as_bytes()) {\n                     Ok(()) => Ok(()),\n                     Err(e) => {\n                         self.error = Err(e);\n@@ -1629,16 +1644,24 @@ pub trait Acceptor<T> {\n /// `Some`. The `Some` contains the `IoResult` representing whether the\n /// connection attempt was successful.  A successful connection will be wrapped\n /// in `Ok`. A failed connection is represented as an `Err`.\n-pub struct IncomingConnections<'a, A:'a> {\n+pub struct IncomingConnections<'a, Sized? A:'a> {\n     inc: &'a mut A,\n }\n \n+#[cfg(stage0)]\n impl<'a, T, A: Acceptor<T>> Iterator<IoResult<T>> for IncomingConnections<'a, A> {\n     fn next(&mut self) -> Option<IoResult<T>> {\n         Some(self.inc.accept())\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<'a, T, Sized? A: Acceptor<T>> Iterator<IoResult<T>> for IncomingConnections<'a, A> {\n+    fn next(&mut self) -> Option<IoResult<T>> {\n+        Some(self.inc.accept())\n+    }\n+}\n+\n /// Creates a standard error for a commonly used flavor of error. The `detail`\n /// field of the returned error will always be `None`.\n ///\n@@ -1919,7 +1942,7 @@ impl fmt::Show for FilePermission {\n mod tests {\n     use self::BadReaderBehavior::*;\n     use super::{IoResult, Reader, MemReader, NoProgress, InvalidInput, Writer};\n-    use prelude::{Ok, Vec, Buffer, CloneSliceExt};\n+    use prelude::v1::{Ok, Vec, Buffer, SliceExt};\n     use uint;\n \n     #[deriving(Clone, PartialEq, Show)]"}, {"sha": "d86cb841f96cebc3e04f3e09ec205088a41e1589", "filename": "src/libstd/io/net/addrinfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -112,7 +112,7 @@ fn lookup(hostname: Option<&str>, servname: Option<&str>, hint: Option<Hint>)\n // permission without help of apk\n #[cfg(all(test, not(target_os = \"android\")))]\n mod test {\n-    use prelude::*;\n+    use prelude::v1::*;\n     use super::*;\n     use io::net::ip::*;\n "}, {"sha": "2a18b839778c6b21716a2fcb8d2225d7a27bb875", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -25,7 +25,7 @@ use ops::FnOnce;\n use option::Option;\n use option::Option::{None, Some};\n use result::Result::{Ok, Err};\n-use slice::{CloneSliceExt, SliceExt};\n+use slice::SliceExt;\n use str::{FromStr, StrExt};\n use vec::Vec;\n \n@@ -544,7 +544,7 @@ impl<'a> ToSocketAddr for &'a str {\n \n #[cfg(test)]\n mod test {\n-    use prelude::*;\n+    use prelude::v1::*;\n     use super::*;\n     use str::FromStr;\n "}, {"sha": "daefdd28b306a5c7264154e567ea18ee28e6fccd", "filename": "src/libstd/io/net/pipe.rs", "status": "modified", "additions": 87, "deletions": 77, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -20,14 +20,14 @@\n \n #![allow(missing_docs)]\n \n-use prelude::*;\n+use prelude::v1::*;\n \n+use c_str::ToCStr;\n use io::{Listener, Acceptor, IoResult, TimedOut, standard_error};\n-use time::Duration;\n-\n-use sys::pipe::UnixStream as UnixStreamImp;\n-use sys::pipe::UnixListener as UnixListenerImp;\n use sys::pipe::UnixAcceptor as UnixAcceptorImp;\n+use sys::pipe::UnixListener as UnixListenerImp;\n+use sys::pipe::UnixStream as UnixStreamImp;\n+use time::Duration;\n \n use sys_common;\n \n@@ -264,13 +264,17 @@ impl sys_common::AsInner<UnixAcceptorImp> for UnixAcceptor {\n }\n \n #[cfg(test)]\n-#[allow(experimental)]\n mod tests {\n-    use super::*;\n-    use io::*;\n-    use io::test::*;\n-    use prelude::{Ok, Err, spawn, range, drop,  Some, None, channel, Send, FnOnce, Clone};\n+    use prelude::v1::*;\n+\n     use io::fs::PathExtensions;\n+    use io::{EndOfFile, TimedOut, ShortWrite, IoError, ConnectionReset};\n+    use io::{NotConnected, BrokenPipe, FileNotFound, InvalidInput, OtherIoError};\n+    use io::{PermissionDenied, Acceptor, Listener};\n+    use io::test::*;\n+    use super::*;\n+    use sync::mpsc::channel;\n+    use thread::Thread;\n     use time::Duration;\n \n     pub fn smalltest<F,G>(server: F, client: G)\n@@ -282,7 +286,7 @@ mod tests {\n \n         let mut acceptor = UnixListener::bind(&path1).listen();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             match UnixStream::connect(&path2) {\n                 Ok(c) => client(c),\n                 Err(e) => panic!(\"failed connect: {}\", e),\n@@ -377,7 +381,7 @@ mod tests {\n             Err(e) => panic!(\"failed listen: {}\", e),\n         };\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             for _ in range(0u, times) {\n                 let mut stream = UnixStream::connect(&path2);\n                 match stream.write(&[100]) {\n@@ -411,7 +415,7 @@ mod tests {\n         let addr = next_test_unix();\n         let mut acceptor = UnixListener::bind(&addr).listen();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut s = UnixStream::connect(&addr);\n             let mut buf = [0, 0];\n             debug!(\"client reading\");\n@@ -427,20 +431,20 @@ mod tests {\n \n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut s2 = s2;\n-            rx1.recv();\n+            rx1.recv().unwrap();\n             debug!(\"writer writing\");\n             s2.write(&[1]).unwrap();\n             debug!(\"writer done\");\n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n-        tx1.send(());\n+        tx1.send(()).unwrap();\n         let mut buf = [0, 0];\n         debug!(\"reader reading\");\n         assert_eq!(s1.read(&mut buf), Ok(1));\n         debug!(\"reader done\");\n-        rx2.recv();\n+        rx2.recv().unwrap();\n     }\n \n     #[test]\n@@ -450,38 +454,38 @@ mod tests {\n         let (tx1, rx) = channel();\n         let tx2 = tx1.clone();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut s = UnixStream::connect(&addr);\n             s.write(&[1]).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n             s.write(&[2]).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n         });\n \n         let mut s1 = acceptor.accept().unwrap();\n         let s2 = s1.clone();\n \n         let (done, rx) = channel();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut s2 = s2;\n             let mut buf = [0, 0];\n             s2.read(&mut buf).unwrap();\n-            tx2.send(());\n-            done.send(());\n+            tx2.send(()).unwrap();\n+            done.send(()).unwrap();\n         });\n         let mut buf = [0, 0];\n         s1.read(&mut buf).unwrap();\n-        tx1.send(());\n+        tx1.send(()).unwrap();\n \n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n     fn unix_clone_two_write() {\n         let addr = next_test_unix();\n         let mut acceptor = UnixListener::bind(&addr).listen();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut s = UnixStream::connect(&addr);\n             let buf = &mut [0, 1];\n             s.read(buf).unwrap();\n@@ -492,14 +496,14 @@ mod tests {\n         let s2 = s1.clone();\n \n         let (tx, rx) = channel();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut s2 = s2;\n             s2.write(&[1]).unwrap();\n-            tx.send(());\n+            tx.send(()).unwrap();\n         });\n         s1.write(&[2]).unwrap();\n \n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     #[cfg(not(windows))]\n@@ -539,10 +543,10 @@ mod tests {\n         // continue to receive any pending connections.\n         let (tx, rx) = channel();\n         let addr2 = addr.clone();\n-        spawn(move|| {\n-            tx.send(UnixStream::connect(&addr2).unwrap());\n+        let _t = Thread::spawn(move|| {\n+            tx.send(UnixStream::connect(&addr2).unwrap()).unwrap();\n         });\n-        let l = rx.recv();\n+        let l = rx.recv().unwrap();\n         for i in range(0u, 1001) {\n             match a.accept() {\n                 Ok(..) => break,\n@@ -557,7 +561,7 @@ mod tests {\n         // Unset the timeout and make sure that this always blocks.\n         a.set_timeout(None);\n         let addr2 = addr.clone();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             drop(UnixStream::connect(&addr2).unwrap());\n         });\n         a.accept().unwrap();\n@@ -595,11 +599,11 @@ mod tests {\n         let addr = next_test_unix();\n         let a = UnixListener::bind(&addr).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n-        spawn(move|| {\n+        Thread::spawn(move|| {\n             let mut a = a;\n             let _s = a.accept().unwrap();\n-            let _ = rx.recv_opt();\n-        });\n+            let _ = rx.recv();\n+        }).detach();\n \n         let mut b = [0];\n         let mut s = UnixStream::connect(&addr).unwrap();\n@@ -632,38 +636,38 @@ mod tests {\n         let addr = next_test_unix();\n         let a = UnixListener::bind(&addr).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n-        spawn(move|| {\n+        Thread::spawn(move|| {\n             let mut a = a;\n             let _s = a.accept().unwrap();\n-            let _ = rx.recv_opt();\n-        });\n+            let _ = rx.recv();\n+        }).detach();\n \n         let mut s = UnixStream::connect(&addr).unwrap();\n         let s2 = s.clone();\n         let (tx, rx) = channel();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut s2 = s2;\n             assert!(s2.read(&mut [0]).is_err());\n-            tx.send(());\n+            tx.send(()).unwrap();\n         });\n         // this should wake up the child task\n         s.close_read().unwrap();\n \n         // this test will never finish if the child doesn't wake up\n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n     fn readwrite_timeouts() {\n         let addr = next_test_unix();\n         let mut a = UnixListener::bind(&addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        spawn(move|| {\n+        Thread::spawn(move|| {\n             let mut s = UnixStream::connect(&addr).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n             assert!(s.write(&[0]).is_ok());\n-            let _ = rx.recv_opt();\n-        });\n+            let _ = rx.recv();\n+        }).detach();\n \n         let mut s = a.accept().unwrap();\n         s.set_timeout(Some(20));\n@@ -686,7 +690,7 @@ mod tests {\n             assert_eq!(s.write(&[0]).err().unwrap().kind, TimedOut);\n         }\n \n-        tx.send(());\n+        tx.send(()).unwrap();\n         s.set_timeout(None);\n         assert_eq!(s.read(&mut [0, 0]), Ok(1));\n     }\n@@ -696,25 +700,25 @@ mod tests {\n         let addr = next_test_unix();\n         let mut a = UnixListener::bind(&addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        spawn(move|| {\n+        Thread::spawn(move|| {\n             let mut s = UnixStream::connect(&addr).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n             let mut amt = 0;\n             while amt < 100 * 128 * 1024 {\n                 match s.read(&mut [0;128 * 1024]) {\n                     Ok(n) => { amt += n; }\n                     Err(e) => panic!(\"{}\", e),\n                 }\n             }\n-            let _ = rx.recv_opt();\n-        });\n+            let _ = rx.recv();\n+        }).detach();\n \n         let mut s = a.accept().unwrap();\n         s.set_read_timeout(Some(20));\n         assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n         assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n \n-        tx.send(());\n+        tx.send(()).unwrap();\n         for _ in range(0u, 100) {\n             assert!(s.write(&[0;128 * 1024]).is_ok());\n         }\n@@ -725,12 +729,12 @@ mod tests {\n         let addr = next_test_unix();\n         let mut a = UnixListener::bind(&addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        spawn(move|| {\n+        Thread::spawn(move|| {\n             let mut s = UnixStream::connect(&addr).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n             assert!(s.write(&[0]).is_ok());\n-            let _ = rx.recv_opt();\n-        });\n+            let _ = rx.recv();\n+        }).detach();\n \n         let mut s = a.accept().unwrap();\n         s.set_write_timeout(Some(20));\n@@ -743,7 +747,7 @@ mod tests {\n            if i == 1000 { panic!(\"should have filled up?!\"); }\n         }\n \n-        tx.send(());\n+        tx.send(()).unwrap();\n         assert!(s.read(&mut [0]).is_ok());\n     }\n \n@@ -752,27 +756,27 @@ mod tests {\n         let addr = next_test_unix();\n         let mut a = UnixListener::bind(&addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        spawn(move|| {\n+        Thread::spawn(move|| {\n             let mut s = UnixStream::connect(&addr).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n             assert!(s.write(&[0]).is_ok());\n-            let _ = rx.recv_opt();\n-        });\n+            let _ = rx.recv();\n+        }).detach();\n \n         let mut s = a.accept().unwrap();\n         let s2 = s.clone();\n         let (tx2, rx2) = channel();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut s2 = s2;\n             assert!(s2.read(&mut [0]).is_ok());\n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n \n         s.set_read_timeout(Some(20));\n         assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n-        tx.send(());\n+        tx.send(()).unwrap();\n \n-        rx2.recv();\n+        rx2.recv().unwrap();\n     }\n \n     #[cfg(not(windows))]\n@@ -784,10 +788,10 @@ mod tests {\n         let mut a2 = a.clone();\n \n         let addr2 = addr.clone();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let _ = UnixStream::connect(&addr2);\n         });\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let _ = UnixStream::connect(&addr);\n         });\n \n@@ -807,19 +811,25 @@ mod tests {\n         let (tx, rx) = channel();\n         let tx2 = tx.clone();\n \n-        spawn(move|| { let mut a = a; tx.send(a.accept()) });\n-        spawn(move|| { let mut a = a2; tx2.send(a.accept()) });\n+        let _t = Thread::spawn(move|| {\n+            let mut a = a;\n+            tx.send(a.accept()).unwrap()\n+        });\n+        let _t = Thread::spawn(move|| {\n+            let mut a = a2;\n+            tx2.send(a.accept()).unwrap()\n+        });\n \n         let addr2 = addr.clone();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let _ = UnixStream::connect(&addr2);\n         });\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let _ = UnixStream::connect(&addr);\n         });\n \n-        assert!(rx.recv().is_ok());\n-        assert!(rx.recv().is_ok());\n+        assert!(rx.recv().unwrap().is_ok());\n+        assert!(rx.recv().unwrap().is_ok());\n     }\n \n     #[test]\n@@ -840,12 +850,12 @@ mod tests {\n         let mut a2 = a.clone();\n \n         let (tx, rx) = channel();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut a = a;\n-            tx.send(a.accept());\n+            tx.send(a.accept()).unwrap();\n         });\n         a2.close_accept().unwrap();\n \n-        assert_eq!(rx.recv().err().unwrap().kind, EndOfFile);\n+        assert_eq!(rx.recv().unwrap().err().unwrap().kind, EndOfFile);\n     }\n }"}, {"sha": "3e59aaa05efd285d8b7f5f3af68273e0d6ac5f37", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 133, "deletions": 124, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -141,7 +141,7 @@ impl TcpStream {\n     /// let mut stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n     /// let stream2 = stream.clone();\n     ///\n-    /// Thread::spawn(move|| {\n+    /// let _t = Thread::spawn(move|| {\n     ///     // close this stream after one second\n     ///     timer::sleep(Duration::seconds(1));\n     ///     let mut stream = stream2;\n@@ -282,10 +282,10 @@ impl sys_common::AsInner<TcpStreamImp> for TcpStream {\n /// use std::io::{Acceptor, Listener};\n /// use std::thread::Thread;\n ///\n-/// let listener = TcpListener::bind(\"127.0.0.1:80\");\n+/// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n ///\n /// // bind the listener to the specified address\n-/// let mut acceptor = listener.listen();\n+/// let mut acceptor = listener.listen().unwrap();\n ///\n /// fn handle_client(mut stream: TcpStream) {\n ///     // ...\n@@ -423,7 +423,7 @@ impl TcpAcceptor {\n     /// let mut a = TcpListener::bind(\"127.0.0.1:8482\").listen().unwrap();\n     /// let a2 = a.clone();\n     ///\n-    /// Thread::spawn(move|| {\n+    /// let _t = Thread::spawn(move|| {\n     ///     let mut a2 = a2;\n     ///     for socket in a2.incoming() {\n     ///         match socket {\n@@ -482,14 +482,17 @@ impl sys_common::AsInner<TcpAcceptorImp> for TcpAcceptor {\n #[cfg(test)]\n #[allow(experimental)]\n mod test {\n+    use prelude::v1::*;\n+\n+    use sync::mpsc::channel;\n+    use thread::Thread;\n     use io::net::tcp::*;\n     use io::net::ip::*;\n-    use io::{EndOfFile, TimedOut, IoError, ShortWrite, OtherIoError, ConnectionAborted};\n-    use io::{ConnectionRefused, ConnectionReset, BrokenPipe, NotConnected};\n-    use io::{PermissionDenied, Listener, Acceptor};\n     use io::test::*;\n-    use prelude::{Ok, Err, spawn, range, drop, Some, None, channel, Clone};\n-    use prelude::{Reader, Writer, IteratorExt};\n+    use io::{EndOfFile, TimedOut, ShortWrite, IoError};\n+    use io::{ConnectionRefused, BrokenPipe, ConnectionAborted};\n+    use io::{ConnectionReset, NotConnected, PermissionDenied, OtherIoError};\n+    use io::{Acceptor, Listener};\n \n     // FIXME #11530 this fails on android because tests are run as root\n     #[cfg_attr(any(windows, target_os = \"android\"), ignore)]\n@@ -515,7 +518,7 @@ mod test {\n         let listener = TcpListener::bind(socket_addr);\n         let mut acceptor = listener.listen();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut stream = TcpStream::connect((\"localhost\", socket_addr.port));\n             stream.write(&[144]).unwrap();\n         });\n@@ -531,7 +534,7 @@ mod test {\n         let addr = next_test_ip4();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut stream = TcpStream::connect((\"localhost\", addr.port));\n             stream.write(&[64]).unwrap();\n         });\n@@ -547,7 +550,7 @@ mod test {\n         let addr = next_test_ip4();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut stream = TcpStream::connect((\"127.0.0.1\", addr.port));\n             stream.write(&[44]).unwrap();\n         });\n@@ -563,7 +566,7 @@ mod test {\n         let addr = next_test_ip6();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut stream = TcpStream::connect((\"::1\", addr.port));\n             stream.write(&[66]).unwrap();\n         });\n@@ -579,7 +582,7 @@ mod test {\n         let addr = next_test_ip4();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut stream = TcpStream::connect(addr);\n             stream.write(&[99]).unwrap();\n         });\n@@ -595,7 +598,7 @@ mod test {\n         let addr = next_test_ip6();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut stream = TcpStream::connect(addr);\n             stream.write(&[99]).unwrap();\n         });\n@@ -611,7 +614,7 @@ mod test {\n         let addr = next_test_ip4();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let _stream = TcpStream::connect(addr);\n             // Close\n         });\n@@ -627,7 +630,7 @@ mod test {\n         let addr = next_test_ip6();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let _stream = TcpStream::connect(addr);\n             // Close\n         });\n@@ -643,7 +646,7 @@ mod test {\n         let addr = next_test_ip4();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let _stream = TcpStream::connect(addr);\n             // Close\n         });\n@@ -667,7 +670,7 @@ mod test {\n         let addr = next_test_ip6();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let _stream = TcpStream::connect(addr);\n             // Close\n         });\n@@ -692,13 +695,13 @@ mod test {\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n         let (tx, rx) = channel();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             drop(TcpStream::connect(addr));\n-            tx.send(());\n+            tx.send(()).unwrap();\n         });\n \n         let mut stream = acceptor.accept();\n-        rx.recv();\n+        rx.recv().unwrap();\n         let buf = [0];\n         match stream.write(&buf) {\n             Ok(..) => {}\n@@ -717,13 +720,13 @@ mod test {\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n         let (tx, rx) = channel();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             drop(TcpStream::connect(addr));\n-            tx.send(());\n+            tx.send(()).unwrap();\n         });\n \n         let mut stream = acceptor.accept();\n-        rx.recv();\n+        rx.recv().unwrap();\n         let buf = [0];\n         match stream.write(&buf) {\n             Ok(..) => {}\n@@ -742,7 +745,7 @@ mod test {\n         let max = 10u;\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             for _ in range(0, max) {\n                 let mut stream = TcpStream::connect(addr);\n                 stream.write(&[99]).unwrap();\n@@ -762,7 +765,7 @@ mod test {\n         let max = 10u;\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             for _ in range(0, max) {\n                 let mut stream = TcpStream::connect(addr);\n                 stream.write(&[99]).unwrap();\n@@ -782,11 +785,11 @@ mod test {\n         static MAX: int = 10;\n         let acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut acceptor = acceptor;\n             for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n                 // Start another task to handle the connection\n-                spawn(move|| {\n+                let _t = Thread::spawn(move|| {\n                     let mut stream = stream;\n                     let mut buf = [0];\n                     stream.read(&mut buf).unwrap();\n@@ -801,7 +804,7 @@ mod test {\n         fn connect(i: int, addr: SocketAddr) {\n             if i == MAX { return }\n \n-            spawn(move|| {\n+            let _t = Thread::spawn(move|| {\n                 debug!(\"connecting\");\n                 let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n@@ -818,11 +821,11 @@ mod test {\n         static MAX: int = 10;\n         let acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut acceptor = acceptor;\n             for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n                 // Start another task to handle the connection\n-                spawn(move|| {\n+                let _t = Thread::spawn(move|| {\n                     let mut stream = stream;\n                     let mut buf = [0];\n                     stream.read(&mut buf).unwrap();\n@@ -837,7 +840,7 @@ mod test {\n         fn connect(i: int, addr: SocketAddr) {\n             if i == MAX { return }\n \n-            spawn(move|| {\n+            let _t = Thread::spawn(move|| {\n                 debug!(\"connecting\");\n                 let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n@@ -854,11 +857,11 @@ mod test {\n         let addr = next_test_ip4();\n         let acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut acceptor = acceptor;\n             for stream in acceptor.incoming().take(MAX as uint) {\n                 // Start another task to handle the connection\n-                spawn(move|| {\n+                let _t = Thread::spawn(move|| {\n                     let mut stream = stream;\n                     let mut buf = [0];\n                     stream.read(&mut buf).unwrap();\n@@ -873,7 +876,7 @@ mod test {\n         fn connect(i: int, addr: SocketAddr) {\n             if i == MAX { return }\n \n-            spawn(move|| {\n+            let _t = Thread::spawn(move|| {\n                 debug!(\"connecting\");\n                 let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n@@ -890,11 +893,11 @@ mod test {\n         let addr = next_test_ip6();\n         let acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut acceptor = acceptor;\n             for stream in acceptor.incoming().take(MAX as uint) {\n                 // Start another task to handle the connection\n-                spawn(move|| {\n+                let _t = Thread::spawn(move|| {\n                     let mut stream = stream;\n                     let mut buf = [0];\n                     stream.read(&mut buf).unwrap();\n@@ -909,7 +912,7 @@ mod test {\n         fn connect(i: int, addr: SocketAddr) {\n             if i == MAX { return }\n \n-            spawn(move|| {\n+            let _t = Thread::spawn(move|| {\n                 debug!(\"connecting\");\n                 let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n@@ -932,7 +935,7 @@ mod test {\n \n     pub fn peer_name(addr: SocketAddr) {\n         let acceptor = TcpListener::bind(addr).listen();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut acceptor = acceptor;\n             acceptor.accept().unwrap();\n         });\n@@ -967,22 +970,22 @@ mod test {\n     fn partial_read() {\n         let addr = next_test_ip4();\n         let (tx, rx) = channel();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut srv = TcpListener::bind(addr).listen().unwrap();\n-            tx.send(());\n+            tx.send(()).unwrap();\n             let mut cl = srv.accept().unwrap();\n             cl.write(&[10]).unwrap();\n             let mut b = [0];\n             cl.read(&mut b).unwrap();\n-            tx.send(());\n+            tx.send(()).unwrap();\n         });\n \n-        rx.recv();\n+        rx.recv().unwrap();\n         let mut c = TcpStream::connect(addr).unwrap();\n         let mut b = [0; 10];\n         assert_eq!(c.read(&mut b), Ok(1));\n         c.write(&[1]).unwrap();\n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n@@ -1004,20 +1007,20 @@ mod test {\n         let addr = next_test_ip4();\n         let (tx, rx) = channel();\n \n-        spawn(move|| {\n-            rx.recv();\n+        let _t = Thread::spawn(move|| {\n+            rx.recv().unwrap();\n             let _stream = TcpStream::connect(addr).unwrap();\n             // Close\n-            rx.recv();\n+            rx.recv().unwrap();\n         });\n \n         {\n             let mut acceptor = TcpListener::bind(addr).listen();\n-            tx.send(());\n+            tx.send(()).unwrap();\n             {\n                 let _stream = acceptor.accept().unwrap();\n                 // Close client\n-                tx.send(());\n+                tx.send(()).unwrap();\n             }\n             // Close listener\n         }\n@@ -1029,7 +1032,7 @@ mod test {\n         let addr = next_test_ip4();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut s = TcpStream::connect(addr);\n             let mut buf = [0, 0];\n             assert_eq!(s.read(&mut buf), Ok(1));\n@@ -1042,16 +1045,16 @@ mod test {\n \n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut s2 = s2;\n-            rx1.recv();\n+            rx1.recv().unwrap();\n             s2.write(&[1]).unwrap();\n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n-        tx1.send(());\n+        tx1.send(()).unwrap();\n         let mut buf = [0, 0];\n         assert_eq!(s1.read(&mut buf), Ok(1));\n-        rx2.recv();\n+        rx2.recv().unwrap();\n     }\n \n     #[test]\n@@ -1061,38 +1064,38 @@ mod test {\n         let (tx1, rx) = channel();\n         let tx2 = tx1.clone();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut s = TcpStream::connect(addr);\n             s.write(&[1]).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n             s.write(&[2]).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n         });\n \n         let mut s1 = acceptor.accept().unwrap();\n         let s2 = s1.clone();\n \n         let (done, rx) = channel();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut s2 = s2;\n             let mut buf = [0, 0];\n             s2.read(&mut buf).unwrap();\n-            tx2.send(());\n-            done.send(());\n+            tx2.send(()).unwrap();\n+            done.send(()).unwrap();\n         });\n         let mut buf = [0, 0];\n         s1.read(&mut buf).unwrap();\n-        tx1.send(());\n+        tx1.send(()).unwrap();\n \n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n     fn tcp_clone_two_write() {\n         let addr = next_test_ip4();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut s = TcpStream::connect(addr);\n             let mut buf = [0, 1];\n             s.read(&mut buf).unwrap();\n@@ -1103,21 +1106,21 @@ mod test {\n         let s2 = s1.clone();\n \n         let (done, rx) = channel();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut s2 = s2;\n             s2.write(&[1]).unwrap();\n-            done.send(());\n+            done.send(()).unwrap();\n         });\n         s1.write(&[2]).unwrap();\n \n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n     fn shutdown_smoke() {\n         let addr = next_test_ip4();\n         let a = TcpListener::bind(addr).unwrap().listen();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut a = a;\n             let mut c = a.accept().unwrap();\n             assert_eq!(c.read_to_end(), Ok(vec!()));\n@@ -1151,10 +1154,10 @@ mod test {\n         //        flakiness.\n         if !cfg!(target_os = \"freebsd\") {\n             let (tx, rx) = channel();\n-            spawn(move|| {\n-                tx.send(TcpStream::connect(addr).unwrap());\n+            let _t = Thread::spawn(move|| {\n+                tx.send(TcpStream::connect(addr).unwrap()).unwrap();\n             });\n-            let _l = rx.recv();\n+            let _l = rx.recv().unwrap();\n             for i in range(0i, 1001) {\n                 match a.accept() {\n                     Ok(..) => break,\n@@ -1168,7 +1171,7 @@ mod test {\n \n         // Unset the timeout and make sure that this always blocks.\n         a.set_timeout(None);\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             drop(TcpStream::connect(addr).unwrap());\n         });\n         a.accept().unwrap();\n@@ -1179,11 +1182,11 @@ mod test {\n         let addr = next_test_ip4();\n         let a = TcpListener::bind(addr).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n-        spawn(move|| {\n+        Thread::spawn(move|| {\n             let mut a = a;\n             let _s = a.accept().unwrap();\n-            let _ = rx.recv_opt();\n-        });\n+            let _ = rx.recv().unwrap();\n+        }).detach();\n \n         let mut b = [0];\n         let mut s = TcpStream::connect(addr).unwrap();\n@@ -1216,38 +1219,38 @@ mod test {\n         let addr = next_test_ip4();\n         let a = TcpListener::bind(addr).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n-        spawn(move|| {\n+        Thread::spawn(move|| {\n             let mut a = a;\n             let _s = a.accept().unwrap();\n-            let _ = rx.recv_opt();\n-        });\n+            let _ = rx.recv().unwrap();\n+        }).detach();\n \n         let mut s = TcpStream::connect(addr).unwrap();\n         let s2 = s.clone();\n         let (tx, rx) = channel();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut s2 = s2;\n             assert!(s2.read(&mut [0]).is_err());\n-            tx.send(());\n+            tx.send(()).unwrap();\n         });\n         // this should wake up the child task\n         s.close_read().unwrap();\n \n         // this test will never finish if the child doesn't wake up\n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n     fn readwrite_timeouts() {\n         let addr = next_test_ip6();\n         let mut a = TcpListener::bind(addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        spawn(move|| {\n+        Thread::spawn(move|| {\n             let mut s = TcpStream::connect(addr).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n             assert!(s.write(&[0]).is_ok());\n-            let _ = rx.recv_opt();\n-        });\n+            let _ = rx.recv();\n+        }).detach();\n \n         let mut s = a.accept().unwrap();\n         s.set_timeout(Some(20));\n@@ -1265,7 +1268,7 @@ mod test {\n         }\n         assert_eq!(s.write(&[0]).err().unwrap().kind, TimedOut);\n \n-        tx.send(());\n+        tx.send(()).unwrap();\n         s.set_timeout(None);\n         assert_eq!(s.read(&mut [0, 0]), Ok(1));\n     }\n@@ -1275,25 +1278,25 @@ mod test {\n         let addr = next_test_ip6();\n         let mut a = TcpListener::bind(addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        spawn(move|| {\n+        Thread::spawn(move|| {\n             let mut s = TcpStream::connect(addr).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n             let mut amt = 0;\n             while amt < 100 * 128 * 1024 {\n                 match s.read(&mut [0;128 * 1024]) {\n                     Ok(n) => { amt += n; }\n                     Err(e) => panic!(\"{}\", e),\n                 }\n             }\n-            let _ = rx.recv_opt();\n-        });\n+            let _ = rx.recv();\n+        }).detach();\n \n         let mut s = a.accept().unwrap();\n         s.set_read_timeout(Some(20));\n         assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n         assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n \n-        tx.send(());\n+        tx.send(()).unwrap();\n         for _ in range(0i, 100) {\n             assert!(s.write(&[0;128 * 1024]).is_ok());\n         }\n@@ -1304,12 +1307,12 @@ mod test {\n         let addr = next_test_ip6();\n         let mut a = TcpListener::bind(addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        spawn(move|| {\n+        Thread::spawn(move|| {\n             let mut s = TcpStream::connect(addr).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n             assert!(s.write(&[0]).is_ok());\n-            let _ = rx.recv_opt();\n-        });\n+            let _ = rx.recv();\n+        }).detach();\n \n         let mut s = a.accept().unwrap();\n         s.set_write_timeout(Some(20));\n@@ -1323,7 +1326,7 @@ mod test {\n         }\n         assert_eq!(s.write(&[0]).err().unwrap().kind, TimedOut);\n \n-        tx.send(());\n+        tx.send(()).unwrap();\n         assert!(s.read(&mut [0]).is_ok());\n     }\n \n@@ -1332,27 +1335,27 @@ mod test {\n         let addr = next_test_ip6();\n         let mut a = TcpListener::bind(addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        spawn(move|| {\n+        Thread::spawn(move|| {\n             let mut s = TcpStream::connect(addr).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n             assert_eq!(s.write(&[0]), Ok(()));\n-            let _ = rx.recv_opt();\n-        });\n+            let _ = rx.recv();\n+        }).detach();\n \n         let mut s = a.accept().unwrap();\n         let s2 = s.clone();\n         let (tx2, rx2) = channel();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut s2 = s2;\n             assert_eq!(s2.read(&mut [0]), Ok(1));\n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n \n         s.set_read_timeout(Some(20));\n         assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n-        tx.send(());\n+        tx.send(()).unwrap();\n \n-        rx2.recv();\n+        rx2.recv().unwrap();\n     }\n \n     #[test]\n@@ -1365,21 +1368,21 @@ mod test {\n         let (tx, rx) = channel();\n         let (txdone, rxdone) = channel();\n         let txdone2 = txdone.clone();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut tcp = TcpStream::connect(addr).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n             tcp.write_u8(0).unwrap();\n-            txdone2.send(());\n+            txdone2.send(()).unwrap();\n         });\n \n         // Spawn off a reading clone\n         let tcp = accept.accept().unwrap();\n         let tcp2 = tcp.clone();\n         let txdone3 = txdone.clone();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut tcp2 = tcp2;\n             tcp2.read_u8().unwrap();\n-            txdone3.send(());\n+            txdone3.send(()).unwrap();\n         });\n \n         // Try to ensure that the reading clone is indeed reading\n@@ -1390,9 +1393,9 @@ mod test {\n         // clone the handle again while it's reading, then let it finish the\n         // read.\n         let _ = tcp.clone();\n-        tx.send(());\n-        rxdone.recv();\n-        rxdone.recv();\n+        tx.send(()).unwrap();\n+        rxdone.recv().unwrap();\n+        rxdone.recv().unwrap();\n     }\n \n     #[test]\n@@ -1402,10 +1405,10 @@ mod test {\n         let mut a = l.listen().unwrap();\n         let mut a2 = a.clone();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let _ = TcpStream::connect(addr);\n         });\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let _ = TcpStream::connect(addr);\n         });\n \n@@ -1423,18 +1426,24 @@ mod test {\n         let (tx, rx) = channel();\n         let tx2 = tx.clone();\n \n-        spawn(move|| { let mut a = a; tx.send(a.accept()) });\n-        spawn(move|| { let mut a = a2; tx2.send(a.accept()) });\n+        let _t = Thread::spawn(move|| {\n+            let mut a = a;\n+            tx.send(a.accept()).unwrap();\n+        });\n+        let _t = Thread::spawn(move|| {\n+            let mut a = a2;\n+            tx2.send(a.accept()).unwrap();\n+        });\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let _ = TcpStream::connect(addr);\n         });\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let _ = TcpStream::connect(addr);\n         });\n \n-        assert!(rx.recv().is_ok());\n-        assert!(rx.recv().is_ok());\n+        assert!(rx.recv().unwrap().is_ok());\n+        assert!(rx.recv().unwrap().is_ok());\n     }\n \n     #[test]\n@@ -1455,12 +1464,12 @@ mod test {\n         let mut a2 = a.clone();\n \n         let (tx, rx) = channel();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut a = a;\n-            tx.send(a.accept());\n+            tx.send(a.accept()).unwrap();\n         });\n         a2.close_accept().unwrap();\n \n-        assert_eq!(rx.recv().err().unwrap().kind, EndOfFile);\n+        assert_eq!(rx.recv().unwrap().err().unwrap().kind, EndOfFile);\n     }\n }"}, {"sha": "6c167359966a8a0b98a24e9cae13b489a192d59f", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 53, "deletions": 50, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -248,11 +248,14 @@ impl Writer for UdpStream {\n #[cfg(test)]\n #[allow(experimental)]\n mod test {\n-    use super::*;\n+    use prelude::v1::*;\n+\n+    use sync::mpsc::channel;\n     use io::net::ip::*;\n-    use io::{ShortWrite, IoError, TimedOut, PermissionDenied};\n     use io::test::*;\n-    use prelude::{Ok, Err, spawn, range, drop, Some, None, channel, Clone, Reader, Writer};\n+    use io::{IoError, TimedOut, PermissionDenied, ShortWrite};\n+    use super::*;\n+    use thread::Thread;\n \n     // FIXME #11530 this fails on android because tests are run as root\n     #[cfg_attr(any(windows, target_os = \"android\"), ignore)]\n@@ -272,20 +275,20 @@ mod test {\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             match UdpSocket::bind(client_ip) {\n                 Ok(ref mut client) => {\n-                    rx1.recv();\n+                    rx1.recv().unwrap();\n                     client.send_to(&[99], server_ip).unwrap()\n                 }\n                 Err(..) => panic!()\n             }\n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n \n         match UdpSocket::bind(server_ip) {\n             Ok(ref mut server) => {\n-                tx1.send(());\n+                tx1.send(()).unwrap();\n                 let mut buf = [0];\n                 match server.recv_from(&mut buf) {\n                     Ok((nread, src)) => {\n@@ -298,7 +301,7 @@ mod test {\n             }\n             Err(..) => panic!()\n         }\n-        rx2.recv();\n+        rx2.recv().unwrap();\n     }\n \n     #[test]\n@@ -307,10 +310,10 @@ mod test {\n         let client_ip = next_test_ip6();\n         let (tx, rx) = channel::<()>();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             match UdpSocket::bind(client_ip) {\n                 Ok(ref mut client) => {\n-                    rx.recv();\n+                    rx.recv().unwrap();\n                     client.send_to(&[99], server_ip).unwrap()\n                 }\n                 Err(..) => panic!()\n@@ -319,7 +322,7 @@ mod test {\n \n         match UdpSocket::bind(server_ip) {\n             Ok(ref mut server) => {\n-                tx.send(());\n+                tx.send(()).unwrap();\n                 let mut buf = [0];\n                 match server.recv_from(&mut buf) {\n                     Ok((nread, src)) => {\n@@ -343,8 +346,8 @@ mod test {\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n \n-        spawn(move|| {\n-            let send_as = |&: ip, val: &[u8]| {\n+        let _t = Thread::spawn(move|| {\n+            let send_as = |&:ip, val: &[u8]| {\n                 match UdpSocket::bind(ip) {\n                     Ok(client) => {\n                         let client = box client;\n@@ -354,17 +357,17 @@ mod test {\n                     Err(..) => panic!()\n                 }\n             };\n-            rx1.recv();\n+            rx1.recv().unwrap();\n             send_as(dummy_ip, &[98]);\n             send_as(client_ip, &[99]);\n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n \n         match UdpSocket::bind(server_ip) {\n             Ok(server) => {\n                 let server = box server;\n                 let mut stream = server.connect(client_ip);\n-                tx1.send(());\n+                tx1.send(()).unwrap();\n                 let mut buf = [0];\n                 match stream.read(&mut buf) {\n                     Ok(nread) => {\n@@ -376,7 +379,7 @@ mod test {\n             }\n             Err(..) => panic!()\n         }\n-        rx2.recv();\n+        rx2.recv().unwrap();\n     }\n \n     #[test]\n@@ -387,24 +390,24 @@ mod test {\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             match UdpSocket::bind(client_ip) {\n                 Ok(client) => {\n                     let client = box client;\n                     let mut stream = client.connect(server_ip);\n-                    rx1.recv();\n+                    rx1.recv().unwrap();\n                     stream.write(&[99]).unwrap();\n                 }\n                 Err(..) => panic!()\n             }\n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n \n         match UdpSocket::bind(server_ip) {\n             Ok(server) => {\n                 let server = box server;\n                 let mut stream = server.connect(client_ip);\n-                tx1.send(());\n+                tx1.send(()).unwrap();\n                 let mut buf = [0];\n                 match stream.read(&mut buf) {\n                     Ok(nread) => {\n@@ -416,7 +419,7 @@ mod test {\n             }\n             Err(..) => panic!()\n         }\n-        rx2.recv();\n+        rx2.recv().unwrap();\n     }\n \n     pub fn socket_name(addr: SocketAddr) {\n@@ -449,7 +452,7 @@ mod test {\n         let mut sock1 = UdpSocket::bind(addr1).unwrap();\n         let sock2 = UdpSocket::bind(addr2).unwrap();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut sock2 = sock2;\n             let mut buf = [0, 0];\n             assert_eq!(sock2.recv_from(&mut buf), Ok((1, addr1)));\n@@ -461,16 +464,16 @@ mod test {\n \n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut sock3 = sock3;\n-            rx1.recv();\n+            rx1.recv().unwrap();\n             sock3.send_to(&[1], addr2).unwrap();\n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n-        tx1.send(());\n+        tx1.send(()).unwrap();\n         let mut buf = [0, 0];\n         assert_eq!(sock1.recv_from(&mut buf), Ok((1, addr2)));\n-        rx2.recv();\n+        rx2.recv().unwrap();\n     }\n \n     #[test]\n@@ -482,29 +485,29 @@ mod test {\n         let (tx1, rx) = channel();\n         let tx2 = tx1.clone();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut sock2 = sock2;\n             sock2.send_to(&[1], addr1).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n             sock2.send_to(&[2], addr1).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n         });\n \n         let sock3 = sock1.clone();\n \n         let (done, rx) = channel();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut sock3 = sock3;\n             let mut buf = [0, 0];\n             sock3.recv_from(&mut buf).unwrap();\n-            tx2.send(());\n-            done.send(());\n+            tx2.send(()).unwrap();\n+            done.send(()).unwrap();\n         });\n         let mut buf = [0, 0];\n         sock1.recv_from(&mut buf).unwrap();\n-        tx1.send(());\n+        tx1.send(()).unwrap();\n \n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n@@ -517,38 +520,38 @@ mod test {\n         let (tx, rx) = channel();\n         let (serv_tx, serv_rx) = channel();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut sock2 = sock2;\n             let mut buf = [0, 1];\n \n-            rx.recv();\n+            rx.recv().unwrap();\n             match sock2.recv_from(&mut buf) {\n                 Ok(..) => {}\n                 Err(e) => panic!(\"failed receive: {}\", e),\n             }\n-            serv_tx.send(());\n+            serv_tx.send(()).unwrap();\n         });\n \n         let sock3 = sock1.clone();\n \n         let (done, rx) = channel();\n         let tx2 = tx.clone();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut sock3 = sock3;\n             match sock3.send_to(&[1], addr2) {\n-                Ok(..) => { let _ = tx2.send_opt(()); }\n+                Ok(..) => { let _ = tx2.send(()); }\n                 Err(..) => {}\n             }\n-            done.send(());\n+            done.send(()).unwrap();\n         });\n         match sock1.send_to(&[2], addr2) {\n-            Ok(..) => { let _ = tx.send_opt(()); }\n+            Ok(..) => { let _ = tx.send(()); }\n             Err(..) => {}\n         }\n         drop(tx);\n \n-        rx.recv();\n-        serv_rx.recv();\n+        rx.recv().unwrap();\n+        serv_rx.recv().unwrap();\n     }\n \n     #[cfg(not(windows))] // FIXME #17553\n@@ -561,14 +564,14 @@ mod test {\n \n         let (tx, rx) = channel();\n         let (tx2, rx2) = channel();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut a = a2;\n             assert_eq!(a.recv_from(&mut [0]), Ok((1, addr1)));\n             assert_eq!(a.send_to(&[0], addr1), Ok(()));\n-            rx.recv();\n+            rx.recv().unwrap();\n             assert_eq!(a.send_to(&[0], addr1), Ok(()));\n \n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n \n         // Make sure that reads time out, but writes can continue\n@@ -583,11 +586,11 @@ mod test {\n \n         // Clearing the timeout should allow for receiving\n         a.set_timeout(None);\n-        tx.send(());\n+        tx.send(()).unwrap();\n         assert_eq!(a2.recv_from(&mut [0]), Ok((1, addr2)));\n \n         // Make sure the child didn't die\n-        rx2.recv();\n+        rx2.recv().unwrap();\n     }\n \n     #[test]"}, {"sha": "09dcafb02187aeff84ff66c2f0093c8d9a31f9ff", "filename": "src/libstd/io/pipe.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fpipe.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -15,7 +15,7 @@\n \n #![allow(missing_docs)]\n \n-use prelude::*;\n+use prelude::v1::*;\n \n use io::IoResult;\n use libc;\n@@ -112,7 +112,10 @@ impl Writer for PipeStream {\n \n #[cfg(test)]\n mod test {\n-    use prelude::*;\n+    use prelude::v1::*;\n+\n+    use sync::mpsc::channel;\n+    use thread::Thread;\n \n     #[test]\n     fn partial_read() {\n@@ -123,14 +126,14 @@ mod test {\n         let out = PipeStream::open(writer);\n         let mut input = PipeStream::open(reader);\n         let (tx, rx) = channel();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut out = out;\n             out.write(&[10]).unwrap();\n-            rx.recv(); // don't close the pipe until the other read has finished\n+            rx.recv().unwrap(); // don't close the pipe until the other read has finished\n         });\n \n         let mut buf = [0; 10];\n         input.read(&mut buf).unwrap();\n-        tx.send(());\n+        tx.send(()).unwrap();\n     }\n }"}, {"sha": "fedc102e45d5334904a1125da4f80963bafe4f5a", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -16,25 +16,25 @@\n pub use self::StdioContainer::*;\n pub use self::ProcessExit::*;\n \n-use prelude::*;\n+use prelude::v1::*;\n \n+use c_str::{CString, ToCStr};\n+use collections::HashMap;\n use fmt;\n-use os;\n+use hash::Hash;\n+use io::pipe::{PipeStream, PipePair};\n use io::{IoResult, IoError};\n use io;\n use libc;\n-use c_str::CString;\n-use collections::HashMap;\n-use hash::Hash;\n-#[cfg(windows)]\n-use std::hash::sip::SipState;\n-use io::pipe::{PipeStream, PipePair};\n+use os;\n use path::BytesContainer;\n-use thread::Thread;\n-\n-use sys;\n+use sync::mpsc::{channel, Receiver};\n use sys::fs::FileDesc;\n use sys::process::Process as ProcessImp;\n+use sys;\n+use thread::Thread;\n+\n+#[cfg(windows)] use std::hash::sip::SipState;\n \n /// Signal a process to exit, without forcibly killing it. Corresponds to\n /// SIGTERM on unix platforms.\n@@ -693,10 +693,10 @@ impl Process {\n                 Some(stream) => {\n                     Thread::spawn(move |:| {\n                         let mut stream = stream;\n-                        tx.send(stream.read_to_end())\n+                        tx.send(stream.read_to_end()).unwrap();\n                     }).detach();\n                 }\n-                None => tx.send(Ok(Vec::new()))\n+                None => tx.send(Ok(Vec::new())).unwrap()\n             }\n             rx\n         }\n@@ -707,8 +707,8 @@ impl Process {\n \n         Ok(ProcessOutput {\n             status: status,\n-            output: stdout.recv().ok().unwrap_or(Vec::new()),\n-            error:  stderr.recv().ok().unwrap_or(Vec::new()),\n+            output: stdout.recv().unwrap().unwrap_or(Vec::new()),\n+            error:  stderr.recv().unwrap().unwrap_or(Vec::new()),\n         })\n     }\n \n@@ -741,18 +741,19 @@ impl Drop for Process {\n \n #[cfg(test)]\n mod tests {\n-    #![allow(unused_imports)]\n+    use prelude::v1::*;\n \n-    use super::*;\n-    use io::timer::*;\n-    use io::{Truncate, Write, TimedOut, timer, process, FileNotFound};\n-    use prelude::{Ok, Err, spawn, range, drop, Box, Some, None, Option, Vec, Buffer};\n-    use prelude::{from_str, Path, String, channel, Reader, Writer, Clone, Slice};\n-    use prelude::{SliceExt, Str, StrExt, AsSlice, ToString, GenericPath};\n     use io::fs::PathExtensions;\n-    use time::Duration;\n-    use str;\n+    use io::process;\n+    use io::timer::*;\n+    use io::{Truncate, Write, TimedOut, timer, FileNotFound};\n     use rt::running_on_valgrind;\n+    use str;\n+    use super::{CreatePipe};\n+    use super::{InheritFd, Process, PleaseExitSignal, Command, ProcessOutput};\n+    use sync::mpsc::channel;\n+    use thread::Thread;\n+    use time::Duration;\n \n     // FIXME(#10380) these tests should not all be ignored on android.\n \n@@ -1156,22 +1157,22 @@ mod tests {\n     fn wait_timeout2() {\n         let (tx, rx) = channel();\n         let tx2 = tx.clone();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut p = sleeper();\n             p.set_timeout(Some(10));\n             assert_eq!(p.wait().err().unwrap().kind, TimedOut);\n             p.signal_kill().unwrap();\n-            tx.send(());\n+            tx.send(()).unwrap();\n         });\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut p = sleeper();\n             p.set_timeout(Some(10));\n             assert_eq!(p.wait().err().unwrap().kind, TimedOut);\n             p.signal_kill().unwrap();\n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n-        rx.recv();\n-        rx.recv();\n+        rx.recv().unwrap();\n+        rx.recv().unwrap();\n     }\n \n     #[test]"}, {"sha": "c1474650f1eb479fa73245b253105b9b708302c3", "filename": "src/libstd/io/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fresult.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -78,7 +78,7 @@ impl<T, A: Acceptor<T>> Acceptor<T> for IoResult<A> {\n \n #[cfg(test)]\n mod test {\n-    use prelude::*;\n+    use prelude::v1::*;\n     use super::super::mem::*;\n     use io;\n "}, {"sha": "cd991c5f884f5ef77be1ab416cb5619665e4ae2b", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -117,13 +117,15 @@ pub struct StdinReaderGuard<'a> {\n     inner: MutexGuard<'a, RaceBox>,\n }\n \n-impl<'a> Deref<BufferedReader<StdReader>> for StdinReaderGuard<'a> {\n+impl<'a> Deref for StdinReaderGuard<'a> {\n+    type Target = BufferedReader<StdReader>;\n+\n     fn deref(&self) -> &BufferedReader<StdReader> {\n         &self.inner.0\n     }\n }\n \n-impl<'a> DerefMut<BufferedReader<StdReader>> for StdinReaderGuard<'a> {\n+impl<'a> DerefMut for StdinReaderGuard<'a> {\n     fn deref_mut(&mut self) -> &mut BufferedReader<StdReader> {\n         &mut self.inner.0\n     }\n@@ -218,7 +220,7 @@ pub fn stdin() -> StdinReader {\n     static ONCE: Once = ONCE_INIT;\n \n     unsafe {\n-        ONCE.doit(|| {\n+        ONCE.call_once(|| {\n             // The default buffer capacity is 64k, but apparently windows doesn't like\n             // 64k reads on stdin. See #13304 for details, but the idea is that on\n             // windows we use a slightly smaller buffer that's been seen to be\n@@ -520,8 +522,11 @@ impl Writer for StdWriter {\n \n #[cfg(test)]\n mod tests {\n+    use prelude::v1::*;\n+\n     use super::*;\n-    use prelude::*;\n+    use sync::mpsc::channel;\n+    use thread::Thread;\n \n     #[test]\n     fn smoke() {\n@@ -537,7 +542,7 @@ mod tests {\n \n         let (tx, rx) = channel();\n         let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             set_stdout(box w);\n             println!(\"hello!\");\n         });\n@@ -550,7 +555,7 @@ mod tests {\n \n         let (tx, rx) = channel();\n         let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));\n-        spawn(move|| {\n+        let _t = Thread::spawn(move || -> () {\n             set_stderr(box w);\n             panic!(\"my special message\");\n         });"}, {"sha": "5cf8667665162ebf34b84e81cd75eaba3b919bab", "filename": "src/libstd/io/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftempfile.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -90,7 +90,7 @@ impl TempDir {\n             return TempDir::new_in(&abs_tmpdir, suffix);\n         }\n \n-        static CNT: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+        static CNT: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n \n         let mut attempts = 0u;\n         loop {"}, {"sha": "2f87abd0ee2fc6731a7d38887af16ca08f821206", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -12,21 +12,22 @@\n \n #![macro_escape]\n \n+use prelude::v1::*;\n+\n use libc;\n use os;\n-use prelude::*;\n use std::io::net::ip::*;\n-use sync::atomic::{AtomicUint, INIT_ATOMIC_UINT, Relaxed};\n+use sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Relaxed};\n \n /// Get a port number, starting at 9600, for use in tests\n pub fn next_test_port() -> u16 {\n-    static NEXT_OFFSET: AtomicUint = INIT_ATOMIC_UINT;\n+    static NEXT_OFFSET: AtomicUint = ATOMIC_UINT_INIT;\n     base_port() + NEXT_OFFSET.fetch_add(1, Relaxed) as u16\n }\n \n /// Get a temporary path which could be the location of a unix socket\n pub fn next_test_unix() -> Path {\n-    static COUNT: AtomicUint = INIT_ATOMIC_UINT;\n+    static COUNT: AtomicUint = ATOMIC_UINT_INIT;\n     // base port and pid are an attempt to be unique between multiple\n     // test-runners of different configurations running on one\n     // buildbot, the count is to be unique within this executable."}, {"sha": "e073f76af825ce77628696d262a99af136589f6b", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 50, "deletions": 51, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -15,7 +15,7 @@\n \n // FIXME: These functions take Durations but only pass ms to the backend impls.\n \n-use comm::{Receiver, Sender, channel};\n+use sync::mpsc::{Receiver, Sender, channel};\n use time::Duration;\n use io::IoResult;\n use sys::timer::Callback;\n@@ -40,11 +40,11 @@ use sys::timer::Timer as TimerImp;\n ///\n /// let timeout = timer.oneshot(Duration::milliseconds(10));\n /// // do some work\n-/// timeout.recv(); // wait for the timeout to expire\n+/// timeout.recv().unwrap(); // wait for the timeout to expire\n ///\n /// let periodic = timer.periodic(Duration::milliseconds(10));\n /// loop {\n-///     periodic.recv();\n+///     periodic.recv().unwrap();\n ///     // this loop is only executed once every 10ms\n /// }\n /// # }\n@@ -126,7 +126,7 @@ impl Timer {\n     /// for _ in range(0u, 100) { /* do work */ }\n     ///\n     /// // blocks until 10 ms after the `oneshot` call\n-    /// ten_milliseconds.recv();\n+    /// ten_milliseconds.recv().unwrap();\n     /// ```\n     ///\n     /// ```rust\n@@ -136,7 +136,7 @@ impl Timer {\n     /// // Incorrect, method chaining-style:\n     /// let mut five_ms = Timer::new().unwrap().oneshot(Duration::milliseconds(5));\n     /// // The timer object was destroyed, so this will always fail:\n-    /// // five_ms.recv()\n+    /// // five_ms.recv().unwrap()\n     /// ```\n     ///\n     /// When provided a zero or negative `duration`, the message will\n@@ -147,7 +147,7 @@ impl Timer {\n         if in_ms_u64(duration) != 0 {\n             self.inner.oneshot(in_ms_u64(duration), box TimerCallback { tx: tx });\n         } else {\n-            tx.send(());\n+            tx.send(()).unwrap();\n         }\n         return rx\n     }\n@@ -178,13 +178,13 @@ impl Timer {\n     /// for _ in range(0u, 100) { /* do work */ }\n     ///\n     /// // blocks until 10 ms after the `periodic` call\n-    /// ten_milliseconds.recv();\n+    /// ten_milliseconds.recv().unwrap();\n     ///\n     /// for _ in range(0u, 100) { /* do work */ }\n     ///\n     /// // blocks until 20 ms after the `periodic` call (*not* 10ms after the\n     /// // previous `recv`)\n-    /// ten_milliseconds.recv();\n+    /// ten_milliseconds.recv().unwrap();\n     /// ```\n     ///\n     /// ```rust\n@@ -194,7 +194,7 @@ impl Timer {\n     /// // Incorrect, method chaining-style.\n     /// let mut five_ms = Timer::new().unwrap().periodic(Duration::milliseconds(5));\n     /// // The timer object was destroyed, so this will always fail:\n-    /// // five_ms.recv()\n+    /// // five_ms.recv().unwrap()\n     /// ```\n     ///\n     /// When provided a zero or negative `duration`, the messages will\n@@ -213,7 +213,7 @@ impl Timer {\n \n impl Callback for TimerCallback {\n     fn call(&mut self) {\n-        let _ = self.tx.send_opt(());\n+        let _ = self.tx.send(());\n     }\n }\n \n@@ -225,9 +225,8 @@ fn in_ms_u64(d: Duration) -> u64 {\n \n #[cfg(test)]\n mod test {\n-    use prelude::*;\n-\n     use super::Timer;\n+    use thread::Thread;\n     use time::Duration;\n \n     #[test]\n@@ -239,7 +238,7 @@ mod test {\n     #[test]\n     fn test_io_timer_sleep_oneshot() {\n         let mut timer = Timer::new().unwrap();\n-        timer.oneshot(Duration::milliseconds(1)).recv();\n+        timer.oneshot(Duration::milliseconds(1)).recv().unwrap();\n     }\n \n     #[test]\n@@ -253,8 +252,8 @@ mod test {\n         let mut timer = Timer::new().unwrap();\n         let rx1 = timer.oneshot(Duration::milliseconds(10000));\n         let rx = timer.oneshot(Duration::milliseconds(1));\n-        rx.recv();\n-        assert_eq!(rx1.recv_opt(), Err(()));\n+        rx.recv().unwrap();\n+        assert!(rx1.recv().is_err());\n     }\n \n     #[test]\n@@ -263,16 +262,16 @@ mod test {\n         let rx = timer.oneshot(Duration::milliseconds(100000000));\n         timer.sleep(Duration::milliseconds(1)); // this should invalidate rx\n \n-        assert_eq!(rx.recv_opt(), Err(()));\n+        assert!(rx.recv().is_err());\n     }\n \n     #[test]\n     fn test_io_timer_sleep_periodic() {\n         let mut timer = Timer::new().unwrap();\n         let rx = timer.periodic(Duration::milliseconds(1));\n-        rx.recv();\n-        rx.recv();\n-        rx.recv();\n+        rx.recv().unwrap();\n+        rx.recv().unwrap();\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n@@ -291,12 +290,12 @@ mod test {\n         let mut timer = Timer::new().unwrap();\n \n         let rx = timer.oneshot(Duration::milliseconds(1));\n-        rx.recv();\n-        assert!(rx.recv_opt().is_err());\n+        rx.recv().unwrap();\n+        assert!(rx.recv().is_err());\n \n         let rx = timer.oneshot(Duration::milliseconds(1));\n-        rx.recv();\n-        assert!(rx.recv_opt().is_err());\n+        rx.recv().unwrap();\n+        assert!(rx.recv().is_err());\n     }\n \n     #[test]\n@@ -305,20 +304,20 @@ mod test {\n         let orx = timer.oneshot(Duration::milliseconds(100));\n         let prx = timer.periodic(Duration::milliseconds(100));\n         timer.sleep(Duration::milliseconds(1));\n-        assert_eq!(orx.recv_opt(), Err(()));\n-        assert_eq!(prx.recv_opt(), Err(()));\n-        timer.oneshot(Duration::milliseconds(1)).recv();\n+        assert!(orx.recv().is_err());\n+        assert!(prx.recv().is_err());\n+        timer.oneshot(Duration::milliseconds(1)).recv().unwrap();\n     }\n \n     #[test]\n     fn period() {\n         let mut timer = Timer::new().unwrap();\n         let rx = timer.periodic(Duration::milliseconds(1));\n-        rx.recv();\n-        rx.recv();\n+        rx.recv().unwrap();\n+        rx.recv().unwrap();\n         let rx2 = timer.periodic(Duration::milliseconds(1));\n-        rx2.recv();\n-        rx2.recv();\n+        rx2.recv().unwrap();\n+        rx2.recv().unwrap();\n     }\n \n     #[test]\n@@ -357,9 +356,9 @@ mod test {\n         let mut timer = Timer::new().unwrap();\n         let timer_rx = timer.periodic(Duration::milliseconds(1000));\n \n-        spawn(move|| {\n-            let _ = timer_rx.recv_opt();\n-        });\n+        Thread::spawn(move|| {\n+            let _ = timer_rx.recv();\n+        }).detach();\n \n         // when we drop the TimerWatcher we're going to destroy the channel,\n         // which must wake up the task on the other end\n@@ -371,9 +370,9 @@ mod test {\n         let mut timer = Timer::new().unwrap();\n         let timer_rx = timer.periodic(Duration::milliseconds(1000));\n \n-        spawn(move|| {\n-            let _ = timer_rx.recv_opt();\n-        });\n+        Thread::spawn(move|| {\n+            let _ = timer_rx.recv();\n+        }).detach();\n \n         timer.oneshot(Duration::milliseconds(1));\n     }\n@@ -384,9 +383,9 @@ mod test {\n         let mut timer = Timer::new().unwrap();\n         let timer_rx = timer.periodic(Duration::milliseconds(1000));\n \n-        spawn(move|| {\n-            let _ = timer_rx.recv_opt();\n-        });\n+        Thread::spawn(move|| {\n+            let _ = timer_rx.recv();\n+        }).detach();\n \n         timer.sleep(Duration::milliseconds(1));\n     }\n@@ -397,7 +396,7 @@ mod test {\n             let mut timer = Timer::new().unwrap();\n             timer.oneshot(Duration::milliseconds(1000))\n         };\n-        assert_eq!(rx.recv_opt(), Err(()));\n+        assert!(rx.recv().is_err());\n     }\n \n     #[test]\n@@ -406,7 +405,7 @@ mod test {\n             let mut timer = Timer::new().unwrap();\n             timer.periodic(Duration::milliseconds(1000))\n         };\n-        assert_eq!(rx.recv_opt(), Err(()));\n+        assert!(rx.recv().is_err());\n     }\n \n     #[test]\n@@ -445,34 +444,34 @@ mod test {\n     fn oneshot_zero() {\n         let mut timer = Timer::new().unwrap();\n         let rx = timer.oneshot(Duration::milliseconds(0));\n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n     fn oneshot_negative() {\n         let mut timer = Timer::new().unwrap();\n         let rx = timer.oneshot(Duration::milliseconds(-1000000));\n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n     fn periodic_zero() {\n         let mut timer = Timer::new().unwrap();\n         let rx = timer.periodic(Duration::milliseconds(0));\n-        rx.recv();\n-        rx.recv();\n-        rx.recv();\n-        rx.recv();\n+        rx.recv().unwrap();\n+        rx.recv().unwrap();\n+        rx.recv().unwrap();\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n     fn periodic_negative() {\n         let mut timer = Timer::new().unwrap();\n         let rx = timer.periodic(Duration::milliseconds(-1000000));\n-        rx.recv();\n-        rx.recv();\n-        rx.recv();\n-        rx.recv();\n+        rx.recv().unwrap();\n+        rx.recv().unwrap();\n+        rx.recv().unwrap();\n+        rx.recv().unwrap();\n     }\n \n }"}, {"sha": "38ab71c172c59ea710c7b9a68b545dd78c7e3f13", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -10,7 +10,7 @@\n \n //! Utility implementations of Reader and Writer\n \n-use prelude::*;\n+use prelude::v1::*;\n use cmp;\n use io;\n use slice::bytes::MutableByteVector;\n@@ -278,11 +278,11 @@ impl<T: Iterator<u8>> Reader for IterReader<T> {\n \n #[cfg(test)]\n mod test {\n+    use prelude::v1::*;\n+\n     use io::{MemReader, ByRefReader};\n     use io;\n-    use boxed::Box;\n     use super::*;\n-    use prelude::{Ok, range, Vec, Buffer, Writer, Reader, ToString, AsSlice};\n \n     #[test]\n     fn test_limit_reader_unlimited() {\n@@ -386,7 +386,7 @@ mod test {\n         let mut r = TeeReader::new(MemReader::new(vec!(0, 1, 2)),\n                                    Vec::new());\n         assert_eq!(vec!(0, 1, 2), r.read_to_end().unwrap());\n-        let (_, w) = r.unwrap();\n+        let (_, w) = r.into_inner();\n         assert_eq!(vec!(0, 1, 2), w);\n     }\n "}, {"sha": "7c8aab2b31dae9ae8d15895181b43381d4aaff23", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -107,6 +107,8 @@\n #![feature(macro_rules, globs, linkage, thread_local, asm)]\n #![feature(default_type_params, phase, lang_items, unsafe_destructor)]\n #![feature(slicing_syntax, unboxed_closures)]\n+#![feature(old_orphan_check)]\n+#![feature(associated_types)]\n \n // Don't link to std. We are std.\n #![no_std]\n@@ -227,7 +229,6 @@ pub mod hash;\n pub mod task;\n pub mod thread;\n pub mod sync;\n-pub mod comm;\n \n #[cfg(unix)]\n #[path = \"sys/unix/mod.rs\"] mod sys;\n@@ -255,7 +256,7 @@ mod std {\n     pub use cmp;\n     pub use hash;\n \n-    pub use comm; // used for select!()\n+    pub use sync; // used for select!()\n     pub use error; // used for try!()\n     pub use fmt; // used for any formatting strings\n     pub use io; // used for println!()\n@@ -265,6 +266,7 @@ mod std {\n     pub use cell; // used for tls!\n     pub use thread_local; // used for thread_local!\n     pub use kinds; // used for tls!\n+    pub use ops; // used for bitflags!\n \n     // The test runner calls ::std::os::args() but really wants realstd\n     #[cfg(test)] pub use realstd::os as os;"}, {"sha": "63fd3209cc0193b619f811373be8f97886f57781", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -317,9 +317,8 @@ macro_rules! try {\n #[macro_export]\n macro_rules! vec {\n     ($($x:expr),*) => ({\n-        use std::slice::BoxedSliceExt;\n         let xs: ::std::boxed::Box<[_]> = box [$($x),*];\n-        xs.into_vec()\n+        ::std::slice::SliceExt::into_vec(xs)\n     });\n     ($($x:expr,)*) => (vec![$($x),*])\n }\n@@ -334,6 +333,7 @@ macro_rules! vec {\n ///\n /// ```\n /// use std::thread::Thread;\n+/// use std::sync::mpsc::channel;\n ///\n /// let (tx1, rx1) = channel();\n /// let (tx2, rx2) = channel();\n@@ -344,21 +344,21 @@ macro_rules! vec {\n /// Thread::spawn(move|| { tx2.send(calculate_the_answer()) }).detach();\n ///\n /// select! (\n-///     () = rx1.recv() => println!(\"the long running task finished first\"),\n+///     _ = rx1.recv() => println!(\"the long running task finished first\"),\n ///     answer = rx2.recv() => {\n-///         println!(\"the answer was: {}\", answer);\n+///         println!(\"the answer was: {}\", answer.unwrap());\n ///     }\n /// )\n /// ```\n ///\n-/// For more information about select, see the `std::comm::Select` structure.\n+/// For more information about select, see the `std::sync::mpsc::Select` structure.\n #[macro_export]\n #[experimental]\n macro_rules! select {\n     (\n         $($name:pat = $rx:ident.$meth:ident() => $code:expr),+\n     ) => ({\n-        use std::comm::Select;\n+        use std::sync::mpsc::Select;\n         let sel = Select::new();\n         $( let mut $rx = sel.handle(&$rx); )+\n         unsafe {"}, {"sha": "f2a0419e39196f584bb44fa645e3e6886fbc8948", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -15,7 +15,7 @@\n #![allow(unsigned_negation)]\n #![doc(primitive = \"f32\")]\n \n-use prelude::*;\n+use prelude::v1::*;\n \n use intrinsics;\n use libc::c_int;\n@@ -496,23 +496,25 @@ mod tests {\n \n     #[test]\n     fn test_real_consts() {\n-        let pi: f32 = Float::pi();\n-        let two_pi: f32 = Float::two_pi();\n-        let frac_pi_2: f32 = Float::frac_pi_2();\n-        let frac_pi_3: f32 = Float::frac_pi_3();\n-        let frac_pi_4: f32 = Float::frac_pi_4();\n-        let frac_pi_6: f32 = Float::frac_pi_6();\n-        let frac_pi_8: f32 = Float::frac_pi_8();\n-        let frac_1_pi: f32 = Float::frac_1_pi();\n-        let frac_2_pi: f32 = Float::frac_2_pi();\n-        let frac_2_sqrtpi: f32 = Float::frac_2_sqrtpi();\n-        let sqrt2: f32 = Float::sqrt2();\n-        let frac_1_sqrt2: f32 = Float::frac_1_sqrt2();\n-        let e: f32 = Float::e();\n-        let log2_e: f32 = Float::log2_e();\n-        let log10_e: f32 = Float::log10_e();\n-        let ln_2: f32 = Float::ln_2();\n-        let ln_10: f32 = Float::ln_10();\n+        use super::consts;\n+\n+        let pi: f32 = consts::PI;\n+        let two_pi: f32 = consts::PI_2;\n+        let frac_pi_2: f32 = consts::FRAC_PI_2;\n+        let frac_pi_3: f32 = consts::FRAC_PI_3;\n+        let frac_pi_4: f32 = consts::FRAC_PI_4;\n+        let frac_pi_6: f32 = consts::FRAC_PI_6;\n+        let frac_pi_8: f32 = consts::FRAC_PI_8;\n+        let frac_1_pi: f32 = consts::FRAC_1_PI;\n+        let frac_2_pi: f32 = consts::FRAC_2_PI;\n+        let frac_2_sqrtpi: f32 = consts::FRAC_2_SQRTPI;\n+        let sqrt2: f32 = consts::SQRT2;\n+        let frac_1_sqrt2: f32 = consts::FRAC_1_SQRT2;\n+        let e: f32 = consts::E;\n+        let log2_e: f32 = consts::LOG2_E;\n+        let log10_e: f32 = consts::LOG10_E;\n+        let ln_2: f32 = consts::LN_2;\n+        let ln_10: f32 = consts::LN_10;\n \n         assert_approx_eq!(two_pi, 2f32 * pi);\n         assert_approx_eq!(frac_pi_2, pi / 2f32);"}, {"sha": "105a8a23bd104596cf0889590f453a39775f3adc", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -14,7 +14,7 @@\n #![allow(missing_docs)]\n #![doc(primitive = \"f64\")]\n \n-use prelude::*;\n+use prelude::v1::*;\n \n use intrinsics;\n use libc::c_int;\n@@ -499,23 +499,24 @@ mod tests {\n \n     #[test]\n     fn test_real_consts() {\n-        let pi: f64 = Float::pi();\n-        let two_pi: f64 = Float::two_pi();\n-        let frac_pi_2: f64 = Float::frac_pi_2();\n-        let frac_pi_3: f64 = Float::frac_pi_3();\n-        let frac_pi_4: f64 = Float::frac_pi_4();\n-        let frac_pi_6: f64 = Float::frac_pi_6();\n-        let frac_pi_8: f64 = Float::frac_pi_8();\n-        let frac_1_pi: f64 = Float::frac_1_pi();\n-        let frac_2_pi: f64 = Float::frac_2_pi();\n-        let frac_2_sqrtpi: f64 = Float::frac_2_sqrtpi();\n-        let sqrt2: f64 = Float::sqrt2();\n-        let frac_1_sqrt2: f64 = Float::frac_1_sqrt2();\n-        let e: f64 = Float::e();\n-        let log2_e: f64 = Float::log2_e();\n-        let log10_e: f64 = Float::log10_e();\n-        let ln_2: f64 = Float::ln_2();\n-        let ln_10: f64 = Float::ln_10();\n+        use super::consts;\n+        let pi: f64 = consts::PI;\n+        let two_pi: f64 = consts::PI_2;\n+        let frac_pi_2: f64 = consts::FRAC_PI_2;\n+        let frac_pi_3: f64 = consts::FRAC_PI_3;\n+        let frac_pi_4: f64 = consts::FRAC_PI_4;\n+        let frac_pi_6: f64 = consts::FRAC_PI_6;\n+        let frac_pi_8: f64 = consts::FRAC_PI_8;\n+        let frac_1_pi: f64 = consts::FRAC_1_PI;\n+        let frac_2_pi: f64 = consts::FRAC_2_PI;\n+        let frac_2_sqrtpi: f64 = consts::FRAC_2_SQRTPI;\n+        let sqrt2: f64 = consts::SQRT2;\n+        let frac_1_sqrt2: f64 = consts::FRAC_1_SQRT2;\n+        let e: f64 = consts::E;\n+        let log2_e: f64 = consts::LOG2_E;\n+        let log10_e: f64 = consts::LOG10_E;\n+        let ln_2: f64 = consts::LN_2;\n+        let ln_10: f64 = consts::LN_10;\n \n         assert_approx_eq!(two_pi, 2.0 * pi);\n         assert_approx_eq!(frac_pi_2, pi / 2f64);"}, {"sha": "01aa21c692bf54cce2047b2cfd694ee89262932f", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -147,10 +147,8 @@ pub fn test_num<T>(ten: T, two: T) where\n \n #[cfg(test)]\n mod tests {\n-    use prelude::{range, Some, None, Option, IteratorExt};\n-    use super::{from_int, from_uint, from_i32, from_i64, from_u64, from_u32};\n-    use super::{from_f64, from_f32, from_u16, from_i16, from_u8, from_i8, Int};\n-    use super::{cast, NumCast, ToPrimitive, FromPrimitive, UnsignedInt};\n+    use prelude::v1::*;\n+    use super::*;\n     use i8;\n     use i16;\n     use i32;\n@@ -802,7 +800,7 @@ mod bench {\n     extern crate test;\n     use self::test::Bencher;\n     use num::Int;\n-    use prelude::*;\n+    use prelude::v1::*;\n \n     #[bench]\n     fn bench_pow_function(b: &mut Bencher) {"}, {"sha": "6c64251091a31d945ef7862928b433648bf7502c", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -20,7 +20,7 @@ use char::{mod, Char};\n use num::{mod, Int, Float, ToPrimitive};\n use num::FpCategory as Fp;\n use ops::FnMut;\n-use slice::{SliceExt, CloneSliceExt};\n+use slice::SliceExt;\n use str::StrExt;\n use string::String;\n use vec::Vec;"}, {"sha": "b52e4fda7af2c8c2af4aa104e5fe4f58e9b5c0a6", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -49,8 +49,9 @@ pub fn to_str_bytes<U, F>(n: $T, radix: uint, f: F) -> U where\n \n #[cfg(test)]\n mod tests {\n-    use prelude::*;\n+    use prelude::v1::*;\n     use num::FromStrRadix;\n+    use str::from_str;\n \n     #[test]\n     pub fn test_from_str() {"}, {"sha": "615a20baf893ce34e239fef8712d7a0f39c77e25", "filename": "src/libstd/os.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -52,10 +52,9 @@ use ptr;\n use result::Result;\n use result::Result::{Err, Ok};\n use slice::{AsSlice, SliceExt};\n-use slice::CloneSliceExt;\n use str::{Str, StrExt};\n use string::{String, ToString};\n-use sync::atomic::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n+use sync::atomic::{AtomicInt, ATOMIC_INT_INIT, SeqCst};\n use vec::Vec;\n \n #[cfg(unix)] use c_str::ToCStr;\n@@ -596,7 +595,7 @@ pub fn last_os_error() -> String {\n     error_string(errno() as uint)\n }\n \n-static EXIT_STATUS: AtomicInt = INIT_ATOMIC_INT;\n+static EXIT_STATUS: AtomicInt = ATOMIC_INT_INIT;\n \n /// Sets the process exit code\n ///\n@@ -1427,8 +1426,9 @@ mod arch_consts {\n \n #[cfg(test)]\n mod tests {\n-    use prelude::*;\n-    use option;\n+    use prelude::v1::*;\n+\n+    use iter::repeat;\n     use os::{env, getcwd, getenv, make_absolute};\n     use os::{split_paths, join_paths, setenv, unsetenv};\n     use os;\n@@ -1457,15 +1457,15 @@ mod tests {\n     fn test_setenv() {\n         let n = make_rand_name();\n         setenv(n.as_slice(), \"VALUE\");\n-        assert_eq!(getenv(n.as_slice()), option::Option::Some(\"VALUE\".to_string()));\n+        assert_eq!(getenv(n.as_slice()), Some(\"VALUE\".to_string()));\n     }\n \n     #[test]\n     fn test_unsetenv() {\n         let n = make_rand_name();\n         setenv(n.as_slice(), \"VALUE\");\n         unsetenv(n.as_slice());\n-        assert_eq!(getenv(n.as_slice()), option::Option::None);\n+        assert_eq!(getenv(n.as_slice()), None);\n     }\n \n     #[test]\n@@ -1474,9 +1474,9 @@ mod tests {\n         let n = make_rand_name();\n         setenv(n.as_slice(), \"1\");\n         setenv(n.as_slice(), \"2\");\n-        assert_eq!(getenv(n.as_slice()), option::Option::Some(\"2\".to_string()));\n+        assert_eq!(getenv(n.as_slice()), Some(\"2\".to_string()));\n         setenv(n.as_slice(), \"\");\n-        assert_eq!(getenv(n.as_slice()), option::Option::Some(\"\".to_string()));\n+        assert_eq!(getenv(n.as_slice()), Some(\"\".to_string()));\n     }\n \n     // Windows GetEnvironmentVariable requires some extra work to make sure\n@@ -1493,7 +1493,7 @@ mod tests {\n         let n = make_rand_name();\n         setenv(n.as_slice(), s.as_slice());\n         debug!(\"{}\", s.clone());\n-        assert_eq!(getenv(n.as_slice()), option::Option::Some(s));\n+        assert_eq!(getenv(n.as_slice()), Some(s));\n     }\n \n     #[test]\n@@ -1530,14 +1530,14 @@ mod tests {\n             // MingW seems to set some funky environment variables like\n             // \"=C:=C:\\MinGW\\msys\\1.0\\bin\" and \"!::=::\\\" that are returned\n             // from env() but not visible from getenv().\n-            assert!(v2.is_none() || v2 == option::Option::Some(v));\n+            assert!(v2.is_none() || v2 == Some(v));\n         }\n     }\n \n     #[test]\n     fn test_env_set_get_huge() {\n         let n = make_rand_name();\n-        let s = \"x\".repeat(10000).to_string();\n+        let s = repeat(\"x\").take(10000).collect::<String>();\n         setenv(n.as_slice(), s.as_slice());\n         assert_eq!(getenv(n.as_slice()), Some(s));\n         unsetenv(n.as_slice());\n@@ -1659,8 +1659,8 @@ mod tests {\n         path.push(\"mmap_file.tmp\");\n         let size = MemoryMap::granularity() * 2;\n         let mut file = File::open_mode(&path, Open, ReadWrite).unwrap();\n-        file.seek(size as i64, SeekSet);\n-        file.write_u8(0);\n+        file.seek(size as i64, SeekSet).unwrap();\n+        file.write_u8(0).unwrap();\n \n         let chunk = MemoryMap::new(size / 2, &[\n             MapOption::MapReadable,"}, {"sha": "731c3bbe427d5836d0a9134e65715bbe0a956fde", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -71,8 +71,7 @@ use option::Option::{None, Some};\n use str;\n use str::{CowString, MaybeOwned, Str, StrExt};\n use string::String;\n-use slice::{AsSlice, CloneSliceExt};\n-use slice::{PartialEqSliceExt, SliceExt};\n+use slice::{AsSlice, SliceExt};\n use vec::Vec;\n \n /// Typedef for POSIX file paths.\n@@ -931,7 +930,9 @@ fn contains_nul<T: BytesContainer>(v: &T) -> bool {\n \n #[cfg(test)]\n mod tests {\n-    use prelude::*;\n+    use prelude::v1::*;\n+    use c_str::ToCStr;\n+    use path::{WindowsPath, PosixPath};\n \n     #[test]\n     fn test_cstring() {"}, {"sha": "6075010f3b5ffdb95f0b9c806fb3adef6cc2b229", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -22,8 +22,7 @@ use option::Option::{None, Some};\n use kinds::Sized;\n use str::{FromStr, Str};\n use str;\n-use slice::{CloneSliceExt, Split, AsSlice, SliceConcatExt,\n-            PartialEqSliceExt, SliceExt};\n+use slice::{Split, AsSlice, SliceConcatExt, SliceExt};\n use vec::Vec;\n \n use super::{BytesContainer, GenericPath, GenericPathUnsafe};\n@@ -448,10 +447,15 @@ static dot_dot_static: &'static [u8] = b\"..\";\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use prelude::Option::{mod, Some, None};\n-    use prelude::{Vec, Clone, AsSlice, SliceExt, CloneSliceExt, IteratorExt};\n-    use prelude::{DoubleEndedIteratorExt, Str, StrExt, ToString, GenericPath};\n-    use str;\n+\n+    use clone::Clone;\n+    use iter::{IteratorExt, DoubleEndedIteratorExt};\n+    use option::Option::{mod, Some, None};\n+    use path::GenericPath;\n+    use slice::{AsSlice, SliceExt};\n+    use str::{mod, Str, StrExt};\n+    use string::ToString;\n+    use vec::Vec;\n \n     macro_rules! t {\n         (s: $path:expr, $exp:expr) => (\n@@ -1239,7 +1243,7 @@ mod bench {\n     extern crate test;\n     use self::test::Bencher;\n     use super::*;\n-    use prelude::{Clone, GenericPath};\n+    use prelude::v1::{Clone, GenericPath};\n \n     #[bench]\n     fn join_home_dir(b: &mut Bencher) {"}, {"sha": "55086ad3a23f98d5bb7143af8b3a479e770a7500", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -1119,12 +1119,18 @@ fn prefix_len(p: Option<PathPrefix>) -> uint {\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n-    use prelude::Option::{mod, Some, None};\n-    use prelude::{Vec, Clone, AsSlice, SliceExt, CloneSliceExt, IteratorExt};\n-    use prelude::{DoubleEndedIteratorExt, Str, ToString, GenericPath};\n     use super::PathPrefix::*;\n     use super::parse_prefix;\n+    use super::*;\n+\n+    use clone::Clone;\n+    use iter::{IteratorExt, DoubleEndedIteratorExt};\n+    use option::Option::{mod, Some, None};\n+    use path::GenericPath;\n+    use slice::{AsSlice, SliceExt};\n+    use str::Str;\n+    use string::ToString;\n+    use vec::Vec;\n \n     macro_rules! t {\n         (s: $path:expr, $exp:expr) => ("}, {"sha": "f016683e3d0a99991cf5f07db5befa71e6edb27e", "filename": "src/libstd/prelude.rs", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/4b40bc85cbc1d072179c92ce01655db0272aa598/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b40bc85cbc1d072179c92ce01655db0272aa598/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=4b40bc85cbc1d072179c92ce01655db0272aa598", "patch": "@@ -1,94 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The Rust prelude\n-//!\n-//! Because `std` is required by most serious Rust software, it is\n-//! imported at the topmost level of every crate by default, as if the\n-//! first line of each crate was\n-//!\n-//! ```ignore\n-//! extern crate std;\n-//! ```\n-//!\n-//! This means that the contents of std can be accessed from any context\n-//! with the `std::` path prefix, as in `use std::vec`, `use std::task::spawn`,\n-//! etc.\n-//!\n-//! Additionally, `std` contains a `prelude` module that reexports many of the\n-//! most common traits, types and functions. The contents of the prelude are\n-//! imported into every *module* by default.  Implicitly, all modules behave as if\n-//! they contained the following prologue:\n-//!\n-//! ```ignore\n-//! use std::prelude::*;\n-//! ```\n-//!\n-//! The prelude is primarily concerned with exporting *traits* that are so\n-//! pervasive that it would be obnoxious to import for every use, particularly\n-//! those that define methods on primitive types. It does include a few\n-//! particularly useful standalone functions, like `from_str`, `range`, and\n-//! `drop`, `spawn`, and `channel`.\n-\n-#![experimental]\n-\n-// Reexported core operators\n-#[doc(no_inline)] pub use kinds::{Copy, Send, Sized, Sync};\n-#[doc(no_inline)] pub use ops::{Add, Sub, Mul, Div, Rem, Neg, Not};\n-#[doc(no_inline)] pub use ops::{BitAnd, BitOr, BitXor};\n-#[doc(no_inline)] pub use ops::{Drop, Deref, DerefMut};\n-#[doc(no_inline)] pub use ops::{Shl, Shr};\n-#[doc(no_inline)] pub use ops::{Index, IndexMut};\n-#[doc(no_inline)] pub use ops::{Slice, SliceMut};\n-#[doc(no_inline)] pub use ops::{Fn, FnMut, FnOnce};\n-\n-// Reexported functions\n-#[doc(no_inline)] pub use iter::range;\n-#[doc(no_inline)] pub use mem::drop;\n-#[doc(no_inline)] pub use str::from_str;\n-\n-// Reexported types and traits\n-\n-#[doc(no_inline)] pub use borrow::IntoCow;\n-#[doc(no_inline)] pub use c_str::ToCStr;\n-#[doc(no_inline)] pub use char::{Char, UnicodeChar};\n-#[doc(no_inline)] pub use clone::Clone;\n-#[doc(no_inline)] pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n-#[doc(no_inline)] pub use cmp::{Ordering, Equiv};\n-#[doc(no_inline)] pub use cmp::Ordering::{Less, Equal, Greater};\n-#[doc(no_inline)] pub use iter::{FromIterator, Extend, ExactSizeIterator};\n-#[doc(no_inline)] pub use iter::{Iterator, IteratorExt, DoubleEndedIterator};\n-#[doc(no_inline)] pub use iter::{DoubleEndedIteratorExt, CloneIteratorExt};\n-#[doc(no_inline)] pub use iter::{RandomAccessIterator, IteratorCloneExt, IteratorPairExt};\n-#[doc(no_inline)] pub use iter::{IteratorOrdExt, MutableDoubleEndedIterator};\n-#[doc(no_inline)] pub use num::{ToPrimitive, FromPrimitive};\n-#[doc(no_inline)] pub use boxed::Box;\n-#[doc(no_inline)] pub use option::Option;\n-#[doc(no_inline)] pub use option::Option::{Some, None};\n-#[doc(no_inline)] pub use path::{GenericPath, Path, PosixPath, WindowsPath};\n-#[doc(no_inline)] pub use ptr::{PtrExt, MutPtrExt};\n-#[doc(no_inline)] pub use result::Result;\n-#[doc(no_inline)] pub use result::Result::{Ok, Err};\n-#[doc(no_inline)] pub use io::{Buffer, Writer, Reader, Seek, BufferPrelude};\n-#[doc(no_inline)] pub use core::prelude::{Tuple1, Tuple2, Tuple3, Tuple4};\n-#[doc(no_inline)] pub use core::prelude::{Tuple5, Tuple6, Tuple7, Tuple8};\n-#[doc(no_inline)] pub use core::prelude::{Tuple9, Tuple10, Tuple11, Tuple12};\n-#[doc(no_inline)] pub use str::{Str, StrExt};\n-#[doc(no_inline)] pub use slice::AsSlice;\n-#[doc(no_inline)] pub use slice::{SliceConcatExt, PartialEqSliceExt};\n-#[doc(no_inline)] pub use slice::{CloneSliceExt, OrdSliceExt, SliceExt};\n-#[doc(no_inline)] pub use slice::{BoxedSliceExt};\n-#[doc(no_inline)] pub use string::{IntoString, String, ToString};\n-#[doc(no_inline)] pub use vec::Vec;\n-\n-// Reexported runtime types\n-#[doc(no_inline)] pub use comm::{sync_channel, channel};\n-#[doc(no_inline)] pub use comm::{SyncSender, Sender, Receiver};\n-#[doc(no_inline)] pub use task::spawn;"}, {"sha": "da945b4c9fa084673605af4e30391c99d64cdd64", "filename": "src/libstd/prelude/mod.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fmod.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The Rust prelude\n+//!\n+//! Because `std` is required by most serious Rust software, it is\n+//! imported at the topmost level of every crate by default, as if the\n+//! first line of each crate was\n+//!\n+//! ```ignore\n+//! extern crate std;\n+//! ```\n+//!\n+//! This means that the contents of std can be accessed from any context\n+//! with the `std::` path prefix, as in `use std::vec`, `use std::task::spawn`,\n+//! etc.\n+//!\n+//! Additionally, `std` contains a `prelude` module that reexports many of the\n+//! most common traits, types and functions. The contents of the prelude are\n+//! imported into every *module* by default.  Implicitly, all modules behave as if\n+//! they contained the following prologue:\n+//!\n+//! ```ignore\n+//! use std::prelude::v1::*;\n+//! ```\n+//!\n+//! The prelude is primarily concerned with exporting *traits* that are so\n+//! pervasive that it would be obnoxious to import for every use, particularly\n+//! those that define methods on primitive types.\n+\n+#[cfg(stage0)]\n+pub use self::v1::*;\n+\n+#[stable]\n+pub mod v1;"}, {"sha": "cb5dfafb4a12380dbfb24f047d091811c11f2894", "filename": "src/libstd/prelude/v1.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The first version of the prelude of the standard library.\n+\n+#![stable]\n+\n+// Reexported core operators\n+#[stable] #[doc(no_inline)] pub use kinds::{Copy, Send, Sized, Sync};\n+#[stable] #[doc(no_inline)] pub use ops::{Drop, Fn, FnMut, FnOnce};\n+\n+// Reexported functions\n+#[stable] #[doc(no_inline)] pub use mem::drop;\n+\n+// Reexported types and traits\n+\n+#[stable] #[doc(no_inline)] pub use boxed::Box;\n+#[stable] #[doc(no_inline)] pub use char::{Char, UnicodeChar};\n+#[stable] #[doc(no_inline)] pub use clone::Clone;\n+#[stable] #[doc(no_inline)] pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n+#[stable] #[doc(no_inline)] pub use iter::CloneIteratorExt;\n+#[stable] #[doc(no_inline)] pub use iter::DoubleEndedIterator;\n+#[stable] #[doc(no_inline)] pub use iter::DoubleEndedIteratorExt;\n+#[stable] #[doc(no_inline)] pub use iter::ExactSizeIterator;\n+#[stable] #[doc(no_inline)] pub use iter::{Iterator, IteratorExt, Extend};\n+#[stable] #[doc(no_inline)] pub use iter::{IteratorCloneExt, IteratorOrdExt};\n+#[stable] #[doc(no_inline)] pub use iter::IteratorPairExt;\n+#[stable] #[doc(no_inline)] pub use option::Option::{mod, Some, None};\n+#[stable] #[doc(no_inline)] pub use ptr::{PtrExt, MutPtrExt};\n+#[stable] #[doc(no_inline)] pub use result::Result::{mod, Ok, Err};\n+#[stable] #[doc(no_inline)] pub use slice::AsSlice;\n+#[stable] #[doc(no_inline)] pub use slice::{SliceExt, SliceConcatExt};\n+#[stable] #[doc(no_inline)] pub use str::{Str, StrExt};\n+#[stable] #[doc(no_inline)] pub use string::{String, ToString};\n+#[stable] #[doc(no_inline)] pub use vec::Vec;\n+\n+// NB: remove when path reform lands\n+#[doc(no_inline)] pub use path::{Path, GenericPath};\n+// NB: remove when I/O reform lands\n+#[doc(no_inline)] pub use io::{Buffer, Writer, Reader, Seek, BufferPrelude};\n+// NB: remove when range syntax lands\n+#[doc(no_inline)] pub use iter::range;"}, {"sha": "86b8bfc73709d6998f722d098b85fb3cf36752cc", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -419,7 +419,7 @@ pub fn sample<T, I: Iterator<T>, R: Rng>(rng: &mut R,\n \n #[cfg(test)]\n mod test {\n-    use prelude::*;\n+    use prelude::v1::*;\n     use super::{Rng, thread_rng, random, SeedableRng, StdRng, sample};\n     use iter::order;\n \n@@ -615,7 +615,7 @@ static RAND_BENCH_N: u64 = 100;\n #[cfg(test)]\n mod bench {\n     extern crate test;\n-    use prelude::*;\n+    use prelude::v1::*;\n \n     use self::test::Bencher;\n     use super::{XorShiftRng, StdRng, IsaacRng, Isaac64Rng, Rng, RAND_BENCH_N};"}, {"sha": "9f3ac84afff514b33e622dc69f31c47e0d6d634b", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -84,10 +84,10 @@ mod imp {\n     #[cfg(all(target_os = \"linux\",\n               any(target_arch = \"x86_64\", target_arch = \"x86\", target_arch = \"arm\")))]\n     fn is_getrandom_available() -> bool {\n-        use sync::atomic::{AtomicBool, INIT_ATOMIC_BOOL, Relaxed};\n+        use sync::atomic::{AtomicBool, ATOMIC_BOOL_INIT, Relaxed};\n \n-        static GETRANDOM_CHECKED: AtomicBool = INIT_ATOMIC_BOOL;\n-        static GETRANDOM_AVAILABLE: AtomicBool = INIT_ATOMIC_BOOL;\n+        static GETRANDOM_CHECKED: AtomicBool = ATOMIC_BOOL_INIT;\n+        static GETRANDOM_AVAILABLE: AtomicBool = ATOMIC_BOOL_INIT;\n \n         if !GETRANDOM_CHECKED.load(Relaxed) {\n             let mut buf: [u8; 0] = [];\n@@ -338,10 +338,11 @@ mod imp {\n \n #[cfg(test)]\n mod test {\n-    use prelude::*;\n+    use prelude::v1::*;\n \n-    use super::OsRng;\n+    use sync::mpsc::channel;\n     use rand::Rng;\n+    use super::OsRng;\n     use thread::Thread;\n \n     #[test]\n@@ -365,7 +366,7 @@ mod test {\n \n             Thread::spawn(move|| {\n                 // wait until all the tasks are ready to go.\n-                rx.recv();\n+                rx.recv().unwrap();\n \n                 // deschedule to attempt to interleave things as much\n                 // as possible (XXX: is this a good test?)\n@@ -386,7 +387,7 @@ mod test {\n \n         // start all the tasks\n         for tx in txs.iter() {\n-            tx.send(())\n+            tx.send(()).unwrap();\n         }\n     }\n }"}, {"sha": "48d7f2e7854da0421270185094414ab2a661fc87", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -74,7 +74,7 @@ impl<R: Reader> Rng for ReaderRng<R> {\n \n #[cfg(test)]\n mod test {\n-    use prelude::*;\n+    use prelude::v1::*;\n \n     use super::ReaderRng;\n     use io::MemReader;"}, {"sha": "4734a39c8354257a6fa21ed236160c8f42b964e5", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -44,7 +44,7 @@ pub fn clone() -> Option<Vec<Vec<u8>>> { imp::clone() }\n           target_os = \"freebsd\",\n           target_os = \"dragonfly\"))]\n mod imp {\n-    use prelude::*;\n+    use prelude::v1::*;\n \n     use mem;\n     use slice;\n@@ -107,7 +107,7 @@ mod imp {\n \n     #[cfg(test)]\n     mod tests {\n-        use prelude::*;\n+        use prelude::v1::*;\n         use finally::Finally;\n \n         use super::*;"}, {"sha": "ae405e9400b374a1ced5166dc320186008bf1b04", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -12,7 +12,7 @@\n \n #![allow(non_camel_case_types)]\n \n-use prelude::*;\n+use prelude::v1::*;\n \n use os;\n use sync::atomic;\n@@ -22,7 +22,7 @@ pub use sys::backtrace::write;\n // For now logging is turned off by default, and this function checks to see\n // whether the magical environment variable is present to see if it's turned on.\n pub fn log_enabled() -> bool {\n-    static ENABLED: atomic::AtomicInt = atomic::INIT_ATOMIC_INT;\n+    static ENABLED: atomic::AtomicInt = atomic::ATOMIC_INT_INIT;\n     match ENABLED.load(atomic::SeqCst) {\n         1 => return false,\n         2 => return true,\n@@ -39,7 +39,7 @@ pub fn log_enabled() -> bool {\n \n #[cfg(test)]\n mod test {\n-    use prelude::*;\n+    use prelude::v1::*;\n     use sys_common;\n     macro_rules! t { ($a:expr, $b:expr) => ({\n         let mut m = Vec::new();"}, {"sha": "88bdb29caecadc94b7e386cd02979ed039fee701", "filename": "src/libstd/rt/exclusive.rs", "status": "removed", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/4b40bc85cbc1d072179c92ce01655db0272aa598/src%2Flibstd%2Frt%2Fexclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b40bc85cbc1d072179c92ce01655db0272aa598/src%2Flibstd%2Frt%2Fexclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fexclusive.rs?ref=4b40bc85cbc1d072179c92ce01655db0272aa598", "patch": "@@ -1,119 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use core::prelude::*;\n-\n-use cell::UnsafeCell;\n-use rt::mutex;\n-\n-/// An OS mutex over some data.\n-///\n-/// This is not a safe primitive to use, it is unaware of the libgreen\n-/// scheduler, as well as being easily susceptible to misuse due to the usage of\n-/// the inner NativeMutex.\n-///\n-/// > **Note**: This type is not recommended for general use. The mutex provided\n-/// >           as part of `libsync` should almost always be favored.\n-pub struct Exclusive<T> {\n-    lock: mutex::NativeMutex,\n-    data: UnsafeCell<T>,\n-}\n-\n-unsafe impl<T:Send> Send for Exclusive<T> { }\n-\n-unsafe impl<T:Send> Sync for Exclusive<T> { }\n-\n-/// An RAII guard returned via `lock`\n-pub struct ExclusiveGuard<'a, T:'a> {\n-    // FIXME #12808: strange name to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n-    _data: &'a mut T,\n-    _guard: mutex::LockGuard<'a>,\n-}\n-\n-impl<T: Send> Exclusive<T> {\n-    /// Creates a new `Exclusive` which will protect the data provided.\n-    pub fn new(user_data: T) -> Exclusive<T> {\n-        Exclusive {\n-            lock: unsafe { mutex::NativeMutex::new() },\n-            data: UnsafeCell::new(user_data),\n-        }\n-    }\n-\n-    /// Acquires this lock, returning a guard which the data is accessed through\n-    /// and from which that lock will be unlocked.\n-    ///\n-    /// This method is unsafe due to many of the same reasons that the\n-    /// NativeMutex itself is unsafe.\n-    pub unsafe fn lock<'a>(&'a self) -> ExclusiveGuard<'a, T> {\n-        let guard = self.lock.lock();\n-        let data = &mut *self.data.get();\n-\n-        ExclusiveGuard {\n-            _data: data,\n-            _guard: guard,\n-        }\n-    }\n-}\n-\n-impl<'a, T: Send> ExclusiveGuard<'a, T> {\n-    // The unsafety here should be ok because our loan guarantees that the lock\n-    // itself is not moving\n-    pub fn signal(&self) {\n-        unsafe { self._guard.signal() }\n-    }\n-    pub fn wait(&self) {\n-        unsafe { self._guard.wait() }\n-    }\n-}\n-\n-impl<'a, T: Send> Deref<T> for ExclusiveGuard<'a, T> {\n-    fn deref(&self) -> &T { &*self._data }\n-}\n-impl<'a, T: Send> DerefMut<T> for ExclusiveGuard<'a, T> {\n-    fn deref_mut(&mut self) -> &mut T { &mut *self._data }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use sync::Arc;\n-    use super::Exclusive;\n-    use task;\n-\n-    #[test]\n-    fn exclusive_new_arc() {\n-        unsafe {\n-            let mut futures = Vec::new();\n-\n-            let num_tasks = 10;\n-            let count = 10;\n-\n-            let total = Arc::new(Exclusive::new(box 0));\n-\n-            for _ in range(0u, num_tasks) {\n-                let total = total.clone();\n-                let (tx, rx) = channel();\n-                futures.push(rx);\n-\n-                task::spawn(move || {\n-                    for _ in range(0u, count) {\n-                        **total.lock() += 1;\n-                    }\n-                    tx.send(());\n-                });\n-            };\n-\n-            for f in futures.iter_mut() { f.recv() }\n-\n-            assert_eq!(**total.lock(), num_tasks * count);\n-        }\n-    }\n-}"}, {"sha": "68aaa1b3ae55dc38e239853dfcb10ab5e93315c9", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -23,14 +23,10 @@\n \n #![allow(dead_code)]\n \n-use os;\n-use thunk::Thunk;\n use kinds::Send;\n-use thread::Thread;\n use ops::FnOnce;\n use sys;\n-use sys_common;\n-use sys_common::thread_info::{mod, NewThread};\n+use thunk::Thunk;\n \n // Reexport some of our utilities which are expected by other crates.\n pub use self::util::{default_sched_threads, min_stack, running_on_valgrind};\n@@ -65,9 +61,14 @@ const OS_DEFAULT_STACK_ESTIMATE: uint = 2 * (1 << 20);\n #[cfg(not(test))]\n #[lang = \"start\"]\n fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n+    use prelude::v1::*;\n+\n     use mem;\n-    use prelude::*;\n+    use os;\n     use rt;\n+    use sys_common::thread_info::{mod, NewThread};\n+    use sys_common;\n+    use thread::Thread;\n \n     let something_around_the_top_of_the_stack = 1;\n     let addr = &something_around_the_top_of_the_stack as *const int;"}, {"sha": "41e91d1b6ef9be4fea4719e858efcf8a9aed1767", "filename": "src/libstd/rt/task.rs", "status": "removed", "additions": 0, "deletions": 554, "changes": 554, "blob_url": "https://github.com/rust-lang/rust/blob/4b40bc85cbc1d072179c92ce01655db0272aa598/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b40bc85cbc1d072179c92ce01655db0272aa598/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=4b40bc85cbc1d072179c92ce01655db0272aa598", "patch": "@@ -1,554 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Language-level runtime services that should reasonably expected\n-//! to be available 'everywhere'. Unwinding, local storage, and logging.\n-//! Even a 'freestanding' Rust would likely want to implement this.\n-\n-pub use self::BlockedTask::*;\n-use self::TaskState::*;\n-\n-use any::Any;\n-use boxed::Box;\n-use sync::Arc;\n-use sync::atomic::{AtomicUint, SeqCst};\n-use iter::{IteratorExt, Take};\n-use kinds::marker;\n-use mem;\n-use ops::FnMut;\n-use core::prelude::{Clone, Drop, Err, Iterator, None, Ok, Option, Send, Some};\n-use core::prelude::{drop};\n-use str::SendStr;\n-use thunk::Thunk;\n-\n-use rt;\n-use rt::mutex::NativeMutex;\n-use rt::local::Local;\n-use rt::thread::{mod, Thread};\n-use sys_common::stack;\n-use rt::unwind;\n-use rt::unwind::Unwinder;\n-\n-/// State associated with Rust threads\n-///\n-/// This structure is currently undergoing major changes, and is\n-/// likely to be move/be merged with a `Thread` structure.\n-pub struct Task {\n-    pub unwinder: Unwinder,\n-    pub death: Death,\n-    pub name: Option<SendStr>,\n-\n-    state: TaskState,\n-    lock: NativeMutex,       // native synchronization\n-    awoken: bool,            // used to prevent spurious wakeups\n-\n-    // This field holds the known bounds of the stack in (lo, hi) form. Not all\n-    // native threads necessarily know their precise bounds, hence this is\n-    // optional.\n-    stack_bounds: (uint, uint),\n-\n-    stack_guard: uint\n-}\n-\n-// Once a thread has entered the `Armed` state it must be destroyed via `drop`,\n-// and no other method. This state is used to track this transition.\n-#[deriving(PartialEq)]\n-enum TaskState {\n-    New,\n-    Armed,\n-    Destroyed,\n-}\n-\n-pub struct TaskOpts {\n-    /// Invoke this procedure with the result of the thread when it finishes.\n-    pub on_exit: Option<Thunk<Result>>,\n-    /// A name for the thread-to-be, for identification in panic messages\n-    pub name: Option<SendStr>,\n-    /// The size of the stack for the spawned thread\n-    pub stack_size: Option<uint>,\n-}\n-\n-/// Indicates the manner in which a thread exited.\n-///\n-/// A thread that completes without panicking is considered to exit successfully.\n-///\n-/// If you wish for this result's delivery to block until all\n-/// children threads complete, recommend using a result future.\n-pub type Result = ::core::result::Result<(), Box<Any + Send>>;\n-\n-/// A handle to a blocked thread. Usually this means having the Box<Task>\n-/// pointer by ownership, but if the thread is killable, a killer can steal it\n-/// at any time.\n-pub enum BlockedTask {\n-    Owned(Box<Task>),\n-    Shared(Arc<AtomicUint>),\n-}\n-\n-/// Per-thread state related to thread death, killing, panic, etc.\n-pub struct Death {\n-    pub on_exit: Option<Thunk<Result>>,\n-}\n-\n-pub struct BlockedTasks {\n-    inner: Arc<AtomicUint>,\n-}\n-\n-impl Task {\n-    /// Creates a new uninitialized thread.\n-    pub fn new(stack_bounds: Option<(uint, uint)>, stack_guard: Option<uint>) -> Task {\n-        Task {\n-            unwinder: Unwinder::new(),\n-            death: Death::new(),\n-            state: New,\n-            name: None,\n-            lock: unsafe { NativeMutex::new() },\n-            awoken: false,\n-            // these *should* get overwritten\n-            stack_bounds: stack_bounds.unwrap_or((0, 0)),\n-            stack_guard: stack_guard.unwrap_or(0)\n-        }\n-    }\n-\n-    pub fn spawn<F>(opts: TaskOpts, f: F)\n-        where F : FnOnce(), F : Send\n-    {\n-        Task::spawn_thunk(opts, Thunk::new(f))\n-    }\n-\n-    fn spawn_thunk(opts: TaskOpts, f: Thunk) {\n-        let TaskOpts { name, stack_size, on_exit } = opts;\n-\n-        let mut task = box Task::new(None, None);\n-        task.name = name;\n-        task.death.on_exit = on_exit;\n-\n-        let stack = stack_size.unwrap_or(rt::min_stack());\n-\n-        // Spawning a new OS thread guarantees that __morestack will never get\n-        // triggered, but we must manually set up the actual stack bounds once\n-        // this function starts executing. This raises the lower limit by a bit\n-        // because by the time that this function is executing we've already\n-        // consumed at least a little bit of stack (we don't know the exact byte\n-        // address at which our stack started).\n-        Thread::spawn_stack(stack, move|| {\n-            let something_around_the_top_of_the_stack = 1;\n-            let addr = &something_around_the_top_of_the_stack as *const int;\n-            let my_stack = addr as uint;\n-            unsafe {\n-                stack::record_os_managed_stack_bounds(my_stack - stack + 1024,\n-                                                      my_stack);\n-            }\n-            task.stack_guard = thread::current_guard_page();\n-            task.stack_bounds = (my_stack - stack + 1024, my_stack);\n-\n-            let mut f = Some(f);\n-            drop(task.run(|| { f.take().unwrap().invoke(()) }).destroy());\n-        })\n-    }\n-\n-    /// Consumes ownership of a thread, runs some code, and returns the thread back.\n-    ///\n-    /// This function can be used as an emulated \"try/catch\" to interoperate\n-    /// with the rust runtime at the outermost boundary. It is not possible to\n-    /// use this function in a nested fashion (a try/catch inside of another\n-    /// try/catch). Invoking this function is quite cheap.\n-    ///\n-    /// If the closure `f` succeeds, then the returned thread can be used again\n-    /// for another invocation of `run`. If the closure `f` panics then `self`\n-    /// will be internally destroyed along with all of the other associated\n-    /// resources of this thread. The `on_exit` callback is invoked with the\n-    /// cause of panic (not returned here). This can be discovered by querying\n-    /// `is_destroyed()`.\n-    ///\n-    /// Note that it is possible to view partial execution of the closure `f`\n-    /// because it is not guaranteed to run to completion, but this function is\n-    /// guaranteed to return if it panicks. Care should be taken to ensure that\n-    /// stack references made by `f` are handled appropriately.\n-    ///\n-    /// It is invalid to call this function with a thread that has been previously\n-    /// destroyed via a failed call to `run`.\n-    pub fn run<F>(mut self: Box<Task>, f: F) -> Box<Task> where F: FnOnce() {\n-        assert!(!self.is_destroyed(), \"cannot re-use a destroyed thread\");\n-\n-        // First, make sure that no one else is in TLS. This does not allow\n-        // recursive invocations of run(). If there's no one else, then\n-        // relinquish ownership of ourselves back into TLS.\n-        if Local::exists(None::<Task>) {\n-            panic!(\"cannot run a thread recursively inside another\");\n-        }\n-        self.state = Armed;\n-        Local::put(self);\n-\n-        // There are two primary reasons that general try/catch is unsafe. The\n-        // first is that we do not support nested try/catch. The above check for\n-        // an existing thread in TLS is sufficient for this invariant to be\n-        // upheld. The second is that unwinding while unwinding is not defined.\n-        // We take care of that by having an 'unwinding' flag in the thread\n-        // itself. For these reasons, this unsafety should be ok.\n-        let result = unsafe { unwind::try(f) };\n-\n-        // After running the closure given return the thread back out if it ran\n-        // successfully, or clean up the thread if it panicked.\n-        let task: Box<Task> = Local::take();\n-        match result {\n-            Ok(()) => task,\n-            Err(cause) => { task.cleanup(Err(cause)) }\n-        }\n-    }\n-\n-    /// Destroy all associated resources of this thread.\n-    ///\n-    /// This function will perform any necessary clean up to prepare the thread\n-    /// for destruction. It is required that this is called before a `Task`\n-    /// falls out of scope.\n-    ///\n-    /// The returned thread cannot be used for running any more code, but it may\n-    /// be used to extract the runtime as necessary.\n-    pub fn destroy(self: Box<Task>) -> Box<Task> {\n-        if self.is_destroyed() {\n-            self\n-        } else {\n-            self.cleanup(Ok(()))\n-        }\n-    }\n-\n-    /// Cleans up a thread, processing the result of the thread as appropriate.\n-    ///\n-    /// This function consumes ownership of the thread, deallocating it once it's\n-    /// done being processed. It is assumed that TLD and the local heap have\n-    /// already been destroyed and/or annihilated.\n-    fn cleanup(mut self: Box<Task>, result: Result) -> Box<Task> {\n-        // After taking care of the data above, we need to transmit the result\n-        // of this thread.\n-        let what_to_do = self.death.on_exit.take();\n-        Local::put(self);\n-\n-        // FIXME: this is running in a seriously constrained context. If this\n-        //        allocates TLD then it will likely abort the runtime. Similarly,\n-        //        if this panics, this will also likely abort the runtime.\n-        //\n-        //        This closure is currently limited to a channel send via the\n-        //        standard library's thread interface, but this needs\n-        //        reconsideration to whether it's a reasonable thing to let a\n-        //        thread to do or not.\n-        match what_to_do {\n-            Some(f) => { f.invoke(result) }\n-            None => { drop(result) }\n-        }\n-\n-        // Now that we're done, we remove the thread from TLS and flag it for\n-        // destruction.\n-        let mut task: Box<Task> = Local::take();\n-        task.state = Destroyed;\n-        return task;\n-    }\n-\n-    /// Queries whether this can be destroyed or not.\n-    pub fn is_destroyed(&self) -> bool { self.state == Destroyed }\n-\n-    /// Deschedules the current thread, invoking `f` `amt` times. It is not\n-    /// recommended to use this function directly, but rather communication\n-    /// primitives in `std::comm` should be used.\n-    //\n-    // This function gets a little interesting. There are a few safety and\n-    // ownership violations going on here, but this is all done in the name of\n-    // shared state. Additionally, all of the violations are protected with a\n-    // mutex, so in theory there are no races.\n-    //\n-    // The first thing we need to do is to get a pointer to the thread's internal\n-    // mutex. This address will not be changing (because the thread is allocated\n-    // on the heap). We must have this handle separately because the thread will\n-    // have its ownership transferred to the given closure. We're guaranteed,\n-    // however, that this memory will remain valid because *this* is the current\n-    // thread's execution thread.\n-    //\n-    // The next weird part is where ownership of the thread actually goes. We\n-    // relinquish it to the `f` blocking function, but upon returning this\n-    // function needs to replace the thread back in TLS. There is no communication\n-    // from the wakeup thread back to this thread about the thread pointer, and\n-    // there's really no need to. In order to get around this, we cast the thread\n-    // to a `uint` which is then used at the end of this function to cast back\n-    // to a `Box<Task>` object. Naturally, this looks like it violates\n-    // ownership semantics in that there may be two `Box<Task>` objects.\n-    //\n-    // The fun part is that the wakeup half of this implementation knows to\n-    // \"forget\" the thread on the other end. This means that the awakening half of\n-    // things silently relinquishes ownership back to this thread, but not in a\n-    // way that the compiler can understand. The thread's memory is always valid\n-    // for both threads because these operations are all done inside of a mutex.\n-    //\n-    // You'll also find that if blocking fails (the `f` function hands the\n-    // BlockedTask back to us), we will `mem::forget` the handles. The\n-    // reasoning for this is the same logic as above in that the thread silently\n-    // transfers ownership via the `uint`, not through normal compiler\n-    // semantics.\n-    //\n-    // On a mildly unrelated note, it should also be pointed out that OS\n-    // condition variables are susceptible to spurious wakeups, which we need to\n-    // be ready for. In order to accommodate for this fact, we have an extra\n-    // `awoken` field which indicates whether we were actually woken up via some\n-    // invocation of `reawaken`. This flag is only ever accessed inside the\n-    // lock, so there's no need to make it atomic.\n-    pub fn deschedule<F>(mut self: Box<Task>, times: uint, mut f: F) where\n-        F: FnMut(BlockedTask) -> ::core::result::Result<(), BlockedTask>,\n-    {\n-        unsafe {\n-            let me = &mut *self as *mut Task;\n-            let task = BlockedTask::block(self);\n-\n-            if times == 1 {\n-                let guard = (*me).lock.lock();\n-                (*me).awoken = false;\n-                match f(task) {\n-                    Ok(()) => {\n-                        while !(*me).awoken {\n-                            guard.wait();\n-                        }\n-                    }\n-                    Err(task) => { mem::forget(task.wake()); }\n-                }\n-            } else {\n-                let iter = task.make_selectable(times);\n-                let guard = (*me).lock.lock();\n-                (*me).awoken = false;\n-\n-                // Apply the given closure to all of the \"selectable threads\",\n-                // bailing on the first one that produces an error. Note that\n-                // care must be taken such that when an error is occurred, we\n-                // may not own the thread, so we may still have to wait for the\n-                // thread to become available. In other words, if thread.wake()\n-                // returns `None`, then someone else has ownership and we must\n-                // wait for their signal.\n-                match iter.map(f).filter_map(|a| a.err()).next() {\n-                    None => {}\n-                    Some(task) => {\n-                        match task.wake() {\n-                            Some(task) => {\n-                                mem::forget(task);\n-                                (*me).awoken = true;\n-                            }\n-                            None => {}\n-                        }\n-                    }\n-                }\n-                while !(*me).awoken {\n-                    guard.wait();\n-                }\n-            }\n-            // put the thread back in TLS, and everything is as it once was.\n-            Local::put(mem::transmute(me));\n-        }\n-    }\n-\n-    /// Wakes up a previously blocked thread. This function can only be\n-    /// called on threads that were previously blocked in `deschedule`.\n-    //\n-    // See the comments on `deschedule` for why the thread is forgotten here, and\n-    // why it's valid to do so.\n-    pub fn reawaken(mut self: Box<Task>) {\n-        unsafe {\n-            let me = &mut *self as *mut Task;\n-            mem::forget(self);\n-            let guard = (*me).lock.lock();\n-            (*me).awoken = true;\n-            guard.signal();\n-        }\n-    }\n-\n-    /// Yields control of this thread to another thread. This function will\n-    /// eventually return, but possibly not immediately. This is used as an\n-    /// opportunity to allow other threads a chance to run.\n-    pub fn yield_now() {\n-        Thread::yield_now();\n-    }\n-\n-    /// Returns the stack bounds for this thread in (lo, hi) format. The stack\n-    /// bounds may not be known for all threads, so the return value may be\n-    /// `None`.\n-    pub fn stack_bounds(&self) -> (uint, uint) {\n-        self.stack_bounds\n-    }\n-\n-    /// Returns the stack guard for this thread, if known.\n-    pub fn stack_guard(&self) -> Option<uint> {\n-        if self.stack_guard != 0 {\n-            Some(self.stack_guard)\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Consume this thread, flagging it as a candidate for destruction.\n-    ///\n-    /// This function is required to be invoked to destroy a thread. A thread\n-    /// destroyed through a normal drop will abort.\n-    pub fn drop(mut self) {\n-        self.state = Destroyed;\n-    }\n-}\n-\n-impl Drop for Task {\n-    fn drop(&mut self) {\n-        rtdebug!(\"called drop for a thread: {}\", self as *mut Task as uint);\n-        rtassert!(self.state != Armed);\n-    }\n-}\n-\n-impl TaskOpts {\n-    pub fn new() -> TaskOpts {\n-        TaskOpts { on_exit: None, name: None, stack_size: None }\n-    }\n-}\n-\n-impl Iterator<BlockedTask> for BlockedTasks {\n-    fn next(&mut self) -> Option<BlockedTask> {\n-        Some(Shared(self.inner.clone()))\n-    }\n-}\n-\n-impl BlockedTask {\n-    /// Returns Some if the thread was successfully woken; None if already killed.\n-    pub fn wake(self) -> Option<Box<Task>> {\n-        match self {\n-            Owned(task) => Some(task),\n-            Shared(arc) => {\n-                match arc.swap(0, SeqCst) {\n-                    0 => None,\n-                    n => Some(unsafe { mem::transmute(n) }),\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Reawakens this thread if ownership is acquired. If finer-grained control\n-    /// is desired, use `wake` instead.\n-    pub fn reawaken(self) {\n-        self.wake().map(|t| t.reawaken());\n-    }\n-\n-    // This assertion has two flavours because the wake involves an atomic op.\n-    // In the faster version, destructors will panic dramatically instead.\n-    #[cfg(not(test))] pub fn trash(self) { }\n-    #[cfg(test)]      pub fn trash(self) { assert!(self.wake().is_none()); }\n-\n-    /// Create a blocked thread, unless the thread was already killed.\n-    pub fn block(task: Box<Task>) -> BlockedTask {\n-        Owned(task)\n-    }\n-\n-    /// Converts one blocked thread handle to a list of many handles to the same.\n-    pub fn make_selectable(self, num_handles: uint) -> Take<BlockedTasks> {\n-        let arc = match self {\n-            Owned(task) => {\n-                let flag = unsafe { AtomicUint::new(mem::transmute(task)) };\n-                Arc::new(flag)\n-            }\n-            Shared(arc) => arc.clone(),\n-        };\n-        BlockedTasks{ inner: arc }.take(num_handles)\n-    }\n-\n-    /// Convert to an unsafe uint value. Useful for storing in a pipe's state\n-    /// flag.\n-    #[inline]\n-    pub unsafe fn cast_to_uint(self) -> uint {\n-        match self {\n-            Owned(task) => {\n-                let blocked_task_ptr: uint = mem::transmute(task);\n-                rtassert!(blocked_task_ptr & 0x1 == 0);\n-                blocked_task_ptr\n-            }\n-            Shared(arc) => {\n-                let blocked_task_ptr: uint = mem::transmute(box arc);\n-                rtassert!(blocked_task_ptr & 0x1 == 0);\n-                blocked_task_ptr | 0x1\n-            }\n-        }\n-    }\n-\n-    /// Convert from an unsafe uint value. Useful for retrieving a pipe's state\n-    /// flag.\n-    #[inline]\n-    pub unsafe fn cast_from_uint(blocked_task_ptr: uint) -> BlockedTask {\n-        if blocked_task_ptr & 0x1 == 0 {\n-            Owned(mem::transmute(blocked_task_ptr))\n-        } else {\n-            let ptr: Box<Arc<AtomicUint>> =\n-                mem::transmute(blocked_task_ptr & !1);\n-            Shared(*ptr)\n-        }\n-    }\n-}\n-\n-impl Death {\n-    pub fn new() -> Death {\n-        Death { on_exit: None }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-    use prelude::*;\n-    use task;\n-    use rt::unwind;\n-\n-    #[test]\n-    fn unwind() {\n-        let result = task::try(move|| ());\n-        rtdebug!(\"trying first assert\");\n-        assert!(result.is_ok());\n-        let result = task::try(move|| -> () panic!());\n-        rtdebug!(\"trying second assert\");\n-        assert!(result.is_err());\n-    }\n-\n-    #[test]\n-    fn rng() {\n-        use rand::{StdRng, Rng};\n-        let mut r = StdRng::new().ok().unwrap();\n-        let _ = r.next_u32();\n-    }\n-\n-    #[test]\n-    fn comm_stream() {\n-        let (tx, rx) = channel();\n-        tx.send(10i);\n-        assert!(rx.recv() == 10);\n-    }\n-\n-    #[test]\n-    fn comm_shared_chan() {\n-        let (tx, rx) = channel();\n-        tx.send(10i);\n-        assert!(rx.recv() == 10);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_begin_unwind() {\n-        use rt::unwind::begin_unwind;\n-        begin_unwind(\"cause\", &(file!(), line!()))\n-    }\n-\n-    #[test]\n-    fn drop_new_task_ok() {\n-        drop(Task::new(None, None));\n-    }\n-\n-    // Thread blocking tests\n-\n-    #[test]\n-    fn block_and_wake() {\n-        let task = box Task::new(None, None);\n-        let task = BlockedTask::block(task).wake().unwrap();\n-        task.drop();\n-    }\n-}"}, {"sha": "6f6be2e111df478b7337bf0a4b4e2e1ed047fb39", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 15, "deletions": 26, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -57,7 +57,7 @@\n //!\n //! Currently Rust uses unwind runtime provided by libgcc.\n \n-use prelude::*;\n+use prelude::v1::*;\n \n use any::Any;\n use cell::Cell;\n@@ -84,15 +84,15 @@ pub type Callback = fn(msg: &(Any + Send), file: &'static str, line: uint);\n // For more information, see below.\n const MAX_CALLBACKS: uint = 16;\n static CALLBACKS: [atomic::AtomicUint; MAX_CALLBACKS] =\n-        [atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT,\n-         atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT,\n-         atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT,\n-         atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT,\n-         atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT,\n-         atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT,\n-         atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT,\n-         atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT];\n-static CALLBACK_CNT: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+        [atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT,\n+         atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT,\n+         atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT,\n+         atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT,\n+         atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT,\n+         atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT,\n+         atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT,\n+         atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT];\n+static CALLBACK_CNT: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n \n thread_local! { static PANICKING: Cell<bool> = Cell::new(false) }\n \n@@ -493,27 +493,16 @@ pub extern fn rust_begin_unwind(msg: fmt::Arguments,\n /// the actual formatting into this shared place.\n #[inline(never)] #[cold]\n pub fn begin_unwind_fmt(msg: fmt::Arguments, file_line: &(&'static str, uint)) -> ! {\n-    use fmt::FormatWriter;\n+    use fmt::Writer;\n \n     // We do two allocations here, unfortunately. But (a) they're\n     // required with the current scheme, and (b) we don't handle\n     // panic + OOM properly anyway (see comment in begin_unwind\n     // below).\n \n-    struct VecWriter<'a> { v: &'a mut Vec<u8> }\n-\n-    impl<'a> fmt::FormatWriter for VecWriter<'a> {\n-        fn write(&mut self, buf: &[u8]) -> fmt::Result {\n-            self.v.push_all(buf);\n-            Ok(())\n-        }\n-    }\n-\n-    let mut v = Vec::new();\n-    let _ = write!(&mut VecWriter { v: &mut v }, \"{}\", msg);\n-\n-    let msg = box String::from_utf8_lossy(v.as_slice()).into_owned();\n-    begin_unwind_inner(msg, file_line)\n+    let mut s = String::new();\n+    let _ = write!(&mut s, \"{}\", msg);\n+    begin_unwind_inner(box s, file_line)\n }\n \n /// This is the entry point of unwinding for panic!() and assert!().\n@@ -544,7 +533,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) ->\n     // Make sure the default failure handler is registered before we look at the\n     // callbacks.\n     static INIT: Once = ONCE_INIT;\n-    INIT.doit(|| unsafe { register(failure::on_fail); });\n+    INIT.call_once(|| unsafe { register(failure::on_fail); });\n \n     // First, invoke call the user-defined callbacks triggered on thread panic.\n     //"}, {"sha": "09859cab536202d5a5b703f77925e4ca290802af", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -10,13 +10,12 @@\n //\n // ignore-lexer-test FIXME #15677\n \n-use prelude::*;\n+use prelude::v1::*;\n \n use cmp;\n use fmt;\n use intrinsics;\n-use libc::uintptr_t;\n-use libc;\n+use libc::{mod, uintptr_t};\n use os;\n use slice;\n use str;\n@@ -47,7 +46,7 @@ pub fn limit_thread_creation_due_to_osx_and_valgrind() -> bool {\n }\n \n pub fn min_stack() -> uint {\n-    static MIN: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+    static MIN: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n     match MIN.load(atomic::SeqCst) {\n         0 => {}\n         n => return n - 1,\n@@ -96,8 +95,8 @@ pub const Stdout: Stdio = Stdio(libc::STDOUT_FILENO);\n #[allow(non_upper_case_globals)]\n pub const Stderr: Stdio = Stdio(libc::STDERR_FILENO);\n \n-impl fmt::FormatWriter for Stdio {\n-    fn write(&mut self, data: &[u8]) -> fmt::Result {\n+impl Stdio {\n+    pub fn write_bytes(&mut self, data: &[u8]) {\n         #[cfg(unix)]\n         type WriteLen = libc::size_t;\n         #[cfg(windows)]\n@@ -108,6 +107,12 @@ impl fmt::FormatWriter for Stdio {\n                         data.as_ptr() as *const libc::c_void,\n                         data.len() as WriteLen);\n         }\n+    }\n+}\n+\n+impl fmt::Writer for Stdio {\n+    fn write_str(&mut self, data: &str) -> fmt::Result {\n+        self.write_bytes(data.as_bytes());\n         Ok(()) // yes, we're lying\n     }\n }\n@@ -117,16 +122,16 @@ pub fn dumb_print(args: fmt::Arguments) {\n }\n \n pub fn abort(args: fmt::Arguments) -> ! {\n-    use fmt::FormatWriter;\n+    use fmt::Writer;\n \n     struct BufWriter<'a> {\n         buf: &'a mut [u8],\n         pos: uint,\n     }\n-    impl<'a> FormatWriter for BufWriter<'a> {\n-        fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n+    impl<'a> fmt::Writer for BufWriter<'a> {\n+        fn write_str(&mut self, bytes: &str) -> fmt::Result {\n             let left = self.buf.slice_from_mut(self.pos);\n-            let to_write = bytes[..cmp::min(bytes.len(), left.len())];\n+            let to_write = bytes.as_bytes()[..cmp::min(bytes.len(), left.len())];\n             slice::bytes::copy_memory(left, to_write);\n             self.pos += to_write.len();\n             Ok(())"}, {"sha": "d4d7607bde34c50c65df27e45904ea4dd4cf2d85", "filename": "src/libstd/sync/atomic.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fatomic.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -86,22 +86,23 @@\n //! Keep a global count of live tasks:\n //!\n //! ```\n-//! use std::sync::atomic::{AtomicUint, SeqCst, INIT_ATOMIC_UINT};\n+//! use std::sync::atomic::{AtomicUint, SeqCst, ATOMIC_UINT_INIT};\n //!\n-//! static GLOBAL_TASK_COUNT: AtomicUint = INIT_ATOMIC_UINT;\n+//! static GLOBAL_TASK_COUNT: AtomicUint = ATOMIC_UINT_INIT;\n //!\n //! let old_task_count = GLOBAL_TASK_COUNT.fetch_add(1, SeqCst);\n //! println!(\"live tasks: {}\", old_task_count + 1);\n //! ```\n \n-#![allow(deprecated)]\n+#![stable]\n \n use alloc::boxed::Box;\n use core::mem;\n use core::prelude::{Send, Drop, None, Option, Some};\n \n pub use core::atomic::{AtomicBool, AtomicInt, AtomicUint, AtomicPtr};\n pub use core::atomic::{INIT_ATOMIC_BOOL, INIT_ATOMIC_INT, INIT_ATOMIC_UINT};\n+pub use core::atomic::{ATOMIC_BOOL_INIT, ATOMIC_INT_INIT, ATOMIC_UINT_INIT};\n pub use core::atomic::fence;\n pub use core::atomic::Ordering::{mod, Relaxed, Release, Acquire, AcqRel, SeqCst};\n \n@@ -116,6 +117,7 @@ pub struct AtomicOption<T> {\n     p: AtomicUint,\n }\n \n+#[allow(deprecated)]\n impl<T: Send> AtomicOption<T> {\n     /// Create a new `AtomicOption`\n     pub fn new(p: Box<T>) -> AtomicOption<T> {\n@@ -180,7 +182,7 @@ impl<T: Send> Drop for AtomicOption<T> {\n \n #[cfg(test)]\n mod test {\n-    use prelude::{Some, None};\n+    use prelude::v1::*;\n     use super::*;\n \n     #[test]"}, {"sha": "bf5da3e7cbae018b18381d6899fd894fcee6a379", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 45, "deletions": 19, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use kinds::{Send, Sync};\n use sync::{Mutex, Condvar};\n \n /// A barrier enables multiple tasks to synchronize the beginning\n@@ -30,29 +29,32 @@ use sync::{Mutex, Condvar};\n ///     }).detach();\n /// }\n /// ```\n+#[stable]\n pub struct Barrier {\n     lock: Mutex<BarrierState>,\n     cvar: Condvar,\n     num_threads: uint,\n }\n \n-unsafe impl Send for Barrier {}\n-unsafe impl Sync for Barrier {}\n-\n // The inner state of a double barrier\n struct BarrierState {\n     count: uint,\n     generation_id: uint,\n }\n \n-unsafe impl Send for BarrierState {}\n-unsafe impl Sync for BarrierState {}\n+/// A result returned from wait.\n+///\n+/// Currently this opaque structure only has one method, `.is_leader()`. Only\n+/// one thread will receive a result that will return `true` from this function.\n+#[allow(missing_copy_implementations)]\n+pub struct BarrierWaitResult(bool);\n \n impl Barrier {\n     /// Create a new barrier that can block a given number of threads.\n     ///\n     /// A barrier will block `n`-1 threads which call `wait` and then wake up\n     /// all threads at once when the `n`th thread calls `wait`.\n+    #[stable]\n     pub fn new(n: uint) -> Barrier {\n         Barrier {\n             lock: Mutex::new(BarrierState {\n@@ -68,7 +70,13 @@ impl Barrier {\n     ///\n     /// Barriers are re-usable after all threads have rendezvoused once, and can\n     /// be used continuously.\n-    pub fn wait(&self) {\n+    ///\n+    /// A single (arbitrary) thread will receive a `BarrierWaitResult` that\n+    /// returns `true` from `is_leader` when returning from this function, and\n+    /// all other threads will receive a result that will return `false` from\n+    /// `is_leader`\n+    #[stable]\n+    pub fn wait(&self) -> BarrierWaitResult {\n         let mut lock = self.lock.lock().unwrap();\n         let local_gen = lock.generation_id;\n         lock.count += 1;\n@@ -79,46 +87,64 @@ impl Barrier {\n                   lock.count < self.num_threads {\n                 lock = self.cvar.wait(lock).unwrap();\n             }\n+            BarrierWaitResult(false)\n         } else {\n             lock.count = 0;\n             lock.generation_id += 1;\n             self.cvar.notify_all();\n+            BarrierWaitResult(true)\n         }\n     }\n }\n \n+impl BarrierWaitResult {\n+    /// Return whether this thread from `wait` is the \"leader thread\".\n+    ///\n+    /// Only one thread will have `true` returned from their result, all other\n+    /// threads will have `false` returned.\n+    #[stable]\n+    pub fn is_leader(&self) -> bool { self.0 }\n+}\n+\n #[cfg(test)]\n mod tests {\n-    use prelude::*;\n+    use prelude::v1::*;\n \n     use sync::{Arc, Barrier};\n-    use comm::Empty;\n+    use sync::mpsc::{channel, TryRecvError};\n+    use thread::Thread;\n \n     #[test]\n     fn test_barrier() {\n-        let barrier = Arc::new(Barrier::new(10));\n+        const N: uint = 10;\n+\n+        let barrier = Arc::new(Barrier::new(N));\n         let (tx, rx) = channel();\n \n-        for _ in range(0u, 9) {\n+        for _ in range(0u, N - 1) {\n             let c = barrier.clone();\n             let tx = tx.clone();\n-            spawn(move|| {\n-                c.wait();\n-                tx.send(true);\n-            });\n+            Thread::spawn(move|| {\n+                tx.send(c.wait().is_leader()).unwrap();\n+            }).detach();\n         }\n \n         // At this point, all spawned tasks should be blocked,\n         // so we shouldn't get anything from the port\n         assert!(match rx.try_recv() {\n-            Err(Empty) => true,\n+            Err(TryRecvError::Empty) => true,\n             _ => false,\n         });\n \n-        barrier.wait();\n+        let mut leader_found = barrier.wait().is_leader();\n+\n         // Now, the barrier is cleared and we should get data.\n-        for _ in range(0u, 9) {\n-            rx.recv();\n+        for _ in range(0u, N - 1) {\n+            if rx.recv().unwrap() {\n+                assert!(!leader_found);\n+                leader_found = true;\n+            }\n         }\n+        assert!(leader_found);\n     }\n }"}, {"sha": "19b8f5e62cf5532eacc2491f9ebe043315b3fc5b", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use prelude::*;\n+use prelude::v1::*;\n \n use sync::atomic::{mod, AtomicUint};\n use sync::poison::{mod, LockResult};\n@@ -88,7 +88,7 @@ unsafe impl Sync for StaticCondvar {}\n #[unstable = \"may be merged with Condvar in the future\"]\n pub const CONDVAR_INIT: StaticCondvar = StaticCondvar {\n     inner: sys::CONDVAR_INIT,\n-    mutex: atomic::INIT_ATOMIC_UINT,\n+    mutex: atomic::ATOMIC_UINT_INIT,\n };\n \n impl Condvar {\n@@ -279,11 +279,13 @@ impl StaticCondvar {\n \n #[cfg(test)]\n mod tests {\n-    use prelude::*;\n+    use prelude::v1::*;\n \n-    use time::Duration;\n     use super::{StaticCondvar, CONDVAR_INIT};\n+    use sync::mpsc::channel;\n     use sync::{StaticMutex, MUTEX_INIT, Condvar, Mutex, Arc};\n+    use thread::Thread;\n+    use time::Duration;\n \n     #[test]\n     fn smoke() {\n@@ -306,7 +308,7 @@ mod tests {\n         static M: StaticMutex = MUTEX_INIT;\n \n         let g = M.lock().unwrap();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let _g = M.lock().unwrap();\n             C.notify_one();\n         });\n@@ -324,30 +326,30 @@ mod tests {\n         for _ in range(0, N) {\n             let data = data.clone();\n             let tx = tx.clone();\n-            spawn(move|| {\n+            Thread::spawn(move|| {\n                 let &(ref lock, ref cond) = &*data;\n                 let mut cnt = lock.lock().unwrap();\n                 *cnt += 1;\n                 if *cnt == N {\n-                    tx.send(());\n+                    tx.send(()).unwrap();\n                 }\n                 while *cnt != 0 {\n                     cnt = cond.wait(cnt).unwrap();\n                 }\n-                tx.send(());\n-            });\n+                tx.send(()).unwrap();\n+            }).detach();\n         }\n         drop(tx);\n \n         let &(ref lock, ref cond) = &*data;\n-        rx.recv();\n+        rx.recv().unwrap();\n         let mut cnt = lock.lock().unwrap();\n         *cnt = 0;\n         cond.notify_all();\n         drop(cnt);\n \n         for _ in range(0, N) {\n-            rx.recv();\n+            rx.recv().unwrap();\n         }\n     }\n \n@@ -359,7 +361,7 @@ mod tests {\n         let g = M.lock().unwrap();\n         let (g, success) = C.wait_timeout(g, Duration::nanoseconds(1000)).unwrap();\n         assert!(!success);\n-        spawn(move|| {\n+        let _t = Thread::spawn(move || {\n             let _g = M.lock().unwrap();\n             C.notify_one();\n         });\n@@ -377,14 +379,13 @@ mod tests {\n         static C: StaticCondvar = CONDVAR_INIT;\n \n         let mut g = M1.lock().unwrap();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let _g = M1.lock().unwrap();\n             C.notify_one();\n         });\n         g = C.wait(g).unwrap();\n         drop(g);\n \n-        C.wait(M2.lock().unwrap()).unwrap();\n-\n+        let _ = C.wait(M2.lock().unwrap()).unwrap();\n     }\n }"}, {"sha": "e5245251ea817482d4ee1862fc35bb12561ce0ec", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A type representing values that may be computed concurrently and operations for working with\n-//! them.\n+//! A type representing values that may be computed concurrently and operations\n+//! for working with them.\n //!\n //! # Example\n //!\n@@ -23,12 +23,15 @@\n //! ```\n \n #![allow(missing_docs)]\n+#![unstable = \"futures as-is have yet to be deeply reevaluated with recent \\\n+               core changes to Rust's synchronization story, and will likely \\\n+               become stable in the future but are unstable until that time\"]\n \n use core::prelude::*;\n use core::mem::replace;\n \n use self::FutureState::*;\n-use comm::{Receiver, channel};\n+use sync::mpsc::{Receiver, channel};\n use thunk::{Thunk};\n use thread::Thread;\n \n@@ -122,8 +125,8 @@ impl<A:Send> Future<A> {\n          * waiting for the result to be received on the port.\n          */\n \n-        Future::from_fn(move|:| {\n-            rx.recv()\n+        Future::from_fn(move |:| {\n+            rx.recv().unwrap()\n         })\n     }\n \n@@ -141,7 +144,7 @@ impl<A:Send> Future<A> {\n \n         Thread::spawn(move |:| {\n             // Don't panic if the other end has hung up\n-            let _ = tx.send_opt(blk());\n+            let _ = tx.send(blk());\n         }).detach();\n \n         Future::from_receiver(rx)\n@@ -150,9 +153,10 @@ impl<A:Send> Future<A> {\n \n #[cfg(test)]\n mod test {\n-    use prelude::*;\n+    use prelude::v1::*;\n+    use sync::mpsc::channel;\n     use sync::Future;\n-    use task;\n+    use thread::Thread;\n \n     #[test]\n     fn test_from_value() {\n@@ -163,7 +167,7 @@ mod test {\n     #[test]\n     fn test_from_receiver() {\n         let (tx, rx) = channel();\n-        tx.send(\"whale\".to_string());\n+        tx.send(\"whale\".to_string()).unwrap();\n         let mut f = Future::from_receiver(rx);\n         assert_eq!(f.get(), \"whale\");\n     }\n@@ -183,7 +187,7 @@ mod test {\n     #[test]\n     fn test_interface_unwrap() {\n         let f = Future::from_value(\"fail\".to_string());\n-        assert_eq!(f.unwrap(), \"fail\");\n+        assert_eq!(f.into_inner(), \"fail\");\n     }\n \n     #[test]\n@@ -210,10 +214,10 @@ mod test {\n         let expected = \"schlorf\";\n         let (tx, rx) = channel();\n         let f = Future::spawn(move|| { expected });\n-        task::spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut f = f;\n-            tx.send(f.get());\n+            tx.send(f.get()).unwrap();\n         });\n-        assert_eq!(rx.recv(), expected);\n+        assert_eq!(rx.recv().unwrap(), expected);\n     }\n }"}, {"sha": "c09c3b45d3e26478df726c7bfe7ec30940073df6", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -26,13 +26,15 @@ pub use self::rwlock::{RWLockReadGuard, RWLockWriteGuard};\n pub use self::condvar::{Condvar, StaticCondvar, CONDVAR_INIT};\n pub use self::once::{Once, ONCE_INIT};\n pub use self::semaphore::{Semaphore, SemaphoreGuard};\n-pub use self::barrier::Barrier;\n+pub use self::barrier::{Barrier, BarrierWaitResult};\n pub use self::poison::{PoisonError, TryLockError, TryLockResult, LockResult};\n \n pub use self::future::Future;\n pub use self::task_pool::TaskPool;\n \n pub mod atomic;\n+pub mod mpsc;\n+\n mod barrier;\n mod condvar;\n mod future;"}, {"sha": "a529901272358604752c43e9d73e86fe907d5142", "filename": "src/libstd/sync/mpsc/blocking.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -11,7 +11,7 @@\n //! Generic support for building blocking abstractions.\n \n use thread::Thread;\n-use sync::atomic::{AtomicBool, INIT_ATOMIC_BOOL, Ordering};\n+use sync::atomic::{AtomicBool, ATOMIC_BOOL_INIT, Ordering};\n use sync::Arc;\n use kinds::{Sync, Send};\n use kinds::marker::{NoSend, NoSync};\n@@ -40,7 +40,7 @@ pub struct WaitToken {\n pub fn tokens() -> (WaitToken, SignalToken) {\n     let inner = Arc::new(Inner {\n         thread: Thread::current(),\n-        woken: INIT_ATOMIC_BOOL,\n+        woken: ATOMIC_BOOL_INIT,\n     });\n     let wait_token = WaitToken {\n         inner: inner.clone(),", "previous_filename": "src/libstd/comm/blocking.rs"}, {"sha": "413675f26d59c96e39471d6624fff38497e22c66", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "renamed", "additions": 723, "deletions": 695, "changes": 1418, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -8,12 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Communication primitives for concurrent tasks\n-//!\n-//! Rust makes it very difficult to share data among tasks to prevent race\n-//! conditions and to improve parallelism, but there is often a need for\n-//! communication between concurrent tasks. The primitives defined in this\n-//! module are the building blocks for synchronization in rust.\n+//! Multi-producer, single-consumer communication primitives threads\n //!\n //! This module provides message-based communication over channels, concretely\n //! defined among three types:\n@@ -23,12 +18,10 @@\n //! * `Receiver`\n //!\n //! A `Sender` or `SyncSender` is used to send data to a `Receiver`. Both\n-//! senders are clone-able such that many tasks can send simultaneously to one\n-//! receiver.  These channels are *task blocking*, not *thread blocking*. This\n-//! means that if one task is blocked on a channel, other tasks can continue to\n-//! make progress.\n+//! senders are clone-able (multi-producer) such that many threads can send\n+//! simultaneously to one receiver (single-consumer).  These channels are\n //!\n-//! Rust channels come in one of two flavors:\n+//! These channels come in two flavors:\n //!\n //! 1. An asynchronous, infinitely buffered channel. The `channel()` function\n //!    will return a `(Sender, Receiver)` tuple where all sends will be\n@@ -43,36 +36,39 @@\n //!    \"rendezvous\" channel where each sender atomically hands off a message to\n //!    a receiver.\n //!\n-//! ## Panic Propagation\n+//! ## Disconnection\n //!\n-//! In addition to being a core primitive for communicating in rust, channels\n-//! are the points at which panics are propagated among tasks.  Whenever the one\n-//! half of channel is closed, the other half will have its next operation\n-//! `panic!`. The purpose of this is to allow propagation of panics among tasks\n-//! that are linked to one another via channels.\n+//! The send and receive operations on channels will all return a `Result`\n+//! indicating whether the operation succeeded or not. An unsuccessful operation\n+//! is normally indicative of the other half of a channel having \"hung up\" by\n+//! being dropped in its corresponding thread.\n //!\n-//! There are methods on both of senders and receivers to perform their\n-//! respective operations without panicking, however.\n+//! Once half of a channel has been deallocated, most operations can no longer\n+//! continue to make progress, so `Err` will be returned. Many applications will\n+//! continue to `unwrap()` the results returned from this module, instigating a\n+//! propagation of failure among threads if one unexpectedly dies.\n //!\n-//! # Example\n+//! # Examples\n //!\n //! Simple usage:\n //!\n //! ```\n //! use std::thread::Thread;\n+//! use std::sync::mpsc::channel;\n //!\n //! // Create a simple streaming channel\n //! let (tx, rx) = channel();\n //! Thread::spawn(move|| {\n-//!     tx.send(10i);\n+//!     tx.send(10i).unwrap();\n //! }).detach();\n-//! assert_eq!(rx.recv(), 10i);\n+//! assert_eq!(rx.recv().unwrap(), 10i);\n //! ```\n //!\n //! Shared usage:\n //!\n //! ```\n //! use std::thread::Thread;\n+//! use std::sync::mpsc::channel;\n //!\n //! // Create a shared channel that can be sent along from many threads\n //! // where tx is the sending half (tx for transmission), and rx is the receiving\n@@ -81,37 +77,40 @@\n //! for i in range(0i, 10i) {\n //!     let tx = tx.clone();\n //!     Thread::spawn(move|| {\n-//!         tx.send(i);\n+//!         tx.send(i).unwrap();\n //!     }).detach()\n //! }\n //!\n //! for _ in range(0i, 10i) {\n-//!     let j = rx.recv();\n+//!     let j = rx.recv().unwrap();\n //!     assert!(0 <= j && j < 10);\n //! }\n //! ```\n //!\n //! Propagating panics:\n //!\n-//! ```should_fail\n-//! // The call to recv() will panic!() because the channel has already hung\n-//! // up (or been deallocated)\n+//! ```\n+//! use std::sync::mpsc::channel;\n+//!\n+//! // The call to recv() will return an error because the channel has already\n+//! // hung up (or been deallocated)\n //! let (tx, rx) = channel::<int>();\n //! drop(tx);\n-//! rx.recv();\n+//! assert!(rx.recv().is_err());\n //! ```\n //!\n //! Synchronous channels:\n //!\n //! ```\n //! use std::thread::Thread;\n+//! use std::sync::mpsc::sync_channel;\n //!\n //! let (tx, rx) = sync_channel::<int>(0);\n //! Thread::spawn(move|| {\n //!     // This will wait for the parent task to start receiving\n-//!     tx.send(53);\n+//!     tx.send(53).unwrap();\n //! }).detach();\n-//! rx.recv();\n+//! rx.recv().unwrap();\n //! ```\n //!\n //! Reading from a channel with a timeout requires to use a Timer together\n@@ -120,6 +119,7 @@\n //! after 10 seconds no matter what:\n //!\n //! ```no_run\n+//! use std::sync::mpsc::channel;\n //! use std::io::timer::Timer;\n //! use std::time::Duration;\n //!\n@@ -129,8 +129,8 @@\n //!\n //! loop {\n //!     select! {\n-//!         val = rx.recv() => println!(\"Received {}\", val),\n-//!         () = timeout.recv() => {\n+//!         val = rx.recv() => println!(\"Received {}\", val.unwrap()),\n+//!         _ = timeout.recv() => {\n //!             println!(\"timed out, total time was more than 10 seconds\");\n //!             break;\n //!         }\n@@ -143,6 +143,7 @@\n //! has been inactive for 5 seconds:\n //!\n //! ```no_run\n+//! use std::sync::mpsc::channel;\n //! use std::io::timer::Timer;\n //! use std::time::Duration;\n //!\n@@ -153,8 +154,8 @@\n //!     let timeout = timer.oneshot(Duration::seconds(5));\n //!\n //!     select! {\n-//!         val = rx.recv() => println!(\"Received {}\", val),\n-//!         () = timeout.recv() => {\n+//!         val = rx.recv() => println!(\"Received {}\", val.unwrap()),\n+//!         _ = timeout.recv() => {\n //!             println!(\"timed out, no message received in 5 seconds\");\n //!             break;\n //!         }\n@@ -312,38 +313,19 @@\n // And now that you've seen all the races that I found and attempted to fix,\n // here's the code for you to find some more!\n \n-use core::prelude::*;\n+use prelude::v1::*;\n \n-pub use self::TryRecvError::*;\n-pub use self::TrySendError::*;\n-\n-use alloc::arc::Arc;\n-use core::kinds;\n-use core::kinds::marker;\n-use core::mem;\n-use core::cell::UnsafeCell;\n+use sync::Arc;\n+use fmt;\n+use kinds::marker;\n+use mem;\n+use cell::UnsafeCell;\n \n pub use self::select::{Select, Handle};\n use self::select::StartResult;\n use self::select::StartResult::*;\n use self::blocking::SignalToken;\n \n-macro_rules! test {\n-    { fn $name:ident() $b:block $(#[$a:meta])*} => (\n-        mod $name {\n-            #![allow(unused_imports)]\n-\n-            use super::*;\n-            use comm::*;\n-            use thread::Thread;\n-            use prelude::{Ok, Err, spawn, range, drop, Box, Some, None, Option};\n-            use prelude::{Vec, Buffer, from_str, Clone};\n-\n-            $(#[$a])* #[test] fn f() { $b }\n-        }\n-    )\n-}\n-\n mod blocking;\n mod oneshot;\n mod select;\n@@ -355,7 +337,7 @@ mod spsc_queue;\n \n /// The receiving-half of Rust's channel type. This half can only be owned by\n /// one task\n-#[unstable]\n+#[stable]\n pub struct Receiver<T> {\n     inner: UnsafeCell<Flavor<T>>,\n }\n@@ -367,14 +349,14 @@ unsafe impl<T:Send> Send for Receiver<T> { }\n /// An iterator over messages on a receiver, this iterator will block\n /// whenever `next` is called, waiting for a new message, and `None` will be\n /// returned when the corresponding channel has hung up.\n-#[unstable]\n-pub struct Messages<'a, T:'a> {\n+#[stable]\n+pub struct Iter<'a, T:'a> {\n     rx: &'a Receiver<T>\n }\n \n /// The sending-half of Rust's asynchronous channel type. This half can only be\n /// owned by one task, but it can be cloned to send to other tasks.\n-#[unstable]\n+#[stable]\n pub struct Sender<T> {\n     inner: UnsafeCell<Flavor<T>>,\n }\n@@ -385,41 +367,64 @@ unsafe impl<T:Send> Send for Sender<T> { }\n \n /// The sending-half of Rust's synchronous channel type. This half can only be\n /// owned by one task, but it can be cloned to send to other tasks.\n-#[unstable = \"this type may be renamed, but it will always exist\"]\n+#[stable]\n pub struct SyncSender<T> {\n     inner: Arc<RacyCell<sync::Packet<T>>>,\n     // can't share in an arc\n     _marker: marker::NoSync,\n }\n \n+/// An error returned from the `send` function on channels.\n+///\n+/// A `send` operation can only fail if the receiving end of a channel is\n+/// disconnected, implying that the data could never be received. The error\n+/// contains the data being sent as a payload so it can be recovered.\n+#[deriving(PartialEq, Eq)]\n+#[stable]\n+pub struct SendError<T>(pub T);\n+\n+/// An error returned from the `recv` function on a `Receiver`.\n+///\n+/// The `recv` operation can only fail if the sending half of a channel is\n+/// disconnected, implying that no further messages will ever be received.\n+#[deriving(PartialEq, Eq, Clone, Copy)]\n+#[stable]\n+pub struct RecvError;\n+\n /// This enumeration is the list of the possible reasons that try_recv could not\n /// return data when called.\n-#[deriving(PartialEq, Clone, Copy, Show)]\n-#[experimental = \"this is likely to be removed in changing try_recv()\"]\n+#[deriving(PartialEq, Clone, Copy)]\n+#[stable]\n pub enum TryRecvError {\n     /// This channel is currently empty, but the sender(s) have not yet\n     /// disconnected, so data may yet become available.\n+    #[stable]\n     Empty,\n+\n     /// This channel's sending half has become disconnected, and there will\n     /// never be any more data received on this channel\n+    #[stable]\n     Disconnected,\n }\n \n /// This enumeration is the list of the possible error outcomes for the\n /// `SyncSender::try_send` method.\n-#[deriving(PartialEq, Clone, Show)]\n-#[experimental = \"this is likely to be removed in changing try_send()\"]\n+#[deriving(PartialEq, Clone)]\n+#[stable]\n pub enum TrySendError<T> {\n     /// The data could not be sent on the channel because it would require that\n     /// the callee block to send the data.\n     ///\n     /// If this is a buffered channel, then the buffer is full at this time. If\n     /// this is not a buffered channel, then there is no receiver available to\n     /// acquire the data.\n+    #[stable]\n     Full(T),\n+\n     /// This channel's receiving half has disconnected, so the data could not be\n     /// sent. The data is returned back to the callee in this case.\n-    RecvDisconnected(T),\n+    #[stable]\n+    Disconnected(T),\n }\n \n enum Flavor<T> {\n@@ -458,6 +463,7 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n /// # Example\n ///\n /// ```\n+/// use std::sync::mpsc::channel;\n /// use std::thread::Thread;\n ///\n /// // tx is is the sending half (tx for transmission), and rx is the receiving\n@@ -467,15 +473,15 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n /// // Spawn off an expensive computation\n /// Thread::spawn(move|| {\n /// #   fn expensive_computation() {}\n-///     tx.send(expensive_computation());\n+///     tx.send(expensive_computation()).unwrap();\n /// }).detach();\n ///\n /// // Do some useful work for awhile\n ///\n /// // Let's see what that answer was\n-/// println!(\"{}\", rx.recv());\n+/// println!(\"{}\", rx.recv().unwrap());\n /// ```\n-#[unstable]\n+#[stable]\n pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n     let a = Arc::new(RacyCell::new(oneshot::Packet::new()));\n     (Sender::new(Flavor::Oneshot(a.clone())), Receiver::new(Flavor::Oneshot(a)))\n@@ -499,23 +505,23 @@ pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n /// # Example\n ///\n /// ```\n+/// use std::sync::mpsc::sync_channel;\n /// use std::thread::Thread;\n ///\n /// let (tx, rx) = sync_channel(1);\n ///\n /// // this returns immediately\n-/// tx.send(1i);\n+/// tx.send(1i).unwrap();\n ///\n /// Thread::spawn(move|| {\n ///     // this will block until the previous message has been received\n-///     tx.send(2i);\n+///     tx.send(2i).unwrap();\n /// }).detach();\n ///\n-/// assert_eq!(rx.recv(), 1i);\n-/// assert_eq!(rx.recv(), 2i);\n+/// assert_eq!(rx.recv().unwrap(), 1i);\n+/// assert_eq!(rx.recv().unwrap(), 2i);\n /// ```\n-#[unstable = \"this function may be renamed to more accurately reflect the type \\\n-              of channel that is is creating\"]\n+#[stable]\n pub fn sync_channel<T: Send>(bound: uint) -> (SyncSender<T>, Receiver<T>) {\n     let a = Arc::new(RacyCell::new(sync::Packet::new(bound)));\n     (SyncSender::new(a.clone()), Receiver::new(Flavor::Sync(a)))\n@@ -532,33 +538,6 @@ impl<T: Send> Sender<T> {\n         }\n     }\n \n-    /// Sends a value along this channel to be received by the corresponding\n-    /// receiver.\n-    ///\n-    /// Rust channels are infinitely buffered so this method will never block.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function will panic if the other end of the channel has hung up.\n-    /// This means that if the corresponding receiver has fallen out of scope,\n-    /// this function will trigger a panic message saying that a message is\n-    /// being sent on a closed channel.\n-    ///\n-    /// Note that if this function does *not* panic, it does not mean that the\n-    /// data will be successfully received. All sends are placed into a queue,\n-    /// so it is possible for a send to succeed (the other end is alive), but\n-    /// then the other end could immediately disconnect.\n-    ///\n-    /// The purpose of this functionality is to propagate panics among tasks.\n-    /// If a panic is not desired, then consider using the `send_opt` method\n-    #[experimental = \"this function is being considered candidate for removal \\\n-                      to adhere to the general guidelines of rust\"]\n-    pub fn send(&self, t: T) {\n-        if self.send_opt(t).is_err() {\n-            panic!(\"sending on a closed channel\");\n-        }\n-    }\n-\n     /// Attempts to send a value on this channel, returning it back if it could\n     /// not be sent.\n     ///\n@@ -570,37 +549,34 @@ impl<T: Send> Sender<T> {\n     /// will be received.  It is possible for the corresponding receiver to\n     /// hang up immediately after this function returns `Ok`.\n     ///\n-    /// Like `send`, this method will never block.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This method will never panic, it will return the message back to the\n-    /// caller if the other end is disconnected\n+    /// This method will never block the current thread.\n     ///\n     /// # Example\n     ///\n     /// ```\n+    /// use std::sync::mpsc::channel;\n+    ///\n     /// let (tx, rx) = channel();\n     ///\n     /// // This send is always successful\n-    /// assert_eq!(tx.send_opt(1i), Ok(()));\n+    /// tx.send(1i).unwrap();\n     ///\n     /// // This send will fail because the receiver is gone\n     /// drop(rx);\n-    /// assert_eq!(tx.send_opt(1i), Err(1));\n+    /// assert_eq!(tx.send(1i).err().unwrap().0, 1);\n     /// ```\n-    #[unstable = \"this function may be renamed to send() in the future\"]\n-    pub fn send_opt(&self, t: T) -> Result<(), T> {\n+    pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n         let (new_inner, ret) = match *unsafe { self.inner() } {\n             Flavor::Oneshot(ref p) => {\n                 unsafe {\n                     let p = p.get();\n                     if !(*p).sent() {\n-                        return (*p).send(t);\n+                        return (*p).send(t).map_err(SendError);\n                     } else {\n                         let a =\n                             Arc::new(RacyCell::new(stream::Packet::new()));\n-                        match (*p).upgrade(Receiver::new(Flavor::Stream(a.clone()))) {\n+                        let rx = Receiver::new(Flavor::Stream(a.clone()));\n+                        match (*p).upgrade(rx) {\n                             oneshot::UpSuccess => {\n                                 let ret = (*a.get()).send(t);\n                                 (a, ret)\n@@ -618,16 +594,20 @@ impl<T: Send> Sender<T> {\n                     }\n                 }\n             }\n-            Flavor::Stream(ref p) => return unsafe { (*p.get()).send(t) },\n-            Flavor::Shared(ref p) => return unsafe { (*p.get()).send(t) },\n+            Flavor::Stream(ref p) => return unsafe {\n+                (*p.get()).send(t).map_err(SendError)\n+            },\n+            Flavor::Shared(ref p) => return unsafe {\n+                (*p.get()).send(t).map_err(SendError)\n+            },\n             Flavor::Sync(..) => unreachable!(),\n         };\n \n         unsafe {\n             let tmp = Sender::new(Flavor::Stream(new_inner));\n             mem::swap(self.inner_mut(), tmp.inner_mut());\n         }\n-        return ret;\n+        ret.map_err(SendError)\n     }\n }\n \n@@ -639,7 +619,8 @@ impl<T: Send> Clone for Sender<T> {\n                 let a = Arc::new(RacyCell::new(shared::Packet::new()));\n                 unsafe {\n                     let guard = (*a.get()).postinit_lock();\n-                    match (*p.get()).upgrade(Receiver::new(Flavor::Shared(a.clone()))) {\n+                    let rx = Receiver::new(Flavor::Shared(a.clone()));\n+                    match (*p.get()).upgrade(rx) {\n                         oneshot::UpSuccess |\n                         oneshot::UpDisconnected => (a, None, guard),\n                         oneshot::UpWoke(task) => (a, Some(task), guard)\n@@ -650,7 +631,8 @@ impl<T: Send> Clone for Sender<T> {\n                 let a = Arc::new(RacyCell::new(shared::Packet::new()));\n                 unsafe {\n                     let guard = (*a.get()).postinit_lock();\n-                    match (*p.get()).upgrade(Receiver::new(Flavor::Shared(a.clone()))) {\n+                    let rx = Receiver::new(Flavor::Shared(a.clone()));\n+                    match (*p.get()).upgrade(rx) {\n                         stream::UpSuccess |\n                         stream::UpDisconnected => (a, None, guard),\n                         stream::UpWoke(task) => (a, Some(task), guard),\n@@ -701,59 +683,29 @@ impl<T: Send> SyncSender<T> {\n     /// available or a receiver is available to hand off the message to.\n     ///\n     /// Note that a successful send does *not* guarantee that the receiver will\n-    /// ever see the data if there is a buffer on this channel. Messages may be\n+    /// ever see the data if there is a buffer on this channel. Items may be\n     /// enqueued in the internal buffer for the receiver to receive at a later\n     /// time. If the buffer size is 0, however, it can be guaranteed that the\n     /// receiver has indeed received the data if this function returns success.\n     ///\n-    /// # Panics\n-    ///\n-    /// Similarly to `Sender::send`, this function will panic if the\n-    /// corresponding `Receiver` for this channel has disconnected. This\n-    /// behavior is used to propagate panics among tasks.\n-    ///\n-    /// If a panic is not desired, you can achieve the same semantics with the\n-    /// `SyncSender::send_opt` method which will not panic if the receiver\n-    /// disconnects.\n-    #[experimental = \"this function is being considered candidate for removal \\\n-                      to adhere to the general guidelines of rust\"]\n-    pub fn send(&self, t: T) {\n-        if self.send_opt(t).is_err() {\n-            panic!(\"sending on a closed channel\");\n-        }\n-    }\n-\n-    /// Send a value on a channel, returning it back if the receiver\n-    /// disconnected\n-    ///\n-    /// This method will *block* to send the value `t` on the channel, but if\n-    /// the value could not be sent due to the receiver disconnecting, the value\n-    /// is returned back to the callee. This function is similar to `try_send`,\n-    /// except that it will block if the channel is currently full.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function cannot panic.\n-    #[unstable = \"this function may be renamed to send() in the future\"]\n-    pub fn send_opt(&self, t: T) -> Result<(), T> {\n-        unsafe { (*self.inner.get()).send(t) }\n+    /// This function will never panic, but it may return `Err` if the\n+    /// `Receiver` has disconnected and is no longer able to receive\n+    /// information.\n+    #[stable]\n+    pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n+        unsafe { (*self.inner.get()).send(t).map_err(SendError) }\n     }\n \n     /// Attempts to send a value on this channel without blocking.\n     ///\n-    /// This method differs from `send_opt` by returning immediately if the\n+    /// This method differs from `send` by returning immediately if the\n     /// channel's buffer is full or no receiver is waiting to acquire some\n-    /// data. Compared with `send_opt`, this function has two failure cases\n+    /// data. Compared with `send`, this function has two failure cases\n     /// instead of one (one for disconnection, one for a full buffer).\n     ///\n     /// See `SyncSender::send` for notes about guarantees of whether the\n     /// receiver has received the data or not if this function is successful.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function cannot panic\n-    #[unstable = \"the return type of this function is candidate for \\\n-                  modification\"]\n+    #[stable]\n     pub fn try_send(&self, t: T) -> Result<(), TrySendError<T>> {\n         unsafe { (*self.inner.get()).try_send(t) }\n     }\n@@ -783,34 +735,6 @@ impl<T: Send> Receiver<T> {\n         Receiver { inner: UnsafeCell::new(inner) }\n     }\n \n-    /// Blocks waiting for a value on this receiver\n-    ///\n-    /// This function will block if necessary to wait for a corresponding send\n-    /// on the channel from its paired `Sender` structure. This receiver will\n-    /// be woken up when data is ready, and the data will be returned.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Similar to channels, this method will trigger a task panic if the\n-    /// other end of the channel has hung up (been deallocated). The purpose of\n-    /// this is to propagate panics among tasks.\n-    ///\n-    /// If a panic is not desired, then there are two options:\n-    ///\n-    /// * If blocking is still desired, the `recv_opt` method will return `None`\n-    ///   when the other end hangs up\n-    ///\n-    /// * If blocking is not desired, then the `try_recv` method will attempt to\n-    ///   peek at a value on this receiver.\n-    #[experimental = \"this function is being considered candidate for removal \\\n-                      to adhere to the general guidelines of rust\"]\n-    pub fn recv(&self) -> T {\n-        match self.recv_opt() {\n-            Ok(t) => t,\n-            Err(()) => panic!(\"receiving on a closed channel\"),\n-        }\n-    }\n-\n     /// Attempts to return a pending value on this receiver without blocking\n     ///\n     /// This method will never block the caller in order to wait for data to\n@@ -819,42 +743,46 @@ impl<T: Send> Receiver<T> {\n     ///\n     /// This is useful for a flavor of \"optimistic check\" before deciding to\n     /// block on a receiver.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function cannot panic.\n-    #[unstable = \"the return type of this function may be altered\"]\n+    #[stable]\n     pub fn try_recv(&self) -> Result<T, TryRecvError> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n                 Flavor::Oneshot(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n                         Ok(t) => return Ok(t),\n-                        Err(oneshot::Empty) => return Err(Empty),\n-                        Err(oneshot::Disconnected) => return Err(Disconnected),\n+                        Err(oneshot::Empty) => return Err(TryRecvError::Empty),\n+                        Err(oneshot::Disconnected) => {\n+                            return Err(TryRecvError::Disconnected)\n+                        }\n                         Err(oneshot::Upgraded(rx)) => rx,\n                     }\n                 }\n                 Flavor::Stream(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n                         Ok(t) => return Ok(t),\n-                        Err(stream::Empty) => return Err(Empty),\n-                        Err(stream::Disconnected) => return Err(Disconnected),\n+                        Err(stream::Empty) => return Err(TryRecvError::Empty),\n+                        Err(stream::Disconnected) => {\n+                            return Err(TryRecvError::Disconnected)\n+                        }\n                         Err(stream::Upgraded(rx)) => rx,\n                     }\n                 }\n                 Flavor::Shared(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n                         Ok(t) => return Ok(t),\n-                        Err(shared::Empty) => return Err(Empty),\n-                        Err(shared::Disconnected) => return Err(Disconnected),\n+                        Err(shared::Empty) => return Err(TryRecvError::Empty),\n+                        Err(shared::Disconnected) => {\n+                            return Err(TryRecvError::Disconnected)\n+                        }\n                     }\n                 }\n                 Flavor::Sync(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n                         Ok(t) => return Ok(t),\n-                        Err(sync::Empty) => return Err(Empty),\n-                        Err(sync::Disconnected) => return Err(Disconnected),\n+                        Err(sync::Empty) => return Err(TryRecvError::Empty),\n+                        Err(sync::Disconnected) => {\n+                            return Err(TryRecvError::Disconnected)\n+                        }\n                     }\n                 }\n             };\n@@ -865,46 +793,47 @@ impl<T: Send> Receiver<T> {\n         }\n     }\n \n-    /// Attempt to wait for a value on this receiver, but does not panic if the\n+    /// Attempt to wait for a value on this receiver, returning an error if the\n     /// corresponding channel has hung up.\n     ///\n-    /// This implementation of iterators for ports will always block if there is\n-    /// not data available on the receiver, but it will not panic in the case\n-    /// that the channel has been deallocated.\n+    /// This function will always block the current thread if there is no data\n+    /// available and it's possible for more data to be sent. Once a message is\n+    /// sent to the corresponding `Sender`, then this receiver will wake up and\n+    /// return that message.\n     ///\n-    /// In other words, this function has the same semantics as the `recv`\n-    /// method except for the panic aspect.\n-    ///\n-    /// If the channel has hung up, then `Err` is returned. Otherwise `Ok` of\n-    /// the value found on the receiver is returned.\n-    #[unstable = \"this function may be renamed to recv()\"]\n-    pub fn recv_opt(&self) -> Result<T, ()> {\n+    /// If the corresponding `Sender` has disconnected, or it disconnects while\n+    /// this call is blocking, this call will wake up and return `Err` to\n+    /// indicate that no more messages can ever be received on this channel.\n+    #[stable]\n+    pub fn recv(&self) -> Result<T, RecvError> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n                 Flavor::Oneshot(ref p) => {\n                     match unsafe { (*p.get()).recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(oneshot::Empty) => return unreachable!(),\n-                        Err(oneshot::Disconnected) => return Err(()),\n+                        Err(oneshot::Disconnected) => return Err(RecvError),\n                         Err(oneshot::Upgraded(rx)) => rx,\n                     }\n                 }\n                 Flavor::Stream(ref p) => {\n                     match unsafe { (*p.get()).recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(stream::Empty) => return unreachable!(),\n-                        Err(stream::Disconnected) => return Err(()),\n+                        Err(stream::Disconnected) => return Err(RecvError),\n                         Err(stream::Upgraded(rx)) => rx,\n                     }\n                 }\n                 Flavor::Shared(ref p) => {\n                     match unsafe { (*p.get()).recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(shared::Empty) => return unreachable!(),\n-                        Err(shared::Disconnected) => return Err(()),\n+                        Err(shared::Disconnected) => return Err(RecvError),\n                     }\n                 }\n-                Flavor::Sync(ref p) => return unsafe { (*p.get()).recv() }\n+                Flavor::Sync(ref p) => return unsafe {\n+                    (*p.get()).recv().map_err(|()| RecvError)\n+                }\n             };\n             unsafe {\n                 mem::swap(self.inner_mut(), new_port.inner_mut());\n@@ -914,9 +843,9 @@ impl<T: Send> Receiver<T> {\n \n     /// Returns an iterator that will block waiting for messages, but never\n     /// `panic!`. It will return `None` when the channel has hung up.\n-    #[unstable]\n-    pub fn iter<'a>(&'a self) -> Messages<'a, T> {\n-        Messages { rx: self }\n+    #[stable]\n+    pub fn iter(&self) -> Iter<T> {\n+        Iter { rx: self }\n     }\n }\n \n@@ -1007,8 +936,8 @@ impl<T: Send> select::Packet for Receiver<T> {\n }\n \n #[unstable]\n-impl<'a, T: Send> Iterator<T> for Messages<'a, T> {\n-    fn next(&mut self) -> Option<T> { self.rx.recv_opt().ok() }\n+impl<'a, T: Send> Iterator<T> for Iter<'a, T> {\n+    fn next(&mut self) -> Option<T> { self.rx.recv().ok() }\n }\n \n #[unsafe_destructor]\n@@ -1041,368 +970,425 @@ impl<T> RacyCell<T> {\n \n unsafe impl<T:Send> Send for RacyCell<T> { }\n \n-unsafe impl<T> kinds::Sync for RacyCell<T> { } // Oh dear\n+unsafe impl<T> Sync for RacyCell<T> { } // Oh dear\n+\n+impl<T> fmt::Show for SendError<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        \"sending on a closed channel\".fmt(f)\n+    }\n+}\n+\n+impl<T> fmt::Show for TrySendError<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            TrySendError::Full(..) => {\n+                \"sending on a full channel\".fmt(f)\n+            }\n+            TrySendError::Disconnected(..) => {\n+                \"sending on a closed channel\".fmt(f)\n+            }\n+        }\n+    }\n+}\n+\n+impl fmt::Show for RecvError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        \"receiving on a closed channel\".fmt(f)\n+    }\n+}\n \n+impl fmt::Show for TryRecvError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            TryRecvError::Empty => {\n+                \"receiving on an empty channel\".fmt(f)\n+            }\n+            TryRecvError::Disconnected => {\n+                \"receiving on a closed channel\".fmt(f)\n+            }\n+        }\n+    }\n+}\n \n #[cfg(test)]\n mod test {\n-    use super::*;\n-    use prelude::{spawn, range, Some, None, from_str, Clone, Str};\n+    use prelude::v1::*;\n+\n     use os;\n+    use super::*;\n+    use thread::Thread;\n \n     pub fn stress_factor() -> uint {\n         match os::getenv(\"RUST_TEST_STRESS\") {\n-            Some(val) => from_str::<uint>(val.as_slice()).unwrap(),\n+            Some(val) => val.parse().unwrap(),\n             None => 1,\n         }\n     }\n \n-    test! { fn smoke() {\n+    #[test]\n+    fn smoke() {\n         let (tx, rx) = channel::<int>();\n-        tx.send(1);\n-        assert_eq!(rx.recv(), 1);\n-    } }\n+        tx.send(1).unwrap();\n+        assert_eq!(rx.recv().unwrap(), 1);\n+    }\n \n-    test! { fn drop_full() {\n+    #[test]\n+    fn drop_full() {\n         let (tx, _rx) = channel();\n-        tx.send(box 1i);\n-    } }\n+        tx.send(box 1i).unwrap();\n+    }\n \n-    test! { fn drop_full_shared() {\n+    #[test]\n+    fn drop_full_shared() {\n         let (tx, _rx) = channel();\n         drop(tx.clone());\n         drop(tx.clone());\n-        tx.send(box 1i);\n-    } }\n+        tx.send(box 1i).unwrap();\n+    }\n \n-    test! { fn smoke_shared() {\n+    #[test]\n+    fn smoke_shared() {\n         let (tx, rx) = channel::<int>();\n-        tx.send(1);\n-        assert_eq!(rx.recv(), 1);\n+        tx.send(1).unwrap();\n+        assert_eq!(rx.recv().unwrap(), 1);\n         let tx = tx.clone();\n-        tx.send(1);\n-        assert_eq!(rx.recv(), 1);\n-    } }\n+        tx.send(1).unwrap();\n+        assert_eq!(rx.recv().unwrap(), 1);\n+    }\n \n-    test! { fn smoke_threads() {\n+    #[test]\n+    fn smoke_threads() {\n         let (tx, rx) = channel::<int>();\n-        spawn(move|| {\n-            tx.send(1);\n+        let _t = Thread::spawn(move|| {\n+            tx.send(1).unwrap();\n         });\n-        assert_eq!(rx.recv(), 1);\n-    } }\n+        assert_eq!(rx.recv().unwrap(), 1);\n+    }\n \n-    test! { fn smoke_port_gone() {\n+    #[test]\n+    fn smoke_port_gone() {\n         let (tx, rx) = channel::<int>();\n         drop(rx);\n-        tx.send(1);\n-    } #[should_fail] }\n+        assert!(tx.send(1).is_err());\n+    }\n \n-    test! { fn smoke_shared_port_gone() {\n+    #[test]\n+    fn smoke_shared_port_gone() {\n         let (tx, rx) = channel::<int>();\n         drop(rx);\n-        tx.send(1);\n-    } #[should_fail] }\n+        assert!(tx.send(1).is_err())\n+    }\n \n-    test! { fn smoke_shared_port_gone2() {\n+    #[test]\n+    fn smoke_shared_port_gone2() {\n         let (tx, rx) = channel::<int>();\n         drop(rx);\n         let tx2 = tx.clone();\n         drop(tx);\n-        tx2.send(1);\n-    } #[should_fail] }\n+        assert!(tx2.send(1).is_err());\n+    }\n \n-    test! { fn port_gone_concurrent() {\n+    #[test]\n+    fn port_gone_concurrent() {\n         let (tx, rx) = channel::<int>();\n-        spawn(move|| {\n-            rx.recv();\n+        let _t = Thread::spawn(move|| {\n+            rx.recv().unwrap();\n         });\n-        loop { tx.send(1) }\n-    } #[should_fail] }\n+        while tx.send(1).is_ok() {}\n+    }\n \n-    test! { fn port_gone_concurrent_shared() {\n+    #[test]\n+    fn port_gone_concurrent_shared() {\n         let (tx, rx) = channel::<int>();\n         let tx2 = tx.clone();\n-        spawn(move|| {\n-            rx.recv();\n+        let _t = Thread::spawn(move|| {\n+            rx.recv().unwrap();\n         });\n-        loop {\n-            tx.send(1);\n-            tx2.send(1);\n-        }\n-    } #[should_fail] }\n+        while tx.send(1).is_ok() && tx2.send(1).is_ok() {}\n+    }\n \n-    test! { fn smoke_chan_gone() {\n+    #[test]\n+    fn smoke_chan_gone() {\n         let (tx, rx) = channel::<int>();\n         drop(tx);\n-        rx.recv();\n-    } #[should_fail] }\n+        assert!(rx.recv().is_err());\n+    }\n \n-    test! { fn smoke_chan_gone_shared() {\n+    #[test]\n+    fn smoke_chan_gone_shared() {\n         let (tx, rx) = channel::<()>();\n         let tx2 = tx.clone();\n         drop(tx);\n         drop(tx2);\n-        rx.recv();\n-    } #[should_fail] }\n+        assert!(rx.recv().is_err());\n+    }\n \n-    test! { fn chan_gone_concurrent() {\n+    #[test]\n+    fn chan_gone_concurrent() {\n         let (tx, rx) = channel::<int>();\n-        spawn(move|| {\n-            tx.send(1);\n-            tx.send(1);\n+        let _t = Thread::spawn(move|| {\n+            tx.send(1).unwrap();\n+            tx.send(1).unwrap();\n         });\n-        loop { rx.recv(); }\n-    } #[should_fail] }\n+        while rx.recv().is_ok() {}\n+    }\n \n-    test! { fn stress() {\n+    #[test]\n+    fn stress() {\n         let (tx, rx) = channel::<int>();\n-        spawn(move|| {\n-            for _ in range(0u, 10000) { tx.send(1i); }\n+        let t = Thread::spawn(move|| {\n+            for _ in range(0u, 10000) { tx.send(1i).unwrap(); }\n         });\n         for _ in range(0u, 10000) {\n-            assert_eq!(rx.recv(), 1);\n+            assert_eq!(rx.recv().unwrap(), 1);\n         }\n-    } }\n+        t.join().ok().unwrap();\n+    }\n \n-    test! { fn stress_shared() {\n+    #[test]\n+    fn stress_shared() {\n         static AMT: uint = 10000;\n         static NTHREADS: uint = 8;\n         let (tx, rx) = channel::<int>();\n-        let (dtx, drx) = channel::<()>();\n \n-        spawn(move|| {\n+        let t = Thread::spawn(move|| {\n             for _ in range(0, AMT * NTHREADS) {\n-                assert_eq!(rx.recv(), 1);\n+                assert_eq!(rx.recv().unwrap(), 1);\n             }\n             match rx.try_recv() {\n                 Ok(..) => panic!(),\n                 _ => {}\n             }\n-            dtx.send(());\n         });\n \n         for _ in range(0, NTHREADS) {\n             let tx = tx.clone();\n-            spawn(move|| {\n-                for _ in range(0, AMT) { tx.send(1); }\n-            });\n+            Thread::spawn(move|| {\n+                for _ in range(0, AMT) { tx.send(1).unwrap(); }\n+            }).detach();\n         }\n         drop(tx);\n-        drx.recv();\n-    } }\n+        t.join().ok().unwrap();\n+    }\n \n     #[test]\n     fn send_from_outside_runtime() {\n         let (tx1, rx1) = channel::<()>();\n         let (tx2, rx2) = channel::<int>();\n-        let (tx3, rx3) = channel::<()>();\n-        let tx4 = tx3.clone();\n-        spawn(move|| {\n-            tx1.send(());\n+        let t1 = Thread::spawn(move|| {\n+            tx1.send(()).unwrap();\n             for _ in range(0i, 40) {\n-                assert_eq!(rx2.recv(), 1);\n+                assert_eq!(rx2.recv().unwrap(), 1);\n             }\n-            tx3.send(());\n         });\n-        rx1.recv();\n-        spawn(move|| {\n+        rx1.recv().unwrap();\n+        let t2 = Thread::spawn(move|| {\n             for _ in range(0i, 40) {\n-                tx2.send(1);\n+                tx2.send(1).unwrap();\n             }\n-            tx4.send(());\n         });\n-        rx3.recv();\n-        rx3.recv();\n+        t1.join().ok().unwrap();\n+        t2.join().ok().unwrap();\n     }\n \n     #[test]\n     fn recv_from_outside_runtime() {\n         let (tx, rx) = channel::<int>();\n-        let (dtx, drx) = channel();\n-        spawn(move|| {\n+        let t = Thread::spawn(move|| {\n             for _ in range(0i, 40) {\n-                assert_eq!(rx.recv(), 1);\n+                assert_eq!(rx.recv().unwrap(), 1);\n             }\n-            dtx.send(());\n         });\n         for _ in range(0u, 40) {\n-            tx.send(1);\n+            tx.send(1).unwrap();\n         }\n-        drx.recv();\n+        t.join().ok().unwrap();\n     }\n \n     #[test]\n     fn no_runtime() {\n         let (tx1, rx1) = channel::<int>();\n         let (tx2, rx2) = channel::<int>();\n-        let (tx3, rx3) = channel::<()>();\n-        let tx4 = tx3.clone();\n-        spawn(move|| {\n-            assert_eq!(rx1.recv(), 1);\n-            tx2.send(2);\n-            tx4.send(());\n+        let t1 = Thread::spawn(move|| {\n+            assert_eq!(rx1.recv().unwrap(), 1);\n+            tx2.send(2).unwrap();\n         });\n-        spawn(move|| {\n-            tx1.send(1);\n-            assert_eq!(rx2.recv(), 2);\n-            tx3.send(());\n+        let t2 = Thread::spawn(move|| {\n+            tx1.send(1).unwrap();\n+            assert_eq!(rx2.recv().unwrap(), 2);\n         });\n-        rx3.recv();\n-        rx3.recv();\n+        t1.join().ok().unwrap();\n+        t2.join().ok().unwrap();\n     }\n \n-    test! { fn oneshot_single_thread_close_port_first() {\n+    #[test]\n+    fn oneshot_single_thread_close_port_first() {\n         // Simple test of closing without sending\n         let (_tx, rx) = channel::<int>();\n         drop(rx);\n-    } }\n+    }\n \n-    test! { fn oneshot_single_thread_close_chan_first() {\n+    #[test]\n+    fn oneshot_single_thread_close_chan_first() {\n         // Simple test of closing without sending\n         let (tx, _rx) = channel::<int>();\n         drop(tx);\n-    } }\n+    }\n \n-    test! { fn oneshot_single_thread_send_port_close() {\n+    #[test]\n+    fn oneshot_single_thread_send_port_close() {\n         // Testing that the sender cleans up the payload if receiver is closed\n         let (tx, rx) = channel::<Box<int>>();\n         drop(rx);\n-        tx.send(box 0);\n-    } #[should_fail] }\n+        assert!(tx.send(box 0).is_err());\n+    }\n \n-    test! { fn oneshot_single_thread_recv_chan_close() {\n+    #[test]\n+    fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n         let res = Thread::spawn(move|| {\n             let (tx, rx) = channel::<int>();\n             drop(tx);\n-            rx.recv();\n+            rx.recv().unwrap();\n         }).join();\n         // What is our res?\n         assert!(res.is_err());\n-    } }\n+    }\n \n-    test! { fn oneshot_single_thread_send_then_recv() {\n+    #[test]\n+    fn oneshot_single_thread_send_then_recv() {\n         let (tx, rx) = channel::<Box<int>>();\n-        tx.send(box 10);\n-        assert!(rx.recv() == box 10);\n-    } }\n+        tx.send(box 10).unwrap();\n+        assert!(rx.recv().unwrap() == box 10);\n+    }\n \n-    test! { fn oneshot_single_thread_try_send_open() {\n+    #[test]\n+    fn oneshot_single_thread_try_send_open() {\n         let (tx, rx) = channel::<int>();\n-        assert!(tx.send_opt(10).is_ok());\n-        assert!(rx.recv() == 10);\n-    } }\n+        assert!(tx.send(10).is_ok());\n+        assert!(rx.recv().unwrap() == 10);\n+    }\n \n-    test! { fn oneshot_single_thread_try_send_closed() {\n+    #[test]\n+    fn oneshot_single_thread_try_send_closed() {\n         let (tx, rx) = channel::<int>();\n         drop(rx);\n-        assert!(tx.send_opt(10).is_err());\n-    } }\n+        assert!(tx.send(10).is_err());\n+    }\n \n-    test! { fn oneshot_single_thread_try_recv_open() {\n+    #[test]\n+    fn oneshot_single_thread_try_recv_open() {\n         let (tx, rx) = channel::<int>();\n-        tx.send(10);\n-        assert!(rx.recv_opt() == Ok(10));\n-    } }\n+        tx.send(10).unwrap();\n+        assert!(rx.recv() == Ok(10));\n+    }\n \n-    test! { fn oneshot_single_thread_try_recv_closed() {\n+    #[test]\n+    fn oneshot_single_thread_try_recv_closed() {\n         let (tx, rx) = channel::<int>();\n         drop(tx);\n-        assert!(rx.recv_opt() == Err(()));\n-    } }\n+        assert!(rx.recv().is_err());\n+    }\n \n-    test! { fn oneshot_single_thread_peek_data() {\n+    #[test]\n+    fn oneshot_single_thread_peek_data() {\n         let (tx, rx) = channel::<int>();\n-        assert_eq!(rx.try_recv(), Err(Empty));\n-        tx.send(10);\n+        assert_eq!(rx.try_recv(), Err(TryRecvError::Empty));\n+        tx.send(10).unwrap();\n         assert_eq!(rx.try_recv(), Ok(10));\n-    } }\n+    }\n \n-    test! { fn oneshot_single_thread_peek_close() {\n+    #[test]\n+    fn oneshot_single_thread_peek_close() {\n         let (tx, rx) = channel::<int>();\n         drop(tx);\n-        assert_eq!(rx.try_recv(), Err(Disconnected));\n-        assert_eq!(rx.try_recv(), Err(Disconnected));\n-    } }\n+        assert_eq!(rx.try_recv(), Err(TryRecvError::Disconnected));\n+        assert_eq!(rx.try_recv(), Err(TryRecvError::Disconnected));\n+    }\n \n-    test! { fn oneshot_single_thread_peek_open() {\n+    #[test]\n+    fn oneshot_single_thread_peek_open() {\n         let (_tx, rx) = channel::<int>();\n-        assert_eq!(rx.try_recv(), Err(Empty));\n-    } }\n+        assert_eq!(rx.try_recv(), Err(TryRecvError::Empty));\n+    }\n \n-    test! { fn oneshot_multi_task_recv_then_send() {\n+    #[test]\n+    fn oneshot_multi_task_recv_then_send() {\n         let (tx, rx) = channel::<Box<int>>();\n-        spawn(move|| {\n-            assert!(rx.recv() == box 10);\n+        let _t = Thread::spawn(move|| {\n+            assert!(rx.recv().unwrap() == box 10);\n         });\n \n-        tx.send(box 10);\n-    } }\n+        tx.send(box 10).unwrap();\n+    }\n \n-    test! { fn oneshot_multi_task_recv_then_close() {\n+    #[test]\n+    fn oneshot_multi_task_recv_then_close() {\n         let (tx, rx) = channel::<Box<int>>();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             drop(tx);\n         });\n         let res = Thread::spawn(move|| {\n-            assert!(rx.recv() == box 10);\n+            assert!(rx.recv().unwrap() == box 10);\n         }).join();\n         assert!(res.is_err());\n-    } }\n+    }\n \n-    test! { fn oneshot_multi_thread_close_stress() {\n+    #[test]\n+    fn oneshot_multi_thread_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = channel::<int>();\n-            spawn(move|| {\n+            let _t = Thread::spawn(move|| {\n                 drop(rx);\n             });\n             drop(tx);\n         }\n-    } }\n+    }\n \n-    test! { fn oneshot_multi_thread_send_close_stress() {\n+    #[test]\n+    fn oneshot_multi_thread_send_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = channel::<int>();\n-            spawn(move|| {\n+            let _t = Thread::spawn(move|| {\n                 drop(rx);\n             });\n             let _ = Thread::spawn(move|| {\n-                tx.send(1);\n+                tx.send(1).unwrap();\n             }).join();\n         }\n-    } }\n+    }\n \n-    test! { fn oneshot_multi_thread_recv_close_stress() {\n+    #[test]\n+    fn oneshot_multi_thread_recv_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = channel::<int>();\n-            spawn(move|| {\n+            Thread::spawn(move|| {\n                 let res = Thread::spawn(move|| {\n-                    rx.recv();\n+                    rx.recv().unwrap();\n                 }).join();\n                 assert!(res.is_err());\n-            });\n-            spawn(move|| {\n-                spawn(move|| {\n+            }).detach();\n+            let _t = Thread::spawn(move|| {\n+                Thread::spawn(move|| {\n                     drop(tx);\n-                });\n+                }).detach();\n             });\n         }\n-    } }\n+    }\n \n-    test! { fn oneshot_multi_thread_send_recv_stress() {\n+    #[test]\n+    fn oneshot_multi_thread_send_recv_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = channel();\n-            spawn(move|| {\n-                tx.send(box 10i);\n-            });\n-            spawn(move|| {\n-                assert!(rx.recv() == box 10i);\n+            let _t = Thread::spawn(move|| {\n+                tx.send(box 10i).unwrap();\n             });\n+            assert!(rx.recv().unwrap() == box 10i);\n         }\n-    } }\n+    }\n \n-    test! { fn stream_send_recv_stress() {\n+    #[test]\n+    fn stream_send_recv_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = channel();\n \n@@ -1412,69 +1398,73 @@ mod test {\n             fn send(tx: Sender<Box<int>>, i: int) {\n                 if i == 10 { return }\n \n-                spawn(move|| {\n-                    tx.send(box i);\n+                Thread::spawn(move|| {\n+                    tx.send(box i).unwrap();\n                     send(tx, i + 1);\n-                });\n+                }).detach();\n             }\n \n             fn recv(rx: Receiver<Box<int>>, i: int) {\n                 if i == 10 { return }\n \n-                spawn(move|| {\n-                    assert!(rx.recv() == box i);\n+                Thread::spawn(move|| {\n+                    assert!(rx.recv().unwrap() == box i);\n                     recv(rx, i + 1);\n-                });\n+                }).detach();\n             }\n         }\n-    } }\n+    }\n \n-    test! { fn recv_a_lot() {\n+    #[test]\n+    fn recv_a_lot() {\n         // Regression test that we don't run out of stack in scheduler context\n         let (tx, rx) = channel();\n-        for _ in range(0i, 10000) { tx.send(()); }\n-        for _ in range(0i, 10000) { rx.recv(); }\n-    } }\n+        for _ in range(0i, 10000) { tx.send(()).unwrap(); }\n+        for _ in range(0i, 10000) { rx.recv().unwrap(); }\n+    }\n \n-    test! { fn shared_chan_stress() {\n+    #[test]\n+    fn shared_chan_stress() {\n         let (tx, rx) = channel();\n         let total = stress_factor() + 100;\n         for _ in range(0, total) {\n             let tx = tx.clone();\n-            spawn(move|| {\n-                tx.send(());\n-            });\n+            Thread::spawn(move|| {\n+                tx.send(()).unwrap();\n+            }).detach();\n         }\n \n         for _ in range(0, total) {\n-            rx.recv();\n+            rx.recv().unwrap();\n         }\n-    } }\n+    }\n \n-    test! { fn test_nested_recv_iter() {\n+    #[test]\n+    fn test_nested_recv_iter() {\n         let (tx, rx) = channel::<int>();\n         let (total_tx, total_rx) = channel::<int>();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut acc = 0;\n             for x in rx.iter() {\n                 acc += x;\n             }\n-            total_tx.send(acc);\n+            total_tx.send(acc).unwrap();\n         });\n \n-        tx.send(3);\n-        tx.send(1);\n-        tx.send(2);\n+        tx.send(3).unwrap();\n+        tx.send(1).unwrap();\n+        tx.send(2).unwrap();\n         drop(tx);\n-        assert_eq!(total_rx.recv(), 6);\n-    } }\n+        assert_eq!(total_rx.recv().unwrap(), 6);\n+    }\n \n-    test! { fn test_recv_iter_break() {\n+    #[test]\n+    fn test_recv_iter_break() {\n         let (tx, rx) = channel::<int>();\n         let (count_tx, count_rx) = channel();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut count = 0;\n             for x in rx.iter() {\n                 if count >= 3 {\n@@ -1483,353 +1473,386 @@ mod test {\n                     count += x;\n                 }\n             }\n-            count_tx.send(count);\n+            count_tx.send(count).unwrap();\n         });\n \n-        tx.send(2);\n-        tx.send(2);\n-        tx.send(2);\n-        let _ = tx.send_opt(2);\n+        tx.send(2).unwrap();\n+        tx.send(2).unwrap();\n+        tx.send(2).unwrap();\n+        let _ = tx.send(2);\n         drop(tx);\n-        assert_eq!(count_rx.recv(), 4);\n-    } }\n+        assert_eq!(count_rx.recv().unwrap(), 4);\n+    }\n \n-    test! { fn try_recv_states() {\n+    #[test]\n+    fn try_recv_states() {\n         let (tx1, rx1) = channel::<int>();\n         let (tx2, rx2) = channel::<()>();\n         let (tx3, rx3) = channel::<()>();\n-        spawn(move|| {\n-            rx2.recv();\n-            tx1.send(1);\n-            tx3.send(());\n-            rx2.recv();\n+        let _t = Thread::spawn(move|| {\n+            rx2.recv().unwrap();\n+            tx1.send(1).unwrap();\n+            tx3.send(()).unwrap();\n+            rx2.recv().unwrap();\n             drop(tx1);\n-            tx3.send(());\n+            tx3.send(()).unwrap();\n         });\n \n-        assert_eq!(rx1.try_recv(), Err(Empty));\n-        tx2.send(());\n-        rx3.recv();\n+        assert_eq!(rx1.try_recv(), Err(TryRecvError::Empty));\n+        tx2.send(()).unwrap();\n+        rx3.recv().unwrap();\n         assert_eq!(rx1.try_recv(), Ok(1));\n-        assert_eq!(rx1.try_recv(), Err(Empty));\n-        tx2.send(());\n-        rx3.recv();\n-        assert_eq!(rx1.try_recv(), Err(Disconnected));\n-    } }\n+        assert_eq!(rx1.try_recv(), Err(TryRecvError::Empty));\n+        tx2.send(()).unwrap();\n+        rx3.recv().unwrap();\n+        assert_eq!(rx1.try_recv(), Err(TryRecvError::Disconnected));\n+    }\n \n     // This bug used to end up in a livelock inside of the Receiver destructor\n     // because the internal state of the Shared packet was corrupted\n-    test! { fn destroy_upgraded_shared_port_when_sender_still_active() {\n+    #[test]\n+    fn destroy_upgraded_shared_port_when_sender_still_active() {\n         let (tx, rx) = channel();\n         let (tx2, rx2) = channel();\n-        spawn(move|| {\n-            rx.recv(); // wait on a oneshot\n+        let _t = Thread::spawn(move|| {\n+            rx.recv().unwrap(); // wait on a oneshot\n             drop(rx);  // destroy a shared\n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n         // make sure the other task has gone to sleep\n         for _ in range(0u, 5000) { Thread::yield_now(); }\n \n         // upgrade to a shared chan and send a message\n         let t = tx.clone();\n         drop(tx);\n-        t.send(());\n+        t.send(()).unwrap();\n \n         // wait for the child task to exit before we exit\n-        rx2.recv();\n-    }}\n+        rx2.recv().unwrap();\n+    }\n }\n \n #[cfg(test)]\n mod sync_tests {\n-    use prelude::*;\n+    use prelude::v1::*;\n+\n     use os;\n+    use thread::Thread;\n+    use super::*;\n \n     pub fn stress_factor() -> uint {\n         match os::getenv(\"RUST_TEST_STRESS\") {\n-            Some(val) => from_str::<uint>(val.as_slice()).unwrap(),\n+            Some(val) => val.parse().unwrap(),\n             None => 1,\n         }\n     }\n \n-    test! { fn smoke() {\n+    #[test]\n+    fn smoke() {\n         let (tx, rx) = sync_channel::<int>(1);\n-        tx.send(1);\n-        assert_eq!(rx.recv(), 1);\n-    } }\n+        tx.send(1).unwrap();\n+        assert_eq!(rx.recv().unwrap(), 1);\n+    }\n \n-    test! { fn drop_full() {\n+    #[test]\n+    fn drop_full() {\n         let (tx, _rx) = sync_channel(1);\n-        tx.send(box 1i);\n-    } }\n+        tx.send(box 1i).unwrap();\n+    }\n \n-    test! { fn smoke_shared() {\n+    #[test]\n+    fn smoke_shared() {\n         let (tx, rx) = sync_channel::<int>(1);\n-        tx.send(1);\n-        assert_eq!(rx.recv(), 1);\n+        tx.send(1).unwrap();\n+        assert_eq!(rx.recv().unwrap(), 1);\n         let tx = tx.clone();\n-        tx.send(1);\n-        assert_eq!(rx.recv(), 1);\n-    } }\n+        tx.send(1).unwrap();\n+        assert_eq!(rx.recv().unwrap(), 1);\n+    }\n \n-    test! { fn smoke_threads() {\n+    #[test]\n+    fn smoke_threads() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        spawn(move|| {\n-            tx.send(1);\n+        let _t = Thread::spawn(move|| {\n+            tx.send(1).unwrap();\n         });\n-        assert_eq!(rx.recv(), 1);\n-    } }\n+        assert_eq!(rx.recv().unwrap(), 1);\n+    }\n \n-    test! { fn smoke_port_gone() {\n+    #[test]\n+    fn smoke_port_gone() {\n         let (tx, rx) = sync_channel::<int>(0);\n         drop(rx);\n-        tx.send(1);\n-    } #[should_fail] }\n+        assert!(tx.send(1).is_err());\n+    }\n \n-    test! { fn smoke_shared_port_gone2() {\n+    #[test]\n+    fn smoke_shared_port_gone2() {\n         let (tx, rx) = sync_channel::<int>(0);\n         drop(rx);\n         let tx2 = tx.clone();\n         drop(tx);\n-        tx2.send(1);\n-    } #[should_fail] }\n+        assert!(tx2.send(1).is_err());\n+    }\n \n-    test! { fn port_gone_concurrent() {\n+    #[test]\n+    fn port_gone_concurrent() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        spawn(move|| {\n-            rx.recv();\n+        let _t = Thread::spawn(move|| {\n+            rx.recv().unwrap();\n         });\n-        loop { tx.send(1) }\n-    } #[should_fail] }\n+        while tx.send(1).is_ok() {}\n+    }\n \n-    test! { fn port_gone_concurrent_shared() {\n+    #[test]\n+    fn port_gone_concurrent_shared() {\n         let (tx, rx) = sync_channel::<int>(0);\n         let tx2 = tx.clone();\n-        spawn(move|| {\n-            rx.recv();\n+        let _t = Thread::spawn(move|| {\n+            rx.recv().unwrap();\n         });\n-        loop {\n-            tx.send(1);\n-            tx2.send(1);\n-        }\n-    } #[should_fail] }\n+        while tx.send(1).is_ok() && tx2.send(1).is_ok() {}\n+    }\n \n-    test! { fn smoke_chan_gone() {\n+    #[test]\n+    fn smoke_chan_gone() {\n         let (tx, rx) = sync_channel::<int>(0);\n         drop(tx);\n-        rx.recv();\n-    } #[should_fail] }\n+        assert!(rx.recv().is_err());\n+    }\n \n-    test! { fn smoke_chan_gone_shared() {\n+    #[test]\n+    fn smoke_chan_gone_shared() {\n         let (tx, rx) = sync_channel::<()>(0);\n         let tx2 = tx.clone();\n         drop(tx);\n         drop(tx2);\n-        rx.recv();\n-    } #[should_fail] }\n+        assert!(rx.recv().is_err());\n+    }\n \n-    test! { fn chan_gone_concurrent() {\n+    #[test]\n+    fn chan_gone_concurrent() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        spawn(move|| {\n-            tx.send(1);\n-            tx.send(1);\n-        });\n-        loop { rx.recv(); }\n-    } #[should_fail] }\n+        Thread::spawn(move|| {\n+            tx.send(1).unwrap();\n+            tx.send(1).unwrap();\n+        }).detach();\n+        while rx.recv().is_ok() {}\n+    }\n \n-    test! { fn stress() {\n+    #[test]\n+    fn stress() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        spawn(move|| {\n-            for _ in range(0u, 10000) { tx.send(1); }\n-        });\n+        Thread::spawn(move|| {\n+            for _ in range(0u, 10000) { tx.send(1).unwrap(); }\n+        }).detach();\n         for _ in range(0u, 10000) {\n-            assert_eq!(rx.recv(), 1);\n+            assert_eq!(rx.recv().unwrap(), 1);\n         }\n-    } }\n+    }\n \n-    test! { fn stress_shared() {\n+    #[test]\n+    fn stress_shared() {\n         static AMT: uint = 1000;\n         static NTHREADS: uint = 8;\n         let (tx, rx) = sync_channel::<int>(0);\n         let (dtx, drx) = sync_channel::<()>(0);\n \n-        spawn(move|| {\n+        Thread::spawn(move|| {\n             for _ in range(0, AMT * NTHREADS) {\n-                assert_eq!(rx.recv(), 1);\n+                assert_eq!(rx.recv().unwrap(), 1);\n             }\n             match rx.try_recv() {\n                 Ok(..) => panic!(),\n                 _ => {}\n             }\n-            dtx.send(());\n-        });\n+            dtx.send(()).unwrap();\n+        }).detach();\n \n         for _ in range(0, NTHREADS) {\n             let tx = tx.clone();\n-            spawn(move|| {\n-                for _ in range(0, AMT) { tx.send(1); }\n-            });\n+            Thread::spawn(move|| {\n+                for _ in range(0, AMT) { tx.send(1).unwrap(); }\n+            }).detach();\n         }\n         drop(tx);\n-        drx.recv();\n-    } }\n+        drx.recv().unwrap();\n+    }\n \n-    test! { fn oneshot_single_thread_close_port_first() {\n+    #[test]\n+    fn oneshot_single_thread_close_port_first() {\n         // Simple test of closing without sending\n         let (_tx, rx) = sync_channel::<int>(0);\n         drop(rx);\n-    } }\n+    }\n \n-    test! { fn oneshot_single_thread_close_chan_first() {\n+    #[test]\n+    fn oneshot_single_thread_close_chan_first() {\n         // Simple test of closing without sending\n         let (tx, _rx) = sync_channel::<int>(0);\n         drop(tx);\n-    } }\n+    }\n \n-    test! { fn oneshot_single_thread_send_port_close() {\n+    #[test]\n+    fn oneshot_single_thread_send_port_close() {\n         // Testing that the sender cleans up the payload if receiver is closed\n         let (tx, rx) = sync_channel::<Box<int>>(0);\n         drop(rx);\n-        tx.send(box 0);\n-    } #[should_fail] }\n+        assert!(tx.send(box 0).is_err());\n+    }\n \n-    test! { fn oneshot_single_thread_recv_chan_close() {\n+    #[test]\n+    fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n         let res = Thread::spawn(move|| {\n             let (tx, rx) = sync_channel::<int>(0);\n             drop(tx);\n-            rx.recv();\n+            rx.recv().unwrap();\n         }).join();\n         // What is our res?\n         assert!(res.is_err());\n-    } }\n+    }\n \n-    test! { fn oneshot_single_thread_send_then_recv() {\n+    #[test]\n+    fn oneshot_single_thread_send_then_recv() {\n         let (tx, rx) = sync_channel::<Box<int>>(1);\n-        tx.send(box 10);\n-        assert!(rx.recv() == box 10);\n-    } }\n+        tx.send(box 10).unwrap();\n+        assert!(rx.recv().unwrap() == box 10);\n+    }\n \n-    test! { fn oneshot_single_thread_try_send_open() {\n+    #[test]\n+    fn oneshot_single_thread_try_send_open() {\n         let (tx, rx) = sync_channel::<int>(1);\n         assert_eq!(tx.try_send(10), Ok(()));\n-        assert!(rx.recv() == 10);\n-    } }\n+        assert!(rx.recv().unwrap() == 10);\n+    }\n \n-    test! { fn oneshot_single_thread_try_send_closed() {\n+    #[test]\n+    fn oneshot_single_thread_try_send_closed() {\n         let (tx, rx) = sync_channel::<int>(0);\n         drop(rx);\n-        assert_eq!(tx.try_send(10), Err(RecvDisconnected(10)));\n-    } }\n+        assert_eq!(tx.try_send(10), Err(TrySendError::Disconnected(10)));\n+    }\n \n-    test! { fn oneshot_single_thread_try_send_closed2() {\n+    #[test]\n+    fn oneshot_single_thread_try_send_closed2() {\n         let (tx, _rx) = sync_channel::<int>(0);\n-        assert_eq!(tx.try_send(10), Err(Full(10)));\n-    } }\n+        assert_eq!(tx.try_send(10), Err(TrySendError::Full(10)));\n+    }\n \n-    test! { fn oneshot_single_thread_try_recv_open() {\n+    #[test]\n+    fn oneshot_single_thread_try_recv_open() {\n         let (tx, rx) = sync_channel::<int>(1);\n-        tx.send(10);\n-        assert!(rx.recv_opt() == Ok(10));\n-    } }\n+        tx.send(10).unwrap();\n+        assert!(rx.recv() == Ok(10));\n+    }\n \n-    test! { fn oneshot_single_thread_try_recv_closed() {\n+    #[test]\n+    fn oneshot_single_thread_try_recv_closed() {\n         let (tx, rx) = sync_channel::<int>(0);\n         drop(tx);\n-        assert!(rx.recv_opt() == Err(()));\n-    } }\n+        assert!(rx.recv().is_err());\n+    }\n \n-    test! { fn oneshot_single_thread_peek_data() {\n+    #[test]\n+    fn oneshot_single_thread_peek_data() {\n         let (tx, rx) = sync_channel::<int>(1);\n-        assert_eq!(rx.try_recv(), Err(Empty));\n-        tx.send(10);\n+        assert_eq!(rx.try_recv(), Err(TryRecvError::Empty));\n+        tx.send(10).unwrap();\n         assert_eq!(rx.try_recv(), Ok(10));\n-    } }\n+    }\n \n-    test! { fn oneshot_single_thread_peek_close() {\n+    #[test]\n+    fn oneshot_single_thread_peek_close() {\n         let (tx, rx) = sync_channel::<int>(0);\n         drop(tx);\n-        assert_eq!(rx.try_recv(), Err(Disconnected));\n-        assert_eq!(rx.try_recv(), Err(Disconnected));\n-    } }\n+        assert_eq!(rx.try_recv(), Err(TryRecvError::Disconnected));\n+        assert_eq!(rx.try_recv(), Err(TryRecvError::Disconnected));\n+    }\n \n-    test! { fn oneshot_single_thread_peek_open() {\n+    #[test]\n+    fn oneshot_single_thread_peek_open() {\n         let (_tx, rx) = sync_channel::<int>(0);\n-        assert_eq!(rx.try_recv(), Err(Empty));\n-    } }\n+        assert_eq!(rx.try_recv(), Err(TryRecvError::Empty));\n+    }\n \n-    test! { fn oneshot_multi_task_recv_then_send() {\n+    #[test]\n+    fn oneshot_multi_task_recv_then_send() {\n         let (tx, rx) = sync_channel::<Box<int>>(0);\n-        spawn(move|| {\n-            assert!(rx.recv() == box 10);\n+        let _t = Thread::spawn(move|| {\n+            assert!(rx.recv().unwrap() == box 10);\n         });\n \n-        tx.send(box 10);\n-    } }\n+        tx.send(box 10).unwrap();\n+    }\n \n-    test! { fn oneshot_multi_task_recv_then_close() {\n+    #[test]\n+    fn oneshot_multi_task_recv_then_close() {\n         let (tx, rx) = sync_channel::<Box<int>>(0);\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             drop(tx);\n         });\n         let res = Thread::spawn(move|| {\n-            assert!(rx.recv() == box 10);\n+            assert!(rx.recv().unwrap() == box 10);\n         }).join();\n         assert!(res.is_err());\n-    } }\n+    }\n \n-    test! { fn oneshot_multi_thread_close_stress() {\n+    #[test]\n+    fn oneshot_multi_thread_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = sync_channel::<int>(0);\n-            spawn(move|| {\n+            let _t = Thread::spawn(move|| {\n                 drop(rx);\n             });\n             drop(tx);\n         }\n-    } }\n+    }\n \n-    test! { fn oneshot_multi_thread_send_close_stress() {\n+    #[test]\n+    fn oneshot_multi_thread_send_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = sync_channel::<int>(0);\n-            spawn(move|| {\n+            let _t = Thread::spawn(move|| {\n                 drop(rx);\n             });\n             let _ = Thread::spawn(move || {\n-                tx.send(1);\n+                tx.send(1).unwrap();\n             }).join();\n         }\n-    } }\n+    }\n \n-    test! { fn oneshot_multi_thread_recv_close_stress() {\n+    #[test]\n+    fn oneshot_multi_thread_recv_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = sync_channel::<int>(0);\n-            spawn(move|| {\n+            let _t = Thread::spawn(move|| {\n                 let res = Thread::spawn(move|| {\n-                    rx.recv();\n+                    rx.recv().unwrap();\n                 }).join();\n                 assert!(res.is_err());\n             });\n-            spawn(move|| {\n-                spawn(move|| {\n+            let _t = Thread::spawn(move|| {\n+                Thread::spawn(move|| {\n                     drop(tx);\n-                });\n+                }).detach();\n             });\n         }\n-    } }\n+    }\n \n-    test! { fn oneshot_multi_thread_send_recv_stress() {\n+    #[test]\n+    fn oneshot_multi_thread_send_recv_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = sync_channel::<Box<int>>(0);\n-            spawn(move|| {\n-                tx.send(box 10i);\n-            });\n-            spawn(move|| {\n-                assert!(rx.recv() == box 10i);\n+            let _t = Thread::spawn(move|| {\n+                tx.send(box 10i).unwrap();\n             });\n+            assert!(rx.recv().unwrap() == box 10i);\n         }\n-    } }\n+    }\n \n-    test! { fn stream_send_recv_stress() {\n+    #[test]\n+    fn stream_send_recv_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = sync_channel::<Box<int>>(0);\n \n@@ -1839,69 +1862,73 @@ mod sync_tests {\n             fn send(tx: SyncSender<Box<int>>, i: int) {\n                 if i == 10 { return }\n \n-                spawn(move|| {\n-                    tx.send(box i);\n+                Thread::spawn(move|| {\n+                    tx.send(box i).unwrap();\n                     send(tx, i + 1);\n-                });\n+                }).detach();\n             }\n \n             fn recv(rx: Receiver<Box<int>>, i: int) {\n                 if i == 10 { return }\n \n-                spawn(move|| {\n-                    assert!(rx.recv() == box i);\n+                Thread::spawn(move|| {\n+                    assert!(rx.recv().unwrap() == box i);\n                     recv(rx, i + 1);\n-                });\n+                }).detach();\n             }\n         }\n-    } }\n+    }\n \n-    test! { fn recv_a_lot() {\n+    #[test]\n+    fn recv_a_lot() {\n         // Regression test that we don't run out of stack in scheduler context\n         let (tx, rx) = sync_channel(10000);\n-        for _ in range(0u, 10000) { tx.send(()); }\n-        for _ in range(0u, 10000) { rx.recv(); }\n-    } }\n+        for _ in range(0u, 10000) { tx.send(()).unwrap(); }\n+        for _ in range(0u, 10000) { rx.recv().unwrap(); }\n+    }\n \n-    test! { fn shared_chan_stress() {\n+    #[test]\n+    fn shared_chan_stress() {\n         let (tx, rx) = sync_channel(0);\n         let total = stress_factor() + 100;\n         for _ in range(0, total) {\n             let tx = tx.clone();\n-            spawn(move|| {\n-                tx.send(());\n-            });\n+            Thread::spawn(move|| {\n+                tx.send(()).unwrap();\n+            }).detach();\n         }\n \n         for _ in range(0, total) {\n-            rx.recv();\n+            rx.recv().unwrap();\n         }\n-    } }\n+    }\n \n-    test! { fn test_nested_recv_iter() {\n+    #[test]\n+    fn test_nested_recv_iter() {\n         let (tx, rx) = sync_channel::<int>(0);\n         let (total_tx, total_rx) = sync_channel::<int>(0);\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut acc = 0;\n             for x in rx.iter() {\n                 acc += x;\n             }\n-            total_tx.send(acc);\n+            total_tx.send(acc).unwrap();\n         });\n \n-        tx.send(3);\n-        tx.send(1);\n-        tx.send(2);\n+        tx.send(3).unwrap();\n+        tx.send(1).unwrap();\n+        tx.send(2).unwrap();\n         drop(tx);\n-        assert_eq!(total_rx.recv(), 6);\n-    } }\n+        assert_eq!(total_rx.recv().unwrap(), 6);\n+    }\n \n-    test! { fn test_recv_iter_break() {\n+    #[test]\n+    fn test_recv_iter_break() {\n         let (tx, rx) = sync_channel::<int>(0);\n         let (count_tx, count_rx) = sync_channel(0);\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut count = 0;\n             for x in rx.iter() {\n                 if count >= 3 {\n@@ -1910,142 +1937,143 @@ mod sync_tests {\n                     count += x;\n                 }\n             }\n-            count_tx.send(count);\n+            count_tx.send(count).unwrap();\n         });\n \n-        tx.send(2);\n-        tx.send(2);\n-        tx.send(2);\n+        tx.send(2).unwrap();\n+        tx.send(2).unwrap();\n+        tx.send(2).unwrap();\n         let _ = tx.try_send(2);\n         drop(tx);\n-        assert_eq!(count_rx.recv(), 4);\n-    } }\n+        assert_eq!(count_rx.recv().unwrap(), 4);\n+    }\n \n-    test! { fn try_recv_states() {\n+    #[test]\n+    fn try_recv_states() {\n         let (tx1, rx1) = sync_channel::<int>(1);\n         let (tx2, rx2) = sync_channel::<()>(1);\n         let (tx3, rx3) = sync_channel::<()>(1);\n-        spawn(move|| {\n-            rx2.recv();\n-            tx1.send(1);\n-            tx3.send(());\n-            rx2.recv();\n+        let _t = Thread::spawn(move|| {\n+            rx2.recv().unwrap();\n+            tx1.send(1).unwrap();\n+            tx3.send(()).unwrap();\n+            rx2.recv().unwrap();\n             drop(tx1);\n-            tx3.send(());\n+            tx3.send(()).unwrap();\n         });\n \n-        assert_eq!(rx1.try_recv(), Err(Empty));\n-        tx2.send(());\n-        rx3.recv();\n+        assert_eq!(rx1.try_recv(), Err(TryRecvError::Empty));\n+        tx2.send(()).unwrap();\n+        rx3.recv().unwrap();\n         assert_eq!(rx1.try_recv(), Ok(1));\n-        assert_eq!(rx1.try_recv(), Err(Empty));\n-        tx2.send(());\n-        rx3.recv();\n-        assert_eq!(rx1.try_recv(), Err(Disconnected));\n-    } }\n+        assert_eq!(rx1.try_recv(), Err(TryRecvError::Empty));\n+        tx2.send(()).unwrap();\n+        rx3.recv().unwrap();\n+        assert_eq!(rx1.try_recv(), Err(TryRecvError::Disconnected));\n+    }\n \n     // This bug used to end up in a livelock inside of the Receiver destructor\n     // because the internal state of the Shared packet was corrupted\n-    test! { fn destroy_upgraded_shared_port_when_sender_still_active() {\n+    #[test]\n+    fn destroy_upgraded_shared_port_when_sender_still_active() {\n         let (tx, rx) = sync_channel::<()>(0);\n         let (tx2, rx2) = sync_channel::<()>(0);\n-        spawn(move|| {\n-            rx.recv(); // wait on a oneshot\n+        let _t = Thread::spawn(move|| {\n+            rx.recv().unwrap(); // wait on a oneshot\n             drop(rx);  // destroy a shared\n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n         // make sure the other task has gone to sleep\n         for _ in range(0u, 5000) { Thread::yield_now(); }\n \n         // upgrade to a shared chan and send a message\n         let t = tx.clone();\n         drop(tx);\n-        t.send(());\n+        t.send(()).unwrap();\n \n         // wait for the child task to exit before we exit\n-        rx2.recv();\n-    } }\n+        rx2.recv().unwrap();\n+    }\n \n-    test! { fn send_opt1() {\n+    #[test]\n+    fn send1() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        spawn(move|| { rx.recv(); });\n-        assert_eq!(tx.send_opt(1), Ok(()));\n-    } }\n+        let _t = Thread::spawn(move|| { rx.recv().unwrap(); });\n+        assert_eq!(tx.send(1), Ok(()));\n+    }\n \n-    test! { fn send_opt2() {\n+    #[test]\n+    fn send2() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        spawn(move|| { drop(rx); });\n-        assert_eq!(tx.send_opt(1), Err(1));\n-    } }\n+        let _t = Thread::spawn(move|| { drop(rx); });\n+        assert!(tx.send(1).is_err());\n+    }\n \n-    test! { fn send_opt3() {\n+    #[test]\n+    fn send3() {\n         let (tx, rx) = sync_channel::<int>(1);\n-        assert_eq!(tx.send_opt(1), Ok(()));\n-        spawn(move|| { drop(rx); });\n-        assert_eq!(tx.send_opt(1), Err(1));\n-    } }\n+        assert_eq!(tx.send(1), Ok(()));\n+        let _t =Thread::spawn(move|| { drop(rx); });\n+        assert!(tx.send(1).is_err());\n+    }\n \n-    test! { fn send_opt4() {\n+    #[test]\n+    fn send4() {\n         let (tx, rx) = sync_channel::<int>(0);\n         let tx2 = tx.clone();\n         let (done, donerx) = channel();\n         let done2 = done.clone();\n-        spawn(move|| {\n-            assert_eq!(tx.send_opt(1), Err(1));\n-            done.send(());\n+        let _t = Thread::spawn(move|| {\n+            assert!(tx.send(1).is_err());\n+            done.send(()).unwrap();\n         });\n-        spawn(move|| {\n-            assert_eq!(tx2.send_opt(2), Err(2));\n-            done2.send(());\n+        let _t = Thread::spawn(move|| {\n+            assert!(tx2.send(2).is_err());\n+            done2.send(()).unwrap();\n         });\n         drop(rx);\n-        donerx.recv();\n-        donerx.recv();\n-    } }\n+        donerx.recv().unwrap();\n+        donerx.recv().unwrap();\n+    }\n \n-    test! { fn try_send1() {\n+    #[test]\n+    fn try_send1() {\n         let (tx, _rx) = sync_channel::<int>(0);\n-        assert_eq!(tx.try_send(1), Err(Full(1)));\n-    } }\n+        assert_eq!(tx.try_send(1), Err(TrySendError::Full(1)));\n+    }\n \n-    test! { fn try_send2() {\n+    #[test]\n+    fn try_send2() {\n         let (tx, _rx) = sync_channel::<int>(1);\n         assert_eq!(tx.try_send(1), Ok(()));\n-        assert_eq!(tx.try_send(1), Err(Full(1)));\n-    } }\n+        assert_eq!(tx.try_send(1), Err(TrySendError::Full(1)));\n+    }\n \n-    test! { fn try_send3() {\n+    #[test]\n+    fn try_send3() {\n         let (tx, rx) = sync_channel::<int>(1);\n         assert_eq!(tx.try_send(1), Ok(()));\n         drop(rx);\n-        assert_eq!(tx.try_send(1), Err(RecvDisconnected(1)));\n-    } }\n-\n-    test! { fn try_send4() {\n-        let (tx, rx) = sync_channel::<int>(0);\n-        spawn(move|| {\n-            for _ in range(0u, 1000) { Thread::yield_now(); }\n-            assert_eq!(tx.try_send(1), Ok(()));\n-        });\n-        assert_eq!(rx.recv(), 1);\n-    } #[ignore(reason = \"flaky on libnative\")] }\n+        assert_eq!(tx.try_send(1), Err(TrySendError::Disconnected(1)));\n+    }\n \n-    test! { fn issue_15761() {\n+    #[test]\n+    fn issue_15761() {\n         fn repro() {\n             let (tx1, rx1) = sync_channel::<()>(3);\n             let (tx2, rx2) = sync_channel::<()>(3);\n \n-            spawn(move|| {\n-                rx1.recv();\n+            let _t = Thread::spawn(move|| {\n+                rx1.recv().unwrap();\n                 tx2.try_send(()).unwrap();\n             });\n \n             tx1.try_send(()).unwrap();\n-            rx2.recv();\n+            rx2.recv().unwrap();\n         }\n \n         for _ in range(0u, 100) {\n             repro()\n         }\n-    } }\n+    }\n }", "previous_filename": "src/libstd/comm/mod.rs"}, {"sha": "8945233dac9cd90ebdf440690df4f08a5d104492", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "renamed", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -153,11 +153,12 @@ impl<T: Send> Drop for Queue<T> {\n \n #[cfg(test)]\n mod tests {\n-    use prelude::*;\n-\n-    use alloc::arc::Arc;\n+    use prelude::v1::*;\n \n+    use sync::mpsc::channel;\n     use super::{Queue, Data, Empty, Inconsistent};\n+    use sync::Arc;\n+    use thread::Thread;\n \n     #[test]\n     fn test_full() {\n@@ -181,12 +182,12 @@ mod tests {\n         for _ in range(0, nthreads) {\n             let tx = tx.clone();\n             let q = q.clone();\n-            spawn(move|| {\n+            Thread::spawn(move|| {\n                 for i in range(0, nmsgs) {\n                     q.push(i);\n                 }\n-                tx.send(());\n-            });\n+                tx.send(()).unwrap();\n+            }).detach();\n         }\n \n         let mut i = 0u;\n@@ -198,7 +199,7 @@ mod tests {\n         }\n         drop(tx);\n         for _ in range(0, nthreads) {\n-            rx.recv();\n+            rx.recv().unwrap();\n         }\n     }\n }", "previous_filename": "src/libstd/comm/mpsc_queue.rs"}, {"sha": "5f599752a46fcfbd5067c74b354da718574b4a27", "filename": "src/libstd/sync/mpsc/oneshot.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -39,8 +39,8 @@ use self::MyUpgrade::*;\n \n use core::prelude::*;\n \n-use comm::Receiver;\n-use comm::blocking::{mod, SignalToken};\n+use sync::mpsc::Receiver;\n+use sync::mpsc::blocking::{mod, SignalToken};\n use core::mem;\n use sync::atomic;\n ", "previous_filename": "src/libstd/comm/oneshot.rs"}, {"sha": "43554d7c335a4c4471084162593651789fcc2c64", "filename": "src/libstd/sync/mpsc/select.rs", "status": "renamed", "additions": 184, "deletions": 159, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -27,18 +27,20 @@\n //! # Example\n //!\n //! ```rust\n+//! use std::sync::mpsc::channel;\n+//!\n //! let (tx1, rx1) = channel();\n //! let (tx2, rx2) = channel();\n //!\n-//! tx1.send(1i);\n-//! tx2.send(2i);\n+//! tx1.send(1i).unwrap();\n+//! tx2.send(2i).unwrap();\n //!\n //! select! {\n //!     val = rx1.recv() => {\n-//!         assert_eq!(val, 1i);\n+//!         assert_eq!(val.unwrap(), 1i);\n //!     },\n //!     val = rx2.recv() => {\n-//!         assert_eq!(val, 2i);\n+//!         assert_eq!(val.unwrap(), 2i);\n //!     }\n //! }\n //! ```\n@@ -59,8 +61,8 @@ use core::kinds::marker;\n use core::mem;\n use core::uint;\n \n-use comm::Receiver;\n-use comm::blocking::{mod, SignalToken};\n+use sync::mpsc::{Receiver, RecvError};\n+use sync::mpsc::blocking::{mod, SignalToken};\n \n /// The \"receiver set\" of the select interface. This structure is used to manage\n /// a set of receivers which are being selected over.\n@@ -245,13 +247,10 @@ impl<'rx, T: Send> Handle<'rx, T> {\n     #[inline]\n     pub fn id(&self) -> uint { self.id }\n \n-    /// Receive a value on the underlying receiver. Has the same semantics as\n-    /// `Receiver.recv`\n-    pub fn recv(&mut self) -> T { self.rx.recv() }\n     /// Block to receive a value on the underlying receiver, returning `Some` on\n     /// success or `None` if the channel disconnects. This function has the same\n-    /// semantics as `Receiver.recv_opt`\n-    pub fn recv_opt(&mut self) -> Result<T, ()> { self.rx.recv_opt() }\n+    /// semantics as `Receiver.recv`\n+    pub fn recv(&mut self) -> Result<T, RecvError> { self.rx.recv() }\n \n     /// Adds this handle to the receiver set that the handle was created from. This\n     /// method can be called multiple times, but it has no effect if `add` was\n@@ -335,17 +334,17 @@ impl Iterator<*mut Handle<'static, ()>> for Packets {\n #[cfg(test)]\n #[allow(unused_imports)]\n mod test {\n-    use prelude::*;\n+    use prelude::v1::*;\n \n-    use super::*;\n+    use thread::Thread;\n+    use sync::mpsc::*;\n \n     // Don't use the libstd version so we can pull in the right Select structure\n     // (std::comm points at the wrong one)\n     macro_rules! select {\n         (\n             $($name:pat = $rx:ident.$meth:ident() => $code:expr),+\n         ) => ({\n-            use comm::Select;\n             let sel = Select::new();\n             $( let mut $rx = sel.handle(&$rx); )+\n             unsafe {\n@@ -357,365 +356,391 @@ mod test {\n         })\n     }\n \n-    test! { fn smoke() {\n+    #[test]\n+    fn smoke() {\n         let (tx1, rx1) = channel::<int>();\n         let (tx2, rx2) = channel::<int>();\n-        tx1.send(1);\n+        tx1.send(1).unwrap();\n         select! {\n-            foo = rx1.recv() => { assert_eq!(foo, 1); },\n+            foo = rx1.recv() => { assert_eq!(foo.unwrap(), 1); },\n             _bar = rx2.recv() => { panic!() }\n         }\n-        tx2.send(2);\n+        tx2.send(2).unwrap();\n         select! {\n             _foo = rx1.recv() => { panic!() },\n-            bar = rx2.recv() => { assert_eq!(bar, 2) }\n+            bar = rx2.recv() => { assert_eq!(bar.unwrap(), 2) }\n         }\n         drop(tx1);\n         select! {\n-            foo = rx1.recv_opt() => { assert_eq!(foo, Err(())); },\n+            foo = rx1.recv() => { assert!(foo.is_err()); },\n             _bar = rx2.recv() => { panic!() }\n         }\n         drop(tx2);\n         select! {\n-            bar = rx2.recv_opt() => { assert_eq!(bar, Err(())); }\n+            bar = rx2.recv() => { assert!(bar.is_err()); }\n         }\n-    } }\n+    }\n \n-    test! { fn smoke2() {\n+    #[test]\n+    fn smoke2() {\n         let (_tx1, rx1) = channel::<int>();\n         let (_tx2, rx2) = channel::<int>();\n         let (_tx3, rx3) = channel::<int>();\n         let (_tx4, rx4) = channel::<int>();\n         let (tx5, rx5) = channel::<int>();\n-        tx5.send(4);\n+        tx5.send(4).unwrap();\n         select! {\n             _foo = rx1.recv() => { panic!(\"1\") },\n             _foo = rx2.recv() => { panic!(\"2\") },\n             _foo = rx3.recv() => { panic!(\"3\") },\n             _foo = rx4.recv() => { panic!(\"4\") },\n-            foo = rx5.recv() => { assert_eq!(foo, 4); }\n+            foo = rx5.recv() => { assert_eq!(foo.unwrap(), 4); }\n         }\n-    } }\n+    }\n \n-    test! { fn closed() {\n+    #[test]\n+    fn closed() {\n         let (_tx1, rx1) = channel::<int>();\n         let (tx2, rx2) = channel::<int>();\n         drop(tx2);\n \n         select! {\n-            _a1 = rx1.recv_opt() => { panic!() },\n-            a2 = rx2.recv_opt() => { assert_eq!(a2, Err(())); }\n+            _a1 = rx1.recv() => { panic!() },\n+            a2 = rx2.recv() => { assert!(a2.is_err()); }\n         }\n-    } }\n+    }\n \n-    test! { fn unblocks() {\n+    #[test]\n+    fn unblocks() {\n         let (tx1, rx1) = channel::<int>();\n         let (_tx2, rx2) = channel::<int>();\n         let (tx3, rx3) = channel::<int>();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             for _ in range(0u, 20) { Thread::yield_now(); }\n-            tx1.send(1);\n-            rx3.recv();\n+            tx1.send(1).unwrap();\n+            rx3.recv().unwrap();\n             for _ in range(0u, 20) { Thread::yield_now(); }\n         });\n \n         select! {\n-            a = rx1.recv() => { assert_eq!(a, 1); },\n+            a = rx1.recv() => { assert_eq!(a.unwrap(), 1); },\n             _b = rx2.recv() => { panic!() }\n         }\n-        tx3.send(1);\n+        tx3.send(1).unwrap();\n         select! {\n-            a = rx1.recv_opt() => { assert_eq!(a, Err(())); },\n+            a = rx1.recv() => { assert!(a.is_err()) },\n             _b = rx2.recv() => { panic!() }\n         }\n-    } }\n+    }\n \n-    test! { fn both_ready() {\n+    #[test]\n+    fn both_ready() {\n         let (tx1, rx1) = channel::<int>();\n         let (tx2, rx2) = channel::<int>();\n         let (tx3, rx3) = channel::<()>();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             for _ in range(0u, 20) { Thread::yield_now(); }\n-            tx1.send(1);\n-            tx2.send(2);\n-            rx3.recv();\n+            tx1.send(1).unwrap();\n+            tx2.send(2).unwrap();\n+            rx3.recv().unwrap();\n         });\n \n         select! {\n-            a = rx1.recv() => { assert_eq!(a, 1); },\n-            a = rx2.recv() => { assert_eq!(a, 2); }\n+            a = rx1.recv() => { assert_eq!(a.unwrap(), 1); },\n+            a = rx2.recv() => { assert_eq!(a.unwrap(), 2); }\n         }\n         select! {\n-            a = rx1.recv() => { assert_eq!(a, 1); },\n-            a = rx2.recv() => { assert_eq!(a, 2); }\n+            a = rx1.recv() => { assert_eq!(a.unwrap(), 1); },\n+            a = rx2.recv() => { assert_eq!(a.unwrap(), 2); }\n         }\n-        assert_eq!(rx1.try_recv(), Err(Empty));\n-        assert_eq!(rx2.try_recv(), Err(Empty));\n-        tx3.send(());\n-    } }\n+        assert_eq!(rx1.try_recv(), Err(TryRecvError::Empty));\n+        assert_eq!(rx2.try_recv(), Err(TryRecvError::Empty));\n+        tx3.send(()).unwrap();\n+    }\n \n-    test! { fn stress() {\n+    #[test]\n+    fn stress() {\n         static AMT: int = 10000;\n         let (tx1, rx1) = channel::<int>();\n         let (tx2, rx2) = channel::<int>();\n         let (tx3, rx3) = channel::<()>();\n \n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             for i in range(0, AMT) {\n                 if i % 2 == 0 {\n-                    tx1.send(i);\n+                    tx1.send(i).unwrap();\n                 } else {\n-                    tx2.send(i);\n+                    tx2.send(i).unwrap();\n                 }\n-                rx3.recv();\n+                rx3.recv().unwrap();\n             }\n         });\n \n         for i in range(0, AMT) {\n             select! {\n-                i1 = rx1.recv() => { assert!(i % 2 == 0 && i == i1); },\n-                i2 = rx2.recv() => { assert!(i % 2 == 1 && i == i2); }\n+                i1 = rx1.recv() => { assert!(i % 2 == 0 && i == i1.unwrap()); },\n+                i2 = rx2.recv() => { assert!(i % 2 == 1 && i == i2.unwrap()); }\n             }\n-            tx3.send(());\n+            tx3.send(()).unwrap();\n         }\n-    } }\n+    }\n \n-    test! { fn cloning() {\n+    #[test]\n+    fn cloning() {\n         let (tx1, rx1) = channel::<int>();\n         let (_tx2, rx2) = channel::<int>();\n         let (tx3, rx3) = channel::<()>();\n \n-        spawn(move|| {\n-            rx3.recv();\n+        let _t = Thread::spawn(move|| {\n+            rx3.recv().unwrap();\n             tx1.clone();\n-            assert_eq!(rx3.try_recv(), Err(Empty));\n-            tx1.send(2);\n-            rx3.recv();\n+            assert_eq!(rx3.try_recv(), Err(TryRecvError::Empty));\n+            tx1.send(2).unwrap();\n+            rx3.recv().unwrap();\n         });\n \n-        tx3.send(());\n+        tx3.send(()).unwrap();\n         select! {\n             _i1 = rx1.recv() => {},\n             _i2 = rx2.recv() => panic!()\n         }\n-        tx3.send(());\n-    } }\n+        tx3.send(()).unwrap();\n+    }\n \n-    test! { fn cloning2() {\n+    #[test]\n+    fn cloning2() {\n         let (tx1, rx1) = channel::<int>();\n         let (_tx2, rx2) = channel::<int>();\n         let (tx3, rx3) = channel::<()>();\n \n-        spawn(move|| {\n-            rx3.recv();\n+        let _t = Thread::spawn(move|| {\n+            rx3.recv().unwrap();\n             tx1.clone();\n-            assert_eq!(rx3.try_recv(), Err(Empty));\n-            tx1.send(2);\n-            rx3.recv();\n+            assert_eq!(rx3.try_recv(), Err(TryRecvError::Empty));\n+            tx1.send(2).unwrap();\n+            rx3.recv().unwrap();\n         });\n \n-        tx3.send(());\n+        tx3.send(()).unwrap();\n         select! {\n             _i1 = rx1.recv() => {},\n             _i2 = rx2.recv() => panic!()\n         }\n-        tx3.send(());\n-    } }\n+        tx3.send(()).unwrap();\n+    }\n \n-    test! { fn cloning3() {\n+    #[test]\n+    fn cloning3() {\n         let (tx1, rx1) = channel::<()>();\n         let (tx2, rx2) = channel::<()>();\n         let (tx3, rx3) = channel::<()>();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let s = Select::new();\n             let mut h1 = s.handle(&rx1);\n             let mut h2 = s.handle(&rx2);\n             unsafe { h2.add(); }\n             unsafe { h1.add(); }\n             assert_eq!(s.wait(), h2.id);\n-            tx3.send(());\n+            tx3.send(()).unwrap();\n         });\n \n         for _ in range(0u, 1000) { Thread::yield_now(); }\n         drop(tx1.clone());\n-        tx2.send(());\n-        rx3.recv();\n-    } }\n+        tx2.send(()).unwrap();\n+        rx3.recv().unwrap();\n+    }\n \n-    test! { fn preflight1() {\n+    #[test]\n+    fn preflight1() {\n         let (tx, rx) = channel();\n-        tx.send(());\n+        tx.send(()).unwrap();\n         select! {\n-            () = rx.recv() => {}\n+            _n = rx.recv() => {}\n         }\n-    } }\n+    }\n \n-    test! { fn preflight2() {\n+    #[test]\n+    fn preflight2() {\n         let (tx, rx) = channel();\n-        tx.send(());\n-        tx.send(());\n+        tx.send(()).unwrap();\n+        tx.send(()).unwrap();\n         select! {\n-            () = rx.recv() => {}\n+            _n = rx.recv() => {}\n         }\n-    } }\n+    }\n \n-    test! { fn preflight3() {\n+    #[test]\n+    fn preflight3() {\n         let (tx, rx) = channel();\n         drop(tx.clone());\n-        tx.send(());\n+        tx.send(()).unwrap();\n         select! {\n-            () = rx.recv() => {}\n+            _n = rx.recv() => {}\n         }\n-    } }\n+    }\n \n-    test! { fn preflight4() {\n+    #[test]\n+    fn preflight4() {\n         let (tx, rx) = channel();\n-        tx.send(());\n+        tx.send(()).unwrap();\n         let s = Select::new();\n         let mut h = s.handle(&rx);\n         unsafe { h.add(); }\n         assert_eq!(s.wait2(false), h.id);\n-    } }\n+    }\n \n-    test! { fn preflight5() {\n+    #[test]\n+    fn preflight5() {\n         let (tx, rx) = channel();\n-        tx.send(());\n-        tx.send(());\n+        tx.send(()).unwrap();\n+        tx.send(()).unwrap();\n         let s = Select::new();\n         let mut h = s.handle(&rx);\n         unsafe { h.add(); }\n         assert_eq!(s.wait2(false), h.id);\n-    } }\n+    }\n \n-    test! { fn preflight6() {\n+    #[test]\n+    fn preflight6() {\n         let (tx, rx) = channel();\n         drop(tx.clone());\n-        tx.send(());\n+        tx.send(()).unwrap();\n         let s = Select::new();\n         let mut h = s.handle(&rx);\n         unsafe { h.add(); }\n         assert_eq!(s.wait2(false), h.id);\n-    } }\n+    }\n \n-    test! { fn preflight7() {\n+    #[test]\n+    fn preflight7() {\n         let (tx, rx) = channel::<()>();\n         drop(tx);\n         let s = Select::new();\n         let mut h = s.handle(&rx);\n         unsafe { h.add(); }\n         assert_eq!(s.wait2(false), h.id);\n-    } }\n+    }\n \n-    test! { fn preflight8() {\n+    #[test]\n+    fn preflight8() {\n         let (tx, rx) = channel();\n-        tx.send(());\n+        tx.send(()).unwrap();\n         drop(tx);\n-        rx.recv();\n+        rx.recv().unwrap();\n         let s = Select::new();\n         let mut h = s.handle(&rx);\n         unsafe { h.add(); }\n         assert_eq!(s.wait2(false), h.id);\n-    } }\n+    }\n \n-    test! { fn preflight9() {\n+    #[test]\n+    fn preflight9() {\n         let (tx, rx) = channel();\n         drop(tx.clone());\n-        tx.send(());\n+        tx.send(()).unwrap();\n         drop(tx);\n-        rx.recv();\n+        rx.recv().unwrap();\n         let s = Select::new();\n         let mut h = s.handle(&rx);\n         unsafe { h.add(); }\n         assert_eq!(s.wait2(false), h.id);\n-    } }\n+    }\n \n-    test! { fn oneshot_data_waiting() {\n+    #[test]\n+    fn oneshot_data_waiting() {\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             select! {\n-                () = rx1.recv() => {}\n+                _n = rx1.recv() => {}\n             }\n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n \n         for _ in range(0u, 100) { Thread::yield_now() }\n-        tx1.send(());\n-        rx2.recv();\n-    } }\n+        tx1.send(()).unwrap();\n+        rx2.recv().unwrap();\n+    }\n \n-    test! { fn stream_data_waiting() {\n+    #[test]\n+    fn stream_data_waiting() {\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n-        tx1.send(());\n-        tx1.send(());\n-        rx1.recv();\n-        rx1.recv();\n-        spawn(move|| {\n+        tx1.send(()).unwrap();\n+        tx1.send(()).unwrap();\n+        rx1.recv().unwrap();\n+        rx1.recv().unwrap();\n+        let _t = Thread::spawn(move|| {\n             select! {\n-                () = rx1.recv() => {}\n+                _n = rx1.recv() => {}\n             }\n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n \n         for _ in range(0u, 100) { Thread::yield_now() }\n-        tx1.send(());\n-        rx2.recv();\n-    } }\n+        tx1.send(()).unwrap();\n+        rx2.recv().unwrap();\n+    }\n \n-    test! { fn shared_data_waiting() {\n+    #[test]\n+    fn shared_data_waiting() {\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n         drop(tx1.clone());\n-        tx1.send(());\n-        rx1.recv();\n-        spawn(move|| {\n+        tx1.send(()).unwrap();\n+        rx1.recv().unwrap();\n+        let _t = Thread::spawn(move|| {\n             select! {\n-                () = rx1.recv() => {}\n+                _n = rx1.recv() => {}\n             }\n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n \n         for _ in range(0u, 100) { Thread::yield_now() }\n-        tx1.send(());\n-        rx2.recv();\n-    } }\n+        tx1.send(()).unwrap();\n+        rx2.recv().unwrap();\n+    }\n \n-    test! { fn sync1() {\n+    #[test]\n+    fn sync1() {\n         let (tx, rx) = sync_channel::<int>(1);\n-        tx.send(1);\n+        tx.send(1).unwrap();\n         select! {\n-            n = rx.recv() => { assert_eq!(n, 1); }\n+            n = rx.recv() => { assert_eq!(n.unwrap(), 1); }\n         }\n-    } }\n+    }\n \n-    test! { fn sync2() {\n+    #[test]\n+    fn sync2() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             for _ in range(0u, 100) { Thread::yield_now() }\n-            tx.send(1);\n+            tx.send(1).unwrap();\n         });\n         select! {\n-            n = rx.recv() => { assert_eq!(n, 1); }\n+            n = rx.recv() => { assert_eq!(n.unwrap(), 1); }\n         }\n-    } }\n+    }\n \n-    test! { fn sync3() {\n+    #[test]\n+    fn sync3() {\n         let (tx1, rx1) = sync_channel::<int>(0);\n         let (tx2, rx2): (Sender<int>, Receiver<int>) = channel();\n-        spawn(move|| { tx1.send(1); });\n-        spawn(move|| { tx2.send(2); });\n+        let _t = Thread::spawn(move|| { tx1.send(1).unwrap(); });\n+        let _t = Thread::spawn(move|| { tx2.send(2).unwrap(); });\n         select! {\n             n = rx1.recv() => {\n+                let n = n.unwrap();\n                 assert_eq!(n, 1);\n-                assert_eq!(rx2.recv(), 2);\n+                assert_eq!(rx2.recv().unwrap(), 2);\n             },\n             n = rx2.recv() => {\n+                let n = n.unwrap();\n                 assert_eq!(n, 2);\n-                assert_eq!(rx1.recv(), 1);\n+                assert_eq!(rx1.recv().unwrap(), 1);\n             }\n         }\n-    } }\n+    }\n }", "previous_filename": "src/libstd/comm/select.rs"}, {"sha": "e15c38cf9a1b35e1b64c41021ea34607858c18ec", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -26,10 +26,10 @@ use core::cmp;\n use core::int;\n \n use sync::{atomic, Mutex, MutexGuard};\n-use comm::mpsc_queue as mpsc;\n-use comm::blocking::{mod, SignalToken};\n-use comm::select::StartResult;\n-use comm::select::StartResult::*;\n+use sync::mpsc::mpsc_queue as mpsc;\n+use sync::mpsc::blocking::{mod, SignalToken};\n+use sync::mpsc::select::StartResult;\n+use sync::mpsc::select::StartResult::*;\n use thread::Thread;\n \n const DISCONNECTED: int = int::MIN;", "previous_filename": "src/libstd/comm/shared.rs"}, {"sha": "15624601157fdb12898737bd72b3aeed2bc61f23", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "renamed", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -240,10 +240,12 @@ impl<T: Send> Drop for Queue<T> {\n \n #[cfg(test)]\n mod test {\n-    use prelude::*;\n+    use prelude::v1::*;\n \n     use sync::Arc;\n     use super::Queue;\n+    use thread::Thread;\n+    use sync::mpsc::channel;\n \n     #[test]\n     fn smoke() {\n@@ -320,7 +322,7 @@ mod test {\n \n             let (tx, rx) = channel();\n             let q2 = q.clone();\n-            spawn(move|| {\n+            let _t = Thread::spawn(move|| {\n                 for _ in range(0u, 100000) {\n                     loop {\n                         match q2.pop() {\n@@ -330,12 +332,12 @@ mod test {\n                         }\n                     }\n                 }\n-                tx.send(());\n+                tx.send(()).unwrap();\n             });\n             for _ in range(0i, 100000) {\n                 q.push(1);\n             }\n-            rx.recv();\n+            rx.recv().unwrap();\n         }\n     }\n }", "previous_filename": "src/libstd/comm/spsc_queue.rs"}, {"sha": "01b799283ee3b58f5679b6b059dbec9675060c0c", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -28,10 +28,10 @@ use core::cmp;\n use core::int;\n use thread::Thread;\n \n+use sync::mpsc::blocking::{mod, SignalToken};\n+use sync::mpsc::spsc_queue as spsc;\n+use sync::mpsc::Receiver;\n use sync::atomic;\n-use comm::spsc_queue as spsc;\n-use comm::Receiver;\n-use comm::blocking::{mod, SignalToken};\n \n const DISCONNECTED: int = int::MIN;\n #[cfg(test)]", "previous_filename": "src/libstd/comm/stream.rs"}, {"sha": "98f1c4c46f9fb847b2b406449b16a3f22944c0ff", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -42,8 +42,8 @@ use vec::Vec;\n use core::mem;\n \n use sync::{atomic, Mutex, MutexGuard};\n-use comm::blocking::{mod, WaitToken, SignalToken};\n-use comm::select::StartResult::{mod, Installed, Abort};\n+use sync::mpsc::blocking::{mod, WaitToken, SignalToken};\n+use sync::mpsc::select::StartResult::{mod, Installed, Abort};\n \n pub struct Packet<T> {\n     /// Only field outside of the mutex. Just done for kicks, but mainly because\n@@ -204,14 +204,14 @@ impl<T: Send> Packet<T> {\n     pub fn try_send(&self, t: T) -> Result<(), super::TrySendError<T>> {\n         let mut guard = self.lock.lock().unwrap();\n         if guard.disconnected {\n-            Err(super::RecvDisconnected(t))\n+            Err(super::TrySendError::Disconnected(t))\n         } else if guard.buf.size() == guard.buf.cap() {\n-            Err(super::Full(t))\n+            Err(super::TrySendError::Full(t))\n         } else if guard.cap == 0 {\n             // With capacity 0, even though we have buffer space we can't\n             // transfer the data unless there's a receiver waiting.\n             match mem::replace(&mut guard.blocker, NoneBlocked) {\n-                NoneBlocked => Err(super::Full(t)),\n+                NoneBlocked => Err(super::TrySendError::Full(t)),\n                 BlockedSender(..) => unreachable!(),\n                 BlockedReceiver(token) => {\n                     guard.buf.enqueue(t);", "previous_filename": "src/libstd/comm/sync.rs"}, {"sha": "f9f9a809221713a86fd821e3079b3ef958e728fd", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use prelude::*;\n+use prelude::v1::*;\n \n use cell::UnsafeCell;\n use kinds::marker;\n+use ops::{Deref, DerefMut};\n use sync::poison::{mod, TryLockError, TryLockResult, LockResult};\n use sys_common::mutex as sys;\n \n@@ -47,6 +48,8 @@ use sys_common::mutex as sys;\n /// ```rust\n /// use std::sync::{Arc, Mutex};\n /// use std::thread::Thread;\n+/// use std::sync::mpsc::channel;\n+///\n /// const N: uint = 10;\n ///\n /// // Spawn a few threads to increment a shared variable (non-atomically), and\n@@ -69,13 +72,13 @@ use sys_common::mutex as sys;\n ///         let mut data = data.lock().unwrap();\n ///         *data += 1;\n ///         if *data == N {\n-///             tx.send(());\n+///             tx.send(()).unwrap();\n ///         }\n ///         // the lock is unlocked here when `data` goes out of scope.\n ///     }).detach();\n /// }\n ///\n-/// rx.recv();\n+/// rx.recv().unwrap();\n /// ```\n ///\n /// To recover from a poisoned mutex:\n@@ -288,12 +291,14 @@ impl<'mutex, T> MutexGuard<'mutex, T> {\n     }\n }\n \n-impl<'mutex, T> Deref<T> for MutexGuard<'mutex, T> {\n+impl<'mutex, T> Deref for MutexGuard<'mutex, T> {\n+    type Target = T;\n+\n     fn deref<'a>(&'a self) -> &'a T {\n         unsafe { &*self.__data.get() }\n     }\n }\n-impl<'mutex, T> DerefMut<T> for MutexGuard<'mutex, T> {\n+impl<'mutex, T> DerefMut for MutexGuard<'mutex, T> {\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n         unsafe { &mut *self.__data.get() }\n     }\n@@ -320,10 +325,11 @@ pub fn guard_poison<'a, T>(guard: &MutexGuard<'a, T>) -> &'a poison::Flag {\n \n #[cfg(test)]\n mod test {\n-    use prelude::*;\n+    use prelude::v1::*;\n \n-    use thread::Thread;\n+    use sync::mpsc::channel;\n     use sync::{Arc, Mutex, StaticMutex, MUTEX_INIT, Condvar};\n+    use thread::Thread;\n \n     struct Packet<T>(Arc<(Mutex<T>, Condvar)>);\n \n@@ -366,14 +372,14 @@ mod test {\n         let (tx, rx) = channel();\n         for _ in range(0, K) {\n             let tx2 = tx.clone();\n-            spawn(move|| { inc(); tx2.send(()); });\n+            Thread::spawn(move|| { inc(); tx2.send(()).unwrap(); }).detach();\n             let tx2 = tx.clone();\n-            spawn(move|| { inc(); tx2.send(()); });\n+            Thread::spawn(move|| { inc(); tx2.send(()).unwrap(); }).detach();\n         }\n \n         drop(tx);\n         for _ in range(0, 2 * K) {\n-            rx.recv();\n+            rx.recv().unwrap();\n         }\n         assert_eq!(unsafe {CNT}, J * K * 2);\n         unsafe {\n@@ -392,9 +398,9 @@ mod test {\n         let packet = Packet(Arc::new((Mutex::new(false), Condvar::new())));\n         let packet2 = Packet(packet.0.clone());\n         let (tx, rx) = channel();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             // wait until parent gets in\n-            rx.recv();\n+            rx.recv().unwrap();\n             let &(ref lock, ref cvar) = &*packet2.0;\n             let mut lock = lock.lock().unwrap();\n             *lock = true;\n@@ -403,7 +409,7 @@ mod test {\n \n         let &(ref lock, ref cvar) = &*packet.0;\n         let mut lock = lock.lock().unwrap();\n-        tx.send(());\n+        tx.send(()).unwrap();\n         assert!(!*lock);\n         while !*lock {\n             lock = cvar.wait(lock).unwrap();\n@@ -416,8 +422,8 @@ mod test {\n         let packet2 = Packet(packet.0.clone());\n         let (tx, rx) = channel();\n \n-        spawn(move|| {\n-            rx.recv();\n+        let _t = Thread::spawn(move || -> () {\n+            rx.recv().unwrap();\n             let &(ref lock, ref cvar) = &*packet2.0;\n             let _g = lock.lock().unwrap();\n             cvar.notify_one();\n@@ -427,7 +433,7 @@ mod test {\n \n         let &(ref lock, ref cvar) = &*packet.0;\n         let mut lock = lock.lock().unwrap();\n-        tx.send(());\n+        tx.send(()).unwrap();\n         while *lock == 1 {\n             match cvar.wait(lock) {\n                 Ok(l) => {\n@@ -443,7 +449,7 @@ mod test {\n     fn test_mutex_arc_poison() {\n         let arc = Arc::new(Mutex::new(1i));\n         let arc2 = arc.clone();\n-        Thread::spawn(move|| {\n+        let _ = Thread::spawn(move|| {\n             let lock = arc2.lock().unwrap();\n             assert_eq!(*lock, 2);\n         }).join();\n@@ -457,13 +463,13 @@ mod test {\n         let arc = Arc::new(Mutex::new(1i));\n         let arc2 = Arc::new(Mutex::new(arc));\n         let (tx, rx) = channel();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let lock = arc2.lock().unwrap();\n-            let lock2 = lock.deref().lock().unwrap();\n+            let lock2 = lock.lock().unwrap();\n             assert_eq!(*lock2, 1);\n-            tx.send(());\n+            tx.send(()).unwrap();\n         });\n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     #[test]"}, {"sha": "9e9a17e482fbf2c72e24fbf07d90a0f210538a35", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -32,10 +32,11 @@ use sync::{StaticMutex, MUTEX_INIT};\n ///\n /// static START: Once = ONCE_INIT;\n ///\n-/// START.doit(|| {\n+/// START.call_once(|| {\n ///     // run initialization here\n /// });\n /// ```\n+#[stable]\n pub struct Once {\n     mutex: StaticMutex,\n     cnt: atomic::AtomicInt,\n@@ -45,23 +46,25 @@ pub struct Once {\n unsafe impl Sync for Once {}\n \n /// Initialization value for static `Once` values.\n+#[stable]\n pub const ONCE_INIT: Once = Once {\n     mutex: MUTEX_INIT,\n-    cnt: atomic::INIT_ATOMIC_INT,\n-    lock_cnt: atomic::INIT_ATOMIC_INT,\n+    cnt: atomic::ATOMIC_INT_INIT,\n+    lock_cnt: atomic::ATOMIC_INT_INIT,\n };\n \n impl Once {\n     /// Perform an initialization routine once and only once. The given closure\n-    /// will be executed if this is the first time `doit` has been called, and\n-    /// otherwise the routine will *not* be invoked.\n+    /// will be executed if this is the first time `call_once` has been called,\n+    /// and otherwise the routine will *not* be invoked.\n     ///\n     /// This method will block the calling task if another initialization\n     /// routine is currently running.\n     ///\n     /// When this function returns, it is guaranteed that some initialization\n     /// has run and completed (it may not be the closure specified).\n-    pub fn doit<F>(&'static self, f: F) where F: FnOnce() {\n+    #[stable]\n+    pub fn call_once<F>(&'static self, f: F) where F: FnOnce() {\n         // Optimize common path: load is much cheaper than fetch_add.\n         if self.cnt.load(atomic::SeqCst) < 0 {\n             return\n@@ -91,13 +94,13 @@ impl Once {\n         //\n         // It is crucial that the negative value is swapped in *after* the\n         // initialization routine has completed because otherwise new threads\n-        // calling `doit` will return immediately before the initialization has\n-        // completed.\n+        // calling `call_once` will return immediately before the initialization\n+        // has completed.\n \n         let prev = self.cnt.fetch_add(1, atomic::SeqCst);\n         if prev < 0 {\n             // Make sure we never overflow, we'll never have int::MIN\n-            // simultaneous calls to `doit` to make this value go back to 0\n+            // simultaneous calls to `call_once` to make this value go back to 0\n             self.cnt.store(int::MIN, atomic::SeqCst);\n             return\n         }\n@@ -118,22 +121,27 @@ impl Once {\n             unsafe { self.mutex.destroy() }\n         }\n     }\n+\n+    /// Deprecated\n+    #[deprecated = \"renamed to `call_once`\"]\n+    pub fn doit<F>(&'static self, f: F) where F: FnOnce() { self.call_once(f) }\n }\n \n #[cfg(test)]\n mod test {\n-    use prelude::*;\n+    use prelude::v1::*;\n \n     use thread::Thread;\n     use super::{ONCE_INIT, Once};\n+    use sync::mpsc::channel;\n \n     #[test]\n     fn smoke_once() {\n         static O: Once = ONCE_INIT;\n         let mut a = 0i;\n-        O.doit(|| a += 1);\n+        O.call_once(|| a += 1);\n         assert_eq!(a, 1);\n-        O.doit(|| a += 1);\n+        O.call_once(|| a += 1);\n         assert_eq!(a, 1);\n     }\n \n@@ -145,29 +153,29 @@ mod test {\n         let (tx, rx) = channel();\n         for _ in range(0u, 10) {\n             let tx = tx.clone();\n-            spawn(move|| {\n+            Thread::spawn(move|| {\n                 for _ in range(0u, 4) { Thread::yield_now() }\n                 unsafe {\n-                    O.doit(|| {\n+                    O.call_once(|| {\n                         assert!(!run);\n                         run = true;\n                     });\n                     assert!(run);\n                 }\n-                tx.send(());\n-            });\n+                tx.send(()).unwrap();\n+            }).detach();\n         }\n \n         unsafe {\n-            O.doit(|| {\n+            O.call_once(|| {\n                 assert!(!run);\n                 run = true;\n             });\n             assert!(run);\n         }\n \n         for _ in range(0u, 10) {\n-            rx.recv();\n+            rx.recv().unwrap();\n         }\n     }\n }"}, {"sha": "6e4df1182091febb789c66a67f2564719701c8fc", "filename": "src/libstd/sync/poison.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fpoison.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use prelude::*;\n+use prelude::v1::*;\n \n use cell::UnsafeCell;\n use error::FromError;"}, {"sha": "431aeb9cae9f8ab222846a59ed31fcce8102f07b", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use prelude::*;\n+use prelude::v1::*;\n \n use cell::UnsafeCell;\n use kinds::marker;\n+use ops::{Deref, DerefMut};\n use sync::poison::{mod, LockResult, TryLockError, TryLockResult};\n use sys_common::rwlock as sys;\n \n@@ -326,13 +327,17 @@ impl<'rwlock, T> RWLockWriteGuard<'rwlock, T> {\n     }\n }\n \n-impl<'rwlock, T> Deref<T> for RWLockReadGuard<'rwlock, T> {\n+impl<'rwlock, T> Deref for RWLockReadGuard<'rwlock, T> {\n+    type Target = T;\n+\n     fn deref(&self) -> &T { unsafe { &*self.__data.get() } }\n }\n-impl<'rwlock, T> Deref<T> for RWLockWriteGuard<'rwlock, T> {\n+impl<'rwlock, T> Deref for RWLockWriteGuard<'rwlock, T> {\n+    type Target = T;\n+\n     fn deref(&self) -> &T { unsafe { &*self.__data.get() } }\n }\n-impl<'rwlock, T> DerefMut<T> for RWLockWriteGuard<'rwlock, T> {\n+impl<'rwlock, T> DerefMut for RWLockWriteGuard<'rwlock, T> {\n     fn deref_mut(&mut self) -> &mut T {\n         unsafe { &mut *self.__data.get() }\n     }\n@@ -355,9 +360,10 @@ impl<'a, T> Drop for RWLockWriteGuard<'a, T> {\n \n #[cfg(test)]\n mod tests {\n-    use prelude::*;\n+    use prelude::v1::*;\n \n     use rand::{mod, Rng};\n+    use sync::mpsc::channel;\n     use thread::Thread;\n     use sync::{Arc, RWLock, StaticRWLock, RWLOCK_INIT};\n \n@@ -389,7 +395,7 @@ mod tests {\n         let (tx, rx) = channel::<()>();\n         for _ in range(0, N) {\n             let tx = tx.clone();\n-            spawn(move|| {\n+            Thread::spawn(move|| {\n                 let mut rng = rand::thread_rng();\n                 for _ in range(0, M) {\n                     if rng.gen_weighted_bool(N) {\n@@ -399,10 +405,10 @@ mod tests {\n                     }\n                 }\n                 drop(tx);\n-            });\n+            }).detach();\n         }\n         drop(tx);\n-        let _ = rx.recv_opt();\n+        let _ = rx.recv();\n         unsafe { R.destroy(); }\n     }\n \n@@ -465,7 +471,7 @@ mod tests {\n                 Thread::yield_now();\n                 *lock = tmp + 1;\n             }\n-            tx.send(());\n+            tx.send(()).unwrap();\n         }).detach();\n \n         // Readers try to catch the writer in the act\n@@ -484,7 +490,7 @@ mod tests {\n         }\n \n         // Wait for writer to finish\n-        rx.recv();\n+        rx.recv().unwrap();\n         let lock = arc.read().unwrap();\n         assert_eq!(*lock, 10);\n     }"}, {"sha": "c0ff674ba0f7dad5870d64df1f644bac1ceb3a53", "filename": "src/libstd/sync/semaphore.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fsemaphore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Fsemaphore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fsemaphore.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![unstable = \"the interaction between semaphores and the acquisition/release \\\n+               of resources is currently unclear\"]\n+\n use ops::Drop;\n use sync::{Mutex, Condvar};\n \n@@ -104,10 +107,12 @@ impl<'a> Drop for SemaphoreGuard<'a> {\n \n #[cfg(test)]\n mod tests {\n-    use prelude::*;\n+    use prelude::v1::*;\n \n     use sync::Arc;\n     use super::Semaphore;\n+    use sync::mpsc::channel;\n+    use thread::Thread;\n \n     #[test]\n     fn test_sem_acquire_release() {\n@@ -127,7 +132,7 @@ mod tests {\n     fn test_sem_as_mutex() {\n         let s = Arc::new(Semaphore::new(1));\n         let s2 = s.clone();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let _g = s2.access();\n         });\n         let _g = s.access();\n@@ -139,9 +144,9 @@ mod tests {\n         let (tx, rx) = channel();\n         let s = Arc::new(Semaphore::new(0));\n         let s2 = s.clone();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             s2.acquire();\n-            tx.send(());\n+            tx.send(()).unwrap();\n         });\n         s.release();\n         let _ = rx.recv();\n@@ -150,12 +155,12 @@ mod tests {\n         let (tx, rx) = channel();\n         let s = Arc::new(Semaphore::new(0));\n         let s2 = s.clone();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             s2.release();\n             let _ = rx.recv();\n         });\n         s.acquire();\n-        tx.send(());\n+        tx.send(()).unwrap();\n     }\n \n     #[test]\n@@ -166,14 +171,14 @@ mod tests {\n         let s2 = s.clone();\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let _g = s2.access();\n             let _ = rx2.recv();\n-            tx1.send(());\n+            tx1.send(()).unwrap();\n         });\n         let _g = s.access();\n-        tx2.send(());\n-        let _ = rx1.recv();\n+        tx2.send(()).unwrap();\n+        rx1.recv().unwrap();\n     }\n \n     #[test]\n@@ -183,13 +188,13 @@ mod tests {\n         let (tx, rx) = channel();\n         {\n             let _g = s.access();\n-            spawn(move|| {\n-                tx.send(());\n+            Thread::spawn(move|| {\n+                tx.send(()).unwrap();\n                 drop(s2.access());\n-                tx.send(());\n-            });\n-            rx.recv(); // wait for child to come alive\n+                tx.send(()).unwrap();\n+            }).detach();\n+            rx.recv().unwrap(); // wait for child to come alive\n         }\n-        rx.recv(); // wait for child to be done\n+        rx.recv().unwrap(); // wait for child to be done\n     }\n }"}, {"sha": "088827dc0842d9041d70db2f98f60dbed7904e13", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -10,11 +10,16 @@\n \n //! Abstraction of a thread pool for basic parallelism.\n \n+#![unstable = \"the semantics of a failing task and whether a thread is \\\n+               re-attached to a thread pool are somewhat unclear, and the \\\n+               utility of this type in `std::sync` is questionable with \\\n+               respect to the jobs of other primitives\"]\n+\n use core::prelude::*;\n \n-use thread::Thread;\n-use comm::{channel, Sender, Receiver};\n use sync::{Arc, Mutex};\n+use sync::mpsc::{channel, Sender, Receiver};\n+use thread::Thread;\n use thunk::Thunk;\n \n struct Sentinel<'a> {\n@@ -53,16 +58,17 @@ impl<'a> Drop for Sentinel<'a> {\n /// # Example\n ///\n /// ```rust\n-/// # use std::sync::TaskPool;\n-/// # use std::iter::AdditiveIterator;\n+/// use std::sync::TaskPool;\n+/// use std::iter::AdditiveIterator;\n+/// use std::sync::mpsc::channel;\n ///\n /// let pool = TaskPool::new(4u);\n ///\n /// let (tx, rx) = channel();\n /// for _ in range(0, 8u) {\n ///     let tx = tx.clone();\n ///     pool.execute(move|| {\n-///         tx.send(1u);\n+///         tx.send(1u).unwrap();\n ///     });\n /// }\n ///\n@@ -100,7 +106,7 @@ impl TaskPool {\n     pub fn execute<F>(&self, job: F)\n         where F : FnOnce(), F : Send\n     {\n-        self.jobs.send(Thunk::new(job));\n+        self.jobs.send(Thunk::new(job)).unwrap();\n     }\n }\n \n@@ -114,7 +120,7 @@ fn spawn_in_pool(jobs: Arc<Mutex<Receiver<Thunk>>>) {\n                 // Only lock jobs for the time it takes\n                 // to get a job, not run it.\n                 let lock = jobs.lock().unwrap();\n-                lock.recv_opt()\n+                lock.recv()\n             };\n \n             match message {\n@@ -131,8 +137,9 @@ fn spawn_in_pool(jobs: Arc<Mutex<Receiver<Thunk>>>) {\n \n #[cfg(test)]\n mod test {\n-    use prelude::*;\n+    use prelude::v1::*;\n     use super::*;\n+    use sync::mpsc::channel;\n \n     const TEST_TASKS: uint = 4u;\n \n@@ -146,7 +153,7 @@ mod test {\n         for _ in range(0, TEST_TASKS) {\n             let tx = tx.clone();\n             pool.execute(move|| {\n-                tx.send(1u);\n+                tx.send(1u).unwrap();\n             });\n         }\n \n@@ -175,7 +182,7 @@ mod test {\n         for _ in range(0, TEST_TASKS) {\n             let tx = tx.clone();\n             pool.execute(move|| {\n-                tx.send(1u);\n+                tx.send(1u).unwrap();\n             });\n         }\n "}, {"sha": "d4039fd96ff204c92ae087e0014e3c79cfb8b3fd", "filename": "src/libstd/sys/common/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use prelude::*;\n+use prelude::v1::*;\n \n use io::IoResult;\n "}, {"sha": "bdf1bf3dfd02ceca099d0be7d70e2cc3324be749", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -20,12 +20,13 @@\n //! can be created in the future and there must be no active timers at that\n //! time.\n \n-use prelude::*;\n+use prelude::v1::*;\n \n use cell::UnsafeCell;\n use mem;\n-use sync::{StaticMutex, StaticCondvar};\n use rt;\n+use sync::{StaticMutex, StaticCondvar};\n+use sync::mpsc::{channel, Sender, Receiver};\n use sys::helper_signal;\n \n use thread::Thread;\n@@ -117,7 +118,7 @@ impl<M: Send> Helper<M> {\n             // message. Otherwise it could wake up and go to sleep before we\n             // send the message.\n             assert!(!self.chan.get().is_null());\n-            (**self.chan.get()).send(msg);\n+            (**self.chan.get()).send(msg).unwrap();\n             helper_signal::signal(*self.signal.get() as helper_signal::signal);\n         }\n     }"}, {"sha": "97015f74a4a10bec8df2662fea0fbd77c0dc9b90", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -12,7 +12,7 @@\n #![allow(dead_code)]\n \n use io::{mod, IoError, IoResult};\n-use prelude::*;\n+use prelude::v1::*;\n use sys::{last_error, retry};\n use c_str::CString;\n use num::Int;"}, {"sha": "cb0c5581abd8b34f1238a2dda59aba79d7090ee8", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -8,24 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use prelude::v1::*;\n use self::SocketStatus::*;\n use self::InAddr::*;\n \n-use alloc::arc::Arc;\n+use c_str::ToCStr;\n+use io::net::addrinfo;\n+use io::net::ip::{SocketAddr, IpAddr, Ipv4Addr, Ipv6Addr};\n+use io::{IoResult, IoError};\n use libc::{mod, c_char, c_int};\n use c_str::CString;\n use mem;\n use num::Int;\n use ptr::{mod, null, null_mut};\n-use io::net::ip::{SocketAddr, IpAddr, Ipv4Addr, Ipv6Addr};\n-use io::net::addrinfo;\n-use io::{IoResult, IoError};\n use sys::{mod, retry, c, sock_t, last_error, last_net_error, last_gai_error, close_sock,\n           wrlen, msglen_t, os, wouldblock, set_nonblocking, timer, ms_to_timeval,\n           decode_error_detailed};\n-use sync::{Mutex, MutexGuard};\n+use sync::{Arc, Mutex, MutexGuard};\n use sys_common::{mod, keep_going, short_write, timeout};\n-use prelude::*;\n use cmp;\n use io;\n "}, {"sha": "92b936e74f6542a611a05a0a2bff6de29c780976", "filename": "src/libstd/sys/common/thread_info.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -10,9 +10,10 @@\n \n use core::prelude::*;\n \n-use thread::Thread;\n use cell::RefCell;\n use string::String;\n+use thread::Thread;\n+use thread_local::State;\n \n struct ThreadInfo {\n     // This field holds the known bounds of the stack in (lo, hi)\n@@ -27,7 +28,7 @@ thread_local! { static THREAD_INFO: RefCell<Option<ThreadInfo>> = RefCell::new(N\n \n impl ThreadInfo {\n     fn with<R, F>(f: F) -> R where F: FnOnce(&mut ThreadInfo) -> R {\n-        if THREAD_INFO.destroyed() {\n+        if THREAD_INFO.state() == State::Destroyed {\n             panic!(\"Use of std::thread::Thread::current() is not possible after \\\n                     the thread's local data has been destroyed\");\n         }"}, {"sha": "9d7188a37bcdfd7c0848f7dcb26849cedb31f036", "filename": "src/libstd/sys/common/thread_local.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -56,7 +56,7 @@\n \n #![allow(non_camel_case_types)]\n \n-use prelude::*;\n+use prelude::v1::*;\n \n use sync::atomic::{mod, AtomicUint};\n use sync::{Mutex, Once, ONCE_INIT};\n@@ -137,7 +137,7 @@ pub const INIT: StaticKey = StaticKey {\n ///\n /// This value allows specific configuration of the destructor for a TLS key.\n pub const INIT_INNER: StaticKeyInner = StaticKeyInner {\n-    key: atomic::INIT_ATOMIC_UINT,\n+    key: atomic::ATOMIC_UINT_INIT,\n };\n \n static INIT_KEYS: Once = ONCE_INIT;\n@@ -246,7 +246,7 @@ impl Drop for Key {\n \n #[cfg(test)]\n mod tests {\n-    use prelude::*;\n+    use prelude::v1::*;\n     use super::{Key, StaticKey, INIT_INNER};\n \n     fn assert_sync<T: Sync>() {}"}, {"sha": "e3e0b279c12c705e6c438cc766a8cfbcc09e04be", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -10,16 +10,15 @@\n \n //! Blocking posix-based file I/O\n \n-use libc::{mod, c_int, c_void};\n-use c_str::CString;\n-use mem;\n-use io;\n-\n-use prelude::*;\n+use prelude::v1::*;\n \n+use c_str::{CString, ToCStr};\n use io::{FilePermission, Write, UnstableFileStat, Open, FileAccess, FileMode};\n use io::{IoResult, FileStat, SeekStyle};\n use io::{Read, Truncate, SeekCur, SeekSet, ReadWrite, SeekEnd, Append};\n+use io;\n+use libc::{mod, c_int, c_void};\n+use mem;\n use sys::retry;\n use sys_common::{keep_going, eof, mkerr_libc};\n \n@@ -360,7 +359,7 @@ mod tests {\n     use super::FileDesc;\n     use libc;\n     use os;\n-    use prelude::*;\n+    use prelude::v1::*;\n \n     #[cfg_attr(target_os = \"freebsd\", ignore)] // hmm, maybe pipes have a tiny buffer\n     #[test]"}, {"sha": "4199cbc1bb9f52242e7fbccf1231e9d3e5a9796a", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -19,7 +19,7 @@ extern crate libc;\n \n use num;\n use num::{Int, SignedInt};\n-use prelude::*;\n+use prelude::v1::*;\n use io::{mod, IoResult, IoError};\n use sys_common::mkerr_libc;\n "}, {"sha": "6a8f55e79c8728feecd0b857d7ba66b44ef25ca9", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -10,17 +10,18 @@\n \n //! Implementation of `std::os` functionality for unix systems\n \n-use prelude::*;\n+use prelude::v1::*;\n \n+use c_str::ToCStr;\n use error::{FromError, Error};\n use fmt;\n use io::{IoError, IoResult};\n use libc::{mod, c_int, c_char, c_void};\n-use path::BytesContainer;\n+use os;\n+use path::{BytesContainer};\n use ptr;\n-use sync::atomic::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n+use sync::atomic::{AtomicInt, SeqCst};\n use sys::fs::FileDesc;\n-use os;\n \n use os::TMPBUF_SZ;\n "}, {"sha": "623f3f6a89c9db9d7e423c086bf17d2d8881fd3c", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use alloc::arc::Arc;\n+use prelude::v1::*;\n+\n use libc;\n use c_str::CString;\n use mem;\n-use sync::{atomic, Mutex};\n+use sync::{atomic, Arc, Mutex};\n use io::{mod, IoResult, IoError};\n-use prelude::*;\n \n use sys::{mod, timer, retry, c, set_nonblocking, wouldblock};\n use sys::fs::{fd_t, FileDesc};\n@@ -117,9 +117,6 @@ pub struct UnixStream {\n     write_deadline: u64,\n }\n \n-unsafe impl Send for UnixStream {}\n-unsafe impl Sync for UnixStream {}\n-\n impl UnixStream {\n     pub fn connect(addr: &CString,\n                    timeout: Option<u64>) -> IoResult<UnixStream> {\n@@ -218,6 +215,7 @@ pub struct UnixListener {\n     path: CString,\n }\n \n+// we currently own the CString, so these impls should be safe\n unsafe impl Send for UnixListener {}\n unsafe impl Sync for UnixListener {}\n \n@@ -265,9 +263,6 @@ struct AcceptorInner {\n     closed: atomic::AtomicBool,\n }\n \n-unsafe impl Send for AcceptorInner {}\n-unsafe impl Sync for AcceptorInner {}\n-\n impl UnixAcceptor {\n     pub fn fd(&self) -> fd_t { self.inner.listener.fd() }\n "}, {"sha": "af09bf4fbd0a290f27dbc512682ee986b6ea358d", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -7,22 +7,23 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+\n+use prelude::v1::*;\n use self::Req::*;\n \n-use libc::{mod, pid_t, c_void, c_int};\n-use c_str::CString;\n+use c_str::{CString, ToCStr};\n+use collections;\n+use hash::Hash;\n+use io::process::{ProcessExit, ExitStatus, ExitSignal};\n use io::{mod, IoResult, IoError, EndOfFile};\n+use libc::{mod, pid_t, c_void, c_int};\n use mem;\n use os;\n-use ptr;\n-use prelude::*;\n-use io::process::{ProcessExit, ExitStatus, ExitSignal};\n-use collections;\n use path::BytesContainer;\n-use hash::Hash;\n-\n-use sys::{mod, retry, c, wouldblock, set_nonblocking, ms_to_timeval};\n+use ptr;\n+use sync::mpsc::{channel, Sender, Receiver};\n use sys::fs::FileDesc;\n+use sys::{mod, retry, c, wouldblock, set_nonblocking, ms_to_timeval};\n use sys_common::helper_thread::Helper;\n use sys_common::{AsInner, mkerr_libc, timeout};\n \n@@ -276,8 +277,8 @@ impl Process {\n     }\n \n     pub fn wait(&self, deadline: u64) -> IoResult<ProcessExit> {\n-        use std::cmp;\n-        use std::comm;\n+        use cmp;\n+        use sync::mpsc::TryRecvError;\n \n         static mut WRITE_FD: libc::c_int = 0;\n \n@@ -336,9 +337,9 @@ impl Process {\n \n         let (tx, rx) = channel();\n         unsafe { HELPER.send(NewChild(self.pid, tx, deadline)); }\n-        return match rx.recv_opt() {\n+        return match rx.recv() {\n             Ok(e) => Ok(e),\n-            Err(()) => Err(timeout(\"wait timed out\")),\n+            Err(..) => Err(timeout(\"wait timed out\")),\n         };\n \n         // Register a new SIGCHLD handler, returning the reading half of the\n@@ -419,11 +420,11 @@ impl Process {\n                             Ok(NewChild(pid, tx, deadline)) => {\n                                 active.push((pid, tx, deadline));\n                             }\n-                            Err(comm::Disconnected) => {\n+                            Err(TryRecvError::Disconnected) => {\n                                 assert!(active.len() == 0);\n                                 break 'outer;\n                             }\n-                            Err(comm::Empty) => break,\n+                            Err(TryRecvError::Empty) => break,\n                         }\n                     }\n                 }\n@@ -459,7 +460,7 @@ impl Process {\n                     active.retain(|&(pid, ref tx, _)| {\n                         let pr = Process { pid: pid };\n                         match pr.try_wait() {\n-                            Some(msg) => { tx.send(msg); false }\n+                            Some(msg) => { tx.send(msg).unwrap(); false }\n                             None => true,\n                         }\n                     });"}, {"sha": "13ccf685fd7fc5b0a1e7c321406bce03ab539b10", "filename": "src/libstd/sys/unix/tcp.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -8,12 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use prelude::v1::*;\n+\n use io::net::ip;\n use io::IoResult;\n use libc;\n use mem;\n use ptr;\n-use prelude::*;\n use super::{last_error, last_net_error, retry, sock_t};\n use sync::{Arc, atomic};\n use sys::fs::FileDesc;"}, {"sha": "e507377a8fcdd880a01c5b98ee53145a7463cfaa", "filename": "src/libstd/sys/unix/thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use prelude::*;\n+use prelude::v1::*;\n use libc::c_int;\n \n pub type Key = pthread_key_t;"}, {"sha": "80f93dd2f618cb7611b5be23b9537da6b48cf54b", "filename": "src/libstd/sys/unix/timer.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -46,19 +46,19 @@\n //!\n //! Note that all time units in this file are in *milliseconds*.\n \n+use prelude::v1::*;\n use self::Req::*;\n \n+use io::IoResult;\n use libc;\n use mem;\n use os;\n use ptr;\n use sync::atomic;\n-use comm;\n+use sync::mpsc::{channel, Sender, Receiver, TryRecvError};\n use sys::c;\n use sys::fs::FileDesc;\n use sys_common::helper_thread::Helper;\n-use prelude::*;\n-use io::IoResult;\n \n helper_init! { static HELPER: Helper<Req> }\n \n@@ -168,7 +168,7 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n             1 => {\n                 loop {\n                     match messages.try_recv() {\n-                        Err(comm::Disconnected) => {\n+                        Err(TryRecvError::Disconnected) => {\n                             assert!(active.len() == 0);\n                             break 'outer;\n                         }\n@@ -179,15 +179,15 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n                             match dead.iter().position(|&(i, _)| id == i) {\n                                 Some(i) => {\n                                     let (_, i) = dead.remove(i);\n-                                    ack.send(i);\n+                                    ack.send(i).unwrap();\n                                     continue\n                                 }\n                                 None => {}\n                             }\n                             let i = active.iter().position(|i| i.id == id);\n                             let i = i.expect(\"no timer found\");\n                             let t = active.remove(i);\n-                            ack.send(t);\n+                            ack.send(t).unwrap();\n                         }\n                         Err(..) => break\n                     }\n@@ -211,7 +211,7 @@ impl Timer {\n         // instead of ()\n         HELPER.boot(|| {}, helper);\n \n-        static ID: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+        static ID: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n         let id = ID.fetch_add(1, atomic::Relaxed);\n         Ok(Timer {\n             id: id,\n@@ -271,7 +271,7 @@ impl Timer {\n             None => {\n                 let (tx, rx) = channel();\n                 HELPER.send(RemoveTimer(self.id, tx));\n-                rx.recv()\n+                rx.recv().unwrap()\n             }\n         }\n     }"}, {"sha": "4ef687d41d8ee70a23c7fd51099885bcc7c58ffe", "filename": "src/libstd/sys/unix/tty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Funix%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Funix%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftty.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use prelude::v1::*;\n+\n use sys::fs::FileDesc;\n-use prelude::*;\n use libc::{mod, c_int};\n use io::{mod, IoResult, IoError};\n use sys_common;"}, {"sha": "1ee57434fb91ada83e4cad503654a6d7b9332afd", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -15,7 +15,7 @@\n #![allow(non_camel_case_types)]\n \n use libc;\n-use prelude::*;\n+use prelude::v1::*;\n \n pub const WSADESCRIPTION_LEN: uint = 256;\n pub const WSASYS_STATUS_LEN: uint = 128;\n@@ -132,7 +132,8 @@ extern \"system\" {\n pub mod compat {\n     use intrinsics::{atomic_store_relaxed, transmute};\n     use libc::types::os::arch::extra::{LPCWSTR, HMODULE, LPCSTR, LPVOID};\n-    use prelude::*;\n+    use prelude::v1::*;\n+    use c_str::ToCStr;\n \n     extern \"system\" {\n         fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;"}, {"sha": "523d60c71aa8b7a2e7c13328da1b91dc27e57a95", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -21,7 +21,7 @@ use ptr;\n use str;\n use io;\n \n-use prelude::*;\n+use prelude::v1::*;\n use sys;\n use sys::os;\n use sys_common::{keep_going, eof, mkerr_libc};"}, {"sha": "1034f0615d9947754672a679affbdd4eaf1bcbf2", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -18,17 +18,18 @@\n \n extern crate libc;\n \n+use prelude::v1::*;\n+\n use num;\n use mem;\n-use prelude::*;\n use io::{mod, IoResult, IoError};\n use sync::{Once, ONCE_INIT};\n \n macro_rules! helper_init { (static $name:ident: Helper<$m:ty>) => (\n     static $name: Helper<$m> = Helper {\n         lock: ::sync::MUTEX_INIT,\n         cond: ::sync::CONDVAR_INIT,\n-        chan: ::cell::UnsafeCell { value: 0 as *mut Sender<$m> },\n+        chan: ::cell::UnsafeCell { value: 0 as *mut ::sync::mpsc::Sender<$m> },\n         signal: ::cell::UnsafeCell { value: 0 },\n         initialized: ::cell::UnsafeCell { value: false },\n         shutdown: ::cell::UnsafeCell { value: false },\n@@ -171,7 +172,7 @@ pub fn init_net() {\n     unsafe {\n         static START: Once = ONCE_INIT;\n \n-        START.doit(|| {\n+        START.call_once(|| {\n             let mut data: c::WSADATA = mem::zeroed();\n             let ret = c::WSAStartup(0x202, // version 2.2\n                                     &mut data);"}, {"sha": "e0fa02b559958cb5858922ff74516781c72fbff8", "filename": "src/libstd/sys/windows/mutex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use prelude::*;\n+use prelude::v1::*;\n \n use sync::atomic;\n use alloc::{mod, heap};\n@@ -20,7 +20,7 @@ const SPIN_COUNT: DWORD = 4000;\n \n pub struct Mutex { inner: atomic::AtomicUint }\n \n-pub const MUTEX_INIT: Mutex = Mutex { inner: atomic::INIT_ATOMIC_UINT };\n+pub const MUTEX_INIT: Mutex = Mutex { inner: atomic::ATOMIC_UINT_INIT };\n \n unsafe impl Sync for Mutex {}\n "}, {"sha": "dfdee0e0385c5c121ee2db90ea5acc7b694cc909", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -13,7 +13,7 @@\n // FIXME: move various extern bindings from here into liblibc or\n // something similar\n \n-use prelude::*;\n+use prelude::v1::*;\n \n use fmt;\n use io::{IoResult, IoError};"}, {"sha": "f173d5fc6d4cb5843abce61eff584eba5c5df3b4", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -84,14 +84,14 @@\n //! the test suite passing (the suite is in libstd), and that's good enough for\n //! me!\n \n-use alloc::arc::Arc;\n+use prelude::v1::*;\n+\n use libc;\n use c_str::CString;\n use mem;\n use ptr;\n-use sync::{atomic, Mutex};\n+use sync::{atomic, Arc, Mutex};\n use io::{mod, IoError, IoResult};\n-use prelude::*;\n \n use sys_common::{mod, eof};\n "}, {"sha": "cb99a886ce4fcf5bf249bed08d46aca8e689ac25", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -8,14 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use prelude::v1::*;\n+\n use libc::{pid_t, c_void, c_int};\n use libc;\n-use c_str::CString;\n+use c_str::{CString, ToCStr};\n use io;\n use mem;\n use os;\n use ptr;\n-use prelude::*;\n use io::process::{ProcessExit, ExitStatus, ExitSignal};\n use collections;\n use path::BytesContainer;\n@@ -466,10 +467,11 @@ fn free_handle(handle: *mut ()) {\n \n #[cfg(test)]\n mod tests {\n+    use c_str::ToCStr;\n \n     #[test]\n     fn test_make_command_line() {\n-        use prelude::*;\n+        use prelude::v1::*;\n         use str;\n         use c_str::CString;\n         use super::make_command_line;"}, {"sha": "5a929f6b2b5ff27aafed24204c774ad654d638c0", "filename": "src/libstd/sys/windows/tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -13,7 +13,7 @@ use io::IoResult;\n use libc;\n use mem;\n use ptr;\n-use prelude::*;\n+use prelude::v1::*;\n use super::{last_error, last_net_error, retry, sock_t};\n use sync::{Arc, atomic};\n use sys::fs::FileDesc;"}, {"sha": "b96e26c7a86a6feef0d49e98297187d2beaa591d", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use prelude::*;\n+use prelude::v1::*;\n \n use libc::types::os::arch::extra::{DWORD, LPVOID, BOOL};\n "}, {"sha": "343b78543bfd01dcd35107a3f9d2b411c2a46c1b", "filename": "src/libstd/sys/windows/timer.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -21,16 +21,16 @@\n //! the other two implementations of timers with nothing *that* new showing up.\n \n use self::Req::*;\n+use prelude::v1::*;\n \n use libc;\n use ptr;\n-use comm;\n \n+use io::IoResult;\n+use sync::mpsc::{channel, Sender, Receiver, TryRecvError};\n use sys::c;\n use sys::fs::FileDesc;\n use sys_common::helper_thread::Helper;\n-use prelude::*;\n-use io::IoResult;\n \n helper_init! { static HELPER: Helper<Req> }\n \n@@ -71,7 +71,7 @@ fn helper(input: libc::HANDLE, messages: Receiver<Req>, _: ()) {\n                         chans.push((c, one));\n                     }\n                     Ok(RemoveTimer(obj, c)) => {\n-                        c.send(());\n+                        c.send(()).unwrap();\n                         match objs.iter().position(|&o| o == obj) {\n                             Some(i) => {\n                                 drop(objs.remove(i));\n@@ -80,7 +80,7 @@ fn helper(input: libc::HANDLE, messages: Receiver<Req>, _: ()) {\n                             None => {}\n                         }\n                     }\n-                    Err(comm::Disconnected) => {\n+                    Err(TryRecvError::Disconnected) => {\n                         assert_eq!(objs.len(), 1);\n                         assert_eq!(chans.len(), 0);\n                         break 'outer;\n@@ -132,7 +132,7 @@ impl Timer {\n \n         let (tx, rx) = channel();\n         HELPER.send(RemoveTimer(self.obj, tx));\n-        rx.recv();\n+        rx.recv().unwrap();\n \n         self.on_worker = false;\n     }"}, {"sha": "7591025d76d6f4305b4a2c67fee27cae32f83fb0", "filename": "src/libstd/sys/windows/tty.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -25,19 +25,20 @@\n //! wrapper that performs encoding/decoding, this implementation should switch\n //! to working in raw UTF-16, with such a wrapper around it.\n \n-use super::c::{ReadConsoleW, WriteConsoleW, GetConsoleMode, SetConsoleMode};\n-use super::c::{ERROR_ILLEGAL_CHARACTER};\n-use super::c::{ENABLE_ECHO_INPUT, ENABLE_EXTENDED_FLAGS};\n-use super::c::{ENABLE_INSERT_MODE, ENABLE_LINE_INPUT};\n-use super::c::{ENABLE_PROCESSED_INPUT, ENABLE_QUICK_EDIT_MODE};\n-use libc::{c_int, HANDLE, LPDWORD, DWORD, LPVOID};\n-use libc::{get_osfhandle, CloseHandle};\n-use libc::types::os::arch::extra::LPCVOID;\n+use prelude::v1::*;\n+\n use io::{mod, IoError, IoResult, MemReader};\n use iter::repeat;\n-use prelude::*;\n+use libc::types::os::arch::extra::LPCVOID;\n+use libc::{c_int, HANDLE, LPDWORD, DWORD, LPVOID};\n+use libc::{get_osfhandle, CloseHandle};\n use ptr;\n use str::from_utf8;\n+use super::c::{ENABLE_ECHO_INPUT, ENABLE_EXTENDED_FLAGS};\n+use super::c::{ENABLE_INSERT_MODE, ENABLE_LINE_INPUT};\n+use super::c::{ENABLE_PROCESSED_INPUT, ENABLE_QUICK_EDIT_MODE};\n+use super::c::{ERROR_ILLEGAL_CHARACTER};\n+use super::c::{ReadConsoleW, WriteConsoleW, GetConsoleMode, SetConsoleMode};\n \n fn invalid_encoding() -> IoError {\n     IoError {"}, {"sha": "3c87309dabcf3ceb06e91edc35f009df841eb00e", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -440,13 +440,15 @@ impl<T: Send> Drop for JoinGuard<T> {\n \n #[cfg(test)]\n mod test {\n-    use prelude::*;\n+    use prelude::v1::*;\n+\n     use any::{Any, AnyRefExt};\n+    use sync::mpsc::{channel, Sender};\n     use boxed::BoxAny;\n     use result;\n     use std::io::{ChanReader, ChanWriter};\n-    use thunk::Thunk;\n     use super::{Thread, Builder};\n+    use thunk::Thunk;\n \n     // !!! These tests are dangerous. If something is buggy, they will hang, !!!\n     // !!! instead of exiting cleanly. This might wedge the buildbots.       !!!\n@@ -469,9 +471,9 @@ mod test {\n     fn test_run_basic() {\n         let (tx, rx) = channel();\n         Thread::spawn(move|| {\n-            tx.send(());\n+            tx.send(()).unwrap();\n         }).detach();\n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n@@ -504,15 +506,15 @@ mod test {\n             let tx = tx.clone();\n             Thread::spawn(move|| {\n                 if i == 0 {\n-                    tx.send(());\n+                    tx.send(()).unwrap();\n                 } else {\n                     f(i - 1, tx);\n                 }\n             }).detach();\n \n         }\n         f(10, tx);\n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n@@ -521,11 +523,11 @@ mod test {\n \n         Thread::spawn(move|| {\n             Thread::spawn(move|| {\n-                tx.send(());\n+                tx.send(()).unwrap();\n             }).detach();\n         }).detach();\n \n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     fn avoid_copying_the_body<F>(spawnfn: F) where F: FnOnce(Thunk) {\n@@ -536,10 +538,10 @@ mod test {\n \n         spawnfn(Thunk::new(move|| {\n             let x_in_child = (&*x) as *const int as uint;\n-            tx.send(x_in_child);\n+            tx.send(x_in_child).unwrap();\n         }));\n \n-        let x_in_child = rx.recv();\n+        let x_in_child = rx.recv().unwrap();\n         assert_eq!(x_in_parent, x_in_child);\n     }\n "}, {"sha": "75e5ac59685b55d0553df7054ae1358c13395d99", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 143, "deletions": 47, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -35,20 +35,23 @@\n //! `Cell` or `RefCell` types.\n \n #![macro_escape]\n-#![experimental]\n+#![stable]\n \n-use prelude::*;\n+use prelude::v1::*;\n \n use cell::UnsafeCell;\n \n-// Sure wish we had macro hygiene, no?\n-#[doc(hidden)] pub use self::imp::Key as KeyInner;\n-#[doc(hidden)] pub use self::imp::destroy_value;\n-#[doc(hidden)] pub use sys_common::thread_local::INIT_INNER as OS_INIT_INNER;\n-#[doc(hidden)] pub use sys_common::thread_local::StaticKey as OsStaticKey;\n-\n pub mod scoped;\n \n+// Sure wish we had macro hygiene, no?\n+#[doc(hidden)]\n+pub mod __impl {\n+    pub use super::imp::Key as KeyInner;\n+    pub use super::imp::destroy_value;\n+    pub use sys_common::thread_local::INIT_INNER as OS_INIT_INNER;\n+    pub use sys_common::thread_local::StaticKey as OsStaticKey;\n+}\n+\n /// A thread local storage key which owns its contents.\n ///\n /// This key uses the fastest possible implementation available to it for the\n@@ -90,6 +93,7 @@ pub mod scoped;\n ///     assert_eq!(*f.borrow(), 2);\n /// });\n /// ```\n+#[stable]\n pub struct Key<T> {\n     // The key itself may be tagged with #[thread_local], and this `Key` is\n     // stored as a `static`, and it's not valid for a static to reference the\n@@ -100,7 +104,7 @@ pub struct Key<T> {\n     // This is trivially devirtualizable by LLVM because we never store anything\n     // to this field and rustc can declare the `static` as constant as well.\n     #[doc(hidden)]\n-    pub inner: fn() -> &'static KeyInner<UnsafeCell<Option<T>>>,\n+    pub inner: fn() -> &'static __impl::KeyInner<UnsafeCell<Option<T>>>,\n \n     // initialization routine to invoke to create a value\n     #[doc(hidden)]\n@@ -109,12 +113,12 @@ pub struct Key<T> {\n \n /// Declare a new thread local storage key of type `std::thread_local::Key`.\n #[macro_export]\n-#[doc(hidden)]\n+#[stable]\n macro_rules! thread_local {\n     (static $name:ident: $t:ty = $init:expr) => (\n         static $name: ::std::thread_local::Key<$t> = {\n             use std::cell::UnsafeCell as __UnsafeCell;\n-            use std::thread_local::KeyInner as __KeyInner;\n+            use std::thread_local::__impl::KeyInner as __KeyInner;\n             use std::option::Option as __Option;\n             use std::option::Option::None as __None;\n \n@@ -131,7 +135,7 @@ macro_rules! thread_local {\n     (pub static $name:ident: $t:ty = $init:expr) => (\n         pub static $name: ::std::thread_local::Key<$t> = {\n             use std::cell::UnsafeCell as __UnsafeCell;\n-            use std::thread_local::KeyInner as __KeyInner;\n+            use std::thread_local::__impl::KeyInner as __KeyInner;\n             use std::option::Option as __Option;\n             use std::option::Option::None as __None;\n \n@@ -168,46 +172,77 @@ macro_rules! thread_local {\n // itself. Woohoo.\n \n #[macro_export]\n+#[doc(hidden)]\n macro_rules! __thread_local_inner {\n     (static $name:ident: $t:ty = $init:expr) => (\n         #[cfg_attr(any(target_os = \"macos\", target_os = \"linux\"), thread_local)]\n-        static $name: ::std::thread_local::KeyInner<$t> =\n+        static $name: ::std::thread_local::__impl::KeyInner<$t> =\n             __thread_local_inner!($init, $t);\n     );\n     (pub static $name:ident: $t:ty = $init:expr) => (\n         #[cfg_attr(any(target_os = \"macos\", target_os = \"linux\"), thread_local)]\n-        pub static $name: ::std::thread_local::KeyInner<$t> =\n+        pub static $name: ::std::thread_local::__impl::KeyInner<$t> =\n             __thread_local_inner!($init, $t);\n     );\n     ($init:expr, $t:ty) => ({\n         #[cfg(any(target_os = \"macos\", target_os = \"linux\"))]\n-        const INIT: ::std::thread_local::KeyInner<$t> = {\n-            ::std::thread_local::KeyInner {\n+        const _INIT: ::std::thread_local::__impl::KeyInner<$t> = {\n+            ::std::thread_local::__impl::KeyInner {\n                 inner: ::std::cell::UnsafeCell { value: $init },\n                 dtor_registered: ::std::cell::UnsafeCell { value: false },\n                 dtor_running: ::std::cell::UnsafeCell { value: false },\n             }\n         };\n \n         #[cfg(all(not(any(target_os = \"macos\", target_os = \"linux\"))))]\n-        const INIT: ::std::thread_local::KeyInner<$t> = {\n+        const _INIT: ::std::thread_local::__impl::KeyInner<$t> = {\n             unsafe extern fn __destroy(ptr: *mut u8) {\n-                ::std::thread_local::destroy_value::<$t>(ptr);\n+                ::std::thread_local::__impl::destroy_value::<$t>(ptr);\n             }\n \n-            ::std::thread_local::KeyInner {\n+            ::std::thread_local::__impl::KeyInner {\n                 inner: ::std::cell::UnsafeCell { value: $init },\n-                os: ::std::thread_local::OsStaticKey {\n-                    inner: ::std::thread_local::OS_INIT_INNER,\n+                os: ::std::thread_local::__impl::OsStaticKey {\n+                    inner: ::std::thread_local::__impl::OS_INIT_INNER,\n                     dtor: ::std::option::Option::Some(__destroy as unsafe extern fn(*mut u8)),\n                 },\n             }\n         };\n \n-        INIT\n+        _INIT\n     });\n }\n \n+/// Indicator of the state of a thread local storage key.\n+#[unstable = \"state querying was recently added\"]\n+#[deriving(Eq, PartialEq, Copy)]\n+pub enum State {\n+    /// All keys are in this state whenever a thread starts. Keys will\n+    /// transition to the `Valid` state once the first call to `with` happens\n+    /// and the initialization expression succeeds.\n+    ///\n+    /// Keys in the `Uninitialized` state will yield a reference to the closure\n+    /// passed to `with` so long as the initialization routine does not panic.\n+    Uninitialized,\n+\n+    /// Once a key has been accessed successfully, it will enter the `Valid`\n+    /// state. Keys in the `Valid` state will remain so until the thread exits,\n+    /// at which point the destructor will be run and the key will enter the\n+    /// `Destroyed` state.\n+    ///\n+    /// Keys in the `Valid` state will be guaranteed to yield a reference to the\n+    /// closure passed to `with`.\n+    Valid,\n+\n+    /// When a thread exits, the destructors for keys will be run (if\n+    /// necessary). While a destructor is running, and possibly after a\n+    /// destructor has run, a key is in the `Destroyed` state.\n+    ///\n+    /// Keys in the `Destroyed` states will trigger a panic when accessed via\n+    /// `with`.\n+    Destroyed,\n+}\n+\n impl<T: 'static> Key<T> {\n     /// Acquire a reference to the value in this TLS key.\n     ///\n@@ -219,6 +254,7 @@ impl<T: 'static> Key<T> {\n     /// This function will `panic!()` if the key currently has its\n     /// destructor running, and it **may** panic if the destructor has\n     /// previously been run for this thread.\n+    #[stable]\n     pub fn with<F, R>(&'static self, f: F) -> R\n                       where F: FnOnce(&T) -> R {\n         let slot = (self.inner)();\n@@ -233,22 +269,57 @@ impl<T: 'static> Key<T> {\n     }\n \n     unsafe fn init(&self, slot: &UnsafeCell<Option<T>>) -> &T {\n-        *slot.get() = Some((self.init)());\n-        (*slot.get()).as_ref().unwrap()\n+        // Execute the initialization up front, *then* move it into our slot,\n+        // just in case initialization fails.\n+        let value = (self.init)();\n+        let ptr = slot.get();\n+        *ptr = Some(value);\n+        (*ptr).as_ref().unwrap()\n     }\n \n-    /// Test this TLS key to determine whether its value has been destroyed for\n-    /// the current thread or not.\n+    /// Query the current state of this key.\n+    ///\n+    /// A key is initially in the `Uninitialized` state whenever a thread\n+    /// starts. It will remain in this state up until the first call to `with`\n+    /// within a thread has run the initialization expression successfully.\n+    ///\n+    /// Once the initialization expression succeeds, the key transitions to the\n+    /// `Valid` state which will guarantee that future calls to `with` will\n+    /// succeed within the thread.\n     ///\n-    /// This will not initialize the key if it is not already initialized.\n-    pub fn destroyed(&'static self) -> bool {\n-        unsafe { (self.inner)().get().is_none() }\n+    /// When a thread exits, each key will be destroyed in turn, and as keys are\n+    /// destroyed they will enter the `Destroyed` state just before the\n+    /// destructor starts to run. Keys may remain in the `Destroyed` state after\n+    /// destruction has completed. Keys without destructors (e.g. with types\n+    /// that are `Copy`), may never enter the `Destroyed` state.\n+    ///\n+    /// Keys in the `Uninitialized` can be accessed so long as the\n+    /// initialization does not panic. Keys in the `Valid` state are guaranteed\n+    /// to be able to be accessed. Keys in the `Destroyed` state will panic on\n+    /// any call to `with`.\n+    #[unstable = \"state querying was recently added\"]\n+    pub fn state(&'static self) -> State {\n+        unsafe {\n+            match (self.inner)().get() {\n+                Some(cell) => {\n+                    match *cell.get() {\n+                        Some(..) => State::Valid,\n+                        None => State::Uninitialized,\n+                    }\n+                }\n+                None => State::Destroyed,\n+            }\n+        }\n     }\n+\n+    /// Deprecated\n+    #[deprecated = \"function renamed to state() and returns more info\"]\n+    pub fn destroyed(&'static self) -> bool { self.state() == State::Destroyed }\n }\n \n #[cfg(any(target_os = \"macos\", target_os = \"linux\"))]\n mod imp {\n-    use prelude::*;\n+    use prelude::v1::*;\n \n     use cell::UnsafeCell;\n     use intrinsics;\n@@ -380,7 +451,7 @@ mod imp {\n \n #[cfg(not(any(target_os = \"macos\", target_os = \"linux\")))]\n mod imp {\n-    use prelude::*;\n+    use prelude::v1::*;\n \n     use cell::UnsafeCell;\n     use mem;\n@@ -453,17 +524,19 @@ mod imp {\n \n #[cfg(test)]\n mod tests {\n-    use prelude::*;\n+    use prelude::v1::*;\n \n+    use sync::mpsc::{channel, Sender};\n     use cell::UnsafeCell;\n+    use super::State;\n     use thread::Thread;\n \n     struct Foo(Sender<()>);\n \n     impl Drop for Foo {\n         fn drop(&mut self) {\n             let Foo(ref s) = *self;\n-            s.send(());\n+            s.send(()).unwrap();\n         }\n     }\n \n@@ -476,33 +549,56 @@ mod tests {\n             *f.get() = 2;\n         });\n         let (tx, rx) = channel();\n-        spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             FOO.with(|f| unsafe {\n                 assert_eq!(*f.get(), 1);\n             });\n-            tx.send(());\n+            tx.send(()).unwrap();\n         });\n-        rx.recv();\n+        rx.recv().unwrap();\n \n         FOO.with(|f| unsafe {\n             assert_eq!(*f.get(), 2);\n         });\n     }\n \n+    #[test]\n+    fn states() {\n+        struct Foo;\n+        impl Drop for Foo {\n+            fn drop(&mut self) {\n+                assert!(FOO.state() == State::Destroyed);\n+            }\n+        }\n+        fn foo() -> Foo {\n+            assert!(FOO.state() == State::Uninitialized);\n+            Foo\n+        }\n+        thread_local!(static FOO: Foo = foo());\n+\n+        Thread::spawn(|| {\n+            assert!(FOO.state() == State::Uninitialized);\n+            FOO.with(|_| {\n+                assert!(FOO.state() == State::Valid);\n+            });\n+            assert!(FOO.state() == State::Valid);\n+        }).join().ok().unwrap();\n+    }\n+\n     #[test]\n     fn smoke_dtor() {\n         thread_local!(static FOO: UnsafeCell<Option<Foo>> = UnsafeCell {\n             value: None\n         });\n \n         let (tx, rx) = channel();\n-        spawn(move|| unsafe {\n+        let _t = Thread::spawn(move|| unsafe {\n             let mut tx = Some(tx);\n             FOO.with(|f| {\n                 *f.get() = Some(Foo(tx.take().unwrap()));\n             });\n         });\n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n@@ -521,7 +617,7 @@ mod tests {\n             fn drop(&mut self) {\n                 unsafe {\n                     HITS += 1;\n-                    if K2.destroyed() {\n+                    if K2.state() == State::Destroyed {\n                         assert_eq!(HITS, 3);\n                     } else {\n                         if HITS == 1 {\n@@ -537,7 +633,7 @@ mod tests {\n             fn drop(&mut self) {\n                 unsafe {\n                     HITS += 1;\n-                    assert!(!K1.destroyed());\n+                    assert!(K1.state() != State::Destroyed);\n                     assert_eq!(HITS, 2);\n                     K1.with(|s| *s.get() = Some(S1));\n                 }\n@@ -546,7 +642,7 @@ mod tests {\n \n         Thread::spawn(move|| {\n             drop(S1);\n-        }).join();\n+        }).join().ok().unwrap();\n     }\n \n     #[test]\n@@ -558,13 +654,13 @@ mod tests {\n \n         impl Drop for S1 {\n             fn drop(&mut self) {\n-                assert!(K1.destroyed());\n+                assert!(K1.state() == State::Destroyed);\n             }\n         }\n \n         Thread::spawn(move|| unsafe {\n             K1.with(|s| *s.get() = Some(S1));\n-        }).join();\n+        }).join().ok().unwrap();\n     }\n \n     #[test]\n@@ -581,25 +677,25 @@ mod tests {\n             fn drop(&mut self) {\n                 let S1(ref tx) = *self;\n                 unsafe {\n-                    if !K2.destroyed() {\n+                    if K2.state() != State::Destroyed {\n                         K2.with(|s| *s.get() = Some(Foo(tx.clone())));\n                     }\n                 }\n             }\n         }\n \n         let (tx, rx) = channel();\n-        spawn(move|| unsafe {\n+        let _t = Thread::spawn(move|| unsafe {\n             let mut tx = Some(tx);\n             K1.with(|s| *s.get() = Some(S1(tx.take().unwrap())));\n         });\n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n }\n \n #[cfg(test)]\n mod dynamic_tests {\n-    use prelude::*;\n+    use prelude::v1::*;\n \n     use cell::RefCell;\n     use collections::HashMap;"}, {"sha": "c53d393f1eb709c9fcc32989384036ae9b354d1e", "filename": "src/libstd/thread_local/scoped.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fthread_local%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Fthread_local%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fscoped.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -39,12 +39,17 @@\n //! ```\n \n #![macro_escape]\n+#![unstable = \"scoped TLS has yet to have wide enough use to fully consider \\\n+               stabilizing its interface\"]\n \n-use prelude::*;\n+use prelude::v1::*;\n \n // macro hygiene sure would be nice, wouldn't it?\n-#[doc(hidden)] pub use self::imp::KeyInner;\n-#[doc(hidden)] pub use sys_common::thread_local::INIT as OS_INIT;\n+#[doc(hidden)]\n+pub mod __impl {\n+    pub use super::imp::KeyInner;\n+    pub use sys_common::thread_local::INIT as OS_INIT;\n+}\n \n /// Type representing a thread local storage key corresponding to a reference\n /// to the type parameter `T`.\n@@ -53,7 +58,7 @@ use prelude::*;\n /// type `T` scoped to a particular lifetime. Keys provides two methods, `set`\n /// and `with`, both of which currently use closures to control the scope of\n /// their contents.\n-pub struct Key<T> { #[doc(hidden)] pub inner: KeyInner<T> }\n+pub struct Key<T> { #[doc(hidden)] pub inner: __impl::KeyInner<T> }\n \n /// Declare a new scoped thread local storage key.\n ///\n@@ -88,21 +93,21 @@ macro_rules! __scoped_thread_local_inner {\n         use std::thread_local::scoped::Key as __Key;\n \n         #[cfg(not(any(windows, target_os = \"android\", target_os = \"ios\")))]\n-        const INIT: __Key<$t> = __Key {\n-            inner: ::std::thread_local::scoped::KeyInner {\n+        const _INIT: __Key<$t> = __Key {\n+            inner: ::std::thread_local::scoped::__impl::KeyInner {\n                 inner: ::std::cell::UnsafeCell { value: 0 as *mut _ },\n             }\n         };\n \n         #[cfg(any(windows, target_os = \"android\", target_os = \"ios\"))]\n-        const INIT: __Key<$t> = __Key {\n-            inner: ::std::thread_local::scoped::KeyInner {\n-                inner: ::std::thread_local::scoped::OS_INIT,\n+        const _INIT: __Key<$t> = __Key {\n+            inner: ::std::thread_local::scoped::__impl::KeyInner {\n+                inner: ::std::thread_local::scoped::__impl::OS_INIT,\n                 marker: ::std::kinds::marker::InvariantType,\n             }\n         };\n \n-        INIT\n+        _INIT\n     })\n }\n \n@@ -139,7 +144,7 @@ impl<T> Key<T> {\n         F: FnOnce() -> R,\n     {\n         struct Reset<'a, T: 'a> {\n-            key: &'a KeyInner<T>,\n+            key: &'a __impl::KeyInner<T>,\n             val: *mut T,\n         }\n         #[unsafe_destructor]\n@@ -238,7 +243,7 @@ mod imp {\n #[cfg(test)]\n mod tests {\n     use cell::Cell;\n-    use prelude::*;\n+    use prelude::v1::*;\n \n     scoped_thread_local!(static FOO: uint);\n "}, {"sha": "d6c94f27a8baf9462dea4a451861ad329956d37b", "filename": "src/libstd/time/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Ftime%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Ftime%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fmod.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -45,7 +45,7 @@ fn precise_time_ns() -> u64 {\n                                                                                    denom: 0 };\n         static ONCE: sync::Once = sync::ONCE_INIT;\n         unsafe {\n-            ONCE.doit(|| {\n+            ONCE.call_once(|| {\n                 imp::mach_timebase_info(&mut TIMEBASE);\n             });\n             let time = imp::mach_absolute_time();"}, {"sha": "fc90bffa03c2f77975535bfa3a656baa62d1b687", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -35,14 +35,14 @@\n //!\n //! # Examples\n //!\n-//! Using methods:\n+//! Using fields:\n //!\n //! ```\n //! #[allow(deprecated)]\n //! # fn main() {\n //! let pair = (\"pi\", 3.14f64);\n-//! assert_eq!(pair.val0(), \"pi\");\n-//! assert_eq!(pair.val1(), 3.14f64);\n+//! assert_eq!(pair.0, \"pi\");\n+//! assert_eq!(pair.1, 3.14f64);\n //! # }\n //! ```\n //!"}, {"sha": "a705872b53d9302b4a3c8480aa5035a8cab59d1c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -643,8 +643,8 @@ pub enum LocalSource {\n /// Local represents a `let` statement, e.g., `let <pat>:<ty> = <expr>;`\n #[deriving(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n pub struct Local {\n-    pub ty: P<Ty>,\n     pub pat: P<Pat>,\n+    pub ty: Option<P<Ty>>,\n     pub init: Option<P<Expr>>,\n     pub id: NodeId,\n     pub span: Span,\n@@ -1662,6 +1662,7 @@ mod test {\n     use serialize;\n     use codemap::*;\n     use super::*;\n+    use std::fmt;\n \n     // are ASTs encodable?\n     #[test]\n@@ -1687,6 +1688,6 @@ mod test {\n             exported_macros: Vec::new(),\n         };\n         // doesn't matter which encoder we use....\n-        let _f = &e as &serialize::Encodable<json::Encoder, io::IoError>;\n+        let _f = &e as &serialize::Encodable<json::Encoder, fmt::Error>;\n     }\n }"}, {"sha": "5eac6546c6b82676270329955870fccf65a8ee84", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -10,19 +10,24 @@\n //\n // ignore-lexer-test FIXME #15679\n \n-//! The CodeMap tracks all the source code used within a single crate, mapping from integer byte\n-//! positions to the original source code location. Each bit of source parsed during crate parsing\n-//! (typically files, in-memory strings, or various bits of macro expansion) cover a continuous\n-//! range of bytes in the CodeMap and are represented by FileMaps. Byte positions are stored in\n-//! `spans` and used pervasively in the compiler. They are absolute positions within the CodeMap,\n-//! which upon request can be converted to line and column information, source code snippets, etc.\n+//! The CodeMap tracks all the source code used within a single crate, mapping\n+//! from integer byte positions to the original source code location. Each bit\n+//! of source parsed during crate parsing (typically files, in-memory strings,\n+//! or various bits of macro expansion) cover a continuous range of bytes in the\n+//! CodeMap and are represented by FileMaps. Byte positions are stored in\n+//! `spans` and used pervasively in the compiler. They are absolute positions\n+//! within the CodeMap, which upon request can be converted to line and column\n+//! information, source code snippets, etc.\n \n pub use self::MacroFormat::*;\n \n-use serialize::{Encodable, Decodable, Encoder, Decoder};\n use std::cell::RefCell;\n+use std::num::ToPrimitive;\n+use std::ops::{Add, Sub};\n use std::rc::Rc;\n+\n use libc::c_uint;\n+use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n pub trait Pos {\n     fn from_uint(n: uint) -> Self;"}, {"sha": "ea345f3a458f49ea4b5d49b579072cf3efdaf18f", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -482,8 +482,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             self.pat_ident(sp, ident)\n         };\n         let local = P(ast::Local {\n-            ty: self.ty_infer(sp),\n             pat: pat,\n+            ty: None,\n             init: Some(ex),\n             id: ast::DUMMY_NODE_ID,\n             span: sp,\n@@ -506,8 +506,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             self.pat_ident(sp, ident)\n         };\n         let local = P(ast::Local {\n-            ty: typ,\n             pat: pat,\n+            ty: Some(typ),\n             init: Some(ex),\n             id: ast::DUMMY_NODE_ID,\n             span: sp,"}, {"sha": "9f225d55b444fe787bf7d8f73ce40798f4f8fd9e", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -17,7 +17,6 @@ use ext::base;\n use ext::build::AstBuilder;\n use std::ascii::AsciiExt;\n \n-\n pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt,\n                               sp: Span,\n                               tts: &[ast::TokenTree])"}, {"sha": "dcf25a26e2c69e04d192970a6816c4b02c953560", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -712,7 +712,7 @@ fn expand_non_macro_stmt(Spanned {node, span: stmt_span}: Stmt, fld: &mut MacroE\n                 let rewritten_local = local.map(|Local {id, pat, ty, init, source, span}| {\n                     // expand the ty since TyFixedLengthVec contains an Expr\n                     // and thus may have a macro use\n-                    let expanded_ty = fld.fold_ty(ty);\n+                    let expanded_ty = ty.map(|t| fld.fold_ty(t));\n                     // expand the pat (it might contain macro uses):\n                     let expanded_pat = fld.fold_pat(pat);\n                     // find the PatIdents in the pattern:"}, {"sha": "e46bd7ac4bc73c07ab63472edc0a2dcd3a6a3988", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -50,8 +50,7 @@ pub mod rt {\n \n     impl<T: ToTokens> ToTokens for Vec<T> {\n         fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n-            let a = self.iter().flat_map(|t| t.to_tokens(cx).into_iter());\n-            FromIterator::from_iter(a)\n+            self.iter().flat_map(|t| t.to_tokens(cx).into_iter()).collect()\n         }\n     }\n "}, {"sha": "545856a27af4ccd81b911f818d091581485a051a", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -56,6 +56,7 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     (\"simd\", Active),\n     (\"default_type_params\", Active),\n     (\"quote\", Active),\n+    (\"link_llvm_intrinsics\", Active),\n     (\"linkage\", Active),\n     (\"struct_inherit\", Removed),\n \n@@ -77,8 +78,11 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     // to bootstrap fix for #5723.\n     (\"issue_5723_bootstrap\", Accepted),\n \n-    // A way to temporary opt out of opt in copy. This will *never* be accepted.\n-    (\"opt_out_copy\", Active),\n+    // A way to temporarily opt out of opt in copy. This will *never* be accepted.\n+    (\"opt_out_copy\", Deprecated),\n+\n+    // A way to temporarily opt out of the new orphan rules. This will *never* be accepted.\n+    (\"old_orphan_check\", Deprecated),\n \n     // These are used to test this portion of the compiler, they don't actually\n     // mean anything\n@@ -91,6 +95,10 @@ enum Status {\n     /// currently being considered for addition/removal.\n     Active,\n \n+    /// Represents a feature gate that is temporarily enabling deprecated behavior.\n+    /// This gate will never be accepted.\n+    Deprecated,\n+\n     /// Represents a feature which has since been removed (it was once Active)\n     Removed,\n \n@@ -108,6 +116,7 @@ pub struct Features {\n     pub visible_private_types: bool,\n     pub quote: bool,\n     pub opt_out_copy: bool,\n+    pub old_orphan_check: bool,\n }\n \n impl Features {\n@@ -120,6 +129,7 @@ impl Features {\n             visible_private_types: false,\n             quote: false,\n             opt_out_copy: false,\n+            old_orphan_check: false,\n         }\n     }\n }\n@@ -327,6 +337,16 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                               \"the `linkage` attribute is experimental \\\n                                and not portable across platforms\")\n         }\n+\n+        let links_to_llvm = match attr::first_attr_value_str_by_name(i.attrs[], \"link_name\") {\n+            Some(val) => val.get().starts_with(\"llvm.\"),\n+            _ => false\n+        };\n+        if links_to_llvm {\n+            self.gate_feature(\"link_llvm_intrinsics\", i.span,\n+                              \"linking to LLVM intrinsics is experimental\");\n+        }\n+\n         visit::walk_foreign_item(self, i)\n     }\n \n@@ -442,7 +462,16 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler, krate: &ast::C\n                     };\n                     match KNOWN_FEATURES.iter()\n                                         .find(|& &(n, _)| name == n) {\n-                        Some(&(name, Active)) => { cx.features.push(name); }\n+                        Some(&(name, Active)) => {\n+                            cx.features.push(name);\n+                        }\n+                        Some(&(name, Deprecated)) => {\n+                            cx.features.push(name);\n+                            span_handler.span_warn(\n+                                mi.span,\n+                                \"feature is deprecated and will only be available \\\n+                                 for a limited time, please rewrite code that relies on it\");\n+                        }\n                         Some(&(_, Removed)) => {\n                             span_handler.span_err(mi.span, \"feature has been removed\");\n                         }\n@@ -469,6 +498,7 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler, krate: &ast::C\n         visible_private_types: cx.has_feature(\"visible_private_types\"),\n         quote: cx.has_feature(\"quote\"),\n         opt_out_copy: cx.has_feature(\"opt_out_copy\"),\n+        old_orphan_check: cx.has_feature(\"old_orphan_check\"),\n     },\n     unknown_features)\n }"}, {"sha": "3d3068f6868c6a3c5c850a542e8a2445e5f55f1b", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -53,7 +53,7 @@ impl<T> MoveMap<T> for OwnedSlice<T> {\n     }\n }\n \n-pub trait Folder {\n+pub trait Folder : Sized {\n     // Any additions to this trait should happen in form\n     // of a call to a public `noop_*` function that only calls\n     // out to the folder again, not other `noop_*` functions.\n@@ -553,7 +553,7 @@ pub fn noop_fold_parenthesized_parameter_data<T: Folder>(data: ParenthesizedPara\n pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n     l.map(|Local {id, pat, ty, init, source, span}| Local {\n         id: fld.new_id(id),\n-        ty: fld.fold_ty(ty),\n+        ty: ty.map(|t| fld.fold_ty(t)),\n         pat: fld.fold_pat(pat),\n         init: init.map(|e| fld.fold_expr(e)),\n         source: source,"}, {"sha": "18cdb3fc6478949180903e8481d04506c0f1a269", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -26,6 +26,8 @@\n #![feature(macro_rules, globs, default_type_params, phase, slicing_syntax)]\n #![feature(quote, unsafe_destructor)]\n #![feature(unboxed_closures)]\n+#![feature(old_orphan_check)]\n+#![feature(associated_types)]\n \n extern crate arena;\n extern crate fmt_macros;"}, {"sha": "bc2e09231159aea3b1ad396278530fad6ab67655", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -8,8 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::fmt;\n use std::default::Default;\n+use std::fmt;\n+use std::iter::FromIterator;\n+use std::ops::Deref;\n use std::vec;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n@@ -54,7 +56,9 @@ impl<T> OwnedSlice<T> {\n     }\n }\n \n-impl<T> Deref<[T]> for OwnedSlice<T> {\n+impl<T> Deref for OwnedSlice<T> {\n+    type Target = [T];\n+\n     fn deref(&self) -> &[T] {\n         self.as_slice()\n     }"}, {"sha": "0f5ff33021cc94867a0f014b177896859ffd7c17", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -16,6 +16,7 @@ use ext::tt::transcribe::tt_next_token;\n use parse::token;\n use parse::token::{str_to_ident};\n \n+use std::borrow::IntoCow;\n use std::char;\n use std::fmt;\n use std::mem::replace;\n@@ -358,7 +359,7 @@ impl<'a> StringReader<'a> {\n \n     pub fn nextnextch(&self) -> Option<char> {\n         let offset = self.byte_offset(self.pos).to_uint();\n-        let s = self.filemap.deref().src[];\n+        let s = self.filemap.src.as_slice();\n         if offset >= s.len() { return None }\n         let str::CharRange { next, .. } = s.char_range_at(offset);\n         if next < s.len() {"}, {"sha": "c597968d4ae533f9eedf481e0245b6a8d00c5798", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -84,11 +84,12 @@ use owned_slice::OwnedSlice;\n \n use std::collections::HashSet;\n use std::io::fs::PathExtensions;\n+use std::iter;\n use std::mem;\n use std::num::Float;\n use std::rc::Rc;\n-use std::iter;\n use std::slice;\n+use std::str::from_str;\n \n bitflags! {\n     flags Restrictions: u8 {\n@@ -3631,13 +3632,9 @@ impl<'a> Parser<'a> {\n         let lo = self.span.lo;\n         let pat = self.parse_pat();\n \n-        let mut ty = P(Ty {\n-            id: ast::DUMMY_NODE_ID,\n-            node: TyInfer,\n-            span: mk_sp(lo, lo),\n-        });\n+        let mut ty = None;\n         if self.eat(&token::Colon) {\n-            ty = self.parse_ty_sum();\n+            ty = Some(self.parse_ty_sum());\n         }\n         let init = self.parse_initializer();\n         P(ast::Local {"}, {"sha": "2745b7e13e9bb47acd69148ca03916442a281e62", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -22,8 +22,10 @@ use util::interner::{RcStr, StrInterner};\n use util::interner;\n \n use serialize::{Decodable, Decoder, Encodable, Encoder};\n+use std::cmp::Equiv;\n use std::fmt;\n use std::mem;\n+use std::ops::Deref;\n use std::path::BytesContainer;\n use std::rc::Rc;\n \n@@ -606,7 +608,9 @@ impl InternedString {\n     }\n }\n \n-impl Deref<str> for InternedString {\n+impl Deref for InternedString {\n+    type Target = str;\n+\n     fn deref(&self) -> &str { &*self.string }\n }\n "}, {"sha": "64eb4192bf0e64ddf8d2baf5bf1156228de4432a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -1858,13 +1858,11 @@ impl<'a> State<'a> {\n \n     pub fn print_local_decl(&mut self, loc: &ast::Local) -> IoResult<()> {\n         try!(self.print_pat(&*loc.pat));\n-        match loc.ty.node {\n-            ast::TyInfer => Ok(()),\n-            _ => {\n-                try!(self.word_space(\":\"));\n-                self.print_type(&*loc.ty)\n-            }\n+        if let Some(ref ty) = loc.ty {\n+            try!(self.word_space(\":\"));\n+            try!(self.print_type(&**ty));\n         }\n+        Ok(())\n     }\n \n     pub fn print_decl(&mut self, decl: &ast::Decl) -> IoResult<()> {"}, {"sha": "a989b32372390be2e9f7026559beea2572e87fb5", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -10,16 +10,18 @@\n \n //! The AST pointer\n //!\n-//! Provides `P<T>`, a frozen owned smart pointer, as a replacement for `@T` in the AST.\n+//! Provides `P<T>`, a frozen owned smart pointer, as a replacement for `@T` in\n+//! the AST.\n //!\n //! # Motivations and benefits\n //!\n-//! * **Identity**: sharing AST nodes is problematic for the various analysis passes\n-//!   (e.g. one may be able to bypass the borrow checker with a shared `ExprAddrOf`\n-//!   node taking a mutable borrow). The only reason `@T` in the AST hasn't caused\n-//!   issues is because of inefficient folding passes which would always deduplicate\n-//!   any such shared nodes. Even if the AST were to switch to an arena, this would\n-//!   still hold, i.e. it couldn't use `&'a T`, but rather a wrapper like `P<'a, T>`.\n+//! * **Identity**: sharing AST nodes is problematic for the various analysis\n+//!   passes (e.g. one may be able to bypass the borrow checker with a shared\n+//!   `ExprAddrOf` node taking a mutable borrow). The only reason `@T` in the\n+//!   AST hasn't caused issues is because of inefficient folding passes which\n+//!   would always deduplicate any such shared nodes. Even if the AST were to\n+//!   switch to an arena, this would still hold, i.e. it couldn't use `&'a T`,\n+//!   but rather a wrapper like `P<'a, T>`.\n //!\n //! * **Immutability**: `P<T>` disallows mutating its inner `T`, unlike `Box<T>`\n //!   (unless it contains an `Unsafe` interior, but that may be denied later).\n@@ -34,9 +36,9 @@\n //!   implementation changes (using a special thread-local heap, for example).\n //!   Moreover, a switch to, e.g. `P<'a, T>` would be easy and mostly automated.\n \n-use std::fmt;\n-use std::fmt::Show;\n+use std::fmt::{mod, Show};\n use std::hash::Hash;\n+use std::ops::Deref;\n use std::ptr;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n@@ -75,7 +77,9 @@ impl<T: 'static> P<T> {\n     }\n }\n \n-impl<T> Deref<T> for P<T> {\n+impl<T> Deref for P<T> {\n+    type Target = T;\n+\n     fn deref<'a>(&'a self) -> &'a T {\n         &*self.ptr\n     }"}, {"sha": "5a4d0cc3bd896cb69c58a07513bc5b2e4674b910", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -152,15 +152,20 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n         let prelude_path = ast::Path {\n             span: DUMMY_SP,\n             global: false,\n-            segments: vec!(\n+            segments: vec![\n                 ast::PathSegment {\n                     identifier: token::str_to_ident(\"std\"),\n                     parameters: ast::PathParameters::none(),\n                 },\n                 ast::PathSegment {\n                     identifier: token::str_to_ident(\"prelude\"),\n                     parameters: ast::PathParameters::none(),\n-                }),\n+                },\n+                ast::PathSegment {\n+                    identifier: token::str_to_ident(\"v1\"),\n+                    parameters: ast::PathParameters::none(),\n+                },\n+            ],\n         };\n \n         let (crates, uses): (Vec<_>, _) = view_items.iter().cloned().partition(|x| {"}, {"sha": "6e087778de9cdf0031e8db960802aea614394a4c", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -15,10 +15,12 @@\n use ast::Name;\n \n use std::borrow::BorrowFrom;\n-use std::collections::HashMap;\n use std::cell::RefCell;\n+use std::cmp::Ordering;\n+use std::collections::HashMap;\n use std::fmt;\n use std::hash::Hash;\n+use std::ops::Deref;\n use std::rc::Rc;\n \n pub struct Interner<T> {\n@@ -124,7 +126,9 @@ impl BorrowFrom<RcStr> for str {\n     }\n }\n \n-impl Deref<str> for RcStr {\n+impl Deref for RcStr {\n+    type Target = str;\n+\n     fn deref(&self) -> &str { self.string[] }\n }\n "}, {"sha": "953a7ae960e8c029d27721fbb9105ea7463bab8f", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -7,9 +7,11 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+\n use self::SmallVectorRepr::*;\n use self::IntoIterRepr::*;\n \n+use std::iter::FromIterator;\n use std::mem;\n use std::slice;\n use std::vec;"}, {"sha": "a1fe63e3f6fcd27af7d9fb981c0f5d2bd7432f8e", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -54,8 +54,7 @@ pub enum FnKind<'a> {\n /// explicitly, you need to override each method.  (And you also need\n /// to monitor future changes to `Visitor` in case a new method with a\n /// new default implementation gets introduced.)\n-pub trait Visitor<'v> {\n-\n+pub trait Visitor<'v> : Sized {\n     fn visit_name(&mut self, _span: Span, _name: Name) {\n         // Nothing to do.\n     }\n@@ -211,7 +210,7 @@ pub fn walk_view_item<'v, V: Visitor<'v>>(visitor: &mut V, vi: &'v ViewItem) {\n \n pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n     visitor.visit_pat(&*local.pat);\n-    visitor.visit_ty(&*local.ty);\n+    walk_ty_opt(visitor, &local.ty);\n     walk_expr_opt(visitor, &local.init);\n }\n \n@@ -381,6 +380,13 @@ pub fn skip_ty<'v, V: Visitor<'v>>(_: &mut V, _: &'v Ty) {\n     // Empty!\n }\n \n+pub fn walk_ty_opt<'v, V: Visitor<'v>>(visitor: &mut V, optional_type: &'v Option<P<Ty>>) {\n+    match *optional_type {\n+        Some(ref ty) => visitor.visit_ty(&**ty),\n+        None => ()\n+    }\n+}\n+\n pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n     match typ.node {\n         TyVec(ref ty) | TyParen(ref ty) => {\n@@ -583,10 +589,7 @@ pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V,\n pub fn walk_ty_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v TyParam) {\n     visitor.visit_ident(param.span, param.ident);\n     walk_ty_param_bounds_helper(visitor, &param.bounds);\n-    match param.default {\n-        Some(ref ty) => visitor.visit_ty(&**ty),\n-        None => {}\n-    }\n+    walk_ty_opt(visitor, &param.default);\n }\n \n pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics) {"}, {"sha": "b2d3611fc64fcb0d76614fc546d6cca05f0d4dcc", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -31,8 +31,10 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n+#![allow(unknown_features)]\n #![feature(asm, macro_rules, phase, globs, slicing_syntax)]\n #![feature(unboxed_closures, default_type_params)]\n+#![feature(old_orphan_check)]\n \n extern crate getopts;\n extern crate regex;\n@@ -49,16 +51,16 @@ use self::TestEvent::*;\n use self::NamePadding::*;\n use self::OutputLocation::*;\n \n-use std::any::{Any, AnyRefExt};\n-use std::collections::BTreeMap;\n use stats::Stats;\n use getopts::{OptGroup, optflag, optopt};\n use regex::Regex;\n use serialize::{json, Decodable, Encodable};\n use term::Terminal;\n use term::color::{Color, RED, YELLOW, GREEN, CYAN};\n \n+use std::any::{Any, AnyRefExt};\n use std::cmp;\n+use std::collections::BTreeMap;\n use std::f64;\n use std::fmt::Show;\n use std::fmt;\n@@ -69,11 +71,11 @@ use std::io;\n use std::iter::repeat;\n use std::num::{Float, FloatMath, Int};\n use std::os;\n-use std::str::FromStr;\n-use std::string::String;\n+use std::str::{FromStr, from_str};\n+use std::sync::mpsc::{channel, Sender};\n use std::thread::{mod, Thread};\n-use std::time::Duration;\n use std::thunk::{Thunk, Invoke};\n+use std::time::Duration;\n \n // to be used by rustc to compile tests in libtest\n pub mod test {\n@@ -171,14 +173,14 @@ impl TestFn {\n \n impl fmt::Show for TestFn {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write(match *self {\n+        f.write_str(match *self {\n             StaticTestFn(..) => \"StaticTestFn(..)\",\n             StaticBenchFn(..) => \"StaticBenchFn(..)\",\n             StaticMetricFn(..) => \"StaticMetricFn(..)\",\n             DynTestFn(..) => \"DynTestFn(..)\",\n             DynMetricFn(..) => \"DynMetricFn(..)\",\n             DynBenchFn(..) => \"DynBenchFn(..)\"\n-        }.as_bytes())\n+        })\n     }\n }\n \n@@ -1021,7 +1023,7 @@ fn run_tests<F>(opts: &TestOpts,\n             pending += 1;\n         }\n \n-        let (desc, result, stdout) = rx.recv();\n+        let (desc, result, stdout) = rx.recv().unwrap();\n         if concurrency != 1 {\n             try!(callback(TeWait(desc.clone(), PadNone)));\n         }\n@@ -1034,7 +1036,7 @@ fn run_tests<F>(opts: &TestOpts,\n     for b in filtered_benchs_and_metrics.into_iter() {\n         try!(callback(TeWait(b.desc.clone(), b.testfn.padding())));\n         run_test(opts, !opts.run_benchmarks, b, tx.clone());\n-        let (test, result, stdout) = rx.recv();\n+        let (test, result, stdout) = rx.recv().unwrap();\n         try!(callback(TeResult(test, result, stdout)));\n     }\n     Ok(())\n@@ -1111,7 +1113,7 @@ pub fn run_test(opts: &TestOpts,\n     let TestDescAndFn {desc, testfn} = test;\n \n     if force_ignore || desc.ignore {\n-        monitor_ch.send((desc, TrIgnored, Vec::new()));\n+        monitor_ch.send((desc, TrIgnored, Vec::new())).unwrap();\n         return;\n     }\n \n@@ -1138,31 +1140,31 @@ pub fn run_test(opts: &TestOpts,\n             let result_guard = cfg.spawn(move || { testfn.invoke(()) });\n             let stdout = reader.read_to_end().unwrap().into_iter().collect();\n             let test_result = calc_result(&desc, result_guard.join());\n-            monitor_ch.send((desc.clone(), test_result, stdout));\n+            monitor_ch.send((desc.clone(), test_result, stdout)).unwrap();\n         }).detach();\n     }\n \n     match testfn {\n         DynBenchFn(bencher) => {\n             let bs = ::bench::benchmark(|harness| bencher.run(harness));\n-            monitor_ch.send((desc, TrBench(bs), Vec::new()));\n+            monitor_ch.send((desc, TrBench(bs), Vec::new())).unwrap();\n             return;\n         }\n         StaticBenchFn(benchfn) => {\n             let bs = ::bench::benchmark(|harness| (benchfn.clone())(harness));\n-            monitor_ch.send((desc, TrBench(bs), Vec::new()));\n+            monitor_ch.send((desc, TrBench(bs), Vec::new())).unwrap();\n             return;\n         }\n         DynMetricFn(f) => {\n             let mut mm = MetricMap::new();\n             f.invoke(&mut mm);\n-            monitor_ch.send((desc, TrMetrics(mm), Vec::new()));\n+            monitor_ch.send((desc, TrMetrics(mm), Vec::new())).unwrap();\n             return;\n         }\n         StaticMetricFn(f) => {\n             let mut mm = MetricMap::new();\n             f(&mut mm);\n-            monitor_ch.send((desc, TrMetrics(mm), Vec::new()));\n+            monitor_ch.send((desc, TrMetrics(mm), Vec::new())).unwrap();\n             return;\n         }\n         DynTestFn(f) => run_test_inner(desc, monitor_ch, opts.nocapture, f),\n@@ -1212,8 +1214,7 @@ impl MetricMap {\n     pub fn save(&self, p: &Path) -> io::IoResult<()> {\n         let mut file = try!(File::create(p));\n         let MetricMap(ref map) = *self;\n-        let mut enc = json::PrettyEncoder::new(&mut file);\n-        map.encode(&mut enc)\n+        write!(&mut file, \"{}\", json::as_json(map))\n     }\n \n     /// Compare against another MetricMap. Optionally compare all\n@@ -1466,6 +1467,7 @@ mod tests {\n                StaticTestName, DynTestName, DynTestFn, ShouldFail};\n     use std::io::TempDir;\n     use std::thunk::Thunk;\n+    use std::sync::mpsc::channel;\n \n     #[test]\n     pub fn do_not_run_ignored_tests() {\n@@ -1480,7 +1482,7 @@ mod tests {\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n-        let (_, res, _) = rx.recv();\n+        let (_, res, _) = rx.recv().unwrap();\n         assert!(res != TrOk);\n     }\n \n@@ -1497,7 +1499,7 @@ mod tests {\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n-        let (_, res, _) = rx.recv();\n+        let (_, res, _) = rx.recv().unwrap();\n         assert!(res == TrIgnored);\n     }\n \n@@ -1514,7 +1516,7 @@ mod tests {\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n-        let (_, res, _) = rx.recv();\n+        let (_, res, _) = rx.recv().unwrap();\n         assert!(res == TrOk);\n     }\n \n@@ -1531,7 +1533,7 @@ mod tests {\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n-        let (_, res, _) = rx.recv();\n+        let (_, res, _) = rx.recv().unwrap();\n         assert!(res == TrOk);\n     }\n \n@@ -1548,7 +1550,7 @@ mod tests {\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n-        let (_, res, _) = rx.recv();\n+        let (_, res, _) = rx.recv().unwrap();\n         assert!(res == TrFailed);\n     }\n \n@@ -1565,7 +1567,7 @@ mod tests {\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n-        let (_, res, _) = rx.recv();\n+        let (_, res, _) = rx.recv().unwrap();\n         assert!(res == TrFailed);\n     }\n "}, {"sha": "ed6a00a8e9115b9f3832fecb5d448643d9c3179f", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -10,13 +10,14 @@\n \n #![allow(missing_docs)]\n \n-use std::collections::hash_map;\n+use std::cmp::Ordering::{mod, Less, Greater, Equal};\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n+use std::collections::hash_map;\n use std::fmt::Show;\n use std::hash::Hash;\n use std::io;\n use std::mem;\n-use std::num::{Float, FloatMath};\n+use std::num::{Float, FloatMath, FromPrimitive};\n \n fn local_cmp<T:Float>(x: T, y: T) -> Ordering {\n     // arbitrarily decide that NaNs are larger than everything."}, {"sha": "bc5d0c21aaeb466c63c9e9cedf2621688a7ee6be", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -20,7 +20,10 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n+\n+#![allow(unknown_features)]\n #![feature(phase, globs)]\n+#![feature(old_orphan_check)]\n \n #[cfg(test)] #[phase(plugin, link)] extern crate log;\n \n@@ -30,10 +33,9 @@ extern crate libc;\n pub use self::ParseError::*;\n use self::Fmt::*;\n \n-use std::fmt::Show;\n-use std::fmt;\n+use std::fmt::{mod, Show};\n use std::num::SignedInt;\n-use std::string::String;\n+use std::ops::{Add, Sub};\n use std::time::Duration;\n \n static NSEC_PER_SEC: i32 = 1_000_000_000_i32;\n@@ -198,7 +200,7 @@ pub fn precise_time_ns() -> u64 {\n                                                                                    denom: 0 };\n         static ONCE: std::sync::Once = std::sync::ONCE_INIT;\n         unsafe {\n-            ONCE.doit(|| {\n+            ONCE.call_once(|| {\n                 imp::mach_timebase_info(&mut TIMEBASE);\n             });\n             let time = imp::mach_absolute_time();\n@@ -1274,6 +1276,7 @@ mod tests {\n     #[cfg(windows)]\n     fn set_time_zone() {\n         use libc;\n+        use std::c_str::ToCStr;\n         // Windows crt doesn't see any environment variable set by\n         // `SetEnvironmentVariable`, which `os::setenv` internally uses.\n         // It is why we use `putenv` here."}, {"sha": "34beb53bd07cc7391d8272706deffbd01c76ae42", "filename": "src/snapshots.txt", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -1,3 +1,12 @@\n+S 2015-01-01 7d4f487\n+  freebsd-x86_64 5dc87adb17bc33abc08f1bf4c092e0b5b92a6ca4\n+  linux-i386 63bf82a5b540d8acbbf1e445ce48be0fa0f003fc\n+  linux-x86_64 b1a414355ef5d2feff18ab9d008a2e9afc7b4625\n+  macos-i386 26042e3e648eb40848bf02f3e05ba31fd686179c\n+  macos-x86_64 f01d7c6faf5db480a18a521c6971364f4ce8ddca\n+  winnt-i386 6f04af045d26a0c87d487ba7254d4ad0c166ecaf\n+  winnt-x86_64 392ab49482ec926de6a167afe920518b9a502a3f\n+\n S 2014-12-30 023dfb0\n   freebsd-x86_64 41ecd0ac557c823831c46696c7d78dc250398f25\n   linux-i386 fe6b59bf70a397e18629cb82264f7c6a70df34d4"}, {"sha": "ec470ddc21343fdd684691d95856e502c31a5089", "filename": "src/test/auxiliary/cci_capture_clause.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::task;\n+use std::sync::mpsc::{Receiver, channel};\n \n pub fn foo<T:Send + Clone>(x: T) -> Receiver<T> {\n     let (tx, rx) = channel();"}, {"sha": "daa123849e4e797d539db3433a7908c97f18887f", "filename": "src/test/auxiliary/coherence-lib.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fauxiliary%2Fcoherence-lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fauxiliary%2Fcoherence-lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcoherence-lib.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type=\"lib\"]\n+\n+pub trait Remote {\n+    fn foo(&self) { }\n+}\n+\n+pub trait Remote1<T> {\n+    fn foo(&self, t: T) { }\n+}\n+\n+pub trait Remote2<T, U> {\n+    fn foo(&self, t: T, u: U) { }\n+}\n+\n+pub struct Pair<T,U>(T,U);"}, {"sha": "689610d799ec065d979858c998df04ce60a473d5", "filename": "src/test/auxiliary/issue-17718.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fauxiliary%2Fissue-17718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fauxiliary%2Fissue-17718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-17718.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -11,12 +11,12 @@\n use std::sync::atomic;\n \n pub const C1: uint = 1;\n-pub const C2: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+pub const C2: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n pub const C3: fn() = foo;\n pub const C4: uint = C1 * C1 + C1 / C1;\n pub const C5: &'static uint = &C4;\n \n pub static S1: uint = 3;\n-pub static S2: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+pub static S2: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n \n fn foo() {}"}, {"sha": "60e3cb13e2e46a88a4d1b0693feec04b212f5db2", "filename": "src/test/auxiliary/issue_20389.rs", "status": "renamed", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fauxiliary%2Fissue_20389.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fauxiliary%2Fissue_20389.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_20389.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Useful for checking syscall usage of baseline scheduler usage\n-fn main() {\n-    spawn(move|| {});\n+#![feature(associated_types)]\n+\n+pub trait T {\n+    type C;\n }", "previous_filename": "src/test/bench/spawnone.rs"}, {"sha": "eb4d62b01ad1a07189e9ef766b199ae1f156e1eb", "filename": "src/test/auxiliary/method_self_arg2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fauxiliary%2Fmethod_self_arg2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fauxiliary%2Fmethod_self_arg2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmethod_self_arg2.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -32,7 +32,7 @@ impl Foo {\n     }\n }\n \n-pub trait Bar {\n+pub trait Bar : Sized {\n     fn foo1(&self);\n     fn foo2(self);\n     fn foo3(self: Box<Self>);"}, {"sha": "05960a5b8e1dd6196a51f865972be9c745200433", "filename": "src/test/auxiliary/overloaded_autoderef_xc.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fauxiliary%2Foverloaded_autoderef_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fauxiliary%2Foverloaded_autoderef_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Foverloaded_autoderef_xc.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(associated_types)]\n+\n use std::ops::Deref;\n \n struct DerefWithHelper<H, T> {\n@@ -24,7 +26,9 @@ impl<T> Helper<T> for Option<T> {\n     }\n }\n \n-impl<T, H: Helper<T>> Deref<T> for DerefWithHelper<H, T> {\n+impl<T, H: Helper<T>> Deref for DerefWithHelper<H, T> {\n+    type Target = T;\n+\n     fn deref(&self) -> &T {\n         self.helper.helper_borrow()\n     }"}, {"sha": "ea4751bf4ed20b07c6b4871b7cfa8aafcbc50c72", "filename": "src/test/auxiliary/static-methods-crate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -12,6 +12,7 @@\n #![crate_type = \"lib\"]\n \n use std::int;\n+use std::str::from_str;\n \n pub trait read {\n     fn readMaybe(s: String) -> Option<Self>;"}, {"sha": "7ddf2c43489c157e05027037837f90173c797981", "filename": "src/test/auxiliary/trait_inheritance_overloading_xc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::cmp::PartialEq;\n+use std::ops::{Add, Sub, Mul};\n \n pub trait MyNum : Add<Self,Self> + Sub<Self,Self> + Mul<Self,Self> + PartialEq + Clone {\n }"}, {"sha": "fd454509b394055aed33f8e44e70ad0d1cb0193b", "filename": "src/test/auxiliary/traitimpl.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fauxiliary%2Ftraitimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fauxiliary%2Ftraitimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftraitimpl.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test inherant trait impls work cross-crait.\n+\n+pub trait Bar<'a> for ?Sized : 'a {}\n+\n+impl<'a> Bar<'a> {\n+    pub fn bar(&self) {}\n+}"}, {"sha": "0b65fa913cb775a32ff44af546d08649f6c3b8ab", "filename": "src/test/auxiliary/unboxed-closures-cross-crate.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fauxiliary%2Funboxed-closures-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fauxiliary%2Funboxed-closures-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Funboxed-closures-cross-crate.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -10,6 +10,8 @@\n \n #![feature(unboxed_closures)]\n \n+use std::ops::Add;\n+\n #[inline]\n pub fn has_closures() -> uint {\n     let x = 1u;"}, {"sha": "0ada1cb991c6be80682edac8f8df45fb99825605", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -13,6 +13,7 @@\n use std::collections::{BTreeMap, HashMap, HashSet};\n use std::os;\n use std::rand::{Rng, IsaacRng, SeedableRng};\n+use std::str::from_str;\n use std::time::Duration;\n use std::uint;\n "}, {"sha": "52380001c6c0d4da69e9f38b729ac0ef376dfa09", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -15,11 +15,12 @@\n extern crate collections;\n extern crate rand;\n \n+use std::collections::BTreeSet;\n use std::collections::BitvSet;\n use std::collections::HashSet;\n-use std::collections::BTreeSet;\n use std::hash::Hash;\n use std::os;\n+use std::str::from_str;\n use std::time::Duration;\n use std::uint;\n "}, {"sha": "08637b4bf1c1c5777c291c2e45ed0e3ed64678e1", "filename": "src/test/bench/core-uint-to-str.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::os;\n+use std::str::from_str;\n use std::uint;\n \n fn main() {"}, {"sha": "285d193e7da8bcba46d631f8e221a25e631311f9", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -18,8 +18,9 @@\n // different scalability characteristics compared to the select\n // version.\n \n-use std::comm;\n+use std::sync::mpsc::{channel, Sender, Receiver};\n use std::os;\n+use std::str::from_str;\n use std::thread::Thread;\n use std::time::Duration;\n use std::uint;\n@@ -36,8 +37,8 @@ fn server(requests: &Receiver<request>, responses: &Sender<uint>) {\n     let mut count = 0u;\n     let mut done = false;\n     while !done {\n-        match requests.recv_opt() {\n-          Ok(request::get_count) => { responses.send(count.clone()); }\n+        match requests.recv() {\n+          Ok(request::get_count) => { responses.send(count.clone()).unwrap(); }\n           Ok(request::bytes(b)) => {\n             //println!(\"server: received {} bytes\", b);\n             count += b;\n@@ -46,7 +47,7 @@ fn server(requests: &Receiver<request>, responses: &Sender<uint>) {\n           _ => { }\n         }\n     }\n-    responses.send(count);\n+    responses.send(count).unwrap();\n     //println!(\"server exiting\");\n }\n \n@@ -67,7 +68,7 @@ fn run(args: &[String]) {\n             worker_results.push(Thread::spawn(move|| {\n                 for _ in range(0u, size / workers) {\n                     //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n-                    to_child.send(request::bytes(num_bytes));\n+                    to_child.send(request::bytes(num_bytes)).unwrap();\n                 }\n                 //println!(\"worker {} exiting\", i);\n             }));\n@@ -81,9 +82,9 @@ fn run(args: &[String]) {\n         }\n \n         //println!(\"sending stop message\");\n-        to_child.send(request::stop);\n+        to_child.send(request::stop).unwrap();\n         move_out(to_child);\n-        result = Some(from_child.recv());\n+        result = Some(from_child.recv().unwrap());\n     });\n     let result = result.unwrap();\n     print!(\"Count is {}\\n\", result);"}, {"sha": "ef22aac776e0334727370b5fcba0cdeedd431af4", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -14,6 +14,7 @@\n //\n // I *think* it's the same, more or less.\n \n+use std::sync::mpsc::{channel, Sender, Receiver};\n use std::os;\n use std::thread::Thread;\n use std::time::Duration;\n@@ -31,7 +32,7 @@ fn server(requests: &Receiver<request>, responses: &Sender<uint>) {\n     let mut count: uint = 0;\n     let mut done = false;\n     while !done {\n-        match requests.recv_opt() {\n+        match requests.recv() {\n           Ok(request::get_count) => { responses.send(count.clone()); }\n           Ok(request::bytes(b)) => {\n             //println!(\"server: received {} bytes\", b);\n@@ -48,8 +49,8 @@ fn server(requests: &Receiver<request>, responses: &Sender<uint>) {\n fn run(args: &[String]) {\n     let (to_parent, from_child) = channel();\n \n-    let size = from_str::<uint>(args[1].as_slice()).unwrap();\n-    let workers = from_str::<uint>(args[2].as_slice()).unwrap();\n+    let size = args[1].parse::<uint>().unwrap();\n+    let workers = args[2].parse::<uint>().unwrap();\n     let num_bytes = 100;\n     let mut result = None;\n     let mut to_parent = Some(to_parent);\n@@ -91,7 +92,7 @@ fn run(args: &[String]) {\n         //println!(\"sending stop message\");\n         //to_child.send(stop);\n         //move_out(to_child);\n-        result = Some(from_child.recv());\n+        result = Some(from_child.recv().unwrap());\n     });\n     let result = result.unwrap();\n     print!(\"Count is {}\\n\", result);"}, {"sha": "3ead5ef64fd9953b41ed1957f75a403207a32dc4", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -19,6 +19,7 @@\n // ignore-lexer-test FIXME #15679\n \n use std::os;\n+use std::str::from_str;\n use std::sync::{Arc, Future, Mutex, Condvar};\n use std::time::Duration;\n use std::uint;"}, {"sha": "de9e6629fbfc04d57c361723d5572491bc14d583", "filename": "src/test/bench/rt-messaging-ping-pong.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -17,7 +17,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::sync::mpsc::channel;\n use std::os;\n+use std::str::from_str;\n+use std::thread::Thread;\n use std::uint;\n \n // This is a simple bench that creates M pairs of tasks. These\n@@ -34,21 +37,21 @@ fn ping_pong_bench(n: uint, m: uint) {\n         // Create a stream B->A\n         let (btx, brx) = channel::<()>();\n \n-        spawn(move|| {\n+        Thread::spawn(move|| {\n             let (tx, rx) = (atx, brx);\n             for _ in range(0, n) {\n                 tx.send(());\n                 rx.recv();\n             }\n-        });\n+        }).detach();\n \n-        spawn(move|| {\n+        Thread::spawn(move|| {\n             let (tx, rx) = (btx, arx);\n             for _ in range(0, n) {\n                 rx.recv();\n                 tx.send(());\n             }\n-        });\n+        }).detach();\n     }\n \n     for _ in range(0, m) {"}, {"sha": "8b212555d4011cdb2d7d1a301d2b4172127befd8", "filename": "src/test/bench/rt-parfib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Frt-parfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Frt-parfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-parfib.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::sync::mpsc::channel;\n use std::os;\n+use std::thread::Thread;\n use std::uint;\n \n // A simple implementation of parfib. One subtree is found in a new\n@@ -21,19 +23,19 @@ fn parfib(n: uint) -> uint {\n     }\n \n     let (tx, rx) = channel();\n-    spawn(move|| {\n+    Thread::spawn(move|| {\n         tx.send(parfib(n-1));\n-    });\n+    }).detach();\n     let m2 = parfib(n-2);\n-    return (rx.recv() + m2);\n+    return (rx.recv().unwrap() + m2);\n }\n \n fn main() {\n \n     let args = os::args();\n     let args = args.as_slice();\n     let n = if args.len() == 2 {\n-        from_str::<uint>(args[1].as_slice()).unwrap()\n+        args[1].parse::<uint>().unwrap()\n     } else {\n         10\n     };"}, {"sha": "f7810d5d740c0cb4adec5a0e3777047c4063e75f", "filename": "src/test/bench/shootout-ackermann.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-ackermann.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::os;\n+use std::str::from_str;\n \n fn ack(m: int, n: int) -> int {\n     if m == 0 {"}, {"sha": "c7a43d61a9a86b1215626a292fbbdafc597ca76f", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -41,7 +41,7 @@\n extern crate arena;\n \n use std::iter::range_step;\n-use std::sync::Future;\n+use std::thread::Thread;\n use arena::TypedArena;\n \n enum Tree<'a> {\n@@ -75,7 +75,7 @@ fn main() {\n     } else if args.len() <= 1u {\n         8\n     } else {\n-        from_str(args[1].as_slice()).unwrap()\n+        args[1].parse().unwrap()\n     };\n     let min_depth = 4;\n     let max_depth = if min_depth + 2 > n {min_depth + 2} else {n};\n@@ -95,7 +95,7 @@ fn main() {\n     let mut messages = range_step(min_depth, max_depth + 1, 2).map(|depth| {\n             use std::num::Int;\n             let iterations = 2i.pow((max_depth - depth + min_depth) as uint);\n-            Future::spawn(move|| {\n+            Thread::spawn(move|| {\n                 let mut chk = 0;\n                 for i in range(1, iterations + 1) {\n                     let arena = TypedArena::new();\n@@ -106,10 +106,10 @@ fn main() {\n                 format!(\"{}\\t trees of depth {}\\t check: {}\",\n                         iterations * 2, depth, chk)\n             })\n-        }).collect::<Vec<Future<String>>>();\n+        }).collect::<Vec<_>>();\n \n-    for message in messages.iter_mut() {\n-        println!(\"{}\", *message.get_ref());\n+    for message in messages.into_iter() {\n+        println!(\"{}\", message.join().ok().unwrap());\n     }\n \n     println!(\"long lived tree of depth {}\\t check: {}\","}, {"sha": "030c627b6f71e4df6c23ae8daadbd8f7d766628f", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -41,8 +41,10 @@\n // no-pretty-expanded\n \n use self::Color::{Red, Yellow, Blue};\n-use std::string::String;\n+use std::sync::mpsc::{channel, Sender, Receiver};\n use std::fmt;\n+use std::str::from_str;\n+use std::thread::Thread;\n \n fn print_complements() {\n     let all = [Blue, Red, Yellow];\n@@ -152,7 +154,7 @@ fn creature(\n \n     loop {\n         // ask for a pairing\n-        to_rendezvous.send(CreatureInfo {name: name, color: color});\n+        to_rendezvous.send(CreatureInfo {name: name, color: color}).unwrap();\n \n         // log and change, or quit\n         match rendezvous.next() {\n@@ -170,7 +172,7 @@ fn creature(\n     }\n     // log creatures met and evil clones of self\n     let report = format!(\"{}{}\", creatures_met, Number(evil_clones_met));\n-    to_rendezvous_log.send(report);\n+    to_rendezvous_log.send(report).unwrap();\n }\n \n fn rendezvous(nn: uint, set: Vec<Color>) {\n@@ -188,27 +190,27 @@ fn rendezvous(nn: uint, set: Vec<Color>) {\n             let to_rendezvous = to_rendezvous.clone();\n             let to_rendezvous_log = to_rendezvous_log.clone();\n             let (to_creature, from_rendezvous) = channel();\n-            spawn(move|| {\n+            Thread::spawn(move|| {\n                 creature(ii,\n                          col,\n                          from_rendezvous,\n                          to_rendezvous,\n                          to_rendezvous_log);\n-            });\n+            }).detach();\n             to_creature\n         }).collect();\n \n     let mut creatures_met = 0;\n \n     // set up meetings...\n     for _ in range(0, nn) {\n-        let fst_creature = from_creatures.recv();\n-        let snd_creature = from_creatures.recv();\n+        let fst_creature = from_creatures.recv().unwrap();\n+        let snd_creature = from_creatures.recv().unwrap();\n \n         creatures_met += 2;\n \n-        to_creature[fst_creature.name].send(snd_creature);\n-        to_creature[snd_creature.name].send(fst_creature);\n+        to_creature[fst_creature.name].send(snd_creature).unwrap();\n+        to_creature[snd_creature.name].send(fst_creature).unwrap();\n     }\n \n     // tell each creature to stop"}, {"sha": "7dca2b24fc11e8fa9b9ef817f74ee26d9fd4e990", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -41,7 +41,7 @@\n #![feature(slicing_syntax)]\n \n use std::{cmp, iter, mem};\n-use std::sync::Future;\n+use std::thread::Thread;\n \n fn rotate(x: &mut [i32]) {\n     let mut prev = x[0];\n@@ -168,15 +168,15 @@ fn fannkuch(n: i32) -> (i32, i32) {\n     for (i, j) in range(0, N).zip(iter::count(0, k)) {\n         let max = cmp::min(j+k, perm.max());\n \n-        futures.push(Future::spawn(move|| {\n+        futures.push(Thread::spawn(move|| {\n             work(perm, j as uint, max as uint)\n         }))\n     }\n \n     let mut checksum = 0;\n     let mut maxflips = 0;\n-    for fut in futures.iter_mut() {\n-        let (cs, mf) = fut.get();\n+    for fut in futures.into_iter() {\n+        let (cs, mf) = fut.join().ok().unwrap();\n         checksum += cs;\n         maxflips = cmp::max(maxflips, mf);\n     }\n@@ -186,7 +186,7 @@ fn fannkuch(n: i32) -> (i32, i32) {\n fn main() {\n     let n = std::os::args().as_slice()\n         .get(1)\n-        .and_then(|arg| from_str(arg.as_slice()))\n+        .and_then(|arg| arg.parse())\n         .unwrap_or(2i32);\n \n     let (checksum, maxflips) = fannkuch(n);"}, {"sha": "09f7f236f19a79e4844deed1a7c159e4d1039d6c", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -44,6 +44,7 @@ use std::cmp::min;\n use std::io::{stdout, IoResult};\n use std::os;\n use std::slice::bytes::copy_memory;\n+use std::str::from_str;\n \n const LINE_LEN: uint = 60;\n const LOOKUP_SIZE: uint = 4 * 1024;"}, {"sha": "7009dd4c1a76fa8fde1700721ade27606a10536f", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -40,11 +40,12 @@\n \n #![feature(slicing_syntax)]\n \n-use std::io;\n-use std::io::{BufferedWriter, File};\n use std::cmp::min;\n+use std::io::{BufferedWriter, File};\n+use std::io;\n use std::num::Float;\n use std::os;\n+use std::str::from_str;\n \n const LINE_LENGTH: uint = 60;\n const IM: u32 = 139968;"}, {"sha": "cbacf415f6f7fcef98d597fca54627bca86e6701", "filename": "src/test/bench/shootout-fibo.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fibo.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::os;\n+use std::str::from_str;\n \n fn fib(n: int) -> int {\n     if n < 2 {"}, {"sha": "d92d30ca844af51570a4d608aa43e66355e09f83", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -18,12 +18,15 @@\n extern crate collections;\n \n use std::ascii::{AsciiExt, OwnedAsciiExt};\n+use std::cmp::Ordering::{mod, Less, Greater, Equal};\n use std::collections::HashMap;\n+use std::sync::mpsc::{channel, Sender, Receiver};\n use std::mem::replace;\n use std::num::Float;\n use std::option;\n use std::os;\n-use std::string::String;\n+use std::string::IntoString;\n+use std::thread::Thread;\n \n fn f64_cmp(x: f64, y: f64) -> Ordering {\n     // arbitrarily decide that NaNs are larger than everything.\n@@ -117,7 +120,7 @@ fn make_sequence_processor(sz: uint,\n \n    loop {\n \n-       line = from_parent.recv();\n+       line = from_parent.recv().unwrap();\n        if line == Vec::new() { break; }\n \n        carry.push_all(line.as_slice());\n@@ -167,9 +170,9 @@ fn main() {\n \n         let (to_child, from_parent) = channel();\n \n-        spawn(move|| {\n+        Thread::spawn(move|| {\n             make_sequence_processor(sz, &from_parent, &to_parent_);\n-        });\n+        }).detach();\n \n         to_child\n     }).collect::<Vec<Sender<Vec<u8> >> >();\n@@ -219,6 +222,6 @@ fn main() {\n \n    // now fetch and print result messages\n    for (ii, _sz) in sizes.iter().enumerate() {\n-       println!(\"{}\", from_child[ii].recv());\n+       println!(\"{}\", from_child[ii].recv().unwrap());\n    }\n }"}, {"sha": "26ef696b616cec7ad64be134965cb3789c5cf293", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -43,7 +43,6 @@\n #![feature(slicing_syntax)]\n \n use std::ascii::OwnedAsciiExt;\n-use std::string::String;\n use std::slice;\n use std::sync::{Arc, Future};\n "}, {"sha": "51ce4cbaa841d022adbdf447009cffb9fa67cc9e", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -47,6 +47,7 @@\n use std::io;\n use std::os;\n use std::simd::f64x2;\n+use std::str::from_str;\n use std::sync::{Arc, Future};\n \n const ITER: int = 50;"}, {"sha": "0c3152d4780f2b8382432ff02f64166815d18724", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -40,7 +40,9 @@\n \n // no-pretty-expanded FIXME #15189\n \n+use std::sync::mpsc::channel;\n use std::sync::Arc;\n+use std::thread::Thread;\n \n //\n // Utilities.\n@@ -310,16 +312,16 @@ fn par_search(masks: Vec<Vec<Vec<u64>>>) -> Data {\n         let masks = masks.clone();\n         let tx = tx.clone();\n         let m = *m;\n-        spawn(move|| {\n+        Thread::spawn(move|| {\n             let mut data = Data::new();\n             search(&*masks, m, 1, List::Cons(m, &List::Nil), &mut data);\n-            tx.send(data);\n-        });\n+            tx.send(data).unwrap();\n+        }).detach();\n     }\n \n     // collecting the results\n     drop(tx);\n-    let mut data = rx.recv();\n+    let mut data = rx.recv().unwrap();\n     for d in rx.iter() { data.reduce_from(d); }\n     data\n }"}, {"sha": "6a325798f5805a71a62953c7fe71d9e7f12b75d9", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -39,6 +39,7 @@\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n use std::num::Float;\n+use std::str::from_str;\n \n const PI: f64 = 3.141592653589793;\n const SOLAR_MASS: f64 = 4.0 * PI * PI;"}, {"sha": "78b5ac00b45e0f4591df351d2ab4eea229101d92", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -20,30 +20,32 @@\n \n extern crate getopts;\n \n+use std::sync::mpsc::{channel, Sender};\n use std::os;\n use std::result::Result::{Ok, Err};\n+use std::str::from_str;\n use std::thread::Thread;\n use std::time::Duration;\n \n fn fib(n: int) -> int {\n     fn pfib(tx: &Sender<int>, n: int) {\n         if n == 0 {\n-            tx.send(0);\n+            tx.send(0).unwrap();\n         } else if n <= 2 {\n-            tx.send(1);\n+            tx.send(1).unwrap();\n         } else {\n             let (tx1, rx) = channel();\n             let tx2 = tx1.clone();\n             Thread::spawn(move|| pfib(&tx2, n - 1)).detach();\n             let tx2 = tx1.clone();\n             Thread::spawn(move|| pfib(&tx2, n - 2)).detach();\n-            tx.send(rx.recv() + rx.recv());\n+            tx.send(rx.recv().unwrap() + rx.recv().unwrap());\n         }\n     }\n \n     let (tx, rx) = channel();\n     Thread::spawn(move|| pfib(&tx, n) ).detach();\n-    rx.recv()\n+    rx.recv().unwrap()\n }\n \n struct Config {"}, {"sha": "d9dfd65d5b34bd49fec61bf02444ec5b97ca2222", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -45,9 +45,10 @@\n extern crate libc;\n \n use std::io::stdio::{stdin_raw, stdout_raw};\n+use std::io::{IoResult, EndOfFile};\n use std::num::{div_rem};\n use std::ptr::{copy_memory, Unique};\n-use std::io::{IoResult, EndOfFile};\n+use std::thread::Thread;\n \n struct Tables {\n     table8: [u8;1 << 8],\n@@ -229,26 +230,20 @@ unsafe impl<T: 'static> Send for Racy<T> {}\n fn parallel<'a, I, T, F>(mut iter: I, f: F)\n         where T: 'a+Send + Sync,\n               I: Iterator<&'a mut [T]>,\n-              F: Fn(&'a mut [T]) + Sync {\n+              F: Fn(&mut [T]) + Sync {\n     use std::mem;\n     use std::raw::Repr;\n \n-    let (tx, rx) = channel();\n-    for chunk in iter {\n-        let tx = tx.clone();\n-\n+    iter.map(|chunk| {\n         // Need to convert `f` and `chunk` to something that can cross the task\n         // boundary.\n         let f = Racy(&f as *const F as *const uint);\n         let raw = Racy(chunk.repr());\n-        spawn(move|| {\n+        Thread::spawn(move|| {\n             let f = f.0 as *const F;\n             unsafe { (*f)(mem::transmute(raw.0)) }\n-            drop(tx)\n-        });\n-    }\n-    drop(tx);\n-    for () in rx.iter() {}\n+        })\n+    }).collect::<Vec<_>>();\n }\n \n fn main() {"}, {"sha": "a5af1227a165de5efdebda356b655310f16081b2", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -44,11 +44,13 @@\n #![feature(unboxed_closures)]\n \n use std::iter::AdditiveIterator;\n+use std::thread::Thread;\n use std::mem;\n use std::num::Float;\n use std::os;\n use std::raw::Repr;\n use std::simd::f64x2;\n+use std::str::from_str;\n \n fn main() {\n     let args = os::args();\n@@ -80,14 +82,15 @@ fn mult_AtAv(v: &[f64], out: &mut [f64], tmp: &mut [f64]) {\n }\n \n fn mult_Av(v: &[f64], out: &mut [f64]) {\n-    parallel(out, |&: start, out| mult(v, out, start, |i, j| A(i, j)));\n+    parallel(out, |start, out| mult(v, out, start, |i, j| A(i, j)));\n }\n \n fn mult_Atv(v: &[f64], out: &mut [f64]) {\n-    parallel(out, |&: start, out| mult(v, out, start, |i, j| A(j, i)));\n+    parallel(out, |start, out| mult(v, out, start, |i, j| A(j, i)));\n }\n \n-fn mult(v: &[f64], out: &mut [f64], start: uint, a: |uint, uint| -> f64) {\n+fn mult<F>(v: &[f64], out: &mut [f64], start: uint, a: F)\n+           where F: Fn(uint, uint) -> f64 {\n     for (i, slot) in out.iter_mut().enumerate().map(|(i, s)| (i + start, s)) {\n         let mut sum = f64x2(0.0, 0.0);\n         for (j, chunk) in v.chunks(2).enumerate().map(|(j, s)| (2 * j, s)) {\n@@ -116,25 +119,19 @@ unsafe impl<T: 'static> Send for Racy<T> {}\n // Executes a closure in parallel over the given mutable slice. The closure `f`\n // is run in parallel and yielded the starting index within `v` as well as a\n // sub-slice of `v`.\n-fn parallel<'a, T, F>(v: &'a mut [T], f: F)\n-                      where T: Send + Sync,\n-                            F: Fn(uint, &'a mut [T]) + Sync {\n-    let (tx, rx) = channel();\n+fn parallel<T, F>(v: &mut [T], f: F)\n+                  where T: Send + Sync,\n+                        F: Fn(uint, &mut [T]) + Sync {\n     let size = v.len() / os::num_cpus() + 1;\n \n-    for (i, chunk) in v.chunks_mut(size).enumerate() {\n-        let tx = tx.clone();\n-\n+    v.chunks_mut(size).enumerate().map(|(i, chunk)| {\n         // Need to convert `f` and `chunk` to something that can cross the task\n         // boundary.\n         let f = Racy(&f as *const _ as *const uint);\n         let raw = Racy(chunk.repr());\n-        spawn(move|| {\n+        Thread::spawn(move|| {\n             let f = f.0 as *const F;\n             unsafe { (*f)(i * size, mem::transmute(raw.0)) }\n-            drop(tx)\n-        });\n-    }\n-    drop(tx);\n-    for () in rx.iter() {}\n+        })\n+    }).collect::<Vec<_>>();\n }"}, {"sha": "543597d8c8118401180698d55389f6c70453103e", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -38,15 +38,19 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n+use std::sync::mpsc::{channel, Sender, Receiver};\n+use std::str::from_str;\n+use std::thread::Thread;\n+\n fn start(n_tasks: int, token: int) {\n     let (tx, mut rx) = channel();\n     tx.send(token);\n     for i in range(2, n_tasks + 1) {\n         let (tx, next_rx) = channel();\n-        spawn(move|| roundtrip(i, tx, rx));\n+        Thread::spawn(move|| roundtrip(i, tx, rx)).detach();\n         rx = next_rx;\n     }\n-    spawn(move|| roundtrip(1, tx, rx));\n+    Thread::spawn(move|| roundtrip(1, tx, rx)).detach();\n }\n \n fn roundtrip(id: int, tx: Sender<int>, rx: Receiver<int>) {"}, {"sha": "035b222e6ce62073fc38e1194584f029c4236a88", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -12,6 +12,7 @@\n \n use std::collections::VecMap;\n use std::os;\n+use std::str::from_str;\n use std::time::Duration;\n use std::uint;\n "}, {"sha": "cccc9362a729ba6133a5f0ba0924bb72592cf024", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -12,11 +12,12 @@\n \n #![allow(non_snake_case)]\n \n-use std::io;\n-use std::io::stdio::StdReader;\n use std::io::BufferedReader;\n+use std::io::stdio::StdReader;\n+use std::io;\n use std::num::Int;\n use std::os;\n+use std::str::from_str;\n \n // Computes a single solution to a given 9x9 sudoku\n //"}, {"sha": "a0278a63a51d9c6a389cb0068bd09728271dc078", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -17,25 +17,27 @@\n \n // ignore-pretty very bad with line comments\n \n-use std::comm;\n+use std::sync::mpsc::{channel, Sender};\n use std::os;\n+use std::str::from_str;\n use std::task;\n+use std::thread::Thread;\n use std::uint;\n \n-fn child_generation(gens_left: uint, tx: comm::Sender<()>) {\n+fn child_generation(gens_left: uint, tx: Sender<()>) {\n     // This used to be O(n^2) in the number of generations that ever existed.\n     // With this code, only as many generations are alive at a time as tasks\n     // alive at a time,\n-    spawn(move|| {\n+    Thread::spawn(move|| {\n         if gens_left & 1 == 1 {\n             task::deschedule(); // shake things up a bit\n         }\n         if gens_left > 0 {\n             child_generation(gens_left - 1, tx); // recurse\n         } else {\n-            tx.send(())\n+            tx.send(()).unwrap()\n         }\n-    });\n+    }).detach();\n }\n \n fn main() {\n@@ -50,7 +52,7 @@ fn main() {\n \n     let (tx, rx) = channel();\n     child_generation(from_str::<uint>(args[1].as_slice()).unwrap(), tx);\n-    if rx.recv_opt().is_err() {\n+    if rx.recv().is_err() {\n         panic!(\"it happened when we slumbered\");\n     }\n }"}, {"sha": "7e2c6fcf0ecd461c7e960a7690cb8722453da989", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -11,6 +11,7 @@\n use std::os;\n use std::task;\n use std::uint;\n+use std::str::from_str;\n \n fn f(n: uint) {\n     let mut i = 0u;"}, {"sha": "5743216b6ca69e1ae98e757597f9dc3825a46b75", "filename": "src/test/compile-fail/associated-types-ICE-when-projecting-out-of-err.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fcompile-fail%2Fassociated-types-ICE-when-projecting-out-of-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fcompile-fail%2Fassociated-types-ICE-when-projecting-out-of-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-ICE-when-projecting-out-of-err.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we do not ICE when the self type is `ty::err`, but rather\n+// just propagate the error.\n+\n+#![crate_type = \"lib\"]\n+#![feature(associated_types, default_type_params, lang_items)]\n+#![no_std]\n+\n+#[lang=\"sized\"]\n+pub trait Sized for Sized? {\n+    // Empty.\n+}\n+\n+#[lang = \"add\"]\n+trait Add<RHS=Self> {\n+    type Output;\n+\n+    fn add(self, RHS) -> Self::Output;\n+}\n+\n+fn ice<A>(a: A) {\n+    let r = loop {};\n+    r = r + a; // here the type `r` is not yet inferred, hence `r+a` generates an error.\n+    //~^ ERROR type of this value must be known\n+}"}, {"sha": "bb6060f2543e2a846cead159de024b47647bc76e", "filename": "src/test/compile-fail/bind-by-move-no-guards.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89417130f042c58adc60012e7cddc4ef70b70b9/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs?ref=c89417130f042c58adc60012e7cddc4ef70b70b9", "patch": "@@ -8,13 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::sync::mpsc::channel;\n+\n fn main() {\n     let (tx, rx) = channel();\n     let x = Some(rx);\n     tx.send(false);\n     match x {\n-        Some(z) if z.recv() => { panic!() }, //~ ERROR cannot bind by-move into a pattern guard\n-        Some(z) => { assert!(!z.recv()); },\n+        Some(z) if z.recv().unwrap() => { panic!() },\n+            //~^ ERROR cannot bind by-move into a pattern guard\n+        Some(z) => { assert!(!z.recv().unwrap()); },\n         None => panic!()\n     }\n }"}]}