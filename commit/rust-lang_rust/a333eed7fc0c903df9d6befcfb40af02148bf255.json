{"sha": "a333eed7fc0c903df9d6befcfb40af02148bf255", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzMzNlZWQ3ZmMwYzkwM2RmOWQ2YmVmY2ZiNDBhZjAyMTQ4YmYyNTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-12T21:27:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-12T21:27:04Z"}, "message": "Auto merge of #60026 - Aaron1011:feature/miri-unwind, r=RalfJung,oli-obk\n\nAdd hooks for Miri panic unwinding\n\nThis commits adds in some additional hooks to allow Miri to properly\nhandle panic unwinding. None of this should have any impact on CTFE mode\n\nThis supports https://github.com/rust-lang/miri/pull/693", "tree": {"sha": "f58c8bd9ef3b92b31916f3a4eda588a00e41fb75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f58c8bd9ef3b92b31916f3a4eda588a00e41fb75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a333eed7fc0c903df9d6befcfb40af02148bf255", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a333eed7fc0c903df9d6befcfb40af02148bf255", "html_url": "https://github.com/rust-lang/rust/commit/a333eed7fc0c903df9d6befcfb40af02148bf255", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a333eed7fc0c903df9d6befcfb40af02148bf255/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f03f4a989d1c8346c19dfb417a77c09b34408b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f03f4a989d1c8346c19dfb417a77c09b34408b8", "html_url": "https://github.com/rust-lang/rust/commit/4f03f4a989d1c8346c19dfb417a77c09b34408b8"}, {"sha": "b4545a4ad625c68479120db845280f4c61b39640", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4545a4ad625c68479120db845280f4c61b39640", "html_url": "https://github.com/rust-lang/rust/commit/b4545a4ad625c68479120db845280f4c61b39640"}], "stats": {"total": 417, "additions": 305, "deletions": 112}, "files": [{"sha": "686d0bbefc882a1f0a3a22b8fdb0c6ee73a8df87", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=a333eed7fc0c903df9d6befcfb40af02148bf255", "patch": "@@ -1348,6 +1348,11 @@ extern \"rust-intrinsic\" {\n     /// See documentation of `<*const T>::offset_from` for details.\n     #[cfg(not(bootstrap))]\n     pub fn ptr_offset_from<T>(ptr: *const T, base: *const T) -> isize;\n+\n+    /// Internal hook used by Miri to implement unwinding.\n+    /// Perma-unstable: do not use\n+    #[cfg(not(bootstrap))]\n+    pub fn miri_start_panic(data: *mut (dyn crate::any::Any + crate::marker::Send)) -> !;\n }\n \n // Some functions are defined here because they accidentally got made"}, {"sha": "4c6c728f6f7d4e2c00ba3c6dfd141dab49d777f2", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=a333eed7fc0c903df9d6befcfb40af02148bf255", "patch": "@@ -36,7 +36,10 @@ use core::raw;\n use core::panic::BoxMeUp;\n \n cfg_if::cfg_if! {\n-    if #[cfg(target_os = \"emscripten\")] {\n+    if #[cfg(miri)] {\n+        #[path = \"miri.rs\"]\n+        mod imp;\n+    } else if #[cfg(target_os = \"emscripten\")] {\n         #[path = \"emcc.rs\"]\n         mod imp;\n     } else if #[cfg(target_arch = \"wasm32\")] {"}, {"sha": "254a9383b42236ee616f24e75e040ebaa045969f", "filename": "src/libpanic_unwind/miri.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibpanic_unwind%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibpanic_unwind%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fmiri.rs?ref=a333eed7fc0c903df9d6befcfb40af02148bf255", "patch": "@@ -0,0 +1,23 @@\n+use core::any::Any;\n+use alloc::boxed::Box;\n+\n+pub fn payload() -> *mut u8 {\n+    core::ptr::null_mut()\n+}\n+\n+pub unsafe fn panic(data: Box<dyn Any + Send>) -> ! {\n+    core::intrinsics::miri_start_panic(Box::into_raw(data))\n+}\n+\n+pub unsafe fn cleanup(ptr: *mut u8) -> Box<dyn Any + Send> {\n+    Box::from_raw(ptr)\n+}\n+\n+\n+// This is required by the compiler to exist (e.g., it's a lang item),\n+// but is never used by Miri. Therefore, we just use a stub here\n+#[lang = \"eh_personality\"]\n+#[cfg(not(test))]\n+fn rust_eh_personality() {\n+    unsafe { core::intrinsics::abort() }\n+}"}, {"sha": "14be0e80fb482de802ee5bbb42620848ca4b3232", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=a333eed7fc0c903df9d6befcfb40af02148bf255", "patch": "@@ -528,6 +528,21 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             _ => FnAbi::new(&bx, sig, &extra_args)\n         };\n \n+        // This should never be reachable at runtime:\n+        // We should only emit a call to this intrinsic in #[cfg(miri)] mode,\n+        // which means that we will never actually use the generate object files\n+        // (we will just be interpreting the MIR)\n+        //\n+        // Note that we still need to be able to codegen *something* for this intrisnic:\n+        // Miri currently uses Xargo to build a special libstd. As a side effect,\n+        // we generate normal object files for libstd - while these are never used,\n+        // we still need to be able to build them.\n+        if intrinsic == Some(\"miri_start_panic\") {\n+            bx.abort();\n+            bx.unreachable();\n+            return;\n+        }\n+\n         // Emit a panic or a no-op for `panic_if_uninhabited`.\n         if intrinsic == Some(\"panic_if_uninhabited\") {\n             let ty = instance.unwrap().substs.type_at(0);"}, {"sha": "f280ea7aa4669fb33efbc4dbdf48ae9e0c3023fc", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=a333eed7fc0c903df9d6befcfb40af02148bf255", "patch": "@@ -325,6 +325,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         args: &[OpTy<'tcx>],\n         dest: Option<PlaceTy<'tcx>>,\n         ret: Option<mir::BasicBlock>,\n+        _unwind: Option<mir::BasicBlock> // unwinding is not supported in consts\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n         debug!(\"eval_fn_call: {:?}\", instance);\n         // Only check non-glue functions\n@@ -336,7 +337,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                 // Some functions we support even if they are non-const -- but avoid testing\n                 // that for const fn!  We certainly do *not* want to actually call the fn\n                 // though, so be sure we return here.\n-                return if ecx.hook_fn(instance, args, dest)? {\n+                return if ecx.hook_panic_fn(instance, args, dest)? {\n                     ecx.goto_block(ret)?; // fully evaluated and done\n                     Ok(None)\n                 } else {\n@@ -374,7 +375,9 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n-        dest: PlaceTy<'tcx>,\n+        dest: Option<PlaceTy<'tcx>>,\n+        _ret: Option<mir::BasicBlock>,\n+        _unwind: Option<mir::BasicBlock>\n     ) -> InterpResult<'tcx> {\n         if ecx.emulate_intrinsic(span, instance, args, dest)? {\n             return Ok(());\n@@ -469,12 +472,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     fn stack_push(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n         Ok(())\n     }\n-\n-    /// Called immediately before a stack frame gets popped.\n-    #[inline(always)]\n-    fn stack_pop(_ecx: &mut InterpCx<'mir, 'tcx, Self>, _extra: ()) -> InterpResult<'tcx> {\n-        Ok(())\n-    }\n }\n \n /// Extracts a field of a (variant of a) const."}, {"sha": "92358ad247e1821832cce1b2de12d16464687720", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 123, "deletions": 57, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=a333eed7fc0c903df9d6befcfb40af02148bf255", "patch": "@@ -21,7 +21,7 @@ use rustc_data_structures::fx::FxHashMap;\n \n use super::{\n     Immediate, Operand, MemPlace, MPlaceTy, Place, PlaceTy, ScalarMaybeUndef,\n-    Memory, Machine\n+    Memory, Machine, StackPopInfo\n };\n \n pub struct InterpCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n@@ -60,6 +60,9 @@ pub struct Frame<'mir, 'tcx, Tag=(), Extra=()> {\n     /// The span of the call site.\n     pub span: source_map::Span,\n \n+    /// Extra data for the machine.\n+    pub extra: Extra,\n+\n     ////////////////////////////////////////////////////////////////////////////////\n     // Return place and locals\n     ////////////////////////////////////////////////////////////////////////////////\n@@ -82,21 +85,22 @@ pub struct Frame<'mir, 'tcx, Tag=(), Extra=()> {\n     ////////////////////////////////////////////////////////////////////////////////\n     /// The block that is currently executed (or will be executed after the above call stacks\n     /// return).\n-    pub block: mir::BasicBlock,\n+    /// If this is `None`, we are unwinding and this function doesn't need any clean-up.\n+    /// Just continue the same as with `Resume`.\n+    pub block: Option<mir::BasicBlock>,\n \n     /// The index of the currently evaluated statement.\n     pub stmt: usize,\n-\n-    /// Extra data for the machine.\n-    pub extra: Extra,\n }\n \n #[derive(Clone, Eq, PartialEq, Debug)] // Miri debug-prints these\n pub enum StackPopCleanup {\n     /// Jump to the next block in the caller, or cause UB if None (that's a function\n     /// that may never return). Also store layout of return place so\n     /// we can validate it at that layout.\n-    Goto(Option<mir::BasicBlock>),\n+    /// `ret` stores the block we jump to on a normal return, while 'unwind'\n+    /// stores the block used for cleanup during unwinding\n+    Goto { ret: Option<mir::BasicBlock>, unwind: Option<mir::BasicBlock> },\n     /// Just do nohing: Used by Main and for the box_alloc hook in miri.\n     /// `cleanup` says whether locals are deallocated. Static computation\n     /// wants them leaked to intern what they need (and just throw away\n@@ -489,7 +493,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let extra = M::stack_push(self)?;\n         self.stack.push(Frame {\n             body,\n-            block: mir::START_BLOCK,\n+            block: Some(mir::START_BLOCK),\n             return_to_block,\n             return_place,\n             // empty local array, we fill it in below, after we are inside the stack frame and\n@@ -547,60 +551,118 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n     }\n \n-    pub(super) fn pop_stack_frame(&mut self) -> InterpResult<'tcx> {\n-        info!(\"LEAVING({}) {}\", self.cur_frame(), self.frame().instance);\n+    /// Pops the current frame from the stack, deallocating the\n+    /// memory for allocated locals.\n+    ///\n+    /// If `unwinding` is `false`, then we are performing a normal return\n+    /// from a function. In this case, we jump back into the frame of the caller,\n+    /// and continue execution as normal.\n+    ///\n+    /// If `unwinding` is `true`, then we are in the middle of a panic,\n+    /// and need to unwind this frame. In this case, we jump to the\n+    /// `cleanup` block for the function, which is responsible for running\n+    /// `Drop` impls for any locals that have been initialized at this point.\n+    /// The cleanup block ends with a special `Resume` terminator, which will\n+    /// cause us to continue unwinding.\n+    pub(super) fn pop_stack_frame(\n+        &mut self,\n+        unwinding: bool\n+    ) -> InterpResult<'tcx> {\n+        info!(\"LEAVING({}) {} (unwinding = {})\",\n+            self.cur_frame(), self.frame().instance, unwinding);\n+\n+        // Sanity check `unwinding`.\n+        assert_eq!(\n+            unwinding,\n+            match self.frame().block {\n+                None => true,\n+                Some(block) => self.body().basic_blocks()[block].is_cleanup\n+            }\n+        );\n+\n         ::log_settings::settings().indentation -= 1;\n         let frame = self.stack.pop().expect(\n             \"tried to pop a stack frame, but there were none\",\n         );\n-        M::stack_pop(self, frame.extra)?;\n-        // Abort early if we do not want to clean up: We also avoid validation in that case,\n+        let stack_pop_info = M::stack_pop(self, frame.extra, unwinding)?;\n+        if let (false, StackPopInfo::StopUnwinding) = (unwinding, stack_pop_info) {\n+            bug!(\"Attempted to stop unwinding while there is no unwinding!\");\n+        }\n+\n+        // Now where do we jump next?\n+\n+        // Determine if we leave this function normally or via unwinding.\n+        let cur_unwinding = if let StackPopInfo::StopUnwinding = stack_pop_info {\n+            false\n+        } else {\n+            unwinding\n+        };\n+\n+        // Usually we want to clean up (deallocate locals), but in a few rare cases we don't.\n+        // In that case, we return early. We also avoid validation in that case,\n         // because this is CTFE and the final value will be thoroughly validated anyway.\n-        match frame.return_to_block {\n-            StackPopCleanup::Goto(_) => {},\n-            StackPopCleanup::None { cleanup } => {\n-                if !cleanup {\n-                    assert!(self.stack.is_empty(), \"only the topmost frame should ever be leaked\");\n-                    // Leak the locals, skip validation.\n-                    return Ok(());\n-                }\n-            }\n+        let (cleanup, next_block) = match frame.return_to_block {\n+            StackPopCleanup::Goto { ret, unwind } => {\n+                (true, Some(if cur_unwinding { unwind } else { ret }))\n+            },\n+            StackPopCleanup::None { cleanup, .. } => (cleanup, None)\n+        };\n+\n+        if !cleanup {\n+            assert!(self.stack.is_empty(), \"only the topmost frame should ever be leaked\");\n+            assert!(next_block.is_none(), \"tried to skip cleanup when we have a next block!\");\n+            // Leak the locals, skip validation.\n+            return Ok(());\n         }\n-        // Deallocate all locals that are backed by an allocation.\n+\n+        // Cleanup: deallocate all locals that are backed by an allocation.\n         for local in frame.locals {\n             self.deallocate_local(local.value)?;\n         }\n-        // Validate the return value. Do this after deallocating so that we catch dangling\n-        // references.\n-        if let Some(return_place) = frame.return_place {\n-            if M::enforce_validity(self) {\n-                // Data got changed, better make sure it matches the type!\n-                // It is still possible that the return place held invalid data while\n-                // the function is running, but that's okay because nobody could have\n-                // accessed that same data from the \"outside\" to observe any broken\n-                // invariant -- that is, unless a function somehow has a ptr to\n-                // its return place... but the way MIR is currently generated, the\n-                // return place is always a local and then this cannot happen.\n-                self.validate_operand(\n-                    self.place_to_op(return_place)?,\n-                    vec![],\n-                    None,\n-                )?;\n-            }\n+\n+\n+        trace!(\"StackPopCleanup: {:?} StackPopInfo: {:?} cur_unwinding = {:?}\",\n+               frame.return_to_block, stack_pop_info, cur_unwinding);\n+        if cur_unwinding {\n+            // Follow the unwind edge.\n+            let unwind = next_block.expect(\"Encounted StackPopCleanup::None when unwinding!\");\n+            let next_frame = self.frame_mut();\n+            // If `unwind` is `None`, we'll leave that function immediately again.\n+            next_frame.block = unwind;\n+            next_frame.stmt = 0;\n         } else {\n-            // Uh, that shouldn't happen... the function did not intend to return\n-            throw_ub!(Unreachable)\n-        }\n-        // Jump to new block -- *after* validation so that the spans make more sense.\n-        match frame.return_to_block {\n-            StackPopCleanup::Goto(block) => {\n-                self.goto_block(block)?;\n+            // Follow the normal return edge.\n+            // Validate the return value. Do this after deallocating so that we catch dangling\n+            // references.\n+            if let Some(return_place) = frame.return_place {\n+                if M::enforce_validity(self) {\n+                    // Data got changed, better make sure it matches the type!\n+                    // It is still possible that the return place held invalid data while\n+                    // the function is running, but that's okay because nobody could have\n+                    // accessed that same data from the \"outside\" to observe any broken\n+                    // invariant -- that is, unless a function somehow has a ptr to\n+                    // its return place... but the way MIR is currently generated, the\n+                    // return place is always a local and then this cannot happen.\n+                    self.validate_operand(\n+                        self.place_to_op(return_place)?,\n+                        vec![],\n+                        None,\n+                    )?;\n+                }\n+            } else {\n+                // Uh, that shouldn't happen... the function did not intend to return\n+                throw_ub!(Unreachable);\n+            }\n+\n+            // Jump to new block -- *after* validation so that the spans make more sense.\n+            if let Some(ret) = next_block {\n+                self.goto_block(ret)?;\n             }\n-            StackPopCleanup::None { .. } => {}\n         }\n \n         if self.stack.len() > 0 {\n-            info!(\"CONTINUING({}) {}\", self.cur_frame(), self.frame().instance);\n+            info!(\"CONTINUING({}) {} (unwinding = {})\",\n+                self.cur_frame(), self.frame().instance, cur_unwinding);\n         }\n \n         Ok(())\n@@ -745,16 +807,20 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             } else {\n                 last_span = Some(span);\n             }\n-            let block = &body.basic_blocks()[block];\n-            let source_info = if stmt < block.statements.len() {\n-                block.statements[stmt].source_info\n-            } else {\n-                block.terminator().source_info\n-            };\n-            let lint_root = match body.source_scope_local_data {\n-                mir::ClearCrossCrate::Set(ref ivs) => Some(ivs[source_info.scope].lint_root),\n-                mir::ClearCrossCrate::Clear => None,\n-            };\n+\n+            let lint_root = block.and_then(|block| {\n+                let block = &body.basic_blocks()[block];\n+                let source_info = if stmt < block.statements.len() {\n+                    block.statements[stmt].source_info\n+                } else {\n+                    block.terminator().source_info\n+                };\n+                match body.source_scope_local_data {\n+                    mir::ClearCrossCrate::Set(ref ivs) => Some(ivs[source_info.scope].lint_root),\n+                    mir::ClearCrossCrate::Clear => None,\n+                }\n+            });\n+\n             frames.push(FrameInfo { call_site: span, instance, lint_root });\n         }\n         trace!(\"generate stacktrace: {:#?}, {:?}\", frames, explicit_span);"}, {"sha": "66b6d4ac12c402c38381c942a3d39df43ef52f30", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=a333eed7fc0c903df9d6befcfb40af02148bf255", "patch": "@@ -91,11 +91,17 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, M::PointerTag>],\n-        dest: PlaceTy<'tcx, M::PointerTag>,\n+        dest: Option<PlaceTy<'tcx, M::PointerTag>>,\n     ) -> InterpResult<'tcx, bool> {\n         let substs = instance.substs;\n \n+        // We currently do not handle any diverging intrinsics.\n+        let dest = match dest {\n+            Some(dest) => dest,\n+            None => return Ok(false)\n+        };\n         let intrinsic_name = &*self.tcx.item_name(instance.def_id()).as_str();\n+\n         match intrinsic_name {\n             \"caller_location\" => {\n                 let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n@@ -347,9 +353,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(true)\n     }\n \n-    /// \"Intercept\" a function call because we have something special to do for it.\n+    /// \"Intercept\" a function call to a panic-related function\n+    /// because we have something special to do for it.\n     /// Returns `true` if an intercept happened.\n-    pub fn hook_fn(\n+    pub fn hook_panic_fn(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, M::PointerTag>],"}, {"sha": "0ddd0962ba54423b0d5c319ef424ca8c83baee0a", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=a333eed7fc0c903df9d6befcfb40af02148bf255", "patch": "@@ -16,6 +16,21 @@ use super::{\n     Frame, Operand,\n };\n \n+/// Data returned by Machine::stack_pop,\n+/// to provide further control over the popping of the stack frame\n+#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+pub enum StackPopInfo {\n+    /// Indicates that no special handling should be\n+    /// done - we'll either return normally or unwind\n+    /// based on the terminator for the function\n+    /// we're leaving.\n+    Normal,\n+\n+    /// Indicates that we should stop unwinding,\n+    /// as we've reached a catch frame\n+    StopUnwinding\n+}\n+\n /// Whether this kind of memory is allowed to leak\n pub trait MayLeak: Copy {\n     fn may_leak(self) -> bool;\n@@ -137,6 +152,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         dest: Option<PlaceTy<'tcx, Self::PointerTag>>,\n         ret: Option<mir::BasicBlock>,\n+        unwind: Option<mir::BasicBlock>\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>>;\n \n     /// Execute `fn_val`.  it is the hook's responsibility to advance the instruction\n@@ -156,7 +172,9 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n-        dest: PlaceTy<'tcx, Self::PointerTag>,\n+        dest: Option<PlaceTy<'tcx, Self::PointerTag>>,\n+        ret: Option<mir::BasicBlock>,\n+        unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx>;\n \n     /// Called for read access to a foreign static item.\n@@ -251,9 +269,13 @@ pub trait Machine<'mir, 'tcx>: Sized {\n \n     /// Called immediately after a stack frame gets popped\n     fn stack_pop(\n-        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        extra: Self::FrameExtra,\n-    ) -> InterpResult<'tcx>;\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _extra: Self::FrameExtra,\n+        _unwinding: bool\n+    ) -> InterpResult<'tcx, StackPopInfo> {\n+        // By default, we do not support unwinding from panics\n+        Ok(StackPopInfo::Normal)\n+    }\n \n     fn int_to_ptr(\n         _mem: &Memory<'mir, 'tcx, Self>,"}, {"sha": "520bd434faa253c720621ec8de50f92e55b884de", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=a333eed7fc0c903df9d6befcfb40af02148bf255", "patch": "@@ -26,7 +26,7 @@ pub use self::place::{Place, PlaceTy, MemPlace, MPlaceTy};\n \n pub use self::memory::{Memory, MemoryKind, AllocCheck, FnVal};\n \n-pub use self::machine::{Machine, AllocMap, MayLeak};\n+pub use self::machine::{Machine, AllocMap, MayLeak, StackPopInfo};\n \n pub use self::operand::{ScalarMaybeUndef, Immediate, ImmTy, Operand, OpTy};\n "}, {"sha": "7f3ea0283cda38d2614458a04ee83498fd922573", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=a333eed7fc0c903df9d6befcfb40af02148bf255", "patch": "@@ -315,7 +315,7 @@ impl<'a, Ctx> Snapshot<'a, Ctx> for &'a Allocation\n }\n \n impl_stable_hash_for!(enum crate::interpret::eval_context::StackPopCleanup {\n-    Goto(block),\n+    Goto { ret, unwind },\n     None { cleanup },\n });\n \n@@ -326,7 +326,7 @@ struct FrameSnapshot<'a, 'tcx> {\n     return_to_block: &'a StackPopCleanup,\n     return_place: Option<Place<(), AllocIdSnapshot<'a>>>,\n     locals: IndexVec<mir::Local, LocalValue<(), AllocIdSnapshot<'a>>>,\n-    block: &'a mir::BasicBlock,\n+    block: Option<mir::BasicBlock>,\n     stmt: usize,\n }\n \n@@ -364,7 +364,7 @@ impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n             instance: *instance,\n             span: *span,\n             return_to_block,\n-            block,\n+            block: *block,\n             stmt: *stmt,\n             return_place: return_place.map(|r| r.snapshot(ctx)),\n             locals: locals.iter().map(|local| local.snapshot(ctx)).collect(),"}, {"sha": "d7493338a5352f083a9db4a3733366d44baf7715", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=a333eed7fc0c903df9d6befcfb40af02148bf255", "patch": "@@ -49,7 +49,16 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(false);\n         }\n \n-        let block = self.frame().block;\n+        let block = match self.frame().block {\n+            Some(block) => block,\n+            None => {\n+                // We are unwinding and this fn has no cleanup code.\n+                // Just go on unwinding.\n+                trace!(\"unwinding: skipping frame\");\n+                self.pop_stack_frame(/* unwinding */ true)?;\n+                return Ok(true)\n+            }\n+        };\n         let stmt_id = self.frame().stmt;\n         let body = self.body();\n         let basic_block = &body.basic_blocks()[block];\n@@ -290,6 +299,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         let old_stack = self.cur_frame();\n         let old_bb = self.frame().block;\n+\n         self.eval_terminator(terminator)?;\n         if !self.stack.is_empty() {\n             // This should change *something*"}, {"sha": "4f9e404b2c635cdb66802c47e342139d54964151", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 40, "deletions": 26, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=a333eed7fc0c903df9d6befcfb40af02148bf255", "patch": "@@ -15,7 +15,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     #[inline]\n     pub fn goto_block(&mut self, target: Option<mir::BasicBlock>) -> InterpResult<'tcx> {\n         if let Some(target) = target {\n-            self.frame_mut().block = target;\n+            self.frame_mut().block = Some(target);\n             self.frame_mut().stmt = 0;\n             Ok(())\n         } else {\n@@ -31,7 +31,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match terminator.kind {\n             Return => {\n                 self.frame().return_place.map(|r| self.dump_place(*r));\n-                self.pop_stack_frame()?\n+                self.pop_stack_frame(/* unwinding */ false)?\n             }\n \n             Goto { target } => self.goto_block(Some(target))?,\n@@ -67,6 +67,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 ref func,\n                 ref args,\n                 ref destination,\n+                ref cleanup,\n                 ..\n             } => {\n                 let (dest, ret) = match *destination {\n@@ -98,13 +99,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     &args[..],\n                     dest,\n                     ret,\n+                    *cleanup\n                 )?;\n             }\n \n             Drop {\n                 ref location,\n                 target,\n-                ..\n+                unwind,\n             } => {\n                 // FIXME(CTFE): forbid drop in const eval\n                 let place = self.eval_place(location)?;\n@@ -117,6 +119,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     instance,\n                     terminator.source_info.span,\n                     target,\n+                    unwind\n                 )?;\n             }\n \n@@ -160,10 +163,21 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n             }\n \n+\n+            // When we encounter Resume, we've finished unwinding\n+            // cleanup for the current stack frame. We pop it in order\n+            // to continue unwinding the next frame\n+            Resume => {\n+                trace!(\"unwinding: resuming from cleanup\");\n+                // By definition, a Resume terminator means\n+                // that we're unwinding\n+                self.pop_stack_frame(/* unwinding */ true)?;\n+                return Ok(())\n+            },\n+\n             Yield { .. } |\n             GeneratorDrop |\n             DropAndReplace { .. } |\n-            Resume |\n             Abort => unimplemented!(\"{:#?}\", terminator.kind),\n             FalseEdges { .. } => bug!(\"should have been eliminated by\\\n                                       `simplify_branches` mir pass\"),\n@@ -237,6 +251,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         args: &[OpTy<'tcx, M::PointerTag>],\n         dest: Option<PlaceTy<'tcx, M::PointerTag>>,\n         ret: Option<mir::BasicBlock>,\n+        unwind: Option<mir::BasicBlock>\n     ) -> InterpResult<'tcx> {\n         trace!(\"eval_fn_call: {:#?}\", fn_val);\n \n@@ -249,17 +264,23 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         match instance.def {\n             ty::InstanceDef::Intrinsic(..) => {\n-                // The intrinsic itself cannot diverge, so if we got here without a return\n-                // place... (can happen e.g., for transmute returning `!`)\n-                let dest = match dest {\n-                    Some(dest) => dest,\n-                    None => throw_ub!(Unreachable)\n-                };\n-                M::call_intrinsic(self, span, instance, args, dest)?;\n+                let old_stack = self.cur_frame();\n+                let old_bb = self.frame().block;\n+                M::call_intrinsic(self, span, instance, args, dest, ret, unwind)?;\n                 // No stack frame gets pushed, the main loop will just act as if the\n                 // call completed.\n-                self.goto_block(ret)?;\n-                self.dump_place(*dest);\n+                if ret.is_some() {\n+                    self.goto_block(ret)?;\n+                } else {\n+                    // If this intrinsic call doesn't have a ret block,\n+                    // then the intrinsic implementation should have\n+                    // changed the stack frame (otherwise, we'll end\n+                    // up trying to execute this intrinsic call again)\n+                    debug_assert!(self.cur_frame() != old_stack || self.frame().block != old_bb);\n+                }\n+                if let Some(dest) = dest {\n+                    self.dump_place(*dest)\n+                }\n                 Ok(())\n             }\n             ty::InstanceDef::VtableShim(..) |\n@@ -294,7 +315,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n \n                 // We need MIR for this fn\n-                let body = match M::find_fn(self, instance, args, dest, ret)? {\n+                let body = match M::find_fn(self, instance, args, dest, ret, unwind)? {\n                     Some(body) => body,\n                     None => return Ok(()),\n                 };\n@@ -304,7 +325,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     span,\n                     body,\n                     dest,\n-                    StackPopCleanup::Goto(ret),\n+                    StackPopCleanup::Goto { ret, unwind }\n                 )?;\n \n                 // We want to pop this frame again in case there was an error, to put\n@@ -422,7 +443,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // cannot use the shim here, because that will only result in infinite recursion\n             ty::InstanceDef::Virtual(_, idx) => {\n                 let mut args = args.to_vec();\n-                let ptr_size = self.pointer_size();\n                 // We have to implement all \"object safe receivers\".  Currently we\n                 // support built-in pointers (&, &mut, Box) as well as unsized-self.  We do\n                 // not yet support custom self types.\n@@ -439,15 +459,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 // Find and consult vtable\n                 let vtable = receiver_place.vtable();\n-                let vtable_slot = vtable.ptr_offset(ptr_size * (idx as u64 + 3), self)?;\n-                let vtable_slot = self.memory.check_ptr_access(\n-                    vtable_slot,\n-                    ptr_size,\n-                    self.tcx.data_layout.pointer_align.abi,\n-                )?.expect(\"cannot be a ZST\");\n-                let fn_ptr = self.memory.get_raw(vtable_slot.alloc_id)?\n-                    .read_ptr_sized(self, vtable_slot)?.not_undef()?;\n-                let drop_fn = self.memory.get_fn(fn_ptr)?;\n+                let drop_fn = self.get_vtable_slot(vtable, idx)?;\n \n                 // `*mut receiver_place.layout.ty` is almost the layout that we\n                 // want for args[0]: We have to project to field 0 because we want\n@@ -462,7 +474,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 });\n                 trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n-                self.eval_fn_call(drop_fn, span, caller_abi, &args, dest, ret)\n+                self.eval_fn_call(drop_fn, span, caller_abi, &args, dest, ret, unwind)\n             }\n         }\n     }\n@@ -473,6 +485,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         instance: ty::Instance<'tcx>,\n         span: Span,\n         target: mir::BasicBlock,\n+        unwind: Option<mir::BasicBlock>\n     ) -> InterpResult<'tcx> {\n         trace!(\"drop_in_place: {:?},\\n  {:?}, {:?}\", *place, place.layout.ty, instance);\n         // We take the address of the object.  This may well be unaligned, which is fine\n@@ -503,6 +516,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             &[arg.into()],\n             Some(dest.into()),\n             Some(target),\n+            unwind\n         )\n     }\n }"}, {"sha": "e3b3df2674f417c0b23ed49f2d16c422b0a93e5c", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=a333eed7fc0c903df9d6befcfb40af02148bf255", "patch": "@@ -97,6 +97,27 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(vtable)\n     }\n \n+    /// Resolve the function at the specified slot in the provided\n+    /// vtable. An index of '0' corresponds to the first method\n+    /// declared in the trait of the provided vtable\n+    pub fn get_vtable_slot(\n+        &self,\n+        vtable: Scalar<M::PointerTag>,\n+        idx: usize\n+    ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n+        let ptr_size = self.pointer_size();\n+        // Skip over the 'drop_ptr', 'size', and 'align' fields\n+        let vtable_slot = vtable.ptr_offset(ptr_size * (idx as u64 + 3), self)?;\n+        let vtable_slot = self.memory.check_ptr_access(\n+            vtable_slot,\n+            ptr_size,\n+            self.tcx.data_layout.pointer_align.abi,\n+        )?.expect(\"cannot be a ZST\");\n+        let fn_ptr = self.memory.get_raw(vtable_slot.alloc_id)?\n+            .read_ptr_sized(self, vtable_slot)?.not_undef()?;\n+        Ok(self.memory.get_fn(fn_ptr)?)\n+    }\n+\n     /// Returns the drop fn instance as well as the actual dynamic type\n     pub fn read_drop_type_from_vtable(\n         &self,"}, {"sha": "2ede43e2111ed164a5f39422f3eda3f9e7bc3f72", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=a333eed7fc0c903df9d6befcfb40af02148bf255", "patch": "@@ -143,6 +143,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         _args: &[OpTy<'tcx>],\n         _dest: Option<PlaceTy<'tcx>>,\n         _ret: Option<BasicBlock>,\n+        _unwind: Option<BasicBlock>,\n     ) -> InterpResult<'tcx, Option<&'mir Body<'tcx>>> {\n         Ok(None)\n     }\n@@ -162,7 +163,9 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         _span: Span,\n         _instance: ty::Instance<'tcx>,\n         _args: &[OpTy<'tcx>],\n-        _dest: PlaceTy<'tcx>,\n+        _dest: Option<PlaceTy<'tcx>>,\n+        _ret: Option<BasicBlock>,\n+        _unwind: Option<BasicBlock>\n     ) -> InterpResult<'tcx> {\n         throw_unsup_format!(\"calling intrinsics isn't supported in ConstProp\");\n     }\n@@ -251,12 +254,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n     fn stack_push(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n         Ok(())\n     }\n-\n-    /// Called immediately before a stack frame gets popped.\n-    #[inline(always)]\n-    fn stack_pop(_ecx: &mut InterpCx<'mir, 'tcx, Self>, _extra: ()) -> InterpResult<'tcx> {\n-        Ok(())\n-    }\n }\n \n type Const<'tcx> = OpTy<'tcx>;"}, {"sha": "84a15c6e4ebe268a47246017a3b1ba3a69cabcdb", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=a333eed7fc0c903df9d6befcfb40af02148bf255", "patch": "@@ -384,6 +384,12 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n                 (1, vec![ tcx.mk_mut_ptr(param(0)), param(0) ], tcx.mk_unit())\n             }\n \n+            \"miri_start_panic\" => {\n+                // FIXME - the relevant types aren't lang items,\n+                // so it's not trivial to check this\n+                return;\n+            }\n+\n             ref other => {\n                 struct_span_err!(tcx.sess, it.span, E0093,\n                                  \"unrecognized intrinsic function: `{}`\","}, {"sha": "d7296b43fbe8aef5fbe639447984bf074709749c", "filename": "src/libstd/sys_common/backtrace.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a333eed7fc0c903df9d6befcfb40af02148bf255/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fbacktrace.rs?ref=a333eed7fc0c903df9d6befcfb40af02148bf255", "patch": "@@ -66,7 +66,14 @@ unsafe fn _print(w: &mut dyn Write, format: PrintFmt) -> io::Result<()> {\n }\n \n unsafe fn _print_fmt(fmt: &mut fmt::Formatter<'_>, print_fmt: PrintFmt) -> fmt::Result {\n-    let cwd = env::current_dir().ok();\n+    // Always 'fail' to get the cwd when running under Miri -\n+    // this allows Miri to display backtraces in isolation mode\n+    let cwd = if !cfg!(miri) {\n+        env::current_dir().ok()\n+    } else {\n+        None\n+    };\n+\n     let mut print_path = move |fmt: &mut fmt::Formatter<'_>, bows: BytesOrWideString<'_>| {\n         output_filename(fmt, bows, print_fmt, cwd.as_ref())\n     };"}]}