{"sha": "0c7c93b8e83544abc7eef5abd76526e5c49882f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjN2M5M2I4ZTgzNTQ0YWJjN2VlZjVhYmQ3NjUyNmU1YzQ5ODgyZjU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-04T17:54:35Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-04T18:13:12Z"}, "message": "std: Improve non-task-based usage\n\nA few notable improvements were implemented to cut down on the number of aborts\ntriggered by the standard library when a local task is not found.\n\n* Primarily, the unwinding functionality was restructured to support an unsafe\n  top-level function, `try`. This function invokes a closure, capturing any\n  failure which occurs inside of it. The purpose of this function is to be as\n  lightweight of a \"try block\" as possible for rust, intended for use when the\n  runtime is difficult to set up.\n\n  This function is *not* meant to be used by normal rust code, nor should it be\n  consider for use with normal rust code.\n\n* When invoking spawn(), a `fail!()` is triggered rather than an abort.\n\n* When invoking LocalIo::borrow(), which is transitively called by all I/O\n  constructors, None is returned rather than aborting to indicate that there is\n  no local I/O implementation.\n\n* Invoking get() on a TLD key will return None if no task is available\n\n* Invoking replace() on a TLD key will fail if no task is available.\n\nA test case was also added showing the variety of things that you can do without\na runtime or task set up now. In general, this is just a refactoring to abort\nless quickly in the standard library when a local task is not found.", "tree": {"sha": "79768d11e65366724ca547ddd5c0bb8598303d4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79768d11e65366724ca547ddd5c0bb8598303d4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c7c93b8e83544abc7eef5abd76526e5c49882f5", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c7c93b8e83544abc7eef5abd76526e5c49882f5", "html_url": "https://github.com/rust-lang/rust/commit/0c7c93b8e83544abc7eef5abd76526e5c49882f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c7c93b8e83544abc7eef5abd76526e5c49882f5/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d130acc0d0e83bd0b4b94cda9d39dcbb67312526", "url": "https://api.github.com/repos/rust-lang/rust/commits/d130acc0d0e83bd0b4b94cda9d39dcbb67312526", "html_url": "https://github.com/rust-lang/rust/commit/d130acc0d0e83bd0b4b94cda9d39dcbb67312526"}], "stats": {"total": 433, "additions": 277, "deletions": 156}, "files": [{"sha": "930d1df02f1269a146ce7e19e7aaa034cef86083", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0c7c93b8e83544abc7eef5abd76526e5c49882f5/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7c93b8e83544abc7eef5abd76526e5c49882f5/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=0c7c93b8e83544abc7eef5abd76526e5c49882f5", "patch": "@@ -96,22 +96,24 @@ pub type Map = Vec<Option<(*u8, TLSValue, uint)>>;\n type TLSValue = Box<LocalData:Send>;\n \n // Gets the map from the runtime. Lazily initialises if not done so already.\n-unsafe fn get_local_map() -> &mut Map {\n+unsafe fn get_local_map() -> Option<&mut Map> {\n     use rt::local::Local;\n \n+    if !Local::exists(None::<Task>) { return None }\n+\n     let task: *mut Task = Local::unsafe_borrow();\n     match &mut (*task).storage {\n         // If the at_exit function is already set, then we just need to take\n         // a loan out on the TLS map stored inside\n         &LocalStorage(Some(ref mut map_ptr)) => {\n-            return map_ptr;\n+            return Some(map_ptr);\n         }\n         // If this is the first time we've accessed TLS, perform similar\n         // actions to the oldsched way of doing things.\n         &LocalStorage(ref mut slot) => {\n             *slot = Some(vec!());\n             match *slot {\n-                Some(ref mut map_ptr) => { return map_ptr }\n+                Some(ref mut map_ptr) => { return Some(map_ptr) }\n                 None => unreachable!(),\n             }\n         }\n@@ -156,7 +158,10 @@ impl<T: 'static> KeyValue<T> {\n     /// assert_eq!(foo.replace(None), Some(4));\n     /// ```\n     pub fn replace(&'static self, data: Option<T>) -> Option<T> {\n-        let map = unsafe { get_local_map() };\n+        let map = match unsafe { get_local_map() } {\n+            Some(map) => map,\n+            None => fail!(\"must have a local task to insert into TLD\"),\n+        };\n         let keyval = key_to_key_value(self);\n \n         // When the task-local map is destroyed, all the data needs to be\n@@ -223,7 +228,10 @@ impl<T: 'static> KeyValue<T> {\n     /// assert_eq!(*key.get().unwrap(), 3);\n     /// ```\n     pub fn get(&'static self) -> Option<Ref<T>> {\n-        let map = unsafe { get_local_map() };\n+        let map = match unsafe { get_local_map() } {\n+            Some(map) => map,\n+            None => return None,\n+        };\n \n         self.find(map).map(|(pos, data, loan)| {\n             *loan += 1;\n@@ -260,7 +268,7 @@ impl<T: 'static> Deref<T> for Ref<T> {\n #[unsafe_destructor]\n impl<T: 'static> Drop for Ref<T> {\n     fn drop(&mut self) {\n-        let map = unsafe { get_local_map() };\n+        let map = unsafe { get_local_map().unwrap() };\n \n         let (_, _, ref mut loan) = *map.get_mut(self._index).get_mut_ref();\n         *loan -= 1;"}, {"sha": "06db465f7eeedf49f8f3b7db8cd9d6000a237fe0", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c7c93b8e83544abc7eef5abd76526e5c49882f5/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7c93b8e83544abc7eef5abd76526e5c49882f5/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=0c7c93b8e83544abc7eef5abd76526e5c49882f5", "patch": "@@ -171,7 +171,10 @@ impl<'a> LocalIo<'a> {\n         //\n         // In order to get around this, we just transmute a copy out of the task\n         // in order to have what is likely a static lifetime (bad).\n-        let mut t: Box<Task> = Local::take();\n+        let mut t: Box<Task> = match Local::try_take() {\n+            Some(t) => t,\n+            None => return None,\n+        };\n         let ret = t.local_io().map(|t| {\n             unsafe { mem::transmute_copy(&t) }\n         });"}, {"sha": "c455648992ed85bf84f32c7fb907a870fcf36ff0", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 196, "deletions": 148, "changes": 344, "blob_url": "https://github.com/rust-lang/rust/blob/0c7c93b8e83544abc7eef5abd76526e5c49882f5/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7c93b8e83544abc7eef5abd76526e5c49882f5/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=0c7c93b8e83544abc7eef5abd76526e5c49882f5", "patch": "@@ -66,7 +66,7 @@ use option::{Some, None, Option};\n use owned::Box;\n use prelude::drop;\n use ptr::RawPtr;\n-use result::{Err, Ok};\n+use result::{Err, Ok, Result};\n use rt::backtrace;\n use rt::local::Local;\n use rt::task::Task;\n@@ -81,6 +81,11 @@ pub struct Unwinder {\n     cause: Option<Box<Any:Send>>\n }\n \n+struct Exception {\n+    uwe: uw::_Unwind_Exception,\n+    cause: Option<Box<Any:Send>>,\n+}\n+\n impl Unwinder {\n     pub fn new() -> Unwinder {\n         Unwinder {\n@@ -94,78 +99,100 @@ impl Unwinder {\n     }\n \n     pub fn try(&mut self, f: ||) {\n-        use raw::Closure;\n-        use libc::{c_void};\n-\n-        unsafe {\n-            let closure: Closure = mem::transmute(f);\n-            let ep = rust_try(try_fn, closure.code as *c_void,\n-                              closure.env as *c_void);\n-            if !ep.is_null() {\n-                rtdebug!(\"caught {}\", (*ep).exception_class);\n-                uw::_Unwind_DeleteException(ep);\n-            }\n-        }\n+        self.cause = unsafe { try(f) }.err();\n+    }\n \n-        extern fn try_fn(code: *c_void, env: *c_void) {\n-            unsafe {\n-                let closure: || = mem::transmute(Closure {\n-                    code: code as *(),\n-                    env: env as *(),\n-                });\n-                closure();\n-            }\n+    pub fn result(&mut self) -> TaskResult {\n+        if self.unwinding {\n+            Err(self.cause.take().unwrap())\n+        } else {\n+            Ok(())\n         }\n+    }\n+}\n \n-        extern {\n-            // Rust's try-catch\n-            // When f(...) returns normally, the return value is null.\n-            // When f(...) throws, the return value is a pointer to the caught\n-            // exception object.\n-            fn rust_try(f: extern \"C\" fn(*c_void, *c_void),\n-                        code: *c_void,\n-                        data: *c_void) -> *uw::_Unwind_Exception;\n+/// Invoke a closure, capturing the cause of failure if one occurs.\n+///\n+/// This function will return `None` if the closure did not fail, and will\n+/// return `Some(cause)` if the closure fails. The `cause` returned is the\n+/// object with which failure was originally invoked.\n+///\n+/// This function also is unsafe for a variety of reasons:\n+///\n+/// * This is not safe to call in a nested fashion. The unwinding\n+///   interface for Rust is designed to have at most one try/catch block per\n+///   task, not multiple. No runtime checking is currently performed to uphold\n+///   this invariant, so this function is not safe. A nested try/catch block\n+///   may result in corruption of the outer try/catch block's state, especially\n+///   if this is used within a task itself.\n+///\n+/// * It is not sound to trigger unwinding while already unwinding. Rust tasks\n+///   have runtime checks in place to ensure this invariant, but it is not\n+///   guaranteed that a rust task is in place when invoking this function.\n+///   Unwinding twice can lead to resource leaks where some destructors are not\n+///   run.\n+pub unsafe fn try(f: ||) -> Result<(), Box<Any:Send>> {\n+    use raw::Closure;\n+    use libc::{c_void};\n+\n+    let closure: Closure = mem::transmute(f);\n+    let ep = rust_try(try_fn, closure.code as *c_void,\n+                      closure.env as *c_void);\n+    return if ep.is_null() {\n+        Ok(())\n+    } else {\n+        let my_ep = ep as *mut Exception;\n+        rtdebug!(\"caught {}\", (*my_ep).uwe.exception_class);\n+        let cause = (*my_ep).cause.take();\n+        uw::_Unwind_DeleteException(ep);\n+        Err(cause.unwrap())\n+    };\n+\n+    extern fn try_fn(code: *c_void, env: *c_void) {\n+        unsafe {\n+            let closure: || = mem::transmute(Closure {\n+                code: code as *(),\n+                env: env as *(),\n+            });\n+            closure();\n         }\n     }\n \n-    pub fn begin_unwind(&mut self, cause: Box<Any:Send>) -> ! {\n-        rtdebug!(\"begin_unwind()\");\n-\n-        self.unwinding = true;\n-        self.cause = Some(cause);\n-\n-        rust_fail();\n+    extern {\n+        // Rust's try-catch\n+        // When f(...) returns normally, the return value is null.\n+        // When f(...) throws, the return value is a pointer to the caught\n+        // exception object.\n+        fn rust_try(f: extern \"C\" fn(*c_void, *c_void),\n+                    code: *c_void,\n+                    data: *c_void) -> *uw::_Unwind_Exception;\n+    }\n+}\n \n-        // An uninlined, unmangled function upon which to slap yer breakpoints\n-        #[inline(never)]\n-        #[no_mangle]\n-        fn rust_fail() -> ! {\n-            unsafe {\n-                let exception = box uw::_Unwind_Exception {\n-                    exception_class: rust_exception_class(),\n-                    exception_cleanup: exception_cleanup,\n-                    private: [0, ..uw::unwinder_private_data_size],\n-                };\n-                let error = uw::_Unwind_RaiseException(mem::transmute(exception));\n-                rtabort!(\"Could not unwind stack, error = {}\", error as int)\n-            }\n+// An uninlined, unmangled function upon which to slap yer breakpoints\n+#[inline(never)]\n+#[no_mangle]\n+fn rust_fail(cause: Box<Any:Send>) -> ! {\n+    rtdebug!(\"begin_unwind()\");\n \n-            extern \"C\" fn exception_cleanup(_unwind_code: uw::_Unwind_Reason_Code,\n-                                            exception: *uw::_Unwind_Exception) {\n-                rtdebug!(\"exception_cleanup()\");\n-                unsafe {\n-                    let _: Box<uw::_Unwind_Exception> =\n-                        mem::transmute(exception);\n-                }\n-            }\n-        }\n+    unsafe {\n+        let exception = box Exception {\n+            uwe: uw::_Unwind_Exception {\n+                exception_class: rust_exception_class(),\n+                exception_cleanup: exception_cleanup,\n+                private: [0, ..uw::unwinder_private_data_size],\n+            },\n+            cause: Some(cause),\n+        };\n+        let error = uw::_Unwind_RaiseException(mem::transmute(exception));\n+        rtabort!(\"Could not unwind stack, error = {}\", error as int)\n     }\n \n-    pub fn result(&mut self) -> TaskResult {\n-        if self.unwinding {\n-            Err(self.cause.take().unwrap())\n-        } else {\n-            Ok(())\n+    extern fn exception_cleanup(_unwind_code: uw::_Unwind_Reason_Code,\n+                                exception: *uw::_Unwind_Exception) {\n+        rtdebug!(\"exception_cleanup()\");\n+        unsafe {\n+            let _: Box<Exception> = mem::transmute(exception);\n         }\n     }\n }\n@@ -346,103 +373,124 @@ pub fn begin_unwind<M: Any + Send>(msg: M, file: &'static str, line: uint) -> !\n fn begin_unwind_inner(msg: Box<Any:Send>,\n                       file: &'static str,\n                       line: uint) -> ! {\n-    let mut task;\n-    {\n-        let msg_s = match msg.as_ref::<&'static str>() {\n-            Some(s) => *s,\n-            None => match msg.as_ref::<String>() {\n-                Some(s) => s.as_slice(),\n-                None => \"Box<Any>\",\n-            }\n-        };\n-\n-        // It is assumed that all reasonable rust code will have a local task at\n-        // all times. This means that this `try_take` will succeed almost all of\n-        // the time. There are border cases, however, when the runtime has\n-        // *almost* set up the local task, but hasn't quite gotten there yet. In\n-        // order to get some better diagnostics, we print on failure and\n-        // immediately abort the whole process if there is no local task\n-        // available.\n-        let opt_task: Option<Box<Task>> = Local::try_take();\n-        task = match opt_task {\n-            Some(t) => t,\n-            None => {\n-                rterrln!(\"failed at '{}', {}:{}\", msg_s, file, line);\n-                if backtrace::log_enabled() {\n+    // First up, print the message that we're failing\n+    print_failure(msg, file, line);\n+\n+    let opt_task: Option<Box<Task>> = Local::try_take();\n+    match opt_task {\n+        Some(mut task) => {\n+            // Now that we've printed why we're failing, do a check\n+            // to make sure that we're not double failing.\n+            //\n+            // If a task fails while it's already unwinding then we\n+            // have limited options. Currently our preference is to\n+            // just abort. In the future we may consider resuming\n+            // unwinding or otherwise exiting the task cleanly.\n+            if task.unwinder.unwinding {\n+                rterrln!(\"task failed during unwinding (double-failure - \\\n+                          total drag!)\")\n+                rterrln!(\"rust must abort now. so sorry.\");\n+\n+                // Don't print the backtrace twice (it would have already been\n+                // printed if logging was enabled).\n+                if !backtrace::log_enabled() {\n                     let mut err = ::rt::util::Stderr;\n                     let _err = backtrace::write(&mut err);\n-                } else {\n-                    rterrln!(\"run with `RUST_BACKTRACE=1` to see a backtrace\");\n                 }\n                 unsafe { intrinsics::abort() }\n             }\n-        };\n \n-        // See comments in io::stdio::with_task_stdout as to why we have to be\n-        // careful when using an arbitrary I/O handle from the task. We\n-        // essentially need to dance to make sure when a task is in TLS when\n-        // running user code.\n-        let name = task.name.take();\n-        {\n-            let n = name.as_ref().map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n-\n-            match task.stderr.take() {\n-                Some(mut stderr) => {\n-                    Local::put(task);\n-                    // FIXME: what to do when the task printing fails?\n-                    let _err = write!(stderr,\n-                                      \"task '{}' failed at '{}', {}:{}\\n\",\n-                                      n, msg_s, file, line);\n-                    if backtrace::log_enabled() {\n-                        let _err = backtrace::write(stderr);\n-                    }\n-                    task = Local::take();\n-\n-                    match mem::replace(&mut task.stderr, Some(stderr)) {\n-                        Some(prev) => {\n-                            Local::put(task);\n-                            drop(prev);\n-                            task = Local::take();\n-                        }\n-                        None => {}\n-                    }\n-                }\n-                None => {\n-                    rterrln!(\"task '{}' failed at '{}', {}:{}\", n, msg_s,\n-                             file, line);\n-                    if backtrace::log_enabled() {\n-                        let mut err = ::rt::util::Stderr;\n-                        let _err = backtrace::write(&mut err);\n-                    }\n-                }\n-            }\n+            // Finally, we've printed our failure and figured out we're not in a\n+            // double failure, so flag that we've started to unwind and then\n+            // actually unwind.  Be sure that the task is in TLS so destructors\n+            // can do fun things like I/O.\n+            task.unwinder.unwinding = true;\n+            Local::put(task);\n         }\n-        task.name = name;\n-\n-        if task.unwinder.unwinding {\n-            // If a task fails while it's already unwinding then we\n-            // have limited options. Currently our preference is to\n-            // just abort. In the future we may consider resuming\n-            // unwinding or otherwise exiting the task cleanly.\n-            rterrln!(\"task failed during unwinding (double-failure - total drag!)\")\n-            rterrln!(\"rust must abort now. so sorry.\");\n+        None => {}\n+    }\n+    rust_fail(msg)\n+}\n \n-            // Don't print the backtrace twice (it would have already been\n-            // printed if logging was enabled).\n-            if !backtrace::log_enabled() {\n+/// Given a failure message and the location that it occurred, prints the\n+/// message to the local task's appropriate stream.\n+///\n+/// This function currently handles three cases:\n+///\n+///     - There is no local task available. In this case the error is printed to\n+///       stderr.\n+///     - There is a local task available, but it does not have a stderr handle.\n+///       In this case the message is also printed to stderr.\n+///     - There is a local task available, and it has a stderr handle. The\n+///       message is printed to the handle given in this case.\n+fn print_failure(msg: &Any:Send, file: &str, line: uint) {\n+    let msg = match msg.as_ref::<&'static str>() {\n+        Some(s) => *s,\n+        None => match msg.as_ref::<String>() {\n+            Some(s) => s.as_slice(),\n+            None => \"Box<Any>\",\n+        }\n+    };\n+\n+    // It is assumed that all reasonable rust code will have a local task at\n+    // all times. This means that this `try_take` will succeed almost all of\n+    // the time. There are border cases, however, when the runtime has\n+    // *almost* set up the local task, but hasn't quite gotten there yet. In\n+    // order to get some better diagnostics, we print on failure and\n+    // immediately abort the whole process if there is no local task\n+    // available.\n+    let mut task: Box<Task> = match Local::try_take() {\n+        Some(t) => t,\n+        None => {\n+            rterrln!(\"failed at '{}', {}:{}\", msg, file, line);\n+            if backtrace::log_enabled() {\n                 let mut err = ::rt::util::Stderr;\n                 let _err = backtrace::write(&mut err);\n+            } else {\n+                rterrln!(\"run with `RUST_BACKTRACE=1` to see a backtrace\");\n             }\n-            unsafe { intrinsics::abort() }\n+            return\n         }\n-    }\n+    };\n \n-    // The unwinder won't actually use the task at all, so we put the task back\n-    // into TLS right before we invoke the unwinder, but this means we need an\n-    // unsafe reference back to the unwinder once it's in TLS.\n-    Local::put(task);\n-    unsafe {\n-        let task: *mut Task = Local::unsafe_borrow();\n-        (*task).unwinder.begin_unwind(msg);\n+    // See comments in io::stdio::with_task_stdout as to why we have to be\n+    // careful when using an arbitrary I/O handle from the task. We\n+    // essentially need to dance to make sure when a task is in TLS when\n+    // running user code.\n+    let name = task.name.take();\n+    {\n+        let n = name.as_ref().map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n+\n+        match task.stderr.take() {\n+            Some(mut stderr) => {\n+                Local::put(task);\n+                // FIXME: what to do when the task printing fails?\n+                let _err = write!(stderr,\n+                                  \"task '{}' failed at '{}', {}:{}\\n\",\n+                                  n, msg, file, line);\n+                if backtrace::log_enabled() {\n+                    let _err = backtrace::write(stderr);\n+                }\n+                task = Local::take();\n+\n+                match mem::replace(&mut task.stderr, Some(stderr)) {\n+                    Some(prev) => {\n+                        Local::put(task);\n+                        drop(prev);\n+                        task = Local::take();\n+                    }\n+                    None => {}\n+                }\n+            }\n+            None => {\n+                rterrln!(\"task '{}' failed at '{}', {}:{}\", n, msg, file, line);\n+                if backtrace::log_enabled() {\n+                    let mut err = ::rt::util::Stderr;\n+                    let _err = backtrace::write(&mut err);\n+                }\n+            }\n+        }\n     }\n+    task.name = name;\n+    Local::put(task);\n }"}, {"sha": "3b573b875744b635e1bcaf1895a42d35dc926da8", "filename": "src/libstd/task.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c7c93b8e83544abc7eef5abd76526e5c49882f5/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7c93b8e83544abc7eef5abd76526e5c49882f5/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=0c7c93b8e83544abc7eef5abd76526e5c49882f5", "patch": "@@ -176,7 +176,10 @@ impl TaskBuilder {\n             Some(gen) => gen(f),\n             None => f\n         };\n-        let t: Box<Task> = Local::take();\n+        let t: Box<Task> = match Local::try_take() {\n+            Some(t) => t,\n+            None => fail!(\"need a local task to spawn a new task\"),\n+        };\n         t.spawn_sibling(self.opts, f);\n     }\n "}, {"sha": "1fe99336bc9cad496271e1624d2c7dee5289550e", "filename": "src/test/run-pass/running-with-no-runtime.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0c7c93b8e83544abc7eef5abd76526e5c49882f5/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7c93b8e83544abc7eef5abd76526e5c49882f5/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs?ref=0c7c93b8e83544abc7eef5abd76526e5c49882f5", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate native;\n+\n+use std::io::process::{Command, ProcessOutput};\n+use std::os;\n+use std::str;\n+use std::rt::unwind::try;\n+\n+local_data_key!(foo: int)\n+\n+#[start]\n+fn start(argc: int, argv: **u8) -> int {\n+    if argc > 1 {\n+        unsafe {\n+            match **argv.offset(1) {\n+                1 => {}\n+                2 => println!(\"foo\"),\n+                3 => assert!(try(|| {}).is_ok()),\n+                4 => assert!(try(|| fail!()).is_err()),\n+                5 => assert!(try(|| spawn(proc() {})).is_err()),\n+                6 => assert!(Command::new(\"test\").spawn().is_err()),\n+                7 => assert!(foo.get().is_some()),\n+                8 => assert!(try(|| { foo.replace(Some(3)); }).is_err()),\n+                _ => fail!()\n+            }\n+        }\n+        return 0\n+    }\n+\n+    native::start(argc, argv, main)\n+}\n+\n+fn main() {\n+    let args = os::args();\n+    let me = args.get(0).as_slice();\n+\n+    pass(Command::new(me).arg(&[1u8]).output().unwrap());\n+    pass(Command::new(me).arg(&[2u8]).output().unwrap());\n+    pass(Command::new(me).arg(&[3u8]).output().unwrap());\n+    pass(Command::new(me).arg(&[4u8]).output().unwrap());\n+    pass(Command::new(me).arg(&[5u8]).output().unwrap());\n+    pass(Command::new(me).arg(&[6u8]).output().unwrap());\n+}\n+\n+fn pass(output: ProcessOutput) {\n+    if !output.status.success() {\n+        println!(\"{}\", str::from_utf8(output.output.as_slice()));\n+        println!(\"{}\", str::from_utf8(output.error.as_slice()));\n+    }\n+}"}]}