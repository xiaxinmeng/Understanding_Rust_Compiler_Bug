{"sha": "f2299490c11b0c53ece5f6a13dd092fc9c99d264", "node_id": "C_kwDOAAsO6NoAKGYyMjk5NDkwYzExYjBjNTNlY2U1ZjZhMTNkZDA5MmZjOWM5OWQyNjQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-29T08:55:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-29T08:55:04Z"}, "message": "Auto merge of #108106 - the8472:layout-opt, r=wesleywiser\n\nImprove niche placement by trying two strategies and picking the better result\n\nFixes #104807\nFixes #105371\n\nDetermining which sort order is better requires calculating the struct size (so we can calculate the niche offset). But that in turn depends on the field order, so happens after sorting. So the simple way to solve that is to run the whole thing twice and pick the better result.\n\n1st commit is just code motion, the meat is in the later ones.", "tree": {"sha": "1be4d3a122a01fa76589e2bca4192689bd0b7ca1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1be4d3a122a01fa76589e2bca4192689bd0b7ca1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2299490c11b0c53ece5f6a13dd092fc9c99d264", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2299490c11b0c53ece5f6a13dd092fc9c99d264", "html_url": "https://github.com/rust-lang/rust/commit/f2299490c11b0c53ece5f6a13dd092fc9c99d264", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2299490c11b0c53ece5f6a13dd092fc9c99d264/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af2c7e0f9b5730b9598ca70fc67360fa69b469c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/af2c7e0f9b5730b9598ca70fc67360fa69b469c8", "html_url": "https://github.com/rust-lang/rust/commit/af2c7e0f9b5730b9598ca70fc67360fa69b469c8"}, {"sha": "61fb5a91b794d7ab9c5f923b26c92cfc473b976b", "url": "https://api.github.com/repos/rust-lang/rust/commits/61fb5a91b794d7ab9c5f923b26c92cfc473b976b", "html_url": "https://github.com/rust-lang/rust/commit/61fb5a91b794d7ab9c5f923b26c92cfc473b976b"}], "stats": {"total": 809, "additions": 511, "deletions": 298}, "files": [{"sha": "b4597d5bc78450eee640215a88d51c042ed74d23", "filename": "compiler/rustc_abi/src/layout.rs", "status": "modified", "additions": 371, "deletions": 210, "changes": 581, "blob_url": "https://github.com/rust-lang/rust/blob/f2299490c11b0c53ece5f6a13dd092fc9c99d264/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2299490c11b0c53ece5f6a13dd092fc9c99d264/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flayout.rs?ref=f2299490c11b0c53ece5f6a13dd092fc9c99d264", "patch": "@@ -1,4 +1,5 @@\n use super::*;\n+use std::fmt::Write;\n use std::{borrow::Borrow, cmp, iter, ops::Bound};\n \n #[cfg(feature = \"randomize\")]\n@@ -49,220 +50,60 @@ pub trait LayoutCalculator {\n         repr: &ReprOptions,\n         kind: StructKind,\n     ) -> Option<LayoutS> {\n-        let pack = repr.pack;\n-        let mut align = if pack.is_some() { dl.i8_align } else { dl.aggregate_align };\n-        let mut inverse_memory_index: IndexVec<u32, FieldIdx> = fields.indices().collect();\n-        let optimize = !repr.inhibit_struct_field_reordering_opt();\n-        if optimize {\n-            let end =\n-                if let StructKind::MaybeUnsized = kind { fields.len() - 1 } else { fields.len() };\n-            let optimizing = &mut inverse_memory_index.raw[..end];\n-            let effective_field_align = |layout: Layout<'_>| {\n-                if let Some(pack) = pack {\n-                    // return the packed alignment in bytes\n-                    layout.align().abi.min(pack).bytes()\n-                } else {\n-                    // returns log2(effective-align).\n-                    // This is ok since `pack` applies to all fields equally.\n-                    // The calculation assumes that size is an integer multiple of align, except for ZSTs.\n-                    //\n-                    // group [u8; 4] with align-4 or [u8; 6] with align-2 fields\n-                    layout.align().abi.bytes().max(layout.size().bytes()).trailing_zeros() as u64\n-                }\n-            };\n-\n-            // If `-Z randomize-layout` was enabled for the type definition we can shuffle\n-            // the field ordering to try and catch some code making assumptions about layouts\n-            // we don't guarantee\n-            if repr.can_randomize_type_layout() && cfg!(feature = \"randomize\") {\n-                #[cfg(feature = \"randomize\")]\n-                {\n-                    // `ReprOptions.layout_seed` is a deterministic seed that we can use to\n-                    // randomize field ordering with\n-                    let mut rng =\n-                        Xoshiro128StarStar::seed_from_u64(repr.field_shuffle_seed.as_u64());\n-\n-                    // Shuffle the ordering of the fields\n-                    optimizing.shuffle(&mut rng);\n-                }\n-                // Otherwise we just leave things alone and actually optimize the type's fields\n-            } else {\n-                match kind {\n-                    StructKind::AlwaysSized | StructKind::MaybeUnsized => {\n-                        optimizing.sort_by_key(|&x| {\n-                            // Place ZSTs first to avoid \"interesting offsets\",\n-                            // especially with only one or two non-ZST fields.\n-                            // Then place largest alignments first, largest niches within an alignment group last\n-                            let f = fields[x];\n-                            let niche_size = f.largest_niche().map_or(0, |n| n.available(dl));\n-                            (!f.0.is_zst(), cmp::Reverse(effective_field_align(f)), niche_size)\n-                        });\n-                    }\n-\n-                    StructKind::Prefixed(..) => {\n-                        // Sort in ascending alignment so that the layout stays optimal\n-                        // regardless of the prefix.\n-                        // And put the largest niche in an alignment group at the end\n-                        // so it can be used as discriminant in jagged enums\n-                        optimizing.sort_by_key(|&x| {\n-                            let f = fields[x];\n-                            let niche_size = f.largest_niche().map_or(0, |n| n.available(dl));\n-                            (effective_field_align(f), niche_size)\n-                        });\n+        let layout = univariant(self, dl, fields, repr, kind, NicheBias::Start);\n+        // Enums prefer niches close to the beginning or the end of the variants so that other (smaller)\n+        // data-carrying variants can be packed into the space after/before the niche.\n+        // If the default field ordering does not give us a niche at the front then we do a second\n+        // run and bias niches to the right and then check which one is closer to one of the struct's\n+        // edges.\n+        if let Some(layout) = &layout {\n+            if let Some(niche) = layout.largest_niche {\n+                let head_space = niche.offset.bytes();\n+                let niche_length = niche.value.size(dl).bytes();\n+                let tail_space = layout.size.bytes() - head_space - niche_length;\n+\n+                // This may end up doing redundant work if the niche is already in the last field\n+                // (e.g. a trailing bool) and there is tail padding. But it's non-trivial to get\n+                // the unpadded size so we try anyway.\n+                if fields.len() > 1 && head_space != 0 && tail_space > 0 {\n+                    let alt_layout = univariant(self, dl, fields, repr, kind, NicheBias::End)\n+                        .expect(\"alt layout should always work\");\n+                    let niche = alt_layout\n+                        .largest_niche\n+                        .expect(\"alt layout should have a niche like the regular one\");\n+                    let alt_head_space = niche.offset.bytes();\n+                    let alt_niche_len = niche.value.size(dl).bytes();\n+                    let alt_tail_space = alt_layout.size.bytes() - alt_head_space - alt_niche_len;\n+\n+                    debug_assert_eq!(layout.size.bytes(), alt_layout.size.bytes());\n+\n+                    let prefer_alt_layout =\n+                        alt_head_space > head_space && alt_head_space > tail_space;\n+\n+                    debug!(\n+                        \"sz: {}, default_niche_at: {}+{}, default_tail_space: {}, alt_niche_at/head_space: {}+{}, alt_tail: {}, num_fields: {}, better: {}\\n\\\n+                        layout: {}\\n\\\n+                        alt_layout: {}\\n\",\n+                        layout.size.bytes(),\n+                        head_space,\n+                        niche_length,\n+                        tail_space,\n+                        alt_head_space,\n+                        alt_niche_len,\n+                        alt_tail_space,\n+                        layout.fields.count(),\n+                        prefer_alt_layout,\n+                        format_field_niches(&layout, &fields, &dl),\n+                        format_field_niches(&alt_layout, &fields, &dl),\n+                    );\n+\n+                    if prefer_alt_layout {\n+                        return Some(alt_layout);\n                     }\n                 }\n-\n-                // FIXME(Kixiron): We can always shuffle fields within a given alignment class\n-                //                 regardless of the status of `-Z randomize-layout`\n             }\n         }\n-        // inverse_memory_index holds field indices by increasing memory offset.\n-        // That is, if field 5 has offset 0, the first element of inverse_memory_index is 5.\n-        // We now write field offsets to the corresponding offset slot;\n-        // field 5 with offset 0 puts 0 in offsets[5].\n-        // At the bottom of this function, we invert `inverse_memory_index` to\n-        // produce `memory_index` (see `invert_mapping`).\n-        let mut sized = true;\n-        let mut offsets = IndexVec::from_elem(Size::ZERO, &fields);\n-        let mut offset = Size::ZERO;\n-        let mut largest_niche = None;\n-        let mut largest_niche_available = 0;\n-        if let StructKind::Prefixed(prefix_size, prefix_align) = kind {\n-            let prefix_align =\n-                if let Some(pack) = pack { prefix_align.min(pack) } else { prefix_align };\n-            align = align.max(AbiAndPrefAlign::new(prefix_align));\n-            offset = prefix_size.align_to(prefix_align);\n-        }\n-        for &i in &inverse_memory_index {\n-            let field = &fields[i];\n-            if !sized {\n-                self.delay_bug(&format!(\n-                    \"univariant: field #{} comes after unsized field\",\n-                    offsets.len(),\n-                ));\n-            }\n-\n-            if field.0.is_unsized() {\n-                sized = false;\n-            }\n-\n-            // Invariant: offset < dl.obj_size_bound() <= 1<<61\n-            let field_align = if let Some(pack) = pack {\n-                field.align().min(AbiAndPrefAlign::new(pack))\n-            } else {\n-                field.align()\n-            };\n-            offset = offset.align_to(field_align.abi);\n-            align = align.max(field_align);\n-\n-            debug!(\"univariant offset: {:?} field: {:#?}\", offset, field);\n-            offsets[i] = offset;\n-\n-            if let Some(mut niche) = field.largest_niche() {\n-                let available = niche.available(dl);\n-                if available > largest_niche_available {\n-                    largest_niche_available = available;\n-                    niche.offset += offset;\n-                    largest_niche = Some(niche);\n-                }\n-            }\n-\n-            offset = offset.checked_add(field.size(), dl)?;\n-        }\n-        if let Some(repr_align) = repr.align {\n-            align = align.max(AbiAndPrefAlign::new(repr_align));\n-        }\n-        debug!(\"univariant min_size: {:?}\", offset);\n-        let min_size = offset;\n-        // As stated above, inverse_memory_index holds field indices by increasing offset.\n-        // This makes it an already-sorted view of the offsets vec.\n-        // To invert it, consider:\n-        // If field 5 has offset 0, offsets[0] is 5, and memory_index[5] should be 0.\n-        // Field 5 would be the first element, so memory_index is i:\n-        // Note: if we didn't optimize, it's already right.\n-        let memory_index = if optimize {\n-            inverse_memory_index.invert_bijective_mapping()\n-        } else {\n-            debug_assert!(inverse_memory_index.iter().copied().eq(fields.indices()));\n-            inverse_memory_index.into_iter().map(FieldIdx::as_u32).collect()\n-        };\n-        let size = min_size.align_to(align.abi);\n-        let mut abi = Abi::Aggregate { sized };\n-        // Unpack newtype ABIs and find scalar pairs.\n-        if sized && size.bytes() > 0 {\n-            // All other fields must be ZSTs.\n-            let mut non_zst_fields = fields.iter_enumerated().filter(|&(_, f)| !f.0.is_zst());\n-\n-            match (non_zst_fields.next(), non_zst_fields.next(), non_zst_fields.next()) {\n-                // We have exactly one non-ZST field.\n-                (Some((i, field)), None, None) => {\n-                    // Field fills the struct and it has a scalar or scalar pair ABI.\n-                    if offsets[i].bytes() == 0\n-                        && align.abi == field.align().abi\n-                        && size == field.size()\n-                    {\n-                        match field.abi() {\n-                            // For plain scalars, or vectors of them, we can't unpack\n-                            // newtypes for `#[repr(C)]`, as that affects C ABIs.\n-                            Abi::Scalar(_) | Abi::Vector { .. } if optimize => {\n-                                abi = field.abi();\n-                            }\n-                            // But scalar pairs are Rust-specific and get\n-                            // treated as aggregates by C ABIs anyway.\n-                            Abi::ScalarPair(..) => {\n-                                abi = field.abi();\n-                            }\n-                            _ => {}\n-                        }\n-                    }\n-                }\n-\n-                // Two non-ZST fields, and they're both scalars.\n-                (Some((i, a)), Some((j, b)), None) => {\n-                    match (a.abi(), b.abi()) {\n-                        (Abi::Scalar(a), Abi::Scalar(b)) => {\n-                            // Order by the memory placement, not source order.\n-                            let ((i, a), (j, b)) = if offsets[i] < offsets[j] {\n-                                ((i, a), (j, b))\n-                            } else {\n-                                ((j, b), (i, a))\n-                            };\n-                            let pair = self.scalar_pair(a, b);\n-                            let pair_offsets = match pair.fields {\n-                                FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n-                                    assert_eq!(memory_index.raw, [0, 1]);\n-                                    offsets\n-                                }\n-                                _ => panic!(),\n-                            };\n-                            if offsets[i] == pair_offsets[FieldIdx::from_usize(0)]\n-                                && offsets[j] == pair_offsets[FieldIdx::from_usize(1)]\n-                                && align == pair.align\n-                                && size == pair.size\n-                            {\n-                                // We can use `ScalarPair` only when it matches our\n-                                // already computed layout (including `#[repr(C)]`).\n-                                abi = pair.abi;\n-                            }\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-\n-                _ => {}\n-            }\n-        }\n-        if fields.iter().any(|f| f.abi().is_uninhabited()) {\n-            abi = Abi::Uninhabited;\n-        }\n-        Some(LayoutS {\n-            variants: Variants::Single { index: FIRST_VARIANT },\n-            fields: FieldsShape::Arbitrary { offsets, memory_index },\n-            abi,\n-            largest_niche,\n-            align,\n-            size,\n-        })\n+        layout\n     }\n \n     fn layout_of_never_type(&self) -> LayoutS {\n@@ -934,3 +775,323 @@ pub trait LayoutCalculator {\n         })\n     }\n }\n+\n+/// Determines towards which end of a struct layout optimizations will try to place the best niches.\n+enum NicheBias {\n+    Start,\n+    End,\n+}\n+\n+fn univariant(\n+    this: &(impl LayoutCalculator + ?Sized),\n+    dl: &TargetDataLayout,\n+    fields: &IndexSlice<FieldIdx, Layout<'_>>,\n+    repr: &ReprOptions,\n+    kind: StructKind,\n+    niche_bias: NicheBias,\n+) -> Option<LayoutS> {\n+    let pack = repr.pack;\n+    let mut align = if pack.is_some() { dl.i8_align } else { dl.aggregate_align };\n+    let mut inverse_memory_index: IndexVec<u32, FieldIdx> = fields.indices().collect();\n+    let optimize = !repr.inhibit_struct_field_reordering_opt();\n+    if optimize && fields.len() > 1 {\n+        let end = if let StructKind::MaybeUnsized = kind { fields.len() - 1 } else { fields.len() };\n+        let optimizing = &mut inverse_memory_index.raw[..end];\n+\n+        // If `-Z randomize-layout` was enabled for the type definition we can shuffle\n+        // the field ordering to try and catch some code making assumptions about layouts\n+        // we don't guarantee\n+        if repr.can_randomize_type_layout() && cfg!(feature = \"randomize\") {\n+            #[cfg(feature = \"randomize\")]\n+            {\n+                // `ReprOptions.layout_seed` is a deterministic seed that we can use to\n+                // randomize field ordering with\n+                let mut rng = Xoshiro128StarStar::seed_from_u64(repr.field_shuffle_seed.as_u64());\n+\n+                // Shuffle the ordering of the fields\n+                optimizing.shuffle(&mut rng);\n+            }\n+            // Otherwise we just leave things alone and actually optimize the type's fields\n+        } else {\n+            let max_field_align = fields.iter().map(|f| f.align().abi.bytes()).max().unwrap_or(1);\n+            let largest_niche_size = fields\n+                .iter()\n+                .filter_map(|f| f.largest_niche())\n+                .map(|n| n.available(dl))\n+                .max()\n+                .unwrap_or(0);\n+\n+            // Calculates a sort key to group fields by their alignment or possibly some size-derived\n+            // pseudo-alignment.\n+            let alignment_group_key = |layout: Layout<'_>| {\n+                if let Some(pack) = pack {\n+                    // return the packed alignment in bytes\n+                    layout.align().abi.min(pack).bytes()\n+                } else {\n+                    // returns log2(effective-align).\n+                    // This is ok since `pack` applies to all fields equally.\n+                    // The calculation assumes that size is an integer multiple of align, except for ZSTs.\n+                    //\n+                    let align = layout.align().abi.bytes();\n+                    let size = layout.size().bytes();\n+                    let niche_size = layout.largest_niche().map(|n| n.available(dl)).unwrap_or(0);\n+                    // group [u8; 4] with align-4 or [u8; 6] with align-2 fields\n+                    let size_as_align = align.max(size).trailing_zeros();\n+                    let size_as_align = if largest_niche_size > 0 {\n+                        match niche_bias {\n+                            // Given `A(u8, [u8; 16])` and `B(bool, [u8; 16])` we want to bump the array\n+                            // to the front in the first case (for aligned loads) but keep the bool in front\n+                            // in the second case for its niches.\n+                            NicheBias::Start => max_field_align.trailing_zeros().min(size_as_align),\n+                            // When moving niches towards the end of the struct then for\n+                            // A((u8, u8, u8, bool), (u8, bool, u8)) we want to keep the first tuple\n+                            // in the align-1 group because its bool can be moved closer to the end.\n+                            NicheBias::End if niche_size == largest_niche_size => {\n+                                align.trailing_zeros()\n+                            }\n+                            NicheBias::End => size_as_align,\n+                        }\n+                    } else {\n+                        size_as_align\n+                    };\n+                    size_as_align as u64\n+                }\n+            };\n+\n+            match kind {\n+                StructKind::AlwaysSized | StructKind::MaybeUnsized => {\n+                    // Currently `LayoutS` only exposes a single niche so sorting is usually sufficient\n+                    // to get one niche into the preferred position. If it ever supported multiple niches\n+                    // then a more advanced pick-and-pack approach could provide better results.\n+                    // But even for the single-niche cache it's not optimal. E.g. for\n+                    // A(u32, (bool, u8), u16) it would be possible to move the bool to the front\n+                    // but it would require packing the tuple together with the u16 to build a 4-byte\n+                    // group so that the u32 can be placed after it without padding. This kind\n+                    // of packing can't be achieved by sorting.\n+                    optimizing.sort_by_key(|&x| {\n+                        let f = fields[x];\n+                        let field_size = f.size().bytes();\n+                        let niche_size = f.largest_niche().map_or(0, |n| n.available(dl));\n+                        let niche_size_key = match niche_bias {\n+                            // large niche first\n+                            NicheBias::Start => !niche_size,\n+                            // large niche last\n+                            NicheBias::End => niche_size,\n+                        };\n+                        let inner_niche_offset_key = match niche_bias {\n+                            NicheBias::Start => f.largest_niche().map_or(0, |n| n.offset.bytes()),\n+                            NicheBias::End => f.largest_niche().map_or(0, |n| {\n+                                !(field_size - n.value.size(dl).bytes() - n.offset.bytes())\n+                            }),\n+                        };\n+\n+                        (\n+                            // Place ZSTs first to avoid \"interesting offsets\", especially with only one\n+                            // or two non-ZST fields. This helps Scalar/ScalarPair layouts.\n+                            !f.0.is_zst(),\n+                            // Then place largest alignments first.\n+                            cmp::Reverse(alignment_group_key(f)),\n+                            // Then prioritize niche placement within alignment group according to\n+                            // `niche_bias_start`.\n+                            niche_size_key,\n+                            // Then among fields with equally-sized niches prefer the ones\n+                            // closer to the start/end of the field.\n+                            inner_niche_offset_key,\n+                        )\n+                    });\n+                }\n+\n+                StructKind::Prefixed(..) => {\n+                    // Sort in ascending alignment so that the layout stays optimal\n+                    // regardless of the prefix.\n+                    // And put the largest niche in an alignment group at the end\n+                    // so it can be used as discriminant in jagged enums\n+                    optimizing.sort_by_key(|&x| {\n+                        let f = fields[x];\n+                        let niche_size = f.largest_niche().map_or(0, |n| n.available(dl));\n+                        (alignment_group_key(f), niche_size)\n+                    });\n+                }\n+            }\n+\n+            // FIXME(Kixiron): We can always shuffle fields within a given alignment class\n+            //                 regardless of the status of `-Z randomize-layout`\n+        }\n+    }\n+    // inverse_memory_index holds field indices by increasing memory offset.\n+    // That is, if field 5 has offset 0, the first element of inverse_memory_index is 5.\n+    // We now write field offsets to the corresponding offset slot;\n+    // field 5 with offset 0 puts 0 in offsets[5].\n+    // At the bottom of this function, we invert `inverse_memory_index` to\n+    // produce `memory_index` (see `invert_mapping`).\n+    let mut sized = true;\n+    let mut offsets = IndexVec::from_elem(Size::ZERO, &fields);\n+    let mut offset = Size::ZERO;\n+    let mut largest_niche = None;\n+    let mut largest_niche_available = 0;\n+    if let StructKind::Prefixed(prefix_size, prefix_align) = kind {\n+        let prefix_align =\n+            if let Some(pack) = pack { prefix_align.min(pack) } else { prefix_align };\n+        align = align.max(AbiAndPrefAlign::new(prefix_align));\n+        offset = prefix_size.align_to(prefix_align);\n+    }\n+    for &i in &inverse_memory_index {\n+        let field = &fields[i];\n+        if !sized {\n+            this.delay_bug(&format!(\n+                \"univariant: field #{} comes after unsized field\",\n+                offsets.len(),\n+            ));\n+        }\n+\n+        if field.0.is_unsized() {\n+            sized = false;\n+        }\n+\n+        // Invariant: offset < dl.obj_size_bound() <= 1<<61\n+        let field_align = if let Some(pack) = pack {\n+            field.align().min(AbiAndPrefAlign::new(pack))\n+        } else {\n+            field.align()\n+        };\n+        offset = offset.align_to(field_align.abi);\n+        align = align.max(field_align);\n+\n+        debug!(\"univariant offset: {:?} field: {:#?}\", offset, field);\n+        offsets[i] = offset;\n+\n+        if let Some(mut niche) = field.largest_niche() {\n+            let available = niche.available(dl);\n+            // Pick up larger niches.\n+            let prefer_new_niche = match niche_bias {\n+                NicheBias::Start => available > largest_niche_available,\n+                // if there are several niches of the same size then pick the last one\n+                NicheBias::End => available >= largest_niche_available,\n+            };\n+            if prefer_new_niche {\n+                largest_niche_available = available;\n+                niche.offset += offset;\n+                largest_niche = Some(niche);\n+            }\n+        }\n+\n+        offset = offset.checked_add(field.size(), dl)?;\n+    }\n+    if let Some(repr_align) = repr.align {\n+        align = align.max(AbiAndPrefAlign::new(repr_align));\n+    }\n+    debug!(\"univariant min_size: {:?}\", offset);\n+    let min_size = offset;\n+    // As stated above, inverse_memory_index holds field indices by increasing offset.\n+    // This makes it an already-sorted view of the offsets vec.\n+    // To invert it, consider:\n+    // If field 5 has offset 0, offsets[0] is 5, and memory_index[5] should be 0.\n+    // Field 5 would be the first element, so memory_index is i:\n+    // Note: if we didn't optimize, it's already right.\n+    let memory_index = if optimize {\n+        inverse_memory_index.invert_bijective_mapping()\n+    } else {\n+        debug_assert!(inverse_memory_index.iter().copied().eq(fields.indices()));\n+        inverse_memory_index.into_iter().map(FieldIdx::as_u32).collect()\n+    };\n+    let size = min_size.align_to(align.abi);\n+    let mut abi = Abi::Aggregate { sized };\n+    // Unpack newtype ABIs and find scalar pairs.\n+    if sized && size.bytes() > 0 {\n+        // All other fields must be ZSTs.\n+        let mut non_zst_fields = fields.iter_enumerated().filter(|&(_, f)| !f.0.is_zst());\n+\n+        match (non_zst_fields.next(), non_zst_fields.next(), non_zst_fields.next()) {\n+            // We have exactly one non-ZST field.\n+            (Some((i, field)), None, None) => {\n+                // Field fills the struct and it has a scalar or scalar pair ABI.\n+                if offsets[i].bytes() == 0 && align.abi == field.align().abi && size == field.size()\n+                {\n+                    match field.abi() {\n+                        // For plain scalars, or vectors of them, we can't unpack\n+                        // newtypes for `#[repr(C)]`, as that affects C ABIs.\n+                        Abi::Scalar(_) | Abi::Vector { .. } if optimize => {\n+                            abi = field.abi();\n+                        }\n+                        // But scalar pairs are Rust-specific and get\n+                        // treated as aggregates by C ABIs anyway.\n+                        Abi::ScalarPair(..) => {\n+                            abi = field.abi();\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+\n+            // Two non-ZST fields, and they're both scalars.\n+            (Some((i, a)), Some((j, b)), None) => {\n+                match (a.abi(), b.abi()) {\n+                    (Abi::Scalar(a), Abi::Scalar(b)) => {\n+                        // Order by the memory placement, not source order.\n+                        let ((i, a), (j, b)) = if offsets[i] < offsets[j] {\n+                            ((i, a), (j, b))\n+                        } else {\n+                            ((j, b), (i, a))\n+                        };\n+                        let pair = this.scalar_pair(a, b);\n+                        let pair_offsets = match pair.fields {\n+                            FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n+                                assert_eq!(memory_index.raw, [0, 1]);\n+                                offsets\n+                            }\n+                            _ => panic!(),\n+                        };\n+                        if offsets[i] == pair_offsets[FieldIdx::from_usize(0)]\n+                            && offsets[j] == pair_offsets[FieldIdx::from_usize(1)]\n+                            && align == pair.align\n+                            && size == pair.size\n+                        {\n+                            // We can use `ScalarPair` only when it matches our\n+                            // already computed layout (including `#[repr(C)]`).\n+                            abi = pair.abi;\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            _ => {}\n+        }\n+    }\n+    if fields.iter().any(|f| f.abi().is_uninhabited()) {\n+        abi = Abi::Uninhabited;\n+    }\n+    Some(LayoutS {\n+        variants: Variants::Single { index: FIRST_VARIANT },\n+        fields: FieldsShape::Arbitrary { offsets, memory_index },\n+        abi,\n+        largest_niche,\n+        align,\n+        size,\n+    })\n+}\n+\n+fn format_field_niches(\n+    layout: &LayoutS,\n+    fields: &IndexSlice<FieldIdx, Layout<'_>>,\n+    dl: &TargetDataLayout,\n+) -> String {\n+    let mut s = String::new();\n+    for i in layout.fields.index_by_increasing_offset() {\n+        let offset = layout.fields.offset(i);\n+        let f = fields[i.into()];\n+        write!(s, \"[o{}a{}s{}\", offset.bytes(), f.align().abi.bytes(), f.size().bytes()).unwrap();\n+        if let Some(n) = f.largest_niche() {\n+            write!(\n+                s,\n+                \" n{}b{}s{}\",\n+                n.offset.bytes(),\n+                n.available(dl).ilog2(),\n+                n.value.size(dl).bytes()\n+            )\n+            .unwrap();\n+        }\n+        write!(s, \"] \").unwrap();\n+    }\n+    s\n+}"}, {"sha": "da64692d27d92fd46f65df77de5253361e3f54c6", "filename": "tests/codegen/issues/issue-103840.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2299490c11b0c53ece5f6a13dd092fc9c99d264/tests%2Fcodegen%2Fissues%2Fissue-103840.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2299490c11b0c53ece5f6a13dd092fc9c99d264/tests%2Fcodegen%2Fissues%2Fissue-103840.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-103840.rs?ref=f2299490c11b0c53ece5f6a13dd092fc9c99d264", "patch": "@@ -1,4 +1,5 @@\n // compile-flags: -O\n+// min-llvm-version: 16.0\n #![crate_type = \"lib\"]\n \n pub fn foo(t: &mut Vec<usize>) {"}, {"sha": "2ee4d7cca0e3c30620016b5011fd14c7865a9dc7", "filename": "tests/codegen/issues/issue-105386-ub-in-debuginfo.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2299490c11b0c53ece5f6a13dd092fc9c99d264/tests%2Fcodegen%2Fissues%2Fissue-105386-ub-in-debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2299490c11b0c53ece5f6a13dd092fc9c99d264/tests%2Fcodegen%2Fissues%2Fissue-105386-ub-in-debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-105386-ub-in-debuginfo.rs?ref=f2299490c11b0c53ece5f6a13dd092fc9c99d264", "patch": "@@ -19,4 +19,5 @@ pub fn outer_function(x: S, y: S) -> usize {\n // CHECK-NOT: [[ptr_tmp:%.*]] = getelementptr inbounds %\"[closure@{{.*.rs}}:9:23: 9:25]\", ptr [[spill]]\n // CHECK-NOT: [[load:%.*]] = load ptr, ptr\n // CHECK: call void @llvm.lifetime.start{{.*}}({{.*}}, ptr [[spill]])\n-// CHECK: call void @llvm.memcpy{{.*}}(ptr {{align .*}} [[spill]], ptr {{align .*}} %x\n+// CHECK: [[inner:%.*]] = getelementptr inbounds %\"{{.*}}\", ptr [[spill]]\n+// CHECK: call void @llvm.memcpy{{.*}}(ptr {{align .*}} [[inner]], ptr {{align .*}} %x"}, {"sha": "c0be7fab2f3e04724869ed5d3cf7dc150c277bba", "filename": "tests/codegen/issues/issue-86106.rs", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f2299490c11b0c53ece5f6a13dd092fc9c99d264/tests%2Fcodegen%2Fissues%2Fissue-86106.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2299490c11b0c53ece5f6a13dd092fc9c99d264/tests%2Fcodegen%2Fissues%2Fissue-86106.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-86106.rs?ref=f2299490c11b0c53ece5f6a13dd092fc9c99d264", "patch": "@@ -1,4 +1,5 @@\n // min-llvm-version: 15.0\n+// only-64bit llvm appears to use stores instead of memset on 32bit\n // compile-flags: -C opt-level=3 -Z merge-functions=disabled\n \n // The below two functions ensure that both `String::new()` and `\"\".to_string()`\n@@ -9,25 +10,19 @@\n // CHECK-LABEL: define void @string_new\n #[no_mangle]\n pub fn string_new() -> String {\n-    // CHECK-NOT: load i8\n-    // CHECK: store i{{32|64}}\n+    // CHECK: store ptr inttoptr\n     // CHECK-NEXT: getelementptr\n-    // CHECK-NEXT: store ptr\n-    // CHECK-NEXT: getelementptr\n-    // CHECK-NEXT: store i{{32|64}}\n+    // CHECK-NEXT: call void @llvm.memset\n     // CHECK-NEXT: ret void\n     String::new()\n }\n \n // CHECK-LABEL: define void @empty_to_string\n #[no_mangle]\n pub fn empty_to_string() -> String {\n-    // CHECK-NOT: load i8\n-    // CHECK: store i{{32|64}}\n-    // CHECK-NEXT: getelementptr\n-    // CHECK-NEXT: store ptr\n+    // CHECK: store ptr inttoptr\n     // CHECK-NEXT: getelementptr\n-    // CHECK-NEXT: store i{{32|64}}\n+    // CHECK-NEXT: call void @llvm.memset\n     // CHECK-NEXT: ret void\n     \"\".to_string()\n }\n@@ -38,25 +33,19 @@ pub fn empty_to_string() -> String {\n // CHECK-LABEL: @empty_vec\n #[no_mangle]\n pub fn empty_vec() -> Vec<u8> {\n-    // CHECK: store i{{32|64}}\n-    // CHECK-NOT: load i8\n+    // CHECK: store ptr inttoptr\n     // CHECK-NEXT: getelementptr\n-    // CHECK-NEXT: store ptr\n-    // CHECK-NEXT: getelementptr\n-    // CHECK-NEXT: store i{{32|64}}\n+    // CHECK-NEXT: call void @llvm.memset\n     // CHECK-NEXT: ret void\n     vec![]\n }\n \n // CHECK-LABEL: @empty_vec_clone\n #[no_mangle]\n pub fn empty_vec_clone() -> Vec<u8> {\n-    // CHECK: store i{{32|64}}\n-    // CHECK-NOT: load i8\n-    // CHECK-NEXT: getelementptr\n-    // CHECK-NEXT: store ptr\n+    // CHECK: store ptr inttoptr\n     // CHECK-NEXT: getelementptr\n-    // CHECK-NEXT: store i{{32|64}}\n+    // CHECK-NEXT: call void @llvm.memset\n     // CHECK-NEXT: ret void\n     vec![].clone()\n }"}, {"sha": "c0fbb0204b307c1d0a42fbc92e04ae9a1918f3c9", "filename": "tests/ui/async-await/future-sizes/async-awaiting-fut.stdout", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f2299490c11b0c53ece5f6a13dd092fc9c99d264/tests%2Fui%2Fasync-await%2Ffuture-sizes%2Fasync-awaiting-fut.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/f2299490c11b0c53ece5f6a13dd092fc9c99d264/tests%2Fui%2Fasync-await%2Ffuture-sizes%2Fasync-awaiting-fut.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Ffuture-sizes%2Fasync-awaiting-fut.stdout?ref=f2299490c11b0c53ece5f6a13dd092fc9c99d264", "patch": "@@ -2,38 +2,34 @@ print-type-size type: `[async fn body@$DIR/async-awaiting-fut.rs:21:21: 24:2]`:\n print-type-size     discriminant: 1 bytes\n print-type-size     variant `Unresumed`: 0 bytes\n print-type-size     variant `Suspend0`: 3077 bytes\n-print-type-size         local `.__awaitee`: 3077 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         local `.__awaitee`: 3077 bytes\n print-type-size     variant `Returned`: 0 bytes\n print-type-size     variant `Panicked`: 0 bytes\n print-type-size type: `[async fn body@$DIR/async-awaiting-fut.rs:10:64: 19:2]`: 3077 bytes, alignment: 1 bytes\n print-type-size     discriminant: 1 bytes\n-print-type-size     variant `Unresumed`: 2051 bytes\n-print-type-size         padding: 1026 bytes\n-print-type-size         upvar `.fut`: 1025 bytes, alignment: 1 bytes\n+print-type-size     variant `Unresumed`: 1025 bytes\n+print-type-size         upvar `.fut`: 1025 bytes, offset: 0 bytes, alignment: 1 bytes\n print-type-size     variant `Suspend0`: 2052 bytes\n-print-type-size         local `.fut`: 1025 bytes, offset: 0 bytes, alignment: 1 bytes\n-print-type-size         local `..generator_field4`: 1 bytes\n+print-type-size         upvar `.fut`: 1025 bytes, offset: 0 bytes, alignment: 1 bytes\n print-type-size         padding: 1 bytes\n-print-type-size         upvar `.fut`: 1025 bytes, alignment: 1 bytes\n+print-type-size         local `.fut`: 1025 bytes, alignment: 1 bytes\n+print-type-size         local `..generator_field4`: 1 bytes\n print-type-size         local `.__awaitee`: 1 bytes\n print-type-size     variant `Suspend1`: 3076 bytes\n-print-type-size         padding: 1024 bytes\n+print-type-size         upvar `.fut`: 1025 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         padding: 1026 bytes\n print-type-size         local `..generator_field4`: 1 bytes, alignment: 1 bytes\n-print-type-size         padding: 1 bytes\n-print-type-size         upvar `.fut`: 1025 bytes, alignment: 1 bytes\n print-type-size         local `.__awaitee`: 1025 bytes\n print-type-size     variant `Suspend2`: 2052 bytes\n-print-type-size         local `.fut`: 1025 bytes, offset: 0 bytes, alignment: 1 bytes\n-print-type-size         local `..generator_field4`: 1 bytes\n+print-type-size         upvar `.fut`: 1025 bytes, offset: 0 bytes, alignment: 1 bytes\n print-type-size         padding: 1 bytes\n-print-type-size         upvar `.fut`: 1025 bytes, alignment: 1 bytes\n+print-type-size         local `.fut`: 1025 bytes, alignment: 1 bytes\n+print-type-size         local `..generator_field4`: 1 bytes\n print-type-size         local `.__awaitee`: 1 bytes\n-print-type-size     variant `Returned`: 2051 bytes\n-print-type-size         padding: 1026 bytes\n-print-type-size         upvar `.fut`: 1025 bytes, alignment: 1 bytes\n-print-type-size     variant `Panicked`: 2051 bytes\n-print-type-size         padding: 1026 bytes\n-print-type-size         upvar `.fut`: 1025 bytes, alignment: 1 bytes\n+print-type-size     variant `Returned`: 1025 bytes\n+print-type-size         upvar `.fut`: 1025 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size     variant `Panicked`: 1025 bytes\n+print-type-size         upvar `.fut`: 1025 bytes, offset: 0 bytes, alignment: 1 bytes\n print-type-size type: `std::mem::ManuallyDrop<[async fn body@$DIR/async-awaiting-fut.rs:10:64: 19:2]>`: 3077 bytes, alignment: 1 bytes\n print-type-size     field `.value`: 3077 bytes\n print-type-size type: `std::mem::MaybeUninit<[async fn body@$DIR/async-awaiting-fut.rs:10:64: 19:2]>`: 3077 bytes, alignment: 1 bytes\n@@ -43,11 +39,11 @@ print-type-size         field `.value`: 3077 bytes\n print-type-size type: `[async fn body@$DIR/async-awaiting-fut.rs:8:35: 8:37]`: 1025 bytes, alignment: 1 bytes\n print-type-size     discriminant: 1 bytes\n print-type-size     variant `Unresumed`: 1024 bytes\n-print-type-size         upvar `.arg`: 1024 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         upvar `.arg`: 1024 bytes\n print-type-size     variant `Returned`: 1024 bytes\n-print-type-size         upvar `.arg`: 1024 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         upvar `.arg`: 1024 bytes\n print-type-size     variant `Panicked`: 1024 bytes\n-print-type-size         upvar `.arg`: 1024 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         upvar `.arg`: 1024 bytes\n print-type-size type: `std::mem::ManuallyDrop<[async fn body@$DIR/async-awaiting-fut.rs:8:35: 8:37]>`: 1025 bytes, alignment: 1 bytes\n print-type-size     field `.value`: 1025 bytes\n print-type-size type: `std::mem::MaybeUninit<[async fn body@$DIR/async-awaiting-fut.rs:8:35: 8:37]>`: 1025 bytes, alignment: 1 bytes"}, {"sha": "b5e95ddd7100dc039689da10457ab7906f533119", "filename": "tests/ui/async-await/future-sizes/large-arg.stdout", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f2299490c11b0c53ece5f6a13dd092fc9c99d264/tests%2Fui%2Fasync-await%2Ffuture-sizes%2Flarge-arg.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/f2299490c11b0c53ece5f6a13dd092fc9c99d264/tests%2Fui%2Fasync-await%2Ffuture-sizes%2Flarge-arg.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Ffuture-sizes%2Flarge-arg.stdout?ref=f2299490c11b0c53ece5f6a13dd092fc9c99d264", "patch": "@@ -2,20 +2,20 @@ print-type-size type: `[async fn body@$DIR/large-arg.rs:6:21: 8:2]`: 3076 bytes,\n print-type-size     discriminant: 1 bytes\n print-type-size     variant `Unresumed`: 0 bytes\n print-type-size     variant `Suspend0`: 3075 bytes\n-print-type-size         local `.__awaitee`: 3075 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         local `.__awaitee`: 3075 bytes\n print-type-size     variant `Returned`: 0 bytes\n print-type-size     variant `Panicked`: 0 bytes\n print-type-size type: `[async fn body@$DIR/large-arg.rs:10:30: 12:2]`: 3075 bytes, alignment: 1 bytes\n print-type-size     discriminant: 1 bytes\n print-type-size     variant `Unresumed`: 1024 bytes\n-print-type-size         upvar `.t`: 1024 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         upvar `.t`: 1024 bytes\n print-type-size     variant `Suspend0`: 3074 bytes\n-print-type-size         upvar `.t`: 1024 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         upvar `.t`: 1024 bytes\n print-type-size         local `.__awaitee`: 2050 bytes\n print-type-size     variant `Returned`: 1024 bytes\n-print-type-size         upvar `.t`: 1024 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         upvar `.t`: 1024 bytes\n print-type-size     variant `Panicked`: 1024 bytes\n-print-type-size         upvar `.t`: 1024 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         upvar `.t`: 1024 bytes\n print-type-size type: `std::mem::ManuallyDrop<[async fn body@$DIR/large-arg.rs:10:30: 12:2]>`: 3075 bytes, alignment: 1 bytes\n print-type-size     field `.value`: 3075 bytes\n print-type-size type: `std::mem::MaybeUninit<[async fn body@$DIR/large-arg.rs:10:30: 12:2]>`: 3075 bytes, alignment: 1 bytes\n@@ -25,14 +25,14 @@ print-type-size         field `.value`: 3075 bytes\n print-type-size type: `[async fn body@$DIR/large-arg.rs:13:26: 15:2]`: 2050 bytes, alignment: 1 bytes\n print-type-size     discriminant: 1 bytes\n print-type-size     variant `Unresumed`: 1024 bytes\n-print-type-size         upvar `.t`: 1024 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         upvar `.t`: 1024 bytes\n print-type-size     variant `Suspend0`: 2049 bytes\n-print-type-size         upvar `.t`: 1024 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         upvar `.t`: 1024 bytes\n print-type-size         local `.__awaitee`: 1025 bytes\n print-type-size     variant `Returned`: 1024 bytes\n-print-type-size         upvar `.t`: 1024 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         upvar `.t`: 1024 bytes\n print-type-size     variant `Panicked`: 1024 bytes\n-print-type-size         upvar `.t`: 1024 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         upvar `.t`: 1024 bytes\n print-type-size type: `std::mem::ManuallyDrop<[async fn body@$DIR/large-arg.rs:13:26: 15:2]>`: 2050 bytes, alignment: 1 bytes\n print-type-size     field `.value`: 2050 bytes\n print-type-size type: `std::mem::MaybeUninit<[async fn body@$DIR/large-arg.rs:13:26: 15:2]>`: 2050 bytes, alignment: 1 bytes\n@@ -42,11 +42,11 @@ print-type-size         field `.value`: 2050 bytes\n print-type-size type: `[async fn body@$DIR/large-arg.rs:16:26: 18:2]`: 1025 bytes, alignment: 1 bytes\n print-type-size     discriminant: 1 bytes\n print-type-size     variant `Unresumed`: 1024 bytes\n-print-type-size         upvar `.t`: 1024 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         upvar `.t`: 1024 bytes\n print-type-size     variant `Returned`: 1024 bytes\n-print-type-size         upvar `.t`: 1024 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         upvar `.t`: 1024 bytes\n print-type-size     variant `Panicked`: 1024 bytes\n-print-type-size         upvar `.t`: 1024 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         upvar `.t`: 1024 bytes\n print-type-size type: `std::mem::ManuallyDrop<[async fn body@$DIR/large-arg.rs:16:26: 18:2]>`: 1025 bytes, alignment: 1 bytes\n print-type-size     field `.value`: 1025 bytes\n print-type-size type: `std::mem::MaybeUninit<[async fn body@$DIR/large-arg.rs:16:26: 18:2]>`: 1025 bytes, alignment: 1 bytes"}, {"sha": "a93b561e5be27611e793b7a0e9b3895eea74c152", "filename": "tests/ui/consts/const-eval/raw-bytes.32bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2299490c11b0c53ece5f6a13dd092fc9c99d264/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2299490c11b0c53ece5f6a13dd092fc9c99d264/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.32bit.stderr?ref=f2299490c11b0c53ece5f6a13dd092fc9c99d264", "patch": "@@ -465,7 +465,7 @@ LL | const LAYOUT_INVALID_ZERO: Layout = unsafe { Layout::from_size_align_unchec\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               00 10 00 00 00 00 00 00                         \u2502 ........\n+               00 00 00 00 00 10 00 00                         \u2502 ........\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -476,7 +476,7 @@ LL | const LAYOUT_INVALID_THREE: Layout = unsafe { Layout::from_size_align_unche\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               09 00 00 00 03 00 00 00                         \u2502 ........\n+               03 00 00 00 09 00 00 00                         \u2502 ........\n            }\n \n error[E0080]: it is undefined behavior to use this value"}, {"sha": "a32d4863a38f009a2948e3f57369d77911218d66", "filename": "tests/ui/consts/const-eval/raw-bytes.64bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2299490c11b0c53ece5f6a13dd092fc9c99d264/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2299490c11b0c53ece5f6a13dd092fc9c99d264/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.64bit.stderr?ref=f2299490c11b0c53ece5f6a13dd092fc9c99d264", "patch": "@@ -465,7 +465,7 @@ LL | const LAYOUT_INVALID_ZERO: Layout = unsafe { Layout::from_size_align_unchec\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n+               00 00 00 00 00 00 00 00 00 10 00 00 00 00 00 00 \u2502 ................\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -476,7 +476,7 @@ LL | const LAYOUT_INVALID_THREE: Layout = unsafe { Layout::from_size_align_unche\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               09 00 00 00 00 00 00 00 03 00 00 00 00 00 00 00 \u2502 ................\n+               03 00 00 00 00 00 00 00 09 00 00 00 00 00 00 00 \u2502 ................\n            }\n \n error[E0080]: it is undefined behavior to use this value"}, {"sha": "8c7c915350f19d38111192c1288034105d10788c", "filename": "tests/ui/layout/issue-96158-scalarpair-payload-might-be-uninit.stderr", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f2299490c11b0c53ece5f6a13dd092fc9c99d264/tests%2Fui%2Flayout%2Fissue-96158-scalarpair-payload-might-be-uninit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2299490c11b0c53ece5f6a13dd092fc9c99d264/tests%2Fui%2Flayout%2Fissue-96158-scalarpair-payload-might-be-uninit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flayout%2Fissue-96158-scalarpair-payload-might-be-uninit.stderr?ref=f2299490c11b0c53ece5f6a13dd092fc9c99d264", "patch": "@@ -370,31 +370,31 @@ error: layout_of(NicheFirst) = Layout {\n                pref: $PREF_ALIGN,\n            },\n            abi: ScalarPair(\n-               Union {\n+               Initialized {\n                    value: Int(\n                        I8,\n                        false,\n                    ),\n+                   valid_range: 0..=4,\n                },\n-               Initialized {\n+               Union {\n                    value: Int(\n                        I8,\n                        false,\n                    ),\n-                   valid_range: 0..=4,\n                },\n            ),\n            fields: Arbitrary {\n                offsets: [\n-                   Size(1 bytes),\n+                   Size(0 bytes),\n                ],\n                memory_index: [\n                    0,\n                ],\n            },\n            largest_niche: Some(\n                Niche {\n-                   offset: Size(1 bytes),\n+                   offset: Size(0 bytes),\n                    value: Int(\n                        I8,\n                        false,\n@@ -429,29 +429,29 @@ error: layout_of(NicheFirst) = Layout {\n                                    I8,\n                                    false,\n                                ),\n-                               valid_range: 0..=255,\n+                               valid_range: 0..=2,\n                            },\n                            Initialized {\n                                value: Int(\n                                    I8,\n                                    false,\n                                ),\n-                               valid_range: 0..=2,\n+                               valid_range: 0..=255,\n                            },\n                        ),\n                        fields: Arbitrary {\n                            offsets: [\n-                               Size(1 bytes),\n                                Size(0 bytes),\n+                               Size(1 bytes),\n                            ],\n                            memory_index: [\n-                               1,\n                                0,\n+                               1,\n                            ],\n                        },\n                        largest_niche: Some(\n                            Niche {\n-                               offset: Size(1 bytes),\n+                               offset: Size(0 bytes),\n                                value: Int(\n                                    I8,\n                                    false,\n@@ -514,31 +514,31 @@ error: layout_of(NicheSecond) = Layout {\n                pref: $PREF_ALIGN,\n            },\n            abi: ScalarPair(\n-               Union {\n+               Initialized {\n                    value: Int(\n                        I8,\n                        false,\n                    ),\n+                   valid_range: 0..=4,\n                },\n-               Initialized {\n+               Union {\n                    value: Int(\n                        I8,\n                        false,\n                    ),\n-                   valid_range: 0..=4,\n                },\n            ),\n            fields: Arbitrary {\n                offsets: [\n-                   Size(1 bytes),\n+                   Size(0 bytes),\n                ],\n                memory_index: [\n                    0,\n                ],\n            },\n            largest_niche: Some(\n                Niche {\n-                   offset: Size(1 bytes),\n+                   offset: Size(0 bytes),\n                    value: Int(\n                        I8,\n                        false,\n@@ -573,29 +573,29 @@ error: layout_of(NicheSecond) = Layout {\n                                    I8,\n                                    false,\n                                ),\n-                               valid_range: 0..=255,\n+                               valid_range: 0..=2,\n                            },\n                            Initialized {\n                                value: Int(\n                                    I8,\n                                    false,\n                                ),\n-                               valid_range: 0..=2,\n+                               valid_range: 0..=255,\n                            },\n                        ),\n                        fields: Arbitrary {\n                            offsets: [\n-                               Size(0 bytes),\n                                Size(1 bytes),\n+                               Size(0 bytes),\n                            ],\n                            memory_index: [\n-                               0,\n                                1,\n+                               0,\n                            ],\n                        },\n                        largest_niche: Some(\n                            Niche {\n-                               offset: Size(1 bytes),\n+                               offset: Size(0 bytes),\n                                value: Int(\n                                    I8,\n                                    false,"}, {"sha": "1c6887412be16a8290506fe6a0dc78cf967c9954", "filename": "tests/ui/print_type_sizes/async.stdout", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f2299490c11b0c53ece5f6a13dd092fc9c99d264/tests%2Fui%2Fprint_type_sizes%2Fasync.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/f2299490c11b0c53ece5f6a13dd092fc9c99d264/tests%2Fui%2Fprint_type_sizes%2Fasync.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint_type_sizes%2Fasync.stdout?ref=f2299490c11b0c53ece5f6a13dd092fc9c99d264", "patch": "@@ -1,15 +1,15 @@\n print-type-size type: `[async fn body@$DIR/async.rs:8:36: 11:2]`: 16386 bytes, alignment: 1 bytes\n print-type-size     discriminant: 1 bytes\n print-type-size     variant `Unresumed`: 8192 bytes\n-print-type-size         upvar `.arg`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         upvar `.arg`: 8192 bytes\n print-type-size     variant `Suspend0`: 16385 bytes\n-print-type-size         upvar `.arg`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         upvar `.arg`: 8192 bytes\n print-type-size         local `.arg`: 8192 bytes\n print-type-size         local `.__awaitee`: 1 bytes\n print-type-size     variant `Returned`: 8192 bytes\n-print-type-size         upvar `.arg`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         upvar `.arg`: 8192 bytes\n print-type-size     variant `Panicked`: 8192 bytes\n-print-type-size         upvar `.arg`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         upvar `.arg`: 8192 bytes\n print-type-size type: `std::mem::ManuallyDrop<[u8; 8192]>`: 8192 bytes, alignment: 1 bytes\n print-type-size     field `.value`: 8192 bytes\n print-type-size type: `std::mem::MaybeUninit<[u8; 8192]>`: 8192 bytes, alignment: 1 bytes"}, {"sha": "2dcadde9ec28b7bf8b2e5c65fd6ad8dc42e43b15", "filename": "tests/ui/print_type_sizes/generator.stdout", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f2299490c11b0c53ece5f6a13dd092fc9c99d264/tests%2Fui%2Fprint_type_sizes%2Fgenerator.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/f2299490c11b0c53ece5f6a13dd092fc9c99d264/tests%2Fui%2Fprint_type_sizes%2Fgenerator.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint_type_sizes%2Fgenerator.stdout?ref=f2299490c11b0c53ece5f6a13dd092fc9c99d264", "patch": "@@ -1,10 +1,10 @@\n print-type-size type: `[generator@$DIR/generator.rs:10:5: 10:14]`: 8193 bytes, alignment: 1 bytes\n print-type-size     discriminant: 1 bytes\n print-type-size     variant `Unresumed`: 8192 bytes\n-print-type-size         upvar `.array`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         upvar `.array`: 8192 bytes\n print-type-size     variant `Suspend0`: 8192 bytes\n-print-type-size         upvar `.array`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         upvar `.array`: 8192 bytes\n print-type-size     variant `Returned`: 8192 bytes\n-print-type-size         upvar `.array`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         upvar `.array`: 8192 bytes\n print-type-size     variant `Panicked`: 8192 bytes\n-print-type-size         upvar `.array`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         upvar `.array`: 8192 bytes"}, {"sha": "406e5c8441e7312e2d988e2b70a9022b260567e2", "filename": "tests/ui/structs-enums/type-sizes.rs", "status": "modified", "additions": 66, "deletions": 1, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/f2299490c11b0c53ece5f6a13dd092fc9c99d264/tests%2Fui%2Fstructs-enums%2Ftype-sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2299490c11b0c53ece5f6a13dd092fc9c99d264/tests%2Fui%2Fstructs-enums%2Ftype-sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstructs-enums%2Ftype-sizes.rs?ref=f2299490c11b0c53ece5f6a13dd092fc9c99d264", "patch": "@@ -4,9 +4,14 @@\n #![allow(dead_code)]\n #![feature(never_type)]\n #![feature(pointer_is_aligned)]\n+#![feature(ptr_from_ref)]\n+#![feature(strict_provenance)]\n \n use std::mem::size_of;\n-use std::num::NonZeroU8;\n+use std::num::{NonZeroU8, NonZeroU16};\n+use std::ptr;\n+use std::ptr::NonNull;\n+use std::borrow::Cow;\n \n struct t {a: u8, b: i8}\n struct u {a: u8, b: i8, c: u8}\n@@ -181,6 +186,41 @@ struct Reorder2 {\n     ary: [u8; 6],\n }\n \n+// We want the niche in the front, which means we can't treat the array as quasi-aligned more than\n+// 4 bytes even though we also want to place it at an 8-aligned offset where possible.\n+// So the ideal layout would look like: (char, u32, [u8; 8], u8)\n+// The current layout algorithm does (char, [u8; 8], u32, u8)\n+#[repr(align(8))]\n+struct ReorderWithNiche {\n+    a: u32,\n+    b: char,\n+    c: u8,\n+    ary: [u8; 8]\n+}\n+\n+#[repr(C)]\n+struct EndNiche8([u8; 7], bool);\n+\n+#[repr(C)]\n+struct MiddleNiche4(u8, u8, bool, u8);\n+\n+struct ReorderEndNiche {\n+    a: EndNiche8,\n+    b: MiddleNiche4,\n+}\n+\n+\n+// standins for std types which we want to be laid out in a reasonable way\n+struct RawVecDummy {\n+    ptr: NonNull<u8>,\n+    cap: usize,\n+}\n+\n+struct VecDummy {\n+    r: RawVecDummy,\n+    len: usize,\n+}\n+\n pub fn main() {\n     assert_eq!(size_of::<u8>(), 1 as usize);\n     assert_eq!(size_of::<u32>(), 4 as usize);\n@@ -270,4 +310,29 @@ pub fn main() {\n     let v = Reorder2 {a: 0, b: 0, ary: [0; 6]};\n     assert_eq!(size_of::<Reorder2>(), 10);\n     assert!((&v.ary).as_ptr().is_aligned_to(2), \"[u8; 6] should group with align-2 fields\");\n+\n+    let v = VecDummy { r: RawVecDummy { ptr: NonNull::dangling(), cap: 0 }, len: 1 };\n+    assert_eq!(ptr::from_ref(&v), ptr::from_ref(&v.r.ptr).cast(),\n+               \"sort niches to the front where possible\");\n+\n+    // Ideal layouts: (bool, u8, NonZeroU16) or (NonZeroU16, u8, bool)\n+    // Currently the layout algorithm will choose the latter because it doesn't attempt\n+    // to aggregate multiple smaller fields to move a niche before a higher-alignment one.\n+    let b = BoolInTheMiddle( NonZeroU16::new(1).unwrap(), true, 0);\n+    assert!(ptr::from_ref(&b.1).addr() > ptr::from_ref(&b.2).addr());\n+\n+    assert_eq!(size_of::<Cow<'static, str>>(), size_of::<String>());\n+\n+    let v = ReorderWithNiche {a: 0, b: ' ', c: 0, ary: [0; 8]};\n+    assert!((&v.ary).as_ptr().is_aligned_to(4),\n+            \"here [u8; 8] should group with _at least_ align-4 fields\");\n+    assert_eq!(ptr::from_ref(&v), ptr::from_ref(&v.b).cast(),\n+               \"sort niches to the front where possible\");\n+\n+    // Neither field has a niche at the beginning so the layout algorithm should try move niches to\n+    // the end which means the 8-sized field shouldn't be alignment-promoted before the 4-sized one.\n+    let v = ReorderEndNiche { a: EndNiche8([0; 7], false), b: MiddleNiche4(0, 0, false, 0) };\n+    assert!(ptr::from_ref(&v.a).addr() > ptr::from_ref(&v.b).addr());\n+\n+\n }"}]}