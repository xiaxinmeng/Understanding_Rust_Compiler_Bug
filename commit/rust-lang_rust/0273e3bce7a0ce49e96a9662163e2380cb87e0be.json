{"sha": "0273e3bce7a0ce49e96a9662163e2380cb87e0be", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyNzNlM2JjZTdhMGNlNDllOTZhOTY2MjE2M2UyMzgwY2I4N2UwYmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-12T02:36:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-12T02:36:01Z"}, "message": "Auto merge of #87073 - jyn514:primitive-docs, r=GuillaumeGomez,jyn514\n\nFix rustdoc handling of primitive items\n\nThis is a complicated PR and does a lot of things. I'm willing to split it up a little more if it would help reviewing, but it would be tricky and I'd rather not unless it's necessary.\n\n ## What does this do?\n\n- Fixes https://github.com/rust-lang/rust/issues/73423.\n- Fixes https://github.com/rust-lang/rust/issues/79630. I'm not sure how to test this for the standard library explicitly, but you can see from some of the diffs from the `no_std` tests. I also tested it locally and it works correctly: ![image](https://user-images.githubusercontent.com/23638587/125214383-e1fdd000-e284-11eb-8048-76b5df958aad.png)\n- Fixes https://github.com/rust-lang/rust/issues/83083.\n\n## Why are these changes interconnected?\n\n- Allowing anchors (https://github.com/rust-lang/rust/issues/83083) without fixing the online/offline problem (https://github.com/rust-lang/rust/issues/79630) will actually just silently discard the anchors, that's not a fix. The online/offline problem is directly related to the fragment hack; links need to go through `fn href()` to be fixed.\n- Technically I could fix the online/offline problem without removing the error on anchors; I am willing to separate that out if it would be helpful for reviewing. However I can't fix the anchor problem without adding docs to core, since rustdoc needs all those primitives to have docs to avoid a fallback, and currently `#![no_std]` crates don't have docs for primitives. I also can't fix the online/offline problem without removing the fragment hack, since otherwise diffs like this will be wrong for some primitives but not others:\n```diff\n`@@` -385,7 +381,7 `@@` fn resolve_primitive_associated_item(\n                         ty::AssocKind::Const => \"associatedconstant\",\n                         ty::AssocKind::Type => \"associatedtype\",\n                     };\n-                    let fragment = format!(\"{}#{}.{}\", prim_ty.as_sym(), out, item_name);\n+                    let fragment = format!(\"{}.{}\", out, item_name);\n                     (Res::Primitive(prim_ty), fragment, Some((kind.as_def_kind(), item.def_id)))\n                 })\n         })\n```\n- Adding primitive docs to core without making any other change will cause links to go to `core` instead of `std`, even for crates with `extern crate std`. See \"Breaking changes to doc(primitive)\" below for why this is the case. That said, I could add some special casing to rustdoc at the same time that would let me separate this change from the others (it would fix https://github.com/rust-lang/rust/issues/73423 but still special-case intra-doc links). I'm willing to separate that out if helpful for reviewing.\n\n### Add primitive documentation to libcore\n\nThis works by reusing the same `include!(\"primitive_docs.rs\")` file in both core and std, and then special-casing links in core to use relative links instead of intra-doc links. This doesn't use purely intra-doc links because some of the primitive docs links to items only in std; this doesn't use purely relative links because that introduces new broken links when the docs are re-exported (e.g. String's `&str` deref impl, or Vec's slice deref impl).\n\nNote that this copies the whole file to core, to avoid anyone compiling core to have to set `CARGO_PKG_NAME`. See https://rust-lang.zulipchat.com/#narrow/stream/122651-general/topic/Who.20should.20review.20changes.20to.20linkchecker.3F/near/249939598 for more context. It also adds a tidy check to make sure the two files are kept in sync.\n\n### Fix inconsistent online/offline primitive docs\n\nThis does four things:\n- Records modules with `doc(primitive)` in `cache.external_paths`. This is necessary for `href()` to find them later.\n- Makes `cache.primitive_locations` available to the intra-doc link pass, by refactoring out a `PrimitiveType::primitive_locations` function that only uses `TyCtxt`.\n- Special cases modules with `doc(primitive)` to be treated as always public for the purpose of links.\n- Removes the fragment hack. cc `@notriddle,` I know you added some comments about this in the code (thank you for that!)\n\n### Breaking changes to `doc(primitive)`\n\n\"Breaking\" is a little misleading here - these are changes in behavior, none of them will cause code to fail to compile.\n\nLet me preface this by saying I think stabilizing `doc(primitive)` was a uniquely terrible idea. As far as I can tell, it was stabilized by oversight; it's been stable since 1.0. No one should have need to use it except the standard library, and a crater run shows that in fact no one is using it: https://github.com/rust-lang/rust/pull/87050#issuecomment-886166706. I hope to actually make `doc(primitive)` a no-op unless you opt-in with a nightly feature, which will keep crates compiling without forcing rustdoc into trying to keep somewhat arbitrary behavior guarantees; but for now, this just subtly changes some of the behavior if you use `doc(primitive)` in a dependency.\n\nThat said, here are the changes:\n-  Refactoring out `primitive_locations()` is technically a change in behavior, since it no longer looks for primitives in crates that were passed through `--extern`, but not used by the crate; however, that seems like such an unlikely edge case it's not worth dealing with.\n- The precedence given to primitive locations is no longer just arbitrary, it can also be inconsistent from run to run. Let me explain that more: previously, primitive locations were sorted by the `CrateNum`; the comment on that sort said \"Favor linking to as local extern as possible, so iterate all crates in reverse topological order.\" Unfortunately, that's not actually what CrateNum tracks: it measures the order crates are loaded, not the number of intermediate crates between that dependency and the root crate. It happened to work as intended before because the compiler injects `extern crate std;` at the top of every crate, which ensured it would have the first CrateNum other than the current, but every other CrateNum was completely arbitrary (for example, `core` often had a later CrateNum than `std`). This now removes the sort on CrateNum completely and special-cases core instead. In particular, if you depend on both `std` and a crate which defines a `doc(primitive)` module, it's arbitrary whether rustdoc will use the docs from std or the ones from the other crate. cc `@alexcrichton,` you wrote this originally.\n\ncc `@rust-lang/rustdoc`\ncc `@rust-lang/libs` for the addition to `core` (the commit you're interested in is https://github.com/rust-lang/rust/pull/87073/commits/91346c8293bb5f41d8e1d2ec9336433664652c53)", "tree": {"sha": "d3913a82bf6e5be22d9d2d229ef2ae35105f0e28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3913a82bf6e5be22d9d2d229ef2ae35105f0e28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0273e3bce7a0ce49e96a9662163e2380cb87e0be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0273e3bce7a0ce49e96a9662163e2380cb87e0be", "html_url": "https://github.com/rust-lang/rust/commit/0273e3bce7a0ce49e96a9662163e2380cb87e0be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0273e3bce7a0ce49e96a9662163e2380cb87e0be/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "547d9374d26f203ab963b3ffe1ed36bd70f16633", "url": "https://api.github.com/repos/rust-lang/rust/commits/547d9374d26f203ab963b3ffe1ed36bd70f16633", "html_url": "https://github.com/rust-lang/rust/commit/547d9374d26f203ab963b3ffe1ed36bd70f16633"}, {"sha": "86fd2505c2e10fa27a49a81978cdcbabebb581a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/86fd2505c2e10fa27a49a81978cdcbabebb581a1", "html_url": "https://github.com/rust-lang/rust/commit/86fd2505c2e10fa27a49a81978cdcbabebb581a1"}], "stats": {"total": 1807, "additions": 1596, "deletions": 211}, "files": [{"sha": "9dd0344c7c7b1c615993b70d6708fd549ba96ad2", "filename": "library/core/primitive_docs/box_into_raw.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fcore%2Fprimitive_docs%2Fbox_into_raw.md", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fcore%2Fprimitive_docs%2Fbox_into_raw.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fprimitive_docs%2Fbox_into_raw.md?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -0,0 +1 @@\n+../std/boxed/struct.Box.html#method.into_raw"}, {"sha": "4023e340a51829d9c5b9bd36b72922d746ae0d96", "filename": "library/core/primitive_docs/fs_file.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fcore%2Fprimitive_docs%2Ffs_file.md", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fcore%2Fprimitive_docs%2Ffs_file.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fprimitive_docs%2Ffs_file.md?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -0,0 +1 @@\n+../std/fs/struct.File.html"}, {"sha": "7beda2cd39085ff19666391bf3ba0cc5a3e3a7da", "filename": "library/core/primitive_docs/io_bufread.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fcore%2Fprimitive_docs%2Fio_bufread.md", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fcore%2Fprimitive_docs%2Fio_bufread.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fprimitive_docs%2Fio_bufread.md?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -0,0 +1 @@\n+../std/io/trait.BufRead.html"}, {"sha": "b7ecf5e273cea7bca8bbabee623f9fc390a3dfbb", "filename": "library/core/primitive_docs/io_read.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fcore%2Fprimitive_docs%2Fio_read.md", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fcore%2Fprimitive_docs%2Fio_read.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fprimitive_docs%2Fio_read.md?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -0,0 +1 @@\n+../std/io/trait.Read.html"}, {"sha": "db0274d291c6f1567805ef557b4a004132fffda7", "filename": "library/core/primitive_docs/io_seek.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fcore%2Fprimitive_docs%2Fio_seek.md", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fcore%2Fprimitive_docs%2Fio_seek.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fprimitive_docs%2Fio_seek.md?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -0,0 +1 @@\n+../std/io/trait.Seek.html"}, {"sha": "92a3b88a79c9c87d1dbb99af3ee8de6acf90c32f", "filename": "library/core/primitive_docs/io_write.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fcore%2Fprimitive_docs%2Fio_write.md", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fcore%2Fprimitive_docs%2Fio_write.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fprimitive_docs%2Fio_write.md?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -0,0 +1 @@\n+../std/io/trait.Write.html"}, {"sha": "4daa10ddbe2b2b0b78b91fb12af56699bbfbeff4", "filename": "library/core/primitive_docs/net_tosocketaddrs.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fcore%2Fprimitive_docs%2Fnet_tosocketaddrs.md", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fcore%2Fprimitive_docs%2Fnet_tosocketaddrs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fprimitive_docs%2Fnet_tosocketaddrs.md?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -0,0 +1 @@\n+../std/net/trait.ToSocketAddrs.html"}, {"sha": "cae34d12d5249c6f72fecf85b68321c08651db20", "filename": "library/core/primitive_docs/process_exit.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fcore%2Fprimitive_docs%2Fprocess_exit.md", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fcore%2Fprimitive_docs%2Fprocess_exit.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fprimitive_docs%2Fprocess_exit.md?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -0,0 +1 @@\n+../std/process/fn.exit.html"}, {"sha": "303dc07b1855df6df4c5743682362da1333febe0", "filename": "library/core/primitive_docs/string_string.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fcore%2Fprimitive_docs%2Fstring_string.md", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fcore%2Fprimitive_docs%2Fstring_string.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fprimitive_docs%2Fstring_string.md?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -0,0 +1 @@\n+../std/string/struct.String.html"}, {"sha": "f14c2a4641627ec4378bad32c91e0b129bd6bbc7", "filename": "library/core/src/bool.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fcore%2Fsrc%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fcore%2Fsrc%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fbool.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -2,7 +2,8 @@\n \n #[lang = \"bool\"]\n impl bool {\n-    /// Returns `Some(t)` if the `bool` is [`true`](keyword.true.html), or `None` otherwise.\n+    /// Returns `Some(t)` if the `bool` is [`true`](../std/keyword.true.html),\n+    /// or `None` otherwise.\n     ///\n     /// # Examples\n     ///\n@@ -18,7 +19,8 @@ impl bool {\n         if self { Some(t) } else { None }\n     }\n \n-    /// Returns `Some(f())` if the `bool` is [`true`](keyword.true.html), or `None` otherwise.\n+    /// Returns `Some(f())` if the `bool` is [`true`](../std/keyword.true.html),\n+    /// or `None` otherwise.\n     ///\n     /// # Examples\n     ///"}, {"sha": "b1dd6aef97493e13500ce026a614005a1ee7c779", "filename": "library/core/src/char/methods.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -24,7 +24,7 @@ impl char {\n     /// decoding error.\n     ///\n     /// It can occur, for example, when giving ill-formed UTF-8 bytes to\n-    /// [`String::from_utf8_lossy`](string/struct.String.html#method.from_utf8_lossy).\n+    /// [`String::from_utf8_lossy`](../std/string/struct.String.html#method.from_utf8_lossy).\n     #[stable(feature = \"assoc_char_consts\", since = \"1.52.0\")]\n     pub const REPLACEMENT_CHARACTER: char = '\\u{FFFD}';\n \n@@ -96,7 +96,7 @@ impl char {\n     /// Converts a `u32` to a `char`.\n     ///\n     /// Note that all `char`s are valid [`u32`]s, and can be cast to one with\n-    /// [`as`](keyword.as.html):\n+    /// [`as`](../std/keyword.as.html):\n     ///\n     /// ```\n     /// let c = '\ud83d\udcaf';\n@@ -372,7 +372,7 @@ impl char {\n     /// println!(\"\\\\u{{2764}}\");\n     /// ```\n     ///\n-    /// Using [`to_string`](string/trait.ToString.html#tymethod.to_string):\n+    /// Using [`to_string`](../std/string/trait.ToString.html#tymethod.to_string):\n     ///\n     /// ```\n     /// assert_eq!('\u2764'.escape_unicode().to_string(), \"\\\\u{2764}\");\n@@ -448,7 +448,7 @@ impl char {\n     /// println!(\"\\\\n\");\n     /// ```\n     ///\n-    /// Using [`to_string`](string/trait.ToString.html#tymethod.to_string):\n+    /// Using [`to_string`](../std/string/trait.ToString.html#tymethod.to_string):\n     ///\n     /// ```\n     /// assert_eq!('\\n'.escape_debug().to_string(), \"\\\\n\");\n@@ -502,7 +502,7 @@ impl char {\n     /// println!(\"\\\\\\\"\");\n     /// ```\n     ///\n-    /// Using [`to_string`](string/trait.ToString.html#tymethod.to_string):\n+    /// Using [`to_string`](../std/string/trait.ToString.html#tymethod.to_string):\n     ///\n     /// ```\n     /// assert_eq!('\"'.escape_default().to_string(), \"\\\\\\\"\");\n@@ -937,7 +937,7 @@ impl char {\n     /// println!(\"i\\u{307}\");\n     /// ```\n     ///\n-    /// Using [`to_string`](string/trait.ToString.html#tymethod.to_string):\n+    /// Using [`to_string`](../std/string/trait.ToString.html#tymethod.to_string):\n     ///\n     /// ```\n     /// assert_eq!('C'.to_lowercase().to_string(), \"c\");\n@@ -1002,7 +1002,7 @@ impl char {\n     /// println!(\"SS\");\n     /// ```\n     ///\n-    /// Using [`to_string`](string/trait.ToString.html#tymethod.to_string):\n+    /// Using [`to_string`](../std/string/trait.ToString.html#tymethod.to_string):\n     ///\n     /// ```\n     /// assert_eq!('c'.to_uppercase().to_string(), \"C\");"}, {"sha": "265ba9f1bb91b69d1fc9c2b162b4a18a03db34d9", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -130,6 +130,7 @@\n #![feature(decl_macro)]\n #![feature(doc_cfg)]\n #![feature(doc_notable_trait)]\n+#![feature(doc_primitive)]\n #![feature(exhaustive_patterns)]\n #![feature(extern_types)]\n #![feature(fundamental)]\n@@ -355,3 +356,5 @@ pub mod arch {\n         /* compiler built-in */\n     }\n }\n+\n+include!(\"primitive_docs.rs\");"}, {"sha": "0de9126dab2fe5679ea2390903a0c1e3293e59a4", "filename": "library/core/src/primitive_docs.rs", "status": "added", "additions": 1307, "deletions": 0, "changes": 1307, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprimitive_docs.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -0,0 +1,1307 @@\n+// `library/{std,core}/src/primitive_docs.rs` should have the same contents.\n+// These are different files so that relative links work properly without\n+// having to have `CARGO_PKG_NAME` set, but conceptually they should always be the same.\n+#[doc(primitive = \"bool\")]\n+#[doc(alias = \"true\")]\n+#[doc(alias = \"false\")]\n+/// The boolean type.\n+///\n+/// The `bool` represents a value, which could only be either [`true`] or [`false`]. If you cast\n+/// a `bool` into an integer, [`true`] will be 1 and [`false`] will be 0.\n+///\n+/// # Basic usage\n+///\n+/// `bool` implements various traits, such as [`BitAnd`], [`BitOr`], [`Not`], etc.,\n+/// which allow us to perform boolean operations using `&`, `|` and `!`.\n+///\n+/// [`if`] requires a `bool` value as its conditional. [`assert!`], which is an\n+/// important macro in testing, checks whether an expression is [`true`] and panics\n+/// if it isn't.\n+///\n+/// ```\n+/// let bool_val = true & false | false;\n+/// assert!(!bool_val);\n+/// ```\n+///\n+/// [`true`]: ../std/keyword.true.html\n+/// [`false`]: ../std/keyword.false.html\n+/// [`BitAnd`]: ops::BitAnd\n+/// [`BitOr`]: ops::BitOr\n+/// [`Not`]: ops::Not\n+/// [`if`]: ../std/keyword.if.html\n+///\n+/// # Examples\n+///\n+/// A trivial example of the usage of `bool`:\n+///\n+/// ```\n+/// let praise_the_borrow_checker = true;\n+///\n+/// // using the `if` conditional\n+/// if praise_the_borrow_checker {\n+///     println!(\"oh, yeah!\");\n+/// } else {\n+///     println!(\"what?!!\");\n+/// }\n+///\n+/// // ... or, a match pattern\n+/// match praise_the_borrow_checker {\n+///     true => println!(\"keep praising!\"),\n+///     false => println!(\"you should praise!\"),\n+/// }\n+/// ```\n+///\n+/// Also, since `bool` implements the [`Copy`] trait, we don't\n+/// have to worry about the move semantics (just like the integer and float primitives).\n+///\n+/// Now an example of `bool` cast to integer type:\n+///\n+/// ```\n+/// assert_eq!(true as i32, 1);\n+/// assert_eq!(false as i32, 0);\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_bool {}\n+\n+#[doc(primitive = \"never\")]\n+#[doc(alias = \"!\")]\n+//\n+/// The `!` type, also called \"never\".\n+///\n+/// `!` represents the type of computations which never resolve to any value at all. For example,\n+/// the [`exit`] function `fn exit(code: i32) -> !` exits the process without ever returning, and\n+/// so returns `!`.\n+///\n+/// `break`, `continue` and `return` expressions also have type `!`. For example we are allowed to\n+/// write:\n+///\n+/// ```\n+/// #![feature(never_type)]\n+/// # fn foo() -> u32 {\n+/// let x: ! = {\n+///     return 123\n+/// };\n+/// # }\n+/// ```\n+///\n+/// Although the `let` is pointless here, it illustrates the meaning of `!`. Since `x` is never\n+/// assigned a value (because `return` returns from the entire function), `x` can be given type\n+/// `!`. We could also replace `return 123` with a `panic!` or a never-ending `loop` and this code\n+/// would still be valid.\n+///\n+/// A more realistic usage of `!` is in this code:\n+///\n+/// ```\n+/// # fn get_a_number() -> Option<u32> { None }\n+/// # loop {\n+/// let num: u32 = match get_a_number() {\n+///     Some(num) => num,\n+///     None => break,\n+/// };\n+/// # }\n+/// ```\n+///\n+/// Both match arms must produce values of type [`u32`], but since `break` never produces a value\n+/// at all we know it can never produce a value which isn't a [`u32`]. This illustrates another\n+/// behaviour of the `!` type - expressions with type `!` will coerce into any other type.\n+///\n+/// [`u32`]: prim@u32\n+#[doc = concat!(\"[`exit`]: \", include_str!(\"../primitive_docs/process_exit.md\"))]\n+///\n+/// # `!` and generics\n+///\n+/// ## Infallible errors\n+///\n+/// The main place you'll see `!` used explicitly is in generic code. Consider the [`FromStr`]\n+/// trait:\n+///\n+/// ```\n+/// trait FromStr: Sized {\n+///     type Err;\n+///     fn from_str(s: &str) -> Result<Self, Self::Err>;\n+/// }\n+/// ```\n+///\n+/// When implementing this trait for [`String`] we need to pick a type for [`Err`]. And since\n+/// converting a string into a string will never result in an error, the appropriate type is `!`.\n+/// (Currently the type actually used is an enum with no variants, though this is only because `!`\n+/// was added to Rust at a later date and it may change in the future.) With an [`Err`] type of\n+/// `!`, if we have to call [`String::from_str`] for some reason the result will be a\n+/// [`Result<String, !>`] which we can unpack like this:\n+///\n+/// ```\n+/// #![feature(exhaustive_patterns)]\n+/// use std::str::FromStr;\n+/// let Ok(s) = String::from_str(\"hello\");\n+/// ```\n+///\n+/// Since the [`Err`] variant contains a `!`, it can never occur. If the `exhaustive_patterns`\n+/// feature is present this means we can exhaustively match on [`Result<T, !>`] by just taking the\n+/// [`Ok`] variant. This illustrates another behaviour of `!` - it can be used to \"delete\" certain\n+/// enum variants from generic types like `Result`.\n+///\n+/// ## Infinite loops\n+///\n+/// While [`Result<T, !>`] is very useful for removing errors, `!` can also be used to remove\n+/// successes as well. If we think of [`Result<T, !>`] as \"if this function returns, it has not\n+/// errored,\" we get a very intuitive idea of [`Result<!, E>`] as well: if the function returns, it\n+/// *has* errored.\n+///\n+/// For example, consider the case of a simple web server, which can be simplified to:\n+///\n+/// ```ignore (hypothetical-example)\n+/// loop {\n+///     let (client, request) = get_request().expect(\"disconnected\");\n+///     let response = request.process();\n+///     response.send(client);\n+/// }\n+/// ```\n+///\n+/// Currently, this isn't ideal, because we simply panic whenever we fail to get a new connection.\n+/// Instead, we'd like to keep track of this error, like this:\n+///\n+/// ```ignore (hypothetical-example)\n+/// loop {\n+///     match get_request() {\n+///         Err(err) => break err,\n+///         Ok((client, request)) => {\n+///             let response = request.process();\n+///             response.send(client);\n+///         },\n+///     }\n+/// }\n+/// ```\n+///\n+/// Now, when the server disconnects, we exit the loop with an error instead of panicking. While it\n+/// might be intuitive to simply return the error, we might want to wrap it in a [`Result<!, E>`]\n+/// instead:\n+///\n+/// ```ignore (hypothetical-example)\n+/// fn server_loop() -> Result<!, ConnectionError> {\n+///     loop {\n+///         let (client, request) = get_request()?;\n+///         let response = request.process();\n+///         response.send(client);\n+///     }\n+/// }\n+/// ```\n+///\n+/// Now, we can use `?` instead of `match`, and the return type makes a lot more sense: if the loop\n+/// ever stops, it means that an error occurred. We don't even have to wrap the loop in an `Ok`\n+/// because `!` coerces to `Result<!, ConnectionError>` automatically.\n+///\n+/// [`String::from_str`]: str::FromStr::from_str\n+#[doc = concat!(\"[`String`]: \", include_str!(\"../primitive_docs/string_string.md\"))]\n+/// [`FromStr`]: str::FromStr\n+///\n+/// # `!` and traits\n+///\n+/// When writing your own traits, `!` should have an `impl` whenever there is an obvious `impl`\n+/// which doesn't `panic!`. The reason is that functions returning an `impl Trait` where `!`\n+/// does not have an `impl` of `Trait` cannot diverge as their only possible code path. In other\n+/// words, they can't return `!` from every code path. As an example, this code doesn't compile:\n+///\n+/// ```compile_fail\n+/// use std::ops::Add;\n+///\n+/// fn foo() -> impl Add<u32> {\n+///     unimplemented!()\n+/// }\n+/// ```\n+///\n+/// But this code does:\n+///\n+/// ```\n+/// use std::ops::Add;\n+///\n+/// fn foo() -> impl Add<u32> {\n+///     if true {\n+///         unimplemented!()\n+///     } else {\n+///         0\n+///     }\n+/// }\n+/// ```\n+///\n+/// The reason is that, in the first example, there are many possible types that `!` could coerce\n+/// to, because many types implement `Add<u32>`. However, in the second example,\n+/// the `else` branch returns a `0`, which the compiler infers from the return type to be of type\n+/// `u32`. Since `u32` is a concrete type, `!` can and will be coerced to it. See issue [#36375]\n+/// for more information on this quirk of `!`.\n+///\n+/// [#36375]: https://github.com/rust-lang/rust/issues/36375\n+///\n+/// As it turns out, though, most traits can have an `impl` for `!`. Take [`Debug`]\n+/// for example:\n+///\n+/// ```\n+/// #![feature(never_type)]\n+/// # use std::fmt;\n+/// # trait Debug {\n+/// #     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result;\n+/// # }\n+/// impl Debug for ! {\n+///     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+///         *self\n+///     }\n+/// }\n+/// ```\n+///\n+/// Once again we're using `!`'s ability to coerce into any other type, in this case\n+/// [`fmt::Result`]. Since this method takes a `&!` as an argument we know that it can never be\n+/// called (because there is no value of type `!` for it to be called with). Writing `*self`\n+/// essentially tells the compiler \"We know that this code can never be run, so just treat the\n+/// entire function body as having type [`fmt::Result`]\". This pattern can be used a lot when\n+/// implementing traits for `!`. Generally, any trait which only has methods which take a `self`\n+/// parameter should have such an impl.\n+///\n+/// On the other hand, one trait which would not be appropriate to implement is [`Default`]:\n+///\n+/// ```\n+/// trait Default {\n+///     fn default() -> Self;\n+/// }\n+/// ```\n+///\n+/// Since `!` has no values, it has no default value either. It's true that we could write an\n+/// `impl` for this which simply panics, but the same is true for any type (we could `impl\n+/// Default` for (eg.) [`File`] by just making [`default()`] panic.)\n+///\n+#[doc = concat!(\"[`File`]: \", include_str!(\"../primitive_docs/fs_file.md\"))]\n+/// [`Debug`]: fmt::Debug\n+/// [`default()`]: Default::default\n+///\n+#[unstable(feature = \"never_type\", issue = \"35121\")]\n+mod prim_never {}\n+\n+#[doc(primitive = \"char\")]\n+/// A character type.\n+///\n+/// The `char` type represents a single character. More specifically, since\n+/// 'character' isn't a well-defined concept in Unicode, `char` is a '[Unicode\n+/// scalar value]', which is similar to, but not the same as, a '[Unicode code\n+/// point]'.\n+///\n+/// [Unicode scalar value]: https://www.unicode.org/glossary/#unicode_scalar_value\n+/// [Unicode code point]: https://www.unicode.org/glossary/#code_point\n+///\n+/// This documentation describes a number of methods and trait implementations on the\n+/// `char` type. For technical reasons, there is additional, separate\n+/// documentation in [the `std::char` module](char/index.html) as well.\n+///\n+/// # Representation\n+///\n+/// `char` is always four bytes in size. This is a different representation than\n+/// a given character would have as part of a [`String`]. For example:\n+///\n+/// ```\n+/// let v = vec!['h', 'e', 'l', 'l', 'o'];\n+///\n+/// // five elements times four bytes for each element\n+/// assert_eq!(20, v.len() * std::mem::size_of::<char>());\n+///\n+/// let s = String::from(\"hello\");\n+///\n+/// // five elements times one byte per element\n+/// assert_eq!(5, s.len() * std::mem::size_of::<u8>());\n+/// ```\n+///\n+#[doc = concat!(\"[`String`]: \", include_str!(\"../primitive_docs/string_string.md\"))]\n+///\n+/// As always, remember that a human intuition for 'character' might not map to\n+/// Unicode's definitions. For example, despite looking similar, the '\u00e9'\n+/// character is one Unicode code point while 'e\u0301' is two Unicode code points:\n+///\n+/// ```\n+/// let mut chars = \"\u00e9\".chars();\n+/// // U+00e9: 'latin small letter e with acute'\n+/// assert_eq!(Some('\\u{00e9}'), chars.next());\n+/// assert_eq!(None, chars.next());\n+///\n+/// let mut chars = \"e\u0301\".chars();\n+/// // U+0065: 'latin small letter e'\n+/// assert_eq!(Some('\\u{0065}'), chars.next());\n+/// // U+0301: 'combining acute accent'\n+/// assert_eq!(Some('\\u{0301}'), chars.next());\n+/// assert_eq!(None, chars.next());\n+/// ```\n+///\n+/// This means that the contents of the first string above _will_ fit into a\n+/// `char` while the contents of the second string _will not_. Trying to create\n+/// a `char` literal with the contents of the second string gives an error:\n+///\n+/// ```text\n+/// error: character literal may only contain one codepoint: 'e\u0301'\n+/// let c = 'e\u0301';\n+///         ^^^\n+/// ```\n+///\n+/// Another implication of the 4-byte fixed size of a `char` is that\n+/// per-`char` processing can end up using a lot more memory:\n+///\n+/// ```\n+/// let s = String::from(\"love: \u2764\ufe0f\");\n+/// let v: Vec<char> = s.chars().collect();\n+///\n+/// assert_eq!(12, std::mem::size_of_val(&s[..]));\n+/// assert_eq!(32, std::mem::size_of_val(&v[..]));\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_char {}\n+\n+#[doc(primitive = \"unit\")]\n+#[doc(alias = \"(\")]\n+#[doc(alias = \")\")]\n+#[doc(alias = \"()\")]\n+//\n+/// The `()` type, also called \"unit\".\n+///\n+/// The `()` type has exactly one value `()`, and is used when there\n+/// is no other meaningful value that could be returned. `()` is most\n+/// commonly seen implicitly: functions without a `-> ...` implicitly\n+/// have return type `()`, that is, these are equivalent:\n+///\n+/// ```rust\n+/// fn long() -> () {}\n+///\n+/// fn short() {}\n+/// ```\n+///\n+/// The semicolon `;` can be used to discard the result of an\n+/// expression at the end of a block, making the expression (and thus\n+/// the block) evaluate to `()`. For example,\n+///\n+/// ```rust\n+/// fn returns_i64() -> i64 {\n+///     1i64\n+/// }\n+/// fn returns_unit() {\n+///     1i64;\n+/// }\n+///\n+/// let is_i64 = {\n+///     returns_i64()\n+/// };\n+/// let is_unit = {\n+///     returns_i64();\n+/// };\n+/// ```\n+///\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_unit {}\n+\n+#[doc(primitive = \"pointer\")]\n+#[doc(alias = \"ptr\")]\n+#[doc(alias = \"*\")]\n+#[doc(alias = \"*const\")]\n+#[doc(alias = \"*mut\")]\n+//\n+/// Raw, unsafe pointers, `*const T`, and `*mut T`.\n+///\n+/// *[See also the `std::ptr` module](ptr).*\n+///\n+/// Working with raw pointers in Rust is uncommon, typically limited to a few patterns.\n+/// Raw pointers can be unaligned or [`null`]. However, when a raw pointer is\n+/// dereferenced (using the `*` operator), it must be non-null and aligned.\n+///\n+/// Storing through a raw pointer using `*ptr = data` calls `drop` on the old value, so\n+/// [`write`] must be used if the type has drop glue and memory is not already\n+/// initialized - otherwise `drop` would be called on the uninitialized memory.\n+///\n+/// Use the [`null`] and [`null_mut`] functions to create null pointers, and the\n+/// [`is_null`] method of the `*const T` and `*mut T` types to check for null.\n+/// The `*const T` and `*mut T` types also define the [`offset`] method, for\n+/// pointer math.\n+///\n+/// # Common ways to create raw pointers\n+///\n+/// ## 1. Coerce a reference (`&T`) or mutable reference (`&mut T`).\n+///\n+/// ```\n+/// let my_num: i32 = 10;\n+/// let my_num_ptr: *const i32 = &my_num;\n+/// let mut my_speed: i32 = 88;\n+/// let my_speed_ptr: *mut i32 = &mut my_speed;\n+/// ```\n+///\n+/// To get a pointer to a boxed value, dereference the box:\n+///\n+/// ```\n+/// let my_num: Box<i32> = Box::new(10);\n+/// let my_num_ptr: *const i32 = &*my_num;\n+/// let mut my_speed: Box<i32> = Box::new(88);\n+/// let my_speed_ptr: *mut i32 = &mut *my_speed;\n+/// ```\n+///\n+/// This does not take ownership of the original allocation\n+/// and requires no resource management later,\n+/// but you must not use the pointer after its lifetime.\n+///\n+/// ## 2. Consume a box (`Box<T>`).\n+///\n+/// The [`into_raw`] function consumes a box and returns\n+/// the raw pointer. It doesn't destroy `T` or deallocate any memory.\n+///\n+/// ```\n+/// let my_speed: Box<i32> = Box::new(88);\n+/// let my_speed: *mut i32 = Box::into_raw(my_speed);\n+///\n+/// // By taking ownership of the original `Box<T>` though\n+/// // we are obligated to put it together later to be destroyed.\n+/// unsafe {\n+///     drop(Box::from_raw(my_speed));\n+/// }\n+/// ```\n+///\n+/// Note that here the call to [`drop`] is for clarity - it indicates\n+/// that we are done with the given value and it should be destroyed.\n+///\n+/// ## 3. Create it using `ptr::addr_of!`\n+///\n+/// Instead of coercing a reference to a raw pointer, you can use the macros\n+/// [`ptr::addr_of!`] (for `*const T`) and [`ptr::addr_of_mut!`] (for `*mut T`).\n+/// These macros allow you to create raw pointers to fields to which you cannot\n+/// create a reference (without causing undefined behaviour), such as an\n+/// unaligned field. This might be necessary if packed structs or uninitialized\n+/// memory is involved.\n+///\n+/// ```\n+/// #[derive(Debug, Default, Copy, Clone)]\n+/// #[repr(C, packed)]\n+/// struct S {\n+///     aligned: u8,\n+///     unaligned: u32,\n+/// }\n+/// let s = S::default();\n+/// let p = std::ptr::addr_of!(s.unaligned); // not allowed with coercion\n+/// ```\n+///\n+/// ## 4. Get it from C.\n+///\n+/// ```\n+/// # #![feature(rustc_private)]\n+/// extern crate libc;\n+///\n+/// use std::mem;\n+///\n+/// unsafe {\n+///     let my_num: *mut i32 = libc::malloc(mem::size_of::<i32>()) as *mut i32;\n+///     if my_num.is_null() {\n+///         panic!(\"failed to allocate memory\");\n+///     }\n+///     libc::free(my_num as *mut libc::c_void);\n+/// }\n+/// ```\n+///\n+/// Usually you wouldn't literally use `malloc` and `free` from Rust,\n+/// but C APIs hand out a lot of pointers generally, so are a common source\n+/// of raw pointers in Rust.\n+///\n+/// [`null`]: ptr::null\n+/// [`null_mut`]: ptr::null_mut\n+/// [`is_null`]: pointer::is_null\n+/// [`offset`]: pointer::offset\n+#[doc = concat!(\"[`into_raw`]: \", include_str!(\"../primitive_docs/box_into_raw.md\"))]\n+/// [`drop`]: mem::drop\n+/// [`write`]: ptr::write\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_pointer {}\n+\n+#[doc(primitive = \"array\")]\n+#[doc(alias = \"[]\")]\n+#[doc(alias = \"[T;N]\")] // unfortunately, rustdoc doesn't have fuzzy search for aliases\n+#[doc(alias = \"[T; N]\")]\n+/// A fixed-size array, denoted `[T; N]`, for the element type, `T`, and the\n+/// non-negative compile-time constant size, `N`.\n+///\n+/// There are two syntactic forms for creating an array:\n+///\n+/// * A list with each element, i.e., `[x, y, z]`.\n+/// * A repeat expression `[x; N]`, which produces an array with `N` copies of `x`.\n+///   The type of `x` must be [`Copy`].\n+///\n+/// Note that `[expr; 0]` is allowed, and produces an empty array.\n+/// This will still evaluate `expr`, however, and immediately drop the resulting value, so\n+/// be mindful of side effects.\n+///\n+/// Arrays of *any* size implement the following traits if the element type allows it:\n+///\n+/// - [`Copy`]\n+/// - [`Clone`]\n+/// - [`Debug`]\n+/// - [`IntoIterator`] (implemented for `[T; N]`, `&[T; N]` and `&mut [T; N]`)\n+/// - [`PartialEq`], [`PartialOrd`], [`Eq`], [`Ord`]\n+/// - [`Hash`]\n+/// - [`AsRef`], [`AsMut`]\n+/// - [`Borrow`], [`BorrowMut`]\n+///\n+/// Arrays of sizes from 0 to 32 (inclusive) implement the [`Default`] trait\n+/// if the element type allows it. As a stopgap, trait implementations are\n+/// statically generated up to size 32.\n+///\n+/// Arrays coerce to [slices (`[T]`)][slice], so a slice method may be called on\n+/// an array. Indeed, this provides most of the API for working with arrays.\n+/// Slices have a dynamic size and do not coerce to arrays.\n+///\n+/// You can move elements out of an array with a [slice pattern]. If you want\n+/// one element, see [`mem::replace`].\n+///\n+/// # Examples\n+///\n+/// ```\n+/// let mut array: [i32; 3] = [0; 3];\n+///\n+/// array[1] = 1;\n+/// array[2] = 2;\n+///\n+/// assert_eq!([1, 2], &array[1..]);\n+///\n+/// // This loop prints: 0 1 2\n+/// for x in array {\n+///     print!(\"{} \", x);\n+/// }\n+/// ```\n+///\n+/// You can also iterate over reference to the array's elements:\n+///\n+/// ```\n+/// let array: [i32; 3] = [0; 3];\n+///\n+/// for x in &array { }\n+/// ```\n+///\n+/// You can use a [slice pattern] to move elements out of an array:\n+///\n+/// ```\n+/// fn move_away(_: String) { /* Do interesting things. */ }\n+///\n+/// let [john, roa] = [\"John\".to_string(), \"Roa\".to_string()];\n+/// move_away(john);\n+/// move_away(roa);\n+/// ```\n+///\n+/// # Editions\n+///\n+/// Prior to Rust 1.53, arrays did not implement [`IntoIterator`] by value, so the method call\n+/// `array.into_iter()` auto-referenced into a [slice iterator](slice::iter). Right now, the old\n+/// behavior is preserved in the 2015 and 2018 editions of Rust for compatibility, ignoring\n+/// [`IntoIterator`] by value. In the future, the behavior on the 2015 and 2018 edition\n+/// might be made consistent to the behavior of later editions.\n+///\n+/// ```rust,edition2018\n+/// // Rust 2015 and 2018:\n+///\n+/// # #![allow(array_into_iter)] // override our `deny(warnings)`\n+/// let array: [i32; 3] = [0; 3];\n+///\n+/// // This creates a slice iterator, producing references to each value.\n+/// for item in array.into_iter().enumerate() {\n+///     let (i, x): (usize, &i32) = item;\n+///     println!(\"array[{}] = {}\", i, x);\n+/// }\n+///\n+/// // The `array_into_iter` lint suggests this change for future compatibility:\n+/// for item in array.iter().enumerate() {\n+///     let (i, x): (usize, &i32) = item;\n+///     println!(\"array[{}] = {}\", i, x);\n+/// }\n+///\n+/// // You can explicitly iterate an array by value using\n+/// // `IntoIterator::into_iter` or `std::array::IntoIter::new`:\n+/// for item in IntoIterator::into_iter(array).enumerate() {\n+///     let (i, x): (usize, i32) = item;\n+///     println!(\"array[{}] = {}\", i, x);\n+/// }\n+/// ```\n+///\n+/// Starting in the 2021 edition, `array.into_iter()` uses `IntoIterator` normally to iterate\n+/// by value, and `iter()` should be used to iterate by reference like previous editions.\n+///\n+/// ```rust,edition2021\n+/// // Rust 2021:\n+///\n+/// let array: [i32; 3] = [0; 3];\n+///\n+/// // This iterates by reference:\n+/// for item in array.iter().enumerate() {\n+///     let (i, x): (usize, &i32) = item;\n+///     println!(\"array[{}] = {}\", i, x);\n+/// }\n+///\n+/// // This iterates by value:\n+/// for item in array.into_iter().enumerate() {\n+///     let (i, x): (usize, i32) = item;\n+///     println!(\"array[{}] = {}\", i, x);\n+/// }\n+/// ```\n+///\n+/// Future language versions might start treating the `array.into_iter()`\n+/// syntax on editions 2015 and 2018 the same as on edition 2021. So code using\n+/// those older editions should still be written with this change in mind, to\n+/// prevent breakage in the future. The safest way to accomplish this is to\n+/// avoid the `into_iter` syntax on those editions. If an edition update is not\n+/// viable/desired, there are multiple alternatives:\n+/// * use `iter`, equivalent to the old behavior, creating references\n+/// * use [`IntoIterator::into_iter`], equivalent to the post-2021 behavior (Rust 1.53+)\n+/// * replace `for ... in array.into_iter() {` with `for ... in array {`,\n+///   equivalent to the post-2021 behavior (Rust 1.53+)\n+///\n+/// ```rust,edition2018\n+/// // Rust 2015 and 2018:\n+///\n+/// let array: [i32; 3] = [0; 3];\n+///\n+/// // This iterates by reference:\n+/// for item in array.iter() {\n+///     let x: &i32 = item;\n+///     println!(\"{}\", x);\n+/// }\n+///\n+/// // This iterates by value:\n+/// for item in IntoIterator::into_iter(array) {\n+///     let x: i32 = item;\n+///     println!(\"{}\", x);\n+/// }\n+///\n+/// // This iterates by value:\n+/// for item in array {\n+///     let x: i32 = item;\n+///     println!(\"{}\", x);\n+/// }\n+///\n+/// // IntoIter can also start a chain.\n+/// // This iterates by value:\n+/// for item in IntoIterator::into_iter(array).enumerate() {\n+///     let (i, x): (usize, i32) = item;\n+///     println!(\"array[{}] = {}\", i, x);\n+/// }\n+/// ```\n+///\n+/// [slice]: prim@slice\n+/// [`Debug`]: fmt::Debug\n+/// [`Hash`]: hash::Hash\n+/// [`Borrow`]: borrow::Borrow\n+/// [`BorrowMut`]: borrow::BorrowMut\n+/// [slice pattern]: ../reference/patterns.html#slice-patterns\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_array {}\n+\n+#[doc(primitive = \"slice\")]\n+#[doc(alias = \"[\")]\n+#[doc(alias = \"]\")]\n+#[doc(alias = \"[]\")]\n+/// A dynamically-sized view into a contiguous sequence, `[T]`. Contiguous here\n+/// means that elements are laid out so that every element is the same\n+/// distance from its neighbors.\n+///\n+/// *[See also the `std::slice` module](crate::slice).*\n+///\n+/// Slices are a view into a block of memory represented as a pointer and a\n+/// length.\n+///\n+/// ```\n+/// // slicing a Vec\n+/// let vec = vec![1, 2, 3];\n+/// let int_slice = &vec[..];\n+/// // coercing an array to a slice\n+/// let str_slice: &[&str] = &[\"one\", \"two\", \"three\"];\n+/// ```\n+///\n+/// Slices are either mutable or shared. The shared slice type is `&[T]`,\n+/// while the mutable slice type is `&mut [T]`, where `T` represents the element\n+/// type. For example, you can mutate the block of memory that a mutable slice\n+/// points to:\n+///\n+/// ```\n+/// let mut x = [1, 2, 3];\n+/// let x = &mut x[..]; // Take a full slice of `x`.\n+/// x[1] = 7;\n+/// assert_eq!(x, &[1, 7, 3]);\n+/// ```\n+///\n+/// As slices store the length of the sequence they refer to, they have twice\n+/// the size of pointers to [`Sized`](marker/trait.Sized.html) types.\n+/// Also see the reference on\n+/// [dynamically sized types](../reference/dynamically-sized-types.html).\n+///\n+/// ```\n+/// # use std::rc::Rc;\n+/// let pointer_size = std::mem::size_of::<&u8>();\n+/// assert_eq!(2 * pointer_size, std::mem::size_of::<&[u8]>());\n+/// assert_eq!(2 * pointer_size, std::mem::size_of::<*const [u8]>());\n+/// assert_eq!(2 * pointer_size, std::mem::size_of::<Box<[u8]>>());\n+/// assert_eq!(2 * pointer_size, std::mem::size_of::<Rc<[u8]>>());\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_slice {}\n+\n+#[doc(primitive = \"str\")]\n+//\n+/// String slices.\n+///\n+/// *[See also the `std::str` module](crate::str).*\n+///\n+/// The `str` type, also called a 'string slice', is the most primitive string\n+/// type. It is usually seen in its borrowed form, `&str`. It is also the type\n+/// of string literals, `&'static str`.\n+///\n+/// String slices are always valid UTF-8.\n+///\n+/// # Examples\n+///\n+/// String literals are string slices:\n+///\n+/// ```\n+/// let hello = \"Hello, world!\";\n+///\n+/// // with an explicit type annotation\n+/// let hello: &'static str = \"Hello, world!\";\n+/// ```\n+///\n+/// They are `'static` because they're stored directly in the final binary, and\n+/// so will be valid for the `'static` duration.\n+///\n+/// # Representation\n+///\n+/// A `&str` is made up of two components: a pointer to some bytes, and a\n+/// length. You can look at these with the [`as_ptr`] and [`len`] methods:\n+///\n+/// ```\n+/// use std::slice;\n+/// use std::str;\n+///\n+/// let story = \"Once upon a time...\";\n+///\n+/// let ptr = story.as_ptr();\n+/// let len = story.len();\n+///\n+/// // story has nineteen bytes\n+/// assert_eq!(19, len);\n+///\n+/// // We can re-build a str out of ptr and len. This is all unsafe because\n+/// // we are responsible for making sure the two components are valid:\n+/// let s = unsafe {\n+///     // First, we build a &[u8]...\n+///     let slice = slice::from_raw_parts(ptr, len);\n+///\n+///     // ... and then convert that slice into a string slice\n+///     str::from_utf8(slice)\n+/// };\n+///\n+/// assert_eq!(s, Ok(story));\n+/// ```\n+///\n+/// [`as_ptr`]: str::as_ptr\n+/// [`len`]: str::len\n+///\n+/// Note: This example shows the internals of `&str`. `unsafe` should not be\n+/// used to get a string slice under normal circumstances. Use `as_str`\n+/// instead.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_str {}\n+\n+#[doc(primitive = \"tuple\")]\n+#[doc(alias = \"(\")]\n+#[doc(alias = \")\")]\n+#[doc(alias = \"()\")]\n+//\n+/// A finite heterogeneous sequence, `(T, U, ..)`.\n+///\n+/// Let's cover each of those in turn:\n+///\n+/// Tuples are *finite*. In other words, a tuple has a length. Here's a tuple\n+/// of length `3`:\n+///\n+/// ```\n+/// (\"hello\", 5, 'c');\n+/// ```\n+///\n+/// 'Length' is also sometimes called 'arity' here; each tuple of a different\n+/// length is a different, distinct type.\n+///\n+/// Tuples are *heterogeneous*. This means that each element of the tuple can\n+/// have a different type. In that tuple above, it has the type:\n+///\n+/// ```\n+/// # let _:\n+/// (&'static str, i32, char)\n+/// # = (\"hello\", 5, 'c');\n+/// ```\n+///\n+/// Tuples are a *sequence*. This means that they can be accessed by position;\n+/// this is called 'tuple indexing', and it looks like this:\n+///\n+/// ```rust\n+/// let tuple = (\"hello\", 5, 'c');\n+///\n+/// assert_eq!(tuple.0, \"hello\");\n+/// assert_eq!(tuple.1, 5);\n+/// assert_eq!(tuple.2, 'c');\n+/// ```\n+///\n+/// The sequential nature of the tuple applies to its implementations of various\n+/// traits. For example, in [`PartialOrd`] and [`Ord`], the elements are compared\n+/// sequentially until the first non-equal set is found.\n+///\n+/// For more about tuples, see [the book](../book/ch03-02-data-types.html#the-tuple-type).\n+///\n+/// # Trait implementations\n+///\n+/// If every type inside a tuple implements one of the following traits, then a\n+/// tuple itself also implements it.\n+///\n+/// * [`Clone`]\n+/// * [`Copy`]\n+/// * [`PartialEq`]\n+/// * [`Eq`]\n+/// * [`PartialOrd`]\n+/// * [`Ord`]\n+/// * [`Debug`]\n+/// * [`Default`]\n+/// * [`Hash`]\n+///\n+/// [`Debug`]: fmt::Debug\n+/// [`Hash`]: hash::Hash\n+///\n+/// Due to a temporary restriction in Rust's type system, these traits are only\n+/// implemented on tuples of arity 12 or less. In the future, this may change.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// let tuple = (\"hello\", 5, 'c');\n+///\n+/// assert_eq!(tuple.0, \"hello\");\n+/// ```\n+///\n+/// Tuples are often used as a return type when you want to return more than\n+/// one value:\n+///\n+/// ```\n+/// fn calculate_point() -> (i32, i32) {\n+///     // Don't do a calculation, that's not the point of the example\n+///     (4, 5)\n+/// }\n+///\n+/// let point = calculate_point();\n+///\n+/// assert_eq!(point.0, 4);\n+/// assert_eq!(point.1, 5);\n+///\n+/// // Combining this with patterns can be nicer.\n+///\n+/// let (x, y) = calculate_point();\n+///\n+/// assert_eq!(x, 4);\n+/// assert_eq!(y, 5);\n+/// ```\n+///\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_tuple {}\n+\n+#[doc(primitive = \"f32\")]\n+/// A 32-bit floating point type (specifically, the \"binary32\" type defined in IEEE 754-2008).\n+///\n+/// This type can represent a wide range of decimal numbers, like `3.5`, `27`,\n+/// `-113.75`, `0.0078125`, `34359738368`, `0`, `-1`. So unlike integer types\n+/// (such as `i32`), floating point types can represent non-integer numbers,\n+/// too.\n+///\n+/// However, being able to represent this wide range of numbers comes at the\n+/// cost of precision: floats can only represent some of the real numbers and\n+/// calculation with floats round to a nearby representable number. For example,\n+/// `5.0` and `1.0` can be exactly represented as `f32`, but `1.0 / 5.0` results\n+/// in `0.20000000298023223876953125` since `0.2` cannot be exactly represented\n+/// as `f32`. Note, however, that printing floats with `println` and friends will\n+/// often discard insignificant digits: `println!(\"{}\", 1.0f32 / 5.0f32)` will\n+/// print `0.2`.\n+///\n+/// Additionally, `f32` can represent some special values:\n+///\n+/// - \u22120.0: IEEE 754 floating point numbers have a bit that indicates their sign, so \u22120.0 is a\n+///   possible value. For comparison \u22120.0 = +0.0, but floating point operations can carry\n+///   the sign bit through arithmetic operations. This means \u22120.0 \u00d7 +0.0 produces \u22120.0 and\n+///   a negative number rounded to a value smaller than a float can represent also produces \u22120.0.\n+/// - [\u221e](#associatedconstant.INFINITY) and\n+///   [\u2212\u221e](#associatedconstant.NEG_INFINITY): these result from calculations\n+///   like `1.0 / 0.0`.\n+/// - [NaN (not a number)](#associatedconstant.NAN): this value results from\n+///   calculations like `(-1.0).sqrt()`. NaN has some potentially unexpected\n+///   behavior: it is unequal to any float, including itself! It is also neither\n+///   smaller nor greater than any float, making it impossible to sort. Lastly,\n+///   it is considered infectious as almost all calculations where one of the\n+///   operands is NaN will also result in NaN.\n+///\n+/// For more information on floating point numbers, see [Wikipedia][wikipedia].\n+///\n+/// *[See also the `std::f32::consts` module](crate::f32::consts).*\n+///\n+/// [wikipedia]: https://en.wikipedia.org/wiki/Single-precision_floating-point_format\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_f32 {}\n+\n+#[doc(primitive = \"f64\")]\n+/// A 64-bit floating point type (specifically, the \"binary64\" type defined in IEEE 754-2008).\n+///\n+/// This type is very similar to [`f32`], but has increased\n+/// precision by using twice as many bits. Please see [the documentation for\n+/// `f32`][`f32`] or [Wikipedia on double precision\n+/// values][wikipedia] for more information.\n+///\n+/// *[See also the `std::f64::consts` module](crate::f64::consts).*\n+///\n+/// [`f32`]: prim@f32\n+/// [wikipedia]: https://en.wikipedia.org/wiki/Double-precision_floating-point_format\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_f64 {}\n+\n+#[doc(primitive = \"i8\")]\n+//\n+/// The 8-bit signed integer type.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_i8 {}\n+\n+#[doc(primitive = \"i16\")]\n+//\n+/// The 16-bit signed integer type.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_i16 {}\n+\n+#[doc(primitive = \"i32\")]\n+//\n+/// The 32-bit signed integer type.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_i32 {}\n+\n+#[doc(primitive = \"i64\")]\n+//\n+/// The 64-bit signed integer type.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_i64 {}\n+\n+#[doc(primitive = \"i128\")]\n+//\n+/// The 128-bit signed integer type.\n+#[stable(feature = \"i128\", since = \"1.26.0\")]\n+mod prim_i128 {}\n+\n+#[doc(primitive = \"u8\")]\n+//\n+/// The 8-bit unsigned integer type.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_u8 {}\n+\n+#[doc(primitive = \"u16\")]\n+//\n+/// The 16-bit unsigned integer type.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_u16 {}\n+\n+#[doc(primitive = \"u32\")]\n+//\n+/// The 32-bit unsigned integer type.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_u32 {}\n+\n+#[doc(primitive = \"u64\")]\n+//\n+/// The 64-bit unsigned integer type.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_u64 {}\n+\n+#[doc(primitive = \"u128\")]\n+//\n+/// The 128-bit unsigned integer type.\n+#[stable(feature = \"i128\", since = \"1.26.0\")]\n+mod prim_u128 {}\n+\n+#[doc(primitive = \"isize\")]\n+//\n+/// The pointer-sized signed integer type.\n+///\n+/// The size of this primitive is how many bytes it takes to reference any\n+/// location in memory. For example, on a 32 bit target, this is 4 bytes\n+/// and on a 64 bit target, this is 8 bytes.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_isize {}\n+\n+#[doc(primitive = \"usize\")]\n+//\n+/// The pointer-sized unsigned integer type.\n+///\n+/// The size of this primitive is how many bytes it takes to reference any\n+/// location in memory. For example, on a 32 bit target, this is 4 bytes\n+/// and on a 64 bit target, this is 8 bytes.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_usize {}\n+\n+#[doc(primitive = \"reference\")]\n+#[doc(alias = \"&\")]\n+#[doc(alias = \"&mut\")]\n+//\n+/// References, both shared and mutable.\n+///\n+/// A reference represents a borrow of some owned value. You can get one by using the `&` or `&mut`\n+/// operators on a value, or by using a [`ref`](../std/keyword.ref.html) or\n+/// <code>[ref](../std/keyword.ref.html) [mut](../std/keyword.mut.html)</code> pattern.\n+///\n+/// For those familiar with pointers, a reference is just a pointer that is assumed to be\n+/// aligned, not null, and pointing to memory containing a valid value of `T` - for example,\n+/// <code>&[bool]</code> can only point to an allocation containing the integer values `1`\n+/// ([`true`](../std/keyword.true.html)) or `0` ([`false`](../std/keyword.false.html)), but\n+/// creating a <code>&[bool]</code> that points to an allocation containing\n+/// the value `3` causes undefined behaviour.\n+/// In fact, <code>[Option]\\<&T></code> has the same memory representation as a\n+/// nullable but aligned pointer, and can be passed across FFI boundaries as such.\n+///\n+/// In most cases, references can be used much like the original value. Field access, method\n+/// calling, and indexing work the same (save for mutability rules, of course). In addition, the\n+/// comparison operators transparently defer to the referent's implementation, allowing references\n+/// to be compared the same as owned values.\n+///\n+/// References have a lifetime attached to them, which represents the scope for which the borrow is\n+/// valid. A lifetime is said to \"outlive\" another one if its representative scope is as long or\n+/// longer than the other. The `'static` lifetime is the longest lifetime, which represents the\n+/// total life of the program. For example, string literals have a `'static` lifetime because the\n+/// text data is embedded into the binary of the program, rather than in an allocation that needs\n+/// to be dynamically managed.\n+///\n+/// `&mut T` references can be freely coerced into `&T` references with the same referent type, and\n+/// references with longer lifetimes can be freely coerced into references with shorter ones.\n+///\n+/// Reference equality by address, instead of comparing the values pointed to, is accomplished via\n+/// implicit reference-pointer coercion and raw pointer equality via [`ptr::eq`], while\n+/// [`PartialEq`] compares values.\n+///\n+/// ```\n+/// use std::ptr;\n+///\n+/// let five = 5;\n+/// let other_five = 5;\n+/// let five_ref = &five;\n+/// let same_five_ref = &five;\n+/// let other_five_ref = &other_five;\n+///\n+/// assert!(five_ref == same_five_ref);\n+/// assert!(five_ref == other_five_ref);\n+///\n+/// assert!(ptr::eq(five_ref, same_five_ref));\n+/// assert!(!ptr::eq(five_ref, other_five_ref));\n+/// ```\n+///\n+/// For more information on how to use references, see [the book's section on \"References and\n+/// Borrowing\"][book-refs].\n+///\n+/// [book-refs]: ../book/ch04-02-references-and-borrowing.html\n+///\n+/// # Trait implementations\n+///\n+/// The following traits are implemented for all `&T`, regardless of the type of its referent:\n+///\n+/// * [`Copy`]\n+/// * [`Clone`] \\(Note that this will not defer to `T`'s `Clone` implementation if it exists!)\n+/// * [`Deref`]\n+/// * [`Borrow`]\n+/// * [`Pointer`]\n+///\n+/// [`Deref`]: ops::Deref\n+/// [`Borrow`]: borrow::Borrow\n+/// [`Pointer`]: fmt::Pointer\n+///\n+/// `&mut T` references get all of the above except `Copy` and `Clone` (to prevent creating\n+/// multiple simultaneous mutable borrows), plus the following, regardless of the type of its\n+/// referent:\n+///\n+/// * [`DerefMut`]\n+/// * [`BorrowMut`]\n+///\n+/// [`DerefMut`]: ops::DerefMut\n+/// [`BorrowMut`]: borrow::BorrowMut\n+/// [bool]: prim@bool\n+///\n+/// The following traits are implemented on `&T` references if the underlying `T` also implements\n+/// that trait:\n+///\n+/// * All the traits in [`std::fmt`] except [`Pointer`] and [`fmt::Write`]\n+/// * [`PartialOrd`]\n+/// * [`Ord`]\n+/// * [`PartialEq`]\n+/// * [`Eq`]\n+/// * [`AsRef`]\n+/// * [`Fn`] \\(in addition, `&T` references get [`FnMut`] and [`FnOnce`] if `T: Fn`)\n+/// * [`Hash`]\n+/// * [`ToSocketAddrs`]\n+///\n+/// [`std::fmt`]: fmt\n+/// ['Pointer`]: fmt::Pointer\n+/// [`Hash`]: hash::Hash\n+#[doc = concat!(\"[`ToSocketAddrs`]: \", include_str!(\"../primitive_docs/net_tosocketaddrs.md\"))]\n+///\n+/// `&mut T` references get all of the above except `ToSocketAddrs`, plus the following, if `T`\n+/// implements that trait:\n+///\n+/// * [`AsMut`]\n+/// * [`FnMut`] \\(in addition, `&mut T` references get [`FnOnce`] if `T: FnMut`)\n+/// * [`fmt::Write`]\n+/// * [`Iterator`]\n+/// * [`DoubleEndedIterator`]\n+/// * [`ExactSizeIterator`]\n+/// * [`FusedIterator`]\n+/// * [`TrustedLen`]\n+/// * [`Send`] \\(note that `&T` references only get `Send` if <code>T: [Sync]</code>)\n+/// * [`io::Write`]\n+/// * [`Read`]\n+/// * [`Seek`]\n+/// * [`BufRead`]\n+///\n+/// [`FusedIterator`]: iter::FusedIterator\n+/// [`TrustedLen`]: iter::TrustedLen\n+#[doc = concat!(\"[`Seek`]: \", include_str!(\"../primitive_docs/io_seek.md\"))]\n+#[doc = concat!(\"[`BufRead`]: \", include_str!(\"../primitive_docs/io_bufread.md\"))]\n+#[doc = concat!(\"[`Read`]: \", include_str!(\"../primitive_docs/io_read.md\"))]\n+#[doc = concat!(\"[`io::Write`]: \", include_str!(\"../primitive_docs/io_write.md\"))]\n+///\n+/// Note that due to method call deref coercion, simply calling a trait method will act like they\n+/// work on references as well as they do on owned values! The implementations described here are\n+/// meant for generic contexts, where the final type `T` is a type parameter or otherwise not\n+/// locally known.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_ref {}\n+\n+#[doc(primitive = \"fn\")]\n+//\n+/// Function pointers, like `fn(usize) -> bool`.\n+///\n+/// *See also the traits [`Fn`], [`FnMut`], and [`FnOnce`].*\n+///\n+/// [`Fn`]: ops::Fn\n+/// [`FnMut`]: ops::FnMut\n+/// [`FnOnce`]: ops::FnOnce\n+///\n+/// Function pointers are pointers that point to *code*, not data. They can be called\n+/// just like functions. Like references, function pointers are, among other things, assumed to\n+/// not be null, so if you want to pass a function pointer over FFI and be able to accommodate null\n+/// pointers, make your type [`Option<fn()>`](core::option#options-and-pointers-nullable-pointers)\n+/// with your required signature.\n+///\n+/// ### Safety\n+///\n+/// Plain function pointers are obtained by casting either plain functions, or closures that don't\n+/// capture an environment:\n+///\n+/// ```\n+/// fn add_one(x: usize) -> usize {\n+///     x + 1\n+/// }\n+///\n+/// let ptr: fn(usize) -> usize = add_one;\n+/// assert_eq!(ptr(5), 6);\n+///\n+/// let clos: fn(usize) -> usize = |x| x + 5;\n+/// assert_eq!(clos(5), 10);\n+/// ```\n+///\n+/// In addition to varying based on their signature, function pointers come in two flavors: safe\n+/// and unsafe. Plain `fn()` function pointers can only point to safe functions,\n+/// while `unsafe fn()` function pointers can point to safe or unsafe functions.\n+///\n+/// ```\n+/// fn add_one(x: usize) -> usize {\n+///     x + 1\n+/// }\n+///\n+/// unsafe fn add_one_unsafely(x: usize) -> usize {\n+///     x + 1\n+/// }\n+///\n+/// let safe_ptr: fn(usize) -> usize = add_one;\n+///\n+/// //ERROR: mismatched types: expected normal fn, found unsafe fn\n+/// //let bad_ptr: fn(usize) -> usize = add_one_unsafely;\n+///\n+/// let unsafe_ptr: unsafe fn(usize) -> usize = add_one_unsafely;\n+/// let really_safe_ptr: unsafe fn(usize) -> usize = add_one;\n+/// ```\n+///\n+/// ### ABI\n+///\n+/// On top of that, function pointers can vary based on what ABI they use. This\n+/// is achieved by adding the `extern` keyword before the type, followed by the\n+/// ABI in question. The default ABI is \"Rust\", i.e., `fn()` is the exact same\n+/// type as `extern \"Rust\" fn()`. A pointer to a function with C ABI would have\n+/// type `extern \"C\" fn()`.\n+///\n+/// `extern \"ABI\" { ... }` blocks declare functions with ABI \"ABI\". The default\n+/// here is \"C\", i.e., functions declared in an `extern {...}` block have \"C\"\n+/// ABI.\n+///\n+/// For more information and a list of supported ABIs, see [the nomicon's\n+/// section on foreign calling conventions][nomicon-abi].\n+///\n+/// [nomicon-abi]: ../nomicon/ffi.html#foreign-calling-conventions\n+///\n+/// ### Variadic functions\n+///\n+/// Extern function declarations with the \"C\" or \"cdecl\" ABIs can also be *variadic*, allowing them\n+/// to be called with a variable number of arguments. Normal Rust functions, even those with an\n+/// `extern \"ABI\"`, cannot be variadic. For more information, see [the nomicon's section on\n+/// variadic functions][nomicon-variadic].\n+///\n+/// [nomicon-variadic]: ../nomicon/ffi.html#variadic-functions\n+///\n+/// ### Creating function pointers\n+///\n+/// When `bar` is the name of a function, then the expression `bar` is *not* a\n+/// function pointer. Rather, it denotes a value of an unnameable type that\n+/// uniquely identifies the function `bar`. The value is zero-sized because the\n+/// type already identifies the function. This has the advantage that \"calling\"\n+/// the value (it implements the `Fn*` traits) does not require dynamic\n+/// dispatch.\n+///\n+/// This zero-sized type *coerces* to a regular function pointer. For example:\n+///\n+/// ```rust\n+/// use std::mem;\n+///\n+/// fn bar(x: i32) {}\n+///\n+/// let not_bar_ptr = bar; // `not_bar_ptr` is zero-sized, uniquely identifying `bar`\n+/// assert_eq!(mem::size_of_val(&not_bar_ptr), 0);\n+///\n+/// let bar_ptr: fn(i32) = not_bar_ptr; // force coercion to function pointer\n+/// assert_eq!(mem::size_of_val(&bar_ptr), mem::size_of::<usize>());\n+///\n+/// let footgun = &bar; // this is a shared reference to the zero-sized type identifying `bar`\n+/// ```\n+///\n+/// The last line shows that `&bar` is not a function pointer either. Rather, it\n+/// is a reference to the function-specific ZST. `&bar` is basically never what you\n+/// want when `bar` is a function.\n+///\n+/// ### Traits\n+///\n+/// Function pointers implement the following traits:\n+///\n+/// * [`Clone`]\n+/// * [`PartialEq`]\n+/// * [`Eq`]\n+/// * [`PartialOrd`]\n+/// * [`Ord`]\n+/// * [`Hash`]\n+/// * [`Pointer`]\n+/// * [`Debug`]\n+///\n+/// [`Hash`]: hash::Hash\n+/// [`Pointer`]: fmt::Pointer\n+///\n+/// Due to a temporary restriction in Rust's type system, these traits are only implemented on\n+/// functions that take 12 arguments or less, with the `\"Rust\"` and `\"C\"` ABIs. In the future, this\n+/// may change.\n+///\n+/// In addition, function pointers of *any* signature, ABI, or safety are [`Copy`], and all *safe*\n+/// function pointers implement [`Fn`], [`FnMut`], and [`FnOnce`]. This works because these traits\n+/// are specially known to the compiler.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_fn {}"}, {"sha": "a04e479e8570dc542b02066998b52266c096e18a", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -2257,9 +2257,9 @@ impl<T> [T] {\n     /// assert!(match r { Ok(1..=4) => true, _ => false, });\n     /// ```\n     // Lint rustdoc::broken_intra_doc_links is allowed as `slice::sort_by_key` is\n-    // in crate `alloc`, and as such doesn't exists yet when building `core`.\n-    // links to downstream crate: #74481. Since primitives are only documented in\n-    // libstd (#73423), this never leads to broken links in practice.\n+    // in crate `alloc`, and as such doesn't exists yet when building `core`: #74481.\n+    // This breaks links when slice is displayed in core, but changing it to use relative links\n+    // would break when the item is re-exported. So allow the core links to be broken for now.\n     #[allow(rustdoc::broken_intra_doc_links)]\n     #[stable(feature = \"slice_binary_search_by_key\", since = \"1.10.0\")]\n     #[inline]"}, {"sha": "307b9c85bd67e70420276fc08d49b43c38bb0691", "filename": "library/std/primitive_docs/box_into_raw.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fstd%2Fprimitive_docs%2Fbox_into_raw.md", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fstd%2Fprimitive_docs%2Fbox_into_raw.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fprimitive_docs%2Fbox_into_raw.md?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -0,0 +1 @@\n+Box::into_raw"}, {"sha": "13e4540835e61884929644f7aae4add33f648f07", "filename": "library/std/primitive_docs/fs_file.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fstd%2Fprimitive_docs%2Ffs_file.md", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fstd%2Fprimitive_docs%2Ffs_file.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fprimitive_docs%2Ffs_file.md?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -0,0 +1 @@\n+fs::File"}, {"sha": "bb688e3a5cc874cfa13c226493c3f50de382b2bf", "filename": "library/std/primitive_docs/io_bufread.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fstd%2Fprimitive_docs%2Fio_bufread.md", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fstd%2Fprimitive_docs%2Fio_bufread.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fprimitive_docs%2Fio_bufread.md?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -0,0 +1 @@\n+io::BufRead"}, {"sha": "5118d7c4888ab24bc0f4be807b5cd8943bc2557d", "filename": "library/std/primitive_docs/io_read.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fstd%2Fprimitive_docs%2Fio_read.md", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fstd%2Fprimitive_docs%2Fio_read.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fprimitive_docs%2Fio_read.md?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -0,0 +1 @@\n+io::Read"}, {"sha": "122e6df77b6d74cd5c6cd3a4c6d8c278f9bf76be", "filename": "library/std/primitive_docs/io_seek.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fstd%2Fprimitive_docs%2Fio_seek.md", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fstd%2Fprimitive_docs%2Fio_seek.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fprimitive_docs%2Fio_seek.md?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -0,0 +1 @@\n+io::Seek"}, {"sha": "15dfc907a65553ccebac45fa8301d4b74960ee4a", "filename": "library/std/primitive_docs/io_write.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fstd%2Fprimitive_docs%2Fio_write.md", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fstd%2Fprimitive_docs%2Fio_write.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fprimitive_docs%2Fio_write.md?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -0,0 +1 @@\n+io::Write"}, {"sha": "a01f318e887715479d074b29fa0a00d50e786f32", "filename": "library/std/primitive_docs/net_tosocketaddrs.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fstd%2Fprimitive_docs%2Fnet_tosocketaddrs.md", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fstd%2Fprimitive_docs%2Fnet_tosocketaddrs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fprimitive_docs%2Fnet_tosocketaddrs.md?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -0,0 +1 @@\n+net::ToSocketAddrs"}, {"sha": "565a71375cd0e58da40cfadb025a5d1c704f4f8c", "filename": "library/std/primitive_docs/process_exit.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fstd%2Fprimitive_docs%2Fprocess_exit.md", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fstd%2Fprimitive_docs%2Fprocess_exit.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fprimitive_docs%2Fprocess_exit.md?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -0,0 +1 @@\n+process::exit"}, {"sha": "ce7815ff91b9e50390753482015fda8f94d507fb", "filename": "library/std/primitive_docs/string_string.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fstd%2Fprimitive_docs%2Fstring_string.md", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fstd%2Fprimitive_docs%2Fstring_string.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fprimitive_docs%2Fstring_string.md?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -0,0 +1 @@\n+string::String"}, {"sha": "0de9126dab2fe5679ea2390903a0c1e3293e59a4", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -1,3 +1,6 @@\n+// `library/{std,core}/src/primitive_docs.rs` should have the same contents.\n+// These are different files so that relative links work properly without\n+// having to have `CARGO_PKG_NAME` set, but conceptually they should always be the same.\n #[doc(primitive = \"bool\")]\n #[doc(alias = \"true\")]\n #[doc(alias = \"false\")]\n@@ -20,12 +23,12 @@\n /// assert!(!bool_val);\n /// ```\n ///\n-/// [`true`]: keyword.true.html\n-/// [`false`]: keyword.false.html\n+/// [`true`]: ../std/keyword.true.html\n+/// [`false`]: ../std/keyword.false.html\n /// [`BitAnd`]: ops::BitAnd\n /// [`BitOr`]: ops::BitOr\n /// [`Not`]: ops::Not\n-/// [`if`]: keyword.if.html\n+/// [`if`]: ../std/keyword.if.html\n ///\n /// # Examples\n ///\n@@ -103,7 +106,7 @@ mod prim_bool {}\n /// behaviour of the `!` type - expressions with type `!` will coerce into any other type.\n ///\n /// [`u32`]: prim@u32\n-/// [`exit`]: process::exit\n+#[doc = concat!(\"[`exit`]: \", include_str!(\"../primitive_docs/process_exit.md\"))]\n ///\n /// # `!` and generics\n ///\n@@ -188,7 +191,7 @@ mod prim_bool {}\n /// because `!` coerces to `Result<!, ConnectionError>` automatically.\n ///\n /// [`String::from_str`]: str::FromStr::from_str\n-/// [`String`]: string::String\n+#[doc = concat!(\"[`String`]: \", include_str!(\"../primitive_docs/string_string.md\"))]\n /// [`FromStr`]: str::FromStr\n ///\n /// # `!` and traits\n@@ -264,15 +267,14 @@ mod prim_bool {}\n /// `impl` for this which simply panics, but the same is true for any type (we could `impl\n /// Default` for (eg.) [`File`] by just making [`default()`] panic.)\n ///\n-/// [`File`]: fs::File\n+#[doc = concat!(\"[`File`]: \", include_str!(\"../primitive_docs/fs_file.md\"))]\n /// [`Debug`]: fmt::Debug\n /// [`default()`]: Default::default\n ///\n #[unstable(feature = \"never_type\", issue = \"35121\")]\n mod prim_never {}\n \n #[doc(primitive = \"char\")]\n-//\n /// A character type.\n ///\n /// The `char` type represents a single character. More specifically, since\n@@ -304,7 +306,7 @@ mod prim_never {}\n /// assert_eq!(5, s.len() * std::mem::size_of::<u8>());\n /// ```\n ///\n-/// [`String`]: string/struct.String.html\n+#[doc = concat!(\"[`String`]: \", include_str!(\"../primitive_docs/string_string.md\"))]\n ///\n /// As always, remember that a human intuition for 'character' might not map to\n /// Unicode's definitions. For example, despite looking similar, the '\u00e9'\n@@ -499,7 +501,7 @@ mod prim_unit {}\n /// [`null_mut`]: ptr::null_mut\n /// [`is_null`]: pointer::is_null\n /// [`offset`]: pointer::offset\n-/// [`into_raw`]: Box::into_raw\n+#[doc = concat!(\"[`into_raw`]: \", include_str!(\"../primitive_docs/box_into_raw.md\"))]\n /// [`drop`]: mem::drop\n /// [`write`]: ptr::write\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -581,9 +583,9 @@ mod prim_pointer {}\n /// # Editions\n ///\n /// Prior to Rust 1.53, arrays did not implement [`IntoIterator`] by value, so the method call\n-/// `array.into_iter()` auto-referenced into a [slice iterator](slice::iter). Right now, the old behavior\n-/// is preserved in the 2015 and 2018 editions of Rust for compatibility, ignoring\n-/// `IntoIterator` by value. In the future, the behavior on the 2015 and 2018 edition\n+/// `array.into_iter()` auto-referenced into a [slice iterator](slice::iter). Right now, the old\n+/// behavior is preserved in the 2015 and 2018 editions of Rust for compatibility, ignoring\n+/// [`IntoIterator`] by value. In the future, the behavior on the 2015 and 2018 edition\n /// might be made consistent to the behavior of later editions.\n ///\n /// ```rust,edition2018\n@@ -1042,15 +1044,15 @@ mod prim_usize {}\n /// References, both shared and mutable.\n ///\n /// A reference represents a borrow of some owned value. You can get one by using the `&` or `&mut`\n-/// operators on a value, or by using a [`ref`](keyword.ref.html) or\n-/// <code>[ref](keyword.ref.html) [mut](keyword.mut.html)</code> pattern.\n+/// operators on a value, or by using a [`ref`](../std/keyword.ref.html) or\n+/// <code>[ref](../std/keyword.ref.html) [mut](../std/keyword.mut.html)</code> pattern.\n ///\n /// For those familiar with pointers, a reference is just a pointer that is assumed to be\n /// aligned, not null, and pointing to memory containing a valid value of `T` - for example,\n /// <code>&[bool]</code> can only point to an allocation containing the integer values `1`\n-/// ([`true`](keyword.true.html)) or `0` ([`false`](keyword.false.html)), but creating a\n-/// <code>&[bool]</code> that points to an allocation containing the value `3` causes\n-/// undefined behaviour.\n+/// ([`true`](../std/keyword.true.html)) or `0` ([`false`](../std/keyword.false.html)), but\n+/// creating a <code>&[bool]</code> that points to an allocation containing\n+/// the value `3` causes undefined behaviour.\n /// In fact, <code>[Option]\\<&T></code> has the same memory representation as a\n /// nullable but aligned pointer, and can be passed across FFI boundaries as such.\n ///\n@@ -1117,6 +1119,7 @@ mod prim_usize {}\n ///\n /// [`DerefMut`]: ops::DerefMut\n /// [`BorrowMut`]: borrow::BorrowMut\n+/// [bool]: prim@bool\n ///\n /// The following traits are implemented on `&T` references if the underlying `T` also implements\n /// that trait:\n@@ -1134,7 +1137,7 @@ mod prim_usize {}\n /// [`std::fmt`]: fmt\n /// ['Pointer`]: fmt::Pointer\n /// [`Hash`]: hash::Hash\n-/// [`ToSocketAddrs`]: net::ToSocketAddrs\n+#[doc = concat!(\"[`ToSocketAddrs`]: \", include_str!(\"../primitive_docs/net_tosocketaddrs.md\"))]\n ///\n /// `&mut T` references get all of the above except `ToSocketAddrs`, plus the following, if `T`\n /// implements that trait:\n@@ -1155,9 +1158,10 @@ mod prim_usize {}\n ///\n /// [`FusedIterator`]: iter::FusedIterator\n /// [`TrustedLen`]: iter::TrustedLen\n-/// [`Seek`]: io::Seek\n-/// [`BufRead`]: io::BufRead\n-/// [`Read`]: io::Read\n+#[doc = concat!(\"[`Seek`]: \", include_str!(\"../primitive_docs/io_seek.md\"))]\n+#[doc = concat!(\"[`BufRead`]: \", include_str!(\"../primitive_docs/io_bufread.md\"))]\n+#[doc = concat!(\"[`Read`]: \", include_str!(\"../primitive_docs/io_read.md\"))]\n+#[doc = concat!(\"[`io::Write`]: \", include_str!(\"../primitive_docs/io_write.md\"))]\n ///\n /// Note that due to method call deref coercion, simply calling a trait method will act like they\n /// work on references as well as they do on owned values! The implementations described here are"}, {"sha": "15d4563ad7461b7d083439bb726cd3a8b0289129", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -17,7 +17,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n         let param_env = self.cx.tcx.param_env(item_def_id);\n         let ty = self.cx.tcx.type_of(item_def_id);\n \n-        debug!(\"get_blanket_impls({:?})\", ty);\n+        trace!(\"get_blanket_impls({:?})\", ty);\n         let mut impls = Vec::new();\n         for &trait_def_id in self.cx.tcx.all_traits(()).iter() {\n             if !self.cx.cache.access_levels.is_public(trait_def_id)\n@@ -28,9 +28,10 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n             // NOTE: doesn't use `for_each_relevant_impl` to avoid looking at anything besides blanket impls\n             let trait_impls = self.cx.tcx.trait_impls_of(trait_def_id);\n             for &impl_def_id in trait_impls.blanket_impls() {\n-                debug!(\n+                trace!(\n                     \"get_blanket_impls: Considering impl for trait '{:?}' {:?}\",\n-                    trait_def_id, impl_def_id\n+                    trait_def_id,\n+                    impl_def_id\n                 );\n                 let trait_ref = self.cx.tcx.impl_trait_ref(impl_def_id).unwrap();\n                 let is_param = matches!(trait_ref.self_ty().kind(), ty::Param(_));\n@@ -50,9 +51,11 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                         // FIXME(eddyb) ignoring `obligations` might cause false positives.\n                         drop(obligations);\n \n-                        debug!(\n+                        trace!(\n                             \"invoking predicate_may_hold: param_env={:?}, trait_ref={:?}, ty={:?}\",\n-                            param_env, trait_ref, ty\n+                            param_env,\n+                            trait_ref,\n+                            ty\n                         );\n                         let predicates = self\n                             .cx"}, {"sha": "40b0175bb15959186c3572827291e8966873c9c3", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -447,9 +447,9 @@ crate fn build_impl(\n     }\n \n     let (merged_attrs, cfg) = merge_attrs(cx, parent_module.into(), load_attrs(cx, did), attrs);\n-    debug!(\"merged_attrs={:?}\", merged_attrs);\n+    trace!(\"merged_attrs={:?}\", merged_attrs);\n \n-    debug!(\"build_impl: impl {:?} for {:?}\", trait_.def_id(), for_.def_id());\n+    trace!(\"build_impl: impl {:?} for {:?}\", trait_.def_id(), for_.def_id());\n     ret.push(clean::Item::from_def_id_and_attrs_and_parts(\n         did,\n         None,"}, {"sha": "6ffdf1df6014affbede6201a5b603a8eba7be42b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -1406,7 +1406,7 @@ fn normalize(cx: &mut DocContext<'tcx>, ty: Ty<'_>) -> Option<Ty<'tcx>> {\n \n impl<'tcx> Clean<Type> for Ty<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n-        debug!(\"cleaning type: {:?}\", self);\n+        trace!(\"cleaning type: {:?}\", self);\n         let ty = normalize(cx, self).unwrap_or(self);\n         match *ty.kind() {\n             ty::Never => Never,"}, {"sha": "454602481e3c5a57140a54378da2cb200cfdf76e", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 52, "deletions": 67, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -461,60 +461,20 @@ impl Item {\n             .map_or(&[][..], |v| v.as_slice())\n             .iter()\n             .filter_map(|ItemLink { link: s, link_text, did, ref fragment }| {\n-                match did {\n-                    Some(did) => {\n-                        if let Ok((mut href, ..)) = href(*did, cx) {\n-                            if let Some(ref fragment) = *fragment {\n-                                href.push('#');\n-                                href.push_str(fragment);\n-                            }\n-                            Some(RenderedLink {\n-                                original_text: s.clone(),\n-                                new_text: link_text.clone(),\n-                                href,\n-                            })\n-                        } else {\n-                            None\n-                        }\n-                    }\n-                    // FIXME(83083): using fragments as a side-channel for\n-                    // primitive names is very unfortunate\n-                    None => {\n-                        let relative_to = &cx.current;\n-                        if let Some(ref fragment) = *fragment {\n-                            let url = match cx.cache().extern_locations.get(&self.def_id.krate()) {\n-                                Some(&ExternalLocation::Local) => {\n-                                    if relative_to[0] == \"std\" {\n-                                        let depth = relative_to.len() - 1;\n-                                        \"../\".repeat(depth)\n-                                    } else {\n-                                        let depth = relative_to.len();\n-                                        format!(\"{}std/\", \"../\".repeat(depth))\n-                                    }\n-                                }\n-                                Some(ExternalLocation::Remote(ref s)) => {\n-                                    format!(\"{}/std/\", s.trim_end_matches('/'))\n-                                }\n-                                Some(ExternalLocation::Unknown) | None => {\n-                                    format!(\"{}/std/\", crate::DOC_RUST_LANG_ORG_CHANNEL)\n-                                }\n-                            };\n-                            // This is a primitive so the url is done \"by hand\".\n-                            let tail = fragment.find('#').unwrap_or_else(|| fragment.len());\n-                            Some(RenderedLink {\n-                                original_text: s.clone(),\n-                                new_text: link_text.clone(),\n-                                href: format!(\n-                                    \"{}primitive.{}.html{}\",\n-                                    url,\n-                                    &fragment[..tail],\n-                                    &fragment[tail..]\n-                                ),\n-                            })\n-                        } else {\n-                            panic!(\"This isn't a primitive?!\");\n-                        }\n+                debug!(?did);\n+                if let Ok((mut href, ..)) = href(*did, cx) {\n+                    debug!(?href);\n+                    if let Some(ref fragment) = *fragment {\n+                        href.push('#');\n+                        href.push_str(fragment);\n                     }\n+                    Some(RenderedLink {\n+                        original_text: s.clone(),\n+                        new_text: link_text.clone(),\n+                        href,\n+                    })\n+                } else {\n+                    None\n                 }\n             })\n             .collect()\n@@ -531,18 +491,10 @@ impl Item {\n             .get(&self.def_id)\n             .map_or(&[][..], |v| v.as_slice())\n             .iter()\n-            .filter_map(|ItemLink { link: s, link_text, did, fragment }| {\n-                // FIXME(83083): using fragments as a side-channel for\n-                // primitive names is very unfortunate\n-                if did.is_some() || fragment.is_some() {\n-                    Some(RenderedLink {\n-                        original_text: s.clone(),\n-                        new_text: link_text.clone(),\n-                        href: String::new(),\n-                    })\n-                } else {\n-                    None\n-                }\n+            .map(|ItemLink { link: s, link_text, .. }| RenderedLink {\n+                original_text: s.clone(),\n+                new_text: link_text.clone(),\n+                href: String::new(),\n             })\n             .collect()\n     }\n@@ -963,7 +915,7 @@ crate struct Attributes {\n     crate other_attrs: Vec<ast::Attribute>,\n }\n \n-#[derive(Clone, Debug, Default, PartialEq, Eq, Hash)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n /// A link that has not yet been rendered.\n ///\n /// This link will be turned into a rendered link by [`Item::links`].\n@@ -975,7 +927,7 @@ crate struct ItemLink {\n     /// This may not be the same as `link` if there was a disambiguator\n     /// in an intra-doc link (e.g. \\[`fn@f`\\])\n     pub(crate) link_text: String,\n-    pub(crate) did: Option<DefId>,\n+    pub(crate) did: DefId,\n     /// The url fragment to append to the link\n     pub(crate) fragment: Option<String>,\n }\n@@ -1802,6 +1754,39 @@ impl PrimitiveType {\n             Never => sym::never,\n         }\n     }\n+\n+    /// Returns the DefId of the module with `doc(primitive)` for this primitive type.\n+    /// Panics if there is no such module.\n+    ///\n+    /// This gives precedence to primitives defined in the current crate, and deprioritizes primitives defined in `core`,\n+    /// but otherwise, if multiple crates define the same primitive, there is no guarantee of which will be picked.\n+    /// In particular, if a crate depends on both `std` and another crate that also defines `doc(primitive)`, then\n+    /// it's entirely random whether `std` or the other crate is picked. (no_std crates are usually fine unless multiple dependencies define a primitive.)\n+    crate fn primitive_locations(tcx: TyCtxt<'_>) -> &FxHashMap<PrimitiveType, DefId> {\n+        static PRIMITIVE_LOCATIONS: OnceCell<FxHashMap<PrimitiveType, DefId>> = OnceCell::new();\n+        PRIMITIVE_LOCATIONS.get_or_init(|| {\n+            let mut primitive_locations = FxHashMap::default();\n+            // NOTE: technically this misses crates that are only passed with `--extern` and not loaded when checking the crate.\n+            // This is a degenerate case that I don't plan to support.\n+            for &crate_num in tcx.crates(()) {\n+                let e = ExternalCrate { crate_num };\n+                let crate_name = e.name(tcx);\n+                debug!(?crate_num, ?crate_name);\n+                for &(def_id, prim) in &e.primitives(tcx) {\n+                    // HACK: try to link to std instead where possible\n+                    if crate_name == sym::core && primitive_locations.contains_key(&prim) {\n+                        continue;\n+                    }\n+                    primitive_locations.insert(prim, def_id);\n+                }\n+            }\n+            let local_primitives = ExternalCrate { crate_num: LOCAL_CRATE }.primitives(tcx);\n+            for (def_id, prim) in local_primitives {\n+                primitive_locations.insert(prim, def_id);\n+            }\n+            primitive_locations\n+        })\n+    }\n }\n \n impl From<ast::IntTy> for PrimitiveType {"}, {"sha": "66fd0d9262d6be75b1fd9904d29225ff3ba1507e", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -6,7 +6,7 @@ use rustc_middle::middle::privacy::AccessLevels;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::sym;\n \n-use crate::clean::{self, GetDefId, ItemId};\n+use crate::clean::{self, GetDefId, ItemId, PrimitiveType};\n use crate::config::RenderOptions;\n use crate::fold::DocFolder;\n use crate::formats::item_type::ItemType;\n@@ -159,17 +159,16 @@ impl Cache {\n             self.external_paths.insert(e.def_id(), (vec![name.to_string()], ItemType::Module));\n         }\n \n-        // Cache where all known primitives have their documentation located.\n-        //\n-        // Favor linking to as local extern as possible, so iterate all crates in\n-        // reverse topological order.\n-        for &e in krate.externs.iter().rev() {\n-            for &(def_id, prim) in &e.primitives(tcx) {\n-                self.primitive_locations.insert(prim, def_id);\n-            }\n-        }\n-        for &(def_id, prim) in &krate.primitives {\n-            self.primitive_locations.insert(prim, def_id);\n+        // FIXME: avoid this clone (requires implementing Default manually)\n+        self.primitive_locations = PrimitiveType::primitive_locations(tcx).clone();\n+        for (prim, &def_id) in &self.primitive_locations {\n+            let crate_name = tcx.crate_name(def_id.krate);\n+            // Recall that we only allow primitive modules to be at the root-level of the crate.\n+            // If that restriction is ever lifted, this will have to include the relative paths instead.\n+            self.external_paths.insert(\n+                def_id,\n+                (vec![crate_name.to_string(), prim.as_sym().to_string()], ItemType::Primitive),\n+            );\n         }\n \n         krate = CacheBuilder { tcx, cache: self }.fold_crate(krate);"}, {"sha": "2fde0017dc80c63be5cb8a1ffc6728620da667f9", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -509,14 +509,19 @@ crate fn href_with_root_path(\n         if shortty == ItemType::Module { fqp } else { &fqp[..fqp.len() - 1] }\n     }\n \n-    if !did.is_local() && !cache.access_levels.is_public(did) && !cache.document_private {\n+    if !did.is_local()\n+        && !cache.access_levels.is_public(did)\n+        && !cache.document_private\n+        && !cache.primitive_locations.values().any(|&id| id == did)\n+    {\n         return Err(HrefError::Private);\n     }\n \n     let mut is_remote = false;\n     let (fqp, shortty, mut url_parts) = match cache.paths.get(&did) {\n         Some(&(ref fqp, shortty)) => (fqp, shortty, {\n             let module_fqp = to_module_fqp(shortty, fqp);\n+            debug!(?fqp, ?shortty, ?module_fqp);\n             href_relative_parts(module_fqp, relative_to)\n         }),\n         None => {\n@@ -548,6 +553,7 @@ crate fn href_with_root_path(\n             url_parts.insert(0, root);\n         }\n     }\n+    debug!(?url_parts);\n     let last = &fqp.last().unwrap()[..];\n     let filename;\n     match shortty {\n@@ -742,7 +748,7 @@ fn fmt_type<'cx>(\n     use_absolute: bool,\n     cx: &'cx Context<'_>,\n ) -> fmt::Result {\n-    debug!(\"fmt_type(t = {:?})\", t);\n+    trace!(\"fmt_type(t = {:?})\", t);\n \n     match *t {\n         clean::Generic(name) => write!(f, \"{}\", name),"}, {"sha": "f8ea7a499b2340a4dcbd14e991d3f6131a1ba409", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -30,9 +30,7 @@ impl JsonRenderer<'_> {\n             .get(&item.def_id)\n             .into_iter()\n             .flatten()\n-            .filter_map(|clean::ItemLink { link, did, .. }| {\n-                did.map(|did| (link.clone(), from_item_id(did.into())))\n-            })\n+            .map(|clean::ItemLink { link, did, .. }| (link.clone(), from_item_id((*did).into())))\n             .collect();\n         let docs = item.attrs.collapsed_doc_value();\n         let attrs = item"}, {"sha": "c0c37ee061198573e3cacc768966215563edaba5", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 23, "deletions": 36, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -14,7 +14,7 @@ use rustc_hir::def::{\n };\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_middle::ty::TyCtxt;\n-use rustc_middle::{bug, ty};\n+use rustc_middle::{bug, span_bug, ty};\n use rustc_resolve::ParentScope;\n use rustc_session::lint::Lint;\n use rustc_span::hygiene::{MacroKind, SyntaxContext};\n@@ -98,14 +98,10 @@ impl Res {\n         }\n     }\n \n-    fn def_id(self) -> DefId {\n-        self.opt_def_id().expect(\"called def_id() on a primitive\")\n-    }\n-\n-    fn opt_def_id(self) -> Option<DefId> {\n+    fn def_id(self, tcx: TyCtxt<'_>) -> DefId {\n         match self {\n-            Res::Def(_, id) => Some(id),\n-            Res::Primitive(_) => None,\n+            Res::Def(_, id) => id,\n+            Res::Primitive(prim) => *PrimitiveType::primitive_locations(tcx).get(&prim).unwrap(),\n         }\n     }\n \n@@ -237,10 +233,7 @@ enum AnchorFailure {\n     /// link, Rustdoc disallows having a user-specified anchor.\n     ///\n     /// Most of the time this is fine, because you can just link to the page of\n-    /// the item if you want to provide your own anchor. For primitives, though,\n-    /// rustdoc uses the anchor as a side channel to know which page to link to;\n-    /// it doesn't show up in the generated link. Ideally, rustdoc would remove\n-    /// this limitation, allowing you to link to subheaders on primitives.\n+    /// the item if you want to provide your own anchor.\n     RustdocAnchorConflict(Res),\n }\n \n@@ -388,7 +381,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         ty::AssocKind::Const => \"associatedconstant\",\n                         ty::AssocKind::Type => \"associatedtype\",\n                     };\n-                    let fragment = format!(\"{}#{}.{}\", prim_ty.as_sym(), out, item_name);\n+                    let fragment = format!(\"{}.{}\", out, item_name);\n                     (Res::Primitive(prim_ty), fragment, Some((kind.as_def_kind(), item.def_id)))\n                 })\n         })\n@@ -475,14 +468,6 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     return handle_variant(self.cx, res, extra_fragment);\n                 }\n                 // Not a trait item; just return what we found.\n-                Res::Primitive(ty) => {\n-                    if extra_fragment.is_some() {\n-                        return Err(ErrorKind::AnchorFailure(\n-                            AnchorFailure::RustdocAnchorConflict(res),\n-                        ));\n-                    }\n-                    return Ok((res, Some(ty.as_sym().to_string())));\n-                }\n                 _ => return Ok((res, extra_fragment.clone())),\n             }\n         }\n@@ -517,6 +502,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 let (res, fragment, side_channel) =\n                     self.resolve_associated_item(ty_res, item_name, ns, module_id)?;\n                 let result = if extra_fragment.is_some() {\n+                    // NOTE: can never be a primitive since `side_channel.is_none()` only when `res`\n+                    // is a trait (and the side channel DefId is always an associated item).\n                     let diag_res = side_channel.map_or(res, |(k, r)| Res::Def(k, r));\n                     Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(diag_res)))\n                 } else {\n@@ -1152,7 +1139,7 @@ impl LinkCollector<'_, '_> {\n             module_id = DefId { krate, index: CRATE_DEF_INDEX };\n         }\n \n-        let (mut res, mut fragment) = self.resolve_with_disambiguator_cached(\n+        let (mut res, fragment) = self.resolve_with_disambiguator_cached(\n             ResolutionInfo {\n                 module_id,\n                 dis: disambiguator,\n@@ -1174,16 +1161,7 @@ impl LinkCollector<'_, '_> {\n             if let Some(prim) = resolve_primitive(path_str, TypeNS) {\n                 // `prim@char`\n                 if matches!(disambiguator, Some(Disambiguator::Primitive)) {\n-                    if fragment.is_some() {\n-                        anchor_failure(\n-                            self.cx,\n-                            diag_info,\n-                            AnchorFailure::RustdocAnchorConflict(prim),\n-                        );\n-                        return None;\n-                    }\n                     res = prim;\n-                    fragment = Some(prim.name(self.cx.tcx).to_string());\n                 } else {\n                     // `[char]` when a `char` module is in scope\n                     let candidates = vec![res, prim];\n@@ -1303,12 +1281,17 @@ impl LinkCollector<'_, '_> {\n                     }\n                 }\n \n-                Some(ItemLink { link: ori_link.link, link_text, did: None, fragment })\n+                Some(ItemLink {\n+                    link: ori_link.link,\n+                    link_text,\n+                    did: res.def_id(self.cx.tcx),\n+                    fragment,\n+                })\n             }\n             Res::Def(kind, id) => {\n                 verify(kind, id)?;\n                 let id = clean::register_res(self.cx, rustc_hir::def::Res::Def(kind, id));\n-                Some(ItemLink { link: ori_link.link, link_text, did: Some(id), fragment })\n+                Some(ItemLink { link: ori_link.link, link_text, did: id, fragment })\n             }\n         }\n     }\n@@ -2069,8 +2052,11 @@ fn anchor_failure(cx: &DocContext<'_>, diag_info: DiagnosticInfo<'_>, failure: A\n             diag.span_label(sp, \"invalid anchor\");\n         }\n         if let AnchorFailure::RustdocAnchorConflict(Res::Primitive(_)) = failure {\n-            diag.note(\"this restriction may be lifted in a future release\");\n-            diag.note(\"see https://github.com/rust-lang/rust/issues/83083 for more information\");\n+            if let Some(sp) = sp {\n+                span_bug!(sp, \"anchors should be allowed now\");\n+            } else {\n+                bug!(\"anchors should be allowed now\");\n+            }\n         }\n     });\n }\n@@ -2198,10 +2184,11 @@ fn handle_variant(\n     use rustc_middle::ty::DefIdTree;\n \n     if extra_fragment.is_some() {\n+        // NOTE: `res` can never be a primitive since this function is only called when `tcx.def_kind(res) == DefKind::Variant`.\n         return Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(res)));\n     }\n     cx.tcx\n-        .parent(res.def_id())\n+        .parent(res.def_id(cx.tcx))\n         .map(|parent| {\n             let parent_def = Res::Def(DefKind::Enum, parent);\n             let variant = cx.tcx.expect_variant_res(res.as_hir_res().unwrap());"}, {"sha": "1c92d019606b673f056ecd613478c877eb6d8afc", "filename": "src/test/rustdoc-js-std/multi-query.js", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftest%2Frustdoc-js-std%2Fmulti-query.js", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftest%2Frustdoc-js-std%2Fmulti-query.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fmulti-query.js?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -2,8 +2,9 @@ const QUERY = 'str,u8';\n \n const EXPECTED = {\n     'others': [\n-        { 'path': 'std', 'name': 'str' },\n-        { 'path': 'std', 'name': 'u8' },\n-        { 'path': 'std::ffi', 'name': 'CStr' },\n+        { 'path': 'std', 'name': 'str', 'href': '../std/primitive.str.html' },\n+        { 'path': 'std', 'name': 'u8', 'href': '../std/primitive.u8.html'  },\n+        { 'path': 'std', 'name': 'str', 'href': '../std/str/index.html' },\n+        { 'path': 'std', 'name': 'u8', 'href': '../std/u8/index.html' },\n     ],\n };"}, {"sha": "34e11c7c7b7cf6ca06f7dc47bafb2f7ffcbb5c28", "filename": "src/test/rustdoc-ui/intra-doc/anchors.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fanchors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fanchors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fanchors.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -37,13 +37,3 @@ pub fn bar() {}\n /// Damn enum's variants: [Enum::A#whatever].\n //~^ ERROR `Enum::A#whatever` contains an anchor\n pub fn enum_link() {}\n-\n-/// Primitives?\n-///\n-/// [u32#hello]\n-//~^ ERROR `u32#hello` contains an anchor\n-pub fn x() {}\n-\n-/// [prim@usize#x]\n-//~^ ERROR `prim@usize#x` contains an anchor\n-pub mod usize {}"}, {"sha": "0d226b277535ce047702b5690a8e3645d099fb59", "filename": "src/test/rustdoc-ui/intra-doc/anchors.stderr", "status": "modified", "additions": 7, "deletions": 28, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fanchors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fanchors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fanchors.stderr?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -1,26 +1,16 @@\n-error: `prim@usize#x` contains an anchor, but links to builtin types are already anchored\n-  --> $DIR/anchors.rs:47:6\n-   |\n-LL | /// [prim@usize#x]\n-   |      ^^^^^^^^^^--\n-   |                |\n-   |                invalid anchor\n-   |\n-note: the lint level is defined here\n-  --> $DIR/anchors.rs:1:9\n-   |\n-LL | #![deny(rustdoc::broken_intra_doc_links)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: this restriction may be lifted in a future release\n-   = note: see https://github.com/rust-lang/rust/issues/83083 for more information\n-\n error: `Foo::f#hola` contains an anchor, but links to fields are already anchored\n   --> $DIR/anchors.rs:25:15\n    |\n LL | /// Or maybe [Foo::f#hola].\n    |               ^^^^^^-----\n    |                     |\n    |                     invalid anchor\n+   |\n+note: the lint level is defined here\n+  --> $DIR/anchors.rs:1:9\n+   |\n+LL | #![deny(rustdoc::broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `hello#people#!` contains multiple anchors\n   --> $DIR/anchors.rs:31:28\n@@ -38,16 +28,5 @@ LL | /// Damn enum's variants: [Enum::A#whatever].\n    |                                   |\n    |                                   invalid anchor\n \n-error: `u32#hello` contains an anchor, but links to builtin types are already anchored\n-  --> $DIR/anchors.rs:43:6\n-   |\n-LL | /// [u32#hello]\n-   |      ^^^------\n-   |         |\n-   |         invalid anchor\n-   |\n-   = note: this restriction may be lifted in a future release\n-   = note: see https://github.com/rust-lang/rust/issues/83083 for more information\n-\n-error: aborting due to 5 previous errors\n+error: aborting due to 3 previous errors\n "}, {"sha": "695fa58ef1d55e500eae3c71fabe2f545cfb15be", "filename": "src/test/rustdoc/auxiliary/issue-15318.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftest%2Frustdoc%2Fauxiliary%2Fissue-15318.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftest%2Frustdoc%2Fauxiliary%2Fissue-15318.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fissue-15318.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -1,6 +1,15 @@\n+// no-prefer-dynamic\n // compile-flags: -Cmetadata=aux\n-\n+#![crate_type = \"rlib\"]\n #![doc(html_root_url = \"http://example.com/\")]\n+#![feature(lang_items)]\n+#![no_std]\n+\n+#[lang = \"eh_personality\"]\n+fn foo() {}\n+\n+#[panic_handler]\n+fn bar(_: &core::panic::PanicInfo) -> ! { loop {} }\n \n /// dox\n #[doc(primitive = \"pointer\")]"}, {"sha": "e8da852a57e631fd32a5938a7a2e4c939e3a36d7", "filename": "src/test/rustdoc/auxiliary/primitive-doc.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftest%2Frustdoc%2Fauxiliary%2Fprimitive-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftest%2Frustdoc%2Fauxiliary%2Fprimitive-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fprimitive-doc.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -1,5 +1,8 @@\n // compile-flags: --crate-type lib --edition 2018\n \n+#![feature(no_core)]\n+#![no_core]\n+\n #[doc(primitive = \"usize\")]\n /// This is the built-in type `usize`.\n mod usize {"}, {"sha": "120b6e9747f4aef1f8f1da144f5e6365f38b6dd0", "filename": "src/test/rustdoc/cross-crate-primitive-doc.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftest%2Frustdoc%2Fcross-crate-primitive-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftest%2Frustdoc%2Fcross-crate-primitive-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcross-crate-primitive-doc.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -1,9 +1,13 @@\n // aux-build:primitive-doc.rs\n // compile-flags: --extern-html-root-url=primitive_doc=../ -Z unstable-options\n+// ignore-windows\n \n-#![no_std]\n+#![feature(no_core)]\n+#![no_core]\n \n extern crate primitive_doc;\n \n // @has 'cross_crate_primitive_doc/fn.foo.html' '//a[@href=\"../primitive_doc/primitive.usize.html\"]' 'usize'\n+// @has 'cross_crate_primitive_doc/fn.foo.html' '//a[@href=\"../primitive_doc/primitive.usize.html\"]' 'link'\n+/// [link](usize)\n pub fn foo() -> usize { 0 }"}, {"sha": "3d4c464960bbce203dfe03debacbb40a5317802e", "filename": "src/test/rustdoc/intra-doc/anchors.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftest%2Frustdoc%2Fintra-doc%2Fanchors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftest%2Frustdoc%2Fintra-doc%2Fanchors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fanchors.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -10,3 +10,15 @@ pub struct Something;\n ///\n /// To link to [Something#Anchor!]\n pub struct SomeOtherType;\n+\n+/// Primitives?\n+///\n+/// [u32#hello]\n+// @has anchors/fn.x.html\n+// @has - '//a/@href' '{{channel}}/std/primitive.u32.html#hello'\n+pub fn x() {}\n+\n+/// [prim@usize#x]\n+// @has anchors/usize/index.html\n+// @has - '//a/@href' '{{channel}}/std/primitive.usize.html#x'\n+pub mod usize {}"}, {"sha": "92cfd46188b015eba5d86c5d2420b0f976abc562", "filename": "src/test/rustdoc/intra-doc/auxiliary/my-core.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftest%2Frustdoc%2Fintra-doc%2Fauxiliary%2Fmy-core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftest%2Frustdoc%2Fintra-doc%2Fauxiliary%2Fmy-core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fauxiliary%2Fmy-core.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -2,6 +2,10 @@\n #![no_core]\n #![crate_type=\"rlib\"]\n \n+#[doc(primitive = \"char\")]\n+/// Some char docs\n+mod char {}\n+\n #[lang = \"char\"]\n impl char {\n     pub fn len_utf8(self) -> usize {"}, {"sha": "5a92a28556eded64fb62281464527a128d3027af", "filename": "src/test/rustdoc/intra-doc/prim-methods-external-core.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-methods-external-core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-methods-external-core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-methods-external-core.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -9,8 +9,8 @@\n #![crate_type = \"rlib\"]\n \n // @has prim_methods_external_core/index.html\n-// @has - '//*[@id=\"main\"]//a[@href=\"{{channel}}/std/primitive.char.html\"]' 'char'\n-// @has - '//*[@id=\"main\"]//a[@href=\"{{channel}}/std/primitive.char.html#method.len_utf8\"]' 'char::len_utf8'\n+// @has - '//*[@id=\"main\"]//a[@href=\"../my_core/primitive.char.html\"]' 'char'\n+// @has - '//*[@id=\"main\"]//a[@href=\"../my_core/primitive.char.html#method.len_utf8\"]' 'char::len_utf8'\n \n //! A [`char`] and its [`char::len_utf8`].\n "}, {"sha": "cfb3c3842ab161694f954813ddfa9823269ce9bf", "filename": "src/test/rustdoc/intra-doc/prim-methods-local.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-methods-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-methods-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-methods-local.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -5,10 +5,13 @@\n \n \n // @has prim_methods_local/index.html\n-// @has - '//*[@id=\"main\"]//a[@href=\"{{channel}}/std/primitive.char.html\"]' 'char'\n-// @has - '//*[@id=\"main\"]//a[@href=\"{{channel}}/std/primitive.char.html#method.len_utf8\"]' 'char::len_utf8'\n+// @has - '//*[@id=\"main\"]//a[@href=\"primitive.char.html\"]' 'char'\n+// @has - '//*[@id=\"main\"]//a[@href=\"primitive.char.html#method.len_utf8\"]' 'char::len_utf8'\n \n-//! A [`char`] and its [`char::len_utf8`].\n+//! A [prim@`char`] and its [`char::len_utf8`].\n+\n+#[doc(primitive = \"char\")]\n+mod char {}\n \n #[lang = \"char\"]\n impl char {"}, {"sha": "8c47f7ef77e5181e2d88e9d1d58aba86f9682ccf", "filename": "src/test/rustdoc/intra-link-prim-self.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftest%2Frustdoc%2Fintra-link-prim-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftest%2Frustdoc%2Fintra-link-prim-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-prim-self.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -7,8 +7,8 @@\n /// [Self::f]\n /// [Self::MAX]\n // @has intra_link_prim_self/primitive.usize.html\n-// @has - '//a[@href=\"{{channel}}/std/primitive.usize.html#method.f\"]' 'Self::f'\n-// @has - '//a[@href=\"{{channel}}/std/primitive.usize.html#associatedconstant.MAX\"]' 'Self::MAX'\n+// @has - '//a[@href=\"primitive.usize.html#method.f\"]' 'Self::f'\n+// @has - '//a[@href=\"primitive.usize.html#associatedconstant.MAX\"]' 'Self::MAX'\n impl usize {\n     /// Some docs\n     pub fn f() {}"}, {"sha": "f7f5052a36dd34329d3c218c0ad7a2c4fe183e7d", "filename": "src/test/rustdoc/issue-15318-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftest%2Frustdoc%2Fissue-15318-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftest%2Frustdoc%2Fissue-15318-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-15318-2.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -1,5 +1,6 @@\n // aux-build:issue-15318.rs\n // ignore-cross-compile\n+#![no_std]\n \n extern crate issue_15318;\n "}, {"sha": "22fd392dd36c349fc062f7363423c6dc40ce4ec7", "filename": "src/test/rustdoc/no_std-primitive.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftest%2Frustdoc%2Fno_std-primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftest%2Frustdoc%2Fno_std-primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fno_std-primitive.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -0,0 +1,6 @@\n+#![no_std]\n+\n+/// Link to [intra-doc link][u8]\n+// @has 'no_std_primitive/fn.foo.html' '//a[@href=\"{{channel}}/core/primitive.u8.html\"]' 'intra-doc link'\n+// @has - '//a[@href=\"{{channel}}/core/primitive.u8.html\"]' 'u8'\n+pub fn foo() -> u8 {}"}, {"sha": "f0f70cb6c1881dff604c29f3d253eea19601d569", "filename": "src/test/rustdoc/primitive/no_std.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftest%2Frustdoc%2Fprimitive%2Fno_std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftest%2Frustdoc%2Fprimitive%2Fno_std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fprimitive%2Fno_std.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -0,0 +1,16 @@\n+#![no_std]\n+#![deny(warnings)]\n+#![deny(rustdoc::broken_intra_doc_links)]\n+\n+// @has no_std/fn.foo.html '//a/[@href=\"{{channel}}/core/primitive.u8.html\"]' 'u8'\n+// @has no_std/fn.foo.html '//a/[@href=\"{{channel}}/core/primitive.u8.html\"]' 'primitive link'\n+/// Link to [primitive link][u8]\n+pub fn foo() -> u8 {}\n+\n+// Test that all primitives can be linked to.\n+/// [isize] [i8] [i16] [i32] [i64] [i128]\n+/// [usize] [u8] [u16] [u32] [u64] [u128]\n+/// [f32] [f64]\n+/// [char] [bool] [str] [slice] [array] [tuple] [unit]\n+/// [pointer] [reference] [fn] [never]\n+pub fn bar() {}"}, {"sha": "94ebbb33e8d8ffad075cd6d06d3248e13e5ecf48", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -30,13 +30,27 @@ use regex::Regex;\n // If at all possible you should use intra-doc links to avoid linkcheck issues. These\n // are cases where that does not work\n // [(generated_documentation_page, &[broken_links])]\n+#[rustfmt::skip]\n const LINKCHECK_EXCEPTIONS: &[(&str, &[&str])] = &[\n     // These try to link to std::collections, but are defined in alloc\n     // https://github.com/rust-lang/rust/issues/74481\n     (\"std/collections/btree_map/struct.BTreeMap.html\", &[\"#insert-and-complex-keys\"]),\n     (\"std/collections/btree_set/struct.BTreeSet.html\", &[\"#insert-and-complex-keys\"]),\n     (\"alloc/collections/btree_map/struct.BTreeMap.html\", &[\"#insert-and-complex-keys\"]),\n     (\"alloc/collections/btree_set/struct.BTreeSet.html\", &[\"#insert-and-complex-keys\"]),\n+\n+    // These try to link to various things in std, but are defined in core.\n+    // The docs in std::primitive use proper intra-doc links, so these seem fine to special-case.\n+    // Most these are broken because liballoc uses `#[lang_item]` magic to define things on\n+    // primitives that aren't available in core.\n+    (\"alloc/slice/trait.Join.html\", &[\"#method.join\"]),\n+    (\"alloc/slice/trait.Concat.html\", &[\"#method.concat\"]),\n+    (\"alloc/slice/index.html\", &[\"#method.concat\", \"#method.join\"]),\n+    (\"alloc/vec/struct.Vec.html\", &[\"#method.sort_by_key\", \"#method.sort_by_cached_key\"]),\n+    (\"core/primitive.str.html\", &[\"#method.to_ascii_uppercase\", \"#method.to_ascii_lowercase\"]),\n+    (\"core/primitive.slice.html\", &[\"#method.to_ascii_uppercase\", \"#method.to_ascii_lowercase\",\n+                                    \"core/slice::sort_by_key\", \"core\\\\slice::sort_by_key\",\n+                                    \"#method.sort_by_cached_key\"]),\n ];\n \n #[rustfmt::skip]\n@@ -376,6 +390,10 @@ impl Checker {\n \n     /// Load a file from disk, or from the cache if available.\n     fn load_file(&mut self, file: &Path, report: &mut Report) -> (String, &FileEntry) {\n+        // https://docs.microsoft.com/en-us/windows/win32/debug/system-error-codes--0-499-\n+        #[cfg(windows)]\n+        const ERROR_INVALID_NAME: i32 = 123;\n+\n         let pretty_path =\n             file.strip_prefix(&self.root).unwrap_or(&file).to_str().unwrap().to_string();\n \n@@ -392,6 +410,14 @@ impl Checker {\n                 }\n                 Err(e) if e.kind() == ErrorKind::NotFound => FileEntry::Missing,\n                 Err(e) => {\n+                    // If a broken intra-doc link contains `::`, on windows, it will cause `ERROR_INVALID_NAME` rather than `NotFound`.\n+                    // Explicitly check for that so that the broken link can be allowed in `LINKCHECK_EXCEPTIONS`.\n+                    #[cfg(windows)]\n+                    if e.raw_os_error() == Some(ERROR_INVALID_NAME)\n+                        && file.as_os_str().to_str().map_or(false, |s| s.contains(\"::\"))\n+                    {\n+                        return FileEntry::Missing;\n+                    }\n                     panic!(\"unexpected read error for {}: {}\", file.display(), e);\n                 }\n             });"}, {"sha": "35809e599266c8111e6758f84307b1371838ea69", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -46,6 +46,7 @@ pub mod errors;\n pub mod extdeps;\n pub mod features;\n pub mod pal;\n+pub mod primitive_docs;\n pub mod style;\n pub mod target_specific_tests;\n pub mod ui_tests;"}, {"sha": "d555f7c8e34fffbaefb5158ddc5e2b815bf77ea3", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -71,6 +71,7 @@ fn main() {\n \n         // Checks that only make sense for the std libs.\n         check!(pal, &library_path);\n+        check!(primitive_docs, &library_path);\n \n         // Checks that need to be done for both the compiler and std libraries.\n         check!(unit_tests, &src_path);"}, {"sha": "8476650d9b5f726e0c2884add732f8667859cbdd", "filename": "src/tools/tidy/src/primitive_docs.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftools%2Ftidy%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0273e3bce7a0ce49e96a9662163e2380cb87e0be/src%2Ftools%2Ftidy%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fprimitive_docs.rs?ref=0273e3bce7a0ce49e96a9662163e2380cb87e0be", "patch": "@@ -0,0 +1,17 @@\n+//! Tidy check to make sure `library/{std,core}/src/primitive_docs.rs` are the same file.  These are\n+//! different files so that relative links work properly without having to have `CARGO_PKG_NAME`\n+//! set, but conceptually they should always be the same.\n+\n+use std::path::Path;\n+\n+pub fn check(library_path: &Path, bad: &mut bool) {\n+    let std_name = \"std/src/primitive_docs.rs\";\n+    let core_name = \"core/src/primitive_docs.rs\";\n+    let std_contents = std::fs::read_to_string(library_path.join(std_name))\n+        .unwrap_or_else(|e| panic!(\"failed to read library/{}: {}\", std_name, e));\n+    let core_contents = std::fs::read_to_string(library_path.join(core_name))\n+        .unwrap_or_else(|e| panic!(\"failed to read library/{}: {}\", core_name, e));\n+    if std_contents != core_contents {\n+        tidy_error!(bad, \"library/{} and library/{} have different contents\", core_name, std_name);\n+    }\n+}"}]}