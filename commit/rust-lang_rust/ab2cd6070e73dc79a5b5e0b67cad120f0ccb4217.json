{"sha": "ab2cd6070e73dc79a5b5e0b67cad120f0ccb4217", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiMmNkNjA3MGU3M2RjNzlhNWI1ZTBiNjdjYWQxMjBmMGNjYjQyMTc=", "commit": {"author": {"name": "Konrad Borowski", "email": "konrad@borowski.pw", "date": "2018-12-05T13:39:42Z"}, "committer": {"name": "Konrad Borowski", "email": "konrad@borowski.pw", "date": "2018-12-05T14:40:14Z"}, "message": "Add unstable Iterator::copied()", "tree": {"sha": "0ba4c6db9c99a6aa6fbc1f820fad8febbb15db9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ba4c6db9c99a6aa6fbc1f820fad8febbb15db9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab2cd6070e73dc79a5b5e0b67cad120f0ccb4217", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab2cd6070e73dc79a5b5e0b67cad120f0ccb4217", "html_url": "https://github.com/rust-lang/rust/commit/ab2cd6070e73dc79a5b5e0b67cad120f0ccb4217", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab2cd6070e73dc79a5b5e0b67cad120f0ccb4217/comments", "author": {"login": "xfix", "id": 1297598, "node_id": "MDQ6VXNlcjEyOTc1OTg=", "avatar_url": "https://avatars.githubusercontent.com/u/1297598?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xfix", "html_url": "https://github.com/xfix", "followers_url": "https://api.github.com/users/xfix/followers", "following_url": "https://api.github.com/users/xfix/following{/other_user}", "gists_url": "https://api.github.com/users/xfix/gists{/gist_id}", "starred_url": "https://api.github.com/users/xfix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xfix/subscriptions", "organizations_url": "https://api.github.com/users/xfix/orgs", "repos_url": "https://api.github.com/users/xfix/repos", "events_url": "https://api.github.com/users/xfix/events{/privacy}", "received_events_url": "https://api.github.com/users/xfix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xfix", "id": 1297598, "node_id": "MDQ6VXNlcjEyOTc1OTg=", "avatar_url": "https://avatars.githubusercontent.com/u/1297598?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xfix", "html_url": "https://github.com/xfix", "followers_url": "https://api.github.com/users/xfix/followers", "following_url": "https://api.github.com/users/xfix/following{/other_user}", "gists_url": "https://api.github.com/users/xfix/gists{/gist_id}", "starred_url": "https://api.github.com/users/xfix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xfix/subscriptions", "organizations_url": "https://api.github.com/users/xfix/orgs", "repos_url": "https://api.github.com/users/xfix/repos", "events_url": "https://api.github.com/users/xfix/events{/privacy}", "received_events_url": "https://api.github.com/users/xfix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "705383adb037dddd834970d2c10edb32dae9fa56", "url": "https://api.github.com/repos/rust-lang/rust/commits/705383adb037dddd834970d2c10edb32dae9fa56", "html_url": "https://github.com/rust-lang/rust/commit/705383adb037dddd834970d2c10edb32dae9fa56"}], "stats": {"total": 129, "additions": 128, "deletions": 1}, "files": [{"sha": "80bd5698c47269c2edd94cc27cba0fc97eb4a5f5", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ab2cd6070e73dc79a5b5e0b67cad120f0ccb4217/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2cd6070e73dc79a5b5e0b67cad120f0ccb4217/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=ab2cd6070e73dc79a5b5e0b67cad120f0ccb4217", "patch": "@@ -12,7 +12,7 @@ use cmp::Ordering;\n use ops::Try;\n \n use super::LoopState;\n-use super::{Chain, Cycle, Cloned, Enumerate, Filter, FilterMap, Fuse};\n+use super::{Chain, Cycle, Copied, Cloned, Enumerate, Filter, FilterMap, Fuse};\n use super::{Flatten, FlatMap, flatten_compat};\n use super::{Inspect, Map, Peekable, Scan, Skip, SkipWhile, StepBy, Take, TakeWhile, Rev};\n use super::{Zip, Sum, Product};\n@@ -2234,6 +2234,35 @@ pub trait Iterator {\n         (ts, us)\n     }\n \n+    /// Creates an iterator which copies all of its elements.\n+    ///\n+    /// This is useful when you have an iterator over `&T`, but you need an\n+    /// iterator over `T`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_copied)]\n+    ///\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let v_cloned: Vec<_> = a.iter().copied().collect();\n+    ///\n+    /// // copied is the same as .map(|&x| x)\n+    /// let v_map: Vec<_> = a.iter().map(|&x| x).collect();\n+    ///\n+    /// assert_eq!(v_cloned, vec![1, 2, 3]);\n+    /// assert_eq!(v_map, vec![1, 2, 3]);\n+    /// ```\n+    #[unstable(feature = \"iter_copied\", issue = \"0\")]\n+    fn copied<'a, T: 'a>(self) -> Copied<Self>\n+        where Self: Sized + Iterator<Item=&'a T>, T: Copy\n+    {\n+        Copied { it: self }\n+    }\n+\n     /// Creates an iterator which [`clone`]s all of its elements.\n     ///\n     /// This is useful when you have an iterator over `&T`, but you need an"}, {"sha": "a23a404e3788b2b427ff7bd8cc038159f89e4e04", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/ab2cd6070e73dc79a5b5e0b67cad120f0ccb4217/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2cd6070e73dc79a5b5e0b67cad120f0ccb4217/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=ab2cd6070e73dc79a5b5e0b67cad120f0ccb4217", "patch": "@@ -501,6 +501,104 @@ impl<I> FusedIterator for Rev<I>\n unsafe impl<I> TrustedLen for Rev<I>\n     where I: TrustedLen + DoubleEndedIterator {}\n \n+/// An iterator that copies the elements of an underlying iterator.\n+///\n+/// This `struct` is created by the [`copied`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`copied`]: trait.Iterator.html#method.copied\n+/// [`Iterator`]: trait.Iterator.html\n+#[unstable(feature = \"iter_copied\", issue = \"0\")]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[derive(Clone, Debug)]\n+pub struct Copied<I> {\n+    it: I,\n+}\n+\n+#[unstable(feature = \"iter_copied\", issue = \"0\")]\n+impl<'a, I, T: 'a> Iterator for Copied<I>\n+    where I: Iterator<Item=&'a T>, T: Copy\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        self.it.next().copied()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.it.size_hint()\n+    }\n+\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.it.try_fold(init, move |acc, &elt| f(acc, elt))\n+    }\n+\n+    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.it.fold(init, move |acc, &elt| f(acc, elt))\n+    }\n+}\n+\n+#[unstable(feature = \"iter_copied\", issue = \"0\")]\n+impl<'a, I, T: 'a> DoubleEndedIterator for Copied<I>\n+    where I: DoubleEndedIterator<Item=&'a T>, T: Copy\n+{\n+    fn next_back(&mut self) -> Option<T> {\n+        self.it.next_back().cloned()\n+    }\n+\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.it.try_rfold(init, move |acc, elt| f(acc, elt.clone()))\n+    }\n+\n+    fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.it.rfold(init, move |acc, elt| f(acc, elt.clone()))\n+    }\n+}\n+\n+#[unstable(feature = \"iter_copied\", issue = \"0\")]\n+impl<'a, I, T: 'a> ExactSizeIterator for Copied<I>\n+    where I: ExactSizeIterator<Item=&'a T>, T: Copy\n+{\n+    fn len(&self) -> usize {\n+        self.it.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.it.is_empty()\n+    }\n+}\n+\n+#[unstable(feature = \"iter_copied\", issue = \"0\")]\n+impl<'a, I, T: 'a> FusedIterator for Copied<I>\n+    where I: FusedIterator<Item=&'a T>, T: Copy\n+{}\n+\n+#[doc(hidden)]\n+unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Copied<I>\n+    where I: TrustedRandomAccess<Item=&'a T>, T: Copy\n+{\n+    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n+        *self.it.get_unchecked(i)\n+    }\n+\n+    #[inline]\n+    fn may_have_side_effect() -> bool { false }\n+}\n+\n+#[unstable(feature = \"iter_copied\", issue = \"0\")]\n+unsafe impl<'a, I, T: 'a> TrustedLen for Copied<I>\n+    where I: TrustedLen<Item=&'a T>,\n+          T: Copy\n+{}\n+\n /// An iterator that clones the elements of an underlying iterator.\n ///\n /// This `struct` is created by the [`cloned`] method on [`Iterator`]. See its"}]}