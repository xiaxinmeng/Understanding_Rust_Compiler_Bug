{"sha": "4fff54381bde70cada702981912447f948e76e27", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmZmY1NDM4MWJkZTcwY2FkYTcwMjk4MTkxMjQ0N2Y5NDhlNzZlMjc=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-09-21T22:51:48Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-10-05T08:39:39Z"}, "message": "Add flag to `mir::LocalDecl` to track whether its a temp from some subexpr a block tail expression.\n\nSlightly refactored the `LocalDecl` construction API in the process.", "tree": {"sha": "fcf3358f8dac978861d7c970c6ed7a78acff19b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fcf3358f8dac978861d7c970c6ed7a78acff19b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4fff54381bde70cada702981912447f948e76e27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4fff54381bde70cada702981912447f948e76e27", "html_url": "https://github.com/rust-lang/rust/commit/4fff54381bde70cada702981912447f948e76e27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4fff54381bde70cada702981912447f948e76e27/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8bea5a0a6aef3966008787a25949344f8cf6942", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8bea5a0a6aef3966008787a25949344f8cf6942", "html_url": "https://github.com/rust-lang/rust/commit/b8bea5a0a6aef3966008787a25949344f8cf6942"}], "stats": {"total": 230, "additions": 207, "deletions": 23}, "files": [{"sha": "9312349ee405528d6db4a5fad114f29a5841e4c3", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4fff54381bde70cada702981912447f948e76e27/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fff54381bde70cada702981912447f948e76e27/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=4fff54381bde70cada702981912447f948e76e27", "patch": "@@ -29,6 +29,7 @@ impl_stable_hash_for!(struct mir::LocalDecl<'tcx> {\n     source_info,\n     visibility_scope,\n     internal,\n+    is_block_tail,\n     is_user_variable\n });\n impl_stable_hash_for!(struct mir::UpvarDecl { debug_name, var_hir_id, by_ref, mutability });"}, {"sha": "5ea097e72433d405f5d8d396013114becf192f6b", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4fff54381bde70cada702981912447f948e76e27/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fff54381bde70cada702981912447f948e76e27/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=4fff54381bde70cada702981912447f948e76e27", "patch": "@@ -638,6 +638,18 @@ mod binding_form_impl {\n     }\n }\n \n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub struct BlockTailInfo {\n+    /// If `true`, then the value resulting from evaluating this tail\n+    /// expression is ignored by the block's expression context.\n+    ///\n+    /// Examples include `{ ...; tail };` and `let _ = { ...; tail };`\n+    /// but not e.g. `let _x = { ...; tail };`\n+    pub tail_result_is_ignored: bool,\n+}\n+\n+impl_stable_hash_for!(struct BlockTailInfo { tail_result_is_ignored });\n+\n /// A MIR local.\n ///\n /// This can be a binding declared by the user, a temporary inserted by the compiler, a function\n@@ -677,6 +689,12 @@ pub struct LocalDecl<'tcx> {\n     /// generator.\n     pub internal: bool,\n \n+    /// If this local is a temporary and `is_block_tail` is `Some`,\n+    /// then it is a temporary created for evaluation of some\n+    /// subexpression of some block's tail expression (with no\n+    /// intervening statement context).\n+    pub is_block_tail: Option<BlockTailInfo>,\n+\n     /// Type of this local.\n     pub ty: Ty<'tcx>,\n \n@@ -825,10 +843,19 @@ impl<'tcx> LocalDecl<'tcx> {\n         Self::new_local(ty, Mutability::Mut, false, span)\n     }\n \n-    /// Create a new immutable `LocalDecl` for a temporary.\n+    /// Converts `self` into same `LocalDecl` except tagged as immutable.\n     #[inline]\n-    pub fn new_immutable_temp(ty: Ty<'tcx>, span: Span) -> Self {\n-        Self::new_local(ty, Mutability::Not, false, span)\n+    pub fn immutable(mut self) -> Self {\n+        self.mutability = Mutability::Not;\n+        self\n+    }\n+\n+    /// Converts `self` into same `LocalDecl` except tagged as internal temporary.\n+    #[inline]\n+    pub fn block_tail(mut self, info: BlockTailInfo) -> Self {\n+        assert!(self.is_block_tail.is_none());\n+        self.is_block_tail = Some(info);\n+        self\n     }\n \n     /// Create a new `LocalDecl` for a internal temporary.\n@@ -856,6 +883,7 @@ impl<'tcx> LocalDecl<'tcx> {\n             visibility_scope: OUTERMOST_SOURCE_SCOPE,\n             internal,\n             is_user_variable: None,\n+            is_block_tail: None,\n         }\n     }\n \n@@ -874,6 +902,7 @@ impl<'tcx> LocalDecl<'tcx> {\n             },\n             visibility_scope: OUTERMOST_SOURCE_SCOPE,\n             internal: false,\n+            is_block_tail: None,\n             name: None, // FIXME maybe we do want some name here?\n             is_user_variable: None,\n         }\n@@ -2668,6 +2697,7 @@ pub enum ClosureOutlivesSubject<'tcx> {\n  */\n \n CloneTypeFoldableAndLiftImpls! {\n+    BlockTailInfo,\n     Mutability,\n     SourceInfo,\n     UpvarDecl,\n@@ -2711,6 +2741,7 @@ BraceStructTypeFoldableImpl! {\n         user_ty,\n         name,\n         source_info,\n+        is_block_tail,\n         visibility_scope,\n     }\n }"}, {"sha": "7d8227053b373c3aa23ccdb6edf3150da8f66142", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4fff54381bde70cada702981912447f948e76e27/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fff54381bde70cada702981912447f948e76e27/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=4fff54381bde70cada702981912447f948e76e27", "patch": "@@ -728,6 +728,7 @@ macro_rules! make_mir_visitor {\n                     ref $($mutability)* visibility_scope,\n                     internal: _,\n                     is_user_variable: _,\n+                    is_block_tail: _,\n                 } = *local_decl;\n \n                 self.visit_ty(ty, TyContext::LocalDecl {"}, {"sha": "b754d63f7183bbb990e53394ea858db3d482d723", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4fff54381bde70cada702981912447f948e76e27/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fff54381bde70cada702981912447f948e76e27/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=4fff54381bde70cada702981912447f948e76e27", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use build::{BlockAnd, BlockAndExtension, Builder};\n+use build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n use build::ForGuard::OutsideGuard;\n use build::matches::ArmHasGuard;\n use hair::*;\n@@ -93,6 +93,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let Stmt { kind, opt_destruction_scope } = this.hir.mirror(stmt);\n             match kind {\n                 StmtKind::Expr { scope, expr } => {\n+                    this.block_context.push(BlockFrame::Statement { ignores_expr_result: true });\n                     unpack!(block = this.in_opt_scope(\n                         opt_destruction_scope.map(|de|(de, source_info)), block, |this| {\n                             let si = (scope, source_info);\n@@ -109,6 +110,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     initializer,\n                     lint_level\n                 } => {\n+                    let ignores_expr_result = if let PatternKind::Wild = *pattern.kind {\n+                        true\n+                    } else {\n+                        false\n+                    };\n+                    this.block_context.push(BlockFrame::Statement { ignores_expr_result });\n+\n                     // Enter the remainder scope, i.e. the bindings' destruction scope.\n                     this.push_scope((remainder_scope, source_info));\n                     let_scope_stack.push(remainder_scope);\n@@ -155,19 +163,40 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n+\n+            let popped = this.block_context.pop();\n+            assert!(popped.map_or(false, |bf|bf.is_statement()));\n         }\n+\n         // Then, the block may have an optional trailing expression which is a \u201creturn\u201d value\n-        // of the block.\n+        // of the block, which is stored into `destination`.\n+        let tcx = this.hir.tcx();\n+        let destination_ty = destination.ty(&this.local_decls, tcx).to_ty(tcx);\n         if let Some(expr) = expr {\n+            let tail_result_is_ignored = destination_ty.is_unit() ||\n+                match this.block_context.last() {\n+                    // no context: conservatively assume result is read\n+                    None => false,\n+\n+                    // sub-expression: block result feeds into some computation\n+                    Some(BlockFrame::SubExpr) => false,\n+\n+                    // otherwise: use accumualated is_ignored state.\n+                    Some(BlockFrame::TailExpr { tail_result_is_ignored: ignored }) |\n+                    Some(BlockFrame::Statement { ignores_expr_result: ignored }) => *ignored,\n+                };\n+            this.block_context.push(BlockFrame::TailExpr { tail_result_is_ignored });\n+\n             unpack!(block = this.into(destination, block, expr));\n+            let popped = this.block_context.pop();\n+\n+            assert!(popped.map_or(false, |bf|bf.is_tail_expr()));\n         } else {\n             // If a block has no trailing expression, then it is given an implicit return type.\n             // This return type is usually `()`, unless the block is diverging, in which case the\n             // return type is `!`. For the unit type, we need to actually return the unit, but in\n             // the case of `!`, no return value is required, as the block will never return.\n-            let tcx = this.hir.tcx();\n-            let ty = destination.ty(&this.local_decls, tcx).to_ty(tcx);\n-            if ty.is_unit() {\n+            if destination_ty.is_unit() {\n                 // We only want to assign an implicit `()` as the return value of the block if the\n                 // block does not diverge. (Otherwise, we may try to assign a unit to a `!`-type.)\n                 this.cfg.push_assign_unit(block, source_info, destination);"}, {"sha": "e0bf02c6739e3839354feeb79a8f375b0ec87629", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4fff54381bde70cada702981912447f948e76e27/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fff54381bde70cada702981912447f948e76e27/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=4fff54381bde70cada702981912447f948e76e27", "patch": "@@ -10,7 +10,7 @@\n \n //! See docs in build/expr/mod.rs\n \n-use build::{BlockAnd, BlockAndExtension, Builder};\n+use build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n use hair::*;\n use rustc::middle::region;\n use rustc::mir::*;\n@@ -59,14 +59,30 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n \n         let expr_ty = expr.ty;\n-        let temp = if mutability == Mutability::Not {\n-            this.local_decls\n-                .push(LocalDecl::new_immutable_temp(expr_ty, expr_span))\n-        } else {\n-            this.local_decls\n-                .push(LocalDecl::new_temp(expr_ty, expr_span))\n-        };\n+        let temp = {\n+            let mut local_decl = LocalDecl::new_temp(expr_ty, expr_span);\n+            if mutability == Mutability::Not {\n+                local_decl = local_decl.immutable();\n+            }\n+\n+            debug!(\"creating temp {:?} with block_context: {:?}\", local_decl, this.block_context);\n+            // Find out whether this temp is being created within the\n+            // tail expression of a block whose result is ignored.\n+            for bf in this.block_context.iter().rev() {\n+                match bf {\n+                    BlockFrame::SubExpr => continue,\n+                    BlockFrame::Statement { .. } => break,\n+                    &BlockFrame::TailExpr { tail_result_is_ignored } => {\n+                        local_decl = local_decl.block_tail(BlockTailInfo {\n+                            tail_result_is_ignored\n+                        });\n+                        break;\n+                    }\n+                }\n+            }\n \n+            this.local_decls.push(local_decl)\n+        };\n         if !expr_ty.is_never() {\n             this.cfg.push(\n                 block,"}, {"sha": "4f5ed34a46133622488aca3670bc13b646621b0a", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4fff54381bde70cada702981912447f948e76e27/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fff54381bde70cada702981912447f948e76e27/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=4fff54381bde70cada702981912447f948e76e27", "patch": "@@ -11,7 +11,7 @@\n //! See docs in build/expr/mod.rs\n \n use build::expr::category::{Category, RvalueFunc};\n-use build::{BlockAnd, BlockAndExtension, Builder};\n+use build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n use hair::*;\n use rustc::mir::*;\n use rustc::ty;\n@@ -39,7 +39,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let expr_span = expr.span;\n         let source_info = this.source_info(expr_span);\n \n-        match expr.kind {\n+        let expr_is_block_or_scope = match expr.kind {\n+            ExprKind::Block { .. } => true,\n+            ExprKind::Scope { .. } => true,\n+            _ => false,\n+        };\n+\n+        if !expr_is_block_or_scope {\n+            this.block_context.push(BlockFrame::SubExpr);\n+        }\n+\n+        let block_and = match expr.kind {\n             ExprKind::Scope {\n                 region_scope,\n                 lint_level,\n@@ -302,6 +312,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         visibility_scope: source_info.scope,\n                         internal: true,\n                         is_user_variable: None,\n+                        is_block_tail: None,\n                     });\n                     let ptr_temp = Place::Local(ptr_temp);\n                     let block = unpack!(this.into(&ptr_temp, block, ptr));\n@@ -414,6 +425,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     .push_assign(block, source_info, destination, rvalue);\n                 block.unit()\n             }\n+        };\n+\n+        if !expr_is_block_or_scope {\n+            let popped = this.block_context.pop();\n+            assert!(popped.is_some());\n         }\n+\n+        block_and\n     }\n }"}, {"sha": "8cb2b6384b8dd7ec1a320488fc009911f6736aa3", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4fff54381bde70cada702981912447f948e76e27/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fff54381bde70cada702981912447f948e76e27/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=4fff54381bde70cada702981912447f948e76e27", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use build::scope::BreakableScope;\n-use build::{BlockAnd, BlockAndExtension, Builder};\n+use build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n use hair::*;\n use rustc::mir::*;\n \n@@ -40,19 +40,22 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // is better for borrowck interaction with overloaded\n                 // operators like x[j] = x[i].\n \n+                this.block_context.push(BlockFrame::SubExpr);\n+\n                 // Generate better code for things that don't need to be\n                 // dropped.\n                 if this.hir.needs_drop(lhs.ty) {\n                     let rhs = unpack!(block = this.as_local_operand(block, rhs));\n                     let lhs = unpack!(block = this.as_place(block, lhs));\n                     unpack!(block = this.build_drop_and_replace(block, lhs_span, lhs, rhs));\n-                    block.unit()\n                 } else {\n                     let rhs = unpack!(block = this.as_local_rvalue(block, rhs));\n                     let lhs = unpack!(block = this.as_place(block, lhs));\n                     this.cfg.push_assign(block, source_info, &lhs, rhs);\n-                    block.unit()\n                 }\n+\n+                this.block_context.pop();\n+                block.unit()\n             }\n             ExprKind::AssignOp { op, lhs, rhs } => {\n                 // FIXME(#28160) there is an interesting semantics\n@@ -66,6 +69,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let lhs = this.hir.mirror(lhs);\n                 let lhs_ty = lhs.ty;\n \n+                this.block_context.push(BlockFrame::SubExpr);\n+\n                 // As above, RTL.\n                 let rhs = unpack!(block = this.as_local_operand(block, rhs));\n                 let lhs = unpack!(block = this.as_place(block, lhs));\n@@ -85,6 +90,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 );\n                 this.cfg.push_assign(block, source_info, &lhs, result);\n \n+                this.block_context.pop();\n                 block.unit()\n             }\n             ExprKind::Continue { label } => {\n@@ -114,7 +120,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     (break_block, region_scope, break_destination.clone())\n                 };\n                 if let Some(value) = value {\n-                    unpack!(block = this.into(&destination, block, value))\n+                    this.block_context.push(BlockFrame::SubExpr);\n+                    unpack!(block = this.into(&destination, block, value));\n+                    this.block_context.pop();\n                 } else {\n                     this.cfg.push_assign_unit(block, source_info, &destination)\n                 }\n@@ -123,7 +131,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n             ExprKind::Return { value } => {\n                 block = match value {\n-                    Some(value) => unpack!(this.into(&Place::Local(RETURN_PLACE), block, value)),\n+                    Some(value) => {\n+                        this.block_context.push(BlockFrame::SubExpr);\n+                        let result = unpack!(this.into(&Place::Local(RETURN_PLACE), block, value));\n+                        this.block_context.pop();\n+                        result\n+                    }\n                     None => {\n                         this.cfg\n                             .push_assign_unit(block, source_info, &Place::Local(RETURN_PLACE));\n@@ -140,6 +153,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 outputs,\n                 inputs,\n             } => {\n+                this.block_context.push(BlockFrame::SubExpr);\n                 let outputs = outputs\n                     .into_iter()\n                     .map(|output| unpack!(block = this.as_place(block, output)))\n@@ -161,6 +175,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         },\n                     },\n                 );\n+                this.block_context.pop();\n                 block.unit()\n             }\n             _ => {"}, {"sha": "656c78a46ed78c84d75ce5366cdc21c004fec938", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fff54381bde70cada702981912447f948e76e27/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fff54381bde70cada702981912447f948e76e27/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=4fff54381bde70cada702981912447f948e76e27", "patch": "@@ -1485,6 +1485,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             source_info,\n             visibility_scope,\n             internal: false,\n+            is_block_tail: None,\n             is_user_variable: Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n                 binding_mode,\n                 // hypothetically, `visit_bindings` could try to unzip\n@@ -1518,6 +1519,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 visibility_scope,\n                 // FIXME: should these secretly injected ref_for_guard's be marked as `internal`?\n                 internal: false,\n+                is_block_tail: None,\n                 is_user_variable: Some(ClearCrossCrate::Set(BindingForm::RefForGuard)),\n             });\n             LocalsForNode::ForGuard {"}, {"sha": "9e78932bffea6d638b3b5b4594af01997f50dccf", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/4fff54381bde70cada702981912447f948e76e27/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fff54381bde70cada702981912447f948e76e27/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=4fff54381bde70cada702981912447f948e76e27", "patch": "@@ -281,6 +281,57 @@ fn liberated_closure_env_ty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     tcx.liberate_late_bound_regions(closure_def_id, &closure_env_ty)\n }\n \n+#[derive(Debug, PartialEq, Eq)]\n+pub enum BlockFrame {\n+    /// Evaluation is currently within a statement.\n+    ///\n+    /// Examples include:\n+    ///  1. `EXPR;`\n+    ///  2. `let _ = EXPR;`\n+    ///  3. `let x = EXPR;`\n+    Statement {\n+        /// If true, then statement discards result from evaluating\n+        /// the expression (such as examples 1 and 2 above).\n+        ignores_expr_result: bool\n+    },\n+\n+    /// Evaluation is currently within the tail expression of a block.\n+    ///\n+    /// Example: `{ STMT_1; STMT_2; EXPR }`\n+    TailExpr {\n+        /// If true, then the surrounding context of the block ignores\n+        /// the result of evaluating the block's tail expression.\n+        ///\n+        /// Example: `let _ = { STMT_1; EXPR };`\n+        tail_result_is_ignored: bool\n+    },\n+\n+    /// Generic mark meaning that the block occurred as a subexpression\n+    /// where the result might be used.\n+    ///\n+    /// Examples: `foo(EXPR)`, `match EXPR { ... }`\n+    SubExpr,\n+}\n+\n+impl BlockFrame {\n+    fn is_tail_expr(&self) -> bool {\n+        match *self {\n+            BlockFrame::TailExpr { .. } => true,\n+\n+            BlockFrame::Statement { .. } |\n+            BlockFrame::SubExpr => false,\n+        }\n+    }\n+    fn is_statement(&self) -> bool {\n+        match *self {\n+            BlockFrame::Statement { .. } => true,\n+\n+            BlockFrame::TailExpr { .. } |\n+            BlockFrame::SubExpr => false,\n+        }\n+    }\n+ }\n+\n struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     hir: Cx<'a, 'gcx, 'tcx>,\n     cfg: CFG<'tcx>,\n@@ -292,6 +343,20 @@ struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     /// see the `scope` module for more details\n     scopes: Vec<scope::Scope<'tcx>>,\n \n+    /// the block-context: each time we build the code within an hair::Block,\n+    /// we push a frame here tracking whether we are building a statement or\n+    /// if we are pushing the tail expression of the block. This is used to\n+    /// embed information in generated temps about whether they were created\n+    /// for a block tail expression or not.\n+    ///\n+    /// It would be great if we could fold this into `self.scopes`\n+    /// somehow; but right now I think that is very tightly tied to\n+    /// the code generation in ways that we cannot (or should not)\n+    /// start just throwing new entries onto that vector in order to\n+    /// distinguish the context of EXPR1 from the context of EXPR2 in\n+    /// `{ STMTS; EXPR1 } + EXPR2`\n+    block_context: Vec<BlockFrame>,\n+\n     /// The current unsafe block in scope, even if it is hidden by\n     /// a PushUnsafeBlock\n     unpushed_unsafe: Safety,\n@@ -695,6 +760,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             fn_span: span,\n             arg_count,\n             scopes: vec![],\n+            block_context: vec![],\n             source_scopes: IndexVec::new(),\n             source_scope: OUTERMOST_SOURCE_SCOPE,\n             source_scope_local_data: IndexVec::new(),\n@@ -781,6 +847,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 name,\n                 internal: false,\n                 is_user_variable: None,\n+                is_block_tail: None,\n             });\n         }\n "}, {"sha": "4c9d29bb6d070379aa3e1b5b3154e84ecc098682", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4fff54381bde70cada702981912447f948e76e27/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fff54381bde70cada702981912447f948e76e27/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=4fff54381bde70cada702981912447f948e76e27", "patch": "@@ -147,6 +147,7 @@ fn temp_decl(mutability: Mutability, ty: Ty, span: Span) -> LocalDecl {\n         visibility_scope: source_info.scope,\n         internal: false,\n         is_user_variable: None,\n+        is_block_tail: None,\n     }\n }\n "}, {"sha": "c2ae6832cc09f9f2c80fb038ef4c5760c8135e0b", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4fff54381bde70cada702981912447f948e76e27/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fff54381bde70cada702981912447f948e76e27/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=4fff54381bde70cada702981912447f948e76e27", "patch": "@@ -308,6 +308,7 @@ fn replace_result_variable<'tcx>(\n         source_info,\n         visibility_scope: source_info.scope,\n         internal: false,\n+        is_block_tail: None,\n         is_user_variable: None,\n     };\n     let new_ret_local = Local::new(mir.local_decls.len());\n@@ -662,6 +663,7 @@ fn create_generator_drop_shim<'a, 'tcx>(\n         source_info,\n         visibility_scope: source_info.scope,\n         internal: false,\n+        is_block_tail: None,\n         is_user_variable: None,\n     };\n \n@@ -679,6 +681,7 @@ fn create_generator_drop_shim<'a, 'tcx>(\n         source_info,\n         visibility_scope: source_info.scope,\n         internal: false,\n+        is_block_tail: None,\n         is_user_variable: None,\n     };\n "}]}