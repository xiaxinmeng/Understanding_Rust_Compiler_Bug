{"sha": "cff0ea5f88cf926a4cb326545ec63ccd27afb846", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmZjBlYTVmODhjZjkyNmE0Y2IzMjY1NDVlYzYzY2NkMjdhZmI4NDY=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-06-22T17:16:18Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-07-13T21:10:55Z"}, "message": "Move HashStable implementations.", "tree": {"sha": "802e99521d9f57bd002f534fd003a836918d634e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/802e99521d9f57bd002f534fd003a836918d634e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cff0ea5f88cf926a4cb326545ec63ccd27afb846", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cff0ea5f88cf926a4cb326545ec63ccd27afb846", "html_url": "https://github.com/rust-lang/rust/commit/cff0ea5f88cf926a4cb326545ec63ccd27afb846", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cff0ea5f88cf926a4cb326545ec63ccd27afb846/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72568552fdc34673b5ab3546843fe3bdbadb7926", "url": "https://api.github.com/repos/rust-lang/rust/commits/72568552fdc34673b5ab3546843fe3bdbadb7926", "html_url": "https://github.com/rust-lang/rust/commit/72568552fdc34673b5ab3546843fe3bdbadb7926"}], "stats": {"total": 121, "additions": 60, "deletions": 61}, "files": [{"sha": "daa331fe0522b0af374d024817a866c22f077dbe", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/cff0ea5f88cf926a4cb326545ec63ccd27afb846/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff0ea5f88cf926a4cb326545ec63ccd27afb846/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=cff0ea5f88cf926a4cb326545ec63ccd27afb846", "patch": "@@ -27,7 +27,7 @@\n use crate::edition::Edition;\n use crate::symbol::{kw, sym, Symbol};\n use crate::with_session_globals;\n-use crate::{BytePos, CachingSourceMapView, ExpnIdCache, SourceFile, Span, DUMMY_SP};\n+use crate::{BytePos, CachingSourceMapView, HashStableContext, SourceFile, Span, DUMMY_SP};\n \n use crate::def_id::{CrateNum, DefId, DefPathHash, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_data_structures::fingerprint::Fingerprint;\n@@ -36,6 +36,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{Lock, Lrc};\n use rustc_macros::HashStable_Generic;\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n+use std::cell::RefCell;\n use std::fmt;\n use std::hash::Hash;\n use std::thread::LocalKey;\n@@ -1407,3 +1408,60 @@ fn update_disambiguator(expn_id: ExpnId) {\n         };\n     }\n }\n+\n+impl<CTX: HashStableContext> HashStable<CTX> for SyntaxContext {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n+        const TAG_EXPANSION: u8 = 0;\n+        const TAG_NO_EXPANSION: u8 = 1;\n+\n+        if *self == SyntaxContext::root() {\n+            TAG_NO_EXPANSION.hash_stable(ctx, hasher);\n+        } else {\n+            TAG_EXPANSION.hash_stable(ctx, hasher);\n+            let (expn_id, transparency) = self.outer_mark();\n+            expn_id.hash_stable(ctx, hasher);\n+            transparency.hash_stable(ctx, hasher);\n+        }\n+    }\n+}\n+\n+pub type ExpnIdCache = RefCell<Vec<Option<Fingerprint>>>;\n+\n+impl<CTX: HashStableContext> HashStable<CTX> for ExpnId {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n+        const TAG_ROOT: u8 = 0;\n+        const TAG_NOT_ROOT: u8 = 1;\n+\n+        if *self == ExpnId::root() {\n+            TAG_ROOT.hash_stable(ctx, hasher);\n+            return;\n+        }\n+\n+        // Since the same expansion context is usually referenced many\n+        // times, we cache a stable hash of it and hash that instead of\n+        // recursing every time.\n+        let index = self.as_u32() as usize;\n+        let res = CTX::expn_id_cache().with(|cache| cache.borrow().get(index).copied().flatten());\n+\n+        if let Some(res) = res {\n+            res.hash_stable(ctx, hasher);\n+        } else {\n+            let new_len = index + 1;\n+\n+            let mut sub_hasher = StableHasher::new();\n+            TAG_NOT_ROOT.hash_stable(ctx, &mut sub_hasher);\n+            self.expn_data().hash_stable(ctx, &mut sub_hasher);\n+            let sub_hash: Fingerprint = sub_hasher.finish();\n+\n+            CTX::expn_id_cache().with(|cache| {\n+                let mut cache = cache.borrow_mut();\n+                if cache.len() < new_len {\n+                    cache.resize(new_len, None);\n+                }\n+                let prev = cache[index].replace(sub_hash);\n+                assert_eq!(prev, None, \"Cache slot was filled\");\n+            });\n+            sub_hash.hash_stable(ctx, hasher);\n+        }\n+    }\n+}"}, {"sha": "fa591521dbc8d417309014f028f1b04136e133bd", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 1, "deletions": 60, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/cff0ea5f88cf926a4cb326545ec63ccd27afb846/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff0ea5f88cf926a4cb326545ec63ccd27afb846/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=cff0ea5f88cf926a4cb326545ec63ccd27afb846", "patch": "@@ -36,9 +36,9 @@ use source_map::SourceMap;\n pub mod edition;\n use edition::Edition;\n pub mod hygiene;\n-pub use hygiene::SyntaxContext;\n use hygiene::Transparency;\n pub use hygiene::{DesugaringKind, ExpnData, ExpnId, ExpnKind, ForLoopLoc, MacroKind};\n+pub use hygiene::{ExpnIdCache, SyntaxContext};\n pub mod def_id;\n use def_id::{CrateNum, DefId, DefPathHash, LOCAL_CRATE};\n pub mod lev_distance;\n@@ -51,12 +51,10 @@ pub use symbol::{sym, Symbol};\n mod analyze_source_file;\n pub mod fatal_error;\n \n-use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{Lock, Lrc};\n \n use std::borrow::Cow;\n-use std::cell::RefCell;\n use std::cmp::{self, Ordering};\n use std::fmt;\n use std::hash::Hash;\n@@ -2036,60 +2034,3 @@ where\n         Hash::hash(&len, hasher);\n     }\n }\n-\n-impl<CTX: HashStableContext> HashStable<CTX> for SyntaxContext {\n-    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n-        const TAG_EXPANSION: u8 = 0;\n-        const TAG_NO_EXPANSION: u8 = 1;\n-\n-        if *self == SyntaxContext::root() {\n-            TAG_NO_EXPANSION.hash_stable(ctx, hasher);\n-        } else {\n-            TAG_EXPANSION.hash_stable(ctx, hasher);\n-            let (expn_id, transparency) = self.outer_mark();\n-            expn_id.hash_stable(ctx, hasher);\n-            transparency.hash_stable(ctx, hasher);\n-        }\n-    }\n-}\n-\n-pub type ExpnIdCache = RefCell<Vec<Option<Fingerprint>>>;\n-\n-impl<CTX: HashStableContext> HashStable<CTX> for ExpnId {\n-    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n-        const TAG_ROOT: u8 = 0;\n-        const TAG_NOT_ROOT: u8 = 1;\n-\n-        if *self == ExpnId::root() {\n-            TAG_ROOT.hash_stable(ctx, hasher);\n-            return;\n-        }\n-\n-        // Since the same expansion context is usually referenced many\n-        // times, we cache a stable hash of it and hash that instead of\n-        // recursing every time.\n-        let index = self.as_u32() as usize;\n-        let res = CTX::expn_id_cache().with(|cache| cache.borrow().get(index).copied().flatten());\n-\n-        if let Some(res) = res {\n-            res.hash_stable(ctx, hasher);\n-        } else {\n-            let new_len = index + 1;\n-\n-            let mut sub_hasher = StableHasher::new();\n-            TAG_NOT_ROOT.hash_stable(ctx, &mut sub_hasher);\n-            self.expn_data().hash_stable(ctx, &mut sub_hasher);\n-            let sub_hash: Fingerprint = sub_hasher.finish();\n-\n-            CTX::expn_id_cache().with(|cache| {\n-                let mut cache = cache.borrow_mut();\n-                if cache.len() < new_len {\n-                    cache.resize(new_len, None);\n-                }\n-                let prev = cache[index].replace(sub_hash);\n-                assert_eq!(prev, None, \"Cache slot was filled\");\n-            });\n-            sub_hash.hash_stable(ctx, hasher);\n-        }\n-    }\n-}"}]}