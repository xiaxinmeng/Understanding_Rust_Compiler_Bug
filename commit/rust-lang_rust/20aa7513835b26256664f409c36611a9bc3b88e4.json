{"sha": "20aa7513835b26256664f409c36611a9bc3b88e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwYWE3NTEzODM1YjI2MjU2NjY0ZjQwOWMzNjYxMWE5YmMzYjg4ZTQ=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2018-10-28T19:33:27Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2018-10-28T19:33:27Z"}, "message": "Choose predicates without inference variables over those with them\n\nFixes #54705\n\nWhen constructing synthetic auto trait impls, we may come across\nmultiple predicates involving the same type, trait, and substitutions.\nSince we can only display one of these, we pick the one with the 'most\nstrict' lifetime paramters. This ensures that the impl we render the\nuser is actually valid (that is, a struct matching that impl will\nactually implement the auto trait in question).\n\nThis commit exapnds the definition of 'more strict' to take into account\ninference variables. We always choose a predicate without inference\nvariables over a predicate with inference variables.", "tree": {"sha": "7a52f961ba97f844a423e8fe834d4a0e8ba2645c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a52f961ba97f844a423e8fe834d4a0e8ba2645c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20aa7513835b26256664f409c36611a9bc3b88e4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAlvWEEkACgkQtAh+UQ6Y\nsWR1+BAAoIpcwvzQ5GgUi6Em3OL6EMqRLfTplyArcx7mUx/q2NIVIteSaSs9LgWq\nkVNIY9QVaGJPJw3hEQqnPufkIDy21BDmiKS7m1Bt9+baL0kBvQ3r8Wx/8IMmhFJr\nPjLQEEVXkawsNWAAaBLZbyxqtCyUwAkItMVVjC/raENHqGR4zhfH49dRCs/oL4P6\nX5XD7ghsXtAsq3NUiFLsVnHHuPoRWkAlYZ8yMUfTXHq98hGseiwRCE61zJGdKlOY\nlN7odExbiAYHwv32uZT8w34OcsMzfebgCdcsKhO7UbPk9XSXvZojgcpuNu73b8wO\nL8+2/nETUN9AAU/02mR8cNm0Ygv71mbLQGSrLJuv17U6QMB1gSn5OZFSYbfYG4lZ\neSoeTBlN5jWjfBMexkPUXdL4klPtRMAzeoSm7l0RYMv/G36HXjgWQMNqA6OGBQ/f\nrL0WTRzyLDySlitWHyGzjcEoeaIRvA89hhsTiSjtjO59OjQyQ1vZ2T4ommTY2Sp2\nctz8WP0HiDVGZ8soUSm+H/EmPi5pSHYljxkS4Qvkpib5CLIXRHkLyCS7/c6vsQwX\nHdKdoU7ZlrhNLprtM2haK/GrSHXdiM+fA8ihpA8qGCoAImtFkp9O2cx7GZBHk/Wb\n/1nfj0fjt55AognykshTbKTZW1g+eF0isHxKFl4x4fdlM65RPjk=\n=avf2\n-----END PGP SIGNATURE-----", "payload": "tree 7a52f961ba97f844a423e8fe834d4a0e8ba2645c\nparent 4f5cfa611d392e87166dfe053ca253c3e822d835\nauthor Aaron Hill <aa1ronham@gmail.com> 1540755207 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1540755207 -0400\n\nChoose predicates without inference variables over those with them\n\nFixes #54705\n\nWhen constructing synthetic auto trait impls, we may come across\nmultiple predicates involving the same type, trait, and substitutions.\nSince we can only display one of these, we pick the one with the 'most\nstrict' lifetime paramters. This ensures that the impl we render the\nuser is actually valid (that is, a struct matching that impl will\nactually implement the auto trait in question).\n\nThis commit exapnds the definition of 'more strict' to take into account\ninference variables. We always choose a predicate without inference\nvariables over a predicate with inference variables.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20aa7513835b26256664f409c36611a9bc3b88e4", "html_url": "https://github.com/rust-lang/rust/commit/20aa7513835b26256664f409c36611a9bc3b88e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20aa7513835b26256664f409c36611a9bc3b88e4/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f5cfa611d392e87166dfe053ca253c3e822d835", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f5cfa611d392e87166dfe053ca253c3e822d835", "html_url": "https://github.com/rust-lang/rust/commit/4f5cfa611d392e87166dfe053ca253c3e822d835"}], "stats": {"total": 82, "additions": 73, "deletions": 9}, "files": [{"sha": "fea686d5db364e871c95ff948ab317dbe7fd17aa", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 33, "deletions": 9, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/20aa7513835b26256664f409c36611a9bc3b88e4/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20aa7513835b26256664f409c36611a9bc3b88e4/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=20aa7513835b26256664f409c36611a9bc3b88e4", "patch": "@@ -447,27 +447,51 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                                     ty::RegionKind::ReLateBound(_, _),\n                                 ) => {}\n \n-                                (ty::RegionKind::ReLateBound(_, _), _) => {\n+                                (ty::RegionKind::ReLateBound(_, _), _) |\n+                                (_, ty::RegionKind::ReVar(_)) => {\n+                                    // One of these is true:\n                                     // The new predicate has a HRTB in a spot where the old\n                                     // predicate does not (if they both had a HRTB, the previous\n-                                    // match arm would have executed).\n+                                    // match arm would have executed). A HRBT is a 'stricter'\n+                                    // bound than anything else, so we want to keep the newer\n+                                    // predicate (with the HRBT) in place of the old predicate.\n                                     //\n-                                    // The means we want to remove the older predicate from\n-                                    // user_computed_preds, since having both it and the new\n+                                    // OR\n+                                    //\n+                                    // The old predicate has a region variable where the new\n+                                    // predicate has some other kind of region. An region\n+                                    // variable isn't something we can actually display to a user,\n+                                    // so we choose ther new predicate (which doesn't have a region\n+                                    // varaible).\n+                                    //\n+                                    // In both cases, we want to remove the old predicate,\n+                                    // from user_computed_preds, and replace it with the new\n+                                    // one. Having both the old and the new\n                                     // predicate in a ParamEnv would confuse SelectionContext\n+                                    //\n                                     // We're currently in the predicate passed to 'retain',\n                                     // so we return 'false' to remove the old predicate from\n                                     // user_computed_preds\n                                     return false;\n                                 }\n-                                (_, ty::RegionKind::ReLateBound(_, _)) => {\n-                                    // This is the opposite situation as the previous arm - the\n-                                    // old predicate has a HRTB lifetime in a place where the\n-                                    // new predicate does not. We want to leave the old\n+                                (_, ty::RegionKind::ReLateBound(_, _)) |\n+                                (ty::RegionKind::ReVar(_), _) => {\n+                                    // This is the opposite situation as the previous arm.\n+                                    // One of these is true:\n+                                    //\n+                                    // The old predicate has a HRTB lifetime in a place where the\n+                                    // new predicate does not.\n+                                    //\n+                                    // OR\n+                                    //\n+                                    // The new predicate has a region variable where the old\n+                                    // predicate has some other type of region.\n+                                    //\n+                                    // We want to leave the old\n                                     // predicate in user_computed_preds, and skip adding\n                                     // new_pred to user_computed_params.\n                                     should_add_new = false\n-                                }\n+                                },\n                                 _ => {}\n                             }\n                         }"}, {"sha": "ccc939657a146dadb74f584b6d06b68ab3e1b207", "filename": "src/test/rustdoc/issue-54705.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/20aa7513835b26256664f409c36611a9bc3b88e4/src%2Ftest%2Frustdoc%2Fissue-54705.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20aa7513835b26256664f409c36611a9bc3b88e4/src%2Ftest%2Frustdoc%2Fissue-54705.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-54705.rs?ref=20aa7513835b26256664f409c36611a9bc3b88e4", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+pub trait ScopeHandle<'scope> {}\n+\n+\n+\n+// @has issue_54705/struct.ScopeFutureContents.html\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//*/code' \"impl<'scope, S> \\\n+// Send for ScopeFutureContents<'scope, S> where S: Sync\"\n+//\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//*/code' \"impl<'scope, S> \\\n+// Sync for ScopeFutureContents<'scope, S> where S: Sync\"\n+pub struct ScopeFutureContents<'scope, S>\n+    where S: ScopeHandle<'scope>,\n+{\n+    dummy: &'scope S,\n+    this: Box<ScopeFuture<'scope, S>>,\n+}\n+\n+struct ScopeFuture<'scope, S>\n+    where S: ScopeHandle<'scope>,\n+{\n+    contents: ScopeFutureContents<'scope, S>,\n+}\n+\n+unsafe impl<'scope, S> Send for ScopeFuture<'scope, S>\n+    where S: ScopeHandle<'scope>,\n+{}\n+unsafe impl<'scope, S> Sync for ScopeFuture<'scope, S>\n+    where S: ScopeHandle<'scope>,\n+{}"}]}