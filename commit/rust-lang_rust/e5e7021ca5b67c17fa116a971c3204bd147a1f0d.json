{"sha": "e5e7021ca5b67c17fa116a971c3204bd147a1f0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1ZTcwMjFjYTViNjdjMTdmYTExNmE5NzFjMzIwNGJkMTQ3YTFmMGQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-09-27T18:51:56Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-09-27T19:41:02Z"}, "message": "rustc: Tweak expansion order of custom derive\n\nThis commit alters the expansion order of custom macros-1.1 style `#[derive]`\nmodes. Instead of left-to-right the expansion now happens in three categories,\neach of which is internally left-to-right:\n\n* Old-style custom derive (`#[derive_Foo]`) is expanded\n* New-style custom derive (macros 1.1) is expanded\n* Built in derive modes are expanded\n\nThis gives built in derive modes maximal knowledge about the struct that's being\nexpanded and also avoids pesky issues like exposing `#[structural_match]` or\n`#[rustc_copy_clone_marker]`.\n\ncc #35900", "tree": {"sha": "5a02e6715d798f0cca684fa30ceab61d0ca01853", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a02e6715d798f0cca684fa30ceab61d0ca01853"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5e7021ca5b67c17fa116a971c3204bd147a1f0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5e7021ca5b67c17fa116a971c3204bd147a1f0d", "html_url": "https://github.com/rust-lang/rust/commit/e5e7021ca5b67c17fa116a971c3204bd147a1f0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5e7021ca5b67c17fa116a971c3204bd147a1f0d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea65ab6c7e96bf38c291ed7192137e6b96772687", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea65ab6c7e96bf38c291ed7192137e6b96772687", "html_url": "https://github.com/rust-lang/rust/commit/ea65ab6c7e96bf38c291ed7192137e6b96772687"}], "stats": {"total": 221, "additions": 124, "deletions": 97}, "files": [{"sha": "111596cfe88e03de33eacdbdce06c36536006d84", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 122, "deletions": 94, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/e5e7021ca5b67c17fa116a971c3204bd147a1f0d/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5e7021ca5b67c17fa116a971c3204bd147a1f0d/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=e5e7021ca5b67c17fa116a971c3204bd147a1f0d", "patch": "@@ -108,11 +108,109 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n         cx.span_err(mitem.span, \"unexpected value in `derive`\");\n     }\n \n-    let traits = mitem.meta_item_list().unwrap_or(&[]);\n+    let mut traits = mitem.meta_item_list().unwrap_or(&[]).to_owned();\n     if traits.is_empty() {\n         cx.span_warn(mitem.span, \"empty trait list in `derive`\");\n     }\n \n+    // First, weed out malformed #[derive]\n+    traits.retain(|titem| {\n+        if titem.word().is_none() {\n+            cx.span_err(titem.span, \"malformed `derive` entry\");\n+            false\n+        } else {\n+            true\n+        }\n+    });\n+\n+    // Next, check for old-style #[derive(Foo)]\n+    //\n+    // These all get expanded to `#[derive_Foo]` and will get expanded first. If\n+    // we actually add any attributes here then we return to get those expanded\n+    // and then eventually we'll come back to finish off the other derive modes.\n+    let mut new_attributes = Vec::new();\n+    traits.retain(|titem| {\n+        let tword = titem.word().unwrap();\n+        let tname = tword.name();\n+\n+        let derive_mode = ast::Ident::with_empty_ctxt(intern(&tname));\n+        let derive_mode = cx.resolver.resolve_derive_mode(derive_mode);\n+        if is_builtin_trait(&tname) || derive_mode.is_some() {\n+            return true\n+        }\n+\n+        if !cx.ecfg.enable_custom_derive() {\n+            feature_gate::emit_feature_err(&cx.parse_sess,\n+                                           \"custom_derive\",\n+                                           titem.span,\n+                                           feature_gate::GateIssue::Language,\n+                                           feature_gate::EXPLAIN_CUSTOM_DERIVE);\n+        } else {\n+            let name = intern_and_get_ident(&format!(\"derive_{}\", tname));\n+            let mitem = cx.meta_word(titem.span, name);\n+            new_attributes.push(cx.attribute(mitem.span, mitem));\n+        }\n+        false\n+    });\n+    if new_attributes.len() > 0 {\n+        item = item.map(|mut i| {\n+            let list = cx.meta_list(mitem.span,\n+                                    intern_and_get_ident(\"derive\"),\n+                                    traits);\n+            i.attrs.extend(new_attributes);\n+            i.attrs.push(cx.attribute(mitem.span, list));\n+            i\n+        });\n+        return vec![Annotatable::Item(item)]\n+    }\n+\n+    // Now check for macros-1.1 style custom #[derive].\n+    //\n+    // Expand each of them in order given, but *before* we expand any built-in\n+    // derive modes. The logic here is to:\n+    //\n+    // 1. Collect the remaining `#[derive]` annotations into a list. If\n+    //    there are any left, attach a `#[derive]` attribute to the item\n+    //    that we're currently expanding with the remaining derive modes.\n+    // 2. Manufacture a `#[derive(Foo)]` attribute to pass to the expander.\n+    // 3. Expand the current item we're expanding, getting back a list of\n+    //    items that replace it.\n+    // 4. Extend the returned list with the current list of items we've\n+    //    collected so far.\n+    // 5. Return everything!\n+    //\n+    // If custom derive extensions end up threading through the `#[derive]`\n+    // attribute, we'll get called again later on to continue expanding\n+    // those modes.\n+    let macros_11_derive = traits.iter()\n+                                 .cloned()\n+                                 .enumerate()\n+                                 .filter(|&(_, ref name)| !is_builtin_trait(&name.name().unwrap()))\n+                                 .next();\n+    if let Some((i, titem)) = macros_11_derive {\n+        let tname = ast::Ident::with_empty_ctxt(intern(&titem.name().unwrap()));\n+        let ext = cx.resolver.resolve_derive_mode(tname).unwrap();\n+        traits.remove(i);\n+        if traits.len() > 0 {\n+            item = item.map(|mut i| {\n+                let list = cx.meta_list(mitem.span,\n+                                        intern_and_get_ident(\"derive\"),\n+                                        traits);\n+                i.attrs.push(cx.attribute(mitem.span, list));\n+                i\n+            });\n+        }\n+        let titem = cx.meta_list_item_word(titem.span, titem.name().unwrap());\n+        let mitem = cx.meta_list(titem.span,\n+                                 intern_and_get_ident(\"derive\"),\n+                                 vec![titem]);\n+        let item = Annotatable::Item(item);\n+        return ext.expand(cx, mitem.span, &mitem, item)\n+    }\n+\n+    // Ok, at this point we know that there are no old-style `#[derive_Foo]` nor\n+    // any macros-1.1 style `#[derive(Foo)]`. Expand all built-in traits here.\n+\n     // RFC #1445. `#[derive(PartialEq, Eq)]` adds a (trusted)\n     // `#[structural_match]` attribute.\n     if traits.iter().filter_map(|t| t.name()).any(|t| t == \"PartialEq\") &&\n@@ -141,103 +239,33 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n         });\n     }\n \n-    let mut other_items = Vec::new();\n-\n-    let mut iter = traits.iter();\n-    while let Some(titem) = iter.next() {\n-\n-        let tword = match titem.word() {\n-            Some(name) => name,\n-            None => {\n-                cx.span_err(titem.span, \"malformed `derive` entry\");\n-                continue\n-            }\n+    let mut items = Vec::new();\n+    for titem in traits.iter() {\n+        let tname = titem.word().unwrap().name();\n+        let name = intern_and_get_ident(&format!(\"derive({})\", tname));\n+        let mitem = cx.meta_word(titem.span, name);\n+\n+        let span = Span {\n+            expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n+                call_site: titem.span,\n+                callee: codemap::NameAndSpan {\n+                    format: codemap::MacroAttribute(intern(&format!(\"derive({})\", tname))),\n+                    span: Some(titem.span),\n+                    allow_internal_unstable: true,\n+                },\n+            }),\n+            ..titem.span\n         };\n-        let tname = tword.name();\n \n-        // If this is a built-in derive mode, then we expand it immediately\n-        // here.\n-        if is_builtin_trait(&tname) {\n-            let name = intern_and_get_ident(&format!(\"derive({})\", tname));\n-            let mitem = cx.meta_word(titem.span, name);\n-\n-            let span = Span {\n-                expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n-                    call_site: titem.span,\n-                    callee: codemap::NameAndSpan {\n-                        format: codemap::MacroAttribute(intern(&format!(\"derive({})\", tname))),\n-                        span: Some(titem.span),\n-                        allow_internal_unstable: true,\n-                    },\n-                }),\n-                ..titem.span\n-            };\n-\n-            let my_item = Annotatable::Item(item);\n-            expand_builtin(&tname, cx, span, &mitem, &my_item, &mut |a| {\n-                other_items.push(a);\n-            });\n-            item = my_item.expect_item();\n-\n-        // Otherwise if this is a `rustc_macro`-style derive mode, we process it\n-        // here. The logic here is to:\n-        //\n-        // 1. Collect the remaining `#[derive]` annotations into a list. If\n-        //    there are any left, attach a `#[derive]` attribute to the item\n-        //    that we're currently expanding with the remaining derive modes.\n-        // 2. Manufacture a `#[derive(Foo)]` attribute to pass to the expander.\n-        // 3. Expand the current item we're expanding, getting back a list of\n-        //    items that replace it.\n-        // 4. Extend the returned list with the current list of items we've\n-        //    collected so far.\n-        // 5. Return everything!\n-        //\n-        // If custom derive extensions end up threading through the `#[derive]`\n-        // attribute, we'll get called again later on to continue expanding\n-        // those modes.\n-        } else if let Some(ext) =\n-                   cx.resolver.resolve_derive_mode(ast::Ident::with_empty_ctxt(intern(&tname))) {\n-            let remaining_derives = iter.cloned().collect::<Vec<_>>();\n-            if remaining_derives.len() > 0 {\n-                let list = cx.meta_list(titem.span,\n-                                        intern_and_get_ident(\"derive\"),\n-                                        remaining_derives);\n-                let attr = cx.attribute(titem.span, list);\n-                item = item.map(|mut i| {\n-                    i.attrs.push(attr);\n-                    i\n-                });\n-            }\n-            let titem = cx.meta_list_item_word(titem.span, tname.clone());\n-            let mitem = cx.meta_list(titem.span,\n-                                     intern_and_get_ident(\"derive\"),\n-                                     vec![titem]);\n-            let item = Annotatable::Item(item);\n-            let mut items = ext.expand(cx, mitem.span, &mitem, item);\n-            items.extend(other_items);\n-            return items\n-\n-        // If we've gotten this far then it means that we're in the territory of\n-        // the old custom derive mechanism. If the feature isn't enabled, we\n-        // issue an error, otherwise manufacture the `derive_Foo` attribute.\n-        } else if !cx.ecfg.enable_custom_derive() {\n-            feature_gate::emit_feature_err(&cx.parse_sess,\n-                                           \"custom_derive\",\n-                                           titem.span,\n-                                           feature_gate::GateIssue::Language,\n-                                           feature_gate::EXPLAIN_CUSTOM_DERIVE);\n-        } else {\n-            let name = intern_and_get_ident(&format!(\"derive_{}\", tname));\n-            let mitem = cx.meta_word(titem.span, name);\n-            item = item.map(|mut i| {\n-                i.attrs.push(cx.attribute(mitem.span, mitem));\n-                i\n-            });\n-        }\n+        let my_item = Annotatable::Item(item);\n+        expand_builtin(&tname, cx, span, &mitem, &my_item, &mut |a| {\n+            items.push(a);\n+        });\n+        item = my_item.expect_item();\n     }\n \n-    other_items.insert(0, Annotatable::Item(item));\n-    return other_items\n+    items.insert(0, Annotatable::Item(item));\n+    return items\n }\n \n macro_rules! derive_traits {"}, {"sha": "b7025c61fb6c4c4b9acbb4c75538cddaabf1bff4", "filename": "src/test/run-pass-fulldeps/rustc-macro/append-impl.rs", "status": "renamed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e5e7021ca5b67c17fa116a971c3204bd147a1f0d/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fappend-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5e7021ca5b67c17fa116a971c3204bd147a1f0d/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fappend-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fappend-impl.rs?ref=e5e7021ca5b67c17fa116a971c3204bd147a1f0d", "patch": "@@ -24,7 +24,6 @@ trait Append {\n          Append,\n          Eq)]\n struct A {\n-//~^ ERROR: the semantics of constant patterns is not yet settled\n     inner: u32,\n }\n ", "previous_filename": "src/test/compile-fail-fulldeps/rustc-macro/append-impl.rs"}, {"sha": "c3d295e02c163f7ec3236efae3506985fc77c5f7", "filename": "src/test/run-pass-fulldeps/rustc-macro/auxiliary/append-impl.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e5e7021ca5b67c17fa116a971c3204bd147a1f0d/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fappend-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5e7021ca5b67c17fa116a971c3204bd147a1f0d/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fappend-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fappend-impl.rs?ref=e5e7021ca5b67c17fa116a971c3204bd147a1f0d", "previous_filename": "src/test/compile-fail-fulldeps/rustc-macro/auxiliary/append-impl.rs"}, {"sha": "42155383decf95afdce9e754e61055043d3c071d", "filename": "src/test/run-pass-fulldeps/rustc-macro/auxiliary/derive-a.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5e7021ca5b67c17fa116a971c3204bd147a1f0d/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5e7021ca5b67c17fa116a971c3204bd147a1f0d/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-a.rs?ref=e5e7021ca5b67c17fa116a971c3204bd147a1f0d", "patch": "@@ -22,6 +22,6 @@ use rustc_macro::TokenStream;\n pub fn derive(input: TokenStream) -> TokenStream {\n     let input = input.to_string();\n     assert!(input.contains(\"struct A;\"));\n-    assert!(input.contains(\"#[derive(Eq, Copy, Clone)]\"));\n-    \"#[derive(Eq, Copy, Clone)] struct A;\".parse().unwrap()\n+    assert!(input.contains(\"#[derive(Debug, PartialEq, Eq, Copy, Clone)]\"));\n+    \"#[derive(Debug, PartialEq, Eq, Copy, Clone)] struct A;\".parse().unwrap()\n }"}]}