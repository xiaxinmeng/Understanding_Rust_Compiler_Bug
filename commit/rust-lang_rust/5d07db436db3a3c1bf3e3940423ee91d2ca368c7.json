{"sha": "5d07db436db3a3c1bf3e3940423ee91d2ca368c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkMDdkYjQzNmRiM2EzYzFiZjNlMzk0MDQyM2VlOTFkMmNhMzY4Yzc=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-07-24T01:27:18Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-19T19:02:33Z"}, "message": "Refactor confirm.rs (part ii)", "tree": {"sha": "b4061c0d3516f6120b81963e0cdb65f798d7bd01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4061c0d3516f6120b81963e0cdb65f798d7bd01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d07db436db3a3c1bf3e3940423ee91d2ca368c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d07db436db3a3c1bf3e3940423ee91d2ca368c7", "html_url": "https://github.com/rust-lang/rust/commit/5d07db436db3a3c1bf3e3940423ee91d2ca368c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d07db436db3a3c1bf3e3940423ee91d2ca368c7/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08d49a65e72c955f39b653a94a9013f11d328d21", "url": "https://api.github.com/repos/rust-lang/rust/commits/08d49a65e72c955f39b653a94a9013f11d328d21", "html_url": "https://github.com/rust-lang/rust/commit/08d49a65e72c955f39b653a94a9013f11d328d21"}], "stats": {"total": 94, "additions": 67, "deletions": 27}, "files": [{"sha": "401e57f31576419052be248d69e8dc5c65e07930", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 67, "deletions": 27, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/5d07db436db3a3c1bf3e3940423ee91d2ca368c7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d07db436db3a3c1bf3e3940423ee91d2ca368c7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=5d07db436db3a3c1bf3e3940423ee91d2ca368c7", "patch": "@@ -14,7 +14,7 @@ use astconv::AstConv;\n use check::{FnCtxt, PlaceOp, callee, Needs};\n use hir::GenericArg;\n use hir::def_id::DefId;\n-use rustc::ty::subst::Substs;\n+use rustc::ty::subst::{Kind, Substs};\n use rustc::traits;\n use rustc::ty::{self, Ty, GenericParamDefKind};\n use rustc::ty::subst::Subst;\n@@ -24,6 +24,8 @@ use rustc::ty::fold::TypeFoldable;\n use rustc::infer::{self, InferOk};\n use syntax_pos::Span;\n use rustc::hir;\n+use rustc_data_structures::accumulate_vec::AccumulateVec;\n+use rustc_data_structures::array_vec::ArrayVec;\n \n use std::ops::Deref;\n \n@@ -323,48 +325,86 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // parameters from the type and those from the method.\n         assert_eq!(method_generics.parent_count, parent_substs.len());\n \n-        let inferred_lifetimes = if if let Some(ref data) = segment.args {\n-            !data.args.iter().any(|arg| match arg {\n-                GenericArg::Lifetime(_) => true,\n-                _ => false,\n-            })\n-        } else {\n-            true\n-        } {\n-            method_generics.own_counts().lifetimes\n+        // Collect the segments of the path: we need to substitute arguments\n+        // for parameters throughout the entire path (wherever there are\n+        // generic parameters).\n+        let def_id = pick.item.def_id;\n+        let mut parent_defs = self.tcx.generics_of(def_id);\n+        let count = parent_defs.count();\n+        let mut stack = vec![(def_id, parent_defs)];\n+        while let Some(def_id) = parent_defs.parent {\n+            parent_defs = self.tcx.generics_of(def_id);\n+            stack.push((def_id, parent_defs));\n+        }\n+\n+        // We manually build up the substitution, rather than using convenience\n+        // methods in subst.rs so that we can iterate over the arguments and\n+        // parameters in lock-step linearly, rather than trying to match each pair.\n+        let mut substs: AccumulateVec<[Kind<'tcx>; 8]> = if count <= 8 {\n+            AccumulateVec::Array(ArrayVec::new())\n         } else {\n-            0\n+            AccumulateVec::Heap(Vec::with_capacity(count))\n         };\n+        fn push_kind<'tcx>(substs: &mut AccumulateVec<[Kind<'tcx>; 8]>, kind: Kind<'tcx>) {\n+            match substs {\n+                AccumulateVec::Array(ref mut arr) => arr.push(kind),\n+                AccumulateVec::Heap(ref mut vec) => vec.push(kind),\n+            }\n+        }\n \n-        Substs::for_item(self.tcx, pick.item.def_id, |param, _| {\n-            let param_idx = param.index as usize;\n-            if param_idx < parent_substs.len() {\n-                parent_substs[param_idx]\n-            } else {\n-                let param_idx = (param.index as usize - parent_substs.len())\n-                    .saturating_sub(inferred_lifetimes);\n+        // Iterate over each segment of the path.\n+        while let Some((_, defs)) = stack.pop() {\n+            let mut params = defs.params.iter();\n+            let mut next_param = params.next();\n+\n+            while let Some(param) = next_param {\n+                if let Some(&kind) = parent_substs.get(param.index as usize) {\n+                    push_kind(&mut substs, kind);\n+                    next_param = params.next();\n+                } else {\n+                    break;\n+                }\n+            }\n \n-                if let Some(ref data) = segment.args {\n-                    if let Some(arg) = data.args.get(param_idx) {\n+            if let Some(ref data) = segment.args {\n+                let args = &data.args;\n+                'args: for arg in args {\n+                    while let Some(param) = next_param {\n                         match param.kind {\n                             GenericParamDefKind::Lifetime => match arg {\n                                 GenericArg::Lifetime(lt) => {\n-                                    return AstConv::ast_region_to_region(\n-                                        self.fcx, lt, Some(param)).into();\n+                                    push_kind(&mut substs, AstConv::ast_region_to_region(\n+                                        self.fcx, lt, Some(param)).into());\n+                                    next_param = params.next();\n+                                    continue 'args;\n+                                }\n+                                _ => {\n+                                    push_kind(&mut substs, self.var_for_def(self.span, param));\n+                                    next_param = params.next();\n                                 }\n-                                _ => {}\n                             }\n                             GenericParamDefKind::Type { .. } => match arg {\n-                                GenericArg::Type(ty) => return self.to_ty(ty).into(),\n-                                _ => {}\n+                                GenericArg::Type(ty) => {\n+                                    push_kind(&mut substs, self.to_ty(ty).into());\n+                                    next_param = params.next();\n+                                    continue 'args;\n+                                }\n+                                _ => {\n+                                    break 'args;\n+                                }\n                             }\n                         }\n                     }\n                 }\n+            }\n \n-                self.var_for_def(self.span, param)\n+            while let Some(param) = next_param {\n+                push_kind(&mut substs, self.var_for_def(self.span, param));\n+                next_param = params.next();\n             }\n-        })\n+        }\n+\n+        self.tcx.intern_substs(&substs)\n     }\n \n     fn unify_receivers(&mut self, self_ty: Ty<'tcx>, method_self_ty: Ty<'tcx>) {"}]}