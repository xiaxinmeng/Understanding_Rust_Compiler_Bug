{"sha": "64b086a8e26cbf7daddcf4581e6351a55718a913", "node_id": "C_kwDOAAsO6NoAKDY0YjA4NmE4ZTI2Y2JmN2RhZGRjZjQ1ODFlNjM1MWE1NTcxOGE5MTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-07T14:58:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-07T14:58:30Z"}, "message": "Auto merge of #2004 - RalfJung:simd, r=RalfJung\n\nimplement more SIMD intrinsics\n\nRequires https://github.com/rust-lang/rust/pull/94681\n\nWith this, the cast, i32_ops, and f32_ops test suites of portable-simd pass. :)\n\nCc https://github.com/rust-lang/miri/issues/1912", "tree": {"sha": "ce70cbe822aabd036e26c610474562572c861f0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce70cbe822aabd036e26c610474562572c861f0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64b086a8e26cbf7daddcf4581e6351a55718a913", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64b086a8e26cbf7daddcf4581e6351a55718a913", "html_url": "https://github.com/rust-lang/rust/commit/64b086a8e26cbf7daddcf4581e6351a55718a913", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64b086a8e26cbf7daddcf4581e6351a55718a913/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd42a47f0a458380a1ea03ec6ef360ece3674692", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd42a47f0a458380a1ea03ec6ef360ece3674692", "html_url": "https://github.com/rust-lang/rust/commit/dd42a47f0a458380a1ea03ec6ef360ece3674692"}, {"sha": "b87a9c90e1ca983eb81778d79b23db8c52eace54", "url": "https://api.github.com/repos/rust-lang/rust/commits/b87a9c90e1ca983eb81778d79b23db8c52eace54", "html_url": "https://github.com/rust-lang/rust/commit/b87a9c90e1ca983eb81778d79b23db8c52eace54"}], "stats": {"total": 424, "additions": 346, "deletions": 78}, "files": [{"sha": "a769188204f5a8697a18fc4f998b88909d775909", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64b086a8e26cbf7daddcf4581e6351a55718a913/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/64b086a8e26cbf7daddcf4581e6351a55718a913/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=64b086a8e26cbf7daddcf4581e6351a55718a913", "patch": "@@ -1 +1 @@\n-8876ca3dd46b99fe7e6ad937f11493d37996231e\n+297273c45b205820a4c055082c71677197a40b55"}, {"sha": "897ebe4ae79fa231ce9d328ea030a794e0442bf6", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 171, "deletions": 48, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/64b086a8e26cbf7daddcf4581e6351a55718a913/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b086a8e26cbf7daddcf4581e6351a55718a913/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=64b086a8e26cbf7daddcf4581e6351a55718a913", "patch": "@@ -345,7 +345,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                                 bug!(\"simd_fabs operand is not a float\")\n                             };\n                             let op = op.to_scalar()?;\n-                            // FIXME: Using host floats.\n                             match float_ty {\n                                 FloatTy::F32 => Scalar::from_f32(op.to_f32()?.abs()),\n                                 FloatTy::F64 => Scalar::from_f64(op.to_f64()?.abs()),\n@@ -371,7 +370,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"simd_lt\"\n             | \"simd_le\"\n             | \"simd_gt\"\n-            | \"simd_ge\" => {\n+            | \"simd_ge\"\n+            | \"simd_fmax\"\n+            | \"simd_fmin\" => {\n                 use mir::BinOp;\n \n                 let &[ref left, ref right] = check_arg_count(args)?;\n@@ -382,58 +383,77 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 assert_eq!(dest_len, left_len);\n                 assert_eq!(dest_len, right_len);\n \n-                let mir_op = match intrinsic_name {\n-                    \"simd_add\" => BinOp::Add,\n-                    \"simd_sub\" => BinOp::Sub,\n-                    \"simd_mul\" => BinOp::Mul,\n-                    \"simd_div\" => BinOp::Div,\n-                    \"simd_rem\" => BinOp::Rem,\n-                    \"simd_shl\" => BinOp::Shl,\n-                    \"simd_shr\" => BinOp::Shr,\n-                    \"simd_and\" => BinOp::BitAnd,\n-                    \"simd_or\" => BinOp::BitOr,\n-                    \"simd_xor\" => BinOp::BitXor,\n-                    \"simd_eq\" => BinOp::Eq,\n-                    \"simd_ne\" => BinOp::Ne,\n-                    \"simd_lt\" => BinOp::Lt,\n-                    \"simd_le\" => BinOp::Le,\n-                    \"simd_gt\" => BinOp::Gt,\n-                    \"simd_ge\" => BinOp::Ge,\n+                enum Op {\n+                    MirOp(BinOp),\n+                    FMax,\n+                    FMin,\n+                }\n+                let which = match intrinsic_name {\n+                    \"simd_add\" => Op::MirOp(BinOp::Add),\n+                    \"simd_sub\" => Op::MirOp(BinOp::Sub),\n+                    \"simd_mul\" => Op::MirOp(BinOp::Mul),\n+                    \"simd_div\" => Op::MirOp(BinOp::Div),\n+                    \"simd_rem\" => Op::MirOp(BinOp::Rem),\n+                    \"simd_shl\" => Op::MirOp(BinOp::Shl),\n+                    \"simd_shr\" => Op::MirOp(BinOp::Shr),\n+                    \"simd_and\" => Op::MirOp(BinOp::BitAnd),\n+                    \"simd_or\" => Op::MirOp(BinOp::BitOr),\n+                    \"simd_xor\" => Op::MirOp(BinOp::BitXor),\n+                    \"simd_eq\" => Op::MirOp(BinOp::Eq),\n+                    \"simd_ne\" => Op::MirOp(BinOp::Ne),\n+                    \"simd_lt\" => Op::MirOp(BinOp::Lt),\n+                    \"simd_le\" => Op::MirOp(BinOp::Le),\n+                    \"simd_gt\" => Op::MirOp(BinOp::Gt),\n+                    \"simd_ge\" => Op::MirOp(BinOp::Ge),\n+                    \"simd_fmax\" => Op::FMax,\n+                    \"simd_fmin\" => Op::FMin,\n                     _ => unreachable!(),\n                 };\n \n                 for i in 0..dest_len {\n                     let left = this.read_immediate(&this.mplace_index(&left, i)?.into())?;\n                     let right = this.read_immediate(&this.mplace_index(&right, i)?.into())?;\n                     let dest = this.mplace_index(&dest, i)?;\n-                    let (val, overflowed, ty) = this.overflowing_binary_op(mir_op, &left, &right)?;\n-                    if matches!(mir_op, BinOp::Shl | BinOp::Shr) {\n-                        // Shifts have extra UB as SIMD operations that the MIR binop does not have.\n-                        // See <https://github.com/rust-lang/rust/issues/91237>.\n-                        if overflowed {\n-                            let r_val = right.to_scalar()?.to_bits(right.layout.size)?;\n-                            throw_ub_format!(\"overflowing shift by {} in `{}` in SIMD lane {}\", r_val, intrinsic_name, i);\n+                    let val = match which {\n+                        Op::MirOp(mir_op) => {\n+                            let (val, overflowed, ty) = this.overflowing_binary_op(mir_op, &left, &right)?;\n+                            if matches!(mir_op, BinOp::Shl | BinOp::Shr) {\n+                                // Shifts have extra UB as SIMD operations that the MIR binop does not have.\n+                                // See <https://github.com/rust-lang/rust/issues/91237>.\n+                                if overflowed {\n+                                    let r_val = right.to_scalar()?.to_bits(right.layout.size)?;\n+                                    throw_ub_format!(\"overflowing shift by {} in `{}` in SIMD lane {}\", r_val, intrinsic_name, i);\n+                                }\n+                            }\n+                            if matches!(mir_op, BinOp::Eq | BinOp::Ne | BinOp::Lt | BinOp::Le | BinOp::Gt | BinOp::Ge) {\n+                                // Special handling for boolean-returning operations\n+                                assert_eq!(ty, this.tcx.types.bool);\n+                                let val = val.to_bool().unwrap();\n+                                bool_to_simd_element(val, dest.layout.size)\n+                            } else {\n+                                assert_ne!(ty, this.tcx.types.bool);\n+                                assert_eq!(ty, dest.layout.ty);\n+                                val\n+                            }\n+                        }\n+                        Op::FMax => {\n+                            fmax_op(&left, &right)?\n                         }\n-                    }\n-                    if matches!(mir_op, BinOp::Eq | BinOp::Ne | BinOp::Lt | BinOp::Le | BinOp::Gt | BinOp::Ge) {\n-                        // Special handling for boolean-returning operations\n-                        assert_eq!(ty, this.tcx.types.bool);\n-                        let val = val.to_bool().unwrap();\n-                        let val = bool_to_simd_element(val, dest.layout.size);\n-                        this.write_scalar(val, &dest.into())?;\n-                    } else {\n-                        assert_ne!(ty, this.tcx.types.bool);\n-                        assert_eq!(ty, dest.layout.ty);\n-                        this.write_scalar(val, &dest.into())?;\n-                    }\n+                        Op::FMin => {\n+                            fmin_op(&left, &right)?\n+                        }\n+                    };\n+                    this.write_scalar(val, &dest.into())?;\n                 }\n             }\n             #[rustfmt::skip]\n             | \"simd_reduce_and\"\n             | \"simd_reduce_or\"\n             | \"simd_reduce_xor\"\n             | \"simd_reduce_any\"\n-            | \"simd_reduce_all\" => {\n+            | \"simd_reduce_all\"\n+            | \"simd_reduce_max\"\n+            | \"simd_reduce_min\" => {\n                 use mir::BinOp;\n \n                 let &[ref op] = check_arg_count(args)?;\n@@ -445,19 +465,27 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 enum Op {\n                     MirOp(BinOp),\n                     MirOpBool(BinOp),\n+                    Max,\n+                    Min,\n                 }\n-                // The initial value is the neutral element.\n-                let (which, init) = match intrinsic_name {\n-                    \"simd_reduce_and\" => (Op::MirOp(BinOp::BitAnd), ImmTy::from_int(-1, dest.layout)),\n-                    \"simd_reduce_or\" => (Op::MirOp(BinOp::BitOr), ImmTy::from_int(0, dest.layout)),\n-                    \"simd_reduce_xor\" => (Op::MirOp(BinOp::BitXor), ImmTy::from_int(0, dest.layout)),\n-                    \"simd_reduce_any\" => (Op::MirOpBool(BinOp::BitOr), imm_from_bool(false)),\n-                    \"simd_reduce_all\" => (Op::MirOpBool(BinOp::BitAnd), imm_from_bool(true)),\n+                let which = match intrinsic_name {\n+                    \"simd_reduce_and\" => Op::MirOp(BinOp::BitAnd),\n+                    \"simd_reduce_or\" => Op::MirOp(BinOp::BitOr),\n+                    \"simd_reduce_xor\" => Op::MirOp(BinOp::BitXor),\n+                    \"simd_reduce_any\" => Op::MirOpBool(BinOp::BitOr),\n+                    \"simd_reduce_all\" => Op::MirOpBool(BinOp::BitAnd),\n+                    \"simd_reduce_max\" => Op::Max,\n+                    \"simd_reduce_min\" => Op::Min,\n                     _ => unreachable!(),\n                 };\n \n-                let mut res = init;\n-                for i in 0..op_len {\n+                // Initialize with first lane, then proceed with the rest.\n+                let mut res = this.read_immediate(&this.mplace_index(&op, 0)?.into())?;\n+                if matches!(which, Op::MirOpBool(_)) {\n+                    // Convert to `bool` scalar.\n+                    res = imm_from_bool(simd_element_to_bool(res)?);\n+                }\n+                for i in 1..op_len {\n                     let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n                     res = match which {\n                         Op::MirOp(mir_op) => {\n@@ -467,6 +495,30 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                             let op = imm_from_bool(simd_element_to_bool(op)?);\n                             this.binary_op(mir_op, &res, &op)?\n                         }\n+                        Op::Max => {\n+                            if matches!(res.layout.ty.kind(), ty::Float(_)) {\n+                                ImmTy::from_scalar(fmax_op(&res, &op)?, res.layout)\n+                            } else {\n+                                // Just boring integers, so NaNs to worry about\n+                                if this.binary_op(BinOp::Ge, &res, &op)?.to_scalar()?.to_bool()? {\n+                                    res\n+                                } else {\n+                                    op\n+                                }\n+                            }\n+                        }\n+                        Op::Min => {\n+                            if matches!(res.layout.ty.kind(), ty::Float(_)) {\n+                                ImmTy::from_scalar(fmin_op(&res, &op)?, res.layout)\n+                            } else {\n+                                // Just boring integers, so NaNs to worry about\n+                                if this.binary_op(BinOp::Le, &res, &op)?.to_scalar()?.to_bool()? {\n+                                    res\n+                                } else {\n+                                    op\n+                                }\n+                            }\n+                        }\n                     };\n                 }\n                 this.write_immediate(*res, dest)?;\n@@ -515,6 +567,45 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     this.write_immediate(*val, &dest.into())?;\n                 }\n             }\n+            #[rustfmt::skip]\n+            \"simd_cast\" | \"simd_as\" => {\n+                let &[ref op] = check_arg_count(args)?;\n+                let (op, op_len) = this.operand_to_simd(op)?;\n+                let (dest, dest_len) = this.place_to_simd(dest)?;\n+\n+                assert_eq!(dest_len, op_len);\n+\n+                let safe_cast = intrinsic_name == \"simd_as\";\n+\n+                for i in 0..dest_len {\n+                    let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n+                    let dest = this.mplace_index(&dest, i)?;\n+\n+                    let val = match (op.layout.ty.kind(), dest.layout.ty.kind()) {\n+                        // Int-to-(int|float): always safe\n+                        (ty::Int(_) | ty::Uint(_), ty::Int(_) | ty::Uint(_) | ty::Float(_)) =>\n+                            this.misc_cast(&op, dest.layout.ty)?,\n+                        // Float-to-float: always safe\n+                        (ty::Float(_), ty::Float(_)) =>\n+                            this.misc_cast(&op, dest.layout.ty)?,\n+                        // Float-to-int in safe mode\n+                        (ty::Float(_), ty::Int(_) | ty::Uint(_)) if safe_cast =>\n+                            this.misc_cast(&op, dest.layout.ty)?,\n+                        // Float-to-int in unchecked mode\n+                        (ty::Float(FloatTy::F32), ty::Int(_) | ty::Uint(_)) if !safe_cast =>\n+                            this.float_to_int_unchecked(op.to_scalar()?.to_f32()?, dest.layout.ty)?.into(),\n+                        (ty::Float(FloatTy::F64), ty::Int(_) | ty::Uint(_)) if !safe_cast =>\n+                            this.float_to_int_unchecked(op.to_scalar()?.to_f64()?, dest.layout.ty)?.into(),\n+                        _ =>\n+                            throw_unsup_format!(\n+                                \"Unsupported SIMD cast from element type {} to {}\",\n+                                op.layout.ty,\n+                                dest.layout.ty\n+                            ),\n+                    };\n+                    this.write_immediate(val, &dest.into())?;\n+                }\n+            }\n \n             // Atomic operations\n             \"atomic_load\" => this.atomic_load(args, dest, AtomicReadOp::SeqCst)?,\n@@ -1003,3 +1094,35 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         })\n     }\n }\n+\n+fn fmax_op<'tcx>(\n+    left: &ImmTy<'tcx, Tag>,\n+    right: &ImmTy<'tcx, Tag>,\n+) -> InterpResult<'tcx, Scalar<Tag>> {\n+    assert_eq!(left.layout.ty, right.layout.ty);\n+    let ty::Float(float_ty) = left.layout.ty.kind() else {\n+        bug!(\"fmax operand is not a float\")\n+    };\n+    let left = left.to_scalar()?;\n+    let right = right.to_scalar()?;\n+    Ok(match float_ty {\n+        FloatTy::F32 => Scalar::from_f32(left.to_f32()?.max(right.to_f32()?)),\n+        FloatTy::F64 => Scalar::from_f64(left.to_f64()?.max(right.to_f64()?)),\n+    })\n+}\n+\n+fn fmin_op<'tcx>(\n+    left: &ImmTy<'tcx, Tag>,\n+    right: &ImmTy<'tcx, Tag>,\n+) -> InterpResult<'tcx, Scalar<Tag>> {\n+    assert_eq!(left.layout.ty, right.layout.ty);\n+    let ty::Float(float_ty) = left.layout.ty.kind() else {\n+        bug!(\"fmin operand is not a float\")\n+    };\n+    let left = left.to_scalar()?;\n+    let right = right.to_scalar()?;\n+    Ok(match float_ty {\n+        FloatTy::F32 => Scalar::from_f32(left.to_f32()?.min(right.to_f32()?)),\n+        FloatTy::F64 => Scalar::from_f64(left.to_f64()?.min(right.to_f64()?)),\n+    })\n+}"}, {"sha": "88d5a7a466f026cdccece98809f13ccc7695ee96", "filename": "tests/compile-fail/intrinsics/simd-float-to-int.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/64b086a8e26cbf7daddcf4581e6351a55718a913/tests%2Fcompile-fail%2Fintrinsics%2Fsimd-float-to-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b086a8e26cbf7daddcf4581e6351a55718a913/tests%2Fcompile-fail%2Fintrinsics%2Fsimd-float-to-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Fsimd-float-to-int.rs?ref=64b086a8e26cbf7daddcf4581e6351a55718a913", "patch": "@@ -0,0 +1,7 @@\n+// error-pattern: cannot be represented in target type `i32`\n+#![feature(portable_simd)]\n+use std::simd::*;\n+\n+fn main() { unsafe {\n+    let _x : i32x2 = f32x2::from_array([f32::MAX, f32::MIN]).to_int_unchecked();\n+} }"}, {"sha": "48297ee4e6901eaaf4c58b2d4426c31051ccbbe7", "filename": "tests/run-pass/portable-simd.rs", "status": "modified", "additions": 167, "deletions": 29, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/64b086a8e26cbf7daddcf4581e6351a55718a913/tests%2Frun-pass%2Fportable-simd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b086a8e26cbf7daddcf4581e6351a55718a913/tests%2Frun-pass%2Fportable-simd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fportable-simd.rs?ref=64b086a8e26cbf7daddcf4581e6351a55718a913", "patch": "@@ -12,19 +12,37 @@ fn simd_ops_f32() {\n     assert_eq!(a / f32x4::splat(2.0), f32x4::splat(5.0));\n     assert_eq!(a % b, f32x4::from_array([0.0, 0.0, 1.0, 2.0]));\n     assert_eq!(b.abs(), f32x4::from_array([1.0, 2.0, 3.0, 4.0]));\n+    assert_eq!(a.max(b * f32x4::splat(4.0)), f32x4::from_array([10.0, 10.0, 12.0, 10.0]));\n+    assert_eq!(a.min(b * f32x4::splat(4.0)), f32x4::from_array([4.0, 8.0, 10.0, -16.0]));\n \n-    // FIXME use Mask::from_array once simd_cast is implemented.\n-    assert_eq!(a.lanes_eq(f32x4::splat(5.0)*b), Mask::from_int(i32x4::from_array([0, -1, 0, 0])));\n-    assert_eq!(a.lanes_ne(f32x4::splat(5.0)*b), Mask::from_int(i32x4::from_array([-1, 0, -1, -1])));\n-    assert_eq!(a.lanes_le(f32x4::splat(5.0)*b), Mask::from_int(i32x4::from_array([0, -1, -1, 0])));\n-    assert_eq!(a.lanes_lt(f32x4::splat(5.0)*b), Mask::from_int(i32x4::from_array([0, 0, -1, 0])));\n-    assert_eq!(a.lanes_ge(f32x4::splat(5.0)*b), Mask::from_int(i32x4::from_array([-1, -1, 0, -1])));\n-    assert_eq!(a.lanes_gt(f32x4::splat(5.0)*b), Mask::from_int(i32x4::from_array([-1, 0, 0, -1])));\n+    assert_eq!(a.lanes_eq(f32x4::splat(5.0) * b), Mask::from_array([false, true, false, false]));\n+    assert_eq!(a.lanes_ne(f32x4::splat(5.0) * b), Mask::from_array([true, false, true, true]));\n+    assert_eq!(a.lanes_le(f32x4::splat(5.0) * b), Mask::from_array([false, true, true, false]));\n+    assert_eq!(a.lanes_lt(f32x4::splat(5.0) * b), Mask::from_array([false, false, true, false]));\n+    assert_eq!(a.lanes_ge(f32x4::splat(5.0) * b), Mask::from_array([true, true, false, true]));\n+    assert_eq!(a.lanes_gt(f32x4::splat(5.0) * b), Mask::from_array([true, false, false, true]));\n \n     assert_eq!(a.horizontal_sum(), 40.0);\n     assert_eq!(b.horizontal_sum(), 2.0);\n-    assert_eq!(a.horizontal_product(), 100.0*100.0);\n+    assert_eq!(a.horizontal_product(), 100.0 * 100.0);\n     assert_eq!(b.horizontal_product(), -24.0);\n+    assert_eq!(a.horizontal_max(), 10.0);\n+    assert_eq!(b.horizontal_max(), 3.0);\n+    assert_eq!(a.horizontal_min(), 10.0);\n+    assert_eq!(b.horizontal_min(), -4.0);\n+\n+    assert_eq!(\n+        f32x2::from_array([0.0, f32::NAN]).max(f32x2::from_array([f32::NAN, 0.0])),\n+        f32x2::from_array([0.0, 0.0])\n+    );\n+    assert_eq!(f32x2::from_array([0.0, f32::NAN]).horizontal_max(), 0.0);\n+    assert_eq!(f32x2::from_array([f32::NAN, 0.0]).horizontal_max(), 0.0);\n+    assert_eq!(\n+        f32x2::from_array([0.0, f32::NAN]).min(f32x2::from_array([f32::NAN, 0.0])),\n+        f32x2::from_array([0.0, 0.0])\n+    );\n+    assert_eq!(f32x2::from_array([0.0, f32::NAN]).horizontal_min(), 0.0);\n+    assert_eq!(f32x2::from_array([f32::NAN, 0.0]).horizontal_min(), 0.0);\n }\n \n fn simd_ops_f64() {\n@@ -38,19 +56,37 @@ fn simd_ops_f64() {\n     assert_eq!(a / f64x4::splat(2.0), f64x4::splat(5.0));\n     assert_eq!(a % b, f64x4::from_array([0.0, 0.0, 1.0, 2.0]));\n     assert_eq!(b.abs(), f64x4::from_array([1.0, 2.0, 3.0, 4.0]));\n+    assert_eq!(a.max(b * f64x4::splat(4.0)), f64x4::from_array([10.0, 10.0, 12.0, 10.0]));\n+    assert_eq!(a.min(b * f64x4::splat(4.0)), f64x4::from_array([4.0, 8.0, 10.0, -16.0]));\n \n-    // FIXME use Mask::from_array once simd_cast is implemented.\n-    assert_eq!(a.lanes_eq(f64x4::splat(5.0)*b), Mask::from_int(i64x4::from_array([0, -1, 0, 0])));\n-    assert_eq!(a.lanes_ne(f64x4::splat(5.0)*b), Mask::from_int(i64x4::from_array([-1, 0, -1, -1])));\n-    assert_eq!(a.lanes_le(f64x4::splat(5.0)*b), Mask::from_int(i64x4::from_array([0, -1, -1, 0])));\n-    assert_eq!(a.lanes_lt(f64x4::splat(5.0)*b), Mask::from_int(i64x4::from_array([0, 0, -1, 0])));\n-    assert_eq!(a.lanes_ge(f64x4::splat(5.0)*b), Mask::from_int(i64x4::from_array([-1, -1, 0, -1])));\n-    assert_eq!(a.lanes_gt(f64x4::splat(5.0)*b), Mask::from_int(i64x4::from_array([-1, 0, 0, -1])));\n+    assert_eq!(a.lanes_eq(f64x4::splat(5.0) * b), Mask::from_array([false, true, false, false]));\n+    assert_eq!(a.lanes_ne(f64x4::splat(5.0) * b), Mask::from_array([true, false, true, true]));\n+    assert_eq!(a.lanes_le(f64x4::splat(5.0) * b), Mask::from_array([false, true, true, false]));\n+    assert_eq!(a.lanes_lt(f64x4::splat(5.0) * b), Mask::from_array([false, false, true, false]));\n+    assert_eq!(a.lanes_ge(f64x4::splat(5.0) * b), Mask::from_array([true, true, false, true]));\n+    assert_eq!(a.lanes_gt(f64x4::splat(5.0) * b), Mask::from_array([true, false, false, true]));\n \n     assert_eq!(a.horizontal_sum(), 40.0);\n     assert_eq!(b.horizontal_sum(), 2.0);\n-    assert_eq!(a.horizontal_product(), 100.0*100.0);\n+    assert_eq!(a.horizontal_product(), 100.0 * 100.0);\n     assert_eq!(b.horizontal_product(), -24.0);\n+    assert_eq!(a.horizontal_max(), 10.0);\n+    assert_eq!(b.horizontal_max(), 3.0);\n+    assert_eq!(a.horizontal_min(), 10.0);\n+    assert_eq!(b.horizontal_min(), -4.0);\n+\n+    assert_eq!(\n+        f64x2::from_array([0.0, f64::NAN]).max(f64x2::from_array([f64::NAN, 0.0])),\n+        f64x2::from_array([0.0, 0.0])\n+    );\n+    assert_eq!(f64x2::from_array([0.0, f64::NAN]).horizontal_max(), 0.0);\n+    assert_eq!(f64x2::from_array([f64::NAN, 0.0]).horizontal_max(), 0.0);\n+    assert_eq!(\n+        f64x2::from_array([0.0, f64::NAN]).min(f64x2::from_array([f64::NAN, 0.0])),\n+        f64x2::from_array([0.0, 0.0])\n+    );\n+    assert_eq!(f64x2::from_array([0.0, f64::NAN]).horizontal_min(), 0.0);\n+    assert_eq!(f64x2::from_array([f64::NAN, 0.0]).horizontal_min(), 0.0);\n }\n \n fn simd_ops_i32() {\n@@ -65,30 +101,124 @@ fn simd_ops_i32() {\n     assert_eq!(i32x2::splat(i32::MIN) / i32x2::splat(-1), i32x2::splat(i32::MIN));\n     assert_eq!(a % b, i32x4::from_array([0, 0, 1, 2]));\n     assert_eq!(i32x2::splat(i32::MIN) % i32x2::splat(-1), i32x2::splat(0));\n+    assert_eq!(b.abs(), i32x4::from_array([1, 2, 3, 4]));\n+    // FIXME not a per-lane method (https://github.com/rust-lang/rust/issues/94682)\n+    // assert_eq!(a.max(b * i32x4::splat(4)), i32x4::from_array([10, 10, 12, 10]));\n+    // assert_eq!(a.min(b * i32x4::splat(4)), i32x4::from_array([4, 8, 10, -16]));\n+\n+    assert_eq!(!b, i32x4::from_array([!1, !2, !3, !-4]));\n     assert_eq!(b << i32x4::splat(2), i32x4::from_array([4, 8, 12, -16]));\n     assert_eq!(b >> i32x4::splat(1), i32x4::from_array([0, 1, 1, -2]));\n     assert_eq!(b & i32x4::splat(2), i32x4::from_array([0, 2, 2, 0]));\n     assert_eq!(b | i32x4::splat(2), i32x4::from_array([3, 2, 3, -2]));\n     assert_eq!(b ^ i32x4::splat(2), i32x4::from_array([3, 0, 1, -2]));\n \n-    // FIXME use Mask::from_array once simd_cast is implemented.\n-    assert_eq!(a.lanes_eq(i32x4::splat(5)*b), Mask::from_int(i32x4::from_array([0, -1, 0, 0])));\n-    assert_eq!(a.lanes_ne(i32x4::splat(5)*b), Mask::from_int(i32x4::from_array([-1, 0, -1, -1])));\n-    assert_eq!(a.lanes_le(i32x4::splat(5)*b), Mask::from_int(i32x4::from_array([0, -1, -1, 0])));\n-    assert_eq!(a.lanes_lt(i32x4::splat(5)*b), Mask::from_int(i32x4::from_array([0, 0, -1, 0])));\n-    assert_eq!(a.lanes_ge(i32x4::splat(5)*b), Mask::from_int(i32x4::from_array([-1, -1, 0, -1])));\n-    assert_eq!(a.lanes_gt(i32x4::splat(5)*b), Mask::from_int(i32x4::from_array([-1, 0, 0, -1])));\n+    assert_eq!(a.lanes_eq(i32x4::splat(5) * b), Mask::from_array([false, true, false, false]));\n+    assert_eq!(a.lanes_ne(i32x4::splat(5) * b), Mask::from_array([true, false, true, true]));\n+    assert_eq!(a.lanes_le(i32x4::splat(5) * b), Mask::from_array([false, true, true, false]));\n+    assert_eq!(a.lanes_lt(i32x4::splat(5) * b), Mask::from_array([false, false, true, false]));\n+    assert_eq!(a.lanes_ge(i32x4::splat(5) * b), Mask::from_array([true, true, false, true]));\n+    assert_eq!(a.lanes_gt(i32x4::splat(5) * b), Mask::from_array([true, false, false, true]));\n+\n+    assert_eq!(a.horizontal_sum(), 40);\n+    assert_eq!(b.horizontal_sum(), 2);\n+    assert_eq!(a.horizontal_product(), 100 * 100);\n+    assert_eq!(b.horizontal_product(), -24);\n+    assert_eq!(a.horizontal_max(), 10);\n+    assert_eq!(b.horizontal_max(), 3);\n+    assert_eq!(a.horizontal_min(), 10);\n+    assert_eq!(b.horizontal_min(), -4);\n \n     assert_eq!(a.horizontal_and(), 10);\n     assert_eq!(b.horizontal_and(), 0);\n     assert_eq!(a.horizontal_or(), 10);\n     assert_eq!(b.horizontal_or(), -1);\n     assert_eq!(a.horizontal_xor(), 0);\n     assert_eq!(b.horizontal_xor(), -4);\n-    assert_eq!(a.horizontal_sum(), 40);\n-    assert_eq!(b.horizontal_sum(), 2);\n-    assert_eq!(a.horizontal_product(), 100*100);\n-    assert_eq!(b.horizontal_product(), -24);\n+}\n+\n+fn simd_mask() {\n+    let intmask = Mask::from_int(i32x4::from_array([0, -1, 0, 0]));\n+    assert_eq!(intmask, Mask::from_array([false, true, false, false]));\n+    assert_eq!(intmask.to_array(), [false, true, false, false]);\n+}\n+\n+fn simd_cast() {\n+    // between integer types\n+    assert_eq!(i32x4::from_array([1, 2, 3, -4]), i16x4::from_array([1, 2, 3, -4]).cast());\n+    assert_eq!(i16x4::from_array([1, 2, 3, -4]), i32x4::from_array([1, 2, 3, -4]).cast());\n+    assert_eq!(i32x4::from_array([1, -1, 3, 4]), u64x4::from_array([1, u64::MAX, 3, 4]).cast());\n+\n+    // float -> int\n+    assert_eq!(\n+        i8x4::from_array([127, -128, 127, -128]),\n+        f32x4::from_array([127.99, -128.99, 999.0, -999.0]).cast()\n+    );\n+    assert_eq!(\n+        i32x4::from_array([0, 1, -1, 2147483520]),\n+        f32x4::from_array([\n+            -0.0,\n+            /*0x1.19999ap+0*/ f32::from_bits(0x3f8ccccd),\n+            /*-0x1.19999ap+0*/ f32::from_bits(0xbf8ccccd),\n+            2147483520.0\n+        ])\n+        .cast()\n+    );\n+    assert_eq!(\n+        i32x8::from_array([i32::MAX, i32::MIN, i32::MAX, i32::MIN, i32::MAX, i32::MIN, 0, 0]),\n+        f32x8::from_array([\n+            2147483648.0f32,\n+            -2147483904.0f32,\n+            f32::MAX,\n+            f32::MIN,\n+            f32::INFINITY,\n+            f32::NEG_INFINITY,\n+            f32::NAN,\n+            -f32::NAN,\n+        ])\n+        .cast()\n+    );\n+\n+    // int -> float\n+    assert_eq!(\n+        f32x4::from_array([\n+            -2147483648.0,\n+            /*0x1.26580cp+30*/ f32::from_bits(0x4e932c06),\n+            16777220.0,\n+            -16777220.0,\n+        ]),\n+        i32x4::from_array([-2147483647i32, 1234567890i32, 16777219i32, -16777219i32]).cast()\n+    );\n+\n+    // float -> float\n+    assert_eq!(\n+        f32x4::from_array([f32::INFINITY, f32::INFINITY, f32::NEG_INFINITY, f32::NEG_INFINITY]),\n+        f64x4::from_array([f64::MAX, f64::INFINITY, f64::MIN, f64::NEG_INFINITY]).cast()\n+    );\n+\n+    // unchecked casts\n+    unsafe {\n+        assert_eq!(\n+            i32x4::from_array([0, 1, -1, 2147483520]),\n+            f32x4::from_array([\n+                -0.0,\n+                /*0x1.19999ap+0*/ f32::from_bits(0x3f8ccccd),\n+                /*-0x1.19999ap+0*/ f32::from_bits(0xbf8ccccd),\n+                2147483520.0\n+            ])\n+            .to_int_unchecked()\n+        );\n+        assert_eq!(\n+            u64x4::from_array([0, 10000000000000000, u64::MAX - 2047, 9223372036854775808]),\n+            f64x4::from_array([\n+                -0.99999999999,\n+                1e16,\n+                (u64::MAX - 1024) as f64,\n+                9223372036854775808.0\n+            ])\n+            .to_int_unchecked()\n+        );\n+    }\n }\n \n fn simd_intrinsics() {\n@@ -112,14 +242,22 @@ fn simd_intrinsics() {\n         assert!(simd_reduce_all(i32x4::splat(-1)));\n         assert!(!simd_reduce_all(i32x2::from_array([0, -1])));\n \n-        assert_eq!(simd_select(i8x4::from_array([0, -1, -1, 0]), a, b), i32x4::from_array([1, 10, 10, 4]));\n-        assert_eq!(simd_select(i8x4::from_array([0, -1, -1, 0]), b, a), i32x4::from_array([10, 2, 10, 10]));\n+        assert_eq!(\n+            simd_select(i8x4::from_array([0, -1, -1, 0]), a, b),\n+            i32x4::from_array([1, 10, 10, 4])\n+        );\n+        assert_eq!(\n+            simd_select(i8x4::from_array([0, -1, -1, 0]), b, a),\n+            i32x4::from_array([10, 2, 10, 10])\n+        );\n     }\n }\n \n fn main() {\n+    simd_mask();\n     simd_ops_f32();\n     simd_ops_f64();\n     simd_ops_i32();\n+    simd_cast();\n     simd_intrinsics();\n }"}]}