{"sha": "66354f00430eebb88d33de02326d7ca9196bd61a", "node_id": "C_kwDOAAsO6NoAKDY2MzU0ZjAwNDMwZWViYjg4ZDMzZGUwMjMyNmQ3Y2E5MTk2YmQ2MWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-27T19:03:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-27T19:03:21Z"}, "message": "Auto merge of #2694 - RalfJung:retag-deref-check, r=saethlin\n\nfix handling of spurious accesses during retag\n\nThe `dereferenceable` attribute we emit for LLVM is checked during retag in Stacked Borrows.\nHowever, we currently don't properly do that for retagging of `&mut !Unpin`, which this PR fixes.\nAlso this adjusts retagging to inform the data race model of the accesses as well.\n\nFixes https://github.com/rust-lang/miri/issues/2648.\nAlso fixes https://github.com/rust-lang/miri/issues/2693 since the same issue arose for retagging as well.\n\nr? `@saethlin`", "tree": {"sha": "a520304e5766ae486d9c03ca337ccf41a2a0de3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a520304e5766ae486d9c03ca337ccf41a2a0de3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66354f00430eebb88d33de02326d7ca9196bd61a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66354f00430eebb88d33de02326d7ca9196bd61a", "html_url": "https://github.com/rust-lang/rust/commit/66354f00430eebb88d33de02326d7ca9196bd61a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66354f00430eebb88d33de02326d7ca9196bd61a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a83b105b4c9dc1363c15685e99893a209438dc35", "url": "https://api.github.com/repos/rust-lang/rust/commits/a83b105b4c9dc1363c15685e99893a209438dc35", "html_url": "https://github.com/rust-lang/rust/commit/a83b105b4c9dc1363c15685e99893a209438dc35"}, {"sha": "edf8154695e697d5bef8fdd3341379a3f789fd62", "url": "https://api.github.com/repos/rust-lang/rust/commits/edf8154695e697d5bef8fdd3341379a3f789fd62", "html_url": "https://github.com/rust-lang/rust/commit/edf8154695e697d5bef8fdd3341379a3f789fd62"}], "stats": {"total": 496, "additions": 339, "deletions": 157}, "files": [{"sha": "d669cc1362a9a7a06a31536c8899cf5ae5d3dce9", "filename": "src/tools/miri/src/concurrency/data_race.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -838,18 +838,18 @@ impl VClockAlloc {\n         &self,\n         alloc_id: AllocId,\n         range: AllocRange,\n-        global: &GlobalState,\n-        thread_mgr: &ThreadManager<'_, '_>,\n+        machine: &MiriMachine<'_, '_>,\n     ) -> InterpResult<'tcx> {\n+        let global = machine.data_race.as_ref().unwrap();\n         if global.race_detecting() {\n-            let (index, clocks) = global.current_thread_state(thread_mgr);\n+            let (index, clocks) = global.current_thread_state(&machine.threads);\n             let mut alloc_ranges = self.alloc_ranges.borrow_mut();\n             for (offset, range) in alloc_ranges.iter_mut(range.start, range.size) {\n                 if let Err(DataRace) = range.read_race_detect(&clocks, index) {\n                     // Report data-race.\n                     return Self::report_data_race(\n                         global,\n-                        thread_mgr,\n+                        &machine.threads,\n                         range,\n                         \"Read\",\n                         false,\n@@ -869,17 +869,17 @@ impl VClockAlloc {\n         alloc_id: AllocId,\n         range: AllocRange,\n         write_type: WriteType,\n-        global: &mut GlobalState,\n-        thread_mgr: &ThreadManager<'_, '_>,\n+        machine: &mut MiriMachine<'_, '_>,\n     ) -> InterpResult<'tcx> {\n+        let global = machine.data_race.as_mut().unwrap();\n         if global.race_detecting() {\n-            let (index, clocks) = global.current_thread_state(thread_mgr);\n+            let (index, clocks) = global.current_thread_state(&machine.threads);\n             for (offset, range) in self.alloc_ranges.get_mut().iter_mut(range.start, range.size) {\n                 if let Err(DataRace) = range.write_race_detect(&clocks, index, write_type) {\n                     // Report data-race\n                     return Self::report_data_race(\n                         global,\n-                        thread_mgr,\n+                        &machine.threads,\n                         range,\n                         write_type.get_descriptor(),\n                         false,\n@@ -901,10 +901,9 @@ impl VClockAlloc {\n         &mut self,\n         alloc_id: AllocId,\n         range: AllocRange,\n-        global: &mut GlobalState,\n-        thread_mgr: &ThreadManager<'_, '_>,\n+        machine: &mut MiriMachine<'_, '_>,\n     ) -> InterpResult<'tcx> {\n-        self.unique_access(alloc_id, range, WriteType::Write, global, thread_mgr)\n+        self.unique_access(alloc_id, range, WriteType::Write, machine)\n     }\n \n     /// Detect data-races for an unsynchronized deallocate operation, will not perform\n@@ -915,10 +914,9 @@ impl VClockAlloc {\n         &mut self,\n         alloc_id: AllocId,\n         range: AllocRange,\n-        global: &mut GlobalState,\n-        thread_mgr: &ThreadManager<'_, '_>,\n+        machine: &mut MiriMachine<'_, '_>,\n     ) -> InterpResult<'tcx> {\n-        self.unique_access(alloc_id, range, WriteType::Deallocate, global, thread_mgr)\n+        self.unique_access(alloc_id, range, WriteType::Deallocate, machine)\n     }\n }\n "}, {"sha": "edfef211dc675abcff79b316ed1f6335a18cf3df", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 7, "deletions": 33, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -1003,21 +1003,12 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         if let Some(data_race) = &alloc_extra.data_race {\n-            data_race.read(\n-                alloc_id,\n-                range,\n-                machine.data_race.as_ref().unwrap(),\n-                &machine.threads,\n-            )?;\n+            data_race.read(alloc_id, range, machine)?;\n         }\n         if let Some(stacked_borrows) = &alloc_extra.stacked_borrows {\n-            stacked_borrows.borrow_mut().before_memory_read(\n-                alloc_id,\n-                prov_extra,\n-                range,\n-                machine.stacked_borrows.as_ref().unwrap(),\n-                machine,\n-            )?;\n+            stacked_borrows\n+                .borrow_mut()\n+                .before_memory_read(alloc_id, prov_extra, range, machine)?;\n         }\n         if let Some(weak_memory) = &alloc_extra.weak_memory {\n             weak_memory.memory_accessed(range, machine.data_race.as_ref().unwrap());\n@@ -1034,21 +1025,10 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         if let Some(data_race) = &mut alloc_extra.data_race {\n-            data_race.write(\n-                alloc_id,\n-                range,\n-                machine.data_race.as_mut().unwrap(),\n-                &machine.threads,\n-            )?;\n+            data_race.write(alloc_id, range, machine)?;\n         }\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n-            stacked_borrows.get_mut().before_memory_write(\n-                alloc_id,\n-                prov_extra,\n-                range,\n-                machine.stacked_borrows.as_ref().unwrap(),\n-                machine,\n-            )?;\n+            stacked_borrows.get_mut().before_memory_write(alloc_id, prov_extra, range, machine)?;\n         }\n         if let Some(weak_memory) = &alloc_extra.weak_memory {\n             weak_memory.memory_accessed(range, machine.data_race.as_ref().unwrap());\n@@ -1068,19 +1048,13 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n             machine.emit_diagnostic(NonHaltingDiagnostic::FreedAlloc(alloc_id));\n         }\n         if let Some(data_race) = &mut alloc_extra.data_race {\n-            data_race.deallocate(\n-                alloc_id,\n-                range,\n-                machine.data_race.as_mut().unwrap(),\n-                &machine.threads,\n-            )?;\n+            data_race.deallocate(alloc_id, range, machine)?;\n         }\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n             stacked_borrows.get_mut().before_memory_deallocation(\n                 alloc_id,\n                 prove_extra,\n                 range,\n-                machine.stacked_borrows.as_ref().unwrap(),\n                 machine,\n             )\n         } else {"}, {"sha": "9970b79f8c7f17838822938cba38c4dbd3a541b2", "filename": "src/tools/miri/src/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fdiagnostics.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -353,10 +353,12 @@ impl<'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n \n     /// Report a descriptive error when `new` could not be granted from `derived_from`.\n     #[inline(never)] // This is only called on fatal code paths\n-    pub(super) fn grant_error(&self, perm: Permission, stack: &Stack) -> InterpError<'tcx> {\n+    pub(super) fn grant_error(&self, stack: &Stack) -> InterpError<'tcx> {\n         let Operation::Retag(op) = &self.operation else {\n             unreachable!(\"grant_error should only be called during a retag\")\n         };\n+        let perm =\n+            op.permission.expect(\"`start_grant` must be called before calling `grant_error`\");\n         let action = format!(\n             \"trying to retag from {:?} for {:?} permission at {:?}[{:#x}]\",\n             op.orig_tag,\n@@ -374,8 +376,11 @@ impl<'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n     /// Report a descriptive error when `access` is not permitted based on `tag`.\n     #[inline(never)] // This is only called on fatal code paths\n     pub(super) fn access_error(&self, stack: &Stack) -> InterpError<'tcx> {\n-        let Operation::Access(op) = &self.operation  else {\n-            unreachable!(\"access_error should only be called during an access\")\n+        // Deallocation and retagging also do an access as part of their thing, so handle that here, too.\n+        let op = match &self.operation {\n+            Operation::Access(op) => op,\n+            Operation::Retag(_) => return self.grant_error(stack),\n+            Operation::Dealloc(_) => return self.dealloc_error(stack),\n         };\n         let action = format!(\n             \"attempting a {access} using {tag:?} at {alloc_id:?}[{offset:#x}]\",\n@@ -428,14 +433,16 @@ impl<'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n     }\n \n     #[inline(never)] // This is only called on fatal code paths\n-    pub fn dealloc_error(&self) -> InterpError<'tcx> {\n+    pub fn dealloc_error(&self, stack: &Stack) -> InterpError<'tcx> {\n         let Operation::Dealloc(op) = &self.operation else {\n             unreachable!(\"dealloc_error should only be called during a deallocation\")\n         };\n         err_sb_ub(\n             format!(\n-                \"no item granting write access for deallocation to tag {:?} at {:?} found in borrow stack\",\n-                op.tag, self.history.id,\n+                \"attempting deallocation using {tag:?} at {alloc_id:?}{cause}\",\n+                tag = op.tag,\n+                alloc_id = self.history.id,\n+                cause = error_cause(stack, op.tag),\n             ),\n             None,\n             op.tag.and_then(|tag| self.get_logs_relevant_to(tag, None)),"}, {"sha": "f6f5c063b39e85aef811089ab08683e884921ba8", "filename": "src/tools/miri/src/stacked_borrows/mod.rs", "status": "modified", "additions": 72, "deletions": 60, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -392,7 +392,7 @@ impl<'tcx> Stack {\n \n         // Step 1: Find granting item.\n         let granting_idx =\n-            self.find_granting(access, tag, exposed_tags).map_err(|_| dcx.access_error(self))?;\n+            self.find_granting(access, tag, exposed_tags).map_err(|()| dcx.access_error(self))?;\n \n         // Step 2: Remove incompatible items above them.  Make sure we do not remove protected\n         // items.  Behavior differs for reads and writes.\n@@ -476,8 +476,7 @@ impl<'tcx> Stack {\n     ) -> InterpResult<'tcx> {\n         // Step 1: Make a write access.\n         // As part of this we do regular protector checking, i.e. even weakly protected items cause UB when popped.\n-        self.access(AccessKind::Write, tag, global, dcx, exposed_tags)\n-            .map_err(|_| dcx.dealloc_error())?;\n+        self.access(AccessKind::Write, tag, global, dcx, exposed_tags)?;\n \n         // Step 2: Pretend we remove the remaining items, checking if any are strongly protected.\n         for idx in (0..self.len()).rev() {\n@@ -489,39 +488,42 @@ impl<'tcx> Stack {\n     }\n \n     /// Derive a new pointer from one with the given tag.\n-    /// `weak` controls whether this operation is weak or strong: weak granting does not act as\n-    /// an access, and they add the new item directly on top of the one it is derived\n-    /// from instead of all the way at the top of the stack.\n-    /// `range` refers the entire operation, and `offset` refers to the specific location in\n-    /// `range` that we are currently checking.\n+    ///\n+    /// `access` indicates which kind of memory access this retag itself should correspond to.\n     fn grant(\n         &mut self,\n         derived_from: ProvenanceExtra,\n         new: Item,\n+        access: Option<AccessKind>,\n         global: &GlobalStateInner,\n         dcx: &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n         exposed_tags: &FxHashSet<SbTag>,\n     ) -> InterpResult<'tcx> {\n         dcx.start_grant(new.perm());\n \n-        // Figure out which access `perm` corresponds to.\n-        let access =\n-            if new.perm().grants(AccessKind::Write) { AccessKind::Write } else { AccessKind::Read };\n-\n-        // Now we figure out which item grants our parent (`derived_from`) this kind of access.\n-        // We use that to determine where to put the new item.\n-        let granting_idx = self\n-            .find_granting(access, derived_from, exposed_tags)\n-            .map_err(|_| dcx.grant_error(new.perm(), self))?;\n-\n         // Compute where to put the new item.\n         // Either way, we ensure that we insert the new item in a way such that between\n         // `derived_from` and the new one, there are only items *compatible with* `derived_from`.\n-        let new_idx = if new.perm() == Permission::SharedReadWrite {\n-            assert!(\n-                access == AccessKind::Write,\n-                \"this case only makes sense for stack-like accesses\"\n-            );\n+        let new_idx = if let Some(access) = access {\n+            // Simple case: We are just a regular memory access, and then push our thing on top,\n+            // like a regular stack.\n+            // This ensures F2b for `Unique`, by removing offending `SharedReadOnly`.\n+            self.access(access, derived_from, global, dcx, exposed_tags)?;\n+\n+            // We insert \"as far up as possible\": We know only compatible items are remaining\n+            // on top of `derived_from`, and we want the new item at the top so that we\n+            // get the strongest possible guarantees.\n+            // This ensures U1 and F1.\n+            self.len()\n+        } else {\n+            // The tricky case: creating a new SRW permission without actually being an access.\n+            assert!(new.perm() == Permission::SharedReadWrite);\n+\n+            // First we figure out which item grants our parent (`derived_from`) this kind of access.\n+            // We use that to determine where to put the new item.\n+            let granting_idx = self\n+                .find_granting(AccessKind::Write, derived_from, exposed_tags)\n+                .map_err(|()| dcx.grant_error(self))?;\n \n             let (Some(granting_idx), ProvenanceExtra::Concrete(_)) = (granting_idx, derived_from) else {\n                 // The parent is a wildcard pointer or matched the unknown bottom.\n@@ -538,17 +540,6 @@ impl<'tcx> Stack {\n             // be popped to (i.e., we insert it above all the write-compatible items).\n             // This ensures F2b by adding the new item below any potentially existing `SharedReadOnly`.\n             self.find_first_write_incompatible(granting_idx)\n-        } else {\n-            // A \"safe\" reborrow for a pointer that actually expects some aliasing guarantees.\n-            // Here, creating a reference actually counts as an access.\n-            // This ensures F2b for `Unique`, by removing offending `SharedReadOnly`.\n-            self.access(access, derived_from, global, dcx, exposed_tags)?;\n-\n-            // We insert \"as far up as possible\": We know only compatible items are remaining\n-            // on top of `derived_from`, and we want the new item at the top so that we\n-            // get the strongest possible guarantees.\n-            // This ensures U1 and F1.\n-            self.len()\n         };\n \n         // Put the new item there.\n@@ -653,7 +644,6 @@ impl Stacks {\n         alloc_id: AllocId,\n         tag: ProvenanceExtra,\n         range: AllocRange,\n-        state: &GlobalState,\n         machine: &'ecx MiriMachine<'mir, 'tcx>,\n     ) -> InterpResult<'tcx>\n     where\n@@ -666,7 +656,7 @@ impl Stacks {\n             range.size.bytes()\n         );\n         let dcx = DiagnosticCxBuilder::read(machine, tag, range);\n-        let state = state.borrow();\n+        let state = machine.stacked_borrows.as_ref().unwrap().borrow();\n         self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n             stack.access(AccessKind::Read, tag, &state, dcx, exposed_tags)\n         })\n@@ -678,8 +668,7 @@ impl Stacks {\n         alloc_id: AllocId,\n         tag: ProvenanceExtra,\n         range: AllocRange,\n-        state: &GlobalState,\n-        machine: &'ecx MiriMachine<'mir, 'tcx>,\n+        machine: &'ecx mut MiriMachine<'mir, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         trace!(\n             \"write access with tag {:?}: {:?}, size {}\",\n@@ -688,7 +677,7 @@ impl Stacks {\n             range.size.bytes()\n         );\n         let dcx = DiagnosticCxBuilder::write(machine, tag, range);\n-        let state = state.borrow();\n+        let state = machine.stacked_borrows.as_ref().unwrap().borrow();\n         self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n             stack.access(AccessKind::Write, tag, &state, dcx, exposed_tags)\n         })\n@@ -700,12 +689,11 @@ impl Stacks {\n         alloc_id: AllocId,\n         tag: ProvenanceExtra,\n         range: AllocRange,\n-        state: &GlobalState,\n-        machine: &'ecx MiriMachine<'mir, 'tcx>,\n+        machine: &'ecx mut MiriMachine<'mir, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocation with tag {:?}: {:?}, size {}\", tag, alloc_id, range.size.bytes());\n         let dcx = DiagnosticCxBuilder::dealloc(machine, tag);\n-        let state = state.borrow();\n+        let state = machine.stacked_borrows.as_ref().unwrap().borrow();\n         self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n             stack.dealloc(tag, &state, dcx, exposed_tags)\n         })?;\n@@ -864,26 +852,30 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         // Update the stacks.\n         // Make sure that raw pointers and mutable shared references are reborrowed \"weak\":\n         // There could be existing unique pointers reborrowed from them that should remain valid!\n-        let perm = match kind {\n-            RefKind::Unique { two_phase: false }\n-                if place.layout.ty.is_unpin(*this.tcx, this.param_env()) =>\n-            {\n-                // Only if the type is unpin do we actually enforce uniqueness\n-                Permission::Unique\n+        let (perm, access) = match kind {\n+            RefKind::Unique { two_phase } => {\n+                // Permission is Unique only if the type is `Unpin` and this is not twophase\n+                let perm = if !two_phase && place.layout.ty.is_unpin(*this.tcx, this.param_env()) {\n+                    Permission::Unique\n+                } else {\n+                    Permission::SharedReadWrite\n+                };\n+                // We do an access for all full borrows, even if `!Unpin`.\n+                let access = if !two_phase { Some(AccessKind::Write) } else { None };\n+                (perm, access)\n             }\n-            RefKind::Unique { .. } => {\n-                // Two-phase references and !Unpin references are treated as SharedReadWrite\n-                Permission::SharedReadWrite\n+            RefKind::Raw { mutable: true } => {\n+                // Creating a raw ptr does not count as an access\n+                (Permission::SharedReadWrite, None)\n             }\n-            RefKind::Raw { mutable: true } => Permission::SharedReadWrite,\n             RefKind::Shared | RefKind::Raw { mutable: false } => {\n                 // Shared references and *const are a whole different kind of game, the\n                 // permission is not uniform across the entire range!\n                 // We need a frozen-sensitive reborrow.\n                 // We have to use shared references to alloc/memory_extra here since\n                 // `visit_freeze_sensitive` needs to access the global state.\n-                let extra = this.get_alloc_extra(alloc_id)?;\n-                let mut stacked_borrows = extra\n+                let alloc_extra = this.get_alloc_extra(alloc_id)?;\n+                let mut stacked_borrows = alloc_extra\n                     .stacked_borrows\n                     .as_ref()\n                     .expect(\"we should have Stacked Borrows data\")\n@@ -892,10 +884,13 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                     // Adjust range.\n                     range.start += base_offset;\n                     // We are only ever `SharedReadOnly` inside the frozen bits.\n-                    let perm = if frozen {\n-                        Permission::SharedReadOnly\n+                    let (perm, access) = if frozen {\n+                        (Permission::SharedReadOnly, Some(AccessKind::Read))\n                     } else {\n-                        Permission::SharedReadWrite\n+                        // Inside UnsafeCell, this does *not* count as an access, as there\n+                        // might actually be mutable references further up the stack that\n+                        // we have to keep alive.\n+                        (Permission::SharedReadWrite, None)\n                     };\n                     let protected = if frozen {\n                         protect.is_some()\n@@ -914,8 +909,17 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                         alloc_range(base_offset, size),\n                     );\n                     stacked_borrows.for_each(range, dcx, |stack, dcx, exposed_tags| {\n-                        stack.grant(orig_tag, item, &global, dcx, exposed_tags)\n-                    })\n+                        stack.grant(orig_tag, item, access, &global, dcx, exposed_tags)\n+                    })?;\n+                    drop(global);\n+                    if let Some(access) = access {\n+                        assert_eq!(access, AccessKind::Read);\n+                        // Make sure the data race model also knows about this.\n+                        if let Some(data_race) = alloc_extra.data_race.as_ref() {\n+                            data_race.read(alloc_id, range, &this.machine)?;\n+                        }\n+                    }\n+                    Ok(())\n                 })?;\n                 return Ok(Some(alloc_id));\n             }\n@@ -941,8 +945,16 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n             alloc_range(base_offset, size),\n         );\n         stacked_borrows.for_each(range, dcx, |stack, dcx, exposed_tags| {\n-            stack.grant(orig_tag, item, &global, dcx, exposed_tags)\n+            stack.grant(orig_tag, item, access, &global, dcx, exposed_tags)\n         })?;\n+        drop(global);\n+        if let Some(access) = access {\n+            assert_eq!(access, AccessKind::Write);\n+            // Make sure the data race model also knows about this.\n+            if let Some(data_race) = alloc_extra.data_race.as_mut() {\n+                data_race.write(alloc_id, range, machine)?;\n+            }\n+        }\n \n         Ok(Some(alloc_id))\n     }"}, {"sha": "51a6fba6df01144d50b166bddd2f9f5a6b5033d1", "filename": "src/tools/miri/src/stacked_borrows/stack.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fstack.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -367,10 +367,10 @@ impl<'tcx> Stack {\n \n     /// Find all `Unique` elements in this borrow stack above `granting_idx`, pass a copy of them\n     /// to the `visitor`, then set their `Permission` to `Disabled`.\n-    pub fn disable_uniques_starting_at<V: FnMut(Item) -> crate::InterpResult<'tcx>>(\n+    pub fn disable_uniques_starting_at(\n         &mut self,\n         disable_start: usize,\n-        mut visitor: V,\n+        mut visitor: impl FnMut(Item) -> crate::InterpResult<'tcx>,\n     ) -> crate::InterpResult<'tcx> {\n         #[cfg(feature = \"stack-cache\")]\n         let unique_range = self.unique_range.clone();"}, {"sha": "6040452a166cbebfe09878abf4236b52938ac0fc", "filename": "src/tools/miri/tests/fail/data_race/alloc_read_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_read_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_read_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_read_race.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n #![feature(new_uninit)]\n \n use std::mem::MaybeUninit;"}, {"sha": "51d431b36f3a36af40c9ca6a128aca6bdb7fc9d9", "filename": "src/tools/miri/tests/fail/data_race/alloc_write_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_write_race.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n #![feature(new_uninit)]\n \n use std::ptr::null_mut;"}, {"sha": "79c6760b7c42af4d71177abb468fceb981d6e9b4", "filename": "src/tools/miri/tests/fail/data_race/atomic_read_na_write_race1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread::spawn;"}, {"sha": "e069ac4ad6a83319a50597248cba798ad608fa4e", "filename": "src/tools/miri/tests/fail/data_race/atomic_read_na_write_race2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::AtomicUsize;\n use std::sync::atomic::Ordering;"}, {"sha": "9c025a0153d58276cdc1152e9be746922685c1d8", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_read_race1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::AtomicUsize;\n use std::sync::atomic::Ordering;"}, {"sha": "30b3c4863740c0202ed87cc783586d5038ec51c1", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_read_race2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread::spawn;"}, {"sha": "02b17cc57b61a51e2f45a0e5a5b81124f45c5970", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_write_race1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread::spawn;"}, {"sha": "b5f4966d8842af1d714480c47da531bcc558d5e2", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_write_race2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::AtomicUsize;\n use std::sync::atomic::Ordering;"}, {"sha": "9922468e5f8424c67fecf0ecf362fba5841abb1f", "filename": "src/tools/miri/tests/fail/data_race/dangling_thread_async_race.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-disable-isolation -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::mem;\n use std::thread::{sleep, spawn};"}, {"sha": "8c8a6ac87f3ab550a0f0a75635de4695cfbda1b0", "filename": "src/tools/miri/tests/fail/data_race/dangling_thread_race.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_race.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-disable-isolation -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::mem;\n use std::thread::{sleep, spawn};"}, {"sha": "8e1216f5bf0a023008afd139efb1f268299347bd", "filename": "src/tools/miri/tests/fail/data_race/dealloc_read_race1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::thread::spawn;\n "}, {"sha": "38f76af9de1373d5661d5a9aca9df4aec327f355", "filename": "src/tools/miri/tests/fail/data_race/dealloc_read_race2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race2.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::thread::spawn;\n "}, {"sha": "665e5ce4a1706c8c98dae69655da6bc0f41f4480", "filename": "src/tools/miri/tests/fail/data_race/dealloc_read_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::ptr::null_mut;\n use std::sync::atomic::{AtomicPtr, Ordering};"}, {"sha": "b36c6b5ac0e45ce5a8aeba89369b6b8e6007bacf", "filename": "src/tools/miri/tests/fail/data_race/dealloc_write_race1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::thread::spawn;\n "}, {"sha": "4af8b904626d203268d6a08a52ba3ee7f9e4a4f9", "filename": "src/tools/miri/tests/fail/data_race/dealloc_write_race2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race2.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::thread::spawn;\n "}, {"sha": "f851ce95785f7e884d8ef4d8d3109409aa5882a4", "filename": "src/tools/miri/tests/fail/data_race/dealloc_write_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::ptr::null_mut;\n use std::sync::atomic::{AtomicPtr, Ordering};"}, {"sha": "27aa16a122f364207547836f73ad2bdb92b673bf", "filename": "src/tools/miri/tests/fail/data_race/enable_after_join_to_main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::thread::spawn;\n "}, {"sha": "4d436d51f9895ee1c68a35931a98c69cdda8a7e1", "filename": "src/tools/miri/tests/fail/data_race/fence_after_load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Ffence_after_load.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Ffence_after_load.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Ffence_after_load.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-disable-isolation -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n use std::sync::atomic::{fence, AtomicUsize, Ordering};\n use std::sync::Arc;\n use std::thread;"}, {"sha": "b26ec6c41427aadb1d0ae01d31e5415520ab2eb5", "filename": "src/tools/miri/tests/fail/data_race/read_write_race.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::thread::spawn;\n "}, {"sha": "2fbac173993e4dae564949efceb43d59e7f24034", "filename": "src/tools/miri/tests/fail/data_race/read_write_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-isolation -Zmir-opt-level=0 -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmir-opt-level=0 -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n // Note: mir-opt-level set to 0 to prevent the read of stack_var in thread 1\n // from being optimized away and preventing the detection of the data-race."}, {"sha": "24040a9496114a37ac07d01ba48afa8b9a31576f", "filename": "src/tools/miri/tests/fail/data_race/relax_acquire_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelax_acquire_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelax_acquire_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelax_acquire_race.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread::spawn;"}, {"sha": "2d7246858e108317a6d8b95572769721d4acbace", "filename": "src/tools/miri/tests/fail/data_race/release_seq_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread::{sleep, spawn};"}, {"sha": "0f974e1c56d3fd0e032c2d53e77f5ee6e123d40c", "filename": "src/tools/miri/tests/fail/data_race/release_seq_race_same_thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread::spawn;"}, {"sha": "2d13da30b46393a257c2383cf06bd0c5aa4ecd6a", "filename": "src/tools/miri/tests/fail/data_race/rmw_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frmw_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frmw_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frmw_race.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread::spawn;"}, {"sha": "cf5c2ed81cb1d1d8e7b992c9875dda159c4046ac", "filename": "src/tools/miri/tests/fail/data_race/stack_pop_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fstack_pop_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fstack_pop_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fstack_pop_race.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n use std::thread;\n \n #[derive(Copy, Clone)]"}, {"sha": "60e9ac2ac6c383f0006b410e50d0b01f6ca6d543", "filename": "src/tools/miri/tests/fail/data_race/write_write_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -1,5 +1,5 @@\n // We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::thread::spawn;\n "}, {"sha": "0a29dc13cba1746f66f5af7f21b75e275f68ea28", "filename": "src/tools/miri/tests/fail/data_race/write_write_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::ptr::null_mut;\n use std::sync::atomic::{AtomicPtr, Ordering};"}, {"sha": "670dd4baad8bc675d69194a61842009bb19578c3", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_dealloc1.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_dealloc1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_dealloc1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_dealloc1.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -0,0 +1,14 @@\n+//@error-pattern: /deallocation .* tag does not exist in the borrow stack/\n+use std::alloc::{alloc, dealloc, Layout};\n+\n+fn main() {\n+    unsafe {\n+        let x = alloc(Layout::from_size_align_unchecked(1, 1));\n+        let ptr1 = (&mut *x) as *mut u8;\n+        let ptr2 = (&mut *ptr1) as *mut u8;\n+        // Invalidate ptr2 by writing to ptr1.\n+        ptr1.write(0);\n+        // Deallocate through ptr2.\n+        dealloc(ptr2, Layout::from_size_align_unchecked(1, 1));\n+    }\n+}"}, {"sha": "3b7802901a54eb723ddf23ae38b9b557d1772a2c", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_dealloc1.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_dealloc1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_dealloc1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_dealloc1.stderr?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -0,0 +1,30 @@\n+error: Undefined Behavior: attempting deallocation using <TAG> at ALLOC, but that tag does not exist in the borrow stack for this location\n+  --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   |\n+LL |     unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attempting deallocation using <TAG> at ALLOC, but that tag does not exist in the borrow stack for this location\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n+   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n+help: <TAG> was created by a SharedReadWrite retag at offsets [0x0..0x1]\n+  --> $DIR/illegal_deALLOC.rs:LL:CC\n+   |\n+LL |         let ptr2 = (&mut *ptr1) as *mut u8;\n+   |                    ^^^^^^^^^^^^\n+help: <TAG> was later invalidated at offsets [0x0..0x1] by a write access\n+  --> $DIR/illegal_deALLOC.rs:LL:CC\n+   |\n+LL |         ptr1.write(0);\n+   |         ^^^^^^^^^^^^^\n+   = note: BACKTRACE:\n+   = note: inside `std::alloc::dealloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+note: inside `main` at $DIR/illegal_deALLOC.rs:LL:CC\n+  --> $DIR/illegal_deALLOC.rs:LL:CC\n+   |\n+LL |         dealloc(ptr2, Layout::from_size_align_unchecked(1, 1));\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "d660921bfe6e2d4755bb18e3c79e8da602fd707a", "filename": "src/tools/miri/tests/fail/stacked_borrows/notunpin_dereferenceable_fakeread.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -0,0 +1,17 @@\n+//! Reborrowing a `&mut !Unpin` must still act like a (fake) read.\n+use std::marker::PhantomPinned;\n+\n+struct NotUnpin(i32, PhantomPinned);\n+\n+fn main() {\n+    unsafe {\n+        let mut x = NotUnpin(0, PhantomPinned);\n+        // Mutable borrow of `Unpin` field (with lifetime laundering)\n+        let fieldref = &mut *(&mut x.0 as *mut i32);\n+        // Mutable reborrow of the entire `x`, which is `!Unpin` but should\n+        // still count as a read since we would add `dereferenceable`.\n+        let _xref = &mut x;\n+        // That read should have invalidated `fieldref`.\n+        *fieldref = 0; //~ ERROR: /write access .* tag does not exist in the borrow stack/\n+    }\n+}"}, {"sha": "3ef8a8e0e9c6a8939975bc3829fbd16e50092577", "filename": "src/tools/miri/tests/fail/stacked_borrows/notunpin_dereferenceable_fakeread.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.stderr?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -0,0 +1,28 @@\n+error: Undefined Behavior: attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+  --> $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n+   |\n+LL |         *fieldref = 0;\n+   |         ^^^^^^^^^^^^^\n+   |         |\n+   |         attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |         this error occurs as part of an access at ALLOC[0x0..0x4]\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n+   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n+help: <TAG> was created by a Unique retag at offsets [0x0..0x4]\n+  --> $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n+   |\n+LL |         let fieldref = &mut *(&mut x.0 as *mut i32);\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a SharedReadWrite retag\n+  --> $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n+   |\n+LL |         let _xref = &mut x;\n+   |                     ^^^^^^\n+   = note: BACKTRACE:\n+   = note: inside `main` at $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "309d7a22be64f20b3eebafe3aa9d89f0d9d09235", "filename": "src/tools/miri/tests/fail/stacked_borrows/retag_data_race_read.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -0,0 +1,31 @@\n+//! Make sure that a retag acts like a write for the data race model.\n+//@compile-flags: -Zmiri-preemption-rate=0\n+#[derive(Copy, Clone)]\n+struct SendPtr(*mut u8);\n+\n+unsafe impl Send for SendPtr {}\n+\n+fn thread_1(p: SendPtr) {\n+    let p = p.0;\n+    unsafe {\n+        let _r = &*p;\n+    }\n+}\n+\n+fn thread_2(p: SendPtr) {\n+    let p = p.0;\n+    unsafe {\n+        *p = 5; //~ ERROR: Data race detected between Write on thread `<unnamed>` and Read on thread `<unnamed>`\n+    }\n+}\n+\n+fn main() {\n+    let mut x = 0;\n+    let p = std::ptr::addr_of_mut!(x);\n+    let p = SendPtr(p);\n+\n+    let t1 = std::thread::spawn(move || thread_1(p));\n+    let t2 = std::thread::spawn(move || thread_2(p));\n+    let _ = t1.join();\n+    let _ = t2.join();\n+}"}, {"sha": "f25d689524d1b3c86a565ea215a7ec5034a5e03a", "filename": "src/tools/miri/tests/fail/stacked_borrows/retag_data_race_read.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.stderr?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -0,0 +1,20 @@\n+error: Undefined Behavior: Data race detected between Write on thread `<unnamed>` and Read on thread `<unnamed>` at ALLOC\n+  --> $DIR/retag_data_race_read.rs:LL:CC\n+   |\n+LL |         *p = 5;\n+   |         ^^^^^^ Data race detected between Write on thread `<unnamed>` and Read on thread `<unnamed>` at ALLOC\n+   |\n+   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n+   = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n+   = note: BACKTRACE:\n+   = note: inside `thread_2` at $DIR/retag_data_race_read.rs:LL:CC\n+note: inside closure at $DIR/retag_data_race_read.rs:LL:CC\n+  --> $DIR/retag_data_race_read.rs:LL:CC\n+   |\n+LL |     let t2 = std::thread::spawn(move || thread_2(p));\n+   |                                         ^^^^^^^^^^^\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "9368a0a919eb3c9a6dc7eadffdea342b5b7efa56", "filename": "src/tools/miri/tests/fail/stacked_borrows/retag_data_race_write.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_write.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -0,0 +1,31 @@\n+//! Make sure that a retag acts like a write for the data race model.\n+//@compile-flags: -Zmiri-preemption-rate=0\n+#[derive(Copy, Clone)]\n+struct SendPtr(*mut u8);\n+\n+unsafe impl Send for SendPtr {}\n+\n+fn thread_1(p: SendPtr) {\n+    let p = p.0;\n+    unsafe {\n+        let _r = &mut *p;\n+    }\n+}\n+\n+fn thread_2(p: SendPtr) {\n+    let p = p.0;\n+    unsafe {\n+        *p = 5; //~ ERROR: Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>`\n+    }\n+}\n+\n+fn main() {\n+    let mut x = 0;\n+    let p = std::ptr::addr_of_mut!(x);\n+    let p = SendPtr(p);\n+\n+    let t1 = std::thread::spawn(move || thread_1(p));\n+    let t2 = std::thread::spawn(move || thread_2(p));\n+    let _ = t1.join();\n+    let _ = t2.join();\n+}"}, {"sha": "f97e6bb11e9d674a7535cfef0329d4c8397f61aa", "filename": "src/tools/miri/tests/fail/stacked_borrows/retag_data_race_write.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_write.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_write.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_write.stderr?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -0,0 +1,20 @@\n+error: Undefined Behavior: Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+  --> $DIR/retag_data_race_write.rs:LL:CC\n+   |\n+LL |         *p = 5;\n+   |         ^^^^^^ Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+   |\n+   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n+   = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n+   = note: BACKTRACE:\n+   = note: inside `thread_2` at $DIR/retag_data_race_write.rs:LL:CC\n+note: inside closure at $DIR/retag_data_race_write.rs:LL:CC\n+  --> $DIR/retag_data_race_write.rs:LL:CC\n+   |\n+LL |     let t2 = std::thread::spawn(move || thread_2(p));\n+   |                                         ^^^^^^^^^^^\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}]}