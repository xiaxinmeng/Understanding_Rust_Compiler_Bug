{"sha": "0bfbaa6e8dfb509b453020740fd37c7a22882c87", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiZmJhYTZlOGRmYjUwOWI0NTMwMjA3NDBmZDM3YzdhMjI4ODJjODc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-30T16:54:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-30T16:54:13Z"}, "message": "Auto merge of #61253 - nnethercote:avoid-hygiene_data-lookups, r=petrochenkov\n\nAvoid `hygiene_data` lookups\n\nThese commits mostly introduce compound operations that allow two close adjacent `hygiene_data` lookups to be combined.\n\nr? @petrochenkov", "tree": {"sha": "1ebe6b4f2e4fbb80aa87763f833c674bfd704d27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ebe6b4f2e4fbb80aa87763f833c674bfd704d27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0bfbaa6e8dfb509b453020740fd37c7a22882c87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0bfbaa6e8dfb509b453020740fd37c7a22882c87", "html_url": "https://github.com/rust-lang/rust/commit/0bfbaa6e8dfb509b453020740fd37c7a22882c87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0bfbaa6e8dfb509b453020740fd37c7a22882c87/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aee7012fab26d5e307a2fe767e4e7c847c5a45ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/aee7012fab26d5e307a2fe767e4e7c847c5a45ee", "html_url": "https://github.com/rust-lang/rust/commit/aee7012fab26d5e307a2fe767e4e7c847c5a45ee"}, {"sha": "95ea7fd735619089ea9a0e95e2f41170127df567", "url": "https://api.github.com/repos/rust-lang/rust/commits/95ea7fd735619089ea9a0e95e2f41170127df567", "html_url": "https://github.com/rust-lang/rust/commit/95ea7fd735619089ea9a0e95e2f41170127df567"}], "stats": {"total": 162, "additions": 100, "deletions": 62}, "files": [{"sha": "86dae579ca753d859b3dc04a320a503b53f9e2c5", "filename": "src/librustc/lint/internal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc%2Flint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc%2Flint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Finternal.rs?ref=0bfbaa6e8dfb509b453020740fd37c7a22882c87", "patch": "@@ -113,7 +113,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n                             .help(\"try using `Ty` instead\")\n                             .emit();\n                         } else {\n-                            if ty.span.ctxt().outer().expn_info().is_some() {\n+                            if ty.span.ctxt().outer_expn_info().is_some() {\n                                 return;\n                             }\n                             if let Some(t) = is_ty_or_ty_ctxt(cx, ty) {"}, {"sha": "f4eff6121c043b0550b3500c02761ddefbf333f7", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=0bfbaa6e8dfb509b453020740fd37c7a22882c87", "patch": "@@ -880,7 +880,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n /// This is used to test whether a lint should not even begin to figure out whether it should\n /// be reported on the current node.\n pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n-    let info = match span.ctxt().outer().expn_info() {\n+    let info = match span.ctxt().outer_expn_info() {\n         Some(info) => info,\n         // no ExpnInfo means this span doesn't come from a macro\n         None => return false,\n@@ -908,7 +908,7 @@ pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n \n /// Returns whether `span` originates in a derive macro's expansion\n pub fn in_derive_expansion(span: Span) -> bool {\n-    let info = match span.ctxt().outer().expn_info() {\n+    let info = match span.ctxt().outer_expn_info() {\n         Some(info) => info,\n         // no ExpnInfo means this span doesn't come from a macro\n         None => return false,"}, {"sha": "a29b173880a081aa21f1fc844c4792eeff8d2b2c", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=0bfbaa6e8dfb509b453020740fd37c7a22882c87", "patch": "@@ -65,7 +65,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 format: ExpnFormat::CompilerDesugaring(_),\n                 def_site: Some(def_span),\n                 ..\n-            }) = span.ctxt().outer().expn_info() {\n+            }) = span.ctxt().outer_expn_info() {\n                 span = def_span;\n             }\n "}, {"sha": "0cbc0112a8e10a0bd0b04790e8ab3e0c5c1a5ac9", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=0bfbaa6e8dfb509b453020740fd37c7a22882c87", "patch": "@@ -2886,7 +2886,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn find_field_index(self, ident: Ident, variant: &VariantDef) -> Option<usize> {\n         variant.fields.iter().position(|field| {\n-            self.adjust_ident(ident, variant.def_id, hir::DUMMY_HIR_ID).0 == field.ident.modern()\n+            self.hygienic_eq(ident, field.ident, variant.def_id)\n         })\n     }\n \n@@ -3085,19 +3085,32 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// its supposed definition name (`def_name`). The method also needs `DefId` of the supposed\n     /// definition's parent/scope to perform comparison.\n     pub fn hygienic_eq(self, use_name: Ident, def_name: Ident, def_parent_def_id: DefId) -> bool {\n-        self.adjust_ident(use_name, def_parent_def_id, hir::DUMMY_HIR_ID).0 == def_name.modern()\n+        // We could use `Ident::eq` here, but we deliberately don't. The name\n+        // comparison fails frequently, and we want to avoid the expensive\n+        // `modern()` calls required for the span comparison whenever possible.\n+        use_name.name == def_name.name &&\n+        self.adjust_ident(use_name, def_parent_def_id).span.ctxt() == def_name.modern().span.ctxt()\n     }\n \n-    pub fn adjust_ident(self, mut ident: Ident, scope: DefId, block: hir::HirId) -> (Ident, DefId) {\n-        ident = ident.modern();\n-        let target_expansion = match scope.krate {\n+    fn expansion_that_defined(self, scope: DefId) -> Mark {\n+        match scope.krate {\n             LOCAL_CRATE => self.hir().definitions().expansion_that_defined(scope.index),\n             _ => Mark::root(),\n-        };\n-        let scope = match ident.span.adjust(target_expansion) {\n+        }\n+    }\n+\n+    pub fn adjust_ident(self, mut ident: Ident, scope: DefId) -> Ident {\n+        ident = ident.modern();\n+        ident.span.adjust(self.expansion_that_defined(scope));\n+        ident\n+    }\n+\n+    pub fn adjust_ident_and_get_scope(self, mut ident: Ident, scope: DefId, block: hir::HirId)\n+                                      -> (Ident, DefId) {\n+        ident = ident.modern();\n+        let scope = match ident.span.adjust(self.expansion_that_defined(scope)) {\n             Some(actual_expansion) =>\n                 self.hir().definitions().parent_module_of_macro_def(actual_expansion),\n-            None if block == hir::DUMMY_HIR_ID => DefId::local(CRATE_DEF_INDEX), // Dummy DefId\n             None => self.hir().get_module_parent_by_hir_id(block),\n         };\n         (ident, scope)"}, {"sha": "5d6f7036c3e29cf4fabb7fad3b8bc4e6e98db697", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=0bfbaa6e8dfb509b453020740fd37c7a22882c87", "patch": "@@ -131,7 +131,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             // at the level above that.\n             let mut span = source_info.span;\n             while span.ctxt() != NO_EXPANSION && span.ctxt() != self.mir.span.ctxt() {\n-                if let Some(info) = span.ctxt().outer().expn_info() {\n+                if let Some(info) = span.ctxt().outer_expn_info() {\n                     span = info.call_site;\n                 } else {\n                     break;"}, {"sha": "44b727c6925d94c544e6f53133e22b7d5e6f91c5", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=0bfbaa6e8dfb509b453020740fd37c7a22882c87", "patch": "@@ -158,7 +158,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n                 if fieldpat.node.is_shorthand {\n                     continue;\n                 }\n-                if fieldpat.span.ctxt().outer().expn_info().is_some() {\n+                if fieldpat.span.ctxt().outer_expn_info().is_some() {\n                     // Don't lint if this is a macro expansion: macro authors\n                     // shouldn't have to worry about this kind of style issue\n                     // (Issue #49588)\n@@ -1003,7 +1003,7 @@ impl UnreachablePub {\n         let mut applicability = Applicability::MachineApplicable;\n         match vis.node {\n             hir::VisibilityKind::Public if !cx.access_levels.is_reachable(id) => {\n-                if span.ctxt().outer().expn_info().is_some() {\n+                if span.ctxt().outer_expn_info().is_some() {\n                     applicability = Applicability::MaybeIncorrect;\n                 }\n                 let def_span = cx.tcx.sess.source_map().def_span(span);"}, {"sha": "036820c6d7fa1386d30ba69fb1720990fec71eef", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=0bfbaa6e8dfb509b453020740fd37c7a22882c87", "patch": "@@ -391,9 +391,8 @@ impl EarlyLintPass for UnusedParens {\n                 // trigger in situations that macro authors shouldn't have to care about, e.g.,\n                 // when a parenthesized token tree matched in one macro expansion is matched as\n                 // an expression in another and used as a fn/method argument (Issue #47775)\n-                if e.span.ctxt().outer().expn_info()\n-                    .map_or(false, |info| info.call_site.ctxt().outer()\n-                            .expn_info().is_some()) {\n+                if e.span.ctxt().outer_expn_info()\n+                    .map_or(false, |info| info.call_site.ctxt().outer_expn_info().is_some()) {\n                         return;\n                 }\n                 let msg = format!(\"{} argument\", call_kind);"}, {"sha": "20e18d60f076b43e36fbb762c0f281eac43c096b", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=0bfbaa6e8dfb509b453020740fd37c7a22882c87", "patch": "@@ -845,7 +845,7 @@ impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n                    field: &'tcx ty::FieldDef) { // definition of the field\n         let ident = Ident::new(kw::Invalid, use_ctxt);\n         let current_hir = self.current_item;\n-        let def_id = self.tcx.adjust_ident(ident, def.did, current_hir).1;\n+        let def_id = self.tcx.adjust_ident_and_get_scope(ident, def.did, current_hir).1;\n         if !def.is_enum() && !field.vis.is_accessible_from(def_id, self.tcx) {\n             struct_span_err!(self.tcx.sess, span, E0451, \"field `{}` of {} `{}` is private\",\n                              field.ident, def.variant_descr(), self.tcx.def_path_str(def.did))"}, {"sha": "59e5fc149fc6e76b7f2ab3bbf14ae736d22c3917", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=0bfbaa6e8dfb509b453020740fd37c7a22882c87", "patch": "@@ -762,7 +762,7 @@ impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n                 ItemKind::Use(..) => {\n                     // don't suggest placing a use before the prelude\n                     // import or other generated ones\n-                    if item.span.ctxt().outer().expn_info().is_none() {\n+                    if item.span.ctxt().outer_expn_info().is_none() {\n                         self.span = Some(item.span.shrink_to_lo());\n                         self.found_use = true;\n                         return;\n@@ -772,7 +772,7 @@ impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n                 ItemKind::ExternCrate(_) => {}\n                 // but place them before the first other item\n                 _ => if self.span.map_or(true, |span| item.span < span ) {\n-                    if item.span.ctxt().outer().expn_info().is_none() {\n+                    if item.span.ctxt().outer_expn_info().is_none() {\n                         // don't insert between attributes and an item\n                         if item.attrs.is_empty() {\n                             self.span = Some(item.span.shrink_to_lo());\n@@ -2308,7 +2308,7 @@ impl<'a> Resolver<'a> {\n \n     fn hygienic_lexical_parent(&mut self, module: Module<'a>, span: &mut Span)\n                                -> Option<Module<'a>> {\n-        if !module.expansion.is_descendant_of(span.ctxt().outer()) {\n+        if !module.expansion.outer_is_descendant_of(span.ctxt()) {\n             return Some(self.macro_def_scope(span.remove_mark()));\n         }\n \n@@ -2344,7 +2344,7 @@ impl<'a> Resolver<'a> {\n             module.expansion.is_descendant_of(parent.expansion) {\n                 // The macro is a proc macro derive\n                 if module.expansion.looks_like_proc_macro_derive() {\n-                    if parent.expansion.is_descendant_of(span.ctxt().outer()) {\n+                    if parent.expansion.outer_is_descendant_of(span.ctxt()) {\n                         *poisoned = Some(node_id);\n                         return module.parent;\n                     }"}, {"sha": "08ab5b853252255e996d7fab640b3b5d264731f0", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=0bfbaa6e8dfb509b453020740fd37c7a22882c87", "patch": "@@ -413,7 +413,7 @@ impl<'a> Resolver<'a> {\n \n         // Possibly apply the macro helper hack\n         if kind == MacroKind::Bang && path.len() == 1 &&\n-           path[0].ident.span.ctxt().outer().expn_info()\n+           path[0].ident.span.ctxt().outer_expn_info()\n                .map_or(false, |info| info.local_inner_macros) {\n             let root = Ident::new(kw::DollarCrate, path[0].ident.span);\n             path.insert(0, Segment::from_ident(root));"}, {"sha": "cd53bdc6ed0a04c9a144e3fcd189ac7d6541dddf", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=0bfbaa6e8dfb509b453020740fd37c7a22882c87", "patch": "@@ -903,7 +903,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         }?;\n \n         let (assoc_ident, def_scope) =\n-            tcx.adjust_ident(binding.item_name, candidate.def_id(), hir_ref_id);\n+            tcx.adjust_ident_and_get_scope(binding.item_name, candidate.def_id(), hir_ref_id);\n         let assoc_ty = tcx.associated_items(candidate.def_id()).find(|i| {\n             i.kind == ty::AssocKind::Type && i.ident.modern() == assoc_ident\n         }).expect(\"missing associated type\");\n@@ -1433,7 +1433,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         };\n \n         let trait_did = bound.def_id();\n-        let (assoc_ident, def_scope) = tcx.adjust_ident(assoc_ident, trait_did, hir_ref_id);\n+        let (assoc_ident, def_scope) =\n+            tcx.adjust_ident_and_get_scope(assoc_ident, trait_did, hir_ref_id);\n         let item = tcx.associated_items(trait_did).find(|i| {\n             Namespace::from(i.kind) == Namespace::Type &&\n                 i.ident.modern() == assoc_ident"}, {"sha": "5cd95a9d834c4af1b547894391af44ccb0ddadcb", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=0bfbaa6e8dfb509b453020740fd37c7a22882c87", "patch": "@@ -1184,7 +1184,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         let mut inexistent_fields = vec![];\n         // Typecheck each field.\n         for &Spanned { node: ref field, span } in fields {\n-            let ident = tcx.adjust_ident(field.ident, variant.def_id, self.body_id).0;\n+            let ident = tcx.adjust_ident(field.ident, variant.def_id);\n             let field_ty = match used_fields.entry(ident) {\n                 Occupied(occupied) => {\n                     struct_span_err!(tcx.sess, span, E0025,"}, {"sha": "87fc90f53abca688a349f0883b134b8400eefd08", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=0bfbaa6e8dfb509b453020740fd37c7a22882c87", "patch": "@@ -331,7 +331,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Check the `expn_info()` to see if this is a macro; if so, it's hard to\n         // extract the text and make a good suggestion, so don't bother.\n-        let is_macro = sp.ctxt().outer().expn_info().is_some();\n+        let is_macro = sp.ctxt().outer_expn_info().is_some();\n \n         match (&expr.node, &expected.sty, &checked_ty.sty) {\n             (_, &ty::Ref(_, exp, _), &ty::Ref(_, check, _)) => match (&exp.sty, &check.sty) {"}, {"sha": "898c15fc77ff7f743038e6ac3002238961381703", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=0bfbaa6e8dfb509b453020740fd37c7a22882c87", "patch": "@@ -510,7 +510,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     {\n         let is_accessible = if let Some(name) = self.method_name {\n             let item = candidate.item;\n-            let def_scope = self.tcx.adjust_ident(name, item.container.id(), self.body_id).1;\n+            let def_scope =\n+                self.tcx.adjust_ident_and_get_scope(name, item.container.id(), self.body_id).1;\n             item.vis.is_accessible_from(def_scope, self.tcx)\n         } else {\n             true"}, {"sha": "9ef6112a94591f5f4ff3b2cecd9f09a21b2def43", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=0bfbaa6e8dfb509b453020740fd37c7a22882c87", "patch": "@@ -892,7 +892,7 @@ impl<'a, 'tcx, 'gcx> hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'a, '\n                 hir::ItemKind::Use(..) => {\n                     // Don't suggest placing a `use` before the prelude\n                     // import or other generated ones.\n-                    if item.span.ctxt().outer().expn_info().is_none() {\n+                    if item.span.ctxt().outer_expn_info().is_none() {\n                         self.span = Some(item.span.shrink_to_lo());\n                         self.found_use = true;\n                         return;\n@@ -902,7 +902,7 @@ impl<'a, 'tcx, 'gcx> hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'a, '\n                 hir::ItemKind::ExternCrate(_) => {}\n                 // ...but do place them before the first other item.\n                 _ => if self.span.map_or(true, |span| item.span < span ) {\n-                    if item.span.ctxt().outer().expn_info().is_none() {\n+                    if item.span.ctxt().outer_expn_info().is_none() {\n                         // Don't insert between attributes and an item.\n                         if item.attrs.is_empty() {\n                             self.span = Some(item.span.shrink_to_lo());"}, {"sha": "7a6d02cc33b210cc3e93d06fa624f1e921d9059b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0bfbaa6e8dfb509b453020740fd37c7a22882c87", "patch": "@@ -3339,7 +3339,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 ty::Adt(base_def, substs) if !base_def.is_enum() => {\n                     debug!(\"struct named {:?}\",  base_t);\n                     let (ident, def_scope) =\n-                        self.tcx.adjust_ident(field, base_def.did, self.body_id);\n+                        self.tcx.adjust_ident_and_get_scope(field, base_def.did, self.body_id);\n                     let fields = &base_def.non_enum_variant().fields;\n                     if let Some(index) = fields.iter().position(|f| f.ident.modern() == ident) {\n                         let field = &fields[index];\n@@ -3510,7 +3510,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn available_field_names(&self, variant: &'tcx ty::VariantDef) -> Vec<ast::Name> {\n         variant.fields.iter().filter(|field| {\n-            let def_scope = self.tcx.adjust_ident(field.ident, variant.def_id, self.body_id).1;\n+            let def_scope =\n+                self.tcx.adjust_ident_and_get_scope(field.ident, variant.def_id, self.body_id).1;\n             field.vis.is_accessible_from(def_scope, self.tcx)\n         })\n         .map(|field| field.ident.name)\n@@ -3628,7 +3629,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Type-check each field.\n         for field in ast_fields {\n-            let ident = tcx.adjust_ident(field.ident, variant.def_id, self.body_id).0;\n+            let ident = tcx.adjust_ident(field.ident, variant.def_id);\n             let field_type = if let Some((i, v_field)) = remaining_fields.remove(&ident) {\n                 seen_fields.insert(ident, field.span);\n                 self.write_field_index(field.hir_id, i);"}, {"sha": "4b5b9ff7bbeeee5b9febe53a99f84b9c7184ca29", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=0bfbaa6e8dfb509b453020740fd37c7a22882c87", "patch": "@@ -872,7 +872,7 @@ impl<'a> ExtCtxt<'a> {\n         let mut ctxt = self.backtrace();\n         let mut last_macro = None;\n         loop {\n-            if ctxt.outer().expn_info().map_or(None, |info| {\n+            if ctxt.outer_expn_info().map_or(None, |info| {\n                 if info.format.name() == sym::include {\n                     // Stop going up the backtrace once include! is encountered\n                     return None;"}, {"sha": "4b6893b242337d03cf6f929c90aa2a2bbee0c16a", "filename": "src/libsyntax/source_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibsyntax%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibsyntax%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map.rs?ref=0bfbaa6e8dfb509b453020740fd37c7a22882c87", "patch": "@@ -30,8 +30,8 @@ use errors::SourceMapper;\n /// otherwise return the call site span up to the `enclosing_sp` by\n /// following the `expn_info` chain.\n pub fn original_sp(sp: Span, enclosing_sp: Span) -> Span {\n-    let call_site1 = sp.ctxt().outer().expn_info().map(|ei| ei.call_site);\n-    let call_site2 = enclosing_sp.ctxt().outer().expn_info().map(|ei| ei.call_site);\n+    let call_site1 = sp.ctxt().outer_expn_info().map(|ei| ei.call_site);\n+    let call_site2 = enclosing_sp.ctxt().outer_expn_info().map(|ei| ei.call_site);\n     match (call_site1, call_site2) {\n         (None, _) => sp,\n         (Some(call_site1), Some(call_site2)) if call_site1 == call_site2 => sp,"}, {"sha": "cc05ecf8df5a6dc91f92f5a7d339178edd2b586f", "filename": "src/libsyntax_ext/proc_macro_server.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_server.rs?ref=0bfbaa6e8dfb509b453020740fd37c7a22882c87", "patch": "@@ -680,7 +680,7 @@ impl server::Span for Rustc<'_> {\n         self.sess.source_map().lookup_char_pos(span.lo()).file\n     }\n     fn parent(&mut self, span: Self::Span) -> Option<Self::Span> {\n-        span.ctxt().outer().expn_info().map(|i| i.call_site)\n+        span.ctxt().outer_expn_info().map(|i| i.call_site)\n     }\n     fn source(&mut self, span: Self::Span) -> Self::Span {\n         span.source_callsite()"}, {"sha": "445d4271d890553c8bd58beb8f0e36cb16314b4c", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 37, "deletions": 14, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=0bfbaa6e8dfb509b453020740fd37c7a22882c87", "patch": "@@ -112,16 +112,14 @@ impl Mark {\n         HygieneData::with(|data| data.marks[self.0 as usize].default_transparency = transparency)\n     }\n \n-    pub fn is_descendant_of(mut self, ancestor: Mark) -> bool {\n-        HygieneData::with(|data| {\n-            while self != ancestor {\n-                if self == Mark::root() {\n-                    return false;\n-                }\n-                self = data.marks[self.0 as usize].parent;\n-            }\n-            true\n-        })\n+    pub fn is_descendant_of(self, ancestor: Mark) -> bool {\n+        HygieneData::with(|data| data.is_descendant_of(self, ancestor))\n+    }\n+\n+    /// `mark.outer_is_descendant_of(ctxt)` is equivalent to but faster than\n+    /// `mark.is_descendant_of(ctxt.outer())`.\n+    pub fn outer_is_descendant_of(self, ctxt: SyntaxContext) -> bool {\n+        HygieneData::with(|data| data.is_descendant_of(self, data.outer(ctxt)))\n     }\n \n     /// Computes a mark such that both input marks are descendants of (or equal to) the returned\n@@ -201,6 +199,24 @@ impl HygieneData {\n     fn with<T, F: FnOnce(&mut HygieneData) -> T>(f: F) -> T {\n         GLOBALS.with(|globals| f(&mut *globals.hygiene_data.borrow_mut()))\n     }\n+\n+    fn outer(&self, ctxt: SyntaxContext) -> Mark {\n+        self.syntax_contexts[ctxt.0 as usize].outer_mark\n+    }\n+\n+    fn expn_info(&self, mark: Mark) -> Option<ExpnInfo> {\n+        self.marks[mark.0 as usize].expn_info.clone()\n+    }\n+\n+    fn is_descendant_of(&self, mut mark: Mark, ancestor: Mark) -> bool {\n+        while mark != ancestor {\n+            if mark == Mark::root() {\n+                return false;\n+            }\n+            mark = self.marks[mark.0 as usize].parent;\n+        }\n+        true\n+    }\n }\n \n pub fn clear_markings() {\n@@ -416,7 +432,7 @@ impl SyntaxContext {\n     /// or `None` if we privacy check as usual (i.e., not w.r.t. a macro definition scope).\n     pub fn adjust(&mut self, expansion: Mark) -> Option<Mark> {\n         let mut scope = None;\n-        while !expansion.is_descendant_of(self.outer()) {\n+        while !expansion.outer_is_descendant_of(*self) {\n             scope = Some(self.remove_mark());\n         }\n         scope\n@@ -450,7 +466,7 @@ impl SyntaxContext {\n     pub fn glob_adjust(&mut self, expansion: Mark, mut glob_ctxt: SyntaxContext)\n                        -> Option<Option<Mark>> {\n         let mut scope = None;\n-        while !expansion.is_descendant_of(glob_ctxt.outer()) {\n+        while !expansion.outer_is_descendant_of(glob_ctxt) {\n             scope = Some(glob_ctxt.remove_mark());\n             if self.remove_mark() != scope.unwrap() {\n                 return None;\n@@ -476,7 +492,7 @@ impl SyntaxContext {\n         }\n \n         let mut marks = Vec::new();\n-        while !expansion.is_descendant_of(glob_ctxt.outer()) {\n+        while !expansion.outer_is_descendant_of(glob_ctxt) {\n             marks.push(glob_ctxt.remove_mark());\n         }\n \n@@ -499,7 +515,14 @@ impl SyntaxContext {\n \n     #[inline]\n     pub fn outer(self) -> Mark {\n-        HygieneData::with(|data| data.syntax_contexts[self.0 as usize].outer_mark)\n+        HygieneData::with(|data| data.outer(self))\n+    }\n+\n+    /// `ctxt.outer_expn_info()` is equivalent to but faster than\n+    /// `ctxt.outer().expn_info()`.\n+    #[inline]\n+    pub fn outer_expn_info(self) -> Option<ExpnInfo> {\n+        HygieneData::with(|data| data.expn_info(data.outer(self)))\n     }\n \n     pub fn dollar_crate_name(self) -> Symbol {"}, {"sha": "30e075a3396133a2b79a4260addd5fa6f7189c2e", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfbaa6e8dfb509b453020740fd37c7a22882c87/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=0bfbaa6e8dfb509b453020740fd37c7a22882c87", "patch": "@@ -348,18 +348,18 @@ impl Span {\n     /// Returns the source span -- this is either the supplied span, or the span for\n     /// the macro callsite that expanded to it.\n     pub fn source_callsite(self) -> Span {\n-        self.ctxt().outer().expn_info().map(|info| info.call_site.source_callsite()).unwrap_or(self)\n+        self.ctxt().outer_expn_info().map(|info| info.call_site.source_callsite()).unwrap_or(self)\n     }\n \n     /// The `Span` for the tokens in the previous macro expansion from which `self` was generated,\n     /// if any.\n     pub fn parent(self) -> Option<Span> {\n-        self.ctxt().outer().expn_info().map(|i| i.call_site)\n+        self.ctxt().outer_expn_info().map(|i| i.call_site)\n     }\n \n     /// Edition of the crate from which this span came.\n     pub fn edition(self) -> edition::Edition {\n-        self.ctxt().outer().expn_info().map_or_else(|| {\n+        self.ctxt().outer_expn_info().map_or_else(|| {\n             Edition::from_session()\n         }, |einfo| einfo.edition)\n     }\n@@ -381,19 +381,19 @@ impl Span {\n     /// corresponding to the source callsite.\n     pub fn source_callee(self) -> Option<ExpnInfo> {\n         fn source_callee(info: ExpnInfo) -> ExpnInfo {\n-            match info.call_site.ctxt().outer().expn_info() {\n+            match info.call_site.ctxt().outer_expn_info() {\n                 Some(info) => source_callee(info),\n                 None => info,\n             }\n         }\n-        self.ctxt().outer().expn_info().map(source_callee)\n+        self.ctxt().outer_expn_info().map(source_callee)\n     }\n \n     /// Checks if a span is \"internal\" to a macro in which `#[unstable]`\n     /// items can be used (that is, a macro marked with\n     /// `#[allow_internal_unstable]`).\n     pub fn allows_unstable(&self, feature: Symbol) -> bool {\n-        match self.ctxt().outer().expn_info() {\n+        match self.ctxt().outer_expn_info() {\n             Some(info) => info\n                 .allow_internal_unstable\n                 .map_or(false, |features| features.iter().any(|&f|\n@@ -405,7 +405,7 @@ impl Span {\n \n     /// Checks if this span arises from a compiler desugaring of kind `kind`.\n     pub fn is_compiler_desugaring(&self, kind: CompilerDesugaringKind) -> bool {\n-        match self.ctxt().outer().expn_info() {\n+        match self.ctxt().outer_expn_info() {\n             Some(info) => match info.format {\n                 ExpnFormat::CompilerDesugaring(k) => k == kind,\n                 _ => false,\n@@ -417,7 +417,7 @@ impl Span {\n     /// Returns the compiler desugaring that created this span, or `None`\n     /// if this span is not from a desugaring.\n     pub fn compiler_desugaring_kind(&self) -> Option<CompilerDesugaringKind> {\n-        match self.ctxt().outer().expn_info() {\n+        match self.ctxt().outer_expn_info() {\n             Some(info) => match info.format {\n                 ExpnFormat::CompilerDesugaring(k) => Some(k),\n                 _ => None\n@@ -430,7 +430,7 @@ impl Span {\n     /// can be used without triggering the `unsafe_code` lint\n     //  (that is, a macro marked with `#[allow_internal_unsafe]`).\n     pub fn allows_unsafe(&self) -> bool {\n-        match self.ctxt().outer().expn_info() {\n+        match self.ctxt().outer_expn_info() {\n             Some(info) => info.allow_internal_unsafe,\n             None => false,\n         }\n@@ -439,7 +439,7 @@ impl Span {\n     pub fn macro_backtrace(mut self) -> Vec<MacroBacktrace> {\n         let mut prev_span = DUMMY_SP;\n         let mut result = vec![];\n-        while let Some(info) = self.ctxt().outer().expn_info() {\n+        while let Some(info) = self.ctxt().outer_expn_info() {\n             // Don't print recursive invocations.\n             if !info.call_site.source_equal(&prev_span) {\n                 let (pre, post) = match info.format {"}]}