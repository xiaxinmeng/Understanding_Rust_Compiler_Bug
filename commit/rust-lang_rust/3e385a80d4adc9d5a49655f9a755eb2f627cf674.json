{"sha": "3e385a80d4adc9d5a49655f9a755eb2f627cf674", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlMzg1YTgwZDRhZGM5ZDVhNDk2NTVmOWE3NTVlYjJmNjI3Y2Y2NzQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-24T16:20:20Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-24T16:22:09Z"}, "message": "prune unused unification code; leave region code that still needs to be ported", "tree": {"sha": "02f63efbb4ed37f3b1f28d3b8db900fdfb213352", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02f63efbb4ed37f3b1f28d3b8db900fdfb213352"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e385a80d4adc9d5a49655f9a755eb2f627cf674", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e385a80d4adc9d5a49655f9a755eb2f627cf674", "html_url": "https://github.com/rust-lang/rust/commit/3e385a80d4adc9d5a49655f9a755eb2f627cf674", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e385a80d4adc9d5a49655f9a755eb2f627cf674/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aae14e352af95ad70d862e0e952d3817fc6c9c27", "url": "https://api.github.com/repos/rust-lang/rust/commits/aae14e352af95ad70d862e0e952d3817fc6c9c27", "html_url": "https://github.com/rust-lang/rust/commit/aae14e352af95ad70d862e0e952d3817fc6c9c27"}], "stats": {"total": 692, "additions": 50, "deletions": 642}, "files": [{"sha": "d084971976094a7dbaa0ab75126ed6754cadd3a9", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 16, "deletions": 628, "changes": 644, "blob_url": "https://github.com/rust-lang/rust/blob/3e385a80d4adc9d5a49655f9a755eb2f627cf674/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e385a80d4adc9d5a49655f9a755eb2f627cf674/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=3e385a80d4adc9d5a49655f9a755eb2f627cf674", "patch": "@@ -93,7 +93,6 @@ export ty_var, mk_var;\n export ty_self, mk_self;\n export region, re_block, re_param, re_var;\n export get, type_has_params, type_has_vars, type_has_rptrs, type_id;\n-export same_type;\n export ty_var_id;\n export ty_to_def_id;\n export ty_fn_args;\n@@ -1587,96 +1586,36 @@ fn set_default_mode(cx: ctxt, m: ast::mode, m_def: ast::rmode) {\n mod unify {\n     import result::{result, ok, err, chain, map, map2};\n \n-    export fixup_vars;\n-    export mk_var_bindings, mk_region_bindings;\n-    export resolve_type_structure;\n-    export resolve_type_var;\n-    export unify;\n-    export var_bindings, region_bindings;\n-    export precise, in_bindings, in_region_bindings;\n+    export mk_region_bindings;\n+    export region_bindings;\n+    export precise, in_region_bindings;\n \n     type ures<T> = result<T,type_err>;\n \n-    // in case of failure, value is the idx of an unresolved type var\n-    type fres<T> = result<T,int>;\n-\n-    type var_bindings =\n-        {sets: ufind::ufind, types: smallintmap::smallintmap<t>};\n     type region_bindings =\n         {sets: ufind::ufind, regions: smallintmap::smallintmap<region>};\n \n     enum unify_style {\n         precise,\n-        in_bindings(@var_bindings),\n-        in_region_bindings(@var_bindings, @region_bindings)\n+        in_region_bindings(@region_bindings)\n     }\n     type uctxt = {st: unify_style, tcx: ctxt};\n \n-    fn mk_var_bindings() -> @var_bindings {\n-        ret @{sets: ufind::make(), types: smallintmap::mk::<t>()};\n-    }\n-\n     fn mk_region_bindings() -> @region_bindings {\n         ret @{sets: ufind::make(), regions: smallintmap::mk::<region>()};\n     }\n \n-    // Unifies two sets.\n-    fn union<T:copy>(\n-        cx: @uctxt, set_a: uint, set_b: uint,\n-        variance: variance, nxt: fn() -> ures<T>) -> ures<T> {\n-\n-        let vb = alt cx.st {\n-            in_region_bindings(vb, _) { vb }\n-            in_bindings(vb) { vb }\n-            precise {\n-                cx.tcx.sess.bug(\"someone forgot to document an invariant \\\n-                                 in union\");\n-            }\n-        };\n-        ufind::grow(vb.sets, uint::max(set_a, set_b) + 1u);\n-        let root_a = ufind::find(vb.sets, set_a);\n-        let root_b = ufind::find(vb.sets, set_b);\n-\n-        let replace_type = (\n-            fn@(vb: @var_bindings, t: t) {\n-                ufind::union(vb.sets, set_a, set_b);\n-                let root_c: uint = ufind::find(vb.sets, set_a);\n-                smallintmap::insert::<t>(vb.types, root_c, t);\n-            }\n-        );\n-\n-        alt smallintmap::find(vb.types, root_a) {\n-          none {\n-            alt smallintmap::find(vb.types, root_b) {\n-              none { ufind::union(vb.sets, set_a, set_b); ret nxt(); }\n-              some(t_b) { replace_type(vb, t_b); ret nxt(); }\n-            }\n-          }\n-          some(t_a) {\n-            alt smallintmap::find(vb.types, root_b) {\n-              none { replace_type(vb, t_a); ret nxt(); }\n-              some(t_b) {\n-                ret unify_step(cx, t_a, t_b, variance) {|t_c|\n-                    replace_type(vb, t_c);\n-                    nxt()\n-                };\n-              }\n-            }\n-          }\n-        }\n-    }\n-\n     // Unifies two region sets.\n     //\n     // FIXME: This is a straight copy of the code above. We should use\n     //        polymorphism to make this better.\n     fn union_region_sets<T:copy>(\n         cx: @uctxt, set_a: uint, set_b: uint,\n-        variance: variance, nxt: fn() -> ures<T>) -> ures<T> {\n+        nxt: fn() -> ures<T>) -> ures<T> {\n \n         let rb = alt cx.st {\n-            in_region_bindings(_, rb) { rb }\n-            in_bindings(_) | precise {\n+            in_region_bindings(rb) { rb }\n+            precise {\n                 cx.tcx.sess.bug(\"attempted to unify two region sets without \\\n                                  a set of region bindings present\");\n             }\n@@ -1704,7 +1643,7 @@ mod unify {\n             alt smallintmap::find(rb.regions, root_b) {\n               none { replace_region(rb, r_a); ret nxt(); }\n               some(r_b) {\n-                ret unify_regions(cx, r_a, r_b, variance) {|r_c|\n+                ret unify_regions(cx, r_a, r_b) {|r_c|\n                     replace_region(rb, r_c);\n                     nxt()\n                 };\n@@ -1714,48 +1653,22 @@ mod unify {\n         }\n     }\n \n-    fn record_var_binding<T:copy>(\n-        cx: @uctxt, key: int,\n-        typ: t, variance: variance,\n-        nxt: fn(t) -> ures<T>) -> ures<T> {\n-\n-        let vb = alt cx.st {\n-            in_bindings(vb) | in_region_bindings(vb, _) { vb }\n-            precise { fail; }\n-        };\n-\n-        ufind::grow(vb.sets, (key as uint) + 1u);\n-        let root = ufind::find(vb.sets, key as uint);\n-        let mut result_type = typ;\n-        alt smallintmap::find(vb.types, root) {\n-          some(old_type) {\n-            alt unify_step(cx, old_type, typ, variance, {|v| ok(v)}) {\n-              ok(unified_type) { result_type = unified_type; }\n-              err(e) { ret err(e); }\n-            }\n-          }\n-          none {/* fall through */ }\n-        }\n-        smallintmap::insert(vb.types, root, result_type);\n-        ret nxt(mk_var(cx.tcx, key));\n-    }\n-\n     fn record_region_binding<T:copy>(\n         cx: @uctxt, key: uint,\n-        r: region, variance: variance,\n+        r: region,\n         nxt: fn(region) -> ures<T>) -> ures<T> {\n \n         let rb = alt cx.st {\n-            in_region_bindings(_, rb) { rb }\n-            in_bindings(_) | precise { fail; }\n+            in_region_bindings(rb) { rb }\n+            precise { fail; }\n         };\n \n         ufind::grow(rb.sets, key + 1u);\n         let root = ufind::find(rb.sets, key);\n         let mut result_region = r;\n         alt smallintmap::find(rb.regions, root) {\n           some(old_region) {\n-            alt unify_regions(cx, old_region, r, variance, {|v| ok(v)}) {\n+            alt unify_regions(cx, old_region, r, {|v| ok(v)}) {\n               ok(unified_region) { result_region = unified_region; }\n               err(e) { ret err(e); }\n             }\n@@ -1768,327 +1681,27 @@ mod unify {\n         ret nxt(re_param(key));\n     }\n \n-    // Simple structural type comparison.\n-    fn struct_cmp<T:copy>(\n-        cx: @uctxt, expected: t, actual: t,\n-        nxt: fn(t) -> ures<T>) -> ures<T> {\n-\n-        let tcx = cx.tcx;\n-        let cfg = tcx.sess.targ_cfg;\n-        if mach_sty(cfg, expected) == mach_sty(cfg, actual) {\n-            ret nxt(expected);\n-        }\n-        ret err(terr_mismatch);\n-    }\n-\n-    // Right now this just checks that the lists of constraints are\n-    // pairwise equal.\n-    fn unify_constrs<T:copy>(\n-        expected: [@type_constr],\n-        actual: [@type_constr],\n-        nxt: fn([@type_constr]) -> ures<T>) -> ures<T> {\n-\n-        if check vec::same_length(expected, actual) {\n-            map2(expected, actual,\n-                 {|e,a| unify_constr(e, a, {|v| ok(v)})}, nxt)\n-        } else {\n-            ret err(terr_constr_len(expected.len(), actual.len()));\n-        }\n-    }\n-\n-    fn unify_constr<T:copy>(\n-        expected: @type_constr,\n-        actual_constr: @type_constr,\n-        nxt: fn(@type_constr) -> ures<T>) -> ures<T> {\n-\n-        let err_res = err(terr_constr_mismatch(expected, actual_constr));\n-        if expected.node.id != actual_constr.node.id { ret err_res; }\n-        let expected_arg_len = vec::len(expected.node.args);\n-        let actual_arg_len = vec::len(actual_constr.node.args);\n-        if expected_arg_len != actual_arg_len { ret err_res; }\n-        let mut i = 0u;\n-        for a: @ty_constr_arg in expected.node.args {\n-            let actual = actual_constr.node.args[i];\n-            alt a.node {\n-              carg_base {\n-                alt actual.node { carg_base { } _ { ret err_res; } }\n-              }\n-              carg_lit(l) {\n-                alt actual.node {\n-                  carg_lit(m) { if l != m { ret err_res; } }\n-                  _ { ret err_res; }\n-                }\n-              }\n-              carg_ident(p) {\n-                alt actual.node {\n-                  carg_ident(q) { if p.node != q.node { ret err_res; } }\n-                  _ { ret err_res; }\n-                }\n-              }\n-            }\n-            i += 1u;\n-        }\n-        ret nxt(expected);\n-    }\n-\n-    // Unifies two mutability flags.\n-    fn unify_mut<T:copy>(\n-        expected: ast::mutability, actual: ast::mutability,\n-        variance: variance, mut_err: type_err,\n-        nxt: fn(ast::mutability, variance) -> ures<T>) -> ures<T> {\n-\n-        // If you're unifying on something mutable then we have to\n-        // be invariant on the inner type\n-        let newvariance = alt expected {\n-          ast::m_mutbl {\n-            variance_transform(variance, invariant)\n-          }\n-          _ {\n-            variance_transform(variance, covariant)\n-          }\n-        };\n-\n-        if expected == actual {\n-            ret nxt(expected, newvariance);\n-        }\n-        if variance == covariant {\n-            if expected == ast::m_const {\n-                ret nxt(actual, newvariance);\n-            }\n-        } else if variance == contravariant {\n-            if actual == ast::m_const {\n-                ret nxt(expected, newvariance);\n-            }\n-        }\n-        ret err(mut_err);\n-    }\n-\n-    fn unify_fn_proto<T:copy>(\n-        e_proto: ast::proto, a_proto: ast::proto, variance: variance,\n-        nxt: fn(ast::proto) -> ures<T>) -> ures<T> {\n-\n-        // Prototypes form a diamond-shaped partial order:\n-        //\n-        //        block\n-        //        ^   ^\n-        //   shared   send\n-        //        ^   ^\n-        //        bare\n-        //\n-        // where \"^\" means \"subtype of\" (forgive the abuse of the term\n-        // subtype).\n-        fn sub_proto(p_sub: ast::proto, p_sup: ast::proto) -> bool {\n-            ret alt (p_sub, p_sup) {\n-              (_, ast::proto_any) { true }\n-              (ast::proto_bare, _) { true }\n-\n-              // Equal prototypes are always subprotos:\n-              (_, _) { p_sub == p_sup }\n-            };\n-        }\n-\n-        ret alt variance {\n-          invariant if e_proto == a_proto { nxt(e_proto) }\n-          covariant if sub_proto(a_proto, e_proto) { nxt(e_proto) }\n-          contravariant if sub_proto(e_proto, a_proto) { nxt(e_proto) }\n-          _ { ret err(terr_mismatch) }\n-        };\n-    }\n-\n-    fn unify_arg<T:copy>(\n-        cx: @uctxt, e_arg: arg, a_arg: arg,\n-        variance: variance,\n-        nxt: fn(arg) -> ures<T>) -> ures<T> {\n-\n-        // Unify the result modes.\n-        chain(unify_mode(cx.tcx, e_arg.mode, a_arg.mode)) {|mode|\n-            unify_step(cx, e_arg.ty, a_arg.ty, variance) {|ty|\n-                nxt({mode: mode, ty: ty})\n-            }\n-        }\n-    }\n-\n-    fn unify_args<T:copy>(\n-        cx: @uctxt, e_args: [arg], a_args: [arg],\n-        variance: variance, nxt: fn([arg]) -> ures<T>) -> ures<T> {\n-\n-        if check vec::same_length(e_args, a_args) {\n-            // The variance changes (flips basically) when descending\n-            // into arguments of function types\n-            let variance = variance_transform(variance, contravariant);\n-            map2(e_args, a_args,\n-                 {|e,a| unify_arg(cx, e, a, variance, {|v| ok(v)})},\n-                 nxt)\n-        } else {\n-            ret err(terr_arg_count);\n-        }\n-    }\n-\n-    fn unify_ret_style<T:copy>(\n-        e_ret_style: ret_style,\n-        a_ret_style: ret_style,\n-        nxt: fn(ret_style) -> ures<T>) -> ures<T> {\n-\n-        if a_ret_style != ast::noreturn && a_ret_style != e_ret_style {\n-            /* even though typestate checking is mostly\n-               responsible for checking control flow annotations,\n-               this check is necessary to ensure that the\n-               annotation in an object method matches the\n-               declared object type */\n-            ret err(terr_ret_style_mismatch(e_ret_style, a_ret_style));\n-        } else {\n-            nxt(a_ret_style)\n-        }\n-    }\n-\n-    fn unify_fn<T:copy>(\n-        cx: @uctxt, e_f: fn_ty, a_f: fn_ty, variance: variance,\n-        nxt: fn(t) -> ures<T>) -> ures<T> {\n-\n-        unify_fn_proto(e_f.proto, a_f.proto, variance) {|proto|\n-            unify_ret_style(e_f.ret_style, a_f.ret_style) {|rs|\n-                unify_args(cx, e_f.inputs, a_f.inputs, variance) {|args|\n-                    unify_step(cx, e_f.output, a_f.output, variance) {|rty|\n-                        let cs = e_f.constraints; // FIXME: Unify?\n-                        nxt(mk_fn(cx.tcx, {proto: proto,\n-                                           inputs: args,\n-                                           output: rty,\n-                                           ret_style: rs,\n-                                           constraints: cs}))\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    // If the given type is a variable, returns the structure of that type.\n-    fn resolve_type_structure(vb: @var_bindings, typ: t) -> fres<t> {\n-        alt get(typ).struct {\n-          ty_var(vid) {\n-            if vid as uint >= ufind::set_count(vb.sets) { ret err(vid); }\n-            let root_id = ufind::find(vb.sets, vid as uint);\n-            alt smallintmap::find::<t>(vb.types, root_id) {\n-              none { ret err(vid); }\n-              some(rt) { ret ok(rt); }\n-            }\n-          }\n-          _ { ret ok(typ); }\n-        }\n-    }\n-\n-    // Specifies the allowable subtyping between expected and actual types\n-    enum variance {\n-        // Actual may be a subtype of expected\n-        covariant,\n-        // Actual may be a supertype of expected\n-        contravariant,\n-        // Actual must be the same type as expected\n-        invariant,\n-    }\n-\n-    // The calculation for recursive variance\n-    // \"Taming the Wildcards: Combining Definition- and Use-Site Variance\"\n-    // by John Altidor, et. al.\n-    //\n-    // I'm just copying the table from figure 1 - haven't actually\n-    // read the paper (yet).\n-    fn variance_transform(a: variance, b: variance) -> variance {\n-        alt a {\n-          covariant {\n-            alt b {\n-              covariant { covariant }\n-              contravariant { contravariant }\n-              invariant { invariant }\n-            }\n-          }\n-          contravariant {\n-            alt b {\n-              covariant { contravariant }\n-              contravariant { covariant }\n-              invariant { invariant }\n-            }\n-          }\n-          invariant {\n-            alt b {\n-              covariant { invariant }\n-              contravariant { invariant }\n-              invariant { invariant }\n-            }\n-          }\n-        }\n-    }\n-\n-    fn unify_tys<T:copy>(\n-        cx: @uctxt, expected_tps: [t], actual_tps: [t],\n-        variance: variance, nxt: fn([t]) -> ures<T>)\n-        : vec::same_length(expected_tps, actual_tps)\n-        -> ures<T> {\n-\n-        map2(expected_tps, actual_tps,\n-             {|e,a| unify_step(cx, e, a, variance, {|v| ok(v)})},\n-             nxt)\n-    }\n-\n-    fn unify_tps<T:copy>(\n-        cx: @uctxt, expected_tps: [t], actual_tps: [t],\n-        variance: variance, nxt: fn([t]) -> ures<T>)\n-        -> ures<T> {\n-\n-        if check vec::same_length(expected_tps, actual_tps) {\n-            map2(expected_tps, actual_tps,\n-                 {|e,a| unify_step(cx, e, a, variance, {|v| ok(v)})},\n-                 nxt)\n-        } else {\n-            err(terr_ty_param_size(expected_tps.len(),\n-                                   actual_tps.len()))\n-        }\n-    }\n-\n-    fn unify_mt<T:copy>(\n-        cx: @uctxt, e_mt: mt, a_mt: mt, variance: variance,\n-        mut_err: type_err,\n-        nxt: fn(mt) -> ures<T>) -> ures<T> {\n-        unify_mut(e_mt.mutbl, a_mt.mutbl, variance, mut_err) {|mutbl,var|\n-            unify_step(cx, e_mt.ty, a_mt.ty, var) {|ty|\n-                nxt({ty: ty, mutbl: mutbl})\n-            }\n-        }\n-    }\n-\n     fn unify_regions<T:copy>(\n         cx: @uctxt, e_region: region, a_region: region,\n-        variance: variance,\n         nxt: fn(region) -> ures<T>) -> ures<T> {\n-        let mut sub, super;\n-        alt variance {\n-            covariant | invariant { super = e_region; sub = a_region; }\n-            contravariant { super = a_region; sub = e_region; }\n-        }\n+        let sub = a_region, super = e_region;\n \n         // FIXME: Should have a way of unifying regions that relies on bounds,\n         // not on unification.\n         alt (super, sub) {\n             (ty::re_var(superkey), ty::re_var(subkey)) {\n-                ret union_region_sets(cx, subkey, superkey, variance,\n+                ret union_region_sets(cx, subkey, superkey,\n                                       {|| nxt(sub) });\n             }\n             (ty::re_var(superkey), _) {\n-                ret record_region_binding(cx, superkey, sub, variance, nxt);\n+                ret record_region_binding(cx, superkey, sub, nxt);\n             }\n             (_, ty::re_var(subkey)) {\n-                ret record_region_binding(cx, subkey, super, variance, nxt);\n+                ret record_region_binding(cx, subkey, super, nxt);\n             }\n             _ { /* fall through */ }\n         }\n \n-        if variance == invariant {\n-          ret if e_region == a_region {\n-              nxt(e_region)\n-          } else {\n-              err(terr_regions_differ(true, e_region, a_region))\n-          };\n-        }\n-\n         alt (super, sub) {\n             (ty::re_var(_), _) | (_, ty::re_var(_)) {\n                 fail \"should have been handled above\";\n@@ -2123,231 +1736,6 @@ mod unify {\n             }\n         }\n     }\n-\n-    fn unify_field<T:copy>(\n-        cx: @uctxt, e_field: field, a_field: field,\n-        variance: variance,\n-        nxt: fn(field) -> ures<T>) -> ures<T> {\n-\n-        if e_field.ident != a_field.ident {\n-            ret err(terr_record_fields(e_field.ident,\n-                                       a_field.ident));\n-        }\n-\n-        unify_mt(cx, e_field.mt, a_field.mt, variance,\n-                 terr_record_mutability) {|mt|\n-            nxt({ident: e_field.ident, mt: mt})\n-        }\n-    }\n-\n-    fn unify_step<T:copy>(\n-        cx: @uctxt, expected: t, actual: t,\n-        variance: variance, nxt: fn(t) -> ures<T>) -> ures<T> {\n-\n-        #debug(\"unify_step: %s %s\", ty_to_str(cx.tcx, expected),\n-               ty_to_str(cx.tcx, actual));\n-\n-        // Fast path.\n-        if expected == actual { ret nxt(expected); }\n-\n-        // FIXME: This is terribly wrong. We should be unifying type sets\n-        // using some sort of bound.\n-\n-        alt (get(expected).struct, get(actual).struct) {\n-          (ty_var(e_id), ty_var(a_id)) {\n-            union(cx, e_id as uint, a_id as uint, variance) {||\n-                nxt(actual)\n-            }\n-          }\n-          (_, ty_var(a_id)) {\n-            let v = variance_transform(variance, contravariant);\n-            record_var_binding(cx, a_id, expected, v, nxt)\n-          }\n-          (ty_var(e_id), _) {\n-            let v = variance_transform(variance, covariant);\n-            record_var_binding(cx, e_id, actual, v, nxt)\n-          }\n-          (_, ty_bot) { nxt(expected) }\n-          (ty_bot, _) { nxt(actual) }\n-          (ty_nil, _) | (ty_bool, _) | (ty_int(_), _) | (ty_uint(_), _) |\n-          (ty_float(_), _) | (ty_str, _) {\n-            struct_cmp(cx, expected, actual, nxt)\n-          }\n-          (ty_param(e_n, _), ty_param(a_n, _)) if e_n == a_n {\n-            nxt(expected)\n-          }\n-          (ty_enum(e_id, e_tps), ty_enum(a_id, a_tps)) if e_id == a_id {\n-            unify_tps(cx, e_tps, a_tps, variance) {|tps|\n-                nxt(mk_enum(cx.tcx, e_id, tps))\n-            }\n-          }\n-          (ty_iface(e_id, e_tps), ty_iface(a_id, a_tps)) if e_id == a_id {\n-            unify_tps(cx, e_tps, a_tps, variance) {|tps|\n-                nxt(mk_iface(cx.tcx, e_id, tps))\n-            }\n-          }\n-          (ty_class(e_id, e_tps), ty_class(a_id, a_tps)) if e_id == a_id {\n-            unify_tps(cx, e_tps, a_tps, variance) {|tps|\n-                nxt(mk_class(cx.tcx, e_id, tps))\n-            }\n-          }\n-          (ty_box(e_mt), ty_box(a_mt)) {\n-            unify_mt(cx, e_mt, a_mt, variance, terr_box_mutability,\n-                     {|mt| nxt(mk_box(cx.tcx, mt))})\n-          }\n-          (ty_uniq(e_mt), ty_uniq(a_mt)) {\n-            unify_mt(cx, e_mt, a_mt, variance, terr_box_mutability,\n-                     {|mt| nxt(mk_uniq(cx.tcx, mt))})\n-          }\n-          (ty_vec(e_mt), ty_vec(a_mt)) {\n-            unify_mt(cx, e_mt, a_mt, variance, terr_vec_mutability,\n-                     {|mt| nxt(mk_vec(cx.tcx, mt))})\n-          }\n-          (ty_ptr(e_mt), ty_ptr(a_mt)) {\n-            unify_mt(cx, e_mt, a_mt, variance, terr_ptr_mutability,\n-                     {|mt| nxt(mk_ptr(cx.tcx, mt))})\n-          }\n-          (ty_rptr(e_region, e_mt), ty_rptr(a_region, a_mt)) {\n-            unify_regions(cx, e_region, a_region, variance) {|r|\n-                unify_mt(cx, e_mt, a_mt, variance, terr_ref_mutability,\n-                         {|mt| nxt(mk_rptr(cx.tcx, r, mt))})\n-            }\n-          }\n-          (ty_res(e_id, e_inner, e_tps), ty_res(a_id, a_inner, a_tps))\n-          if e_id == a_id {\n-              unify_step(cx, e_inner, a_inner, variance) {|t|\n-                  unify_tps(cx, e_tps, a_tps, variance) {|tps|\n-                      nxt(mk_res(cx.tcx, a_id, t, tps))\n-                  }\n-              }\n-          }\n-          (ty_rec(e_fields), ty_rec(a_fields)) {\n-              if check vec::same_length(e_fields, a_fields) {\n-                  map2(e_fields, a_fields,\n-                       {|e,a| unify_field(cx, e, a, variance, {|v| ok(v)})},\n-                       {|fields| nxt(mk_rec(cx.tcx, fields))})\n-              } else {\n-                  ret err(terr_record_size(e_fields.len(),\n-                                           a_fields.len()));\n-              }\n-          }\n-          (ty_tup(e_elems), ty_tup(a_elems)) {\n-            if check vec::same_length(e_elems, a_elems) {\n-                unify_tys(cx, e_elems, a_elems, variance) {|elems|\n-                    nxt(mk_tup(cx.tcx, elems))\n-                }\n-            } else {\n-                err(terr_tuple_size(e_elems.len(), a_elems.len()))\n-            }\n-          }\n-          (ty_fn(e_fty), ty_fn(a_fty)) {\n-            unify_fn(cx, e_fty, a_fty, variance, nxt)\n-          }\n-          (ty_constr(e_t, e_constrs), ty_constr(a_t, a_constrs)) {\n-            // unify the base types...\n-            unify_step(cx, e_t, a_t, variance) {|rty|\n-                // FIXME: probably too restrictive --\n-                // requires the constraints to be syntactically equal\n-                unify_constrs(e_constrs, a_constrs) {|constrs|\n-                    nxt(mk_constr(cx.tcx, rty, constrs))\n-                }\n-            }\n-          }\n-          (ty_constr(e_t, _), _) {\n-            // If the actual type is *not* a constrained type,\n-            // then we go ahead and just ignore the constraints on\n-            // the expected type. typestate handles the rest.\n-            unify_step(cx, e_t, actual, variance, nxt)\n-          }\n-          _ { err(terr_mismatch) }\n-        }\n-    }\n-    fn unify(expected: t, actual: t, st: unify_style,\n-             tcx: ctxt) -> ures<t> {\n-        let cx = @{st: st, tcx: tcx};\n-        ret unify_step(cx, expected, actual, covariant, {|v| ok(v)});\n-    }\n-    fn dump_var_bindings(tcx: ctxt, vb: @var_bindings) {\n-        let mut i = 0u;\n-        while i < vec::len::<ufind::node>(vb.sets.nodes) {\n-            let mut sets = \"\";\n-            let mut j = 0u;\n-            while j < vec::len::<option<uint>>(vb.sets.nodes) {\n-                if ufind::find(vb.sets, j) == i { sets += #fmt[\" %u\", j]; }\n-                j += 1u;\n-            }\n-            let typespec = alt smallintmap::find::<t>(vb.types, i) {\n-              none { \"\" }\n-              some(typ) { \" =\" + ty_to_str(tcx, typ) }\n-            };\n-            #error(\"set %u:%s%s\", i, typespec, sets);\n-            i += 1u;\n-        }\n-    }\n-\n-    // Fixups and substitutions\n-    //    Takes an optional span - complain about occurs check violations\n-    //    iff the span is present (so that if we already know we're going\n-    //    to error anyway, we don't complain)\n-    fn fixup_vars(tcx: ctxt, sp: option<span>, vb: @var_bindings,\n-                  typ: t) -> fres<t> {\n-        fn subst_vars(tcx: ctxt, sp: option<span>, vb: @var_bindings,\n-                      unresolved: @mutable option<int>,\n-                      vars_seen: std::list::list<int>, vid: int) -> t {\n-            // Should really return a fixup_result instead of a t, but fold_ty\n-            // doesn't allow returning anything but a t.\n-            if vid as uint >= ufind::set_count(vb.sets) {\n-                *unresolved = some(vid);\n-                ret mk_var(tcx, vid);\n-            }\n-            let root_id = ufind::find(vb.sets, vid as uint);\n-            alt smallintmap::find::<t>(vb.types, root_id) {\n-              none { *unresolved = some(vid); ret mk_var(tcx, vid); }\n-              some(rt) {\n-                let mut give_up = false;\n-                std::list::iter(vars_seen) {|v|\n-                    if v == vid {\n-                        give_up = true;\n-                        option::may(sp) {|sp|\n-                            tcx.sess.span_fatal(\n-                                sp, \"can not instantiate infinite type\");\n-                        }\n-                    }\n-                }\n-                // Return the type unchanged, so we can error out\n-                // downstream\n-                if give_up { ret rt; }\n-                ret fold_ty(tcx, fm_var(bind subst_vars(\n-                    tcx, sp, vb, unresolved, std::list::cons(vid, @vars_seen),\n-                    _)), rt);\n-              }\n-            }\n-        }\n-        let unresolved = @mutable none::<int>;\n-        let rty = fold_ty(tcx, fm_var(bind subst_vars(\n-            tcx, sp, vb, unresolved, std::list::nil, _)), typ);\n-        let ur = *unresolved;\n-        alt ur {\n-          none { ret ok(rty); }\n-          some(var_id) { ret err(var_id); }\n-        }\n-    }\n-    fn resolve_type_var(tcx: ctxt, sp: option<span>, vb: @var_bindings,\n-                        vid: int) -> fres<t> {\n-        if vid as uint >= ufind::set_count(vb.sets) { ret err(vid); }\n-        let root_id = ufind::find(vb.sets, vid as uint);\n-        alt smallintmap::find::<t>(vb.types, root_id) {\n-          none { ret err(vid); }\n-          some(rt) { ret fixup_vars(tcx, sp, vb, rt); }\n-        }\n-    }\n-}\n-\n-fn same_type(cx: ctxt, a: t, b: t) -> bool {\n-    alt unify::unify(a, b, unify::precise, cx) {\n-      result::ok(_) { true }\n-      result::err(_) { false }\n-    }\n }\n \n fn type_err_to_str(cx: ctxt, err: type_err) -> str {"}, {"sha": "5c512690c17bac73020499b7b2e59422ead4a304", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3e385a80d4adc9d5a49655f9a755eb2f627cf674/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e385a80d4adc9d5a49655f9a755eb2f627cf674/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=3e385a80d4adc9d5a49655f9a755eb2f627cf674", "patch": "@@ -798,14 +798,10 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n             if_fty = fixup_self_in_method_ty(tcx, if_fty, substs,\n                                              self_full(self_ty, impl_tps));\n         }\n-        alt infer::compare_tys(tcx, impl_fty, if_fty) {\n-          result::err(err) {\n-            tcx.sess.span_err(sp, \"method `\" + if_m.ident +\n-                              \"` has an incompatible type: \" +\n-                              ty::type_err_to_str(tcx, err));\n-          }\n-          result::ok(()) { }\n-        }\n+        require_same_types(\n+            tcx, sp, impl_fty, if_fty,\n+            {|| \"method `\" + if_m.ident +\n+                 \"` has an incompatible type\"});\n         ret impl_fty;\n     }\n }\n@@ -1188,6 +1184,24 @@ fn resolve_type_vars_if_possible(fcx: @fn_ctxt, typ: ty::t) -> ty::t {\n // message if they don't.\n type ty_param_substs_and_ty = {substs: [ty::t], ty: ty::t};\n \n+fn require_same_types(\n+    tcx: ty::ctxt,\n+    span: span,\n+    t1: ty::t,\n+    t2: ty::t,\n+    msg: fn() -> str) -> bool {\n+\n+    alt infer::compare_tys(tcx, t1, t2) {\n+      result::ok(()) { true }\n+      result::err(terr) {\n+        tcx.sess.span_err(\n+            span, msg() + \": \" +\n+            ty::type_err_to_str(tcx, terr));\n+        false\n+      }\n+    }\n+}\n+\n mod demand {\n     fn simple(fcx: @fn_ctxt, sp: span, expected: ty::t, actual: ty::t) ->\n        ty::t {\n@@ -1503,9 +1517,12 @@ fn check_intrinsic_type(tcx: ty::ctxt, it: @ast::native_item) {\n         tcx.sess.span_err(it.span, #fmt(\"intrinsic has wrong number \\\n                                          of type parameters. found %u, \\\n                                          expected %u\", i_n_tps, n_tps));\n-    } else if !ty::same_type(tcx, i_ty.ty, fty) {\n-        tcx.sess.span_err(it.span, #fmt(\"intrinsic has wrong type. \\\n-                                         expected %s\", ty_to_str(tcx, fty)));\n+    } else {\n+        require_same_types(\n+            tcx, it.span, i_ty.ty, fty,\n+            {|| #fmt[\"intrinsic has wrong type. \\\n+                      expected %s\",\n+                     ty_to_str(tcx, fty)]});\n     }\n }\n \n@@ -1765,9 +1782,12 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         check_expr_with(pcx.fcx, end, expected);\n         let b_ty = resolve_type_vars_if_possible(pcx.fcx,\n                                                  expr_ty(tcx, begin));\n-        if !ty::same_type(tcx, b_ty, resolve_type_vars_if_possible(\n-            pcx.fcx, expr_ty(tcx, end))) {\n-            tcx.sess.span_err(pat.span, \"mismatched types in range\");\n+        if !require_same_types(\n+            tcx, pat.span, b_ty,\n+            resolve_type_vars_if_possible(\n+                pcx.fcx, expr_ty(tcx, end)),\n+            {|| \"mismatched types in range\" }) {\n+            // no-op\n         } else if !ty::type_is_numeric(b_ty) {\n             tcx.sess.span_err(pat.span, \"non-numeric type used in range\");\n         } else if !valid_range_bounds(tcx, begin, end) {"}]}