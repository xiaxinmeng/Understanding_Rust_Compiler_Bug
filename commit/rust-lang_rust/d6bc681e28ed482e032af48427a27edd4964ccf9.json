{"sha": "d6bc681e28ed482e032af48427a27edd4964ccf9", "node_id": "C_kwDOAAsO6NoAKGQ2YmM2ODFlMjhlZDQ4MmUwMzJhZjQ4NDI3YTI3ZWRkNDk2NGNjZjk", "commit": {"author": {"name": "Jan Gaura", "email": "jan.gaura@gmail.com", "date": "2023-02-06T17:05:10Z"}, "committer": {"name": "Jakub Ber\u00e1nek", "email": "berykubik@gmail.com", "date": "2023-02-13T16:56:08Z"}, "message": "Store metrics from metrics.json into PGO CI timer\n\nCo-authored-by: Jakub Ber\u00e1nek <berykubik@gmail.com>", "tree": {"sha": "a2cc366c76853f070abb955bdaf15880efd38b08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2cc366c76853f070abb955bdaf15880efd38b08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6bc681e28ed482e032af48427a27edd4964ccf9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEzFQynJm4WzBnfhz8kJzQ0mSDUWsFAmPqa6kACgkQkJzQ0mSD\nUWu9Mwv8DufN2dQaTuNIcya6vWU2TuHMLyGg8VKC++zhk9CmMPJl3kVY0jwBLB8H\nOhxQDXdQkMDVPW6groWXAeUQcC0JP0CemXWazd2vI8DEMVAUFLXCFr5nOiTaEUDM\n9MYPA2lL6e9VDNdqDFdvzVjw2J0dA+IvGOTy4flqiqmPKsKslN7kPhYGWJLFuZq8\nfSxImiyZLRDX6xtwyhtxkkr5pbfPC1WpHnFXNTaQHjjDCZ46nJDAca7BRMnPJ1/b\n7/U2fz3qlmNTyDKsiZsxt+G/5Z0t6fmJD4qBOvDxURE6F6ui+H6AXKJa2ln70d/Q\n4UlugrArllHB5FDGbwKrDjtwxNvh4rvK30vTWejqUAC2YrWvgeOp552Ioi22XyTE\nTWQkVb/on7rnKmvVbgyMRiKASUksT4iW9j96peDoTFZCHiAH3fIz6UejFwCpunuB\nEztHVtqDctINsi+x1HyRasKMN6PHdnUdLKvBICeMMuw0BR+unpvAjBf7i7YjLb1I\nOH7BlRhX\n=oYlT\n-----END PGP SIGNATURE-----", "payload": "tree a2cc366c76853f070abb955bdaf15880efd38b08\nparent 0b439b119b8d49450bddbbea317afeb0d4166f70\nauthor Jan Gaura <jan.gaura@gmail.com> 1675703110 +0100\ncommitter Jakub Ber\u00e1nek <berykubik@gmail.com> 1676307368 +0100\n\nStore metrics from metrics.json into PGO CI timer\n\nCo-authored-by: Jakub Ber\u00e1nek <berykubik@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6bc681e28ed482e032af48427a27edd4964ccf9", "html_url": "https://github.com/rust-lang/rust/commit/d6bc681e28ed482e032af48427a27edd4964ccf9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6bc681e28ed482e032af48427a27edd4964ccf9/comments", "author": {"login": "geordi", "id": 263425, "node_id": "MDQ6VXNlcjI2MzQyNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/263425?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geordi", "html_url": "https://github.com/geordi", "followers_url": "https://api.github.com/users/geordi/followers", "following_url": "https://api.github.com/users/geordi/following{/other_user}", "gists_url": "https://api.github.com/users/geordi/gists{/gist_id}", "starred_url": "https://api.github.com/users/geordi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geordi/subscriptions", "organizations_url": "https://api.github.com/users/geordi/orgs", "repos_url": "https://api.github.com/users/geordi/repos", "events_url": "https://api.github.com/users/geordi/events{/privacy}", "received_events_url": "https://api.github.com/users/geordi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kobzol", "id": 4539057, "node_id": "MDQ6VXNlcjQ1MzkwNTc=", "avatar_url": "https://avatars.githubusercontent.com/u/4539057?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kobzol", "html_url": "https://github.com/Kobzol", "followers_url": "https://api.github.com/users/Kobzol/followers", "following_url": "https://api.github.com/users/Kobzol/following{/other_user}", "gists_url": "https://api.github.com/users/Kobzol/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kobzol/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kobzol/subscriptions", "organizations_url": "https://api.github.com/users/Kobzol/orgs", "repos_url": "https://api.github.com/users/Kobzol/repos", "events_url": "https://api.github.com/users/Kobzol/events{/privacy}", "received_events_url": "https://api.github.com/users/Kobzol/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b439b119b8d49450bddbbea317afeb0d4166f70", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b439b119b8d49450bddbbea317afeb0d4166f70", "html_url": "https://github.com/rust-lang/rust/commit/0b439b119b8d49450bddbbea317afeb0d4166f70"}], "stats": {"total": 136, "additions": 102, "deletions": 34}, "files": [{"sha": "8b7408484691f80919fff3a0367e8a091603a7e5", "filename": "src/ci/stage-build.py", "status": "modified", "additions": 102, "deletions": 34, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/d6bc681e28ed482e032af48427a27edd4964ccf9/src%2Fci%2Fstage-build.py", "raw_url": "https://github.com/rust-lang/rust/raw/d6bc681e28ed482e032af48427a27edd4964ccf9/src%2Fci%2Fstage-build.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fstage-build.py?ref=d6bc681e28ed482e032af48427a27edd4964ccf9", "patch": "@@ -6,6 +6,7 @@\n import contextlib\n import getpass\n import glob\n+import json\n import logging\n import os\n import pprint\n@@ -17,7 +18,8 @@\n import urllib.request\n from io import StringIO\n from pathlib import Path\n-from typing import Callable, Dict, Iterable, Iterator, List, Optional, Tuple, Union\n+from typing import Callable, ContextManager, Dict, Iterable, Iterator, List, Optional, \\\n+    Tuple, Union\n \n PGO_HOST = os.environ[\"PGO_HOST\"]\n \n@@ -115,6 +117,9 @@ def supports_bolt(self) -> bool:\n     def llvm_bolt_profile_merged_file(self) -> Path:\n         return self.opt_artifacts() / \"bolt.profdata\"\n \n+    def metrics_path(self) -> Path:\n+        return self.build_root() / \"build\" / \"metrics.json\"\n+\n \n class LinuxPipeline(Pipeline):\n     def checkout_path(self) -> Path:\n@@ -208,32 +213,27 @@ def get_timestamp() -> float:\n \n \n Duration = float\n-TimerSection = Union[Duration, \"Timer\"]\n \n \n-def iterate_sections(section: TimerSection, name: str, level: int = 0) -> Iterator[\n+def iterate_timers(timer: \"Timer\", name: str, level: int = 0) -> Iterator[\n     Tuple[int, str, Duration]]:\n     \"\"\"\n-    Hierarchically iterate the sections of a timer, in a depth-first order.\n+    Hierarchically iterate the children of a timer, in a depth-first order.\n     \"\"\"\n-    if isinstance(section, Duration):\n-        yield (level, name, section)\n-    elif isinstance(section, Timer):\n-        yield (level, name, section.total_duration())\n-        for (child_name, child_section) in section.sections:\n-            yield from iterate_sections(child_section, child_name, level=level + 1)\n-    else:\n-        assert False\n+    yield (level, name, timer.total_duration())\n+    for (child_name, child_timer) in timer.children:\n+        yield from iterate_timers(child_timer, child_name, level=level + 1)\n \n \n class Timer:\n     def __init__(self, parent_names: Tuple[str, ...] = ()):\n-        self.sections: List[Tuple[str, TimerSection]] = []\n+        self.children: List[Tuple[str, Timer]] = []\n         self.section_active = False\n         self.parent_names = parent_names\n+        self.duration_excluding_children: Duration = 0\n \n     @contextlib.contextmanager\n-    def section(self, name: str) -> \"Timer\":\n+    def section(self, name: str) -> ContextManager[\"Timer\"]:\n         assert not self.section_active\n         self.section_active = True\n \n@@ -252,33 +252,26 @@ def section(self, name: str) -> \"Timer\":\n             end = get_timestamp()\n             duration = end - start\n \n-            if child_timer.has_children():\n-                self.sections.append((name, child_timer))\n-            else:\n-                self.sections.append((name, duration))\n+            child_timer.duration_excluding_children = duration - child_timer.total_duration()\n+            self.add_child(name, child_timer)\n             if exc is None:\n                 LOGGER.info(f\"Section `{full_name}` ended: OK ({duration:.2f}s)\")\n             else:\n                 LOGGER.info(f\"Section `{full_name}` ended: FAIL ({duration:.2f}s)\")\n             self.section_active = False\n \n     def total_duration(self) -> Duration:\n-        duration = 0\n-        for (_, section) in self.sections:\n-            if isinstance(section, Duration):\n-                duration += section\n-            else:\n-                duration += section.total_duration()\n-        return duration\n+        return self.duration_excluding_children + sum(\n+            c.total_duration() for (_, c) in self.children)\n \n     def has_children(self) -> bool:\n-        return len(self.sections) > 0\n+        return len(self.children) > 0\n \n     def print_stats(self):\n         rows = []\n-        for (child_name, child_section) in self.sections:\n-            for (level, name, duration) in iterate_sections(child_section, child_name, level=0):\n-                label = f\"{' ' * level}{name}:\"\n+        for (child_name, child_timer) in self.children:\n+            for (level, name, duration) in iterate_timers(child_timer, child_name, level=0):\n+                label = f\"{'  ' * level}{name}:\"\n                 rows.append((label, duration))\n \n         # Empty row\n@@ -306,6 +299,60 @@ def print_stats(self):\n             print(divider, file=output, end=\"\")\n             LOGGER.info(f\"Timer results\\n{output.getvalue()}\")\n \n+    def add_child(self, name: str, timer: \"Timer\"):\n+        self.children.append((name, timer))\n+\n+    def add_duration(self, name: str, duration: Duration):\n+        timer = Timer(parent_names=self.parent_names + (name,))\n+        timer.duration_excluding_children = duration\n+        self.add_child(name, timer)\n+\n+\n+class BuildStep:\n+    def __init__(self, type: str, children: List[\"BuildStep\"], duration: float):\n+        self.type = type\n+        self.children = children\n+        self.duration = duration\n+\n+    def find_all_by_type(self, type: str) -> Iterator[\"BuildStep\"]:\n+        if type == self.type:\n+            yield self\n+        for child in self.children:\n+            yield from child.find_all_by_type(type)\n+\n+    def __repr__(self):\n+        return f\"BuildStep(type={self.type}, duration={self.duration}, children={len(self.children)})\"\n+\n+\n+def load_last_metrics(path: Path) -> BuildStep:\n+    \"\"\"\n+    Loads the metrics of the most recent bootstrap execution from a metrics.json file.\n+    \"\"\"\n+    with open(path, \"r\") as f:\n+        metrics = json.load(f)\n+    invocation = metrics[\"invocations\"][-1]\n+\n+    def parse(entry) -> Optional[BuildStep]:\n+        if \"kind\" not in entry or entry[\"kind\"] != \"rustbuild_step\":\n+            return None\n+        type = entry.get(\"type\", \"\")\n+        duration = entry.get(\"duration_excluding_children_sec\", 0)\n+        children = []\n+\n+        for child in entry.get(\"children\", ()):\n+            step = parse(child)\n+            if step is not None:\n+                children.append(step)\n+                duration += step.duration\n+        return BuildStep(type=type, children=children, duration=duration)\n+\n+    children = [parse(child) for child in invocation.get(\"children\", ())]\n+    return BuildStep(\n+        type=\"root\",\n+        children=children,\n+        duration=invocation.get(\"duration_including_children_sec\", 0)\n+    )\n+\n \n @contextlib.contextmanager\n def change_cwd(dir: Path):\n@@ -645,7 +692,7 @@ def print_binary_sizes(pipeline: Pipeline):\n     with StringIO() as output:\n         for path in paths:\n             path_str = f\"{path.name}:\"\n-            print(f\"{path_str:<30}{format_bytes(path.stat().st_size):>14}\", file=output)\n+            print(f\"{path_str:<50}{format_bytes(path.stat().st_size):>14}\", file=output)\n         LOGGER.info(f\"Rustc binary size\\n{output.getvalue()}\")\n \n \n@@ -659,6 +706,22 @@ def print_free_disk_space(pipeline: Pipeline):\n         f\"Free disk space: {format_bytes(free)} out of total {format_bytes(total)} ({(used / total) * 100:.2f}% used)\")\n \n \n+def record_metrics(pipeline: Pipeline, timer: Timer):\n+    metrics = load_last_metrics(pipeline.metrics_path())\n+    if metrics is None:\n+        return\n+    llvm_steps = metrics.find_all_by_type(\"bootstrap::native::Llvm\")\n+    llvm_duration = sum(step.duration for step in llvm_steps)\n+    rustc_steps = metrics.find_all_by_type(\"bootstrap::compile::Rustc\")\n+    rustc_duration = sum(step.duration for step in rustc_steps)\n+\n+    # The LLVM step is part of the Rustc step\n+    rustc_duration -= llvm_duration\n+\n+    timer.add_duration(\"LLVM\", llvm_duration)\n+    timer.add_duration(\"Rustc\", rustc_duration)\n+\n+\n def execute_build_pipeline(timer: Timer, pipeline: Pipeline, final_build_args: List[str]):\n     # Clear and prepare tmp directory\n     shutil.rmtree(pipeline.opt_artifacts(), ignore_errors=True)\n@@ -668,12 +731,13 @@ def execute_build_pipeline(timer: Timer, pipeline: Pipeline, final_build_args: L\n \n     # Stage 1: Build rustc + PGO instrumented LLVM\n     with timer.section(\"Stage 1 (LLVM PGO)\") as stage1:\n-        with stage1.section(\"Build rustc and LLVM\"):\n+        with stage1.section(\"Build rustc and LLVM\") as rustc_build:\n             build_rustc(pipeline, args=[\n                 \"--llvm-profile-generate\"\n             ], env=dict(\n                 LLVM_PROFILE_DIR=str(pipeline.llvm_profile_dir_root() / \"prof-%p\")\n             ))\n+            record_metrics(pipeline, rustc_build)\n \n         with stage1.section(\"Gather profiles\"):\n             gather_llvm_profiles(pipeline)\n@@ -687,11 +751,12 @@ def execute_build_pipeline(timer: Timer, pipeline: Pipeline, final_build_args: L\n \n     # Stage 2: Build PGO instrumented rustc + LLVM\n     with timer.section(\"Stage 2 (rustc PGO)\") as stage2:\n-        with stage2.section(\"Build rustc and LLVM\"):\n+        with stage2.section(\"Build rustc and LLVM\") as rustc_build:\n             build_rustc(pipeline, args=[\n                 \"--rust-profile-generate\",\n                 pipeline.rustc_profile_dir_root()\n             ])\n+            record_metrics(pipeline, rustc_build)\n \n         with stage2.section(\"Gather profiles\"):\n             gather_rustc_profiles(pipeline)\n@@ -706,12 +771,14 @@ def execute_build_pipeline(timer: Timer, pipeline: Pipeline, final_build_args: L\n     # Stage 3: Build rustc + BOLT instrumented LLVM\n     if pipeline.supports_bolt():\n         with timer.section(\"Stage 3 (LLVM BOLT)\") as stage3:\n-            with stage3.section(\"Build rustc and LLVM\"):\n+            with stage3.section(\"Build rustc and LLVM\") as rustc_build:\n                 build_rustc(pipeline, args=[\n                     \"--llvm-profile-use\",\n                     pipeline.llvm_profile_merged_file(),\n                     \"--llvm-bolt-profile-generate\",\n                 ])\n+                record_metrics(pipeline, rustc_build)\n+\n             with stage3.section(\"Gather profiles\"):\n                 gather_llvm_bolt_profiles(pipeline)\n \n@@ -723,8 +790,9 @@ def execute_build_pipeline(timer: Timer, pipeline: Pipeline, final_build_args: L\n         ]\n \n     # Stage 4: Build PGO optimized rustc + PGO/BOLT optimized LLVM\n-    with timer.section(\"Stage 4 (final build)\"):\n+    with timer.section(\"Stage 4 (final build)\") as stage4:\n         cmd(final_build_args)\n+        record_metrics(pipeline, stage4)\n \n \n if __name__ == \"__main__\":"}]}