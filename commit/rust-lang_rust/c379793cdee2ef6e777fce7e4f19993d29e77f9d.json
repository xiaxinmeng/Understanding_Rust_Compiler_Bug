{"sha": "c379793cdee2ef6e777fce7e4f19993d29e77f9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzNzk3OTNjZGVlMmVmNmU3NzdmY2U3ZTRmMTk5OTNkMjllNzdmOWQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-07-02T07:50:52Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-07-02T08:33:54Z"}, "message": "add option to track call IDs", "tree": {"sha": "3d8c21faacedbd12d80a9a1d0ce6dfa8ea7bb782", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d8c21faacedbd12d80a9a1d0ce6dfa8ea7bb782"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c379793cdee2ef6e777fce7e4f19993d29e77f9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c379793cdee2ef6e777fce7e4f19993d29e77f9d", "html_url": "https://github.com/rust-lang/rust/commit/c379793cdee2ef6e777fce7e4f19993d29e77f9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c379793cdee2ef6e777fce7e4f19993d29e77f9d/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd8101247749c5be6850d5cb5096f01a1867e5ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd8101247749c5be6850d5cb5096f01a1867e5ba", "html_url": "https://github.com/rust-lang/rust/commit/fd8101247749c5be6850d5cb5096f01a1867e5ba"}], "stats": {"total": 61, "additions": 46, "deletions": 15}, "files": [{"sha": "ab4d4c02db1edf5a2cd16906bfc812646b9056f2", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c379793cdee2ef6e777fce7e4f19993d29e77f9d/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/c379793cdee2ef6e777fce7e4f19993d29e77f9d/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=c379793cdee2ef6e777fce7e4f19993d29e77f9d", "patch": "@@ -196,6 +196,9 @@ Miri adds its own set of `-Z` flags:\n   is popped from a borrow stack (which is where the tag becomes invalid and any\n   future use of it will error).  This helps you in finding out why UB is\n   happening and where in your code would be a good place to look for it.\n+* `-Zmiri-track-call-id=<id>` shows a backtrace when the given call id is\n+  assigned to a stack frame.  This helps in debugging UB related to Stacked\n+  Borrows \"protectors\".\n \n [alignment-false-positives]: https://github.com/rust-lang/miri/issues/1074\n "}, {"sha": "f22f19845c6c98b5451d1204766478d2c2c22e14", "filename": "src/bin/miri.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c379793cdee2ef6e777fce7e4f19993d29e77f9d/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c379793cdee2ef6e777fce7e4f19993d29e77f9d/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=c379793cdee2ef6e777fce7e4f19993d29e77f9d", "patch": "@@ -172,6 +172,7 @@ fn main() {\n     let mut ignore_leaks = false;\n     let mut seed: Option<u64> = None;\n     let mut tracked_pointer_tag: Option<miri::PtrId> = None;\n+    let mut tracked_call_id: Option<miri::CallId> = None;\n     let mut tracked_alloc_id: Option<miri::AllocId> = None;\n     let mut rustc_args = vec![];\n     let mut crate_args = vec![];\n@@ -233,26 +234,38 @@ fn main() {\n                         .push(arg.strip_prefix(\"-Zmiri-env-exclude=\").unwrap().to_owned());\n                 }\n                 arg if arg.starts_with(\"-Zmiri-track-pointer-tag=\") => {\n-                    let id: u64 = match arg.strip_prefix(\"-Zmiri-track-pointer-tag=\").unwrap().parse()\n-                    {\n+                    let id: u64 = match arg.strip_prefix(\"-Zmiri-track-pointer-tag=\").unwrap().parse() {\n                         Ok(id) => id,\n                         Err(err) => panic!(\n-                            \"-Zmiri-track-pointer-tag requires a valid `u64` as the argument: {}\",\n+                            \"-Zmiri-track-pointer-tag requires a valid `u64` argument: {}\",\n                             err\n                         ),\n                     };\n                     if let Some(id) = miri::PtrId::new(id) {\n                         tracked_pointer_tag = Some(id);\n                     } else {\n-                        panic!(\"-Zmiri-track-pointer-tag must be a nonzero id\");\n+                        panic!(\"-Zmiri-track-pointer-tag requires a nonzero argument\");\n+                    }\n+                }\n+                arg if arg.starts_with(\"-Zmiri-track-call-id=\") => {\n+                    let id: u64 = match arg.strip_prefix(\"-Zmiri-track-call-id=\").unwrap().parse() {\n+                        Ok(id) => id,\n+                        Err(err) => panic!(\n+                            \"-Zmiri-track-call-id requires a valid `u64` argument: {}\",\n+                            err\n+                        ),\n+                    };\n+                    if let Some(id) = miri::CallId::new(id) {\n+                        tracked_call_id = Some(id);\n+                    } else {\n+                        panic!(\"-Zmiri-track-call-id requires a nonzero argument\");\n                     }\n                 }\n                 arg if arg.starts_with(\"-Zmiri-track-alloc-id=\") => {\n-                    let id: u64 = match arg.strip_prefix(\"-Zmiri-track-alloc-id=\").unwrap().parse()\n-                    {\n+                    let id: u64 = match arg.strip_prefix(\"-Zmiri-track-alloc-id=\").unwrap().parse() {\n                         Ok(id) => id,\n                         Err(err) => panic!(\n-                            \"-Zmiri-track-alloc-id requires a valid `u64` as the argument: {}\",\n+                            \"-Zmiri-track-alloc-id requires a valid `u64` argument: {}\",\n                             err\n                         ),\n                     };\n@@ -278,6 +291,7 @@ fn main() {\n         seed,\n         args: crate_args,\n         tracked_pointer_tag,\n+        tracked_call_id,\n         tracked_alloc_id,\n     };\n     run_compiler(rustc_args, &mut MiriCompilerCalls { miri_config })"}, {"sha": "8fdf039ce8e6cfc7839edffe3dab4af2a4310062", "filename": "src/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c379793cdee2ef6e777fce7e4f19993d29e77f9d/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c379793cdee2ef6e777fce7e4f19993d29e77f9d/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=c379793cdee2ef6e777fce7e4f19993d29e77f9d", "patch": "@@ -40,7 +40,8 @@ impl MachineStopType for TerminationInfo {}\n \n /// Miri specific diagnostics\n pub enum NonHaltingDiagnostic {\n-    PoppedTrackedPointerTag(Item),\n+    PoppedPointerTag(Item),\n+    CreatedCallId(CallId),\n     CreatedAlloc(AllocId),\n     FreedAlloc(AllocId),\n }\n@@ -204,8 +205,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             for e in diagnostics.borrow_mut().drain(..) {\n                 use NonHaltingDiagnostic::*;\n                 let msg = match e {\n-                    PoppedTrackedPointerTag(item) =>\n+                    PoppedPointerTag(item) =>\n                         format!(\"popped tracked tag for item {:?}\", item),\n+                    CreatedCallId(id) =>\n+                        format!(\"function call with id {}\", id),\n                     CreatedAlloc(AllocId(id)) =>\n                         format!(\"created allocation with id {}\", id),\n                     FreedAlloc(AllocId(id)) =>"}, {"sha": "ee429dd3143ed5cbfc2ee6df9bedda2dac6d02de", "filename": "src/eval.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c379793cdee2ef6e777fce7e4f19993d29e77f9d/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c379793cdee2ef6e777fce7e4f19993d29e77f9d/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=c379793cdee2ef6e777fce7e4f19993d29e77f9d", "patch": "@@ -31,8 +31,10 @@ pub struct MiriConfig {\n     pub args: Vec<String>,\n     /// The seed to use when non-determinism or randomness are required (e.g. ptr-to-int cast, `getrandom()`).\n     pub seed: Option<u64>,\n-    /// The stacked borrow id to report about\n+    /// The stacked borrows pointer id to report about\n     pub tracked_pointer_tag: Option<PtrId>,\n+    /// The stacked borrows call ID to report about\n+    pub tracked_call_id: Option<CallId>,\n     /// The allocation id to report about.\n     pub tracked_alloc_id: Option<AllocId>,\n }\n@@ -49,6 +51,7 @@ impl Default for MiriConfig {\n             args: vec![],\n             seed: None,\n             tracked_pointer_tag: None,\n+            tracked_call_id: None,\n             tracked_alloc_id: None,\n         }\n     }\n@@ -74,6 +77,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n             StdRng::seed_from_u64(config.seed.unwrap_or(0)),\n             config.stacked_borrows,\n             config.tracked_pointer_tag,\n+            config.tracked_call_id,\n             config.tracked_alloc_id,\n             config.check_alignment,\n         ),"}, {"sha": "816917081a8ce31fefaa8c5183eea3a12747314e", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c379793cdee2ef6e777fce7e4f19993d29e77f9d/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c379793cdee2ef6e777fce7e4f19993d29e77f9d/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=c379793cdee2ef6e777fce7e4f19993d29e77f9d", "patch": "@@ -65,7 +65,7 @@ pub use crate::mono_hash_map::MonoHashMap;\n pub use crate::operator::EvalContextExt as OperatorEvalContextExt;\n pub use crate::range_map::RangeMap;\n pub use crate::stacked_borrows::{\n-    EvalContextExt as StackedBorEvalContextExt, Item, Permission, PtrId, Stack, Stacks, Tag,\n+    EvalContextExt as StackedBorEvalContextExt, Item, Permission, CallId, PtrId, Stack, Stacks, Tag,\n };\n pub use crate::thread::{\n     EvalContextExt as ThreadsEvalContextExt, SchedulingAction, ThreadId, ThreadManager, ThreadState,"}, {"sha": "f23d8833bd82b8965770bbee5ec534a4cefbe84c", "filename": "src/machine.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c379793cdee2ef6e777fce7e4f19993d29e77f9d/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c379793cdee2ef6e777fce7e4f19993d29e77f9d/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=c379793cdee2ef6e777fce7e4f19993d29e77f9d", "patch": "@@ -129,11 +129,12 @@ impl MemoryExtra {\n         rng: StdRng,\n         stacked_borrows: bool,\n         tracked_pointer_tag: Option<PtrId>,\n+        tracked_call_id: Option<CallId>,\n         tracked_alloc_id: Option<AllocId>,\n         check_alignment: bool,\n     ) -> Self {\n         let stacked_borrows = if stacked_borrows {\n-            Some(Rc::new(RefCell::new(stacked_borrows::GlobalState::new(tracked_pointer_tag))))\n+            Some(Rc::new(RefCell::new(stacked_borrows::GlobalState::new(tracked_pointer_tag, tracked_call_id))))\n         } else {\n             None\n         };"}, {"sha": "3c263670bc7fb8da596a4bded4bdad2358954003", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c379793cdee2ef6e777fce7e4f19993d29e77f9d/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c379793cdee2ef6e777fce7e4f19993d29e77f9d/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=c379793cdee2ef6e777fce7e4f19993d29e77f9d", "patch": "@@ -104,8 +104,10 @@ pub struct GlobalState {\n     next_call_id: CallId,\n     /// Those call IDs corresponding to functions that are still running.\n     active_calls: FxHashSet<CallId>,\n-    /// The id to trace in this execution run\n+    /// The pointer id to trace\n     tracked_pointer_tag: Option<PtrId>,\n+    /// The call id to trace\n+    tracked_call_id: Option<CallId>,\n }\n /// Memory extra state gives us interior mutable access to the global state.\n pub type MemoryExtra = Rc<RefCell<GlobalState>>;\n@@ -153,13 +155,14 @@ impl fmt::Display for RefKind {\n \n /// Utilities for initialization and ID generation\n impl GlobalState {\n-    pub fn new(tracked_pointer_tag: Option<PtrId>) -> Self {\n+    pub fn new(tracked_pointer_tag: Option<PtrId>, tracked_call_id: Option<CallId>) -> Self {\n         GlobalState {\n             next_ptr_id: NonZeroU64::new(1).unwrap(),\n             base_ptr_ids: FxHashMap::default(),\n             next_call_id: NonZeroU64::new(1).unwrap(),\n             active_calls: FxHashSet::default(),\n             tracked_pointer_tag,\n+            tracked_call_id,\n         }\n     }\n \n@@ -172,6 +175,9 @@ impl GlobalState {\n     pub fn new_call(&mut self) -> CallId {\n         let id = self.next_call_id;\n         trace!(\"new_call: Assigning ID {}\", id);\n+        if Some(id) == self.tracked_call_id {\n+            register_diagnostic(NonHaltingDiagnostic::CreatedCallId(id));\n+        }\n         assert!(self.active_calls.insert(id));\n         self.next_call_id = NonZeroU64::new(id.get() + 1).unwrap();\n         id\n@@ -277,7 +283,7 @@ impl<'tcx> Stack {\n     fn check_protector(item: &Item, tag: Option<Tag>, global: &GlobalState) -> InterpResult<'tcx> {\n         if let Tag::Tagged(id) = item.tag {\n             if Some(id) == global.tracked_pointer_tag {\n-                register_diagnostic(NonHaltingDiagnostic::PoppedTrackedPointerTag(item.clone()));\n+                register_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(item.clone()));\n             }\n         }\n         if let Some(call) = item.protector {"}]}