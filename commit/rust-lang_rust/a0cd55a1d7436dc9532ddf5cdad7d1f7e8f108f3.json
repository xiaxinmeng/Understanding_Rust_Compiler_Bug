{"sha": "a0cd55a1d7436dc9532ddf5cdad7d1f7e8f108f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwY2Q1NWExZDc0MzZkYzk1MzJkZGY1Y2RhZDdkMWY3ZThmMTA4ZjM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-21T01:23:56Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-22T07:43:29Z"}, "message": "core::rt: Add RemoteCallback trait and uv implementation\n\nThis is used for signalling the event loop from other threads.", "tree": {"sha": "2ea255a7a41f8bfbe7bfd8f3f67b6883aed5efc7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ea255a7a41f8bfbe7bfd8f3f67b6883aed5efc7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0cd55a1d7436dc9532ddf5cdad7d1f7e8f108f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0cd55a1d7436dc9532ddf5cdad7d1f7e8f108f3", "html_url": "https://github.com/rust-lang/rust/commit/a0cd55a1d7436dc9532ddf5cdad7d1f7e8f108f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0cd55a1d7436dc9532ddf5cdad7d1f7e8f108f3/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f77a6f422184dacc14ae1b6a042c321e06bef88", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f77a6f422184dacc14ae1b6a042c321e06bef88", "html_url": "https://github.com/rust-lang/rust/commit/8f77a6f422184dacc14ae1b6a042c321e06bef88"}], "stats": {"total": 103, "additions": 100, "deletions": 3}, "files": [{"sha": "fa657555f3aa0fc6f8012a9ad164746f7a1ae6a1", "filename": "src/libcore/rt/rtio.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a0cd55a1d7436dc9532ddf5cdad7d1f7e8f108f3/src%2Flibcore%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0cd55a1d7436dc9532ddf5cdad7d1f7e8f108f3/src%2Flibcore%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Frtio.rs?ref=a0cd55a1d7436dc9532ddf5cdad7d1f7e8f108f3", "patch": "@@ -18,6 +18,7 @@ use rt::uv::uvio;\n // XXX: ~object doesn't work currently so these are some placeholder\n // types to use instead\n pub type EventLoopObject = uvio::UvEventLoop;\n+pub type RemoteCallbackObject = uvio::UvRemoteCallback;\n pub type IoFactoryObject = uvio::UvIoFactory;\n pub type RtioTcpStreamObject = uvio::UvTcpStream;\n pub type RtioTcpListenerObject = uvio::UvTcpListener;\n@@ -26,10 +27,20 @@ pub trait EventLoop {\n     fn run(&mut self);\n     fn callback(&mut self, ~fn());\n     fn callback_ms(&mut self, ms: u64, ~fn());\n+    fn remote_callback(&mut self, ~fn()) -> ~RemoteCallbackObject;\n     /// The asynchronous I/O services. Not all event loops may provide one\n     fn io<'a>(&'a mut self) -> Option<&'a mut IoFactoryObject>;\n }\n \n+pub trait RemoteCallback {\n+    /// Trigger the remote callback. Note that the number of times the callback\n+    /// is run is not guaranteed. All that is guaranteed is that, after calling 'fire',\n+    /// the callback will be called at least once, but multiple callbacks may be coalesced\n+    /// and callbacks may be called more often requested. Destruction also triggers the\n+    /// callback.\n+    fn fire(&mut self);\n+}\n+\n pub trait IoFactory {\n     fn tcp_connect(&mut self, addr: IpAddr) -> Result<~RtioTcpStreamObject, IoError>;\n     fn tcp_bind(&mut self, addr: IpAddr) -> Result<~RtioTcpListenerObject, IoError>;"}, {"sha": "6ed06cc10b78a56b12b169f513b0007540d0c5c1", "filename": "src/libcore/rt/uv/async.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a0cd55a1d7436dc9532ddf5cdad7d1f7e8f108f3/src%2Flibcore%2Frt%2Fuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0cd55a1d7436dc9532ddf5cdad7d1f7e8f108f3/src%2Flibcore%2Frt%2Fuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fasync.rs?ref=a0cd55a1d7436dc9532ddf5cdad7d1f7e8f108f3", "patch": "@@ -20,7 +20,7 @@ pub struct AsyncWatcher(*uvll::uv_async_t);\n impl Watcher for AsyncWatcher { }\n \n impl AsyncWatcher {\n-    fn new(loop_: &mut Loop, cb: AsyncCallback) -> AsyncWatcher {\n+    pub fn new(loop_: &mut Loop, cb: AsyncCallback) -> AsyncWatcher {\n         unsafe {\n             let handle = uvll::malloc_handle(UV_ASYNC);\n             assert!(handle.is_not_null());\n@@ -41,14 +41,14 @@ impl AsyncWatcher {\n         }\n     }\n \n-    fn send(&mut self) {\n+    pub fn send(&mut self) {\n         unsafe {\n             let handle = self.native_handle();\n             uvll::async_send(handle);\n         }\n     }\n \n-    fn close(self, cb: NullCallback) {\n+    pub fn close(self, cb: NullCallback) {\n         let mut this = self;\n         let data = this.get_watcher_data();\n         assert!(data.close_cb.is_none());"}, {"sha": "cf1bd568d02885cc0237e1a491fe0a145bc1b2b9", "filename": "src/libcore/rt/uv/uvio.rs", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/a0cd55a1d7436dc9532ddf5cdad7d1f7e8f108f3/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0cd55a1d7436dc9532ddf5cdad7d1f7e8f108f3/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs?ref=a0cd55a1d7436dc9532ddf5cdad7d1f7e8f108f3", "patch": "@@ -12,6 +12,7 @@ use option::*;\n use result::*;\n use ops::Drop;\n use cell::{Cell, empty_cell};\n+use cast;\n use cast::transmute;\n use clone::Clone;\n use rt::io::IoError;\n@@ -23,6 +24,8 @@ use rt::sched::Scheduler;\n use rt::io::{standard_error, OtherIoError};\n use rt::tube::Tube;\n use rt::local::Local;\n+use unstable::sync::{UnsafeAtomicRcBox, AtomicInt};\n+use unstable::intrinsics;\n \n #[cfg(test)] use container::Container;\n #[cfg(test)] use uint;\n@@ -82,6 +85,10 @@ impl EventLoop for UvEventLoop {\n         }\n     }\n \n+    fn remote_callback(&mut self, f: ~fn()) -> ~RemoteCallbackObject {\n+        ~UvRemoteCallback::new(self.uvio.uv_loop(), f)\n+    }\n+\n     fn io<'a>(&'a mut self) -> Option<&'a mut IoFactoryObject> {\n         Some(&mut self.uvio)\n     }\n@@ -101,6 +108,85 @@ fn test_callback_run_once() {\n     }\n }\n \n+pub struct UvRemoteCallback {\n+    // The uv async handle for triggering the callback\n+    async: AsyncWatcher,\n+    // An atomic flag to tell the callback to exit,\n+    // set from the dtor.\n+    exit_flag: UnsafeAtomicRcBox<AtomicInt>\n+}\n+\n+impl UvRemoteCallback {\n+    pub fn new(loop_: &mut Loop, f: ~fn()) -> UvRemoteCallback {\n+        let exit_flag = UnsafeAtomicRcBox::new(AtomicInt::new(0));\n+        let exit_flag_clone = exit_flag.clone();\n+        let async = do AsyncWatcher::new(loop_) |watcher, status| {\n+            assert!(status.is_none());\n+            f();\n+            let exit_flag_ptr = exit_flag_clone.get();\n+            unsafe {\n+                if (*exit_flag_ptr).load() == 1 {\n+                    watcher.close(||());\n+                }\n+            }\n+        };\n+        UvRemoteCallback {\n+            async: async,\n+            exit_flag: exit_flag\n+        }\n+    }\n+}\n+\n+impl RemoteCallback for UvRemoteCallback {\n+    fn fire(&mut self) { self.async.send() }\n+}\n+\n+impl Drop for UvRemoteCallback {\n+    fn finalize(&self) {\n+        unsafe {\n+            let mut this: &mut UvRemoteCallback = cast::transmute_mut(self);\n+            let exit_flag_ptr = this.exit_flag.get();\n+            (*exit_flag_ptr).store(1);\n+            this.async.send();\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test_remote {\n+    use super::*;\n+    use cell;\n+    use cell::Cell;\n+    use rt::test::*;\n+    use rt::thread::Thread;\n+    use rt::tube::Tube;\n+    use rt::rtio::EventLoop;\n+    use rt::local::Local;\n+    use rt::sched::Scheduler;\n+\n+    #[test]\n+    fn test_uv_remote() {\n+        do run_in_newsched_task {\n+            let mut tube = Tube::new();\n+            let tube_clone = tube.clone();\n+            let remote_cell = cell::empty_cell();\n+            do Local::borrow::<Scheduler>() |sched| {\n+                let tube_clone = tube_clone.clone();\n+                let tube_clone_cell = Cell(tube_clone);\n+                let remote = do sched.event_loop.remote_callback {\n+                    tube_clone_cell.take().send(1);\n+                };\n+                remote_cell.put_back(remote);\n+            }\n+            let _thread = do Thread::start {\n+                remote_cell.take().fire();\n+            };\n+\n+            assert!(tube.recv() == 1);\n+        }\n+    }\n+}\n+\n pub struct UvIoFactory(Loop);\n \n pub impl UvIoFactory {"}]}