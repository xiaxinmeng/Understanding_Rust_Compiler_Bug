{"sha": "c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6", "node_id": "C_kwDOAAsO6NoAKGM3OGUzYzczNWFmZjhhYTliYWQ5Y2QyZGM0NmI1ZmRiZjRjYTFhZjY", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2023-02-15T06:54:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-15T06:54:55Z"}, "message": "Rollup merge of #107411 - cjgillot:dataflow-discriminant, r=oli-obk\n\nHandle discriminant in DataflowConstProp\n\ncc ``@jachris``\nr? ``@JakobDegen``\n\nThis PR attempts to extend the DataflowConstProp pass to handle propagation of discriminants. We handle this by adding 2 new variants to `TrackElem`: `TrackElem::Variant` for enum variants and `TrackElem::Discriminant` for the enum discriminant pseudo-place.\n\nThe difficulty is that the enum discriminant and enum variants may alias each another. This is the issue of the `Option<NonZeroUsize>` test, which is the equivalent of https://github.com/rust-lang/unsafe-code-guidelines/issues/84 with a direct write.\n\nTo handle that, we generalize the flood process to flood all the potentially aliasing places. In particular:\n- any write to `(PLACE as Variant)`, either direct or through a projection, floods `(PLACE as OtherVariant)` for all other variants and `discriminant(PLACE)`;\n- `SetDiscriminant(PLACE)` floods `(PLACE as Variant)` for each variant.\n\nThis implies that flooding is not hierarchical any more, and that an assignment to a non-tracked place may need to flood a tracked place. This is handled by `for_each_aliasing_place` which generalizes `preorder_invoke`.\n\nAs we deaggregate enums by putting `SetDiscriminant` last, this allows to propagate the value of the discriminant.\n\nThis refactor will allow to make https://github.com/rust-lang/rust/pull/107009 able to handle discriminants too.", "tree": {"sha": "70b814539bb7b7ff9c4c7b10f400611d93099804", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70b814539bb7b7ff9c4c7b10f400611d93099804"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj7IG/CRBK7hj4Ov3rIwAAFSIIAItrVF4yVWjp2+/T0yo9q7VE\nnWwMBBJ5K9/kihYlgy733YqsXm13gE2BcW0oYCoVb4xumMxOBO003bU3zCPZ0nbQ\ntAGmRs/46uEUJRqDfNbGwTJ4Ogl4ZZlwDNaqqeADolN2AlQxWdaX9QoUYzA3ezo5\nE9ktLp5i+PrADJ3YAW9ov3j8/XFQmJroENHbc5jVYjq67tvIGYsNYL6vCmqDr2rf\n03bKqyDnx38nOii6GQm0UeLf8cr/UsiLPWpnIy2Ii7An5c77bvBBxGCBrdrtZkZX\ne9zXTYiBmLvimkGYnoZkpllMBgiHvYrsryf4APzRClEJvzqtMAdAc843EBoE154=\n=4wcA\n-----END PGP SIGNATURE-----\n", "payload": "tree 70b814539bb7b7ff9c4c7b10f400611d93099804\nparent a110cf5d1649aa920c046c764c28c666ebdd85cd\nparent 09797a463cd1bc70bc439aaf0c94b7b5a80f5bfb\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1676444095 +0530\ncommitter GitHub <noreply@github.com> 1676444095 +0530\n\nRollup merge of #107411 - cjgillot:dataflow-discriminant, r=oli-obk\n\nHandle discriminant in DataflowConstProp\n\ncc ``@jachris``\nr? ``@JakobDegen``\n\nThis PR attempts to extend the DataflowConstProp pass to handle propagation of discriminants. We handle this by adding 2 new variants to `TrackElem`: `TrackElem::Variant` for enum variants and `TrackElem::Discriminant` for the enum discriminant pseudo-place.\n\nThe difficulty is that the enum discriminant and enum variants may alias each another. This is the issue of the `Option<NonZeroUsize>` test, which is the equivalent of https://github.com/rust-lang/unsafe-code-guidelines/issues/84 with a direct write.\n\nTo handle that, we generalize the flood process to flood all the potentially aliasing places. In particular:\n- any write to `(PLACE as Variant)`, either direct or through a projection, floods `(PLACE as OtherVariant)` for all other variants and `discriminant(PLACE)`;\n- `SetDiscriminant(PLACE)` floods `(PLACE as Variant)` for each variant.\n\nThis implies that flooding is not hierarchical any more, and that an assignment to a non-tracked place may need to flood a tracked place. This is handled by `for_each_aliasing_place` which generalizes `preorder_invoke`.\n\nAs we deaggregate enums by putting `SetDiscriminant` last, this allows to propagate the value of the discriminant.\n\nThis refactor will allow to make https://github.com/rust-lang/rust/pull/107009 able to handle discriminants too.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6", "html_url": "https://github.com/rust-lang/rust/commit/c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a110cf5d1649aa920c046c764c28c666ebdd85cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/a110cf5d1649aa920c046c764c28c666ebdd85cd", "html_url": "https://github.com/rust-lang/rust/commit/a110cf5d1649aa920c046c764c28c666ebdd85cd"}, {"sha": "09797a463cd1bc70bc439aaf0c94b7b5a80f5bfb", "url": "https://api.github.com/repos/rust-lang/rust/commits/09797a463cd1bc70bc439aaf0c94b7b5a80f5bfb", "html_url": "https://github.com/rust-lang/rust/commit/09797a463cd1bc70bc439aaf0c94b7b5a80f5bfb"}], "stats": {"total": 520, "additions": 408, "deletions": 112}, "files": [{"sha": "6996d91a80dcc428bb38f38f522af2cf2b20b435", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6", "patch": "@@ -1642,6 +1642,14 @@ impl<'tcx> PlaceRef<'tcx> {\n         }\n     }\n \n+    /// Returns `true` if this `Place` contains a `Deref` projection.\n+    ///\n+    /// If `Place::is_indirect` returns false, the caller knows that the `Place` refers to the\n+    /// same region of memory as its base.\n+    pub fn is_indirect(&self) -> bool {\n+        self.projection.iter().any(|elem| elem.is_indirect())\n+    }\n+\n     /// If MirPhase >= Derefered and if projection contains Deref,\n     /// It's guaranteed to be in the first place\n     pub fn has_deref(&self) -> bool {"}, {"sha": "6f4e7fd4682c171f15512954fa9ff773fe63812a", "filename": "compiler/rustc_mir_dataflow/src/impls/borrowed_locals.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fborrowed_locals.rs?ref=c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6", "patch": "@@ -121,7 +121,9 @@ where\n                 // for now. See discussion on [#61069].\n                 //\n                 // [#61069]: https://github.com/rust-lang/rust/pull/61069\n-                self.trans.gen(dropped_place.local);\n+                if !dropped_place.is_indirect() {\n+                    self.trans.gen(dropped_place.local);\n+                }\n             }\n \n             TerminatorKind::Abort"}, {"sha": "3e382f500afbe0bc27a2e63ef313afda907b3ca7", "filename": "compiler/rustc_mir_dataflow/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs?ref=c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6", "patch": "@@ -1,6 +1,7 @@\n #![feature(associated_type_defaults)]\n #![feature(box_patterns)]\n #![feature(exact_size_is_empty)]\n+#![feature(let_chains)]\n #![feature(min_specialization)]\n #![feature(once_cell)]\n #![feature(stmt_expr_attributes)]"}, {"sha": "401db890a9810d1f811d63390c9f082f8beb57a9", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 214, "deletions": 61, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6", "patch": "@@ -24,7 +24,7 @@\n //! - The bottom state denotes uninitialized memory. Because we are only doing a sound approximation\n //! of the actual execution, we can also use this state for places where access would be UB.\n //!\n-//! - The assignment logic in `State::assign_place_idx` assumes that the places are non-overlapping,\n+//! - The assignment logic in `State::insert_place_idx` assumes that the places are non-overlapping,\n //! or identical. Note that this refers to place expressions, not memory locations.\n //!\n //! - Currently, places that have their reference taken cannot be tracked. Although this would be\n@@ -35,6 +35,7 @@\n use std::fmt::{Debug, Formatter};\n \n use rustc_data_structures::fx::FxHashMap;\n+use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::visit::{MutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n@@ -64,10 +65,8 @@ pub trait ValueAnalysis<'tcx> {\n             StatementKind::Assign(box (place, rvalue)) => {\n                 self.handle_assign(*place, rvalue, state);\n             }\n-            StatementKind::SetDiscriminant { .. } => {\n-                // Could treat this as writing a constant to a pseudo-place.\n-                // But discriminants are currently not tracked, so we do nothing.\n-                // Related: https://github.com/rust-lang/unsafe-code-guidelines/issues/84\n+            StatementKind::SetDiscriminant { box ref place, .. } => {\n+                state.flood_discr(place.as_ref(), self.map());\n             }\n             StatementKind::Intrinsic(box intrinsic) => {\n                 self.handle_intrinsic(intrinsic, state);\n@@ -446,77 +445,93 @@ impl<V: Clone + HasTop + HasBottom> State<V> {\n     }\n \n     pub fn flood_with(&mut self, place: PlaceRef<'_>, map: &Map, value: V) {\n-        if let Some(root) = map.find(place) {\n-            self.flood_idx_with(root, map, value);\n-        }\n+        let StateData::Reachable(values) = &mut self.0 else { return };\n+        map.for_each_aliasing_place(place, None, &mut |place| {\n+            if let Some(vi) = map.places[place].value_index {\n+                values[vi] = value.clone();\n+            }\n+        });\n     }\n \n     pub fn flood(&mut self, place: PlaceRef<'_>, map: &Map) {\n         self.flood_with(place, map, V::top())\n     }\n \n-    pub fn flood_idx_with(&mut self, place: PlaceIndex, map: &Map, value: V) {\n+    pub fn flood_discr_with(&mut self, place: PlaceRef<'_>, map: &Map, value: V) {\n         let StateData::Reachable(values) = &mut self.0 else { return };\n-        map.preorder_invoke(place, &mut |place| {\n+        map.for_each_aliasing_place(place, Some(TrackElem::Discriminant), &mut |place| {\n             if let Some(vi) = map.places[place].value_index {\n                 values[vi] = value.clone();\n             }\n         });\n     }\n \n-    pub fn flood_idx(&mut self, place: PlaceIndex, map: &Map) {\n-        self.flood_idx_with(place, map, V::top())\n+    pub fn flood_discr(&mut self, place: PlaceRef<'_>, map: &Map) {\n+        self.flood_discr_with(place, map, V::top())\n+    }\n+\n+    /// Low-level method that assigns to a place.\n+    /// This does nothing if the place is not tracked.\n+    ///\n+    /// The target place must have been flooded before calling this method.\n+    pub fn insert_idx(&mut self, target: PlaceIndex, result: ValueOrPlace<V>, map: &Map) {\n+        match result {\n+            ValueOrPlace::Value(value) => self.insert_value_idx(target, value, map),\n+            ValueOrPlace::Place(source) => self.insert_place_idx(target, source, map),\n+        }\n+    }\n+\n+    /// Low-level method that assigns a value to a place.\n+    /// This does nothing if the place is not tracked.\n+    ///\n+    /// The target place must have been flooded before calling this method.\n+    pub fn insert_value_idx(&mut self, target: PlaceIndex, value: V, map: &Map) {\n+        let StateData::Reachable(values) = &mut self.0 else { return };\n+        if let Some(value_index) = map.places[target].value_index {\n+            values[value_index] = value;\n+        }\n     }\n \n     /// Copies `source` to `target`, including all tracked places beneath.\n     ///\n     /// If `target` contains a place that is not contained in `source`, it will be overwritten with\n     /// Top. Also, because this will copy all entries one after another, it may only be used for\n     /// places that are non-overlapping or identical.\n-    pub fn assign_place_idx(&mut self, target: PlaceIndex, source: PlaceIndex, map: &Map) {\n+    ///\n+    /// The target place must have been flooded before calling this method.\n+    fn insert_place_idx(&mut self, target: PlaceIndex, source: PlaceIndex, map: &Map) {\n         let StateData::Reachable(values) = &mut self.0 else { return };\n \n-        // If both places are tracked, we copy the value to the target. If the target is tracked,\n-        // but the source is not, we have to invalidate the value in target. If the target is not\n-        // tracked, then we don't have to do anything.\n+        // If both places are tracked, we copy the value to the target.\n+        // If the target is tracked, but the source is not, we do nothing, as invalidation has\n+        // already been performed.\n         if let Some(target_value) = map.places[target].value_index {\n             if let Some(source_value) = map.places[source].value_index {\n                 values[target_value] = values[source_value].clone();\n-            } else {\n-                values[target_value] = V::top();\n             }\n         }\n         for target_child in map.children(target) {\n             // Try to find corresponding child and recurse. Reasoning is similar as above.\n             let projection = map.places[target_child].proj_elem.unwrap();\n             if let Some(source_child) = map.projections.get(&(source, projection)) {\n-                self.assign_place_idx(target_child, *source_child, map);\n-            } else {\n-                self.flood_idx(target_child, map);\n+                self.insert_place_idx(target_child, *source_child, map);\n             }\n         }\n     }\n \n+    /// Helper method to interpret `target = result`.\n     pub fn assign(&mut self, target: PlaceRef<'_>, result: ValueOrPlace<V>, map: &Map) {\n+        self.flood(target, map);\n         if let Some(target) = map.find(target) {\n-            self.assign_idx(target, result, map);\n-        } else {\n-            // We don't track this place nor any projections, assignment can be ignored.\n+            self.insert_idx(target, result, map);\n         }\n     }\n \n-    pub fn assign_idx(&mut self, target: PlaceIndex, result: ValueOrPlace<V>, map: &Map) {\n-        match result {\n-            ValueOrPlace::Value(value) => {\n-                // First flood the target place in case we also track any projections (although\n-                // this scenario is currently not well-supported by the API).\n-                self.flood_idx(target, map);\n-                let StateData::Reachable(values) = &mut self.0 else { return };\n-                if let Some(value_index) = map.places[target].value_index {\n-                    values[value_index] = value;\n-                }\n-            }\n-            ValueOrPlace::Place(source) => self.assign_place_idx(target, source, map),\n+    /// Helper method for assignments to a discriminant.\n+    pub fn assign_discr(&mut self, target: PlaceRef<'_>, result: ValueOrPlace<V>, map: &Map) {\n+        self.flood_discr(target, map);\n+        if let Some(target) = map.find_discr(target) {\n+            self.insert_idx(target, result, map);\n         }\n     }\n \n@@ -525,6 +540,14 @@ impl<V: Clone + HasTop + HasBottom> State<V> {\n         map.find(place).map(|place| self.get_idx(place, map)).unwrap_or(V::top())\n     }\n \n+    /// Retrieve the value stored for a place, or \u22a4 if it is not tracked.\n+    pub fn get_discr(&self, place: PlaceRef<'_>, map: &Map) -> V {\n+        match map.find_discr(place) {\n+            Some(place) => self.get_idx(place, map),\n+            None => V::top(),\n+        }\n+    }\n+\n     /// Retrieve the value stored for a place index, or \u22a4 if it is not tracked.\n     pub fn get_idx(&self, place: PlaceIndex, map: &Map) -> V {\n         match &self.0 {\n@@ -581,15 +604,15 @@ impl Map {\n     /// This is currently the only way to create a [`Map`]. The way in which the tracked places are\n     /// chosen is an implementation detail and may not be relied upon (other than that their type\n     /// passes the filter).\n-    #[instrument(skip_all, level = \"debug\")]\n     pub fn from_filter<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n         filter: impl FnMut(Ty<'tcx>) -> bool,\n+        place_limit: Option<usize>,\n     ) -> Self {\n         let mut map = Self::new();\n         let exclude = excluded_locals(body);\n-        map.register_with_filter(tcx, body, filter, &exclude);\n+        map.register_with_filter(tcx, body, filter, exclude, place_limit);\n         debug!(\"registered {} places ({} nodes in total)\", map.value_count, map.places.len());\n         map\n     }\n@@ -600,48 +623,85 @@ impl Map {\n         tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n         mut filter: impl FnMut(Ty<'tcx>) -> bool,\n-        exclude: &IndexVec<Local, bool>,\n+        exclude: BitSet<Local>,\n+        place_limit: Option<usize>,\n     ) {\n         // We use this vector as stack, pushing and popping projections.\n         let mut projection = Vec::new();\n         for (local, decl) in body.local_decls.iter_enumerated() {\n-            if !exclude[local] {\n-                self.register_with_filter_rec(tcx, local, &mut projection, decl.ty, &mut filter);\n+            if !exclude.contains(local) {\n+                self.register_with_filter_rec(\n+                    tcx,\n+                    local,\n+                    &mut projection,\n+                    decl.ty,\n+                    &mut filter,\n+                    place_limit,\n+                );\n             }\n         }\n     }\n \n     /// Potentially register the (local, projection) place and its fields, recursively.\n     ///\n-    /// Invariant: The projection must only contain fields.\n+    /// Invariant: The projection must only contain trackable elements.\n     fn register_with_filter_rec<'tcx>(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n         local: Local,\n         projection: &mut Vec<PlaceElem<'tcx>>,\n         ty: Ty<'tcx>,\n         filter: &mut impl FnMut(Ty<'tcx>) -> bool,\n+        place_limit: Option<usize>,\n     ) {\n-        // Note: The framework supports only scalars for now.\n-        if filter(ty) && ty.is_scalar() {\n-            // We know that the projection only contains trackable elements.\n-            let place = self.make_place(local, projection).unwrap();\n+        if let Some(place_limit) = place_limit && self.value_count >= place_limit {\n+            return\n+        }\n+\n+        // We know that the projection only contains trackable elements.\n+        let place = self.make_place(local, projection).unwrap();\n \n-            // Allocate a value slot if it doesn't have one.\n-            if self.places[place].value_index.is_none() {\n-                self.places[place].value_index = Some(self.value_count.into());\n-                self.value_count += 1;\n+        // Allocate a value slot if it doesn't have one, and the user requested one.\n+        if self.places[place].value_index.is_none() && filter(ty) {\n+            self.places[place].value_index = Some(self.value_count.into());\n+            self.value_count += 1;\n+        }\n+\n+        if ty.is_enum() {\n+            let discr_ty = ty.discriminant_ty(tcx);\n+            if filter(discr_ty) {\n+                let discr = *self\n+                    .projections\n+                    .entry((place, TrackElem::Discriminant))\n+                    .or_insert_with(|| {\n+                        // Prepend new child to the linked list.\n+                        let next = self.places.push(PlaceInfo::new(Some(TrackElem::Discriminant)));\n+                        self.places[next].next_sibling = self.places[place].first_child;\n+                        self.places[place].first_child = Some(next);\n+                        next\n+                    });\n+\n+                // Allocate a value slot if it doesn't have one.\n+                if self.places[discr].value_index.is_none() {\n+                    self.places[discr].value_index = Some(self.value_count.into());\n+                    self.value_count += 1;\n+                }\n             }\n         }\n \n         // Recurse with all fields of this place.\n         iter_fields(ty, tcx, |variant, field, ty| {\n-            if variant.is_some() {\n-                // Downcasts are currently not supported.\n+            if let Some(variant) = variant {\n+                projection.push(PlaceElem::Downcast(None, variant));\n+                let _ = self.make_place(local, projection);\n+                projection.push(PlaceElem::Field(field, ty));\n+                self.register_with_filter_rec(tcx, local, projection, ty, filter, place_limit);\n+                projection.pop();\n+                projection.pop();\n                 return;\n             }\n             projection.push(PlaceElem::Field(field, ty));\n-            self.register_with_filter_rec(tcx, local, projection, ty, filter);\n+            self.register_with_filter_rec(tcx, local, projection, ty, filter, place_limit);\n             projection.pop();\n         });\n     }\n@@ -684,23 +744,105 @@ impl Map {\n     }\n \n     /// Locates the given place, if it exists in the tree.\n-    pub fn find(&self, place: PlaceRef<'_>) -> Option<PlaceIndex> {\n+    pub fn find_extra(\n+        &self,\n+        place: PlaceRef<'_>,\n+        extra: impl IntoIterator<Item = TrackElem>,\n+    ) -> Option<PlaceIndex> {\n         let mut index = *self.locals.get(place.local)?.as_ref()?;\n \n         for &elem in place.projection {\n             index = self.apply(index, elem.try_into().ok()?)?;\n         }\n+        for elem in extra {\n+            index = self.apply(index, elem)?;\n+        }\n \n         Some(index)\n     }\n \n+    /// Locates the given place, if it exists in the tree.\n+    pub fn find(&self, place: PlaceRef<'_>) -> Option<PlaceIndex> {\n+        self.find_extra(place, [])\n+    }\n+\n+    /// Locates the given place and applies `Discriminant`, if it exists in the tree.\n+    pub fn find_discr(&self, place: PlaceRef<'_>) -> Option<PlaceIndex> {\n+        self.find_extra(place, [TrackElem::Discriminant])\n+    }\n+\n     /// Iterate over all direct children.\n     pub fn children(&self, parent: PlaceIndex) -> impl Iterator<Item = PlaceIndex> + '_ {\n         Children::new(self, parent)\n     }\n \n+    /// Invoke a function on the given place and all places that may alias it.\n+    ///\n+    /// In particular, when the given place has a variant downcast, we invoke the function on all\n+    /// the other variants.\n+    ///\n+    /// `tail_elem` allows to support discriminants that are not a place in MIR, but that we track\n+    /// as such.\n+    pub fn for_each_aliasing_place(\n+        &self,\n+        place: PlaceRef<'_>,\n+        tail_elem: Option<TrackElem>,\n+        f: &mut impl FnMut(PlaceIndex),\n+    ) {\n+        if place.is_indirect() {\n+            // We do not track indirect places.\n+            return;\n+        }\n+        let Some(&Some(mut index)) = self.locals.get(place.local) else {\n+            // The local is not tracked at all, so it does not alias anything.\n+            return;\n+        };\n+        let elems = place\n+            .projection\n+            .iter()\n+            .map(|&elem| elem.try_into())\n+            .chain(tail_elem.map(Ok).into_iter());\n+        for elem in elems {\n+            // A field aliases the parent place.\n+            f(index);\n+\n+            let Ok(elem) = elem else { return };\n+            let sub = self.apply(index, elem);\n+            if let TrackElem::Variant(..) | TrackElem::Discriminant = elem {\n+                // Enum variant fields and enum discriminants alias each another.\n+                self.for_each_variant_sibling(index, sub, f);\n+            }\n+            if let Some(sub) = sub {\n+                index = sub\n+            } else {\n+                return;\n+            }\n+        }\n+        self.preorder_invoke(index, f);\n+    }\n+\n+    /// Invoke the given function on all the descendants of the given place, except one branch.\n+    fn for_each_variant_sibling(\n+        &self,\n+        parent: PlaceIndex,\n+        preserved_child: Option<PlaceIndex>,\n+        f: &mut impl FnMut(PlaceIndex),\n+    ) {\n+        for sibling in self.children(parent) {\n+            let elem = self.places[sibling].proj_elem;\n+            // Only invalidate variants and discriminant. Fields (for generators) are not\n+            // invalidated by assignment to a variant.\n+            if let Some(TrackElem::Variant(..) | TrackElem::Discriminant) = elem\n+                // Only invalidate the other variants, the current one is fine.\n+                && Some(sibling) != preserved_child\n+            {\n+                self.preorder_invoke(sibling, f);\n+            }\n+        }\n+    }\n+\n     /// Invoke a function on the given place and all descendants.\n-    pub fn preorder_invoke(&self, root: PlaceIndex, f: &mut impl FnMut(PlaceIndex)) {\n+    fn preorder_invoke(&self, root: PlaceIndex, f: &mut impl FnMut(PlaceIndex)) {\n         f(root);\n         for child in self.children(root) {\n             self.preorder_invoke(child, f);\n@@ -759,6 +901,7 @@ impl<'a> Iterator for Children<'a> {\n }\n \n /// Used as the result of an operand or r-value.\n+#[derive(Debug)]\n pub enum ValueOrPlace<V> {\n     Value(V),\n     Place(PlaceIndex),\n@@ -776,6 +919,8 @@ impl<V: HasTop> ValueOrPlace<V> {\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum TrackElem {\n     Field(Field),\n+    Variant(VariantIdx),\n+    Discriminant,\n }\n \n impl<V, T> TryFrom<ProjectionElem<V, T>> for TrackElem {\n@@ -784,6 +929,7 @@ impl<V, T> TryFrom<ProjectionElem<V, T>> for TrackElem {\n     fn try_from(value: ProjectionElem<V, T>) -> Result<Self, Self::Error> {\n         match value {\n             ProjectionElem::Field(field, _) => Ok(TrackElem::Field(field)),\n+            ProjectionElem::Downcast(_, idx) => Ok(TrackElem::Variant(idx)),\n             _ => Err(()),\n         }\n     }\n@@ -824,26 +970,27 @@ pub fn iter_fields<'tcx>(\n }\n \n /// Returns all locals with projections that have their reference or address taken.\n-pub fn excluded_locals(body: &Body<'_>) -> IndexVec<Local, bool> {\n+pub fn excluded_locals(body: &Body<'_>) -> BitSet<Local> {\n     struct Collector {\n-        result: IndexVec<Local, bool>,\n+        result: BitSet<Local>,\n     }\n \n     impl<'tcx> Visitor<'tcx> for Collector {\n         fn visit_place(&mut self, place: &Place<'tcx>, context: PlaceContext, _location: Location) {\n-            if context.is_borrow()\n+            if (context.is_borrow()\n                 || context.is_address_of()\n                 || context.is_drop()\n-                || context == PlaceContext::MutatingUse(MutatingUseContext::AsmOutput)\n+                || context == PlaceContext::MutatingUse(MutatingUseContext::AsmOutput))\n+                && !place.is_indirect()\n             {\n                 // A pointer to a place could be used to access other places with the same local,\n                 // hence we have to exclude the local completely.\n-                self.result[place.local] = true;\n+                self.result.insert(place.local);\n             }\n         }\n     }\n \n-    let mut collector = Collector { result: IndexVec::from_elem(false, &body.local_decls) };\n+    let mut collector = Collector { result: BitSet::new_empty(body.local_decls.len()) };\n     collector.visit_body(body);\n     collector.result\n }\n@@ -899,6 +1046,12 @@ fn debug_with_context_rec<V: Debug + Eq>(\n     for child in map.children(place) {\n         let info_elem = map.places[child].proj_elem.unwrap();\n         let child_place_str = match info_elem {\n+            TrackElem::Discriminant => {\n+                format!(\"discriminant({})\", place_str)\n+            }\n+            TrackElem::Variant(idx) => {\n+                format!(\"({} as {:?})\", place_str, idx)\n+            }\n             TrackElem::Field(field) => {\n                 if place_str.starts_with('*') {\n                     format!(\"({}).{}\", place_str, field.index())"}, {"sha": "f3ca2337e59ca5a72455c309a359d88a1d5f4af2", "filename": "compiler/rustc_mir_transform/src/dataflow_const_prop.rs", "status": "modified", "additions": 95, "deletions": 32, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs?ref=c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6", "patch": "@@ -13,6 +13,7 @@ use rustc_mir_dataflow::value_analysis::{Map, State, TrackElem, ValueAnalysis, V\n use rustc_mir_dataflow::{lattice::FlatSet, Analysis, ResultsVisitor, SwitchIntEdgeEffects};\n use rustc_span::DUMMY_SP;\n use rustc_target::abi::Align;\n+use rustc_target::abi::VariantIdx;\n \n use crate::MirPass;\n \n@@ -30,14 +31,12 @@ impl<'tcx> MirPass<'tcx> for DataflowConstProp {\n \n     #[instrument(skip_all level = \"debug\")]\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        debug!(def_id = ?body.source.def_id());\n         if tcx.sess.mir_opt_level() < 4 && body.basic_blocks.len() > BLOCK_LIMIT {\n             debug!(\"aborted dataflow const prop due too many basic blocks\");\n             return;\n         }\n \n-        // Decide which places to track during the analysis.\n-        let map = Map::from_filter(tcx, body, Ty::is_scalar);\n-\n         // We want to have a somewhat linear runtime w.r.t. the number of statements/terminators.\n         // Let's call this number `n`. Dataflow analysis has `O(h*n)` transfer function\n         // applications, where `h` is the height of the lattice. Because the height of our lattice\n@@ -46,10 +45,10 @@ impl<'tcx> MirPass<'tcx> for DataflowConstProp {\n         // `O(num_nodes * tracked_places * n)` in terms of time complexity. Since the number of\n         // map nodes is strongly correlated to the number of tracked places, this becomes more or\n         // less `O(n)` if we place a constant limit on the number of tracked places.\n-        if tcx.sess.mir_opt_level() < 4 && map.tracked_places() > PLACE_LIMIT {\n-            debug!(\"aborted dataflow const prop due to too many tracked places\");\n-            return;\n-        }\n+        let place_limit = if tcx.sess.mir_opt_level() < 4 { Some(PLACE_LIMIT) } else { None };\n+\n+        // Decide which places to track during the analysis.\n+        let map = Map::from_filter(tcx, body, Ty::is_scalar, place_limit);\n \n         // Perform the actual dataflow analysis.\n         let analysis = ConstAnalysis::new(tcx, body, map);\n@@ -63,14 +62,31 @@ impl<'tcx> MirPass<'tcx> for DataflowConstProp {\n     }\n }\n \n-struct ConstAnalysis<'tcx> {\n+struct ConstAnalysis<'a, 'tcx> {\n     map: Map,\n     tcx: TyCtxt<'tcx>,\n+    local_decls: &'a LocalDecls<'tcx>,\n     ecx: InterpCx<'tcx, 'tcx, DummyMachine>,\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n-impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n+impl<'tcx> ConstAnalysis<'_, 'tcx> {\n+    fn eval_discriminant(\n+        &self,\n+        enum_ty: Ty<'tcx>,\n+        variant_index: VariantIdx,\n+    ) -> Option<ScalarTy<'tcx>> {\n+        if !enum_ty.is_enum() {\n+            return None;\n+        }\n+        let discr = enum_ty.discriminant_for_variant(self.tcx, variant_index)?;\n+        let discr_layout = self.tcx.layout_of(self.param_env.and(discr.ty)).ok()?;\n+        let discr_value = Scalar::try_from_uint(discr.val, discr_layout.size)?;\n+        Some(ScalarTy(discr_value, discr.ty))\n+    }\n+}\n+\n+impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'_, 'tcx> {\n     type Value = FlatSet<ScalarTy<'tcx>>;\n \n     const NAME: &'static str = \"ConstAnalysis\";\n@@ -79,6 +95,25 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n         &self.map\n     }\n \n+    fn handle_statement(&self, statement: &Statement<'tcx>, state: &mut State<Self::Value>) {\n+        match statement.kind {\n+            StatementKind::SetDiscriminant { box ref place, variant_index } => {\n+                state.flood_discr(place.as_ref(), &self.map);\n+                if self.map.find_discr(place.as_ref()).is_some() {\n+                    let enum_ty = place.ty(self.local_decls, self.tcx).ty;\n+                    if let Some(discr) = self.eval_discriminant(enum_ty, variant_index) {\n+                        state.assign_discr(\n+                            place.as_ref(),\n+                            ValueOrPlace::Value(FlatSet::Elem(discr)),\n+                            &self.map,\n+                        );\n+                    }\n+                }\n+            }\n+            _ => self.super_statement(statement, state),\n+        }\n+    }\n+\n     fn handle_assign(\n         &self,\n         target: Place<'tcx>,\n@@ -87,36 +122,47 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n     ) {\n         match rvalue {\n             Rvalue::Aggregate(kind, operands) => {\n-                let target = self.map().find(target.as_ref());\n-                if let Some(target) = target {\n-                    state.flood_idx_with(target, self.map(), FlatSet::Bottom);\n-                    let field_based = match **kind {\n-                        AggregateKind::Tuple | AggregateKind::Closure(..) => true,\n-                        AggregateKind::Adt(def_id, ..) => {\n-                            matches!(self.tcx.def_kind(def_id), DefKind::Struct)\n+                state.flood_with(target.as_ref(), self.map(), FlatSet::Bottom);\n+                if let Some(target_idx) = self.map().find(target.as_ref()) {\n+                    let (variant_target, variant_index) = match **kind {\n+                        AggregateKind::Tuple | AggregateKind::Closure(..) => {\n+                            (Some(target_idx), None)\n                         }\n-                        _ => false,\n+                        AggregateKind::Adt(def_id, variant_index, ..) => {\n+                            match self.tcx.def_kind(def_id) {\n+                                DefKind::Struct => (Some(target_idx), None),\n+                                DefKind::Enum => (Some(target_idx), Some(variant_index)),\n+                                _ => (None, None),\n+                            }\n+                        }\n+                        _ => (None, None),\n                     };\n-                    if field_based {\n+                    if let Some(target) = variant_target {\n                         for (field_index, operand) in operands.iter().enumerate() {\n                             if let Some(field) = self\n                                 .map()\n                                 .apply(target, TrackElem::Field(Field::from_usize(field_index)))\n                             {\n                                 let result = self.handle_operand(operand, state);\n-                                state.assign_idx(field, result, self.map());\n+                                state.insert_idx(field, result, self.map());\n                             }\n                         }\n                     }\n+                    if let Some(variant_index) = variant_index\n+                        && let Some(discr_idx) = self.map().apply(target_idx, TrackElem::Discriminant)\n+                    {\n+                        let enum_ty = target.ty(self.local_decls, self.tcx).ty;\n+                        if let Some(discr_val) = self.eval_discriminant(enum_ty, variant_index) {\n+                            state.insert_value_idx(discr_idx, FlatSet::Elem(discr_val), &self.map);\n+                        }\n+                    }\n                 }\n             }\n             Rvalue::CheckedBinaryOp(op, box (left, right)) => {\n+                // Flood everything now, so we can use `insert_value_idx` directly later.\n+                state.flood(target.as_ref(), self.map());\n+\n                 let target = self.map().find(target.as_ref());\n-                if let Some(target) = target {\n-                    // We should not track any projections other than\n-                    // what is overwritten below, but just in case...\n-                    state.flood_idx(target, self.map());\n-                }\n \n                 let value_target = target\n                     .and_then(|target| self.map().apply(target, TrackElem::Field(0_u32.into())));\n@@ -127,7 +173,8 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n                     let (val, overflow) = self.binary_op(state, *op, left, right);\n \n                     if let Some(value_target) = value_target {\n-                        state.assign_idx(value_target, ValueOrPlace::Value(val), self.map());\n+                        // We have flooded `target` earlier.\n+                        state.insert_value_idx(value_target, val, self.map());\n                     }\n                     if let Some(overflow_target) = overflow_target {\n                         let overflow = match overflow {\n@@ -142,11 +189,8 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n                             }\n                             FlatSet::Bottom => FlatSet::Bottom,\n                         };\n-                        state.assign_idx(\n-                            overflow_target,\n-                            ValueOrPlace::Value(overflow),\n-                            self.map(),\n-                        );\n+                        // We have flooded `target` earlier.\n+                        state.insert_value_idx(overflow_target, overflow, self.map());\n                     }\n                 }\n             }\n@@ -195,6 +239,9 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n                 FlatSet::Bottom => ValueOrPlace::Value(FlatSet::Bottom),\n                 FlatSet::Top => ValueOrPlace::Value(FlatSet::Top),\n             },\n+            Rvalue::Discriminant(place) => {\n+                ValueOrPlace::Value(state.get_discr(place.as_ref(), self.map()))\n+            }\n             _ => self.super_rvalue(rvalue, state),\n         }\n     }\n@@ -268,12 +315,13 @@ impl<'tcx> std::fmt::Debug for ScalarTy<'tcx> {\n     }\n }\n \n-impl<'tcx> ConstAnalysis<'tcx> {\n-    pub fn new(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, map: Map) -> Self {\n+impl<'a, 'tcx> ConstAnalysis<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, map: Map) -> Self {\n         let param_env = tcx.param_env(body.source.def_id());\n         Self {\n             map,\n             tcx,\n+            local_decls: &body.local_decls,\n             ecx: InterpCx::new(tcx, DUMMY_SP, param_env, DummyMachine),\n             param_env: param_env,\n         }\n@@ -466,6 +514,21 @@ impl<'tcx, 'map, 'a> Visitor<'tcx> for OperandCollector<'tcx, 'map, 'a> {\n             _ => (),\n         }\n     }\n+\n+    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n+        match rvalue {\n+            Rvalue::Discriminant(place) => {\n+                match self.state.get_discr(place.as_ref(), self.visitor.map) {\n+                    FlatSet::Top => (),\n+                    FlatSet::Elem(value) => {\n+                        self.visitor.before_effect.insert((location, *place), value);\n+                    }\n+                    FlatSet::Bottom => (),\n+                }\n+            }\n+            _ => self.super_rvalue(rvalue, location),\n+        }\n+    }\n }\n \n struct DummyMachine;"}, {"sha": "8a37423b2a052b23d15c5f4fc8f3a2b08e309cc7", "filename": "compiler/rustc_mir_transform/src/sroa.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs?ref=c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6", "patch": "@@ -1,5 +1,5 @@\n use crate::MirPass;\n-use rustc_index::bit_set::BitSet;\n+use rustc_index::bit_set::{BitSet, GrowableBitSet};\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::patch::MirPatch;\n use rustc_middle::mir::visit::*;\n@@ -26,10 +26,12 @@ impl<'tcx> MirPass<'tcx> for ScalarReplacementOfAggregates {\n             debug!(?replacements);\n             let all_dead_locals = replace_flattened_locals(tcx, body, replacements);\n             if !all_dead_locals.is_empty() {\n-                for local in excluded.indices() {\n-                    excluded[local] |= all_dead_locals.contains(local);\n-                }\n-                excluded.raw.resize(body.local_decls.len(), false);\n+                excluded.union(&all_dead_locals);\n+                excluded = {\n+                    let mut growable = GrowableBitSet::from(excluded);\n+                    growable.ensure(body.local_decls.len());\n+                    growable.into()\n+                };\n             } else {\n                 break;\n             }\n@@ -44,11 +46,11 @@ impl<'tcx> MirPass<'tcx> for ScalarReplacementOfAggregates {\n /// - the locals is a union or an enum;\n /// - the local's address is taken, and thus the relative addresses of the fields are observable to\n ///   client code.\n-fn escaping_locals(excluded: &IndexVec<Local, bool>, body: &Body<'_>) -> BitSet<Local> {\n+fn escaping_locals(excluded: &BitSet<Local>, body: &Body<'_>) -> BitSet<Local> {\n     let mut set = BitSet::new_empty(body.local_decls.len());\n     set.insert_range(RETURN_PLACE..=Local::from_usize(body.arg_count));\n     for (local, decl) in body.local_decls().iter_enumerated() {\n-        if decl.ty.is_union() || decl.ty.is_enum() || excluded[local] {\n+        if decl.ty.is_union() || decl.ty.is_enum() || excluded.contains(local) {\n             set.insert(local);\n         }\n     }\n@@ -172,7 +174,7 @@ fn replace_flattened_locals<'tcx>(\n     body: &mut Body<'tcx>,\n     replacements: ReplacementMap<'tcx>,\n ) -> BitSet<Local> {\n-    let mut all_dead_locals = BitSet::new_empty(body.local_decls.len());\n+    let mut all_dead_locals = BitSet::new_empty(replacements.fragments.len());\n     for (local, replacements) in replacements.fragments.iter_enumerated() {\n         if replacements.is_some() {\n             all_dead_locals.insert(local);"}, {"sha": "038e6c6bd900596a0ca54886a4f1c9e89c8c0133", "filename": "tests/mir-opt/dataflow-const-prop/enum.mutate_discriminant.DataflowConstProp.diff", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.mutate_discriminant.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.mutate_discriminant.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.mutate_discriminant.DataflowConstProp.diff?ref=c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6", "patch": "@@ -0,0 +1,26 @@\n+- // MIR for `mutate_discriminant` before DataflowConstProp\n++ // MIR for `mutate_discriminant` after DataflowConstProp\n+  \n+  fn mutate_discriminant() -> u8 {\n+      let mut _0: u8;                      // return place in scope 0 at $DIR/enum.rs:+0:29: +0:31\n+      let mut _1: std::option::Option<NonZeroUsize>; // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+      let mut _2: isize;                   // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+  \n+      bb0: {\n+          discriminant(_1) = 1;            // scope 0 at $DIR/enum.rs:+4:13: +4:34\n+          (((_1 as variant#1).0: NonZeroUsize).0: usize) = const 0_usize; // scope 0 at $DIR/enum.rs:+6:13: +6:64\n+          _2 = discriminant(_1);           // scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+          switchInt(_2) -> [0: bb1, otherwise: bb2]; // scope 0 at $DIR/enum.rs:+9:13: +12:14\n+      }\n+  \n+      bb1: {\n+          _0 = const 1_u8;                 // scope 0 at $DIR/enum.rs:+15:13: +15:20\n+          return;                          // scope 0 at $DIR/enum.rs:+16:13: +16:21\n+      }\n+  \n+      bb2: {\n+          _0 = const 2_u8;                 // scope 0 at $DIR/enum.rs:+19:13: +19:20\n+          unreachable;                     // scope 0 at $DIR/enum.rs:+20:13: +20:26\n+      }\n+  }\n+  "}, {"sha": "7ea405bd9c408057f5cec1bdae6486d3f05ed16d", "filename": "tests/mir-opt/dataflow-const-prop/enum.rs", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.rs?ref=c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6", "patch": "@@ -1,13 +1,52 @@\n // unit-test: DataflowConstProp\n \n-// Not trackable, because variants could be aliased.\n+#![feature(custom_mir, core_intrinsics, rustc_attrs)]\n+\n+use std::intrinsics::mir::*;\n+\n enum E {\n     V1(i32),\n     V2(i32)\n }\n \n-// EMIT_MIR enum.main.DataflowConstProp.diff\n-fn main() {\n+// EMIT_MIR enum.simple.DataflowConstProp.diff\n+fn simple() {\n     let e = E::V1(0);\n     let x = match e { E::V1(x) => x, E::V2(x) => x };\n }\n+\n+#[rustc_layout_scalar_valid_range_start(1)]\n+#[rustc_nonnull_optimization_guaranteed]\n+struct NonZeroUsize(usize);\n+\n+// EMIT_MIR enum.mutate_discriminant.DataflowConstProp.diff\n+#[custom_mir(dialect = \"runtime\", phase = \"post-cleanup\")]\n+fn mutate_discriminant() -> u8 {\n+    mir!(\n+        let x: Option<NonZeroUsize>;\n+        {\n+            SetDiscriminant(x, 1);\n+            // This assignment overwrites the niche in which the discriminant is stored.\n+            place!(Field(Field(Variant(x, 1), 0), 0)) = 0_usize;\n+            // So we cannot know the value of this discriminant.\n+            let a = Discriminant(x);\n+            match a {\n+                0 => bb1,\n+                _ => bad,\n+            }\n+        }\n+        bb1 = {\n+            RET = 1;\n+            Return()\n+        }\n+        bad = {\n+            RET = 2;\n+            Unreachable()\n+        }\n+    )\n+}\n+\n+fn main() {\n+    simple();\n+    mutate_discriminant();\n+}"}, {"sha": "1fb65e6584525dacb6507da722d147def7dc3dba", "filename": "tests/mir-opt/dataflow-const-prop/enum.simple.DataflowConstProp.diff", "status": "renamed", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.simple.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.simple.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.simple.DataflowConstProp.diff?ref=c78e3c735aff8aa9bad9cd2dc46b5fdbf4ca1af6", "patch": "@@ -1,8 +1,8 @@\n-- // MIR for `main` before DataflowConstProp\n-+ // MIR for `main` after DataflowConstProp\n+- // MIR for `simple` before DataflowConstProp\n++ // MIR for `simple` after DataflowConstProp\n   \n-  fn main() -> () {\n-      let mut _0: ();                      // return place in scope 0 at $DIR/enum.rs:+0:11: +0:11\n+  fn simple() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/enum.rs:+0:13: +0:13\n       let _1: E;                           // in scope 0 at $DIR/enum.rs:+1:9: +1:10\n       let mut _3: isize;                   // in scope 0 at $DIR/enum.rs:+2:23: +2:31\n       scope 1 {\n@@ -25,8 +25,10 @@\n           StorageLive(_1);                 // scope 0 at $DIR/enum.rs:+1:9: +1:10\n           _1 = E::V1(const 0_i32);         // scope 0 at $DIR/enum.rs:+1:13: +1:21\n           StorageLive(_2);                 // scope 1 at $DIR/enum.rs:+2:9: +2:10\n-          _3 = discriminant(_1);           // scope 1 at $DIR/enum.rs:+2:19: +2:20\n-          switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2]; // scope 1 at $DIR/enum.rs:+2:13: +2:20\n+-         _3 = discriminant(_1);           // scope 1 at $DIR/enum.rs:+2:19: +2:20\n+-         switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2]; // scope 1 at $DIR/enum.rs:+2:13: +2:20\n++         _3 = const 0_isize;              // scope 1 at $DIR/enum.rs:+2:19: +2:20\n++         switchInt(const 0_isize) -> [0: bb3, 1: bb1, otherwise: bb2]; // scope 1 at $DIR/enum.rs:+2:13: +2:20\n       }\n   \n       bb1: {\n@@ -50,7 +52,7 @@\n       }\n   \n       bb4: {\n-          _0 = const ();                   // scope 0 at $DIR/enum.rs:+0:11: +3:2\n+          _0 = const ();                   // scope 0 at $DIR/enum.rs:+0:13: +3:2\n           StorageDead(_2);                 // scope 1 at $DIR/enum.rs:+3:1: +3:2\n           StorageDead(_1);                 // scope 0 at $DIR/enum.rs:+3:1: +3:2\n           return;                          // scope 0 at $DIR/enum.rs:+3:2: +3:2", "previous_filename": "tests/mir-opt/dataflow-const-prop/enum.main.DataflowConstProp.diff"}]}