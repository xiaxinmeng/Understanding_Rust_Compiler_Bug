{"sha": "6d672961fbb0f5b69d39003757bddef1d1d4469a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkNjcyOTYxZmJiMGY1YjY5ZDM5MDAzNzU3YmRkZWYxZDFkNDQ2OWE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-04T13:08:11Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-15T21:49:23Z"}, "message": "thread location info through mir typeck (but do not use)", "tree": {"sha": "27633a8bef12a846963e3d0f4c4540e229a1c709", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27633a8bef12a846963e3d0f4c4540e229a1c709"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d672961fbb0f5b69d39003757bddef1d1d4469a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d672961fbb0f5b69d39003757bddef1d1d4469a", "html_url": "https://github.com/rust-lang/rust/commit/6d672961fbb0f5b69d39003757bddef1d1d4469a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d672961fbb0f5b69d39003757bddef1d1d4469a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15a2dfa324d6c10f6dfae0f874d050a009ab8f3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/15a2dfa324d6c10f6dfae0f874d050a009ab8f3d", "html_url": "https://github.com/rust-lang/rust/commit/15a2dfa324d6c10f6dfae0f874d050a009ab8f3d"}], "stats": {"total": 157, "additions": 107, "deletions": 50}, "files": [{"sha": "bea273c84a92e20ab28b328119203a715880614b", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6d672961fbb0f5b69d39003757bddef1d1d4469a/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d672961fbb0f5b69d39003757bddef1d1d4469a/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=6d672961fbb0f5b69d39003757bddef1d1d4469a", "patch": "@@ -555,6 +555,15 @@ pub struct UpvarDecl {\n \n newtype_index!(BasicBlock { DEBUG_FORMAT = \"bb{}\" });\n \n+impl BasicBlock {\n+    pub fn start_location(self) -> Location {\n+        Location {\n+            block: self,\n+            statement_index: 0,\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // BasicBlockData and Terminator\n \n@@ -638,7 +647,32 @@ pub enum TerminatorKind<'tcx> {\n         unwind: Option<BasicBlock>\n     },\n \n-    /// Drop the Lvalue and assign the new value over it\n+    /// Drop the Lvalue and assign the new value over it. This ensures\n+    /// that the assignment to LV occurs *even if* the destructor for\n+    /// lvalue unwinds. Its semantics are best explained by by the\n+    /// elaboration:\n+    ///\n+    /// ```\n+    /// BB0 {\n+    ///   DropAndReplace(LV <- RV, goto BB1, unwind BB2)\n+    /// }\n+    /// ```\n+    ///\n+    /// becomes\n+    ///\n+    /// ```\n+    /// BB0 {\n+    ///   Drop(LV, goto BB1, unwind BB2)\n+    /// }\n+    /// BB1 {\n+    ///   // LV is now unitialized\n+    ///   LV <- RV\n+    /// }\n+    /// BB2 {\n+    ///   // LV is now unitialized -- its dtor panicked\n+    ///   LV <- RV\n+    /// }\n+    /// ```\n     DropAndReplace {\n         location: Lvalue<'tcx>,\n         value: Operand<'tcx>,"}, {"sha": "0a9f673abe0608eb24208248a2ffa1b31f572925", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 72, "deletions": 49, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/6d672961fbb0f5b69d39003757bddef1d1d4469a/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d672961fbb0f5b69d39003757bddef1d1d4469a/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=6d672961fbb0f5b69d39003757bddef1d1d4469a", "patch": "@@ -139,8 +139,8 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             Lvalue::Static(box Static { def_id, ty: sty }) => {\n                 let sty = self.sanitize_type(lvalue, sty);\n                 let ty = self.tcx().type_of(def_id);\n-                let ty = self.cx.normalize(&ty);\n-                if let Err(terr) = self.cx.eq_types(self.last_span, ty, sty) {\n+                let ty = self.cx.normalize(&ty, location);\n+                if let Err(terr) = self.cx.eq_types(self.last_span, ty, sty, location) {\n                     span_mirbug!(\n                         self, lvalue, \"bad static type ({:?}: {:?}): {:?}\",\n                         ty, sty, terr);\n@@ -165,7 +165,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                            base: LvalueTy<'tcx>,\n                            pi: &LvalueElem<'tcx>,\n                            lvalue: &Lvalue<'tcx>,\n-                           _: Location)\n+                           location: Location)\n                            -> LvalueTy<'tcx> {\n         debug!(\"sanitize_projection: {:?} {:?} {:?}\", base, pi, lvalue);\n         let tcx = self.tcx();\n@@ -254,9 +254,9 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 },\n             ProjectionElem::Field(field, fty) => {\n                 let fty = self.sanitize_type(lvalue, fty);\n-                match self.field_ty(lvalue, base, field) {\n+                match self.field_ty(lvalue, base, field, location) {\n                     Ok(ty) => {\n-                        if let Err(terr) = self.cx.eq_types(span, ty, fty) {\n+                        if let Err(terr) = self.cx.eq_types(span, ty, fty, location) {\n                             span_mirbug!(\n                                 self, lvalue, \"bad field access ({:?}: {:?}): {:?}\",\n                                 ty, fty, terr);\n@@ -281,7 +281,8 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     fn field_ty(&mut self,\n                 parent: &fmt::Debug,\n                 base_ty: LvalueTy<'tcx>,\n-                field: Field)\n+                field: Field,\n+                location: Location)\n                 -> Result<Ty<'tcx>, FieldAccessError>\n     {\n         let tcx = self.tcx();\n@@ -329,7 +330,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         };\n \n         if let Some(field) = variant.fields.get(field.index()) {\n-            Ok(self.cx.normalize(&field.ty(tcx, substs)))\n+            Ok(self.cx.normalize(&field.ty(tcx, substs), location))\n         } else {\n             Err(FieldAccessError::OutOfRange { field_count: variant.fields.len() })\n         }\n@@ -371,15 +372,15 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         infer_ok.value\n     }\n \n-    fn sub_types(&mut self, sub: Ty<'tcx>, sup: Ty<'tcx>)\n+    fn sub_types(&mut self, sub: Ty<'tcx>, sup: Ty<'tcx>, _at_location: Location)\n                  -> infer::UnitResult<'tcx>\n     {\n         self.infcx.at(&self.misc(self.last_span), self.param_env)\n                   .sup(sup, sub)\n                   .map(|ok| self.register_infer_ok_obligations(ok))\n     }\n \n-    fn eq_types(&mut self, span: Span, a: Ty<'tcx>, b: Ty<'tcx>)\n+    fn eq_types(&mut self, span: Span, a: Ty<'tcx>, b: Ty<'tcx>, _at_location: Location)\n                 -> infer::UnitResult<'tcx>\n     {\n         self.infcx.at(&self.misc(span), self.param_env)\n@@ -391,14 +392,17 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn check_stmt(&mut self, mir: &Mir<'tcx>, stmt: &Statement<'tcx>) {\n+    fn check_stmt(&mut self,\n+                  mir: &Mir<'tcx>,\n+                  stmt: &Statement<'tcx>,\n+                  location: Location) {\n         debug!(\"check_stmt: {:?}\", stmt);\n         let tcx = self.tcx();\n         match stmt.kind {\n             StatementKind::Assign(ref lv, ref rv) => {\n                 let lv_ty = lv.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = rv.ty(mir, tcx);\n-                if let Err(terr) = self.sub_types(rv_ty, lv_ty) {\n+                if let Err(terr) = self.sub_types(rv_ty, lv_ty, location.successor_within_block()) {\n                     span_mirbug!(self, stmt, \"bad assignment ({:?} = {:?}): {:?}\",\n                                  lv_ty, rv_ty, terr);\n                 }\n@@ -432,7 +436,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n     fn check_terminator(&mut self,\n                         mir: &Mir<'tcx>,\n-                        term: &Terminator<'tcx>) {\n+                        term: &Terminator<'tcx>,\n+                        location: Location) {\n         debug!(\"check_terminator: {:?}\", term);\n         let tcx = self.tcx();\n         match term.kind {\n@@ -450,18 +455,30 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             TerminatorKind::DropAndReplace {\n                 ref location,\n                 ref value,\n-                ..\n+                target,\n+                unwind,\n             } => {\n                 let lv_ty = location.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = value.ty(mir, tcx);\n-                if let Err(terr) = self.sub_types(rv_ty, lv_ty) {\n+\n+                if let Err(terr) = self.sub_types(rv_ty, lv_ty, target.start_location()) {\n                     span_mirbug!(self, term, \"bad DropAndReplace ({:?} = {:?}): {:?}\",\n                                  lv_ty, rv_ty, terr);\n                 }\n+\n+                // Subtle: this assignment occurs at the start of\n+                // *both* blocks, so we need to ensure that it holds\n+                // at both locations.\n+                if let Some(unwind) = unwind {\n+                    if let Err(terr) = self.sub_types(rv_ty, lv_ty, unwind.start_location()) {\n+                        span_mirbug!(self, term, \"bad DropAndReplace ({:?} = {:?}): {:?}\",\n+                                     lv_ty, rv_ty, terr);\n+                    }\n+                }\n             }\n             TerminatorKind::SwitchInt { ref discr, switch_ty, .. } => {\n                 let discr_ty = discr.ty(mir, tcx);\n-                if let Err(terr) = self.sub_types(discr_ty, switch_ty) {\n+                if let Err(terr) = self.sub_types(discr_ty, switch_ty, location) {\n                     span_mirbug!(self, term, \"bad SwitchInt ({:?} on {:?}): {:?}\",\n                                  switch_ty, discr_ty, terr);\n                 }\n@@ -483,13 +500,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     }\n                 };\n                 let sig = tcx.erase_late_bound_regions(&sig);\n-                let sig = self.normalize(&sig);\n+                let sig = self.normalize(&sig, location);\n                 self.check_call_dest(mir, term, &sig, destination);\n \n                 if self.is_box_free(func) {\n-                    self.check_box_free_inputs(mir, term, &sig, args);\n+                    self.check_box_free_inputs(mir, term, &sig, args, location);\n                 } else {\n-                    self.check_call_inputs(mir, term, &sig, args);\n+                    self.check_call_inputs(mir, term, &sig, args, location);\n                 }\n             }\n             TerminatorKind::Assert { ref cond, ref msg, .. } => {\n@@ -512,7 +529,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 match mir.yield_ty {\n                     None => span_mirbug!(self, term, \"yield in non-generator\"),\n                     Some(ty) => {\n-                        if let Err(terr) = self.sub_types(value_ty, ty) {\n+                        if let Err(terr) = self.sub_types(value_ty, ty, location) {\n                             span_mirbug!(self,\n                                 term,\n                                 \"type of yield value is {:?}, but the yield type is {:?}: {:?}\",\n@@ -533,9 +550,11 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                        destination: &Option<(Lvalue<'tcx>, BasicBlock)>) {\n         let tcx = self.tcx();\n         match *destination {\n-            Some((ref dest, _)) => {\n+            Some((ref dest, target_block)) => {\n                 let dest_ty = dest.ty(mir, tcx).to_ty(tcx);\n-                if let Err(terr) = self.sub_types(sig.output(), dest_ty) {\n+                if let Err(terr) = self.sub_types(sig.output(),\n+                                                  dest_ty,\n+                                                  target_block.start_location()) {\n                     span_mirbug!(self, term,\n                                  \"call dest mismatch ({:?} <- {:?}): {:?}\",\n                                  dest_ty, sig.output(), terr);\n@@ -554,7 +573,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                          mir: &Mir<'tcx>,\n                          term: &Terminator<'tcx>,\n                          sig: &ty::FnSig<'tcx>,\n-                         args: &[Operand<'tcx>])\n+                         args: &[Operand<'tcx>],\n+                         location: Location)\n     {\n         debug!(\"check_call_inputs({:?}, {:?})\", sig, args);\n         if args.len() < sig.inputs().len() ||\n@@ -563,7 +583,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n         for (n, (fn_arg, op_arg)) in sig.inputs().iter().zip(args).enumerate() {\n             let op_arg_ty = op_arg.ty(mir, self.tcx());\n-            if let Err(terr) = self.sub_types(op_arg_ty, fn_arg) {\n+            if let Err(terr) = self.sub_types(op_arg_ty, fn_arg, location) {\n                 span_mirbug!(self, term, \"bad arg #{:?} ({:?} <- {:?}): {:?}\",\n                              n, fn_arg, op_arg_ty, terr);\n             }\n@@ -587,7 +607,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                              mir: &Mir<'tcx>,\n                              term: &Terminator<'tcx>,\n                              sig: &ty::FnSig<'tcx>,\n-                             args: &[Operand<'tcx>])\n+                             args: &[Operand<'tcx>],\n+                             location: Location)\n     {\n         debug!(\"check_box_free_inputs\");\n \n@@ -621,69 +642,69 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        if let Err(terr) = self.sub_types(arg_ty, pointee_ty) {\n+        if let Err(terr) = self.sub_types(arg_ty, pointee_ty, location) {\n             span_mirbug!(self, term, \"bad box_free arg ({:?} <- {:?}): {:?}\",\n                          pointee_ty, arg_ty, terr);\n         }\n     }\n \n-    fn check_iscleanup(&mut self, mir: &Mir<'tcx>, block: &BasicBlockData<'tcx>)\n+    fn check_iscleanup(&mut self, mir: &Mir<'tcx>, block_data: &BasicBlockData<'tcx>)\n     {\n-        let is_cleanup = block.is_cleanup;\n-        self.last_span = block.terminator().source_info.span;\n-        match block.terminator().kind {\n+        let is_cleanup = block_data.is_cleanup;\n+        self.last_span = block_data.terminator().source_info.span;\n+        match block_data.terminator().kind {\n             TerminatorKind::Goto { target } =>\n-                self.assert_iscleanup(mir, block, target, is_cleanup),\n+                self.assert_iscleanup(mir, block_data, target, is_cleanup),\n             TerminatorKind::SwitchInt { ref targets, .. } => {\n                 for target in targets {\n-                    self.assert_iscleanup(mir, block, *target, is_cleanup);\n+                    self.assert_iscleanup(mir, block_data, *target, is_cleanup);\n                 }\n             }\n             TerminatorKind::Resume => {\n                 if !is_cleanup {\n-                    span_mirbug!(self, block, \"resume on non-cleanup block!\")\n+                    span_mirbug!(self, block_data, \"resume on non-cleanup block!\")\n                 }\n             }\n             TerminatorKind::Return => {\n                 if is_cleanup {\n-                    span_mirbug!(self, block, \"return on cleanup block\")\n+                    span_mirbug!(self, block_data, \"return on cleanup block\")\n                 }\n             }\n             TerminatorKind::GeneratorDrop { .. } => {\n                 if is_cleanup {\n-                    span_mirbug!(self, block, \"generator_drop in cleanup block\")\n+                    span_mirbug!(self, block_data, \"generator_drop in cleanup block\")\n                 }\n             }\n             TerminatorKind::Yield { resume, drop, .. } => {\n                 if is_cleanup {\n-                    span_mirbug!(self, block, \"yield in cleanup block\")\n+                    span_mirbug!(self, block_data, \"yield in cleanup block\")\n                 }\n-                self.assert_iscleanup(mir, block, resume, is_cleanup);\n+                self.assert_iscleanup(mir, block_data, resume, is_cleanup);\n                 if let Some(drop) = drop {\n-                    self.assert_iscleanup(mir, block, drop, is_cleanup);\n+                    self.assert_iscleanup(mir, block_data, drop, is_cleanup);\n                 }\n             }\n             TerminatorKind::Unreachable => {}\n             TerminatorKind::Drop { target, unwind, .. } |\n             TerminatorKind::DropAndReplace { target, unwind, .. } |\n             TerminatorKind::Assert { target, cleanup: unwind, .. } => {\n-                self.assert_iscleanup(mir, block, target, is_cleanup);\n+                self.assert_iscleanup(mir, block_data, target, is_cleanup);\n                 if let Some(unwind) = unwind {\n                     if is_cleanup {\n-                        span_mirbug!(self, block, \"unwind on cleanup block\")\n+                        span_mirbug!(self, block_data, \"unwind on cleanup block\")\n                     }\n-                    self.assert_iscleanup(mir, block, unwind, true);\n+                    self.assert_iscleanup(mir, block_data, unwind, true);\n                 }\n             }\n             TerminatorKind::Call { ref destination, cleanup, .. } => {\n                 if let &Some((_, target)) = destination {\n-                    self.assert_iscleanup(mir, block, target, is_cleanup);\n+                    self.assert_iscleanup(mir, block_data, target, is_cleanup);\n                 }\n                 if let Some(cleanup) = cleanup {\n                     if is_cleanup {\n-                        span_mirbug!(self, block, \"cleanup on cleanup block\")\n+                        span_mirbug!(self, block_data, \"cleanup on cleanup block\")\n                     }\n-                    self.assert_iscleanup(mir, block, cleanup, true);\n+                    self.assert_iscleanup(mir, block_data, cleanup, true);\n                 }\n             }\n             TerminatorKind::FalseEdges { real_target, ref imaginary_targets } => {\n@@ -744,21 +765,23 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             self.check_local(mir, local, local_decl);\n         }\n \n-        for block in mir.basic_blocks() {\n-            for stmt in &block.statements {\n+        for (block, block_data) in mir.basic_blocks().iter_enumerated() {\n+            let mut location = Location { block, statement_index: 0 };\n+            for stmt in &block_data.statements {\n                 if stmt.source_info.span != DUMMY_SP {\n                     self.last_span = stmt.source_info.span;\n                 }\n-                self.check_stmt(mir, stmt);\n+                self.check_stmt(mir, stmt, location);\n+                location.statement_index += 1;\n             }\n \n-            self.check_terminator(mir, block.terminator());\n-            self.check_iscleanup(mir, block);\n+            self.check_terminator(mir, block_data.terminator(), location);\n+            self.check_iscleanup(mir, block_data);\n         }\n     }\n \n \n-    fn normalize<T>(&mut self, value: &T) -> T\n+    fn normalize<T>(&mut self, value: &T, _location: Location) -> T\n         where T: fmt::Debug + TypeFoldable<'tcx>\n     {\n         let mut selcx = traits::SelectionContext::new(self.infcx);"}]}