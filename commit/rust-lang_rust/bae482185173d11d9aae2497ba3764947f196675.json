{"sha": "bae482185173d11d9aae2497ba3764947f196675", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhZTQ4MjE4NTE3M2QxMWQ5YWFlMjQ5N2JhMzc2NDk0N2YxOTY2NzU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-30T00:26:16Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-30T00:26:16Z"}, "message": "librustc: De-export typeck. rs=deexporting", "tree": {"sha": "d970874fd40569814f961143674a2ce7603b1231", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d970874fd40569814f961143674a2ce7603b1231"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bae482185173d11d9aae2497ba3764947f196675", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bae482185173d11d9aae2497ba3764947f196675", "html_url": "https://github.com/rust-lang/rust/commit/bae482185173d11d9aae2497ba3764947f196675", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bae482185173d11d9aae2497ba3764947f196675/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c25703ccb860e039aedd9454d38f5c0dc7635a77", "url": "https://api.github.com/repos/rust-lang/rust/commits/c25703ccb860e039aedd9454d38f5c0dc7635a77", "html_url": "https://github.com/rust-lang/rust/commit/c25703ccb860e039aedd9454d38f5c0dc7635a77"}], "stats": {"total": 845, "additions": 382, "deletions": 463}, "files": [{"sha": "4e4fc564c2384666ea73d9e9dabb6494aec04f50", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=bae482185173d11d9aae2497ba3764947f196675", "patch": "@@ -81,9 +81,10 @@ pub trait ast_conv {\n     fn ty_infer(span: span) -> ty::t;\n }\n \n-fn get_region_reporting_err(tcx: ty::ctxt,\n-                            span: span,\n-                            res: Result<ty::Region, ~str>) -> ty::Region {\n+pub fn get_region_reporting_err(tcx: ty::ctxt,\n+                                span: span,\n+                                res: Result<ty::Region, ~str>)\n+                             -> ty::Region {\n \n     match res {\n       result::Ok(r) => r,\n@@ -94,7 +95,7 @@ fn get_region_reporting_err(tcx: ty::ctxt,\n     }\n }\n \n-fn ast_region_to_region<AC: ast_conv, RS: region_scope Copy Durable>(\n+pub fn ast_region_to_region<AC: ast_conv, RS: region_scope Copy Durable>(\n     self: AC, rscope: RS, span: span, a_r: @ast::region) -> ty::Region {\n \n     let res = match a_r.node {\n@@ -107,7 +108,7 @@ fn ast_region_to_region<AC: ast_conv, RS: region_scope Copy Durable>(\n     get_region_reporting_err(self.tcx(), span, res)\n }\n \n-fn ast_path_to_substs_and_ty<AC: ast_conv, RS: region_scope Copy Durable>(\n+pub fn ast_path_to_substs_and_ty<AC: ast_conv, RS: region_scope Copy Durable>(\n     self: AC, rscope: RS, did: ast::def_id,\n     path: @ast::path) -> ty_param_substs_and_ty {\n \n@@ -174,13 +175,13 @@ pub fn ast_path_to_ty<AC: ast_conv, RS: region_scope Copy Durable>(\n     return {substs: substs, ty: ty};\n }\n \n-const NO_REGIONS: uint = 1;\n-const NO_TPS: uint = 2;\n+pub const NO_REGIONS: uint = 1;\n+pub const NO_TPS: uint = 2;\n \n // Parses the programmer's textual representation of a type into our\n // internal notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID:\n-fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Durable>(\n+pub fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Durable>(\n     self: AC, rscope: RS, &&ast_ty: @ast::Ty) -> ty::t {\n \n     fn ast_mt_to_mt<AC: ast_conv, RS: region_scope Copy Durable>(\n@@ -405,7 +406,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Durable>(\n     return typ;\n }\n \n-fn ty_of_arg<AC: ast_conv, RS: region_scope Copy Durable>(\n+pub fn ty_of_arg<AC: ast_conv, RS: region_scope Copy Durable>(\n     self: AC, rscope: RS, a: ast::arg,\n     expected_ty: Option<ty::arg>) -> ty::arg {\n \n@@ -451,10 +452,10 @@ fn ty_of_arg<AC: ast_conv, RS: region_scope Copy Durable>(\n     arg {mode: mode, ty: ty}\n }\n \n-type expected_tys = Option<{inputs: ~[ty::arg],\n-                            output: ty::t}>;\n+pub type expected_tys = Option<{inputs: ~[ty::arg],\n+                                output: ty::t}>;\n \n-fn ty_of_fn_decl<AC: ast_conv, RS: region_scope Copy Durable>(\n+pub fn ty_of_fn_decl<AC: ast_conv, RS: region_scope Copy Durable>(\n     self: AC, rscope: RS,\n     ast_proto: ast::Proto,\n     purity: ast::purity,\n@@ -463,8 +464,7 @@ fn ty_of_fn_decl<AC: ast_conv, RS: region_scope Copy Durable>(\n     opt_region: Option<@ast::region>,\n     decl: ast::fn_decl,\n     expected_tys: expected_tys,\n-    span: span) -> ty::FnTy\n-{\n+    span: span) -> ty::FnTy {\n     debug!(\"ty_of_fn_decl\");\n     do indent {\n         // resolve the function bound region in the original region"}, {"sha": "d3a56055a5a6040895d7764edaf26cbe81695a9e", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 85, "deletions": 86, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=bae482185173d11d9aae2497ba3764947f196675", "patch": "@@ -156,15 +156,15 @@ pub type self_info = {\n /// Here, the function `foo()` and the closure passed to\n /// `bar()` will each have their own `fn_ctxt`, but they will\n /// share the inherited fields.\n-struct inherited {\n+pub struct inherited {\n     infcx: @infer::InferCtxt,\n     locals: HashMap<ast::node_id, ty::t>,\n     node_types: HashMap<ast::node_id, ty::t>,\n     node_type_substs: HashMap<ast::node_id, ty::substs>,\n     adjustments: HashMap<ast::node_id, @ty::AutoAdjustment>\n }\n \n-enum FnKind { ForLoop, DoBlock, Vanilla }\n+pub enum FnKind { ForLoop, DoBlock, Vanilla }\n \n pub struct fn_ctxt {\n     // var_bindings, locals and next_var_id are shared\n@@ -206,7 +206,7 @@ pub struct fn_ctxt {\n     ccx: @crate_ctxt,\n }\n \n-fn blank_inherited(ccx: @crate_ctxt) -> @inherited {\n+pub fn blank_inherited(ccx: @crate_ctxt) -> @inherited {\n     @inherited {\n         infcx: infer::new_infer_ctxt(ccx.tcx),\n         locals: HashMap(),\n@@ -217,8 +217,8 @@ fn blank_inherited(ccx: @crate_ctxt) -> @inherited {\n }\n \n // Used by check_const and check_enum_variants\n-fn blank_fn_ctxt(ccx: @crate_ctxt, rty: ty::t,\n-                 region_bnd: ast::node_id) -> @fn_ctxt {\n+pub fn blank_fn_ctxt(ccx: @crate_ctxt, rty: ty::t,\n+                     region_bnd: ast::node_id) -> @fn_ctxt {\n // It's kind of a kludge to manufacture a fake function context\n // and statement context, but we might as well do write the code only once\n     @fn_ctxt {\n@@ -242,11 +242,11 @@ pub fn check_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n     visit::visit_crate(*crate, (), visit);\n }\n \n-fn check_bare_fn(ccx: @crate_ctxt,\n-                 decl: &ast::fn_decl,\n-                 body: ast::blk,\n-                 id: ast::node_id,\n-                 self_info: Option<self_info>) {\n+pub fn check_bare_fn(ccx: @crate_ctxt,\n+                     decl: &ast::fn_decl,\n+                     body: ast::blk,\n+                     id: ast::node_id,\n+                     self_info: Option<self_info>) {\n     let fty = ty::node_id_to_type(ccx.tcx, id);\n     match ty::get(fty).sty {\n         ty::ty_fn(ref fn_ty) => {\n@@ -257,13 +257,13 @@ fn check_bare_fn(ccx: @crate_ctxt,\n     }\n }\n \n-fn check_fn(ccx: @crate_ctxt,\n-            self_info: Option<self_info>,\n-            fn_ty: &ty::FnTy,\n-            decl: &ast::fn_decl,\n-            body: ast::blk,\n-            fn_kind: FnKind,\n-            old_fcx: Option<@fn_ctxt>) {\n+pub fn check_fn(ccx: @crate_ctxt,\n+                self_info: Option<self_info>,\n+                fn_ty: &ty::FnTy,\n+                decl: &ast::fn_decl,\n+                body: ast::blk,\n+                fn_kind: FnKind,\n+                old_fcx: Option<@fn_ctxt>) {\n \n     let tcx = ccx.tcx;\n     let indirect_ret = match fn_kind {\n@@ -487,17 +487,17 @@ fn check_fn(ccx: @crate_ctxt,\n     }\n }\n \n-fn check_method(ccx: @crate_ctxt, method: @ast::method,\n-                self_ty: ty::t, self_impl_def_id: ast::def_id) {\n+pub fn check_method(ccx: @crate_ctxt, method: @ast::method,\n+                    self_ty: ty::t, self_impl_def_id: ast::def_id) {\n     let self_info = {self_ty: self_ty,\n                      self_id: method.self_id,\n                      def_id: self_impl_def_id,\n                      explicit_self: method.self_ty };\n     check_bare_fn(ccx, &method.decl, method.body, method.id, Some(self_info));\n }\n \n-fn check_no_duplicate_fields(tcx: ty::ctxt, fields:\n-                             ~[(ast::ident, span)]) {\n+pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n+                                 fields: ~[(ast::ident, span)]) {\n     let field_names = HashMap();\n \n     for fields.each |p| {\n@@ -516,11 +516,10 @@ fn check_no_duplicate_fields(tcx: ty::ctxt, fields:\n           }\n         }\n     }\n-\n }\n \n-fn check_struct(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n-                id: ast::node_id, span: span) {\n+pub fn check_struct(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n+                    id: ast::node_id, span: span) {\n     let tcx = ccx.tcx;\n     let self_ty = ty::node_id_to_type(tcx, id);\n \n@@ -542,7 +541,7 @@ fn check_struct(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n     check_instantiable(ccx.tcx, span, id);\n }\n \n-fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n+pub fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n     debug!(\"check_item(it.id=%d, it.ident=%s)\",\n            it.id,\n            ty::item_path_str(ccx.tcx, local_def(it.id)));\n@@ -617,7 +616,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n     }\n }\n \n-impl @fn_ctxt: ast_conv {\n+pub impl @fn_ctxt: ast_conv {\n     fn tcx() -> ty::ctxt { self.ccx.tcx }\n     fn ccx() -> @crate_ctxt { self.ccx }\n \n@@ -630,7 +629,7 @@ impl @fn_ctxt: ast_conv {\n     }\n }\n \n-impl @fn_ctxt {\n+pub impl @fn_ctxt {\n     fn infcx() -> @infer::InferCtxt { self.inh.infcx }\n     fn search_in_scope_regions(br: ty::bound_region)\n         -> Result<ty::Region, ~str>\n@@ -650,7 +649,7 @@ impl @fn_ctxt {\n     }\n }\n \n-impl @fn_ctxt: region_scope {\n+pub impl @fn_ctxt: region_scope {\n     fn anon_region(span: span) -> Result<ty::Region, ~str> {\n         result::Ok(self.infcx().next_region_var_nb(span))\n     }\n@@ -662,7 +661,7 @@ impl @fn_ctxt: region_scope {\n     }\n }\n \n-impl @fn_ctxt {\n+pub impl @fn_ctxt {\n     fn tag() -> ~str { fmt!(\"%x\", ptr::addr_of(&(*self)) as uint) }\n \n     fn local_ty(span: span, nid: ast::node_id) -> ty::t {\n@@ -874,7 +873,7 @@ impl @fn_ctxt {\n     }\n }\n \n-fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> (ty::t, uint) {\n+pub fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> (ty::t, uint) {\n     /*!\n      *\n      * Autoderefs the type `t` as many times as possible, returning\n@@ -931,7 +930,7 @@ fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> (ty::t, uint) {\n }\n \n // AST fragment checking\n-fn check_lit(fcx: @fn_ctxt, lit: @ast::lit) -> ty::t {\n+pub fn check_lit(fcx: @fn_ctxt, lit: @ast::lit) -> ty::t {\n     let tcx = fcx.ccx.tcx;\n \n     match lit.node {\n@@ -961,37 +960,33 @@ pub fn valid_range_bounds(ccx: @crate_ctxt, from: @ast::expr, to: @ast::expr)\n \n pub fn check_expr_has_type(\n     fcx: @fn_ctxt, expr: @ast::expr,\n-    expected: ty::t) -> bool\n-{\n+    expected: ty::t) -> bool {\n     do check_expr_with_unifier(fcx, expr, Some(expected)) {\n         demand::suptype(fcx, expr.span, expected, fcx.expr_ty(expr));\n     }\n }\n \n-fn check_expr_coercable_to_type(\n+pub fn check_expr_coercable_to_type(\n     fcx: @fn_ctxt, expr: @ast::expr,\n-    expected: ty::t) -> bool\n-{\n+    expected: ty::t) -> bool {\n     do check_expr_with_unifier(fcx, expr, Some(expected)) {\n         demand::coerce(fcx, expr.span, expected, expr)\n     }\n }\n \n-fn check_expr_with_hint(\n+pub fn check_expr_with_hint(\n     fcx: @fn_ctxt, expr: @ast::expr,\n-    expected: ty::t) -> bool\n-{\n+    expected: ty::t) -> bool {\n     check_expr_with_unifier(fcx, expr, Some(expected), || ())\n }\n \n-fn check_expr_with_opt_hint(\n+pub fn check_expr_with_opt_hint(\n     fcx: @fn_ctxt, expr: @ast::expr,\n-    expected: Option<ty::t>) -> bool\n-{\n+    expected: Option<ty::t>) -> bool {\n     check_expr_with_unifier(fcx, expr, expected, || ())\n }\n \n-fn check_expr(fcx: @fn_ctxt, expr: @ast::expr) -> bool {\n+pub fn check_expr(fcx: @fn_ctxt, expr: @ast::expr) -> bool {\n     check_expr_with_unifier(fcx, expr, None, || ())\n }\n \n@@ -1060,11 +1055,11 @@ pub fn impl_self_ty(vcx: &VtableContext,\n \n // Only for fields! Returns <none> for methods>\n // Indifferent to privacy flags\n-fn lookup_field_ty(tcx: ty::ctxt,\n-                   class_id: ast::def_id,\n-                   items: &[ty::field_ty],\n-                   fieldname: ast::ident,\n-                   substs: &ty::substs) -> Option<ty::t> {\n+pub fn lookup_field_ty(tcx: ty::ctxt,\n+                       class_id: ast::def_id,\n+                       items: &[ty::field_ty],\n+                       fieldname: ast::ident,\n+                       substs: &ty::substs) -> Option<ty::t> {\n \n     let o_field = vec::find(items, |f| f.ident == fieldname);\n     do o_field.map() |f| {\n@@ -1079,15 +1074,14 @@ pub enum DerefArgs {\n     DoDerefArgs\n }\n \n-fn break_here() {\n+pub fn break_here() {\n     debug!(\"break here!\");\n }\n \n-fn check_expr_with_unifier(fcx: @fn_ctxt,\n-                           expr: @ast::expr,\n-                           expected: Option<ty::t>,\n-                           unifier: fn()) -> bool\n-{\n+pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n+                               expr: @ast::expr,\n+                               expected: Option<ty::t>,\n+                               unifier: fn()) -> bool {\n     debug!(\">> typechecking %s\", fcx.expr_to_str(expr));\n \n     // A generic function to factor out common logic from call and\n@@ -2522,7 +2516,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n     return bot;\n }\n \n-fn require_integral(fcx: @fn_ctxt, sp: span, t: ty::t) {\n+pub fn require_integral(fcx: @fn_ctxt, sp: span, t: ty::t) {\n     if !type_is_integral(fcx, sp, t) {\n         fcx.type_error_message(sp, |actual| {\n             fmt!(\"mismatched types: expected integral type but found `%s`\",\n@@ -2531,13 +2525,13 @@ fn require_integral(fcx: @fn_ctxt, sp: span, t: ty::t) {\n     }\n }\n \n-fn check_decl_initializer(fcx: @fn_ctxt, nid: ast::node_id,\n-                          init: @ast::expr) -> bool {\n+pub fn check_decl_initializer(fcx: @fn_ctxt, nid: ast::node_id,\n+                              init: @ast::expr) -> bool {\n     let local_ty = fcx.local_ty(init.span, nid);\n     return check_expr_coercable_to_type(fcx, init, local_ty);\n }\n \n-fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n+pub fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n     let mut bot = false;\n     let tcx = fcx.ccx.tcx;\n \n@@ -2563,7 +2557,7 @@ fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n     return bot;\n }\n \n-fn check_stmt(fcx: @fn_ctxt, stmt: @ast::stmt) -> bool {\n+pub fn check_stmt(fcx: @fn_ctxt, stmt: @ast::stmt) -> bool {\n     let mut node_id;\n     let mut bot = false;\n     match stmt.node {\n@@ -2590,7 +2584,7 @@ fn check_stmt(fcx: @fn_ctxt, stmt: @ast::stmt) -> bool {\n     return bot;\n }\n \n-fn check_block_no_value(fcx: @fn_ctxt, blk: ast::blk) -> bool {\n+pub fn check_block_no_value(fcx: @fn_ctxt, blk: ast::blk) -> bool {\n     let bot = check_block(fcx, blk);\n     if !bot {\n         let blkty = fcx.node_ty(blk.node.id);\n@@ -2604,9 +2598,9 @@ pub fn check_block(fcx0: @fn_ctxt, blk: ast::blk) -> bool {\n     check_block_with_expected(fcx0, blk, None)\n }\n \n-fn check_block_with_expected(fcx0: @fn_ctxt,\n-                             blk: ast::blk,\n-                             expected: Option<ty::t>) -> bool {\n+pub fn check_block_with_expected(fcx0: @fn_ctxt,\n+                                 blk: ast::blk,\n+                                 expected: Option<ty::t>) -> bool {\n     let fcx = match blk.node.rules {\n       ast::unsafe_blk => @fn_ctxt {purity: ast::unsafe_fn,.. copy *fcx0},\n       ast::default_blk => fcx0\n@@ -2647,15 +2641,18 @@ fn check_block_with_expected(fcx0: @fn_ctxt,\n     }\n }\n \n-fn check_const(ccx: @crate_ctxt, _sp: span, e: @ast::expr, id: ast::node_id) {\n+pub fn check_const(ccx: @crate_ctxt,\n+                   _sp: span,\n+                   e: @ast::expr,\n+                   id: ast::node_id) {\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n     let fcx = blank_fn_ctxt(ccx, rty, e.id);\n     let declty = fcx.ccx.tcx.tcache.get(local_def(id)).ty;\n     check_const_with_ty(fcx, _sp, e, declty);\n }\n \n-fn check_const_with_ty(fcx: @fn_ctxt, _sp: span, e: @ast::expr,\n-                       declty: ty::t) {\n+pub fn check_const_with_ty(fcx: @fn_ctxt, _sp: span, e: @ast::expr,\n+                           declty: ty::t) {\n     check_expr(fcx, e);\n     let cty = fcx.expr_ty(e);\n     demand::suptype(fcx, e.span, declty, cty);\n@@ -2674,9 +2671,9 @@ fn check_const_with_ty(fcx: @fn_ctxt, _sp: span, e: @ast::expr,\n ///     enum foo { Some(@foo) }\n ///\n /// is representable, but not instantiable.\n-fn check_instantiable(tcx: ty::ctxt,\n-                      sp: span,\n-                      item_id: ast::node_id) {\n+pub fn check_instantiable(tcx: ty::ctxt,\n+                          sp: span,\n+                          item_id: ast::node_id) {\n     let item_ty = ty::node_id_to_type(tcx, item_id);\n     if !ty::is_instantiable(tcx, item_ty) {\n         tcx.sess.span_err(sp, fmt!(\"this type cannot be instantiated \\\n@@ -2686,10 +2683,10 @@ fn check_instantiable(tcx: ty::ctxt,\n     }\n }\n \n-fn check_enum_variants(ccx: @crate_ctxt,\n-                       sp: span,\n-                       +vs: ~[ast::variant],\n-                       id: ast::node_id) {\n+pub fn check_enum_variants(ccx: @crate_ctxt,\n+                           sp: span,\n+                           +vs: ~[ast::variant],\n+                           id: ast::node_id) {\n     fn do_check(ccx: @crate_ctxt, sp: span, vs: ~[ast::variant],\n                 id: ast::node_id, disr_vals: &mut ~[int], disr_val: &mut int,\n                 variants: &mut ~[ty::VariantInfo]) {\n@@ -2806,8 +2803,10 @@ pub fn lookup_def(fcx: @fn_ctxt, sp: span, id: ast::node_id) -> ast::def {\n }\n \n // Returns the type parameter count and the type for the given definition.\n-fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n-    ty_param_bounds_and_ty {\n+pub fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt,\n+                                      sp: span,\n+                                      defn: ast::def)\n+                                   -> ty_param_bounds_and_ty {\n \n     match defn {\n       ast::def_arg(nid, _, _) | ast::def_local(nid, _) |\n@@ -2949,23 +2948,23 @@ pub fn structure_of(fcx: @fn_ctxt, sp: span, typ: ty::t) -> ty::sty {\n     /*bad*/copy ty::get(structurally_resolved_type(fcx, sp, typ)).sty\n }\n \n-fn type_is_integral(fcx: @fn_ctxt, sp: span, typ: ty::t) -> bool {\n+pub fn type_is_integral(fcx: @fn_ctxt, sp: span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_integral(typ_s);\n }\n \n-fn type_is_scalar(fcx: @fn_ctxt, sp: span, typ: ty::t) -> bool {\n+pub fn type_is_scalar(fcx: @fn_ctxt, sp: span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_scalar(typ_s);\n }\n \n-fn type_is_c_like_enum(fcx: @fn_ctxt, sp: span, typ: ty::t) -> bool {\n+pub fn type_is_c_like_enum(fcx: @fn_ctxt, sp: span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_c_like_enum(fcx.ccx.tcx, typ_s);\n }\n \n-fn ast_expr_vstore_to_vstore(fcx: @fn_ctxt, e: @ast::expr, n: uint,\n-                             v: ast::expr_vstore) -> ty::vstore {\n+pub fn ast_expr_vstore_to_vstore(fcx: @fn_ctxt, e: @ast::expr, n: uint,\n+                                 v: ast::expr_vstore) -> ty::vstore {\n     match v {\n         ast::expr_vstore_fixed(None) => ty::vstore_fixed(n),\n         ast::expr_vstore_fixed(Some(u)) => {\n@@ -2985,7 +2984,7 @@ fn ast_expr_vstore_to_vstore(fcx: @fn_ctxt, e: @ast::expr, n: uint,\n }\n \n // Returns true if b contains a break that can exit from b\n-fn may_break(cx: ty::ctxt, id: ast::node_id, b: ast::blk) -> bool {\n+pub fn may_break(cx: ty::ctxt, id: ast::node_id, b: ast::blk) -> bool {\n     // First: is there an unlabeled break immediately\n     // inside the loop?\n     (loop_query(b, |e| {\n@@ -3007,10 +3006,10 @@ fn may_break(cx: ty::ctxt, id: ast::node_id, b: ast::blk) -> bool {\n         }}))\n }\n \n-fn check_bounds_are_used(ccx: @crate_ctxt,\n-                         span: span,\n-                         tps: ~[ast::ty_param],\n-                         ty: ty::t) {\n+pub fn check_bounds_are_used(ccx: @crate_ctxt,\n+                             span: span,\n+                             tps: ~[ast::ty_param],\n+                             ty: ty::t) {\n     debug!(\"check_bounds_are_used(n_tps=%u, ty=%s)\",\n            tps.len(), ppaux::ty_to_str(ccx.tcx, ty));\n \n@@ -3041,7 +3040,7 @@ fn check_bounds_are_used(ccx: @crate_ctxt,\n     }\n }\n \n-fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n+pub fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n     fn param(ccx: @crate_ctxt, n: uint) -> ty::t {\n         ty::mk_param(ccx.tcx, n, local_def(0))\n     }"}, {"sha": "153d09e82e6188fa9ef052c909d7e7f3ec421da5", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=bae482185173d11d9aae2497ba3764947f196675", "patch": "@@ -65,15 +65,16 @@ use core::vec::{len, push};\n use core::vec;\n use std::map::HashMap;\n \n-struct UniversalQuantificationResult {\n+pub struct UniversalQuantificationResult {\n     monotype: t,\n     type_variables: ~[ty::t],\n     bounds: @~[param_bounds]\n }\n \n-fn get_base_type(inference_context: @InferCtxt, span: span, original_type: t)\n-              -> Option<t> {\n-\n+pub fn get_base_type(inference_context: @InferCtxt,\n+                     span: span,\n+                     original_type: t)\n+                  -> Option<t> {\n     let resolved_type;\n     match resolve_type(inference_context,\n                      original_type,\n@@ -118,11 +119,10 @@ fn get_base_type(inference_context: @InferCtxt, span: span, original_type: t)\n }\n \n // Returns the def ID of the base type, if there is one.\n-fn get_base_type_def_id(inference_context: @InferCtxt,\n-                        span: span,\n-                        original_type: t)\n-                     -> Option<def_id> {\n-\n+pub fn get_base_type_def_id(inference_context: @InferCtxt,\n+                            span: span,\n+                            original_type: t)\n+                         -> Option<def_id> {\n     match get_base_type(inference_context, span, original_type) {\n         None => {\n             return None;\n@@ -144,7 +144,7 @@ fn get_base_type_def_id(inference_context: @InferCtxt,\n }\n \n \n-fn method_to_MethodInfo(ast_method: @method) -> @MethodInfo {\n+pub fn method_to_MethodInfo(ast_method: @method) -> @MethodInfo {\n     @{\n         did: local_def(ast_method.id),\n         n_tps: ast_method.tps.len(),\n@@ -153,7 +153,7 @@ fn method_to_MethodInfo(ast_method: @method) -> @MethodInfo {\n     }\n }\n \n-struct CoherenceInfo {\n+pub struct CoherenceInfo {\n     // Contains implementations of methods that are inherent to a type.\n     // Methods in these implementations don't need to be exported.\n     inherent_methods: HashMap<def_id,@DVec<@Impl>>,\n@@ -164,14 +164,14 @@ struct CoherenceInfo {\n \n }\n \n-fn CoherenceInfo() -> CoherenceInfo {\n+pub fn CoherenceInfo() -> CoherenceInfo {\n     CoherenceInfo {\n         inherent_methods: HashMap(),\n         extension_methods: HashMap(),\n     }\n }\n \n-fn CoherenceChecker(crate_context: @crate_ctxt) -> CoherenceChecker {\n+pub fn CoherenceChecker(crate_context: @crate_ctxt) -> CoherenceChecker {\n     CoherenceChecker {\n         crate_context: crate_context,\n         inference_context: new_infer_ctxt(crate_context.tcx),\n@@ -181,7 +181,7 @@ fn CoherenceChecker(crate_context: @crate_ctxt) -> CoherenceChecker {\n     }\n }\n \n-struct CoherenceChecker {\n+pub struct CoherenceChecker {\n     crate_context: @crate_ctxt,\n     inference_context: @InferCtxt,\n \n@@ -196,7 +196,7 @@ struct CoherenceChecker {\n     privileged_implementations: HashMap<node_id,()>,\n }\n \n-impl CoherenceChecker {\n+pub impl CoherenceChecker {\n     fn check_coherence(crate: @crate) {\n         // Check implementations and traits. This populates the tables\n         // containing the inherent methods and extension methods. It also\n@@ -1011,7 +1011,7 @@ impl CoherenceChecker {\n     }\n }\n \n-fn check_coherence(crate_context: @crate_ctxt, crate: @crate) {\n+pub fn check_coherence(crate_context: @crate_ctxt, crate: @crate) {\n     let coherence_checker = @CoherenceChecker(crate_context);\n     (*coherence_checker).check_coherence(crate);\n }"}, {"sha": "3693a2779b8a604fadddd9185ae90cf6650db53f", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 76, "deletions": 75, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=bae482185173d11d9aae2497ba3764947f196675", "patch": "@@ -61,7 +61,7 @@ use syntax::codemap;\n use syntax::print::pprust::path_to_str;\n use syntax::visit;\n \n-fn collect_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n+pub fn collect_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n \n     // FIXME (#2592): hooking into the \"intrinsic\" root module is crude.\n     // There ought to be a better approach. Attributes?\n@@ -114,15 +114,15 @@ fn collect_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n         }));\n }\n \n-impl @crate_ctxt {\n+pub impl @crate_ctxt {\n     fn to_ty<RS: region_scope Copy Durable>(\n         rs: RS, ast_ty: @ast::Ty) -> ty::t {\n \n         ast_ty_to_ty(self, rs, ast_ty)\n     }\n }\n \n-impl @crate_ctxt: ast_conv {\n+pub impl @crate_ctxt: ast_conv {\n     fn tcx() -> ty::ctxt { self.tcx }\n     fn ccx() -> @crate_ctxt { self }\n \n@@ -151,11 +151,11 @@ impl @crate_ctxt: ast_conv {\n     }\n }\n \n-fn get_enum_variant_types(ccx: @crate_ctxt,\n-                          enum_ty: ty::t,\n-                          variants: ~[ast::variant],\n-                          ty_params: ~[ast::ty_param],\n-                          rp: Option<ty::region_variance>) {\n+pub fn get_enum_variant_types(ccx: @crate_ctxt,\n+                              enum_ty: ty::t,\n+                              variants: ~[ast::variant],\n+                              ty_params: ~[ast::ty_param],\n+                              rp: Option<ty::region_variance>) {\n     let tcx = ccx.tcx;\n \n     // Create a set of parameter types shared among all the variants.\n@@ -237,7 +237,9 @@ fn get_enum_variant_types(ccx: @crate_ctxt,\n     }\n }\n \n-fn ensure_trait_methods(ccx: @crate_ctxt, id: ast::node_id, trait_ty: ty::t) {\n+pub fn ensure_trait_methods(ccx: @crate_ctxt,\n+                            id: ast::node_id,\n+                            trait_ty: ty::t) {\n     fn store_methods<T>(ccx: @crate_ctxt, id: ast::node_id,\n                         stuff: ~[T], f: &fn(v: &T) -> ty::method) {\n         ty::store_trait_methods(ccx.tcx, id, @vec::map(stuff, f));\n@@ -318,11 +320,11 @@ fn ensure_trait_methods(ccx: @crate_ctxt, id: ast::node_id, trait_ty: ty::t) {\n     }\n }\n \n-fn ensure_supertraits(ccx: @crate_ctxt,\n-                      id: ast::node_id,\n-                      sp: codemap::span,\n-                      rp: Option<ty::region_variance>,\n-                      trait_refs: &[@ast::trait_ref]) {\n+pub fn ensure_supertraits(ccx: @crate_ctxt,\n+                          id: ast::node_id,\n+                          sp: codemap::span,\n+                          rp: Option<ty::region_variance>,\n+                          trait_refs: &[@ast::trait_ref]) {\n     let tcx = ccx.tcx;\n     if tcx.supertraits.contains_key(local_def(id)) { return; }\n \n@@ -355,13 +357,12 @@ fn ensure_supertraits(ccx: @crate_ctxt,\n  * - trait_substs: the substitutions used on the type of the trait\n  * - self_ty: the self type of the impl\n  */\n-fn compare_impl_method(tcx: ty::ctxt,\n-                       impl_tps: uint,\n-                       cm: &ConvertedMethod,\n-                       trait_m: &ty::method,\n-                       trait_substs: &ty::substs,\n-                       self_ty: ty::t)\n-{\n+pub fn compare_impl_method(tcx: ty::ctxt,\n+                           impl_tps: uint,\n+                           cm: &ConvertedMethod,\n+                           trait_m: &ty::method,\n+                           trait_substs: &ty::substs,\n+                           self_ty: ty::t) {\n     debug!(\"compare_impl_method()\");\n     let _indenter = indenter();\n \n@@ -503,12 +504,12 @@ fn compare_impl_method(tcx: ty::ctxt,\n     }\n }\n \n-fn check_methods_against_trait(ccx: @crate_ctxt,\n-                               tps: ~[ast::ty_param],\n-                               rp: Option<ty::region_variance>,\n-                               selfty: ty::t,\n-                               a_trait_ty: @ast::trait_ref,\n-                               impl_ms: ~[ConvertedMethod]) {\n+pub fn check_methods_against_trait(ccx: @crate_ctxt,\n+                                   tps: ~[ast::ty_param],\n+                                   rp: Option<ty::region_variance>,\n+                                   selfty: ty::t,\n+                                   a_trait_ty: @ast::trait_ref,\n+                                   impl_ms: ~[ConvertedMethod]) {\n \n     let tcx = ccx.tcx;\n     let (did, tpt) = instantiate_trait_ref(ccx, a_trait_ty, rp);\n@@ -554,10 +555,10 @@ fn check_methods_against_trait(ccx: @crate_ctxt,\n     }\n } // fn\n \n-fn convert_field(ccx: @crate_ctxt,\n-                 rp: Option<ty::region_variance>,\n-                 bounds: @~[ty::param_bounds],\n-                 v: @ast::struct_field) {\n+pub fn convert_field(ccx: @crate_ctxt,\n+                     rp: Option<ty::region_variance>,\n+                     bounds: @~[ty::param_bounds],\n+                     v: @ast::struct_field) {\n     let tt = ccx.to_ty(type_rscope(rp), v.node.ty);\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n     /* add the field to the tcache */\n@@ -567,17 +568,18 @@ fn convert_field(ccx: @crate_ctxt,\n                            ty: tt});\n }\n \n-struct ConvertedMethod {\n+pub struct ConvertedMethod {\n     mty: ty::method,\n     id: ast::node_id,\n     span: span,\n     body_id: ast::node_id\n }\n \n-fn convert_methods(ccx: @crate_ctxt,\n-                   ms: ~[@ast::method],\n-                   rp: Option<ty::region_variance>,\n-                   rcvr_bounds: @~[ty::param_bounds]) -> ~[ConvertedMethod] {\n+pub fn convert_methods(ccx: @crate_ctxt,\n+                       ms: ~[@ast::method],\n+                       rp: Option<ty::region_variance>,\n+                       rcvr_bounds: @~[ty::param_bounds])\n+                    -> ~[ConvertedMethod] {\n \n     let tcx = ccx.tcx;\n     do vec::map(ms) |m| {\n@@ -598,10 +600,10 @@ fn convert_methods(ccx: @crate_ctxt,\n     }\n }\n \n-fn ensure_no_ty_param_bounds(ccx: @crate_ctxt,\n-                             span: span,\n-                             ty_params: &[ast::ty_param],\n-                             thing: &static/str) {\n+pub fn ensure_no_ty_param_bounds(ccx: @crate_ctxt,\n+                                 span: span,\n+                                 ty_params: &[ast::ty_param],\n+                                 thing: &static/str) {\n     for ty_params.each |ty_param| {\n         if ty_param.bounds.len() > 0 {\n             ccx.tcx.sess.span_err(\n@@ -612,7 +614,7 @@ fn ensure_no_ty_param_bounds(ccx: @crate_ctxt,\n     }\n }\n \n-fn convert(ccx: @crate_ctxt, it: @ast::item) {\n+pub fn convert(ccx: @crate_ctxt, it: @ast::item) {\n     let tcx = ccx.tcx;\n     let rp = tcx.region_paramd_items.find(it.id);\n     debug!(\"convert: item %s with id %d rp %?\",\n@@ -683,12 +685,12 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n     }\n }\n \n-fn convert_struct(ccx: @crate_ctxt,\n-                  rp: Option<ty::region_variance>,\n-                  struct_def: @ast::struct_def,\n-                  +tps: ~[ast::ty_param],\n-                  tpt: ty::ty_param_bounds_and_ty,\n-                  id: ast::node_id) {\n+pub fn convert_struct(ccx: @crate_ctxt,\n+                      rp: Option<ty::region_variance>,\n+                      struct_def: @ast::struct_def,\n+                      +tps: ~[ast::ty_param],\n+                      tpt: ty::ty_param_bounds_and_ty,\n+                      id: ast::node_id) {\n     let tcx = ccx.tcx;\n \n     do option::iter(&struct_def.dtor) |dtor| {\n@@ -755,7 +757,7 @@ fn convert_struct(ccx: @crate_ctxt,\n     }\n }\n \n-fn convert_foreign(ccx: @crate_ctxt, i: @ast::foreign_item) {\n+pub fn convert_foreign(ccx: @crate_ctxt, i: @ast::foreign_item) {\n     // As above, this call populates the type table with the converted\n     // type of the foreign item. We simply write it into the node type\n     // table.\n@@ -764,9 +766,9 @@ fn convert_foreign(ccx: @crate_ctxt, i: @ast::foreign_item) {\n     ccx.tcx.tcache.insert(local_def(i.id), tpt);\n }\n \n-fn ty_of_method(ccx: @crate_ctxt,\n-                m: @ast::method,\n-                rp: Option<ty::region_variance>) -> ty::method {\n+pub fn ty_of_method(ccx: @crate_ctxt,\n+                    m: @ast::method,\n+                    rp: Option<ty::region_variance>) -> ty::method {\n     {ident: m.ident,\n      tps: ty_param_bounds(ccx, /*bad*/copy m.tps),\n      fty: ty_of_fn_decl(ccx, type_rscope(rp), ast::ProtoBare,\n@@ -778,10 +780,10 @@ fn ty_of_method(ccx: @crate_ctxt,\n      def_id: local_def(m.id)}\n }\n \n-fn ty_of_ty_method(self: @crate_ctxt,\n-                   m: ast::ty_method,\n-                   rp: Option<ty::region_variance>,\n-                   id: ast::def_id) -> ty::method {\n+pub fn ty_of_ty_method(self: @crate_ctxt,\n+                       m: ast::ty_method,\n+                       rp: Option<ty::region_variance>,\n+                       id: ast::def_id) -> ty::method {\n     {ident: m.ident,\n      tps: ty_param_bounds(self, /*bad*/copy m.tps),\n      fty: ty_of_fn_decl(self, type_rscope(rp), ast::ProtoBare,\n@@ -799,8 +801,8 @@ fn ty_of_ty_method(self: @crate_ctxt,\n   it's bound to a valid trait type. Returns the def_id for the defining\n   trait. Fails if the type is a type other than an trait type.\n  */\n-fn instantiate_trait_ref(ccx: @crate_ctxt, t: @ast::trait_ref,\n-                         rp: Option<ty::region_variance>)\n+pub fn instantiate_trait_ref(ccx: @crate_ctxt, t: @ast::trait_ref,\n+                             rp: Option<ty::region_variance>)\n     -> (ast::def_id, ty_param_substs_and_ty) {\n \n     let sp = t.path.span, err = ~\"can only implement trait types\",\n@@ -823,7 +825,7 @@ fn instantiate_trait_ref(ccx: @crate_ctxt, t: @ast::trait_ref,\n     }\n }\n \n-fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n+pub fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n     -> ty::ty_param_bounds_and_ty {\n \n     let def_id = local_def(it.id);\n@@ -916,7 +918,7 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n     }\n }\n \n-fn ty_of_foreign_item(ccx: @crate_ctxt, it: @ast::foreign_item)\n+pub fn ty_of_foreign_item(ccx: @crate_ctxt, it: @ast::foreign_item)\n     -> ty::ty_param_bounds_and_ty {\n     match /*bad*/copy it.node {\n       ast::foreign_item_fn(fn_decl, _, params) => {\n@@ -937,9 +939,9 @@ fn ty_of_foreign_item(ccx: @crate_ctxt, it: @ast::foreign_item)\n // of a newtyped Ty or a region) to ty's notion of ty param bounds, which can\n // either be user-defined traits, or one of the four built-in traits (formerly\n // known as kinds): Const, Copy, Durable, and Send.\n-fn compute_bounds(ccx: @crate_ctxt,\n-                  ast_bounds: @~[ast::ty_param_bound])\n-               -> ty::param_bounds {\n+pub fn compute_bounds(ccx: @crate_ctxt,\n+                      ast_bounds: @~[ast::ty_param_bound])\n+                   -> ty::param_bounds {\n     @do vec::flat_map(*ast_bounds) |b| {\n         match b {\n             &TraitTyParamBound(b) => {\n@@ -973,10 +975,8 @@ fn compute_bounds(ccx: @crate_ctxt,\n     }\n }\n \n-fn ty_param_bounds(ccx: @crate_ctxt,\n-                   params: ~[ast::ty_param]) -> @~[ty::param_bounds] {\n-\n-\n+pub fn ty_param_bounds(ccx: @crate_ctxt,\n+                       params: ~[ast::ty_param]) -> @~[ty::param_bounds] {\n     @do params.map |param| {\n         match ccx.tcx.ty_param_bounds.find(param.id) {\n           Some(bs) => bs,\n@@ -989,10 +989,11 @@ fn ty_param_bounds(ccx: @crate_ctxt,\n     }\n }\n \n-fn ty_of_foreign_fn_decl(ccx: @crate_ctxt,\n-                         decl: ast::fn_decl,\n-                         +ty_params: ~[ast::ty_param],\n-                         def_id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n+pub fn ty_of_foreign_fn_decl(ccx: @crate_ctxt,\n+                             decl: ast::fn_decl,\n+                             +ty_params: ~[ast::ty_param],\n+                             def_id: ast::def_id)\n+                          -> ty::ty_param_bounds_and_ty {\n     let bounds = ty_param_bounds(ccx, ty_params);\n     let rb = in_binding_rscope(empty_rscope);\n     let input_tys = decl.inputs.map(|a| ty_of_arg(ccx, rb, *a, None) );\n@@ -1012,7 +1013,7 @@ fn ty_of_foreign_fn_decl(ccx: @crate_ctxt,\n     return tpt;\n }\n \n-fn mk_ty_params(ccx: @crate_ctxt, atps: ~[ast::ty_param])\n+pub fn mk_ty_params(ccx: @crate_ctxt, atps: ~[ast::ty_param])\n     -> {bounds: @~[ty::param_bounds], params: ~[ty::t]} {\n \n     let mut i = 0u;\n@@ -1026,10 +1027,10 @@ fn mk_ty_params(ccx: @crate_ctxt, atps: ~[ast::ty_param])\n      })}\n }\n \n-fn mk_substs(ccx: @crate_ctxt,\n-             +atps: ~[ast::ty_param],\n-             rp: Option<ty::region_variance>)\n-          -> {bounds: @~[ty::param_bounds], substs: ty::substs} {\n+pub fn mk_substs(ccx: @crate_ctxt,\n+                 +atps: ~[ast::ty_param],\n+                 rp: Option<ty::region_variance>)\n+              -> {bounds: @~[ty::param_bounds], substs: ty::substs} {\n     let {bounds, params} = mk_ty_params(ccx, atps);\n     let self_r = rscope::bound_self_region(rp);\n     {"}, {"sha": "819348e744ecf6d6544189c5a8be6af5321c6ea5", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=bae482185173d11d9aae2497ba3764947f196675", "patch": "@@ -72,9 +72,12 @@ use syntax::ast::{Onceness, purity, ret_style};\n use syntax::ast;\n use syntax::codemap::span;\n \n-fn macros() { include!(\"macros.rs\"); } // FIXME(#3114): Macro import/export.\n+pub fn macros() {\n+    // FIXME(#3114): Macro import/export.\n+    include!(\"macros.rs\");\n+}\n \n-trait Combine {\n+pub trait Combine {\n     fn infcx() -> @InferCtxt;\n     fn tag() -> ~str;\n     fn a_is_expected() -> bool;\n@@ -112,9 +115,8 @@ pub struct CombineFields {\n     span: span,\n }\n \n-fn expected_found<C:Combine,T>(\n-    self: &C, +a: T, +b: T) -> ty::expected_found<T>\n-{\n+pub fn expected_found<C:Combine,T>(\n+        self: &C, +a: T, +b: T) -> ty::expected_found<T> {\n     if self.a_is_expected() {\n         ty::expected_found {expected: move a, found: move b}\n     } else {\n@@ -131,7 +133,8 @@ pub fn eq_tys<C:Combine>(self: &C, a: ty::t, b: ty::t) -> ures {\n     }\n }\n \n-fn eq_regions<C:Combine>(self: &C, a: ty::Region, b: ty::Region) -> ures {\n+pub fn eq_regions<C:Combine>(self: &C, a: ty::Region, b: ty::Region)\n+                          -> ures {\n     debug!(\"eq_regions(%s, %s)\",\n            a.inf_str(self.infcx()),\n            b.inf_str(self.infcx()));\n@@ -153,7 +156,7 @@ fn eq_regions<C:Combine>(self: &C, a: ty::Region, b: ty::Region) -> ures {\n     }\n }\n \n-fn eq_opt_regions<C:Combine>(\n+pub fn eq_opt_regions<C:Combine>(\n     self: &C,\n     a: Option<ty::Region>,\n     b: Option<ty::Region>) -> cres<Option<ty::Region>> {\n@@ -181,7 +184,7 @@ fn eq_opt_regions<C:Combine>(\n     }\n }\n \n-fn super_substs<C:Combine>(\n+pub fn super_substs<C:Combine>(\n     self: &C, did: ast::def_id,\n     a: &ty::substs, b: &ty::substs) -> cres<ty::substs> {\n \n@@ -243,7 +246,7 @@ fn super_substs<C:Combine>(\n     }\n }\n \n-fn super_tps<C:Combine>(\n+pub fn super_tps<C:Combine>(\n     self: &C, as_: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {\n \n     // Note: type parameters are always treated as *invariant*\n@@ -261,7 +264,7 @@ fn super_tps<C:Combine>(\n     }\n }\n \n-fn super_self_tys<C:Combine>(\n+pub fn super_self_tys<C:Combine>(\n     self: &C, a: Option<ty::t>, b: Option<ty::t>) -> cres<Option<ty::t>> {\n \n     // Note: the self type parameter is (currently) always treated as\n@@ -284,17 +287,16 @@ fn super_self_tys<C:Combine>(\n     }\n }\n \n-fn super_protos<C: Combine>(\n-    self: &C, p1: ast::Proto, p2: ast::Proto) -> cres<ast::Proto>\n-{\n+pub fn super_protos<C: Combine>(\n+    self: &C, p1: ast::Proto, p2: ast::Proto) -> cres<ast::Proto> {\n     if p1 == p2 {\n         Ok(p1)\n     } else {\n         Err(ty::terr_proto_mismatch(expected_found(self, p1, p2)))\n     }\n }\n \n-fn super_flds<C:Combine>(\n+pub fn super_flds<C:Combine>(\n     self: &C, a: ty::field, b: ty::field) -> cres<ty::field> {\n \n     if a.ident == b.ident {\n@@ -307,7 +309,7 @@ fn super_flds<C:Combine>(\n     }\n }\n \n-fn super_modes<C:Combine>(\n+pub fn super_modes<C:Combine>(\n     self: &C, a: ast::mode, b: ast::mode)\n     -> cres<ast::mode> {\n \n@@ -326,10 +328,9 @@ fn super_args<C:Combine>(\n     }\n }\n \n-fn super_vstores<C:Combine>(\n+pub fn super_vstores<C:Combine>(\n     self: &C, vk: ty::terr_vstore_kind,\n-    a: ty::vstore, b: ty::vstore) -> cres<ty::vstore>\n-{\n+    a: ty::vstore, b: ty::vstore) -> cres<ty::vstore> {\n     debug!(\"%s.super_vstores(a=%?, b=%?)\", self.tag(), a, b);\n \n     match (a, b) {\n@@ -349,9 +350,8 @@ fn super_vstores<C:Combine>(\n     }\n }\n \n-fn super_fn_metas<C:Combine>(\n-    self: &C, a_f: &ty::FnMeta, b_f: &ty::FnMeta) -> cres<ty::FnMeta>\n-{\n+pub fn super_fn_metas<C:Combine>(\n+    self: &C, a_f: &ty::FnMeta, b_f: &ty::FnMeta) -> cres<ty::FnMeta> {\n     let p = if_ok!(self.protos(a_f.proto, b_f.proto));\n     let r = if_ok!(self.contraregions(a_f.region, b_f.region));\n     let purity = if_ok!(self.purities(a_f.purity, b_f.purity));\n@@ -363,9 +363,8 @@ fn super_fn_metas<C:Combine>(\n                bounds: a_f.bounds}) // XXX: This is wrong!\n }\n \n-fn super_fn_sigs<C:Combine>(\n-    self: &C, a_f: &ty::FnSig, b_f: &ty::FnSig) -> cres<ty::FnSig>\n-{\n+pub fn super_fn_sigs<C:Combine>(\n+    self: &C, a_f: &ty::FnSig, b_f: &ty::FnSig) -> cres<ty::FnSig> {\n     fn argvecs<C:Combine>(self: &C,\n                           +a_args: ~[ty::arg],\n                           +b_args: ~[ty::arg]) -> cres<~[ty::arg]>\n@@ -385,17 +384,15 @@ fn super_fn_sigs<C:Combine>(\n     }\n }\n \n-fn super_fns<C:Combine>(\n-    self: &C, a_f: &ty::FnTy, b_f: &ty::FnTy) -> cres<ty::FnTy>\n-{\n+pub fn super_fns<C:Combine>(\n+    self: &C, a_f: &ty::FnTy, b_f: &ty::FnTy) -> cres<ty::FnTy> {\n     let m = if_ok!(self.fn_metas(&a_f.meta, &b_f.meta));\n     let s = if_ok!(self.fn_sigs(&a_f.sig, &b_f.sig));\n     Ok(FnTyBase {meta: m, sig: s})\n }\n \n-fn super_tys<C:Combine>(\n-    self: &C, a: ty::t, b: ty::t) -> cres<ty::t>\n-{\n+pub fn super_tys<C:Combine>(\n+    self: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n     let tcx = self.infcx().tcx;\n     return match (/*bad*/copy ty::get(a).sty, /*bad*/copy ty::get(b).sty) {\n       // The \"subtype\" ought to be handling cases involving bot or var:"}, {"sha": "58d9f1019aebebf0e9f0bf9e1d8a325f7f75a0fe", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=bae482185173d11d9aae2497ba3764947f196675", "patch": "@@ -25,9 +25,9 @@ use util::ppaux::mt_to_str;\n \n use std::list;\n \n-enum Glb = CombineFields;  // \"greatest lower bound\" (common subtype)\n+pub enum Glb = CombineFields;  // \"greatest lower bound\" (common subtype)\n \n-impl Glb: Combine {\n+pub impl Glb: Combine {\n     fn infcx() -> @InferCtxt { self.infcx }\n     fn tag() -> ~str { ~\"glb\" }\n     fn a_is_expected() -> bool { self.a_is_expected }"}, {"sha": "f061aeb459ba6b534d4cec9a444bc2c708c0de3f", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=bae482185173d11d9aae2497ba3764947f196675", "patch": "@@ -49,15 +49,15 @@ use middle::typeck::infer::to_str::InferStr;\n \n use std::list;\n \n-trait LatticeValue {\n+pub trait LatticeValue {\n     static fn sub(cf: &CombineFields, a: &self, b: &self) -> ures;\n     static fn lub(cf: &CombineFields, a: &self, b: &self) -> cres<self>;\n     static fn glb(cf: &CombineFields, a: &self, b: &self) -> cres<self>;\n }\n \n-type LatticeOp<T> = &fn(cf: &CombineFields, a: &T, b: &T) -> cres<T>;\n+pub type LatticeOp<T> = &fn(cf: &CombineFields, a: &T, b: &T) -> cres<T>;\n \n-impl ty::t: LatticeValue {\n+pub impl ty::t: LatticeValue {\n     static fn sub(cf: &CombineFields, a: &ty::t, b: &ty::t) -> ures {\n         Sub(*cf).tys(*a, *b).to_ures()\n     }\n@@ -71,7 +71,7 @@ impl ty::t: LatticeValue {\n     }\n }\n \n-impl FnMeta: LatticeValue {\n+pub impl FnMeta: LatticeValue {\n     static fn sub(cf: &CombineFields,\n                   a: &FnMeta, b: &FnMeta) -> ures {\n         Sub(*cf).fn_metas(a, b).to_ures()\n@@ -88,7 +88,7 @@ impl FnMeta: LatticeValue {\n     }\n }\n \n-impl CombineFields {\n+pub impl CombineFields {\n     fn var_sub_var<T:Copy InferStr LatticeValue,\n                    V:Copy Eq ToStr Vid UnifyVid<Bounds<T>>>(\n         &self,\n@@ -309,49 +309,48 @@ impl CombineFields {\n // This is common code used by both LUB and GLB to compute the LUB/GLB\n // for pairs of variables or for variables and values.\n \n-trait LatticeDir {\n+pub trait LatticeDir {\n     fn combine_fields() -> CombineFields;\n     fn bnd<T:Copy>(b: &Bounds<T>) -> Option<T>;\n     fn with_bnd<T:Copy>(b: &Bounds<T>, +t: T) -> Bounds<T>;\n }\n \n-trait TyLatticeDir {\n+pub trait TyLatticeDir {\n     fn ty_bot(t: ty::t) -> cres<ty::t>;\n }\n \n-impl Lub: LatticeDir {\n+pub impl Lub: LatticeDir {\n     fn combine_fields() -> CombineFields { *self }\n     fn bnd<T:Copy>(b: &Bounds<T>) -> Option<T> { b.ub }\n     fn with_bnd<T:Copy>(b: &Bounds<T>, +t: T) -> Bounds<T> {\n         {ub: Some(t), ..*b}\n     }\n }\n \n-impl Lub: TyLatticeDir {\n+pub impl Lub: TyLatticeDir {\n     fn ty_bot(t: ty::t) -> cres<ty::t> {\n         Ok(t)\n     }\n }\n \n-impl Glb: LatticeDir {\n+pub impl Glb: LatticeDir {\n     fn combine_fields() -> CombineFields { *self }\n     fn bnd<T:Copy>(b: &Bounds<T>) -> Option<T> { b.lb }\n     fn with_bnd<T:Copy>(b: &Bounds<T>, +t: T) -> Bounds<T> {\n         {lb: Some(t), ..*b}\n     }\n }\n \n-impl Glb: TyLatticeDir {\n+pub impl Glb: TyLatticeDir {\n     fn ty_bot(_t: ty::t) -> cres<ty::t> {\n         Ok(ty::mk_bot(self.infcx.tcx))\n     }\n }\n \n-fn super_lattice_tys<L:LatticeDir TyLatticeDir Combine>(\n+pub fn super_lattice_tys<L:LatticeDir TyLatticeDir Combine>(\n     self: &L,\n     a: ty::t,\n-    b: ty::t) -> cres<ty::t>\n-{\n+    b: ty::t) -> cres<ty::t> {\n     debug!(\"%s.lattice_tys(%s, %s)\", self.tag(),\n            a.inf_str(self.infcx()),\n            b.inf_str(self.infcx()));\n@@ -392,9 +391,9 @@ fn super_lattice_tys<L:LatticeDir TyLatticeDir Combine>(\n     }\n }\n \n-type LatticeDirOp<T> = &fn(a: &T, b: &T) -> cres<T>;\n+pub type LatticeDirOp<T> = &fn(a: &T, b: &T) -> cres<T>;\n \n-enum LatticeVarResult<V,T> {\n+pub enum LatticeVarResult<V,T> {\n     VarResult(V),\n     ValueResult(T)\n }\n@@ -414,15 +413,14 @@ enum LatticeVarResult<V,T> {\n  *   the variables and return the unified variable, in which case the\n  *   result is a variable.  This is indicated with a `VarResult`\n  *   return. */\n-fn lattice_vars<L:LatticeDir Combine,\n-                T:Copy InferStr LatticeValue,\n-                V:Copy Eq ToStr Vid UnifyVid<Bounds<T>>>(\n+pub fn lattice_vars<L:LatticeDir Combine,\n+                    T:Copy InferStr LatticeValue,\n+                    V:Copy Eq ToStr Vid UnifyVid<Bounds<T>>>(\n     self: &L,                           // defines whether we want LUB or GLB\n     +a_vid: V,                          // first variable\n     +b_vid: V,                          // second variable\n     lattice_dir_op: LatticeDirOp<T>)    // LUB or GLB operation on types\n-    -> cres<LatticeVarResult<V,T>>\n-{\n+    -> cres<LatticeVarResult<V,T>> {\n     let nde_a = self.infcx().get(a_vid);\n     let nde_b = self.infcx().get(b_vid);\n     let a_vid = nde_a.root;\n@@ -461,15 +459,14 @@ fn lattice_vars<L:LatticeDir Combine,\n     }\n }\n \n-fn lattice_var_and_t<L:LatticeDir Combine,\n-                     T:Copy InferStr LatticeValue,\n-                     V:Copy Eq ToStr Vid UnifyVid<Bounds<T>>>(\n+pub fn lattice_var_and_t<L:LatticeDir Combine,\n+                         T:Copy InferStr LatticeValue,\n+                         V:Copy Eq ToStr Vid UnifyVid<Bounds<T>>>(\n     self: &L,\n     +a_id: V,\n     b: &T,\n     lattice_dir_op: LatticeDirOp<T>)\n-    -> cres<T>\n-{\n+    -> cres<T> {\n     let nde_a = self.infcx().get(a_id);\n     let a_id = nde_a.root;\n     let a_bounds = &nde_a.possible_types;\n@@ -506,7 +503,7 @@ fn lattice_var_and_t<L:LatticeDir Combine,\n // Random utility functions used by LUB/GLB when computing LUB/GLB of\n // fn types\n \n-fn var_ids<T: Combine>(self: &T, isr: isr_alist) -> ~[RegionVid] {\n+pub fn var_ids<T: Combine>(self: &T, isr: isr_alist) -> ~[RegionVid] {\n     let mut result = ~[];\n     for list::each(isr) |pair| {\n         match pair.second() {\n@@ -521,7 +518,7 @@ fn var_ids<T: Combine>(self: &T, isr: isr_alist) -> ~[RegionVid] {\n     return result;\n }\n \n-fn is_var_in_set(new_vars: &[RegionVid], r: ty::Region) -> bool {\n+pub fn is_var_in_set(new_vars: &[RegionVid], r: ty::Region) -> bool {\n     match r {\n         ty::re_infer(ty::ReVar(ref v)) => new_vars.contains(v),\n         _ => false"}, {"sha": "f24d245db58ed50f4f91c0551225e2e510530635", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=bae482185173d11d9aae2497ba3764947f196675", "patch": "@@ -24,16 +24,19 @@ use std::list;\n use syntax::ast::{Many, Once, extern_fn, m_const, impure_fn, noreturn};\n use syntax::ast::{pure_fn, ret_style, return_val, unsafe_fn};\n \n-fn macros() { include!(\"macros.rs\"); } // FIXME(#3114): Macro import/export.\n+pub fn macros() {\n+    // FIXME(#3114): Macro import/export.\n+    include!(\"macros.rs\");\n+}\n \n-enum Lub = CombineFields;  // least-upper-bound: common supertype\n+pub enum Lub = CombineFields;  // least-upper-bound: common supertype\n \n-impl Lub {\n+pub impl Lub {\n     fn bot_ty(b: ty::t) -> cres<ty::t> { Ok(b) }\n     fn ty_bot(b: ty::t) -> cres<ty::t> { self.bot_ty(b) } // commutative\n }\n \n-impl Lub: Combine {\n+pub impl Lub: Combine {\n     fn infcx() -> @InferCtxt { self.infcx }\n     fn tag() -> ~str { ~\"lub\" }\n     fn a_is_expected() -> bool { self.a_is_expected }"}, {"sha": "7cc09733c20f50fa5c7ecc4fa6fceaf108e6f0bf", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 45, "deletions": 88, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=bae482185173d11d9aae2497ba3764947f196675", "patch": "@@ -242,28 +242,30 @@ section on \"Type Combining\" below for details.\n \n */\n \n-#[legacy_exports];\n #[warn(deprecated_mode)];\n #[warn(deprecated_pattern)];\n \n use core::prelude::*;\n \n+pub use middle::ty::IntVarValue;\n+pub use middle::typeck::infer::resolve::resolve_and_force_all_but_regions;\n+pub use middle::typeck::infer::resolve::{force_all, not_regions};\n+pub use middle::typeck::infer::resolve::{force_ivar};\n+pub use middle::typeck::infer::resolve::{force_tvar, force_rvar};\n+pub use middle::typeck::infer::resolve::{resolve_ivar, resolve_all};\n+pub use middle::typeck::infer::resolve::{resolve_nested_tvar};\n+pub use middle::typeck::infer::resolve::{resolve_rvar};\n+\n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, Vid};\n use middle::ty::{mk_fn, type_is_bot};\n use middle::ty::{ty_int, ty_uint, get, terr_fn, TyVar, IntVar, FloatVar};\n-use middle::ty::IntVarValue;\n use middle::ty;\n use middle::typeck::check::regionmanip::{replace_bound_regions_in_fn_sig};\n use middle::typeck::infer::coercion::Coerce;\n use middle::typeck::infer::combine::{Combine, CombineFields, eq_tys};\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::region_inference::{RegionVarBindings};\n-use middle::typeck::infer::resolve::{force_all, not_regions};\n-use middle::typeck::infer::resolve::{force_tvar, force_rvar, force_ivar};\n-use middle::typeck::infer::resolve::{resolve_and_force_all_but_regions};\n-use middle::typeck::infer::resolve::{resolve_ivar, resolve_all};\n-use middle::typeck::infer::resolve::{resolve_nested_tvar, resolve_rvar};\n use middle::typeck::infer::resolve::{resolver};\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::to_str::InferStr;\n@@ -288,69 +290,26 @@ use syntax::ast_util::dummy_sp;\n use syntax::ast_util;\n use syntax::codemap::span;\n \n-export InferCtxt;\n-export new_infer_ctxt;\n-export mk_subty, can_mk_subty;\n-export mk_subr;\n-export mk_eqty;\n-export mk_coercety, can_mk_coercety;\n-export resolve_nested_tvar, resolve_rvar, resolve_ivar, resolve_all;\n-export force_tvar, force_rvar, force_ivar, force_all;\n-export resolve_and_force_all_but_regions, not_regions;\n-export resolve_type, resolve_region;\n-export resolve_borrowings;\n-export cres, fres, fixup_err, fixup_err_to_str;\n-export root, to_str;\n-export int_ty_set_all;\n-export combine;\n-export glb;\n-export integral;\n-export lattice;\n-export lub;\n-export region_inference;\n-export resolve;\n-export sub;\n-export coercion;\n-export to_str;\n-export unify;\n-export uok;\n-export cyclic_ty, unresolved_ty, region_var_bound_by_region_var;\n-export Bound, Bounds;\n-export ures;\n-export CoerceResult;\n-export infer_ctxt;\n-export fixup_err;\n-export IntVarValue, IntType, UintType;\n-\n-#[legacy_exports]\n-mod combine;\n-#[legacy_exports]\n-mod glb;\n-#[legacy_exports]\n-mod lattice;\n-#[legacy_exports]\n-mod lub;\n-#[legacy_exports]\n-mod region_inference;\n-#[legacy_exports]\n-mod resolve;\n-#[legacy_exports]\n-mod sub;\n-#[legacy_exports]\n-mod to_str;\n-#[legacy_exports]\n-mod unify;\n-mod coercion;\n-\n-type Bound<T> = Option<T>;\n-type Bounds<T> = {lb: Bound<T>, ub: Bound<T>};\n-\n-type cres<T> = Result<T,ty::type_err>; // \"combine result\"\n-type ures = cres<()>; // \"unify result\"\n-type fres<T> = Result<T, fixup_err>; // \"fixup result\"\n-type CoerceResult = cres<Option<@ty::AutoAdjustment>>;\n-\n-struct InferCtxt {\n+pub mod combine;\n+pub mod glb;\n+pub mod lattice;\n+pub mod lub;\n+pub mod region_inference;\n+pub mod resolve;\n+pub mod sub;\n+pub mod to_str;\n+pub mod unify;\n+pub mod coercion;\n+\n+pub type Bound<T> = Option<T>;\n+pub type Bounds<T> = {lb: Bound<T>, ub: Bound<T>};\n+\n+pub type cres<T> = Result<T,ty::type_err>; // \"combine result\"\n+pub type ures = cres<()>; // \"unify result\"\n+pub type fres<T> = Result<T, fixup_err>; // \"fixup result\"\n+pub type CoerceResult = cres<Option<@ty::AutoAdjustment>>;\n+\n+pub struct InferCtxt {\n     tcx: ty::ctxt,\n \n     // We instantiate ValsAndBindings with bounds<ty::t> because the\n@@ -371,15 +330,15 @@ struct InferCtxt {\n     region_vars: RegionVarBindings,\n }\n \n-enum fixup_err {\n+pub enum fixup_err {\n     unresolved_int_ty(IntVid),\n     unresolved_ty(TyVid),\n     cyclic_ty(TyVid),\n     unresolved_region(RegionVid),\n     region_var_bound_by_region_var(RegionVid, RegionVid)\n }\n \n-fn fixup_err_to_str(f: fixup_err) -> ~str {\n+pub fn fixup_err_to_str(f: fixup_err) -> ~str {\n     match f {\n       unresolved_int_ty(_) => ~\"unconstrained integral type\",\n       unresolved_ty(_) => ~\"unconstrained type\",\n@@ -399,7 +358,7 @@ fn new_ValsAndBindings<V:Copy, T:Copy>() -> ValsAndBindings<V, T> {\n     }\n }\n \n-fn new_infer_ctxt(tcx: ty::ctxt) -> @InferCtxt {\n+pub fn new_infer_ctxt(tcx: ty::ctxt) -> @InferCtxt {\n     @InferCtxt {\n         tcx: tcx,\n \n@@ -416,8 +375,8 @@ fn new_infer_ctxt(tcx: ty::ctxt) -> @InferCtxt {\n     }\n }\n \n-fn mk_subty(cx: @InferCtxt, a_is_expected: bool, span: span,\n-            a: ty::t, b: ty::t) -> ures {\n+pub fn mk_subty(cx: @InferCtxt, a_is_expected: bool, span: span,\n+                a: ty::t, b: ty::t) -> ures {\n     debug!(\"mk_subty(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n@@ -426,7 +385,7 @@ fn mk_subty(cx: @InferCtxt, a_is_expected: bool, span: span,\n     }.to_ures()\n }\n \n-fn can_mk_subty(cx: @InferCtxt, a: ty::t, b: ty::t) -> ures {\n+pub fn can_mk_subty(cx: @InferCtxt, a: ty::t, b: ty::t) -> ures {\n     debug!(\"can_mk_subty(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.probe {\n@@ -435,8 +394,8 @@ fn can_mk_subty(cx: @InferCtxt, a: ty::t, b: ty::t) -> ures {\n     }.to_ures()\n }\n \n-fn mk_subr(cx: @InferCtxt, a_is_expected: bool, span: span,\n-           a: ty::Region, b: ty::Region) -> ures {\n+pub fn mk_subr(cx: @InferCtxt, a_is_expected: bool, span: span,\n+               a: ty::Region, b: ty::Region) -> ures {\n     debug!(\"mk_subr(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n@@ -445,8 +404,8 @@ fn mk_subr(cx: @InferCtxt, a_is_expected: bool, span: span,\n     }.to_ures()\n }\n \n-fn mk_eqty(cx: @InferCtxt, a_is_expected: bool, span: span,\n-           a: ty::t, b: ty::t) -> ures {\n+pub fn mk_eqty(cx: @InferCtxt, a_is_expected: bool, span: span,\n+               a: ty::t, b: ty::t) -> ures {\n     debug!(\"mk_eqty(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n@@ -456,9 +415,8 @@ fn mk_eqty(cx: @InferCtxt, a_is_expected: bool, span: span,\n     }.to_ures()\n }\n \n-fn mk_coercety(cx: @InferCtxt, a_is_expected: bool, span: span,\n-               a: ty::t, b: ty::t) -> CoerceResult\n-{\n+pub fn mk_coercety(cx: @InferCtxt, a_is_expected: bool, span: span,\n+                   a: ty::t, b: ty::t) -> CoerceResult {\n     debug!(\"mk_coercety(%s -> %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n@@ -467,7 +425,7 @@ fn mk_coercety(cx: @InferCtxt, a_is_expected: bool, span: span,\n     }\n }\n \n-fn can_mk_coercety(cx: @InferCtxt, a: ty::t, b: ty::t) -> ures {\n+pub fn can_mk_coercety(cx: @InferCtxt, a: ty::t, b: ty::t) -> ures {\n     debug!(\"can_mk_coercety(%s -> %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.probe {\n@@ -478,13 +436,12 @@ fn can_mk_coercety(cx: @InferCtxt, a: ty::t, b: ty::t) -> ures {\n }\n \n // See comment on the type `resolve_state` below\n-fn resolve_type(cx: @InferCtxt, a: ty::t, modes: uint)\n-    -> fres<ty::t> {\n+pub fn resolve_type(cx: @InferCtxt, a: ty::t, modes: uint) -> fres<ty::t> {\n     resolver(cx, modes).resolve_type_chk(a)\n }\n \n-fn resolve_region(cx: @InferCtxt, r: ty::Region, modes: uint)\n-    -> fres<ty::Region> {\n+pub fn resolve_region(cx: @InferCtxt, r: ty::Region, modes: uint)\n+                   -> fres<ty::Region> {\n     resolver(cx, modes).resolve_region_chk(r)\n }\n "}, {"sha": "5d602ab88bbcbcc9efa71a574a292cbf87a278fd", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=bae482185173d11d9aae2497ba3764947f196675", "patch": "@@ -565,11 +565,6 @@ use std::list::{List, Nil, Cons};\n use syntax::codemap::span;\n use syntax::codemap;\n \n-export RegionVarBindings;\n-export make_subregion;\n-export lub_regions;\n-export glb_regions;\n-\n enum Constraint {\n     ConstrainVarSubVar(RegionVid, RegionVid),\n     ConstrainRegSubVar(Region, RegionVid),\n@@ -638,7 +633,7 @@ enum UndoLogEntry {\n \n type CombineMap = HashMap<TwoRegions, RegionVid>;\n \n-struct RegionVarBindings {\n+pub struct RegionVarBindings {\n     tcx: ty::ctxt,\n     var_spans: DVec<span>,\n     constraints: HashMap<Constraint, span>,\n@@ -663,7 +658,7 @@ struct RegionVarBindings {\n     values: Cell<~[GraphNodeValue]>,\n }\n \n-fn RegionVarBindings(tcx: ty::ctxt) -> RegionVarBindings {\n+pub fn RegionVarBindings(tcx: ty::ctxt) -> RegionVarBindings {\n     RegionVarBindings {\n         tcx: tcx,\n         var_spans: DVec(),\n@@ -684,7 +679,7 @@ fn CombineMap() -> CombineMap {\n     return HashMap();\n }\n \n-impl RegionVarBindings {\n+pub impl RegionVarBindings {\n     fn in_snapshot(&self) -> bool {\n         self.undo_log.len() > 0\n     }"}, {"sha": "2801b30ee7f7100866650ae77044476e670ab031", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=bae482185173d11d9aae2497ba3764947f196675", "patch": "@@ -63,34 +63,34 @@ use syntax::ast;\n use core::uint;\n use core::vec;\n \n-const resolve_nested_tvar: uint = 0b0000000001;\n-const resolve_rvar: uint        = 0b0000000010;\n-const resolve_ivar: uint        = 0b0000000100;\n-const resolve_fvar: uint        = 0b0000001000;\n-const resolve_fnvar: uint       = 0b0000010000;\n-const resolve_all: uint         = 0b0000011111;\n-const force_tvar: uint          = 0b0000100000;\n-const force_rvar: uint          = 0b0001000000;\n-const force_ivar: uint          = 0b0010000000;\n-const force_fvar: uint          = 0b0100000000;\n-const force_fnvar: uint         = 0b1000000000;\n-const force_all: uint           = 0b1111100000;\n-\n-const not_regions: uint         = !(force_rvar | resolve_rvar);\n-\n-const try_resolve_tvar_shallow: uint = 0;\n-const resolve_and_force_all_but_regions: uint =\n+pub const resolve_nested_tvar: uint = 0b0000000001;\n+pub const resolve_rvar: uint        = 0b0000000010;\n+pub const resolve_ivar: uint        = 0b0000000100;\n+pub const resolve_fvar: uint        = 0b0000001000;\n+pub const resolve_fnvar: uint       = 0b0000010000;\n+pub const resolve_all: uint         = 0b0000011111;\n+pub const force_tvar: uint          = 0b0000100000;\n+pub const force_rvar: uint          = 0b0001000000;\n+pub const force_ivar: uint          = 0b0010000000;\n+pub const force_fvar: uint          = 0b0100000000;\n+pub const force_fnvar: uint         = 0b1000000000;\n+pub const force_all: uint           = 0b1111100000;\n+\n+pub const not_regions: uint         = !(force_rvar | resolve_rvar);\n+\n+pub const try_resolve_tvar_shallow: uint = 0;\n+pub const resolve_and_force_all_but_regions: uint =\n     (resolve_all | force_all) & not_regions;\n \n-struct ResolveState {\n+pub struct ResolveState {\n     infcx: @InferCtxt,\n     modes: uint,\n     mut err: Option<fixup_err>,\n     mut v_seen: ~[TyVid],\n     mut type_depth: uint\n }\n \n-fn resolver(infcx: @InferCtxt, modes: uint) -> ResolveState {\n+pub fn resolver(infcx: @InferCtxt, modes: uint) -> ResolveState {\n     ResolveState {\n         infcx: infcx,\n         modes: modes,\n@@ -100,7 +100,7 @@ fn resolver(infcx: @InferCtxt, modes: uint) -> ResolveState {\n     }\n }\n \n-impl ResolveState {\n+pub impl ResolveState {\n     fn should(&self, mode: uint) -> bool {\n         (self.modes & mode) == mode\n     }"}, {"sha": "158cbb41abd522143cbdf4fca5928181da510b0b", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=bae482185173d11d9aae2497ba3764947f196675", "patch": "@@ -25,11 +25,14 @@ use std::list::Nil;\n use std::list;\n use syntax::ast::{m_const, purity, ret_style};\n \n-fn macros() { include!(\"macros.rs\"); } // FIXME(#3114): Macro import/export.\n+pub fn macros() {\n+    // FIXME(#3114): Macro import/export.\n+    include!(\"macros.rs\");\n+}\n \n-enum Sub = CombineFields;  // \"subtype\", \"subregion\" etc\n+pub enum Sub = CombineFields;  // \"subtype\", \"subregion\" etc\n \n-impl Sub: Combine {\n+pub impl Sub: Combine {\n     fn infcx() -> @InferCtxt { self.infcx }\n     fn tag() -> ~str { ~\"sub\" }\n     fn a_is_expected() -> bool { self.a_is_expected }"}, {"sha": "e100392bba9adc0565a77f00a3f9287613792b8b", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=bae482185173d11d9aae2497ba3764947f196675", "patch": "@@ -28,45 +28,45 @@ pub trait InferStr {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str;\n }\n \n-impl ty::t : InferStr {\n+pub impl ty::t : InferStr {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n         ty_to_str(cx.tcx, *self)\n     }\n }\n \n-impl FnMeta : InferStr {\n+pub impl FnMeta : InferStr {\n     fn inf_str(&self, _cx: &InferCtxt) -> ~str {\n         fmt!(\"%?\", *self)\n     }\n }\n \n-impl FnSig : InferStr {\n+pub impl FnSig : InferStr {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n         fmt!(\"(%s) -> %s\",\n              str::connect(self.inputs.map(|a| a.ty.inf_str(cx)), \", \"),\n              self.output.inf_str(cx))\n     }\n }\n \n-impl<M:InferStr> FnTyBase<M> : InferStr {\n+pub impl<M:InferStr> FnTyBase<M> : InferStr {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n         fmt!(\"%s%s\", self.meta.inf_str(cx), self.sig.inf_str(cx))\n     }\n }\n \n-impl ty::mt : InferStr {\n+pub impl ty::mt : InferStr {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n         mt_to_str(cx.tcx, *self)\n     }\n }\n \n-impl ty::Region : InferStr {\n+pub impl ty::Region : InferStr {\n     fn inf_str(&self, _cx: &InferCtxt) -> ~str {\n         fmt!(\"%?\", *self)\n     }\n }\n \n-impl<V:InferStr> Bound<V> : InferStr {\n+pub impl<V:InferStr> Bound<V> : InferStr {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n         match *self {\n           Some(ref v) => v.inf_str(cx),\n@@ -75,15 +75,15 @@ impl<V:InferStr> Bound<V> : InferStr {\n     }\n }\n \n-impl<T:InferStr> Bounds<T> : InferStr {\n+pub impl<T:InferStr> Bounds<T> : InferStr {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n         fmt!(\"{%s <: %s}\",\n              self.lb.inf_str(cx),\n              self.ub.inf_str(cx))\n     }\n }\n \n-impl<V:Vid ToStr, T:InferStr> VarValue<V, T> : InferStr {\n+pub impl<V:Vid ToStr, T:InferStr> VarValue<V, T> : InferStr {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n         match *self {\n           Redirect(ref vid) => fmt!(\"Redirect(%s)\", vid.to_str()),\n@@ -93,13 +93,13 @@ impl<V:Vid ToStr, T:InferStr> VarValue<V, T> : InferStr {\n     }\n }\n \n-impl IntVarValue : InferStr {\n+pub impl IntVarValue : InferStr {\n     fn inf_str(&self, _cx: &InferCtxt) -> ~str {\n         self.to_str()\n     }\n }\n \n-impl ast::float_ty : InferStr {\n+pub impl ast::float_ty : InferStr {\n     fn inf_str(&self, _cx: &InferCtxt) -> ~str {\n         self.to_str()\n     }"}, {"sha": "db3dab297a756069464cd7249cc69b470980def3", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=bae482185173d11d9aae2497ba3764947f196675", "patch": "@@ -21,28 +21,28 @@ use middle::typeck::infer::to_str::InferStr;\n use syntax::ast;\n use util::common::{indent, indenter};\n \n-enum VarValue<V, T> {\n+pub enum VarValue<V, T> {\n     Redirect(V),\n     Root(T, uint),\n }\n \n-struct ValsAndBindings<V, T> {\n+pub struct ValsAndBindings<V, T> {\n     vals: SmallIntMap<VarValue<V, T>>,\n     mut bindings: ~[(V, VarValue<V, T>)],\n }\n \n-struct Node<V, T> {\n+pub struct Node<V, T> {\n     root: V,\n     possible_types: T,\n     rank: uint,\n }\n \n-trait UnifyVid<T> {\n+pub trait UnifyVid<T> {\n     static fn appropriate_vals_and_bindings(infcx: &v/InferCtxt)\n         -> &v/ValsAndBindings<self, T>;\n }\n \n-impl InferCtxt {\n+pub impl InferCtxt {\n     fn get<T:Copy, V:Copy Eq Vid UnifyVid<T>>(\n         &self,\n         +vid: V) -> Node<V, T>\n@@ -135,14 +135,13 @@ impl InferCtxt {\n // Code to handle simple variables like ints, floats---anything that\n // doesn't have a subtyping relationship we need to worry about.\n \n-trait SimplyUnifiable {\n+pub trait SimplyUnifiable {\n     static fn to_type_err(expected_found<self>) -> ty::type_err;\n }\n \n-fn mk_err<T: SimplyUnifiable>(+a_is_expected: bool,\n-                              +a_t: T,\n-                              +b_t: T) -> ures\n-{\n+pub fn mk_err<T: SimplyUnifiable>(+a_is_expected: bool,\n+                                  +a_t: T,\n+                                  +b_t: T) -> ures {\n     if a_is_expected {\n         Err(SimplyUnifiable::to_type_err(\n             ty::expected_found {expected: a_t, found: b_t}))\n@@ -152,7 +151,7 @@ fn mk_err<T: SimplyUnifiable>(+a_is_expected: bool,\n     }\n }\n \n-impl InferCtxt {\n+pub impl InferCtxt {\n     fn simple_vars<T:Copy Eq InferStr SimplyUnifiable,\n                    V:Copy Eq Vid ToStr UnifyVid<Option<T>>>(\n         &self,\n@@ -227,39 +226,39 @@ impl InferCtxt {\n \n // ______________________________________________________________________\n \n-impl ty::TyVid : UnifyVid<Bounds<ty::t>> {\n+pub impl ty::TyVid : UnifyVid<Bounds<ty::t>> {\n     static fn appropriate_vals_and_bindings(infcx: &v/InferCtxt)\n         -> &v/ValsAndBindings<ty::TyVid, Bounds<ty::t>>\n     {\n         return &infcx.ty_var_bindings;\n     }\n }\n \n-impl ty::IntVid : UnifyVid<Option<IntVarValue>> {\n+pub impl ty::IntVid : UnifyVid<Option<IntVarValue>> {\n     static fn appropriate_vals_and_bindings(infcx: &v/InferCtxt)\n         -> &v/ValsAndBindings<ty::IntVid, Option<IntVarValue>>\n     {\n         return &infcx.int_var_bindings;\n     }\n }\n \n-impl IntVarValue : SimplyUnifiable {\n+pub impl IntVarValue : SimplyUnifiable {\n     static fn to_type_err(err: expected_found<IntVarValue>)\n         -> ty::type_err\n     {\n         return ty::terr_int_mismatch(err);\n     }\n }\n \n-impl ty::FloatVid : UnifyVid<Option<ast::float_ty>> {\n+pub impl ty::FloatVid : UnifyVid<Option<ast::float_ty>> {\n     static fn appropriate_vals_and_bindings(infcx: &v/InferCtxt)\n         -> &v/ValsAndBindings<ty::FloatVid, Option<ast::float_ty>>\n     {\n         return &infcx.float_var_bindings;\n     }\n }\n \n-impl ast::float_ty : SimplyUnifiable {\n+pub impl ast::float_ty : SimplyUnifiable {\n     static fn to_type_err(err: expected_found<ast::float_ty>)\n         -> ty::type_err\n     {"}, {"sha": "c264d8e08063abd7b9e9cf79604a5a2efedafea4", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 17, "deletions": 50, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=bae482185173d11d9aae2497ba3764947f196675", "patch": "@@ -48,8 +48,6 @@ independently:\n \n */\n \n-#[legacy_exports];\n-\n use core::prelude::*;\n \n use metadata::csearch;\n@@ -81,45 +79,13 @@ use syntax::print::pprust::*;\n use syntax::visit;\n use syntax::{ast, ast_util, ast_map};\n \n-export check;\n-export check_crate;\n-export infer;\n-export method_map;\n-export method_origin;\n-export method_map_entry;\n-export vtable_map;\n-export vtable_res;\n-export vtable_origin;\n-export method_static, method_param, method_trait, method_self;\n-export vtable_static, vtable_param, vtable_trait;\n-export provided_methods_map;\n-export coherence;\n-export check;\n-export rscope;\n-export astconv;\n-export infer;\n-export collect;\n-export coherence;\n-export deriving;\n-export crate_ctxt;\n-export write_ty_to_tcx, write_substs_to_tcx;\n-export no_params;\n-export isr_alist;\n-export require_same_types;\n-export lookup_def_ccx, lookup_def_tcx;\n-\n-#[legacy_exports]\n #[path = \"check/mod.rs\"]\n pub mod check;\n-#[legacy_exports]\n pub mod rscope;\n-#[legacy_exports]\n pub mod astconv;\n #[path = \"infer/mod.rs\"]\n pub mod infer;\n-#[legacy_exports]\n pub mod collect;\n-#[legacy_exports]\n pub mod coherence;\n \n #[auto_encode]\n@@ -142,7 +108,7 @@ pub enum method_origin {\n // with a bounded trait.\n #[auto_encode]\n #[auto_decode]\n-struct method_param {\n+pub struct method_param {\n     // the trait containing the method to be invoked\n     trait_id: ast::def_id,\n \n@@ -199,7 +165,7 @@ pub enum vtable_origin {\n     vtable_trait(ast::def_id, ~[ty::t]),\n }\n \n-impl vtable_origin {\n+pub impl vtable_origin {\n     fn to_str(tcx: ty::ctxt) -> ~str {\n         match self {\n             vtable_static(def_id, ref tys, ref vtable_res) => {\n@@ -222,7 +188,7 @@ impl vtable_origin {\n     }\n }\n \n-type vtable_map = HashMap<ast::node_id, vtable_res>;\n+pub type vtable_map = HashMap<ast::node_id, vtable_res>;\n \n struct crate_ctxt__ {\n     // A mapping from method call sites to traits that have that method.\n@@ -238,21 +204,21 @@ pub enum crate_ctxt {\n }\n \n // Functions that write types into the node type table\n-fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t) {\n+pub fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t) {\n     debug!(\"write_ty_to_tcx(%d, %s)\", node_id, ppaux::ty_to_str(tcx, ty));\n     smallintmap::insert(*tcx.node_types, node_id as uint, ty);\n }\n-fn write_substs_to_tcx(tcx: ty::ctxt,\n-                       node_id: ast::node_id,\n-                       +substs: ~[ty::t]) {\n+pub fn write_substs_to_tcx(tcx: ty::ctxt,\n+                           node_id: ast::node_id,\n+                           +substs: ~[ty::t]) {\n     if substs.len() > 0u {\n         debug!(\"write_substs_to_tcx(%d, %?)\", node_id,\n                substs.map(|t| ppaux::ty_to_str(tcx, *t)));\n         tcx.node_type_substs.insert(node_id, substs);\n     }\n }\n \n-fn lookup_def_tcx(tcx: ty::ctxt, sp: span, id: ast::node_id) -> ast::def {\n+pub fn lookup_def_tcx(tcx: ty::ctxt, sp: span, id: ast::node_id) -> ast::def {\n     match tcx.def_map.find(id) {\n       Some(x) => x,\n       _ => {\n@@ -261,15 +227,16 @@ fn lookup_def_tcx(tcx: ty::ctxt, sp: span, id: ast::node_id) -> ast::def {\n     }\n }\n \n-fn lookup_def_ccx(ccx: @crate_ctxt, sp: span, id: ast::node_id) -> ast::def {\n+pub fn lookup_def_ccx(ccx: @crate_ctxt, sp: span, id: ast::node_id)\n+                   -> ast::def {\n     lookup_def_tcx(ccx.tcx, sp, id)\n }\n \n-fn no_params(t: ty::t) -> ty::ty_param_bounds_and_ty {\n+pub fn no_params(t: ty::t) -> ty::ty_param_bounds_and_ty {\n     {bounds: @~[], region_param: None, ty: t}\n }\n \n-fn require_same_types(\n+pub fn require_same_types(\n     tcx: ty::ctxt,\n     maybe_infcx: Option<@infer::InferCtxt>,\n     t1_is_expected: bool,\n@@ -303,7 +270,7 @@ fn require_same_types(\n \n // a list of mapping from in-scope-region-names (\"isr\") to the\n // corresponding ty::Region\n-type isr_alist = @List<(ty::bound_region, ty::Region)>;\n+pub type isr_alist = @List<(ty::bound_region, ty::Region)>;\n \n trait get_and_find_region {\n     fn get(br: ty::bound_region) -> ty::Region;\n@@ -397,10 +364,10 @@ fn check_for_main_fn(ccx: @crate_ctxt) {\n     }\n }\n \n-fn check_crate(tcx: ty::ctxt,\n-               trait_map: resolve::TraitMap,\n-               crate: @ast::crate)\n-    -> (method_map, vtable_map) {\n+pub fn check_crate(tcx: ty::ctxt,\n+                   trait_map: resolve::TraitMap,\n+                   crate: @ast::crate)\n+                -> (method_map, vtable_map) {\n \n     let ccx = @crate_ctxt_(crate_ctxt__ {\n         trait_map: trait_map,"}, {"sha": "244f05a8f7e028dda2484f843fabc763d154f604", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bae482185173d11d9aae2497ba3764947f196675/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=bae482185173d11d9aae2497ba3764947f196675", "patch": "@@ -18,14 +18,14 @@ use syntax::ast;\n use syntax::codemap::span;\n use syntax::parse::token::special_idents;\n \n-trait region_scope {\n+pub trait region_scope {\n     fn anon_region(span: span) -> Result<ty::Region, ~str>;\n     fn self_region(span: span) -> Result<ty::Region, ~str>;\n     fn named_region(span: span, id: ast::ident) -> Result<ty::Region, ~str>;\n }\n \n-enum empty_rscope { empty_rscope }\n-impl empty_rscope: region_scope {\n+pub enum empty_rscope { empty_rscope }\n+pub impl empty_rscope: region_scope {\n     fn anon_region(_span: span) -> Result<ty::Region, ~str> {\n         result::Ok(ty::re_static)\n     }\n@@ -39,8 +39,8 @@ impl empty_rscope: region_scope {\n     }\n }\n \n-enum type_rscope = Option<ty::region_variance>;\n-impl type_rscope: region_scope {\n+pub enum type_rscope = Option<ty::region_variance>;\n+pub impl type_rscope: region_scope {\n     fn anon_region(_span: span) -> Result<ty::Region, ~str> {\n         match *self {\n           Some(_) => result::Ok(ty::re_bound(ty::br_self)),\n@@ -59,19 +59,20 @@ impl type_rscope: region_scope {\n     }\n }\n \n-fn bound_self_region(rp: Option<ty::region_variance>) -> Option<ty::Region> {\n+pub fn bound_self_region(rp: Option<ty::region_variance>)\n+                      -> Option<ty::Region> {\n     match rp {\n       Some(_) => Some(ty::re_bound(ty::br_self)),\n       None => None\n     }\n }\n \n-enum anon_rscope = {anon: ty::Region, base: region_scope};\n-fn in_anon_rscope<RS: region_scope Copy Durable>(self: RS, r: ty::Region)\n+pub enum anon_rscope = {anon: ty::Region, base: region_scope};\n+pub fn in_anon_rscope<RS: region_scope Copy Durable>(self: RS, r: ty::Region)\n     -> @anon_rscope {\n     @anon_rscope({anon: r, base: self as region_scope})\n }\n-impl @anon_rscope: region_scope {\n+pub impl @anon_rscope: region_scope {\n     fn anon_region(_span: span) -> Result<ty::Region, ~str> {\n         result::Ok(self.anon)\n     }\n@@ -83,16 +84,16 @@ impl @anon_rscope: region_scope {\n     }\n }\n \n-struct binding_rscope {\n+pub struct binding_rscope {\n     base: region_scope,\n     mut anon_bindings: uint,\n }\n-fn in_binding_rscope<RS: region_scope Copy Durable>(self: RS)\n+pub fn in_binding_rscope<RS: region_scope Copy Durable>(self: RS)\n     -> @binding_rscope {\n     let base = self as region_scope;\n     @binding_rscope { base: base, anon_bindings: 0 }\n }\n-impl @binding_rscope: region_scope {\n+pub impl @binding_rscope: region_scope {\n     fn anon_region(_span: span) -> Result<ty::Region, ~str> {\n         let idx = self.anon_bindings;\n         self.anon_bindings += 1;"}]}