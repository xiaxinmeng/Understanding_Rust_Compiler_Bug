{"sha": "662c70a59f79919640465b8753f790af822e96c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2MmM3MGE1OWY3OTkxOTY0MDQ2NWI4NzUzZjc5MGFmODIyZTk2Yzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-21T20:58:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-21T20:58:51Z"}, "message": "Auto merge of #48149 - varkor:generics-generalisation, r=petrochenkov\n\nThe Great Generics Generalisation: HIR Edition\n\nThis is essentially a followup to https://github.com/rust-lang/rust/pull/45930, consolidating the use of separate lifetime and type vectors into single kinds vectors wherever possible. This is intended to provide more of the groundwork for const generics (https://github.com/rust-lang/rust/issues/44580).\n\nr? @eddyb\ncc @yodaldevoid", "tree": {"sha": "6cdf8eebd7ef3e59549aa057f85475d86286359b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cdf8eebd7ef3e59549aa057f85475d86286359b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/662c70a59f79919640465b8753f790af822e96c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/662c70a59f79919640465b8753f790af822e96c8", "html_url": "https://github.com/rust-lang/rust/commit/662c70a59f79919640465b8753f790af822e96c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/662c70a59f79919640465b8753f790af822e96c8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f790780451a724dce9be0ba03ff217955036ff88", "url": "https://api.github.com/repos/rust-lang/rust/commits/f790780451a724dce9be0ba03ff217955036ff88", "html_url": "https://github.com/rust-lang/rust/commit/f790780451a724dce9be0ba03ff217955036ff88"}, {"sha": "daf7e359a10306c004bdffd06b6432998d70b858", "url": "https://api.github.com/repos/rust-lang/rust/commits/daf7e359a10306c004bdffd06b6432998d70b858", "html_url": "https://github.com/rust-lang/rust/commit/daf7e359a10306c004bdffd06b6432998d70b858"}], "stats": {"total": 5049, "additions": 2565, "deletions": 2484}, "files": [{"sha": "ed86ef705649b651de8f718032c5f3cdb615c8cf", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 38, "deletions": 46, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -314,8 +314,8 @@ pub trait Visitor<'v> : Sized {\n     fn visit_trait_ref(&mut self, t: &'v TraitRef) {\n         walk_trait_ref(self, t)\n     }\n-    fn visit_ty_param_bound(&mut self, bounds: &'v TyParamBound) {\n-        walk_ty_param_bound(self, bounds)\n+    fn visit_param_bound(&mut self, bounds: &'v GenericBound) {\n+        walk_param_bound(self, bounds)\n     }\n     fn visit_poly_trait_ref(&mut self, t: &'v PolyTraitRef, m: TraitBoundModifier) {\n         walk_poly_trait_ref(self, t, m)\n@@ -344,6 +344,12 @@ pub trait Visitor<'v> : Sized {\n     fn visit_label(&mut self, label: &'v Label) {\n         walk_label(self, label)\n     }\n+    fn visit_generic_arg(&mut self, generic_arg: &'v GenericArg) {\n+        match generic_arg {\n+            GenericArg::Lifetime(lt) => self.visit_lifetime(lt),\n+            GenericArg::Type(ty) => self.visit_ty(ty),\n+        }\n+    }\n     fn visit_lifetime(&mut self, lifetime: &'v Lifetime) {\n         walk_lifetime(self, lifetime)\n     }\n@@ -356,8 +362,8 @@ pub trait Visitor<'v> : Sized {\n     fn visit_path_segment(&mut self, path_span: Span, path_segment: &'v PathSegment) {\n         walk_path_segment(self, path_span, path_segment)\n     }\n-    fn visit_path_parameters(&mut self, path_span: Span, path_parameters: &'v PathParameters) {\n-        walk_path_parameters(self, path_span, path_parameters)\n+    fn visit_generic_args(&mut self, path_span: Span, generic_args: &'v GenericArgs) {\n+        walk_generic_args(self, path_span, generic_args)\n     }\n     fn visit_assoc_type_binding(&mut self, type_binding: &'v TypeBinding) {\n         walk_assoc_type_binding(self, type_binding)\n@@ -427,10 +433,10 @@ pub fn walk_label<'v, V: Visitor<'v>>(visitor: &mut V, label: &'v Label) {\n pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime) {\n     visitor.visit_id(lifetime.id);\n     match lifetime.name {\n-        LifetimeName::Name(name) => {\n+        LifetimeName::Param(ParamName::Plain(name)) => {\n             visitor.visit_name(lifetime.span, name);\n         }\n-        LifetimeName::Fresh(_) |\n+        LifetimeName::Param(ParamName::Fresh(_)) |\n         LifetimeName::Static |\n         LifetimeName::Implicit |\n         LifetimeName::Underscore => {}\n@@ -505,7 +511,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n         ItemExistential(ExistTy {ref generics, ref bounds, impl_trait_fn}) => {\n             visitor.visit_id(item.id);\n             walk_generics(visitor, generics);\n-            walk_list!(visitor, visit_ty_param_bound, bounds);\n+            walk_list!(visitor, visit_param_bound, bounds);\n             if let Some(impl_trait_fn) = impl_trait_fn {\n                 visitor.visit_def_mention(Def::Fn(impl_trait_fn))\n             }\n@@ -531,13 +537,13 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n         ItemTrait(.., ref generics, ref bounds, ref trait_item_refs) => {\n             visitor.visit_id(item.id);\n             visitor.visit_generics(generics);\n-            walk_list!(visitor, visit_ty_param_bound, bounds);\n+            walk_list!(visitor, visit_param_bound, bounds);\n             walk_list!(visitor, visit_trait_item_ref, trait_item_refs);\n         }\n         ItemTraitAlias(ref generics, ref bounds) => {\n             visitor.visit_id(item.id);\n             visitor.visit_generics(generics);\n-            walk_list!(visitor, visit_ty_param_bound, bounds);\n+            walk_list!(visitor, visit_param_bound, bounds);\n         }\n     }\n     walk_list!(visitor, visit_attribute, &item.attrs);\n@@ -642,17 +648,16 @@ pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V,\n                                              path_span: Span,\n                                              segment: &'v PathSegment) {\n     visitor.visit_name(path_span, segment.name);\n-    if let Some(ref parameters) = segment.parameters {\n-        visitor.visit_path_parameters(path_span, parameters);\n+    if let Some(ref args) = segment.args {\n+        visitor.visit_generic_args(path_span, args);\n     }\n }\n \n-pub fn walk_path_parameters<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                                _path_span: Span,\n-                                                path_parameters: &'v PathParameters) {\n-    walk_list!(visitor, visit_lifetime, &path_parameters.lifetimes);\n-    walk_list!(visitor, visit_ty, &path_parameters.types);\n-    walk_list!(visitor, visit_assoc_type_binding, &path_parameters.bindings);\n+pub fn walk_generic_args<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                             _path_span: Span,\n+                                             generic_args: &'v GenericArgs) {\n+    walk_list!(visitor, visit_generic_arg, &generic_args.args);\n+    walk_list!(visitor, visit_assoc_type_binding, &generic_args.bindings);\n }\n \n pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n@@ -726,40 +731,27 @@ pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v\n     walk_list!(visitor, visit_attribute, &foreign_item.attrs);\n }\n \n-pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v TyParamBound) {\n+pub fn walk_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v GenericBound) {\n     match *bound {\n-        TraitTyParamBound(ref typ, modifier) => {\n+        GenericBound::Trait(ref typ, modifier) => {\n             visitor.visit_poly_trait_ref(typ, modifier);\n         }\n-        RegionTyParamBound(ref lifetime) => {\n-            visitor.visit_lifetime(lifetime);\n-        }\n+        GenericBound::Outlives(ref lifetime) => visitor.visit_lifetime(lifetime),\n     }\n }\n \n pub fn walk_generic_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v GenericParam) {\n-    match *param {\n-        GenericParam::Lifetime(ref ld) => {\n-            visitor.visit_id(ld.lifetime.id);\n-            match ld.lifetime.name {\n-                LifetimeName::Name(name) => {\n-                    visitor.visit_name(ld.lifetime.span, name);\n-                }\n-                LifetimeName::Fresh(_) |\n-                LifetimeName::Static |\n-                LifetimeName::Implicit |\n-                LifetimeName::Underscore => {}\n-            }\n-            walk_list!(visitor, visit_lifetime, &ld.bounds);\n-        }\n-        GenericParam::Type(ref ty_param) => {\n-            visitor.visit_id(ty_param.id);\n-            visitor.visit_name(ty_param.span, ty_param.name);\n-            walk_list!(visitor, visit_ty_param_bound, &ty_param.bounds);\n-            walk_list!(visitor, visit_ty, &ty_param.default);\n-            walk_list!(visitor, visit_attribute, ty_param.attrs.iter());\n-        }\n+    visitor.visit_id(param.id);\n+    walk_list!(visitor, visit_attribute, &param.attrs);\n+    match param.name {\n+        ParamName::Plain(name) => visitor.visit_name(param.span, name),\n+        ParamName::Fresh(_) => {}\n+    }\n+    match param.kind {\n+        GenericParamKind::Lifetime { .. } => {}\n+        GenericParamKind::Type { ref default, .. } => walk_list!(visitor, visit_ty, default),\n     }\n+    walk_list!(visitor, visit_param_bound, &param.bounds);\n }\n \n pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics) {\n@@ -778,14 +770,14 @@ pub fn walk_where_predicate<'v, V: Visitor<'v>>(\n                                                             ref bound_generic_params,\n                                                             ..}) => {\n             visitor.visit_ty(bounded_ty);\n-            walk_list!(visitor, visit_ty_param_bound, bounds);\n+            walk_list!(visitor, visit_param_bound, bounds);\n             walk_list!(visitor, visit_generic_param, bound_generic_params);\n         }\n         &WherePredicate::RegionPredicate(WhereRegionPredicate{ref lifetime,\n                                                               ref bounds,\n                                                               ..}) => {\n             visitor.visit_lifetime(lifetime);\n-            walk_list!(visitor, visit_lifetime, bounds);\n+            walk_list!(visitor, visit_param_bound, bounds);\n         }\n         &WherePredicate::EqPredicate(WhereEqPredicate{id,\n                                                       ref lhs_ty,\n@@ -862,7 +854,7 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n         }\n         TraitItemKind::Type(ref bounds, ref default) => {\n             visitor.visit_id(trait_item.id);\n-            walk_list!(visitor, visit_ty_param_bound, bounds);\n+            walk_list!(visitor, visit_param_bound, bounds);\n             walk_list!(visitor, visit_ty, default);\n         }\n     }"}, {"sha": "6291e0eb113728dc8a8711baec6e7dfe5f7f3ca2", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 257, "deletions": 278, "changes": 535, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -41,11 +41,12 @@\n //! in the HIR, especially for multiple identifiers.\n \n use dep_graph::DepGraph;\n-use hir;\n+use hir::{self, ParamName};\n use hir::HirVec;\n use hir::map::{DefKey, DefPathData, Definitions};\n use hir::def_id::{DefId, DefIndex, DefIndexAddressSpace, CRATE_DEF_INDEX};\n use hir::def::{Def, PathResolution, PerNS};\n+use hir::GenericArg;\n use lint::builtin::{self, PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES};\n use middle::cstore::CrateStore;\n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -58,6 +59,7 @@ use std::fmt::Debug;\n use std::iter;\n use std::mem;\n use syntax::attr;\n+use syntax::ast;\n use syntax::ast::*;\n use syntax::errors;\n use syntax::ext::hygiene::{Mark, SyntaxContext};\n@@ -114,7 +116,7 @@ pub struct LoweringContext<'a> {\n     // When traversing a signature such as `fn foo(x: impl Trait)`,\n     // we record `impl Trait` as a new type parameter, then later\n     // add it on to `foo`s generics.\n-    in_band_ty_params: Vec<hir::TyParam>,\n+    in_band_ty_params: Vec<hir::GenericParam>,\n \n     // Used to create lifetime definitions from in-band lifetime usages.\n     // e.g. `fn foo(x: &'x u8) -> &'x u8` to `fn foo<'x>(x: &'x u8) -> &'x u8`\n@@ -123,7 +125,7 @@ pub struct LoweringContext<'a> {\n     // (i.e. it doesn't appear in the in_scope_lifetimes list), it is added\n     // to this list. The results of this list are then added to the list of\n     // lifetime definitions in the corresponding impl or function generics.\n-    lifetimes_to_define: Vec<(Span, hir::LifetimeName)>,\n+    lifetimes_to_define: Vec<(Span, ParamName)>,\n \n     // Whether or not in-band lifetimes are being collected. This is used to\n     // indicate whether or not we're in a place where new lifetimes will result\n@@ -322,7 +324,10 @@ impl<'a> LoweringContext<'a> {\n                         let count = generics\n                             .params\n                             .iter()\n-                            .filter(|param| param.is_lifetime_param())\n+                            .filter(|param| match param.kind {\n+                                ast::GenericParamKind::Lifetime { .. } => true,\n+                                _ => false,\n+                            })\n                             .count();\n                         self.lctx.type_def_lifetime_params.insert(def_id, count);\n                     }\n@@ -374,25 +379,24 @@ impl<'a> LoweringContext<'a> {\n                 });\n \n                 if item_lowered {\n-                    let item_lifetimes = match self.lctx.items.get(&item.id).unwrap().node {\n+                    let item_generics = match self.lctx.items.get(&item.id).unwrap().node {\n                         hir::Item_::ItemImpl(_, _, _, ref generics, ..)\n                         | hir::Item_::ItemTrait(_, _, ref generics, ..) => {\n-                            generics.lifetimes().cloned().collect::<Vec<_>>()\n+                            generics.params.clone()\n                         }\n-                        _ => Vec::new(),\n+                        _ => HirVec::new(),\n                     };\n \n-                    self.lctx\n-                        .with_parent_impl_lifetime_defs(&item_lifetimes, |this| {\n-                            let this = &mut ItemLowerer { lctx: this };\n-                            if let ItemKind::Impl(_, _, _, _, ref opt_trait_ref, _, _) = item.node {\n-                                this.with_trait_impl_ref(opt_trait_ref, |this| {\n-                                    visit::walk_item(this, item)\n-                                });\n-                            } else {\n-                                visit::walk_item(this, item);\n-                            }\n-                        });\n+                    self.lctx.with_parent_impl_lifetime_defs(&item_generics, |this| {\n+                        let this = &mut ItemLowerer { lctx: this };\n+                        if let ItemKind::Impl(_, _, _, _, ref opt_trait_ref, _, _) = item.node {\n+                            this.with_trait_impl_ref(opt_trait_ref, |this| {\n+                                visit::walk_item(this, item)\n+                            });\n+                        } else {\n+                            visit::walk_item(this, item);\n+                        }\n+                    });\n                 }\n             }\n \n@@ -674,41 +678,31 @@ impl<'a> LoweringContext<'a> {\n                 // that collisions are ok here and this shouldn't\n                 // really show up for end-user.\n                 let str_name = match hir_name {\n-                    hir::LifetimeName::Name(n) => n.as_str(),\n-                    hir::LifetimeName::Fresh(_) => keywords::UnderscoreLifetime.name().as_str(),\n-                    hir::LifetimeName::Implicit\n-                    | hir::LifetimeName::Underscore\n-                    | hir::LifetimeName::Static => {\n-                        span_bug!(span, \"unexpected in-band lifetime name: {:?}\", hir_name)\n-                    }\n+                    ParamName::Plain(name) => name.as_str(),\n+                    ParamName::Fresh(_) => keywords::UnderscoreLifetime.name().as_str(),\n                 };\n \n                 // Add a definition for the in-band lifetime def\n                 self.resolver.definitions().create_def_with_parent(\n                     parent_id.index,\n                     def_node_id,\n-                    DefPathData::LifetimeDef(str_name.as_interned_str()),\n+                    DefPathData::LifetimeParam(str_name.as_interned_str()),\n                     DefIndexAddressSpace::High,\n                     Mark::root(),\n                     span,\n                 );\n \n-                hir::GenericParam::Lifetime(hir::LifetimeDef {\n-                    lifetime: hir::Lifetime {\n-                        id: def_node_id,\n-                        span,\n-                        name: hir_name,\n-                    },\n-                    bounds: Vec::new().into(),\n+                hir::GenericParam {\n+                    id: def_node_id,\n+                    name: hir_name,\n+                    attrs: hir_vec![],\n+                    bounds: hir_vec![],\n+                    span,\n                     pure_wrt_drop: false,\n-                    in_band: true,\n-                })\n+                    kind: hir::GenericParamKind::Lifetime { in_band: true }\n+                }\n             })\n-            .chain(\n-                in_band_ty_params\n-                    .into_iter()\n-                    .map(|tp| hir::GenericParam::Type(tp)),\n-            )\n+            .chain(in_band_ty_params.into_iter())\n             .collect();\n \n         (params, res)\n@@ -727,12 +721,9 @@ impl<'a> LoweringContext<'a> {\n             return;\n         }\n \n-        let hir_name = hir::LifetimeName::Name(name);\n+        let hir_name = ParamName::Plain(name);\n \n-        if self.lifetimes_to_define\n-            .iter()\n-            .any(|(_, lt_name)| *lt_name == hir_name)\n-        {\n+        if self.lifetimes_to_define.iter().any(|(_, lt_name)| *lt_name == hir_name) {\n             return;\n         }\n \n@@ -741,28 +732,27 @@ impl<'a> LoweringContext<'a> {\n \n     /// When we have either an elided or `'_` lifetime in an impl\n     /// header, we convert it to\n-    fn collect_fresh_in_band_lifetime(&mut self, span: Span) -> hir::LifetimeName {\n+    fn collect_fresh_in_band_lifetime(&mut self, span: Span) -> ParamName {\n         assert!(self.is_collecting_in_band_lifetimes);\n         let index = self.lifetimes_to_define.len();\n-        let hir_name = hir::LifetimeName::Fresh(index);\n+        let hir_name = ParamName::Fresh(index);\n         self.lifetimes_to_define.push((span, hir_name));\n         hir_name\n     }\n \n-    // Evaluates `f` with the lifetimes in `lt_defs` in-scope.\n+    // Evaluates `f` with the lifetimes in `params` in-scope.\n     // This is used to track which lifetimes have already been defined, and\n     // which are new in-band lifetimes that need to have a definition created\n     // for them.\n-    fn with_in_scope_lifetime_defs<'l, T, F>(\n-        &mut self,\n-        lt_defs: impl Iterator<Item = &'l LifetimeDef>,\n-        f: F,\n-    ) -> T\n+    fn with_in_scope_lifetime_defs<T, F>(&mut self, params: &Vec<GenericParam>, f: F) -> T\n     where\n         F: FnOnce(&mut LoweringContext) -> T,\n     {\n         let old_len = self.in_scope_lifetimes.len();\n-        let lt_def_names = lt_defs.map(|lt_def| lt_def.lifetime.ident.name);\n+        let lt_def_names = params.iter().filter_map(|param| match param.kind {\n+            GenericParamKind::Lifetime { .. } => Some(param.ident.name),\n+            _ => None,\n+        });\n         self.in_scope_lifetimes.extend(lt_def_names);\n \n         let res = f(self);\n@@ -771,17 +761,22 @@ impl<'a> LoweringContext<'a> {\n         res\n     }\n \n-    // Same as the method above, but accepts `hir::LifetimeDef`s\n-    // instead of `ast::LifetimeDef`s.\n+    // Same as the method above, but accepts `hir::GenericParam`s\n+    // instead of `ast::GenericParam`s.\n     // This should only be used with generics that have already had their\n     // in-band lifetimes added. In practice, this means that this function is\n     // only used when lowering a child item of a trait or impl.\n-    fn with_parent_impl_lifetime_defs<T, F>(&mut self, lt_defs: &[hir::LifetimeDef], f: F) -> T\n-    where\n+    fn with_parent_impl_lifetime_defs<T, F>(&mut self,\n+        params: &HirVec<hir::GenericParam>,\n+        f: F\n+    ) -> T where\n         F: FnOnce(&mut LoweringContext) -> T,\n     {\n         let old_len = self.in_scope_lifetimes.len();\n-        let lt_def_names = lt_defs.iter().map(|lt_def| lt_def.lifetime.name.name());\n+        let lt_def_names = params.iter().filter_map(|param| match param.kind {\n+            hir::GenericParamKind::Lifetime { .. } => Some(param.name.name()),\n+            _ => None,\n+        });\n         self.in_scope_lifetimes.extend(lt_def_names);\n \n         let res = f(self);\n@@ -807,10 +802,7 @@ impl<'a> LoweringContext<'a> {\n         F: FnOnce(&mut LoweringContext) -> T,\n     {\n         let (in_band_defs, (mut lowered_generics, res)) = self.with_in_scope_lifetime_defs(\n-            generics.params.iter().filter_map(|p| match p {\n-                GenericParam::Lifetime(ld) => Some(ld),\n-                _ => None,\n-            }),\n+            &generics.params,\n             |this| {\n                 let itctx = ImplTraitContext::Universal(parent_id);\n                 this.collect_in_band_defs(parent_id, anonymous_lifetime_mode, |this| {\n@@ -1037,6 +1029,16 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n+    fn lower_generic_arg(&mut self,\n+                        arg: &ast::GenericArg,\n+                        itctx: ImplTraitContext)\n+                        -> hir::GenericArg {\n+        match arg {\n+            ast::GenericArg::Lifetime(lt) => GenericArg::Lifetime(self.lower_lifetime(&lt)),\n+            ast::GenericArg::Type(ty) => GenericArg::Type(self.lower_ty(&ty, itctx)),\n+        }\n+    }\n+\n     fn lower_ty(&mut self, t: &Ty, itctx: ImplTraitContext) -> P<hir::Ty> {\n         let kind = match t.node {\n             TyKind::Infer => hir::TyInfer,\n@@ -1052,10 +1054,7 @@ impl<'a> LoweringContext<'a> {\n                 hir::TyRptr(lifetime, self.lower_mt(mt, itctx))\n             }\n             TyKind::BareFn(ref f) => self.with_in_scope_lifetime_defs(\n-                f.generic_params.iter().filter_map(|p| match p {\n-                    GenericParam::Lifetime(ld) => Some(ld),\n-                    _ => None,\n-                }),\n+                &f.generic_params,\n                 |this| {\n                     this.with_anonymous_lifetime_mode(\n                         AnonymousLifetimeMode::PassThrough,\n@@ -1110,11 +1109,11 @@ impl<'a> LoweringContext<'a> {\n                 let bounds = bounds\n                     .iter()\n                     .filter_map(|bound| match *bound {\n-                        TraitTyParamBound(ref ty, TraitBoundModifier::None) => {\n+                        GenericBound::Trait(ref ty, TraitBoundModifier::None) => {\n                             Some(self.lower_poly_trait_ref(ty, itctx))\n                         }\n-                        TraitTyParamBound(_, TraitBoundModifier::Maybe) => None,\n-                        RegionTyParamBound(ref lifetime) => {\n+                        GenericBound::Trait(_, TraitBoundModifier::Maybe) => None,\n+                        GenericBound::Outlives(ref lifetime) => {\n                             if lifetime_bound.is_none() {\n                                 lifetime_bound = Some(self.lower_lifetime(lifetime));\n                             }\n@@ -1166,7 +1165,7 @@ impl<'a> LoweringContext<'a> {\n                         self.allocate_hir_id_counter(exist_ty_node_id, t);\n \n                         let hir_bounds = self.with_hir_id_owner(exist_ty_node_id, |lctx| {\n-                            lctx.lower_bounds(bounds, itctx)\n+                            lctx.lower_param_bounds(bounds, itctx)\n                         });\n \n                         let (lifetimes, lifetime_defs) = self.lifetimes_from_impl_trait_bounds(\n@@ -1233,18 +1232,20 @@ impl<'a> LoweringContext<'a> {\n                             span,\n                         );\n \n-                        let hir_bounds = self.lower_bounds(bounds, itctx);\n+                        let hir_bounds = self.lower_param_bounds(bounds, itctx);\n                         // Set the name to `impl Bound1 + Bound2`\n                         let name = Symbol::intern(&pprust::ty_to_string(t));\n-                        self.in_band_ty_params.push(hir::TyParam {\n-                            name,\n+                        self.in_band_ty_params.push(hir::GenericParam {\n                             id: def_node_id,\n-                            bounds: hir_bounds,\n-                            default: None,\n+                            name: ParamName::Plain(name),\n                             span,\n                             pure_wrt_drop: false,\n-                            synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n-                            attrs: P::new(),\n+                            attrs: hir_vec![],\n+                            bounds: hir_bounds,\n+                            kind: hir::GenericParamKind::Type {\n+                                default: None,\n+                                synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n+                            }\n                         });\n \n                         hir::TyPath(hir::QPath::Resolved(\n@@ -1284,7 +1285,7 @@ impl<'a> LoweringContext<'a> {\n         &mut self,\n         exist_ty_id: NodeId,\n         parent_index: DefIndex,\n-        bounds: &hir::TyParamBounds,\n+        bounds: &hir::GenericBounds,\n     ) -> (HirVec<hir::Lifetime>, HirVec<hir::GenericParam>) {\n         // This visitor walks over impl trait bounds and creates defs for all lifetimes which\n         // appear in the bounds, excluding lifetimes that are created within the bounds.\n@@ -1307,15 +1308,15 @@ impl<'a> LoweringContext<'a> {\n                 hir::intravisit::NestedVisitorMap::None\n             }\n \n-            fn visit_path_parameters(&mut self, span: Span, parameters: &'v hir::PathParameters) {\n+            fn visit_generic_args(&mut self, span: Span, parameters: &'v hir::GenericArgs) {\n                 // Don't collect elided lifetimes used inside of `Fn()` syntax.\n                 if parameters.parenthesized {\n                     let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n                     self.collect_elided_lifetimes = false;\n-                    hir::intravisit::walk_path_parameters(self, span, parameters);\n+                    hir::intravisit::walk_generic_args(self, span, parameters);\n                     self.collect_elided_lifetimes = old_collect_elided_lifetimes;\n                 } else {\n-                    hir::intravisit::walk_path_parameters(self, span, parameters);\n+                    hir::intravisit::walk_generic_args(self, span, parameters);\n                 }\n             }\n \n@@ -1351,10 +1352,11 @@ impl<'a> LoweringContext<'a> {\n \n             fn visit_generic_param(&mut self, param: &'v hir::GenericParam) {\n                 // Record the introduction of 'a in `for<'a> ...`\n-                if let hir::GenericParam::Lifetime(ref lt_def) = *param {\n+                if let hir::GenericParamKind::Lifetime { .. } = param.kind {\n                     // Introduce lifetimes one at a time so that we can handle\n                     // cases like `fn foo<'d>() -> impl for<'a, 'b: 'a, 'c: 'b + 'd>`\n-                    self.currently_bound_lifetimes.push(lt_def.lifetime.name);\n+                    let lt_name = hir::LifetimeName::Param(param.name);\n+                    self.currently_bound_lifetimes.push(lt_name);\n                 }\n \n                 hir::intravisit::walk_generic_param(self, param);\n@@ -1371,14 +1373,12 @@ impl<'a> LoweringContext<'a> {\n                             return;\n                         }\n                     }\n-                    name @ hir::LifetimeName::Fresh(_) => name,\n-                    name @ hir::LifetimeName::Name(_) => name,\n+                    hir::LifetimeName::Param(_) => lifetime.name,\n                     hir::LifetimeName::Static => return,\n                 };\n \n                 if !self.currently_bound_lifetimes.contains(&name)\n-                    && !self.already_defined_lifetimes.contains(&name)\n-                {\n+                    && !self.already_defined_lifetimes.contains(&name) {\n                     self.already_defined_lifetimes.insert(name);\n \n                     self.output_lifetimes.push(hir::Lifetime {\n@@ -1395,23 +1395,31 @@ impl<'a> LoweringContext<'a> {\n                     self.context.resolver.definitions().create_def_with_parent(\n                         self.parent,\n                         def_node_id,\n-                        DefPathData::LifetimeDef(name.name().as_interned_str()),\n+                        DefPathData::LifetimeParam(name.name().as_interned_str()),\n                         DefIndexAddressSpace::High,\n                         Mark::root(),\n                         lifetime.span,\n                     );\n-                    let def_lifetime = hir::Lifetime {\n+\n+                    let name = match name {\n+                        hir::LifetimeName::Underscore => {\n+                            hir::ParamName::Plain(keywords::UnderscoreLifetime.name())\n+                        }\n+                        hir::LifetimeName::Param(param_name) => param_name,\n+                        _ => bug!(\"expected LifetimeName::Param or ParamName::Plain\"),\n+                    };\n+\n+                    self.output_lifetime_params.push(hir::GenericParam {\n                         id: def_node_id,\n-                        span: lifetime.span,\n                         name,\n-                    };\n-                    self.output_lifetime_params\n-                        .push(hir::GenericParam::Lifetime(hir::LifetimeDef {\n-                            lifetime: def_lifetime,\n-                            bounds: Vec::new().into(),\n-                            pure_wrt_drop: false,\n+                        span: lifetime.span,\n+                        pure_wrt_drop: false,\n+                        attrs: hir_vec![],\n+                        bounds: hir_vec![],\n+                        kind: hir::GenericParamKind::Lifetime {\n                             in_band: false,\n-                        }));\n+                        }\n+                    });\n                 }\n             }\n         }\n@@ -1428,7 +1436,7 @@ impl<'a> LoweringContext<'a> {\n         };\n \n         for bound in bounds {\n-            hir::intravisit::walk_ty_param_bound(&mut lifetime_collector, &bound);\n+            hir::intravisit::walk_param_bound(&mut lifetime_collector, &bound);\n         }\n \n         (\n@@ -1669,13 +1677,13 @@ impl<'a> LoweringContext<'a> {\n         parenthesized_generic_args: ParenthesizedGenericArgs,\n         itctx: ImplTraitContext,\n     ) -> hir::PathSegment {\n-        let (mut parameters, infer_types) = if let Some(ref parameters) = segment.parameters {\n+        let (mut generic_args, infer_types) = if let Some(ref generic_args) = segment.args {\n             let msg = \"parenthesized parameters may only be used with a trait\";\n-            match **parameters {\n-                PathParameters::AngleBracketed(ref data) => {\n+            match **generic_args {\n+                GenericArgs::AngleBracketed(ref data) => {\n                     self.lower_angle_bracketed_parameter_data(data, param_mode, itctx)\n                 }\n-                PathParameters::Parenthesized(ref data) => match parenthesized_generic_args {\n+                GenericArgs::Parenthesized(ref data) => match parenthesized_generic_args {\n                     ParenthesizedGenericArgs::Ok => self.lower_parenthesized_parameter_data(data),\n                     ParenthesizedGenericArgs::Warn => {\n                         self.sess.buffer_lint(\n@@ -1684,61 +1692,63 @@ impl<'a> LoweringContext<'a> {\n                             data.span,\n                             msg.into(),\n                         );\n-                        (hir::PathParameters::none(), true)\n+                        (hir::GenericArgs::none(), true)\n                     }\n                     ParenthesizedGenericArgs::Err => {\n                         struct_span_err!(self.sess, data.span, E0214, \"{}\", msg)\n                             .span_label(data.span, \"only traits may use parentheses\")\n                             .emit();\n-                        (hir::PathParameters::none(), true)\n+                        (hir::GenericArgs::none(), true)\n                     }\n                 },\n             }\n         } else {\n             self.lower_angle_bracketed_parameter_data(&Default::default(), param_mode, itctx)\n         };\n \n-        if !parameters.parenthesized && parameters.lifetimes.is_empty() {\n-            parameters.lifetimes = self.elided_path_lifetimes(path_span, expected_lifetimes);\n+        let has_lifetimes = generic_args.args.iter().any(|arg| match arg {\n+            GenericArg::Lifetime(_) => true,\n+            _ => false,\n+        });\n+        if !generic_args.parenthesized && !has_lifetimes {\n+            generic_args.args =\n+                self.elided_path_lifetimes(path_span, expected_lifetimes)\n+                    .into_iter()\n+                    .map(|lt| GenericArg::Lifetime(lt))\n+                    .chain(generic_args.args.into_iter())\n+                    .collect();\n         }\n \n         hir::PathSegment::new(\n             self.lower_ident(segment.ident),\n-            parameters,\n+            generic_args,\n             infer_types,\n         )\n     }\n \n     fn lower_angle_bracketed_parameter_data(\n         &mut self,\n-        data: &AngleBracketedParameterData,\n+        data: &AngleBracketedArgs,\n         param_mode: ParamMode,\n         itctx: ImplTraitContext,\n-    ) -> (hir::PathParameters, bool) {\n-        let &AngleBracketedParameterData {\n-            ref lifetimes,\n-            ref types,\n-            ref bindings,\n-            ..\n-        } = data;\n-        (\n-            hir::PathParameters {\n-                lifetimes: self.lower_lifetimes(lifetimes),\n-                types: types.iter().map(|ty| self.lower_ty(ty, itctx)).collect(),\n-                bindings: bindings\n-                    .iter()\n-                    .map(|b| self.lower_ty_binding(b, itctx))\n-                    .collect(),\n-                parenthesized: false,\n-            },\n-            types.is_empty() && param_mode == ParamMode::Optional,\n-        )\n+    ) -> (hir::GenericArgs, bool) {\n+        let &AngleBracketedArgs { ref args, ref bindings, .. } = data;\n+        let has_types = args.iter().any(|arg| match arg {\n+            ast::GenericArg::Type(_) => true,\n+            _ => false,\n+        });\n+        (hir::GenericArgs {\n+            args: args.iter().map(|a| self.lower_generic_arg(a, itctx)).collect(),\n+            bindings: bindings.iter().map(|b| self.lower_ty_binding(b, itctx)).collect(),\n+            parenthesized: false,\n+        },\n+        !has_types && param_mode == ParamMode::Optional)\n     }\n \n     fn lower_parenthesized_parameter_data(\n         &mut self,\n-        data: &ParenthesizedParameterData,\n-    ) -> (hir::PathParameters, bool) {\n+        data: &ParenthesisedArgs,\n+    ) -> (hir::GenericArgs, bool) {\n         // Switch to `PassThrough` mode for anonymous lifetimes: this\n         // means that we permit things like `&Ref<T>`, where `Ref` has\n         // a hidden lifetime parameter. This is needed for backwards\n@@ -1748,29 +1758,16 @@ impl<'a> LoweringContext<'a> {\n             AnonymousLifetimeMode::PassThrough,\n             |this| {\n                 const DISALLOWED: ImplTraitContext = ImplTraitContext::Disallowed;\n-                let &ParenthesizedParameterData {\n-                    ref inputs,\n-                    ref output,\n-                    span,\n-                } = data;\n-                let inputs = inputs\n-                    .iter()\n-                    .map(|ty| this.lower_ty(ty, DISALLOWED))\n-                    .collect();\n+                let &ParenthesisedArgs { ref inputs, ref output, span } = data;\n+                let inputs = inputs.iter().map(|ty| this.lower_ty(ty, DISALLOWED)).collect();\n                 let mk_tup = |this: &mut Self, tys, span| {\n                     let LoweredNodeId { node_id, hir_id } = this.next_id();\n-                    P(hir::Ty {\n-                        node: hir::TyTup(tys),\n-                        id: node_id,\n-                        hir_id,\n-                        span,\n-                    })\n+                    P(hir::Ty { node: hir::TyTup(tys), id: node_id, hir_id, span })\n                 };\n \n                 (\n-                    hir::PathParameters {\n-                        lifetimes: hir::HirVec::new(),\n-                        types: hir_vec![mk_tup(this, inputs, span)],\n+                    hir::GenericArgs {\n+                        args: hir_vec![GenericArg::Type(mk_tup(this, inputs, span))],\n                         bindings: hir_vec![\n                             hir::TypeBinding {\n                                 id: this.next_id().node_id,\n@@ -1874,71 +1871,30 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn lower_ty_param_bound(\n+    fn lower_param_bound(\n         &mut self,\n-        tpb: &TyParamBound,\n+        tpb: &GenericBound,\n         itctx: ImplTraitContext,\n-    ) -> hir::TyParamBound {\n+    ) -> hir::GenericBound {\n         match *tpb {\n-            TraitTyParamBound(ref ty, modifier) => hir::TraitTyParamBound(\n+            GenericBound::Trait(ref ty, modifier) => hir::GenericBound::Trait(\n                 self.lower_poly_trait_ref(ty, itctx),\n                 self.lower_trait_bound_modifier(modifier),\n             ),\n-            RegionTyParamBound(ref lifetime) => {\n-                hir::RegionTyParamBound(self.lower_lifetime(lifetime))\n+            GenericBound::Outlives(ref lifetime) => {\n+                hir::GenericBound::Outlives(self.lower_lifetime(lifetime))\n             }\n         }\n     }\n \n-    fn lower_ty_param(\n-        &mut self,\n-        tp: &TyParam,\n-        add_bounds: &[TyParamBound],\n-        itctx: ImplTraitContext,\n-    ) -> hir::TyParam {\n-        let mut name = self.lower_ident(tp.ident);\n-\n-        // Don't expose `Self` (recovered \"keyword used as ident\" parse error).\n-        // `rustc::ty` expects `Self` to be only used for a trait's `Self`.\n-        // Instead, use gensym(\"Self\") to create a distinct name that looks the same.\n-        if name == keywords::SelfType.name() {\n-            name = Symbol::gensym(\"Self\");\n-        }\n-\n-        let mut bounds = self.lower_bounds(&tp.bounds, itctx);\n-        if !add_bounds.is_empty() {\n-            bounds = bounds\n-                .into_iter()\n-                .chain(self.lower_bounds(add_bounds, itctx).into_iter())\n-                .collect();\n-        }\n-\n-        hir::TyParam {\n-            id: self.lower_node_id(tp.id).node_id,\n-            name,\n-            bounds,\n-            default: tp.default\n-                .as_ref()\n-                .map(|x| self.lower_ty(x, ImplTraitContext::Disallowed)),\n-            span: tp.ident.span,\n-            pure_wrt_drop: attr::contains_name(&tp.attrs, \"may_dangle\"),\n-            synthetic: tp.attrs\n-                .iter()\n-                .filter(|attr| attr.check_name(\"rustc_synthetic\"))\n-                .map(|_| hir::SyntheticTyParamKind::ImplTrait)\n-                .nth(0),\n-            attrs: self.lower_attrs(&tp.attrs),\n-        }\n-    }\n-\n     fn lower_lifetime(&mut self, l: &Lifetime) -> hir::Lifetime {\n         let span = l.ident.span;\n         match self.lower_ident(l.ident) {\n             x if x == \"'static\" => self.new_named_lifetime(l.id, span, hir::LifetimeName::Static),\n             x if x == \"'_\" => match self.anonymous_lifetime_mode {\n                 AnonymousLifetimeMode::CreateParameter => {\n                     let fresh_name = self.collect_fresh_in_band_lifetime(span);\n-                    self.new_named_lifetime(l.id, span, fresh_name)\n+                    self.new_named_lifetime(l.id, span, hir::LifetimeName::Param(fresh_name))\n                 }\n \n                 AnonymousLifetimeMode::PassThrough => {\n@@ -1947,7 +1903,8 @@ impl<'a> LoweringContext<'a> {\n             },\n             name => {\n                 self.maybe_collect_in_band_lifetime(span, name);\n-                self.new_named_lifetime(l.id, span, hir::LifetimeName::Name(name))\n+                let param_name = ParamName::Plain(name);\n+                self.new_named_lifetime(l.id, span, hir::LifetimeName::Param(param_name))\n             }\n         }\n     }\n@@ -1965,57 +1922,98 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_lifetime_def(&mut self, l: &LifetimeDef) -> hir::LifetimeDef {\n-        let was_collecting_in_band = self.is_collecting_in_band_lifetimes;\n-        self.is_collecting_in_band_lifetimes = false;\n-\n-        let def = hir::LifetimeDef {\n-            lifetime: self.lower_lifetime(&l.lifetime),\n-            bounds: self.lower_lifetimes(&l.bounds),\n-            pure_wrt_drop: attr::contains_name(&l.attrs, \"may_dangle\"),\n-            in_band: false,\n-        };\n-\n-        self.is_collecting_in_band_lifetimes = was_collecting_in_band;\n-\n-        def\n-    }\n-\n-    fn lower_lifetimes(&mut self, lts: &Vec<Lifetime>) -> hir::HirVec<hir::Lifetime> {\n-        lts.iter().map(|l| self.lower_lifetime(l)).collect()\n-    }\n-\n     fn lower_generic_params(\n         &mut self,\n         params: &Vec<GenericParam>,\n-        add_bounds: &NodeMap<Vec<TyParamBound>>,\n+        add_bounds: &NodeMap<Vec<GenericBound>>,\n         itctx: ImplTraitContext,\n     ) -> hir::HirVec<hir::GenericParam> {\n-        params\n-            .iter()\n-            .map(|param| match *param {\n-                GenericParam::Lifetime(ref lifetime_def) => {\n-                    hir::GenericParam::Lifetime(self.lower_lifetime_def(lifetime_def))\n+        params.iter().map(|param| self.lower_generic_param(param, add_bounds, itctx)).collect()\n+    }\n+\n+    fn lower_generic_param(&mut self,\n+                           param: &GenericParam,\n+                           add_bounds: &NodeMap<Vec<GenericBound>>,\n+                           itctx: ImplTraitContext)\n+                           -> hir::GenericParam {\n+        let mut bounds = self.lower_param_bounds(&param.bounds, itctx);\n+        match param.kind {\n+            GenericParamKind::Lifetime => {\n+                let was_collecting_in_band = self.is_collecting_in_band_lifetimes;\n+                self.is_collecting_in_band_lifetimes = false;\n+\n+                let lt = self.lower_lifetime(&Lifetime { id: param.id, ident: param.ident });\n+                let param_name = match lt.name {\n+                    hir::LifetimeName::Param(param_name) => param_name,\n+                    _ => hir::ParamName::Plain(lt.name.name()),\n+                };\n+                let param = hir::GenericParam {\n+                    id: lt.id,\n+                    name: param_name,\n+                    span: lt.span,\n+                    pure_wrt_drop: attr::contains_name(&param.attrs, \"may_dangle\"),\n+                    attrs: self.lower_attrs(&param.attrs),\n+                    bounds,\n+                    kind: hir::GenericParamKind::Lifetime { in_band: false }\n+                };\n+\n+                self.is_collecting_in_band_lifetimes = was_collecting_in_band;\n+\n+                param\n+            }\n+            GenericParamKind::Type { ref default, .. } => {\n+                let mut name = self.lower_ident(param.ident);\n+\n+                // Don't expose `Self` (recovered \"keyword used as ident\" parse error).\n+                // `rustc::ty` expects `Self` to be only used for a trait's `Self`.\n+                // Instead, use gensym(\"Self\") to create a distinct name that looks the same.\n+                if name == keywords::SelfType.name() {\n+                    name = Symbol::gensym(\"Self\");\n                 }\n-                GenericParam::Type(ref ty_param) => hir::GenericParam::Type(self.lower_ty_param(\n-                    ty_param,\n-                    add_bounds.get(&ty_param.id).map_or(&[][..], |x| &x),\n-                    itctx,\n-                )),\n-            })\n-            .collect()\n+\n+                let add_bounds = add_bounds.get(&param.id).map_or(&[][..], |x| &x);\n+                if !add_bounds.is_empty() {\n+                    bounds = bounds.into_iter()\n+                                   .chain(self.lower_param_bounds(add_bounds, itctx).into_iter())\n+                                   .collect();\n+                }\n+\n+                hir::GenericParam {\n+                    id: self.lower_node_id(param.id).node_id,\n+                    name: hir::ParamName::Plain(name),\n+                    span: param.ident.span,\n+                    pure_wrt_drop: attr::contains_name(&param.attrs, \"may_dangle\"),\n+                    attrs: self.lower_attrs(&param.attrs),\n+                    bounds,\n+                    kind: hir::GenericParamKind::Type {\n+                        default: default.as_ref().map(|x| {\n+                            self.lower_ty(x, ImplTraitContext::Disallowed)\n+                        }),\n+                        synthetic: param.attrs.iter()\n+                                              .filter(|attr| attr.check_name(\"rustc_synthetic\"))\n+                                              .map(|_| hir::SyntheticTyParamKind::ImplTrait)\n+                                              .next(),\n+                    }\n+                }\n+            }\n+        }\n     }\n \n-    fn lower_generics(&mut self, g: &Generics, itctx: ImplTraitContext) -> hir::Generics {\n+    fn lower_generics(\n+        &mut self,\n+        generics: &Generics,\n+        itctx: ImplTraitContext)\n+        -> hir::Generics\n+    {\n         // Collect `?Trait` bounds in where clause and move them to parameter definitions.\n         // FIXME: This could probably be done with less rightward drift. Also looks like two control\n         //        paths where report_error is called are also the only paths that advance to after\n         //        the match statement, so the error reporting could probably just be moved there.\n         let mut add_bounds = NodeMap();\n-        for pred in &g.where_clause.predicates {\n+        for pred in &generics.where_clause.predicates {\n             if let WherePredicate::BoundPredicate(ref bound_pred) = *pred {\n                 'next_bound: for bound in &bound_pred.bounds {\n-                    if let TraitTyParamBound(_, TraitBoundModifier::Maybe) = *bound {\n+                    if let GenericBound::Trait(_, TraitBoundModifier::Maybe) = *bound {\n                         let report_error = |this: &mut Self| {\n                             this.diagnostic().span_err(\n                                 bound_pred.bounded_ty.span,\n@@ -2036,15 +2034,17 @@ impl<'a> LoweringContext<'a> {\n                                     if let Some(node_id) =\n                                         self.resolver.definitions().as_local_node_id(def_id)\n                                     {\n-                                        for param in &g.params {\n-                                            if let GenericParam::Type(ref ty_param) = *param {\n-                                                if node_id == ty_param.id {\n-                                                    add_bounds\n-                                                        .entry(ty_param.id)\n-                                                        .or_insert(Vec::new())\n-                                                        .push(bound.clone());\n-                                                    continue 'next_bound;\n+                                        for param in &generics.params {\n+                                            match param.kind {\n+                                                GenericParamKind::Type { .. } => {\n+                                                    if node_id == param.id {\n+                                                        add_bounds.entry(param.id)\n+                                                            .or_insert(Vec::new())\n+                                                            .push(bound.clone());\n+                                                        continue 'next_bound;\n+                                                    }\n                                                 }\n+                                                _ => {}\n                                             }\n                                         }\n                                     }\n@@ -2059,9 +2059,9 @@ impl<'a> LoweringContext<'a> {\n         }\n \n         hir::Generics {\n-            params: self.lower_generic_params(&g.params, &add_bounds, itctx),\n-            where_clause: self.lower_where_clause(&g.where_clause),\n-            span: g.span,\n+            params: self.lower_generic_params(&generics.params, &add_bounds, itctx),\n+            where_clause: self.lower_where_clause(&generics.where_clause),\n+            span: generics.span,\n         }\n     }\n \n@@ -2084,10 +2084,7 @@ impl<'a> LoweringContext<'a> {\n                 span,\n             }) => {\n                 self.with_in_scope_lifetime_defs(\n-                    bound_generic_params.iter().filter_map(|p| match p {\n-                        GenericParam::Lifetime(ld) => Some(ld),\n-                        _ => None,\n-                    }),\n+                    &bound_generic_params,\n                     |this| {\n                         hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n                             bound_generic_params: this.lower_generic_params(\n@@ -2101,8 +2098,8 @@ impl<'a> LoweringContext<'a> {\n                                 .filter_map(|bound| match *bound {\n                                     // Ignore `?Trait` bounds.\n                                     // Tthey were copied into type parameters already.\n-                                    TraitTyParamBound(_, TraitBoundModifier::Maybe) => None,\n-                                    _ => Some(this.lower_ty_param_bound(\n+                                    GenericBound::Trait(_, TraitBoundModifier::Maybe) => None,\n+                                    _ => Some(this.lower_param_bound(\n                                         bound,\n                                         ImplTraitContext::Disallowed,\n                                     )),\n@@ -2120,10 +2117,7 @@ impl<'a> LoweringContext<'a> {\n             }) => hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n                 span,\n                 lifetime: self.lower_lifetime(lifetime),\n-                bounds: bounds\n-                    .iter()\n-                    .map(|bound| self.lower_lifetime(bound))\n-                    .collect(),\n+                bounds: self.lower_param_bounds(bounds, ImplTraitContext::Disallowed),\n             }),\n             WherePredicate::EqPredicate(WhereEqPredicate {\n                 id,\n@@ -2180,13 +2174,7 @@ impl<'a> LoweringContext<'a> {\n         let bound_generic_params =\n             self.lower_generic_params(&p.bound_generic_params, &NodeMap(), itctx);\n         let trait_ref = self.with_parent_impl_lifetime_defs(\n-            &bound_generic_params\n-                .iter()\n-                .filter_map(|p| match *p {\n-                    hir::GenericParam::Lifetime(ref ld) => Some(ld.clone()),\n-                    _ => None,\n-                })\n-                .collect::<Vec<_>>(),\n+            &bound_generic_params,\n             |this| this.lower_trait_ref(&p.trait_ref, itctx),\n         );\n \n@@ -2229,15 +2217,9 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_bounds(\n-        &mut self,\n-        bounds: &[TyParamBound],\n-        itctx: ImplTraitContext,\n-    ) -> hir::TyParamBounds {\n-        bounds\n-            .iter()\n-            .map(|bound| self.lower_ty_param_bound(bound, itctx))\n-            .collect()\n+    fn lower_param_bounds(&mut self, bounds: &[GenericBound], itctx: ImplTraitContext)\n+        -> hir::GenericBounds {\n+        bounds.iter().map(|bound| self.lower_param_bound(bound, itctx)).collect()\n     }\n \n     fn lower_block(&mut self, b: &Block, targeted_by_break: bool) -> P<hir::Block> {\n@@ -2403,10 +2385,7 @@ impl<'a> LoweringContext<'a> {\n                 );\n \n                 let new_impl_items = self.with_in_scope_lifetime_defs(\n-                    ast_generics.params.iter().filter_map(|p| match p {\n-                        GenericParam::Lifetime(ld) => Some(ld),\n-                        _ => None,\n-                    }),\n+                    &ast_generics.params,\n                     |this| {\n                         impl_items\n                             .iter()\n@@ -2426,7 +2405,7 @@ impl<'a> LoweringContext<'a> {\n                 )\n             }\n             ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref items) => {\n-                let bounds = self.lower_bounds(bounds, ImplTraitContext::Disallowed);\n+                let bounds = self.lower_param_bounds(bounds, ImplTraitContext::Disallowed);\n                 let items = items\n                     .iter()\n                     .map(|item| self.lower_trait_item_ref(item))\n@@ -2441,7 +2420,7 @@ impl<'a> LoweringContext<'a> {\n             }\n             ItemKind::TraitAlias(ref generics, ref bounds) => hir::ItemTraitAlias(\n                 self.lower_generics(generics, ImplTraitContext::Disallowed),\n-                self.lower_bounds(bounds, ImplTraitContext::Disallowed),\n+                self.lower_param_bounds(bounds, ImplTraitContext::Disallowed),\n             ),\n             ItemKind::MacroDef(..) | ItemKind::Mac(..) => panic!(\"Shouldn't still be around\"),\n         }\n@@ -2668,7 +2647,7 @@ impl<'a> LoweringContext<'a> {\n             TraitItemKind::Type(ref bounds, ref default) => (\n                 self.lower_generics(&i.generics, ImplTraitContext::Disallowed),\n                 hir::TraitItemKind::Type(\n-                    self.lower_bounds(bounds, ImplTraitContext::Disallowed),\n+                    self.lower_param_bounds(bounds, ImplTraitContext::Disallowed),\n                     default\n                         .as_ref()\n                         .map(|x| self.lower_ty(x, ImplTraitContext::Disallowed)),\n@@ -4217,7 +4196,7 @@ impl<'a> LoweringContext<'a> {\n                 hir::Lifetime {\n                     id: self.next_id().node_id,\n                     span,\n-                    name: fresh_name,\n+                    name: hir::LifetimeName::Param(fresh_name),\n                 }\n             }\n "}, {"sha": "14cecba490d0ab3c99258ab9f7ab2429ce46d8f2", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -212,7 +212,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             NodeBlock(n) => EntryBlock(parent, dep_node_index, n),\n             NodeStructCtor(n) => EntryStructCtor(parent, dep_node_index, n),\n             NodeLifetime(n) => EntryLifetime(parent, dep_node_index, n),\n-            NodeTyParam(n) => EntryTyParam(parent, dep_node_index, n),\n+            NodeGenericParam(n) => EntryGenericParam(parent, dep_node_index, n),\n             NodeVisibility(n) => EntryVisibility(parent, dep_node_index, n),\n             NodeLocal(n) => EntryLocal(parent, dep_node_index, n),\n             NodeMacroDef(n) => EntryMacroDef(dep_node_index, n),\n@@ -347,14 +347,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_generic_param(&mut self, param: &'hir GenericParam) {\n-        match *param {\n-            GenericParam::Lifetime(ref ld) => {\n-                self.insert(ld.lifetime.id, NodeLifetime(&ld.lifetime));\n-            }\n-            GenericParam::Type(ref ty_param) => {\n-                self.insert(ty_param.id, NodeTyParam(ty_param));\n-            }\n-        }\n+        self.insert(param.id, NodeGenericParam(param));\n         intravisit::walk_generic_param(self, param);\n     }\n "}, {"sha": "8aa5dd4ad80fd36c6a2a1fa54395bd62bbcba6ba", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -171,24 +171,12 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     }\n \n     fn visit_generic_param(&mut self, param: &'a GenericParam) {\n-        match *param {\n-            GenericParam::Lifetime(ref lifetime_def) => {\n-                self.create_def(\n-                    lifetime_def.lifetime.id,\n-                    DefPathData::LifetimeDef(lifetime_def.lifetime.ident.name.as_interned_str()),\n-                    REGULAR_SPACE,\n-                    lifetime_def.lifetime.ident.span\n-                );\n-            }\n-            GenericParam::Type(ref ty_param) => {\n-                self.create_def(\n-                    ty_param.id,\n-                    DefPathData::TypeParam(ty_param.ident.name.as_interned_str()),\n-                    REGULAR_SPACE,\n-                    ty_param.ident.span\n-                );\n-            }\n-        }\n+        let name = param.ident.name.as_interned_str();\n+        let def_path_data = match param.kind {\n+            GenericParamKind::Lifetime { .. } => DefPathData::LifetimeParam(name),\n+            GenericParamKind::Type { .. } => DefPathData::TypeParam(name),\n+        };\n+        self.create_def(param.id, def_path_data, REGULAR_SPACE, param.ident.span);\n \n         visit::walk_generic_param(self, param);\n     }"}, {"sha": "b1cb9d7fbd4a5aa201ebc1735c1fd109b29af5f8", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -360,7 +360,7 @@ pub enum DefPathData {\n     /// A type parameter (generic parameter)\n     TypeParam(InternedString),\n     /// A lifetime definition\n-    LifetimeDef(InternedString),\n+    LifetimeParam(InternedString),\n     /// A variant of a enum\n     EnumVariant(InternedString),\n     /// A struct field\n@@ -625,7 +625,7 @@ impl DefPathData {\n             Module(name) |\n             MacroDef(name) |\n             TypeParam(name) |\n-            LifetimeDef(name) |\n+            LifetimeParam(name) |\n             EnumVariant(name) |\n             Field(name) |\n             GlobalMetaData(name) => Some(name),\n@@ -652,7 +652,7 @@ impl DefPathData {\n             Module(name) |\n             MacroDef(name) |\n             TypeParam(name) |\n-            LifetimeDef(name) |\n+            LifetimeParam(name) |\n             EnumVariant(name) |\n             Field(name) |\n             GlobalMetaData(name) => {"}, {"sha": "c2c8c7a391b9c02c417cc33b199a2e6a3dc8a2c3", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -68,7 +68,7 @@ pub enum Node<'hir> {\n     NodeStructCtor(&'hir VariantData),\n \n     NodeLifetime(&'hir Lifetime),\n-    NodeTyParam(&'hir TyParam),\n+    NodeGenericParam(&'hir GenericParam),\n     NodeVisibility(&'hir Visibility),\n }\n \n@@ -96,7 +96,7 @@ enum MapEntry<'hir> {\n     EntryBlock(NodeId, DepNodeIndex, &'hir Block),\n     EntryStructCtor(NodeId, DepNodeIndex, &'hir VariantData),\n     EntryLifetime(NodeId, DepNodeIndex, &'hir Lifetime),\n-    EntryTyParam(NodeId, DepNodeIndex, &'hir TyParam),\n+    EntryGenericParam(NodeId, DepNodeIndex, &'hir GenericParam),\n     EntryVisibility(NodeId, DepNodeIndex, &'hir Visibility),\n     EntryLocal(NodeId, DepNodeIndex, &'hir Local),\n \n@@ -132,7 +132,7 @@ impl<'hir> MapEntry<'hir> {\n             EntryBlock(id, _, _) => id,\n             EntryStructCtor(id, _, _) => id,\n             EntryLifetime(id, _, _) => id,\n-            EntryTyParam(id, _, _) => id,\n+            EntryGenericParam(id, _, _) => id,\n             EntryVisibility(id, _, _) => id,\n             EntryLocal(id, _, _) => id,\n \n@@ -160,7 +160,7 @@ impl<'hir> MapEntry<'hir> {\n             EntryBlock(_, _, n) => NodeBlock(n),\n             EntryStructCtor(_, _, n) => NodeStructCtor(n),\n             EntryLifetime(_, _, n) => NodeLifetime(n),\n-            EntryTyParam(_, _, n) => NodeTyParam(n),\n+            EntryGenericParam(_, _, n) => NodeGenericParam(n),\n             EntryVisibility(_, _, n) => NodeVisibility(n),\n             EntryLocal(_, _, n) => NodeLocal(n),\n             EntryMacroDef(_, n) => NodeMacroDef(n),\n@@ -328,7 +328,7 @@ impl<'hir> Map<'hir> {\n             EntryBlock(_, dep_node_index, _) |\n             EntryStructCtor(_, dep_node_index, _) |\n             EntryLifetime(_, dep_node_index, _) |\n-            EntryTyParam(_, dep_node_index, _) |\n+            EntryGenericParam(_, dep_node_index, _) |\n             EntryVisibility(_, dep_node_index, _) |\n             EntryAnonConst(_, dep_node_index, _) |\n             EntryExpr(_, dep_node_index, _) |\n@@ -494,8 +494,11 @@ impl<'hir> Map<'hir> {\n                 Some(Def::Macro(self.local_def_id(macro_def.id),\n                                 MacroKind::Bang))\n             }\n-            NodeTyParam(param) => {\n-                Some(Def::TyParam(self.local_def_id(param.id)))\n+            NodeGenericParam(param) => {\n+                Some(match param.kind {\n+                    GenericParamKind::Lifetime { .. } => Def::Local(param.id),\n+                    GenericParamKind::Type { .. } => Def::TyParam(self.local_def_id(param.id)),\n+                })\n             }\n         }\n     }\n@@ -600,7 +603,7 @@ impl<'hir> Map<'hir> {\n     pub fn ty_param_owner(&self, id: NodeId) -> NodeId {\n         match self.get(id) {\n             NodeItem(&Item { node: ItemTrait(..), .. }) => id,\n-            NodeTyParam(_) => self.get_parent_node(id),\n+            NodeGenericParam(_) => self.get_parent_node(id),\n             _ => {\n                 bug!(\"ty_param_owner: {} not a type parameter\",\n                     self.node_to_string(id))\n@@ -613,11 +616,8 @@ impl<'hir> Map<'hir> {\n             NodeItem(&Item { node: ItemTrait(..), .. }) => {\n                 keywords::SelfType.name()\n             }\n-            NodeTyParam(tp) => tp.name,\n-            _ => {\n-                bug!(\"ty_param_name: {} not a type parameter\",\n-                    self.node_to_string(id))\n-            }\n+            NodeGenericParam(param) => param.name.name(),\n+            _ => bug!(\"ty_param_name: {} not a type parameter\", self.node_to_string(id)),\n         }\n     }\n \n@@ -954,7 +954,7 @@ impl<'hir> Map<'hir> {\n             NodeVariant(v) => v.node.name,\n             NodeField(f) => f.ident.name,\n             NodeLifetime(lt) => lt.name.name(),\n-            NodeTyParam(tp) => tp.name,\n+            NodeGenericParam(param) => param.name.name(),\n             NodeBinding(&Pat { node: PatKind::Binding(_,_,l,_), .. }) => l.node,\n             NodeStructCtor(_) => self.name(self.get_parent(id)),\n             _ => bug!(\"no name for {}\", self.node_to_string(id))\n@@ -974,7 +974,7 @@ impl<'hir> Map<'hir> {\n             Some(NodeField(ref f)) => Some(&f.attrs[..]),\n             Some(NodeExpr(ref e)) => Some(&*e.attrs),\n             Some(NodeStmt(ref s)) => Some(s.node.attrs()),\n-            Some(NodeTyParam(tp)) => Some(&tp.attrs[..]),\n+            Some(NodeGenericParam(param)) => Some(&param.attrs[..]),\n             // unit/tuple structs take the attributes straight from\n             // the struct definition.\n             Some(NodeStructCtor(_)) => {\n@@ -1021,7 +1021,7 @@ impl<'hir> Map<'hir> {\n             Some(EntryBlock(_, _, block)) => block.span,\n             Some(EntryStructCtor(_, _, _)) => self.expect_item(self.get_parent(id)).span,\n             Some(EntryLifetime(_, _, lifetime)) => lifetime.span,\n-            Some(EntryTyParam(_, _, ty_param)) => ty_param.span,\n+            Some(EntryGenericParam(_, _, param)) => param.span,\n             Some(EntryVisibility(_, _, &Visibility::Restricted { ref path, .. })) => path.span,\n             Some(EntryVisibility(_, _, v)) => bug!(\"unexpected Visibility {:?}\", v),\n             Some(EntryLocal(_, _, local)) => local.span,\n@@ -1226,19 +1226,19 @@ impl<'hir> print::PpAnn for Map<'hir> {\n impl<'a> print::State<'a> {\n     pub fn print_node(&mut self, node: Node) -> io::Result<()> {\n         match node {\n-            NodeItem(a)        => self.print_item(&a),\n-            NodeForeignItem(a) => self.print_foreign_item(&a),\n-            NodeTraitItem(a)   => self.print_trait_item(a),\n-            NodeImplItem(a)    => self.print_impl_item(a),\n-            NodeVariant(a)     => self.print_variant(&a),\n-            NodeAnonConst(a)   => self.print_anon_const(&a),\n-            NodeExpr(a)        => self.print_expr(&a),\n-            NodeStmt(a)        => self.print_stmt(&a),\n-            NodeTy(a)          => self.print_type(&a),\n-            NodeTraitRef(a)    => self.print_trait_ref(&a),\n+            NodeItem(a)         => self.print_item(&a),\n+            NodeForeignItem(a)  => self.print_foreign_item(&a),\n+            NodeTraitItem(a)    => self.print_trait_item(a),\n+            NodeImplItem(a)     => self.print_impl_item(a),\n+            NodeVariant(a)      => self.print_variant(&a),\n+            NodeAnonConst(a)    => self.print_anon_const(&a),\n+            NodeExpr(a)         => self.print_expr(&a),\n+            NodeStmt(a)         => self.print_stmt(&a),\n+            NodeTy(a)           => self.print_type(&a),\n+            NodeTraitRef(a)     => self.print_trait_ref(&a),\n             NodeBinding(a)       |\n-            NodePat(a)         => self.print_pat(&a),\n-            NodeBlock(a)       => {\n+            NodePat(a)          => self.print_pat(&a),\n+            NodeBlock(a)        => {\n                 use syntax::print::pprust::PrintState;\n \n                 // containing cbox, will be closed by print-block at }\n@@ -1247,16 +1247,16 @@ impl<'a> print::State<'a> {\n                 self.ibox(0)?;\n                 self.print_block(&a)\n             }\n-            NodeLifetime(a)    => self.print_lifetime(&a),\n-            NodeVisibility(a)  => self.print_visibility(&a),\n-            NodeTyParam(_)     => bug!(\"cannot print TyParam\"),\n-            NodeField(_)       => bug!(\"cannot print StructField\"),\n+            NodeLifetime(a)     => self.print_lifetime(&a),\n+            NodeVisibility(a)   => self.print_visibility(&a),\n+            NodeGenericParam(_) => bug!(\"cannot print NodeGenericParam\"),\n+            NodeField(_)        => bug!(\"cannot print StructField\"),\n             // these cases do not carry enough information in the\n             // hir_map to reconstruct their full structure for pretty\n             // printing.\n-            NodeStructCtor(_)  => bug!(\"cannot print isolated StructCtor\"),\n-            NodeLocal(a)       => self.print_local_decl(&a),\n-            NodeMacroDef(_)    => bug!(\"cannot print MacroDef\"),\n+            NodeStructCtor(_)   => bug!(\"cannot print isolated StructCtor\"),\n+            NodeLocal(a)        => self.print_local_decl(&a),\n+            NodeMacroDef(_)     => bug!(\"cannot print MacroDef\"),\n         }\n     }\n }\n@@ -1371,8 +1371,8 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         Some(NodeLifetime(_)) => {\n             format!(\"lifetime {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeTyParam(ref ty_param)) => {\n-            format!(\"typaram {:?}{}\", ty_param, id_str)\n+        Some(NodeGenericParam(ref param)) => {\n+            format!(\"generic_param {:?}{}\", param, id_str)\n         }\n         Some(NodeVisibility(ref vis)) => {\n             format!(\"visibility {:?}{}\", vis, id_str)"}, {"sha": "f6876113c1176a0ca2f924694499b1b710780449", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 136, "deletions": 188, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -22,7 +22,6 @@ pub use self::Mutability::*;\n pub use self::PrimTy::*;\n pub use self::Stmt_::*;\n pub use self::Ty_::*;\n-pub use self::TyParamBound::*;\n pub use self::UnOp::*;\n pub use self::UnsafeSource::*;\n pub use self::Visibility::{Public, Inherited};\n@@ -53,8 +52,6 @@ use rustc_data_structures::sync::{ParallelIterator, par_iter, Send, Sync, scope}\n use serialize::{self, Encoder, Encodable, Decoder, Decodable};\n use std::collections::BTreeMap;\n use std::fmt;\n-use std::iter;\n-use std::slice;\n \n /// HIR doesn't commit to a concrete storage type and has its own alias for a vector.\n /// It can be `Vec`, `P<[T]>` or potentially `Box<[T]>`, or some other container with similar\n@@ -203,12 +200,9 @@ pub struct Lifetime {\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n-pub enum LifetimeName {\n-    /// User typed nothing. e.g. the lifetime in `&u32`.\n-    Implicit,\n-\n-    /// User typed `'_`.\n-    Underscore,\n+pub enum ParamName {\n+    /// Some user-given name like `T` or `'x`.\n+    Plain(Name),\n \n     /// Synthetic name generated when user elided a lifetime in an impl header,\n     /// e.g. the lifetimes in cases like these:\n@@ -224,24 +218,60 @@ pub enum LifetimeName {\n     /// where `'f` is something like `Fresh(0)`. The indices are\n     /// unique per impl, but not necessarily continuous.\n     Fresh(usize),\n+}\n+\n+impl ParamName {\n+    pub fn name(&self) -> Name {\n+        match *self {\n+            ParamName::Plain(name) => name,\n+            ParamName::Fresh(_) => keywords::UnderscoreLifetime.name(),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+pub enum LifetimeName {\n+    /// User-given names or fresh (synthetic) names.\n+    Param(ParamName),\n+\n+    /// User typed nothing. e.g. the lifetime in `&u32`.\n+    Implicit,\n+\n+    /// User typed `'_`.\n+    Underscore,\n \n     /// User wrote `'static`\n     Static,\n-\n-    /// Some user-given name like `'x`\n-    Name(Name),\n }\n \n impl LifetimeName {\n     pub fn name(&self) -> Name {\n         use self::LifetimeName::*;\n         match *self {\n             Implicit => keywords::Invalid.name(),\n-            Fresh(_) | Underscore => keywords::UnderscoreLifetime.name(),\n+            Underscore => keywords::UnderscoreLifetime.name(),\n             Static => keywords::StaticLifetime.name(),\n-            Name(name) => name,\n+            Param(param_name) => param_name.name(),\n         }\n     }\n+\n+    fn is_elided(&self) -> bool {\n+        use self::LifetimeName::*;\n+        match self {\n+            Implicit | Underscore => true,\n+\n+            // It might seem surprising that `Fresh(_)` counts as\n+            // *not* elided -- but this is because, as far as the code\n+            // in the compiler is concerned -- `Fresh(_)` variants act\n+            // equivalently to \"some fresh name\". They correspond to\n+            // early-bound regions on an impl, in other words.\n+            Param(_) | Static => false,\n+        }\n+    }\n+\n+    fn is_static(&self) -> bool {\n+        self == &LifetimeName::Static\n+    }\n }\n \n impl fmt::Debug for Lifetime {\n@@ -255,36 +285,14 @@ impl fmt::Debug for Lifetime {\n \n impl Lifetime {\n     pub fn is_elided(&self) -> bool {\n-        use self::LifetimeName::*;\n-        match self.name {\n-            Implicit | Underscore => true,\n-\n-            // It might seem surprising that `Fresh(_)` counts as\n-            // *not* elided -- but this is because, as far as the code\n-            // in the compiler is concerned -- `Fresh(_)` variants act\n-            // equivalently to \"some fresh name\". They correspond to\n-            // early-bound regions on an impl, in other words.\n-            Fresh(_) | Static | Name(_) => false,\n-        }\n+        self.name.is_elided()\n     }\n \n     pub fn is_static(&self) -> bool {\n-        self.name == LifetimeName::Static\n+        self.name.is_static()\n     }\n }\n \n-/// A lifetime definition, eg `'a: 'b+'c+'d`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct LifetimeDef {\n-    pub lifetime: Lifetime,\n-    pub bounds: HirVec<Lifetime>,\n-    pub pure_wrt_drop: bool,\n-    // Indicates that the lifetime definition was synthetically added\n-    // as a result of an in-band lifetime usage like\n-    // `fn foo(x: &'a u8) -> &'a u8 { x }`\n-    pub in_band: bool,\n-}\n-\n /// A \"Path\" is essentially Rust's notion of a name; for instance:\n /// `std::cmp::PartialEq`. It's represented as a sequence of identifiers,\n /// along with a bunch of supporting information.\n@@ -327,7 +335,7 @@ pub struct PathSegment {\n     /// this is more than just simple syntactic sugar; the use of\n     /// parens affects the region binding rules, so we preserve the\n     /// distinction.\n-    pub parameters: Option<P<PathParameters>>,\n+    pub args: Option<P<GenericArgs>>,\n \n     /// Whether to infer remaining type parameters, if any.\n     /// This only applies to expression and pattern paths, and\n@@ -342,173 +350,145 @@ impl PathSegment {\n         PathSegment {\n             name,\n             infer_types: true,\n-            parameters: None\n+            args: None,\n         }\n     }\n \n-    pub fn new(name: Name, parameters: PathParameters, infer_types: bool) -> Self {\n+    pub fn new(name: Name, args: GenericArgs, infer_types: bool) -> Self {\n         PathSegment {\n             name,\n             infer_types,\n-            parameters: if parameters.is_empty() {\n+            args: if args.is_empty() {\n                 None\n             } else {\n-                Some(P(parameters))\n+                Some(P(args))\n             }\n         }\n     }\n \n     // FIXME: hack required because you can't create a static\n-    // PathParameters, so you can't just return a &PathParameters.\n-    pub fn with_parameters<F, R>(&self, f: F) -> R\n-        where F: FnOnce(&PathParameters) -> R\n+    // GenericArgs, so you can't just return a &GenericArgs.\n+    pub fn with_generic_args<F, R>(&self, f: F) -> R\n+        where F: FnOnce(&GenericArgs) -> R\n     {\n-        let dummy = PathParameters::none();\n-        f(if let Some(ref params) = self.parameters {\n-            &params\n+        let dummy = GenericArgs::none();\n+        f(if let Some(ref args) = self.args {\n+            &args\n         } else {\n             &dummy\n         })\n     }\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct PathParameters {\n-    /// The lifetime parameters for this path segment.\n-    pub lifetimes: HirVec<Lifetime>,\n-    /// The type parameters for this path segment, if present.\n-    pub types: HirVec<P<Ty>>,\n+pub enum GenericArg {\n+    Lifetime(Lifetime),\n+    Type(P<Ty>),\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct GenericArgs {\n+    /// The generic arguments for this path segment.\n+    pub args: HirVec<GenericArg>,\n     /// Bindings (equality constraints) on associated types, if present.\n     /// E.g., `Foo<A=Bar>`.\n     pub bindings: HirVec<TypeBinding>,\n-    /// Were parameters written in parenthesized form `Fn(T) -> U`?\n+    /// Were arguments written in parenthesized form `Fn(T) -> U`?\n     /// This is required mostly for pretty-printing and diagnostics,\n     /// but also for changing lifetime elision rules to be \"function-like\".\n     pub parenthesized: bool,\n }\n \n-impl PathParameters {\n+impl GenericArgs {\n     pub fn none() -> Self {\n         Self {\n-            lifetimes: HirVec::new(),\n-            types: HirVec::new(),\n+            args: HirVec::new(),\n             bindings: HirVec::new(),\n             parenthesized: false,\n         }\n     }\n \n     pub fn is_empty(&self) -> bool {\n-        self.lifetimes.is_empty() && self.types.is_empty() &&\n-            self.bindings.is_empty() && !self.parenthesized\n+        self.args.is_empty() && self.bindings.is_empty() && !self.parenthesized\n     }\n \n     pub fn inputs(&self) -> &[P<Ty>] {\n         if self.parenthesized {\n-            if let Some(ref ty) = self.types.get(0) {\n-                if let TyTup(ref tys) = ty.node {\n-                    return tys;\n+            for arg in &self.args {\n+                match arg {\n+                    GenericArg::Lifetime(_) => {}\n+                    GenericArg::Type(ref ty) => {\n+                        if let TyTup(ref tys) = ty.node {\n+                            return tys;\n+                        }\n+                        break;\n+                    }\n                 }\n             }\n         }\n-        bug!(\"PathParameters::inputs: not a `Fn(T) -> U`\");\n+        bug!(\"GenericArgs::inputs: not a `Fn(T) -> U`\");\n     }\n }\n \n+/// A modifier on a bound, currently this is only used for `?Sized`, where the\n+/// modifier is `Maybe`. Negative bounds should also be handled here.\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum TraitBoundModifier {\n+    None,\n+    Maybe,\n+}\n+\n /// The AST represents all type param bounds as types.\n /// typeck::collect::compute_bounds matches these against\n /// the \"special\" built-in traits (see middle::lang_items) and\n /// detects Copy, Send and Sync.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum TyParamBound {\n-    TraitTyParamBound(PolyTraitRef, TraitBoundModifier),\n-    RegionTyParamBound(Lifetime),\n+pub enum GenericBound {\n+    Trait(PolyTraitRef, TraitBoundModifier),\n+    Outlives(Lifetime),\n }\n \n-impl TyParamBound {\n+impl GenericBound {\n     pub fn span(&self) -> Span {\n         match self {\n-            &TraitTyParamBound(ref t, ..) => t.span,\n-            &RegionTyParamBound(ref l) => l.span,\n+            &GenericBound::Trait(ref t, ..) => t.span,\n+            &GenericBound::Outlives(ref l) => l.span,\n         }\n     }\n }\n \n-/// A modifier on a bound, currently this is only used for `?Sized`, where the\n-/// modifier is `Maybe`. Negative bounds should also be handled here.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum TraitBoundModifier {\n-    None,\n-    Maybe,\n-}\n+pub type GenericBounds = HirVec<GenericBound>;\n \n-pub type TyParamBounds = HirVec<TyParamBound>;\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum GenericParamKind {\n+    /// A lifetime definition, eg `'a: 'b + 'c + 'd`.\n+    Lifetime {\n+        // Indicates that the lifetime definition was synthetically added\n+        // as a result of an in-band lifetime usage like:\n+        // `fn foo(x: &'a u8) -> &'a u8 { x }`\n+        in_band: bool,\n+    },\n+    Type {\n+        default: Option<P<Ty>>,\n+        synthetic: Option<SyntheticTyParamKind>,\n+    }\n+}\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct TyParam {\n-    pub name: Name,\n+pub struct GenericParam {\n     pub id: NodeId,\n-    pub bounds: TyParamBounds,\n-    pub default: Option<P<Ty>>,\n+    pub name: ParamName,\n+    pub attrs: HirVec<Attribute>,\n+    pub bounds: GenericBounds,\n     pub span: Span,\n     pub pure_wrt_drop: bool,\n-    pub synthetic: Option<SyntheticTyParamKind>,\n-    pub attrs: HirVec<Attribute>,\n-}\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum GenericParam {\n-    Lifetime(LifetimeDef),\n-    Type(TyParam),\n+    pub kind: GenericParamKind,\n }\n \n-impl GenericParam {\n-    pub fn is_lifetime_param(&self) -> bool {\n-        match *self {\n-            GenericParam::Lifetime(_) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn is_type_param(&self) -> bool {\n-        match *self {\n-            GenericParam::Type(_) => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n-pub trait GenericParamsExt {\n-    fn lifetimes<'a>(&'a self) -> iter::FilterMap<\n-        slice::Iter<GenericParam>,\n-        fn(&GenericParam) -> Option<&LifetimeDef>,\n-    >;\n-\n-    fn ty_params<'a>(&'a self) -> iter::FilterMap<\n-        slice::Iter<GenericParam>,\n-        fn(&GenericParam) -> Option<&TyParam>,\n-    >;\n-}\n-\n-impl GenericParamsExt for [GenericParam] {\n-    fn lifetimes<'a>(&'a self) -> iter::FilterMap<\n-        slice::Iter<GenericParam>,\n-        fn(&GenericParam) -> Option<&LifetimeDef>,\n-    > {\n-        self.iter().filter_map(|param| match *param {\n-            GenericParam::Lifetime(ref l) => Some(l),\n-            _ => None,\n-        })\n-    }\n-\n-    fn ty_params<'a>(&'a self) -> iter::FilterMap<\n-        slice::Iter<GenericParam>,\n-        fn(&GenericParam) -> Option<&TyParam>,\n-    > {\n-        self.iter().filter_map(|param| match *param {\n-            GenericParam::Type(ref t) => Some(t),\n-            _ => None,\n-        })\n-    }\n+pub struct GenericParamCount {\n+    pub lifetimes: usize,\n+    pub types: usize,\n }\n \n /// Represents lifetimes and type parameters attached to a declaration\n@@ -532,55 +512,23 @@ impl Generics {\n         }\n     }\n \n-    pub fn is_lt_parameterized(&self) -> bool {\n-        self.params.iter().any(|param| param.is_lifetime_param())\n-    }\n-\n-    pub fn is_type_parameterized(&self) -> bool {\n-        self.params.iter().any(|param| param.is_type_param())\n-    }\n-\n-    pub fn lifetimes<'a>(&'a self) -> impl Iterator<Item = &'a LifetimeDef> {\n-        self.params.lifetimes()\n-    }\n-\n-    pub fn ty_params<'a>(&'a self) -> impl Iterator<Item = &'a TyParam> {\n-        self.params.ty_params()\n-    }\n-}\n-\n-pub enum UnsafeGeneric {\n-    Region(LifetimeDef, &'static str),\n-    Type(TyParam, &'static str),\n-}\n+    pub fn own_counts(&self) -> GenericParamCount {\n+        // We could cache this as a property of `GenericParamCount`, but\n+        // the aim is to refactor this away entirely eventually and the\n+        // presence of this method will be a constant reminder.\n+        let mut own_counts = GenericParamCount {\n+            lifetimes: 0,\n+            types: 0,\n+        };\n \n-impl UnsafeGeneric {\n-    pub fn attr_name(&self) -> &'static str {\n-        match *self {\n-            UnsafeGeneric::Region(_, s) => s,\n-            UnsafeGeneric::Type(_, s) => s,\n-        }\n-    }\n-}\n-\n-impl Generics {\n-    pub fn carries_unsafe_attr(&self) -> Option<UnsafeGeneric> {\n         for param in &self.params {\n-            match *param {\n-                GenericParam::Lifetime(ref l) => {\n-                    if l.pure_wrt_drop {\n-                        return Some(UnsafeGeneric::Region(l.clone(), \"may_dangle\"));\n-                    }\n-                }\n-                GenericParam::Type(ref t) => {\n-                    if t.pure_wrt_drop {\n-                        return Some(UnsafeGeneric::Type(t.clone(), \"may_dangle\"));\n-                    }\n-                }\n-            }\n+            match param.kind {\n+                GenericParamKind::Lifetime { .. } => own_counts.lifetimes += 1,\n+                GenericParamKind::Type { .. } => own_counts.types += 1,\n+            };\n         }\n \n-        None\n+        own_counts\n     }\n }\n \n@@ -640,15 +588,15 @@ pub struct WhereBoundPredicate {\n     /// The type being bounded\n     pub bounded_ty: P<Ty>,\n     /// Trait and lifetime bounds (`Clone+Send+'static`)\n-    pub bounds: TyParamBounds,\n+    pub bounds: GenericBounds,\n }\n \n /// A lifetime predicate, e.g. `'a: 'b+'c`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereRegionPredicate {\n     pub span: Span,\n     pub lifetime: Lifetime,\n-    pub bounds: HirVec<Lifetime>,\n+    pub bounds: GenericBounds,\n }\n \n /// An equality predicate (unsupported), e.g. `T=int`\n@@ -1607,7 +1555,7 @@ pub enum TraitItemKind {\n     Method(MethodSig, TraitMethod),\n     /// An associated type with (possibly empty) bounds and optional concrete\n     /// type\n-    Type(TyParamBounds, Option<P<Ty>>),\n+    Type(GenericBounds, Option<P<Ty>>),\n }\n \n // The bodies for items are stored \"out of line\", in a separate\n@@ -1692,7 +1640,7 @@ pub struct BareFnTy {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ExistTy {\n     pub generics: Generics,\n-    pub bounds: TyParamBounds,\n+    pub bounds: GenericBounds,\n     pub impl_trait_fn: Option<DefId>,\n }\n \n@@ -2101,9 +2049,9 @@ pub enum Item_ {\n     /// A union definition, e.g. `union Foo<A, B> {x: A, y: B}`\n     ItemUnion(VariantData, Generics),\n     /// Represents a Trait Declaration\n-    ItemTrait(IsAuto, Unsafety, Generics, TyParamBounds, HirVec<TraitItemRef>),\n+    ItemTrait(IsAuto, Unsafety, Generics, GenericBounds, HirVec<TraitItemRef>),\n     /// Represents a Trait Alias Declaration\n-    ItemTraitAlias(Generics, TyParamBounds),\n+    ItemTraitAlias(Generics, GenericBounds),\n \n     /// An implementation, eg `impl<A> Trait for Foo { .. }`\n     ItemImpl(Unsafety,"}, {"sha": "14f780fab7f2e5d0b1de06a763fb95115dfd6677", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 95, "deletions": 75, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -24,7 +24,8 @@ use syntax::util::parser::{self, AssocOp, Fixity};\n use syntax_pos::{self, BytePos, FileName};\n \n use hir;\n-use hir::{PatKind, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier, RangeEnd};\n+use hir::{PatKind, GenericBound, TraitBoundModifier, RangeEnd};\n+use hir::{GenericParam, GenericParamKind, GenericArg};\n \n use std::cell::Cell;\n use std::io::{self, Write, Read};\n@@ -513,7 +514,7 @@ impl<'a> State<'a> {\n \n     fn print_associated_type(&mut self,\n                              name: ast::Name,\n-                             bounds: Option<&hir::TyParamBounds>,\n+                             bounds: Option<&hir::GenericBounds>,\n                              ty: Option<&hir::Ty>)\n                              -> io::Result<()> {\n         self.word_space(\"type\")?;\n@@ -661,7 +662,7 @@ impl<'a> State<'a> {\n                 self.word_space(\":\")?;\n                 let mut real_bounds = Vec::with_capacity(exist.bounds.len());\n                 for b in exist.bounds.iter() {\n-                    if let TraitTyParamBound(ref ptr, hir::TraitBoundModifier::Maybe) = *b {\n+                    if let GenericBound::Trait(ref ptr, hir::TraitBoundModifier::Maybe) = *b {\n                         self.s.space()?;\n                         self.word_space(\"for ?\")?;\n                         self.print_trait_ref(&ptr.trait_ref)?;\n@@ -739,7 +740,7 @@ impl<'a> State<'a> {\n                 self.print_generic_params(&generics.params)?;\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n                 for b in bounds.iter() {\n-                    if let TraitTyParamBound(ref ptr, hir::TraitBoundModifier::Maybe) = *b {\n+                    if let GenericBound::Trait(ref ptr, hir::TraitBoundModifier::Maybe) = *b {\n                         self.s.space()?;\n                         self.word_space(\"for ?\")?;\n                         self.print_trait_ref(&ptr.trait_ref)?;\n@@ -765,7 +766,7 @@ impl<'a> State<'a> {\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n                 // FIXME(durka) this seems to be some quite outdated syntax\n                 for b in bounds.iter() {\n-                    if let TraitTyParamBound(ref ptr, hir::TraitBoundModifier::Maybe) = *b {\n+                    if let GenericBound::Trait(ref ptr, hir::TraitBoundModifier::Maybe) = *b {\n                         self.s.space()?;\n                         self.word_space(\"for ?\")?;\n                         self.print_trait_ref(&ptr.trait_ref)?;\n@@ -1268,15 +1269,11 @@ impl<'a> State<'a> {\n         self.s.word(\".\")?;\n         self.print_name(segment.name)?;\n \n-        segment.with_parameters(|parameters| {\n-            if !parameters.lifetimes.is_empty() ||\n-                !parameters.types.is_empty() ||\n-                !parameters.bindings.is_empty()\n-            {\n-                self.print_path_parameters(&parameters, segment.infer_types, true)\n-            } else {\n-                Ok(())\n+        segment.with_generic_args(|generic_args| {\n+            if !generic_args.args.is_empty() || !generic_args.bindings.is_empty() {\n+                return self.print_generic_args(&generic_args, segment.infer_types, true);\n             }\n+            Ok(())\n         })?;\n         self.print_call_post(base_args)\n     }\n@@ -1641,10 +1638,9 @@ impl<'a> State<'a> {\n             if segment.name != keywords::CrateRoot.name() &&\n                segment.name != keywords::DollarCrate.name() {\n                self.print_name(segment.name)?;\n-               segment.with_parameters(|parameters| {\n-                   self.print_path_parameters(parameters,\n-                                              segment.infer_types,\n-                                              colons_before_params)\n+               segment.with_generic_args(|generic_args| {\n+                   self.print_generic_args(generic_args, segment.infer_types,\n+                                           colons_before_params)\n                })?;\n             }\n         }\n@@ -1673,10 +1669,10 @@ impl<'a> State<'a> {\n                     if segment.name != keywords::CrateRoot.name() &&\n                        segment.name != keywords::DollarCrate.name() {\n                         self.print_name(segment.name)?;\n-                        segment.with_parameters(|parameters| {\n-                            self.print_path_parameters(parameters,\n-                                                       segment.infer_types,\n-                                                       colons_before_params)\n+                        segment.with_generic_args(|generic_args| {\n+                            self.print_generic_args(generic_args,\n+                                                    segment.infer_types,\n+                                                    colons_before_params)\n                         })?;\n                     }\n                 }\n@@ -1685,10 +1681,10 @@ impl<'a> State<'a> {\n                 self.s.word(\"::\")?;\n                 let item_segment = path.segments.last().unwrap();\n                 self.print_name(item_segment.name)?;\n-                item_segment.with_parameters(|parameters| {\n-                    self.print_path_parameters(parameters,\n-                                               item_segment.infer_types,\n-                                               colons_before_params)\n+                item_segment.with_generic_args(|generic_args| {\n+                    self.print_generic_args(generic_args,\n+                                            item_segment.infer_types,\n+                                            colons_before_params)\n                 })\n             }\n             hir::QPath::TypeRelative(ref qself, ref item_segment) => {\n@@ -1697,28 +1693,28 @@ impl<'a> State<'a> {\n                 self.s.word(\">\")?;\n                 self.s.word(\"::\")?;\n                 self.print_name(item_segment.name)?;\n-                item_segment.with_parameters(|parameters| {\n-                    self.print_path_parameters(parameters,\n-                                               item_segment.infer_types,\n-                                               colons_before_params)\n+                item_segment.with_generic_args(|generic_args| {\n+                    self.print_generic_args(generic_args,\n+                                            item_segment.infer_types,\n+                                            colons_before_params)\n                 })\n             }\n         }\n     }\n \n-    fn print_path_parameters(&mut self,\n-                             parameters: &hir::PathParameters,\n+    fn print_generic_args(&mut self,\n+                             generic_args: &hir::GenericArgs,\n                              infer_types: bool,\n                              colons_before_params: bool)\n                              -> io::Result<()> {\n-        if parameters.parenthesized {\n+        if generic_args.parenthesized {\n             self.s.word(\"(\")?;\n-            self.commasep(Inconsistent, parameters.inputs(), |s, ty| s.print_type(&ty))?;\n+            self.commasep(Inconsistent, generic_args.inputs(), |s, ty| s.print_type(&ty))?;\n             self.s.word(\")\")?;\n \n             self.space_if_not_bol()?;\n             self.word_space(\"->\")?;\n-            self.print_type(&parameters.bindings[0].ty)?;\n+            self.print_type(&generic_args.bindings[0].ty)?;\n         } else {\n             let start = if colons_before_params { \"::<\" } else { \"<\" };\n             let empty = Cell::new(true);\n@@ -1731,16 +1727,31 @@ impl<'a> State<'a> {\n                 }\n             };\n \n-            if !parameters.lifetimes.iter().all(|lt| lt.is_elided()) {\n-                for lifetime in &parameters.lifetimes {\n-                    start_or_comma(self)?;\n-                    self.print_lifetime(lifetime)?;\n+            let mut types = vec![];\n+            let mut elide_lifetimes = true;\n+            for arg in &generic_args.args {\n+                match arg {\n+                    GenericArg::Lifetime(lt) => {\n+                        if !lt.is_elided() {\n+                            elide_lifetimes = false;\n+                        }\n+                    }\n+                    GenericArg::Type(ty) => {\n+                        types.push(ty);\n+                    }\n                 }\n             }\n-\n-            if !parameters.types.is_empty() {\n+            if !elide_lifetimes {\n+                start_or_comma(self)?;\n+                self.commasep(Inconsistent, &generic_args.args, |s, generic_arg| {\n+                    match generic_arg {\n+                        GenericArg::Lifetime(lt) => s.print_lifetime(lt),\n+                        GenericArg::Type(ty) => s.print_type(ty),\n+                    }\n+                })?;\n+            } else if !types.is_empty() {\n                 start_or_comma(self)?;\n-                self.commasep(Inconsistent, &parameters.types, |s, ty| s.print_type(&ty))?;\n+                self.commasep(Inconsistent, &types, |s, ty| s.print_type(&ty))?;\n             }\n \n             // FIXME(eddyb) This would leak into error messages, e.g.:\n@@ -1750,7 +1761,7 @@ impl<'a> State<'a> {\n                 self.s.word(\"..\")?;\n             }\n \n-            for binding in parameters.bindings.iter() {\n+            for binding in generic_args.bindings.iter() {\n                 start_or_comma(self)?;\n                 self.print_name(binding.name)?;\n                 self.s.space()?;\n@@ -2060,7 +2071,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_bounds(&mut self, prefix: &str, bounds: &[hir::TyParamBound]) -> io::Result<()> {\n+    pub fn print_bounds(&mut self, prefix: &str, bounds: &[hir::GenericBound]) -> io::Result<()> {\n         if !bounds.is_empty() {\n             self.s.word(prefix)?;\n             let mut first = true;\n@@ -2075,13 +2086,13 @@ impl<'a> State<'a> {\n                 }\n \n                 match bound {\n-                    TraitTyParamBound(tref, modifier) => {\n+                    GenericBound::Trait(tref, modifier) => {\n                         if modifier == &TraitBoundModifier::Maybe {\n                             self.s.word(\"?\")?;\n                         }\n                         self.print_poly_trait_ref(tref)?;\n                     }\n-                    RegionTyParamBound(lt) => {\n+                    GenericBound::Outlives(lt) => {\n                         self.print_lifetime(lt)?;\n                     }\n                 }\n@@ -2090,50 +2101,54 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_lifetime(&mut self, lifetime: &hir::Lifetime) -> io::Result<()> {\n-        self.print_name(lifetime.name.name())\n-    }\n-\n-    pub fn print_lifetime_def(&mut self, lifetime: &hir::LifetimeDef) -> io::Result<()> {\n-        self.print_lifetime(&lifetime.lifetime)?;\n-        let mut sep = \":\";\n-        for v in &lifetime.bounds {\n-            self.s.word(sep)?;\n-            self.print_lifetime(v)?;\n-            sep = \"+\";\n-        }\n-        Ok(())\n-    }\n-\n-    pub fn print_generic_params(&mut self, generic_params: &[hir::GenericParam]) -> io::Result<()> {\n+    pub fn print_generic_params(&mut self, generic_params: &[GenericParam]) -> io::Result<()> {\n         if !generic_params.is_empty() {\n             self.s.word(\"<\")?;\n \n             self.commasep(Inconsistent, generic_params, |s, param| {\n-                match *param {\n-                    hir::GenericParam::Lifetime(ref ld) => s.print_lifetime_def(ld),\n-                    hir::GenericParam::Type(ref tp) => s.print_ty_param(tp),\n-                }\n+                s.print_generic_param(param)\n             })?;\n \n             self.s.word(\">\")?;\n         }\n         Ok(())\n     }\n \n-    pub fn print_ty_param(&mut self, param: &hir::TyParam) -> io::Result<()> {\n-        self.print_name(param.name)?;\n-        self.print_bounds(\":\", &param.bounds)?;\n-        match param.default {\n-            Some(ref default) => {\n-                self.s.space()?;\n-                self.word_space(\"=\")?;\n-                self.print_type(&default)\n+    pub fn print_generic_param(&mut self, param: &GenericParam) -> io::Result<()> {\n+        self.print_name(param.name.name())?;\n+        match param.kind {\n+            GenericParamKind::Lifetime { .. } => {\n+                let mut sep = \":\";\n+                for bound in &param.bounds {\n+                    match bound {\n+                        GenericBound::Outlives(lt) => {\n+                            self.s.word(sep)?;\n+                            self.print_lifetime(lt)?;\n+                            sep = \"+\";\n+                        }\n+                        _ => bug!(),\n+                    }\n+                }\n+                Ok(())\n+            }\n+            GenericParamKind::Type { ref default, .. } => {\n+                self.print_bounds(\":\", &param.bounds)?;\n+                match default {\n+                    Some(default) => {\n+                        self.s.space()?;\n+                        self.word_space(\"=\")?;\n+                        self.print_type(&default)\n+                    }\n+                    _ => Ok(()),\n+                }\n             }\n-            _ => Ok(()),\n         }\n     }\n \n+    pub fn print_lifetime(&mut self, lifetime: &hir::Lifetime) -> io::Result<()> {\n+        self.print_name(lifetime.name.name())\n+    }\n+\n     pub fn print_where_clause(&mut self, where_clause: &hir::WhereClause) -> io::Result<()> {\n         if where_clause.predicates.is_empty() {\n             return Ok(());\n@@ -2165,7 +2180,12 @@ impl<'a> State<'a> {\n                     self.s.word(\":\")?;\n \n                     for (i, bound) in bounds.iter().enumerate() {\n-                        self.print_lifetime(bound)?;\n+                        match bound {\n+                            GenericBound::Outlives(lt) => {\n+                                self.print_lifetime(lt)?;\n+                            }\n+                            _ => bug!(),\n+                        }\n \n                         if i != 0 {\n                             self.s.word(\":\")?;"}, {"sha": "882194ae64e79df096a3df67768edc4a432b512c", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -142,12 +142,16 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItemId {\n     }\n }\n \n+impl_stable_hash_for!(enum hir::ParamName {\n+    Plain(name),\n+    Fresh(index)\n+});\n+\n impl_stable_hash_for!(enum hir::LifetimeName {\n+    Param(param_name),\n     Implicit,\n     Underscore,\n-    Fresh(index),\n     Static,\n-    Name(name)\n });\n \n impl_stable_hash_for!(struct hir::Label {\n@@ -161,13 +165,6 @@ impl_stable_hash_for!(struct hir::Lifetime {\n     name\n });\n \n-impl_stable_hash_for!(struct hir::LifetimeDef {\n-    lifetime,\n-    bounds,\n-    pure_wrt_drop,\n-    in_band\n-});\n-\n impl_stable_hash_for!(struct hir::Path {\n     span,\n     def,\n@@ -177,41 +174,56 @@ impl_stable_hash_for!(struct hir::Path {\n impl_stable_hash_for!(struct hir::PathSegment {\n     name,\n     infer_types,\n-    parameters\n+    args\n });\n \n-impl_stable_hash_for!(struct hir::PathParameters {\n-    lifetimes,\n-    types,\n+impl_stable_hash_for!(enum hir::GenericArg {\n+    Lifetime(lt),\n+    Type(ty)\n+});\n+\n+impl_stable_hash_for!(struct hir::GenericArgs {\n+    args,\n     bindings,\n     parenthesized\n });\n \n-impl_stable_hash_for!(enum hir::TyParamBound {\n-    TraitTyParamBound(poly_trait_ref, trait_bound_modifier),\n-    RegionTyParamBound(lifetime)\n+impl_stable_hash_for!(enum hir::GenericBound {\n+    Trait(poly_trait_ref, trait_bound_modifier),\n+    Outlives(lifetime)\n });\n \n impl_stable_hash_for!(enum hir::TraitBoundModifier {\n     None,\n     Maybe\n });\n \n-impl_stable_hash_for!(struct hir::TyParam {\n-    name,\n+impl_stable_hash_for!(struct hir::GenericParam {\n     id,\n-    bounds,\n-    default,\n+    name,\n     span,\n     pure_wrt_drop,\n-    synthetic,\n-    attrs\n+    attrs,\n+    bounds,\n+    kind\n });\n \n-impl_stable_hash_for!(enum hir::GenericParam {\n-    Lifetime(lifetime_def),\n-    Type(ty_param)\n-});\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::GenericParamKind {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match self {\n+            hir::GenericParamKind::Lifetime { in_band } => {\n+                in_band.hash_stable(hcx, hasher);\n+            }\n+            hir::GenericParamKind::Type { ref default, synthetic } => {\n+                default.hash_stable(hcx, hasher);\n+                synthetic.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n \n impl_stable_hash_for!(struct hir::Generics {\n     params,"}, {"sha": "4d6f2fb41b05d7e5c5fa5512071b9aa2f9e0eacc", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -1036,23 +1036,22 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             // Get the `hir::TyParam` to verify whether it already has any bounds.\n                             // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n                             // instead we suggest `T: 'a + 'b` in that case.\n-                            let has_lifetimes = if let hir_map::NodeTyParam(ref p) = hir.get(id) {\n-                                p.bounds.len() > 0\n-                            } else {\n-                                false\n-                            };\n+                            let mut has_bounds = false;\n+                            if let hir_map::NodeGenericParam(ref param) = hir.get(id) {\n+                                has_bounds = !param.bounds.is_empty();\n+                            }\n                             let sp = hir.span(id);\n                             // `sp` only covers `T`, change it so that it covers\n                             // `T:` when appropriate\n-                            let sp = if has_lifetimes {\n+                            let sp = if has_bounds {\n                                 sp.to(self.tcx\n                                     .sess\n                                     .codemap()\n                                     .next_point(self.tcx.sess.codemap().next_point(sp)))\n                             } else {\n                                 sp\n                             };\n-                            (sp, has_lifetimes)\n+                            (sp, has_bounds)\n                         })\n                     } else {\n                         None"}, {"sha": "7f81af7e46c7d28eba9d3e59007261fef30e62f8", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -20,7 +20,7 @@ use hir::map as hir_map;\n use hir::def::Def;\n use hir::def_id::{DefId, CrateNum};\n use rustc_data_structures::sync::Lrc;\n-use ty::{self, TyCtxt};\n+use ty::{self, TyCtxt, GenericParamDefKind};\n use ty::query::Providers;\n use middle::privacy;\n use session::config;\n@@ -37,21 +37,30 @@ use hir::intravisit;\n \n // Returns true if the given set of generics implies that the item it's\n // associated with must be inlined.\n-fn generics_require_inlining(generics: &hir::Generics) -> bool {\n-    generics.params.iter().any(|param| param.is_type_param())\n+fn generics_require_inlining(generics: &ty::Generics) -> bool {\n+    for param in &generics.params {\n+        match param.kind {\n+            GenericParamDefKind::Lifetime { .. } => {}\n+            GenericParamDefKind::Type { .. } => return true,\n+        }\n+    }\n+    false\n }\n \n // Returns true if the given item must be inlined because it may be\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n-fn item_might_be_inlined(item: &hir::Item, attrs: CodegenFnAttrs) -> bool {\n+fn item_might_be_inlined(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                         item: &hir::Item,\n+                         attrs: CodegenFnAttrs) -> bool {\n     if attrs.requests_inline() {\n         return true\n     }\n \n     match item.node {\n-        hir::ItemImpl(_, _, _, ref generics, ..) |\n-        hir::ItemFn(.., ref generics, _) => {\n+        hir::ItemImpl(..) |\n+        hir::ItemFn(..) => {\n+            let generics = tcx.generics_of(tcx.hir.local_def_id(item.id));\n             generics_require_inlining(generics)\n         }\n         _ => false,\n@@ -62,14 +71,14 @@ fn method_might_be_inlined<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      impl_item: &hir::ImplItem,\n                                      impl_src: DefId) -> bool {\n     let codegen_fn_attrs = tcx.codegen_fn_attrs(impl_item.hir_id.owner_def_id());\n-    if codegen_fn_attrs.requests_inline() ||\n-        generics_require_inlining(&impl_item.generics) {\n+    let generics = tcx.generics_of(tcx.hir.local_def_id(impl_item.id));\n+    if codegen_fn_attrs.requests_inline() || generics_require_inlining(generics) {\n         return true\n     }\n     if let Some(impl_node_id) = tcx.hir.as_local_node_id(impl_src) {\n         match tcx.hir.find(impl_node_id) {\n             Some(hir_map::NodeItem(item)) =>\n-                item_might_be_inlined(&item, codegen_fn_attrs),\n+                item_might_be_inlined(tcx, &item, codegen_fn_attrs),\n             Some(..) | None =>\n                 span_bug!(impl_item.span, \"impl did is not an item\")\n         }\n@@ -163,7 +172,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             Some(hir_map::NodeItem(item)) => {\n                 match item.node {\n                     hir::ItemFn(..) =>\n-                        item_might_be_inlined(&item, self.tcx.codegen_fn_attrs(def_id)),\n+                        item_might_be_inlined(self.tcx, &item, self.tcx.codegen_fn_attrs(def_id)),\n                     _ => false,\n                 }\n             }\n@@ -180,7 +189,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::ImplItemKind::Const(..) => true,\n                     hir::ImplItemKind::Method(..) => {\n                         let attrs = self.tcx.codegen_fn_attrs(def_id);\n-                        if generics_require_inlining(&impl_item.generics) ||\n+                        let generics = self.tcx.generics_of(def_id);\n+                        if generics_require_inlining(&generics) ||\n                                 attrs.requests_inline() {\n                             true\n                         } else {\n@@ -192,8 +202,9 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                             // does too.\n                             let impl_node_id = self.tcx.hir.as_local_node_id(impl_did).unwrap();\n                             match self.tcx.hir.expect_item(impl_node_id).node {\n-                                hir::ItemImpl(_, _, _, ref generics, ..) => {\n-                                    generics_require_inlining(generics)\n+                                hir::ItemImpl(..) => {\n+                                    let generics = self.tcx.generics_of(impl_did);\n+                                    generics_require_inlining(&generics)\n                                 }\n                                 _ => false\n                             }\n@@ -251,7 +262,9 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 match item.node {\n                     hir::ItemFn(.., body) => {\n                         let def_id = self.tcx.hir.local_def_id(item.id);\n-                        if item_might_be_inlined(&item, self.tcx.codegen_fn_attrs(def_id)) {\n+                        if item_might_be_inlined(self.tcx,\n+                                                 &item,\n+                                                 self.tcx.codegen_fn_attrs(def_id)) {\n                             self.visit_nested_body(body);\n                         }\n                     }"}, {"sha": "091662966ea8f9c4050a9a53de5d1438aaa855bf", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 358, "deletions": 289, "changes": 647, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -18,8 +18,7 @@\n use hir::def::Def;\n use hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use hir::map::Map;\n-use hir::ItemLocalId;\n-use hir::LifetimeName;\n+use hir::{GenericArg, GenericParam, ItemLocalId, LifetimeName, ParamName};\n use ty::{self, TyCtxt, GenericParamDefKind};\n \n use errors::DiagnosticBuilder;\n@@ -28,15 +27,15 @@ use rustc_data_structures::sync::Lrc;\n use session::Session;\n use std::cell::Cell;\n use std::mem::replace;\n-use std::slice;\n use syntax::ast;\n use syntax::attr;\n use syntax::ptr::P;\n+use syntax::symbol::keywords;\n use syntax_pos::Span;\n use util::nodemap::{DefIdMap, FxHashMap, FxHashSet, NodeMap, NodeSet};\n \n use hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use hir::{self, GenericParamsExt};\n+use hir::{self, GenericParamKind};\n \n /// The origin of a named lifetime definition.\n ///\n@@ -50,11 +49,16 @@ pub enum LifetimeDefOrigin {\n }\n \n impl LifetimeDefOrigin {\n-    fn from_is_in_band(is_in_band: bool) -> Self {\n-        if is_in_band {\n-            LifetimeDefOrigin::InBand\n-        } else {\n-            LifetimeDefOrigin::Explicit\n+    fn from_param(param: &GenericParam) -> Self {\n+        match param.kind {\n+            GenericParamKind::Lifetime { in_band } => {\n+                if in_band {\n+                    LifetimeDefOrigin::InBand\n+                } else {\n+                    LifetimeDefOrigin::Explicit\n+                }\n+            }\n+            _ => bug!(\"expected a lifetime param\"),\n         }\n     }\n }\n@@ -84,31 +88,27 @@ pub enum Region {\n }\n \n impl Region {\n-    fn early(\n-        hir_map: &Map,\n-        index: &mut u32,\n-        def: &hir::LifetimeDef,\n-    ) -> (hir::LifetimeName, Region) {\n+    fn early(hir_map: &Map, index: &mut u32, param: &GenericParam) -> (ParamName, Region) {\n         let i = *index;\n         *index += 1;\n-        let def_id = hir_map.local_def_id(def.lifetime.id);\n-        let origin = LifetimeDefOrigin::from_is_in_band(def.in_band);\n+        let def_id = hir_map.local_def_id(param.id);\n+        let origin = LifetimeDefOrigin::from_param(param);\n         debug!(\"Region::early: index={} def_id={:?}\", i, def_id);\n-        (def.lifetime.name, Region::EarlyBound(i, def_id, origin))\n+        (param.name, Region::EarlyBound(i, def_id, origin))\n     }\n \n-    fn late(hir_map: &Map, def: &hir::LifetimeDef) -> (hir::LifetimeName, Region) {\n+    fn late(hir_map: &Map, param: &GenericParam) -> (ParamName, Region) {\n         let depth = ty::INNERMOST;\n-        let def_id = hir_map.local_def_id(def.lifetime.id);\n-        let origin = LifetimeDefOrigin::from_is_in_band(def.in_band);\n+        let def_id = hir_map.local_def_id(param.id);\n+        let origin = LifetimeDefOrigin::from_param(param);\n         debug!(\n-            \"Region::late: def={:?} depth={:?} def_id={:?} origin={:?}\",\n-            def,\n+            \"Region::late: param={:?} depth={:?} def_id={:?} origin={:?}\",\n+            param,\n             depth,\n             def_id,\n             origin,\n         );\n-        (def.lifetime.name, Region::LateBound(depth, def_id, origin))\n+        (param.name, Region::LateBound(depth, def_id, origin))\n     }\n \n     fn late_anon(index: &Cell<u32>) -> Region {\n@@ -155,11 +155,10 @@ impl Region {\n         }\n     }\n \n-    fn subst(self, params: &[hir::Lifetime], map: &NamedRegionMap) -> Option<Region> {\n+    fn subst<'a, L>(self, mut params: L, map: &NamedRegionMap) -> Option<Region>\n+            where L: Iterator<Item = &'a hir::Lifetime>  {\n         if let Region::EarlyBound(index, _, _) = self {\n-            params\n-                .get(index as usize)\n-                .and_then(|lifetime| map.defs.get(&lifetime.id).cloned())\n+            params.nth(index as usize).and_then(|lifetime| map.defs.get(&lifetime.id).cloned())\n         } else {\n             Some(self)\n         }\n@@ -270,7 +269,7 @@ enum Scope<'a> {\n     /// it should be shifted by the number of `Binder`s in between the\n     /// declaration `Binder` and the location it's referenced from.\n     Binder {\n-        lifetimes: FxHashMap<hir::LifetimeName, Region>,\n+        lifetimes: FxHashMap<hir::ParamName, Region>,\n \n         /// if we extend this scope with another scope, what is the next index\n         /// we should use for an early-bound region?\n@@ -524,14 +523,19 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 } else {\n                     0\n                 };\n-                let lifetimes = generics\n-                    .lifetimes()\n-                    .map(|def| Region::early(&self.tcx.hir, &mut index, def))\n-                    .collect();\n-                let next_early_index = index + generics.ty_params().count() as u32;\n+                let mut type_count = 0;\n+                let lifetimes = generics.params.iter().filter_map(|param| match param.kind {\n+                    GenericParamKind::Lifetime { .. } => {\n+                        Some(Region::early(&self.tcx.hir, &mut index, param))\n+                    }\n+                    GenericParamKind::Type { .. } => {\n+                        type_count += 1;\n+                        None\n+                    }\n+                }).collect();\n                 let scope = Scope::Binder {\n                     lifetimes,\n-                    next_early_index,\n+                    next_early_index: index + type_count,\n                     abstract_type_parent: true,\n                     track_lifetime_uses,\n                     s: ROOT_SCOPE,\n@@ -568,10 +572,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let was_in_fn_syntax = self.is_in_fn_syntax;\n                 self.is_in_fn_syntax = true;\n                 let scope = Scope::Binder {\n-                    lifetimes: c.generic_params\n-                        .lifetimes()\n-                        .map(|def| Region::late(&self.tcx.hir, def))\n-                        .collect(),\n+                    lifetimes: c.generic_params.iter().filter_map(|param| match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {\n+                            Some(Region::late(&self.tcx.hir, param))\n+                        }\n+                        _ => None,\n+                    }).collect(),\n                     s: self.scope,\n                     next_early_index,\n                     track_lifetime_uses: true,\n@@ -603,9 +609,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         // resolved the same as the `'_` in `&'_ Foo`.\n                         //\n                         // cc #48468\n-                        self.resolve_elided_lifetimes(slice::from_ref(lifetime), false)\n+                        self.resolve_elided_lifetimes(vec![lifetime], false)\n                     }\n-                    LifetimeName::Fresh(_) | LifetimeName::Static | LifetimeName::Name(_) => {\n+                    LifetimeName::Param(_) | LifetimeName::Static => {\n                         // If the user wrote an explicit name, use that.\n                         self.visit_lifetime(lifetime);\n                     }\n@@ -676,18 +682,29 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n                 let mut elision = None;\n                 let mut lifetimes = FxHashMap();\n-                for lt_def in generics.lifetimes() {\n-                    let (lt_name, region) = Region::early(&self.tcx.hir, &mut index, &lt_def);\n-                    if let hir::LifetimeName::Underscore = lt_name {\n-                        // Pick the elided lifetime \"definition\" if one exists and use it to make\n-                        // an elision scope.\n-                        elision = Some(region);\n-                    } else {\n-                        lifetimes.insert(lt_name, region);\n+                let mut type_count = 0;\n+                for param in &generics.params {\n+                    match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {\n+                            let (name, reg) = Region::early(&self.tcx.hir, &mut index, &param);\n+                            if let hir::ParamName::Plain(param_name) = name {\n+                                if param_name == keywords::UnderscoreLifetime.name() {\n+                                    // Pick the elided lifetime \"definition\" if one exists\n+                                    // and use it to make an elision scope.\n+                                    elision = Some(reg);\n+                                } else {\n+                                    lifetimes.insert(name, reg);\n+                                }\n+                            } else {\n+                                lifetimes.insert(name, reg);\n+                            }\n+                        }\n+                        GenericParamKind::Type { .. } => {\n+                            type_count += 1;\n+                        }\n                     }\n                 }\n-\n-                let next_early_index = index + generics.ty_params().count() as u32;\n+                let next_early_index = index + type_count;\n \n                 if let Some(elision_region) = elision {\n                     let scope = Scope::Elision {\n@@ -705,7 +722,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         this.with(scope, |_old_scope, this| {\n                             this.visit_generics(generics);\n                             for bound in bounds {\n-                                this.visit_ty_param_bound(bound);\n+                                this.visit_param_bound(bound);\n                             }\n                         });\n                     });\n@@ -720,7 +737,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     self.with(scope, |_old_scope, this| {\n                         this.visit_generics(generics);\n                         for bound in bounds {\n-                            this.visit_ty_param_bound(bound);\n+                            this.visit_param_bound(bound);\n                         }\n                     });\n                 }\n@@ -745,23 +762,27 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let generics = &trait_item.generics;\n                 let mut index = self.next_early_index();\n                 debug!(\"visit_ty: index = {}\", index);\n-                let lifetimes = generics\n-                    .lifetimes()\n-                    .map(|lt_def| Region::early(&self.tcx.hir, &mut index, lt_def))\n-                    .collect();\n-\n-                let next_early_index = index + generics.ty_params().count() as u32;\n+                let mut type_count = 0;\n+                let lifetimes = generics.params.iter().filter_map(|param| match param.kind {\n+                    GenericParamKind::Lifetime { .. } => {\n+                        Some(Region::early(&self.tcx.hir, &mut index, param))\n+                    }\n+                    GenericParamKind::Type { .. } => {\n+                        type_count += 1;\n+                        None\n+                    }\n+                }).collect();\n                 let scope = Scope::Binder {\n                     lifetimes,\n-                    next_early_index,\n+                    next_early_index: index + type_count,\n                     s: self.scope,\n                     track_lifetime_uses: true,\n                     abstract_type_parent: true,\n                 };\n                 self.with(scope, |_old_scope, this| {\n                     this.visit_generics(generics);\n                     for bound in bounds {\n-                        this.visit_ty_param_bound(bound);\n+                        this.visit_param_bound(bound);\n                     }\n                     if let Some(ty) = ty {\n                         this.visit_ty(ty);\n@@ -791,13 +812,17 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             Type(ref ty) => {\n                 let generics = &impl_item.generics;\n                 let mut index = self.next_early_index();\n+                let mut next_early_index = index;\n                 debug!(\"visit_ty: index = {}\", index);\n-                let lifetimes = generics\n-                    .lifetimes()\n-                    .map(|lt_def| Region::early(&self.tcx.hir, &mut index, lt_def))\n-                    .collect();\n-\n-                let next_early_index = index + generics.ty_params().count() as u32;\n+                let lifetimes = generics.params.iter().filter_map(|param| match param.kind {\n+                    GenericParamKind::Lifetime { .. } => {\n+                        Some(Region::early(&self.tcx.hir, &mut index, param))\n+                    }\n+                    GenericParamKind::Type { .. } => {\n+                        next_early_index += 1;\n+                        None\n+                    }\n+                }).collect();\n                 let scope = Scope::Binder {\n                     lifetimes,\n                     next_early_index,\n@@ -820,7 +845,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n         if lifetime_ref.is_elided() {\n-            self.resolve_elided_lifetimes(slice::from_ref(lifetime_ref), false);\n+            self.resolve_elided_lifetimes(vec![lifetime_ref], false);\n             return;\n         }\n         if lifetime_ref.is_static() {\n@@ -833,8 +858,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_path(&mut self, path: &'tcx hir::Path, _: ast::NodeId) {\n         for (i, segment) in path.segments.iter().enumerate() {\n             let depth = path.segments.len() - i - 1;\n-            if let Some(ref parameters) = segment.parameters {\n-                self.visit_segment_parameters(path.def, depth, parameters);\n+            if let Some(ref args) = segment.args {\n+                self.visit_segment_args(path.def, depth, args);\n             }\n         }\n     }\n@@ -848,14 +873,16 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n-        check_mixed_explicit_and_in_band_defs(\n-            self.tcx,\n-            &generics.lifetimes().cloned().collect::<Vec<_>>(),\n-        );\n-        for ty_param in generics.ty_params() {\n-            walk_list!(self, visit_ty_param_bound, &ty_param.bounds);\n-            if let Some(ref ty) = ty_param.default {\n-                self.visit_ty(&ty);\n+        check_mixed_explicit_and_in_band_defs(self.tcx, &generics.params);\n+        for param in &generics.params {\n+            match param.kind {\n+                GenericParamKind::Lifetime { .. } => {}\n+                GenericParamKind::Type { ref default, .. } => {\n+                    walk_list!(self, visit_param_bound, &param.bounds);\n+                    if let Some(ref ty) = default {\n+                        self.visit_ty(&ty);\n+                    }\n+                }\n             }\n         }\n         for predicate in &generics.where_clause.predicates {\n@@ -866,14 +893,18 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     ref bound_generic_params,\n                     ..\n                 }) => {\n-                    if bound_generic_params.iter().any(|p| p.is_lifetime_param()) {\n+                    let lifetimes: FxHashMap<_, _> = bound_generic_params.iter()\n+                        .filter_map(|param| match param.kind {\n+                            GenericParamKind::Lifetime { .. } => {\n+                                Some(Region::late(&self.tcx.hir, param))\n+                            }\n+                            _ => None,\n+                        }).collect();\n+                    if !lifetimes.is_empty() {\n                         self.trait_ref_hack = true;\n                         let next_early_index = self.next_early_index();\n                         let scope = Scope::Binder {\n-                            lifetimes: bound_generic_params\n-                                .lifetimes()\n-                                .map(|def| Region::late(&self.tcx.hir, def))\n-                                .collect(),\n+                            lifetimes,\n                             s: self.scope,\n                             next_early_index,\n                             track_lifetime_uses: true,\n@@ -882,13 +913,13 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         let result = self.with(scope, |old_scope, this| {\n                             this.check_lifetime_params(old_scope, &bound_generic_params);\n                             this.visit_ty(&bounded_ty);\n-                            walk_list!(this, visit_ty_param_bound, bounds);\n+                            walk_list!(this, visit_param_bound, bounds);\n                         });\n                         self.trait_ref_hack = false;\n                         result\n                     } else {\n                         self.visit_ty(&bounded_ty);\n-                        walk_list!(self, visit_ty_param_bound, bounds);\n+                        walk_list!(self, visit_param_bound, bounds);\n                     }\n                 }\n                 &hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n@@ -897,9 +928,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     ..\n                 }) => {\n                     self.visit_lifetime(lifetime);\n-                    for bound in bounds {\n-                        self.visit_lifetime(bound);\n-                    }\n+                    walk_list!(self, visit_param_bound, bounds);\n                 }\n                 &hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n                     ref lhs_ty,\n@@ -924,7 +953,10 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             || trait_ref\n                 .bound_generic_params\n                 .iter()\n-                .any(|p| p.is_lifetime_param())\n+                .any(|param| match param.kind {\n+                    GenericParamKind::Lifetime { .. } => true,\n+                    _ => false,\n+                })\n         {\n             if self.trait_ref_hack {\n                 span_err!(\n@@ -936,11 +968,13 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             }\n             let next_early_index = self.next_early_index();\n             let scope = Scope::Binder {\n-                lifetimes: trait_ref\n-                    .bound_generic_params\n-                    .lifetimes()\n-                    .map(|def| Region::late(&self.tcx.hir, def))\n-                    .collect(),\n+                lifetimes: trait_ref.bound_generic_params.iter()\n+                    .filter_map(|param| match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {\n+                            Some(Region::late(&self.tcx.hir, param))\n+                        }\n+                        _ => None,\n+                    }).collect(),\n                 s: self.scope,\n                 next_early_index,\n                 track_lifetime_uses: true,\n@@ -989,10 +1023,10 @@ fn original_lifetime(span: Span) -> Original {\n         span: span,\n     }\n }\n-fn shadower_lifetime(l: &hir::Lifetime) -> Shadower {\n+fn shadower_lifetime(param: &hir::GenericParam) -> Shadower {\n     Shadower {\n         kind: ShadowKind::Lifetime,\n-        span: l.span,\n+        span: param.span,\n     }\n }\n \n@@ -1007,23 +1041,27 @@ impl ShadowKind {\n \n fn check_mixed_explicit_and_in_band_defs(\n     tcx: TyCtxt<'_, '_, '_>,\n-    lifetime_defs: &[hir::LifetimeDef],\n+    params: &P<[hir::GenericParam]>,\n ) {\n-    let oob_def = lifetime_defs.iter().find(|lt| !lt.in_band);\n-    let in_band_def = lifetime_defs.iter().find(|lt| lt.in_band);\n-\n-    if let (Some(oob_def), Some(in_band_def)) = (oob_def, in_band_def) {\n+    let in_bands: Vec<_> = params.iter().filter_map(|param| match param.kind {\n+        GenericParamKind::Lifetime { in_band, .. } => Some((in_band, param.span)),\n+        _ => None,\n+    }).collect();\n+    let out_of_band = in_bands.iter().find(|(in_band, _)| !in_band);\n+    let in_band = in_bands.iter().find(|(in_band, _)| *in_band);\n+\n+    if let (Some((_, out_of_band_span)), Some((_, in_band_span)))\n+        = (out_of_band, in_band) {\n         struct_span_err!(\n             tcx.sess,\n-            in_band_def.lifetime.span,\n+            *in_band_span,\n             E0688,\n             \"cannot mix in-band and explicit lifetime definitions\"\n         ).span_label(\n-            in_band_def.lifetime.span,\n+            *in_band_span,\n             \"in-band lifetime definition here\",\n-        )\n-            .span_label(oob_def.lifetime.span, \"explicit lifetime definition here\")\n-            .emit();\n+        ).span_label(*out_of_band_span, \"explicit lifetime definition here\")\n+        .emit();\n     }\n }\n \n@@ -1138,7 +1176,8 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n                     ref lifetimes, s, ..\n                 } => {\n                     // FIXME (#24278): non-hygienic comparison\n-                    if let Some(def) = lifetimes.get(&hir::LifetimeName::Name(label)) {\n+                    let param_name = hir::ParamName::Plain(label);\n+                    if let Some(def) = lifetimes.get(&param_name) {\n                         let node_id = tcx.hir.as_local_node_id(def.id().unwrap()).unwrap();\n \n                         signal_shadowing_problem(\n@@ -1176,14 +1215,18 @@ fn compute_object_lifetime_defaults(\n                         .map(|set| match *set {\n                             Set1::Empty => \"BaseDefault\".to_string(),\n                             Set1::One(Region::Static) => \"'static\".to_string(),\n-                            Set1::One(Region::EarlyBound(i, _, _)) => generics\n-                                .lifetimes()\n-                                .nth(i as usize)\n-                                .unwrap()\n-                                .lifetime\n-                                .name\n-                                .name()\n-                                .to_string(),\n+                            Set1::One(Region::EarlyBound(mut i, _, _)) => {\n+                                generics.params.iter().find_map(|param| match param.kind {\n+                                        GenericParamKind::Lifetime { .. } => {\n+                                            if i == 0 {\n+                                                return Some(param.name.name().to_string());\n+                                            }\n+                                            i -= 1;\n+                                            None\n+                                        }\n+                                        _ => None,\n+                                    }).unwrap()\n+                            }\n                             Set1::One(_) => bug!(),\n                             Set1::Many => \"Ambiguous\".to_string(),\n                         })\n@@ -1207,17 +1250,17 @@ fn object_lifetime_defaults_for_item(\n     tcx: TyCtxt<'_, '_, '_>,\n     generics: &hir::Generics,\n ) -> Vec<ObjectLifetimeDefault> {\n-    fn add_bounds(set: &mut Set1<hir::LifetimeName>, bounds: &[hir::TyParamBound]) {\n+    fn add_bounds(set: &mut Set1<hir::LifetimeName>, bounds: &[hir::GenericBound]) {\n         for bound in bounds {\n-            if let hir::RegionTyParamBound(ref lifetime) = *bound {\n+            if let hir::GenericBound::Outlives(ref lifetime) = *bound {\n                 set.insert(lifetime.name);\n             }\n         }\n     }\n \n-    generics\n-        .ty_params()\n-        .map(|param| {\n+    generics.params.iter().filter_map(|param| match param.kind {\n+        GenericParamKind::Lifetime { .. } => None,\n+        GenericParamKind::Type { .. } => {\n             let mut set = Set1::Empty;\n \n             add_bounds(&mut set, &param.bounds);\n@@ -1246,27 +1289,35 @@ fn object_lifetime_defaults_for_item(\n                 }\n             }\n \n-            match set {\n+            Some(match set {\n                 Set1::Empty => Set1::Empty,\n                 Set1::One(name) => {\n                     if name == hir::LifetimeName::Static {\n                         Set1::One(Region::Static)\n                     } else {\n-                        generics\n-                            .lifetimes()\n-                            .enumerate()\n-                            .find(|&(_, def)| def.lifetime.name == name)\n-                            .map_or(Set1::Many, |(i, def)| {\n-                                let def_id = tcx.hir.local_def_id(def.lifetime.id);\n-                                let origin = LifetimeDefOrigin::from_is_in_band(def.in_band);\n-                                Set1::One(Region::EarlyBound(i as u32, def_id, origin))\n-                            })\n+                        generics.params.iter().filter_map(|param| match param.kind {\n+                            GenericParamKind::Lifetime { .. } => {\n+                                Some((\n+                                    param.id,\n+                                    hir::LifetimeName::Param(param.name),\n+                                    LifetimeDefOrigin::from_param(param),\n+                                ))\n+                            }\n+                            _ => None,\n+                        })\n+                        .enumerate()\n+                        .find(|&(_, (_, lt_name, _))| lt_name == name)\n+                        .map_or(Set1::Many, |(i, (id, _, origin))| {\n+                            let def_id = tcx.hir.local_def_id(id);\n+                            Set1::One(Region::EarlyBound(i as u32, def_id, origin))\n+                        })\n                     }\n                 }\n                 Set1::Many => Set1::Many,\n-            }\n-        })\n-        .collect()\n+            })\n+        }\n+    })\n+    .collect()\n }\n \n impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n@@ -1346,47 +1397,45 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 Some(LifetimeUseSet::One(_)) => {\n                     let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n                     debug!(\"node id first={:?}\", node_id);\n-                    if let hir::map::NodeLifetime(hir_lifetime) = self.tcx.hir.get(node_id) {\n-                        let span = hir_lifetime.span;\n-                        let id = hir_lifetime.id;\n-                        debug!(\n-                            \"id ={:?} span = {:?} hir_lifetime = {:?}\",\n-                            node_id, span, hir_lifetime\n-                        );\n-\n-                        self.tcx\n-                            .struct_span_lint_node(\n-                                lint::builtin::SINGLE_USE_LIFETIMES,\n-                                id,\n-                                span,\n-                                &format!(\n-                                    \"lifetime parameter `{}` only used once\",\n-                                    hir_lifetime.name.name()\n-                                ),\n-                            )\n-                            .emit();\n+                    if let Some((id, span, name)) = match self.tcx.hir.get(node_id) {\n+                        hir::map::NodeLifetime(hir_lifetime) => {\n+                            Some((hir_lifetime.id, hir_lifetime.span, hir_lifetime.name.name()))\n+                        }\n+                        hir::map::NodeGenericParam(param) => {\n+                            Some((param.id, param.span, param.name.name()))\n+                        }\n+                        _ => None,\n+                    } {\n+                        debug!(\"id = {:?} span = {:?} name = {:?}\", node_id, span, name);\n+                        self.tcx.struct_span_lint_node(\n+                            lint::builtin::SINGLE_USE_LIFETIMES,\n+                            id,\n+                            span,\n+                            &format!(\"lifetime parameter `{}` only used once\", name),\n+                        ).emit();\n                     }\n                 }\n                 Some(LifetimeUseSet::Many) => {\n                     debug!(\"Not one use lifetime\");\n                 }\n                 None => {\n                     let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n-                    if let hir::map::NodeLifetime(hir_lifetime) = self.tcx.hir.get(node_id) {\n-                        let span = hir_lifetime.span;\n-                        let id = hir_lifetime.id;\n-\n-                        self.tcx\n-                            .struct_span_lint_node(\n-                                lint::builtin::UNUSED_LIFETIMES,\n-                                id,\n-                                span,\n-                                &format!(\n-                                    \"lifetime parameter `{}` never used\",\n-                                    hir_lifetime.name.name()\n-                                ),\n-                            )\n-                            .emit();\n+                    if let Some((id, span, name)) = match self.tcx.hir.get(node_id) {\n+                        hir::map::NodeLifetime(hir_lifetime) => {\n+                            Some((hir_lifetime.id, hir_lifetime.span, hir_lifetime.name.name()))\n+                        }\n+                        hir::map::NodeGenericParam(param) => {\n+                            Some((param.id, param.span, param.name.name()))\n+                        }\n+                        _ => None,\n+                    } {\n+                        debug!(\"id ={:?} span = {:?} name = {:?}\", node_id, span, name);\n+                        self.tcx.struct_span_lint_node(\n+                            lint::builtin::UNUSED_LIFETIMES,\n+                            id,\n+                            span,\n+                            &format!(\"lifetime parameter `{}` never used\", name)\n+                        ).emit();\n                     }\n                 }\n             }\n@@ -1438,18 +1487,21 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         }\n \n-        let lifetimes = generics\n-            .lifetimes()\n-            .map(|def| {\n-                if self.map.late_bound.contains(&def.lifetime.id) {\n-                    Region::late(&self.tcx.hir, def)\n+        let mut type_count = 0;\n+        let lifetimes = generics.params.iter().filter_map(|param| match param.kind {\n+            GenericParamKind::Lifetime { .. } => {\n+                if self.map.late_bound.contains(&param.id) {\n+                    Some(Region::late(&self.tcx.hir, param))\n                 } else {\n-                    Region::early(&self.tcx.hir, &mut index, def)\n+                    Some(Region::early(&self.tcx.hir, &mut index, param))\n                 }\n-            })\n-            .collect();\n-\n-        let next_early_index = index + generics.ty_params().count() as u32;\n+            }\n+            GenericParamKind::Type { .. } => {\n+                type_count += 1;\n+                None\n+            }\n+        }).collect();\n+        let next_early_index = index + type_count;\n \n         let scope = Scope::Binder {\n             lifetimes,\n@@ -1521,10 +1573,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     break None;\n                 }\n \n-                Scope::Binder {\n-                    ref lifetimes, s, ..\n-                } => {\n-                    if let Some(&def) = lifetimes.get(&lifetime_ref.name) {\n+                Scope::Binder { ref lifetimes, s, .. } => {\n+                    let name = match lifetime_ref.name {\n+                        LifetimeName::Param(param_name) => param_name,\n+                        _ => bug!(\"expected LifetimeName::Param\"),\n+                    };\n+                    if let Some(&def) = lifetimes.get(&name) {\n                         break Some(def.shifted(late_depth));\n                     } else {\n                         late_depth += 1;\n@@ -1599,26 +1653,35 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_segment_parameters(\n+    fn visit_segment_args(\n         &mut self,\n         def: Def,\n         depth: usize,\n-        params: &'tcx hir::PathParameters,\n+        generic_args: &'tcx hir::GenericArgs,\n     ) {\n-        if params.parenthesized {\n+        if generic_args.parenthesized {\n             let was_in_fn_syntax = self.is_in_fn_syntax;\n             self.is_in_fn_syntax = true;\n-            self.visit_fn_like_elision(params.inputs(), Some(&params.bindings[0].ty));\n+            self.visit_fn_like_elision(generic_args.inputs(),\n+                                       Some(&generic_args.bindings[0].ty));\n             self.is_in_fn_syntax = was_in_fn_syntax;\n             return;\n         }\n \n-        if params.lifetimes.iter().all(|l| l.is_elided()) {\n-            self.resolve_elided_lifetimes(&params.lifetimes, true);\n-        } else {\n-            for l in &params.lifetimes {\n-                self.visit_lifetime(l);\n+        let mut elide_lifetimes = true;\n+        let lifetimes = generic_args.args.iter().filter_map(|arg| match arg {\n+            hir::GenericArg::Lifetime(lt) => {\n+                if !lt.is_elided() {\n+                    elide_lifetimes = false;\n+                }\n+                Some(lt)\n             }\n+            _ => None,\n+        }).collect();\n+        if elide_lifetimes {\n+            self.resolve_elided_lifetimes(lifetimes, true);\n+        } else {\n+            lifetimes.iter().for_each(|lt| self.visit_lifetime(lt));\n         }\n \n         // Figure out if this is a type/trait segment,\n@@ -1680,33 +1743,45 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         }).collect()\n                     })\n             };\n-            unsubst\n-                .iter()\n-                .map(|set| match *set {\n-                    Set1::Empty => if in_body {\n-                        None\n-                    } else {\n-                        Some(Region::Static)\n-                    },\n-                    Set1::One(r) => r.subst(&params.lifetimes, map),\n-                    Set1::Many => None,\n-                })\n-                .collect()\n+            unsubst.iter()\n+                   .map(|set| match *set {\n+                       Set1::Empty => if in_body {\n+                           None\n+                       } else {\n+                           Some(Region::Static)\n+                       },\n+                       Set1::One(r) => {\n+                           let lifetimes = generic_args.args.iter().filter_map(|arg| match arg {\n+                               GenericArg::Lifetime(lt) => Some(lt),\n+                               _ => None,\n+                           });\n+                           r.subst(lifetimes, map)\n+                       }\n+                       Set1::Many => None,\n+                   })\n+                   .collect()\n         });\n \n-        for (i, ty) in params.types.iter().enumerate() {\n-            if let Some(&lt) = object_lifetime_defaults.get(i) {\n-                let scope = Scope::ObjectLifetimeDefault {\n-                    lifetime: lt,\n-                    s: self.scope,\n-                };\n-                self.with(scope, |_, this| this.visit_ty(ty));\n-            } else {\n-                self.visit_ty(ty);\n+        let mut i = 0;\n+        for arg in &generic_args.args {\n+            match arg {\n+                GenericArg::Lifetime(_) => {}\n+                GenericArg::Type(ty) => {\n+                    if let Some(&lt) = object_lifetime_defaults.get(i) {\n+                        let scope = Scope::ObjectLifetimeDefault {\n+                            lifetime: lt,\n+                            s: self.scope,\n+                        };\n+                        self.with(scope, |_, this| this.visit_ty(ty));\n+                    } else {\n+                        self.visit_ty(ty);\n+                    }\n+                    i += 1;\n+                }\n             }\n         }\n \n-        for b in &params.bindings {\n+        for b in &generic_args.bindings {\n             self.visit_assoc_type_binding(b);\n         }\n     }\n@@ -1944,7 +2019,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n \n             fn visit_generic_param(&mut self, param: &hir::GenericParam) {\n-                if let hir::GenericParam::Lifetime(_) = *param {\n+                if let hir::GenericParamKind::Lifetime { .. } = param.kind {\n                     // FIXME(eddyb) Do we want this? It only makes a difference\n                     // if this `for<'a>` lifetime parameter is never used.\n                     self.have_bound_regions = true;\n@@ -1981,7 +2056,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn resolve_elided_lifetimes(&mut self, lifetime_refs: &'tcx [hir::Lifetime], deprecated: bool) {\n+    fn resolve_elided_lifetimes(&mut self,\n+                                lifetime_refs: Vec<&'tcx hir::Lifetime>,\n+                                deprecated: bool) {\n         if lifetime_refs.is_empty() {\n             return;\n         }\n@@ -2159,100 +2236,99 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n \n     fn check_lifetime_params(&mut self, old_scope: ScopeRef, params: &'tcx [hir::GenericParam]) {\n-        for (i, lifetime_i) in params.lifetimes().enumerate() {\n-            match lifetime_i.lifetime.name {\n-                hir::LifetimeName::Static | hir::LifetimeName::Underscore => {\n-                    let lifetime = lifetime_i.lifetime;\n-                    let name = lifetime.name.name();\n+        let lifetimes: Vec<_> = params.iter().filter_map(|param| match param.kind {\n+            GenericParamKind::Lifetime { .. } => Some((param, param.name)),\n+            _ => None,\n+        }).collect();\n+        for (i, (lifetime_i, lifetime_i_name)) in lifetimes.iter().enumerate() {\n+            if let hir::ParamName::Plain(_) = lifetime_i_name {\n+                let name = lifetime_i_name.name();\n+                if name == keywords::UnderscoreLifetime.name() ||\n+                   name == keywords::StaticLifetime.name() {\n                     let mut err = struct_span_err!(\n                         self.tcx.sess,\n-                        lifetime.span,\n+                        lifetime_i.span,\n                         E0262,\n                         \"invalid lifetime parameter name: `{}`\",\n                         name\n                     );\n                     err.span_label(\n-                        lifetime.span,\n+                        lifetime_i.span,\n                         format!(\"{} is a reserved lifetime name\", name),\n                     );\n                     err.emit();\n                 }\n-                hir::LifetimeName::Fresh(_)\n-                | hir::LifetimeName::Implicit\n-                | hir::LifetimeName::Name(_) => {}\n             }\n \n             // It is a hard error to shadow a lifetime within the same scope.\n-            for lifetime_j in params.lifetimes().skip(i + 1) {\n-                if lifetime_i.lifetime.name == lifetime_j.lifetime.name {\n+            for (lifetime_j, lifetime_j_name) in lifetimes.iter().skip(i + 1) {\n+                if lifetime_i_name == lifetime_j_name {\n                     struct_span_err!(\n                         self.tcx.sess,\n-                        lifetime_j.lifetime.span,\n+                        lifetime_j.span,\n                         E0263,\n                         \"lifetime name `{}` declared twice in the same scope\",\n-                        lifetime_j.lifetime.name.name()\n-                    ).span_label(lifetime_j.lifetime.span, \"declared twice\")\n-                        .span_label(lifetime_i.lifetime.span, \"previous declaration here\")\n-                        .emit();\n+                        lifetime_j.name.name()\n+                    ).span_label(lifetime_j.span, \"declared twice\")\n+                     .span_label(lifetime_i.span, \"previous declaration here\")\n+                     .emit();\n                 }\n             }\n \n             // It is a soft error to shadow a lifetime within a parent scope.\n-            self.check_lifetime_def_for_shadowing(old_scope, &lifetime_i.lifetime);\n+            self.check_lifetime_param_for_shadowing(old_scope, &lifetime_i);\n \n             for bound in &lifetime_i.bounds {\n-                match bound.name {\n-                    hir::LifetimeName::Underscore => {\n-                        let mut err = struct_span_err!(\n-                            self.tcx.sess,\n-                            bound.span,\n-                            E0637,\n-                            \"invalid lifetime bound name: `'_`\"\n-                        );\n-                        err.span_label(bound.span, \"`'_` is a reserved lifetime name\");\n-                        err.emit();\n-                    }\n-                    hir::LifetimeName::Static => {\n-                        self.insert_lifetime(bound, Region::Static);\n-                        self.tcx\n-                            .sess\n-                            .struct_span_warn(\n-                                lifetime_i.lifetime.span.to(bound.span),\n+                match bound {\n+                    hir::GenericBound::Outlives(lt) => match lt.name {\n+                        hir::LifetimeName::Underscore => {\n+                            let mut err = struct_span_err!(\n+                                self.tcx.sess,\n+                                lt.span,\n+                                E0637,\n+                                \"invalid lifetime bound name: `'_`\"\n+                            );\n+                            err.span_label(lt.span, \"`'_` is a reserved lifetime name\");\n+                            err.emit();\n+                        }\n+                        hir::LifetimeName::Static => {\n+                            self.insert_lifetime(lt, Region::Static);\n+                            self.tcx.sess.struct_span_warn(\n+                                lifetime_i.span.to(lt.span),\n                                 &format!(\n                                     \"unnecessary lifetime parameter `{}`\",\n-                                    lifetime_i.lifetime.name.name()\n+                                    lifetime_i.name.name(),\n                                 ),\n-                            )\n-                            .help(&format!(\n+                            ).help(&format!(\n                                 \"you can use the `'static` lifetime directly, in place \\\n-                                 of `{}`\",\n-                                lifetime_i.lifetime.name.name()\n-                            ))\n-                            .emit();\n-                    }\n-                    hir::LifetimeName::Fresh(_)\n-                    | hir::LifetimeName::Implicit\n-                    | hir::LifetimeName::Name(_) => {\n-                        self.resolve_lifetime_ref(bound);\n+                                    of `{}`\",\n+                                lifetime_i.name.name(),\n+                            )).emit();\n+                        }\n+                        hir::LifetimeName::Param(_)\n+                        | hir::LifetimeName::Implicit => {\n+                            self.resolve_lifetime_ref(lt);\n+                        }\n                     }\n+                    _ => bug!(),\n                 }\n             }\n         }\n     }\n \n-    fn check_lifetime_def_for_shadowing(\n+    fn check_lifetime_param_for_shadowing(\n         &self,\n         mut old_scope: ScopeRef,\n-        lifetime: &'tcx hir::Lifetime,\n+        param: &'tcx hir::GenericParam,\n     ) {\n         for &(label, label_span) in &self.labels_in_fn {\n             // FIXME (#24278): non-hygienic comparison\n-            if lifetime.name.name() == label {\n+            if param.name.name() == label {\n                 signal_shadowing_problem(\n                     self.tcx,\n                     label,\n                     original_label(label_span),\n-                    shadower_lifetime(&lifetime),\n+                    shadower_lifetime(&param),\n                 );\n                 return;\n             }\n@@ -2273,14 +2349,14 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 Scope::Binder {\n                     ref lifetimes, s, ..\n                 } => {\n-                    if let Some(&def) = lifetimes.get(&lifetime.name) {\n+                    if let Some(&def) = lifetimes.get(&param.name) {\n                         let node_id = self.tcx.hir.as_local_node_id(def.id().unwrap()).unwrap();\n \n                         signal_shadowing_problem(\n                             self.tcx,\n-                            lifetime.name.name(),\n+                            param.name.name(),\n                             original_lifetime(self.tcx.hir.span(node_id)),\n-                            shadower_lifetime(&lifetime),\n+                            shadower_lifetime(&param),\n                         );\n                         return;\n                     }\n@@ -2428,14 +2504,14 @@ fn insert_late_bound_lifetimes(\n     appears_in_where_clause.visit_generics(generics);\n \n     for param in &generics.params {\n-        match *param {\n-            hir::GenericParam::Lifetime(ref lifetime_def) => {\n-                if !lifetime_def.bounds.is_empty() {\n+        match param.kind {\n+            hir::GenericParamKind::Lifetime { .. } => {\n+                if !param.bounds.is_empty() {\n                     // `'a: 'b` means both `'a` and `'b` are referenced\n-                    appears_in_where_clause.regions.insert(lifetime_def.lifetime.name);\n+                    appears_in_where_clause.regions.insert(hir::LifetimeName::Param(param.name));\n                 }\n             }\n-            hir::GenericParam::Type(_) => {}\n+            hir::GenericParamKind::Type { .. } => {}\n         }\n     }\n \n@@ -2448,33 +2524,26 @@ fn insert_late_bound_lifetimes(\n     // - appear in the inputs\n     // - do not appear in the where-clauses\n     // - are not implicitly captured by `impl Trait`\n-    for lifetime in generics.lifetimes() {\n-        let name = lifetime.lifetime.name;\n-\n+    for param in &generics.params {\n+        let lt_name = hir::LifetimeName::Param(param.name);\n         // appears in the where clauses? early-bound.\n-        if appears_in_where_clause.regions.contains(&name) {\n+        if appears_in_where_clause.regions.contains(&lt_name) {\n             continue;\n         }\n \n         // does not appear in the inputs, but appears in the return type? early-bound.\n-        if !constrained_by_input.regions.contains(&name)\n-            && appears_in_output.regions.contains(&name)\n+        if !constrained_by_input.regions.contains(&lt_name)\n+            && appears_in_output.regions.contains(&lt_name)\n         {\n             continue;\n         }\n \n-        debug!(\n-            \"insert_late_bound_lifetimes: \\\n-             lifetime {:?} with id {:?} is late-bound\",\n-            lifetime.lifetime.name, lifetime.lifetime.id\n-        );\n+        debug!(\"insert_late_bound_lifetimes: lifetime {:?} with id {:?} is late-bound\",\n+               param.name.name(),\n+               param.id);\n \n-        let inserted = map.late_bound.insert(lifetime.lifetime.id);\n-        assert!(\n-            inserted,\n-            \"visited lifetime {:?} twice\",\n-            lifetime.lifetime.id\n-        );\n+        let inserted = map.late_bound.insert(param.id);\n+        assert!(inserted, \"visited lifetime {:?} twice\", param.id);\n     }\n \n     return;"}, {"sha": "f48739799203fb9c41453c7a2f7592f42daf72a6", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -224,11 +224,9 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             let names_map: FxHashSet<String> = generics\n                 .params\n                 .iter()\n-                .filter_map(|param| {\n-                    match param.kind {\n-                        ty::GenericParamDefKind::Lifetime => Some(param.name.to_string()),\n-                        _ => None\n-                    }\n+                .filter_map(|param| match param.kind {\n+                    ty::GenericParamDefKind::Lifetime => Some(param.name.to_string()),\n+                    _ => None\n                 })\n                 .collect();\n "}, {"sha": "479fbe2673b97357a8d54aaa37dd41e06c6d0433", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -215,7 +215,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             data @ DefPathData::ValueNs(..) |\n             data @ DefPathData::Module(..) |\n             data @ DefPathData::TypeParam(..) |\n-            data @ DefPathData::LifetimeDef(..) |\n+            data @ DefPathData::LifetimeParam(..) |\n             data @ DefPathData::EnumVariant(..) |\n             data @ DefPathData::Field(..) |\n             data @ DefPathData::AnonConst |"}, {"sha": "3252a2cd6ab0f6bcbfe35c54ae3ba41cd6cb36e2", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -287,7 +287,7 @@ impl PrintContext {\n                     DefPathData::MacroDef(_) |\n                     DefPathData::ClosureExpr |\n                     DefPathData::TypeParam(_) |\n-                    DefPathData::LifetimeDef(_) |\n+                    DefPathData::LifetimeParam(_) |\n                     DefPathData::Field(_) |\n                     DefPathData::StructCtor |\n                     DefPathData::AnonConst |\n@@ -336,12 +336,10 @@ impl PrintContext {\n \n             if !verbose {\n                 let mut type_params =\n-                    generics.params.iter().rev().filter_map(|param| {\n-                        match param.kind {\n-                            GenericParamDefKind::Type { has_default, .. } => {\n-                                Some((param.def_id, has_default))\n-                            }\n-                            GenericParamDefKind::Lifetime => None,\n+                    generics.params.iter().rev().filter_map(|param| match param.kind {\n+                        GenericParamDefKind::Lifetime => None,\n+                        GenericParamDefKind::Type { has_default, .. } => {\n+                            Some((param.def_id, has_default))\n                         }\n                     }).peekable();\n                 let has_default = {"}, {"sha": "67720e61e91af3eb16fbeb930a5ca2128f948cf8", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -677,14 +677,20 @@ impl<'a> ReplaceBodyWithLoop<'a> {\n                     ast::TyKind::Paren(ref subty) => involves_impl_trait(subty),\n                     ast::TyKind::Tup(ref tys) => any_involves_impl_trait(tys.iter()),\n                     ast::TyKind::Path(_, ref path) => path.segments.iter().any(|seg| {\n-                        match seg.parameters.as_ref().map(|p| &**p) {\n+                        match seg.args.as_ref().map(|generic_arg| &**generic_arg) {\n                             None => false,\n-                            Some(&ast::PathParameters::AngleBracketed(ref data)) =>\n-                                any_involves_impl_trait(data.types.iter()) ||\n-                                any_involves_impl_trait(data.bindings.iter().map(|b| &b.ty)),\n-                            Some(&ast::PathParameters::Parenthesized(ref data)) =>\n+                            Some(&ast::GenericArgs::AngleBracketed(ref data)) => {\n+                                let types = data.args.iter().filter_map(|arg| match arg {\n+                                    ast::GenericArg::Type(ty) => Some(ty),\n+                                    _ => None,\n+                                });\n+                                any_involves_impl_trait(types.into_iter()) ||\n+                                any_involves_impl_trait(data.bindings.iter().map(|b| &b.ty))\n+                            },\n+                            Some(&ast::GenericArgs::Parenthesized(ref data)) => {\n                                 any_involves_impl_trait(data.inputs.iter()) ||\n-                                any_involves_impl_trait(data.output.iter()),\n+                                any_involves_impl_trait(data.output.iter())\n+                            }\n                         }\n                     }),\n                     _ => false,"}, {"sha": "8f8fe04fd8e019c9ab653ece9f90d1526297eae4", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -18,7 +18,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax_pos::Span;\n \n-use rustc::hir::{self, PatKind};\n+use rustc::hir::{self, GenericParamKind, PatKind};\n use rustc::hir::intravisit::FnKind;\n \n #[derive(PartialEq)]\n@@ -147,9 +147,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCamelCaseTypes {\n     }\n \n     fn check_generic_param(&mut self, cx: &LateContext, param: &hir::GenericParam) {\n-        if let hir::GenericParam::Type(ref gen) = *param {\n-            if gen.synthetic.is_none() {\n-                self.check_case(cx, \"type parameter\", gen.name, gen.span);\n+        match param.kind {\n+            GenericParamKind::Lifetime { .. } => {}\n+            GenericParamKind::Type { synthetic, .. } => {\n+                if synthetic.is_none() {\n+                    self.check_case(cx, \"type parameter\", param.name.name(), param.span);\n+                }\n             }\n         }\n     }\n@@ -253,13 +256,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n     }\n \n     fn check_generic_param(&mut self, cx: &LateContext, param: &hir::GenericParam) {\n-        if let hir::GenericParam::Lifetime(ref ld) = *param {\n-            self.check_snake_case(\n-                cx,\n-                \"lifetime\",\n-                &ld.lifetime.name.name().as_str(),\n-                Some(ld.lifetime.span)\n-            );\n+        match param.kind {\n+            GenericParamKind::Lifetime { .. } => {\n+                let name = param.name.name().as_str();\n+                self.check_snake_case(cx, \"lifetime\", &name, Some(param.span));\n+            }\n+            GenericParamKind::Type { .. } => {}\n         }\n     }\n "}, {"sha": "941fabe26a6ed3ff3f789103372c6d4306dc2546", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -49,7 +49,7 @@ use syntax_pos::{BytePos, Span, SyntaxContext};\n use syntax::symbol::keywords;\n use syntax::errors::{Applicability, DiagnosticBuilder};\n \n-use rustc::hir::{self, PatKind};\n+use rustc::hir::{self, GenericParamKind, PatKind};\n use rustc::hir::intravisit::FnKind;\n \n use bad_style::{MethodLateContext, method_context};\n@@ -1196,15 +1196,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n                         }\n                         err.emit();\n                     }\n-                    if generics.is_type_parameterized() {\n-                        let mut err = cx.struct_span_lint(NO_MANGLE_GENERIC_ITEMS,\n-                                                          it.span,\n-                                                          \"functions generic over \\\n-                                                           types must be mangled\");\n-                        err.span_suggestion_short(no_mangle_attr.span,\n-                                                  \"remove this attribute\",\n-                                                  \"\".to_owned());\n-                        err.emit();\n+                    for param in &generics.params {\n+                        match param.kind {\n+                            GenericParamKind::Lifetime { .. } => {}\n+                            GenericParamKind::Type { .. } => {\n+                                let mut err = cx.struct_span_lint(NO_MANGLE_GENERIC_ITEMS,\n+                                                                  it.span,\n+                                                                  \"functions generic over \\\n+                                                                   types must be mangled\");\n+                                err.span_suggestion_short(no_mangle_attr.span,\n+                                                          \"remove this attribute\",\n+                                                          \"\".to_owned());\n+                                err.emit();\n+                                break;\n+                            }\n+                        }\n                     }\n                 }\n             }\n@@ -1531,10 +1537,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeAliasBounds {\n         }\n         // The parameters must not have bounds\n         for param in type_alias_generics.params.iter() {\n-            let spans : Vec<_> = match param {\n-                &hir::GenericParam::Lifetime(ref l) => l.bounds.iter().map(|b| b.span).collect(),\n-                &hir::GenericParam::Type(ref ty) => ty.bounds.iter().map(|b| b.span()).collect(),\n-            };\n+            let spans: Vec<_> = param.bounds.iter().map(|b| b.span()).collect();\n             if !spans.is_empty() {\n                 let mut err = cx.struct_span_lint(\n                     TYPE_ALIAS_BOUNDS,"}, {"sha": "50492ae073720b62fef99564f6df441697fa2407", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 55, "deletions": 44, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -810,52 +810,63 @@ impl LintPass for VariantSizeDifferences {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n-        if let hir::ItemEnum(ref enum_definition, ref gens) = it.node {\n-            if gens.params.iter().all(|param| param.is_lifetime_param()) {\n-                // sizes only make sense for non-generic types\n-                let item_def_id = cx.tcx.hir.local_def_id(it.id);\n-                let t = cx.tcx.type_of(item_def_id);\n-                let ty = cx.tcx.erase_regions(&t);\n-                let layout = cx.layout_of(ty).unwrap_or_else(|e| {\n-                    bug!(\"failed to get layout for `{}`: {}\", t, e)\n-                });\n-\n-                if let layout::Variants::Tagged { ref variants, ref tag, .. } = layout.variants {\n-                    let discr_size = tag.value.size(cx.tcx).bytes();\n-\n-                    debug!(\"enum `{}` is {} bytes large with layout:\\n{:#?}\",\n-                      t, layout.size.bytes(), layout);\n-\n-                    let (largest, slargest, largest_index) = enum_definition.variants\n-                        .iter()\n-                        .zip(variants)\n-                        .map(|(variant, variant_layout)| {\n-                            // Subtract the size of the enum discriminant\n-                            let bytes = variant_layout.size.bytes()\n-                                .saturating_sub(discr_size);\n-\n-                            debug!(\"- variant `{}` is {} bytes large\", variant.node.name, bytes);\n-                            bytes\n-                        })\n-                        .enumerate()\n-                        .fold((0, 0, 0), |(l, s, li), (idx, size)| if size > l {\n-                            (size, l, idx)\n-                        } else if size > s {\n-                            (l, size, li)\n-                        } else {\n-                            (l, s, li)\n-                        });\n-\n-                    // we only warn if the largest variant is at least thrice as large as\n-                    // the second-largest.\n-                    if largest > slargest * 3 && slargest > 0 {\n-                        cx.span_lint(VARIANT_SIZE_DIFFERENCES,\n-                                     enum_definition.variants[largest_index].span,\n-                                     &format!(\"enum variant is more than three times larger \\\n-                                               ({} bytes) than the next largest\",\n-                                              largest));\n+        if let hir::ItemEnum(ref enum_definition, _) = it.node {\n+            let item_def_id = cx.tcx.hir.local_def_id(it.id);\n+            let generics = cx.tcx.generics_of(item_def_id);\n+            for param in &generics.params {\n+                match param.kind {\n+                    ty::GenericParamDefKind::Lifetime { .. } => {},\n+                    ty::GenericParamDefKind::Type { .. } => return,\n+                }\n+            }\n+            // Sizes only make sense for non-generic types.\n+            let t = cx.tcx.type_of(item_def_id);\n+            let ty = cx.tcx.erase_regions(&t);\n+            match cx.layout_of(ty) {\n+                Ok(layout) => {\n+                    let variants = &layout.variants;\n+                    if let layout::Variants::Tagged { ref variants, ref tag, .. } = variants {\n+                        let discr_size = tag.value.size(cx.tcx).bytes();\n+\n+                        debug!(\"enum `{}` is {} bytes large with layout:\\n{:#?}\",\n+                               t, layout.size.bytes(), layout);\n+\n+                        let (largest, slargest, largest_index) = enum_definition.variants\n+                            .iter()\n+                            .zip(variants)\n+                            .map(|(variant, variant_layout)| {\n+                                // Subtract the size of the enum discriminant.\n+                                let bytes = variant_layout.size.bytes().saturating_sub(discr_size);\n+\n+                                debug!(\"- variant `{}` is {} bytes large\",\n+                                       variant.node.name,\n+                                       bytes);\n+                                bytes\n+                            })\n+                            .enumerate()\n+                            .fold((0, 0, 0), |(l, s, li), (idx, size)| if size > l {\n+                                (size, l, idx)\n+                            } else if size > s {\n+                                (l, size, li)\n+                            } else {\n+                                (l, s, li)\n+                            });\n+\n+                        // We only warn if the largest variant is at least thrice as large as\n+                        // the second-largest.\n+                        if largest > slargest * 3 && slargest > 0 {\n+                            cx.span_lint(VARIANT_SIZE_DIFFERENCES,\n+                                            enum_definition.variants[largest_index].span,\n+                                            &format!(\"enum variant is more than three times \\\n+                                                      larger ({} bytes) than the next largest\",\n+                                                     largest));\n+                        }\n                     }\n                 }\n+                Err(ty::layout::LayoutError::Unknown(_)) => return,\n+                Err(err @ ty::layout::LayoutError::SizeOverflow(_)) => {\n+                    bug!(\"failed to get layout for `{}`: {}\", t, err);\n+                }\n             }\n         }\n     }"}, {"sha": "cbe9615c69397c644e18b5c44652198aaaad30c5", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -1235,10 +1235,14 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                     self.encode_optimized_mir(def_id)\n                 }\n                 hir::ItemConst(..) => self.encode_optimized_mir(def_id),\n-                hir::ItemFn(_, _, constness, _, ref generics, _) => {\n-                    let has_tps = generics.ty_params().next().is_some();\n+                hir::ItemFn(_, _, constness, ..) => {\n+                    let generics = tcx.generics_of(def_id);\n+                    let has_types = generics.params.iter().any(|param| match param.kind {\n+                        ty::GenericParamDefKind::Type { .. } => true,\n+                        _ => false,\n+                    });\n                     let needs_inline =\n-                        (has_tps || tcx.codegen_fn_attrs(def_id).requests_inline()) &&\n+                        (has_types || tcx.codegen_fn_attrs(def_id).requests_inline()) &&\n                             !self.metadata_output_only();\n                     let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n                     if needs_inline || constness == hir::Constness::Const || always_encode_mir {\n@@ -1645,11 +1649,15 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_info_for_generics(&mut self, generics: &hir::Generics) {\n-        for ty_param in generics.ty_params() {\n-            let def_id = self.tcx.hir.local_def_id(ty_param.id);\n-            let has_default = Untracked(ty_param.default.is_some());\n-            self.record(def_id, IsolatedEncoder::encode_info_for_ty_param, (def_id, has_default));\n-        }\n+        generics.params.iter().for_each(|param| match param.kind {\n+            hir::GenericParamKind::Lifetime { .. } => {}\n+            hir::GenericParamKind::Type { ref default, .. } => {\n+                let def_id = self.tcx.hir.local_def_id(param.id);\n+                let has_default = Untracked(default.is_some());\n+                let encode_info = IsolatedEncoder::encode_info_for_ty_param;\n+                self.record(def_id, encode_info, (def_id, has_default));\n+            }\n+        });\n     }\n \n     fn encode_info_for_ty(&mut self, ty: &hir::Ty) {"}, {"sha": "2c58bd8e79b08ac7d4de1c7d4fb3c71577de9d83", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -295,7 +295,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             );\n             let label_msg = match pat.node {\n                 PatKind::Path(hir::QPath::Resolved(None, ref path))\n-                        if path.segments.len() == 1 && path.segments[0].parameters.is_none() => {\n+                        if path.segments.len() == 1 && path.segments[0].args.is_none() => {\n                     format!(\"interpreted as a {} pattern, not new variable\", path.def.kind_name())\n                 }\n                 _ => format!(\"pattern `{}` not covered\", pattern_string),"}, {"sha": "ef69cb574e07e6b70571899b23b92ba1f72dfc16", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -1099,14 +1099,12 @@ fn create_mono_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                  item: &'tcx hir::Item,\n                                                  output: &mut Vec<MonoItem<'tcx>>) {\n     match item.node {\n-        hir::ItemImpl(_,\n-                      _,\n-                      _,\n-                      ref generics,\n-                      ..,\n-                      ref impl_item_refs) => {\n-            if generics.is_type_parameterized() {\n-                return\n+        hir::ItemImpl(_, _, _, ref generics, .., ref impl_item_refs) => {\n+            for param in &generics.params {\n+                match param.kind {\n+                    hir::GenericParamKind::Lifetime { .. } => {}\n+                    hir::GenericParamKind::Type { .. } => return,\n+                }\n             }\n \n             let impl_def_id = tcx.hir.local_def_id(item.id);"}, {"sha": "fc54d323b0f9600726d930b4203415067ea23548", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 66, "deletions": 76, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -99,9 +99,9 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    fn no_questions_in_bounds(&self, bounds: &TyParamBounds, where_: &str, is_trait: bool) {\n+    fn no_questions_in_bounds(&self, bounds: &GenericBounds, where_: &str, is_trait: bool) {\n         for bound in bounds {\n-            if let TraitTyParamBound(ref poly, TraitBoundModifier::Maybe) = *bound {\n+            if let GenericBound::Trait(ref poly, TraitBoundModifier::Maybe) = *bound {\n                 let mut err = self.err_handler().struct_span_err(poly.span,\n                                     &format!(\"`?Trait` is not permitted in {}\", where_));\n                 if is_trait {\n@@ -139,29 +139,22 @@ impl<'a> AstValidator<'a> {\n     }\n \n     fn check_late_bound_lifetime_defs(&self, params: &Vec<GenericParam>) {\n-        // Check: Only lifetime parameters\n-        let non_lifetime_param_spans : Vec<_> = params.iter()\n-            .filter_map(|param| match *param {\n-                GenericParam::Lifetime(_) => None,\n-                GenericParam::Type(ref t) => Some(t.ident.span),\n-            }).collect();\n-        if !non_lifetime_param_spans.is_empty() {\n-            self.err_handler().span_err(non_lifetime_param_spans,\n-                \"only lifetime parameters can be used in this context\");\n-        }\n-\n-        // Check: No bounds on lifetime parameters\n-        for param in params.iter() {\n-            match *param {\n-                GenericParam::Lifetime(ref l) => {\n-                    if !l.bounds.is_empty() {\n-                        let spans: Vec<_> = l.bounds.iter().map(|b| b.ident.span).collect();\n-                        self.err_handler().span_err(spans,\n-                            \"lifetime bounds cannot be used in this context\");\n+        // Check only lifetime parameters are present and that the lifetime\n+        // parameters that are present have no bounds.\n+        let non_lt_param_spans: Vec<_> = params.iter().filter_map(|param| match param.kind {\n+                GenericParamKind::Lifetime { .. } => {\n+                    if !param.bounds.is_empty() {\n+                        let spans: Vec<_> = param.bounds.iter().map(|b| b.span()).collect();\n+                        self.err_handler()\n+                            .span_err(spans, \"lifetime bounds cannot be used in this context\");\n                     }\n+                    None\n                 }\n-                GenericParam::Type(_) => {}\n-            }\n+                _ => Some(param.ident.span),\n+            }).collect();\n+        if !non_lt_param_spans.is_empty() {\n+            self.err_handler().span_err(non_lt_param_spans,\n+                \"only lifetime parameters can be used in this context\");\n         }\n     }\n }\n@@ -197,7 +190,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             TyKind::TraitObject(ref bounds, ..) => {\n                 let mut any_lifetime_bounds = false;\n                 for bound in bounds {\n-                    if let RegionTyParamBound(ref lifetime) = *bound {\n+                    if let GenericBound::Outlives(ref lifetime) = *bound {\n                         if any_lifetime_bounds {\n                             span_err!(self.session, lifetime.ident.span, E0226,\n                                       \"only a single explicit lifetime bound is permitted\");\n@@ -210,7 +203,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             TyKind::ImplTrait(ref bounds) => {\n                 if !bounds.iter()\n-                          .any(|b| if let TraitTyParamBound(..) = *b { true } else { false }) {\n+                          .any(|b| if let GenericBound::Trait(..) = *b { true } else { false }) {\n                     self.err_handler().span_err(ty.span, \"at least one trait must be specified\");\n                 }\n             }\n@@ -230,9 +223,9 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         // }\n         // foo!(bar::baz<T>);\n         use_tree.prefix.segments.iter().find(|segment| {\n-            segment.parameters.is_some()\n+            segment.args.is_some()\n         }).map(|segment| {\n-            self.err_handler().span_err(segment.parameters.as_ref().unwrap().span(),\n+            self.err_handler().span_err(segment.args.as_ref().unwrap().span(),\n                                         \"generic arguments in import path\");\n         });\n \n@@ -300,7 +293,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             ItemKind::Trait(is_auto, _, ref generics, ref bounds, ref trait_items) => {\n                 if is_auto == IsAuto::Yes {\n                     // Auto traits cannot have generics, super traits nor contain items.\n-                    if generics.is_parameterized() {\n+                    if !generics.params.is_empty() {\n                         struct_span_err!(self.session, item.span, E0567,\n                                         \"auto traits cannot have generic parameters\").emit();\n                     }\n@@ -335,22 +328,19 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             ItemKind::TraitAlias(Generics { ref params, .. }, ..) => {\n                 for param in params {\n-                    if let GenericParam::Type(TyParam {\n-                        ident,\n-                        ref bounds,\n-                        ref default,\n-                        ..\n-                    }) = *param\n-                    {\n-                        if !bounds.is_empty() {\n-                            self.err_handler().span_err(ident.span,\n-                                                        \"type parameters on the left side of a \\\n-                                                         trait alias cannot be bounded\");\n-                        }\n-                        if !default.is_none() {\n-                            self.err_handler().span_err(ident.span,\n-                                                        \"type parameters on the left side of a \\\n-                                                         trait alias cannot have defaults\");\n+                    match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {}\n+                        GenericParamKind::Type { ref default, .. } => {\n+                            if !param.bounds.is_empty() {\n+                                self.err_handler()\n+                                    .span_err(param.ident.span, \"type parameters on the left \\\n+                                        side of a trait alias cannot be bounded\");\n+                            }\n+                            if !default.is_none() {\n+                                self.err_handler()\n+                                    .span_err(param.ident.span, \"type parameters on the left \\\n+                                        side of a trait alias cannot have defaults\");\n+                            }\n                         }\n                     }\n                 }\n@@ -398,8 +388,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     fn visit_vis(&mut self, vis: &'a Visibility) {\n         match vis.node {\n             VisibilityKind::Restricted { ref path, .. } => {\n-                path.segments.iter().find(|segment| segment.parameters.is_some()).map(|segment| {\n-                    self.err_handler().span_err(segment.parameters.as_ref().unwrap().span(),\n+                path.segments.iter().find(|segment| segment.args.is_some()).map(|segment| {\n+                    self.err_handler().span_err(segment.args.as_ref().unwrap().span(),\n                                                 \"generic arguments in visibility path\");\n                 });\n             }\n@@ -409,41 +399,40 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         visit::walk_vis(self, vis)\n     }\n \n-    fn visit_generics(&mut self, g: &'a Generics) {\n+    fn visit_generics(&mut self, generics: &'a Generics) {\n         let mut seen_non_lifetime_param = false;\n         let mut seen_default = None;\n-        for param in &g.params {\n-            match (param, seen_non_lifetime_param) {\n-                (&GenericParam::Lifetime(ref ld), true) => {\n+        for param in &generics.params {\n+            match (&param.kind, seen_non_lifetime_param) {\n+                (GenericParamKind::Lifetime { .. }, true) => {\n                     self.err_handler()\n-                        .span_err(ld.lifetime.ident.span, \"lifetime parameters must be leading\");\n+                        .span_err(param.ident.span, \"lifetime parameters must be leading\");\n                 },\n-                (&GenericParam::Lifetime(_), false) => {}\n-                _ => {\n+                (GenericParamKind::Lifetime { .. }, false) => {}\n+                (GenericParamKind::Type { ref default, .. }, _) => {\n                     seen_non_lifetime_param = true;\n+                    if default.is_some() {\n+                        seen_default = Some(param.ident.span);\n+                    } else if let Some(span) = seen_default {\n+                        self.err_handler()\n+                            .span_err(span, \"type parameters with a default must be trailing\");\n+                        break;\n+                    }\n                 }\n             }\n-\n-            if let GenericParam::Type(ref ty_param @ TyParam { default: Some(_), .. }) = *param {\n-                seen_default = Some(ty_param.ident.span);\n-            } else if let Some(span) = seen_default {\n-                self.err_handler()\n-                    .span_err(span, \"type parameters with a default must be trailing\");\n-                break\n-            }\n         }\n-        for predicate in &g.where_clause.predicates {\n+        for predicate in &generics.where_clause.predicates {\n             if let WherePredicate::EqPredicate(ref predicate) = *predicate {\n                 self.err_handler().span_err(predicate.span, \"equality constraints are not yet \\\n                                                              supported in where clauses (#20041)\");\n             }\n         }\n-        visit::walk_generics(self, g)\n+        visit::walk_generics(self, generics)\n     }\n \n     fn visit_generic_param(&mut self, param: &'a GenericParam) {\n-        if let GenericParam::Lifetime(ref ld) = *param {\n-            self.check_lifetime(ld.lifetime.ident);\n+        if let GenericParamKind::Lifetime { .. } = param.kind {\n+            self.check_lifetime(param.ident);\n         }\n         visit::walk_generic_param(self, param);\n     }\n@@ -521,23 +510,24 @@ impl<'a> Visitor<'a> for NestedImplTraitVisitor<'a> {\n             visit::walk_ty(self, t);\n         }\n     }\n-    fn visit_path_parameters(&mut self, _: Span, path_parameters: &'a PathParameters) {\n-        match *path_parameters {\n-            PathParameters::AngleBracketed(ref params) => {\n-                for type_ in &params.types {\n-                    self.visit_ty(type_);\n-                }\n-                for type_binding in &params.bindings {\n+    fn visit_generic_args(&mut self, _: Span, generic_args: &'a GenericArgs) {\n+        match *generic_args {\n+            GenericArgs::AngleBracketed(ref data) => {\n+                data.args.iter().for_each(|arg| match arg {\n+                    GenericArg::Type(ty) => self.visit_ty(ty),\n+                    _ => {}\n+                });\n+                for type_binding in &data.bindings {\n                     // Type bindings such as `Item=impl Debug` in `Iterator<Item=Debug>`\n                     // are allowed to contain nested `impl Trait`.\n                     self.with_impl_trait(None, |this| visit::walk_ty(this, &type_binding.ty));\n                 }\n             }\n-            PathParameters::Parenthesized(ref params) => {\n-                for type_ in &params.inputs {\n+            GenericArgs::Parenthesized(ref data) => {\n+                for type_ in &data.inputs {\n                     self.visit_ty(type_);\n                 }\n-                if let Some(ref type_) = params.output {\n+                if let Some(ref type_) = data.output {\n                     // `-> Foo` syntax is essentially an associated type binding,\n                     // so it is also allowed to contain nested `impl Trait`.\n                     self.with_impl_trait(None, |this| visit::walk_ty(this, type_));\n@@ -590,7 +580,7 @@ impl<'a> Visitor<'a> for ImplTraitProjectionVisitor<'a> {\n                 //\n                 // To implement this, we disallow `impl Trait` from `qself`\n                 // (for cases like `<impl Trait>::Foo>`)\n-                // but we allow `impl Trait` in `PathParameters`\n+                // but we allow `impl Trait` in `GenericArgs`\n                 // iff there are no more PathSegments.\n                 if let Some(ref qself) = *qself {\n                     // `impl Trait` in `qself` is always illegal"}, {"sha": "e7b2869dfe61eaaea68c0f03df8350a07f7c9c5e", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -203,9 +203,9 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         hir_visit::walk_impl_item(self, ii)\n     }\n \n-    fn visit_ty_param_bound(&mut self, bounds: &'v hir::TyParamBound) {\n-        self.record(\"TyParamBound\", Id::None, bounds);\n-        hir_visit::walk_ty_param_bound(self, bounds)\n+    fn visit_param_bound(&mut self, bounds: &'v hir::GenericBound) {\n+        self.record(\"GenericBound\", Id::None, bounds);\n+        hir_visit::walk_param_bound(self, bounds)\n     }\n \n     fn visit_struct_field(&mut self, s: &'v hir::StructField) {\n@@ -322,9 +322,9 @@ impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n         ast_visit::walk_impl_item(self, ii)\n     }\n \n-    fn visit_ty_param_bound(&mut self, bounds: &'v ast::TyParamBound) {\n-        self.record(\"TyParamBound\", Id::None, bounds);\n-        ast_visit::walk_ty_param_bound(self, bounds)\n+    fn visit_param_bound(&mut self, bounds: &'v ast::GenericBound) {\n+        self.record(\"GenericBound\", Id::None, bounds);\n+        ast_visit::walk_param_bound(self, bounds)\n     }\n \n     fn visit_struct_field(&mut self, s: &'v ast::StructField) {"}, {"sha": "de087049267b1f1ed82a4db643497692355a3061", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -22,7 +22,7 @@ extern crate rustc_typeck;\n extern crate syntax_pos;\n extern crate rustc_data_structures;\n \n-use rustc::hir::{self, PatKind};\n+use rustc::hir::{self, GenericParamKind, PatKind};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefId};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n@@ -1037,9 +1037,8 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         self.access_levels.is_public(trait_id)\n     }\n \n-    fn check_ty_param_bound(&mut self,\n-                            ty_param_bound: &hir::TyParamBound) {\n-        if let hir::TraitTyParamBound(ref trait_ref, _) = *ty_param_bound {\n+    fn check_generic_bound(&mut self, bound: &hir::GenericBound) {\n+        if let hir::GenericBound::Trait(ref trait_ref, _) = *bound {\n             if self.path_is_private_type(&trait_ref.trait_ref.path) {\n                 self.old_error_set.insert(trait_ref.trait_ref.ref_id);\n             }\n@@ -1101,7 +1100,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                 }\n \n                 for bound in bounds.iter() {\n-                    self.check_ty_param_bound(bound)\n+                    self.check_generic_bound(bound)\n                 }\n             }\n \n@@ -1268,16 +1267,19 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n-        for ty_param in generics.ty_params() {\n-            for bound in ty_param.bounds.iter() {\n-                self.check_ty_param_bound(bound)\n+        generics.params.iter().for_each(|param| match param.kind {\n+            GenericParamKind::Lifetime { .. } => {}\n+            GenericParamKind::Type { .. } => {\n+                for bound in &param.bounds {\n+                    self.check_generic_bound(bound);\n+                }\n             }\n-        }\n+        });\n         for predicate in &generics.where_clause.predicates {\n             match predicate {\n                 &hir::WherePredicate::BoundPredicate(ref bound_pred) => {\n                     for bound in bound_pred.bounds.iter() {\n-                        self.check_ty_param_bound(bound)\n+                        self.check_generic_bound(bound)\n                     }\n                 }\n                 &hir::WherePredicate::RegionPredicate(_) => {}"}, {"sha": "e311701ac0589722ecc7a435d79e6ad39a49112e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 35, "deletions": 25, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -56,7 +56,7 @@ use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::visit::{self, FnKind, Visitor};\n use syntax::attr;\n use syntax::ast::{Arm, BindingMode, Block, Crate, Expr, ExprKind};\n-use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, GenericParam, Generics};\n+use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, GenericParamKind, Generics};\n use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n use syntax::ast::{Label, Local, Mutability, Pat, PatKind, Path};\n use syntax::ast::{QSelf, TraitItemKind, TraitRef, Ty, TyKind};\n@@ -797,31 +797,41 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n         // put all the parameters on the ban list and then remove\n         // them one by one as they are processed and become available.\n         let mut default_ban_rib = Rib::new(ForwardTyParamBanRibKind);\n+        let mut found_default = false;\n         default_ban_rib.bindings.extend(generics.params.iter()\n-            .filter_map(|p| if let GenericParam::Type(ref tp) = *p { Some(tp) } else { None })\n-            .skip_while(|p| p.default.is_none())\n-            .map(|p| (Ident::with_empty_ctxt(p.ident.name), Def::Err)));\n+            .filter_map(|param| match param.kind {\n+                GenericParamKind::Lifetime { .. } => None,\n+                GenericParamKind::Type { ref default, .. } => {\n+                    if found_default || default.is_some() {\n+                        found_default = true;\n+                        return Some((Ident::with_empty_ctxt(param.ident.name), Def::Err));\n+                    }\n+                    None\n+                }\n+            }));\n \n         for param in &generics.params {\n-            match *param {\n-                GenericParam::Lifetime(_) => self.visit_generic_param(param),\n-                GenericParam::Type(ref ty_param) => {\n-                    for bound in &ty_param.bounds {\n-                        self.visit_ty_param_bound(bound);\n+            match param.kind {\n+                GenericParamKind::Lifetime { .. } => self.visit_generic_param(param),\n+                GenericParamKind::Type { ref default, .. } => {\n+                    for bound in &param.bounds {\n+                        self.visit_param_bound(bound);\n                     }\n \n-                    if let Some(ref ty) = ty_param.default {\n+                    if let Some(ref ty) = default {\n                         self.ribs[TypeNS].push(default_ban_rib);\n                         self.visit_ty(ty);\n                         default_ban_rib = self.ribs[TypeNS].pop().unwrap();\n                     }\n \n                     // Allow all following defaults to refer to this type parameter.\n-                    default_ban_rib.bindings.remove(&Ident::with_empty_ctxt(ty_param.ident.name));\n+                    default_ban_rib.bindings.remove(&Ident::with_empty_ctxt(param.ident.name));\n                 }\n             }\n         }\n-        for p in &generics.where_clause.predicates { self.visit_where_predicate(p); }\n+        for p in &generics.where_clause.predicates {\n+            self.visit_where_predicate(p);\n+        }\n     }\n }\n \n@@ -2066,7 +2076,7 @@ impl<'a> Resolver<'a> {\n                     let local_def_id = this.definitions.local_def_id(item.id);\n                     this.with_self_rib(Def::SelfTy(Some(local_def_id), None), |this| {\n                         this.visit_generics(generics);\n-                        walk_list!(this, visit_ty_param_bound, bounds);\n+                        walk_list!(this, visit_param_bound, bounds);\n \n                         for trait_item in trait_items {\n                             this.check_proc_macro_attrs(&trait_item.attrs);\n@@ -2109,7 +2119,7 @@ impl<'a> Resolver<'a> {\n                     let local_def_id = this.definitions.local_def_id(item.id);\n                     this.with_self_rib(Def::SelfTy(Some(local_def_id), None), |this| {\n                         this.visit_generics(generics);\n-                        walk_list!(this, visit_ty_param_bound, bounds);\n+                        walk_list!(this, visit_param_bound, bounds);\n                     });\n                 });\n             }\n@@ -2197,28 +2207,28 @@ impl<'a> Resolver<'a> {\n             HasTypeParameters(generics, rib_kind) => {\n                 let mut function_type_rib = Rib::new(rib_kind);\n                 let mut seen_bindings = FxHashMap();\n-                for param in &generics.params {\n-                    if let GenericParam::Type(ref type_parameter) = *param {\n-                        let ident = type_parameter.ident.modern();\n-                        debug!(\"with_type_parameter_rib: {}\", type_parameter.id);\n+                generics.params.iter().for_each(|param| match param.kind {\n+                    GenericParamKind::Lifetime { .. } => {}\n+                    GenericParamKind::Type { .. } => {\n+                        let ident = param.ident.modern();\n+                        debug!(\"with_type_parameter_rib: {}\", param.id);\n \n                         if seen_bindings.contains_key(&ident) {\n                             let span = seen_bindings.get(&ident).unwrap();\n                             let err = ResolutionError::NameAlreadyUsedInTypeParameterList(\n                                 ident.name,\n                                 span,\n                             );\n-                            resolve_error(self, type_parameter.ident.span, err);\n+                            resolve_error(self, param.ident.span, err);\n                         }\n-                        seen_bindings.entry(ident).or_insert(type_parameter.ident.span);\n+                        seen_bindings.entry(ident).or_insert(param.ident.span);\n \n-                        // plain insert (no renaming)\n-                        let def_id = self.definitions.local_def_id(type_parameter.id);\n-                        let def = Def::TyParam(def_id);\n+                    // Plain insert (no renaming).\n+                    let def = Def::TyParam(self.definitions.local_def_id(param.id));\n                         function_type_rib.bindings.insert(ident, def);\n-                        self.record_def(type_parameter.id, PathResolution::new(def));\n+                        self.record_def(param.id, PathResolution::new(def));\n                     }\n-                }\n+                });\n                 self.ribs[TypeNS].push(function_type_rib);\n             }\n "}, {"sha": "649e8858b0971b4b45a25690ed4fa74be2216ce3", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -437,8 +437,8 @@ impl<'a> Resolver<'a> {\n         let def = self.resolve_macro_to_def_inner(scope, path, kind, force);\n         if def != Err(Determinacy::Undetermined) {\n             // Do not report duplicated errors on every undetermined resolution.\n-            path.segments.iter().find(|segment| segment.parameters.is_some()).map(|segment| {\n-                self.session.span_err(segment.parameters.as_ref().unwrap().span(),\n+            path.segments.iter().find(|segment| segment.args.is_some()).map(|segment| {\n+                self.session.span_err(segment.args.as_ref().unwrap().span(),\n                                       \"generic arguments in macro path\");\n             });\n         }"}, {"sha": "7da5b1668b3d824585af1c0ecdc2afd7b35291c4", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 57, "deletions": 51, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -370,35 +370,38 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         id: NodeId,\n     ) {\n         for param in &generics.params {\n-            if let ast::GenericParam::Type(ref ty_param) = *param {\n-                let param_ss = ty_param.ident.span;\n-                let name = escape(self.span.snippet(param_ss));\n-                // Append $id to name to make sure each one is unique\n-                let qualname = format!(\"{}::{}${}\", prefix, name, id);\n-                if !self.span.filter_generated(Some(param_ss), full_span) {\n-                    let id = ::id_from_node_id(ty_param.id, &self.save_ctxt);\n-                    let span = self.span_from_span(param_ss);\n+            match param.kind {\n+                ast::GenericParamKind::Lifetime { .. } => {}\n+                ast::GenericParamKind::Type { .. } => {\n+                    let param_ss = param.ident.span;\n+                    let name = escape(self.span.snippet(param_ss));\n+                    // Append $id to name to make sure each one is unique.\n+                    let qualname = format!(\"{}::{}${}\", prefix, name, id);\n+                    if !self.span.filter_generated(Some(param_ss), full_span) {\n+                        let id = ::id_from_node_id(param.id, &self.save_ctxt);\n+                        let span = self.span_from_span(param_ss);\n \n-                    self.dumper.dump_def(\n-                        &Access {\n-                            public: false,\n-                            reachable: false,\n-                        },\n-                        Def {\n-                            kind: DefKind::Type,\n-                            id,\n-                            span,\n-                            name,\n-                            qualname,\n-                            value: String::new(),\n-                            parent: None,\n-                            children: vec![],\n-                            decl_id: None,\n-                            docs: String::new(),\n-                            sig: None,\n-                            attributes: vec![],\n-                        },\n-                    );\n+                        self.dumper.dump_def(\n+                            &Access {\n+                                public: false,\n+                                reachable: false,\n+                            },\n+                            Def {\n+                                kind: DefKind::Type,\n+                                id,\n+                                span,\n+                                name,\n+                                qualname,\n+                                value: String::new(),\n+                                parent: None,\n+                                children: vec![],\n+                                decl_id: None,\n+                                docs: String::new(),\n+                                sig: None,\n+                                attributes: vec![],\n+                            },\n+                        );\n+                    }\n                 }\n             }\n         }\n@@ -715,7 +718,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         &mut self,\n         item: &'l ast::Item,\n         generics: &'l ast::Generics,\n-        trait_refs: &'l ast::TyParamBounds,\n+        trait_refs: &'l ast::GenericBounds,\n         methods: &'l [ast::TraitItem],\n     ) {\n         let name = item.ident.to_string();\n@@ -758,10 +761,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         // super-traits\n         for super_bound in trait_refs.iter() {\n             let trait_ref = match *super_bound {\n-                ast::TraitTyParamBound(ref trait_ref, _) => trait_ref,\n-                ast::RegionTyParamBound(..) => {\n-                    continue;\n-                }\n+                ast::GenericBound::Trait(ref trait_ref, _) => trait_ref,\n+                ast::GenericBound::Outlives(..) => continue,\n             };\n \n             let trait_ref = &trait_ref.trait_ref;\n@@ -818,14 +819,17 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         }\n         self.dump_path_ref(id, path);\n \n-        // Type parameters\n+        // Type arguments\n         for seg in &path.segments {\n-            if let Some(ref params) = seg.parameters {\n-                match **params {\n-                    ast::PathParameters::AngleBracketed(ref data) => for t in &data.types {\n-                        self.visit_ty(t);\n-                    },\n-                    ast::PathParameters::Parenthesized(ref data) => {\n+            if let Some(ref generic_args) = seg.args {\n+                match **generic_args {\n+                    ast::GenericArgs::AngleBracketed(ref data) => {\n+                        data.args.iter().for_each(|arg| match arg {\n+                            ast::GenericArg::Type(ty) => self.visit_ty(ty),\n+                            _ => {}\n+                        });\n+                    }\n+                    ast::GenericArgs::Parenthesized(ref data) => {\n                         for t in &data.inputs {\n                             self.visit_ty(t);\n                         }\n@@ -905,11 +909,12 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         }\n \n         // Explicit types in the turbo-fish.\n-        if let Some(ref params) = seg.parameters {\n-            if let ast::PathParameters::AngleBracketed(ref data) = **params {\n-                for t in &data.types {\n-                    self.visit_ty(t);\n-                }\n+        if let Some(ref generic_args) = seg.args {\n+            if let ast::GenericArgs::AngleBracketed(ref data) = **generic_args {\n+                data.args.iter().for_each(|arg| match arg {\n+                    ast::GenericArg::Type(ty) => self.visit_ty(ty),\n+                    _ => {}\n+                });\n             }\n         }\n \n@@ -1478,18 +1483,19 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n     }\n \n     fn visit_generics(&mut self, generics: &'l ast::Generics) {\n-        for param in &generics.params {\n-            if let ast::GenericParam::Type(ref ty_param) = *param {\n-                for bound in ty_param.bounds.iter() {\n-                    if let ast::TraitTyParamBound(ref trait_ref, _) = *bound {\n+        generics.params.iter().for_each(|param| match param.kind {\n+            ast::GenericParamKind::Lifetime { .. } => {}\n+            ast::GenericParamKind::Type { ref default, .. } => {\n+                for bound in &param.bounds {\n+                    if let ast::GenericBound::Trait(ref trait_ref, _) = *bound {\n                         self.process_path(trait_ref.trait_ref.ref_id, &trait_ref.trait_ref.path)\n                     }\n                 }\n-                if let Some(ref ty) = ty_param.default {\n+                if let Some(ref ty) = default {\n                     self.visit_ty(&ty);\n                 }\n             }\n-        }\n+        });\n     }\n \n     fn visit_ty(&mut self, t: &'l ast::Ty) {"}, {"sha": "453500d5ab7bd4d6a8cfd010d8130cdad8581d5d", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -692,8 +692,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             if path.segments.len() != 1 {\n                 return false;\n             }\n-            if let Some(ref params) = path.segments[0].parameters {\n-                if let ast::PathParameters::Parenthesized(_) = **params {\n+            if let Some(ref generic_args) = path.segments[0].args {\n+                if let ast::GenericArgs::Parenthesized(_) = **generic_args {\n                     return true;\n                 }\n             }\n@@ -934,10 +934,7 @@ fn make_signature(decl: &ast::FnDecl, generics: &ast::Generics) -> String {\n         sig.push_str(&generics\n             .params\n             .iter()\n-            .map(|param| match *param {\n-                ast::GenericParam::Lifetime(ref l) => l.lifetime.ident.name.to_string(),\n-                ast::GenericParam::Type(ref t) => t.ident.to_string(),\n-            })\n+            .map(|param| param.ident.to_string())\n             .collect::<Vec<_>>()\n             .join(\", \"));\n         sig.push_str(\"> \");"}, {"sha": "7f2f0b0c83716ea6767e24237ced1c4d8a8c517e", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 25, "deletions": 36, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -104,7 +104,7 @@ pub fn assoc_const_signature(\n pub fn assoc_type_signature(\n     id: NodeId,\n     ident: ast::Ident,\n-    bounds: Option<&ast::TyParamBounds>,\n+    bounds: Option<&ast::GenericBounds>,\n     default: Option<&ast::Ty>,\n     scx: &SaveContext,\n ) -> Option<Signature> {\n@@ -223,9 +223,9 @@ impl Sig for ast::Ty {\n                     text.push_str(\"for<\");\n                     text.push_str(&f.generic_params\n                         .iter()\n-                        .filter_map(|p| match *p {\n-                            ast::GenericParam::Lifetime(ref l) => {\n-                                Some(l.lifetime.ident.to_string())\n+                        .filter_map(|param| match param.kind {\n+                            ast::GenericParamKind::Lifetime { .. } => {\n+                                Some(param.ident.to_string())\n                             }\n                             _ => None,\n                         })\n@@ -617,45 +617,34 @@ impl Sig for ast::Generics {\n \n         let mut defs = vec![];\n         for param in &self.params {\n-            match *param {\n-                ast::GenericParam::Lifetime(ref l) => {\n-                    let mut l_text = l.lifetime.ident.to_string();\n-                    defs.push(SigElement {\n-                        id: id_from_node_id(l.lifetime.id, scx),\n-                        start: offset + text.len(),\n-                        end: offset + text.len() + l_text.len(),\n-                    });\n-\n-                    if !l.bounds.is_empty() {\n-                        l_text.push_str(\": \");\n-                        let bounds = l.bounds\n-                            .iter()\n-                            .map(|l| l.ident.to_string())\n+            let mut param_text = param.ident.to_string();\n+            defs.push(SigElement {\n+                id: id_from_node_id(param.id, scx),\n+                start: offset + text.len(),\n+                end: offset + text.len() + param_text.len(),\n+            });\n+            if !param.bounds.is_empty() {\n+                param_text.push_str(\": \");\n+                match param.kind {\n+                    ast::GenericParamKind::Lifetime { .. } => {\n+                        let bounds = param.bounds.iter()\n+                            .map(|bound| match bound {\n+                                ast::GenericBound::Outlives(lt) => lt.ident.to_string(),\n+                                _ => panic!(),\n+                            })\n                             .collect::<Vec<_>>()\n                             .join(\" + \");\n-                        l_text.push_str(&bounds);\n+                        param_text.push_str(&bounds);\n                         // FIXME add lifetime bounds refs.\n                     }\n-                    text.push_str(&l_text);\n-                    text.push(',');\n-                }\n-                ast::GenericParam::Type(ref t) => {\n-                    let mut t_text = t.ident.to_string();\n-                    defs.push(SigElement {\n-                        id: id_from_node_id(t.id, scx),\n-                        start: offset + text.len(),\n-                        end: offset + text.len() + t_text.len(),\n-                    });\n-\n-                    if !t.bounds.is_empty() {\n-                        t_text.push_str(\": \");\n-                        t_text.push_str(&pprust::bounds_to_string(&t.bounds));\n+                    ast::GenericParamKind::Type { .. } => {\n+                        param_text.push_str(&pprust::bounds_to_string(&param.bounds));\n                         // FIXME descend properly into bounds.\n                     }\n-                    text.push_str(&t_text);\n-                    text.push(',');\n                 }\n             }\n+            text.push_str(&param_text);\n+            text.push(',');\n         }\n \n         text.push('>');\n@@ -852,7 +841,7 @@ fn name_and_generics(\n fn make_assoc_type_signature(\n     id: NodeId,\n     ident: ast::Ident,\n-    bounds: Option<&ast::TyParamBounds>,\n+    bounds: Option<&ast::GenericBounds>,\n     default: Option<&ast::Ty>,\n     scx: &SaveContext,\n ) -> Result {"}, {"sha": "f3912c3042d7fceef539782e094ed0dcf2aa18d4", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 67, "deletions": 44, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -13,7 +13,7 @@\n //! is parameterized by an instance of `AstConv`.\n \n use rustc_data_structures::accumulate_vec::AccumulateVec;\n-use hir;\n+use hir::{self, GenericArg};\n use hir::def::Def;\n use hir::def_id::DefId;\n use middle::resolve_lifetime as rl;\n@@ -177,11 +177,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     {\n \n         let (substs, assoc_bindings) =\n-            item_segment.with_parameters(|parameters| {\n+            item_segment.with_generic_args(|generic_args| {\n                 self.create_substs_for_ast_path(\n                     span,\n                     def_id,\n-                    parameters,\n+                    generic_args,\n                     item_segment.infer_types,\n                     None)\n             });\n@@ -199,24 +199,34 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     fn create_substs_for_ast_path(&self,\n         span: Span,\n         def_id: DefId,\n-        parameters: &hir::PathParameters,\n+        generic_args: &hir::GenericArgs,\n         infer_types: bool,\n         self_ty: Option<Ty<'tcx>>)\n         -> (&'tcx Substs<'tcx>, Vec<ConvertedBinding<'tcx>>)\n     {\n         let tcx = self.tcx();\n \n         debug!(\"create_substs_for_ast_path(def_id={:?}, self_ty={:?}, \\\n-               parameters={:?})\",\n-               def_id, self_ty, parameters);\n+               generic_args={:?})\",\n+               def_id, self_ty, generic_args);\n \n         // If the type is parameterized by this region, then replace this\n         // region with the current anon region binding (in other words,\n         // whatever & would get replaced with).\n-        let decl_generics = tcx.generics_of(def_id);\n-        let ty_provided = parameters.types.len();\n-        let lt_provided = parameters.lifetimes.len();\n \n+        // FIXME(varkor): Separating out the parameters is messy.\n+        let lifetimes: Vec<_> = generic_args.args.iter().filter_map(|arg| match arg {\n+            GenericArg::Lifetime(lt) => Some(lt),\n+            _ => None,\n+        }).collect();\n+        let types: Vec<_> = generic_args.args.iter().filter_map(|arg| match arg {\n+            GenericArg::Type(ty) => Some(ty),\n+            _ => None,\n+        }).collect();\n+        let lt_provided = lifetimes.len();\n+        let ty_provided = types.len();\n+\n+        let decl_generics = tcx.generics_of(def_id);\n         let mut lt_accepted = 0;\n         let mut ty_params = ParamRange { required: 0, accepted: 0 };\n         for param in &decl_generics.params {\n@@ -269,8 +279,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             match param.kind {\n                 GenericParamDefKind::Lifetime => {\n                     let i = param.index as usize - own_self;\n-                    if let Some(lifetime) = parameters.lifetimes.get(i) {\n-                        self.ast_region_to_region(lifetime, Some(param)).into()\n+                    if let Some(lt) = lifetimes.get(i) {\n+                        self.ast_region_to_region(lt, Some(param)).into()\n                     } else {\n                         tcx.types.re_static.into()\n                     }\n@@ -286,7 +296,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     let i = i - (lt_accepted + own_self);\n                     if i < ty_provided {\n                         // A provided type parameter.\n-                        self.ast_ty_to_ty(&parameters.types[i]).into()\n+                        self.ast_ty_to_ty(&types[i]).into()\n                     } else if infer_types {\n                         // No type parameters were provided, we can infer all.\n                         if !default_needs_object_self(param) {\n@@ -330,7 +340,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n         });\n \n-        let assoc_bindings = parameters.bindings.iter().map(|binding| {\n+        let assoc_bindings = generic_args.bindings.iter().map(|binding| {\n             ConvertedBinding {\n                 item_name: binding.name,\n                 ty: self.ast_ty_to_ty(&binding.ty),\n@@ -355,7 +365,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         self_ty: Ty<'tcx>)\n         -> ty::TraitRef<'tcx>\n     {\n-        self.prohibit_type_params(trait_ref.path.segments.split_last().unwrap().1);\n+        self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1);\n \n         let trait_def_id = self.trait_def_id(trait_ref);\n         self.ast_path_to_mono_trait_ref(trait_ref.path.span,\n@@ -389,7 +399,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         debug!(\"ast_path_to_poly_trait_ref({:?}, def_id={:?})\", trait_ref, trait_def_id);\n \n-        self.prohibit_type_params(trait_ref.path.segments.split_last().unwrap().1);\n+        self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1);\n \n         let (substs, assoc_bindings) =\n             self.create_substs_for_ast_trait_ref(trait_ref.path.span,\n@@ -451,7 +461,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let trait_def = self.tcx().trait_def(trait_def_id);\n \n         if !self.tcx().features().unboxed_closures &&\n-           trait_segment.with_parameters(|p| p.parenthesized) != trait_def.paren_sugar {\n+            trait_segment.with_generic_args(|generic_args| generic_args.parenthesized)\n+            != trait_def.paren_sugar {\n             // For now, require that parenthetical notation be used only with `Fn()` etc.\n             let msg = if trait_def.paren_sugar {\n                 \"the precise format of `Fn`-family traits' type parameters is subject to change. \\\n@@ -463,10 +474,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                              span, GateIssue::Language, msg);\n         }\n \n-        trait_segment.with_parameters(|parameters| {\n+        trait_segment.with_generic_args(|generic_args| {\n             self.create_substs_for_ast_path(span,\n                                             trait_def_id,\n-                                            parameters,\n+                                            generic_args,\n                                             trait_segment.infer_types,\n                                             Some(self_ty))\n         })\n@@ -866,7 +877,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         debug!(\"associated_path_def_to_ty: {:?}::{}\", ty, assoc_name);\n \n-        self.prohibit_type_params(slice::from_ref(item_segment));\n+        self.prohibit_generics(slice::from_ref(item_segment));\n \n         // Find the type of the associated item, and the trait where the associated\n         // item is declared.\n@@ -943,7 +954,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let tcx = self.tcx();\n         let trait_def_id = tcx.parent_def_id(item_def_id).unwrap();\n \n-        self.prohibit_type_params(slice::from_ref(item_segment));\n+        self.prohibit_generics(slice::from_ref(item_segment));\n \n         let self_ty = if let Some(ty) = opt_self_ty {\n             ty\n@@ -968,25 +979,37 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         self.normalize_ty(span, tcx.mk_projection(item_def_id, trait_ref.substs))\n     }\n \n-    pub fn prohibit_type_params(&self, segments: &[hir::PathSegment]) {\n+    pub fn prohibit_generics(&self, segments: &[hir::PathSegment]) {\n         for segment in segments {\n-            segment.with_parameters(|parameters| {\n-                for typ in &parameters.types {\n-                    struct_span_err!(self.tcx().sess, typ.span, E0109,\n-                                     \"type parameters are not allowed on this type\")\n-                        .span_label(typ.span, \"type parameter not allowed\")\n-                        .emit();\n-                    break;\n-                }\n-                for lifetime in &parameters.lifetimes {\n-                    struct_span_err!(self.tcx().sess, lifetime.span, E0110,\n-                                     \"lifetime parameters are not allowed on this type\")\n-                        .span_label(lifetime.span,\n-                                    \"lifetime parameter not allowed on this type\")\n-                        .emit();\n-                    break;\n+            segment.with_generic_args(|generic_args| {\n+                let (mut err_for_lt, mut err_for_ty) = (false, false);\n+                for arg in &generic_args.args {\n+                    let (mut span_err, span, kind) = match arg {\n+                        hir::GenericArg::Lifetime(lt) => {\n+                            if err_for_lt { continue }\n+                            err_for_lt = true;\n+                            (struct_span_err!(self.tcx().sess, lt.span, E0110,\n+                                            \"lifetime parameters are not allowed on \\\n+                                                this type\"),\n+                             lt.span,\n+                             \"lifetime\")\n+                        }\n+                        hir::GenericArg::Type(ty) => {\n+                            if err_for_ty { continue }\n+                            err_for_ty = true;\n+                            (struct_span_err!(self.tcx().sess, ty.span, E0109,\n+                                            \"type parameters are not allowed on this type\"),\n+                             ty.span,\n+                             \"type\")\n+                        }\n+                    };\n+                    span_err.span_label(span, format!(\"{} parameter not allowed\", kind))\n+                            .emit();\n+                    if err_for_lt && err_for_ty {\n+                        break;\n+                    }\n                 }\n-                for binding in &parameters.bindings {\n+                for binding in &generic_args.bindings {\n                     self.prohibit_projection(binding.span);\n                     break;\n                 }\n@@ -1016,21 +1039,21 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) |\n             Def::Union(did) | Def::TyForeign(did) => {\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_type_params(path.segments.split_last().unwrap().1);\n+                self.prohibit_generics(path.segments.split_last().unwrap().1);\n                 self.ast_path_to_ty(span, did, path.segments.last().unwrap())\n             }\n             Def::Variant(did) if permit_variants => {\n                 // Convert \"variant type\" as if it were a real type.\n                 // The resulting `Ty` is type of the variant's enum for now.\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_type_params(path.segments.split_last().unwrap().1);\n+                self.prohibit_generics(path.segments.split_last().unwrap().1);\n                 self.ast_path_to_ty(span,\n                                     tcx.parent_def_id(did).unwrap(),\n                                     path.segments.last().unwrap())\n             }\n             Def::TyParam(did) => {\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_type_params(&path.segments);\n+                self.prohibit_generics(&path.segments);\n \n                 let node_id = tcx.hir.as_local_node_id(did).unwrap();\n                 let item_id = tcx.hir.get_parent_node(node_id);\n@@ -1043,18 +1066,18 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 // Self in impl (we know the concrete type).\n \n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_type_params(&path.segments);\n+                self.prohibit_generics(&path.segments);\n \n                 tcx.at(span).type_of(def_id)\n             }\n             Def::SelfTy(Some(_), None) => {\n                 // Self in trait.\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_type_params(&path.segments);\n+                self.prohibit_generics(&path.segments);\n                 tcx.mk_self_type()\n             }\n             Def::AssociatedTy(def_id) => {\n-                self.prohibit_type_params(&path.segments[..path.segments.len()-2]);\n+                self.prohibit_generics(&path.segments[..path.segments.len()-2]);\n                 self.qpath_to_ty(span,\n                                  opt_self_ty,\n                                  def_id,\n@@ -1063,7 +1086,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n             Def::PrimTy(prim_ty) => {\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_type_params(&path.segments);\n+                self.prohibit_generics(&path.segments);\n                 match prim_ty {\n                     hir::TyBool => tcx.types.bool,\n                     hir::TyChar => tcx.types.char,"}, {"sha": "5f8955612e10cb00614bf34c15aae479d6eab212", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::hir::{self, ImplItemKind, TraitItemKind};\n+use rustc::hir::{self, GenericParamKind, ImplItemKind, TraitItemKind};\n use rustc::infer::{self, InferOk};\n use rustc::ty::{self, TyCtxt, GenericParamDefKind};\n use rustc::ty::util::ExplicitSelf;\n@@ -728,11 +728,9 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut error_found = false;\n     let impl_m_generics = tcx.generics_of(impl_m.def_id);\n     let trait_m_generics = tcx.generics_of(trait_m.def_id);\n-    let impl_m_type_params = impl_m_generics.params.iter().filter_map(|param| {\n-        match param.kind {\n-            GenericParamDefKind::Type { synthetic, .. } => Some((param.def_id, synthetic)),\n-            GenericParamDefKind::Lifetime => None,\n-        }\n+    let impl_m_type_params = impl_m_generics.params.iter().filter_map(|param| match param.kind {\n+        GenericParamDefKind::Type { synthetic, .. } => Some((param.def_id, synthetic)),\n+        GenericParamDefKind::Lifetime => None,\n     });\n     let trait_m_type_params = trait_m_generics.params.iter().filter_map(|param| {\n         match param.kind {\n@@ -843,19 +841,19 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         }\n                         let span = visitor.0?;\n \n-                        let param = impl_m.generics.params.iter().filter_map(|param| {\n-                            match param {\n-                                hir::GenericParam::Type(param) => {\n+                        let bounds = impl_m.generics.params.iter().find_map(|param| {\n+                            match param.kind {\n+                                GenericParamKind::Lifetime { .. } => None,\n+                                GenericParamKind::Type { .. } => {\n                                     if param.id == impl_node_id {\n-                                        Some(param)\n+                                        Some(&param.bounds)\n                                     } else {\n                                         None\n                                     }\n-                                },\n-                                hir::GenericParam::Lifetime(..) => None,\n+                                }\n                             }\n-                        }).next()?;\n-                        let bounds = param.bounds.first()?.span().to(param.bounds.last()?.span());\n+                        })?;\n+                        let bounds = bounds.first()?.span().to(bounds.last()?.span());\n                         let bounds = tcx\n                             .sess\n                             .codemap()"}, {"sha": "36ce01bcd08b30cd266aa242a1c68fede31fae50", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -12,6 +12,7 @@ use super::{probe, MethodCallee};\n \n use astconv::AstConv;\n use check::{FnCtxt, PlaceOp, callee, Needs};\n+use hir::GenericArg;\n use hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n@@ -59,7 +60,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             \"confirm(unadjusted_self_ty={:?}, pick={:?}, generic_args={:?})\",\n             unadjusted_self_ty,\n             pick,\n-            segment.parameters,\n+            segment.args,\n         );\n \n         let mut confirm_cx = ConfirmContext::new(self, span, self_expr, call_expr);\n@@ -316,36 +317,44 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         let method_generics = self.tcx.generics_of(pick.item.def_id);\n         let mut fn_segment = Some((segment, method_generics));\n         let supress_mismatch = self.fcx.check_impl_trait(self.span, fn_segment);\n-        self.fcx.check_path_parameter_count(self.span, &mut fn_segment, true, supress_mismatch);\n+        self.fcx.check_generic_arg_count(self.span, &mut fn_segment, true, supress_mismatch);\n \n         // Create subst for early-bound lifetime parameters, combining\n         // parameters from the type and those from the method.\n         assert_eq!(method_generics.parent_count, parent_substs.len());\n-        let provided = &segment.parameters;\n+        let provided = &segment.args;\n         let own_counts = method_generics.own_counts();\n         Substs::for_item(self.tcx, pick.item.def_id, |param, _| {\n-            let i = param.index as usize;\n+            let mut i = param.index as usize;\n             if i < parent_substs.len() {\n                 parent_substs[i]\n             } else {\n-                match param.kind {\n-                    GenericParamDefKind::Lifetime => {\n-                        if let Some(lifetime) = provided.as_ref().and_then(|p| {\n-                            p.lifetimes.get(i - parent_substs.len())\n-                        }) {\n-                            return AstConv::ast_region_to_region(\n-                                self.fcx, lifetime, Some(param)).into();\n-                        }\n-                    }\n-                    GenericParamDefKind::Type {..} => {\n-                        if let Some(ast_ty) = provided.as_ref().and_then(|p| {\n-                            p.types.get(i - parent_substs.len() - own_counts.lifetimes)\n-                        }) {\n-                            return self.to_ty(ast_ty).into();\n+                let (is_lt, is_ty) = match param.kind {\n+                    GenericParamDefKind::Lifetime => (true, false),\n+                    GenericParamDefKind::Type { .. } => (false, true),\n+                };\n+                provided.as_ref().and_then(|data| {\n+                    for arg in &data.args {\n+                        match arg {\n+                            GenericArg::Lifetime(lt) if is_lt => {\n+                                if i == parent_substs.len() {\n+                                    return Some(AstConv::ast_region_to_region(\n+                                        self.fcx, lt, Some(param)).into());\n+                                }\n+                                i -= 1;\n+                            }\n+                            GenericArg::Lifetime(_) => {}\n+                            GenericArg::Type(ty) if is_ty => {\n+                                if i == parent_substs.len() + own_counts.lifetimes {\n+                                    return Some(self.to_ty(ty).into());\n+                                }\n+                                i -= 1;\n+                            }\n+                            GenericArg::Type(_) => {}\n                         }\n                     }\n-                }\n-                self.var_for_def(self.span, param)\n+                    None\n+                }).unwrap_or_else(|| self.var_for_def(self.span, param))\n             }\n         })\n     }"}, {"sha": "366420cfcabb15780a8f6e2e72c4a496b7f63d71", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 128, "deletions": 100, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -85,6 +85,7 @@ use self::method::MethodCallee;\n use self::TupleArgumentsFlag::*;\n \n use astconv::AstConv;\n+use hir::GenericArg;\n use hir::def::Def;\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use std::slice;\n@@ -1260,10 +1261,11 @@ pub fn check_item_type<'a,'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Item\n       hir::ItemUnion(..) => {\n         check_union(tcx, it.id, it.span);\n       }\n-      hir::ItemTy(_, ref generics) => {\n+      hir::ItemTy(..) => {\n         let def_id = tcx.hir.local_def_id(it.id);\n         let pty_ty = tcx.type_of(def_id);\n-        check_bounds_are_used(tcx, generics, pty_ty);\n+        let generics = tcx.generics_of(def_id);\n+        check_bounds_are_used(tcx, &generics, pty_ty);\n       }\n       hir::ItemForeignMod(ref m) => {\n         check_abi(tcx, it.span, m.abi);\n@@ -4740,8 +4742,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Def::Fn(def_id) |\n             Def::Const(def_id) |\n             Def::Static(def_id, _) => {\n-                fn_segment = Some((segments.last().unwrap(),\n-                                   self.tcx.generics_of(def_id)));\n+                fn_segment = Some((segments.last().unwrap(), self.tcx.generics_of(def_id)));\n             }\n \n             // Case 3. Reference to a method or associated const.\n@@ -4781,7 +4782,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // errors if type parameters are provided in an inappropriate place.\n         let poly_segments = type_segment.is_some() as usize +\n                             fn_segment.is_some() as usize;\n-        AstConv::prohibit_type_params(self, &segments[..segments.len() - poly_segments]);\n+        AstConv::prohibit_generics(self, &segments[..segments.len() - poly_segments]);\n \n         match def {\n             Def::Local(nid) | Def::Upvar(nid, ..) => {\n@@ -4800,8 +4801,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // to add defaults. If the user provided *too many* types, that's\n         // a problem.\n         let supress_mismatch = self.check_impl_trait(span, fn_segment);\n-        self.check_path_parameter_count(span, &mut type_segment, false, supress_mismatch);\n-        self.check_path_parameter_count(span, &mut fn_segment, false, supress_mismatch);\n+        self.check_generic_arg_count(span, &mut type_segment, false, supress_mismatch);\n+        self.check_generic_arg_count(span, &mut fn_segment, false, supress_mismatch);\n \n         let (fn_start, has_self) = match (type_segment, fn_segment) {\n             (_, Some((_, generics))) => {\n@@ -4812,11 +4813,42 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n             (None, None) => (0, false)\n         };\n+        // FIXME(varkor): Separating out the parameters is messy.\n+        let mut lifetimes_type_seg = vec![];\n+        let mut types_type_seg = vec![];\n+        let mut infer_types_type_seg = true;\n+        if let Some((seg, _)) = type_segment {\n+            if let Some(ref data) = seg.args {\n+                for arg in &data.args {\n+                    match arg {\n+                        GenericArg::Lifetime(lt) => lifetimes_type_seg.push(lt),\n+                        GenericArg::Type(ty) => types_type_seg.push(ty),\n+                    }\n+                }\n+            }\n+            infer_types_type_seg = seg.infer_types;\n+        }\n+\n+        let mut lifetimes_fn_seg = vec![];\n+        let mut types_fn_seg = vec![];\n+        let mut infer_types_fn_seg = true;\n+        if let Some((seg, _)) = fn_segment {\n+            if let Some(ref data) = seg.args {\n+                for arg in &data.args {\n+                    match arg {\n+                        GenericArg::Lifetime(lt) => lifetimes_fn_seg.push(lt),\n+                        GenericArg::Type(ty) => types_fn_seg.push(ty),\n+                    }\n+                }\n+            }\n+            infer_types_fn_seg = seg.infer_types;\n+        }\n+\n         let substs = Substs::for_item(self.tcx, def.def_id(), |param, substs| {\n             let mut i = param.index as usize;\n \n-            let segment = if i < fn_start {\n-                if let GenericParamDefKind::Type {..} = param.kind {\n+            let (segment, lifetimes, types, infer_types) = if i < fn_start {\n+                if let GenericParamDefKind::Type { .. } = param.kind {\n                     // Handle Self first, so we can adjust the index to match the AST.\n                     if has_self && i == 0 {\n                         return opt_self_ty.map(|ty| ty.into()).unwrap_or_else(|| {\n@@ -4825,29 +4857,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n                 i -= has_self as usize;\n-                type_segment\n+                (type_segment, &lifetimes_type_seg, &types_type_seg, infer_types_type_seg)\n             } else {\n                 i -= fn_start;\n-                fn_segment\n+                (fn_segment, &lifetimes_fn_seg, &types_fn_seg, infer_types_fn_seg)\n             };\n \n             match param.kind {\n                 GenericParamDefKind::Lifetime => {\n-                    let lifetimes = segment.map_or(&[][..], |(s, _)| {\n-                        s.parameters.as_ref().map_or(&[][..], |p| &p.lifetimes[..])\n-                    });\n-\n                     if let Some(lifetime) = lifetimes.get(i) {\n                         AstConv::ast_region_to_region(self, lifetime, Some(param)).into()\n                     } else {\n                         self.re_infer(span, Some(param)).unwrap().into()\n                     }\n                 }\n-                GenericParamDefKind::Type {..} => {\n-                    let (types, infer_types) = segment.map_or((&[][..], true), |(s, _)| {\n-                        (s.parameters.as_ref().map_or(&[][..], |p| &p.types[..]), s.infer_types)\n-                    });\n-\n+                GenericParamDefKind::Type { .. } => {\n                     // Skip over the lifetimes in the same segment.\n                     if let Some((_, generics)) = segment {\n                         i -= generics.own_counts().lifetimes;\n@@ -4955,25 +4979,26 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Report errors if the provided parameters are too few or too many.\n-    fn check_path_parameter_count(&self,\n-                                  span: Span,\n-                                  segment: &mut Option<(&hir::PathSegment, &ty::Generics)>,\n-                                  is_method_call: bool,\n-                                  supress_mismatch_error: bool) {\n+    fn check_generic_arg_count(&self,\n+                               span: Span,\n+                               segment: &mut Option<(&hir::PathSegment, &ty::Generics)>,\n+                               is_method_call: bool,\n+                               supress_mismatch_error: bool) {\n         let (lifetimes, types, infer_types, bindings) = segment.map_or(\n-            (&[][..], &[][..], true, &[][..]),\n-            |(s, _)| s.parameters.as_ref().map_or(\n-                (&[][..], &[][..], s.infer_types, &[][..]),\n-                |p| (&p.lifetimes[..], &p.types[..],\n-                     s.infer_types, &p.bindings[..])));\n-        let infer_lifetimes = lifetimes.len() == 0;\n-\n-        let count_lifetime_params = |n| {\n-            format!(\"{} lifetime parameter{}\", n, if n == 1 { \"\" } else { \"s\" })\n-        };\n-        let count_type_params = |n| {\n-            format!(\"{} type parameter{}\", n, if n == 1 { \"\" } else { \"s\" })\n-        };\n+            (vec![], vec![], true, &[][..]),\n+            |(s, _)| {\n+                s.args.as_ref().map_or(\n+                    (vec![], vec![], s.infer_types, &[][..]),\n+                    |data| {\n+                        let (mut lifetimes, mut types) = (vec![], vec![]);\n+                        data.args.iter().for_each(|arg| match arg {\n+                            GenericArg::Lifetime(lt) => lifetimes.push(lt),\n+                            GenericArg::Type(ty) => types.push(ty),\n+                        });\n+                        (lifetimes, types, s.infer_types, &data.bindings[..])\n+                    }\n+                )\n+            });\n \n         // Check provided parameters.\n         let ((ty_required, ty_accepted), lt_accepted) =\n@@ -4987,9 +5012,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let mut ty_params = ParamRange { required: 0, accepted: 0 };\n                 for param in &generics.params {\n                     match param.kind {\n-                        GenericParamDefKind::Lifetime => {\n-                            lt_accepted += 1;\n-                        }\n+                        GenericParamDefKind::Lifetime => lt_accepted += 1,\n                         GenericParamDefKind::Type { has_default, .. } => {\n                             ty_params.accepted += 1;\n                             if !has_default {\n@@ -5006,36 +5029,37 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 ((ty_params.required, ty_params.accepted), lt_accepted)\n             });\n \n-        if types.len() > ty_accepted {\n-            let span = types[ty_accepted].span;\n-            let expected_text = count_type_params(ty_accepted);\n-            let actual_text = count_type_params(types.len());\n-            struct_span_err!(self.tcx.sess, span, E0087,\n-                             \"too many type parameters provided: \\\n-                              expected at most {}, found {}\",\n-                             expected_text, actual_text)\n-                .span_label(span, format!(\"expected {}\", expected_text))\n-                .emit();\n-\n+        let count_type_params = |n| {\n+            format!(\"{} type parameter{}\", n, if n == 1 { \"\" } else { \"s\" })\n+        };\n+        let expected_text = count_type_params(ty_accepted);\n+        let actual_text = count_type_params(types.len());\n+        if let Some((mut err, span)) = if types.len() > ty_accepted {\n             // To prevent derived errors to accumulate due to extra\n             // type parameters, we force instantiate_value_path to\n             // use inference variables instead of the provided types.\n             *segment = None;\n+            let span = types[ty_accepted].span;\n+            Some((struct_span_err!(self.tcx.sess, span, E0087,\n+                                  \"too many type parameters provided: \\\n+                                  expected at most {}, found {}\",\n+                                  expected_text, actual_text), span))\n         } else if types.len() < ty_required && !infer_types && !supress_mismatch_error {\n-            let expected_text = count_type_params(ty_required);\n-            let actual_text = count_type_params(types.len());\n-            struct_span_err!(self.tcx.sess, span, E0089,\n-                             \"too few type parameters provided: \\\n-                              expected {}, found {}\",\n-                             expected_text, actual_text)\n-                .span_label(span, format!(\"expected {}\", expected_text))\n-                .emit();\n+            Some((struct_span_err!(self.tcx.sess, span, E0089,\n+                                  \"too few type parameters provided: \\\n+                                  expected {}, found {}\",\n+                                  expected_text, actual_text), span))\n+        } else {\n+            None\n+        } {\n+            err.span_label(span, format!(\"expected {}\", expected_text)).emit();\n         }\n \n         if !bindings.is_empty() {\n             AstConv::prohibit_projection(self, bindings[0].span);\n         }\n \n+        let infer_lifetimes = lifetimes.len() == 0;\n         // Prohibit explicit lifetime arguments if late bound lifetime parameters are present.\n         let has_late_bound_lifetime_defs =\n             segment.map_or(None, |(_, generics)| generics.has_late_bound_regions);\n@@ -5059,25 +5083,26 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return;\n         }\n \n-        if lifetimes.len() > lt_accepted {\n+        let count_lifetime_params = |n| {\n+            format!(\"{} lifetime parameter{}\", n, if n == 1 { \"\" } else { \"s\" })\n+        };\n+        let expected_text = count_lifetime_params(lt_accepted);\n+        let actual_text = count_lifetime_params(lifetimes.len());\n+        if let Some((mut err, span)) = if lifetimes.len() > lt_accepted {\n             let span = lifetimes[lt_accepted].span;\n-            let expected_text = count_lifetime_params(lt_accepted);\n-            let actual_text = count_lifetime_params(lifetimes.len());\n-            struct_span_err!(self.tcx.sess, span, E0088,\n-                             \"too many lifetime parameters provided: \\\n-                              expected at most {}, found {}\",\n-                             expected_text, actual_text)\n-                .span_label(span, format!(\"expected {}\", expected_text))\n-                .emit();\n+            Some((struct_span_err!(self.tcx.sess, span, E0088,\n+                                  \"too many lifetime parameters provided: \\\n+                                  expected at most {}, found {}\",\n+                                  expected_text, actual_text), span))\n         } else if lifetimes.len() < lt_accepted && !infer_lifetimes {\n-            let expected_text = count_lifetime_params(lt_accepted);\n-            let actual_text = count_lifetime_params(lifetimes.len());\n-            struct_span_err!(self.tcx.sess, span, E0090,\n-                             \"too few lifetime parameters provided: \\\n-                              expected {}, found {}\",\n-                             expected_text, actual_text)\n-                .span_label(span, format!(\"expected {}\", expected_text))\n-                .emit();\n+            Some((struct_span_err!(self.tcx.sess, span, E0090,\n+                                  \"too few lifetime parameters provided: \\\n+                                  expected {}, found {}\",\n+                                  expected_text, actual_text), span))\n+        } else {\n+            None\n+        } {\n+            err.span_label(span, format!(\"expected {}\", expected_text)).emit();\n         }\n     }\n \n@@ -5088,13 +5113,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         -> bool {\n         let segment = segment.map(|(path_segment, generics)| {\n             let explicit = !path_segment.infer_types;\n-            let impl_trait = generics.params.iter().any(|param| {\n-                match param.kind {\n-                    ty::GenericParamDefKind::Type {\n-                        synthetic: Some(hir::SyntheticTyParamKind::ImplTrait), ..\n-                    } => true,\n-                    _ => false,\n-                }\n+            let impl_trait = generics.params.iter().any(|param| match param.kind {\n+                ty::GenericParamDefKind::Type {\n+                    synthetic: Some(hir::SyntheticTyParamKind::ImplTrait), ..\n+                } => true,\n+                _ => false,\n             });\n \n             if explicit && impl_trait {\n@@ -5155,34 +5178,39 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n }\n \n pub fn check_bounds_are_used<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       generics: &hir::Generics,\n+                                       generics: &ty::Generics,\n                                        ty: Ty<'tcx>) {\n-    debug!(\"check_bounds_are_used(n_tps={}, ty={:?})\",\n-           generics.ty_params().count(),  ty);\n-\n-    // make a vector of booleans initially false, set to true when used\n-    if generics.ty_params().next().is_none() { return; }\n-    let mut tps_used = vec![false; generics.ty_params().count()];\n+    let own_counts = generics.own_counts();\n+    debug!(\"check_bounds_are_used(n_tps={}, ty={:?})\", own_counts.types, ty);\n \n-    let lifetime_count = generics.lifetimes().count();\n+    if own_counts.types == 0 {\n+        return;\n+    }\n+    // Make a vector of booleans initially false, set to true when used.\n+    let mut types_used = vec![false; own_counts.types];\n \n     for leaf_ty in ty.walk() {\n-        if let ty::TyParam(ty::ParamTy {idx, ..}) = leaf_ty.sty {\n+        if let ty::TyParam(ty::ParamTy { idx, .. }) = leaf_ty.sty {\n             debug!(\"Found use of ty param num {}\", idx);\n-            tps_used[idx as usize - lifetime_count] = true;\n+            types_used[idx as usize - own_counts.lifetimes] = true;\n         } else if let ty::TyError = leaf_ty.sty {\n-            // If there already another error, do not emit an error for not using a type Parameter\n+            // If there is already another error, do not emit\n+            // an error for not using a type Parameter.\n             assert!(tcx.sess.err_count() > 0);\n             return;\n         }\n     }\n \n-    for (&used, param) in tps_used.iter().zip(generics.ty_params()) {\n+    let types = generics.params.iter().filter(|param| match param.kind {\n+        ty::GenericParamDefKind::Type { .. } => true,\n+        _ => false,\n+    });\n+    for (&used, param) in types_used.iter().zip(types) {\n         if !used {\n-            struct_span_err!(tcx.sess, param.span, E0091,\n-                \"type parameter `{}` is unused\",\n-                param.name)\n-                .span_label(param.span, \"unused type parameter\")\n+            let id = tcx.hir.as_local_node_id(param.def_id).unwrap();\n+            let span = tcx.hir.span(id);\n+            struct_span_err!(tcx.sess, span, E0091, \"type parameter `{}` is unused\", param.name)\n+                .span_label(span, \"unused type parameter\")\n                 .emit();\n         }\n     }"}, {"sha": "b61f09cbaea6d22b2789f476416768f0f039dd7a", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -602,8 +602,8 @@ fn check_method_receiver<'fcx, 'gcx, 'tcx>(fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n }\n \n fn check_variances_for_type_defn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                    item: &hir::Item,\n-                                    ast_generics: &hir::Generics)\n+                                           item: &hir::Item,\n+                                           hir_generics: &hir::Generics)\n {\n     let item_def_id = tcx.hir.local_def_id(item.id);\n     let ty = tcx.type_of(item_def_id);\n@@ -631,11 +631,8 @@ fn check_variances_for_type_defn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             continue;\n         }\n \n-        let (span, name) = match ast_generics.params[index] {\n-            hir::GenericParam::Lifetime(ref ld) => (ld.lifetime.span, ld.lifetime.name.name()),\n-            hir::GenericParam::Type(ref tp) => (tp.span, tp.name),\n-        };\n-        report_bivariance(tcx, span, name);\n+        let param = &hir_generics.params[index];\n+        report_bivariance(tcx, param.span, param.name.name());\n     }\n }\n \n@@ -663,17 +660,12 @@ fn report_bivariance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn reject_shadowing_parameters(tcx: TyCtxt, def_id: DefId) {\n     let generics = tcx.generics_of(def_id);\n     let parent = tcx.generics_of(generics.parent.unwrap());\n-    let impl_params: FxHashMap<_, _> =\n-        parent.params.iter()\n-                     .flat_map(|param| {\n-                         match param.kind {\n-                             GenericParamDefKind::Lifetime => None,\n-                             GenericParamDefKind::Type {..} => Some((param.name, param.def_id)),\n-                         }\n-                     })\n-                     .collect();\n-\n-    for method_param in generics.params.iter() {\n+    let impl_params: FxHashMap<_, _> = parent.params.iter().flat_map(|param| match param.kind {\n+        GenericParamDefKind::Lifetime => None,\n+        GenericParamDefKind::Type {..} => Some((param.name, param.def_id)),\n+    }).collect();\n+\n+    for method_param in &generics.params {\n         match method_param.kind {\n             // Shadowing is checked in resolve_lifetime.\n             GenericParamDefKind::Lifetime => continue,"}, {"sha": "5a442881a631582a539d625c0141ada151845590", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -35,7 +35,9 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n \n             Some(trait_ref) => {\n                 let trait_def = self.tcx.trait_def(trait_ref.def_id);\n-                let unsafe_attr = impl_generics.and_then(|g| g.carries_unsafe_attr());\n+                let unsafe_attr = impl_generics.and_then(|generics| {\n+                    generics.params.iter().find(|p| p.pure_wrt_drop).map(|_| \"may_dangle\")\n+                });\n                 match (trait_def.unsafety, unsafe_attr, unsafety, polarity) {\n                     (Unsafety::Normal, None, Unsafety::Unsafe, hir::ImplPolarity::Positive) => {\n                         span_err!(self.tcx.sess,\n@@ -53,13 +55,14 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n                                   trait_ref);\n                     }\n \n-                    (Unsafety::Normal, Some(g), Unsafety::Normal, hir::ImplPolarity::Positive) =>\n+                    (Unsafety::Normal, Some(attr_name), Unsafety::Normal,\n+                        hir::ImplPolarity::Positive) =>\n                     {\n                         span_err!(self.tcx.sess,\n                                   item.span,\n                                   E0569,\n                                   \"requires an `unsafe impl` declaration due to `#[{}]` attribute\",\n-                                  g.attr_name());\n+                                  attr_name);\n                     }\n \n                     (_, _, Unsafety::Unsafe, hir::ImplPolarity::Negative) => {"}, {"sha": "7a4fbc73c2e7dc554571d0b8affeb4cb2106bc51", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 121, "deletions": 88, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -49,6 +49,7 @@ use syntax::feature_gate;\n use syntax_pos::{Span, DUMMY_SP};\n \n use rustc::hir::{self, map as hir_map, CodegenFnAttrs, CodegenFnAttrFlags, Unsafety};\n+use rustc::hir::GenericParamKind;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n@@ -113,10 +114,14 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n-        for param in generics.ty_params() {\n-            if param.default.is_some() {\n-                let def_id = self.tcx.hir.local_def_id(param.id);\n-                self.tcx.type_of(def_id);\n+        for param in &generics.params {\n+            match param.kind {\n+                hir::GenericParamKind::Lifetime { .. } => {}\n+                hir::GenericParamKind::Type { default: Some(_), .. } => {\n+                    let def_id = self.tcx.hir.local_def_id(param.id);\n+                    self.tcx.type_of(def_id);\n+                }\n+                hir::GenericParamKind::Type { .. } => {}\n             }\n         }\n         intravisit::walk_generics(self, generics);\n@@ -308,9 +313,12 @@ impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n                                          -> Vec<ty::Predicate<'tcx>>\n     {\n         let from_ty_params =\n-            ast_generics.ty_params()\n-                .filter(|p| p.id == param_id)\n-                .flat_map(|p| p.bounds.iter())\n+            ast_generics.params.iter()\n+                .filter_map(|param| match param.kind {\n+                    GenericParamKind::Type { .. } if param.id == param_id => Some(&param.bounds),\n+                    _ => None\n+                })\n+                .flat_map(|bounds| bounds.iter())\n                 .flat_map(|b| predicates_from_bound(self, ty, b));\n \n         let from_where_clauses =\n@@ -739,10 +747,15 @@ fn has_late_bound_regions<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             outer_index: ty::INNERMOST,\n             has_late_bound_regions: None,\n         };\n-        for lifetime in generics.lifetimes() {\n-            let hir_id = tcx.hir.node_to_hir_id(lifetime.lifetime.id);\n-            if tcx.is_late_bound(hir_id) {\n-                return Some(lifetime.lifetime.span);\n+        for param in &generics.params {\n+            match param.kind {\n+                GenericParamKind::Lifetime { .. } => {\n+                    let hir_id = tcx.hir.node_to_hir_id(param.id);\n+                    if tcx.is_late_bound(hir_id) {\n+                        return Some(param.span);\n+                    }\n+                }\n+                _ => {},\n             }\n         }\n         visitor.visit_fn_decl(decl);\n@@ -883,12 +896,12 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut params: Vec<_> = opt_self.into_iter().collect();\n \n     let early_lifetimes = early_bound_lifetimes_from_generics(tcx, ast_generics);\n-    params.extend(early_lifetimes.enumerate().map(|(i, l)| {\n+    params.extend(early_lifetimes.enumerate().map(|(i, param)| {\n         ty::GenericParamDef {\n-            name: l.lifetime.name.name().as_interned_str(),\n+            name: param.name.name().as_interned_str(),\n             index: own_start + i as u32,\n-            def_id: tcx.hir.local_def_id(l.lifetime.id),\n-            pure_wrt_drop: l.pure_wrt_drop,\n+            def_id: tcx.hir.local_def_id(param.id),\n+            pure_wrt_drop: param.pure_wrt_drop,\n             kind: ty::GenericParamDefKind::Lifetime,\n         }\n     }));\n@@ -898,34 +911,40 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Now create the real type parameters.\n     let type_start = own_start - has_self as u32 + params.len() as u32;\n-    params.extend(ast_generics.ty_params().enumerate().map(|(i, p)| {\n-        if p.name == keywords::SelfType.name() {\n-            span_bug!(p.span, \"`Self` should not be the name of a regular parameter\");\n-        }\n-\n-        if !allow_defaults && p.default.is_some() {\n-            if !tcx.features().default_type_parameter_fallback {\n-                tcx.lint_node(\n-                    lint::builtin::INVALID_TYPE_PARAM_DEFAULT,\n-                    p.id,\n-                    p.span,\n-                    &format!(\"defaults for type parameters are only allowed in `struct`, \\\n-                              `enum`, `type`, or `trait` definitions.\"));\n+    let mut i = 0;\n+    params.extend(ast_generics.params.iter().filter_map(|param| match param.kind {\n+        GenericParamKind::Type { ref default, synthetic, .. } => {\n+            if param.name.name() == keywords::SelfType.name() {\n+                span_bug!(param.span,  \"`Self` should not be the name of a regular parameter\");\n             }\n-        }\n \n-        ty::GenericParamDef {\n-            index: type_start + i as u32,\n-            name: p.name.as_interned_str(),\n-            def_id: tcx.hir.local_def_id(p.id),\n-            pure_wrt_drop: p.pure_wrt_drop,\n-            kind: ty::GenericParamDefKind::Type {\n-                has_default: p.default.is_some(),\n-                object_lifetime_default:\n-                    object_lifetime_defaults.as_ref().map_or(rl::Set1::Empty, |o| o[i]),\n-                synthetic: p.synthetic,\n-            },\n+            if !allow_defaults && default.is_some() {\n+                if !tcx.features().default_type_parameter_fallback {\n+                    tcx.lint_node(\n+                        lint::builtin::INVALID_TYPE_PARAM_DEFAULT,\n+                        param.id,\n+                        param.span,\n+                        &format!(\"defaults for type parameters are only allowed in \\\n+                                    `struct`, `enum`, `type`, or `trait` definitions.\"));\n+                }\n+            }\n+\n+            let ty_param = ty::GenericParamDef {\n+                index: type_start + i as u32,\n+                name: param.name.name().as_interned_str(),\n+                def_id: tcx.hir.local_def_id(param.id),\n+                pure_wrt_drop: param.pure_wrt_drop,\n+                kind: ty::GenericParamDefKind::Type {\n+                    has_default: default.is_some(),\n+                    object_lifetime_default:\n+                        object_lifetime_defaults.as_ref().map_or(rl::Set1::Empty, |o| o[i]),\n+                    synthetic,\n+                },\n+            };\n+            i += 1;\n+            Some(ty_param)\n         }\n+        _ => None,\n     }));\n \n     // provide junk type parameter defs - the only place that\n@@ -1119,8 +1138,13 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n         },\n \n-        NodeTyParam(&hir::TyParam { default: Some(ref ty), .. }) => {\n-            icx.to_ty(ty)\n+        NodeGenericParam(param) => {\n+            match param.kind {\n+                hir::GenericParamKind::Type { default: Some(ref ty), .. } => {\n+                    icx.to_ty(ty)\n+                }\n+                _ => bug!(\"unexpected non-type NodeGenericParam\"),\n+            }\n         }\n \n         x => {\n@@ -1225,15 +1249,15 @@ fn impl_polarity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n // Is it marked with ?Sized\n fn is_unsized<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n-                                ast_bounds: &[hir::TyParamBound],\n+                                ast_bounds: &[hir::GenericBound],\n                                 span: Span) -> bool\n {\n     let tcx = astconv.tcx();\n \n     // Try to find an unbound in bounds.\n     let mut unbound = None;\n     for ab in ast_bounds {\n-        if let &hir::TraitTyParamBound(ref ptr, hir::TraitBoundModifier::Maybe) = ab  {\n+        if let &hir::GenericBound::Trait(ref ptr, hir::TraitBoundModifier::Maybe) = ab  {\n             if unbound.is_none() {\n                 unbound = Some(ptr.trait_ref.clone());\n             } else {\n@@ -1274,15 +1298,16 @@ fn is_unsized<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n /// `resolve_lifetime::early_bound_lifetimes`.\n fn early_bound_lifetimes_from_generics<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    ast_generics: &'a hir::Generics)\n-    -> impl Iterator<Item=&'a hir::LifetimeDef> + Captures<'tcx>\n+    generics: &'a hir::Generics)\n+    -> impl Iterator<Item=&'a hir::GenericParam> + Captures<'tcx>\n {\n-    ast_generics\n-        .lifetimes()\n-        .filter(move |l| {\n-            let hir_id = tcx.hir.node_to_hir_id(l.lifetime.id);\n+    generics.params.iter().filter(move |param| match param.kind {\n+        GenericParamKind::Lifetime { .. } => {\n+            let hir_id = tcx.hir.node_to_hir_id(param.id);\n             !tcx.is_late_bound(hir_id)\n-        })\n+        }\n+        _ => false,\n+    })\n }\n \n fn predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -1410,31 +1435,42 @@ pub fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut index = parent_count + has_own_self as u32;\n     for param in early_bound_lifetimes_from_generics(tcx, ast_generics) {\n         let region = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n-            def_id: tcx.hir.local_def_id(param.lifetime.id),\n+            def_id: tcx.hir.local_def_id(param.id),\n             index,\n-            name: param.lifetime.name.name().as_interned_str(),\n+            name: param.name.name().as_interned_str(),\n         }));\n         index += 1;\n \n-        for bound in &param.bounds {\n-            let bound_region = AstConv::ast_region_to_region(&icx, bound, None);\n-            let outlives = ty::Binder::bind(ty::OutlivesPredicate(region, bound_region));\n-            predicates.push(outlives.to_predicate());\n+        match param.kind {\n+            GenericParamKind::Lifetime { .. } => {\n+                param.bounds.iter().for_each(|bound| match bound {\n+                    hir::GenericBound::Outlives(lt) => {\n+                        let bound = AstConv::ast_region_to_region(&icx, &lt, None);\n+                        let outlives = ty::Binder::bind(ty::OutlivesPredicate(region, bound));\n+                        predicates.push(outlives.to_predicate());\n+                    }\n+                    _ => bug!(),\n+                });\n+            },\n+            _ => bug!(),\n         }\n     }\n \n     // Collect the predicates that were written inline by the user on each\n     // type parameter (e.g., `<T:Foo>`).\n-    for param in ast_generics.ty_params() {\n-        let param_ty = ty::ParamTy::new(index, param.name.as_interned_str()).to_ty(tcx);\n-        index += 1;\n-\n-        let bounds = compute_bounds(&icx,\n-                                    param_ty,\n-                                    &param.bounds,\n-                                    SizedByDefault::Yes,\n-                                    param.span);\n-        predicates.extend(bounds.predicates(tcx, param_ty));\n+    for param in &ast_generics.params {\n+        match param.kind {\n+            GenericParamKind::Type { .. } => {\n+                let name = param.name.name().as_interned_str();\n+                let param_ty = ty::ParamTy::new(index, name).to_ty(tcx);\n+                index += 1;\n+\n+                let sized = SizedByDefault::Yes;\n+                let bounds = compute_bounds(&icx, param_ty, &param.bounds, sized, param.span);\n+                predicates.extend(bounds.predicates(tcx, param_ty));\n+            }\n+            _ => {}\n+        }\n     }\n \n     // Add in the bounds that appear in the where-clause\n@@ -1446,7 +1482,7 @@ pub fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n                 for bound in bound_pred.bounds.iter() {\n                     match bound {\n-                        &hir::TyParamBound::TraitTyParamBound(ref poly_trait_ref, _) => {\n+                        &hir::GenericBound::Trait(ref poly_trait_ref, _) => {\n                             let mut projections = Vec::new();\n \n                             let trait_ref =\n@@ -1462,7 +1498,7 @@ pub fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             }\n                         }\n \n-                        &hir::TyParamBound::RegionTyParamBound(ref lifetime) => {\n+                        &hir::GenericBound::Outlives(ref lifetime) => {\n                             let region = AstConv::ast_region_to_region(&icx,\n                                                                        lifetime,\n                                                                        None);\n@@ -1476,7 +1512,12 @@ pub fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             &hir::WherePredicate::RegionPredicate(ref region_pred) => {\n                 let r1 = AstConv::ast_region_to_region(&icx, &region_pred.lifetime, None);\n                 for bound in &region_pred.bounds {\n-                    let r2 = AstConv::ast_region_to_region(&icx, bound, None);\n+                    let r2 = match bound {\n+                        hir::GenericBound::Outlives(lt) => {\n+                            AstConv::ast_region_to_region(&icx, lt, None)\n+                        }\n+                        _ => bug!(),\n+                    };\n                     let pred = ty::Binder::bind(ty::OutlivesPredicate(r1, r2));\n                     predicates.push(ty::Predicate::RegionOutlives(pred))\n                 }\n@@ -1541,7 +1582,7 @@ pub enum SizedByDefault { Yes, No, }\n /// built-in trait (formerly known as kind): Send.\n pub fn compute_bounds<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n                                         param_ty: Ty<'tcx>,\n-                                        ast_bounds: &[hir::TyParamBound],\n+                                        ast_bounds: &[hir::GenericBound],\n                                         sized_by_default: SizedByDefault,\n                                         span: Span)\n                                         -> Bounds<'tcx>\n@@ -1550,22 +1591,16 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n     let mut trait_bounds = vec![];\n     for ast_bound in ast_bounds {\n         match *ast_bound {\n-            hir::TraitTyParamBound(ref b, hir::TraitBoundModifier::None) => {\n-                trait_bounds.push(b);\n-            }\n-            hir::TraitTyParamBound(_, hir::TraitBoundModifier::Maybe) => {}\n-            hir::RegionTyParamBound(ref l) => {\n-                region_bounds.push(l);\n-            }\n+            hir::GenericBound::Trait(ref b, hir::TraitBoundModifier::None) => trait_bounds.push(b),\n+            hir::GenericBound::Trait(_, hir::TraitBoundModifier::Maybe) => {}\n+            hir::GenericBound::Outlives(ref l) => region_bounds.push(l),\n         }\n     }\n \n     let mut projection_bounds = vec![];\n \n     let mut trait_bounds: Vec<_> = trait_bounds.iter().map(|&bound| {\n-        astconv.instantiate_poly_trait_ref(bound,\n-                                           param_ty,\n-                                           &mut projection_bounds)\n+        astconv.instantiate_poly_trait_ref(bound, param_ty, &mut projection_bounds)\n     }).collect();\n \n     let region_bounds = region_bounds.into_iter().map(|r| {\n@@ -1588,18 +1623,18 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n     }\n }\n \n-/// Converts a specific TyParamBound from the AST into a set of\n+/// Converts a specific GenericBound from the AST into a set of\n /// predicates that apply to the self-type. A vector is returned\n /// because this can be anywhere from 0 predicates (`T:?Sized` adds no\n /// predicates) to 1 (`T:Foo`) to many (`T:Bar<X=i32>` adds `T:Bar`\n /// and `<T as Bar>::X == i32`).\n fn predicates_from_bound<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n                                param_ty: Ty<'tcx>,\n-                               bound: &hir::TyParamBound)\n+                               bound: &hir::GenericBound)\n                                -> Vec<ty::Predicate<'tcx>>\n {\n     match *bound {\n-        hir::TraitTyParamBound(ref tr, hir::TraitBoundModifier::None) => {\n+        hir::GenericBound::Trait(ref tr, hir::TraitBoundModifier::None) => {\n             let mut projections = Vec::new();\n             let pred = astconv.instantiate_poly_trait_ref(tr,\n                                                           param_ty,\n@@ -1609,14 +1644,12 @@ fn predicates_from_bound<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n                        .chain(Some(pred.to_predicate()))\n                        .collect()\n         }\n-        hir::RegionTyParamBound(ref lifetime) => {\n+        hir::GenericBound::Outlives(ref lifetime) => {\n             let region = astconv.ast_region_to_region(lifetime, None);\n             let pred = ty::Binder::bind(ty::OutlivesPredicate(param_ty, region));\n             vec![ty::Predicate::TypeOutlives(pred)]\n         }\n-        hir::TraitTyParamBound(_, hir::TraitBoundModifier::Maybe) => {\n-            Vec::new()\n-        }\n+        hir::GenericBound::Trait(_, hir::TraitBoundModifier::Maybe) => vec![],\n     }\n }\n "}, {"sha": "3f7e3529e9648f713430dd29216aec29ab623802", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -1501,12 +1501,12 @@ struct Foo {\n \"##,\n \n E0131: r##\"\n-It is not possible to define `main` with type parameters, or even with function\n-parameters. When `main` is present, it must take no arguments and return `()`.\n+It is not possible to define `main` with generic parameters.\n+When `main` is present, it must take no arguments and return `()`.\n Erroneous code example:\n \n ```compile_fail,E0131\n-fn main<T>() { // error: main function is not allowed to have type parameters\n+fn main<T>() { // error: main function is not allowed to have generic parameters\n }\n ```\n \"##,"}, {"sha": "dcc5fa53d2f420f9c0e75c6cc0464d00b1f37781", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -76,6 +76,7 @@ This API is completely unstable and subject to change.\n #![feature(crate_visibility_modifier)]\n #![feature(from_ref)]\n #![feature(exhaustive_patterns)]\n+#![feature(iterator_find_map)]\n #![feature(quote)]\n #![feature(refcell_replace_swap)]\n #![feature(rustc_diagnostic_macros)]\n@@ -190,16 +191,9 @@ fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         hir::ItemFn(.., ref generics, _) => {\n                             let mut error = false;\n                             if !generics.params.is_empty() {\n-                                let param_type = if generics.is_lt_parameterized() {\n-                                    \"lifetime\"\n-                                } else {\n-                                    \"type\"\n-                                };\n-                                let msg =\n-                                    format!(\"`main` function is not allowed to have {} parameters\",\n-                                            param_type);\n-                                let label =\n-                                    format!(\"`main` cannot have {} parameters\", param_type);\n+                                let msg = format!(\"`main` function is not allowed to have generic \\\n+                                                   parameters\");\n+                                let label = format!(\"`main` cannot have generic parameters\");\n                                 struct_span_err!(tcx.sess, generics.span, E0131, \"{}\", msg)\n                                     .span_label(generics.span, label)\n                                     .emit();"}, {"sha": "5c09da90491d064f6001723f0080d4e1171640e4", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 44, "deletions": 56, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -244,34 +244,32 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n         None\n     }\n \n-    fn generics_to_path_params(&self, generics: ty::Generics) -> hir::PathParameters {\n-        let mut lifetimes = vec![];\n-        let mut types = vec![];\n+    fn generics_to_path_params(&self, generics: ty::Generics) -> hir::GenericArgs {\n+        let mut args = vec![];\n \n         for param in generics.params.iter() {\n             match param.kind {\n                 ty::GenericParamDefKind::Lifetime => {\n                     let name = if param.name == \"\" {\n-                        hir::LifetimeName::Static\n+                        hir::ParamName::Plain(keywords::StaticLifetime.name())\n                     } else {\n-                        hir::LifetimeName::Name(param.name.as_symbol())\n+                        hir::ParamName::Plain(param.name.as_symbol())\n                     };\n \n-                    lifetimes.push(hir::Lifetime {\n+                    args.push(hir::GenericArg::Lifetime(hir::Lifetime {\n                         id: ast::DUMMY_NODE_ID,\n                         span: DUMMY_SP,\n-                        name,\n-                    });\n+                        name: hir::LifetimeName::Param(name),\n+                    }));\n                 }\n                 ty::GenericParamDefKind::Type {..} => {\n-                    types.push(P(self.ty_param_to_ty(param.clone())));\n+                    args.push(hir::GenericArg::Type(P(self.ty_param_to_ty(param.clone()))));\n                 }\n             }\n         }\n \n-        hir::PathParameters {\n-            lifetimes: HirVec::from_vec(lifetimes),\n-            types: HirVec::from_vec(types),\n+        hir::GenericArgs {\n+            args: HirVec::from_vec(args),\n             bindings: HirVec::new(),\n             parenthesized: false,\n         }\n@@ -488,11 +486,8 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n             .iter()\n             .flat_map(|(name, lifetime)| {\n                 let empty = Vec::new();\n-                let bounds: FxHashSet<Lifetime> = finished\n-                    .get(name)\n-                    .unwrap_or(&empty)\n-                    .iter()\n-                    .map(|region| self.get_lifetime(region, names_map))\n+                let bounds: FxHashSet<GenericBound> = finished.get(name).unwrap_or(&empty).iter()\n+                    .map(|region| GenericBound::Outlives(self.get_lifetime(region, names_map)))\n                     .collect();\n \n                 if bounds.is_empty() {\n@@ -523,7 +518,10 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                         // We only care about late bound regions, as we need to add them\n                         // to the 'for<>' section\n                         &ty::ReLateBound(_, ty::BoundRegion::BrNamed(_, name)) => {\n-                            Some(GenericParamDef::Lifetime(Lifetime(name.to_string())))\n+                            Some(GenericParamDef {\n+                                name: name.to_string(),\n+                                kind: GenericParamDefKind::Lifetime,\n+                            })\n                         }\n                         &ty::ReVar(_) | &ty::ReEarlyBound(_) => None,\n                         _ => panic!(\"Unexpected region type {:?}\", r),\n@@ -535,9 +533,9 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n \n     fn make_final_bounds<'b, 'c, 'cx>(\n         &self,\n-        ty_to_bounds: FxHashMap<Type, FxHashSet<TyParamBound>>,\n+        ty_to_bounds: FxHashMap<Type, FxHashSet<GenericBound>>,\n         ty_to_fn: FxHashMap<Type, (Option<PolyTrait>, Option<Type>)>,\n-        lifetime_to_bounds: FxHashMap<Lifetime, FxHashSet<Lifetime>>,\n+        lifetime_to_bounds: FxHashMap<Lifetime, FxHashSet<GenericBound>>,\n     ) -> Vec<WherePredicate> {\n         ty_to_bounds\n             .into_iter()\n@@ -555,9 +553,9 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                             let mut new_path = path.clone();\n                             let last_segment = new_path.segments.pop().unwrap();\n \n-                            let (old_input, old_output) = match last_segment.params {\n-                                PathParameters::AngleBracketed { types, .. } => (types, None),\n-                                PathParameters::Parenthesized { inputs, output, .. } => {\n+                            let (old_input, old_output) = match last_segment.args {\n+                                GenericArgs::AngleBracketed { types, .. } => (types, None),\n+                                GenericArgs::Parenthesized { inputs, output, .. } => {\n                                     (inputs, output)\n                                 }\n                             };\n@@ -569,14 +567,14 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                                 );\n                             }\n \n-                            let new_params = PathParameters::Parenthesized {\n+                            let new_params = GenericArgs::Parenthesized {\n                                 inputs: old_input,\n                                 output,\n                             };\n \n                             new_path.segments.push(PathSegment {\n                                 name: last_segment.name,\n-                                params: new_params,\n+                                args: new_params,\n                             });\n \n                             Type::ResolvedPath {\n@@ -588,7 +586,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                         }\n                         _ => panic!(\"Unexpected data: {:?}, {:?}\", ty, data),\n                     };\n-                    bounds.insert(TyParamBound::TraitBound(\n+                    bounds.insert(GenericBound::TraitBound(\n                         PolyTrait {\n                             trait_: new_ty,\n                             generic_params: poly_trait.generic_params,\n@@ -614,7 +612,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                     .filter(|&(_, ref bounds)| !bounds.is_empty())\n                     .map(|(lifetime, bounds)| {\n                         let mut bounds_vec = bounds.into_iter().collect();\n-                        self.sort_where_lifetimes(&mut bounds_vec);\n+                        self.sort_where_bounds(&mut bounds_vec);\n                         WherePredicate::RegionPredicate {\n                             lifetime,\n                             bounds: bounds_vec,\n@@ -731,7 +729,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                         // later\n \n                         let is_fn = match &mut b {\n-                            &mut TyParamBound::TraitBound(ref mut p, _) => {\n+                            &mut GenericBound::TraitBound(ref mut p, _) => {\n                                 // Insert regions into the for_generics hash map first, to ensure\n                                 // that we don't end up with duplicate bounds (e.g. for<'b, 'b>)\n                                 for_generics.extend(p.generic_params.clone());\n@@ -793,13 +791,13 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n \n                                     // FIXME: Remove this scope when NLL lands\n                                     {\n-                                        let params =\n-                                            &mut new_trait_path.segments.last_mut().unwrap().params;\n+                                        let args =\n+                                            &mut new_trait_path.segments.last_mut().unwrap().args;\n \n-                                        match params {\n+                                        match args {\n                                             // Convert somethiung like '<T as Iterator::Item> = u8'\n                                             // to 'T: Iterator<Item=u8>'\n-                                            &mut PathParameters::AngleBracketed {\n+                                            &mut GenericArgs::AngleBracketed {\n                                                 ref mut bindings,\n                                                 ..\n                                             } => {\n@@ -808,7 +806,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                                                     ty: rhs,\n                                                 });\n                                             }\n-                                            &mut PathParameters::Parenthesized { .. } => {\n+                                            &mut GenericArgs::Parenthesized { .. } => {\n                                                 existing_predicates.push(\n                                                     WherePredicate::EqPredicate {\n                                                         lhs: lhs.clone(),\n@@ -825,7 +823,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                                         .entry(*ty.clone())\n                                         .or_insert_with(|| FxHashSet());\n \n-                                    bounds.insert(TyParamBound::TraitBound(\n+                                    bounds.insert(GenericBound::TraitBound(\n                                         PolyTrait {\n                                             trait_: Type::ResolvedPath {\n                                                 path: new_trait_path,\n@@ -842,7 +840,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                                     // that we don't see a\n                                     // duplicate bound like `T: Iterator + Iterator<Item=u8>`\n                                     // on the docs page.\n-                                    bounds.remove(&TyParamBound::TraitBound(\n+                                    bounds.remove(&GenericBound::TraitBound(\n                                         PolyTrait {\n                                             trait_: *trait_.clone(),\n                                             generic_params: Vec::new(),\n@@ -869,19 +867,17 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n \n         existing_predicates.extend(final_bounds);\n \n-        for p in generic_params.iter_mut() {\n-            match p {\n-                &mut GenericParamDef::Type(ref mut ty) => {\n-                    // We never want something like 'impl<T=Foo>'\n-                    ty.default.take();\n-\n-                    let generic_ty = Type::Generic(ty.name.clone());\n-\n+        for param in generic_params.iter_mut() {\n+            match param.kind {\n+                GenericParamDefKind::Type { ref mut default, ref mut bounds, .. } => {\n+                    // We never want something like `impl<T=Foo>`.\n+                    default.take();\n+                    let generic_ty = Type::Generic(param.name.clone());\n                     if !has_sized.contains(&generic_ty) {\n-                        ty.bounds.insert(0, TyParamBound::maybe_sized(self.cx));\n+                        bounds.insert(0, GenericBound::maybe_sized(self.cx));\n                     }\n                 }\n-                GenericParamDef::Lifetime(_) => {}\n+                GenericParamDefKind::Lifetime => {}\n             }\n         }\n \n@@ -912,15 +908,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n     // both for visual consistency between 'rustdoc' runs, and to\n     // make writing tests much easier\n     #[inline]\n-    fn sort_where_bounds(&self, mut bounds: &mut Vec<TyParamBound>) {\n-        // We should never have identical bounds - and if we do,\n-        // they're visually identical as well. Therefore, using\n-        // an unstable sort is fine.\n-        self.unstable_debug_sort(&mut bounds);\n-    }\n-\n-    #[inline]\n-    fn sort_where_lifetimes(&self, mut bounds: &mut Vec<Lifetime>) {\n+    fn sort_where_bounds(&self, mut bounds: &mut Vec<GenericBound>) {\n         // We should never have identical bounds - and if we do,\n         // they're visually identical as well. Therefore, using\n         // an unstable sort is fine.\n@@ -940,7 +928,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n     // to end users, it makes writing tests much more difficult, as predicates\n     // can appear in any order in the final result.\n     //\n-    // To solve this problem, we sort WherePredicates and TyParamBounds\n+    // To solve this problem, we sort WherePredicates and GenericBounds\n     // by their Debug string. The thing to keep in mind is that we don't really\n     // care what the final order is - we're synthesizing an impl or bound\n     // ourselves, so any order can be considered equally valid. By sorting the\n@@ -950,7 +938,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n     // Using the Debug impementation for sorting prevents us from needing to\n     // write quite a bit of almost entirely useless code (e.g. how should two\n     // Types be sorted relative to each other). It also allows us to solve the\n-    // problem for both WherePredicates and TyParamBounds at the same time. This\n+    // problem for both WherePredicates and GenericBounds at the same time. This\n     // approach is probably somewhat slower, but the small number of items\n     // involved (impls rarely have more than a few bounds) means that it\n     // shouldn't matter in practice."}, {"sha": "114cb0e455d9aa057a7e950cce502b0a658123db", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -374,8 +374,8 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n     let polarity = tcx.impl_polarity(did);\n     let trait_ = associated_trait.clean(cx).map(|bound| {\n         match bound {\n-            clean::TraitBound(polyt, _) => polyt.trait_,\n-            clean::RegionBound(..) => unreachable!(),\n+            clean::GenericBound::TraitBound(polyt, _) => polyt.trait_,\n+            clean::GenericBound::Outlives(..) => unreachable!(),\n         }\n     });\n     if trait_.def_id() == tcx.lang_items().deref_trait() {\n@@ -387,9 +387,9 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n \n     let provided = trait_.def_id().map(|did| {\n         tcx.provided_trait_methods(did)\n-            .into_iter()\n-            .map(|meth| meth.name.to_string())\n-            .collect()\n+           .into_iter()\n+           .map(|meth| meth.name.to_string())\n+           .collect()\n     }).unwrap_or(FxHashSet());\n \n     ret.push(clean::Item {\n@@ -474,7 +474,7 @@ fn filter_non_trait_generics(trait_did: DefId, mut g: clean::Generics) -> clean:\n             } if *s == \"Self\" => {\n                 bounds.retain(|bound| {\n                     match *bound {\n-                        clean::TyParamBound::TraitBound(clean::PolyTrait {\n+                        clean::GenericBound::TraitBound(clean::PolyTrait {\n                             trait_: clean::ResolvedPath { did, .. },\n                             ..\n                         }, _) => did != trait_did,\n@@ -505,7 +505,7 @@ fn filter_non_trait_generics(trait_did: DefId, mut g: clean::Generics) -> clean:\n /// the metadata for a crate, so we want to separate those out and create a new\n /// list of explicit supertrait bounds to render nicely.\n fn separate_supertrait_bounds(mut g: clean::Generics)\n-                              -> (clean::Generics, Vec<clean::TyParamBound>) {\n+                              -> (clean::Generics, Vec<clean::GenericBound>) {\n     let mut ty_bounds = Vec::new();\n     g.where_predicates.retain(|pred| {\n         match *pred {"}, {"sha": "0979c3d85587d2ed2852f7a8b804ef8b550b78f8", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 263, "deletions": 200, "changes": 463, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -14,7 +14,6 @@\n pub use self::Type::*;\n pub use self::Mutability::*;\n pub use self::ItemEnum::*;\n-pub use self::TyParamBound::*;\n pub use self::SelfTy::*;\n pub use self::FunctionRetTy::*;\n pub use self::Visibility::{Public, Inherited};\n@@ -36,12 +35,12 @@ use rustc::middle::resolve_lifetime as rl;\n use rustc::ty::fold::TypeFolder;\n use rustc::middle::lang_items;\n use rustc::mir::interpret::GlobalId;\n-use rustc::hir::{self, HirVec};\n+use rustc::hir::{self, GenericArg, HirVec};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::hir::def_id::DefIndexAddressSpace;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, TyCtxt, Region, RegionVid, Ty, AdtKind, GenericParamCount};\n+use rustc::ty::{self, TyCtxt, Region, RegionVid, Ty, AdtKind};\n use rustc::middle::stability;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_typeck::hir_ty_to_ty;\n@@ -532,7 +531,7 @@ pub enum ItemEnum {\n     MacroItem(Macro),\n     PrimitiveItem(PrimitiveType),\n     AssociatedConstItem(Type, Option<String>),\n-    AssociatedTypeItem(Vec<TyParamBound>, Option<Type>),\n+    AssociatedTypeItem(Vec<GenericBound>, Option<Type>),\n     /// An item that has been stripped by a rustdoc pass\n     StrippedItem(Box<ItemEnum>),\n     KeywordItem(String),\n@@ -1458,61 +1457,19 @@ impl Clean<Attributes> for [ast::Attribute] {\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n-pub struct TyParam {\n-    pub name: String,\n-    pub did: DefId,\n-    pub bounds: Vec<TyParamBound>,\n-    pub default: Option<Type>,\n-    pub synthetic: Option<hir::SyntheticTyParamKind>,\n-}\n-\n-impl Clean<TyParam> for hir::TyParam {\n-    fn clean(&self, cx: &DocContext) -> TyParam {\n-        TyParam {\n-            name: self.name.clean(cx),\n-            did: cx.tcx.hir.local_def_id(self.id),\n-            bounds: self.bounds.clean(cx),\n-            default: self.default.clean(cx),\n-            synthetic: self.synthetic,\n-        }\n-    }\n+pub enum GenericBound {\n+    TraitBound(PolyTrait, hir::TraitBoundModifier),\n+    Outlives(Lifetime),\n }\n \n-impl<'tcx> Clean<TyParam> for ty::GenericParamDef {\n-    fn clean(&self, cx: &DocContext) -> TyParam {\n-        cx.renderinfo.borrow_mut().external_typarams.insert(self.def_id, self.name.clean(cx));\n-        let has_default = match self.kind {\n-            ty::GenericParamDefKind::Type { has_default, .. } => has_default,\n-            _ => panic!(\"tried to convert a non-type GenericParamDef as a type\")\n-        };\n-        TyParam {\n-            name: self.name.clean(cx),\n-            did: self.def_id,\n-            bounds: vec![], // these are filled in from the where-clauses\n-            default: if has_default {\n-                Some(cx.tcx.type_of(self.def_id).clean(cx))\n-            } else {\n-                None\n-            },\n-            synthetic: None,\n-        }\n-    }\n-}\n-\n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n-pub enum TyParamBound {\n-    RegionBound(Lifetime),\n-    TraitBound(PolyTrait, hir::TraitBoundModifier)\n-}\n-\n-impl TyParamBound {\n-    fn maybe_sized(cx: &DocContext) -> TyParamBound {\n+impl GenericBound {\n+    fn maybe_sized(cx: &DocContext) -> GenericBound {\n         let did = cx.tcx.require_lang_item(lang_items::SizedTraitLangItem);\n         let empty = cx.tcx.intern_substs(&[]);\n         let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n             Some(did), false, vec![], empty);\n         inline::record_extern_fqn(cx, did, TypeKind::Trait);\n-        TraitBound(PolyTrait {\n+        GenericBound::TraitBound(PolyTrait {\n             trait_: ResolvedPath {\n                 path,\n                 typarams: None,\n@@ -1525,7 +1482,7 @@ impl TyParamBound {\n \n     fn is_sized_bound(&self, cx: &DocContext) -> bool {\n         use rustc::hir::TraitBoundModifier as TBM;\n-        if let TyParamBound::TraitBound(PolyTrait { ref trait_, .. }, TBM::None) = *self {\n+        if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, TBM::None) = *self {\n             if trait_.def_id() == cx.tcx.lang_items().sized_trait() {\n                 return true;\n             }\n@@ -1534,32 +1491,34 @@ impl TyParamBound {\n     }\n \n     fn get_poly_trait(&self) -> Option<PolyTrait> {\n-        if let TyParamBound::TraitBound(ref p, _) = *self {\n+        if let GenericBound::TraitBound(ref p, _) = *self {\n             return Some(p.clone())\n         }\n         None\n     }\n \n     fn get_trait_type(&self) -> Option<Type> {\n \n-        if let TyParamBound::TraitBound(PolyTrait { ref trait_, .. }, _) = *self {\n+        if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, _) = *self {\n             return Some(trait_.clone());\n         }\n         None\n     }\n }\n \n-impl Clean<TyParamBound> for hir::TyParamBound {\n-    fn clean(&self, cx: &DocContext) -> TyParamBound {\n+impl Clean<GenericBound> for hir::GenericBound {\n+    fn clean(&self, cx: &DocContext) -> GenericBound {\n         match *self {\n-            hir::RegionTyParamBound(lt) => RegionBound(lt.clean(cx)),\n-            hir::TraitTyParamBound(ref t, modifier) => TraitBound(t.clean(cx), modifier),\n+            hir::GenericBound::Outlives(lt) => GenericBound::Outlives(lt.clean(cx)),\n+            hir::GenericBound::Trait(ref t, modifier) => {\n+                GenericBound::TraitBound(t.clean(cx), modifier)\n+            }\n         }\n     }\n }\n \n-fn external_path_params(cx: &DocContext, trait_did: Option<DefId>, has_self: bool,\n-                        bindings: Vec<TypeBinding>, substs: &Substs) -> PathParameters {\n+fn external_generic_args(cx: &DocContext, trait_did: Option<DefId>, has_self: bool,\n+                        bindings: Vec<TypeBinding>, substs: &Substs) -> GenericArgs {\n     let lifetimes = substs.regions().filter_map(|v| v.clean(cx)).collect();\n     let types = substs.types().skip(has_self as usize).collect::<Vec<_>>();\n \n@@ -1570,7 +1529,7 @@ fn external_path_params(cx: &DocContext, trait_did: Option<DefId>, has_self: boo\n             let inputs = match types[0].sty {\n                 ty::TyTuple(ref tys) => tys.iter().map(|t| t.clean(cx)).collect(),\n                 _ => {\n-                    return PathParameters::AngleBracketed {\n+                    return GenericArgs::AngleBracketed {\n                         lifetimes,\n                         types: types.clean(cx),\n                         bindings,\n@@ -1583,13 +1542,13 @@ fn external_path_params(cx: &DocContext, trait_did: Option<DefId>, has_self: boo\n             //     ty::TyTuple(ref v) if v.is_empty() => None, // -> ()\n             //     _ => Some(types[1].clean(cx))\n             // };\n-            PathParameters::Parenthesized {\n+            GenericArgs::Parenthesized {\n                 inputs,\n                 output,\n             }\n         },\n         _ => {\n-            PathParameters::AngleBracketed {\n+            GenericArgs::AngleBracketed {\n                 lifetimes,\n                 types: types.clean(cx),\n                 bindings,\n@@ -1607,13 +1566,13 @@ fn external_path(cx: &DocContext, name: &str, trait_did: Option<DefId>, has_self\n         def: Def::Err,\n         segments: vec![PathSegment {\n             name: name.to_string(),\n-            params: external_path_params(cx, trait_did, has_self, bindings, substs)\n+            args: external_generic_args(cx, trait_did, has_self, bindings, substs)\n         }],\n     }\n }\n \n-impl<'a, 'tcx> Clean<TyParamBound> for (&'a ty::TraitRef<'tcx>, Vec<TypeBinding>) {\n-    fn clean(&self, cx: &DocContext) -> TyParamBound {\n+impl<'a, 'tcx> Clean<GenericBound> for (&'a ty::TraitRef<'tcx>, Vec<TypeBinding>) {\n+    fn clean(&self, cx: &DocContext) -> GenericBound {\n         let (trait_ref, ref bounds) = *self;\n         inline::record_extern_fqn(cx, trait_ref.def_id, TypeKind::Trait);\n         let path = external_path(cx, &cx.tcx.item_name(trait_ref.def_id).as_str(),\n@@ -1629,16 +1588,19 @@ impl<'a, 'tcx> Clean<TyParamBound> for (&'a ty::TraitRef<'tcx>, Vec<TypeBinding>\n                     if let ty::TyRef(ref reg, _, _) = ty_s.sty {\n                         if let &ty::RegionKind::ReLateBound(..) = *reg {\n                             debug!(\"  hit an ReLateBound {:?}\", reg);\n-                            if let Some(lt) = reg.clean(cx) {\n-                                late_bounds.push(GenericParamDef::Lifetime(lt));\n+                            if let Some(Lifetime(name)) = reg.clean(cx) {\n+                                late_bounds.push(GenericParamDef {\n+                                    name,\n+                                    kind: GenericParamDefKind::Lifetime,\n+                                });\n                             }\n                         }\n                     }\n                 }\n             }\n         }\n \n-        TraitBound(\n+        GenericBound::TraitBound(\n             PolyTrait {\n                 trait_: ResolvedPath {\n                     path,\n@@ -1653,18 +1615,17 @@ impl<'a, 'tcx> Clean<TyParamBound> for (&'a ty::TraitRef<'tcx>, Vec<TypeBinding>\n     }\n }\n \n-impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n-    fn clean(&self, cx: &DocContext) -> TyParamBound {\n+impl<'tcx> Clean<GenericBound> for ty::TraitRef<'tcx> {\n+    fn clean(&self, cx: &DocContext) -> GenericBound {\n         (self, vec![]).clean(cx)\n     }\n }\n \n-impl<'tcx> Clean<Option<Vec<TyParamBound>>> for Substs<'tcx> {\n-    fn clean(&self, cx: &DocContext) -> Option<Vec<TyParamBound>> {\n+impl<'tcx> Clean<Option<Vec<GenericBound>>> for Substs<'tcx> {\n+    fn clean(&self, cx: &DocContext) -> Option<Vec<GenericBound>> {\n         let mut v = Vec::new();\n-        v.extend(self.regions().filter_map(|r| r.clean(cx))\n-                     .map(RegionBound));\n-        v.extend(self.types().map(|t| TraitBound(PolyTrait {\n+        v.extend(self.regions().filter_map(|r| r.clean(cx)).map(GenericBound::Outlives));\n+        v.extend(self.types().map(|t| GenericBound::TraitBound(PolyTrait {\n             trait_: t.clean(cx),\n             generic_params: Vec::new(),\n         }, hir::TraitBoundModifier::None)));\n@@ -1707,18 +1668,26 @@ impl Clean<Lifetime> for hir::Lifetime {\n     }\n }\n \n-impl Clean<Lifetime> for hir::LifetimeDef {\n+impl Clean<Lifetime> for hir::GenericParam {\n     fn clean(&self, _: &DocContext) -> Lifetime {\n-        if self.bounds.len() > 0 {\n-            let mut s = format!(\"{}: {}\",\n-                                self.lifetime.name.name(),\n-                                self.bounds[0].name.name());\n-            for bound in self.bounds.iter().skip(1) {\n-                s.push_str(&format!(\" + {}\", bound.name.name()));\n+        match self.kind {\n+            hir::GenericParamKind::Lifetime { .. } => {\n+                if self.bounds.len() > 0 {\n+                    let mut bounds = self.bounds.iter().map(|bound| match bound {\n+                        hir::GenericBound::Outlives(lt) => lt,\n+                        _ => panic!(),\n+                    });\n+                    let name = bounds.next().unwrap().name.name();\n+                    let mut s = format!(\"{}: {}\", self.name.name(), name);\n+                    for bound in bounds {\n+                        s.push_str(&format!(\" + {}\", bound.name.name()));\n+                    }\n+                    Lifetime(s)\n+                } else {\n+                    Lifetime(self.name.name().to_string())\n+                }\n             }\n-            Lifetime(s)\n-        } else {\n-            Lifetime(self.lifetime.name.name().to_string())\n+            _ => panic!(),\n         }\n     }\n }\n@@ -1751,8 +1720,8 @@ impl Clean<Option<Lifetime>> for ty::RegionKind {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub enum WherePredicate {\n-    BoundPredicate { ty: Type, bounds: Vec<TyParamBound> },\n-    RegionPredicate { lifetime: Lifetime, bounds: Vec<Lifetime>},\n+    BoundPredicate { ty: Type, bounds: Vec<GenericBound> },\n+    RegionPredicate { lifetime: Lifetime, bounds: Vec<GenericBound> },\n     EqPredicate { lhs: Type, rhs: Type },\n }\n \n@@ -1822,7 +1791,7 @@ impl<'tcx> Clean<WherePredicate> for ty::OutlivesPredicate<ty::Region<'tcx>, ty:\n         let ty::OutlivesPredicate(ref a, ref b) = *self;\n         WherePredicate::RegionPredicate {\n             lifetime: a.clean(cx).unwrap(),\n-            bounds: vec![b.clean(cx).unwrap()]\n+            bounds: vec![GenericBound::Outlives(b.clean(cx).unwrap())]\n         }\n     }\n }\n@@ -1833,7 +1802,7 @@ impl<'tcx> Clean<WherePredicate> for ty::OutlivesPredicate<Ty<'tcx>, ty::Region<\n \n         WherePredicate::BoundPredicate {\n             ty: ty.clean(cx),\n-            bounds: vec![TyParamBound::RegionBound(lt.clean(cx).unwrap())]\n+            bounds: vec![GenericBound::Outlives(lt.clean(cx).unwrap())]\n         }\n     }\n }\n@@ -1850,10 +1819,8 @@ impl<'tcx> Clean<WherePredicate> for ty::ProjectionPredicate<'tcx> {\n impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Type {\n         let trait_ = match self.trait_ref(cx.tcx).clean(cx) {\n-            TyParamBound::TraitBound(t, _) => t.trait_,\n-            TyParamBound::RegionBound(_) => {\n-                panic!(\"cleaning a trait got a region\")\n-            }\n+            GenericBound::TraitBound(t, _) => t.trait_,\n+            GenericBound::Outlives(_) => panic!(\"cleaning a trait got a lifetime\"),\n         };\n         Type::QPath {\n             name: cx.tcx.associated_item(self.item_def_id).name.clean(cx),\n@@ -1864,25 +1831,95 @@ impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n-pub enum GenericParamDef {\n-    Lifetime(Lifetime),\n-    Type(TyParam),\n+pub enum GenericParamDefKind {\n+    Lifetime,\n+    Type {\n+        did: DefId,\n+        bounds: Vec<GenericBound>,\n+        default: Option<Type>,\n+        synthetic: Option<hir::SyntheticTyParamKind>,\n+    },\n+}\n+\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n+pub struct GenericParamDef {\n+    pub name: String,\n+\n+    pub kind: GenericParamDefKind,\n }\n \n impl GenericParamDef {\n     pub fn is_synthetic_type_param(&self) -> bool {\n-        match self {\n-            GenericParamDef::Type(ty) => ty.synthetic.is_some(),\n-            GenericParamDef::Lifetime(_) => false,\n+        match self.kind {\n+            GenericParamDefKind::Lifetime => false,\n+            GenericParamDefKind::Type { ref synthetic, .. } => synthetic.is_some(),\n+        }\n+    }\n+}\n+\n+impl<'tcx> Clean<GenericParamDef> for ty::GenericParamDef {\n+    fn clean(&self, cx: &DocContext) -> GenericParamDef {\n+        let (name, kind) = match self.kind {\n+            ty::GenericParamDefKind::Lifetime => {\n+                (self.name.to_string(), GenericParamDefKind::Lifetime)\n+            }\n+            ty::GenericParamDefKind::Type { has_default, .. } => {\n+                cx.renderinfo.borrow_mut().external_typarams\n+                             .insert(self.def_id, self.name.clean(cx));\n+                let default = if has_default {\n+                    Some(cx.tcx.type_of(self.def_id).clean(cx))\n+                } else {\n+                    None\n+                };\n+                (self.name.clean(cx), GenericParamDefKind::Type {\n+                    did: self.def_id,\n+                    bounds: vec![], // These are filled in from the where-clauses.\n+                    default,\n+                    synthetic: None,\n+                })\n+            }\n+        };\n+\n+        GenericParamDef {\n+            name,\n+            kind,\n         }\n     }\n }\n \n impl Clean<GenericParamDef> for hir::GenericParam {\n     fn clean(&self, cx: &DocContext) -> GenericParamDef {\n-        match *self {\n-            hir::GenericParam::Lifetime(ref l) => GenericParamDef::Lifetime(l.clean(cx)),\n-            hir::GenericParam::Type(ref t) => GenericParamDef::Type(t.clean(cx)),\n+        let (name, kind) = match self.kind {\n+            hir::GenericParamKind::Lifetime { .. } => {\n+                let name = if self.bounds.len() > 0 {\n+                    let mut bounds = self.bounds.iter().map(|bound| match bound {\n+                        hir::GenericBound::Outlives(lt) => lt,\n+                        _ => panic!(),\n+                    });\n+                    let name = bounds.next().unwrap().name.name();\n+                    let mut s = format!(\"{}: {}\", self.name.name(), name);\n+                    for bound in bounds {\n+                        s.push_str(&format!(\" + {}\", bound.name.name()));\n+                    }\n+                    s\n+                } else {\n+                    self.name.name().to_string()\n+                };\n+                (name, GenericParamDefKind::Lifetime)\n+            }\n+            hir::GenericParamKind::Type { ref default, synthetic, .. } => {\n+                (self.name.name().clean(cx), GenericParamDefKind::Type {\n+                    did: cx.tcx.hir.local_def_id(self.id),\n+                    bounds: self.bounds.clean(cx),\n+                    default: default.clean(cx),\n+                    synthetic: synthetic,\n+                })\n+            }\n+        };\n+\n+        GenericParamDef {\n+            name,\n+            kind,\n         }\n     }\n }\n@@ -1900,25 +1937,25 @@ impl Clean<Generics> for hir::Generics {\n         // In order for normal parameters to be able to refer to synthetic ones,\n         // scans them first.\n         fn is_impl_trait(param: &hir::GenericParam) -> bool {\n-            if let hir::GenericParam::Type(ref tp) = param {\n-                tp.synthetic == Some(hir::SyntheticTyParamKind::ImplTrait)\n-            } else {\n-                false\n+            match param.kind {\n+                hir::GenericParamKind::Type { synthetic, .. } => {\n+                    synthetic == Some(hir::SyntheticTyParamKind::ImplTrait)\n+                }\n+                _ => false,\n             }\n         }\n         let impl_trait_params = self.params\n             .iter()\n-            .filter(|p| is_impl_trait(p))\n-            .map(|p| {\n-                let p = p.clean(cx);\n-                if let GenericParamDef::Type(ref tp) = p {\n-                    cx.impl_trait_bounds\n-                        .borrow_mut()\n-                        .insert(tp.did, tp.bounds.clone());\n-                } else {\n-                    unreachable!()\n+            .filter(|param| is_impl_trait(param))\n+            .map(|param| {\n+                let param: GenericParamDef = param.clean(cx);\n+                match param.kind {\n+                    GenericParamDefKind::Lifetime => unreachable!(),\n+                    GenericParamDefKind::Type { did, ref bounds, .. } => {\n+                        cx.impl_trait_bounds.borrow_mut().insert(did, bounds.clone());\n+                    }\n                 }\n-                p\n+                param\n             })\n             .collect::<Vec<_>>();\n \n@@ -1929,23 +1966,26 @@ impl Clean<Generics> for hir::Generics {\n         }\n         params.extend(impl_trait_params);\n \n-        let mut g = Generics {\n+        let mut generics = Generics {\n             params,\n-            where_predicates: self.where_clause.predicates.clean(cx)\n+            where_predicates: self.where_clause.predicates.clean(cx),\n         };\n \n         // Some duplicates are generated for ?Sized bounds between type params and where\n         // predicates. The point in here is to move the bounds definitions from type params\n         // to where predicates when such cases occur.\n-        for where_pred in &mut g.where_predicates {\n+        for where_pred in &mut generics.where_predicates {\n             match *where_pred {\n                 WherePredicate::BoundPredicate { ty: Generic(ref name), ref mut bounds } => {\n                     if bounds.is_empty() {\n-                        for param in &mut g.params {\n-                            if let GenericParamDef::Type(ref mut type_param) = *param {\n-                                if &type_param.name == name {\n-                                    mem::swap(bounds, &mut type_param.bounds);\n-                                    break\n+                        for param in &mut generics.params {\n+                            match param.kind {\n+                                GenericParamDefKind::Lifetime => {}\n+                                GenericParamDefKind::Type { bounds: ref mut ty_bounds, .. } => {\n+                                    if &param.name == name {\n+                                        mem::swap(bounds, ty_bounds);\n+                                        break\n+                                    }\n                                 }\n                             }\n                         }\n@@ -1954,7 +1994,7 @@ impl Clean<Generics> for hir::Generics {\n                 _ => continue,\n             }\n         }\n-        g\n+        generics\n     }\n }\n \n@@ -1968,18 +2008,16 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n         // Bounds in the type_params and lifetimes fields are repeated in the\n         // predicates field (see rustc_typeck::collect::ty_generics), so remove\n         // them.\n-        let stripped_typarams = gens.params.iter().filter_map(|param| {\n-            if let ty::GenericParamDefKind::Type {..} = param.kind {\n+        let stripped_typarams = gens.params.iter().filter_map(|param| match param.kind {\n+            ty::GenericParamDefKind::Lifetime => None,\n+            ty::GenericParamDefKind::Type { .. } => {\n                 if param.name == keywords::SelfType.name().as_str() {\n                     assert_eq!(param.index, 0);\n-                    None\n-                } else {\n-                    Some(param.clean(cx))\n+                    return None;\n                 }\n-            } else {\n-                None\n+                Some(param.clean(cx))\n             }\n-        }).collect::<Vec<TyParam>>();\n+        }).collect::<Vec<GenericParamDef>>();\n \n         let mut where_predicates = preds.predicates.to_vec().clean(cx);\n \n@@ -2011,7 +2049,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n             if !sized_params.contains(&tp.name) {\n                 where_predicates.push(WP::BoundPredicate {\n                     ty: Type::Generic(tp.name.clone()),\n-                    bounds: vec![TyParamBound::maybe_sized(cx)],\n+                    bounds: vec![GenericBound::maybe_sized(cx)],\n                 })\n             }\n         }\n@@ -2023,17 +2061,10 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n         Generics {\n             params: gens.params\n                         .iter()\n-                        .flat_map(|param| {\n-                            if let ty::GenericParamDefKind::Lifetime = param.kind {\n-                                Some(GenericParamDef::Lifetime(param.clean(cx)))\n-                            } else {\n-                                None\n-                            }\n-                        }).chain(\n-                            simplify::ty_params(stripped_typarams)\n-                                .into_iter()\n-                                .map(|tp| GenericParamDef::Type(tp))\n-                        )\n+                        .flat_map(|param| match param.kind {\n+                            ty::GenericParamDefKind::Lifetime => Some(param.clean(cx)),\n+                            ty::GenericParamDefKind::Type { .. } => None,\n+                        }).chain(simplify::ty_params(stripped_typarams).into_iter())\n                         .collect(),\n             where_predicates: simplify::where_clauses(cx, where_predicates),\n         }\n@@ -2259,7 +2290,7 @@ pub struct Trait {\n     pub unsafety: hir::Unsafety,\n     pub items: Vec<Item>,\n     pub generics: Generics,\n-    pub bounds: Vec<TyParamBound>,\n+    pub bounds: Vec<GenericBound>,\n     pub is_spotlight: bool,\n     pub is_auto: bool,\n }\n@@ -2481,7 +2512,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                     // at the end.\n                     match bounds.iter().position(|b| b.is_sized_bound(cx)) {\n                         Some(i) => { bounds.remove(i); }\n-                        None => bounds.push(TyParamBound::maybe_sized(cx)),\n+                        None => bounds.push(GenericBound::maybe_sized(cx)),\n                     }\n \n                     let ty = if self.defaultness.has_value() {\n@@ -2536,7 +2567,7 @@ pub enum Type {\n     /// structs/enums/traits (most that'd be an hir::TyPath)\n     ResolvedPath {\n         path: Path,\n-        typarams: Option<Vec<TyParamBound>>,\n+        typarams: Option<Vec<GenericBound>>,\n         did: DefId,\n         /// true if is a `T::Name` path for associated types\n         is_generic: bool,\n@@ -2572,7 +2603,7 @@ pub enum Type {\n     Infer,\n \n     // impl TraitA+TraitB\n-    ImplTrait(Vec<TyParamBound>),\n+    ImplTrait(Vec<GenericBound>),\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Copy, Debug)]\n@@ -2656,7 +2687,7 @@ impl Type {\n         match *self {\n             ResolvedPath { ref path, .. } => {\n                 path.segments.last().and_then(|seg| {\n-                    if let PathParameters::AngleBracketed { ref types, .. } = seg.params {\n+                    if let GenericArgs::AngleBracketed { ref types, .. } = seg.args {\n                         Some(&**types)\n                     } else {\n                         None\n@@ -2851,31 +2882,55 @@ impl Clean<Type> for hir::Ty {\n                     let provided_params = &path.segments.last().unwrap();\n                     let mut ty_substs = FxHashMap();\n                     let mut lt_substs = FxHashMap();\n-                    provided_params.with_parameters(|provided_params| {\n-                        let mut indices = GenericParamCount {\n+                    provided_params.with_generic_args(|generic_args| {\n+                        let mut indices = ty::GenericParamCount {\n                             lifetimes: 0,\n                             types: 0\n                         };\n                         for param in generics.params.iter() {\n-                            match param {\n-                                hir::GenericParam::Lifetime(lt_param) => {\n-                                    if let Some(lt) = provided_params.lifetimes\n-                                        .get(indices.lifetimes).cloned() {\n+                            match param.kind {\n+                                hir::GenericParamKind::Lifetime { .. } => {\n+                                    let mut j = 0;\n+                                    let lifetime = generic_args.args.iter().find_map(|arg| {\n+                                        match arg {\n+                                            GenericArg::Lifetime(lt) => {\n+                                                if indices.lifetimes == j {\n+                                                    return Some(lt);\n+                                                }\n+                                                j += 1;\n+                                                None\n+                                            }\n+                                            _ => None,\n+                                        }\n+                                    });\n+                                    if let Some(lt) = lifetime.cloned() {\n                                         if !lt.is_elided() {\n                                             let lt_def_id =\n-                                                cx.tcx.hir.local_def_id(lt_param.lifetime.id);\n+                                                cx.tcx.hir.local_def_id(param.id);\n                                             lt_substs.insert(lt_def_id, lt.clean(cx));\n                                         }\n                                     }\n                                     indices.lifetimes += 1;\n                                 }\n-                                hir::GenericParam::Type(ty_param) => {\n+                                hir::GenericParamKind::Type { ref default, .. } => {\n                                     let ty_param_def =\n-                                        Def::TyParam(cx.tcx.hir.local_def_id(ty_param.id));\n-                                    if let Some(ty) = provided_params.types\n-                                        .get(indices.types).cloned() {\n+                                        Def::TyParam(cx.tcx.hir.local_def_id(param.id));\n+                                    let mut j = 0;\n+                                    let type_ = generic_args.args.iter().find_map(|arg| {\n+                                        match arg {\n+                                            GenericArg::Type(ty) => {\n+                                                if indices.types == j {\n+                                                    return Some(ty);\n+                                                }\n+                                                j += 1;\n+                                                None\n+                                            }\n+                                            _ => None,\n+                                        }\n+                                    });\n+                                    if let Some(ty) = type_.cloned() {\n                                         ty_substs.insert(ty_param_def, ty.into_inner().clean(cx));\n-                                    } else if let Some(default) = ty_param.default.clone() {\n+                                    } else if let Some(default) = default.clone() {\n                                         ty_substs.insert(ty_param_def,\n                                                          default.into_inner().clean(cx));\n                                     }\n@@ -2922,18 +2977,14 @@ impl Clean<Type> for hir::Ty {\n             TyTraitObject(ref bounds, ref lifetime) => {\n                 match bounds[0].clean(cx).trait_ {\n                     ResolvedPath { path, typarams: None, did, is_generic } => {\n-                        let mut bounds: Vec<_> = bounds[1..].iter().map(|bound| {\n-                            TraitBound(bound.clean(cx), hir::TraitBoundModifier::None)\n+                        let mut bounds: Vec<self::GenericBound> = bounds[1..].iter().map(|bound| {\n+                            self::GenericBound::TraitBound(bound.clean(cx),\n+                                                           hir::TraitBoundModifier::None)\n                         }).collect();\n                         if !lifetime.is_elided() {\n-                            bounds.push(RegionBound(lifetime.clean(cx)));\n-                        }\n-                        ResolvedPath {\n-                            path,\n-                            typarams: Some(bounds),\n-                            did,\n-                            is_generic,\n+                            bounds.push(self::GenericBound::Outlives(lifetime.clean(cx)));\n                         }\n+                        ResolvedPath { path, typarams: Some(bounds), did, is_generic, }\n                     }\n                     _ => Infer // shouldn't happen\n                 }\n@@ -3030,13 +3081,13 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     inline::record_extern_fqn(cx, did, TypeKind::Trait);\n \n                     let mut typarams = vec![];\n-                    reg.clean(cx).map(|b| typarams.push(RegionBound(b)));\n+                    reg.clean(cx).map(|b| typarams.push(GenericBound::Outlives(b)));\n                     for did in obj.auto_traits() {\n                         let empty = cx.tcx.intern_substs(&[]);\n                         let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n                             Some(did), false, vec![], empty);\n                         inline::record_extern_fqn(cx, did, TypeKind::Trait);\n-                        let bound = TraitBound(PolyTrait {\n+                        let bound = GenericBound::TraitBound(PolyTrait {\n                             trait_: ResolvedPath {\n                                 path,\n                                 typarams: None,\n@@ -3087,7 +3138,9 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                         tr\n                     } else if let ty::Predicate::TypeOutlives(pred) = *predicate {\n                         // these should turn up at the end\n-                        pred.skip_binder().1.clean(cx).map(|r| regions.push(RegionBound(r)));\n+                        pred.skip_binder().1.clean(cx).map(|r| {\n+                            regions.push(GenericBound::Outlives(r))\n+                        });\n                         return None;\n                     } else {\n                         return None;\n@@ -3100,7 +3153,6 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                         }\n                     }\n \n-\n                     let bounds = bounds.predicates.iter().filter_map(|pred|\n                         if let ty::Predicate::Projection(proj) = *pred {\n                             let proj = proj.skip_binder();\n@@ -3122,7 +3174,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 }).collect::<Vec<_>>();\n                 bounds.extend(regions);\n                 if !has_sized && !bounds.is_empty() {\n-                    bounds.insert(0, TyParamBound::maybe_sized(cx));\n+                    bounds.insert(0, GenericBound::maybe_sized(cx));\n                 }\n                 ImplTrait(bounds)\n             }\n@@ -3447,7 +3499,7 @@ impl Path {\n             def: Def::Err,\n             segments: vec![PathSegment {\n                 name,\n-                params: PathParameters::AngleBracketed {\n+                args: GenericArgs::AngleBracketed {\n                     lifetimes: Vec::new(),\n                     types: Vec::new(),\n                     bindings: Vec::new(),\n@@ -3472,7 +3524,7 @@ impl Clean<Path> for hir::Path {\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n-pub enum PathParameters {\n+pub enum GenericArgs {\n     AngleBracketed {\n         lifetimes: Vec<Lifetime>,\n         types: Vec<Type>,\n@@ -3484,22 +3536,33 @@ pub enum PathParameters {\n     }\n }\n \n-impl Clean<PathParameters> for hir::PathParameters {\n-    fn clean(&self, cx: &DocContext) -> PathParameters {\n+impl Clean<GenericArgs> for hir::GenericArgs {\n+    fn clean(&self, cx: &DocContext) -> GenericArgs {\n         if self.parenthesized {\n             let output = self.bindings[0].ty.clean(cx);\n-            PathParameters::Parenthesized {\n+            GenericArgs::Parenthesized {\n                 inputs: self.inputs().clean(cx),\n                 output: if output != Type::Tuple(Vec::new()) { Some(output) } else { None }\n             }\n         } else {\n-            PathParameters::AngleBracketed {\n-                lifetimes: if self.lifetimes.iter().all(|lt| lt.is_elided()) {\n-                    vec![]\n-                } else {\n-                    self.lifetimes.clean(cx)\n-                },\n-                types: self.types.clean(cx),\n+            let (mut lifetimes, mut types) = (vec![], vec![]);\n+            let mut elided_lifetimes = true;\n+            for arg in &self.args {\n+                match arg {\n+                    GenericArg::Lifetime(lt) => {\n+                        if !lt.is_elided() {\n+                            elided_lifetimes = false;\n+                        }\n+                        lifetimes.push(lt.clean(cx));\n+                    }\n+                    GenericArg::Type(ty) => {\n+                        types.push(ty.clean(cx));\n+                    }\n+                }\n+            }\n+            GenericArgs::AngleBracketed {\n+                lifetimes: if elided_lifetimes { vec![] } else { lifetimes },\n+                types,\n                 bindings: self.bindings.clean(cx),\n             }\n         }\n@@ -3509,14 +3572,14 @@ impl Clean<PathParameters> for hir::PathParameters {\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub struct PathSegment {\n     pub name: String,\n-    pub params: PathParameters,\n+    pub args: GenericArgs,\n }\n \n impl Clean<PathSegment> for hir::PathSegment {\n     fn clean(&self, cx: &DocContext) -> PathSegment {\n         PathSegment {\n             name: self.name.clean(cx),\n-            params: self.with_parameters(|parameters| parameters.clean(cx))\n+            args: self.with_generic_args(|generic_args| generic_args.clean(cx))\n         }\n     }\n }\n@@ -3550,7 +3613,7 @@ fn strip_path(path: &Path) -> Path {\n     let segments = path.segments.iter().map(|s| {\n         PathSegment {\n             name: s.name.clone(),\n-            params: PathParameters::AngleBracketed {\n+            args: GenericArgs::AngleBracketed {\n                 lifetimes: Vec::new(),\n                 types: Vec::new(),\n                 bindings: Vec::new(),\n@@ -4365,7 +4428,7 @@ where F: Fn(DefId) -> Def {\n         def: def_ctor(def_id),\n         segments: hir::HirVec::from_vec(apb.names.iter().map(|s| hir::PathSegment {\n             name: ast::Name::intern(&s),\n-            parameters: None,\n+            args: None,\n             infer_types: false,\n         }).collect())\n     }\n@@ -4388,8 +4451,8 @@ struct RegionDeps<'tcx> {\n \n #[derive(Eq, PartialEq, Hash, Debug)]\n enum SimpleBound {\n-    RegionBound(Lifetime),\n-    TraitBound(Vec<PathSegment>, Vec<SimpleBound>, Vec<GenericParamDef>, hir::TraitBoundModifier)\n+    TraitBound(Vec<PathSegment>, Vec<SimpleBound>, Vec<GenericParamDef>, hir::TraitBoundModifier),\n+    Outlives(Lifetime),\n }\n \n enum AutoTraitResult {\n@@ -4407,11 +4470,11 @@ impl AutoTraitResult {\n     }\n }\n \n-impl From<TyParamBound> for SimpleBound {\n-    fn from(bound: TyParamBound) -> Self {\n+impl From<GenericBound> for SimpleBound {\n+    fn from(bound: GenericBound) -> Self {\n         match bound.clone() {\n-            TyParamBound::RegionBound(l) => SimpleBound::RegionBound(l),\n-            TyParamBound::TraitBound(t, mod_) => match t.trait_ {\n+            GenericBound::Outlives(l) => SimpleBound::Outlives(l),\n+            GenericBound::TraitBound(t, mod_) => match t.trait_ {\n                 Type::ResolvedPath { path, typarams, .. } => {\n                     SimpleBound::TraitBound(path.segments,\n                                             typarams"}, {"sha": "30a55bf0d18092f112df492ec5356e51f01bf1bb", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -27,7 +27,7 @@ use std::collections::BTreeMap;\n use rustc::hir::def_id::DefId;\n use rustc::ty;\n \n-use clean::PathParameters as PP;\n+use clean::GenericArgs as PP;\n use clean::WherePredicate as WP;\n use clean;\n use core::DocContext;\n@@ -83,8 +83,8 @@ pub fn where_clauses(cx: &DocContext, clauses: Vec<WP>) -> Vec<WP> {\n         };\n         !bounds.iter_mut().any(|b| {\n             let trait_ref = match *b {\n-                clean::TraitBound(ref mut tr, _) => tr,\n-                clean::RegionBound(..) => return false,\n+                clean::GenericBound::TraitBound(ref mut tr, _) => tr,\n+                clean::GenericBound::Outlives(..) => return false,\n             };\n             let (did, path) = match trait_ref.trait_ {\n                 clean::ResolvedPath { did, ref mut path, ..} => (did, path),\n@@ -97,7 +97,7 @@ pub fn where_clauses(cx: &DocContext, clauses: Vec<WP>) -> Vec<WP> {\n                 return false\n             }\n             let last = path.segments.last_mut().unwrap();\n-            match last.params {\n+            match last.args {\n                 PP::AngleBracketed { ref mut bindings, .. } => {\n                     bindings.push(clean::TypeBinding {\n                         name: name.clone(),\n@@ -135,14 +135,19 @@ pub fn where_clauses(cx: &DocContext, clauses: Vec<WP>) -> Vec<WP> {\n     clauses\n }\n \n-pub fn ty_params(mut params: Vec<clean::TyParam>) -> Vec<clean::TyParam> {\n+pub fn ty_params(mut params: Vec<clean::GenericParamDef>) -> Vec<clean::GenericParamDef> {\n     for param in &mut params {\n-        param.bounds = ty_bounds(mem::replace(&mut param.bounds, Vec::new()));\n+        match param.kind {\n+            clean::GenericParamDefKind::Type { ref mut bounds, .. } => {\n+                *bounds = ty_bounds(mem::replace(bounds, Vec::new()));\n+            }\n+            _ => panic!(\"expected only type parameters\"),\n+        }\n     }\n     params\n }\n \n-fn ty_bounds(bounds: Vec<clean::TyParamBound>) -> Vec<clean::TyParamBound> {\n+fn ty_bounds(bounds: Vec<clean::GenericBound>) -> Vec<clean::GenericBound> {\n     bounds\n }\n "}, {"sha": "53ebb3a12f527e637bfe3b84938f2e6c816d9d79", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -77,7 +77,7 @@ pub struct DocContext<'a, 'tcx: 'a, 'rcx: 'a> {\n     /// Table node id of lifetime parameter definition -> substituted lifetime\n     pub lt_substs: RefCell<FxHashMap<DefId, clean::Lifetime>>,\n     /// Table DefId of `impl Trait` in argument position -> bounds\n-    pub impl_trait_bounds: RefCell<FxHashMap<DefId, Vec<clean::TyParamBound>>>,\n+    pub impl_trait_bounds: RefCell<FxHashMap<DefId, Vec<clean::GenericBound>>>,\n     pub send_trait: Option<DefId>,\n     pub fake_def_ids: RefCell<FxHashMap<CrateNum, DefId>>,\n     pub all_fake_def_ids: RefCell<FxHashSet<DefId>>,"}, {"sha": "16d14bc56d6950257b21eda784f2fe559b548101", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -201,7 +201,7 @@ pub struct Trait {\n     pub name: Name,\n     pub items: hir::HirVec<hir::TraitItem>,\n     pub generics: hir::Generics,\n-    pub bounds: hir::HirVec<hir::TyParamBound>,\n+    pub bounds: hir::HirVec<hir::GenericBound>,\n     pub attrs: hir::HirVec<ast::Attribute>,\n     pub id: ast::NodeId,\n     pub whence: Span,"}, {"sha": "3d360f2f344b614c369eb1649ff73cb90d245788", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -46,7 +46,7 @@ pub struct MutableSpace(pub clean::Mutability);\n #[derive(Copy, Clone)]\n pub struct RawMutableSpace(pub clean::Mutability);\n /// Wrapper struct for emitting type parameter bounds.\n-pub struct TyParamBounds<'a>(pub &'a [clean::TyParamBound]);\n+pub struct GenericBounds<'a>(pub &'a [clean::GenericBound]);\n /// Wrapper struct for emitting a comma-separated list of items\n pub struct CommaSep<'a, T: 'a>(pub &'a [T]);\n pub struct AbiSpace(pub Abi);\n@@ -104,9 +104,9 @@ impl<'a, T: fmt::Display> fmt::Display for CommaSep<'a, T> {\n     }\n }\n \n-impl<'a> fmt::Display for TyParamBounds<'a> {\n+impl<'a> fmt::Display for GenericBounds<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let &TyParamBounds(bounds) = self;\n+        let &GenericBounds(bounds) = self;\n         for (i, bound) in bounds.iter().enumerate() {\n             if i > 0 {\n                 f.write_str(\" + \")?;\n@@ -119,20 +119,20 @@ impl<'a> fmt::Display for TyParamBounds<'a> {\n \n impl fmt::Display for clean::GenericParamDef {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            clean::GenericParamDef::Lifetime(ref lp) => write!(f, \"{}\", lp),\n-            clean::GenericParamDef::Type(ref tp) => {\n-                f.write_str(&tp.name)?;\n+        match self.kind {\n+            clean::GenericParamDefKind::Lifetime => write!(f, \"{}\", self.name),\n+            clean::GenericParamDefKind::Type { ref bounds, ref default, .. } => {\n+                f.write_str(&self.name)?;\n \n-                if !tp.bounds.is_empty() {\n+                if !bounds.is_empty() {\n                     if f.alternate() {\n-                        write!(f, \": {:#}\", TyParamBounds(&tp.bounds))?;\n+                        write!(f, \": {:#}\", GenericBounds(bounds))?;\n                     } else {\n-                        write!(f, \":&nbsp;{}\", TyParamBounds(&tp.bounds))?;\n+                        write!(f, \":&nbsp;{}\", GenericBounds(bounds))?;\n                     }\n                 }\n \n-                if let Some(ref ty) = tp.default {\n+                if let Some(ref ty) = default {\n                     if f.alternate() {\n                         write!(f, \" = {:#}\", ty)?;\n                     } else {\n@@ -190,9 +190,9 @@ impl<'a> fmt::Display for WhereClause<'a> {\n                 &clean::WherePredicate::BoundPredicate { ref ty, ref bounds } => {\n                     let bounds = bounds;\n                     if f.alternate() {\n-                        clause.push_str(&format!(\"{:#}: {:#}\", ty, TyParamBounds(bounds)));\n+                        clause.push_str(&format!(\"{:#}: {:#}\", ty, GenericBounds(bounds)));\n                     } else {\n-                        clause.push_str(&format!(\"{}: {}\", ty, TyParamBounds(bounds)));\n+                        clause.push_str(&format!(\"{}: {}\", ty, GenericBounds(bounds)));\n                     }\n                 }\n                 &clean::WherePredicate::RegionPredicate { ref lifetime,\n@@ -267,13 +267,13 @@ impl fmt::Display for clean::PolyTrait {\n     }\n }\n \n-impl fmt::Display for clean::TyParamBound {\n+impl fmt::Display for clean::GenericBound {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            clean::RegionBound(ref lt) => {\n+            clean::GenericBound::Outlives(ref lt) => {\n                 write!(f, \"{}\", *lt)\n             }\n-            clean::TraitBound(ref ty, modifier) => {\n+            clean::GenericBound::TraitBound(ref ty, modifier) => {\n                 let modifier_str = match modifier {\n                     hir::TraitBoundModifier::None => \"\",\n                     hir::TraitBoundModifier::Maybe => \"?\",\n@@ -288,10 +288,10 @@ impl fmt::Display for clean::TyParamBound {\n     }\n }\n \n-impl fmt::Display for clean::PathParameters {\n+impl fmt::Display for clean::GenericArgs {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            clean::PathParameters::AngleBracketed {\n+            clean::GenericArgs::AngleBracketed {\n                 ref lifetimes, ref types, ref bindings\n             } => {\n                 if !lifetimes.is_empty() || !types.is_empty() || !bindings.is_empty() {\n@@ -337,7 +337,7 @@ impl fmt::Display for clean::PathParameters {\n                     }\n                 }\n             }\n-            clean::PathParameters::Parenthesized { ref inputs, ref output } => {\n+            clean::GenericArgs::Parenthesized { ref inputs, ref output } => {\n                 f.write_str(\"(\")?;\n                 let mut comma = false;\n                 for ty in inputs {\n@@ -369,9 +369,9 @@ impl fmt::Display for clean::PathSegment {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.write_str(&self.name)?;\n         if f.alternate() {\n-            write!(f, \"{:#}\", self.params)\n+            write!(f, \"{:#}\", self.args)\n         } else {\n-            write!(f, \"{}\", self.params)\n+            write!(f, \"{}\", self.args)\n         }\n     }\n }\n@@ -447,7 +447,7 @@ fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n         }\n     }\n     if w.alternate() {\n-        write!(w, \"{:#}{:#}\", HRef::new(did, &last.name), last.params)?;\n+        write!(w, \"{:#}{:#}\", HRef::new(did, &last.name), last.args)?;\n     } else {\n         let path = if use_absolute {\n             match href(did) {\n@@ -461,7 +461,7 @@ fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n         } else {\n             format!(\"{}\", HRef::new(did, &last.name))\n         };\n-        write!(w, \"{}{}\", path, last.params)?;\n+        write!(w, \"{}{}\", path, last.args)?;\n     }\n     Ok(())\n }\n@@ -512,7 +512,7 @@ fn primitive_link(f: &mut fmt::Formatter,\n \n /// Helper to render type parameters\n fn tybounds(w: &mut fmt::Formatter,\n-            typarams: &Option<Vec<clean::TyParamBound>>) -> fmt::Result {\n+            typarams: &Option<Vec<clean::GenericBound>>) -> fmt::Result {\n     match *typarams {\n         Some(ref params) => {\n             for param in params {\n@@ -667,7 +667,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt:\n             }\n         }\n         clean::ImplTrait(ref bounds) => {\n-            write!(f, \"impl {}\", TyParamBounds(bounds))\n+            write!(f, \"impl {}\", GenericBounds(bounds))\n         }\n         clean::QPath { ref name, ref self_type, ref trait_ } => {\n             let should_show_cast = match *trait_ {\n@@ -757,7 +757,7 @@ fn fmt_impl(i: &clean::Impl,\n                 clean::ResolvedPath { typarams: None, ref path, is_generic: false, .. } => {\n                     let last = path.segments.last().unwrap();\n                     fmt::Display::fmt(&last.name, f)?;\n-                    fmt::Display::fmt(&last.params, f)?;\n+                    fmt::Display::fmt(&last.args, f)?;\n                 }\n                 _ => unreachable!(),\n             }"}, {"sha": "180591b35326073f3fc3c825be08563a7d2d0d39", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -69,7 +69,7 @@ use doctree;\n use fold::DocFolder;\n use html::escape::Escape;\n use html::format::{ConstnessSpace};\n-use html::format::{TyParamBounds, WhereClause, href, AbiSpace};\n+use html::format::{GenericBounds, WhereClause, href, AbiSpace};\n use html::format::{VisSpace, Method, UnsafetySpace, MutableSpace};\n use html::format::fmt_impl_for_trait_page;\n use html::item_type::ItemType;\n@@ -1453,11 +1453,11 @@ impl DocFolder for Cache {\n impl<'a> Cache {\n     fn generics(&mut self, generics: &clean::Generics) {\n         for param in &generics.params {\n-            match *param {\n-                clean::GenericParamDef::Type(ref typ) => {\n-                    self.typarams.insert(typ.did, typ.name.clone());\n+            match param.kind {\n+                clean::GenericParamDefKind::Lifetime => {}\n+                clean::GenericParamDefKind::Type { did, .. } => {\n+                    self.typarams.insert(did, param.name.clone());\n                 }\n-                clean::GenericParamDef::Lifetime(_) => {}\n             }\n         }\n     }\n@@ -2960,14 +2960,14 @@ fn assoc_const(w: &mut fmt::Formatter,\n }\n \n fn assoc_type<W: fmt::Write>(w: &mut W, it: &clean::Item,\n-                             bounds: &Vec<clean::TyParamBound>,\n+                             bounds: &Vec<clean::GenericBound>,\n                              default: Option<&clean::Type>,\n                              link: AssocItemLink) -> fmt::Result {\n     write!(w, \"type <a href='{}' class=\\\"type\\\">{}</a>\",\n            naive_assoc_href(it, link),\n            it.name.as_ref().unwrap())?;\n     if !bounds.is_empty() {\n-        write!(w, \": {}\", TyParamBounds(bounds))?\n+        write!(w, \": {}\", GenericBounds(bounds))?\n     }\n     if let Some(default) = default {\n         write!(w, \" = {}\", default)?;"}, {"sha": "566e2f1ed498c47fd8e7fbc1fc442b32b7e161b3", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -18,6 +18,7 @@\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(fs_read_write)]\n+#![feature(iterator_find_map)]\n #![feature(set_stdio)]\n #![feature(slice_sort_by_cached_key)]\n #![feature(test)]"}, {"sha": "c6de2c4da39cfb59238af3da3e5cd89069f0c09a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 61, "deletions": 103, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -10,9 +10,8 @@\n \n // The Rust abstract syntax tree.\n \n-pub use self::TyParamBound::*;\n pub use self::UnsafeSource::*;\n-pub use self::PathParameters::*;\n+pub use self::GenericArgs::*;\n pub use symbol::{Ident, Symbol as Name};\n pub use util::ThinVec;\n pub use util::parser::ExprPrecedence;\n@@ -58,14 +57,6 @@ impl fmt::Debug for Lifetime {\n     }\n }\n \n-/// A lifetime definition, e.g. `'a: 'b+'c+'d`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct LifetimeDef {\n-    pub attrs: ThinVec<Attribute>,\n-    pub lifetime: Lifetime,\n-    pub bounds: Vec<Lifetime>\n-}\n-\n /// A \"Path\" is essentially Rust's notion of a name.\n ///\n /// It's represented as a sequence of identifiers,\n@@ -135,30 +126,30 @@ pub struct PathSegment {\n     /// `Some` means that parameter list is supplied (`Path<X, Y>`)\n     /// but it can be empty (`Path<>`).\n     /// `P` is used as a size optimization for the common case with no parameters.\n-    pub parameters: Option<P<PathParameters>>,\n+    pub args: Option<P<GenericArgs>>,\n }\n \n impl PathSegment {\n     pub fn from_ident(ident: Ident) -> Self {\n-        PathSegment { ident, parameters: None }\n+        PathSegment { ident, args: None }\n     }\n     pub fn crate_root(span: Span) -> Self {\n         PathSegment::from_ident(Ident::new(keywords::CrateRoot.name(), span))\n     }\n }\n \n-/// Parameters of a path segment.\n+/// Arguments of a path segment.\n ///\n /// E.g. `<A, B>` as in `Foo<A, B>` or `(A, B)` as in `Foo(A, B)`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum PathParameters {\n+pub enum GenericArgs {\n     /// The `<'a, A,B,C>` in `foo::bar::baz::<'a, A,B,C>`\n-    AngleBracketed(AngleBracketedParameterData),\n+    AngleBracketed(AngleBracketedArgs),\n     /// The `(A,B)` and `C` in `Foo(A,B) -> C`\n-    Parenthesized(ParenthesizedParameterData),\n+    Parenthesized(ParenthesisedArgs),\n }\n \n-impl PathParameters {\n+impl GenericArgs {\n     pub fn span(&self) -> Span {\n         match *self {\n             AngleBracketed(ref data) => data.span,\n@@ -167,36 +158,40 @@ impl PathParameters {\n     }\n }\n \n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum GenericArg {\n+    Lifetime(Lifetime),\n+    Type(P<Ty>),\n+}\n+\n /// A path like `Foo<'a, T>`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Default)]\n-pub struct AngleBracketedParameterData {\n+pub struct AngleBracketedArgs {\n     /// Overall span\n     pub span: Span,\n-    /// The lifetime parameters for this path segment.\n-    pub lifetimes: Vec<Lifetime>,\n-    /// The type parameters for this path segment, if present.\n-    pub types: Vec<P<Ty>>,\n+    /// The arguments for this path segment.\n+    pub args: Vec<GenericArg>,\n     /// Bindings (equality constraints) on associated types, if present.\n     ///\n     /// E.g., `Foo<A=Bar>`.\n     pub bindings: Vec<TypeBinding>,\n }\n \n-impl Into<Option<P<PathParameters>>> for AngleBracketedParameterData {\n-    fn into(self) -> Option<P<PathParameters>> {\n-        Some(P(PathParameters::AngleBracketed(self)))\n+impl Into<Option<P<GenericArgs>>> for AngleBracketedArgs {\n+    fn into(self) -> Option<P<GenericArgs>> {\n+        Some(P(GenericArgs::AngleBracketed(self)))\n     }\n }\n \n-impl Into<Option<P<PathParameters>>> for ParenthesizedParameterData {\n-    fn into(self) -> Option<P<PathParameters>> {\n-        Some(P(PathParameters::Parenthesized(self)))\n+impl Into<Option<P<GenericArgs>>> for ParenthesisedArgs {\n+    fn into(self) -> Option<P<GenericArgs>> {\n+        Some(P(GenericArgs::Parenthesized(self)))\n     }\n }\n \n /// A path like `Foo(A,B) -> C`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct ParenthesizedParameterData {\n+pub struct ParenthesisedArgs {\n     /// Overall span\n     pub span: Span,\n \n@@ -273,64 +268,52 @@ pub const CRATE_NODE_ID: NodeId = NodeId(0);\n /// small, positive ids.\n pub const DUMMY_NODE_ID: NodeId = NodeId(!0);\n \n+/// A modifier on a bound, currently this is only used for `?Sized`, where the\n+/// modifier is `Maybe`. Negative bounds should also be handled here.\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum TraitBoundModifier {\n+    None,\n+    Maybe,\n+}\n+\n /// The AST represents all type param bounds as types.\n /// typeck::collect::compute_bounds matches these against\n /// the \"special\" built-in traits (see middle::lang_items) and\n /// detects Copy, Send and Sync.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum TyParamBound {\n-    TraitTyParamBound(PolyTraitRef, TraitBoundModifier),\n-    RegionTyParamBound(Lifetime)\n+pub enum GenericBound {\n+    Trait(PolyTraitRef, TraitBoundModifier),\n+    Outlives(Lifetime)\n }\n \n-impl TyParamBound {\n+impl GenericBound {\n     pub fn span(&self) -> Span {\n         match self {\n-            &TraitTyParamBound(ref t, ..) => t.span,\n-            &RegionTyParamBound(ref l) => l.ident.span,\n+            &GenericBound::Trait(ref t, ..) => t.span,\n+            &GenericBound::Outlives(ref l) => l.ident.span,\n         }\n     }\n }\n \n-/// A modifier on a bound, currently this is only used for `?Sized`, where the\n-/// modifier is `Maybe`. Negative bounds should also be handled here.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum TraitBoundModifier {\n-    None,\n-    Maybe,\n-}\n-\n-pub type TyParamBounds = Vec<TyParamBound>;\n+pub type GenericBounds = Vec<GenericBound>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct TyParam {\n-    pub attrs: ThinVec<Attribute>,\n-    pub ident: Ident,\n-    pub id: NodeId,\n-    pub bounds: TyParamBounds,\n-    pub default: Option<P<Ty>>,\n+pub enum GenericParamKind {\n+    /// A lifetime definition, e.g. `'a: 'b+'c+'d`.\n+    Lifetime,\n+    Type {\n+        default: Option<P<Ty>>,\n+    }\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum GenericParam {\n-    Lifetime(LifetimeDef),\n-    Type(TyParam),\n-}\n-\n-impl GenericParam {\n-    pub fn is_lifetime_param(&self) -> bool {\n-        match *self {\n-            GenericParam::Lifetime(_) => true,\n-            _ => false,\n-        }\n-    }\n+pub struct GenericParam {\n+    pub id: NodeId,\n+    pub ident: Ident,\n+    pub attrs: ThinVec<Attribute>,\n+    pub bounds: GenericBounds,\n \n-    pub fn is_type_param(&self) -> bool {\n-        match *self {\n-            GenericParam::Type(_) => true,\n-            _ => false,\n-        }\n-    }\n+    pub kind: GenericParamKind,\n }\n \n /// Represents lifetime, type and const parameters attached to a declaration of\n@@ -342,31 +325,6 @@ pub struct Generics {\n     pub span: Span,\n }\n \n-impl Generics {\n-    pub fn is_lt_parameterized(&self) -> bool {\n-        self.params.iter().any(|param| param.is_lifetime_param())\n-    }\n-\n-    pub fn is_type_parameterized(&self) -> bool {\n-        self.params.iter().any(|param| param.is_type_param())\n-    }\n-\n-    pub fn is_parameterized(&self) -> bool {\n-        !self.params.is_empty()\n-    }\n-\n-    pub fn span_for_name(&self, name: &str) -> Option<Span> {\n-        for param in &self.params {\n-            if let GenericParam::Type(ref t) = *param {\n-                if t.ident.name == name {\n-                    return Some(t.ident.span);\n-                }\n-            }\n-        }\n-        None\n-    }\n-}\n-\n impl Default for Generics {\n     /// Creates an instance of `Generics`.\n     fn default() ->  Generics {\n@@ -422,7 +380,7 @@ pub struct WhereBoundPredicate {\n     /// The type being bounded\n     pub bounded_ty: P<Ty>,\n     /// Trait and lifetime bounds (`Clone+Send+'static`)\n-    pub bounds: TyParamBounds,\n+    pub bounds: GenericBounds,\n }\n \n /// A lifetime predicate.\n@@ -432,7 +390,7 @@ pub struct WhereBoundPredicate {\n pub struct WhereRegionPredicate {\n     pub span: Span,\n     pub lifetime: Lifetime,\n-    pub bounds: Vec<Lifetime>,\n+    pub bounds: GenericBounds,\n }\n \n /// An equality predicate (unsupported).\n@@ -968,11 +926,11 @@ impl Expr {\n         }\n     }\n \n-    fn to_bound(&self) -> Option<TyParamBound> {\n+    fn to_bound(&self) -> Option<GenericBound> {\n         match &self.node {\n             ExprKind::Path(None, path) =>\n-                Some(TraitTyParamBound(PolyTraitRef::new(Vec::new(), path.clone(), self.span),\n-                                       TraitBoundModifier::None)),\n+                Some(GenericBound::Trait(PolyTraitRef::new(Vec::new(), path.clone(), self.span),\n+                                         TraitBoundModifier::None)),\n             _ => None,\n         }\n     }\n@@ -1393,7 +1351,7 @@ pub struct TraitItem {\n pub enum TraitItemKind {\n     Const(P<Ty>, Option<P<Expr>>),\n     Method(MethodSig, Option<P<Block>>),\n-    Type(TyParamBounds, Option<P<Ty>>),\n+    Type(GenericBounds, Option<P<Ty>>),\n     Macro(Mac),\n }\n \n@@ -1578,10 +1536,10 @@ pub enum TyKind {\n     Path(Option<QSelf>, Path),\n     /// A trait object type `Bound1 + Bound2 + Bound3`\n     /// where `Bound` is a trait or a lifetime.\n-    TraitObject(TyParamBounds, TraitObjectSyntax),\n+    TraitObject(GenericBounds, TraitObjectSyntax),\n     /// An `impl Bound1 + Bound2 + Bound3` type\n     /// where `Bound` is a trait or a lifetime.\n-    ImplTrait(TyParamBounds),\n+    ImplTrait(GenericBounds),\n     /// No-op; kept solely so that we can pretty-print faithfully\n     Paren(P<Ty>),\n     /// Unused for now\n@@ -2102,11 +2060,11 @@ pub enum ItemKind {\n     /// A Trait declaration (`trait` or `pub trait`).\n     ///\n     /// E.g. `trait Foo { .. }`, `trait Foo<T> { .. }` or `auto trait Foo {}`\n-    Trait(IsAuto, Unsafety, Generics, TyParamBounds, Vec<TraitItem>),\n+    Trait(IsAuto, Unsafety, Generics, GenericBounds, Vec<TraitItem>),\n     /// Trait alias\n     ///\n     /// E.g. `trait Foo = Bar + Quux;`\n-    TraitAlias(Generics, TyParamBounds),\n+    TraitAlias(Generics, GenericBounds),\n     /// An implementation.\n     ///\n     /// E.g. `impl<A> Foo<A> { .. }` or `impl<A> Trait for Foo<A> { .. }`"}, {"sha": "ded493fe3958c4f57a8e32db2e11a74646e08f4a", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -1446,17 +1446,12 @@ impl HasAttrs for Stmt {\n \n impl HasAttrs for GenericParam {\n     fn attrs(&self) -> &[ast::Attribute] {\n-        match self {\n-            GenericParam::Lifetime(lifetime) => lifetime.attrs(),\n-            GenericParam::Type(ty) => ty.attrs(),\n-        }\n+        &self.attrs\n     }\n \n-    fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(self, f: F) -> Self {\n-        match self {\n-            GenericParam::Lifetime(lifetime) => GenericParam::Lifetime(lifetime.map_attrs(f)),\n-            GenericParam::Type(ty) => GenericParam::Type(ty.map_attrs(f)),\n-        }\n+    fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(mut self, f: F) -> Self {\n+        self.attrs = self.attrs.map_attrs(f);\n+        self\n     }\n }\n \n@@ -1479,5 +1474,5 @@ macro_rules! derive_has_attrs {\n \n derive_has_attrs! {\n     Item, Expr, Local, ast::ForeignItem, ast::StructField, ast::ImplItem, ast::TraitItem, ast::Arm,\n-    ast::Field, ast::FieldPat, ast::Variant_, ast::LifetimeDef, ast::TyParam\n+    ast::Field, ast::FieldPat, ast::Variant_\n }"}, {"sha": "9044cab05d667f08d70b186d8aae85e569ec349a", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 38, "deletions": 37, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -30,10 +30,9 @@ pub trait AstBuilder {\n     fn path_global(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path;\n     fn path_all(&self, sp: Span,\n                 global: bool,\n-                idents: Vec<ast::Ident> ,\n-                lifetimes: Vec<ast::Lifetime>,\n-                types: Vec<P<ast::Ty>>,\n-                bindings: Vec<ast::TypeBinding> )\n+                idents: Vec<ast::Ident>,\n+                args: Vec<ast::GenericArg>,\n+                bindings: Vec<ast::TypeBinding>)\n         -> ast::Path;\n \n     fn qpath(&self, self_type: P<ast::Ty>,\n@@ -43,8 +42,7 @@ pub trait AstBuilder {\n     fn qpath_all(&self, self_type: P<ast::Ty>,\n                 trait_path: ast::Path,\n                 ident: ast::Ident,\n-                lifetimes: Vec<ast::Lifetime>,\n-                types: Vec<P<ast::Ty>>,\n+                args: Vec<ast::GenericArg>,\n                 bindings: Vec<ast::TypeBinding>)\n                 -> (ast::QSelf, ast::Path);\n \n@@ -70,19 +68,19 @@ pub trait AstBuilder {\n                span: Span,\n                id: ast::Ident,\n                attrs: Vec<ast::Attribute>,\n-               bounds: ast::TyParamBounds,\n-               default: Option<P<ast::Ty>>) -> ast::TyParam;\n+               bounds: ast::GenericBounds,\n+               default: Option<P<ast::Ty>>) -> ast::GenericParam;\n \n     fn trait_ref(&self, path: ast::Path) -> ast::TraitRef;\n     fn poly_trait_ref(&self, span: Span, path: ast::Path) -> ast::PolyTraitRef;\n-    fn typarambound(&self, path: ast::Path) -> ast::TyParamBound;\n+    fn trait_bound(&self, path: ast::Path) -> ast::GenericBound;\n     fn lifetime(&self, span: Span, ident: ast::Ident) -> ast::Lifetime;\n     fn lifetime_def(&self,\n                     span: Span,\n                     ident: ast::Ident,\n                     attrs: Vec<ast::Attribute>,\n-                    bounds: Vec<ast::Lifetime>)\n-                    -> ast::LifetimeDef;\n+                    bounds: ast::GenericBounds)\n+                    -> ast::GenericParam;\n \n     // statements\n     fn stmt_expr(&self, expr: P<ast::Expr>) -> ast::Stmt;\n@@ -304,34 +302,33 @@ pub trait AstBuilder {\n \n impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn path(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path {\n-        self.path_all(span, false, strs, Vec::new(), Vec::new(), Vec::new())\n+        self.path_all(span, false, strs, vec![], vec![])\n     }\n     fn path_ident(&self, span: Span, id: ast::Ident) -> ast::Path {\n         self.path(span, vec![id])\n     }\n     fn path_global(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path {\n-        self.path_all(span, true, strs, Vec::new(), Vec::new(), Vec::new())\n+        self.path_all(span, true, strs, vec![], vec![])\n     }\n     fn path_all(&self,\n                 span: Span,\n                 global: bool,\n                 mut idents: Vec<ast::Ident> ,\n-                lifetimes: Vec<ast::Lifetime>,\n-                types: Vec<P<ast::Ty>>,\n+                args: Vec<ast::GenericArg>,\n                 bindings: Vec<ast::TypeBinding> )\n                 -> ast::Path {\n         let last_ident = idents.pop().unwrap();\n-        let mut segments: Vec<ast::PathSegment> = Vec::new();\n+        let mut segments: Vec<ast::PathSegment> = vec![];\n \n         segments.extend(idents.into_iter().map(|ident| {\n             ast::PathSegment::from_ident(ident.with_span_pos(span))\n         }));\n-        let parameters = if !lifetimes.is_empty() || !types.is_empty() || !bindings.is_empty() {\n-            ast::AngleBracketedParameterData { lifetimes, types, bindings, span }.into()\n+        let args = if !args.is_empty() || !bindings.is_empty() {\n+            ast::AngleBracketedArgs { args, bindings, span }.into()\n         } else {\n             None\n         };\n-        segments.push(ast::PathSegment { ident: last_ident.with_span_pos(span), parameters });\n+        segments.push(ast::PathSegment { ident: last_ident.with_span_pos(span), args });\n         let mut path = ast::Path { span, segments };\n         if global {\n             if let Some(seg) = path.make_root() {\n@@ -349,7 +346,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n              trait_path: ast::Path,\n              ident: ast::Ident)\n              -> (ast::QSelf, ast::Path) {\n-        self.qpath_all(self_type, trait_path, ident, vec![], vec![], vec![])\n+        self.qpath_all(self_type, trait_path, ident, vec![], vec![])\n     }\n \n     /// Constructs a qualified path.\n@@ -359,17 +356,16 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                  self_type: P<ast::Ty>,\n                  trait_path: ast::Path,\n                  ident: ast::Ident,\n-                 lifetimes: Vec<ast::Lifetime>,\n-                 types: Vec<P<ast::Ty>>,\n+                 args: Vec<ast::GenericArg>,\n                  bindings: Vec<ast::TypeBinding>)\n                  -> (ast::QSelf, ast::Path) {\n         let mut path = trait_path;\n-        let parameters = if !lifetimes.is_empty() || !types.is_empty() || !bindings.is_empty() {\n-            ast::AngleBracketedParameterData { lifetimes, types, bindings, span: ident.span }.into()\n+        let args = if !args.is_empty() || !bindings.is_empty() {\n+            ast::AngleBracketedArgs { args, bindings, span: ident.span }.into()\n         } else {\n             None\n         };\n-        path.segments.push(ast::PathSegment { ident, parameters });\n+        path.segments.push(ast::PathSegment { ident, args });\n \n         (ast::QSelf {\n             ty: self_type,\n@@ -428,8 +424,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             self.path_all(DUMMY_SP,\n                           true,\n                           self.std_path(&[\"option\", \"Option\"]),\n-                          Vec::new(),\n-                          vec![ ty ],\n+                          vec![ast::GenericArg::Type(ty)],\n                           Vec::new()))\n     }\n \n@@ -441,14 +436,16 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                span: Span,\n                ident: ast::Ident,\n                attrs: Vec<ast::Attribute>,\n-               bounds: ast::TyParamBounds,\n-               default: Option<P<ast::Ty>>) -> ast::TyParam {\n-        ast::TyParam {\n+               bounds: ast::GenericBounds,\n+               default: Option<P<ast::Ty>>) -> ast::GenericParam {\n+        ast::GenericParam {\n             ident: ident.with_span_pos(span),\n             id: ast::DUMMY_NODE_ID,\n             attrs: attrs.into(),\n             bounds,\n-            default,\n+            kind: ast::GenericParamKind::Type {\n+                default,\n+            }\n         }\n     }\n \n@@ -467,8 +464,9 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         }\n     }\n \n-    fn typarambound(&self, path: ast::Path) -> ast::TyParamBound {\n-        ast::TraitTyParamBound(self.poly_trait_ref(path.span, path), ast::TraitBoundModifier::None)\n+    fn trait_bound(&self, path: ast::Path) -> ast::GenericBound {\n+        ast::GenericBound::Trait(self.poly_trait_ref(path.span, path),\n+                                 ast::TraitBoundModifier::None)\n     }\n \n     fn lifetime(&self, span: Span, ident: ast::Ident) -> ast::Lifetime {\n@@ -479,12 +477,15 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                     span: Span,\n                     ident: ast::Ident,\n                     attrs: Vec<ast::Attribute>,\n-                    bounds: Vec<ast::Lifetime>)\n-                    -> ast::LifetimeDef {\n-        ast::LifetimeDef {\n+                    bounds: ast::GenericBounds)\n+                    -> ast::GenericParam {\n+        let lifetime = self.lifetime(span, ident);\n+        ast::GenericParam {\n+            ident: lifetime.ident,\n+            id: lifetime.id,\n             attrs: attrs.into(),\n-            lifetime: self.lifetime(span, ident),\n             bounds,\n+            kind: ast::GenericParamKind::Lifetime,\n         }\n     }\n "}, {"sha": "be4cf197be4eb2c569abe0511cf99e6ee1bdd207", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -1797,7 +1797,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                     gate_feature_post!(&self, associated_type_defaults, ti.span,\n                                        \"associated type defaults are unstable\");\n                 }\n-                if ti.generics.is_parameterized() {\n+                if !ti.generics.params.is_empty() {\n                     gate_feature_post!(&self, generic_associated_types, ti.span,\n                                        \"generic associated types are unstable\");\n                 }\n@@ -1824,7 +1824,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                     gate_feature_post!(&self, const_fn, ii.span, \"const fn is unstable\");\n                 }\n             }\n-            ast::ImplItemKind::Type(_) if ii.generics.is_parameterized() => {\n+            ast::ImplItemKind::Type(_) if !ii.generics.params.is_empty() => {\n                 gate_feature_post!(&self, generic_associated_types, ii.span,\n                                    \"generic associated types are unstable\");\n             }"}, {"sha": "93248fe3bfab0a0ac8971755f3fa73314f0c7c5b", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 77, "deletions": 82, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -132,10 +132,21 @@ pub trait Folder : Sized {\n         noop_fold_exprs(es, self)\n     }\n \n+    fn fold_generic_arg(&mut self, arg: GenericArg) -> GenericArg {\n+        match arg {\n+            GenericArg::Lifetime(lt) => GenericArg::Lifetime(self.fold_lifetime(lt)),\n+            GenericArg::Type(ty) => GenericArg::Type(self.fold_ty(ty)),\n+        }\n+    }\n+\n     fn fold_ty(&mut self, t: P<Ty>) -> P<Ty> {\n         noop_fold_ty(t, self)\n     }\n \n+    fn fold_lifetime(&mut self, l: Lifetime) -> Lifetime {\n+        noop_fold_lifetime(l, self)\n+    }\n+\n     fn fold_ty_binding(&mut self, t: TypeBinding) -> TypeBinding {\n         noop_fold_ty_binding(t, self)\n     }\n@@ -172,18 +183,18 @@ pub trait Folder : Sized {\n         noop_fold_qpath(qs, p, self)\n     }\n \n-    fn fold_path_parameters(&mut self, p: PathParameters) -> PathParameters {\n-        noop_fold_path_parameters(p, self)\n+    fn fold_generic_args(&mut self, p: GenericArgs) -> GenericArgs {\n+        noop_fold_generic_args(p, self)\n     }\n \n-    fn fold_angle_bracketed_parameter_data(&mut self, p: AngleBracketedParameterData)\n-                                           -> AngleBracketedParameterData\n+    fn fold_angle_bracketed_parameter_data(&mut self, p: AngleBracketedArgs)\n+                                           -> AngleBracketedArgs\n     {\n         noop_fold_angle_bracketed_parameter_data(p, self)\n     }\n \n-    fn fold_parenthesized_parameter_data(&mut self, p: ParenthesizedParameterData)\n-                                         -> ParenthesizedParameterData\n+    fn fold_parenthesized_parameter_data(&mut self, p: ParenthesisedArgs)\n+                                         -> ParenthesisedArgs\n     {\n         noop_fold_parenthesized_parameter_data(p, self)\n     }\n@@ -233,10 +244,6 @@ pub trait Folder : Sized {\n         noop_fold_variant_data(vdata, self)\n     }\n \n-    fn fold_ty_param(&mut self, tp: TyParam) -> TyParam {\n-        noop_fold_ty_param(tp, self)\n-    }\n-\n     fn fold_generic_param(&mut self, param: GenericParam) -> GenericParam {\n         noop_fold_generic_param(param, self)\n     }\n@@ -261,18 +268,16 @@ pub trait Folder : Sized {\n         noop_fold_interpolated(nt, self)\n     }\n \n-    fn fold_opt_bounds(&mut self, b: Option<TyParamBounds>)\n-                       -> Option<TyParamBounds> {\n+    fn fold_opt_bounds(&mut self, b: Option<GenericBounds>) -> Option<GenericBounds> {\n         noop_fold_opt_bounds(b, self)\n     }\n \n-    fn fold_bounds(&mut self, b: TyParamBounds)\n-                       -> TyParamBounds {\n+    fn fold_bounds(&mut self, b: GenericBounds) -> GenericBounds {\n         noop_fold_bounds(b, self)\n     }\n \n-    fn fold_ty_param_bound(&mut self, tpb: TyParamBound) -> TyParamBound {\n-        noop_fold_ty_param_bound(tpb, self)\n+    fn fold_param_bound(&mut self, tpb: GenericBound) -> GenericBound {\n+        noop_fold_param_bound(tpb, self)\n     }\n \n     fn fold_mt(&mut self, mt: MutTy) -> MutTy {\n@@ -385,10 +390,10 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n                 TyKind::Typeof(fld.fold_anon_const(expr))\n             }\n             TyKind::TraitObject(bounds, syntax) => {\n-                TyKind::TraitObject(bounds.move_map(|b| fld.fold_ty_param_bound(b)), syntax)\n+                TyKind::TraitObject(bounds.move_map(|b| fld.fold_param_bound(b)), syntax)\n             }\n             TyKind::ImplTrait(bounds) => {\n-                TyKind::ImplTrait(bounds.move_map(|b| fld.fold_ty_param_bound(b)))\n+                TyKind::ImplTrait(bounds.move_map(|b| fld.fold_param_bound(b)))\n             }\n             TyKind::Mac(mac) => {\n                 TyKind::Mac(fld.fold_mac(mac))\n@@ -433,9 +438,9 @@ pub fn noop_fold_usize<T: Folder>(i: usize, _: &mut T) -> usize {\n \n pub fn noop_fold_path<T: Folder>(Path { segments, span }: Path, fld: &mut T) -> Path {\n     Path {\n-        segments: segments.move_map(|PathSegment {ident, parameters}| PathSegment {\n+        segments: segments.move_map(|PathSegment { ident, args }| PathSegment {\n             ident: fld.fold_ident(ident),\n-            parameters: parameters.map(|ps| ps.map(|ps| fld.fold_path_parameters(ps))),\n+            args: args.map(|args| args.map(|args| fld.fold_generic_args(args))),\n         }),\n         span: fld.new_span(span)\n     }\n@@ -454,36 +459,40 @@ pub fn noop_fold_qpath<T: Folder>(qself: Option<QSelf>,\n     (qself, fld.fold_path(path))\n }\n \n-pub fn noop_fold_path_parameters<T: Folder>(path_parameters: PathParameters, fld: &mut T)\n-                                            -> PathParameters\n+pub fn noop_fold_generic_args<T: Folder>(generic_args: GenericArgs, fld: &mut T) -> GenericArgs\n {\n-    match path_parameters {\n-        PathParameters::AngleBracketed(data) =>\n-            PathParameters::AngleBracketed(fld.fold_angle_bracketed_parameter_data(data)),\n-        PathParameters::Parenthesized(data) =>\n-            PathParameters::Parenthesized(fld.fold_parenthesized_parameter_data(data)),\n+    match generic_args {\n+        GenericArgs::AngleBracketed(data) => {\n+            GenericArgs::AngleBracketed(fld.fold_angle_bracketed_parameter_data(data))\n+        }\n+        GenericArgs::Parenthesized(data) => {\n+            GenericArgs::Parenthesized(fld.fold_parenthesized_parameter_data(data))\n+        }\n     }\n }\n \n-pub fn noop_fold_angle_bracketed_parameter_data<T: Folder>(data: AngleBracketedParameterData,\n+pub fn noop_fold_angle_bracketed_parameter_data<T: Folder>(data: AngleBracketedArgs,\n                                                            fld: &mut T)\n-                                                           -> AngleBracketedParameterData\n+                                                           -> AngleBracketedArgs\n {\n-    let AngleBracketedParameterData { lifetimes, types, bindings, span } = data;\n-    AngleBracketedParameterData { lifetimes: lifetimes.move_map(|l| noop_fold_lifetime(l, fld)),\n-                                  types: types.move_map(|ty| fld.fold_ty(ty)),\n-                                  bindings: bindings.move_map(|b| fld.fold_ty_binding(b)),\n-                                  span: fld.new_span(span) }\n+    let AngleBracketedArgs { args, bindings, span } = data;\n+    AngleBracketedArgs {\n+        args: args.move_map(|arg| fld.fold_generic_arg(arg)),\n+        bindings: bindings.move_map(|b| fld.fold_ty_binding(b)),\n+        span: fld.new_span(span)\n+    }\n }\n \n-pub fn noop_fold_parenthesized_parameter_data<T: Folder>(data: ParenthesizedParameterData,\n+pub fn noop_fold_parenthesized_parameter_data<T: Folder>(data: ParenthesisedArgs,\n                                                          fld: &mut T)\n-                                                         -> ParenthesizedParameterData\n+                                                         -> ParenthesisedArgs\n {\n-    let ParenthesizedParameterData { inputs, output, span } = data;\n-    ParenthesizedParameterData { inputs: inputs.move_map(|ty| fld.fold_ty(ty)),\n-                                 output: output.map(|ty| fld.fold_ty(ty)),\n-                                 span: fld.new_span(span) }\n+    let ParenthesisedArgs { inputs, output, span } = data;\n+    ParenthesisedArgs {\n+        inputs: inputs.move_map(|ty| fld.fold_ty(ty)),\n+        output: output.map(|ty| fld.fold_ty(ty)),\n+        span: fld.new_span(span)\n+    }\n }\n \n pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n@@ -667,47 +676,33 @@ pub fn noop_fold_fn_decl<T: Folder>(decl: P<FnDecl>, fld: &mut T) -> P<FnDecl> {\n     })\n }\n \n-pub fn noop_fold_ty_param_bound<T>(tpb: TyParamBound, fld: &mut T)\n-                                   -> TyParamBound\n-                                   where T: Folder {\n-    match tpb {\n-        TraitTyParamBound(ty, modifier) => TraitTyParamBound(fld.fold_poly_trait_ref(ty), modifier),\n-        RegionTyParamBound(lifetime) => RegionTyParamBound(noop_fold_lifetime(lifetime, fld)),\n-    }\n-}\n-\n-pub fn noop_fold_ty_param<T: Folder>(tp: TyParam, fld: &mut T) -> TyParam {\n-    let TyParam {attrs, id, ident, bounds, default} = tp;\n-    let attrs: Vec<_> = attrs.into();\n-    TyParam {\n-        attrs: attrs.into_iter()\n-            .flat_map(|x| fld.fold_attribute(x).into_iter())\n-            .collect::<Vec<_>>()\n-            .into(),\n-        id: fld.new_id(id),\n-        ident: fld.fold_ident(ident),\n-        bounds: fld.fold_bounds(bounds),\n-        default: default.map(|x| fld.fold_ty(x)),\n+pub fn noop_fold_param_bound<T>(pb: GenericBound, fld: &mut T) -> GenericBound where T: Folder {\n+    match pb {\n+        GenericBound::Trait(ty, modifier) => {\n+            GenericBound::Trait(fld.fold_poly_trait_ref(ty), modifier)\n+        }\n+        GenericBound::Outlives(lifetime) => {\n+            GenericBound::Outlives(noop_fold_lifetime(lifetime, fld))\n+        }\n     }\n }\n \n pub fn noop_fold_generic_param<T: Folder>(param: GenericParam, fld: &mut T) -> GenericParam {\n-    match param {\n-        GenericParam::Lifetime(l) => {\n-            let attrs: Vec<_> = l.attrs.into();\n-            GenericParam::Lifetime(LifetimeDef {\n-                attrs: attrs.into_iter()\n+    let attrs: Vec<_> = param.attrs.into();\n+    GenericParam {\n+        ident: fld.fold_ident(param.ident),\n+        id: fld.new_id(param.id),\n+        attrs: attrs.into_iter()\n                     .flat_map(|x| fld.fold_attribute(x).into_iter())\n                     .collect::<Vec<_>>()\n                     .into(),\n-                lifetime: Lifetime {\n-                    id: fld.new_id(l.lifetime.id),\n-                    ident: fld.fold_ident(l.lifetime.ident),\n-                },\n-                bounds: l.bounds.move_map(|l| noop_fold_lifetime(l, fld)),\n-            })\n+        bounds: param.bounds.move_map(|l| noop_fold_param_bound(l, fld)),\n+        kind: match param.kind {\n+            GenericParamKind::Lifetime => GenericParamKind::Lifetime,\n+            GenericParamKind::Type { default } => GenericParamKind::Type {\n+                default: default.map(|ty| fld.fold_ty(ty))\n+            }\n         }\n-        GenericParam::Type(t) => GenericParam::Type(fld.fold_ty_param(t)),\n     }\n }\n \n@@ -765,7 +760,7 @@ pub fn noop_fold_where_predicate<T: Folder>(\n             ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n                 bound_generic_params: fld.fold_generic_params(bound_generic_params),\n                 bounded_ty: fld.fold_ty(bounded_ty),\n-                bounds: bounds.move_map(|x| fld.fold_ty_param_bound(x)),\n+                bounds: bounds.move_map(|x| fld.fold_param_bound(x)),\n                 span: fld.new_span(span)\n             })\n         }\n@@ -775,7 +770,7 @@ pub fn noop_fold_where_predicate<T: Folder>(\n             ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate {\n                 span: fld.new_span(span),\n                 lifetime: noop_fold_lifetime(lifetime, fld),\n-                bounds: bounds.move_map(|bound| noop_fold_lifetime(bound, fld))\n+                bounds: bounds.move_map(|bound| noop_fold_param_bound(bound, fld))\n             })\n         }\n         ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{id,\n@@ -854,14 +849,14 @@ pub fn noop_fold_mt<T: Folder>(MutTy {ty, mutbl}: MutTy, folder: &mut T) -> MutT\n     }\n }\n \n-pub fn noop_fold_opt_bounds<T: Folder>(b: Option<TyParamBounds>, folder: &mut T)\n-                                       -> Option<TyParamBounds> {\n+pub fn noop_fold_opt_bounds<T: Folder>(b: Option<GenericBounds>, folder: &mut T)\n+                                       -> Option<GenericBounds> {\n     b.map(|bounds| folder.fold_bounds(bounds))\n }\n \n-fn noop_fold_bounds<T: Folder>(bounds: TyParamBounds, folder: &mut T)\n-                          -> TyParamBounds {\n-    bounds.move_map(|bound| folder.fold_ty_param_bound(bound))\n+fn noop_fold_bounds<T: Folder>(bounds: GenericBounds, folder: &mut T)\n+                          -> GenericBounds {\n+    bounds.move_map(|bound| folder.fold_param_bound(bound))\n }\n \n pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n@@ -1184,8 +1179,8 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                 ExprKind::MethodCall(\n                     PathSegment {\n                         ident: folder.fold_ident(seg.ident),\n-                        parameters: seg.parameters.map(|ps| {\n-                            ps.map(|ps| folder.fold_path_parameters(ps))\n+                        args: seg.args.map(|args| {\n+                            args.map(|args| folder.fold_generic_args(args))\n                         }),\n                     },\n                     folder.fold_exprs(args))"}, {"sha": "6f78ae9ebca5dd0c2d7f22d1f7c2272ce945b4cb", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 62, "deletions": 63, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n use rustc_target::spec::abi::{self, Abi};\n-use ast::{AngleBracketedParameterData, ParenthesizedParameterData, AttrStyle, BareFnTy};\n-use ast::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n+use ast::{AngleBracketedArgs, ParenthesisedArgs, AttrStyle, BareFnTy};\n+use ast::{GenericBound, TraitBoundModifier};\n use ast::Unsafety;\n use ast::{Mod, AnonConst, Arg, Arm, Attribute, BindingMode, TraitItemKind};\n use ast::Block;\n@@ -21,9 +21,10 @@ use ast::EnumDef;\n use ast::{Expr, ExprKind, RangeLimits};\n use ast::{Field, FnDecl};\n use ast::{ForeignItem, ForeignItemKind, FunctionRetTy};\n-use ast::GenericParam;\n+use ast::{GenericParam, GenericParamKind};\n+use ast::GenericArg;\n use ast::{Ident, ImplItem, IsAuto, Item, ItemKind};\n-use ast::{Label, Lifetime, LifetimeDef, Lit, LitKind};\n+use ast::{Label, Lifetime, Lit, LitKind};\n use ast::Local;\n use ast::MacStmtStyle;\n use ast::{Mac, Mac_, MacDelimiter};\n@@ -35,7 +36,7 @@ use ast::{VariantData, StructField};\n use ast::StrStyle;\n use ast::SelfKind;\n use ast::{TraitItem, TraitRef, TraitObjectSyntax};\n-use ast::{Ty, TyKind, TypeBinding, TyParam, TyParamBounds};\n+use ast::{Ty, TyKind, TypeBinding, GenericBounds};\n use ast::{Visibility, VisibilityKind, WhereClause, CrateSugar};\n use ast::{UseTree, UseTreeKind};\n use ast::{BinOpKind, UnOp};\n@@ -1245,8 +1246,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// parse a TyKind::BareFn type:\n-    fn parse_ty_bare_fn(&mut self, generic_params: Vec<GenericParam>)\n-                            -> PResult<'a, TyKind> {\n+    fn parse_ty_bare_fn(&mut self, generic_params: Vec<GenericParam>) -> PResult<'a, TyKind> {\n         /*\n \n         [unsafe] [extern \"ABI\"] fn (S) -> T\n@@ -1311,9 +1311,7 @@ impl<'a> Parser<'a> {\n         let lo = self.span;\n \n         let (name, node, generics) = if self.eat_keyword(keywords::Type) {\n-            let (generics, TyParam {ident, bounds, default, ..}) =\n-                self.parse_trait_item_assoc_ty(vec![])?;\n-            (ident, TraitItemKind::Type(bounds, default), generics)\n+            self.parse_trait_item_assoc_ty()?\n         } else if self.is_const_item() {\n             self.expect_keyword(keywords::Const)?;\n             let ident = self.parse_ident()?;\n@@ -1446,7 +1444,7 @@ impl<'a> Parser<'a> {\n                     TyKind::TraitObject(ref bounds, TraitObjectSyntax::None)\n                             if maybe_bounds && bounds.len() == 1 && !trailing_plus => {\n                         let path = match bounds[0] {\n-                            TraitTyParamBound(ref pt, ..) => pt.trait_ref.path.clone(),\n+                            GenericBound::Trait(ref pt, ..) => pt.trait_ref.path.clone(),\n                             _ => self.bug(\"unexpected lifetime bound\"),\n                         };\n                         self.parse_remaining_bounds(Vec::new(), path, lo, true)?\n@@ -1511,21 +1509,21 @@ impl<'a> Parser<'a> {\n             }\n         } else if self.eat_keyword(keywords::Impl) {\n             // Always parse bounds greedily for better error recovery.\n-            let bounds = self.parse_ty_param_bounds()?;\n+            let bounds = self.parse_generic_bounds()?;\n             impl_dyn_multi = bounds.len() > 1 || self.prev_token_kind == PrevTokenKind::Plus;\n             TyKind::ImplTrait(bounds)\n         } else if self.check_keyword(keywords::Dyn) &&\n                   self.look_ahead(1, |t| t.can_begin_bound() &&\n                                          !can_continue_type_after_non_fn_ident(t)) {\n             self.bump(); // `dyn`\n             // Always parse bounds greedily for better error recovery.\n-            let bounds = self.parse_ty_param_bounds()?;\n+            let bounds = self.parse_generic_bounds()?;\n             impl_dyn_multi = bounds.len() > 1 || self.prev_token_kind == PrevTokenKind::Plus;\n             TyKind::TraitObject(bounds, TraitObjectSyntax::Dyn)\n         } else if self.check(&token::Question) ||\n                   self.check_lifetime() && self.look_ahead(1, |t| t.is_like_plus()) {\n             // Bound list (trait object type)\n-            TyKind::TraitObject(self.parse_ty_param_bounds_common(allow_plus)?,\n+            TyKind::TraitObject(self.parse_generic_bounds_common(allow_plus)?,\n                                 TraitObjectSyntax::None)\n         } else if self.eat_lt() {\n             // Qualified path\n@@ -1568,10 +1566,10 @@ impl<'a> Parser<'a> {\n     fn parse_remaining_bounds(&mut self, generic_params: Vec<GenericParam>, path: ast::Path,\n                               lo: Span, parse_plus: bool) -> PResult<'a, TyKind> {\n         let poly_trait_ref = PolyTraitRef::new(generic_params, path, lo.to(self.prev_span));\n-        let mut bounds = vec![TraitTyParamBound(poly_trait_ref, TraitBoundModifier::None)];\n+        let mut bounds = vec![GenericBound::Trait(poly_trait_ref, TraitBoundModifier::None)];\n         if parse_plus {\n             self.eat_plus(); // `+`, or `+=` gets split and `+` is discarded\n-            bounds.append(&mut self.parse_ty_param_bounds()?);\n+            bounds.append(&mut self.parse_generic_bounds()?);\n         }\n         Ok(TyKind::TraitObject(bounds, TraitObjectSyntax::None))\n     }\n@@ -1596,7 +1594,7 @@ impl<'a> Parser<'a> {\n         }\n \n         self.bump(); // `+`\n-        let bounds = self.parse_ty_param_bounds()?;\n+        let bounds = self.parse_generic_bounds()?;\n         let sum_span = ty.span.to(self.prev_span);\n \n         let mut err = struct_span_err!(self.sess.span_diagnostic, sum_span, E0178,\n@@ -1612,7 +1610,7 @@ impl<'a> Parser<'a> {\n                     s.print_mutability(mut_ty.mutbl)?;\n                     s.popen()?;\n                     s.print_type(&mut_ty.ty)?;\n-                    s.print_bounds(\" +\", &bounds)?;\n+                    s.print_type_bounds(\" +\", &bounds)?;\n                     s.pclose()\n                 });\n                 err.span_suggestion_with_applicability(\n@@ -1894,7 +1892,7 @@ impl<'a> Parser<'a> {\n                              -> PResult<'a, ast::Path> {\n         maybe_whole!(self, NtPath, |path| {\n             if style == PathStyle::Mod &&\n-               path.segments.iter().any(|segment| segment.parameters.is_some()) {\n+               path.segments.iter().any(|segment| segment.args.is_some()) {\n                 self.diagnostic().span_err(path.span, \"unexpected generic arguments in path\");\n             }\n             path\n@@ -1969,12 +1967,12 @@ impl<'a> Parser<'a> {\n                                  .span_label(self.prev_span, \"try removing `::`\").emit();\n             }\n \n-            let parameters = if self.eat_lt() {\n+            let args = if self.eat_lt() {\n                 // `<'a, T, A = U>`\n-                let (lifetimes, types, bindings) = self.parse_generic_args()?;\n+                let (args, bindings) = self.parse_generic_args()?;\n                 self.expect_gt()?;\n                 let span = lo.to(self.prev_span);\n-                AngleBracketedParameterData { lifetimes, types, bindings, span }.into()\n+                AngleBracketedArgs { args, bindings, span }.into()\n             } else {\n                 // `(T, U) -> R`\n                 self.bump(); // `(`\n@@ -1990,10 +1988,10 @@ impl<'a> Parser<'a> {\n                     None\n                 };\n                 let span = lo.to(self.prev_span);\n-                ParenthesizedParameterData { inputs, output, span }.into()\n+                ParenthesisedArgs { inputs, output, span }.into()\n             };\n \n-            PathSegment { ident, parameters }\n+            PathSegment { ident, args }\n         } else {\n             // Generic arguments are not found.\n             PathSegment::from_ident(ident)\n@@ -2543,8 +2541,8 @@ impl<'a> Parser<'a> {\n             }\n             _ => {\n                 // Field access `expr.f`\n-                if let Some(parameters) = segment.parameters {\n-                    self.span_err(parameters.span(),\n+                if let Some(args) = segment.args {\n+                    self.span_err(args.span(),\n                                   \"field expressions may not have generic arguments\");\n                 }\n \n@@ -4737,7 +4735,7 @@ impl<'a> Parser<'a> {\n     // LT_BOUND = LIFETIME (e.g. `'a`)\n     // TY_BOUND = TY_BOUND_NOPAREN | (TY_BOUND_NOPAREN)\n     // TY_BOUND_NOPAREN = [?] [for<LT_PARAM_DEFS>] SIMPLE_PATH (e.g. `?for<'a: 'b> m::Trait<'a>`)\n-    fn parse_ty_param_bounds_common(&mut self, allow_plus: bool) -> PResult<'a, TyParamBounds> {\n+    fn parse_generic_bounds_common(&mut self, allow_plus: bool) -> PResult<'a, GenericBounds> {\n         let mut bounds = Vec::new();\n         loop {\n             // This needs to be syncronized with `Token::can_begin_bound`.\n@@ -4754,7 +4752,7 @@ impl<'a> Parser<'a> {\n                         self.span_err(question_span,\n                                       \"`?` may only modify trait bounds, not lifetime bounds\");\n                     }\n-                    bounds.push(RegionTyParamBound(self.expect_lifetime()));\n+                    bounds.push(GenericBound::Outlives(self.expect_lifetime()));\n                     if has_parens {\n                         self.expect(&token::CloseDelim(token::Paren))?;\n                         self.span_err(self.prev_span,\n@@ -4772,7 +4770,7 @@ impl<'a> Parser<'a> {\n                     } else {\n                         TraitBoundModifier::None\n                     };\n-                    bounds.push(TraitTyParamBound(poly_trait, modifier));\n+                    bounds.push(GenericBound::Trait(poly_trait, modifier));\n                 }\n             } else {\n                 break\n@@ -4786,16 +4784,16 @@ impl<'a> Parser<'a> {\n         return Ok(bounds);\n     }\n \n-    fn parse_ty_param_bounds(&mut self) -> PResult<'a, TyParamBounds> {\n-        self.parse_ty_param_bounds_common(true)\n+    fn parse_generic_bounds(&mut self) -> PResult<'a, GenericBounds> {\n+        self.parse_generic_bounds_common(true)\n     }\n \n     // Parse bounds of a lifetime parameter `BOUND + BOUND + BOUND`, possibly with trailing `+`.\n     // BOUND = LT_BOUND (e.g. `'a`)\n-    fn parse_lt_param_bounds(&mut self) -> Vec<Lifetime> {\n+    fn parse_lt_param_bounds(&mut self) -> GenericBounds {\n         let mut lifetimes = Vec::new();\n         while self.check_lifetime() {\n-            lifetimes.push(self.expect_lifetime());\n+            lifetimes.push(ast::GenericBound::Outlives(self.expect_lifetime()));\n \n             if !self.eat_plus() {\n                 break\n@@ -4805,12 +4803,14 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Matches typaram = IDENT (`?` unbound)? optbounds ( EQ ty )?\n-    fn parse_ty_param(&mut self, preceding_attrs: Vec<Attribute>) -> PResult<'a, TyParam> {\n+    fn parse_ty_param(&mut self,\n+                      preceding_attrs: Vec<Attribute>)\n+                      -> PResult<'a, GenericParam> {\n         let ident = self.parse_ident()?;\n \n         // Parse optional colon and param bounds.\n         let bounds = if self.eat(&token::Colon) {\n-            self.parse_ty_param_bounds()?\n+            self.parse_generic_bounds()?\n         } else {\n             Vec::new()\n         };\n@@ -4821,25 +4821,27 @@ impl<'a> Parser<'a> {\n             None\n         };\n \n-        Ok(TyParam {\n-            attrs: preceding_attrs.into(),\n+        Ok(GenericParam {\n             ident,\n             id: ast::DUMMY_NODE_ID,\n+            attrs: preceding_attrs.into(),\n             bounds,\n-            default,\n+            kind: GenericParamKind::Type {\n+                default,\n+            }\n         })\n     }\n \n     /// Parses the following grammar:\n-    ///     TraitItemAssocTy = Ident [\"<\"...\">\"] [\":\" [TyParamBounds]] [\"where\" ...] [\"=\" Ty]\n-    fn parse_trait_item_assoc_ty(&mut self, preceding_attrs: Vec<Attribute>)\n-        -> PResult<'a, (ast::Generics, TyParam)> {\n+    ///     TraitItemAssocTy = Ident [\"<\"...\">\"] [\":\" [GenericBounds]] [\"where\" ...] [\"=\" Ty]\n+    fn parse_trait_item_assoc_ty(&mut self)\n+        -> PResult<'a, (Ident, TraitItemKind, ast::Generics)> {\n         let ident = self.parse_ident()?;\n         let mut generics = self.parse_generics()?;\n \n         // Parse optional colon and param bounds.\n         let bounds = if self.eat(&token::Colon) {\n-            self.parse_ty_param_bounds()?\n+            self.parse_generic_bounds()?\n         } else {\n             Vec::new()\n         };\n@@ -4852,13 +4854,7 @@ impl<'a> Parser<'a> {\n         };\n         self.expect(&token::Semi)?;\n \n-        Ok((generics, TyParam {\n-            attrs: preceding_attrs.into(),\n-            ident,\n-            id: ast::DUMMY_NODE_ID,\n-            bounds,\n-            default,\n-        }))\n+        Ok((ident, TraitItemKind::Type(bounds, default), generics))\n     }\n \n     /// Parses (possibly empty) list of lifetime and type parameters, possibly including\n@@ -4876,18 +4872,20 @@ impl<'a> Parser<'a> {\n                 } else {\n                     Vec::new()\n                 };\n-                params.push(ast::GenericParam::Lifetime(LifetimeDef {\n+                params.push(ast::GenericParam {\n+                    ident: lifetime.ident,\n+                    id: lifetime.id,\n                     attrs: attrs.into(),\n-                    lifetime,\n                     bounds,\n-                }));\n+                    kind: ast::GenericParamKind::Lifetime,\n+                });\n                 if seen_ty_param {\n                     self.span_err(self.prev_span,\n                         \"lifetime parameters must be declared prior to type parameters\");\n                 }\n             } else if self.check_ident() {\n                 // Parse type parameter.\n-                params.push(ast::GenericParam::Type(self.parse_ty_param(attrs)?));\n+                params.push(self.parse_ty_param(attrs)?);\n                 seen_ty_param = true;\n             } else {\n                 // Check for trailing attributes and stop parsing.\n@@ -4936,16 +4934,16 @@ impl<'a> Parser<'a> {\n \n     /// Parses (possibly empty) list of lifetime and type arguments and associated type bindings,\n     /// possibly including trailing comma.\n-    fn parse_generic_args(&mut self) -> PResult<'a, (Vec<Lifetime>, Vec<P<Ty>>, Vec<TypeBinding>)> {\n-        let mut lifetimes = Vec::new();\n-        let mut types = Vec::new();\n+    fn parse_generic_args(&mut self)\n+                          -> PResult<'a, (Vec<GenericArg>, Vec<TypeBinding>)> {\n+        let mut args = Vec::new();\n         let mut bindings = Vec::new();\n         let mut seen_type = false;\n         let mut seen_binding = false;\n         loop {\n             if self.check_lifetime() && self.look_ahead(1, |t| !t.is_like_plus()) {\n                 // Parse lifetime argument.\n-                lifetimes.push(self.expect_lifetime());\n+                args.push(GenericArg::Lifetime(self.expect_lifetime()));\n                 if seen_type || seen_binding {\n                     self.span_err(self.prev_span,\n                         \"lifetime parameters must be declared prior to type parameters\");\n@@ -4965,11 +4963,12 @@ impl<'a> Parser<'a> {\n                 seen_binding = true;\n             } else if self.check_type() {\n                 // Parse type argument.\n-                types.push(self.parse_ty()?);\n+                let ty_param = self.parse_ty()?;\n                 if seen_binding {\n-                    self.span_err(types[types.len() - 1].span,\n+                    self.span_err(ty_param.span,\n                         \"type parameters must be declared prior to associated type bindings\");\n                 }\n+                args.push(GenericArg::Type(ty_param));\n                 seen_type = true;\n             } else {\n                 break\n@@ -4979,7 +4978,7 @@ impl<'a> Parser<'a> {\n                 break\n             }\n         }\n-        Ok((lifetimes, types, bindings))\n+        Ok((args, bindings))\n     }\n \n     /// Parses an optional `where` clause and places it in `generics`.\n@@ -5037,7 +5036,7 @@ impl<'a> Parser<'a> {\n                 // or with mandatory equality sign and the second type.\n                 let ty = self.parse_ty()?;\n                 if self.eat(&token::Colon) {\n-                    let bounds = self.parse_ty_param_bounds()?;\n+                    let bounds = self.parse_generic_bounds()?;\n                     where_clause.predicates.push(ast::WherePredicate::BoundPredicate(\n                         ast::WhereBoundPredicate {\n                             span: lo.to(self.prev_span),\n@@ -5537,14 +5536,14 @@ impl<'a> Parser<'a> {\n \n         // Parse optional colon and supertrait bounds.\n         let bounds = if self.eat(&token::Colon) {\n-            self.parse_ty_param_bounds()?\n+            self.parse_generic_bounds()?\n         } else {\n             Vec::new()\n         };\n \n         if self.eat(&token::Eq) {\n             // it's a trait alias\n-            let bounds = self.parse_ty_param_bounds()?;\n+            let bounds = self.parse_generic_bounds()?;\n             tps.where_clause = self.parse_where_clause()?;\n             self.expect(&token::Semi)?;\n             if unsafety != Unsafety::Normal {"}, {"sha": "7a55919f422b88c70adc2b49f3e1bc2e2eb1f92a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 73, "deletions": 86, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -12,8 +12,8 @@ pub use self::AnnNode::*;\n \n use rustc_target::spec::abi::{self, Abi};\n use ast::{self, BlockCheckMode, PatKind, RangeEnd, RangeSyntax};\n-use ast::{SelfKind, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n-use ast::{Attribute, MacDelimiter};\n+use ast::{SelfKind, GenericBound, TraitBoundModifier};\n+use ast::{Attribute, MacDelimiter, GenericArg};\n use util::parser::{self, AssocOp, Fixity};\n use attr;\n use codemap::{self, CodeMap};\n@@ -292,8 +292,8 @@ pub fn ty_to_string(ty: &ast::Ty) -> String {\n     to_string(|s| s.print_type(ty))\n }\n \n-pub fn bounds_to_string(bounds: &[ast::TyParamBound]) -> String {\n-    to_string(|s| s.print_bounds(\"\", bounds))\n+pub fn bounds_to_string(bounds: &[ast::GenericBound]) -> String {\n+    to_string(|s| s.print_type_bounds(\"\", bounds))\n }\n \n pub fn pat_to_string(pat: &ast::Pat) -> String {\n@@ -308,8 +308,8 @@ pub fn expr_to_string(e: &ast::Expr) -> String {\n     to_string(|s| s.print_expr(e))\n }\n \n-pub fn lifetime_to_string(e: &ast::Lifetime) -> String {\n-    to_string(|s| s.print_lifetime(e))\n+pub fn lifetime_to_string(lt: &ast::Lifetime) -> String {\n+    to_string(|s| s.print_lifetime(*lt))\n }\n \n pub fn tt_to_string(tt: tokenstream::TokenTree) -> String {\n@@ -1008,15 +1008,21 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_opt_lifetime(&mut self,\n-                              lifetime: &Option<ast::Lifetime>) -> io::Result<()> {\n-        if let Some(l) = *lifetime {\n-            self.print_lifetime(&l)?;\n+    pub fn print_opt_lifetime(&mut self, lifetime: &Option<ast::Lifetime>) -> io::Result<()> {\n+        if let Some(lt) = *lifetime {\n+            self.print_lifetime(lt)?;\n             self.nbsp()?;\n         }\n         Ok(())\n     }\n \n+    pub fn print_generic_arg(&mut self, generic_arg: &GenericArg) -> io::Result<()> {\n+        match generic_arg {\n+            GenericArg::Lifetime(lt) => self.print_lifetime(*lt),\n+            GenericArg::Type(ty) => self.print_type(ty),\n+        }\n+    }\n+\n     pub fn print_type(&mut self, ty: &ast::Ty) -> io::Result<()> {\n         self.maybe_print_comment(ty.span.lo())?;\n         self.ibox(0)?;\n@@ -1071,10 +1077,10 @@ impl<'a> State<'a> {\n             }\n             ast::TyKind::TraitObject(ref bounds, syntax) => {\n                 let prefix = if syntax == ast::TraitObjectSyntax::Dyn { \"dyn\" } else { \"\" };\n-                self.print_bounds(prefix, &bounds[..])?;\n+                self.print_type_bounds(prefix, &bounds[..])?;\n             }\n             ast::TyKind::ImplTrait(ref bounds) => {\n-                self.print_bounds(\"impl\", &bounds[..])?;\n+                self.print_type_bounds(\"impl\", &bounds[..])?;\n             }\n             ast::TyKind::Array(ref ty, ref length) => {\n                 self.s.word(\"[\")?;\n@@ -1171,13 +1177,13 @@ impl<'a> State<'a> {\n \n     fn print_associated_type(&mut self,\n                              ident: ast::Ident,\n-                             bounds: Option<&ast::TyParamBounds>,\n+                             bounds: Option<&ast::GenericBounds>,\n                              ty: Option<&ast::Ty>)\n                              -> io::Result<()> {\n         self.word_space(\"type\")?;\n         self.print_ident(ident)?;\n         if let Some(bounds) = bounds {\n-            self.print_bounds(\":\", bounds)?;\n+            self.print_type_bounds(\":\", bounds)?;\n         }\n         if let Some(ty) = ty {\n             self.s.space()?;\n@@ -1322,7 +1328,7 @@ impl<'a> State<'a> {\n                 self.print_unsafety(unsafety)?;\n                 self.word_nbsp(\"impl\")?;\n \n-                if generics.is_parameterized() {\n+                if !generics.params.is_empty() {\n                     self.print_generic_params(&generics.params)?;\n                     self.s.space()?;\n                 }\n@@ -1358,15 +1364,15 @@ impl<'a> State<'a> {\n                 self.print_generic_params(&generics.params)?;\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n                 for b in bounds.iter() {\n-                    if let TraitTyParamBound(ref ptr, ast::TraitBoundModifier::Maybe) = *b {\n+                    if let GenericBound::Trait(ref ptr, ast::TraitBoundModifier::Maybe) = *b {\n                         self.s.space()?;\n                         self.word_space(\"for ?\")?;\n                         self.print_trait_ref(&ptr.trait_ref)?;\n                     } else {\n                         real_bounds.push(b.clone());\n                     }\n                 }\n-                self.print_bounds(\":\", &real_bounds[..])?;\n+                self.print_type_bounds(\":\", &real_bounds[..])?;\n                 self.print_where_clause(&generics.where_clause)?;\n                 self.s.word(\" \")?;\n                 self.bopen()?;\n@@ -1384,7 +1390,7 @@ impl<'a> State<'a> {\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n                 // FIXME(durka) this seems to be some quite outdated syntax\n                 for b in bounds.iter() {\n-                    if let TraitTyParamBound(ref ptr, ast::TraitBoundModifier::Maybe) = *b {\n+                    if let GenericBound::Trait(ref ptr, ast::TraitBoundModifier::Maybe) = *b {\n                         self.s.space()?;\n                         self.word_space(\"for ?\")?;\n                         self.print_trait_ref(&ptr.trait_ref)?;\n@@ -1393,7 +1399,7 @@ impl<'a> State<'a> {\n                     }\n                 }\n                 self.nbsp()?;\n-                self.print_bounds(\"=\", &real_bounds[..])?;\n+                self.print_type_bounds(\"=\", &real_bounds[..])?;\n                 self.print_where_clause(&generics.where_clause)?;\n                 self.s.word(\";\")?;\n             }\n@@ -1984,8 +1990,8 @@ impl<'a> State<'a> {\n         self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX)?;\n         self.s.word(\".\")?;\n         self.print_ident(segment.ident)?;\n-        if let Some(ref parameters) = segment.parameters {\n-            self.print_path_parameters(parameters, true)?;\n+        if let Some(ref args) = segment.args {\n+            self.print_generic_args(args, true)?;\n         }\n         self.print_call_post(base_args)\n     }\n@@ -2428,8 +2434,8 @@ impl<'a> State<'a> {\n         if segment.ident.name != keywords::CrateRoot.name() &&\n            segment.ident.name != keywords::DollarCrate.name() {\n             self.print_ident(segment.ident)?;\n-            if let Some(ref parameters) = segment.parameters {\n-                self.print_path_parameters(parameters, colons_before_params)?;\n+            if let Some(ref args) = segment.args {\n+                self.print_generic_args(args, colons_before_params)?;\n             }\n         } else if segment.ident.name == keywords::DollarCrate.name() {\n             self.print_dollar_crate(segment.ident.span.ctxt())?;\n@@ -2455,44 +2461,30 @@ impl<'a> State<'a> {\n         self.s.word(\"::\")?;\n         let item_segment = path.segments.last().unwrap();\n         self.print_ident(item_segment.ident)?;\n-        match item_segment.parameters {\n-            Some(ref parameters) => self.print_path_parameters(parameters, colons_before_params),\n+        match item_segment.args {\n+            Some(ref args) => self.print_generic_args(args, colons_before_params),\n             None => Ok(()),\n         }\n     }\n \n-    fn print_path_parameters(&mut self,\n-                             parameters: &ast::PathParameters,\n-                             colons_before_params: bool)\n-                             -> io::Result<()>\n+    fn print_generic_args(&mut self,\n+                          args: &ast::GenericArgs,\n+                          colons_before_params: bool)\n+                          -> io::Result<()>\n     {\n         if colons_before_params {\n             self.s.word(\"::\")?\n         }\n \n-        match *parameters {\n-            ast::PathParameters::AngleBracketed(ref data) => {\n+        match *args {\n+            ast::GenericArgs::AngleBracketed(ref data) => {\n                 self.s.word(\"<\")?;\n \n-                let mut comma = false;\n-                for lifetime in &data.lifetimes {\n-                    if comma {\n-                        self.word_space(\",\")?\n-                    }\n-                    self.print_lifetime(lifetime)?;\n-                    comma = true;\n-                }\n+                self.commasep(Inconsistent, &data.args, |s, generic_arg| {\n+                    s.print_generic_arg(generic_arg)\n+                })?;\n \n-                if !data.types.is_empty() {\n-                    if comma {\n-                        self.word_space(\",\")?\n-                    }\n-                    self.commasep(\n-                        Inconsistent,\n-                        &data.types,\n-                        |s, ty| s.print_type(ty))?;\n-                        comma = true;\n-                }\n+                let mut comma = data.args.len() != 0;\n \n                 for binding in data.bindings.iter() {\n                     if comma {\n@@ -2508,7 +2500,7 @@ impl<'a> State<'a> {\n                 self.s.word(\">\")?\n             }\n \n-            ast::PathParameters::Parenthesized(ref data) => {\n+            ast::GenericArgs::Parenthesized(ref data) => {\n                 self.s.word(\"(\")?;\n                 self.commasep(\n                     Inconsistent,\n@@ -2816,9 +2808,9 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_bounds(&mut self,\n+    pub fn print_type_bounds(&mut self,\n                         prefix: &str,\n-                        bounds: &[ast::TyParamBound])\n+                        bounds: &[ast::GenericBound])\n                         -> io::Result<()> {\n         if !bounds.is_empty() {\n             self.s.word(prefix)?;\n@@ -2834,32 +2826,25 @@ impl<'a> State<'a> {\n                 }\n \n                 match bound {\n-                    TraitTyParamBound(tref, modifier) => {\n+                    GenericBound::Trait(tref, modifier) => {\n                         if modifier == &TraitBoundModifier::Maybe {\n                             self.s.word(\"?\")?;\n                         }\n                         self.print_poly_trait_ref(tref)?;\n                     }\n-                    RegionTyParamBound(lt) => {\n-                        self.print_lifetime(lt)?;\n-                    }\n+                    GenericBound::Outlives(lt) => self.print_lifetime(*lt)?,\n                 }\n             }\n         }\n         Ok(())\n     }\n \n-    pub fn print_lifetime(&mut self,\n-                          lifetime: &ast::Lifetime)\n-                          -> io::Result<()>\n-    {\n+    pub fn print_lifetime(&mut self, lifetime: ast::Lifetime) -> io::Result<()> {\n         self.print_name(lifetime.ident.name)\n     }\n \n-    pub fn print_lifetime_bounds(&mut self,\n-                                 lifetime: &ast::Lifetime,\n-                                 bounds: &[ast::Lifetime])\n-                                 -> io::Result<()>\n+    pub fn print_lifetime_bounds(&mut self, lifetime: ast::Lifetime, bounds: &ast::GenericBounds)\n+        -> io::Result<()>\n     {\n         self.print_lifetime(lifetime)?;\n         if !bounds.is_empty() {\n@@ -2868,7 +2853,10 @@ impl<'a> State<'a> {\n                 if i != 0 {\n                     self.s.word(\" + \")?;\n                 }\n-                self.print_lifetime(bound)?;\n+                match bound {\n+                    ast::GenericBound::Outlives(lt) => self.print_lifetime(*lt)?,\n+                    _ => panic!(),\n+                }\n             }\n         }\n         Ok(())\n@@ -2885,33 +2873,32 @@ impl<'a> State<'a> {\n         self.s.word(\"<\")?;\n \n         self.commasep(Inconsistent, &generic_params, |s, param| {\n-            match *param {\n-                ast::GenericParam::Lifetime(ref lifetime_def) => {\n-                    s.print_outer_attributes_inline(&lifetime_def.attrs)?;\n-                    s.print_lifetime_bounds(&lifetime_def.lifetime, &lifetime_def.bounds)\n+            match param.kind {\n+                ast::GenericParamKind::Lifetime => {\n+                    s.print_outer_attributes_inline(&param.attrs)?;\n+                    let lt = ast::Lifetime { id: param.id, ident: param.ident };\n+                    s.print_lifetime_bounds(lt, &param.bounds)\n                 },\n-                ast::GenericParam::Type(ref ty_param) => s.print_ty_param(ty_param),\n+                ast::GenericParamKind::Type { ref default } => {\n+                    s.print_outer_attributes_inline(&param.attrs)?;\n+                    s.print_ident(param.ident)?;\n+                    s.print_type_bounds(\":\", &param.bounds)?;\n+                    match default {\n+                        Some(ref default) => {\n+                            s.s.space()?;\n+                            s.word_space(\"=\")?;\n+                            s.print_type(default)\n+                        }\n+                        _ => Ok(())\n+                    }\n+                }\n             }\n         })?;\n \n         self.s.word(\">\")?;\n         Ok(())\n     }\n \n-    pub fn print_ty_param(&mut self, param: &ast::TyParam) -> io::Result<()> {\n-        self.print_outer_attributes_inline(&param.attrs)?;\n-        self.print_ident(param.ident)?;\n-        self.print_bounds(\":\", &param.bounds)?;\n-        match param.default {\n-            Some(ref default) => {\n-                self.s.space()?;\n-                self.word_space(\"=\")?;\n-                self.print_type(default)\n-            }\n-            _ => Ok(())\n-        }\n-    }\n-\n     pub fn print_where_clause(&mut self, where_clause: &ast::WhereClause)\n                               -> io::Result<()> {\n         if where_clause.predicates.is_empty() {\n@@ -2935,12 +2922,12 @@ impl<'a> State<'a> {\n                 }) => {\n                     self.print_formal_generic_params(bound_generic_params)?;\n                     self.print_type(bounded_ty)?;\n-                    self.print_bounds(\":\", bounds)?;\n+                    self.print_type_bounds(\":\", bounds)?;\n                 }\n                 ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate{ref lifetime,\n                                                                                ref bounds,\n                                                                                ..}) => {\n-                    self.print_lifetime_bounds(lifetime, bounds)?;\n+                    self.print_lifetime_bounds(*lifetime, bounds)?;\n                 }\n                 ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{ref lhs_ty,\n                                                                        ref rhs_ty,"}, {"sha": "f896fa351b0af4210fb525113be4dec96388248d", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -353,7 +353,7 @@ fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n \n                 match (has_output, has_should_panic_attr) {\n                     (true, true) => No(BadTestSignature::ShouldPanicOnlyWithNoArgs),\n-                    (true, false) => if generics.is_parameterized() {\n+                    (true, false) => if !generics.params.is_empty() {\n                         No(BadTestSignature::WrongTypeSignature)\n                     } else {\n                         Yes"}, {"sha": "ebb3081c1fde5586665e08271e5cdd35ef972e75", "filename": "src/libsyntax/util/node_count.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax%2Futil%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax%2Futil%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fnode_count.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -95,9 +95,9 @@ impl<'ast> Visitor<'ast> for NodeCounter {\n         self.count += 1;\n         walk_trait_ref(self, t)\n     }\n-    fn visit_ty_param_bound(&mut self, bounds: &TyParamBound) {\n+    fn visit_param_bound(&mut self, bounds: &GenericBound) {\n         self.count += 1;\n-        walk_ty_param_bound(self, bounds)\n+        walk_param_bound(self, bounds)\n     }\n     fn visit_poly_trait_ref(&mut self, t: &PolyTraitRef, m: &TraitBoundModifier) {\n         self.count += 1;\n@@ -137,9 +137,9 @@ impl<'ast> Visitor<'ast> for NodeCounter {\n         self.count += 1;\n         walk_use_tree(self, use_tree, id)\n     }\n-    fn visit_path_parameters(&mut self, path_span: Span, path_parameters: &PathParameters) {\n+    fn visit_generic_args(&mut self, path_span: Span, generic_args: &GenericArgs) {\n         self.count += 1;\n-        walk_path_parameters(self, path_span, path_parameters)\n+        walk_generic_args(self, path_span, generic_args)\n     }\n     fn visit_assoc_type_binding(&mut self, type_binding: &TypeBinding) {\n         self.count += 1;"}, {"sha": "613f1a4f113bdf5377ba79b9ffb150edf43a6f11", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 37, "deletions": 40, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -73,7 +73,9 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_expr(&mut self, ex: &'ast Expr) { walk_expr(self, ex) }\n     fn visit_expr_post(&mut self, _ex: &'ast Expr) { }\n     fn visit_ty(&mut self, t: &'ast Ty) { walk_ty(self, t) }\n-    fn visit_generic_param(&mut self, param: &'ast GenericParam) { walk_generic_param(self, param) }\n+    fn visit_generic_param(&mut self, param: &'ast GenericParam) {\n+        walk_generic_param(self, param)\n+    }\n     fn visit_generics(&mut self, g: &'ast Generics) { walk_generics(self, g) }\n     fn visit_where_predicate(&mut self, p: &'ast WherePredicate) {\n         walk_where_predicate(self, p)\n@@ -84,8 +86,8 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_trait_item(&mut self, ti: &'ast TraitItem) { walk_trait_item(self, ti) }\n     fn visit_impl_item(&mut self, ii: &'ast ImplItem) { walk_impl_item(self, ii) }\n     fn visit_trait_ref(&mut self, t: &'ast TraitRef) { walk_trait_ref(self, t) }\n-    fn visit_ty_param_bound(&mut self, bounds: &'ast TyParamBound) {\n-        walk_ty_param_bound(self, bounds)\n+    fn visit_param_bound(&mut self, bounds: &'ast GenericBound) {\n+        walk_param_bound(self, bounds)\n     }\n     fn visit_poly_trait_ref(&mut self, t: &'ast PolyTraitRef, m: &'ast TraitBoundModifier) {\n         walk_poly_trait_ref(self, t, m)\n@@ -128,8 +130,14 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_path_segment(&mut self, path_span: Span, path_segment: &'ast PathSegment) {\n         walk_path_segment(self, path_span, path_segment)\n     }\n-    fn visit_path_parameters(&mut self, path_span: Span, path_parameters: &'ast PathParameters) {\n-        walk_path_parameters(self, path_span, path_parameters)\n+    fn visit_generic_args(&mut self, path_span: Span, generic_args: &'ast GenericArgs) {\n+        walk_generic_args(self, path_span, generic_args)\n+    }\n+    fn visit_generic_arg(&mut self, generic_arg: &'ast GenericArg) {\n+        match generic_arg {\n+            GenericArg::Lifetime(lt) => self.visit_lifetime(lt),\n+            GenericArg::Type(ty) => self.visit_ty(ty),\n+        }\n     }\n     fn visit_assoc_type_binding(&mut self, type_binding: &'ast TypeBinding) {\n         walk_assoc_type_binding(self, type_binding)\n@@ -268,12 +276,12 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n         }\n         ItemKind::Trait(.., ref generics, ref bounds, ref methods) => {\n             visitor.visit_generics(generics);\n-            walk_list!(visitor, visit_ty_param_bound, bounds);\n+            walk_list!(visitor, visit_param_bound, bounds);\n             walk_list!(visitor, visit_trait_item, methods);\n         }\n         ItemKind::TraitAlias(ref generics, ref bounds) => {\n             visitor.visit_generics(generics);\n-            walk_list!(visitor, visit_ty_param_bound, bounds);\n+            walk_list!(visitor, visit_param_bound, bounds);\n         }\n         ItemKind::Mac(ref mac) => visitor.visit_mac(mac),\n         ItemKind::MacroDef(ref ts) => visitor.visit_mac_def(ts, item.id),\n@@ -333,7 +341,7 @@ pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n         }\n         TyKind::TraitObject(ref bounds, ..) |\n         TyKind::ImplTrait(ref bounds) => {\n-            walk_list!(visitor, visit_ty_param_bound, bounds);\n+            walk_list!(visitor, visit_param_bound, bounds);\n         }\n         TyKind::Typeof(ref expression) => {\n             visitor.visit_anon_const(expression)\n@@ -375,23 +383,22 @@ pub fn walk_path_segment<'a, V: Visitor<'a>>(visitor: &mut V,\n                                              path_span: Span,\n                                              segment: &'a PathSegment) {\n     visitor.visit_ident(segment.ident);\n-    if let Some(ref parameters) = segment.parameters {\n-        visitor.visit_path_parameters(path_span, parameters);\n+    if let Some(ref args) = segment.args {\n+        visitor.visit_generic_args(path_span, args);\n     }\n }\n \n-pub fn walk_path_parameters<'a, V>(visitor: &mut V,\n-                                   _path_span: Span,\n-                                   path_parameters: &'a PathParameters)\n+pub fn walk_generic_args<'a, V>(visitor: &mut V,\n+                                _path_span: Span,\n+                                generic_args: &'a GenericArgs)\n     where V: Visitor<'a>,\n {\n-    match *path_parameters {\n-        PathParameters::AngleBracketed(ref data) => {\n-            walk_list!(visitor, visit_ty, &data.types);\n-            walk_list!(visitor, visit_lifetime, &data.lifetimes);\n+    match *generic_args {\n+        GenericArgs::AngleBracketed(ref data) => {\n+            walk_list!(visitor, visit_generic_arg, &data.args);\n             walk_list!(visitor, visit_assoc_type_binding, &data.bindings);\n         }\n-        PathParameters::Parenthesized(ref data) => {\n+        GenericArgs::Parenthesized(ref data) => {\n             walk_list!(visitor, visit_ty, &data.inputs);\n             walk_list!(visitor, visit_ty, &data.output);\n         }\n@@ -472,30 +479,20 @@ pub fn walk_global_asm<'a, V: Visitor<'a>>(_: &mut V, _: &'a GlobalAsm) {\n     // Empty!\n }\n \n-pub fn walk_ty_param_bound<'a, V: Visitor<'a>>(visitor: &mut V, bound: &'a TyParamBound) {\n+pub fn walk_param_bound<'a, V: Visitor<'a>>(visitor: &mut V, bound: &'a GenericBound) {\n     match *bound {\n-        TraitTyParamBound(ref typ, ref modifier) => {\n-            visitor.visit_poly_trait_ref(typ, modifier);\n-        }\n-        RegionTyParamBound(ref lifetime) => {\n-            visitor.visit_lifetime(lifetime);\n-        }\n+        GenericBound::Trait(ref typ, ref modifier) => visitor.visit_poly_trait_ref(typ, modifier),\n+        GenericBound::Outlives(ref lifetime) => visitor.visit_lifetime(lifetime),\n     }\n }\n \n pub fn walk_generic_param<'a, V: Visitor<'a>>(visitor: &mut V, param: &'a GenericParam) {\n-    match *param {\n-        GenericParam::Lifetime(ref l) => {\n-            visitor.visit_ident(l.lifetime.ident);\n-            walk_list!(visitor, visit_lifetime, &l.bounds);\n-            walk_list!(visitor, visit_attribute, &*l.attrs);\n-        }\n-        GenericParam::Type(ref t) => {\n-            visitor.visit_ident(t.ident);\n-            walk_list!(visitor, visit_ty_param_bound, &t.bounds);\n-            walk_list!(visitor, visit_ty, &t.default);\n-            walk_list!(visitor, visit_attribute, &*t.attrs);\n-        }\n+    visitor.visit_ident(param.ident);\n+    walk_list!(visitor, visit_attribute, param.attrs.iter());\n+    walk_list!(visitor, visit_param_bound, &param.bounds);\n+    match param.kind {\n+        GenericParamKind::Lifetime => {}\n+        GenericParamKind::Type { ref default } => walk_list!(visitor, visit_ty, default),\n     }\n }\n \n@@ -511,14 +508,14 @@ pub fn walk_where_predicate<'a, V: Visitor<'a>>(visitor: &mut V, predicate: &'a\n                                                            ref bound_generic_params,\n                                                            ..}) => {\n             visitor.visit_ty(bounded_ty);\n-            walk_list!(visitor, visit_ty_param_bound, bounds);\n+            walk_list!(visitor, visit_param_bound, bounds);\n             walk_list!(visitor, visit_generic_param, bound_generic_params);\n         }\n         WherePredicate::RegionPredicate(WhereRegionPredicate{ref lifetime,\n                                                              ref bounds,\n                                                              ..}) => {\n             visitor.visit_lifetime(lifetime);\n-            walk_list!(visitor, visit_lifetime, bounds);\n+            walk_list!(visitor, visit_param_bound, bounds);\n         }\n         WherePredicate::EqPredicate(WhereEqPredicate{ref lhs_ty,\n                                                      ref rhs_ty,\n@@ -579,7 +576,7 @@ pub fn walk_trait_item<'a, V: Visitor<'a>>(visitor: &mut V, trait_item: &'a Trai\n                              &sig.decl, trait_item.span, trait_item.id);\n         }\n         TraitItemKind::Type(ref bounds, ref default) => {\n-            walk_list!(visitor, visit_ty_param_bound, bounds);\n+            walk_list!(visitor, visit_param_bound, bounds);\n             walk_list!(visitor, visit_ty, default);\n         }\n         TraitItemKind::Macro(ref mac) => {"}, {"sha": "9aeac5b1ddb2ae9937cb952897cde1b90e4cda49", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -13,6 +13,7 @@ use deriving::generic::*;\n use deriving::generic::ty::*;\n \n use syntax::ast::{self, Expr, Generics, ItemKind, MetaItem, VariantData};\n+use syntax::ast::GenericArg;\n use syntax::attr;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n@@ -48,7 +49,10 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n                 ItemKind::Struct(_, Generics { ref params, .. }) |\n                 ItemKind::Enum(_, Generics { ref params, .. }) => {\n                     if attr::contains_name(&annitem.attrs, \"rustc_copy_clone_marker\") &&\n-                        !params.iter().any(|param| param.is_type_param())\n+                        !params.iter().any(|param| match param.kind {\n+                            ast::GenericParamKind::Type { .. } => true,\n+                            _ => false,\n+                        })\n                     {\n                         bounds = vec![];\n                         is_shallow = true;\n@@ -123,7 +127,7 @@ fn cs_clone_shallow(name: &str,\n         let span = span.with_ctxt(cx.backtrace());\n         let assert_path = cx.path_all(span, true,\n                                         cx.std_path(&[\"clone\", helper_name]),\n-                                        vec![], vec![ty], vec![]);\n+                                        vec![GenericArg::Type(ty)], vec![]);\n         stmts.push(cx.stmt_let_type_only(span, cx.ty_path(assert_path)));\n     }\n     fn process_variant(cx: &mut ExtCtxt, stmts: &mut Vec<ast::Stmt>, variant: &VariantData) {"}, {"sha": "00ab39032acbd2489dbdc6273ca1812d1a8f9259", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -12,7 +12,7 @@ use deriving::path_std;\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast::{self, Expr, MetaItem};\n+use syntax::ast::{self, Expr, MetaItem, GenericArg};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n@@ -62,7 +62,7 @@ fn cs_total_eq_assert(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n         let span = span.with_ctxt(cx.backtrace());\n         let assert_path = cx.path_all(span, true,\n                                         cx.std_path(&[\"cmp\", helper_name]),\n-                                        vec![], vec![ty], vec![]);\n+                                        vec![GenericArg::Type(ty)], vec![]);\n         stmts.push(cx.stmt_let_type_only(span, cx.ty_path(assert_path)));\n     }\n     fn process_variant(cx: &mut ExtCtxt, stmts: &mut Vec<ast::Stmt>, variant: &ast::VariantData) {"}, {"sha": "672726d1475793e80340bda13a7e6bb66e3cc243", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 40, "deletions": 55, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -192,10 +192,8 @@ use std::collections::HashSet;\n use std::vec;\n \n use rustc_target::spec::abi::Abi;\n-use syntax::ast::{\n-    self, BinOpKind, EnumDef, Expr, GenericParam, Generics, Ident, PatKind, VariantData\n-};\n-\n+use syntax::ast::{self, BinOpKind, EnumDef, Expr, Generics, Ident, PatKind};\n+use syntax::ast::{VariantData, GenericParamKind, GenericArg};\n use syntax::attr;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n@@ -424,7 +422,10 @@ impl<'a> TraitDef<'a> {\n                     ast::ItemKind::Struct(_, ref generics) |\n                     ast::ItemKind::Enum(_, ref generics) |\n                     ast::ItemKind::Union(_, ref generics) => {\n-                        !generics.params.iter().any(|p| p.is_type_param())\n+                        !generics.params.iter().any(|param| match param.kind {\n+                            ast::GenericParamKind::Type { .. } => true,\n+                            _ => false,\n+                        })\n                     }\n                     _ => {\n                         // Non-ADT derive is an error, but it should have been\n@@ -548,30 +549,27 @@ impl<'a> TraitDef<'a> {\n             .to_generics(cx, self.span, type_ident, generics);\n \n         // Create the generic parameters\n-        params.extend(generics.params.iter().map(|param| {\n-            match *param {\n-                ref l @ GenericParam::Lifetime(_) => l.clone(),\n-                GenericParam::Type(ref ty_param) => {\n-                    // I don't think this can be moved out of the loop, since\n-                    // a TyParamBound requires an ast id\n-                    let mut bounds: Vec<_> =\n-                        // extra restrictions on the generics parameters to the\n-                        // type being derived upon\n-                        self.additional_bounds.iter().map(|p| {\n-                            cx.typarambound(p.to_path(cx, self.span,\n-                                                        type_ident, generics))\n-                        }).collect();\n-\n-                    // require the current trait\n-                    bounds.push(cx.typarambound(trait_path.clone()));\n-\n-                    // also add in any bounds from the declaration\n-                    for declared_bound in ty_param.bounds.iter() {\n-                        bounds.push((*declared_bound).clone());\n-                    }\n-\n-                    GenericParam::Type(cx.typaram(self.span, ty_param.ident, vec![], bounds, None))\n+        params.extend(generics.params.iter().map(|param| match param.kind {\n+            GenericParamKind::Lifetime { .. } => param.clone(),\n+            GenericParamKind::Type { .. } => {\n+                // I don't think this can be moved out of the loop, since\n+                // a GenericBound requires an ast id\n+                let mut bounds: Vec<_> =\n+                    // extra restrictions on the generics parameters to the\n+                    // type being derived upon\n+                    self.additional_bounds.iter().map(|p| {\n+                        cx.trait_bound(p.to_path(cx, self.span, type_ident, generics))\n+                    }).collect();\n+\n+                // require the current trait\n+                bounds.push(cx.trait_bound(trait_path.clone()));\n+\n+                // also add in any bounds from the declaration\n+                for declared_bound in &param.bounds {\n+                    bounds.push((*declared_bound).clone());\n                 }\n+\n+                cx.typaram(self.span, param.ident, vec![], bounds, None)\n             }\n         }));\n \n@@ -608,8 +606,8 @@ impl<'a> TraitDef<'a> {\n             // Extra scope required here so ty_params goes out of scope before params is moved\n \n             let mut ty_params = params.iter()\n-                .filter_map(|param| match *param {\n-                    ast::GenericParam::Type(ref t) => Some(t),\n+                .filter_map(|param| match param.kind {\n+                    ast::GenericParamKind::Type { .. } => Some(param),\n                     _ => None,\n                 })\n                 .peekable();\n@@ -636,12 +634,12 @@ impl<'a> TraitDef<'a> {\n                         let mut bounds: Vec<_> = self.additional_bounds\n                             .iter()\n                             .map(|p| {\n-                                cx.typarambound(p.to_path(cx, self.span, type_ident, generics))\n+                                cx.trait_bound(p.to_path(cx, self.span, type_ident, generics))\n                             })\n                             .collect();\n \n                         // require the current trait\n-                        bounds.push(cx.typarambound(trait_path.clone()));\n+                        bounds.push(cx.trait_bound(trait_path.clone()));\n \n                         let predicate = ast::WhereBoundPredicate {\n                             span: self.span,\n@@ -666,31 +664,18 @@ impl<'a> TraitDef<'a> {\n         // Create the reference to the trait.\n         let trait_ref = cx.trait_ref(trait_path);\n \n-        // Create the type parameters on the `self` path.\n-        let self_ty_params = generics.params\n-            .iter()\n-            .filter_map(|param| match *param {\n-                GenericParam::Type(ref ty_param)\n-                    => Some(cx.ty_ident(self.span, ty_param.ident)),\n-                _ => None,\n-            })\n-            .collect();\n-\n-        let self_lifetimes: Vec<ast::Lifetime> = generics.params\n-            .iter()\n-            .filter_map(|param| match *param {\n-                GenericParam::Lifetime(ref ld) => Some(ld.lifetime),\n-                _ => None,\n-            })\n-            .collect();\n+        let self_params: Vec<_> = generics.params.iter().map(|param| match param.kind {\n+            GenericParamKind::Lifetime { .. } => {\n+                GenericArg::Lifetime(cx.lifetime(self.span, param.ident))\n+            }\n+            GenericParamKind::Type { .. } => {\n+                GenericArg::Type(cx.ty_ident(self.span, param.ident))\n+            }\n+        }).collect();\n \n         // Create the type of `self`.\n-        let self_type = cx.ty_path(cx.path_all(self.span,\n-                                               false,\n-                                               vec![type_ident],\n-                                               self_lifetimes,\n-                                               self_ty_params,\n-                                               Vec::new()));\n+        let path = cx.path_all(self.span, false, vec![type_ident], self_params, vec![]);\n+        let self_type = cx.ty_path(path);\n \n         let attr = cx.attribute(self.span,\n                                 cx.meta_word(self.span,"}, {"sha": "0b809ab585cdcb9cd2e927e74640049e8bf4f94a", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 27, "deletions": 37, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -15,7 +15,7 @@ pub use self::PtrTy::*;\n pub use self::Ty::*;\n \n use syntax::ast;\n-use syntax::ast::{Expr, GenericParam, Generics, Ident, SelfKind};\n+use syntax::ast::{Expr, GenericParamKind, Generics, Ident, SelfKind, GenericArg};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::codemap::{respan, DUMMY_SP};\n@@ -86,15 +86,20 @@ impl<'a> Path<'a> {\n                    -> ast::Path {\n         let mut idents = self.path.iter().map(|s| cx.ident_of(*s)).collect();\n         let lt = mk_lifetimes(cx, span, &self.lifetime);\n-        let tys = self.params.iter().map(|t| t.to_ty(cx, span, self_ty, self_generics)).collect();\n+        let tys: Vec<P<ast::Ty>> =\n+            self.params.iter().map(|t| t.to_ty(cx, span, self_ty, self_generics)).collect();\n+        let params = lt.into_iter()\n+                       .map(|lt| GenericArg::Lifetime(lt))\n+                       .chain(tys.into_iter().map(|ty| GenericArg::Type(ty)))\n+                       .collect();\n \n         match self.kind {\n-            PathKind::Global => cx.path_all(span, true, idents, lt, tys, Vec::new()),\n-            PathKind::Local => cx.path_all(span, false, idents, lt, tys, Vec::new()),\n+            PathKind::Global => cx.path_all(span, true, idents, params, Vec::new()),\n+            PathKind::Local => cx.path_all(span, false, idents, params, Vec::new()),\n             PathKind::Std => {\n                 let def_site = DUMMY_SP.apply_mark(cx.current_expansion.mark);\n                 idents.insert(0, Ident::new(keywords::DollarCrate.name(), def_site));\n-                cx.path_all(span, false, idents, lt, tys, Vec::new())\n+                cx.path_all(span, false, idents, params, Vec::new())\n             }\n         }\n \n@@ -180,34 +185,22 @@ impl<'a> Ty<'a> {\n                    cx: &ExtCtxt,\n                    span: Span,\n                    self_ty: Ident,\n-                   self_generics: &Generics)\n+                   generics: &Generics)\n                    -> ast::Path {\n         match *self {\n             Self_ => {\n-                let self_params = self_generics.params\n-                    .iter()\n-                    .filter_map(|param| match *param {\n-                        GenericParam::Type(ref ty_param) => Some(cx.ty_ident(span, ty_param.ident)),\n-                        _ => None,\n-                    })\n-                    .collect();\n-\n-                let lifetimes: Vec<ast::Lifetime> = self_generics.params\n-                    .iter()\n-                    .filter_map(|param| match *param {\n-                        GenericParam::Lifetime(ref ld) => Some(ld.lifetime),\n-                        _ => None,\n-                    })\n-                    .collect();\n+                let params: Vec<_> = generics.params.iter().map(|param| match param.kind {\n+                    GenericParamKind::Lifetime { .. } => {\n+                        GenericArg::Lifetime(ast::Lifetime { id: param.id, ident: param.ident })\n+                    }\n+                    GenericParamKind::Type { .. } => {\n+                        GenericArg::Type(cx.ty_ident(span, param.ident))\n+                    }\n+                }).collect();\n \n-                cx.path_all(span,\n-                            false,\n-                            vec![self_ty],\n-                            lifetimes,\n-                            self_params,\n-                            Vec::new())\n+                cx.path_all(span, false, vec![self_ty], params, vec![])\n             }\n-            Literal(ref p) => p.to_path(cx, span, self_ty, self_generics),\n+            Literal(ref p) => p.to_path(cx, span, self_ty, generics),\n             Ptr(..) => cx.span_bug(span, \"pointer in a path in generic `derive`\"),\n             Tuple(..) => cx.span_bug(span, \"tuple in a path in generic `derive`\"),\n         }\n@@ -222,17 +215,17 @@ fn mk_ty_param(cx: &ExtCtxt,\n                bounds: &[Path],\n                self_ident: Ident,\n                self_generics: &Generics)\n-               -> ast::TyParam {\n+               -> ast::GenericParam {\n     let bounds = bounds.iter()\n         .map(|b| {\n             let path = b.to_path(cx, span, self_ident, self_generics);\n-            cx.typarambound(path)\n+            cx.trait_bound(path)\n         })\n         .collect();\n     cx.typaram(span, cx.ident_of(name), attrs.to_owned(), bounds, None)\n }\n \n-fn mk_generics(params: Vec<GenericParam>, span: Span) -> Generics {\n+fn mk_generics(params: Vec<ast::GenericParam>, span: Span) -> Generics {\n     Generics {\n         params,\n         where_clause: ast::WhereClause {\n@@ -268,17 +261,14 @@ impl<'a> LifetimeBounds<'a> {\n             .iter()\n             .map(|&(lt, ref bounds)| {\n                 let bounds = bounds.iter()\n-                    .map(|b| cx.lifetime(span, Ident::from_str(b)))\n-                    .collect();\n-                GenericParam::Lifetime(cx.lifetime_def(span, Ident::from_str(lt), vec![], bounds))\n+                    .map(|b| ast::GenericBound::Outlives(cx.lifetime(span, Ident::from_str(b))));\n+                cx.lifetime_def(span, Ident::from_str(lt), vec![], bounds.collect())\n             })\n             .chain(self.bounds\n                 .iter()\n                 .map(|t| {\n                     let (name, ref bounds) = *t;\n-                    GenericParam::Type(mk_ty_param(\n-                        cx, span, name, &[], &bounds, self_ty, self_generics\n-                    ))\n+                    mk_ty_param(cx, span, name, &[], &bounds, self_ty, self_generics)\n                 })\n             )\n             .collect();"}, {"sha": "6ff385b18e8bf41187de2b5511db7c3d973b6c90", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -134,9 +134,12 @@ fn hygienic_type_parameter(item: &Annotatable, base: &str) -> String {\n         match item.node {\n             ast::ItemKind::Struct(_, ast::Generics { ref params, .. }) |\n             ast::ItemKind::Enum(_, ast::Generics { ref params, .. }) => {\n-                for param in params.iter() {\n-                    if let ast::GenericParam::Type(ref ty) = *param{\n-                        typaram.push_str(&ty.ident.as_str());\n+                for param in params {\n+                    match param.kind {\n+                        ast::GenericParamKind::Type { .. } => {\n+                            typaram.push_str(&param.ident.as_str());\n+                        }\n+                        _ => {}\n                     }\n                 }\n             }"}, {"sha": "bbc5b03d6885eaa3f1a69cf2119b7d12f3550827", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -13,7 +13,7 @@\n // interface.\n //\n \n-use syntax::ast::{self, Ident};\n+use syntax::ast::{self, Ident, GenericArg};\n use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n@@ -39,12 +39,11 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt,\n             cx.expr_path(cx.path_all(sp,\n                                      true,\n                                      cx.std_path(&[\"option\", \"Option\", \"None\"]),\n-                                     Vec::new(),\n-                                     vec![cx.ty_rptr(sp,\n+                                     vec![GenericArg::Type(cx.ty_rptr(sp,\n                                                      cx.ty_ident(sp, Ident::from_str(\"str\")),\n                                                      Some(lt),\n-                                                     ast::Mutability::Immutable)],\n-                                     Vec::new()))\n+                                                     ast::Mutability::Immutable))],\n+                                     vec![]))\n         }\n         Ok(s) => {\n             cx.expr_call_global(sp,"}, {"sha": "ccdd9db25c40a0b2e8d10b6de52ad49fda78bd1f", "filename": "src/test/compile-fail/issue-1900.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Ftest%2Fcompile-fail%2Fissue-1900.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Ftest%2Fcompile-fail%2Fissue-1900.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1900.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -8,5 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: `main` function is not allowed to have type parameters\n+// error-pattern: `main` function is not allowed to have generic parameters\n fn main<T>() { }"}, {"sha": "4df46c0e2e1e7377cc514d93e22a8c11f5f14996", "filename": "src/test/run-pass/issue-22777.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Ftest%2Frun-pass%2Fissue-22777.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Ftest%2Frun-pass%2Fissue-22777.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-22777.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -32,8 +32,8 @@ struct S04_TyParamBound(S05_PolyTraitRef);\n struct S05_PolyTraitRef(S06_TraitRef);\n struct S06_TraitRef(S07_Path);\n struct S07_Path(Vec<S08_PathSegment>);\n-struct S08_PathSegment(S09_PathParameters);\n-struct S09_PathParameters(P<S10_ParenthesizedParameterData>);\n+struct S08_PathSegment(S09_GenericArgs);\n+struct S09_GenericArgs(P<S10_ParenthesizedParameterData>);\n struct S10_ParenthesizedParameterData(Option<P<S11_Ty>>);\n struct S11_Ty(P<S12_Expr>);\n struct S12_Expr(P<S13_Block>);"}, {"sha": "7f5b78684fbc18a9011b7cd6585532a47594279b", "filename": "src/test/ui/error-codes/E0110.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Ftest%2Fui%2Ferror-codes%2FE0110.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Ftest%2Fui%2Ferror-codes%2FE0110.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0110.stderr?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -2,7 +2,7 @@ error[E0110]: lifetime parameters are not allowed on this type\n   --> $DIR/E0110.rs:11:14\n    |\n LL | type X = u32<'static>; //~ ERROR E0110\n-   |              ^^^^^^^ lifetime parameter not allowed on this type\n+   |              ^^^^^^^ lifetime parameter not allowed\n \n error: aborting due to previous error\n "}, {"sha": "46bc872746cc32492d16ccd787bf2afdd5ae6f91", "filename": "src/test/ui/error-codes/E0131.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Ftest%2Fui%2Ferror-codes%2FE0131.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Ftest%2Fui%2Ferror-codes%2FE0131.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0131.stderr?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -1,8 +1,8 @@\n-error[E0131]: `main` function is not allowed to have type parameters\n+error[E0131]: `main` function is not allowed to have generic parameters\n   --> $DIR/E0131.rs:11:8\n    |\n LL | fn main<T>() {\n-   |        ^^^ `main` cannot have type parameters\n+   |        ^^^ `main` cannot have generic parameters\n \n error: aborting due to previous error\n "}, {"sha": "831c3e5fda084c560f01c0676303e1ea99a85ad4", "filename": "src/test/ui/issue-51022.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Ftest%2Fui%2Fissue-51022.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Ftest%2Fui%2Fissue-51022.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-51022.rs?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -9,4 +9,4 @@\n // except according to those terms.\n \n fn main<'a>() { }\n-    //~^ ERROR `main` function is not allowed to have lifetime parameters [E0131]\n+    //~^ ERROR `main` function is not allowed to have generic parameters [E0131]"}, {"sha": "1daa8dfbba689ec3b55edc3daf15dbf6da8f8932", "filename": "src/test/ui/issue-51022.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Ftest%2Fui%2Fissue-51022.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Ftest%2Fui%2Fissue-51022.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-51022.stderr?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -1,8 +1,8 @@\n-error[E0131]: `main` function is not allowed to have lifetime parameters\n+error[E0131]: `main` function is not allowed to have generic parameters\n   --> $DIR/issue-51022.rs:11:8\n    |\n LL | fn main<'a>() { }\n-   |        ^^^^ `main` cannot have lifetime parameters\n+   |        ^^^^ `main` cannot have generic parameters\n \n error: aborting due to previous error\n "}, {"sha": "8c31ab2ca88e4d71a88dda2c6d1b759b1c3444d0", "filename": "src/test/ui/rfc1598-generic-associated-types/collections.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fcollections.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fcollections.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fcollections.stderr?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -20,13 +20,13 @@ error[E0110]: lifetime parameters are not allowed on this type\n   --> $DIR/collections.rs:33:50\n    |\n LL |     fn iterate<'iter>(&'iter self) -> Self::Iter<'iter>;\n-   |                                                  ^^^^^ lifetime parameter not allowed on this type\n+   |                                                  ^^^^^ lifetime parameter not allowed\n \n error[E0110]: lifetime parameters are not allowed on this type\n   --> $DIR/collections.rs:59:50\n    |\n LL |     fn iterate<'iter>(&'iter self) -> Self::Iter<'iter> {\n-   |                                                  ^^^^^ lifetime parameter not allowed on this type\n+   |                                                  ^^^^^ lifetime parameter not allowed\n \n error: aborting due to 5 previous errors\n "}, {"sha": "1746122eb49f41d68b726acf25b086e6cda7e555", "filename": "src/test/ui/rfc1598-generic-associated-types/construct_with_other_type.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fconstruct_with_other_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fconstruct_with_other_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fconstruct_with_other_type.stderr?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -2,19 +2,19 @@ error[E0110]: lifetime parameters are not allowed on this type\n   --> $DIR/construct_with_other_type.rs:26:46\n    |\n LL |     type Baa<'a>: Deref<Target = <Self::Quux<'a> as Foo>::Bar<'a, 'static>>;\n-   |                                              ^^ lifetime parameter not allowed on this type\n+   |                                              ^^ lifetime parameter not allowed\n \n error[E0110]: lifetime parameters are not allowed on this type\n   --> $DIR/construct_with_other_type.rs:26:63\n    |\n LL |     type Baa<'a>: Deref<Target = <Self::Quux<'a> as Foo>::Bar<'a, 'static>>;\n-   |                                                               ^^ lifetime parameter not allowed on this type\n+   |                                                               ^^ lifetime parameter not allowed\n \n error[E0110]: lifetime parameters are not allowed on this type\n   --> $DIR/construct_with_other_type.rs:34:40\n    |\n LL |     type Baa<'a> = &'a <T as Foo>::Bar<'a, 'static>;\n-   |                                        ^^ lifetime parameter not allowed on this type\n+   |                                        ^^ lifetime parameter not allowed\n \n error: aborting due to 3 previous errors\n "}, {"sha": "d48c21477b310668bfa620ace9f6314c561a08e0", "filename": "src/test/ui/rfc1598-generic-associated-types/generic_associated_type_undeclared_lifetimes.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fgeneric_associated_type_undeclared_lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fgeneric_associated_type_undeclared_lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fgeneric_associated_type_undeclared_lifetimes.stderr?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -14,19 +14,19 @@ error[E0110]: lifetime parameters are not allowed on this type\n   --> $DIR/generic_associated_type_undeclared_lifetimes.rs:20:47\n    |\n LL |     type Iter<'a>: Iterator<Item = Self::Item<'a>>\n-   |                                               ^^ lifetime parameter not allowed on this type\n+   |                                               ^^ lifetime parameter not allowed\n \n error[E0110]: lifetime parameters are not allowed on this type\n   --> $DIR/generic_associated_type_undeclared_lifetimes.rs:22:37\n    |\n LL |         + Deref<Target = Self::Item<'b>>;\n-   |                                     ^^ lifetime parameter not allowed on this type\n+   |                                     ^^ lifetime parameter not allowed\n \n error[E0110]: lifetime parameters are not allowed on this type\n   --> $DIR/generic_associated_type_undeclared_lifetimes.rs:26:41\n    |\n LL |     fn iter<'a>(&'a self) -> Self::Iter<'undeclared>;\n-   |                                         ^^^^^^^^^^^ lifetime parameter not allowed on this type\n+   |                                         ^^^^^^^^^^^ lifetime parameter not allowed\n \n error: aborting due to 5 previous errors\n "}, {"sha": "737a29ec2c8be46ced3f82ad9674b416b6ca9b73", "filename": "src/test/ui/rfc1598-generic-associated-types/iterable.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fiterable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fiterable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fiterable.stderr?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -2,37 +2,37 @@ error[E0110]: lifetime parameters are not allowed on this type\n   --> $DIR/iterable.rs:20:47\n    |\n LL |     type Iter<'a>: Iterator<Item = Self::Item<'a>>;\n-   |                                               ^^ lifetime parameter not allowed on this type\n+   |                                               ^^ lifetime parameter not allowed\n \n error[E0110]: lifetime parameters are not allowed on this type\n   --> $DIR/iterable.rs:49:53\n    |\n LL | fn make_iter<'a, I: Iterable>(it: &'a I) -> I::Iter<'a> {\n-   |                                                     ^^ lifetime parameter not allowed on this type\n+   |                                                     ^^ lifetime parameter not allowed\n \n error[E0110]: lifetime parameters are not allowed on this type\n   --> $DIR/iterable.rs:54:60\n    |\n LL | fn get_first<'a, I: Iterable>(it: &'a I) -> Option<I::Item<'a>> {\n-   |                                                            ^^ lifetime parameter not allowed on this type\n+   |                                                            ^^ lifetime parameter not allowed\n \n error[E0110]: lifetime parameters are not allowed on this type\n   --> $DIR/iterable.rs:23:41\n    |\n LL |     fn iter<'a>(&'a self) -> Self::Iter<'a>;\n-   |                                         ^^ lifetime parameter not allowed on this type\n+   |                                         ^^ lifetime parameter not allowed\n \n error[E0110]: lifetime parameters are not allowed on this type\n   --> $DIR/iterable.rs:32:41\n    |\n LL |     fn iter<'a>(&'a self) -> Self::Iter<'a> {\n-   |                                         ^^ lifetime parameter not allowed on this type\n+   |                                         ^^ lifetime parameter not allowed\n \n error[E0110]: lifetime parameters are not allowed on this type\n   --> $DIR/iterable.rs:43:41\n    |\n LL |     fn iter<'a>(&'a self) -> Self::Iter<'a> {\n-   |                                         ^^ lifetime parameter not allowed on this type\n+   |                                         ^^ lifetime parameter not allowed\n \n error: aborting due to 6 previous errors\n "}, {"sha": "c8d37a51fa96bd5cd73e1c6161a89c453bca1b62", "filename": "src/test/ui/rfc1598-generic-associated-types/parameter_number_and_kind.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fparameter_number_and_kind.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fparameter_number_and_kind.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fparameter_number_and_kind.stderr?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -1,33 +1,33 @@\n+error[E0110]: lifetime parameters are not allowed on this type\n+  --> $DIR/parameter_number_and_kind.rs:26:27\n+   |\n+LL |     type FOk<T> = Self::E<'static, T>;\n+   |                           ^^^^^^^ lifetime parameter not allowed\n+\n error[E0109]: type parameters are not allowed on this type\n   --> $DIR/parameter_number_and_kind.rs:26:36\n    |\n LL |     type FOk<T> = Self::E<'static, T>;\n    |                                    ^ type parameter not allowed\n \n error[E0110]: lifetime parameters are not allowed on this type\n-  --> $DIR/parameter_number_and_kind.rs:26:27\n+  --> $DIR/parameter_number_and_kind.rs:29:26\n    |\n-LL |     type FOk<T> = Self::E<'static, T>;\n-   |                           ^^^^^^^ lifetime parameter not allowed on this type\n+LL |     type FErr1 = Self::E<'static, 'static>; // Error\n+   |                          ^^^^^^^ lifetime parameter not allowed\n \n error[E0110]: lifetime parameters are not allowed on this type\n-  --> $DIR/parameter_number_and_kind.rs:29:26\n+  --> $DIR/parameter_number_and_kind.rs:31:29\n    |\n-LL |     type FErr1 = Self::E<'static, 'static>; // Error\n-   |                          ^^^^^^^ lifetime parameter not allowed on this type\n+LL |     type FErr2<T> = Self::E<'static, T, u32>; // Error\n+   |                             ^^^^^^^ lifetime parameter not allowed\n \n error[E0109]: type parameters are not allowed on this type\n   --> $DIR/parameter_number_and_kind.rs:31:38\n    |\n LL |     type FErr2<T> = Self::E<'static, T, u32>; // Error\n    |                                      ^ type parameter not allowed\n \n-error[E0110]: lifetime parameters are not allowed on this type\n-  --> $DIR/parameter_number_and_kind.rs:31:29\n-   |\n-LL |     type FErr2<T> = Self::E<'static, T, u32>; // Error\n-   |                             ^^^^^^^ lifetime parameter not allowed on this type\n-\n error: aborting due to 5 previous errors\n \n Some errors occurred: E0109, E0110."}, {"sha": "12e206cbd476af56a70098be716d39a69b699fc8", "filename": "src/test/ui/rfc1598-generic-associated-types/streaming_iterator.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/662c70a59f79919640465b8753f790af822e96c8/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fstreaming_iterator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/662c70a59f79919640465b8753f790af822e96c8/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fstreaming_iterator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fstreaming_iterator.stderr?ref=662c70a59f79919640465b8753f790af822e96c8", "patch": "@@ -2,31 +2,31 @@ error[E0110]: lifetime parameters are not allowed on this type\n   --> $DIR/streaming_iterator.rs:27:41\n    |\n LL |     bar: <T as StreamingIterator>::Item<'static>,\n-   |                                         ^^^^^^^ lifetime parameter not allowed on this type\n+   |                                         ^^^^^^^ lifetime parameter not allowed\n \n error[E0110]: lifetime parameters are not allowed on this type\n   --> $DIR/streaming_iterator.rs:35:64\n    |\n LL | fn foo<T>(iter: T) where T: StreamingIterator, for<'a> T::Item<'a>: Display { /* ... */ }\n-   |                                                                ^^ lifetime parameter not allowed on this type\n+   |                                                                ^^ lifetime parameter not allowed\n \n error[E0110]: lifetime parameters are not allowed on this type\n   --> $DIR/streaming_iterator.rs:21:48\n    |\n LL |     fn next<'a>(&'a self) -> Option<Self::Item<'a>>;\n-   |                                                ^^ lifetime parameter not allowed on this type\n+   |                                                ^^ lifetime parameter not allowed\n \n error[E0110]: lifetime parameters are not allowed on this type\n   --> $DIR/streaming_iterator.rs:47:37\n    |\n LL |     type Item<'a> = (usize, I::Item<'a>);\n-   |                                     ^^ lifetime parameter not allowed on this type\n+   |                                     ^^ lifetime parameter not allowed\n \n error[E0110]: lifetime parameters are not allowed on this type\n   --> $DIR/streaming_iterator.rs:49:48\n    |\n LL |     fn next<'a>(&'a self) -> Option<Self::Item<'a>> {\n-   |                                                ^^ lifetime parameter not allowed on this type\n+   |                                                ^^ lifetime parameter not allowed\n \n error: aborting due to 5 previous errors\n "}]}