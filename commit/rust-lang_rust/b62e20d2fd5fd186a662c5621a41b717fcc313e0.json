{"sha": "b62e20d2fd5fd186a662c5621a41b717fcc313e0", "node_id": "C_kwDOAAsO6NoAKGI2MmUyMGQyZmQ1ZmQxODZhNjYyYzU2MjFhNDFiNzE3ZmNjMzEzZTA", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-06-09T14:41:11Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-06-09T14:41:11Z"}, "message": "split opaque type handling in new solver\n\nbe more explicit in where we only add new hidden types\nand where we also have to deal with item bounds.", "tree": {"sha": "d9a2feb6226bb035cc3ffc5a051043b298f93b08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9a2feb6226bb035cc3ffc5a051043b298f93b08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b62e20d2fd5fd186a662c5621a41b717fcc313e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b62e20d2fd5fd186a662c5621a41b717fcc313e0", "html_url": "https://github.com/rust-lang/rust/commit/b62e20d2fd5fd186a662c5621a41b717fcc313e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b62e20d2fd5fd186a662c5621a41b717fcc313e0/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "669d609dfda2f61f2b358c9e9061f76ebd852e7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/669d609dfda2f61f2b358c9e9061f76ebd852e7e", "html_url": "https://github.com/rust-lang/rust/commit/669d609dfda2f61f2b358c9e9061f76ebd852e7e"}], "stats": {"total": 192, "additions": 114, "deletions": 78}, "files": [{"sha": "6697e1aff7dd06bbaa5abb4a5cc03d0b48ad6ef3", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b62e20d2fd5fd186a662c5621a41b717fcc313e0/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62e20d2fd5fd186a662c5621a41b717fcc313e0/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=b62e20d2fd5fd186a662c5621a41b717fcc313e0", "patch": "@@ -27,6 +27,7 @@ use rustc_middle::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::AssertKind;\n use rustc_middle::mir::*;\n use rustc_middle::traits::query::NoSolution;\n+use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::cast::CastTy;\n use rustc_middle::ty::subst::{SubstsRef, UserSubsts};\n@@ -1051,15 +1052,28 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             ConstraintCategory::OpaqueType,\n             CustomTypeOp::new(\n                 |ocx| {\n-                    for (key, hidden_ty) in renumbered_opaques {\n-                        ocx.register_infer_ok_obligations(\n-                            ocx.infcx.register_hidden_type_in_new_solver(\n-                                key,\n-                                param_env,\n-                                hidden_ty.ty,\n-                            )?,\n+                    let mut obligations = Vec::new();\n+                    for (opaque_type_key, hidden_ty) in renumbered_opaques {\n+                        let cause = ObligationCause::dummy();\n+                        ocx.infcx.insert_hidden_type(\n+                            opaque_type_key,\n+                            &cause,\n+                            param_env,\n+                            hidden_ty.ty,\n+                            true,\n+                            &mut obligations,\n+                        )?;\n+\n+                        ocx.infcx.add_item_bounds_for_hidden_type(\n+                            opaque_type_key,\n+                            cause,\n+                            param_env,\n+                            hidden_ty.ty,\n+                            &mut obligations,\n                         );\n                     }\n+\n+                    ocx.register_obligations(obligations);\n                     Ok(())\n                 },\n                 \"register pre-defined opaques\","}, {"sha": "6b8293f90f10aa8093d6de5b1740bac5c0d7472d", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 47, "deletions": 36, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/b62e20d2fd5fd186a662c5621a41b717fcc313e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62e20d2fd5fd186a662c5621a41b717fcc313e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=b62e20d2fd5fd186a662c5621a41b717fcc313e0", "patch": "@@ -524,65 +524,76 @@ impl<'tcx> InferCtxt<'tcx> {\n         hidden_ty: Ty<'tcx>,\n         a_is_expected: bool,\n     ) -> InferResult<'tcx, ()> {\n+        let mut obligations = Vec::new();\n+\n+        self.insert_hidden_type(\n+            opaque_type_key,\n+            &cause,\n+            param_env,\n+            hidden_ty,\n+            a_is_expected,\n+            &mut obligations,\n+        )?;\n+\n+        self.add_item_bounds_for_hidden_type(\n+            opaque_type_key,\n+            cause,\n+            param_env,\n+            hidden_ty,\n+            &mut obligations,\n+        );\n+\n+        Ok(InferOk { value: (), obligations })\n+    }\n+\n+    /// Insert a hidden type into the opaque type storage, equating it\n+    /// with any previous entries if necessary.\n+    ///\n+    /// This **does not** add the item bounds of the opaque as nested\n+    /// obligations. That is only necessary when normalizing the opaque\n+    /// itself, not when getting the opaque type constraints from\n+    /// somewhere else.\n+    pub fn insert_hidden_type(\n+        &self,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        hidden_ty: Ty<'tcx>,\n+        a_is_expected: bool,\n+        obligations: &mut Vec<PredicateObligation<'tcx>>,\n+    ) -> Result<(), TypeError<'tcx>> {\n         // Ideally, we'd get the span where *this specific `ty` came\n         // from*, but right now we just use the span from the overall\n         // value being folded. In simple cases like `-> impl Foo`,\n         // these are the same span, but not in cases like `-> (impl\n         // Foo, impl Bar)`.\n         let span = cause.span;\n-        let mut obligations = if self.intercrate {\n+        if self.intercrate {\n             // During intercrate we do not define opaque types but instead always\n             // force ambiguity unless the hidden type is known to not implement\n             // our trait.\n-            vec![traits::Obligation::new(\n+            obligations.push(traits::Obligation::new(\n                 self.tcx,\n                 cause.clone(),\n                 param_env,\n                 ty::PredicateKind::Ambiguous,\n-            )]\n+            ))\n         } else {\n             let prev = self\n                 .inner\n                 .borrow_mut()\n                 .opaque_types()\n                 .register(opaque_type_key, OpaqueHiddenType { ty: hidden_ty, span });\n             if let Some(prev) = prev {\n-                self.at(&cause, param_env)\n-                    .eq_exp(DefineOpaqueTypes::Yes, a_is_expected, prev, hidden_ty)?\n-                    .obligations\n-            } else {\n-                Vec::new()\n+                obligations.extend(\n+                    self.at(&cause, param_env)\n+                        .eq_exp(DefineOpaqueTypes::Yes, a_is_expected, prev, hidden_ty)?\n+                        .obligations,\n+                );\n             }\n         };\n \n-        self.add_item_bounds_for_hidden_type(\n-            opaque_type_key,\n-            cause,\n-            param_env,\n-            hidden_ty,\n-            &mut obligations,\n-        );\n-\n-        Ok(InferOk { value: (), obligations })\n-    }\n-\n-    /// Registers an opaque's hidden type -- only should be used when the opaque\n-    /// can be defined. For something more fallible -- checks the anchors, tries\n-    /// to unify opaques in both dirs, etc. -- use `InferCtxt::handle_opaque_type`.\n-    pub fn register_hidden_type_in_new_solver(\n-        &self,\n-        opaque_type_key: OpaqueTypeKey<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        hidden_ty: Ty<'tcx>,\n-    ) -> InferResult<'tcx, ()> {\n-        assert!(self.next_trait_solver());\n-        self.register_hidden_type(\n-            opaque_type_key,\n-            ObligationCause::dummy(),\n-            param_env,\n-            hidden_ty,\n-            true,\n-        )\n+        Ok(())\n     }\n \n     pub fn add_item_bounds_for_hidden_type("}, {"sha": "e01187bcd3c2a81b05565912d893041360ab715d", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 42, "deletions": 27, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b62e20d2fd5fd186a662c5621a41b717fcc313e0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62e20d2fd5fd186a662c5621a41b717fcc313e0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=b62e20d2fd5fd186a662c5621a41b717fcc313e0", "patch": "@@ -15,8 +15,8 @@ use rustc_middle::traits::solve::{\n };\n use rustc_middle::traits::DefiningAnchor;\n use rustc_middle::ty::{\n-    self, Ty, TyCtxt, TypeFoldable, TypeSuperVisitable, TypeVisitable, TypeVisitableExt,\n-    TypeVisitor,\n+    self, OpaqueTypeKey, Ty, TyCtxt, TypeFoldable, TypeSuperVisitable, TypeVisitable,\n+    TypeVisitableExt, TypeVisitor,\n };\n use rustc_span::DUMMY_SP;\n use std::ops::ControlFlow;\n@@ -191,16 +191,6 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 .with_opaque_type_inference(canonical_input.value.anchor)\n                 .build_with_canonical(DUMMY_SP, &canonical_input);\n \n-            for &(a, b) in &input.predefined_opaques_in_body.opaque_types {\n-                let InferOk { value: (), obligations } = infcx\n-                    .register_hidden_type_in_new_solver(a, input.goal.param_env, b)\n-                    .expect(\"expected opaque type instantiation to succeed\");\n-                // We're only registering opaques already defined by the caller,\n-                // so we're not responsible for proving that they satisfy their\n-                // item bounds, unless we use them in a normalizes-to goal,\n-                // which is handled in `EvalCtxt::unify_existing_opaque_tys`.\n-                let _ = obligations;\n-            }\n             let mut ecx = EvalCtxt {\n                 infcx,\n                 var_values,\n@@ -211,6 +201,15 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 tainted: Ok(()),\n             };\n \n+            for &(key, ty) in &input.predefined_opaques_in_body.opaque_types {\n+                ecx.insert_hidden_type(key, input.goal.param_env, ty)\n+                    .expect(\"failed to prepopulate opaque types\");\n+            }\n+\n+            if !ecx.nested_goals.is_empty() {\n+                panic!(\"prepopulating opaque types shouldn't add goals: {:?}\", ecx.nested_goals);\n+            }\n+\n             let result = ecx.compute_goal(input.goal);\n \n             // When creating a query response we clone the opaque type constraints\n@@ -729,18 +728,42 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         self.infcx.opaque_type_origin(def_id).is_some()\n     }\n \n-    pub(super) fn register_opaque_ty(\n+    pub(super) fn insert_hidden_type(\n         &mut self,\n-        a: ty::OpaqueTypeKey<'tcx>,\n-        b: Ty<'tcx>,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n+        hidden_ty: Ty<'tcx>,\n     ) -> Result<(), NoSolution> {\n-        let InferOk { value: (), obligations } =\n-            self.infcx.register_hidden_type_in_new_solver(a, param_env, b)?;\n-        self.add_goals(obligations.into_iter().map(|obligation| obligation.into()));\n+        let mut obligations = Vec::new();\n+        self.infcx.insert_hidden_type(\n+            opaque_type_key,\n+            &ObligationCause::dummy(),\n+            param_env,\n+            hidden_ty,\n+            true,\n+            &mut obligations,\n+        )?;\n+        self.add_goals(obligations.into_iter().map(|o| o.into()));\n         Ok(())\n     }\n \n+    pub(super) fn add_item_bounds_for_hidden_type(\n+        &mut self,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        hidden_ty: Ty<'tcx>,\n+    ) {\n+        let mut obligations = Vec::new();\n+        self.infcx.add_item_bounds_for_hidden_type(\n+            opaque_type_key,\n+            ObligationCause::dummy(),\n+            param_env,\n+            hidden_ty,\n+            &mut obligations,\n+        );\n+        self.add_goals(obligations.into_iter().map(|o| o.into()));\n+    }\n+\n     // Do something for each opaque/hidden pair defined with `def_id` in the\n     // current inference context.\n     pub(super) fn unify_existing_opaque_tys(\n@@ -762,15 +785,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                     ecx.eq(param_env, a, b)?;\n                 }\n                 ecx.eq(param_env, candidate_ty, ty)?;\n-                let mut obl = vec![];\n-                ecx.infcx.add_item_bounds_for_hidden_type(\n-                    candidate_key,\n-                    ObligationCause::dummy(),\n-                    param_env,\n-                    candidate_ty,\n-                    &mut obl,\n-                );\n-                ecx.add_goals(obl.into_iter().map(Into::into));\n+                ecx.add_item_bounds_for_hidden_type(candidate_key, param_env, candidate_ty);\n                 ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             }));\n         }"}, {"sha": "db6734100088f0d1240526caccd4c862d5e30e8d", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt/canonical.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b62e20d2fd5fd186a662c5621a41b717fcc313e0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62e20d2fd5fd186a662c5621a41b717fcc313e0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs?ref=b62e20d2fd5fd186a662c5621a41b717fcc313e0", "patch": "@@ -15,7 +15,6 @@ use rustc_index::IndexVec;\n use rustc_infer::infer::canonical::query_response::make_query_region_constraints;\n use rustc_infer::infer::canonical::CanonicalVarValues;\n use rustc_infer::infer::canonical::{CanonicalExt, QueryRegionConstraints};\n-use rustc_infer::infer::InferOk;\n use rustc_middle::traits::query::NoSolution;\n use rustc_middle::traits::solve::{\n     ExternalConstraints, ExternalConstraintsData, MaybeCause, PredefinedOpaquesData, QueryInput,\n@@ -317,12 +316,8 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         opaque_types: &[(ty::OpaqueTypeKey<'tcx>, Ty<'tcx>)],\n     ) -> Result<(), NoSolution> {\n-        for &(a, b) in opaque_types {\n-            let InferOk { value: (), obligations } =\n-                self.infcx.register_hidden_type_in_new_solver(a, param_env, b)?;\n-            // It's sound to drop these obligations, since the normalizes-to goal\n-            // is responsible for proving these obligations.\n-            let _ = obligations;\n+        for &(key, ty) in opaque_types {\n+            self.insert_hidden_type(key, param_env, ty)?;\n         }\n         Ok(())\n     }"}, {"sha": "538c16c8ce2cde6eef9a8104e05a4575ed3536d6", "filename": "compiler/rustc_trait_selection/src/solve/opaques.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b62e20d2fd5fd186a662c5621a41b717fcc313e0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fopaques.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62e20d2fd5fd186a662c5621a41b717fcc313e0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fopaques.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fopaques.rs?ref=b62e20d2fd5fd186a662c5621a41b717fcc313e0", "patch": "@@ -50,7 +50,8 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                     }\n                 }\n                 // Otherwise, define a new opaque type\n-                self.register_opaque_ty(opaque_ty, expected, goal.param_env)?;\n+                self.insert_hidden_type(opaque_ty, goal.param_env, expected)?;\n+                self.add_item_bounds_for_hidden_type(opaque_ty, goal.param_env, expected);\n                 self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             }\n             (Reveal::UserFacing, SolverMode::Coherence) => {"}]}