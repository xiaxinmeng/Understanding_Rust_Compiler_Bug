{"sha": "68bc12c3b80b0dce655c8602e683b1989640f00b", "node_id": "C_kwDOAAsO6NoAKDY4YmMxMmMzYjgwYjBkY2U2NTVjODYwMmU2ODNiMTk4OTY0MGYwMGI", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-01-04T16:49:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-04T16:49:47Z"}, "message": "Merge #11157\n\n11157: internal: Remove `SemanticScope::speculative_resolve_as_mac` r=Veykril a=Veykril\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/11132\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "4c19b15ac62d7b645a5bdd71ea482ba606b68eaa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c19b15ac62d7b645a5bdd71ea482ba606b68eaa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68bc12c3b80b0dce655c8602e683b1989640f00b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh1HqrCRBK7hj4Ov3rIwAAY5UIABhpgMNA85TtjkVZvxJe8rG0\nIO7kdDnsFqrhe5pGLSDoVcheH5Cxi8Jvz6PGvEXsjHEIsV/0xTbIlNKnS5jIU9x8\nxbWzSKsUeUwwNaXzCV/I/BetICKG3vhmL4Gp6OqAMqAqUeaym7PBQgJtAU+l4a6U\nnqiTq3/oxszsTAtuGrqIHQUpWrKLd0lmaR/1DP7IlKLX2KtgdCZwQGO7jYK6qB/x\nPh0STiOg0ZN7UeSMt3ASPzy0oIxzkeGqGHg2Q/mU1ZW8YjHqShkW2klltlX5qiYr\nCVvhbSaMJZz7JA0jNG9qT/33X0kjrNXjQL08M7RKfriKw1NuVcBcelqD6VpJ7VM=\n=/mHH\n-----END PGP SIGNATURE-----\n", "payload": "tree 4c19b15ac62d7b645a5bdd71ea482ba606b68eaa\nparent 98df25c350e91c0eebf15fdaa3b26949ea3e91d5\nparent 19f1ff5c7063dac772c1d324d11661393a3b5f7e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1641314987 +0000\ncommitter GitHub <noreply@github.com> 1641314987 +0000\n\nMerge #11157\n\n11157: internal: Remove `SemanticScope::speculative_resolve_as_mac` r=Veykril a=Veykril\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/11132\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68bc12c3b80b0dce655c8602e683b1989640f00b", "html_url": "https://github.com/rust-lang/rust/commit/68bc12c3b80b0dce655c8602e683b1989640f00b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68bc12c3b80b0dce655c8602e683b1989640f00b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98df25c350e91c0eebf15fdaa3b26949ea3e91d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/98df25c350e91c0eebf15fdaa3b26949ea3e91d5", "html_url": "https://github.com/rust-lang/rust/commit/98df25c350e91c0eebf15fdaa3b26949ea3e91d5"}, {"sha": "19f1ff5c7063dac772c1d324d11661393a3b5f7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/19f1ff5c7063dac772c1d324d11661393a3b5f7e", "html_url": "https://github.com/rust-lang/rust/commit/19f1ff5c7063dac772c1d324d11661393a3b5f7e"}], "stats": {"total": 188, "additions": 131, "deletions": 57}, "files": [{"sha": "b685d260815d4033ad31756e6b5bcf089b98246a", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 81, "deletions": 16, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/68bc12c3b80b0dce655c8602e683b1989640f00b/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68bc12c3b80b0dce655c8602e683b1989640f00b/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=68bc12c3b80b0dce655c8602e683b1989640f00b", "patch": "@@ -5,6 +5,7 @@ mod source_to_def;\n use std::{cell::RefCell, fmt};\n \n use base_db::{FileId, FileRange};\n+use either::Either;\n use hir_def::{\n     body,\n     resolver::{self, HasResolver, Resolver, TypeNs},\n@@ -18,13 +19,14 @@ use smallvec::{smallvec, SmallVec};\n use syntax::{\n     algo::skip_trivia_token,\n     ast::{self, HasAttrs, HasGenericParams, HasLoopBody},\n-    match_ast, AstNode, Direction, SyntaxNode, SyntaxNodePtr, SyntaxToken, TextSize,\n+    match_ast, AstNode, AstToken, Direction, SyntaxElement, SyntaxNode, SyntaxNodePtr, SyntaxToken,\n+    TextSize, T,\n };\n \n use crate::{\n     db::HirDatabase,\n     semantics::source_to_def::{ChildContainer, SourceToDefCache, SourceToDefCtx},\n-    source_analyzer::{resolve_hir_path, resolve_hir_path_as_macro, SourceAnalyzer},\n+    source_analyzer::{resolve_hir_path, SourceAnalyzer},\n     Access, AssocItem, BuiltinAttr, Callable, ConstParam, Crate, Field, Function, HasSource,\n     HirFileId, Impl, InFile, Label, LifetimeParam, Local, MacroDef, Module, ModuleDef, Name, Path,\n     ScopeDef, ToolModule, Trait, Type, TypeAlias, TypeParam, VariantDef,\n@@ -354,6 +356,14 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.resolve_bind_pat_to_const(pat)\n     }\n \n+    pub fn resolve_derive_ident(\n+        &self,\n+        derive: &ast::Attr,\n+        ident: &ast::Ident,\n+    ) -> Option<PathResolution> {\n+        self.imp.resolve_derive_ident(derive, ident)\n+    }\n+\n     // FIXME: use this instead?\n     // pub fn resolve_name_ref(&self, name_ref: &ast::NameRef) -> Option<???>;\n \n@@ -471,12 +481,12 @@ impl<'db> SemanticsImpl<'db> {\n     }\n \n     fn derive_macro_calls(&self, attr: &ast::Attr) -> Option<Vec<Option<MacroCallId>>> {\n-        let item = attr.syntax().parent().and_then(ast::Item::cast)?;\n-        let file_id = self.find_file(item.syntax()).file_id;\n-        let item = InFile::new(file_id, &item);\n+        let adt = attr.syntax().parent().and_then(ast::Adt::cast)?;\n+        let file_id = self.find_file(adt.syntax()).file_id;\n+        let adt = InFile::new(file_id, &adt);\n         let src = InFile::new(file_id, attr.clone());\n         self.with_ctx(|ctx| {\n-            let res = ctx.attr_to_derive_macro_call(item, src)?;\n+            let res = ctx.attr_to_derive_macro_call(adt, src)?;\n             Some(res.to_vec())\n         })\n     }\n@@ -894,6 +904,70 @@ impl<'db> SemanticsImpl<'db> {\n         self.analyze(pat.syntax()).resolve_bind_pat_to_const(self.db, pat)\n     }\n \n+    fn resolve_derive_ident(\n+        &self,\n+        derive: &ast::Attr,\n+        ident: &ast::Ident,\n+    ) -> Option<PathResolution> {\n+        debug_assert!(ident.syntax().parent().and_then(ast::TokenTree::cast).is_some());\n+        debug_assert!(ident.syntax().ancestors().any(|anc| anc == *derive.syntax()));\n+        // derive macros are always at depth 2, tokentree -> meta -> attribute\n+        let syntax = ident.syntax();\n+\n+        let tt = derive.token_tree()?;\n+        let file = self.find_file(derive.syntax());\n+        let adt = derive.syntax().parent().and_then(ast::Adt::cast)?;\n+\n+        let res = self.with_ctx(|ctx| {\n+            let attr_def = ctx.attr_to_def(file.with_value(derive.clone()))?;\n+            let derives = ctx.attr_to_derive_macro_call(\n+                file.with_value(&adt),\n+                file.with_value(derive.clone()),\n+            )?;\n+\n+            let mut derive_paths = attr_def.parse_path_comma_token_tree()?;\n+\n+            let derive_idx = tt\n+                .syntax()\n+                .children_with_tokens()\n+                .filter_map(SyntaxElement::into_token)\n+                .take_while(|tok| tok != syntax)\n+                .filter(|t| t.kind() == T![,])\n+                .count();\n+            let path_segment_idx = syntax\n+                .siblings_with_tokens(Direction::Prev)\n+                .filter_map(SyntaxElement::into_token)\n+                .take_while(|tok| matches!(tok.kind(), T![:] | T![ident]))\n+                .filter(|tok| tok.kind() == T![ident])\n+                .count();\n+\n+            let mut mod_path = derive_paths.nth(derive_idx)?;\n+\n+            if path_segment_idx < mod_path.len() {\n+                // the path for the given ident is a qualifier, resolve to module if possible\n+                while path_segment_idx < mod_path.len() {\n+                    mod_path.pop_segment();\n+                }\n+                Some(Either::Left(mod_path))\n+            } else {\n+                // otherwise fetch the derive\n+                Some(Either::Right(derives[derive_idx]))\n+            }\n+        })?;\n+\n+        match res {\n+            Either::Left(path) => resolve_hir_path(\n+                self.db,\n+                &self.scope(derive.syntax()).resolver,\n+                &Path::from_known_path(path, []),\n+            )\n+            .filter(|res| matches!(res, PathResolution::Def(ModuleDef::Module(_)))),\n+            Either::Right(derive) => derive\n+                .map(|call| MacroDef { id: self.db.lookup_intern_macro_call(call).def })\n+                .map(PathResolution::Macro),\n+        }\n+    }\n+\n     fn record_literal_missing_fields(&self, literal: &ast::RecordExpr) -> Vec<(Field, Type)> {\n         self.analyze(literal.syntax())\n             .record_literal_missing_fields(self.db, literal)\n@@ -1151,6 +1225,7 @@ to_def_impls![\n     (crate::Local, ast::SelfParam, self_param_to_def),\n     (crate::Label, ast::Label, label_to_def),\n     (crate::Adt, ast::Adt, adt_to_def),\n+    (crate::Attr, ast::Attr, attr_to_def),\n ];\n \n fn find_root(node: &SyntaxNode) -> SyntaxNode {\n@@ -1230,14 +1305,4 @@ impl<'a> SemanticsScope<'a> {\n         let path = Path::from_src(path.clone(), &ctx)?;\n         resolve_hir_path(self.db, &self.resolver, &path)\n     }\n-\n-    /// Resolve a path as-if it was written at the given scope. This is\n-    /// necessary a heuristic, as it doesn't take hygiene into account.\n-    // FIXME: This special casing solely exists for attributes for now\n-    // ideally we should have a path resolution infra that properly knows about overlapping namespaces\n-    pub fn speculative_resolve_as_mac(&self, path: &ast::Path) -> Option<MacroDef> {\n-        let ctx = body::LowerCtx::new(self.db.upcast(), self.file_id);\n-        let path = Path::from_src(path.clone(), &ctx)?;\n-        resolve_hir_path_as_macro(self.db, &self.resolver, &path)\n-    }\n }"}, {"sha": "fbce53eb166cdd31288ced36dd5767fe0ee47a52", "filename": "crates/hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/68bc12c3b80b0dce655c8602e683b1989640f00b/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68bc12c3b80b0dce655c8602e683b1989640f00b/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=68bc12c3b80b0dce655c8602e683b1989640f00b", "patch": "@@ -210,6 +210,19 @@ impl SourceToDefCtx<'_, '_> {\n             ast::Adt::Union(it) => self.union_to_def(InFile::new(file_id, it)).map(AdtId::UnionId),\n         }\n     }\n+    pub(super) fn attr_to_def(\n+        &mut self,\n+        InFile { file_id, value }: InFile<ast::Attr>,\n+    ) -> Option<crate::Attr> {\n+        // FIXME: Use dynmap?\n+        let adt = value.syntax().parent().and_then(ast::Adt::cast)?;\n+        let attr_pos = ast::HasAttrs::attrs(&adt).position(|it| it == value)?;\n+        let attrs = {\n+            let def = self.adt_to_def(InFile::new(file_id, adt))?;\n+            self.db.attrs(def.into())\n+        };\n+        attrs.get(attr_pos).cloned()\n+    }\n     pub(super) fn bind_pat_to_def(\n         &mut self,\n         src: InFile<ast::IdentPat>,\n@@ -246,7 +259,7 @@ impl SourceToDefCtx<'_, '_> {\n \n     pub(super) fn attr_to_derive_macro_call(\n         &mut self,\n-        item: InFile<&ast::Item>,\n+        item: InFile<&ast::Adt>,\n         src: InFile<ast::Attr>,\n     ) -> Option<&[Option<MacroCallId>]> {\n         let map = self.dyn_map(item)?;"}, {"sha": "ca87b501aa8f5b7e2756ae214ce408491acd91ed", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/68bc12c3b80b0dce655c8602e683b1989640f00b/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68bc12c3b80b0dce655c8602e683b1989640f00b/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=68bc12c3b80b0dce655c8602e683b1989640f00b", "patch": "@@ -720,11 +720,8 @@ impl Attr {\n         Self::from_src(db, ast, hygiene, id)\n     }\n \n-    /// Parses this attribute as a `#[derive]`, returns an iterator that yields all contained paths\n-    /// to derive macros.\n-    ///\n-    /// Returns `None` when the attribute does not have a well-formed `#[derive]` attribute input.\n-    pub(crate) fn parse_derive(&self) -> Option<impl Iterator<Item = ModPath> + '_> {\n+    /// Parses this attribute as a token tree consisting of comma separated paths.\n+    pub fn parse_path_comma_token_tree(&self) -> Option<impl Iterator<Item = ModPath> + '_> {\n         let args = match self.input.as_deref() {\n             Some(AttrInput::TokenTree(args, _)) => args,\n             _ => return None,\n@@ -749,7 +746,11 @@ impl Attr {\n             })\n             .collect::<Vec<_>>();\n \n-        return Some(paths.into_iter());\n+        Some(paths.into_iter())\n+    }\n+\n+    pub fn path(&self) -> &ModPath {\n+        &self.path\n     }\n \n     pub fn string_value(&self) -> Option<&SmolStr> {"}, {"sha": "be749c3b46f4420fbce717a3a3ded8b0d20e95c8", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68bc12c3b80b0dce655c8602e683b1989640f00b/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68bc12c3b80b0dce655c8602e683b1989640f00b/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=68bc12c3b80b0dce655c8602e683b1989640f00b", "patch": "@@ -1145,7 +1145,7 @@ impl DefCollector<'_> {\n                             }\n                         }\n \n-                        match attr.parse_derive() {\n+                        match attr.parse_path_comma_token_tree() {\n                             Some(derive_macros) => {\n                                 let mut len = 0;\n                                 for (idx, path) in derive_macros.enumerate() {"}, {"sha": "4d638e687ae35d0f7c199eacf38cfc58b78190bc", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/68bc12c3b80b0dce655c8602e683b1989640f00b/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68bc12c3b80b0dce655c8602e683b1989640f00b/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=68bc12c3b80b0dce655c8602e683b1989640f00b", "patch": "@@ -1381,6 +1381,18 @@ mod foo {\n            // ^^^^\n }\n #[derive(foo::Copy$0)]\n+struct Foo;\n+            \"#,\n+        );\n+        check(\n+            r#\"\n+//- minicore:derive\n+mod foo {\n+ // ^^^\n+    #[rustc_builtin_macro]\n+    pub macro Copy {}\n+}\n+#[derive(foo$0::Copy)]\n struct Foo;\n             \"#,\n         );"}, {"sha": "84732aef5499c52bd5e9be9236628b2ca71dfd8d", "filename": "crates/ide/src/syntax_highlighting/highlight.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/68bc12c3b80b0dce655c8602e683b1989640f00b/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68bc12c3b80b0dce655c8602e683b1989640f00b/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs?ref=68bc12c3b80b0dce655c8602e683b1989640f00b", "patch": "@@ -3,7 +3,7 @@\n use hir::{AsAssocItem, HasVisibility, Semantics};\n use ide_db::{\n     defs::{Definition, NameClass, NameRefClass},\n-    helpers::{try_resolve_derive_input, FamousDefs},\n+    helpers::FamousDefs,\n     RootDatabase, SymbolKind,\n };\n use rustc_hash::FxHashMap;\n@@ -39,16 +39,17 @@ pub(super) fn token(\n         INT_NUMBER | FLOAT_NUMBER => HlTag::NumericLiteral.into(),\n         BYTE => HlTag::ByteLiteral.into(),\n         CHAR => HlTag::CharLiteral.into(),\n-        IDENT if parent_matches::<ast::TokenTree>(&token) => {\n-            match token.ancestors().nth(2).and_then(ast::Attr::cast) {\n-                Some(attr) => {\n-                    match try_resolve_derive_input(sema, &attr, &ast::Ident::cast(token).unwrap()) {\n-                        Some(res) => highlight_def(sema, krate, Definition::from(res)),\n-                        None => HlTag::None.into(),\n-                    }\n-                }\n-                None => HlTag::None.into(),\n-            }\n+        IDENT => {\n+            let tt = ast::TokenTree::cast(token.parent()?)?;\n+            let ident = ast::Ident::cast(token)?;\n+            // from this point on we are inside a token tree, this only happens for identifiers\n+            // that were not mapped down into macro invocations\n+            (|| {\n+                let attr = tt.parent_meta()?.parent_attr()?;\n+                let res = sema.resolve_derive_ident(&attr, &ident)?;\n+                Some(highlight_def(sema, krate, Definition::from(res)))\n+            })()\n+            .unwrap_or_else(|| HlTag::None.into())\n         }\n         p if p.is_punct() => punctuation(sema, token, p),\n         k if k.is_keyword() => keyword(sema, token, k)?,"}, {"sha": "1501c4eda53aa9a4bb495d3473388b87193dc934", "filename": "crates/ide_db/src/defs.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/68bc12c3b80b0dce655c8602e683b1989640f00b/crates%2Fide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68bc12c3b80b0dce655c8602e683b1989640f00b/crates%2Fide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fdefs.rs?ref=68bc12c3b80b0dce655c8602e683b1989640f00b", "patch": "@@ -17,7 +17,7 @@ use syntax::{\n     match_ast, AstToken, SyntaxKind, SyntaxNode, SyntaxToken,\n };\n \n-use crate::{helpers::try_resolve_derive_input, RootDatabase};\n+use crate::RootDatabase;\n \n // FIXME: a more precise name would probably be `Symbol`?\n #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n@@ -56,7 +56,8 @@ impl Definition {\n                 .and_then(|tt| tt.parent_meta())\n                 .and_then(|meta| meta.parent_attr());\n             if let Some(attr) = attr {\n-                return try_resolve_derive_input(&sema, &attr, &ident)\n+                return sema\n+                    .resolve_derive_ident(&attr, &ident)\n                     .map(Into::into)\n                     .into_iter()\n                     .collect();"}, {"sha": "344f8db8d00a7569d6a3cf8064fce49cb7455eda", "filename": "crates/ide_db/src/helpers.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/68bc12c3b80b0dce655c8602e683b1989640f00b/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68bc12c3b80b0dce655c8602e683b1989640f00b/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers.rs?ref=68bc12c3b80b0dce655c8602e683b1989640f00b", "patch": "@@ -74,26 +74,6 @@ pub fn get_path_at_cursor_in_tt(cursor: &ast::Ident) -> Option<ast::Path> {\n         })\n }\n \n-/// Parses and resolves the path at the cursor position in the given attribute, if it is a derive.\n-/// This special case is required because the derive macro is a compiler builtin that discards the input derives.\n-pub fn try_resolve_derive_input(\n-    sema: &hir::Semantics<RootDatabase>,\n-    attr: &ast::Attr,\n-    cursor: &ast::Ident,\n-) -> Option<PathResolution> {\n-    let path = get_path_in_derive_attr(sema, attr, cursor)?;\n-    let scope = sema.scope(attr.syntax());\n-    // FIXME: This double resolve shouldn't be necessary\n-    // It's only here so we prefer macros over other namespaces\n-    match scope.speculative_resolve_as_mac(&path) {\n-        Some(mac) if mac.kind() == hir::MacroKind::Derive => Some(PathResolution::Macro(mac)),\n-        Some(_) => return None,\n-        None => scope\n-            .speculative_resolve(&path)\n-            .filter(|res| matches!(res, PathResolution::Def(ModuleDef::Module(_)))),\n-    }\n-}\n-\n /// Picks the token with the highest rank returned by the passed in function.\n pub fn pick_best_token(\n     tokens: TokenAtOffset<SyntaxToken>,"}, {"sha": "2356750bceb86c16f1c4a3bcd53cf595ba56962d", "filename": "crates/ide_db/src/helpers/import_assets.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/68bc12c3b80b0dce655c8602e683b1989640f00b/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68bc12c3b80b0dce655c8602e683b1989640f00b/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs?ref=68bc12c3b80b0dce655c8602e683b1989640f00b", "patch": "@@ -146,6 +146,7 @@ impl ImportAssets {\n         if let Some(_) = path.qualifier() {\n             return None;\n         }\n+\n         let name = NameToImport::exact_case_sensitive(path.segment()?.name_ref()?.to_string());\n         let candidate_node = attr.syntax().clone();\n         Some(Self {"}]}