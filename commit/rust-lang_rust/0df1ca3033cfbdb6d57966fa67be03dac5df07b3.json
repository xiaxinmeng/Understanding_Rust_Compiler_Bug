{"sha": "0df1ca3033cfbdb6d57966fa67be03dac5df07b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkZjFjYTMwMzNjZmJkYjZkNTc5NjZmYTY3YmUwM2RhYzVkZjA3YjM=", "commit": {"author": {"name": "jumbatm", "email": "jumbatm@gmail.com", "date": "2020-01-31T20:57:50Z"}, "committer": {"name": "jumbatm", "email": "jumbatm@gmail.com", "date": "2020-02-11T09:47:40Z"}, "message": "Box `decorate` to avoid code bloat.", "tree": {"sha": "3a23b0f1d521c289ddb6860781719d731ee51874", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a23b0f1d521c289ddb6860781719d731ee51874"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0df1ca3033cfbdb6d57966fa67be03dac5df07b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0df1ca3033cfbdb6d57966fa67be03dac5df07b3", "html_url": "https://github.com/rust-lang/rust/commit/0df1ca3033cfbdb6d57966fa67be03dac5df07b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0df1ca3033cfbdb6d57966fa67be03dac5df07b3/comments", "author": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c58ffe874142e1943e2674d7e75989938a7d21b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c58ffe874142e1943e2674d7e75989938a7d21b", "html_url": "https://github.com/rust-lang/rust/commit/7c58ffe874142e1943e2674d7e75989938a7d21b"}], "stats": {"total": 226, "additions": 119, "deletions": 107}, "files": [{"sha": "a9273fcb8acdebd2ae8ebca274047b4e740184ef", "filename": "src/librustc/lint.rs", "status": "modified", "additions": 119, "deletions": 107, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/0df1ca3033cfbdb6d57966fa67be03dac5df07b3/src%2Flibrustc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0df1ca3033cfbdb6d57966fa67be03dac5df07b3/src%2Flibrustc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint.rs?ref=0df1ca3033cfbdb6d57966fa67be03dac5df07b3", "patch": "@@ -191,134 +191,146 @@ impl<'a> LintDiagnosticBuilder<'a> {\n     }\n }\n \n-pub fn struct_lint_level<'s>(\n+pub fn struct_lint_level<'s, 'd>(\n     sess: &'s Session,\n     lint: &'static Lint,\n     level: Level,\n     src: LintSource,\n     span: Option<MultiSpan>,\n-    decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>)) {\n-\n-    // FIXME: Move the guts of this function into a fn which takes dyn Fn to reduce code bloat.\n-    let mut err = match (level, span) {\n-        (Level::Allow, _) => { return; },\n-        (Level::Warn, Some(span)) => sess.struct_span_warn(span, \"\"),\n-        (Level::Warn, None) => sess.struct_warn(\"\"),\n-        (Level::Deny, Some(span)) | (Level::Forbid, Some(span)) => sess.struct_span_err(span, \"\"),\n-        (Level::Deny, None) | (Level::Forbid, None) => sess.struct_err(\"\"),\n-    };\n+    decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>) + 'd,\n+) {\n+    // Avoid codegen bloat from monomorphization by immediately doing dyn dispatch of `decorate` to\n+    // the \"real\" work.\n+    fn struct_lint_level_impl(\n+        sess: &'s Session,\n+        lint: &'static Lint,\n+        level: Level,\n+        src: LintSource,\n+        span: Option<MultiSpan>,\n+        decorate: Box<dyn for<'b> FnOnce(LintDiagnosticBuilder<'b>) + 'd>) {\n+        let mut err = match (level, span) {\n+            (Level::Allow, _) => {\n+                return;\n+            }\n+            (Level::Warn, Some(span)) => sess.struct_span_warn(span, \"\"),\n+            (Level::Warn, None) => sess.struct_warn(\"\"),\n+            (Level::Deny, Some(span)) | (Level::Forbid, Some(span)) => sess.struct_span_err(span, \"\"),\n+            (Level::Deny, None) | (Level::Forbid, None) => sess.struct_err(\"\"),\n+        };\n \n-    // Check for future incompatibility lints and issue a stronger warning.\n-    let lint_id = LintId::of(lint);\n-    let future_incompatible = lint.future_incompatible;\n-\n-    // If this code originates in a foreign macro, aka something that this crate\n-    // did not itself author, then it's likely that there's nothing this crate\n-    // can do about it. We probably want to skip the lint entirely.\n-    if err.span.primary_spans().iter().any(|s| in_external_macro(sess, *s)) {\n-        // Any suggestions made here are likely to be incorrect, so anything we\n-        // emit shouldn't be automatically fixed by rustfix.\n-        err.allow_suggestions(false);\n-\n-        // If this is a future incompatible lint it'll become a hard error, so\n-        // we have to emit *something*. Also allow lints to whitelist themselves\n-        // on a case-by-case basis for emission in a foreign macro.\n-        if future_incompatible.is_none() && !lint.report_in_external_macro {\n-            err.cancel();\n-            // Don't continue further, since we don't want to have\n-            // `diag_span_note_once` called for a diagnostic that isn't emitted.\n-            return;\n+        // Check for future incompatibility lints and issue a stronger warning.\n+        let lint_id = LintId::of(lint);\n+        let future_incompatible = lint.future_incompatible;\n+\n+        // If this code originates in a foreign macro, aka something that this crate\n+        // did not itself author, then it's likely that there's nothing this crate\n+        // can do about it. We probably want to skip the lint entirely.\n+        if err.span.primary_spans().iter().any(|s| in_external_macro(sess, *s)) {\n+            // Any suggestions made here are likely to be incorrect, so anything we\n+            // emit shouldn't be automatically fixed by rustfix.\n+            err.allow_suggestions(false);\n+\n+            // If this is a future incompatible lint it'll become a hard error, so\n+            // we have to emit *something*. Also allow lints to whitelist themselves\n+            // on a case-by-case basis for emission in a foreign macro.\n+            if future_incompatible.is_none() && !lint.report_in_external_macro {\n+                err.cancel();\n+                // Don't continue further, since we don't want to have\n+                // `diag_span_note_once` called for a diagnostic that isn't emitted.\n+                return;\n+            }\n         }\n-    }\n \n-    let name = lint.name_lower();\n-    match src {\n-        LintSource::Default => {\n-            sess.diag_note_once(\n-                &mut err,\n-                DiagnosticMessageId::from(lint),\n-                &format!(\"`#[{}({})]` on by default\", level.as_str(), name),\n-            );\n-        }\n-        LintSource::CommandLine(lint_flag_val) => {\n-            let flag = match level {\n-                Level::Warn => \"-W\",\n-                Level::Deny => \"-D\",\n-                Level::Forbid => \"-F\",\n-                Level::Allow => panic!(),\n-            };\n-            let hyphen_case_lint_name = name.replace(\"_\", \"-\");\n-            if lint_flag_val.as_str() == name {\n+        let name = lint.name_lower();\n+        match src {\n+            LintSource::Default => {\n                 sess.diag_note_once(\n                     &mut err,\n                     DiagnosticMessageId::from(lint),\n-                    &format!(\n-                        \"requested on the command line with `{} {}`\",\n-                        flag, hyphen_case_lint_name\n-                    ),\n-                );\n-            } else {\n-                let hyphen_case_flag_val = lint_flag_val.as_str().replace(\"_\", \"-\");\n-                sess.diag_note_once(\n-                    &mut err,\n-                    DiagnosticMessageId::from(lint),\n-                    &format!(\n-                        \"`{} {}` implied by `{} {}`\",\n-                        flag, hyphen_case_lint_name, flag, hyphen_case_flag_val\n-                    ),\n+                    &format!(\"`#[{}({})]` on by default\", level.as_str(), name),\n                 );\n             }\n-        }\n-        LintSource::Node(lint_attr_name, src, reason) => {\n-            if let Some(rationale) = reason {\n-                err.note(&rationale.as_str());\n+            LintSource::CommandLine(lint_flag_val) => {\n+                let flag = match level {\n+                    Level::Warn => \"-W\",\n+                    Level::Deny => \"-D\",\n+                    Level::Forbid => \"-F\",\n+                    Level::Allow => panic!(),\n+                };\n+                let hyphen_case_lint_name = name.replace(\"_\", \"-\");\n+                if lint_flag_val.as_str() == name {\n+                    sess.diag_note_once(\n+                        &mut err,\n+                        DiagnosticMessageId::from(lint),\n+                        &format!(\n+                            \"requested on the command line with `{} {}`\",\n+                            flag, hyphen_case_lint_name\n+                        ),\n+                    );\n+                } else {\n+                    let hyphen_case_flag_val = lint_flag_val.as_str().replace(\"_\", \"-\");\n+                    sess.diag_note_once(\n+                        &mut err,\n+                        DiagnosticMessageId::from(lint),\n+                        &format!(\n+                            \"`{} {}` implied by `{} {}`\",\n+                            flag, hyphen_case_lint_name, flag, hyphen_case_flag_val\n+                        ),\n+                    );\n+                }\n             }\n-            sess.diag_span_note_once(\n-                &mut err,\n-                DiagnosticMessageId::from(lint),\n-                src,\n-                \"the lint level is defined here\",\n-            );\n-            if lint_attr_name.as_str() != name {\n-                let level_str = level.as_str();\n-                sess.diag_note_once(\n+            LintSource::Node(lint_attr_name, src, reason) => {\n+                if let Some(rationale) = reason {\n+                    err.note(&rationale.as_str());\n+                }\n+                sess.diag_span_note_once(\n                     &mut err,\n                     DiagnosticMessageId::from(lint),\n-                    &format!(\n-                        \"`#[{}({})]` implied by `#[{}({})]`\",\n-                        level_str, name, level_str, lint_attr_name\n-                    ),\n+                    src,\n+                    \"the lint level is defined here\",\n                 );\n+                if lint_attr_name.as_str() != name {\n+                    let level_str = level.as_str();\n+                    sess.diag_note_once(\n+                        &mut err,\n+                        DiagnosticMessageId::from(lint),\n+                        &format!(\n+                            \"`#[{}({})]` implied by `#[{}({})]`\",\n+                            level_str, name, level_str, lint_attr_name\n+                        ),\n+                    );\n+                }\n             }\n         }\n-    }\n \n-    err.code(DiagnosticId::Lint(name));\n-\n-    if let Some(future_incompatible) = future_incompatible {\n-        const STANDARD_MESSAGE: &str = \"this was previously accepted by the compiler but is being phased out; \\\n-             it will become a hard error\";\n-\n-        let explanation = if lint_id == LintId::of(builtin::UNSTABLE_NAME_COLLISIONS) {\n-            \"once this method is added to the standard library, \\\n-             the ambiguity may cause an error or change in behavior!\"\n-                .to_owned()\n-        } else if lint_id == LintId::of(builtin::MUTABLE_BORROW_RESERVATION_CONFLICT) {\n-            \"this borrowing pattern was not meant to be accepted, \\\n-             and may become a hard error in the future\"\n-                .to_owned()\n-        } else if let Some(edition) = future_incompatible.edition {\n-            format!(\"{} in the {} edition!\", STANDARD_MESSAGE, edition)\n-        } else {\n-            format!(\"{} in a future release!\", STANDARD_MESSAGE)\n-        };\n-        let citation = format!(\"for more information, see {}\", future_incompatible.reference);\n-        err.warn(&explanation);\n-        err.note(&citation);\n-    }\n+        err.code(DiagnosticId::Lint(name));\n+\n+        if let Some(future_incompatible) = future_incompatible {\n+            const STANDARD_MESSAGE: &str = \"this was previously accepted by the compiler but is being phased out; \\\n+                 it will become a hard error\";\n+\n+            let explanation = if lint_id == LintId::of(builtin::UNSTABLE_NAME_COLLISIONS) {\n+                \"once this method is added to the standard library, \\\n+                 the ambiguity may cause an error or change in behavior!\"\n+                    .to_owned()\n+            } else if lint_id == LintId::of(builtin::MUTABLE_BORROW_RESERVATION_CONFLICT) {\n+                \"this borrowing pattern was not meant to be accepted, \\\n+                 and may become a hard error in the future\"\n+                    .to_owned()\n+            } else if let Some(edition) = future_incompatible.edition {\n+                format!(\"{} in the {} edition!\", STANDARD_MESSAGE, edition)\n+            } else {\n+                format!(\"{} in a future release!\", STANDARD_MESSAGE)\n+            };\n+            let citation = format!(\"for more information, see {}\", future_incompatible.reference);\n+            err.warn(&explanation);\n+            err.note(&citation);\n+        }\n \n-    // Finally, run `decorate`. This function is also responsible for emitting the diagnostic.\n-    decorate(LintDiagnosticBuilder::new(err));\n+        // Finally, run `decorate`. This function is also responsible for emitting the diagnostic.\n+        decorate(LintDiagnosticBuilder::new(err));\n+    }\n+    struct_lint_level_impl(sess, lint, level, src, span, Box::new(decorate))\n }\n \n /// Returns whether `span` originates in a foreign crate's external macro."}]}