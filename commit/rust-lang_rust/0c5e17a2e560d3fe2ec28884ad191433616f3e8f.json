{"sha": "0c5e17a2e560d3fe2ec28884ad191433616f3e8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjNWUxN2EyZTU2MGQzZmUyZWMyODg4NGFkMTkxNDMzNjE2ZjNlOGY=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2017-02-21T05:32:52Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2017-02-21T19:02:00Z"}, "message": "types", "tree": {"sha": "ff19bbedb108e8a796ab64a31d830c45effa525e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff19bbedb108e8a796ab64a31d830c45effa525e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c5e17a2e560d3fe2ec28884ad191433616f3e8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c5e17a2e560d3fe2ec28884ad191433616f3e8f", "html_url": "https://github.com/rust-lang/rust/commit/0c5e17a2e560d3fe2ec28884ad191433616f3e8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c5e17a2e560d3fe2ec28884ad191433616f3e8f/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3de961972f2ed997988e775eed07b372be64cb8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3de961972f2ed997988e775eed07b372be64cb8b", "html_url": "https://github.com/rust-lang/rust/commit/3de961972f2ed997988e775eed07b372be64cb8b"}], "stats": {"total": 22, "additions": 11, "deletions": 11}, "files": [{"sha": "2ddcba177e35df92ce78b81b2a5431367b524c23", "filename": "src/doc/reference/src/types.md", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0c5e17a2e560d3fe2ec28884ad191433616f3e8f/src%2Fdoc%2Freference%2Fsrc%2Ftypes.md", "raw_url": "https://github.com/rust-lang/rust/raw/0c5e17a2e560d3fe2ec28884ad191433616f3e8f/src%2Fdoc%2Freference%2Fsrc%2Ftypes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Ftypes.md?ref=0c5e17a2e560d3fe2ec28884ad191433616f3e8f", "patch": "@@ -131,7 +131,7 @@ A `struct` *type* is a heterogeneous product of other types, called the\n     or the *struct* types of the Lisp family.\n \n New instances of a `struct` can be constructed with a [struct\n-expression](#struct-expressions).\n+expression](expressions.html#struct-expressions).\n \n The memory layout of a `struct` is undefined by default to allow for compiler\n optimizations like field reordering, but it can be fixed with the\n@@ -140,37 +140,37 @@ a corresponding struct *expression*; the resulting `struct` value will always\n have the same memory layout.\n \n The fields of a `struct` may be qualified by [visibility\n-modifiers](#visibility-and-privacy), to allow access to data in a\n+modifiers](visibility-and-privacy.html), to allow access to data in a\n struct outside a module.\n \n A _tuple struct_ type is just like a struct type, except that the fields are\n anonymous.\n \n A _unit-like struct_ type is like a struct type, except that it has no\n fields. The one value constructed by the associated [struct\n-expression](#struct-expressions) is the only value that inhabits such a\n+expression](expressions.html#struct-expressions) is the only value that inhabits such a\n type.\n \n ## Enumerated types\n \n An *enumerated type* is a nominal, heterogeneous disjoint union type, denoted\n-by the name of an [`enum` item](#enumerations). [^enumtype]\n+by the name of an [`enum` item](items.html#enumerations). [^enumtype]\n \n [^enumtype]: The `enum` type is analogous to a `data` constructor declaration in\n              ML, or a *pick ADT* in Limbo.\n \n-An [`enum` item](#enumerations) declares both the type and a number of *variant\n+An [`enum` item](items.html#enumerations) declares both the type and a number of *variant\n constructors*, each of which is independently named and takes an optional tuple\n of arguments.\n \n New instances of an `enum` can be constructed by calling one of the variant\n-constructors, in a [call expression](#call-expressions).\n+constructors, in a [call expression](expressions.html#call-expressions).\n \n Any `enum` value consumes as much memory as the largest variant constructor for\n its corresponding `enum` type.\n \n Enum types cannot be denoted *structurally* as types, but must be denoted by\n-named reference to an [`enum` item](#enumerations).\n+named reference to an [`enum` item](items.html#enumerations).\n \n ## Recursive types\n \n@@ -180,7 +180,7 @@ constructor or `struct` field may refer, directly or indirectly, to the\n enclosing `enum` or `struct` type itself. Such recursion has restrictions:\n \n * Recursive types must include a nominal type in the recursion\n-  (not mere [type definitions](grammar.html#type-definitions),\n+  (not mere [type definitions](../grammar.html#type-definitions),\n    or other structural types such as [arrays](#array-and-slice-types) or [tuples](#tuple-types)).\n * A recursive `enum` item must have at least one non-recursive constructor\n   (in order to give the recursion a basis case).\n@@ -222,7 +222,7 @@ varieties of pointer in Rust:\n     for example `*const i32` means a raw pointer to a 32-bit integer.\n     Copying or dropping a raw pointer has no effect on the lifecycle of any\n     other value. Dereferencing a raw pointer or converting it to any other\n-    pointer type is an [`unsafe` operation](#unsafe-functions).\n+    pointer type is an [`unsafe` operation](unsafe-functions.html).\n     Raw pointers are generally discouraged in Rust code;\n     they exist to support interoperability with foreign code,\n     and writing performance-critical or low-level functions.\n@@ -268,8 +268,8 @@ messages to indicate \"the unique fn type for the function `foo`\".\n \n ## Closure types\n \n-A [lambda expression](#lambda-expressions) produces a closure value with\n-a unique, anonymous type that cannot be written out.\n+A [lambda expression](expressions.html#lambda-expressions) produces a closure\n+value with a unique, anonymous type that cannot be written out.\n \n Depending on the requirements of the closure, its type implements one or\n more of the closure traits:"}]}