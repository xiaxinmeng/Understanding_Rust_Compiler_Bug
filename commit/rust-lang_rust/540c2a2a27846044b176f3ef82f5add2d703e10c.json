{"sha": "540c2a2a27846044b176f3ef82f5add2d703e10c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0MGMyYTJhMjc4NDYwNDRiMTc2ZjNlZjgyZjVhZGQyZDcwM2UxMGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-04T08:01:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-04T08:01:51Z"}, "message": "auto merge of #13255 : alexcrichton/rust/issue-5605, r=huonw\n\nThese syntax extensions need a place to be documented, and this starts passing a\r\n`--cfg dox` parameter to `rustdoc` when building and testing documentation in\r\norder to document macros so that they have no effect on the compiled crate, but\r\nonly documentation.\r\n\r\nCloses #5605", "tree": {"sha": "344d9b60b3abed0a6ae934af86b3dd0cfa5a1a06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/344d9b60b3abed0a6ae934af86b3dd0cfa5a1a06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/540c2a2a27846044b176f3ef82f5add2d703e10c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/540c2a2a27846044b176f3ef82f5add2d703e10c", "html_url": "https://github.com/rust-lang/rust/commit/540c2a2a27846044b176f3ef82f5add2d703e10c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/540c2a2a27846044b176f3ef82f5add2d703e10c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7056f97093a5b0bee3cacbdee2f9a60cfc1488f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/7056f97093a5b0bee3cacbdee2f9a60cfc1488f0", "html_url": "https://github.com/rust-lang/rust/commit/7056f97093a5b0bee3cacbdee2f9a60cfc1488f0"}, {"sha": "78937b9779b1dac99546922740935aa96c87b6be", "url": "https://api.github.com/repos/rust-lang/rust/commits/78937b9779b1dac99546922740935aa96c87b6be", "html_url": "https://github.com/rust-lang/rust/commit/78937b9779b1dac99546922740935aa96c87b6be"}], "stats": {"total": 289, "additions": 277, "deletions": 12}, "files": [{"sha": "fab828571cd4f508a97f4032b4332a131004b3cb", "filename": "mk/docs.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/540c2a2a27846044b176f3ef82f5add2d703e10c/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/540c2a2a27846044b176f3ef82f5add2d703e10c/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=540c2a2a27846044b176f3ef82f5add2d703e10c", "patch": "@@ -271,7 +271,7 @@ endif\n $(2) += doc/$(1)/index.html\n doc/$(1)/index.html: $$(LIB_DOC_DEP_$(1))\n \t@$$(call E, rustdoc $$@)\n-\t$$(Q)$$(RUSTDOC) --cfg stage2 $$<\n+\t$$(Q)$$(RUSTDOC) --cfg dox --cfg stage2 $$<\n endef\n \n $(foreach crate,$(DOC_CRATES),$(eval $(call DEF_LIB_DOC,$(crate),DOC_TARGETS)))"}, {"sha": "5860c2f252cbdeecda59204fdc1471840eecf67a", "filename": "mk/tests.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/540c2a2a27846044b176f3ef82f5add2d703e10c/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/540c2a2a27846044b176f3ef82f5add2d703e10c/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=540c2a2a27846044b176f3ef82f5add2d703e10c", "patch": "@@ -694,7 +694,7 @@ endif\n ifeq ($(2),$$(CFG_BUILD))\n $$(call TEST_OK_FILE,$(1),$(2),$(3),doc-$(4)): $$(DOCTESTDEP_$(1)_$(2)_$(3)_$(4))\n \t@$$(call E, run doc-$(4) [$(2)])\n-\t$$(Q)$$(RUSTDOC_$(1)_T_$(2)_H_$(3)) --test $$< --test-args \"$$(TESTARGS)\" && touch $$@\n+\t$$(Q)$$(RUSTDOC_$(1)_T_$(2)_H_$(3)) --cfg dox --test $$< --test-args \"$$(TESTARGS)\" && touch $$@\n else\n $$(call TEST_OK_FILE,$(1),$(2),$(3),doc-$(4)):\n \ttouch $$@"}, {"sha": "5e53632dbba55b75ca0ad31b998c24d4801eeea1", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/540c2a2a27846044b176f3ef82f5add2d703e10c/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/540c2a2a27846044b176f3ef82f5add2d703e10c/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=540c2a2a27846044b176f3ef82f5add2d703e10c", "patch": "@@ -168,14 +168,16 @@ pub fn main_args(args: &[~str]) -> int {\n     let markdown_input = input.ends_with(\".md\") || input.ends_with(\".markdown\");\n \n     let output = matches.opt_str(\"o\").map(|s| Path::new(s));\n+    let cfgs = matches.opt_strs(\"cfg\");\n \n     match (should_test, markdown_input) {\n         (true, true) => {\n             return markdown::test(input,\n                                   libs,\n                                   test_args.move_iter().collect())\n         }\n-        (true, false) => return test::run(input, libs, test_args),\n+        (true, false) => return test::run(input, cfgs.move_iter().collect(),\n+                                          libs, test_args),\n \n         (false, true) => return markdown::render(input, output.unwrap_or(Path::new(\"doc\")),\n                                                  &matches),"}, {"sha": "2138d210443f5f07d27a1964c951910b286644cb", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/540c2a2a27846044b176f3ef82f5add2d703e10c/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/540c2a2a27846044b176f3ef82f5add2d703e10c/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=540c2a2a27846044b176f3ef82f5add2d703e10c", "patch": "@@ -22,8 +22,10 @@ use rustc::back::link;\n use rustc::driver::driver;\n use rustc::driver::session;\n use rustc::metadata::creader::Loader;\n+use syntax::ast;\n+use syntax::codemap::{CodeMap, dummy_spanned};\n use syntax::diagnostic;\n-use syntax::codemap::CodeMap;\n+use syntax::parse::token;\n \n use core;\n use clean;\n@@ -33,7 +35,8 @@ use html::markdown;\n use passes;\n use visit_ast::RustdocVisitor;\n \n-pub fn run(input: &str, libs: HashSet<Path>, mut test_args: Vec<~str>) -> int {\n+pub fn run(input: &str, cfgs: Vec<~str>,\n+           libs: HashSet<Path>, mut test_args: Vec<~str>) -> int {\n     let input_path = Path::new(input);\n     let input = driver::FileInput(input_path.clone());\n \n@@ -54,7 +57,11 @@ pub fn run(input: &str, libs: HashSet<Path>, mut test_args: Vec<~str>) -> int {\n                                       Some(input_path),\n                                       span_diagnostic_handler);\n \n-    let cfg = driver::build_configuration(&sess);\n+    let mut cfg = driver::build_configuration(&sess);\n+    cfg.extend(cfgs.move_iter().map(|cfg_| {\n+        let cfg_ = token::intern_and_get_ident(cfg_);\n+        @dummy_spanned(ast::MetaWord(cfg_))\n+    }));\n     let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n     let (krate, _) = driver::phase_2_configure_and_expand(&sess, &mut Loader::new(&sess), krate,\n                                                           &from_str(\"rustdoc-test\").unwrap());\n@@ -160,17 +167,14 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n \n fn maketest(s: &str, cratename: &str, loose_feature_gating: bool) -> ~str {\n     let mut prog = ~r\"\n-#[deny(warnings)];\n-#[allow(unused_variable, dead_assignment, unused_mut, attribute_usage, dead_code)];\n-\n-// FIXME: remove when ~[] disappears from tests.\n-#[allow(deprecated_owned_vector)];\n+#![deny(warnings)]\n+#![allow(unused_variable, dead_assignment, unused_mut, attribute_usage, dead_code)]\n \";\n \n     if loose_feature_gating {\n         // FIXME #12773: avoid inserting these when the tutorial & manual\n         // etc. have been updated to not use them so prolifically.\n-        prog.push_str(\"#[ feature(macro_rules, globs, struct_variant, managed_boxes) ];\\n\");\n+        prog.push_str(\"#![feature(macro_rules, globs, struct_variant, managed_boxes) ]\\n\");\n     }\n \n     if !s.contains(\"extern crate\") {"}, {"sha": "1a35252f8cadda48a178b24db40b27dcc8734b24", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 259, "deletions": 0, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/540c2a2a27846044b176f3ef82f5add2d703e10c/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/540c2a2a27846044b176f3ef82f5add2d703e10c/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=540c2a2a27846044b176f3ef82f5add2d703e10c", "patch": "@@ -332,3 +332,262 @@ macro_rules! log (\n         if log_enabled!($lvl) { println!($($args)*) }\n     )\n )\n+\n+/// Built-in macros to the compiler itself.\n+///\n+/// These macros do not have any corresponding definition with a `macro_rules!`\n+/// macro, but are documented here. Their implementations can be found hardcoded\n+/// into libsyntax itself.\n+#[cfg(dox)]\n+pub mod builtin {\n+    /// The core macro for formatted string creation & output.\n+    ///\n+    /// This macro takes as its first argument a callable expression which will\n+    /// receive as its first argument a value of type `&fmt::Arguments`. This\n+    /// value can be passed to the functions in `std::fmt` for performing useful\n+    /// functions. All other formatting macros (`format!`, `write!`,\n+    /// `println!`, etc) are proxied through this one.\n+    ///\n+    /// For more information, see the documentation in `std::fmt`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// let s = format_args!(fmt::format, \"hello {}\", \"world\");\n+    /// assert_eq!(s, format!(\"hello {}\", \"world\"));\n+    ///\n+    /// format_args!(|args| {\n+    ///     // pass `args` to another function, etc.\n+    /// }, \"hello {}\", \"world\");\n+    /// ```\n+    #[macro_export]\n+    macro_rules! format_args( ($closure:expr, $fmt:expr $($args:tt)*) => ({\n+        /* compiler built-in */\n+    }) )\n+\n+    /// Inspect an environment variable at compile time.\n+    ///\n+    /// This macro will expand to the value of the named environment variable at\n+    /// compile time, yielding an expression of type `&'static str`.\n+    ///\n+    /// If the environment variable is not defined, then a compilation error\n+    /// will be emitted.  To not emit a compile error, use the `option_env!`\n+    /// macro instead.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let user: &'static str = env!(\"USER\");\n+    /// println!(\"the user who compiled this code is: {}\", user);\n+    /// ```\n+    #[macro_export]\n+    macro_rules! env( ($name:expr) => ({ /* compiler built-in */ }) )\n+\n+    /// Optionally inspect an environment variable at compile time.\n+    ///\n+    /// If the named environment variable is present at compile time, this will\n+    /// expand into an expression of type `Option<&'static str>` whose value is\n+    /// `Some` of the value of the environment variable. If the environment\n+    /// variable is not present, then this will expand to `None`.\n+    ///\n+    /// A compile time error is never emitted when using this macro regardless\n+    /// of whether the environment variable is present or not.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let key: Option<&'static str> = option_env!(\"SECRET_KEY\");\n+    /// println!(\"the secret key might be: {}\", key);\n+    /// ```\n+    #[macro_export]\n+    macro_rules! option_env( ($name:expr) => ({ /* compiler built-in */ }) )\n+\n+    /// Concatenate literals into a static byte slice.\n+    ///\n+    /// This macro takes any number of comma-separated literal expressions,\n+    /// yielding an expression of type `&'static [u8]` which is the\n+    /// concatenation (left to right) of all the literals in their byte format.\n+    ///\n+    /// This extension currently only supports string literals, character\n+    /// literals, and integers less than 256. The byte slice returned is the\n+    /// utf8-encoding of strings and characters.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let rust = bytes!(\"r\", 'u', \"st\");\n+    /// assert_eq!(rust[1], 'u' as u8);\n+    /// ```\n+    #[macro_export]\n+    macro_rules! bytes( ($($e:expr),*) => ({ /* compiler built-in */ }) )\n+\n+    /// Concatenate identifiers into one identifier.\n+    ///\n+    /// This macro takes any number of comma-separated identifiers, and\n+    /// concatenates them all into one, yielding an expression which is a new\n+    /// identifier. Note that hygiene makes it such that this macro cannot\n+    /// capture local variables, and macros are only allowed in item,\n+    /// statement or expression position, meaning this macro may be difficult to\n+    /// use in some situations.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// fn foobar() -> int { 23 }\n+    ///\n+    /// let f = concat_idents!(foo, bar);\n+    /// println!(\"{}\", f());\n+    /// ```\n+    #[macro_export]\n+    macro_rules! concat_idents( ($($e:ident),*) => ({ /* compiler built-in */ }) )\n+\n+    /// Concatenates literals into a static string slice.\n+    ///\n+    /// This macro takes any number of comma-separated literals, yielding an\n+    /// expression of type `&'static str` which represents all of the literals\n+    /// concatenated left-to-right.\n+    ///\n+    /// Integer and floating point literals are stringified in order to be\n+    /// concatenated.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let s = concat!(\"test\", 10, 'b', true);\n+    /// assert_eq!(s, \"test10btrue\");\n+    /// ```\n+    #[macro_export]\n+    macro_rules! concat( ($($e:expr),*) => ({ /* compiler built-in */ }) )\n+\n+    /// A macro which expands to the line number on which it was invoked.\n+    ///\n+    /// The expanded expression has type `uint`, and the returned line is not\n+    /// the invocation of the `line!()` macro itself, but rather the first macro\n+    /// invocation leading up to the invocation of the `line!()` macro.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let current_line = line!();\n+    /// println!(\"defined on line: {}\", current_line);\n+    /// ```\n+    #[macro_export]\n+    macro_rules! line( () => ({ /* compiler built-in */ }) )\n+\n+    /// A macro which expands to the column number on which it was invoked.\n+    ///\n+    /// The expanded expression has type `uint`, and the returned column is not\n+    /// the invocation of the `col!()` macro itself, but rather the first macro\n+    /// invocation leading up to the invocation of the `col!()` macro.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let current_col = col!();\n+    /// println!(\"defined on column: {}\", current_col);\n+    /// ```\n+    #[macro_export]\n+    macro_rules! col( () => ({ /* compiler built-in */ }) )\n+\n+    /// A macro which expands to the file name from which it was invoked.\n+    ///\n+    /// The expanded expression has type `&'static str`, and the returned file\n+    /// is not the invocation of the `file!()` macro itself, but rather the\n+    /// first macro invocation leading up to the invocation of the `file!()`\n+    /// macro.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let this_file = file!();\n+    /// println!(\"defined in file: {}\", this_file);\n+    /// ```\n+    #[macro_export]\n+    macro_rules! file( () => ({ /* compiler built-in */ }) )\n+\n+    /// A macro which stringifies its argument.\n+    ///\n+    /// This macro will yield an expression of type `&'static str` which is the\n+    /// stringification of all the tokens passed to the macro. No restrictions\n+    /// are placed on the syntax of the macro invocation itself.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let one_plus_one = stringify!(1 + 1);\n+    /// assert_eq!(one_plus_one, \"1 + 1\");\n+    /// ```\n+    #[macro_export]\n+    macro_rules! stringify( ($t:tt) => ({ /* compiler built-in */ }) )\n+\n+    /// Includes a utf8-encoded file as a string.\n+    ///\n+    /// This macro will yield an expression of type `&'static str` which is the\n+    /// contents of the filename specified. The file is located relative to the\n+    /// current file (similarly to how modules are found),\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust,ignore\n+    /// let secret_key = include_str!(\"secret-key.ascii\");\n+    /// ```\n+    #[macro_export]\n+    macro_rules! include_str( ($file:expr) => ({ /* compiler built-in */ }) )\n+\n+    /// Includes a file as a byte slice.\n+    ///\n+    /// This macro will yield an expression of type `&'static [u8]` which is\n+    /// the contents of the filename specified. The file is located relative to\n+    /// the current file (similarly to how modules are found),\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust,ignore\n+    /// let secret_key = include_bin!(\"secret-key.bin\");\n+    /// ```\n+    #[macro_export]\n+    macro_rules! include_bin( ($file:expr) => ({ /* compiler built-in */ }) )\n+\n+    /// Expands to a string that represents the current module path.\n+    ///\n+    /// The current module path can be thought of as the hierarchy of modules\n+    /// leading back up to the crate root. The first component of the path\n+    /// returned is the name of the crate currently being compiled.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// mod test {\n+    ///     pub fn foo() {\n+    ///         assert!(module_path!().ends_with(\"test\"));\n+    ///     }\n+    /// }\n+    ///\n+    /// test::foo();\n+    /// ```\n+    #[macro_export]\n+    macro_rules! module_path( () => ({ /* compiler built-in */ }) )\n+\n+    /// Boolean evaluation of configuration flags.\n+    ///\n+    /// In addition to the `#[cfg]` attribute, this macro is provided to allow\n+    /// boolean expression evaluation of configuration flags. This frequently\n+    /// leads to less duplicated code.\n+    ///\n+    /// The syntax given to this macro is the same syntax as the `cfg`\n+    /// attribute.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let my_directory = if cfg!(windows) {\n+    ///     \"windows-specific-directory\"\n+    /// } else {\n+    ///     \"unix-directory\"\n+    /// };\n+    /// ```\n+    #[macro_export]\n+    macro_rules! cfg( ($cfg:tt) => ({ /* compiler built-in */ }) )\n+}"}]}