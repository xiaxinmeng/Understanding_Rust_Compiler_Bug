{"sha": "fb68286700525b5bcd2d44d05d1d53f53b702af6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiNjgyODY3MDA1MjViNWJjZDJkNDRkMDVkMWQ1M2Y1M2I3MDJhZjY=", "commit": {"author": {"name": "Roy Frostig", "email": "rfrostig@mozilla.com", "date": "2010-07-17T01:14:52Z"}, "committer": {"name": "Roy Frostig", "email": "rfrostig@mozilla.com", "date": "2010-07-17T01:14:52Z"}, "message": "Add incomplete hashmap implementation to stdlib.", "tree": {"sha": "63b0a5b61eed209c0210f133258ef85554e4ebb4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63b0a5b61eed209c0210f133258ef85554e4ebb4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb68286700525b5bcd2d44d05d1d53f53b702af6", "comment_count": 2, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb68286700525b5bcd2d44d05d1d53f53b702af6", "html_url": "https://github.com/rust-lang/rust/commit/fb68286700525b5bcd2d44d05d1d53f53b702af6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb68286700525b5bcd2d44d05d1d53f53b702af6/comments", "author": {"login": "froystig", "id": 123903, "node_id": "MDQ6VXNlcjEyMzkwMw==", "avatar_url": "https://avatars.githubusercontent.com/u/123903?v=4", "gravatar_id": "", "url": "https://api.github.com/users/froystig", "html_url": "https://github.com/froystig", "followers_url": "https://api.github.com/users/froystig/followers", "following_url": "https://api.github.com/users/froystig/following{/other_user}", "gists_url": "https://api.github.com/users/froystig/gists{/gist_id}", "starred_url": "https://api.github.com/users/froystig/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/froystig/subscriptions", "organizations_url": "https://api.github.com/users/froystig/orgs", "repos_url": "https://api.github.com/users/froystig/repos", "events_url": "https://api.github.com/users/froystig/events{/privacy}", "received_events_url": "https://api.github.com/users/froystig/received_events", "type": "User", "site_admin": false}, "committer": {"login": "froystig", "id": 123903, "node_id": "MDQ6VXNlcjEyMzkwMw==", "avatar_url": "https://avatars.githubusercontent.com/u/123903?v=4", "gravatar_id": "", "url": "https://api.github.com/users/froystig", "html_url": "https://github.com/froystig", "followers_url": "https://api.github.com/users/froystig/followers", "following_url": "https://api.github.com/users/froystig/following{/other_user}", "gists_url": "https://api.github.com/users/froystig/gists{/gist_id}", "starred_url": "https://api.github.com/users/froystig/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/froystig/subscriptions", "organizations_url": "https://api.github.com/users/froystig/orgs", "repos_url": "https://api.github.com/users/froystig/repos", "events_url": "https://api.github.com/users/froystig/events{/privacy}", "received_events_url": "https://api.github.com/users/froystig/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c906759807dfe106c7c59f939c7be492b4f16d8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c906759807dfe106c7c59f939c7be492b4f16d8f", "html_url": "https://github.com/rust-lang/rust/commit/c906759807dfe106c7c59f939c7be492b4f16d8f"}], "stats": {"total": 169, "additions": 169, "deletions": 0}, "files": [{"sha": "8df2cba02e45490e133665da7523d911c6db07b1", "filename": "src/lib/map.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/fb68286700525b5bcd2d44d05d1d53f53b702af6/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb68286700525b5bcd2d44d05d1d53f53b702af6/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=fb68286700525b5bcd2d44d05d1d53f53b702af6", "patch": "@@ -0,0 +1,160 @@\n+/**\n+ * At the moment, this is a partial hashmap implementation, not yet fit for\n+ * use, but useful as a stress test for rustboot.\n+ */\n+\n+import std._int;\n+import std.sys;\n+import std.util;\n+import std._vec;\n+\n+\n+type hashfn[K] = fn(K) -> uint;\n+type eqfn[K] = fn(K) -> bool;\n+\n+type hashmap[K, V] = obj {\n+  fn insert(&K key, &V val);\n+  fn contains_key(&K key) -> bool;\n+  fn get(&K key) -> V;\n+  fn find(&K key) -> util.option[V];\n+  fn remove(&K key) -> util.option[V];\n+  fn rehash();\n+};\n+\n+fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n+\n+  let uint initial_capacity = uint(32); // 2^5\n+  let util.rational load_factor = rec(num=3, den=4);\n+\n+  type bucket[V] = tag(nil(), deleted(), some(V));\n+\n+  // Derive two hash functions from the one given by taking the upper\n+  // half and lower half of the uint bits.  Our bucket probing\n+  // sequence is then defined by\n+  //\n+  //   hash(key, i) := hashl(key) + i * hashr(key)   for i = 0, 1, 2, ...\n+  //\n+  // Tearing the hash function apart this way is kosher in practice\n+  // as, assuming 32-bit uints, the table would have to be at 2^32\n+  // buckets before the resulting pair of hash functions no longer\n+  // probes all buckets for a fixed key.  Note that hashr is made to\n+  // output odd numbers (hence coprime to the number of nbkts, which\n+  // is always a power of 2), so that all buckets are probed for a\n+  // fixed key.\n+\n+  fn hashl[K](hashfn[K] hasher, uint nbkts, &K key) -> uint {\n+    ret (hasher(key) >>> (sys.rustrt.size_of[uint]() * uint(8) / uint(2)))\n+      % nbkts;\n+  }\n+\n+  fn hashr[K](hashfn[K] hasher, uint nbkts, &K key) -> uint {\n+    ret ((((~ uint(0)) >>> (sys.rustrt.size_of[uint]() * uint(8) / uint(2)))\n+          & hasher(key)) * uint(2) + uint(1))\n+      % nbkts;\n+  }\n+\n+  fn hash[K](hashfn[K] hasher, uint nbkts, &K key, uint i) -> uint {\n+    ret hashl[K](hasher, nbkts, key) + i * hashr[K](hasher, nbkts, key);\n+  }\n+\n+  fn find_common[K, V](hashfn[K] hasher,\n+                       vec[mutable bucket[V]] bkts,\n+                       uint nbkts,\n+                       &K key)\n+    -> util.option[V]\n+  {\n+    let uint i = uint(0);\n+    while (i < nbkts) {\n+      // Pending fix to issue #94, remove uint coercion.\n+      let int j = int(hash[K](hasher, nbkts, key, i));\n+      alt (bkts.(j)) {\n+        case (some[V](val)) {\n+          ret util.some[V](val);\n+        }\n+        case (nil[V]()) {\n+          ret util.none[V]();\n+        }\n+        case (deleted[V]()) {\n+          i += uint(1);\n+        }\n+      }\n+    }\n+    ret util.none[V]();\n+  }\n+\n+  obj hashmap[K, V](hashfn[K] hasher,\n+                    eqfn[K] eqer,\n+                    mutable vec[mutable bucket[V]] bkts,\n+                    mutable uint nbkts,\n+                    mutable uint nelts,\n+                    util.rational lf)\n+  {\n+    fn insert(&K key, &V val) {\n+      // FIXME grow the table and rehash if we ought to.\n+      let uint i = uint(0);\n+      while (i < nbkts) {\n+        // Issue #94, as in find_common()\n+        let int j = int(hash[K](hasher, nbkts, key, i));\n+        alt (bkts.(j)) {\n+          case (some[V](_)) {\n+            i += uint(1);\n+          }\n+          case (_) {\n+            bkts.(j) = some[V](val);\n+            nelts += uint(1);\n+            ret;\n+          }\n+        }\n+      }\n+      // full table, impossible unless growth is broken. remove after testing.\n+      fail;\n+    }\n+\n+    fn contains_key(&K key) -> bool {\n+      alt (find_common[K, V](hasher, bkts, nbkts, key)) {\n+        case (util.some[V](_)) { ret true; }\n+        case (_) { ret false; }\n+      }\n+    }\n+\n+    fn get(&K key) -> V {\n+      alt (find_common[K, V](hasher, bkts, nbkts, key)) {\n+        case (util.some[V](val)) { ret val; }\n+        case (_) { fail; }\n+      }\n+    }\n+\n+    fn find(&K key) -> util.option[V] {\n+      be find_common[K, V](hasher, bkts, nbkts, key);\n+    }\n+\n+    fn remove(&K key) -> util.option[V] {\n+      let uint i = uint(0);\n+      while (i < nbkts) {\n+        // Issue #94, as in find_common()\n+        let int j = int(hash[K](hasher, nbkts, key, i));\n+        alt (bkts.(j)) {\n+          case (some[V](val)) {\n+            bkts.(j) = deleted[V]();\n+            ret util.some[V](val);\n+          }\n+          case (deleted[V]()) {\n+            nelts += uint(1);\n+          }\n+          case (nil[V]()) {\n+            ret util.none[V]();\n+          }\n+        }\n+      }\n+      ret util.none[V]();\n+    }\n+\n+    fn rehash() {}\n+  }\n+\n+  let vec[mutable bucket[V]] bkts =\n+    _vec.init_elt[mutable bucket[V]](nil[V](),\n+                                     uint(initial_capacity));\n+\n+  ret hashmap[K, V](hasher, eqer, bkts, uint(0), uint(0), load_factor);\n+}"}, {"sha": "4bdad5bd248615ea2707dd8219f19e745a9952af", "filename": "src/lib/std.rc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb68286700525b5bcd2d44d05d1d53f53b702af6/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/fb68286700525b5bcd2d44d05d1d53f53b702af6/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=fb68286700525b5bcd2d44d05d1d53f53b702af6", "patch": "@@ -26,6 +26,13 @@ auth _io = unsafe;\n auth _str = unsafe;\n auth _vec = unsafe;\n \n+/**\n+ * FIXME for some reason 'auth sys = unsafe' isn't enough here to silence\n+ * the effect system about map.mk_hashmap.hashl and .hashr using\n+ * sys.rustrt.size_of and thereby being unsafe.\n+ */\n+auth map.mk_hashmap = unsafe;\n+\n // Target-OS module.\n \n alt (target_os) {\n@@ -37,3 +44,5 @@ alt (target_os) {\n     mod os = \"linux_os.rs\";\n   }\n }\n+\n+mod map;"}]}