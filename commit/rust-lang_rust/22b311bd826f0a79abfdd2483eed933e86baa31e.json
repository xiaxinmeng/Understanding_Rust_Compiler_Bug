{"sha": "22b311bd826f0a79abfdd2483eed933e86baa31e", "node_id": "C_kwDOAAsO6NoAKDIyYjMxMWJkODI2ZjBhNzlhYmZkZDI0ODNlZWQ5MzNlODZiYWEzMWU", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2022-03-24T15:27:09Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2022-03-24T15:44:06Z"}, "message": "Extract impl_subject_and_oglibations fn and make equate receive subjects", "tree": {"sha": "f2aa461ed0b6f1b8db4f0209e3d4eff71c37c2ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2aa461ed0b6f1b8db4f0209e3d4eff71c37c2ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22b311bd826f0a79abfdd2483eed933e86baa31e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEF0ntrgrd9qf9uuThgTGiTgx5768FAmI8kccACgkQgTGiTgx5\n76/JFQ/5ARR1k+TOXOT+aLcUEl6lYAzOQpnjNVkhg4gNxp9dLRcvO+QekgLD9LV4\nE2rqT+vPBbJEuGBToYgAGtsPJ1OjsUj0JXlnot7AdaNQGcSfBUrjxtahEUswa3Pe\nL2qnb0YTJKNpnoGVKrNYTEX68wdBFsKmbQVXEwO+1boqj5uVn5LeY0dgQ0UDcRsN\nUhWA04sNY81lHQ4CQ8b0TbnpI4FyJfJ2jt11+HL5JJdHzKQmeKO0gPEKnAb9GfDr\nmmqbLaFrdKb+7jxJmD7LsYkvrWJbHFc96ueg+jo9hH6bIcL1NKZ8oZUJOLgOwwu2\nzOAzBJyKoIy0fR2R53fucpn60994ZGA7w1tMzBDB60HJ6YJL51nCmz+3mxW3VXqb\nOANBEKAiDoa1wIF3w1LGBiGmxfuoHZZeCVbx/mx2vW7Xk9YdL0ZE0KWx8H0+29h6\n/uey+VL84N2sMTqolMb1FiAEK3Cih5QimDczOIFwPU7d6RcuzpTz9KpkZG7sdqww\nNFml9foMciaxvdFvz6KOkPNN4MC84grCTmpcOaxsYgEwtSUqEM3FjPyBb85n5C3W\nDqGX+caKlFnI9SrJgw+HSrmc3d/Pv2H8aa9KNmbEhSwbewnHz0pdgwheGzVphUz8\nNovF//6rUOC/ZLq6iI9rDMDYUHNa5tU0U39KqIDwajKKYq6u7NA=\n=NGUB\n-----END PGP SIGNATURE-----", "payload": "tree f2aa461ed0b6f1b8db4f0209e3d4eff71c37c2ec\nparent 64df2ee1eb3fb9eee420b13b48d59fdb5ae2c23d\nauthor Santiago Pastorino <spastorino@gmail.com> 1648135629 -0300\ncommitter Santiago Pastorino <spastorino@gmail.com> 1648136646 -0300\n\nExtract impl_subject_and_oglibations fn and make equate receive subjects\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22b311bd826f0a79abfdd2483eed933e86baa31e", "html_url": "https://github.com/rust-lang/rust/commit/22b311bd826f0a79abfdd2483eed933e86baa31e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22b311bd826f0a79abfdd2483eed933e86baa31e/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64df2ee1eb3fb9eee420b13b48d59fdb5ae2c23d", "url": "https://api.github.com/repos/rust-lang/rust/commits/64df2ee1eb3fb9eee420b13b48d59fdb5ae2c23d", "html_url": "https://github.com/rust-lang/rust/commit/64df2ee1eb3fb9eee420b13b48d59fdb5ae2c23d"}], "stats": {"total": 139, "additions": 93, "deletions": 46}, "files": [{"sha": "ff8082840e1e0f29af1d4dbf84e9eee7618ece6f", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/22b311bd826f0a79abfdd2483eed933e86baa31e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b311bd826f0a79abfdd2483eed933e86baa31e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=22b311bd826f0a79abfdd2483eed933e86baa31e", "patch": "@@ -28,7 +28,7 @@\n use super::*;\n \n use rustc_middle::ty::relate::{Relate, TypeRelation};\n-use rustc_middle::ty::Const;\n+use rustc_middle::ty::{Const, ImplSubject};\n \n pub struct At<'a, 'tcx> {\n     pub infcx: &'a InferCtxt<'a, 'tcx>,\n@@ -272,6 +272,29 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     }\n }\n \n+impl<'tcx> ToTrace<'tcx> for ImplSubject<'tcx> {\n+    fn to_trace(\n+        tcx: TyCtxt<'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+        a_is_expected: bool,\n+        a: Self,\n+        b: Self,\n+    ) -> TypeTrace<'tcx> {\n+        match (a, b) {\n+            (ImplSubject::Trait(trait_ref_a), ImplSubject::Trait(trait_ref_b)) => {\n+                ToTrace::to_trace(tcx, cause, a_is_expected, trait_ref_a, trait_ref_b)\n+            }\n+            (ImplSubject::Inherent(ty_a), ImplSubject::Inherent(ty_b)) => {\n+                ToTrace::to_trace(tcx, cause, a_is_expected, ty_a, ty_b)\n+            }\n+            (ImplSubject::Trait(_), ImplSubject::Inherent(_))\n+            | (ImplSubject::Inherent(_), ImplSubject::Trait(_)) => {\n+                bug!(\"can not trace TraitRef and Ty\");\n+            }\n+        }\n+    }\n+}\n+\n impl<'tcx> ToTrace<'tcx> for Ty<'tcx> {\n     fn to_trace(\n         _: TyCtxt<'tcx>,"}, {"sha": "3a0019cf92bd46cafea1e020541fa475358ff03b", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/22b311bd826f0a79abfdd2483eed933e86baa31e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b311bd826f0a79abfdd2483eed933e86baa31e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=22b311bd826f0a79abfdd2483eed933e86baa31e", "patch": "@@ -44,6 +44,7 @@ use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::Span;\n use rustc_target::abi::Align;\n \n+use std::fmt::Debug;\n use std::hash::Hash;\n use std::ops::ControlFlow;\n use std::{fmt, str};\n@@ -172,7 +173,7 @@ pub struct ImplHeader<'tcx> {\n     pub predicates: Vec<Predicate<'tcx>>,\n }\n \n-#[derive(Debug)]\n+#[derive(Copy, Clone, Debug, TypeFoldable)]\n pub enum ImplSubject<'tcx> {\n     Trait(TraitRef<'tcx>),\n     Inherent(Ty<'tcx>),"}, {"sha": "99cd0c789de72cdd3c0f9c8fdcbbf2a1ff964e8c", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/22b311bd826f0a79abfdd2483eed933e86baa31e/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b311bd826f0a79abfdd2483eed933e86baa31e/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=22b311bd826f0a79abfdd2483eed933e86baa31e", "patch": "@@ -7,7 +7,7 @@\n use crate::mir::interpret::{get_slice_bytes, ConstValue, GlobalAlloc, Scalar};\n use crate::ty::error::{ExpectedFound, TypeError};\n use crate::ty::subst::{GenericArg, GenericArgKind, Subst, SubstsRef};\n-use crate::ty::{self, Term, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::{self, ImplSubject, Term, Ty, TyCtxt, TypeFoldable};\n use rustc_hir as ast;\n use rustc_hir::def_id::DefId;\n use rustc_span::DUMMY_SP;\n@@ -356,6 +356,30 @@ impl<'tcx> Relate<'tcx> for GeneratorWitness<'tcx> {\n     }\n }\n \n+impl<'tcx> Relate<'tcx> for ImplSubject<'tcx> {\n+    #[inline]\n+    fn relate<R: TypeRelation<'tcx>>(\n+        relation: &mut R,\n+        a: ImplSubject<'tcx>,\n+        b: ImplSubject<'tcx>,\n+    ) -> RelateResult<'tcx, ImplSubject<'tcx>> {\n+        match (a, b) {\n+            (ImplSubject::Trait(trait_ref_a), ImplSubject::Trait(trait_ref_b)) => {\n+                let trait_ref = ty::TraitRef::relate(relation, trait_ref_a, trait_ref_b)?;\n+                Ok(ImplSubject::Trait(trait_ref))\n+            }\n+            (ImplSubject::Inherent(ty_a), ImplSubject::Inherent(ty_b)) => {\n+                let ty = Ty::relate(relation, ty_a, ty_b)?;\n+                Ok(ImplSubject::Inherent(ty))\n+            }\n+            (ImplSubject::Trait(_), ImplSubject::Inherent(_))\n+            | (ImplSubject::Inherent(_), ImplSubject::Trait(_)) => {\n+                bug!(\"can not relate TraitRef and Ty\");\n+            }\n+        }\n+    }\n+}\n+\n impl<'tcx> Relate<'tcx> for Ty<'tcx> {\n     #[inline]\n     fn relate<R: TypeRelation<'tcx>>("}, {"sha": "7ac6c08307676f49d2371e863fa552b2c0805491", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 42, "deletions": 43, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/22b311bd826f0a79abfdd2483eed933e86baa31e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b311bd826f0a79abfdd2483eed933e86baa31e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=22b311bd826f0a79abfdd2483eed933e86baa31e", "patch": "@@ -17,7 +17,6 @@ use crate::traits::{\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::CRATE_HIR_ID;\n-use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::{util, TraitEngine};\n use rustc_middle::traits::specialization_graph::OverlapMode;\n@@ -305,72 +304,72 @@ fn negative_impl<'cx, 'tcx>(\n     // Create an infcx, taking the predicates of impl1 as assumptions:\n     tcx.infer_ctxt().enter(|infcx| {\n         // create a parameter environment corresponding to a (placeholder) instantiation of impl1\n-        let impl1_env = tcx.param_env(impl1_def_id);\n-\n-        match tcx.impl_subject(impl1_def_id) {\n+        let impl_env = tcx.param_env(impl1_def_id);\n+        let subject1 = match tcx.impl_subject(impl1_def_id) {\n             ImplSubject::Trait(impl1_trait_ref) => {\n-                // Normalize the trait reference. The WF rules ought to ensure\n-                // that this always succeeds.\n-                let impl1_trait_ref = match traits::fully_normalize(\n+                match traits::fully_normalize(\n                     &infcx,\n                     FulfillmentContext::new(),\n                     ObligationCause::dummy(),\n-                    impl1_env,\n+                    impl_env,\n                     impl1_trait_ref,\n                 ) {\n-                    Ok(impl1_trait_ref) => impl1_trait_ref,\n+                    Ok(impl1_trait_ref) => ImplSubject::Trait(impl1_trait_ref),\n                     Err(err) => {\n                         bug!(\"failed to fully normalize {:?}: {:?}\", impl1_trait_ref, err);\n                     }\n-                };\n+                }\n+            }\n+            subject @ ImplSubject::Inherent(_) => subject,\n+        };\n \n-                // Attempt to prove that impl2 applies, given all of the above.\n-                let selcx = &mut SelectionContext::new(&infcx);\n-                let impl2_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl2_def_id);\n-                let (impl2_trait_ref, obligations) =\n-                    impl_trait_ref_and_oblig(selcx, impl1_env, impl2_def_id, impl2_substs);\n+        let (subject2, obligations) =\n+            impl_subject_and_obligations(&infcx, impl_env, subject1, impl2_def_id);\n \n-                !equate(\n-                    &infcx,\n-                    impl1_env,\n-                    impl1_def_id,\n-                    impl1_trait_ref,\n-                    impl2_trait_ref,\n-                    obligations,\n-                )\n-            }\n-            ImplSubject::Inherent(ty1) => {\n-                let ty2 = tcx.type_of(impl2_def_id);\n-                !equate(&infcx, impl1_env, impl1_def_id, ty1, ty2, iter::empty())\n-            }\n-        }\n+        !equate(&infcx, impl_env, impl1_def_id, subject1, subject2, obligations)\n     })\n }\n \n-fn equate<'cx, 'tcx, T: Debug + ToTrace<'tcx>>(\n+fn impl_subject_and_obligations<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n-    impl1_env: ty::ParamEnv<'tcx>,\n+    impl_env: ty::ParamEnv<'tcx>,\n+    subject1: ImplSubject<'tcx>,\n+    impl2_def_id: DefId,\n+) -> (ImplSubject<'tcx>, Box<dyn Iterator<Item = PredicateObligation<'tcx>> + 'tcx>) {\n+    if let ImplSubject::Trait(_) = subject1 {\n+        // Attempt to prove that impl2 applies, given all of the above.\n+        let selcx = &mut SelectionContext::new(&infcx);\n+        let impl2_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl2_def_id);\n+        let (impl2_trait_ref, obligations) =\n+            impl_trait_ref_and_oblig(selcx, impl_env, impl2_def_id, impl2_substs);\n+\n+        (ImplSubject::Trait(impl2_trait_ref), Box::new(obligations))\n+    } else {\n+        (infcx.tcx.impl_subject(impl2_def_id), Box::new(iter::empty()))\n+    }\n+}\n+\n+fn equate<'cx, 'tcx>(\n+    infcx: &InferCtxt<'cx, 'tcx>,\n+    impl_env: ty::ParamEnv<'tcx>,\n     impl1_def_id: DefId,\n-    impl1: T,\n-    impl2: T,\n+    subject1: ImplSubject<'tcx>,\n+    subject2: ImplSubject<'tcx>,\n     obligations: impl Iterator<Item = PredicateObligation<'tcx>>,\n ) -> bool {\n     // do the impls unify? If not, not disjoint.\n-    let Ok(InferOk { obligations: more_obligations, .. }) = infcx\n-        .at(&ObligationCause::dummy(), impl1_env)\n-        .eq(impl1, impl2) else {\n-            debug!(\n-                \"explicit_disjoint: {:?} does not unify with {:?}\",\n-                impl1, impl2\n-            );\n-            return true;\n-        };\n+    let Ok(InferOk { obligations: more_obligations, .. }) =\n+        infcx.at(&ObligationCause::dummy(), impl_env).eq(subject1, subject2)\n+    else {\n+        debug!(\"explicit_disjoint: {:?} does not unify with {:?}\", subject1, subject2);\n+        return true;\n+    };\n \n     let selcx = &mut SelectionContext::new(&infcx);\n     let opt_failing_obligation = obligations\n         .into_iter()\n         .chain(more_obligations)\n-        .find(|o| negative_impl_exists(selcx, impl1_env, impl1_def_id, o));\n+        .find(|o| negative_impl_exists(selcx, impl_env, impl1_def_id, o));\n \n     if let Some(failing_obligation) = opt_failing_obligation {\n         debug!(\"overlap: obligation unsatisfiable {:?}\", failing_obligation);"}]}