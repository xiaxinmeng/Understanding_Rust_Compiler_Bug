{"sha": "1af63171f8264b552adec3dabe069731e750e05d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhZjYzMTcxZjgyNjRiNTUyYWRlYzNkYWJlMDY5NzMxZTc1MGUwNWQ=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-12-11T00:23:07Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-12-11T00:23:07Z"}, "message": "Split primval into operator and value.", "tree": {"sha": "c4c80676997c6afda5df402a087942004978c156", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4c80676997c6afda5df402a087942004978c156"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1af63171f8264b552adec3dabe069731e750e05d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1af63171f8264b552adec3dabe069731e750e05d", "html_url": "https://github.com/rust-lang/rust/commit/1af63171f8264b552adec3dabe069731e750e05d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1af63171f8264b552adec3dabe069731e750e05d/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc5bd719229baaffb19bb64ad11f9e40996b0030", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc5bd719229baaffb19bb64ad11f9e40996b0030", "html_url": "https://github.com/rust-lang/rust/commit/bc5bd719229baaffb19bb64ad11f9e40996b0030"}], "stats": {"total": 402, "additions": 202, "deletions": 200}, "files": [{"sha": "a49b3b124807957463996627be1aeca9cd99bd3c", "filename": "src/cast.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1af63171f8264b552adec3dabe069731e750e05d/src%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af63171f8264b552adec3dabe069731e750e05d/src%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcast.rs?ref=1af63171f8264b552adec3dabe069731e750e05d", "patch": "@@ -1,14 +1,10 @@\n+use rustc::ty::{self, Ty};\n+use syntax::ast::{FloatTy, IntTy, UintTy};\n \n-use super::{\n-    EvalContext,\n-};\n use error::{EvalResult, EvalError};\n-use rustc::ty;\n-use primval::PrimVal;\n+use eval_context::EvalContext;\n use memory::Pointer;\n-\n-use rustc::ty::Ty;\n-use syntax::ast::{FloatTy, IntTy, UintTy};\n+use value::PrimVal;\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(super) fn cast_primval(\n@@ -19,7 +15,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     ) -> EvalResult<'tcx, PrimVal> {\n         let kind = self.ty_to_primval_kind(src_ty)?;\n \n-        use primval::PrimValKind::*;\n+        use value::PrimValKind::*;\n         match kind {\n             F32 => self.cast_float(val.to_f32() as f64, dest_ty),\n             F64 => self.cast_float(val.to_f64(), dest_ty),"}, {"sha": "b0c01aed9e134d5cc145e6afbc2a7cd88ea4ab9a", "filename": "src/eval_context.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1af63171f8264b552adec3dabe069731e750e05d/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af63171f8264b552adec3dabe069731e750e05d/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=1af63171f8264b552adec3dabe069731e750e05d", "patch": "@@ -15,7 +15,8 @@ use syntax::codemap::{self, DUMMY_SP};\n use error::{EvalError, EvalResult};\n use lvalue::{Global, GlobalId, Lvalue, LvalueExtra};\n use memory::{Memory, Pointer};\n-use primval::{self, PrimVal, PrimValKind};\n+use operator;\n+use value::{PrimVal, PrimValKind};\n \n // FIXME(solson): Remove this.\n pub use value::Value;\n@@ -370,7 +371,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let right_kind = self.ty_to_primval_kind(right_ty)?;\n         let left_val   = self.eval_operand_to_primval(left)?;\n         let right_val  = self.eval_operand_to_primval(right)?;\n-        primval::binary_op(op, left_val, left_kind, right_val, right_kind)\n+        operator::binary_op(op, left_val, left_kind, right_val, right_kind)\n     }\n \n     /// Applies the binary operation `op` to the two operands and writes a tuple of the result\n@@ -453,7 +454,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             UnaryOp(un_op, ref operand) => {\n                 let val = self.eval_operand_to_primval(operand)?;\n                 let kind = self.ty_to_primval_kind(dest_ty)?;\n-                self.write_primval(dest, primval::unary_op(un_op, val, kind)?, dest_ty)?;\n+                self.write_primval(dest, operator::unary_op(un_op, val, kind)?, dest_ty)?;\n             }\n \n             Aggregate(ref kind, ref operands) => {"}, {"sha": "1400d637767dc5ff032b424c1243d9415b346fc0", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1af63171f8264b552adec3dabe069731e750e05d/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af63171f8264b552adec3dabe069731e750e05d/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=1af63171f8264b552adec3dabe069731e750e05d", "patch": "@@ -27,7 +27,7 @@ mod error;\n mod eval_context;\n mod lvalue;\n mod memory;\n-mod primval;\n+mod operator;\n mod step;\n mod terminator;\n mod value;\n@@ -54,12 +54,12 @@ pub use lvalue::{\n };\n \n pub use memory::{\n+    AllocId,\n     Memory,\n     Pointer,\n-    AllocId,\n };\n \n-pub use primval::{\n+pub use value::{\n     PrimVal,\n     PrimValKind,\n };"}, {"sha": "671174fd75690bdba6f801c5b583c36017754cde", "filename": "src/memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1af63171f8264b552adec3dabe069731e750e05d/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af63171f8264b552adec3dabe069731e750e05d/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=1af63171f8264b552adec3dabe069731e750e05d", "patch": "@@ -11,7 +11,7 @@ use rustc::ty::layout::{self, TargetDataLayout};\n use syntax::abi::Abi;\n \n use error::{EvalError, EvalResult};\n-use primval::{PrimVal, PrimValKind};\n+use value::{PrimVal, PrimValKind};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Allocations and pointers\n@@ -575,7 +575,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             return self.write_ptr(dest, Pointer::new(alloc_id, val.bits));\n         }\n \n-        use primval::PrimValKind::*;\n+        use value::PrimValKind::*;\n         let (size, bits) = match kind {\n             I8 | U8 | Bool         => (1, val.bits as u8  as u64),\n             I16 | U16              => (2, val.bits as u16 as u64),"}, {"sha": "5a6182d0be7686524f0c3c3c4a2c639fe31bc585", "filename": "src/operator.rs", "status": "renamed", "additions": 12, "deletions": 172, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/1af63171f8264b552adec3dabe069731e750e05d/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af63171f8264b552adec3dabe069731e750e05d/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=1af63171f8264b552adec3dabe069731e750e05d", "patch": "@@ -1,176 +1,16 @@\n-#![allow(unknown_lints)]\n-#![allow(float_cmp)]\n-\n-use std::mem::transmute;\n-\n use rustc::mir;\n \n use error::{EvalError, EvalResult};\n-use memory::{AllocId, Pointer};\n-\n-fn bits_to_f32(bits: u64) -> f32 {\n-    unsafe { transmute::<u32, f32>(bits as u32) }\n-}\n-\n-fn bits_to_f64(bits: u64) -> f64 {\n-    unsafe { transmute::<u64, f64>(bits) }\n-}\n-\n-fn f32_to_bits(f: f32) -> u64 {\n-    unsafe { transmute::<f32, u32>(f) as u64 }\n-}\n-\n-fn f64_to_bits(f: f64) -> u64 {\n-    unsafe { transmute::<f64, u64>(f) }\n-}\n-\n-fn bits_to_bool(n: u64) -> bool {\n-    // FIXME(solson): Can we reach here due to user error?\n-    debug_assert!(n == 0 || n == 1, \"bits interpreted as bool were {}\", n);\n-    n & 1 == 1\n-}\n-\n-#[derive(Clone, Copy, Debug, PartialEq)]\n-pub struct PrimVal {\n-    pub bits: u64,\n-\n-    /// This field is initialized when the `PrimVal` represents a pointer into an `Allocation`. An\n-    /// `Allocation` in the `memory` module has a list of relocations, but a `PrimVal` is only\n-    /// large enough to contain one, hence the `Option`.\n-    pub relocation: Option<AllocId>,\n-}\n-\n-#[derive(Clone, Copy, Debug, PartialEq)]\n-pub enum PrimValKind {\n-    I8, I16, I32, I64,\n-    U8, U16, U32, U64,\n-    F32, F64,\n-    Bool,\n-    Char,\n-    Ptr,\n-    FnPtr,\n-}\n-\n-impl PrimValKind {\n-    pub fn is_int(self) -> bool {\n-        use self::PrimValKind::*;\n-        match self {\n-            I8 | I16 | I32 | I64 | U8 | U16 | U32 | U64 => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn from_uint_size(size: u64) -> Self {\n-        match size {\n-            1 => PrimValKind::U8,\n-            2 => PrimValKind::U16,\n-            4 => PrimValKind::U32,\n-            8 => PrimValKind::U64,\n-            _ => bug!(\"can't make uint with size {}\", size),\n-        }\n-    }\n-\n-    pub fn from_int_size(size: u64) -> Self {\n-        match size {\n-            1 => PrimValKind::I8,\n-            2 => PrimValKind::I16,\n-            4 => PrimValKind::I32,\n-            8 => PrimValKind::I64,\n-            _ => bug!(\"can't make int with size {}\", size),\n-        }\n-    }\n-}\n-\n-impl PrimVal {\n-    pub fn new(bits: u64) -> Self {\n-        PrimVal { bits: bits, relocation: None }\n-    }\n-\n-    pub fn new_with_relocation(bits: u64, alloc_id: AllocId) -> Self {\n-        PrimVal { bits: bits, relocation: Some(alloc_id) }\n-    }\n-\n-    pub fn from_ptr(ptr: Pointer) -> Self {\n-        PrimVal::new_with_relocation(ptr.offset as u64, ptr.alloc_id)\n-    }\n-\n-    pub fn from_bool(b: bool) -> Self {\n-        PrimVal::new(b as u64)\n-    }\n-\n-    pub fn from_char(c: char) -> Self {\n-        PrimVal::new(c as u64)\n-    }\n-\n-    pub fn from_f32(f: f32) -> Self {\n-        PrimVal::new(f32_to_bits(f))\n-    }\n-\n-    pub fn from_f64(f: f64) -> Self {\n-        PrimVal::new(f64_to_bits(f))\n-    }\n-\n-    pub fn from_uint(n: u64) -> Self {\n-        PrimVal::new(n)\n-    }\n-\n-    pub fn from_int(n: i64) -> Self {\n-        PrimVal::new(n as u64)\n-    }\n-\n-    pub fn to_f32(self) -> f32 {\n-        assert!(self.relocation.is_none());\n-        bits_to_f32(self.bits)\n-    }\n-\n-    pub fn to_f64(self) -> f64 {\n-        assert!(self.relocation.is_none());\n-        bits_to_f64(self.bits)\n-    }\n-\n-    pub fn to_ptr(self) -> Pointer {\n-        self.relocation.map(|alloc_id| {\n-            Pointer::new(alloc_id, self.bits)\n-        }).unwrap_or_else(|| Pointer::from_int(self.bits))\n-    }\n-\n-    pub fn try_as_uint<'tcx>(self) -> EvalResult<'tcx, u64> {\n-        self.to_ptr().to_int()\n-    }\n-\n-    pub fn to_u64(self) -> u64 {\n-        if let Some(ptr) = self.try_as_ptr() {\n-            return ptr.to_int().expect(\"non abstract ptr\") as u64;\n-        }\n-        self.bits\n-    }\n-\n-    pub fn to_i64(self) -> i64 {\n-        if let Some(ptr) = self.try_as_ptr() {\n-            return ptr.to_int().expect(\"non abstract ptr\") as i64;\n-        }\n-        self.bits as i64\n-    }\n-\n-    pub fn try_as_ptr(self) -> Option<Pointer> {\n-        self.relocation.map(|alloc_id| {\n-            Pointer::new(alloc_id, self.bits)\n-        })\n-    }\n-\n-    pub fn try_as_bool<'tcx>(self) -> EvalResult<'tcx, bool> {\n-        match self.bits {\n-            0 => Ok(false),\n-            1 => Ok(true),\n-            _ => Err(EvalError::InvalidBool),\n-        }\n-    }\n-\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// MIR operator evaluation\n-////////////////////////////////////////////////////////////////////////////////\n+use memory::Pointer;\n+use value::{\n+    PrimVal,\n+    PrimValKind,\n+    bits_to_f32,\n+    bits_to_f64,\n+    f32_to_bits,\n+    f64_to_bits,\n+    bits_to_bool,\n+};\n \n macro_rules! overflow {\n     ($op:ident, $l:expr, $r:expr) => ({\n@@ -246,7 +86,7 @@ pub fn binary_op<'tcx>(\n     right_kind: PrimValKind,\n ) -> EvalResult<'tcx, (PrimVal, bool)> {\n     use rustc::mir::BinOp::*;\n-    use self::PrimValKind::*;\n+    use value::PrimValKind::*;\n \n     // If the pointers are into the same allocation, fall through to the more general match\n     // later, which will do comparisons on the `bits` fields, which are the pointer offsets\n@@ -360,7 +200,7 @@ pub fn unary_op<'tcx>(\n     val_kind: PrimValKind,\n ) -> EvalResult<'tcx, PrimVal> {\n     use rustc::mir::UnOp::*;\n-    use self::PrimValKind::*;\n+    use value::PrimValKind::*;\n \n     let bits = match (un_op, val_kind) {\n         (Not, Bool) => !bits_to_bool(val.bits) as u64,", "previous_filename": "src/primval.rs"}, {"sha": "9be094d9bd97783d1644a732fcac24a857bd5976", "filename": "src/terminator/intrinsics.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1af63171f8264b552adec3dabe069731e750e05d/src%2Fterminator%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af63171f8264b552adec3dabe069731e750e05d/src%2Fterminator%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsics.rs?ref=1af63171f8264b552adec3dabe069731e750e05d", "patch": "@@ -7,8 +7,8 @@ use rustc::ty::{self, Ty};\n use error::{EvalError, EvalResult};\n use eval_context::EvalContext;\n use lvalue::{Lvalue, LvalueExtra};\n-use primval::{self, PrimVal, PrimValKind};\n-use value::Value;\n+use operator;\n+use value::{PrimVal, PrimValKind, Value};\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(super) fn call_intrinsic(\n@@ -101,7 +101,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Value::ByValPair(..) => bug!(\"atomic_cxchg doesn't work with nonprimitives\"),\n                 };\n                 let kind = self.ty_to_primval_kind(ty)?;\n-                let (val, _) = primval::binary_op(mir::BinOp::Eq, old, kind, expect_old, kind)?;\n+                let (val, _) = operator::binary_op(mir::BinOp::Eq, old, kind, expect_old, kind)?;\n                 let dest = self.force_allocation(dest)?.to_ptr();\n                 self.write_pair_to_ptr(old, val, dest, dest_ty)?;\n                 self.write_primval(Lvalue::from_ptr(ptr), change, ty)?;\n@@ -120,7 +120,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.write_primval(dest, old, ty)?;\n                 let kind = self.ty_to_primval_kind(ty)?;\n                 // FIXME: what do atomics do on overflow?\n-                let (val, _) = primval::binary_op(mir::BinOp::Add, old, kind, change, kind)?;\n+                let (val, _) = operator::binary_op(mir::BinOp::Add, old, kind, change, kind)?;\n                 self.write_primval(Lvalue::from_ptr(ptr), val, ty)?;\n             },\n \n@@ -137,7 +137,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.write_primval(dest, old, ty)?;\n                 let kind = self.ty_to_primval_kind(ty)?;\n                 // FIXME: what do atomics do on overflow?\n-                let (val, _) = primval::binary_op(mir::BinOp::Sub, old, kind, change, kind)?;\n+                let (val, _) = operator::binary_op(mir::BinOp::Sub, old, kind, change, kind)?;\n                 self.write_primval(Lvalue::from_ptr(ptr), val, ty)?;\n             }\n \n@@ -217,7 +217,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let kind = self.ty_to_primval_kind(ty)?;\n                 let a = self.value_to_primval(arg_vals[0], ty)?;\n                 let b = self.value_to_primval(arg_vals[0], ty)?;\n-                let result = primval::binary_op(mir::BinOp::Add, a, kind, b, kind)?;\n+                let result = operator::binary_op(mir::BinOp::Add, a, kind, b, kind)?;\n                 self.write_primval(dest, result.0, dest_ty)?;\n             }\n \n@@ -504,7 +504,7 @@ macro_rules! integer_intrinsic {\n     ($name:expr, $val:expr, $kind:expr, $method:ident) => ({\n         let val = $val;\n \n-        use primval::PrimValKind::*;\n+        use value::PrimValKind::*;\n         let bits = match $kind {\n             I8 => (val.bits as i8).$method() as u64,\n             U8 => (val.bits as u8).$method() as u64,"}, {"sha": "31234807d729d41d62858e3b7ac39c4b880803f2", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1af63171f8264b552adec3dabe069731e750e05d/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af63171f8264b552adec3dabe069731e750e05d/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=1af63171f8264b552adec3dabe069731e750e05d", "patch": "@@ -12,7 +12,7 @@ use error::{EvalError, EvalResult};\n use eval_context::{EvalContext, IntegerExt, StackPopCleanup, monomorphize_field_ty};\n use lvalue::{Lvalue, LvalueExtra};\n use memory::Pointer;\n-use primval::PrimVal;\n+use value::PrimVal;\n use value::Value;\n \n mod intrinsics;"}, {"sha": "4642018c12465b5f9e1aacf8652a1d434faf4d0f", "filename": "src/value.rs", "status": "modified", "additions": 168, "deletions": 3, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/1af63171f8264b552adec3dabe069731e750e05d/src%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af63171f8264b552adec3dabe069731e750e05d/src%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue.rs?ref=1af63171f8264b552adec3dabe069731e750e05d", "patch": "@@ -1,6 +1,32 @@\n-use error::EvalResult;\n-use memory::{Memory, Pointer};\n-use primval::PrimVal;\n+#![allow(unknown_lints)]\n+#![allow(float_cmp)]\n+\n+use std::mem::transmute;\n+\n+use error::{EvalError, EvalResult};\n+use memory::{AllocId, Memory, Pointer};\n+\n+pub(super) fn bits_to_f32(bits: u64) -> f32 {\n+    unsafe { transmute::<u32, f32>(bits as u32) }\n+}\n+\n+pub(super) fn bits_to_f64(bits: u64) -> f64 {\n+    unsafe { transmute::<u64, f64>(bits) }\n+}\n+\n+pub(super) fn f32_to_bits(f: f32) -> u64 {\n+    unsafe { transmute::<f32, u32>(f) as u64 }\n+}\n+\n+pub(super) fn f64_to_bits(f: f64) -> u64 {\n+    unsafe { transmute::<f64, u64>(f) }\n+}\n+\n+pub(super) fn bits_to_bool(n: u64) -> bool {\n+    // FIXME(solson): Can we reach here due to user error?\n+    debug_assert!(n == 0 || n == 1, \"bits interpreted as bool were {}\", n);\n+    n & 1 == 1\n+}\n \n /// A `Value` represents a single self-contained Rust value.\n ///\n@@ -17,6 +43,29 @@ pub enum Value {\n     ByValPair(PrimVal, PrimVal),\n }\n \n+/// A `PrimVal` represents an immediate, primitive value existing outside of an allocation. It is\n+/// considered to be like a\n+#[derive(Clone, Copy, Debug, PartialEq)]\n+pub struct PrimVal {\n+    pub bits: u64,\n+\n+    /// This field is initialized when the `PrimVal` represents a pointer into an `Allocation`. An\n+    /// `Allocation` in the `memory` module has a list of relocations, but a `PrimVal` is only\n+    /// large enough to contain one, hence the `Option`.\n+    pub relocation: Option<AllocId>,\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq)]\n+pub enum PrimValKind {\n+    I8, I16, I32, I64,\n+    U8, U16, U32, U64,\n+    F32, F64,\n+    Bool,\n+    Char,\n+    Ptr,\n+    FnPtr,\n+}\n+\n impl<'a, 'tcx: 'a> Value {\n     pub(super) fn read_ptr(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, Pointer> {\n         use self::Value::*;\n@@ -59,3 +108,119 @@ impl<'a, 'tcx: 'a> Value {\n         }\n     }\n }\n+\n+impl PrimVal {\n+    pub fn new(bits: u64) -> Self {\n+        PrimVal { bits: bits, relocation: None }\n+    }\n+\n+    pub fn new_with_relocation(bits: u64, alloc_id: AllocId) -> Self {\n+        PrimVal { bits: bits, relocation: Some(alloc_id) }\n+    }\n+\n+    pub fn from_ptr(ptr: Pointer) -> Self {\n+        PrimVal::new_with_relocation(ptr.offset as u64, ptr.alloc_id)\n+    }\n+\n+    pub fn from_bool(b: bool) -> Self {\n+        PrimVal::new(b as u64)\n+    }\n+\n+    pub fn from_char(c: char) -> Self {\n+        PrimVal::new(c as u64)\n+    }\n+\n+    pub fn from_f32(f: f32) -> Self {\n+        PrimVal::new(f32_to_bits(f))\n+    }\n+\n+    pub fn from_f64(f: f64) -> Self {\n+        PrimVal::new(f64_to_bits(f))\n+    }\n+\n+    pub fn from_uint(n: u64) -> Self {\n+        PrimVal::new(n)\n+    }\n+\n+    pub fn from_int(n: i64) -> Self {\n+        PrimVal::new(n as u64)\n+    }\n+\n+    pub fn to_f32(self) -> f32 {\n+        assert!(self.relocation.is_none());\n+        bits_to_f32(self.bits)\n+    }\n+\n+    pub fn to_f64(self) -> f64 {\n+        assert!(self.relocation.is_none());\n+        bits_to_f64(self.bits)\n+    }\n+\n+    pub fn to_ptr(self) -> Pointer {\n+        self.relocation.map(|alloc_id| {\n+            Pointer::new(alloc_id, self.bits)\n+        }).unwrap_or_else(|| Pointer::from_int(self.bits))\n+    }\n+\n+    pub fn try_as_uint<'tcx>(self) -> EvalResult<'tcx, u64> {\n+        self.to_ptr().to_int()\n+    }\n+\n+    pub fn to_u64(self) -> u64 {\n+        if let Some(ptr) = self.try_as_ptr() {\n+            return ptr.to_int().expect(\"non abstract ptr\") as u64;\n+        }\n+        self.bits\n+    }\n+\n+    pub fn to_i64(self) -> i64 {\n+        if let Some(ptr) = self.try_as_ptr() {\n+            return ptr.to_int().expect(\"non abstract ptr\") as i64;\n+        }\n+        self.bits as i64\n+    }\n+\n+    pub fn try_as_ptr(self) -> Option<Pointer> {\n+        self.relocation.map(|alloc_id| {\n+            Pointer::new(alloc_id, self.bits)\n+        })\n+    }\n+\n+    pub fn try_as_bool<'tcx>(self) -> EvalResult<'tcx, bool> {\n+        match self.bits {\n+            0 => Ok(false),\n+            1 => Ok(true),\n+            _ => Err(EvalError::InvalidBool),\n+        }\n+    }\n+}\n+\n+impl PrimValKind {\n+    pub fn is_int(self) -> bool {\n+        use self::PrimValKind::*;\n+        match self {\n+            I8 | I16 | I32 | I64 | U8 | U16 | U32 | U64 => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn from_uint_size(size: u64) -> Self {\n+        match size {\n+            1 => PrimValKind::U8,\n+            2 => PrimValKind::U16,\n+            4 => PrimValKind::U32,\n+            8 => PrimValKind::U64,\n+            _ => bug!(\"can't make uint with size {}\", size),\n+        }\n+    }\n+\n+    pub fn from_int_size(size: u64) -> Self {\n+        match size {\n+            1 => PrimValKind::I8,\n+            2 => PrimValKind::I16,\n+            4 => PrimValKind::I32,\n+            8 => PrimValKind::I64,\n+            _ => bug!(\"can't make int with size {}\", size),\n+        }\n+    }\n+}"}]}