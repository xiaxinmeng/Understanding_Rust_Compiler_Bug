{"sha": "53be0ccbc913f05c81f1762fd60512e3f57ab5c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzYmUwY2NiYzkxM2YwNWM4MWYxNzYyZmQ2MDUxMmUzZjU3YWI1Yzc=", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2020-03-04T18:34:24Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2020-03-04T18:34:24Z"}, "message": "Use subslice patterns in slice methods\n\nFor all of the methods that pick off the first or last element, we can\nuse subslice patterns to implement them directly, rather than relying on\ndeeper indexing function calls. At a minimum, this means the generated\ncode will rely less on inlining for performance, but in some cases it\nalso optimizes better.", "tree": {"sha": "901313c91371d8ae7ff18d43c5d13ce5ccbf5648", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/901313c91371d8ae7ff18d43c5d13ce5ccbf5648"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53be0ccbc913f05c81f1762fd60512e3f57ab5c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53be0ccbc913f05c81f1762fd60512e3f57ab5c7", "html_url": "https://github.com/rust-lang/rust/commit/53be0ccbc913f05c81f1762fd60512e3f57ab5c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53be0ccbc913f05c81f1762fd60512e3f57ab5c7/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b0cfa5b4c5099f45ca540ee1c7d8c1ecd5267d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b0cfa5b4c5099f45ca540ee1c7d8c1ecd5267d2", "html_url": "https://github.com/rust-lang/rust/commit/2b0cfa5b4c5099f45ca540ee1c7d8c1ecd5267d2"}], "stats": {"total": 30, "additions": 8, "deletions": 22}, "files": [{"sha": "0e12e6360da9512363d87f7631939a89161e1024", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/53be0ccbc913f05c81f1762fd60512e3f57ab5c7/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53be0ccbc913f05c81f1762fd60512e3f57ab5c7/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=53be0ccbc913f05c81f1762fd60512e3f57ab5c7", "patch": "@@ -103,7 +103,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn first(&self) -> Option<&T> {\n-        self.get(0)\n+        if let [first, ..] = self { Some(first) } else { None }\n     }\n \n     /// Returns a mutable pointer to the first element of the slice, or `None` if it is empty.\n@@ -121,7 +121,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn first_mut(&mut self) -> Option<&mut T> {\n-        self.get_mut(0)\n+        if let [first, ..] = self { Some(first) } else { None }\n     }\n \n     /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.\n@@ -139,7 +139,7 @@ impl<T> [T] {\n     #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n     #[inline]\n     pub fn split_first(&self) -> Option<(&T, &[T])> {\n-        if self.is_empty() { None } else { Some((&self[0], &self[1..])) }\n+        if let [first, tail @ ..] = self { Some((first, tail)) } else { None }\n     }\n \n     /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.\n@@ -159,12 +159,7 @@ impl<T> [T] {\n     #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n     #[inline]\n     pub fn split_first_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n-        if self.is_empty() {\n-            None\n-        } else {\n-            let split = self.split_at_mut(1);\n-            Some((&mut split.0[0], split.1))\n-        }\n+        if let [first, tail @ ..] = self { Some((first, tail)) } else { None }\n     }\n \n     /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.\n@@ -182,8 +177,7 @@ impl<T> [T] {\n     #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n     #[inline]\n     pub fn split_last(&self) -> Option<(&T, &[T])> {\n-        let len = self.len();\n-        if len == 0 { None } else { Some((&self[len - 1], &self[..(len - 1)])) }\n+        if let [init @ .., last] = self { Some((last, init)) } else { None }\n     }\n \n     /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.\n@@ -203,13 +197,7 @@ impl<T> [T] {\n     #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n     #[inline]\n     pub fn split_last_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n-        let len = self.len();\n-        if len == 0 {\n-            None\n-        } else {\n-            let split = self.split_at_mut(len - 1);\n-            Some((&mut split.1[0], split.0))\n-        }\n+        if let [init @ .., last] = self { Some((last, init)) } else { None }\n     }\n \n     /// Returns the last element of the slice, or `None` if it is empty.\n@@ -226,8 +214,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn last(&self) -> Option<&T> {\n-        let last_idx = self.len().checked_sub(1)?;\n-        self.get(last_idx)\n+        if let [.., last] = self { Some(last) } else { None }\n     }\n \n     /// Returns a mutable pointer to the last item in the slice.\n@@ -245,8 +232,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn last_mut(&mut self) -> Option<&mut T> {\n-        let last_idx = self.len().checked_sub(1)?;\n-        self.get_mut(last_idx)\n+        if let [.., last] = self { Some(last) } else { None }\n     }\n \n     /// Returns a reference to an element or subslice depending on the type of"}]}