{"sha": "fa15c4d75e87bd3bf761c91f030c76aec59308ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhMTVjNGQ3NWU4N2JkM2JmNzYxYzkxZjAzMGM3NmFlYzU5MzA4YWU=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-21T10:34:07Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-21T10:34:07Z"}, "message": "Merge #1175\n\n1175: Fix bugs and add error log about macro expansion r=matklad a=edwin0cheng\n\nThis PR fixed / add following things:\r\n\r\n* Add a fused count which stop recursion of macro expansion in name resolution.\r\n* Add some logs when macro expansion fails\r\n* Add `$crate` meta variable support in mbe, which create a `$crate` ident token in token tree.\r\n* Fixed matching a `$REPEAT` pattern inside a subtree, e.g. `(fn $name:ident {$($i:ident)*} ) => {...}`\r\n* Remove composite-able punct token in syntax node to token conversion. \n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "ba7a3495b13e41231076d5a0e491132bbdb0670e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba7a3495b13e41231076d5a0e491132bbdb0670e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa15c4d75e87bd3bf761c91f030c76aec59308ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa15c4d75e87bd3bf761c91f030c76aec59308ae", "html_url": "https://github.com/rust-lang/rust/commit/fa15c4d75e87bd3bf761c91f030c76aec59308ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa15c4d75e87bd3bf761c91f030c76aec59308ae/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "493bf20b3d1a0a890514d5252901f13d2878ff34", "url": "https://api.github.com/repos/rust-lang/rust/commits/493bf20b3d1a0a890514d5252901f13d2878ff34", "html_url": "https://github.com/rust-lang/rust/commit/493bf20b3d1a0a890514d5252901f13d2878ff34"}, {"sha": "9e35bf91b827900b089a7ea937cb73707bebc420", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e35bf91b827900b089a7ea937cb73707bebc420", "html_url": "https://github.com/rust-lang/rust/commit/9e35bf91b827900b089a7ea937cb73707bebc420"}], "stats": {"total": 204, "additions": 154, "deletions": 50}, "files": [{"sha": "2a1ed9b8160991c9d59c6efc8f71ac8ec7b49305", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fa15c4d75e87bd3bf761c91f030c76aec59308ae/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa15c4d75e87bd3bf761c91f030c76aec59308ae/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=fa15c4d75e87bd3bf761c91f030c76aec59308ae", "patch": "@@ -63,8 +63,15 @@ impl HirFileId {\n         match file_id.0 {\n             HirFileIdRepr::File(file_id) => db.parse(file_id),\n             HirFileIdRepr::Macro(macro_call_id) => {\n-                // returning an empty string looks fishy...\n-                parse_macro(db, macro_call_id).unwrap_or_else(|| SourceFile::parse(\"\"))\n+                parse_macro(db, macro_call_id).unwrap_or_else(|| {\n+                    // Note:\n+                    // The final goal we would like to make all parse_macro success,\n+                    // such that the following log will not call anyway.\n+                    log::warn!(\"fail on macro_parse: {}\", macro_call_id.debug_dump(db));\n+\n+                    // returning an empty string looks fishy...\n+                    SourceFile::parse(\"\")\n+                })\n             }\n         }\n     }\n@@ -299,3 +306,16 @@ impl AstItemDef<ast::TypeAliasDef> for TypeAliasId {\n         db.lookup_intern_type_alias(self)\n     }\n }\n+\n+impl MacroCallId {\n+    pub fn debug_dump(&self, db: &impl DefDatabase) -> String {\n+        let loc = self.clone().loc(db);\n+        let node = loc.ast_id.to_node(db);\n+        let syntax_str = node.syntax().to_string();\n+\n+        // dump the file name\n+        let file_id: HirFileId = self.clone().into();\n+        let original = file_id.original_file(db);\n+        format!(\"macro call [file: {:#?}] : {}\", db.file_relative_path(original), syntax_str)\n+    }\n+}"}, {"sha": "6147b3219b20f907a0fbd502402f828911341955", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fa15c4d75e87bd3bf761c91f030c76aec59308ae/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa15c4d75e87bd3bf761c91f030c76aec59308ae/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=fa15c4d75e87bd3bf761c91f030c76aec59308ae", "patch": "@@ -42,6 +42,7 @@ pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> C\n         unresolved_imports: Vec::new(),\n         unexpanded_macros: Vec::new(),\n         global_macro_scope: FxHashMap::default(),\n+        marco_stack_count: 0,\n     };\n     collector.collect();\n     collector.finish()\n@@ -55,6 +56,10 @@ struct DefCollector<DB> {\n     unresolved_imports: Vec<(CrateModuleId, raw::ImportId, raw::ImportData)>,\n     unexpanded_macros: Vec<(CrateModuleId, AstId<ast::MacroCall>, Path)>,\n     global_macro_scope: FxHashMap<Name, MacroDefId>,\n+\n+    /// Some macro use `$tt:tt which mean we have to handle the macro perfectly\n+    /// To prevent stackoverflow, we add a deep counter here for prevent that.\n+    marco_stack_count: u32,\n }\n \n impl<'a, DB> DefCollector<&'a DB>\n@@ -324,10 +329,18 @@ where\n     }\n \n     fn collect_macro_expansion(&mut self, module_id: CrateModuleId, macro_call_id: MacroCallId) {\n-        let file_id: HirFileId = macro_call_id.into();\n-        let raw_items = self.db.raw_items(file_id);\n-        ModCollector { def_collector: &mut *self, file_id, module_id, raw_items: &raw_items }\n-            .collect(raw_items.items())\n+        self.marco_stack_count += 1;\n+\n+        if self.marco_stack_count < 300 {\n+            let file_id: HirFileId = macro_call_id.into();\n+            let raw_items = self.db.raw_items(file_id);\n+            ModCollector { def_collector: &mut *self, file_id, module_id, raw_items: &raw_items }\n+                .collect(raw_items.items())\n+        } else {\n+            log::error!(\"Too deep macro expansion: {}\", macro_call_id.debug_dump(self.db));\n+        }\n+\n+        self.marco_stack_count -= 1;\n     }\n \n     fn finish(self) -> CrateDefMap {"}, {"sha": "9aad08db963af7ecc29ae357e60c6c8d212e1db3", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 87, "deletions": 23, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/fa15c4d75e87bd3bf761c91f030c76aec59308ae/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa15c4d75e87bd3bf761c91f030c76aec59308ae/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=fa15c4d75e87bd3bf761c91f030c76aec59308ae", "patch": "@@ -214,14 +214,15 @@ impl_froms!(TokenTree: Leaf, Subtree);\n         let tree = token_tree_to_macro_items(&expanded);\n \n         // Eat all white space by parse it back and forth\n-        let expansion = ast::SourceFile::parse(expansion);\n+        // Because $crate will seperate in two token , will do some special treatment here\n+        let expansion = expansion.replace(\"$crate\", \"C_C__C\");\n+        let expansion = ast::SourceFile::parse(&expansion);\n         let expansion = syntax_node_to_token_tree(expansion.syntax()).unwrap().0;\n         let file = token_tree_to_macro_items(&expansion);\n+        let file = file.unwrap().syntax().debug_dump().trim().to_string();\n+        let file = file.replace(\"C_C__C\", \"$crate\");\n \n-        assert_eq!(\n-            tree.unwrap().syntax().debug_dump().trim(),\n-            file.unwrap().syntax().debug_dump().trim()\n-        );\n+        assert_eq!(tree.unwrap().syntax().debug_dump().trim(), file,);\n     }\n \n     #[test]\n@@ -348,7 +349,36 @@ impl_froms!(TokenTree: Leaf, Subtree);\n     }\n \n     #[test]\n-    fn expand_to_item_list() {\n+    fn test_match_group_empty_fixed_token() {\n+        let rules = create_rules(\n+            r#\"\n+        macro_rules! foo {\n+            ($ ($ i:ident)* #abc) => ( fn baz { $ (\n+                $ i ();\n+            )*} );            \n+        }\n+\"#,\n+        );\n+\n+        assert_expansion(&rules, \"foo! {#abc}\", \"fn baz {}\");\n+    }\n+\n+    #[test]\n+    fn test_match_group_in_subtree() {\n+        let rules = create_rules(\n+            r#\"\n+        macro_rules! foo {            \n+            (fn $name:ident {$($i:ident)*} ) => ( fn $name() { $ (\n+                $ i ();\n+            )*} );            \n+        }\"#,\n+        );\n+\n+        assert_expansion(&rules, \"foo! {fn baz {a b} }\", \"fn baz () {a () ; b () ;}\");\n+    }\n+\n+    #[test]\n+    fn test_expand_to_item_list() {\n         let rules = create_rules(\n             \"\n             macro_rules! structs {\n@@ -401,7 +431,7 @@ MACRO_ITEMS@[0; 40)\n     }\n \n     #[test]\n-    fn expand_literals_to_token_tree() {\n+    fn test_expand_literals_to_token_tree() {\n         fn to_subtree(tt: &tt::TokenTree) -> &tt::Subtree {\n             if let tt::TokenTree::Subtree(subtree) = tt {\n                 return &subtree;\n@@ -763,30 +793,29 @@ MACRO_ITEMS@[0; 40)\n         );\n     }\n \n-    //     #[test]\n-    //     fn test_tt_block() {\n-    //         let rules = create_rules(\n-    //             r#\"\n+    #[test]\n+    // fn test_tt_block() {\n+    //     let rules = create_rules(\n+    //         r#\"\n     //         macro_rules! foo {\n     //             ($ i:tt) => { fn foo() $ i }\n     //         }\n     // \"#,\n-    //         );\n-    //         assert_expansion(&rules, r#\"foo! { { 1; } }\"#, r#\"fn foo () {1 ;}\"#);\n-    //     }\n-\n-    //     #[test]\n-    //     fn test_tt_group() {\n-    //         let rules = create_rules(\n-    //             r#\"\n+    //     );\n+    //     assert_expansion(&rules, r#\"foo! { { 1; } }\"#, r#\"fn foo () {1 ;}\"#);\n+    // }\n+\n+    // #[test]\n+    // fn test_tt_group() {\n+    //     let rules = create_rules(\n+    //         r#\"\n     //         macro_rules! foo {\n     //              ($($ i:tt)*) => { $($ i)* }\n     //         }\n     // \"#,\n-    //         );\n-    //         assert_expansion(&rules, r#\"foo! { fn foo() {} }\"#, r#\"fn foo () {}\"#);\n-    //     }\n-\n+    //     );\n+    //     assert_expansion(&rules, r#\"foo! { fn foo() {} }\"#, r#\"fn foo () {}\"#);\n+    // }\n     #[test]\n     fn test_lifetime() {\n         let rules = create_rules(\n@@ -822,4 +851,39 @@ MACRO_ITEMS@[0; 40)\n         );\n         assert_expansion(&rules, r#\"foo!(pub foo);\"#, r#\"pub fn foo () {}\"#);\n     }\n+\n+    // The following tests are based on real world situations\n+    #[test]\n+    fn test_winapi_struct() {\n+        // from https://github.com/retep998/winapi-rs/blob/a7ef2bca086aae76cf6c4ce4c2552988ed9798ad/src/macros.rs#L366\n+\n+        let rules = create_rules(\n+            r#\"\n+macro_rules! STRUCT {\n+    ($(#[$attrs:meta])* struct $name:ident {\n+        $($field:ident: $ftype:ty,)+\n+    }) => (\n+        #[repr(C)] #[derive(Copy)] $(#[$attrs])*\n+        pub struct $name {\n+            $(pub $field: $ftype,)+\n+        }\n+        impl Clone for $name {\n+            #[inline]\n+            fn clone(&self) -> $name { *self }\n+        }\n+        #[cfg(feature = \"impl-default\")]\n+        impl Default for $name {\n+            #[inline]\n+            fn default() -> $name { unsafe { $crate::_core::mem::zeroed() } }\n+        }\n+    );\n+}\n+\"#,\n+        );\n+        // from https://github.com/retep998/winapi-rs/blob/a7ef2bca086aae76cf6c4ce4c2552988ed9798ad/src/shared/d3d9caps.rs\n+        assert_expansion(&rules, r#\"STRUCT!{struct D3DVSHADERCAPS2_0 {Caps: u8,}}\"#,\n+        \"# [repr (C)] # [derive (Copy)]  pub struct D3DVSHADERCAPS2_0 {pub Caps : u8 ,} impl Clone for D3DVSHADERCAPS2_0 {# [inline] fn clone (& self) -> D3DVSHADERCAPS2_0 {* self}} # [cfg (feature = \\\"impl-default\\\")] impl Default for D3DVSHADERCAPS2_0 {# [inline] fn default () -> D3DVSHADERCAPS2_0 {unsafe {$crate :: _core :: mem :: zeroed ()}}}\");\n+        assert_expansion(&rules, r#\"STRUCT!{#[cfg_attr(target_arch = \"x86\", repr(packed))] struct D3DCONTENTPROTECTIONCAPS {Caps : u8 ,}}\"#, \n+        \"# [repr (C)] # [derive (Copy)] # [cfg_attr (target_arch = \\\"x86\\\" , repr (packed))] pub struct D3DCONTENTPROTECTIONCAPS {pub Caps : u8 ,} impl Clone for D3DCONTENTPROTECTIONCAPS {# [inline] fn clone (& self) -> D3DCONTENTPROTECTIONCAPS {* self}} # [cfg (feature = \\\"impl-default\\\")] impl Default for D3DCONTENTPROTECTIONCAPS {# [inline] fn default () -> D3DCONTENTPROTECTIONCAPS {unsafe {$crate :: _core :: mem :: zeroed ()}}}\");\n+    }\n }"}, {"sha": "66ea7669898b86576f2c921f6794b8752d7ef1fb", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fa15c4d75e87bd3bf761c91f030c76aec59308ae/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa15c4d75e87bd3bf761c91f030c76aec59308ae/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=fa15c4d75e87bd3bf761c91f030c76aec59308ae", "patch": "@@ -121,6 +121,10 @@ impl Bindings {\n         }\n         Ok(())\n     }\n+\n+    fn merge(&mut self, nested: Bindings) {\n+        self.inner.extend(nested.inner);\n+    }\n }\n \n fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings, ExpandError> {\n@@ -236,7 +240,21 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n                     }\n                 }\n             }\n-            _ => {}\n+            crate::TokenTree::Subtree(subtree) => {\n+                let input_subtree =\n+                    input.eat_subtree().map_err(|_| ExpandError::UnexpectedToken)?;\n+                if subtree.delimiter != input_subtree.delimiter {\n+                    return Err(ExpandError::UnexpectedToken);\n+                }\n+\n+                let mut input = TtCursor::new(input_subtree);\n+                let bindings = match_lhs(&subtree, &mut input)?;\n+                if !input.is_eof() {\n+                    return Err(ExpandError::UnexpectedToken);\n+                }\n+\n+                res.merge(bindings);\n+            }\n         }\n     }\n     Ok(res)\n@@ -287,7 +305,15 @@ fn expand_tt(\n                     .into()\n             }\n             crate::Leaf::Punct(punct) => tt::Leaf::from(punct.clone()).into(),\n-            crate::Leaf::Var(v) => bindings.get(&v.text, nesting)?.clone(),\n+            crate::Leaf::Var(v) => {\n+                if v.text == \"crate\" {\n+                    // FIXME: Properly handle $crate token\n+                    tt::Leaf::from(tt::Ident { text: \"$crate\".into(), id: TokenId::unspecified() })\n+                        .into()\n+                } else {\n+                    bindings.get(&v.text, nesting)?.clone()\n+                }\n+            }\n             crate::Leaf::Literal(l) => tt::Leaf::from(tt::Literal { text: l.text.clone() }).into(),\n         },\n     };"}, {"sha": "16a053b49bb615fc06a6eee966ea8352d72467b0", "filename": "crates/ra_mbe/src/subtree_source.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fa15c4d75e87bd3bf761c91f030c76aec59308ae/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa15c4d75e87bd3bf761c91f030c76aec59308ae/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs?ref=fa15c4d75e87bd3bf761c91f030c76aec59308ae", "patch": "@@ -379,8 +379,6 @@ where\n {\n     if let Some((m, is_joint_to_next)) = iter.current_punct3(p) {\n         if let Some((kind, text)) = match m {\n-            ('<', '<', '=') => Some((SHLEQ, \"<<=\")),\n-            ('>', '>', '=') => Some((SHREQ, \">>=\")),\n             ('.', '.', '.') => Some((DOTDOTDOT, \"...\")),\n             ('.', '.', '=') => Some((DOTDOTEQ, \"..=\")),\n             _ => None,\n@@ -391,23 +389,6 @@ where\n \n     if let Some((m, is_joint_to_next)) = iter.current_punct2(p) {\n         if let Some((kind, text)) = match m {\n-            ('<', '<') => Some((SHL, \"<<\")),\n-            ('>', '>') => Some((SHR, \">>\")),\n-\n-            ('|', '|') => Some((PIPEPIPE, \"||\")),\n-            ('&', '&') => Some((AMPAMP, \"&&\")),\n-            ('%', '=') => Some((PERCENTEQ, \"%=\")),\n-            ('*', '=') => Some((STAREQ, \"*=\")),\n-            ('/', '=') => Some((SLASHEQ, \"/=\")),\n-            ('^', '=') => Some((CARETEQ, \"^=\")),\n-\n-            ('&', '=') => Some((AMPEQ, \"&=\")),\n-            ('|', '=') => Some((PIPEEQ, \"|=\")),\n-            ('-', '=') => Some((MINUSEQ, \"-=\")),\n-            ('+', '=') => Some((PLUSEQ, \"+=\")),\n-            ('>', '=') => Some((GTEQ, \">=\")),\n-            ('<', '=') => Some((LTEQ, \"<=\")),\n-\n             ('-', '>') => Some((THIN_ARROW, \"->\")),\n             ('!', '=') => Some((NEQ, \"!=\")),\n             ('=', '>') => Some((FAT_ARROW, \"=>\")),"}]}