{"sha": "3f12fa7fda96de6687cdd281affcee4a61c35b80", "node_id": "C_kwDOAAsO6NoAKDNmMTJmYTdmZGE5NmRlNjY4N2NkZDI4MWFmZmNlZTRhNjFjMzViODA", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2021-11-26T20:20:24Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-06-20T15:00:48Z"}, "message": "Add support for macro in \"jump to def\" feature", "tree": {"sha": "bab9532c53d1f3111f87aedf23669d62636a0e6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bab9532c53d1f3111f87aedf23669d62636a0e6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f12fa7fda96de6687cdd281affcee4a61c35b80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f12fa7fda96de6687cdd281affcee4a61c35b80", "html_url": "https://github.com/rust-lang/rust/commit/3f12fa7fda96de6687cdd281affcee4a61c35b80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f12fa7fda96de6687cdd281affcee4a61c35b80/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5c039cdb7431ddf3653c582b98ab6eb9af0701b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5c039cdb7431ddf3653c582b98ab6eb9af0701b", "html_url": "https://github.com/rust-lang/rust/commit/a5c039cdb7431ddf3653c582b98ab6eb9af0701b"}], "stats": {"total": 198, "additions": 162, "deletions": 36}, "files": [{"sha": "29a58810036c61dd46c7759dc20c6a11843bf073", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f12fa7fda96de6687cdd281affcee4a61c35b80/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f12fa7fda96de6687cdd281affcee4a61c35b80/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=3f12fa7fda96de6687cdd281affcee4a61c35b80", "patch": "@@ -519,6 +519,7 @@ impl clean::GenericArgs {\n }\n \n // Possible errors when computing href link source for a `DefId`\n+#[derive(PartialEq, Eq)]\n pub(crate) enum HrefError {\n     /// This item is known to rustdoc, but from a crate that does not have documentation generated.\n     ///"}, {"sha": "209172bb98e67db9277cb29de7c615b0f25aae62", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 107, "deletions": 19, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/3f12fa7fda96de6687cdd281affcee4a61c35b80/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f12fa7fda96de6687cdd281affcee4a61c35b80/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=3f12fa7fda96de6687cdd281affcee4a61c35b80", "patch": "@@ -5,15 +5,19 @@\n //!\n //! Use the `render_with_highlighting` to highlight some rust code.\n \n-use crate::clean::PrimitiveType;\n+use crate::clean::{ExternalLocation, PrimitiveType};\n use crate::html::escape::Escape;\n use crate::html::render::Context;\n \n use std::collections::VecDeque;\n use std::fmt::{Display, Write};\n+use std::iter::once;\n \n+use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::def_id::DefId;\n use rustc_lexer::{LiteralKind, TokenKind};\n+use rustc_metadata::creader::{CStore, LoadedMacro};\n use rustc_span::edition::Edition;\n use rustc_span::symbol::Symbol;\n use rustc_span::{BytePos, Span, DUMMY_SP};\n@@ -99,6 +103,7 @@ fn write_code(\n ) {\n     // This replace allows to fix how the code source with DOS backline characters is displayed.\n     let src = src.replace(\"\\r\\n\", \"\\n\");\n+    let mut closing_tag = \"\";\n     Classifier::new(\n         &src,\n         edition,\n@@ -108,8 +113,8 @@ fn write_code(\n     .highlight(&mut |highlight| {\n         match highlight {\n             Highlight::Token { text, class } => string(out, Escape(text), class, &context_info),\n-            Highlight::EnterSpan { class } => enter_span(out, class),\n-            Highlight::ExitSpan => exit_span(out),\n+            Highlight::EnterSpan { class } => closing_tag = enter_span(out, class, &context_info),\n+            Highlight::ExitSpan => exit_span(out, &closing_tag),\n         };\n     });\n }\n@@ -129,7 +134,7 @@ enum Class {\n     RefKeyWord,\n     Self_(Span),\n     Op,\n-    Macro,\n+    Macro(Span),\n     MacroNonTerminal,\n     String,\n     Number,\n@@ -153,7 +158,7 @@ impl Class {\n             Class::RefKeyWord => \"kw-2\",\n             Class::Self_(_) => \"self\",\n             Class::Op => \"op\",\n-            Class::Macro => \"macro\",\n+            Class::Macro(_) => \"macro\",\n             Class::MacroNonTerminal => \"macro-nonterminal\",\n             Class::String => \"string\",\n             Class::Number => \"number\",\n@@ -171,8 +176,22 @@ impl Class {\n     /// a \"span\" (a tuple representing `(lo, hi)` equivalent of `Span`).\n     fn get_span(self) -> Option<Span> {\n         match self {\n-            Self::Ident(sp) | Self::Self_(sp) => Some(sp),\n-            _ => None,\n+            Self::Ident(sp) | Self::Self_(sp) | Self::Macro(sp) => Some(sp),\n+            Self::Comment\n+            | Self::DocComment\n+            | Self::Attribute\n+            | Self::KeyWord\n+            | Self::RefKeyWord\n+            | Self::Op\n+            | Self::MacroNonTerminal\n+            | Self::String\n+            | Self::Number\n+            | Self::Bool\n+            | Self::Lifetime\n+            | Self::PreludeTy\n+            | Self::PreludeVal\n+            | Self::QuestionMark\n+            | Self::Decoration(_) => None,\n         }\n     }\n }\n@@ -611,7 +630,7 @@ impl<'a> Classifier<'a> {\n             },\n             TokenKind::Ident | TokenKind::RawIdent if lookahead == Some(TokenKind::Bang) => {\n                 self.in_macro = true;\n-                sink(Highlight::EnterSpan { class: Class::Macro });\n+                sink(Highlight::EnterSpan { class: Class::Macro(self.new_span(before, text)) });\n                 sink(Highlight::Token { text, class: None });\n                 return;\n             }\n@@ -658,13 +677,18 @@ impl<'a> Classifier<'a> {\n \n /// Called when we start processing a span of text that should be highlighted.\n /// The `Class` argument specifies how it should be highlighted.\n-fn enter_span(out: &mut Buffer, klass: Class) {\n-    write!(out, \"<span class=\\\"{}\\\">\", klass.as_html());\n+fn enter_span(\n+    out: &mut Buffer,\n+    klass: Class,\n+    context_info: &Option<ContextInfo<'_, '_, '_>>,\n+) -> &'static str {\n+    string_without_closing_tag(out, \"\", Some(klass), context_info)\n+        .expect(\"no closing tag to close wrapper...\")\n }\n \n /// Called at the end of a span of highlighted text.\n-fn exit_span(out: &mut Buffer) {\n-    out.write_str(\"</span>\");\n+fn exit_span(out: &mut Buffer, closing_tag: &str) {\n+    out.write_str(closing_tag);\n }\n \n /// Called for a span of text. If the text should be highlighted differently\n@@ -689,13 +713,28 @@ fn string<T: Display>(\n     klass: Option<Class>,\n     context_info: &Option<ContextInfo<'_, '_, '_>>,\n ) {\n+    if let Some(closing_tag) = string_without_closing_tag(out, text, klass, context_info) {\n+        out.write_str(closing_tag);\n+    }\n+}\n+\n+fn string_without_closing_tag<T: Display>(\n+    out: &mut Buffer,\n+    text: T,\n+    klass: Option<Class>,\n+    context_info: &Option<ContextInfo<'_, '_, '_>>,\n+) -> Option<&'static str> {\n     let Some(klass) = klass\n-    else { return write!(out, \"{}\", text) };\n+    else {\n+        write!(out, \"{}\", text);\n+        return None;\n+    };\n     let Some(def_span) = klass.get_span()\n     else {\n-        write!(out, \"<span class=\\\"{}\\\">{}</span>\", klass.as_html(), text);\n-        return;\n+        write!(out, \"<span class=\\\"{}\\\">{}\", klass.as_html(), text);\n+        return Some(\"</span>\");\n     };\n+\n     let mut text_s = text.to_string();\n     if text_s.contains(\"::\") {\n         text_s = text_s.split(\"::\").intersperse(\"::\").fold(String::new(), |mut path, t| {\n@@ -730,8 +769,17 @@ fn string<T: Display>(\n                         .map(|s| format!(\"{}{}\", context_info.root_path, s)),\n                     LinkFromSrc::External(def_id) => {\n                         format::href_with_root_path(*def_id, context, Some(context_info.root_path))\n-                            .ok()\n                             .map(|(url, _, _)| url)\n+                            .or_else(|e| {\n+                                if e == format::HrefError::NotInExternalCache\n+                                    && matches!(klass, Class::Macro(_))\n+                                {\n+                                    Ok(generate_macro_def_id_path(context_info, *def_id))\n+                                } else {\n+                                    Err(e)\n+                                }\n+                            })\n+                            .ok()\n                     }\n                     LinkFromSrc::Primitive(prim) => format::href_with_root_path(\n                         PrimitiveType::primitive_locations(context.tcx())[prim],\n@@ -743,11 +791,51 @@ fn string<T: Display>(\n                 }\n             })\n         {\n-            write!(out, \"<a class=\\\"{}\\\" href=\\\"{}\\\">{}</a>\", klass.as_html(), href, text_s);\n-            return;\n+            write!(out, \"<a class=\\\"{}\\\" href=\\\"{}\\\">{}\", klass.as_html(), href, text_s);\n+            return Some(\"</a>\");\n         }\n     }\n-    write!(out, \"<span class=\\\"{}\\\">{}</span>\", klass.as_html(), text_s);\n+    write!(out, \"<span class=\\\"{}\\\">{}\", klass.as_html(), text_s);\n+    Some(\"</span>\")\n+}\n+\n+/// This function is to get the external macro path because they are not in the cache used n\n+/// `href_with_root_path`.\n+fn generate_macro_def_id_path(context_info: &ContextInfo<'_, '_, '_>, def_id: DefId) -> String {\n+    let tcx = context_info.context.shared.tcx;\n+    let crate_name = tcx.crate_name(def_id.krate).to_string();\n+    let cache = &context_info.context.cache();\n+\n+    let relative = tcx.def_path(def_id).data.into_iter().filter_map(|elem| {\n+        // extern blocks have an empty name\n+        let s = elem.data.to_string();\n+        if !s.is_empty() { Some(s) } else { None }\n+    });\n+    // Check to see if it is a macro 2.0 or built-in macro\n+    let mut path = if matches!(\n+        CStore::from_tcx(tcx).load_macro_untracked(def_id, tcx.sess),\n+        LoadedMacro::MacroDef(def, _)\n+            if matches!(&def.kind, ast::ItemKind::MacroDef(ast_def)\n+                if !ast_def.macro_rules)\n+    ) {\n+        once(crate_name.clone()).chain(relative).collect()\n+    } else {\n+        vec![crate_name.clone(), relative.last().expect(\"relative was empty\")]\n+    };\n+\n+    let url_parts = match cache.extern_locations[&def_id.krate] {\n+        ExternalLocation::Remote(ref s) => vec![s.trim_end_matches('/')],\n+        ExternalLocation::Local => vec![context_info.root_path.trim_end_matches('/'), &crate_name],\n+        ExternalLocation::Unknown => panic!(\"unknown crate\"),\n+    };\n+\n+    let last = path.pop().unwrap();\n+    let last = format!(\"macro.{}.html\", last);\n+    if path.is_empty() {\n+        format!(\"{}/{}\", url_parts.join(\"/\"), last)\n+    } else {\n+        format!(\"{}/{}/{}\", url_parts.join(\"/\"), path.join(\"/\"), last)\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "0c60278a82dd96ef9e6830a6fd664eb729142214", "filename": "src/librustdoc/html/render/span_map.rs", "status": "modified", "additions": 54, "deletions": 17, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/3f12fa7fda96de6687cdd281affcee4a61c35b80/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f12fa7fda96de6687cdd281affcee4a61c35b80/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs?ref=3f12fa7fda96de6687cdd281affcee4a61c35b80", "patch": "@@ -8,7 +8,8 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{ExprKind, HirId, Mod, Node};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::TyCtxt;\n-use rustc_span::Span;\n+use rustc_span::hygiene::MacroKind;\n+use rustc_span::{BytePos, ExpnKind, Span};\n \n use std::path::{Path, PathBuf};\n \n@@ -63,32 +64,59 @@ struct SpanMapVisitor<'tcx> {\n \n impl<'tcx> SpanMapVisitor<'tcx> {\n     /// This function is where we handle `hir::Path` elements and add them into the \"span map\".\n-    fn handle_path(&mut self, path: &rustc_hir::Path<'_>, path_span: Option<Span>) {\n+    fn handle_path(&mut self, path: &rustc_hir::Path<'_>) {\n         let info = match path.res {\n-            // FIXME: For now, we only handle `DefKind` if it's not `DefKind::TyParam` or\n-            // `DefKind::Macro`. Would be nice to support them too alongside the other `DefKind`\n+            // FIXME: For now, we handle `DefKind` if it's not a `DefKind::TyParam`.\n+            // Would be nice to support them too alongside the other `DefKind`\n             // (such as primitive types!).\n-            Res::Def(kind, def_id) if kind != DefKind::TyParam => {\n-                if matches!(kind, DefKind::Macro(_)) {\n-                    return;\n-                }\n-                Some(def_id)\n-            }\n+            Res::Def(kind, def_id) if kind != DefKind::TyParam => Some(def_id),\n             Res::Local(_) => None,\n             Res::PrimTy(p) => {\n                 // FIXME: Doesn't handle \"path-like\" primitives like arrays or tuples.\n-                let span = path_span.unwrap_or(path.span);\n-                self.matches.insert(span, LinkFromSrc::Primitive(PrimitiveType::from(p)));\n+                self.matches.insert(path.span, LinkFromSrc::Primitive(PrimitiveType::from(p)));\n                 return;\n             }\n             Res::Err => return,\n             _ => return,\n         };\n         if let Some(span) = self.tcx.hir().res_span(path.res) {\n-            self.matches\n-                .insert(path_span.unwrap_or(path.span), LinkFromSrc::Local(clean::Span::new(span)));\n+            self.matches.insert(path.span, LinkFromSrc::Local(clean::Span::new(span)));\n         } else if let Some(def_id) = info {\n-            self.matches.insert(path_span.unwrap_or(path.span), LinkFromSrc::External(def_id));\n+            self.matches.insert(path.span, LinkFromSrc::External(def_id));\n+        }\n+    }\n+\n+    /// Adds the macro call into the span map. Returns `true` if the `span` was inside a macro\n+    /// expansion, whether or not it was added to the span map.\n+    fn handle_macro(&mut self, span: Span) -> bool {\n+        if span.from_expansion() {\n+            let mut data = span.ctxt().outer_expn_data();\n+            let mut call_site = data.call_site;\n+            while call_site.from_expansion() {\n+                data = call_site.ctxt().outer_expn_data();\n+                call_site = data.call_site;\n+            }\n+\n+            if let ExpnKind::Macro(MacroKind::Bang, macro_name) = data.kind {\n+                let link_from_src = if let Some(macro_def_id) = data.macro_def_id {\n+                    if macro_def_id.is_local() {\n+                        LinkFromSrc::Local(clean::Span::new(data.def_site))\n+                    } else {\n+                        LinkFromSrc::External(macro_def_id)\n+                    }\n+                } else {\n+                    return true;\n+                };\n+                let new_span = data.call_site;\n+                let macro_name = macro_name.as_str();\n+                // The \"call_site\" includes the whole macro with its \"arguments\". We only want\n+                // the macro name.\n+                let new_span = new_span.with_hi(new_span.lo() + BytePos(macro_name.len() as u32));\n+                self.matches.insert(new_span, link_from_src);\n+            }\n+            true\n+        } else {\n+            false\n         }\n     }\n }\n@@ -101,7 +129,10 @@ impl<'tcx> Visitor<'tcx> for SpanMapVisitor<'tcx> {\n     }\n \n     fn visit_path(&mut self, path: &'tcx rustc_hir::Path<'tcx>, _id: HirId) {\n-        self.handle_path(path, None);\n+        if self.handle_macro(path.span) {\n+            return;\n+        }\n+        self.handle_path(path);\n         intravisit::walk_path(self, path);\n     }\n \n@@ -143,12 +174,18 @@ impl<'tcx> Visitor<'tcx> for SpanMapVisitor<'tcx> {\n                     );\n                 }\n             }\n+        } else if self.handle_macro(expr.span) {\n+            // We don't want to deeper into the macro.\n+            return;\n         }\n         intravisit::walk_expr(self, expr);\n     }\n \n     fn visit_use(&mut self, path: &'tcx rustc_hir::Path<'tcx>, id: HirId) {\n-        self.handle_path(path, None);\n+        if self.handle_macro(path.span) {\n+            return;\n+        }\n+        self.handle_path(path);\n         intravisit::walk_use(self, path, id);\n     }\n }"}]}