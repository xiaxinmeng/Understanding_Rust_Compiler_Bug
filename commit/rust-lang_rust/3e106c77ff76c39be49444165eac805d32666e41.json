{"sha": "3e106c77ff76c39be49444165eac805d32666e41", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlMTA2Yzc3ZmY3NmMzOWJlNDk0NDQxNjVlYWM4MDVkMzI2NjZlNDE=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-02-22T12:14:39Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-02-22T12:14:39Z"}, "message": "Rework find_super_trait_path to protect against cycles", "tree": {"sha": "7f136356bb7edb610233a2821be0b755725ed03a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f136356bb7edb610233a2821be0b755725ed03a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e106c77ff76c39be49444165eac805d32666e41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e106c77ff76c39be49444165eac805d32666e41", "html_url": "https://github.com/rust-lang/rust/commit/3e106c77ff76c39be49444165eac805d32666e41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e106c77ff76c39be49444165eac805d32666e41/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2000257941956cd4c4365d6eb6cdbc1b16e929c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2000257941956cd4c4365d6eb6cdbc1b16e929c", "html_url": "https://github.com/rust-lang/rust/commit/c2000257941956cd4c4365d6eb6cdbc1b16e929c"}], "stats": {"total": 97, "additions": 74, "deletions": 23}, "files": [{"sha": "0009c426c4ed557c127ba7e916c1c9fc563595ba", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3e106c77ff76c39be49444165eac805d32666e41/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e106c77ff76c39be49444165eac805d32666e41/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=3e106c77ff76c39be49444165eac805d32666e41", "patch": "@@ -814,13 +814,16 @@ pub trait TypeWalk {\n     where\n         Self: Sized,\n     {\n-        self.fold_binders(&mut |ty, binders| match ty {\n-            Ty::Bound(idx) if idx as usize >= binders => {\n-                assert!(idx as i32 >= -n);\n-                Ty::Bound((idx as i32 + n) as u32)\n-            }\n-            ty => ty,\n-        }, 0)\n+        self.fold_binders(\n+            &mut |ty, binders| match ty {\n+                Ty::Bound(idx) if idx as usize >= binders => {\n+                    assert!(idx as i32 >= -n);\n+                    Ty::Bound((idx as i32 + n) as u32)\n+                }\n+                ty => ty,\n+            },\n+            0,\n+        )\n     }\n }\n "}, {"sha": "092977e93054e1850f2fd858f8bd8b4a259e507f", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e106c77ff76c39be49444165eac805d32666e41/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e106c77ff76c39be49444165eac805d32666e41/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=3e106c77ff76c39be49444165eac805d32666e41", "patch": "@@ -241,7 +241,8 @@ impl Ty {\n             TypeNs::TraitId(trait_) => {\n                 // if this is a bare dyn Trait, we'll directly put the required ^0 for the self type in there\n                 let self_ty = if remaining_segments.len() == 0 { Some(Ty::Bound(0)) } else { None };\n-                let trait_ref = TraitRef::from_resolved_path(ctx, trait_, resolved_segment, self_ty);\n+                let trait_ref =\n+                    TraitRef::from_resolved_path(ctx, trait_, resolved_segment, self_ty);\n                 return if remaining_segments.len() == 1 {\n                     let segment = remaining_segments.first().unwrap();\n                     let associated_ty = associated_type_by_name_including_super_traits("}, {"sha": "60ad6e9be3ab728f34d02a351bd3ce09a88d57c4", "filename": "crates/ra_hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3e106c77ff76c39be49444165eac805d32666e41/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e106c77ff76c39be49444165eac805d32666e41/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=3e106c77ff76c39be49444165eac805d32666e41", "patch": "@@ -622,6 +622,44 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn coerce_unsize_super_trait_cycle() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+#[lang = \"unsize\"]\n+pub trait Unsize<T> {}\n+#[lang = \"coerce_unsized\"]\n+pub trait CoerceUnsized<T> {}\n+\n+impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n+\n+trait A {}\n+trait B: C + A {}\n+trait C: B {}\n+trait D: C\n+\n+struct S;\n+impl A for S {}\n+impl B for S {}\n+impl C for S {}\n+impl D for S {}\n+\n+fn test() {\n+    let obj: &dyn D = &S;\n+    let obj: &dyn A = obj;\n+}\n+\"#, true),\n+        @r###\"\n+    [292; 348) '{     ...obj; }': ()\n+    [302; 305) 'obj': &dyn D\n+    [316; 318) '&S': &S\n+    [317; 318) 'S': S\n+    [328; 331) 'obj': &dyn A\n+    [342; 345) 'obj': &dyn D\n+    \"###\n+    );\n+}\n+\n #[ignore]\n #[test]\n fn coerce_unsize_generic() {"}, {"sha": "df0645717c638fc5fe3a0d673df1fcb46e4393db", "filename": "crates/ra_hir_ty/src/traits/builtin.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e106c77ff76c39be49444165eac805d32666e41/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e106c77ff76c39be49444165eac805d32666e41/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs?ref=3e106c77ff76c39be49444165eac805d32666e41", "patch": "@@ -316,12 +316,10 @@ fn super_trait_object_unsize_impl_datum(\n     let self_bounds = vec![GenericPredicate::Implemented(self_trait_ref.clone())];\n \n     // we need to go from our trait to the super trait, substituting type parameters\n-    let mut path = crate::utils::find_super_trait_path(db, data.super_trait, data.trait_);\n-    path.pop(); // the last one is our current trait, we don't need that\n-    path.reverse(); // we want to go from trait to super trait\n+    let path = crate::utils::find_super_trait_path(db, data.trait_, data.super_trait);\n \n     let mut current_trait_ref = self_trait_ref;\n-    for t in path {\n+    for t in path.into_iter().skip(1) {\n         let bounds = db.generic_predicates(current_trait_ref.trait_.into());\n         let super_trait_ref = bounds\n             .iter()"}, {"sha": "463fd65b4e27ec979820881ece74b8a46c383270", "filename": "crates/ra_hir_ty/src/utils.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3e106c77ff76c39be49444165eac805d32666e41/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e106c77ff76c39be49444165eac805d32666e41/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Futils.rs?ref=3e106c77ff76c39be49444165eac805d32666e41", "patch": "@@ -62,25 +62,36 @@ pub(super) fn all_super_traits(db: &impl DefDatabase, trait_: TraitId) -> Vec<Tr\n     result\n }\n \n-/// Finds a path from a trait to one of its descendant traits. Returns an empty\n+/// Finds a path from a trait to one of its super traits. Returns an empty\n /// vector if there is no path.\n pub(super) fn find_super_trait_path(\n     db: &impl DefDatabase,\n-    super_trait: TraitId,\n     trait_: TraitId,\n+    super_trait: TraitId,\n ) -> Vec<TraitId> {\n-    if trait_ == super_trait {\n-        return vec![trait_];\n-    }\n+    let mut result = Vec::with_capacity(2);\n+    result.push(trait_);\n+    return if go(db, super_trait, &mut result) { result } else { Vec::new() };\n+\n+    fn go(db: &impl DefDatabase, super_trait: TraitId, path: &mut Vec<TraitId>) -> bool {\n+        let trait_ = *path.last().unwrap();\n+        if trait_ == super_trait {\n+            return true;\n+        }\n \n-    for tt in direct_super_traits(db, trait_) {\n-        let mut path = find_super_trait_path(db, super_trait, tt);\n-        if !path.is_empty() {\n-            path.push(trait_);\n-            return path;\n+        for tt in direct_super_traits(db, trait_) {\n+            if path.contains(&tt) {\n+                continue;\n+            }\n+            path.push(tt);\n+            if go(db, super_trait, path) {\n+                return true;\n+            } else {\n+                path.pop();\n+            }\n         }\n+        false\n     }\n-    Vec::new()\n }\n \n pub(super) fn associated_type_by_name_including_super_traits("}]}