{"sha": "2ee4aac62f4f14204194c391f0eac267c2eee077", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlZTRhYWM2MmY0ZjE0MjA0MTk0YzM5MWYwZWFjMjY3YzJlZWUwNzc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-23T19:22:57Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-24T14:45:08Z"}, "message": "fix leaks with -Zmiri-start-fn", "tree": {"sha": "7b53f2c56bc486866632863b69e8a80f556f862a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b53f2c56bc486866632863b69e8a80f556f862a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ee4aac62f4f14204194c391f0eac267c2eee077", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ee4aac62f4f14204194c391f0eac267c2eee077", "html_url": "https://github.com/rust-lang/rust/commit/2ee4aac62f4f14204194c391f0eac267c2eee077", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ee4aac62f4f14204194c391f0eac267c2eee077/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a4ad2bb9fe3216010f33b47c6b05debaef7d604", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a4ad2bb9fe3216010f33b47c6b05debaef7d604", "html_url": "https://github.com/rust-lang/rust/commit/1a4ad2bb9fe3216010f33b47c6b05debaef7d604"}], "stats": {"total": 90, "additions": 49, "deletions": 41}, "files": [{"sha": "d16e024db47d4cdc55660ef652f947570c162d81", "filename": "src/fn_call.rs", "status": "modified", "additions": 25, "deletions": 34, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/2ee4aac62f4f14204194c391f0eac267c2eee077/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ee4aac62f4f14204194c391f0eac267c2eee077/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=2ee4aac62f4f14204194c391f0eac267c2eee077", "patch": "@@ -75,35 +75,6 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n             return Ok(None);\n         }\n \n-        // FIXME: Why are these hooked here, not in `emulate_missing_fn` or so?\n-        let def_id = instance.def_id();\n-        let item_path = self.tcx.absolute_item_path_str(def_id);\n-        match &*item_path {\n-            \"std::sys::unix::thread::guard::init\" | \"std::sys::unix::thread::guard::current\" => {\n-                // Return None, as it doesn't make sense to return Some, because miri detects stack overflow itself.\n-                let dest = dest.unwrap();\n-                match dest.layout.ty.sty {\n-                    ty::Adt(ref adt_def, _) => {\n-                        assert!(adt_def.is_enum(), \"Unexpected return type for {}\", item_path);\n-                        let none_variant_index = adt_def.variants.iter().position(|def| {\n-                            def.name.as_str() == \"None\"\n-                        }).expect(\"No None variant\");\n-\n-                        self.write_discriminant_value(none_variant_index, dest)?;\n-                        self.goto_block(ret)?;\n-                        return Ok(None);\n-                    }\n-                    _ => panic!(\"Unexpected return type for {}\", item_path)\n-                }\n-            }\n-            \"std::sys::unix::fast_thread_local::register_dtor\" => {\n-                // TODO: register the dtor\n-                self.goto_block(ret)?;\n-                return Ok(None);\n-            }\n-            _ => {}\n-        }\n-\n         // Try to see if we can do something about foreign items\n         if self.tcx.is_foreign_item(instance.def_id()) {\n             // An external function that we cannot find MIR for, but we can still run enough\n@@ -280,6 +251,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n                 let data = self.read_scalar(args[1])?.not_undef()?;\n                 let f_instance = self.memory.get_fn(f)?;\n                 self.write_null(dest)?;\n+                trace!(\"__rust_maybe_catch_panic: {:?}\", f_instance);\n \n                 // Now we make a function call.  TODO: Consider making this re-usable?  EvalContext::step does sth. similar for the TLS dtors,\n                 // and of course eval_main.\n@@ -478,7 +450,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n             }\n \n             \"sysconf\" => {\n-                let name = self.read_scalar(args[0])?.to_usize(&self)?;\n+                let name = self.read_scalar(args[0])?.to_i32()?;\n \n                 trace!(\"sysconf() called with name {}\", name);\n                 // cache the sysconf integers via miri's global cache\n@@ -494,7 +466,9 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n                             promoted: None,\n                         };\n                         let const_val = self.const_eval(cid)?;\n-                        let value = const_val.unwrap_usize(self.tcx.tcx);\n+                        let value = const_val.unwrap_bits(\n+                            self.tcx.tcx,\n+                            ty::ParamEnv::empty().and(self.tcx.types.i32)) as i32;\n                         if value == name {\n                             result = Some(path_value);\n                             break;\n@@ -568,9 +542,26 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n                 return err!(Unimplemented(\"Thread-local store is not fully supported on macOS\".to_owned()));\n             },\n \n-            // Stub out all the other pthread calls to just return 0\n-            link_name if link_name.starts_with(\"pthread_\") => {\n-                debug!(\"ignoring C ABI call: {}\", link_name);\n+            // Determining stack base address\n+            \"pthread_attr_init\" | \"pthread_attr_destroy\" | \"pthread_attr_get_np\" |\n+            \"pthread_getattr_np\" | \"pthread_self\" => {\n+                self.write_null(dest)?;\n+            }\n+            \"pthread_attr_getstack\" => {\n+                // second argument is where we are supposed to write the stack size\n+                let ptr = self.ref_to_mplace(self.read_value(args[1])?)?;\n+                self.write_scalar(Scalar::from_int(0x80000, args[1].layout.size), ptr.into())?;\n+                // return 0\n+                self.write_null(dest)?;\n+            }\n+\n+            // Stub out calls for condvar, mutex and rwlock to just return 0\n+            \"pthread_mutexattr_init\" | \"pthread_mutexattr_settype\" | \"pthread_mutex_init\" |\n+            \"pthread_mutexattr_destroy\" | \"pthread_mutex_lock\" | \"pthread_mutex_unlock\" |\n+            \"pthread_mutex_destroy\" | \"pthread_rwlock_rdlock\" | \"pthread_rwlock_unlock\" |\n+            \"pthread_rwlock_wrlock\" | \"pthread_rwlock_destroy\" | \"pthread_condattr_init\" |\n+            \"pthread_condattr_setclock\" | \"pthread_cond_init\" | \"pthread_condattr_destroy\" |\n+            \"pthread_cond_destroy\" => {\n                 self.write_null(dest)?;\n             }\n "}, {"sha": "a3810516eafd9d5edea9804b3461e3d874e68abc", "filename": "src/lib.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2ee4aac62f4f14204194c391f0eac267c2eee077/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ee4aac62f4f14204194c391f0eac267c2eee077/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=2ee4aac62f4f14204194c391f0eac267c2eee077", "patch": "@@ -16,14 +16,15 @@ extern crate rustc_mir;\n extern crate rustc_target;\n extern crate syntax;\n \n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, TyCtxt, query::TyCtxtAt};\n use rustc::ty::layout::{TyLayout, LayoutOf, Size};\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n \n use rustc_data_structures::fx::FxHasher;\n \n use syntax::ast::Mutability;\n+use syntax::attr;\n \n use std::marker::PhantomData;\n use std::collections::{HashMap, BTreeMap};\n@@ -359,12 +360,28 @@ impl<'mir, 'tcx: 'mir> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         Ok(())\n     }\n \n-    fn global_item_with_linkage<'a>(\n-        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        _instance: ty::Instance<'tcx>,\n-        _mutability: Mutability,\n-    ) -> EvalResult<'tcx> {\n-        panic!(\"remove this function from rustc\");\n+    fn find_foreign_static<'a>(\n+        tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n+        def_id: DefId,\n+    ) -> EvalResult<'tcx, &'tcx Allocation> {\n+        let attrs = tcx.get_attrs(def_id);\n+        let link_name = match attr::first_attr_value_str_by_name(&attrs, \"link_name\") {\n+            Some(name) => name.as_str(),\n+            None => tcx.item_name(def_id).as_str(),\n+        };\n+\n+        let alloc = match &link_name[..] {\n+            \"__cxa_thread_atexit_impl\" => {\n+                // This should be all-zero, pointer-sized\n+                let data = vec![0; tcx.data_layout.pointer_size.bytes() as usize];\n+                let alloc = Allocation::from_bytes(&data[..], tcx.data_layout.pointer_align);\n+                tcx.intern_const_alloc(alloc)\n+            }\n+            _ => return err!(Unimplemented(\n+                    format!(\"can't access foreign static: {}\", link_name),\n+                )),\n+        };\n+        Ok(alloc)\n     }\n \n     fn validation_op<'a>("}]}