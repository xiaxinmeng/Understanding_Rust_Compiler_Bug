{"sha": "ec30876f30082a7b32876bd78a8da01f11dcde1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjMzA4NzZmMzAwODJhN2IzMjg3NmJkNzhhOGRhMDFmMTFkY2RlMWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-13T13:44:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-13T13:44:40Z"}, "message": "Auto merge of #62468 - rust-lang:mutable-overloaded-operators, r=estebank\n\nImprove diagnostics for invalid mutation through overloaded operators\n\nCloses #58864\nCloses #52941\nCloses #57839", "tree": {"sha": "42882a1242f0a60f3666cce6057338841444d619", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42882a1242f0a60f3666cce6057338841444d619"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec30876f30082a7b32876bd78a8da01f11dcde1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec30876f30082a7b32876bd78a8da01f11dcde1e", "html_url": "https://github.com/rust-lang/rust/commit/ec30876f30082a7b32876bd78a8da01f11dcde1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec30876f30082a7b32876bd78a8da01f11dcde1e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b468c6360cba002ba1e97b70cf51223a498442e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b468c6360cba002ba1e97b70cf51223a498442e", "html_url": "https://github.com/rust-lang/rust/commit/6b468c6360cba002ba1e97b70cf51223a498442e"}, {"sha": "38306adf16ea6eecb6ccfaf0f701b0a1117bb19d", "url": "https://api.github.com/repos/rust-lang/rust/commits/38306adf16ea6eecb6ccfaf0f701b0a1117bb19d", "html_url": "https://github.com/rust-lang/rust/commit/38306adf16ea6eecb6ccfaf0f701b0a1117bb19d"}], "stats": {"total": 551, "additions": 282, "deletions": 269}, "files": [{"sha": "5f61ed151c0d626fe5a4fe2ef7cff76960c97e70", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 151, "deletions": 2, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/ec30876f30082a7b32876bd78a8da01f11dcde1e/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec30876f30082a7b32876bd78a8da01f11dcde1e/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=ec30876f30082a7b32876bd78a8da01f11dcde1e", "patch": "@@ -4,9 +4,9 @@ use rustc::hir::def_id::DefId;\n use rustc::mir::{\n     AggregateKind, Constant, Field, Local, LocalKind, Location, Operand,\n     Place, PlaceBase, ProjectionElem, Rvalue, Statement, StatementKind, Static,\n-    StaticKind, TerminatorKind,\n+    StaticKind, Terminator, TerminatorKind,\n };\n-use rustc::ty::{self, DefIdTree, Ty};\n+use rustc::ty::{self, DefIdTree, Ty, TyCtxt};\n use rustc::ty::layout::VariantIdx;\n use rustc::ty::print::Print;\n use rustc_errors::DiagnosticBuilder;\n@@ -15,6 +15,7 @@ use syntax::symbol::sym;\n \n use super::borrow_set::BorrowData;\n use super::{MirBorrowckCtxt};\n+use crate::dataflow::move_paths::{InitLocation, LookupResult};\n \n pub(super) struct IncludingDowncast(pub(super) bool);\n \n@@ -401,6 +402,70 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             err.note(&message);\n         }\n     }\n+\n+    pub(super) fn borrowed_content_source(\n+        &self,\n+        deref_base: &Place<'tcx>,\n+    ) -> BorrowedContentSource<'tcx> {\n+        let tcx = self.infcx.tcx;\n+\n+        // Look up the provided place and work out the move path index for it,\n+        // we'll use this to check whether it was originally from an overloaded\n+        // operator.\n+        match self.move_data.rev_lookup.find(deref_base) {\n+            LookupResult::Exact(mpi) | LookupResult::Parent(Some(mpi)) => {\n+                debug!(\"borrowed_content_source: mpi={:?}\", mpi);\n+\n+                for i in &self.move_data.init_path_map[mpi] {\n+                    let init = &self.move_data.inits[*i];\n+                    debug!(\"borrowed_content_source: init={:?}\", init);\n+                    // We're only interested in statements that initialized a value, not the\n+                    // initializations from arguments.\n+                    let loc = match init.location {\n+                        InitLocation::Statement(stmt) => stmt,\n+                        _ => continue,\n+                    };\n+\n+                    let bbd = &self.body[loc.block];\n+                    let is_terminator = bbd.statements.len() == loc.statement_index;\n+                    debug!(\n+                        \"borrowed_content_source: loc={:?} is_terminator={:?}\",\n+                        loc,\n+                        is_terminator,\n+                    );\n+                    if !is_terminator {\n+                        continue;\n+                    } else if let Some(Terminator {\n+                        kind: TerminatorKind::Call {\n+                            ref func,\n+                            from_hir_call: false,\n+                            ..\n+                        },\n+                        ..\n+                    }) = bbd.terminator {\n+                        if let Some(source)\n+                            = BorrowedContentSource::from_call(func.ty(self.body, tcx), tcx)\n+                        {\n+                            return source;\n+                        }\n+                    }\n+                }\n+            }\n+            // Base is a `static` so won't be from an overloaded operator\n+            _ => (),\n+        };\n+\n+        // If we didn't find an overloaded deref or index, then assume it's a\n+        // built in deref and check the type of the base.\n+        let base_ty = deref_base.ty(self.body, tcx).ty;\n+        if base_ty.is_unsafe_ptr() {\n+            BorrowedContentSource::DerefRawPointer\n+        } else if base_ty.is_mutable_pointer() {\n+            BorrowedContentSource::DerefMutableRef\n+        } else {\n+            BorrowedContentSource::DerefSharedRef\n+        }\n+    }\n }\n \n impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n@@ -547,6 +612,90 @@ impl UseSpans {\n     }\n }\n \n+pub(super) enum BorrowedContentSource<'tcx> {\n+    DerefRawPointer,\n+    DerefMutableRef,\n+    DerefSharedRef,\n+    OverloadedDeref(Ty<'tcx>),\n+    OverloadedIndex(Ty<'tcx>),\n+}\n+\n+impl BorrowedContentSource<'tcx> {\n+    pub(super) fn describe_for_unnamed_place(&self) -> String {\n+        match *self {\n+            BorrowedContentSource::DerefRawPointer => format!(\"a raw pointer\"),\n+            BorrowedContentSource::DerefSharedRef => format!(\"a shared reference\"),\n+            BorrowedContentSource::DerefMutableRef => {\n+                format!(\"a mutable reference\")\n+            }\n+            BorrowedContentSource::OverloadedDeref(ty) => {\n+                if ty.is_rc() {\n+                   format!(\"an `Rc`\")\n+                } else if ty.is_arc() {\n+                    format!(\"an `Arc`\")\n+                } else {\n+                    format!(\"dereference of `{}`\", ty)\n+                }\n+            }\n+            BorrowedContentSource::OverloadedIndex(ty) => format!(\"index of `{}`\", ty),\n+        }\n+    }\n+\n+    pub(super) fn describe_for_named_place(&self) -> Option<&'static str> {\n+        match *self {\n+            BorrowedContentSource::DerefRawPointer => Some(\"raw pointer\"),\n+            BorrowedContentSource::DerefSharedRef => Some(\"shared reference\"),\n+            BorrowedContentSource::DerefMutableRef => Some(\"mutable reference\"),\n+            // Overloaded deref and index operators should be evaluated into a\n+            // temporary. So we don't need a description here.\n+            BorrowedContentSource::OverloadedDeref(_)\n+            | BorrowedContentSource::OverloadedIndex(_) => None\n+        }\n+    }\n+\n+    pub(super) fn describe_for_immutable_place(&self) -> String {\n+        match *self {\n+            BorrowedContentSource::DerefRawPointer => format!(\"a `*const` pointer\"),\n+            BorrowedContentSource::DerefSharedRef => format!(\"a `&` reference\"),\n+            BorrowedContentSource::DerefMutableRef => {\n+                 bug!(\"describe_for_immutable_place: DerefMutableRef isn't immutable\")\n+            },\n+            BorrowedContentSource::OverloadedDeref(ty) => {\n+                if ty.is_rc() {\n+                   format!(\"an `Rc`\")\n+                } else if ty.is_arc() {\n+                    format!(\"an `Arc`\")\n+                } else {\n+                    format!(\"a dereference of `{}`\", ty)\n+                }\n+            }\n+            BorrowedContentSource::OverloadedIndex(ty) => format!(\"an index of `{}`\", ty),\n+        }\n+    }\n+\n+    fn from_call(func: Ty<'tcx>, tcx: TyCtxt<'tcx>) -> Option<Self> {\n+        match func.sty {\n+            ty::FnDef(def_id, substs) => {\n+                let trait_id = tcx.trait_of_item(def_id)?;\n+\n+                let lang_items = tcx.lang_items();\n+                if Some(trait_id) == lang_items.deref_trait()\n+                    || Some(trait_id) == lang_items.deref_mut_trait()\n+                {\n+                    Some(BorrowedContentSource::OverloadedDeref(substs.type_at(0)))\n+                } else if Some(trait_id) == lang_items.index_trait()\n+                    || Some(trait_id) == lang_items.index_mut_trait()\n+                {\n+                    Some(BorrowedContentSource::OverloadedIndex(substs.type_at(0)))\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n+}\n+\n impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Finds the spans associated to a move or copy of move_place at location.\n     pub(super) fn move_spans("}, {"sha": "3130b7cec5b4a946628aa9b7ee645ce071fc4b15", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 2, "deletions": 127, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/ec30876f30082a7b32876bd78a8da01f11dcde1e/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec30876f30082a7b32876bd78a8da01f11dcde1e/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=ec30876f30082a7b32876bd78a8da01f11dcde1e", "patch": "@@ -1,15 +1,15 @@\n use core::unicode::property::Pattern_White_Space;\n \n use rustc::mir::*;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty;\n use rustc_errors::{DiagnosticBuilder,Applicability};\n use syntax_pos::Span;\n \n use crate::borrow_check::MirBorrowckCtxt;\n use crate::borrow_check::prefixes::PrefixSet;\n use crate::borrow_check::error_reporting::UseSpans;\n use crate::dataflow::move_paths::{\n-    IllegalMoveOrigin, IllegalMoveOriginKind, InitLocation,\n+    IllegalMoveOrigin, IllegalMoveOriginKind,\n     LookupResult, MoveError, MovePathIndex,\n };\n use crate::util::borrowck_errors::{BorrowckErrors, Origin};\n@@ -55,70 +55,6 @@ enum GroupedMoveError<'tcx> {\n     },\n }\n \n-enum BorrowedContentSource<'tcx> {\n-    DerefRawPointer,\n-    DerefMutableRef,\n-    DerefSharedRef,\n-    OverloadedDeref(Ty<'tcx>),\n-    OverloadedIndex(Ty<'tcx>),\n-}\n-\n-impl BorrowedContentSource<'tcx> {\n-    fn describe_for_unnamed_place(&self) -> String {\n-        match *self {\n-            BorrowedContentSource::DerefRawPointer => format!(\"a raw pointer\"),\n-            BorrowedContentSource::DerefSharedRef => format!(\"a shared reference\"),\n-            BorrowedContentSource::DerefMutableRef => {\n-                format!(\"a mutable reference\")\n-            }\n-            BorrowedContentSource::OverloadedDeref(ty) => {\n-                if ty.is_rc() {\n-                   format!(\"an `Rc`\")\n-                } else if ty.is_arc() {\n-                    format!(\"an `Arc`\")\n-                } else {\n-                    format!(\"dereference of `{}`\", ty)\n-                }\n-            }\n-            BorrowedContentSource::OverloadedIndex(ty) => format!(\"index of `{}`\", ty),\n-        }\n-    }\n-\n-    fn describe_for_named_place(&self) -> Option<&'static str> {\n-        match *self {\n-            BorrowedContentSource::DerefRawPointer => Some(\"raw pointer\"),\n-            BorrowedContentSource::DerefSharedRef => Some(\"shared reference\"),\n-            BorrowedContentSource::DerefMutableRef => Some(\"mutable reference\"),\n-            // Overloaded deref and index operators should be evaluated into a\n-            // temporary. So we don't need a description here.\n-            BorrowedContentSource::OverloadedDeref(_)\n-            | BorrowedContentSource::OverloadedIndex(_) => None\n-        }\n-    }\n-\n-    fn from_call(func: Ty<'tcx>, tcx: TyCtxt<'tcx>) -> Option<Self> {\n-        match func.sty {\n-            ty::FnDef(def_id, substs) => {\n-                let trait_id = tcx.trait_of_item(def_id)?;\n-\n-                let lang_items = tcx.lang_items();\n-                if Some(trait_id) == lang_items.deref_trait()\n-                    || Some(trait_id) == lang_items.deref_mut_trait()\n-                {\n-                    Some(BorrowedContentSource::OverloadedDeref(substs.type_at(0)))\n-                } else if Some(trait_id) == lang_items.index_trait()\n-                    || Some(trait_id) == lang_items.index_mut_trait()\n-                {\n-                    Some(BorrowedContentSource::OverloadedIndex(substs.type_at(0)))\n-                } else {\n-                    None\n-                }\n-            }\n-            _ => None,\n-        }\n-    }\n-}\n-\n impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     pub(crate) fn report_move_errors(&mut self, move_errors: Vec<(Place<'tcx>, MoveError<'tcx>)>) {\n         let grouped_errors = self.group_move_errors(move_errors);\n@@ -646,65 +582,4 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             );\n         }\n     }\n-\n-    fn borrowed_content_source(&self, deref_base: &Place<'tcx>) -> BorrowedContentSource<'tcx> {\n-        let tcx = self.infcx.tcx;\n-\n-        // Look up the provided place and work out the move path index for it,\n-        // we'll use this to check whether it was originally from an overloaded\n-        // operator.\n-        match self.move_data.rev_lookup.find(deref_base) {\n-            LookupResult::Exact(mpi) | LookupResult::Parent(Some(mpi)) => {\n-                debug!(\"borrowed_content_source: mpi={:?}\", mpi);\n-\n-                for i in &self.move_data.init_path_map[mpi] {\n-                    let init = &self.move_data.inits[*i];\n-                    debug!(\"borrowed_content_source: init={:?}\", init);\n-                    // We're only interested in statements that initialized a value, not the\n-                    // initializations from arguments.\n-                    let loc = match init.location {\n-                        InitLocation::Statement(stmt) => stmt,\n-                        _ => continue,\n-                    };\n-\n-                    let bbd = &self.body[loc.block];\n-                    let is_terminator = bbd.statements.len() == loc.statement_index;\n-                    debug!(\n-                        \"borrowed_content_source: loc={:?} is_terminator={:?}\",\n-                        loc,\n-                        is_terminator,\n-                    );\n-                    if !is_terminator {\n-                        continue;\n-                    } else if let Some(Terminator {\n-                        kind: TerminatorKind::Call {\n-                            ref func,\n-                            from_hir_call: false,\n-                            ..\n-                        },\n-                        ..\n-                    }) = bbd.terminator {\n-                        if let Some(source)\n-                            = BorrowedContentSource::from_call(func.ty(self.body, tcx), tcx)\n-                        {\n-                            return source;\n-                        }\n-                    }\n-                }\n-            }\n-            // Base is a `static` so won't be from an overloaded operator\n-            _ => (),\n-        };\n-\n-        // If we didn't find an overloaded deref or index, then assume it's a\n-        // built in deref and check the type of the base.\n-        let base_ty = deref_base.ty(self.body, tcx).ty;\n-        if base_ty.is_unsafe_ptr() {\n-            BorrowedContentSource::DerefRawPointer\n-        } else if base_ty.is_mutable_pointer() {\n-            BorrowedContentSource::DerefMutableRef\n-        } else {\n-            BorrowedContentSource::DerefSharedRef\n-        }\n-    }\n }"}, {"sha": "04814a15c626b373ce5a7be39ccefd764b665fe4", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 32, "deletions": 65, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/ec30876f30082a7b32876bd78a8da01f11dcde1e/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec30876f30082a7b32876bd78a8da01f11dcde1e/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=ec30876f30082a7b32876bd78a8da01f11dcde1e", "patch": "@@ -1,17 +1,14 @@\n use rustc::hir;\n use rustc::hir::Node;\n-use rustc::mir::{self, BindingForm, Constant, ClearCrossCrate, Local, Location, Body};\n-use rustc::mir::{\n-    Mutability, Operand, Place, PlaceBase, Projection, ProjectionElem, Static, StaticKind,\n-};\n-use rustc::mir::{Terminator, TerminatorKind};\n-use rustc::ty::{self, Const, DefIdTree, Ty, TyS, TyCtxt};\n+use rustc::mir::{self, BindingForm, ClearCrossCrate, Local, Location, Body};\n+use rustc::mir::{Mutability, Place, PlaceBase, Projection, ProjectionElem, Static, StaticKind};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc_data_structures::indexed_vec::Idx;\n use syntax_pos::Span;\n use syntax_pos::symbol::kw;\n \n-use crate::dataflow::move_paths::InitLocation;\n use crate::borrow_check::MirBorrowckCtxt;\n+use crate::borrow_check::error_reporting::BorrowedContentSource;\n use crate::util::borrowck_errors::{BorrowckErrors, Origin};\n use crate::util::collect_writes::FindAssignments;\n use crate::util::suggest_ref_mut;\n@@ -43,6 +40,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let mut err;\n         let item_msg;\n         let reason;\n+        let mut opt_source = None;\n         let access_place_desc = self.describe_place(access_place);\n         debug!(\"report_mutability_error: access_place_desc={:?}\", access_place_desc);\n \n@@ -103,23 +101,20 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                     reason = \", as it is immutable for the pattern guard\".to_string();\n                 } else {\n-                    let pointer_type =\n-                        if base.ty(self.body, self.infcx.tcx).ty.is_region_ptr() {\n-                            \"`&` reference\"\n-                        } else {\n-                            \"`*const` pointer\"\n-                        };\n+                    let source = self.borrowed_content_source(base);\n+                    let pointer_type = source.describe_for_immutable_place();\n+                    opt_source = Some(source);\n                     if let Some(desc) = access_place_desc {\n                         item_msg = format!(\"`{}`\", desc);\n                         reason = match error_access {\n                             AccessKind::Move |\n-                            AccessKind::Mutate => format!(\" which is behind a {}\", pointer_type),\n+                            AccessKind::Mutate => format!(\" which is behind {}\", pointer_type),\n                             AccessKind::MutableBorrow => {\n-                                format!(\", as it is behind a {}\", pointer_type)\n+                                format!(\", as it is behind {}\", pointer_type)\n                             }\n                         }\n                     } else {\n-                        item_msg = format!(\"data in a {}\", pointer_type);\n+                        item_msg = format!(\"data in {}\", pointer_type);\n                         reason = String::new();\n                     }\n                 }\n@@ -457,59 +452,31 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n \n             Place::Projection(box Projection {\n-                base: Place::Base(PlaceBase::Local(local)),\n+                base: _,\n                 elem: ProjectionElem::Deref,\n-            })  if error_access == AccessKind::MutableBorrow => {\n+            }) => {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n \n-                let mpi = self.move_data.rev_lookup.find_local(*local);\n-                for i in self.move_data.init_path_map[mpi].iter() {\n-                    if let InitLocation::Statement(location) = self.move_data.inits[*i].location {\n-                        if let Some(\n-                            Terminator {\n-                                kind: TerminatorKind::Call {\n-                                    func: Operand::Constant(box Constant {\n-                                        literal: Const {\n-                                            ty: &TyS {\n-                                                sty: ty::FnDef(id, substs),\n-                                                ..\n-                                            },\n-                                            ..\n-                                        },\n-                                        ..\n-                                    }),\n-                                    ..\n-                                },\n-                                ..\n-                            }\n-                        ) = &self.body.basic_blocks()[location.block].terminator {\n-                            let index_trait = self.infcx.tcx.lang_items().index_trait();\n-                            if self.infcx.tcx.parent(id) == index_trait {\n-                                let mut found = false;\n-                                self.infcx.tcx.for_each_relevant_impl(\n-                                    self.infcx.tcx.lang_items().index_mut_trait().unwrap(),\n-                                    substs.type_at(0),\n-                                    |_relevant_impl| {\n-                                        found = true;\n-                                    }\n-                                );\n-\n-                                let extra = if found {\n-                                    String::new()\n-                                } else {\n-                                    format!(\", but it is not implemented for `{}`\",\n-                                            substs.type_at(0))\n-                                };\n-\n-                                err.help(\n-                                    &format!(\n-                                        \"trait `IndexMut` is required to modify indexed content{}\",\n-                                         extra,\n-                                    ),\n-                                );\n-                            }\n-                        }\n+                match opt_source {\n+                    Some(BorrowedContentSource::OverloadedDeref(ty)) => {\n+                        err.help(\n+                            &format!(\n+                                \"trait `DerefMut` is required to modify through a dereference, \\\n+                                but it is not implemented for `{}`\",\n+                                ty,\n+                            ),\n+                        );\n+                    },\n+                    Some(BorrowedContentSource::OverloadedIndex(ty)) => {\n+                        err.help(\n+                            &format!(\n+                                \"trait `IndexMut` is required to modify indexed content, \\\n+                                but it is not implemented for `{}`\",\n+                                ty,\n+                            ),\n+                        );\n                     }\n+                    _ => (),\n                 }\n             }\n "}, {"sha": "83eab7fdeab6a3529078fd75f6fff432f04995d8", "filename": "src/test/ui/borrowck/borrowck-borrow-overloaded-auto-deref.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ec30876f30082a7b32876bd78a8da01f11dcde1e/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrow-overloaded-auto-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec30876f30082a7b32876bd78a8da01f11dcde1e/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrow-overloaded-auto-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrow-overloaded-auto-deref.rs?ref=ec30876f30082a7b32876bd78a8da01f11dcde1e", "patch": "@@ -2,18 +2,7 @@\n // Deref and not DerefMut is implemented.\n \n use std::ops::Deref;\n-\n-struct Rc<T> {\n-    value: *const T\n-}\n-\n-impl<T> Deref for Rc<T> {\n-    type Target = T;\n-\n-    fn deref(&self) -> &T {\n-        unsafe { &*self.value }\n-    }\n-}\n+use std::rc::Rc;\n \n struct Point {\n     x: isize,"}, {"sha": "d262c578843a035e655742b81cf743356a941341", "filename": "src/test/ui/borrowck/borrowck-borrow-overloaded-auto-deref.stderr", "status": "modified", "additions": 56, "deletions": 28, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/ec30876f30082a7b32876bd78a8da01f11dcde1e/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrow-overloaded-auto-deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec30876f30082a7b32876bd78a8da01f11dcde1e/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrow-overloaded-auto-deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrow-overloaded-auto-deref.stderr?ref=ec30876f30082a7b32876bd78a8da01f11dcde1e", "patch": "@@ -1,86 +1,114 @@\n-error[E0596]: cannot borrow data in a `&` reference as mutable\n-  --> $DIR/borrowck-borrow-overloaded-auto-deref.rs:47:19\n+error[E0596]: cannot borrow data in an `Rc` as mutable\n+  --> $DIR/borrowck-borrow-overloaded-auto-deref.rs:36:19\n    |\n LL |     let __isize = &mut x.y;\n    |                   ^^^^^^^^ cannot borrow as mutable\n+   |\n+   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::rc::Rc<Point>`\n \n-error[E0596]: cannot borrow data in a `&` reference as mutable\n-  --> $DIR/borrowck-borrow-overloaded-auto-deref.rs:51:19\n+error[E0596]: cannot borrow data in an `Rc` as mutable\n+  --> $DIR/borrowck-borrow-overloaded-auto-deref.rs:40:19\n    |\n LL |     let __isize = &mut x.y;\n    |                   ^^^^^^^^ cannot borrow as mutable\n+   |\n+   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::rc::Rc<Point>`\n \n-error[E0596]: cannot borrow data in a `&` reference as mutable\n-  --> $DIR/borrowck-borrow-overloaded-auto-deref.rs:59:5\n+error[E0596]: cannot borrow data in an `Rc` as mutable\n+  --> $DIR/borrowck-borrow-overloaded-auto-deref.rs:48:5\n    |\n LL |     &mut x.y\n    |     ^^^^^^^^ cannot borrow as mutable\n+   |\n+   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::rc::Rc<Point>`\n \n-error[E0596]: cannot borrow data in a `&` reference as mutable\n-  --> $DIR/borrowck-borrow-overloaded-auto-deref.rs:63:5\n+error[E0596]: cannot borrow data in an `Rc` as mutable\n+  --> $DIR/borrowck-borrow-overloaded-auto-deref.rs:52:5\n    |\n LL |     &mut x.y\n    |     ^^^^^^^^ cannot borrow as mutable\n+   |\n+   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::rc::Rc<Point>`\n \n-error[E0594]: cannot assign to data in a `&` reference\n-  --> $DIR/borrowck-borrow-overloaded-auto-deref.rs:67:5\n+error[E0594]: cannot assign to data in an `Rc`\n+  --> $DIR/borrowck-borrow-overloaded-auto-deref.rs:56:5\n    |\n LL |     x.y = 3;\n    |     ^^^^^^^ cannot assign\n+   |\n+   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::rc::Rc<Point>`\n \n-error[E0594]: cannot assign to data in a `&` reference\n-  --> $DIR/borrowck-borrow-overloaded-auto-deref.rs:71:5\n+error[E0594]: cannot assign to data in an `Rc`\n+  --> $DIR/borrowck-borrow-overloaded-auto-deref.rs:60:5\n    |\n LL |     x.y = 3;\n    |     ^^^^^^^ cannot assign\n+   |\n+   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::rc::Rc<Point>`\n \n-error[E0594]: cannot assign to data in a `&` reference\n-  --> $DIR/borrowck-borrow-overloaded-auto-deref.rs:75:5\n+error[E0594]: cannot assign to data in an `Rc`\n+  --> $DIR/borrowck-borrow-overloaded-auto-deref.rs:64:5\n    |\n LL |     x.y = 3;\n    |     ^^^^^^^ cannot assign\n+   |\n+   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::rc::Rc<Point>`\n \n-error[E0596]: cannot borrow data in a `&` reference as mutable\n-  --> $DIR/borrowck-borrow-overloaded-auto-deref.rs:83:5\n+error[E0596]: cannot borrow data in an `Rc` as mutable\n+  --> $DIR/borrowck-borrow-overloaded-auto-deref.rs:72:5\n    |\n LL |     x.set(0, 0);\n    |     ^ cannot borrow as mutable\n+   |\n+   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::rc::Rc<Point>`\n \n-error[E0596]: cannot borrow data in a `&` reference as mutable\n-  --> $DIR/borrowck-borrow-overloaded-auto-deref.rs:87:5\n+error[E0596]: cannot borrow data in an `Rc` as mutable\n+  --> $DIR/borrowck-borrow-overloaded-auto-deref.rs:76:5\n    |\n LL |     x.set(0, 0);\n    |     ^ cannot borrow as mutable\n+   |\n+   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::rc::Rc<Point>`\n \n-error[E0596]: cannot borrow data in a `&` reference as mutable\n-  --> $DIR/borrowck-borrow-overloaded-auto-deref.rs:95:5\n+error[E0596]: cannot borrow data in an `Rc` as mutable\n+  --> $DIR/borrowck-borrow-overloaded-auto-deref.rs:84:5\n    |\n LL |     x.y_mut()\n    |     ^ cannot borrow as mutable\n+   |\n+   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::rc::Rc<Point>`\n \n-error[E0596]: cannot borrow data in a `&` reference as mutable\n-  --> $DIR/borrowck-borrow-overloaded-auto-deref.rs:99:5\n+error[E0596]: cannot borrow data in an `Rc` as mutable\n+  --> $DIR/borrowck-borrow-overloaded-auto-deref.rs:88:5\n    |\n LL |     x.y_mut()\n    |     ^ cannot borrow as mutable\n+   |\n+   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::rc::Rc<Point>`\n \n-error[E0596]: cannot borrow data in a `&` reference as mutable\n-  --> $DIR/borrowck-borrow-overloaded-auto-deref.rs:103:6\n+error[E0596]: cannot borrow data in an `Rc` as mutable\n+  --> $DIR/borrowck-borrow-overloaded-auto-deref.rs:92:6\n    |\n LL |     *x.y_mut() = 3;\n    |      ^ cannot borrow as mutable\n+   |\n+   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::rc::Rc<Point>`\n \n-error[E0596]: cannot borrow data in a `&` reference as mutable\n-  --> $DIR/borrowck-borrow-overloaded-auto-deref.rs:107:6\n+error[E0596]: cannot borrow data in an `Rc` as mutable\n+  --> $DIR/borrowck-borrow-overloaded-auto-deref.rs:96:6\n    |\n LL |     *x.y_mut() = 3;\n    |      ^ cannot borrow as mutable\n+   |\n+   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::rc::Rc<Point>`\n \n-error[E0596]: cannot borrow data in a `&` reference as mutable\n-  --> $DIR/borrowck-borrow-overloaded-auto-deref.rs:111:6\n+error[E0596]: cannot borrow data in an `Rc` as mutable\n+  --> $DIR/borrowck-borrow-overloaded-auto-deref.rs:100:6\n    |\n LL |     *x.y_mut() = 3;\n    |      ^ cannot borrow as mutable\n+   |\n+   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::rc::Rc<Point>`\n \n error: aborting due to 14 previous errors\n "}, {"sha": "2b98a7b9483b2ce1dd507cbf728bb7761490f626", "filename": "src/test/ui/borrowck/borrowck-borrow-overloaded-deref.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ec30876f30082a7b32876bd78a8da01f11dcde1e/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrow-overloaded-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec30876f30082a7b32876bd78a8da01f11dcde1e/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrow-overloaded-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrow-overloaded-deref.rs?ref=ec30876f30082a7b32876bd78a8da01f11dcde1e", "patch": "@@ -2,18 +2,7 @@\n // Deref and not DerefMut is implemented.\n \n use std::ops::Deref;\n-\n-struct Rc<T> {\n-    value: *const T\n-}\n-\n-impl<T> Deref for Rc<T> {\n-    type Target = T;\n-\n-    fn deref<'a>(&'a self) -> &'a T {\n-        unsafe { &*self.value }\n-    }\n-}\n+use std::rc::Rc;\n \n fn deref_imm(x: Rc<isize>) {\n     let __isize = &*x;"}, {"sha": "8cacc29414d75459ada2fc0eb0e4f8f8fc7c42a2", "filename": "src/test/ui/borrowck/borrowck-borrow-overloaded-deref.stderr", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ec30876f30082a7b32876bd78a8da01f11dcde1e/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrow-overloaded-deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec30876f30082a7b32876bd78a8da01f11dcde1e/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrow-overloaded-deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrow-overloaded-deref.stderr?ref=ec30876f30082a7b32876bd78a8da01f11dcde1e", "patch": "@@ -1,44 +1,58 @@\n-error[E0596]: cannot borrow data in a `&` reference as mutable\n-  --> $DIR/borrowck-borrow-overloaded-deref.rs:23:19\n+error[E0596]: cannot borrow data in an `Rc` as mutable\n+  --> $DIR/borrowck-borrow-overloaded-deref.rs:12:19\n    |\n LL |     let __isize = &mut *x;\n    |                   ^^^^^^^ cannot borrow as mutable\n+   |\n+   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::rc::Rc<isize>`\n \n-error[E0596]: cannot borrow data in a `&` reference as mutable\n-  --> $DIR/borrowck-borrow-overloaded-deref.rs:27:19\n+error[E0596]: cannot borrow data in an `Rc` as mutable\n+  --> $DIR/borrowck-borrow-overloaded-deref.rs:16:19\n    |\n LL |     let __isize = &mut *x;\n    |                   ^^^^^^^ cannot borrow as mutable\n+   |\n+   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::rc::Rc<isize>`\n \n-error[E0596]: cannot borrow data in a `&` reference as mutable\n-  --> $DIR/borrowck-borrow-overloaded-deref.rs:35:5\n+error[E0596]: cannot borrow data in an `Rc` as mutable\n+  --> $DIR/borrowck-borrow-overloaded-deref.rs:24:5\n    |\n LL |     &mut **x\n    |     ^^^^^^^^ cannot borrow as mutable\n+   |\n+   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::rc::Rc<isize>`\n \n-error[E0596]: cannot borrow data in a `&` reference as mutable\n-  --> $DIR/borrowck-borrow-overloaded-deref.rs:39:5\n+error[E0596]: cannot borrow data in an `Rc` as mutable\n+  --> $DIR/borrowck-borrow-overloaded-deref.rs:28:5\n    |\n LL |     &mut **x\n    |     ^^^^^^^^ cannot borrow as mutable\n+   |\n+   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::rc::Rc<isize>`\n \n-error[E0594]: cannot assign to data in a `&` reference\n-  --> $DIR/borrowck-borrow-overloaded-deref.rs:43:5\n+error[E0594]: cannot assign to data in an `Rc`\n+  --> $DIR/borrowck-borrow-overloaded-deref.rs:32:5\n    |\n LL |     *x = 3;\n    |     ^^^^^^ cannot assign\n+   |\n+   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::rc::Rc<isize>`\n \n-error[E0594]: cannot assign to data in a `&` reference\n-  --> $DIR/borrowck-borrow-overloaded-deref.rs:47:5\n+error[E0594]: cannot assign to data in an `Rc`\n+  --> $DIR/borrowck-borrow-overloaded-deref.rs:36:5\n    |\n LL |     **x = 3;\n    |     ^^^^^^^ cannot assign\n+   |\n+   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::rc::Rc<isize>`\n \n-error[E0594]: cannot assign to data in a `&` reference\n-  --> $DIR/borrowck-borrow-overloaded-deref.rs:51:5\n+error[E0594]: cannot assign to data in an `Rc`\n+  --> $DIR/borrowck-borrow-overloaded-deref.rs:40:5\n    |\n LL |     **x = 3;\n    |     ^^^^^^^ cannot assign\n+   |\n+   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::rc::Rc<isize>`\n \n error: aborting due to 7 previous errors\n "}, {"sha": "8adafaa8e938c0503d4cc6b8eb04b4160ee30770", "filename": "src/test/ui/borrowck/borrowck-overloaded-index-ref-index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec30876f30082a7b32876bd78a8da01f11dcde1e/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-overloaded-index-ref-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec30876f30082a7b32876bd78a8da01f11dcde1e/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-overloaded-index-ref-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-overloaded-index-ref-index.rs?ref=ec30876f30082a7b32876bd78a8da01f11dcde1e", "patch": "@@ -54,6 +54,6 @@ fn main() {\n         x: 1,\n     };\n     s[2] = 20;\n-    //~^ ERROR cannot assign to data in a `&` reference\n+    //~^ ERROR cannot assign to data in an index of `Bar`\n     drop(rs);\n }"}, {"sha": "84fe17d85448e72e8cd07ca372d85dd133b4020c", "filename": "src/test/ui/borrowck/borrowck-overloaded-index-ref-index.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec30876f30082a7b32876bd78a8da01f11dcde1e/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-overloaded-index-ref-index.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec30876f30082a7b32876bd78a8da01f11dcde1e/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-overloaded-index-ref-index.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-overloaded-index-ref-index.stderr?ref=ec30876f30082a7b32876bd78a8da01f11dcde1e", "patch": "@@ -21,11 +21,13 @@ LL |     f[&s] = 10;\n LL |     drop(rs);\n    |          -- mutable borrow later used here\n \n-error[E0594]: cannot assign to data in a `&` reference\n+error[E0594]: cannot assign to data in an index of `Bar`\n   --> $DIR/borrowck-overloaded-index-ref-index.rs:56:5\n    |\n LL |     s[2] = 20;\n    |     ^^^^^^^^^ cannot assign\n+   |\n+   = help: trait `IndexMut` is required to modify indexed content, but it is not implemented for `Bar`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "89391f4099a21e5f626869042875feccbfbd93f9", "filename": "src/test/ui/borrowck/index-mut-help-with-impl.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec30876f30082a7b32876bd78a8da01f11dcde1e/src%2Ftest%2Fui%2Fborrowck%2Findex-mut-help-with-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec30876f30082a7b32876bd78a8da01f11dcde1e/src%2Ftest%2Fui%2Fborrowck%2Findex-mut-help-with-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Findex-mut-help-with-impl.stderr?ref=ec30876f30082a7b32876bd78a8da01f11dcde1e", "patch": "@@ -3,8 +3,6 @@ error[E0596]: cannot borrow data in a `&` reference as mutable\n    |\n LL |     Index::index(&v, 1..2).make_ascii_uppercase();\n    |     ^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n-   |\n-   = help: trait `IndexMut` is required to modify indexed content\n \n error: aborting due to previous error\n "}, {"sha": "47f2171f88c86e1b7aab8ef87a3a362f6d981965", "filename": "src/test/ui/borrowck/index-mut-help.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec30876f30082a7b32876bd78a8da01f11dcde1e/src%2Ftest%2Fui%2Fborrowck%2Findex-mut-help.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec30876f30082a7b32876bd78a8da01f11dcde1e/src%2Ftest%2Fui%2Fborrowck%2Findex-mut-help.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Findex-mut-help.stderr?ref=ec30876f30082a7b32876bd78a8da01f11dcde1e", "patch": "@@ -1,18 +1,20 @@\n-error[E0596]: cannot borrow data in a `&` reference as mutable\n+error[E0596]: cannot borrow data in an index of `std::collections::HashMap<&str, std::string::String>` as mutable\n   --> $DIR/index-mut-help.rs:11:5\n    |\n LL |     map[\"peter\"].clear();\n    |     ^^^^^^^^^^^^ cannot borrow as mutable\n    |\n    = help: trait `IndexMut` is required to modify indexed content, but it is not implemented for `std::collections::HashMap<&str, std::string::String>`\n \n-error[E0594]: cannot assign to data in a `&` reference\n+error[E0594]: cannot assign to data in an index of `std::collections::HashMap<&str, std::string::String>`\n   --> $DIR/index-mut-help.rs:12:5\n    |\n LL |     map[\"peter\"] = \"0\".to_string();\n    |     ^^^^^^^^^^^^ cannot assign\n+   |\n+   = help: trait `IndexMut` is required to modify indexed content, but it is not implemented for `std::collections::HashMap<&str, std::string::String>`\n \n-error[E0596]: cannot borrow data in a `&` reference as mutable\n+error[E0596]: cannot borrow data in an index of `std::collections::HashMap<&str, std::string::String>` as mutable\n   --> $DIR/index-mut-help.rs:13:13\n    |\n LL |     let _ = &mut map[\"peter\"];"}, {"sha": "39631912c00e721827420060ce665a2ad62cfbcd", "filename": "src/test/ui/issues/issue-41726.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec30876f30082a7b32876bd78a8da01f11dcde1e/src%2Ftest%2Fui%2Fissues%2Fissue-41726.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec30876f30082a7b32876bd78a8da01f11dcde1e/src%2Ftest%2Fui%2Fissues%2Fissue-41726.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-41726.rs?ref=ec30876f30082a7b32876bd78a8da01f11dcde1e", "patch": "@@ -2,6 +2,6 @@ use std::collections::HashMap;\n fn main() {\n     let things: HashMap<String, Vec<String>> = HashMap::new();\n     for src in things.keys() {\n-        things[src.as_str()].sort(); //~ ERROR cannot borrow data in a `&` reference as mutable\n+        things[src.as_str()].sort(); //~ ERROR cannot borrow data in an index of\n     }\n }"}, {"sha": "aa7f23511dd8270540eb783323f9b2844260d8ae", "filename": "src/test/ui/issues/issue-41726.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec30876f30082a7b32876bd78a8da01f11dcde1e/src%2Ftest%2Fui%2Fissues%2Fissue-41726.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec30876f30082a7b32876bd78a8da01f11dcde1e/src%2Ftest%2Fui%2Fissues%2Fissue-41726.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-41726.stderr?ref=ec30876f30082a7b32876bd78a8da01f11dcde1e", "patch": "@@ -1,4 +1,4 @@\n-error[E0596]: cannot borrow data in a `&` reference as mutable\n+error[E0596]: cannot borrow data in an index of `std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>` as mutable\n   --> $DIR/issue-41726.rs:5:9\n    |\n LL |         things[src.as_str()].sort();"}]}