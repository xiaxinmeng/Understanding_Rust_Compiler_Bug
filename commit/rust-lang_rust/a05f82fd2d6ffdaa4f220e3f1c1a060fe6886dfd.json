{"sha": "a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwNWY4MmZkMmQ2ZmZkYWE0ZjIyMGUzZjFjMWEwNjBmZTY4ODZkZmQ=", "commit": {"author": {"name": "ashtneoi", "email": "ashtneoi@gmail.com", "date": "2018-08-07T08:02:39Z"}, "committer": {"name": "ashtneoi", "email": "ashtneoi@gmail.com", "date": "2018-08-15T22:14:21Z"}, "message": "Suggest match ergonomics, not `ref`/`ref mut`", "tree": {"sha": "8f163a1f308af344bb04e8820e4cb7143388b711", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f163a1f308af344bb04e8820e4cb7143388b711"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd", "html_url": "https://github.com/rust-lang/rust/commit/a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd/comments", "author": {"login": "ashtneoi", "id": 33603534, "node_id": "MDQ6VXNlcjMzNjAzNTM0", "avatar_url": "https://avatars.githubusercontent.com/u/33603534?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ashtneoi", "html_url": "https://github.com/ashtneoi", "followers_url": "https://api.github.com/users/ashtneoi/followers", "following_url": "https://api.github.com/users/ashtneoi/following{/other_user}", "gists_url": "https://api.github.com/users/ashtneoi/gists{/gist_id}", "starred_url": "https://api.github.com/users/ashtneoi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ashtneoi/subscriptions", "organizations_url": "https://api.github.com/users/ashtneoi/orgs", "repos_url": "https://api.github.com/users/ashtneoi/repos", "events_url": "https://api.github.com/users/ashtneoi/events{/privacy}", "received_events_url": "https://api.github.com/users/ashtneoi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ashtneoi", "id": 33603534, "node_id": "MDQ6VXNlcjMzNjAzNTM0", "avatar_url": "https://avatars.githubusercontent.com/u/33603534?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ashtneoi", "html_url": "https://github.com/ashtneoi", "followers_url": "https://api.github.com/users/ashtneoi/followers", "following_url": "https://api.github.com/users/ashtneoi/following{/other_user}", "gists_url": "https://api.github.com/users/ashtneoi/gists{/gist_id}", "starred_url": "https://api.github.com/users/ashtneoi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ashtneoi/subscriptions", "organizations_url": "https://api.github.com/users/ashtneoi/orgs", "repos_url": "https://api.github.com/users/ashtneoi/repos", "events_url": "https://api.github.com/users/ashtneoi/events{/privacy}", "received_events_url": "https://api.github.com/users/ashtneoi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b1013329789e1902577af6bda220dc5a8ac7f37", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b1013329789e1902577af6bda220dc5a8ac7f37", "html_url": "https://github.com/rust-lang/rust/commit/7b1013329789e1902577af6bda220dc5a8ac7f37"}], "stats": {"total": 1152, "additions": 1055, "deletions": 97}, "files": [{"sha": "8ceff303774b596a265af6a1dfac05a09589914c", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd", "patch": "@@ -523,6 +523,8 @@ pub struct VarBindingForm<'tcx> {\n     /// (b) it gives a way to separate this case from the remaining cases\n     ///     for diagnostics.\n     pub opt_match_place: Option<(Option<Place<'tcx>>, Span)>,\n+    /// Span of the pattern in which this variable was bound.\n+    pub pat_span: Span,\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n@@ -540,7 +542,8 @@ CloneTypeFoldableAndLiftImpls! { BindingForm<'tcx>, }\n impl_stable_hash_for!(struct self::VarBindingForm<'tcx> {\n     binding_mode,\n     opt_ty_info,\n-    opt_match_place\n+    opt_match_place,\n+    pat_span\n });\n \n mod binding_form_impl {\n@@ -710,6 +713,7 @@ impl<'tcx> LocalDecl<'tcx> {\n                 binding_mode: ty::BindingMode::BindByValue(_),\n                 opt_ty_info: _,\n                 opt_match_place: _,\n+                pat_span: _,\n             }))) => true,\n \n             // FIXME: might be able to thread the distinction between\n@@ -729,6 +733,7 @@ impl<'tcx> LocalDecl<'tcx> {\n                 binding_mode: ty::BindingMode::BindByValue(_),\n                 opt_ty_info: _,\n                 opt_match_place: _,\n+                pat_span: _,\n             }))) => true,\n \n             Some(ClearCrossCrate::Set(BindingForm::ImplicitSelf)) => true,"}, {"sha": "5b08400eb112d05ddc56fe37aca367d0eb61391c", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd", "patch": "@@ -1235,7 +1235,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     ty::BindByReference(..) => {\n                         let let_span = self.tcx.hir.span(node_id);\n                         let suggestion = suggest_ref_mut(self.tcx, let_span);\n-                        if let Some((let_span, replace_str)) = suggestion {\n+                        if let Some(replace_str) = suggestion {\n                             db.span_suggestion(\n                                 let_span,\n                                 \"use a mutable reference instead\","}, {"sha": "b89a8fa88b3e6c052534f5a3c40ab2f8bf4602b8", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 99, "deletions": 88, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::hir;\n+use core::unicode::property::Pattern_White_Space;\n use rustc::mir::*;\n use rustc::ty;\n use rustc_errors::DiagnosticBuilder;\n@@ -36,25 +36,27 @@ use util::borrowck_errors::{BorrowckErrors, Origin};\n // let (&x, &y) = (&String::new(), &String::new());\n #[derive(Debug)]\n enum GroupedMoveError<'tcx> {\n-    // Match place can't be moved from\n+    // Place expression can't be moved from,\n     // e.g. match x[0] { s => (), } where x: &[String]\n-    MovesFromMatchPlace {\n+    MovesFromPlace {\n         original_path: Place<'tcx>,\n         span: Span,\n         move_from: Place<'tcx>,\n         kind: IllegalMoveOriginKind<'tcx>,\n         binds_to: Vec<Local>,\n     },\n-    // Part of a pattern can't be moved from,\n+    // Part of a value expression can't be moved from,\n     // e.g. match &String::new() { &x => (), }\n-    MovesFromPattern {\n+    MovesFromValue {\n         original_path: Place<'tcx>,\n         span: Span,\n         move_from: MovePathIndex,\n         kind: IllegalMoveOriginKind<'tcx>,\n         binds_to: Vec<Local>,\n     },\n     // Everything that isn't from pattern matching.\n+    // FIXME(ashtneoi): I think this is only for moves into temporaries, as\n+    // when returning a value. Clarification needed.\n     OtherIllegalMove {\n         original_path: Place<'tcx>,\n         span: Span,\n@@ -119,6 +121,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                         opt_match_place: Some((ref opt_match_place, match_span)),\n                         binding_mode: _,\n                         opt_ty_info: _,\n+                        pat_span: _,\n                     }))) = local_decl.is_user_variable\n                     {\n                         self.append_binding_error(\n@@ -166,7 +169,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             // Error with the match place\n             LookupResult::Parent(_) => {\n                 for ge in &mut *grouped_errors {\n-                    if let GroupedMoveError::MovesFromMatchPlace { span, binds_to, .. } = ge {\n+                    if let GroupedMoveError::MovesFromPlace { span, binds_to, .. } = ge {\n                         if match_span == *span {\n                             debug!(\"appending local({:?}) to list\", bind_to);\n                             if !binds_to.is_empty() {\n@@ -184,7 +187,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 } else {\n                     (vec![bind_to], match_span)\n                 };\n-                grouped_errors.push(GroupedMoveError::MovesFromMatchPlace {\n+                grouped_errors.push(GroupedMoveError::MovesFromPlace {\n                     span,\n                     move_from: match_place.clone(),\n                     original_path,\n@@ -200,7 +203,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     _ => unreachable!(\"Probably not unreachable...\"),\n                 };\n                 for ge in &mut *grouped_errors {\n-                    if let GroupedMoveError::MovesFromPattern {\n+                    if let GroupedMoveError::MovesFromValue {\n                         span,\n                         move_from: other_mpi,\n                         binds_to,\n@@ -215,7 +218,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n                 debug!(\"found a new move error location\");\n-                grouped_errors.push(GroupedMoveError::MovesFromPattern {\n+                grouped_errors.push(GroupedMoveError::MovesFromValue {\n                     span: match_span,\n                     move_from: mpi,\n                     original_path,\n@@ -230,13 +233,13 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n         let (mut err, err_span) = {\n             let (span, original_path, kind): (Span, &Place<'tcx>, &IllegalMoveOriginKind) =\n                 match error {\n-                    GroupedMoveError::MovesFromMatchPlace {\n+                    GroupedMoveError::MovesFromPlace {\n                         span,\n                         ref original_path,\n                         ref kind,\n                         ..\n                     } |\n-                    GroupedMoveError::MovesFromPattern { span, ref original_path, ref kind, .. } |\n+                    GroupedMoveError::MovesFromValue { span, ref original_path, ref kind, .. } |\n                     GroupedMoveError::OtherIllegalMove { span, ref original_path, ref kind } => {\n                         (span, original_path, kind)\n                     },\n@@ -331,111 +334,119 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n         err: &mut DiagnosticBuilder<'a>,\n         span: Span,\n     ) {\n+        let snippet = self.tcx.sess.codemap().span_to_snippet(span).unwrap();\n         match error {\n-            GroupedMoveError::MovesFromMatchPlace {\n+            GroupedMoveError::MovesFromPlace {\n                 mut binds_to,\n                 move_from,\n                 ..\n             } => {\n-                // Ok to suggest a borrow, since the target can't be moved from\n-                // anyway.\n-                if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n-                    match move_from {\n-                        Place::Projection(ref proj)\n-                            if self.suitable_to_remove_deref(proj, &snippet) =>\n-                        {\n+                let mut suggest_change_head_expr = false;\n+                match move_from {\n+                    Place::Projection(box PlaceProjection {\n+                        elem: ProjectionElem::Deref,\n+                        ..\n+                    }) => {\n+                        // This is false for (e.g.) index expressions `a[b]`,\n+                        // which roughly desugar to `*Index::index(&a, b)` or\n+                        // `*IndexMut::index_mut(&mut a, b)`.\n+                        if snippet.starts_with('*') {\n                             err.span_suggestion(\n                                 span,\n                                 \"consider removing this dereference operator\",\n                                 (&snippet[1..]).to_owned(),\n                             );\n-                        }\n-                        _ => {\n-                            err.span_suggestion(\n-                                span,\n-                                \"consider using a reference instead\",\n-                                format!(\"&{}\", snippet),\n-                            );\n+                            suggest_change_head_expr = true;\n                         }\n                     }\n-\n-                    binds_to.sort();\n-                    binds_to.dedup();\n-                    for local in binds_to {\n-                        let bind_to = &self.mir.local_decls[local];\n-                        let binding_span = bind_to.source_info.span;\n-                        err.span_label(\n-                            binding_span,\n-                            format!(\n-                                \"move occurs because {} has type `{}`, \\\n-                                 which does not implement the `Copy` trait\",\n-                                bind_to.name.unwrap(),\n-                                bind_to.ty\n-                            ),\n+                    _ => {\n+                        err.span_suggestion(\n+                            span,\n+                            \"consider using a reference instead\",\n+                            format!(\"&{}\", snippet),\n                         );\n+                        suggest_change_head_expr = true;\n                     }\n                 }\n+                binds_to.sort();\n+                binds_to.dedup();\n+                if !suggest_change_head_expr {\n+                    self.add_move_error_suggestions(err, &binds_to);\n+                }\n+                self.add_move_error_labels(err, &binds_to);\n             }\n-            GroupedMoveError::MovesFromPattern { mut binds_to, .. } => {\n-                // Suggest ref, since there might be a move in\n-                // another match arm\n+            GroupedMoveError::MovesFromValue { mut binds_to, .. } => {\n                 binds_to.sort();\n                 binds_to.dedup();\n-                let mut multipart_suggestion = Vec::with_capacity(binds_to.len());\n-                for (j, local) in binds_to.into_iter().enumerate() {\n-                    let bind_to = &self.mir.local_decls[local];\n-                    let binding_span = bind_to.source_info.span;\n+                self.add_move_error_suggestions(err, &binds_to);\n+                self.add_move_error_labels(err, &binds_to);\n+            }\n+            // No binding. Nothing to suggest.\n+            GroupedMoveError::OtherIllegalMove { .. } => (),\n+        }\n+    }\n \n-                    // Suggest ref mut when the user has already written mut.\n-                    let ref_kind = match bind_to.mutability {\n-                        Mutability::Not => \"ref\",\n-                        Mutability::Mut => \"ref mut\",\n-                    };\n-                    if j == 0 {\n-                        err.span_label(binding_span, format!(\"data moved here\"));\n+    fn add_move_error_suggestions(\n+        &self,\n+        err: &mut DiagnosticBuilder<'a>,\n+        binds_to: &[Local],\n+    ) {\n+        for local in binds_to {\n+            let bind_to = &self.mir.local_decls[*local];\n+            if let Some(\n+                ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+                    pat_span,\n+                    ..\n+                }))\n+            ) = bind_to.is_user_variable {\n+                let pat_snippet = self\n+                    .tcx.sess.codemap()\n+                    .span_to_snippet(pat_span)\n+                    .unwrap();\n+                if pat_snippet.starts_with('&') {\n+                    let pat_snippet = &pat_snippet[1..];\n+                    let suggestion;\n+                    if pat_snippet.starts_with(\"mut\")\n+                        && pat_snippet[\"mut\".len()..].starts_with(Pattern_White_Space)\n+                    {\n+                        suggestion = pat_snippet[\"mut\".len()..].trim_left();\n                     } else {\n-                        err.span_label(binding_span, format!(\"... and here\"));\n-                    }\n-                    match bind_to.name {\n-                        Some(name) => {\n-                            multipart_suggestion.push((binding_span,\n-                                                       format!(\"{} {}\", ref_kind, name)));\n-                        }\n-                        None => {\n-                            err.span_label(\n-                                span,\n-                                format!(\"Local {:?} is not suitable for ref\", bind_to),\n-                            );\n-                        }\n+                        suggestion = pat_snippet;\n                     }\n+                    err.span_suggestion(\n+                        pat_span,\n+                        \"consider removing this borrow operator\",\n+                        suggestion.to_owned(),\n+                    );\n                 }\n-                err.multipart_suggestion(\"to prevent move, use ref or ref mut\",\n-                                         multipart_suggestion);\n             }\n-            // Nothing to suggest.\n-            GroupedMoveError::OtherIllegalMove { .. } => (),\n         }\n     }\n \n-    fn suitable_to_remove_deref(&self, proj: &PlaceProjection<'tcx>, snippet: &str) -> bool {\n-        let is_shared_ref = |ty: ty::Ty| match ty.sty {\n-            ty::TypeVariants::TyRef(.., hir::Mutability::MutImmutable) => true,\n-            _ => false,\n-        };\n+    fn add_move_error_labels(\n+        &self,\n+        err: &mut DiagnosticBuilder<'a>,\n+        binds_to: &[Local],\n+    ) {\n+        for (j, local) in binds_to.into_iter().enumerate() {\n+            let bind_to = &self.mir.local_decls[*local];\n+            let binding_span = bind_to.source_info.span;\n \n-        proj.elem == ProjectionElem::Deref && snippet.starts_with('*') && match proj.base {\n-            Place::Local(local) => {\n-                let local_decl = &self.mir.local_decls[local];\n-                // If this is a temporary, then this could be from an\n-                // overloaded * operator.\n-                local_decl.is_user_variable.is_some() && is_shared_ref(local_decl.ty)\n+            if j == 0 {\n+                err.span_label(binding_span, format!(\"data moved here\"));\n+            } else {\n+                err.span_label(binding_span, format!(\"... and here\"));\n             }\n-            Place::Promoted(_) => true,\n-            Place::Static(ref st) => is_shared_ref(st.ty),\n-            Place::Projection(ref proj) => match proj.elem {\n-                ProjectionElem::Field(_, ty) => is_shared_ref(ty),\n-                _ => false,\n-            },\n+\n+            err.span_note(\n+                binding_span,\n+                &format!(\n+                    \"move occurs because {} has type `{}`, \\\n+                        which does not implement the `Copy` trait\",\n+                    bind_to.name.unwrap(),\n+                    bind_to.ty\n+                ),\n+            );\n         }\n     }\n }"}, {"sha": "f11135fc026f53acd940600a43d226a733416c30", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd", "patch": "@@ -329,7 +329,11 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     ClearCrossCrate::Set(mir::BindingForm::Var(mir::VarBindingForm {\n                         binding_mode: ty::BindingMode::BindByReference(_),\n                         ..\n-                    })) => suggest_ref_mut(self.tcx, local_decl.source_info.span),\n+                    })) => {\n+                        let pattern_span = local_decl.source_info.span;\n+                        suggest_ref_mut(self.tcx, pattern_span)\n+                            .map(|replacement| (pattern_span, replacement))\n+                    }\n \n                     //\n                     ClearCrossCrate::Set(mir::BindingForm::RefForGuard) => unreachable!(),"}, {"sha": "b317bb7cff0e3c9a6e0b720f0dd0b2a63e1123f9", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd", "patch": "@@ -357,7 +357,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let visibility_scope = visibility_scope.unwrap();\n             this.declare_binding(source_info, visibility_scope, mutability, name, mode,\n                                  num_patterns, var, ty, has_guard,\n-                                 opt_match_place.map(|(x, y)| (x.cloned(), y)));\n+                                 opt_match_place.map(|(x, y)| (x.cloned(), y)),\n+                                 patterns[0].span);\n         });\n         visibility_scope\n     }\n@@ -1182,7 +1183,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                        var_id: NodeId,\n                        var_ty: Ty<'tcx>,\n                        has_guard: ArmHasGuard,\n-                       opt_match_place: Option<(Option<Place<'tcx>>, Span)>)\n+                       opt_match_place: Option<(Option<Place<'tcx>>, Span)>,\n+                       pat_span: Span)\n     {\n         debug!(\"declare_binding(var_id={:?}, name={:?}, mode={:?}, var_ty={:?}, \\\n                 visibility_scope={:?}, source_info={:?})\",\n@@ -1208,6 +1210,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // Instead, just abandon providing diagnostic info.\n                 opt_ty_info: None,\n                 opt_match_place,\n+                pat_span,\n             }))),\n         };\n         let for_arm_body = self.local_decls.push(local.clone());"}, {"sha": "c0c431804d8c1ea52fcf1716084e06c761586e55", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd", "patch": "@@ -763,6 +763,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                     binding_mode,\n                                     opt_ty_info,\n                                     opt_match_place: Some((Some(place.clone()), span)),\n+                                    pat_span: span,\n                                 })))\n                             };\n                         self.var_indices.insert(var, LocalsForNode::One(local));"}, {"sha": "bda80ff562c75ede8ef6cbacc79b5982d36de066", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd", "patch": "@@ -35,6 +35,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(try_trait)]\n #![feature(unicode_internals)]\n #![feature(step_trait)]\n+#![feature(slice_concat_ext)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "fe6fefe89fd66b59cab4e0e5b4887eb165fbc1ce", "filename": "src/librustc_mir/util/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd/src%2Flibrustc_mir%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd/src%2Flibrustc_mir%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fmod.rs?ref=a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd", "patch": "@@ -31,14 +31,14 @@ pub use self::graphviz::write_node_label as write_graphviz_node_label;\n /// If possible, suggest replacing `ref` with `ref mut`.\n pub fn suggest_ref_mut<'cx, 'gcx, 'tcx>(\n     tcx: ty::TyCtxt<'cx, 'gcx, 'tcx>,\n-    pattern_span: Span,\n-) -> Option<(Span, String)> {\n-    let hi_src = tcx.sess.codemap().span_to_snippet(pattern_span).unwrap();\n+    binding_span: Span,\n+) -> Option<(String)> {\n+    let hi_src = tcx.sess.codemap().span_to_snippet(binding_span).unwrap();\n     if hi_src.starts_with(\"ref\")\n         && hi_src[\"ref\".len()..].starts_with(Pattern_White_Space)\n     {\n         let replacement = format!(\"ref mut{}\", &hi_src[\"ref\".len()..]);\n-        Some((pattern_span, replacement))\n+        Some(replacement)\n     } else {\n         None\n     }"}, {"sha": "cdf5503f2a9516452a7b84be0dedd78d279d20e4", "filename": "src/test/ui/suggestions/dont-suggest-ref.rs", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref.rs?ref=a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd", "patch": "@@ -0,0 +1,267 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(nll)]\n+\n+enum Either {\n+    One(X),\n+    Two(X),\n+}\n+\n+struct X(Y);\n+\n+struct Y;\n+\n+pub fn main() {\n+    let e = Either::One(X(Y));\n+    let mut em = Either::One(X(Y));\n+\n+    let r = &e;\n+    let rm = &mut Either::One(X(Y));\n+\n+    let x = X(Y);\n+    let mut xm = X(Y);\n+\n+    let s = &x;\n+    let sm = &mut X(Y);\n+\n+    // --------\n+\n+    let X(_t) = *s;\n+    //~^ ERROR cannot move\n+    //~| HELP consider removing this dereference operator\n+    //~| SUGGESTION s\n+    if let Either::One(_t) = *r { }\n+    //~^ ERROR cannot move\n+    //~| HELP consider removing this dereference operator\n+    //~| SUGGESTION r\n+    while let Either::One(_t) = *r { }\n+    //~^ ERROR cannot move\n+    //~| HELP consider removing this dereference operator\n+    //~| SUGGESTION r\n+    match *r {\n+        //~^ ERROR cannot move\n+        //~| HELP consider removing this dereference operator\n+        //~| SUGGESTION r\n+        Either::One(_t)\n+        | Either::Two(_t) => (),\n+    }\n+    match *r {\n+        //~^ ERROR cannot move\n+        //~| HELP consider removing this dereference operator\n+        //~| SUGGESTION r\n+        // (invalid but acceptable)\n+        Either::One(_t) => (),\n+        Either::Two(ref _t) => (),\n+    }\n+\n+    let X(_t) = *sm;\n+    //~^ ERROR cannot move\n+    //~| HELP consider removing this dereference operator\n+    //~| SUGGESTION sm\n+    if let Either::One(_t) = *rm { }\n+    //~^ ERROR cannot move\n+    //~| HELP consider removing this dereference operator\n+    //~| SUGGESTION rm\n+    while let Either::One(_t) = *rm { }\n+    //~^ ERROR cannot move\n+    //~| HELP consider removing this dereference operator\n+    //~| SUGGESTION rm\n+    match *rm {\n+        //~^ ERROR cannot move\n+        //~| HELP consider removing this dereference operator\n+        //~| SUGGESTION rm\n+        Either::One(_t)\n+        | Either::Two(_t) => (),\n+    }\n+    match *rm {\n+        //~^ ERROR cannot move\n+        //~| HELP consider removing this dereference operator\n+        //~| SUGGESTION rm\n+        // (invalid but acceptable)\n+        Either::One(_t) => (),\n+        Either::Two(ref _t) => (),\n+    }\n+    match *rm {\n+        //~^ ERROR cannot move\n+        //~| HELP consider removing this dereference operator\n+        //~| SUGGESTION rm\n+        // (invalid but acceptable)\n+        Either::One(_t) => (),\n+        Either::Two(ref mut _t) => (),\n+    }\n+\n+    // --------\n+\n+    let &X(_t) = s;\n+    //~^ ERROR cannot move\n+    //~| HELP consider removing this borrow operator\n+    //~| SUGGESTION X(_t)\n+    if let &Either::One(_t) = r { }\n+    //~^ ERROR cannot move\n+    //~| HELP consider removing this borrow operator\n+    //~| SUGGESTION Either::One(_t)\n+    while let &Either::One(_t) = r { }\n+    //~^ ERROR cannot move\n+    //~| HELP consider removing this borrow operator\n+    //~| SUGGESTION Either::One(_t)\n+    match r {\n+        //~^ ERROR cannot move\n+        &Either::One(_t)\n+        //~^ HELP consider removing this borrow operator\n+        //~| SUGGESTION Either::One(_t)\n+        | &Either::Two(_t) => (),\n+        // TODO: would really like a suggestion here too\n+    }\n+    match r {\n+        //~^ ERROR cannot move\n+        &Either::One(_t) => (),\n+        //~^ HELP consider removing this borrow operator\n+        //~| SUGGESTION Either::One(_t)\n+        &Either::Two(ref _t) => (),\n+    }\n+    match r {\n+        //~^ ERROR cannot move\n+        &Either::One(_t) => (),\n+        //~^ HELP consider removing this borrow operator\n+        //~| SUGGESTION Either::One(_t)\n+        Either::Two(_t) => (),\n+    }\n+    fn f1(&X(_t): &X) { }\n+    //~^ ERROR cannot move\n+    //~| HELP consider removing this borrow operator\n+    //~| SUGGESTION X(_t)\n+\n+    let &mut X(_t) = sm;\n+    //~^ ERROR cannot move\n+    //~| HELP consider removing this borrow operator\n+    //~| SUGGESTION X(_t)\n+    if let &mut Either::One(_t) = rm { }\n+    //~^ ERROR cannot move\n+    //~| HELP consider removing this borrow operator\n+    //~| SUGGESTION Either::One(_t)\n+    while let &mut Either::One(_t) = rm { }\n+    //~^ ERROR cannot move\n+    //~| HELP consider removing this borrow operator\n+    //~| SUGGESTION Either::One(_t)\n+    match rm {\n+        //~^ ERROR cannot move\n+        &mut Either::One(_t) => (),\n+        //~^ HELP consider removing this borrow operator\n+        //~| SUGGESTION Either::One(_t)\n+        &mut Either::Two(_t) => (),\n+        //~^ HELP consider removing this borrow operator\n+        //~| SUGGESTION Either::Two(_t)\n+    }\n+    match rm {\n+        //~^ ERROR cannot move\n+        &mut Either::One(_t) => (),\n+        //~^ HELP consider removing this borrow operator\n+        //~| SUGGESTION Either::One(_t)\n+        &mut Either::Two(ref _t) => (),\n+    }\n+    match rm {\n+        //~^ ERROR cannot move\n+        &mut Either::One(_t) => (),\n+        //~^ HELP consider removing this borrow operator\n+        //~| SUGGESTION Either::One(_t)\n+        &mut Either::Two(ref mut _t) => (),\n+    }\n+    match rm {\n+        //~^ ERROR cannot move\n+        &mut Either::One(_t) => (),\n+        //~^ HELP consider removing this borrow operator\n+        //~| SUGGESTION Either::One(_t)\n+        Either::Two(_t) => (),\n+    }\n+    fn f2(&mut X(_t): &mut X) { }\n+    //~^ ERROR cannot move\n+    //~| HELP consider removing this borrow operator\n+    //~| SUGGESTION X(_t)\n+\n+    // --------\n+\n+    let &X(_t) = &x;\n+    //~^ ERROR cannot move\n+    //~| HELP consider removing this borrow operator\n+    //~| SUGGESTION X(_t)\n+    if let &Either::One(_t) = &e { }\n+    //~^ ERROR cannot move\n+    //~| HELP consider removing this borrow operator\n+    //~| SUGGESTION Either::One(_t)\n+    while let &Either::One(_t) = &e { }\n+    //~^ ERROR cannot move\n+    //~| HELP consider removing this borrow operator\n+    //~| SUGGESTION Either::One(_t)\n+    match &e {\n+        //~^ ERROR cannot move\n+        &Either::One(_t)\n+        //~^ HELP consider removing this borrow operator\n+        //~| SUGGESTION Either::One(_t)\n+        | &Either::Two(_t) => (),\n+        // TODO: would really like a suggestion here too\n+    }\n+    match &e {\n+        //~^ ERROR cannot move\n+        &Either::One(_t) => (),\n+        //~^ HELP consider removing this borrow operator\n+        //~| SUGGESTION Either::One(_t)\n+        &Either::Two(ref _t) => (),\n+    }\n+    match &e {\n+        //~^ ERROR cannot move\n+        &Either::One(_t) => (),\n+        //~^ HELP consider removing this borrow operator\n+        //~| SUGGESTION Either::One(_t)\n+        Either::Two(_t) => (),\n+    }\n+\n+    let &mut X(_t) = &mut xm;\n+    //~^ ERROR cannot move\n+    //~| HELP consider removing this borrow operator\n+    //~| SUGGESTION X(_t)\n+    if let &mut Either::One(_t) = &mut em { }\n+    //~^ ERROR cannot move\n+    //~| HELP consider removing this borrow operator\n+    //~| SUGGESTION Either::One(_t)\n+    while let &mut Either::One(_t) = &mut em { }\n+    //~^ ERROR cannot move\n+    //~| HELP consider removing this borrow operator\n+    //~| SUGGESTION Either::One(_t)\n+    match &mut em {\n+        //~^ ERROR cannot move\n+        &mut Either::One(_t)\n+        //~^ HELP consider removing this borrow operator\n+        //~| SUGGESTION Either::One(_t)\n+        | &mut Either::Two(_t) => (),\n+        // TODO: would really like a suggestion here too\n+    }\n+    match &mut em {\n+        //~^ ERROR cannot move\n+        &mut Either::One(_t) => (),\n+        //~^ HELP consider removing this borrow operator\n+        //~| SUGGESTION Either::One(_t)\n+        &mut Either::Two(ref _t) => (),\n+    }\n+    match &mut em {\n+        //~^ ERROR cannot move\n+        &mut Either::One(_t) => (),\n+        //~^ HELP consider removing this borrow operator\n+        //~| SUGGESTION Either::One(_t)\n+        &mut Either::Two(ref mut _t) => (),\n+    }\n+    match &mut em {\n+        //~^ ERROR cannot move\n+        &mut Either::One(_t) => (),\n+        //~^ HELP consider removing this borrow operator\n+        //~| SUGGESTION Either::One(_t)\n+        Either::Two(_t) => (),\n+    }\n+}"}, {"sha": "682ba88f555655b2b680fbd5c83a316ae0a8c61b", "filename": "src/test/ui/suggestions/dont-suggest-ref.stderr", "status": "added", "additions": 666, "deletions": 0, "changes": 666, "blob_url": "https://github.com/rust-lang/rust/blob/a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref.stderr?ref=a05f82fd2d6ffdaa4f220e3f1c1a060fe6886dfd", "patch": "@@ -0,0 +1,666 @@\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:37:17\n+   |\n+LL |     let X(_t) = *s;\n+   |           --    ^^\n+   |           |     |\n+   |           |     cannot move out of borrowed content\n+   |           |     help: consider removing this dereference operator: `s`\n+   |           data moved here\n+   |\n+note: move occurs because _t has type `Y`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:37:11\n+   |\n+LL |     let X(_t) = *s;\n+   |           ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:41:30\n+   |\n+LL |     if let Either::One(_t) = *r { }\n+   |                        --    ^^\n+   |                        |     |\n+   |                        |     cannot move out of borrowed content\n+   |                        |     help: consider removing this dereference operator: `r`\n+   |                        data moved here\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:41:24\n+   |\n+LL |     if let Either::One(_t) = *r { }\n+   |                        ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:45:33\n+   |\n+LL |     while let Either::One(_t) = *r { }\n+   |                           --    ^^\n+   |                           |     |\n+   |                           |     cannot move out of borrowed content\n+   |                           |     help: consider removing this dereference operator: `r`\n+   |                           data moved here\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:45:27\n+   |\n+LL |     while let Either::One(_t) = *r { }\n+   |                           ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:49:11\n+   |\n+LL |     match *r {\n+   |           ^^\n+   |           |\n+   |           cannot move out of borrowed content\n+   |           help: consider removing this dereference operator: `r`\n+...\n+LL |         Either::One(_t)\n+   |                     -- data moved here\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:53:21\n+   |\n+LL |         Either::One(_t)\n+   |                     ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:56:11\n+   |\n+LL |     match *r {\n+   |           ^^\n+   |           |\n+   |           cannot move out of borrowed content\n+   |           help: consider removing this dereference operator: `r`\n+...\n+LL |         Either::One(_t) => (),\n+   |                     -- data moved here\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:61:21\n+   |\n+LL |         Either::One(_t) => (),\n+   |                     ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:65:17\n+   |\n+LL |     let X(_t) = *sm;\n+   |           --    ^^^\n+   |           |     |\n+   |           |     cannot move out of borrowed content\n+   |           |     help: consider removing this dereference operator: `sm`\n+   |           data moved here\n+   |\n+note: move occurs because _t has type `Y`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:65:11\n+   |\n+LL |     let X(_t) = *sm;\n+   |           ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:69:30\n+   |\n+LL |     if let Either::One(_t) = *rm { }\n+   |                        --    ^^^\n+   |                        |     |\n+   |                        |     cannot move out of borrowed content\n+   |                        |     help: consider removing this dereference operator: `rm`\n+   |                        data moved here\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:69:24\n+   |\n+LL |     if let Either::One(_t) = *rm { }\n+   |                        ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:73:33\n+   |\n+LL |     while let Either::One(_t) = *rm { }\n+   |                           --    ^^^\n+   |                           |     |\n+   |                           |     cannot move out of borrowed content\n+   |                           |     help: consider removing this dereference operator: `rm`\n+   |                           data moved here\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:73:27\n+   |\n+LL |     while let Either::One(_t) = *rm { }\n+   |                           ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:77:11\n+   |\n+LL |     match *rm {\n+   |           ^^^\n+   |           |\n+   |           cannot move out of borrowed content\n+   |           help: consider removing this dereference operator: `rm`\n+...\n+LL |         Either::One(_t)\n+   |                     -- data moved here\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:81:21\n+   |\n+LL |         Either::One(_t)\n+   |                     ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:84:11\n+   |\n+LL |     match *rm {\n+   |           ^^^\n+   |           |\n+   |           cannot move out of borrowed content\n+   |           help: consider removing this dereference operator: `rm`\n+...\n+LL |         Either::One(_t) => (),\n+   |                     -- data moved here\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:89:21\n+   |\n+LL |         Either::One(_t) => (),\n+   |                     ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:92:11\n+   |\n+LL |     match *rm {\n+   |           ^^^\n+   |           |\n+   |           cannot move out of borrowed content\n+   |           help: consider removing this dereference operator: `rm`\n+...\n+LL |         Either::One(_t) => (),\n+   |                     -- data moved here\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:97:21\n+   |\n+LL |         Either::One(_t) => (),\n+   |                     ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:103:18\n+   |\n+LL |     let &X(_t) = s;\n+   |         ------   ^ cannot move out of borrowed content\n+   |         |  |\n+   |         |  data moved here\n+   |         help: consider removing this borrow operator: `X(_t)`\n+   |\n+note: move occurs because _t has type `Y`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:103:12\n+   |\n+LL |     let &X(_t) = s;\n+   |            ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:107:31\n+   |\n+LL |     if let &Either::One(_t) = r { }\n+   |            ----------------   ^ cannot move out of borrowed content\n+   |            |            |\n+   |            |            data moved here\n+   |            help: consider removing this borrow operator: `Either::One(_t)`\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:107:25\n+   |\n+LL |     if let &Either::One(_t) = r { }\n+   |                         ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:111:34\n+   |\n+LL |     while let &Either::One(_t) = r { }\n+   |               ----------------   ^ cannot move out of borrowed content\n+   |               |            |\n+   |               |            data moved here\n+   |               help: consider removing this borrow operator: `Either::One(_t)`\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:111:28\n+   |\n+LL |     while let &Either::One(_t) = r { }\n+   |                            ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:115:11\n+   |\n+LL |     match r {\n+   |           ^ cannot move out of borrowed content\n+LL |         //~^ ERROR cannot move\n+LL |         &Either::One(_t)\n+   |         ----------------\n+   |         |            |\n+   |         |            data moved here\n+   |         help: consider removing this borrow operator: `Either::One(_t)`\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:117:22\n+   |\n+LL |         &Either::One(_t)\n+   |                      ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:123:11\n+   |\n+LL |     match r {\n+   |           ^ cannot move out of borrowed content\n+LL |         //~^ ERROR cannot move\n+LL |         &Either::One(_t) => (),\n+   |         ----------------\n+   |         |            |\n+   |         |            data moved here\n+   |         help: consider removing this borrow operator: `Either::One(_t)`\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:125:22\n+   |\n+LL |         &Either::One(_t) => (),\n+   |                      ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:130:11\n+   |\n+LL |     match r {\n+   |           ^ cannot move out of borrowed content\n+LL |         //~^ ERROR cannot move\n+LL |         &Either::One(_t) => (),\n+   |         ----------------\n+   |         |            |\n+   |         |            data moved here\n+   |         help: consider removing this borrow operator: `Either::One(_t)`\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:132:22\n+   |\n+LL |         &Either::One(_t) => (),\n+   |                      ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:142:22\n+   |\n+LL |     let &mut X(_t) = sm;\n+   |         ----------   ^^ cannot move out of borrowed content\n+   |         |      |\n+   |         |      data moved here\n+   |         help: consider removing this borrow operator: `X(_t)`\n+   |\n+note: move occurs because _t has type `Y`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:142:16\n+   |\n+LL |     let &mut X(_t) = sm;\n+   |                ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:146:35\n+   |\n+LL |     if let &mut Either::One(_t) = rm { }\n+   |            --------------------   ^^ cannot move out of borrowed content\n+   |            |                |\n+   |            |                data moved here\n+   |            help: consider removing this borrow operator: `Either::One(_t)`\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:146:29\n+   |\n+LL |     if let &mut Either::One(_t) = rm { }\n+   |                             ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:150:38\n+   |\n+LL |     while let &mut Either::One(_t) = rm { }\n+   |               --------------------   ^^ cannot move out of borrowed content\n+   |               |                |\n+   |               |                data moved here\n+   |               help: consider removing this borrow operator: `Either::One(_t)`\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:150:32\n+   |\n+LL |     while let &mut Either::One(_t) = rm { }\n+   |                                ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:154:11\n+   |\n+LL |     match rm {\n+   |           ^^ cannot move out of borrowed content\n+LL |         //~^ ERROR cannot move\n+LL |         &mut Either::One(_t) => (),\n+   |                          -- data moved here\n+...\n+LL |         &mut Either::Two(_t) => (),\n+   |                          -- ... and here\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:156:26\n+   |\n+LL |         &mut Either::One(_t) => (),\n+   |                          ^^\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:159:26\n+   |\n+LL |         &mut Either::Two(_t) => (),\n+   |                          ^^\n+help: consider removing this borrow operator\n+   |\n+LL |         Either::One(_t) => (),\n+   |         ^^^^^^^^^^^^^^^\n+help: consider removing this borrow operator\n+   |\n+LL |         Either::Two(_t) => (),\n+   |         ^^^^^^^^^^^^^^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:163:11\n+   |\n+LL |     match rm {\n+   |           ^^ cannot move out of borrowed content\n+LL |         //~^ ERROR cannot move\n+LL |         &mut Either::One(_t) => (),\n+   |         --------------------\n+   |         |                |\n+   |         |                data moved here\n+   |         help: consider removing this borrow operator: `Either::One(_t)`\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:165:26\n+   |\n+LL |         &mut Either::One(_t) => (),\n+   |                          ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:170:11\n+   |\n+LL |     match rm {\n+   |           ^^ cannot move out of borrowed content\n+LL |         //~^ ERROR cannot move\n+LL |         &mut Either::One(_t) => (),\n+   |         --------------------\n+   |         |                |\n+   |         |                data moved here\n+   |         help: consider removing this borrow operator: `Either::One(_t)`\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:172:26\n+   |\n+LL |         &mut Either::One(_t) => (),\n+   |                          ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:177:11\n+   |\n+LL |     match rm {\n+   |           ^^ cannot move out of borrowed content\n+LL |         //~^ ERROR cannot move\n+LL |         &mut Either::One(_t) => (),\n+   |         --------------------\n+   |         |                |\n+   |         |                data moved here\n+   |         help: consider removing this borrow operator: `Either::One(_t)`\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:179:26\n+   |\n+LL |         &mut Either::One(_t) => (),\n+   |                          ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:191:18\n+   |\n+LL |     let &X(_t) = &x;\n+   |         ------   ^^ cannot move out of borrowed content\n+   |         |  |\n+   |         |  data moved here\n+   |         help: consider removing this borrow operator: `X(_t)`\n+   |\n+note: move occurs because _t has type `Y`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:191:12\n+   |\n+LL |     let &X(_t) = &x;\n+   |            ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:195:31\n+   |\n+LL |     if let &Either::One(_t) = &e { }\n+   |            ----------------   ^^ cannot move out of borrowed content\n+   |            |            |\n+   |            |            data moved here\n+   |            help: consider removing this borrow operator: `Either::One(_t)`\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:195:25\n+   |\n+LL |     if let &Either::One(_t) = &e { }\n+   |                         ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:199:34\n+   |\n+LL |     while let &Either::One(_t) = &e { }\n+   |               ----------------   ^^ cannot move out of borrowed content\n+   |               |            |\n+   |               |            data moved here\n+   |               help: consider removing this borrow operator: `Either::One(_t)`\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:199:28\n+   |\n+LL |     while let &Either::One(_t) = &e { }\n+   |                            ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:203:11\n+   |\n+LL |     match &e {\n+   |           ^^ cannot move out of borrowed content\n+LL |         //~^ ERROR cannot move\n+LL |         &Either::One(_t)\n+   |         ----------------\n+   |         |            |\n+   |         |            data moved here\n+   |         help: consider removing this borrow operator: `Either::One(_t)`\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:205:22\n+   |\n+LL |         &Either::One(_t)\n+   |                      ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:211:11\n+   |\n+LL |     match &e {\n+   |           ^^ cannot move out of borrowed content\n+LL |         //~^ ERROR cannot move\n+LL |         &Either::One(_t) => (),\n+   |         ----------------\n+   |         |            |\n+   |         |            data moved here\n+   |         help: consider removing this borrow operator: `Either::One(_t)`\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:213:22\n+   |\n+LL |         &Either::One(_t) => (),\n+   |                      ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:218:11\n+   |\n+LL |     match &e {\n+   |           ^^ cannot move out of borrowed content\n+LL |         //~^ ERROR cannot move\n+LL |         &Either::One(_t) => (),\n+   |         ----------------\n+   |         |            |\n+   |         |            data moved here\n+   |         help: consider removing this borrow operator: `Either::One(_t)`\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:220:22\n+   |\n+LL |         &Either::One(_t) => (),\n+   |                      ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:226:22\n+   |\n+LL |     let &mut X(_t) = &mut xm;\n+   |         ----------   ^^^^^^^ cannot move out of borrowed content\n+   |         |      |\n+   |         |      data moved here\n+   |         help: consider removing this borrow operator: `X(_t)`\n+   |\n+note: move occurs because _t has type `Y`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:226:16\n+   |\n+LL |     let &mut X(_t) = &mut xm;\n+   |                ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:230:35\n+   |\n+LL |     if let &mut Either::One(_t) = &mut em { }\n+   |            --------------------   ^^^^^^^ cannot move out of borrowed content\n+   |            |                |\n+   |            |                data moved here\n+   |            help: consider removing this borrow operator: `Either::One(_t)`\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:230:29\n+   |\n+LL |     if let &mut Either::One(_t) = &mut em { }\n+   |                             ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:234:38\n+   |\n+LL |     while let &mut Either::One(_t) = &mut em { }\n+   |               --------------------   ^^^^^^^ cannot move out of borrowed content\n+   |               |                |\n+   |               |                data moved here\n+   |               help: consider removing this borrow operator: `Either::One(_t)`\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:234:32\n+   |\n+LL |     while let &mut Either::One(_t) = &mut em { }\n+   |                                ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:238:11\n+   |\n+LL |     match &mut em {\n+   |           ^^^^^^^ cannot move out of borrowed content\n+LL |         //~^ ERROR cannot move\n+LL |         &mut Either::One(_t)\n+   |         --------------------\n+   |         |                |\n+   |         |                data moved here\n+   |         help: consider removing this borrow operator: `Either::One(_t)`\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:240:26\n+   |\n+LL |         &mut Either::One(_t)\n+   |                          ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:246:11\n+   |\n+LL |     match &mut em {\n+   |           ^^^^^^^ cannot move out of borrowed content\n+LL |         //~^ ERROR cannot move\n+LL |         &mut Either::One(_t) => (),\n+   |         --------------------\n+   |         |                |\n+   |         |                data moved here\n+   |         help: consider removing this borrow operator: `Either::One(_t)`\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:248:26\n+   |\n+LL |         &mut Either::One(_t) => (),\n+   |                          ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:253:11\n+   |\n+LL |     match &mut em {\n+   |           ^^^^^^^ cannot move out of borrowed content\n+LL |         //~^ ERROR cannot move\n+LL |         &mut Either::One(_t) => (),\n+   |         --------------------\n+   |         |                |\n+   |         |                data moved here\n+   |         help: consider removing this borrow operator: `Either::One(_t)`\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:255:26\n+   |\n+LL |         &mut Either::One(_t) => (),\n+   |                          ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:260:11\n+   |\n+LL |     match &mut em {\n+   |           ^^^^^^^ cannot move out of borrowed content\n+LL |         //~^ ERROR cannot move\n+LL |         &mut Either::One(_t) => (),\n+   |         --------------------\n+   |         |                |\n+   |         |                data moved here\n+   |         help: consider removing this borrow operator: `Either::One(_t)`\n+   |\n+note: move occurs because _t has type `X`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:262:26\n+   |\n+LL |         &mut Either::One(_t) => (),\n+   |                          ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:137:11\n+   |\n+LL |     fn f1(&X(_t): &X) { }\n+   |           ^^^--^\n+   |           |  |\n+   |           |  data moved here\n+   |           cannot move out of borrowed content\n+   |           help: consider removing this borrow operator: `X(_t)`\n+   |\n+note: move occurs because _t has type `Y`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:137:14\n+   |\n+LL |     fn f1(&X(_t): &X) { }\n+   |              ^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/dont-suggest-ref.rs:184:11\n+   |\n+LL |     fn f2(&mut X(_t): &mut X) { }\n+   |           ^^^^^^^--^\n+   |           |      |\n+   |           |      data moved here\n+   |           cannot move out of borrowed content\n+   |           help: consider removing this borrow operator: `X(_t)`\n+   |\n+note: move occurs because _t has type `Y`, which does not implement the `Copy` trait\n+  --> $DIR/dont-suggest-ref.rs:184:18\n+   |\n+LL |     fn f2(&mut X(_t): &mut X) { }\n+   |                  ^^\n+\n+error: aborting due to 39 previous errors\n+\n+For more information about this error, try `rustc --explain E0507`."}]}