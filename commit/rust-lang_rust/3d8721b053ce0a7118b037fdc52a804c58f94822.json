{"sha": "3d8721b053ce0a7118b037fdc52a804c58f94822", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkODcyMWIwNTNjZTBhNzExOGIwMzdmZGM1MmE4MDRjNThmOTQ4MjI=", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2020-10-11T18:32:46Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2020-10-11T18:32:46Z"}, "message": "Fix casts, add tests", "tree": {"sha": "7fef103d138347b4239da42150e32b024ecefddf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fef103d138347b4239da42150e32b024ecefddf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d8721b053ce0a7118b037fdc52a804c58f94822", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d8721b053ce0a7118b037fdc52a804c58f94822", "html_url": "https://github.com/rust-lang/rust/commit/3d8721b053ce0a7118b037fdc52a804c58f94822", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d8721b053ce0a7118b037fdc52a804c58f94822/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75fdacde1ce6da3a93058a9fca248bfaf2611cd3", "url": "https://api.github.com/repos/rust-lang/rust/commits/75fdacde1ce6da3a93058a9fca248bfaf2611cd3", "html_url": "https://github.com/rust-lang/rust/commit/75fdacde1ce6da3a93058a9fca248bfaf2611cd3"}], "stats": {"total": 174, "additions": 149, "deletions": 25}, "files": [{"sha": "acf85983a9837bb5c02aa0ce797f2e7ee77e018f", "filename": "crates/core_simd/src/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d8721b053ce0a7118b037fdc52a804c58f94822/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8721b053ce0a7118b037fdc52a804c58f94822/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=3d8721b053ce0a7118b037fdc52a804c58f94822", "patch": "@@ -36,4 +36,7 @@ extern \"platform-intrinsic\" {\n \n     /// xor\n     pub(crate) fn simd_xor<T>(x: T, y: T) -> T;\n+\n+    /// fptoui/fptosi/uitofp/sitofp\n+    pub(crate) fn simd_cast<T, U>(x: T) -> U;\n }"}, {"sha": "aadade1fd066f72d9f1ebfe8fc7d7021de011c53", "filename": "crates/core_simd/src/round.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3d8721b053ce0a7118b037fdc52a804c58f94822/crates%2Fcore_simd%2Fsrc%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8721b053ce0a7118b037fdc52a804c58f94822/crates%2Fcore_simd%2Fsrc%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fround.rs?ref=3d8721b053ce0a7118b037fdc52a804c58f94822", "patch": "@@ -6,7 +6,6 @@ macro_rules! implement {\n             ceil = $ceil_intrinsic:literal,\n             round = $round_intrinsic:literal,\n             trunc = $trunc_intrinsic:literal,\n-            round_to_int = $round_to_int_intrinsic:literal,\n         }\n     } => {\n         mod $type {\n@@ -20,8 +19,6 @@ macro_rules! implement {\n                 fn round_intrinsic(x: crate::$type) -> crate::$type;\n                 #[link_name = $trunc_intrinsic]\n                 fn trunc_intrinsic(x: crate::$type) -> crate::$type;\n-                #[link_name = $round_to_int_intrinsic]\n-                fn round_to_int_intrinsic(x: crate::$type) -> crate::$int_type;\n             }\n \n             impl crate::$type {\n@@ -60,11 +57,24 @@ macro_rules! implement {\n                     self - self.trunc()\n                 }\n \n+                /// Rounds toward zero and converts to the same-width integer type, assuming that\n+                /// the value is finite and fits in that type.\n+                ///\n+                /// # Safety\n+                /// The value must:\n+                ///\n+                /// * Not be NaN\n+                /// * Not be infinite\n+                /// * Be representable in the return type, after truncating off its fractional part\n+                #[inline]\n+                pub unsafe fn to_int_unchecked(self) -> crate::$int_type {\n+                    crate::intrinsics::simd_cast(self)\n+                }\n+\n                 /// Returns the nearest integer to each lane. Round half-way cases away from 0.0.\n-                #[must_use = \"method returns a new vector and does not mutate the original value\"]\n                 #[inline]\n-                pub fn round_to_int(self) -> crate::$int_type {\n-                    unsafe { round_to_int_intrinsic(self) }\n+                pub fn round_from_int(value: crate::$int_type) -> Self {\n+                    unsafe { crate::intrinsics::simd_cast(value) }\n                 }\n             }\n         }\n@@ -78,7 +88,6 @@ implement! {\n         ceil = \"llvm.ceil.v2f32\",\n         round = \"llvm.round.v2f32\",\n         trunc = \"llvm.trunc.v2f32\",\n-        round_to_int = \"llvm.lround.i32.v2f32\",\n     }\n }\n \n@@ -89,7 +98,6 @@ implement! {\n         ceil = \"llvm.ceil.v4f32\",\n         round = \"llvm.round.v4f32\",\n         trunc = \"llvm.trunc.v4f32\",\n-        round_to_int = \"llvm.lround.i32.v4f32\",\n     }\n }\n \n@@ -100,7 +108,6 @@ implement! {\n         ceil = \"llvm.ceil.v8f32\",\n         round = \"llvm.round.v8f32\",\n         trunc = \"llvm.trunc.v8f32\",\n-        round_to_int = \"llvm.lround.i32.v8f32\",\n     }\n }\n \n@@ -111,7 +118,6 @@ implement! {\n         ceil = \"llvm.ceil.v16f32\",\n         round = \"llvm.round.v16f32\",\n         trunc = \"llvm.trunc.v16f32\",\n-        round_to_int = \"llvm.lround.i32.v16f32\",\n     }\n }\n \n@@ -122,7 +128,6 @@ implement! {\n         ceil = \"llvm.ceil.v2f64\",\n         round = \"llvm.round.v2f64\",\n         trunc = \"llvm.trunc.v2f64\",\n-        round_to_int = \"llvm.lround.i64.v2f64\",\n     }\n }\n \n@@ -133,7 +138,6 @@ implement! {\n         ceil = \"llvm.ceil.v4f64\",\n         round = \"llvm.round.v4f64\",\n         trunc = \"llvm.trunc.v4f64\",\n-        round_to_int = \"llvm.lround.i64.v4f64\",\n     }\n }\n \n@@ -144,6 +148,5 @@ implement! {\n         ceil = \"llvm.ceil.v8f64\",\n         round = \"llvm.round.v8f64\",\n         trunc = \"llvm.trunc.v8f64\",\n-        round_to_int = \"llvm.lround.i64.v8f64\",\n     }\n }"}, {"sha": "15f1a88ffd5c3232274f806a0f2c3d54de098c70", "filename": "crates/core_simd/tests/helpers/lanewise.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3d8721b053ce0a7118b037fdc52a804c58f94822/crates%2Fcore_simd%2Ftests%2Fhelpers%2Flanewise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8721b053ce0a7118b037fdc52a804c58f94822/crates%2Fcore_simd%2Ftests%2Fhelpers%2Flanewise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fhelpers%2Flanewise.rs?ref=3d8721b053ce0a7118b037fdc52a804c58f94822", "patch": "@@ -1,8 +1,13 @@\n-pub fn apply_unary_lanewise<T: Copy, V: AsMut<[T]> + Default>(mut x: V, f: impl Fn(T) -> T) -> V {\n-    for lane in x.as_mut() {\n-        *lane = f(*lane)\n+pub fn apply_unary_lanewise<T1: Copy, T2: Copy, V1: AsRef<[T1]>, V2: AsMut<[T2]> + Default>(\n+    x: V1,\n+    f: impl Fn(T1) -> T2,\n+) -> V2 {\n+    let mut y = V2::default();\n+    assert_eq!(x.as_ref().len(), y.as_mut().len());\n+    for (x, y) in x.as_ref().iter().zip(y.as_mut().iter_mut()) {\n+        *y = f(*x);\n     }\n-    x\n+    y\n }\n \n pub fn apply_binary_lanewise<T: Copy, V: AsRef<[T]> + AsMut<[T]> + Default>("}, {"sha": "1472822fe1fe559f935b5b1381c6ff0999d6ad2b", "filename": "crates/core_simd/tests/ops_impl/f32.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d8721b053ce0a7118b037fdc52a804c58f94822/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8721b053ce0a7118b037fdc52a804c58f94822/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff32.rs?ref=3d8721b053ce0a7118b037fdc52a804c58f94822", "patch": "@@ -1,6 +1,6 @@\n use super::helpers;\n \n-float_tests! { f32x2, f32 }\n-float_tests! { f32x4, f32 }\n-float_tests! { f32x8, f32 }\n-float_tests! { f32x16, f32 }\n+float_tests! { f32x2, f32, i32x2, i32 }\n+float_tests! { f32x4, f32, i32x4, i32 }\n+float_tests! { f32x8, f32, i32x8, i32 }\n+float_tests! { f32x16, f32, i32x16, i32 }"}, {"sha": "8f573baa1ad222a20fe7a35ff7c13a6135750112", "filename": "crates/core_simd/tests/ops_impl/f64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d8721b053ce0a7118b037fdc52a804c58f94822/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8721b053ce0a7118b037fdc52a804c58f94822/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff64.rs?ref=3d8721b053ce0a7118b037fdc52a804c58f94822", "patch": "@@ -1,5 +1,5 @@\n use super::helpers;\n \n-float_tests! { f64x2, f64 }\n-float_tests! { f64x4, f64 }\n-float_tests! { f64x8, f64 }\n+float_tests! { f64x2, f64, i64x2, i64 }\n+float_tests! { f64x4, f64, i64x4, i64 }\n+float_tests! { f64x8, f64, i64x8, i64 }"}, {"sha": "6f6f6385d9769f9db2c21df2e2f35240dc9e0d29", "filename": "crates/core_simd/tests/ops_impl/float_macros.rs", "status": "modified", "additions": 114, "deletions": 1, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/3d8721b053ce0a7118b037fdc52a804c58f94822/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8721b053ce0a7118b037fdc52a804c58f94822/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ffloat_macros.rs?ref=3d8721b053ce0a7118b037fdc52a804c58f94822", "patch": "@@ -1,5 +1,5 @@\n macro_rules! float_tests {\n-    { $vector:ident, $scalar:ident } => {\n+    { $vector:ident, $scalar:ident, $int_vector:ident, $int_scalar:ident } => {\n         #[cfg(test)]\n         mod $vector {\n             use super::*;\n@@ -24,6 +24,18 @@ macro_rules! float_tests {\n                 slice.chunks_exact(lanes).map(from_slice)\n             }\n \n+            fn from_slice_int(slice: &[$int_scalar]) -> core_simd::$int_vector {\n+                let mut value = core_simd::$int_vector::default();\n+                let value_slice: &mut [_] = value.as_mut();\n+                value_slice.copy_from_slice(&slice[0..value_slice.len()]);\n+                value\n+            }\n+\n+            fn slice_chunks_int(slice: &[$int_scalar]) -> impl Iterator<Item = core_simd::$int_vector> + '_ {\n+                let lanes = core::mem::size_of::<core_simd::$int_vector>() / core::mem::size_of::<$int_scalar>();\n+                slice.chunks_exact(lanes).map(from_slice_int)\n+            }\n+\n             const A: [$scalar; 16] = [0.,   1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11., 12., 13., 14., 15.];\n             const B: [$scalar; 16] = [16., 17., 18., 19., 20., 21., 22., 23., 24., 25., 26., 27., 28., 29., 30., 31.];\n             const C: [$scalar; 16] = [\n@@ -322,6 +334,107 @@ macro_rules! float_tests {\n                     assert_biteq!(v.abs(), expected);\n                 }\n             }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn ceil_odd_floats() {\n+                for v in slice_chunks(&C) {\n+                    let expected = apply_unary_lanewise(v, <$scalar>::ceil);\n+                    assert_biteq!(v.ceil(), expected);\n+                }\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn floor_odd_floats() {\n+                for v in slice_chunks(&C) {\n+                    let expected = apply_unary_lanewise(v, <$scalar>::floor);\n+                    assert_biteq!(v.floor(), expected);\n+                }\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn round_odd_floats() {\n+                for v in slice_chunks(&C) {\n+                    let expected = apply_unary_lanewise(v, <$scalar>::round);\n+                    assert_biteq!(v.round(), expected);\n+                }\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn trunc_odd_floats() {\n+                for v in slice_chunks(&C) {\n+                    let expected = apply_unary_lanewise(v, <$scalar>::trunc);\n+                    assert_biteq!(v.trunc(), expected);\n+                }\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn fract_odd_floats() {\n+                for v in slice_chunks(&C) {\n+                    let expected = apply_unary_lanewise(v, <$scalar>::fract);\n+                    assert_biteq!(v.fract(), expected);\n+                }\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn to_int_unchecked() {\n+                const VALUES: [$scalar; 16] = [\n+                    -0.0,\n+                    0.0,\n+                    -1.0,\n+                    1.0,\n+                    <$scalar>::MIN,\n+                    -<$scalar>::MIN,\n+                    <$scalar>::MIN_POSITIVE,\n+                    -<$scalar>::MIN_POSITIVE,\n+                    <$scalar>::EPSILON,\n+                    -<$scalar>::EPSILON,\n+                    core::$scalar::consts::PI,\n+                    -core::$scalar::consts::PI,\n+                    core::$scalar::consts::TAU,\n+                    -core::$scalar::consts::TAU,\n+                    100.0 / 3.0,\n+                    -100.0 / 3.0,\n+                ];\n+\n+                for v in slice_chunks(&VALUES) {\n+                    let expected = apply_unary_lanewise(v, |x| unsafe { x.to_int_unchecked() });\n+                    assert_biteq!(unsafe { v.to_int_unchecked() }, expected);\n+                }\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn round_from_int() {\n+                const VALUES: [$int_scalar; 16] = [\n+                    0,\n+                    0,\n+                    1,\n+                    -1,\n+                    100,\n+                    -100,\n+                    200,\n+                    -200,\n+                    413,\n+                    -413,\n+                    1017,\n+                    -1017,\n+                    1234567,\n+                    -1234567,\n+                    <$int_scalar>::MAX,\n+                    <$int_scalar>::MIN,\n+                ];\n+\n+                for v in slice_chunks_int(&VALUES) {\n+                    let expected = apply_unary_lanewise(v, |x| x as $scalar);\n+                    assert_biteq!(core_simd::$vector::round_from_int(v), expected);\n+                }\n+            }\n         }\n     }\n }"}]}