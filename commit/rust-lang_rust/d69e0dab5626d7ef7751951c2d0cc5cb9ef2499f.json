{"sha": "d69e0dab5626d7ef7751951c2d0cc5cb9ef2499f", "node_id": "C_kwDOAAsO6NoAKGQ2OWUwZGFiNTYyNmQ3ZWY3NzUxOTUxYzJkMGNjNWNiOWVmMjQ5OWY", "commit": {"author": {"name": "Jake Heinz", "email": "jh@discordapp.com", "date": "2021-11-29T03:54:52Z"}, "committer": {"name": "Jake Heinz", "email": "jh@discordapp.com", "date": "2021-11-29T03:54:52Z"}, "message": "cleanup the whole thing...", "tree": {"sha": "42b81bdfebcf270c0e615abbcbd540a7c14ddd9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42b81bdfebcf270c0e615abbcbd540a7c14ddd9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d69e0dab5626d7ef7751951c2d0cc5cb9ef2499f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d69e0dab5626d7ef7751951c2d0cc5cb9ef2499f", "html_url": "https://github.com/rust-lang/rust/commit/d69e0dab5626d7ef7751951c2d0cc5cb9ef2499f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d69e0dab5626d7ef7751951c2d0cc5cb9ef2499f/comments", "author": {"login": "jhgg", "id": 5489149, "node_id": "MDQ6VXNlcjU0ODkxNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5489149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jhgg", "html_url": "https://github.com/jhgg", "followers_url": "https://api.github.com/users/jhgg/followers", "following_url": "https://api.github.com/users/jhgg/following{/other_user}", "gists_url": "https://api.github.com/users/jhgg/gists{/gist_id}", "starred_url": "https://api.github.com/users/jhgg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jhgg/subscriptions", "organizations_url": "https://api.github.com/users/jhgg/orgs", "repos_url": "https://api.github.com/users/jhgg/repos", "events_url": "https://api.github.com/users/jhgg/events{/privacy}", "received_events_url": "https://api.github.com/users/jhgg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jhgg", "id": 5489149, "node_id": "MDQ6VXNlcjU0ODkxNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5489149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jhgg", "html_url": "https://github.com/jhgg", "followers_url": "https://api.github.com/users/jhgg/followers", "following_url": "https://api.github.com/users/jhgg/following{/other_user}", "gists_url": "https://api.github.com/users/jhgg/gists{/gist_id}", "starred_url": "https://api.github.com/users/jhgg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jhgg/subscriptions", "organizations_url": "https://api.github.com/users/jhgg/orgs", "repos_url": "https://api.github.com/users/jhgg/repos", "events_url": "https://api.github.com/users/jhgg/events{/privacy}", "received_events_url": "https://api.github.com/users/jhgg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aecb9a378c8d61a355cb9e9fa247f9307799f7f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/aecb9a378c8d61a355cb9e9fa247f9307799f7f8", "html_url": "https://github.com/rust-lang/rust/commit/aecb9a378c8d61a355cb9e9fa247f9307799f7f8"}], "stats": {"total": 441, "additions": 233, "deletions": 208}, "files": [{"sha": "f6d703fd9b154fb074f28cbe765621a36dc6131b", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d69e0dab5626d7ef7751951c2d0cc5cb9ef2499f/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69e0dab5626d7ef7751951c2d0cc5cb9ef2499f/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=d69e0dab5626d7ef7751951c2d0cc5cb9ef2499f", "patch": "@@ -44,9 +44,8 @@ use hir_def::{\n     nameres,\n     per_ns::PerNs,\n     resolver::{HasResolver, Resolver},\n-    AttrDefId, ConstId, ConstParamId, EnumId, FunctionId, GenericDefId, HasModule, ImplId,\n-    LifetimeParamId, LocalEnumVariantId, LocalFieldId, StaticId, StructId, TraitId, TypeAliasId,\n-    TypeParamId, UnionId,\n+    AttrDefId, ConstId, ConstParamId, EnumId, FunctionId, GenericDefId, HasModule, LifetimeParamId,\n+    LocalEnumVariantId, LocalFieldId, StaticId, StructId, TypeAliasId, TypeParamId, UnionId,\n };\n use hir_expand::{name::name, MacroCallKind, MacroDefId, MacroDefKind};\n use hir_ty::{\n@@ -118,10 +117,12 @@ pub use {\n         AssocItemId,\n         AssocItemLoc,\n         DefWithBodyId,\n+        ImplId,\n         ItemLoc,\n         Lookup,\n         ModuleDefId,\n         ModuleId,\n+        TraitId,\n     },\n     hir_expand::{\n         name::{known, Name},"}, {"sha": "3a0dfd066c14e5cf6bd67176bb533e7af3f53250", "filename": "crates/ide_db/src/symbol_index.rs", "status": "modified", "additions": 229, "deletions": 205, "changes": 434, "blob_url": "https://github.com/rust-lang/rust/blob/d69e0dab5626d7ef7751951c2d0cc5cb9ef2499f/crates%2Fide_db%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69e0dab5626d7ef7751951c2d0cc5cb9ef2499f/crates%2Fide_db%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsymbol_index.rs?ref=d69e0dab5626d7ef7751951c2d0cc5cb9ef2499f", "patch": "@@ -35,8 +35,8 @@ use base_db::{\n use fst::{self, Streamer};\n use hir::{\n     db::DefDatabase, AdtId, AssocContainerId, AssocItemId, AssocItemLoc, DefHasSource,\n-    DefWithBodyId, HirFileId, InFile, ItemLoc, ItemScope, ItemTreeNode, Lookup, ModuleData,\n-    ModuleDefId, ModuleId, Semantics,\n+    DefWithBodyId, HirFileId, ImplId, InFile, ItemLoc, ItemTreeNode, Lookup, ModuleDefId, ModuleId,\n+    Semantics, TraitId,\n };\n use rayon::prelude::*;\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -129,13 +129,7 @@ fn library_symbols(db: &dyn SymbolsDatabase) -> Arc<FxHashMap<SourceRootId, Symb\n }\n \n fn module_symbols(db: &dyn SymbolsDatabase, module_id: ModuleId) -> Arc<SymbolIndex> {\n-    db.unwind_if_cancelled();\n-\n-    let def_map = module_id.def_map(db.upcast());\n-    let module_data = &def_map[module_id.local_id];\n-\n-    let symbols = module_data_to_file_symbols(db.upcast(), module_data);\n-\n+    let symbols = SymbolCollector::collect(db.upcast(), module_id);\n     Arc::new(SymbolIndex::new(symbols))\n }\n \n@@ -444,229 +438,259 @@ fn source_file_to_file_symbols(_source_file: &SourceFile, _file_id: FileId) -> V\n     // todo: delete this.\n     vec![]\n }\n+enum SymbolCollectorWorkItem {\n+    Module { module_id: ModuleId, parent: Option<DefWithBodyId> },\n+    Body { body: DefWithBodyId },\n+    Impl { impl_id: ImplId },\n+    Trait { trait_id: TraitId },\n+}\n \n-fn module_data_to_file_symbols(db: &dyn DefDatabase, module_data: &ModuleData) -> Vec<FileSymbol> {\n-    let mut symbols = Vec::new();\n-    collect_symbols_from_item_scope(db, &mut symbols, &module_data.scope);\n-    // todo: collect macros from scope.macros().\n-    symbols\n+struct SymbolCollector<'a> {\n+    db: &'a dyn DefDatabase,\n+    symbols: Vec<FileSymbol>,\n+    work: Vec<SymbolCollectorWorkItem>,\n+    container_name_stack: Vec<SmolStr>,\n }\n \n-fn collect_symbols_from_item_scope(\n-    db: &dyn DefDatabase,\n-    symbols: &mut Vec<FileSymbol>,\n-    scope: &ItemScope,\n-) {\n-    fn container_name(db: &dyn DefDatabase, container: AssocContainerId) -> Option<SmolStr> {\n-        match container {\n-            AssocContainerId::ModuleId(module_id) => {\n-                let def_map = module_id.def_map(db);\n-                let module_data = &def_map[module_id.local_id];\n-                module_data\n-                    .origin\n-                    .declaration()\n-                    .and_then(|s| s.to_node(db.upcast()).name().map(|n| n.text().into()))\n+impl<'a> SymbolCollector<'a> {\n+    fn collect(db: &dyn DefDatabase, module_id: ModuleId) -> Vec<FileSymbol> {\n+        let mut symbol_collector = SymbolCollector {\n+            db,\n+            symbols: Default::default(),\n+            container_name_stack: Default::default(),\n+            work: vec![SymbolCollectorWorkItem::Module { module_id, parent: None }],\n+        };\n+\n+        while let Some(work_item) = symbol_collector.work.pop() {\n+            symbol_collector.do_work(work_item);\n+        }\n+\n+        symbol_collector.symbols\n+    }\n+\n+    fn do_work(&mut self, work_item: SymbolCollectorWorkItem) {\n+        self.db.unwind_if_cancelled();\n+\n+        match work_item {\n+            SymbolCollectorWorkItem::Module { module_id, parent } => {\n+                let parent_name = parent.and_then(|id| self.def_with_body_id_name(id));\n+                self.with_container_name(parent_name, |s| s.collect_from_module(module_id));\n             }\n-            AssocContainerId::TraitId(trait_id) => {\n-                let loc = trait_id.lookup(db);\n-                let source = loc.source(db);\n-                source.value.name().map(|n| n.text().into())\n+            SymbolCollectorWorkItem::Body { body } => self.collect_from_body(body),\n+            SymbolCollectorWorkItem::Impl { impl_id } => self.collect_from_impl(impl_id),\n+            SymbolCollectorWorkItem::Trait { trait_id } => {\n+                let trait_name = self.db.trait_data(trait_id).name.as_text();\n+                self.with_container_name(trait_name, |s| s.collect_from_trait(trait_id));\n+            }\n+        }\n+    }\n+\n+    fn collect_from_module(&mut self, module_id: ModuleId) {\n+        let def_map = module_id.def_map(self.db);\n+        let module_data = &def_map[module_id.local_id];\n+        let scope = &module_data.scope;\n+\n+        for module_def_id in scope.declarations() {\n+            match module_def_id {\n+                ModuleDefId::ModuleId(id) => self.push_module(id),\n+                ModuleDefId::FunctionId(id) => {\n+                    self.push_decl_assoc(id, FileSymbolKind::Function);\n+                    self.work.push(SymbolCollectorWorkItem::Body { body: id.into() });\n+                }\n+                ModuleDefId::AdtId(AdtId::StructId(id)) => {\n+                    self.push_decl(id, FileSymbolKind::Struct)\n+                }\n+                ModuleDefId::AdtId(AdtId::EnumId(id)) => self.push_decl(id, FileSymbolKind::Enum),\n+                ModuleDefId::AdtId(AdtId::UnionId(id)) => self.push_decl(id, FileSymbolKind::Union),\n+                ModuleDefId::ConstId(id) => {\n+                    self.push_decl_assoc(id, FileSymbolKind::Const);\n+                    self.work.push(SymbolCollectorWorkItem::Body { body: id.into() })\n+                }\n+                ModuleDefId::StaticId(id) => {\n+                    self.push_decl(id, FileSymbolKind::Static);\n+                    self.work.push(SymbolCollectorWorkItem::Body { body: id.into() })\n+                }\n+                ModuleDefId::TraitId(id) => {\n+                    self.push_decl(id, FileSymbolKind::Trait);\n+                    self.work.push(SymbolCollectorWorkItem::Trait { trait_id: id })\n+                }\n+                ModuleDefId::TypeAliasId(id) => {\n+                    self.push_decl_assoc(id, FileSymbolKind::TypeAlias);\n+                }\n+                // Don't index these.\n+                ModuleDefId::BuiltinType(_) => {}\n+                ModuleDefId::EnumVariantId(_) => {}\n             }\n-            AssocContainerId::ImplId(_) => None,\n         }\n+\n+        for impl_id in scope.impls() {\n+            self.work.push(SymbolCollectorWorkItem::Impl { impl_id });\n+        }\n+\n+        for const_id in scope.unnamed_consts() {\n+            self.work.push(SymbolCollectorWorkItem::Body { body: const_id.into() })\n+        }\n+\n+        // todo: collect macros.\n+    }\n+\n+    fn collect_from_body(&mut self, body_id: DefWithBodyId) {\n+        let body = self.db.body(body_id);\n+\n+        // Descend into the blocks and enqueue collection of all modules within.\n+        for (_, def_map) in body.blocks(self.db) {\n+            for (id, _) in def_map.modules() {\n+                self.work.push(SymbolCollectorWorkItem::Module {\n+                    module_id: def_map.module_id(id),\n+                    parent: Some(body_id),\n+                });\n+            }\n+        }\n+    }\n+\n+    fn collect_from_impl(&mut self, impl_id: ImplId) {\n+        let impl_data = self.db.impl_data(impl_id);\n+        for &assoc_item_id in &impl_data.items {\n+            self.push_assoc_item(assoc_item_id)\n+        }\n+    }\n+\n+    fn collect_from_trait(&mut self, trait_id: TraitId) {\n+        let trait_data = self.db.trait_data(trait_id);\n+        for &(_, assoc_item_id) in &trait_data.items {\n+            self.push_assoc_item(assoc_item_id);\n+        }\n+    }\n+\n+    fn with_container_name(&mut self, container_name: Option<SmolStr>, f: impl FnOnce(&mut Self)) {\n+        if let Some(container_name) = container_name {\n+            self.container_name_stack.push(container_name);\n+            f(self);\n+            self.container_name_stack.pop();\n+        } else {\n+            f(self);\n+        }\n+    }\n+\n+    fn current_container_name(&self) -> Option<SmolStr> {\n+        self.container_name_stack.last().cloned()\n     }\n \n-    fn decl_assoc<L, T>(db: &dyn DefDatabase, id: L, kind: FileSymbolKind) -> Option<FileSymbol>\n+    fn def_with_body_id_name(&self, body_id: DefWithBodyId) -> Option<SmolStr> {\n+        match body_id {\n+            DefWithBodyId::FunctionId(id) => {\n+                Some(id.lookup(self.db).source(self.db).value.name()?.text().into())\n+            }\n+            DefWithBodyId::StaticId(id) => {\n+                Some(id.lookup(self.db).source(self.db).value.name()?.text().into())\n+            }\n+            DefWithBodyId::ConstId(id) => {\n+                Some(id.lookup(self.db).source(self.db).value.name()?.text().into())\n+            }\n+        }\n+    }\n+\n+    fn push_assoc_item(&mut self, assoc_item_id: AssocItemId) {\n+        match assoc_item_id {\n+            AssocItemId::FunctionId(id) => self.push_decl_assoc(id, FileSymbolKind::Function),\n+            AssocItemId::ConstId(id) => self.push_decl_assoc(id, FileSymbolKind::Const),\n+            AssocItemId::TypeAliasId(id) => self.push_decl_assoc(id, FileSymbolKind::TypeAlias),\n+        }\n+    }\n+\n+    fn push_decl_assoc<L, T>(&mut self, id: L, kind: FileSymbolKind)\n     where\n         L: Lookup<Data = AssocItemLoc<T>>,\n         T: ItemTreeNode,\n         <T as ItemTreeNode>::Source: HasName,\n     {\n-        let loc = id.lookup(db);\n-        let source = loc.source(db);\n-        let name_node = source.value.name()?;\n-        let container_name = container_name(db, loc.container);\n-\n-        Some(FileSymbol {\n-            name: name_node.text().into(),\n-            kind,\n-            container_name,\n-            loc: DeclarationLocation {\n-                hir_file_id: source.file_id,\n-                ptr: SyntaxNodePtr::new(source.value.syntax()),\n-                name_ptr: SyntaxNodePtr::new(name_node.syntax()),\n-            },\n+        fn container_name(db: &dyn DefDatabase, container: AssocContainerId) -> Option<SmolStr> {\n+            match container {\n+                AssocContainerId::ModuleId(module_id) => {\n+                    let def_map = module_id.def_map(db);\n+                    let module_data = &def_map[module_id.local_id];\n+                    module_data\n+                        .origin\n+                        .declaration()\n+                        .and_then(|s| s.to_node(db.upcast()).name().map(|n| n.text().into()))\n+                }\n+                AssocContainerId::TraitId(trait_id) => {\n+                    let loc = trait_id.lookup(db);\n+                    let source = loc.source(db);\n+                    source.value.name().map(|n| n.text().into())\n+                }\n+                AssocContainerId::ImplId(_) => None,\n+            }\n+        }\n+\n+        self.push_file_symbol(|s| {\n+            let loc = id.lookup(s.db);\n+            let source = loc.source(s.db);\n+            let name_node = source.value.name()?;\n+            let container_name =\n+                container_name(s.db, loc.container).or_else(|| s.current_container_name());\n+\n+            Some(FileSymbol {\n+                name: name_node.text().into(),\n+                kind,\n+                container_name,\n+                loc: DeclarationLocation {\n+                    hir_file_id: source.file_id,\n+                    ptr: SyntaxNodePtr::new(source.value.syntax()),\n+                    name_ptr: SyntaxNodePtr::new(name_node.syntax()),\n+                },\n+            })\n         })\n     }\n \n-    fn decl<L, T>(db: &dyn DefDatabase, id: L, kind: FileSymbolKind) -> Option<FileSymbol>\n+    fn push_decl<L, T>(&mut self, id: L, kind: FileSymbolKind)\n     where\n         L: Lookup<Data = ItemLoc<T>>,\n         T: ItemTreeNode,\n         <T as ItemTreeNode>::Source: HasName,\n     {\n-        let loc = id.lookup(db);\n-        let source = loc.source(db);\n-        let name_node = source.value.name()?;\n-\n-        Some(FileSymbol {\n-            name: name_node.text().into(),\n-            kind,\n-            container_name: None,\n-            loc: DeclarationLocation {\n-                hir_file_id: source.file_id,\n-                ptr: SyntaxNodePtr::new(source.value.syntax()),\n-                name_ptr: SyntaxNodePtr::new(name_node.syntax()),\n-            },\n+        self.push_file_symbol(|s| {\n+            let loc = id.lookup(s.db);\n+            let source = loc.source(s.db);\n+            let name_node = source.value.name()?;\n+\n+            Some(FileSymbol {\n+                name: name_node.text().into(),\n+                kind,\n+                container_name: s.current_container_name(),\n+                loc: DeclarationLocation {\n+                    hir_file_id: source.file_id,\n+                    ptr: SyntaxNodePtr::new(source.value.syntax()),\n+                    name_ptr: SyntaxNodePtr::new(name_node.syntax()),\n+                },\n+            })\n         })\n     }\n \n-    fn decl_module(db: &dyn DefDatabase, module_id: ModuleId) -> Option<FileSymbol> {\n-        let def_map = module_id.def_map(db);\n-        let module_data = &def_map[module_id.local_id];\n-        let declaration = module_data.origin.declaration()?;\n-        let module = declaration.to_node(db.upcast());\n-        let name_node = module.name()?;\n-\n-        Some(FileSymbol {\n-            name: name_node.text().into(),\n-            kind: FileSymbolKind::Module,\n-            container_name: None,\n-            loc: DeclarationLocation {\n-                hir_file_id: declaration.file_id,\n-                ptr: SyntaxNodePtr::new(module.syntax()),\n-                name_ptr: SyntaxNodePtr::new(name_node.syntax()),\n-            },\n+    fn push_module(&mut self, module_id: ModuleId) {\n+        self.push_file_symbol(|s| {\n+            let def_map = module_id.def_map(s.db);\n+            let module_data = &def_map[module_id.local_id];\n+            let declaration = module_data.origin.declaration()?;\n+            let module = declaration.to_node(s.db.upcast());\n+            let name_node = module.name()?;\n+\n+            Some(FileSymbol {\n+                name: name_node.text().into(),\n+                kind: FileSymbolKind::Module,\n+                container_name: s.current_container_name(),\n+                loc: DeclarationLocation {\n+                    hir_file_id: declaration.file_id,\n+                    ptr: SyntaxNodePtr::new(module.syntax()),\n+                    name_ptr: SyntaxNodePtr::new(name_node.syntax()),\n+                },\n+            })\n         })\n     }\n \n-    let collect_symbols_from_scope =\n-        |scope: &ItemScope,\n-         symbols: &mut Vec<FileSymbol>,\n-         bodies_to_traverse: &mut Vec<(Option<SmolStr>, DefWithBodyId)>,\n-         container_name: &Option<SmolStr>| {\n-            let mut trait_ids = Vec::new();\n-\n-            let scope_declaration_symbols = scope\n-                .declarations()\n-                .filter_map(|module_def_id| match module_def_id {\n-                    ModuleDefId::ModuleId(module_id) => decl_module(db, module_id),\n-                    ModuleDefId::FunctionId(function_id) => {\n-                        let symbol = decl_assoc(db, function_id, FileSymbolKind::Function);\n-                        bodies_to_traverse.push((\n-                            symbol.as_ref().and_then(|x| Some(x.name.clone())),\n-                            function_id.into(),\n-                        ));\n-                        symbol\n-                    }\n-                    ModuleDefId::AdtId(AdtId::StructId(struct_id)) => {\n-                        decl(db, struct_id, FileSymbolKind::Struct)\n-                    }\n-                    ModuleDefId::AdtId(AdtId::EnumId(enum_id)) => {\n-                        decl(db, enum_id, FileSymbolKind::Enum)\n-                    }\n-                    ModuleDefId::AdtId(AdtId::UnionId(union_id)) => {\n-                        decl(db, union_id, FileSymbolKind::Union)\n-                    }\n-                    ModuleDefId::ConstId(const_id) => {\n-                        let symbol = decl_assoc(db, const_id, FileSymbolKind::Const);\n-                        bodies_to_traverse.push((\n-                            symbol.as_ref().and_then(|x| Some(x.name.clone())),\n-                            const_id.into(),\n-                        ));\n-                        symbol\n-                    }\n-                    ModuleDefId::StaticId(static_id) => {\n-                        let symbol = decl(db, static_id, FileSymbolKind::Static);\n-                        bodies_to_traverse.push((\n-                            symbol.as_ref().and_then(|x| Some(x.name.clone())),\n-                            static_id.into(),\n-                        ));\n-                        symbol\n-                    }\n-                    ModuleDefId::TraitId(trait_id) => {\n-                        trait_ids.push(trait_id);\n-                        decl(db, trait_id, FileSymbolKind::Trait)\n-                    }\n-                    ModuleDefId::TypeAliasId(alias_id) => {\n-                        decl_assoc(db, alias_id, FileSymbolKind::TypeAlias)\n-                    }\n-                    ModuleDefId::BuiltinType(_) => None,\n-                    ModuleDefId::EnumVariantId(_) => None,\n-                })\n-                .map(|mut s| {\n-                    // If a container name was not provided in the symbol, but within the scope of our traversal,\n-                    // we'll update the container name here.\n-                    if let Some(container_name) = &container_name {\n-                        s.container_name.get_or_insert_with(|| container_name.clone());\n-                    }\n-\n-                    s\n-                });\n-\n-            symbols.extend(scope_declaration_symbols);\n-\n-            // todo: we need to merge in container name to these too.\n-            // also clean this up generally tooooo.\n-            let scope_impl_symbols = scope\n-                .impls()\n-                .map(|impl_id| db.impl_data(impl_id))\n-                .flat_map(|d| d.items.clone()) // xx: clean up this clone??\n-                .filter_map(|assoc_item_id| match assoc_item_id {\n-                    AssocItemId::FunctionId(function_id) => {\n-                        decl_assoc(db, function_id, FileSymbolKind::Function)\n-                    }\n-                    AssocItemId::ConstId(const_id) => {\n-                        decl_assoc(db, const_id, FileSymbolKind::Const)\n-                    }\n-                    AssocItemId::TypeAliasId(type_alias_id) => {\n-                        decl_assoc(db, type_alias_id, FileSymbolKind::TypeAlias)\n-                    }\n-                });\n-\n-            symbols.extend(scope_impl_symbols);\n-\n-            // todo: we need to merge in container name to these too.\n-            // also clean this up generally tooooo.\n-            let scope_trait_symbols = trait_ids\n-                .into_iter()\n-                .map(|trait_id| db.trait_data(trait_id))\n-                .flat_map(|d| d.items.clone())\n-                .filter_map(|(_, assoc_item_id)| match assoc_item_id {\n-                    AssocItemId::FunctionId(function_id) => {\n-                        decl_assoc(db, function_id, FileSymbolKind::Function)\n-                    }\n-                    AssocItemId::ConstId(const_id) => {\n-                        decl_assoc(db, const_id, FileSymbolKind::Const)\n-                    }\n-                    AssocItemId::TypeAliasId(type_alias_id) => {\n-                        decl_assoc(db, type_alias_id, FileSymbolKind::TypeAlias)\n-                    }\n-                });\n-\n-            symbols.extend(scope_trait_symbols);\n-\n-            for const_id in scope.unnamed_consts() {\n-                // since unnamed consts don't really have a name, we'll inherit parent scope's symbol name.\n-                bodies_to_traverse.push((container_name.clone(), const_id.into()));\n-            }\n-        };\n-\n-    let mut bodies_to_traverse = Vec::new();\n-    collect_symbols_from_scope(scope, symbols, &mut bodies_to_traverse, &None);\n-\n-    while let Some((container_name, body)) = bodies_to_traverse.pop() {\n-        let body = db.body(body);\n-\n-        for (_, block_def_map) in body.blocks(db) {\n-            for (_, module_data) in block_def_map.modules() {\n-                collect_symbols_from_scope(\n-                    &module_data.scope,\n-                    symbols,\n-                    &mut bodies_to_traverse,\n-                    &container_name,\n-                );\n-            }\n+    fn push_file_symbol(&mut self, f: impl FnOnce(&Self) -> Option<FileSymbol>) {\n+        if let Some(file_symbol) = f(self) {\n+            self.symbols.push(file_symbol);\n         }\n     }\n }"}]}