{"sha": "8681d4cffcd23bbe619984ab62772a91827a40dc", "node_id": "C_kwDOAAsO6NoAKDg2ODFkNGNmZmNkMjNiYmU2MTk5ODRhYjYyNzcyYTkxODI3YTQwZGM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-25T19:09:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-25T19:09:30Z"}, "message": "Auto merge of #104902 - matthiaskrgr:rollup-oo27a4u, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #104716 (move 2 candidates into builtin candidate)\n - #104760 (Clarify `SyntaxExtensionKind::LegacyDerive`.)\n - #104797 (rustc_codegen_ssa: write `.dwp` in a streaming fashion)\n - #104835 (Use infcx.partially_normalize_associated_types_in)\n - #104853 (Fix typo in miri sysroot)\n - #104879 (jsondoclint: Recognise Typedef as valid kind for Type::ResolvedPath)\n - #104887 (rustbuild: Don't build doc::SharedAssets when building JSON docs.)\n - #104896 (rustdoc: fix broken tooltip CSS)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "32cc196f2843a02ea0ae3d08e50ccb1c96a6bedc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32cc196f2843a02ea0ae3d08e50ccb1c96a6bedc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8681d4cffcd23bbe619984ab62772a91827a40dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8681d4cffcd23bbe619984ab62772a91827a40dc", "html_url": "https://github.com/rust-lang/rust/commit/8681d4cffcd23bbe619984ab62772a91827a40dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8681d4cffcd23bbe619984ab62772a91827a40dc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "051cab2b842113b18da28259f4b85d0a7556f7f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/051cab2b842113b18da28259f4b85d0a7556f7f1", "html_url": "https://github.com/rust-lang/rust/commit/051cab2b842113b18da28259f4b85d0a7556f7f1"}, {"sha": "12e1b84e95c05885d9f4714fe6dc2fceab0d2fe2", "url": "https://api.github.com/repos/rust-lang/rust/commits/12e1b84e95c05885d9f4714fe6dc2fceab0d2fe2", "html_url": "https://github.com/rust-lang/rust/commit/12e1b84e95c05885d9f4714fe6dc2fceab0d2fe2"}], "stats": {"total": 551, "additions": 251, "deletions": 300}, "files": [{"sha": "762430c6187216b8ff2b66ee8832eef2a9c921e4", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8681d4cffcd23bbe619984ab62772a91827a40dc/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8681d4cffcd23bbe619984ab62772a91827a40dc/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=8681d4cffcd23bbe619984ab62772a91827a40dc", "patch": "@@ -676,17 +676,18 @@ fn link_dwarf_object<'a>(\n             thorin::MissingReferencedObjectBehaviour::Skip,\n         )?;\n \n-        let output = package.finish()?.write()?;\n-        let mut output_stream = BufWriter::new(\n+        let output_stream = BufWriter::new(\n             OpenOptions::new()\n                 .read(true)\n                 .write(true)\n                 .create(true)\n                 .truncate(true)\n                 .open(dwp_out_filename)?,\n         );\n-        output_stream.write_all(&output)?;\n-        output_stream.flush()?;\n+        let mut output_stream = object::write::StreamingBuffer::new(output_stream);\n+        package.finish()?.emit(&mut output_stream)?;\n+        output_stream.result()?;\n+        output_stream.into_inner().flush()?;\n \n         Ok(())\n     }) {"}, {"sha": "8955abebf1e0f0d116d100e84ba1f0b1e9c12e3d", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8681d4cffcd23bbe619984ab62772a91827a40dc/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8681d4cffcd23bbe619984ab62772a91827a40dc/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=8681d4cffcd23bbe619984ab62772a91827a40dc", "patch": "@@ -676,8 +676,13 @@ pub enum SyntaxExtensionKind {\n \n     /// A token-based derive macro.\n     Derive(\n-        /// An expander with signature TokenStream -> TokenStream (not yet).\n+        /// An expander with signature TokenStream -> TokenStream.\n         /// The produced TokenSteam is appended to the input TokenSteam.\n+        ///\n+        /// FIXME: The text above describes how this should work. Currently it\n+        /// is handled identically to `LegacyDerive`. It should be migrated to\n+        /// a token-based representation like `Bang` and `Attr`, instead of\n+        /// using `MultiItemModifier`.\n         Box<dyn MultiItemModifier + sync::Sync + sync::Send>,\n     ),\n "}, {"sha": "6d858eacb45a38fc0cf1a307c7df01ae507cc998", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8681d4cffcd23bbe619984ab62772a91827a40dc/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8681d4cffcd23bbe619984ab62772a91827a40dc/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=8681d4cffcd23bbe619984ab62772a91827a40dc", "patch": "@@ -31,6 +31,7 @@ use rustc_span::lev_distance::{\n use rustc_span::symbol::sym;\n use rustc_span::{symbol::Ident, Span, Symbol, DUMMY_SP};\n use rustc_trait_selection::autoderef::{self, Autoderef};\n+use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::query::method_autoderef::MethodAutoderefBadTy;\n use rustc_trait_selection::traits::query::method_autoderef::{\n@@ -716,9 +717,10 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             // maybe shouldn't include `Param`s, but rather fresh variables or be canonicalized,\n             // see issue #89650\n             let cause = traits::ObligationCause::misc(self.span, self.body_id);\n-            let selcx = &mut traits::SelectionContext::new(self.fcx);\n-            let traits::Normalized { value: xform_self_ty, obligations } =\n-                traits::normalize(selcx, self.param_env, cause, xform_self_ty);\n+            let InferOk { value: xform_self_ty, obligations } = self\n+                .fcx\n+                .partially_normalize_associated_types_in(cause, self.param_env, xform_self_ty);\n+\n             debug!(\n                 \"assemble_inherent_impl_probe after normalization: xform_self_ty = {:?}/{:?}\",\n                 xform_self_ty, xform_ret_ty\n@@ -1490,7 +1492,6 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             let mut xform_ret_ty = probe.xform_ret_ty;\n             debug!(?xform_ret_ty);\n \n-            let selcx = &mut traits::SelectionContext::new(self);\n             let cause = traits::ObligationCause::misc(self.span, self.body_id);\n \n             let mut parent_pred = None;\n@@ -1504,19 +1505,28 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     // `xform_ret_ty` hasn't been normalized yet, only `xform_self_ty`,\n                     // see the reasons mentioned in the comments in `assemble_inherent_impl_probe`\n                     // for why this is necessary\n-                    let traits::Normalized {\n+                    let InferOk {\n                         value: normalized_xform_ret_ty,\n                         obligations: normalization_obligations,\n-                    } = traits::normalize(selcx, self.param_env, cause.clone(), probe.xform_ret_ty);\n+                    } = self.fcx.partially_normalize_associated_types_in(\n+                        cause.clone(),\n+                        self.param_env,\n+                        probe.xform_ret_ty,\n+                    );\n                     xform_ret_ty = normalized_xform_ret_ty;\n                     debug!(\"xform_ret_ty after normalization: {:?}\", xform_ret_ty);\n \n                     // Check whether the impl imposes obligations we have to worry about.\n                     let impl_def_id = probe.item.container_id(self.tcx);\n                     let impl_bounds = self.tcx.predicates_of(impl_def_id);\n                     let impl_bounds = impl_bounds.instantiate(self.tcx, substs);\n-                    let traits::Normalized { value: impl_bounds, obligations: norm_obligations } =\n-                        traits::normalize(selcx, self.param_env, cause.clone(), impl_bounds);\n+\n+                    let InferOk { value: impl_bounds, obligations: norm_obligations } =\n+                        self.fcx.partially_normalize_associated_types_in(\n+                            cause.clone(),\n+                            self.param_env,\n+                            impl_bounds,\n+                        );\n \n                     // Convert the bounds into obligations.\n                     let impl_obligations = traits::predicates_for_generics("}, {"sha": "26f3052b642b27d6af86b56a5d87a14b420347d6", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8681d4cffcd23bbe619984ab62772a91827a40dc/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8681d4cffcd23bbe619984ab62772a91827a40dc/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=8681d4cffcd23bbe619984ab62772a91827a40dc", "patch": "@@ -651,12 +651,6 @@ pub enum ImplSource<'tcx, N> {\n     /// Same as above, but for a function pointer type with the given signature.\n     FnPointer(ImplSourceFnPointerData<'tcx, N>),\n \n-    /// ImplSource for a builtin `DeterminantKind` trait implementation.\n-    DiscriminantKind(ImplSourceDiscriminantKindData),\n-\n-    /// ImplSource for a builtin `Pointee` trait implementation.\n-    Pointee(ImplSourcePointeeData),\n-\n     /// ImplSource automatically generated for a generator.\n     Generator(ImplSourceGeneratorData<'tcx, N>),\n \n@@ -682,8 +676,6 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n             ImplSource::Future(c) => c.nested,\n             ImplSource::Object(d) => d.nested,\n             ImplSource::FnPointer(d) => d.nested,\n-            ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData)\n-            | ImplSource::Pointee(ImplSourcePointeeData) => vec![],\n             ImplSource::TraitAlias(d) => d.nested,\n             ImplSource::TraitUpcasting(d) => d.nested,\n             ImplSource::ConstDestruct(i) => i.nested,\n@@ -701,8 +693,6 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n             ImplSource::Future(c) => &c.nested,\n             ImplSource::Object(d) => &d.nested,\n             ImplSource::FnPointer(d) => &d.nested,\n-            ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData)\n-            | ImplSource::Pointee(ImplSourcePointeeData) => &[],\n             ImplSource::TraitAlias(d) => &d.nested,\n             ImplSource::TraitUpcasting(d) => &d.nested,\n             ImplSource::ConstDestruct(i) => &i.nested,\n@@ -751,12 +741,6 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n                 fn_ty: p.fn_ty,\n                 nested: p.nested.into_iter().map(f).collect(),\n             }),\n-            ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData) => {\n-                ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData)\n-            }\n-            ImplSource::Pointee(ImplSourcePointeeData) => {\n-                ImplSource::Pointee(ImplSourcePointeeData)\n-            }\n             ImplSource::TraitAlias(d) => ImplSource::TraitAlias(ImplSourceTraitAliasData {\n                 alias_def_id: d.alias_def_id,\n                 substs: d.substs,\n@@ -876,13 +860,6 @@ pub struct ImplSourceFnPointerData<'tcx, N> {\n     pub nested: Vec<N>,\n }\n \n-// FIXME(@lcnr): This should be  refactored and merged with other builtin vtables.\n-#[derive(Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n-pub struct ImplSourceDiscriminantKindData;\n-\n-#[derive(Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n-pub struct ImplSourcePointeeData;\n-\n #[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, Lift)]\n #[derive(TypeFoldable, TypeVisitable)]\n pub struct ImplSourceConstDestructData<N> {"}, {"sha": "ec69864c951d4df347bb0befaf12df9587561fae", "filename": "compiler/rustc_middle/src/traits/select.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8681d4cffcd23bbe619984ab62772a91827a40dc/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8681d4cffcd23bbe619984ab62772a91827a40dc/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs?ref=8681d4cffcd23bbe619984ab62772a91827a40dc", "patch": "@@ -105,6 +105,12 @@ pub type EvaluationCache<'tcx> = Cache<\n /// parameter environment.\n #[derive(PartialEq, Eq, Debug, Clone, TypeFoldable, TypeVisitable)]\n pub enum SelectionCandidate<'tcx> {\n+    /// A builtin implementation for some specific traits, used in cases\n+    /// where we cannot rely an ordinary library implementations.\n+    ///\n+    /// The most notable examples are `sized`, `Copy` and `Clone`. This is also\n+    /// used for the `DiscriminantKind` and `Pointee` trait, both of which have\n+    /// an associated type.\n     BuiltinCandidate {\n         /// `false` if there are no *further* obligations.\n         has_nested: bool,\n@@ -141,12 +147,6 @@ pub enum SelectionCandidate<'tcx> {\n         is_const: bool,\n     },\n \n-    /// Builtin implementation of `DiscriminantKind`.\n-    DiscriminantKindCandidate,\n-\n-    /// Builtin implementation of `Pointee`.\n-    PointeeCandidate,\n-\n     TraitAliasCandidate,\n \n     /// Matching `dyn Trait` with a supertrait of `Trait`. The index is the"}, {"sha": "6acb7745d654e9552b8adc86c4a61418957c40d0", "filename": "compiler/rustc_middle/src/traits/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8681d4cffcd23bbe619984ab62772a91827a40dc/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8681d4cffcd23bbe619984ab62772a91827a40dc/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs?ref=8681d4cffcd23bbe619984ab62772a91827a40dc", "patch": "@@ -19,10 +19,6 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSource<'tcx, N> {\n \n             super::ImplSource::FnPointer(ref d) => write!(f, \"({:?})\", d),\n \n-            super::ImplSource::DiscriminantKind(ref d) => write!(f, \"{:?}\", d),\n-\n-            super::ImplSource::Pointee(ref d) => write!(f, \"{:?}\", d),\n-\n             super::ImplSource::Object(ref d) => write!(f, \"{:?}\", d),\n \n             super::ImplSource::Param(ref n, ct) => {\n@@ -137,11 +133,3 @@ impl<N: fmt::Debug> fmt::Debug for traits::ImplSourceConstDestructData<N> {\n         write!(f, \"ImplSourceConstDestructData(nested={:?})\", self.nested)\n     }\n }\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Lift implementations\n-\n-TrivialTypeTraversalAndLiftImpls! {\n-    super::ImplSourceDiscriminantKindData,\n-    super::ImplSourcePointeeData,\n-}"}, {"sha": "4ac53f6302fbf0bf75185c739318518cd47f53b2", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8681d4cffcd23bbe619984ab62772a91827a40dc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8681d4cffcd23bbe619984ab62772a91827a40dc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=8681d4cffcd23bbe619984ab62772a91827a40dc", "patch": "@@ -9,6 +9,7 @@ use super::{\n };\n use crate::infer::error_reporting::{TyCategory, TypeAnnotationNeeded as ErrorCode};\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use crate::infer::InferCtxtExt as _;\n use crate::infer::{self, InferCtxt, TyCtxtInferExt};\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n use crate::traits::query::normalize::AtExt as _;\n@@ -28,7 +29,7 @@ use rustc_hir::GenericParam;\n use rustc_hir::Item;\n use rustc_hir::Node;\n use rustc_infer::infer::error_reporting::TypeErrCtxt;\n-use rustc_infer::infer::TypeTrace;\n+use rustc_infer::infer::{InferOk, TypeTrace};\n use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::error::ExpectedFound;\n@@ -2530,18 +2531,15 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         }\n \n         self.probe(|_| {\n-            let mut selcx = SelectionContext::new(self);\n-\n             let cleaned_pred =\n                 pred.fold_with(&mut ParamToVarFolder { infcx: self, var_map: Default::default() });\n \n-            let cleaned_pred = super::project::normalize(\n-                &mut selcx,\n-                param_env,\n-                ObligationCause::dummy(),\n-                cleaned_pred,\n-            )\n-            .value;\n+            let InferOk { value: cleaned_pred, .. } =\n+                self.infcx.partially_normalize_associated_types_in(\n+                    ObligationCause::dummy(),\n+                    param_env,\n+                    cleaned_pred,\n+                );\n \n             let obligation =\n                 Obligation::new(self.tcx, ObligationCause::dummy(), param_env, cleaned_pred);"}, {"sha": "5c13b6400aebe95822faa1c593dc49a06bd495fa", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8681d4cffcd23bbe619984ab62772a91827a40dc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8681d4cffcd23bbe619984ab62772a91827a40dc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=8681d4cffcd23bbe619984ab62772a91827a40dc", "patch": "@@ -1,11 +1,7 @@\n-use super::{\n-    DefIdOrName, Obligation, ObligationCause, ObligationCauseCode, PredicateObligation,\n-    SelectionContext,\n-};\n+use super::{DefIdOrName, Obligation, ObligationCause, ObligationCauseCode, PredicateObligation};\n \n use crate::autoderef::Autoderef;\n use crate::infer::InferCtxt;\n-use crate::traits::normalize_to;\n \n use hir::def::CtorOf;\n use hir::HirId;\n@@ -23,7 +19,7 @@ use rustc_hir::lang_items::LangItem;\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, Node};\n use rustc_infer::infer::error_reporting::TypeErrCtxt;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::LateBoundRegionConversionTime;\n+use rustc_infer::infer::{InferOk, LateBoundRegionConversionTime};\n use rustc_middle::hir::map;\n use rustc_middle::ty::{\n     self, suggest_arbitrary_trait_bound, suggest_constraining_type_param, AdtKind, DefIdTree,\n@@ -2979,13 +2975,12 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         self.tcx.mk_substs_trait(trait_pred.self_ty(), []),\n                     )\n                 });\n-                let projection_ty = normalize_to(\n-                    &mut SelectionContext::new(self),\n-                    obligation.param_env,\n-                    obligation.cause.clone(),\n-                    projection_ty,\n-                    &mut vec![],\n-                );\n+                let InferOk { value: projection_ty, .. } = self\n+                    .partially_normalize_associated_types_in(\n+                        obligation.cause.clone(),\n+                        obligation.param_env,\n+                        projection_ty,\n+                    );\n \n                 debug!(\n                     normalized_projection_type = ?self.resolve_vars_if_possible(projection_ty)"}, {"sha": "ae6fa841856cb4d70c2c7ac3328ee40dce51fae2", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 156, "deletions": 176, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/8681d4cffcd23bbe619984ab62772a91827a40dc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8681d4cffcd23bbe619984ab62772a91827a40dc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=8681d4cffcd23bbe619984ab62772a91827a40dc", "patch": "@@ -11,8 +11,7 @@ use super::Selection;\n use super::SelectionContext;\n use super::SelectionError;\n use super::{\n-    ImplSourceClosureData, ImplSourceDiscriminantKindData, ImplSourceFnPointerData,\n-    ImplSourceFutureData, ImplSourceGeneratorData, ImplSourcePointeeData,\n+    ImplSourceClosureData, ImplSourceFnPointerData, ImplSourceFutureData, ImplSourceGeneratorData,\n     ImplSourceUserDefinedData,\n };\n use super::{Normalized, NormalizedTy, ProjectionCacheEntry, ProjectionCacheKey};\n@@ -29,6 +28,7 @@ use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_infer::infer::resolve::OpportunisticRegionResolver;\n+use rustc_infer::traits::ImplSourceBuiltinData;\n use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::visit::{MaxUniverse, TypeVisitable};\n@@ -1599,128 +1599,126 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                     }\n                 }\n             }\n-            super::ImplSource::DiscriminantKind(..) => {\n-                // While `DiscriminantKind` is automatically implemented for every type,\n-                // the concrete discriminant may not be known yet.\n-                //\n-                // Any type with multiple potential discriminant types is therefore not eligible.\n+            super::ImplSource::Builtin(..) => {\n+                // While a builtin impl may be known to exist, the associated type may not yet\n+                // be known. Any type with multiple potential associated types is therefore\n+                // not eligible.\n                 let self_ty = selcx.infcx().shallow_resolve(obligation.predicate.self_ty());\n \n-                match self_ty.kind() {\n-                    ty::Bool\n-                    | ty::Char\n-                    | ty::Int(_)\n-                    | ty::Uint(_)\n-                    | ty::Float(_)\n-                    | ty::Adt(..)\n-                    | ty::Foreign(_)\n-                    | ty::Str\n-                    | ty::Array(..)\n-                    | ty::Slice(_)\n-                    | ty::RawPtr(..)\n-                    | ty::Ref(..)\n-                    | ty::FnDef(..)\n-                    | ty::FnPtr(..)\n-                    | ty::Dynamic(..)\n-                    | ty::Closure(..)\n-                    | ty::Generator(..)\n-                    | ty::GeneratorWitness(..)\n-                    | ty::Never\n-                    | ty::Tuple(..)\n-                    // Integers and floats always have `u8` as their discriminant.\n-                    | ty::Infer(ty::InferTy::IntVar(_) | ty::InferTy::FloatVar(..)) => true,\n-\n-                    ty::Projection(..)\n-                    | ty::Opaque(..)\n-                    | ty::Param(..)\n-                    | ty::Bound(..)\n-                    | ty::Placeholder(..)\n-                    | ty::Infer(..)\n-                    | ty::Error(_) => false,\n-                }\n-            }\n-            super::ImplSource::Pointee(..) => {\n-                // While `Pointee` is automatically implemented for every type,\n-                // the concrete metadata type may not be known yet.\n-                //\n-                // Any type with multiple potential metadata types is therefore not eligible.\n-                let self_ty = selcx.infcx().shallow_resolve(obligation.predicate.self_ty());\n-\n-                let tail = selcx.tcx().struct_tail_with_normalize(\n-                    self_ty,\n-                    |ty| {\n-                        // We throw away any obligations we get from this, since we normalize\n-                        // and confirm these obligations once again during confirmation\n-                        normalize_with_depth(\n-                            selcx,\n-                            obligation.param_env,\n-                            obligation.cause.clone(),\n-                            obligation.recursion_depth + 1,\n-                            ty,\n-                        )\n-                        .value\n-                    },\n-                    || {},\n-                );\n-\n-                match tail.kind() {\n-                    ty::Bool\n-                    | ty::Char\n-                    | ty::Int(_)\n-                    | ty::Uint(_)\n-                    | ty::Float(_)\n-                    | ty::Str\n-                    | ty::Array(..)\n-                    | ty::Slice(_)\n-                    | ty::RawPtr(..)\n-                    | ty::Ref(..)\n-                    | ty::FnDef(..)\n-                    | ty::FnPtr(..)\n-                    | ty::Dynamic(..)\n-                    | ty::Closure(..)\n-                    | ty::Generator(..)\n-                    | ty::GeneratorWitness(..)\n-                    | ty::Never\n-                    // Extern types have unit metadata, according to RFC 2850\n-                    | ty::Foreign(_)\n-                    // If returned by `struct_tail_without_normalization` this is a unit struct\n-                    // without any fields, or not a struct, and therefore is Sized.\n-                    | ty::Adt(..)\n-                    // If returned by `struct_tail_without_normalization` this is the empty tuple.\n-                    | ty::Tuple(..)\n-                    // Integers and floats are always Sized, and so have unit type metadata.\n-                    | ty::Infer(ty::InferTy::IntVar(_) | ty::InferTy::FloatVar(..)) => true,\n-\n-                    // type parameters, opaques, and unnormalized projections have pointer\n-                    // metadata if they're known (e.g. by the param_env) to be sized\n-                    ty::Param(_) | ty::Projection(..) | ty::Opaque(..)\n-                        if selcx.infcx().predicate_must_hold_modulo_regions(\n-                            &obligation.with(\n-                                selcx.tcx(),\n-                                ty::Binder::dummy(selcx.tcx().at(obligation.cause.span).mk_trait_ref(\n-                                    LangItem::Sized,\n-                                    [self_ty],\n-                                ))\n-                                .without_const(),\n-                            ),\n-                        ) =>\n-                    {\n-                        true\n+                let lang_items = selcx.tcx().lang_items();\n+                if lang_items.discriminant_kind_trait() == Some(poly_trait_ref.def_id()) {\n+                    match self_ty.kind() {\n+                        ty::Bool\n+                        | ty::Char\n+                        | ty::Int(_)\n+                        | ty::Uint(_)\n+                        | ty::Float(_)\n+                        | ty::Adt(..)\n+                        | ty::Foreign(_)\n+                        | ty::Str\n+                        | ty::Array(..)\n+                        | ty::Slice(_)\n+                        | ty::RawPtr(..)\n+                        | ty::Ref(..)\n+                        | ty::FnDef(..)\n+                        | ty::FnPtr(..)\n+                        | ty::Dynamic(..)\n+                        | ty::Closure(..)\n+                        | ty::Generator(..)\n+                        | ty::GeneratorWitness(..)\n+                        | ty::Never\n+                        | ty::Tuple(..)\n+                        // Integers and floats always have `u8` as their discriminant.\n+                        | ty::Infer(ty::InferTy::IntVar(_) | ty::InferTy::FloatVar(..)) => true,\n+\n+                         // type parameters, opaques, and unnormalized projections have pointer\n+                        // metadata if they're known (e.g. by the param_env) to be sized\n+                        ty::Param(_)\n+                        | ty::Projection(..)\n+                        | ty::Opaque(..)\n+                        | ty::Bound(..)\n+                        | ty::Placeholder(..)\n+                        | ty::Infer(..)\n+                        | ty::Error(_) => false,\n                     }\n+                } else if lang_items.pointee_trait() == Some(poly_trait_ref.def_id()) {\n+                    let tail = selcx.tcx().struct_tail_with_normalize(\n+                        self_ty,\n+                        |ty| {\n+                            // We throw away any obligations we get from this, since we normalize\n+                            // and confirm these obligations once again during confirmation\n+                            normalize_with_depth(\n+                                selcx,\n+                                obligation.param_env,\n+                                obligation.cause.clone(),\n+                                obligation.recursion_depth + 1,\n+                                ty,\n+                            )\n+                            .value\n+                        },\n+                        || {},\n+                    );\n \n-                    // FIXME(compiler-errors): are Bound and Placeholder types ever known sized?\n-                    ty::Param(_)\n-                    | ty::Projection(..)\n-                    | ty::Opaque(..)\n-                    | ty::Bound(..)\n-                    | ty::Placeholder(..)\n-                    | ty::Infer(..)\n-                    | ty::Error(_) => {\n-                        if tail.has_infer_types() {\n-                            candidate_set.mark_ambiguous();\n+                    match tail.kind() {\n+                        ty::Bool\n+                        | ty::Char\n+                        | ty::Int(_)\n+                        | ty::Uint(_)\n+                        | ty::Float(_)\n+                        | ty::Str\n+                        | ty::Array(..)\n+                        | ty::Slice(_)\n+                        | ty::RawPtr(..)\n+                        | ty::Ref(..)\n+                        | ty::FnDef(..)\n+                        | ty::FnPtr(..)\n+                        | ty::Dynamic(..)\n+                        | ty::Closure(..)\n+                        | ty::Generator(..)\n+                        | ty::GeneratorWitness(..)\n+                        | ty::Never\n+                        // Extern types have unit metadata, according to RFC 2850\n+                        | ty::Foreign(_)\n+                        // If returned by `struct_tail_without_normalization` this is a unit struct\n+                        // without any fields, or not a struct, and therefore is Sized.\n+                        | ty::Adt(..)\n+                        // If returned by `struct_tail_without_normalization` this is the empty tuple.\n+                        | ty::Tuple(..)\n+                        // Integers and floats are always Sized, and so have unit type metadata.\n+                        | ty::Infer(ty::InferTy::IntVar(_) | ty::InferTy::FloatVar(..)) => true,\n+\n+                        // type parameters, opaques, and unnormalized projections have pointer\n+                        // metadata if they're known (e.g. by the param_env) to be sized\n+                        ty::Param(_) | ty::Projection(..) | ty::Opaque(..)\n+                            if selcx.infcx().predicate_must_hold_modulo_regions(\n+                                &obligation.with(\n+                                    selcx.tcx(),\n+                                    ty::Binder::dummy(\n+                                        selcx.tcx().at(obligation.cause.span()).mk_trait_ref(LangItem::Sized, [self_ty]),\n+                                    )\n+                                    .without_const(),\n+                                ),\n+                            ) =>\n+                        {\n+                            true\n+                        }\n+\n+                        // FIXME(compiler-errors): are Bound and Placeholder types ever known sized?\n+                        ty::Param(_)\n+                        | ty::Projection(..)\n+                        | ty::Opaque(..)\n+                        | ty::Bound(..)\n+                        | ty::Placeholder(..)\n+                        | ty::Infer(..)\n+                        | ty::Error(_) => {\n+                            if tail.has_infer_types() {\n+                                candidate_set.mark_ambiguous();\n+                            }\n+                            false\n                         }\n-                        false\n                     }\n+                } else {\n+                    bug!(\"unexpected builtin trait with associated type: {poly_trait_ref:?}\")\n                 }\n             }\n             super::ImplSource::Param(..) => {\n@@ -1758,7 +1756,6 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 false\n             }\n             super::ImplSource::AutoImpl(..)\n-            | super::ImplSource::Builtin(..)\n             | super::ImplSource::TraitUpcasting(_)\n             | super::ImplSource::ConstDestruct(_) => {\n                 // These traits have no associated types.\n@@ -1838,14 +1835,10 @@ fn confirm_select_candidate<'cx, 'tcx>(\n         super::ImplSource::Future(data) => confirm_future_candidate(selcx, obligation, data),\n         super::ImplSource::Closure(data) => confirm_closure_candidate(selcx, obligation, data),\n         super::ImplSource::FnPointer(data) => confirm_fn_pointer_candidate(selcx, obligation, data),\n-        super::ImplSource::DiscriminantKind(data) => {\n-            confirm_discriminant_kind_candidate(selcx, obligation, data)\n-        }\n-        super::ImplSource::Pointee(data) => confirm_pointee_candidate(selcx, obligation, data),\n+        super::ImplSource::Builtin(data) => confirm_builtin_candidate(selcx, obligation, data),\n         super::ImplSource::Object(_)\n         | super::ImplSource::AutoImpl(..)\n         | super::ImplSource::Param(..)\n-        | super::ImplSource::Builtin(..)\n         | super::ImplSource::TraitUpcasting(_)\n         | super::ImplSource::TraitAlias(..)\n         | super::ImplSource::ConstDestruct(_) => {\n@@ -1951,68 +1944,55 @@ fn confirm_future_candidate<'cx, 'tcx>(\n         .with_addl_obligations(obligations)\n }\n \n-fn confirm_discriminant_kind_candidate<'cx, 'tcx>(\n+fn confirm_builtin_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    _: ImplSourceDiscriminantKindData,\n+    data: ImplSourceBuiltinData<PredicateObligation<'tcx>>,\n ) -> Progress<'tcx> {\n     let tcx = selcx.tcx();\n-\n-    let self_ty = selcx.infcx().shallow_resolve(obligation.predicate.self_ty());\n-    // We get here from `poly_project_and_unify_type` which replaces bound vars\n-    // with placeholders\n-    debug_assert!(!self_ty.has_escaping_bound_vars());\n+    let self_ty = obligation.predicate.self_ty();\n     let substs = tcx.mk_substs([self_ty.into()].iter());\n-\n-    let discriminant_def_id = tcx.require_lang_item(LangItem::Discriminant, None);\n-\n-    let predicate = ty::ProjectionPredicate {\n-        projection_ty: ty::ProjectionTy { substs, item_def_id: discriminant_def_id },\n-        term: self_ty.discriminant_ty(tcx).into(),\n+    let lang_items = tcx.lang_items();\n+    let item_def_id = obligation.predicate.item_def_id;\n+    let trait_def_id = tcx.trait_of_item(item_def_id).unwrap();\n+    let (term, obligations) = if lang_items.discriminant_kind_trait() == Some(trait_def_id) {\n+        let discriminant_def_id = tcx.require_lang_item(LangItem::Discriminant, None);\n+        assert_eq!(discriminant_def_id, item_def_id);\n+\n+        (self_ty.discriminant_ty(tcx).into(), Vec::new())\n+    } else if lang_items.pointee_trait() == Some(trait_def_id) {\n+        let metadata_def_id = tcx.require_lang_item(LangItem::Metadata, None);\n+        assert_eq!(metadata_def_id, item_def_id);\n+\n+        let mut obligations = Vec::new();\n+        let (metadata_ty, check_is_sized) = self_ty.ptr_metadata_ty(tcx, |ty| {\n+            normalize_with_depth_to(\n+                selcx,\n+                obligation.param_env,\n+                obligation.cause.clone(),\n+                obligation.recursion_depth + 1,\n+                ty,\n+                &mut obligations,\n+            )\n+        });\n+        if check_is_sized {\n+            let sized_predicate = ty::Binder::dummy(\n+                tcx.at(obligation.cause.span()).mk_trait_ref(LangItem::Sized, [self_ty]),\n+            )\n+            .without_const();\n+            obligations.push(obligation.with(tcx, sized_predicate));\n+        }\n+        (metadata_ty.into(), obligations)\n+    } else {\n+        bug!(\"unexpected builtin trait with associated type: {:?}\", obligation.predicate);\n     };\n \n-    // We get here from `poly_project_and_unify_type` which replaces bound vars\n-    // with placeholders, so dummy is okay here.\n-    confirm_param_env_candidate(selcx, obligation, ty::Binder::dummy(predicate), false)\n-}\n-\n-fn confirm_pointee_candidate<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    obligation: &ProjectionTyObligation<'tcx>,\n-    _: ImplSourcePointeeData,\n-) -> Progress<'tcx> {\n-    let tcx = selcx.tcx();\n-    let self_ty = selcx.infcx().shallow_resolve(obligation.predicate.self_ty());\n-\n-    let mut obligations = vec![];\n-    let (metadata_ty, check_is_sized) = self_ty.ptr_metadata_ty(tcx, |ty| {\n-        normalize_with_depth_to(\n-            selcx,\n-            obligation.param_env,\n-            obligation.cause.clone(),\n-            obligation.recursion_depth + 1,\n-            ty,\n-            &mut obligations,\n-        )\n-    });\n-    if check_is_sized {\n-        let sized_predicate = ty::Binder::dummy(\n-            tcx.at(obligation.cause.span).mk_trait_ref(LangItem::Sized, [self_ty]),\n-        )\n-        .without_const();\n-        obligations.push(obligation.with(tcx, sized_predicate));\n-    }\n-\n-    let substs = tcx.mk_substs([self_ty.into()].iter());\n-    let metadata_def_id = tcx.require_lang_item(LangItem::Metadata, Some(obligation.cause.span));\n-\n-    let predicate = ty::ProjectionPredicate {\n-        projection_ty: ty::ProjectionTy { substs, item_def_id: metadata_def_id },\n-        term: metadata_ty.into(),\n-    };\n+    let predicate =\n+        ty::ProjectionPredicate { projection_ty: ty::ProjectionTy { substs, item_def_id }, term };\n \n     confirm_param_env_candidate(selcx, obligation, ty::Binder::dummy(predicate), false)\n         .with_addl_obligations(obligations)\n+        .with_addl_obligations(data.nested)\n }\n \n fn confirm_fn_pointer_candidate<'cx, 'tcx>("}, {"sha": "f8c7a896b530b13fa692be232fd4134074ffdb1e", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8681d4cffcd23bbe619984ab62772a91827a40dc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8681d4cffcd23bbe619984ab62772a91827a40dc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=8681d4cffcd23bbe619984ab62772a91827a40dc", "patch": "@@ -282,10 +282,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.assemble_builtin_bound_candidates(copy_conditions, &mut candidates);\n             } else if lang_items.discriminant_kind_trait() == Some(def_id) {\n                 // `DiscriminantKind` is automatically implemented for every type.\n-                candidates.vec.push(DiscriminantKindCandidate);\n+                candidates.vec.push(BuiltinCandidate { has_nested: false });\n             } else if lang_items.pointee_trait() == Some(def_id) {\n                 // `Pointee` is automatically implemented for every type.\n-                candidates.vec.push(PointeeCandidate);\n+                candidates.vec.push(BuiltinCandidate { has_nested: false });\n             } else if lang_items.sized_trait() == Some(def_id) {\n                 // Sized is never implementable by end-users, it is\n                 // always automatically computed."}, {"sha": "8c589aa8cd1dedaccf7789f8a492cde8c1811ed1", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8681d4cffcd23bbe619984ab62772a91827a40dc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8681d4cffcd23bbe619984ab62772a91827a40dc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=8681d4cffcd23bbe619984ab62772a91827a40dc", "patch": "@@ -22,12 +22,11 @@ use crate::traits::util::{self, closure_trait_ref_and_return_type, predicate_for\n use crate::traits::{\n     BuiltinDerivedObligation, ImplDerivedObligation, ImplDerivedObligationCause, ImplSource,\n     ImplSourceAutoImplData, ImplSourceBuiltinData, ImplSourceClosureData,\n-    ImplSourceConstDestructData, ImplSourceDiscriminantKindData, ImplSourceFnPointerData,\n-    ImplSourceFutureData, ImplSourceGeneratorData, ImplSourceObjectData, ImplSourcePointeeData,\n-    ImplSourceTraitAliasData, ImplSourceTraitUpcastingData, ImplSourceUserDefinedData, Normalized,\n-    ObjectCastObligation, Obligation, ObligationCause, OutputTypeParameterMismatch,\n-    PredicateObligation, Selection, SelectionError, TraitNotObjectSafe, TraitObligation,\n-    Unimplemented, VtblSegment,\n+    ImplSourceConstDestructData, ImplSourceFnPointerData, ImplSourceFutureData,\n+    ImplSourceGeneratorData, ImplSourceObjectData, ImplSourceTraitAliasData,\n+    ImplSourceTraitUpcastingData, ImplSourceUserDefinedData, Normalized, ObjectCastObligation,\n+    Obligation, ObligationCause, OutputTypeParameterMismatch, PredicateObligation, Selection,\n+    SelectionError, TraitNotObjectSafe, TraitObligation, Unimplemented, VtblSegment,\n };\n \n use super::BuiltinImplConditions;\n@@ -100,12 +99,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ImplSource::FnPointer(data)\n             }\n \n-            DiscriminantKindCandidate => {\n-                ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData)\n-            }\n-\n-            PointeeCandidate => ImplSource::Pointee(ImplSourcePointeeData),\n-\n             TraitAliasCandidate => {\n                 let data = self.confirm_trait_alias_candidate(obligation);\n                 ImplSource::TraitAlias(data)"}, {"sha": "3c8f8b5642c9e3fc63529cd22891d847e857a387", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8681d4cffcd23bbe619984ab62772a91827a40dc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8681d4cffcd23bbe619984ab62772a91827a40dc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=8681d4cffcd23bbe619984ab62772a91827a40dc", "patch": "@@ -1573,20 +1573,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             (TransmutabilityCandidate, _) | (_, TransmutabilityCandidate) => false,\n \n             // (*)\n-            (\n-                BuiltinCandidate { has_nested: false }\n-                | DiscriminantKindCandidate\n-                | PointeeCandidate\n-                | ConstDestructCandidate(_),\n-                _,\n-            ) => true,\n-            (\n-                _,\n-                BuiltinCandidate { has_nested: false }\n-                | DiscriminantKindCandidate\n-                | PointeeCandidate\n-                | ConstDestructCandidate(_),\n-            ) => false,\n+            (BuiltinCandidate { has_nested: false } | ConstDestructCandidate(_), _) => true,\n+            (_, BuiltinCandidate { has_nested: false } | ConstDestructCandidate(_)) => false,\n \n             (ParamCandidate(other), ParamCandidate(victim)) => {\n                 let same_except_bound_vars = other.skip_binder().trait_ref"}, {"sha": "dae7d589d5cca75189bfcf6dc49d4fcf996a6b95", "filename": "compiler/rustc_trait_selection/src/traits/util.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8681d4cffcd23bbe619984ab62772a91827a40dc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8681d4cffcd23bbe619984ab62772a91827a40dc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs?ref=8681d4cffcd23bbe619984ab62772a91827a40dc", "patch": "@@ -8,7 +8,9 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::ty::{self, ImplSubject, ToPredicate, Ty, TyCtxt, TypeVisitable};\n use rustc_middle::ty::{GenericArg, SubstsRef};\n \n-use super::{Normalized, Obligation, ObligationCause, PredicateObligation, SelectionContext};\n+use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext};\n+use crate::infer::InferCtxtExt;\n+use rustc_infer::infer::InferOk;\n pub use rustc_infer::traits::{self, util::*};\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -200,13 +202,15 @@ pub fn impl_subject_and_oblig<'a, 'tcx>(\n ) -> (ImplSubject<'tcx>, impl Iterator<Item = PredicateObligation<'tcx>>) {\n     let subject = selcx.tcx().bound_impl_subject(impl_def_id);\n     let subject = subject.subst(selcx.tcx(), impl_substs);\n-    let Normalized { value: subject, obligations: normalization_obligations1 } =\n-        super::normalize(selcx, param_env, ObligationCause::dummy(), subject);\n+    let InferOk { value: subject, obligations: normalization_obligations1 } = selcx\n+        .infcx()\n+        .partially_normalize_associated_types_in(ObligationCause::dummy(), param_env, subject);\n \n     let predicates = selcx.tcx().predicates_of(impl_def_id);\n     let predicates = predicates.instantiate(selcx.tcx(), impl_substs);\n-    let Normalized { value: predicates, obligations: normalization_obligations2 } =\n-        super::normalize(selcx, param_env, ObligationCause::dummy(), predicates);\n+    let InferOk { value: predicates, obligations: normalization_obligations2 } = selcx\n+        .infcx()\n+        .partially_normalize_associated_types_in(ObligationCause::dummy(), param_env, predicates);\n     let impl_obligations =\n         super::predicates_for_generics(|_, _| ObligationCause::dummy(), param_env, predicates);\n "}, {"sha": "4a887bc591827f0c77cf5f09e57a4890bac24e9a", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8681d4cffcd23bbe619984ab62772a91827a40dc/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8681d4cffcd23bbe619984ab62772a91827a40dc/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=8681d4cffcd23bbe619984ab62772a91827a40dc", "patch": "@@ -270,8 +270,6 @@ fn resolve_associated_item<'tcx>(\n         traits::ImplSource::AutoImpl(..)\n         | traits::ImplSource::Param(..)\n         | traits::ImplSource::TraitAlias(..)\n-        | traits::ImplSource::DiscriminantKind(..)\n-        | traits::ImplSource::Pointee(..)\n         | traits::ImplSource::TraitUpcasting(_)\n         | traits::ImplSource::ConstDestruct(_) => None,\n     })"}, {"sha": "2c6fd1e1d4dd4e19edd1a10c3f9b09bd9afec634", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8681d4cffcd23bbe619984ab62772a91827a40dc/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8681d4cffcd23bbe619984ab62772a91827a40dc/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=8681d4cffcd23bbe619984ab62772a91827a40dc", "patch": "@@ -458,7 +458,9 @@ impl Step for Std {\n \n         t!(fs::create_dir_all(&out));\n \n-        builder.ensure(SharedAssets { target: self.target });\n+        if self.format == DocumentationFormat::HTML {\n+            builder.ensure(SharedAssets { target: self.target });\n+        }\n \n         let index_page = builder.src.join(\"src/doc/index.md\").into_os_string();\n         let mut extra_args = match self.format {"}, {"sha": "a69979d7f073a83d7ae2da771110c0ef39cc52da", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8681d4cffcd23bbe619984ab62772a91827a40dc/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8681d4cffcd23bbe619984ab62772a91827a40dc/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=8681d4cffcd23bbe619984ab62772a91827a40dc", "patch": "@@ -473,7 +473,7 @@ impl Miri {\n         miri: &Path,\n         target: TargetSelection,\n     ) -> String {\n-        let miri_sysroot = builder.out.join(compiler.host.triple).join(\"miri-sysrot\");\n+        let miri_sysroot = builder.out.join(compiler.host.triple).join(\"miri-sysroot\");\n         let mut cargo = tool::prepare_tool_cargo(\n             builder,\n             compiler,"}, {"sha": "063082c1c7cad58f259f5c60a169cd938c5709e3", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8681d4cffcd23bbe619984ab62772a91827a40dc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/8681d4cffcd23bbe619984ab62772a91827a40dc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=8681d4cffcd23bbe619984ab62772a91827a40dc", "patch": "@@ -1139,7 +1139,6 @@ pre.rust .doccomment {\n .example-wrap .tooltip {\n \tposition: absolute;\n \tdisplay: block;\n-\tcursor: pointer;\n \tleft: -25px;\n \ttop: 5px;\n }"}, {"sha": "78a0cdcc3bc0578d92d2ccd68a0f140bb8cece2f", "filename": "src/librustdoc/html/static/css/themes/light.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8681d4cffcd23bbe619984ab62772a91827a40dc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/8681d4cffcd23bbe619984ab62772a91827a40dc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css?ref=8681d4cffcd23bbe619984ab62772a91827a40dc", "patch": "@@ -64,7 +64,7 @@\n \t--test-arrow-hover-background-color: #4e8bca;\n \t--target-background-color: #fdffd3;\n \t--target-border-color: #ad7c37;\n-\t--tooltip-background-color: #fdffd3;\n+\t--tooltip-background-color: #000;\n \t--tooltip-color: #fff;\n \t--kbd-color: #000;\n \t--kbd-background: #fafbfc;"}, {"sha": "4d923be3e786446d12ee8879581cf1d98bdb13fc", "filename": "src/test/rustdoc-gui/codeblock-tooltip.goml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8681d4cffcd23bbe619984ab62772a91827a40dc/src%2Ftest%2Frustdoc-gui%2Fcodeblock-tooltip.goml", "raw_url": "https://github.com/rust-lang/rust/raw/8681d4cffcd23bbe619984ab62772a91827a40dc/src%2Ftest%2Frustdoc-gui%2Fcodeblock-tooltip.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fcodeblock-tooltip.goml?ref=8681d4cffcd23bbe619984ab62772a91827a40dc", "patch": "@@ -146,7 +146,7 @@ call-function: (\"check-colors\", {\n })\n call-function: (\"check-colors\", {\n     \"theme\": \"light\",\n-    \"background\": \"rgb(253, 255, 211)\",\n+    \"background\": \"rgb(0, 0, 0)\",\n     \"color\": \"rgb(255, 255, 255)\",\n     \"border\": \"rgb(224, 224, 224)\",\n })"}, {"sha": "2578bb49ad339ab465f3d0a7d8f65612a0132b63", "filename": "src/test/rustdoc-json/fns/return_type_alias.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8681d4cffcd23bbe619984ab62772a91827a40dc/src%2Ftest%2Frustdoc-json%2Ffns%2Freturn_type_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8681d4cffcd23bbe619984ab62772a91827a40dc/src%2Ftest%2Frustdoc-json%2Ffns%2Freturn_type_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Ffns%2Freturn_type_alias.rs?ref=8681d4cffcd23bbe619984ab62772a91827a40dc", "patch": "@@ -0,0 +1,10 @@\n+// Regression test for <https://github.com/rust-lang/rust/issues/104851>\n+\n+/// @set foo = \"$.index[*][?(@.name=='Foo')].id\"\n+pub type Foo = i32;\n+\n+// @is \"$.index[*][?(@.name=='demo')].inner.decl.output.kind\" '\"resolved_path\"'\n+// @is \"$.index[*][?(@.name=='demo')].inner.decl.output.inner.id\" $foo\n+pub fn demo() -> Foo {\n+    42\n+}"}, {"sha": "a533e3671223632ce916d0ec7a2dacab79103bb3", "filename": "src/tools/jsondoclint/src/item_kind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8681d4cffcd23bbe619984ab62772a91827a40dc/src%2Ftools%2Fjsondoclint%2Fsrc%2Fitem_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8681d4cffcd23bbe619984ab62772a91827a40dc/src%2Ftools%2Fjsondoclint%2Fsrc%2Fitem_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fitem_kind.rs?ref=8681d4cffcd23bbe619984ab62772a91827a40dc", "patch": "@@ -114,8 +114,8 @@ impl Kind {\n     pub fn is_trait(self) -> bool {\n         matches!(self, Kind::Trait)\n     }\n-    pub fn is_struct_enum_union(self) -> bool {\n-        matches!(self, Kind::Struct | Kind::Enum | Kind::Union)\n+    pub fn is_type(self) -> bool {\n+        matches!(self, Kind::Struct | Kind::Enum | Kind::Union | Kind::Typedef)\n     }\n \n     pub fn from_item(i: &Item) -> Self {"}, {"sha": "9548276d826fb61830c95f6bdee7b8331d2d70fa", "filename": "src/tools/jsondoclint/src/validator.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8681d4cffcd23bbe619984ab62772a91827a40dc/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8681d4cffcd23bbe619984ab62772a91827a40dc/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs?ref=8681d4cffcd23bbe619984ab62772a91827a40dc", "patch": "@@ -32,7 +32,10 @@ pub struct Validator<'a> {\n \n enum PathKind {\n     Trait,\n-    StructEnumUnion,\n+    /// Structs, Enums, Unions and Typedefs.\n+    ///\n+    /// This doesn't include trait's because traits are not types.\n+    Type,\n }\n \n impl<'a> Validator<'a> {\n@@ -224,7 +227,7 @@ impl<'a> Validator<'a> {\n \n     fn check_type(&mut self, x: &'a Type) {\n         match x {\n-            Type::ResolvedPath(path) => self.check_path(path, PathKind::StructEnumUnion),\n+            Type::ResolvedPath(path) => self.check_path(path, PathKind::Type),\n             Type::DynTrait(dyn_trait) => self.check_dyn_trait(dyn_trait),\n             Type::Generic(_) => {}\n             Type::Primitive(_) => {}\n@@ -264,7 +267,7 @@ impl<'a> Validator<'a> {\n     fn check_path(&mut self, x: &'a Path, kind: PathKind) {\n         match kind {\n             PathKind::Trait => self.add_trait_id(&x.id),\n-            PathKind::StructEnumUnion => self.add_struct_enum_union_id(&x.id),\n+            PathKind::Type => self.add_type_id(&x.id),\n         }\n         if let Some(args) = &x.args {\n             self.check_generic_args(&**args);\n@@ -392,8 +395,8 @@ impl<'a> Validator<'a> {\n         self.add_id_checked(id, Kind::is_trait, \"Trait\");\n     }\n \n-    fn add_struct_enum_union_id(&mut self, id: &'a Id) {\n-        self.add_id_checked(id, Kind::is_struct_enum_union, \"Struct or Enum or Union\");\n+    fn add_type_id(&mut self, id: &'a Id) {\n+        self.add_id_checked(id, Kind::is_type, \"Type (Struct, Enum, Union or Typedef)\");\n     }\n \n     /// Add an Id that appeared in a trait"}]}