{"sha": "e919f82da1fb9fa0409f8febede311de4a8f1703", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5MTlmODJkYTFmYjlmYTA0MDlmOGZlYmVkZTMxMWRlNGE4ZjE3MDM=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-02-22T15:34:26Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-03-03T11:10:57Z"}, "message": "Address arith-overflow and error-handling in `const_eval.rs`.\n\n 1. Detect and report arithmetic overflow during const-expr eval.\n\n 2. Instead `eval_const_expr_partial` returning `Err(String)`, it now\n    has a dedicated enum of different cases. The main benefit of this\n    is the ability to pass along an interpretable payload, namely the\n    two inputs that caused an overlfow.\n\nI attempted to minimize fallout to error output in tests, but some was\nunavoidable. Those changes are in a follow-on commit.", "tree": {"sha": "6f6afaca95486b6b6cfad1675952331630efb662", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f6afaca95486b6b6cfad1675952331630efb662"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e919f82da1fb9fa0409f8febede311de4a8f1703", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e919f82da1fb9fa0409f8febede311de4a8f1703", "html_url": "https://github.com/rust-lang/rust/commit/e919f82da1fb9fa0409f8febede311de4a8f1703", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e919f82da1fb9fa0409f8febede311de4a8f1703/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9bbef7f448ba843052eb88733c79aa36c35d5ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9bbef7f448ba843052eb88733c79aa36c35d5ab", "html_url": "https://github.com/rust-lang/rust/commit/f9bbef7f448ba843052eb88733c79aa36c35d5ab"}], "stats": {"total": 303, "additions": 234, "deletions": 69}, "files": [{"sha": "497022ac6ac49b3eb87ebfccf0a499db4722f8ba", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e919f82da1fb9fa0409f8febede311de4a8f1703/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e919f82da1fb9fa0409f8febede311de4a8f1703/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=e919f82da1fb9fa0409f8febede311de4a8f1703", "patch": "@@ -307,8 +307,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                             match const_eval::eval_const_expr_partial(self.tcx, ex, None) {\n                                 Ok(_) => {}\n                                 Err(msg) => {\n-                                    span_err!(self.tcx.sess, ex.span, E0020,\n-                                              \"{} in a constant expression\", msg)\n+                                    span_err!(self.tcx.sess, msg.span, E0020,\n+                                              \"{} in a constant expression\",\n+                                              msg.description())\n                                 }\n                             }\n                         }"}, {"sha": "51bf5a6db5bbe1bd8af6feac9c3f5e485d62e7b3", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 210, "deletions": 56, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/e919f82da1fb9fa0409f8febede311de4a8f1703/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e919f82da1fb9fa0409f8febede311de4a8f1703/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=e919f82da1fb9fa0409f8febede311de4a8f1703", "patch": "@@ -25,6 +25,7 @@ use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n use syntax::{ast_map, ast_util, codemap};\n \n+use std::borrow::{Cow, IntoCow};\n use std::num::wrapping::OverflowingOps;\n use std::cmp::Ordering;\n use std::collections::hash_map::Entry::Vacant;\n@@ -203,42 +204,193 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<ast::Pat>\n pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> const_val {\n     match eval_const_expr_partial(tcx, e, None) {\n         Ok(r) => r,\n-        Err(s) => tcx.sess.span_fatal(e.span, &s[..])\n+        Err(s) => tcx.sess.span_fatal(s.span, s.description().as_slice())\n     }\n }\n \n-fn checked_add_int(a: i64, b: i64) -> Result<const_val, String> {\n+\n+#[derive(Clone)]\n+pub struct ConstEvalErr {\n+    pub span: Span,\n+    pub kind: ErrKind,\n+}\n+\n+#[derive(Clone)]\n+pub enum ErrKind {\n+    CannotCast,\n+    CannotCastTo(&'static str),\n+    InvalidOpForBools(ast::BinOp_),\n+    InvalidOpForFloats(ast::BinOp_),\n+    InvalidOpForIntUint(ast::BinOp_),\n+    InvalidOpForUintInt(ast::BinOp_),\n+    NegateOnString,\n+    NegateOnBoolean,\n+    NotOnFloat,\n+    NotOnString,\n+\n+    AddiWithOverflow(i64, i64),\n+    SubiWithOverflow(i64, i64),\n+    MuliWithOverflow(i64, i64),\n+    AdduWithOverflow(u64, u64),\n+    SubuWithOverflow(u64, u64),\n+    MuluWithOverflow(u64, u64),\n+    DivideByZero,\n+    DivideWithOverflow,\n+    ModuloByZero,\n+    ModuloWithOverflow,\n+    MissingStructField,\n+    NonConstPath,\n+    NonConstStruct,\n+    TupleIndexOutOfBounds,\n+\n+    MiscBinaryOp,\n+    MiscCatchAll,\n+}\n+\n+impl ConstEvalErr {\n+    pub fn description(&self) -> Cow<str> {\n+        use self::ErrKind::*;\n+        match self.kind {\n+            CannotCast => \"can't cast this type\".into_cow(),\n+            CannotCastTo(s) => format!(\"can't cast this type to {}\", s).into_cow(),\n+            InvalidOpForBools(_) =>  \"can't do this op on bools\".into_cow(),\n+            InvalidOpForFloats(_) => \"can't do this op on floats\".into_cow(),\n+            InvalidOpForIntUint(..) => \"can't do this op on an int and uint\".into_cow(),\n+            InvalidOpForUintInt(..) => \"can't do this op on a uint and int\".into_cow(),\n+            NegateOnString => \"negate on string\".into_cow(),\n+            NegateOnBoolean => \"negate on boolean\".into_cow(),\n+            NotOnFloat => \"not on float or string\".into_cow(),\n+            NotOnString => \"not on float or string\".into_cow(),\n+\n+            AddiWithOverflow(..) => \"attempted to add with overflow\".into_cow(),\n+            SubiWithOverflow(..) => \"attempted to sub with overflow\".into_cow(),\n+            MuliWithOverflow(..) => \"attempted to mul with overflow\".into_cow(),\n+            AdduWithOverflow(..) => \"attempted to add with overflow\".into_cow(),\n+            SubuWithOverflow(..) => \"attempted to sub with overflow\".into_cow(),\n+            MuluWithOverflow(..) => \"attempted to mul with overflow\".into_cow(),\n+            DivideByZero         => \"attempted to divide by zero\".into_cow(),\n+            DivideWithOverflow   => \"attempted to divide with overflow\".into_cow(),\n+            ModuloByZero         => \"attempted remainder with a divisor of zero\".into_cow(),\n+            ModuloWithOverflow   => \"attempted remainder with overflow\".into_cow(),\n+            MissingStructField  => \"nonexistent struct field\".into_cow(),\n+            NonConstPath        => \"non-constant path in constant expr\".into_cow(),\n+            NonConstStruct      => \"non-constant struct in constant expr\".into_cow(),\n+            TupleIndexOutOfBounds => \"tuple index out of bounds\".into_cow(),\n+\n+            MiscBinaryOp => \"bad operands for binary\".into_cow(),\n+            MiscCatchAll => \"unsupported constant expr\".into_cow(),\n+        }\n+    }\n+}\n+\n+fn invalid_op_for_bools(e: &Expr, op: ast::BinOp_) -> ConstEvalErr {\n+    ConstEvalErr { span: e.span, kind: ErrKind::InvalidOpForBools(op) }\n+}\n+fn invalid_op_for_floats(e: &Expr, op: ast::BinOp_) -> ConstEvalErr {\n+    ConstEvalErr { span: e.span, kind: ErrKind::InvalidOpForFloats(op) }\n+}\n+fn invalid_op_for_int_uint(e: &Expr, op: ast::BinOp_) -> ConstEvalErr {\n+    ConstEvalErr { span: e.span, kind: ErrKind::InvalidOpForIntUint(op) }\n+}\n+fn invalid_op_for_uint_int(e: &Expr, op: ast::BinOp_) -> ConstEvalErr {\n+    ConstEvalErr { span: e.span, kind: ErrKind::InvalidOpForUintInt(op) }\n+}\n+fn negate_on_string(e: &Expr) -> ConstEvalErr {\n+    ConstEvalErr { span: e.span, kind: ErrKind::NegateOnString }\n+}\n+fn negate_on_boolean(e: &Expr) -> ConstEvalErr {\n+    ConstEvalErr { span: e.span, kind: ErrKind::NegateOnBoolean }\n+}\n+fn not_on_float(e: &Expr) -> ConstEvalErr {\n+    ConstEvalErr { span: e.span, kind: ErrKind::NotOnFloat }\n+}\n+fn not_on_string(e: &Expr) -> ConstEvalErr {\n+    ConstEvalErr { span: e.span, kind: ErrKind::NotOnString }\n+}\n+\n+fn addi_with_overflow(e: &Expr, a: i64, b: i64) -> ConstEvalErr {\n+    ConstEvalErr { span: e.span, kind: ErrKind::AddiWithOverflow(a, b) }\n+}\n+fn subi_with_overflow(e: &Expr, a: i64, b: i64) -> ConstEvalErr {\n+    ConstEvalErr { span: e.span, kind: ErrKind::SubiWithOverflow(a, b) }\n+}\n+fn muli_with_overflow(e: &Expr, a: i64, b: i64) -> ConstEvalErr {\n+    ConstEvalErr { span: e.span, kind: ErrKind::MuliWithOverflow(a, b) }\n+}\n+fn addu_with_overflow(e: &Expr, a: u64, b: u64) -> ConstEvalErr {\n+    ConstEvalErr { span: e.span, kind: ErrKind::AdduWithOverflow(a, b) }\n+}\n+fn subu_with_overflow(e: &Expr, a: u64, b: u64) -> ConstEvalErr {\n+    ConstEvalErr { span: e.span, kind: ErrKind::SubuWithOverflow(a, b) }\n+}\n+fn mulu_with_overflow(e: &Expr, a: u64, b: u64) -> ConstEvalErr {\n+    ConstEvalErr { span: e.span, kind: ErrKind::MuluWithOverflow(a, b) }\n+}\n+fn divide_by_zero(e: &Expr) -> ConstEvalErr {\n+    ConstEvalErr { span: e.span, kind: ErrKind::DivideByZero }\n+}\n+fn divide_with_overflow(e: &Expr) -> ConstEvalErr {\n+    ConstEvalErr { span: e.span, kind: ErrKind::DivideWithOverflow }\n+}\n+fn modulo_by_zero(e: &Expr) -> ConstEvalErr {\n+    ConstEvalErr { span: e.span, kind: ErrKind::ModuloByZero }\n+}\n+fn modulo_with_overflow(e: &Expr) -> ConstEvalErr {\n+    ConstEvalErr { span: e.span, kind: ErrKind::ModuloWithOverflow }\n+}\n+fn missing_struct_field(e: &Expr) -> ConstEvalErr {\n+    ConstEvalErr { span: e.span, kind: ErrKind::MissingStructField }\n+}\n+fn non_const_path(e: &Expr) -> ConstEvalErr {\n+    ConstEvalErr { span: e.span, kind: ErrKind::NonConstPath }\n+}\n+fn non_const_struct(e: &Expr) -> ConstEvalErr {\n+    ConstEvalErr { span: e.span, kind: ErrKind::NonConstStruct }\n+}\n+fn tuple_index_out_of_bounds(e: &Expr) -> ConstEvalErr {\n+    ConstEvalErr { span: e.span, kind: ErrKind::TupleIndexOutOfBounds }\n+}\n+\n+fn misc_binary_op(e: &Expr) -> ConstEvalErr {\n+    ConstEvalErr { span: e.span, kind: ErrKind::MiscBinaryOp }\n+}\n+fn misc_catch_all(e: &Expr) -> ConstEvalErr {\n+    ConstEvalErr { span: e.span, kind: ErrKind::MiscCatchAll }\n+}\n+\n+\n+fn checked_add_int(e: &Expr, a: i64, b: i64) -> Result<const_val, ConstEvalErr> {\n     let (ret, oflo) = a.overflowing_add(b);\n-    if !oflo { Ok(const_int(ret)) } else { Err(format!(\"constant arithmetic overflow\")) }\n+    if !oflo { Ok(const_int(ret)) } else { Err(addi_with_overflow(e, a, b)) }\n }\n-fn checked_sub_int(a: i64, b: i64) -> Result<const_val, String> {\n+fn checked_sub_int(e: &Expr, a: i64, b: i64) -> Result<const_val, ConstEvalErr> {\n     let (ret, oflo) = a.overflowing_sub(b);\n-    if !oflo { Ok(const_int(ret)) } else { Err(format!(\"constant arithmetic overflow\")) }\n+    if !oflo { Ok(const_int(ret)) } else { Err(subi_with_overflow(e, a, b)) }\n }\n-fn checked_mul_int(a: i64, b: i64) -> Result<const_val, String> {\n+fn checked_mul_int(e: &Expr, a: i64, b: i64) -> Result<const_val, ConstEvalErr> {\n     let (ret, oflo) = a.overflowing_mul(b);\n-    if !oflo { Ok(const_int(ret)) } else { Err(format!(\"constant arithmetic overflow\")) }\n+    if !oflo { Ok(const_int(ret)) } else { Err(muli_with_overflow(e, a, b)) }\n }\n \n-fn checked_add_uint(a: u64, b: u64) -> Result<const_val, String> {\n+fn checked_add_uint(e: &Expr, a: u64, b: u64) -> Result<const_val, ConstEvalErr> {\n     let (ret, oflo) = a.overflowing_add(b);\n-    if !oflo { Ok(const_uint(ret)) } else { Err(format!(\"constant arithmetic overflow\")) }\n+    if !oflo { Ok(const_uint(ret)) } else { Err(addu_with_overflow(e, a, b)) }\n }\n-fn checked_sub_uint(a: u64, b: u64) -> Result<const_val, String> {\n+fn checked_sub_uint(e: &Expr, a: u64, b: u64) -> Result<const_val, ConstEvalErr> {\n     let (ret, oflo) = a.overflowing_sub(b);\n-    if !oflo { Ok(const_uint(ret)) } else { Err(format!(\"constant arithmetic overflow\")) }\n+    if !oflo { Ok(const_uint(ret)) } else { Err(subu_with_overflow(e, a, b)) }\n }\n-fn checked_mul_uint(a: u64, b: u64) -> Result<const_val, String> {\n+fn checked_mul_uint(e: &Expr, a: u64, b: u64) -> Result<const_val, ConstEvalErr> {\n     let (ret, oflo) = a.overflowing_mul(b);\n-    if !oflo { Ok(const_uint(ret)) } else { Err(format!(\"constant arithmetic overflow\")) }\n+    if !oflo { Ok(const_uint(ret)) } else { Err(mulu_with_overflow(e, a, b)) }\n }\n \n \n pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      e: &Expr,\n                                      ty_hint: Option<Ty<'tcx>>)\n-                                     -> Result<const_val, String> {\n-    fn fromb(b: bool) -> Result<const_val, String> { Ok(const_int(b as i64)) }\n+                                     -> Result<const_val, ConstEvalErr> {\n+    fn fromb<T>(b: bool) -> Result<const_val, T> { Ok(const_int(b as i64)) }\n \n     let ety = ty_hint.or_else(|| ty::expr_ty_opt(tcx, e));\n \n@@ -248,17 +400,19 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n           Ok(const_float(f)) => Ok(const_float(-f)),\n           Ok(const_int(i)) => Ok(const_int(-i)),\n           Ok(const_uint(i)) => Ok(const_uint(-i)),\n-          Ok(const_str(_)) => Err(\"negate on string\".to_string()),\n-          Ok(const_bool(_)) => Err(\"negate on boolean\".to_string()),\n-          ref err => ((*err).clone())\n+          Ok(const_str(_)) => Err(negate_on_string(e)),\n+          Ok(const_bool(_)) => Err(negate_on_boolean(e)),\n+          err => err\n         }\n       }\n       ast::ExprUnary(ast::UnNot, ref inner) => {\n         match eval_const_expr_partial(tcx, &**inner, ety) {\n           Ok(const_int(i)) => Ok(const_int(!i)),\n           Ok(const_uint(i)) => Ok(const_uint(!i)),\n           Ok(const_bool(b)) => Ok(const_bool(!b)),\n-          _ => Err(\"not on float or string\".to_string())\n+          Ok(const_str(_)) => Err(not_on_string(e)),\n+          Ok(const_float(_)) => Err(not_on_float(e)),\n+          err => err\n         }\n       }\n       ast::ExprBinary(op, ref a, ref b) => {\n@@ -281,7 +435,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n               ast::BiNe => fromb(a != b),\n               ast::BiGe => fromb(a >= b),\n               ast::BiGt => fromb(a > b),\n-              _ => Err(\"can't do this op on floats\".to_string())\n+              _ => Err(invalid_op_for_floats(e, op.node)),\n             }\n           }\n           (Ok(const_int(a)), Ok(const_int(b))) => {\n@@ -304,23 +458,23 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                 }\n             };\n             match op.node {\n-              ast::BiAdd => checked_add_int(a, b),\n-              ast::BiSub => checked_sub_int(a, b),\n-              ast::BiMul => checked_mul_int(a, b),\n+              ast::BiAdd => checked_add_int(e, a, b),\n+              ast::BiSub => checked_sub_int(e, a, b),\n+              ast::BiMul => checked_mul_int(e, a, b),\n               ast::BiDiv => {\n                   if b == 0 {\n-                      Err(\"attempted to divide by zero\".to_string())\n+                      Err(divide_by_zero(e))\n                   } else if b == -1 && is_a_min_value() {\n-                      Err(\"attempted to divide with overflow\".to_string())\n+                      Err(divide_with_overflow(e))\n                   } else {\n                       Ok(const_int(a / b))\n                   }\n               }\n               ast::BiRem => {\n                   if b == 0 {\n-                      Err(\"attempted remainder with a divisor of zero\".to_string())\n+                      Err(modulo_by_zero(e))\n                   } else if b == -1 && is_a_min_value() {\n-                      Err(\"attempted remainder with overflow\".to_string())\n+                      Err(modulo_with_overflow(e))\n                   } else {\n                       Ok(const_int(a % b))\n                   }\n@@ -340,17 +494,12 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n           }\n           (Ok(const_uint(a)), Ok(const_uint(b))) => {\n             match op.node {\n-              ast::BiAdd => checked_add_uint(a, b),\n-              ast::BiSub => checked_sub_uint(a, b),\n-              ast::BiMul => checked_mul_uint(a, b),\n-              ast::BiDiv if b == 0 => {\n-                  Err(\"attempted to divide by zero\".to_string())\n-              }\n+              ast::BiAdd => checked_add_uint(e, a, b),\n+              ast::BiSub => checked_sub_uint(e, a, b),\n+              ast::BiMul => checked_mul_uint(e, a, b),\n+              ast::BiDiv if b == 0 => Err(divide_by_zero(e)),\n               ast::BiDiv => Ok(const_uint(a / b)),\n-              ast::BiRem if b == 0 => {\n-                  Err(\"attempted remainder with a divisor of \\\n-                       zero\".to_string())\n-              }\n+              ast::BiRem if b == 0 => Err(modulo_by_zero(e)),\n               ast::BiRem => Ok(const_uint(a % b)),\n               ast::BiAnd | ast::BiBitAnd => Ok(const_uint(a & b)),\n               ast::BiOr | ast::BiBitOr => Ok(const_uint(a | b)),\n@@ -370,14 +519,14 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n             match op.node {\n               ast::BiShl => Ok(const_int(a << b as uint)),\n               ast::BiShr => Ok(const_int(a >> b as uint)),\n-              _ => Err(\"can't do this op on an int and uint\".to_string())\n+              _ => Err(invalid_op_for_int_uint(e, op.node)),\n             }\n           }\n           (Ok(const_uint(a)), Ok(const_int(b))) => {\n             match op.node {\n               ast::BiShl => Ok(const_uint(a << b as uint)),\n               ast::BiShr => Ok(const_uint(a >> b as uint)),\n-              _ => Err(\"can't do this op on a uint and int\".to_string())\n+              _ => Err(invalid_op_for_uint_int(e, op.node)),\n             }\n           }\n           (Ok(const_bool(a)), Ok(const_bool(b))) => {\n@@ -389,10 +538,13 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n               ast::BiBitOr => a | b,\n               ast::BiEq => a == b,\n               ast::BiNe => a != b,\n-              _ => return Err(\"can't do this op on bools\".to_string())\n+              _ => return Err(invalid_op_for_bools(e, op.node)),\n              }))\n           }\n-          _ => Err(\"bad operands for binary\".to_string())\n+          (err @ Err(..), _) |\n+          (_, err @ Err(..)) => err,\n+\n+          _ => Err(misc_binary_op(e)),\n         }\n       }\n       ast::ExprCast(ref base, ref target_ty) => {\n@@ -407,7 +559,10 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n         // Prefer known type to noop, but always have a type hint.\n         let base_hint = ty::expr_ty_opt(tcx, &**base).unwrap_or(ety);\n         let val = try!(eval_const_expr_partial(tcx, &**base, Some(base_hint)));\n-        cast_const(val, ety)\n+        match cast_const(val, ety) {\n+            Ok(val) => Ok(val),\n+            Err(kind) => Err(ConstEvalErr { span: e.span, kind: kind }),\n+        }\n       }\n       ast::ExprPath(..) => {\n           let opt_def = tcx.def_map.borrow().get(&e.id).map(|d| d.full_def());\n@@ -434,7 +589,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n           };\n           let const_expr = match const_expr {\n               Some(actual_e) => actual_e,\n-              None => return Err(\"non-constant path in constant expr\".to_string())\n+              None => return Err(non_const_path(e)),\n           };\n           let ety = ety.or_else(|| const_ty.and_then(|ty| ast_ty_to_prim_ty(tcx, ty)));\n           eval_const_expr_partial(tcx, const_expr, ety)\n@@ -456,11 +611,11 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n             if fields.len() > index.node {\n                 return eval_const_expr_partial(tcx, &*fields[index.node], None)\n             } else {\n-                return Err(\"tuple index out of bounds\".to_string())\n+                return Err(tuple_index_out_of_bounds(e))\n             }\n         }\n \n-        Err(\"non-constant struct in constant expr\".to_string())\n+        Err(non_const_struct(e))\n       }\n       ast::ExprField(ref base, field_name) => {\n         // Get the base expression if it is a struct and it is constant\n@@ -471,17 +626,17 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                            f.ident.node.as_str() == field_name.node.as_str()) {\n                 return eval_const_expr_partial(tcx, &*f.expr, None)\n             } else {\n-                return Err(\"nonexistent struct field\".to_string())\n+                return Err(missing_struct_field(e));\n             }\n         }\n \n-        Err(\"non-constant struct in constant expr\".to_string())\n+        Err(non_const_struct(e))\n       }\n-      _ => Err(\"unsupported constant expr\".to_string())\n+      _ => Err(misc_catch_all(e))\n     }\n }\n \n-fn cast_const(val: const_val, ty: Ty) -> Result<const_val, String> {\n+fn cast_const(val: const_val, ty: Ty) -> Result<const_val, ErrKind> {\n     macro_rules! define_casts {\n         ($($ty_pat:pat => (\n             $intermediate_ty:ty,\n@@ -494,11 +649,10 @@ fn cast_const(val: const_val, ty: Ty) -> Result<const_val, String> {\n                     const_uint(u) => Ok($const_type(u as $intermediate_ty as $target_ty)),\n                     const_int(i) => Ok($const_type(i as $intermediate_ty as $target_ty)),\n                     const_float(f) => Ok($const_type(f as $intermediate_ty as $target_ty)),\n-                    _ => Err(concat!(\"can't cast this type to \",\n-                                     stringify!($const_type)).to_string())\n+                    _ => Err(ErrKind::CannotCastTo(stringify!($const_type))),\n                 }\n             },)*\n-            _ => Err(\"can't cast this type\".to_string())\n+            _ => Err(ErrKind::CannotCast),\n         })\n     }\n \n@@ -572,15 +726,15 @@ pub fn compare_lit_exprs<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                -> Option<Ordering> {\n     let a = match eval_const_expr_partial(tcx, a, ty_hint) {\n         Ok(a) => a,\n-        Err(s) => {\n-            tcx.sess.span_err(a.span, &s[..]);\n+        Err(e) => {\n+            tcx.sess.span_err(a.span, e.description().as_slice());\n             return None;\n         }\n     };\n     let b = match eval_const_expr_partial(tcx, b, ty_hint) {\n         Ok(b) => b,\n-        Err(s) => {\n-            tcx.sess.span_err(b.span, &s[..]);\n+        Err(e) => {\n+            tcx.sess.span_err(b.span, e.description().as_slice());\n             return None;\n         }\n     };"}, {"sha": "62947d796b7ee81ecf5c7bebf63de7fd81d9aff5", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e919f82da1fb9fa0409f8febede311de4a8f1703/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e919f82da1fb9fa0409f8febede311de4a8f1703/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e919f82da1fb9fa0409f8febede311de4a8f1703", "patch": "@@ -5366,8 +5366,9 @@ pub fn enum_variants<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                                                       \"expected signed integer constant\");\n                                         }\n                                         Err(err) => {\n-                                            span_err!(cx.sess, e.span, E0305,\n-                                                      \"expected constant: {}\", err);\n+                                            span_err!(cx.sess, err.span, E0305,\n+                                                      \"constant evaluation error: {}\",\n+                                                      err.description().as_slice());\n                                         }\n                                     }\n                                 } else {"}, {"sha": "832de5251b50298679be19d6d5529454a54189ad", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e919f82da1fb9fa0409f8febede311de4a8f1703/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e919f82da1fb9fa0409f8febede311de4a8f1703/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=e919f82da1fb9fa0409f8febede311de4a8f1703", "patch": "@@ -1390,14 +1390,22 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                             ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty),\n                                         Some(i as uint)),\n                         _ => {\n-                            span_fatal!(tcx.sess, ast_ty.span, E0249,\n-                                        \"expected constant expr for array length\");\n+                            span_err!(tcx.sess, ast_ty.span, E0249,\n+                                      \"expected constant expr for array length\");\n+                            this.tcx().types.err\n                         }\n                     }\n                 }\n-                Err(r) => {\n-                    span_fatal!(tcx.sess, ast_ty.span, E0250,\n-                                \"expected constant expr for array length: {}\", r);\n+                Err(ref r) => {\n+                    let subspan  =\n+                        ast_ty.span.lo <= r.span.lo && r.span.hi <= ast_ty.span.hi;\n+                    span_err!(tcx.sess, ast_ty.span, E0250,\n+                              \"array length constant evaluation error: {}\",\n+                              r.description().as_slice());\n+                    if !subspan {\n+                        span_note!(tcx.sess, ast_ty.span, \"for array length here\")\n+                    }\n+                    this.tcx().types.err\n                 }\n             }\n         }"}, {"sha": "a12ff04912c4905e15cae18c22968bf638744ba4", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e919f82da1fb9fa0409f8febede311de4a8f1703/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e919f82da1fb9fa0409f8febede311de4a8f1703/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e919f82da1fb9fa0409f8febede311de4a8f1703", "patch": "@@ -4604,8 +4604,9 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                 \"expected signed integer constant\");\n                         }\n                         Err(ref err) => {\n-                            span_err!(ccx.tcx.sess, e.span, E0080,\n-                                \"expected constant: {}\", *err);\n+                            span_err!(ccx.tcx.sess, err.span, E0080,\n+                                      \"constant evaluation error: {}\",\n+                                      err.description().as_slice());\n                         }\n                     }\n                 },"}, {"sha": "ed1327f31185e8d565dd95307800193381e584a5", "filename": "src/test/compile-fail/eval-enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e919f82da1fb9fa0409f8febede311de4a8f1703/src%2Ftest%2Fcompile-fail%2Feval-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e919f82da1fb9fa0409f8febede311de4a8f1703/src%2Ftest%2Fcompile-fail%2Feval-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Feval-enum.rs?ref=e919f82da1fb9fa0409f8febede311de4a8f1703", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n enum test {\n-    div_zero = 1/0, //~ERROR expected constant: attempted to divide by zero\n-    rem_zero = 1%0  //~ERROR expected constant: attempted remainder with a divisor of zero\n+    div_zero = 1/0, //~ERROR constant evaluation error: attempted to divide by zero\n+    rem_zero = 1%0  //~ERROR constant evaluation error: attempted remainder with a divisor of zero\n }\n \n fn main() {}"}]}