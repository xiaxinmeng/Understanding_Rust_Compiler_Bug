{"sha": "7cd8f69a4f06d41979f95c48ec6bca2310fae995", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjZDhmNjlhNGYwNmQ0MTk3OWY5NWM0OGVjNmJjYTIzMTBmYWU5OTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-06T13:13:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-06T13:13:08Z"}, "message": "Auto merge of #29620 - petrochenkov:reachable2, r=alexcrichton\n\nHandle them in `middle::reachable` instead (no optimizations so far, just drop all trait impl items into the reachable set, as before). Addresses the concerns from https://github.com/rust-lang/rust/pull/29291#discussion_r43672413\n\\+ In `middle::reachable` don't treat impls of `Drop` specially, they are subsumed by the general impl treatment.\n\\+ Add some tests checking reachability of trait methods written in UFCS form\n\\+ Minor refactoring in the second commit\n\nr? @alexcrichton", "tree": {"sha": "99ded824d6de7a9e8b0748cdfe45e493e5a4e652", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99ded824d6de7a9e8b0748cdfe45e493e5a4e652"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7cd8f69a4f06d41979f95c48ec6bca2310fae995", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7cd8f69a4f06d41979f95c48ec6bca2310fae995", "html_url": "https://github.com/rust-lang/rust/commit/7cd8f69a4f06d41979f95c48ec6bca2310fae995", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7cd8f69a4f06d41979f95c48ec6bca2310fae995/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f59977d96ebe5cf5fc000bf27e3f663cad3250c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f59977d96ebe5cf5fc000bf27e3f663cad3250c", "html_url": "https://github.com/rust-lang/rust/commit/2f59977d96ebe5cf5fc000bf27e3f663cad3250c"}, {"sha": "1d693976df991c4e1e9bc9c823ccb71e70c6f397", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d693976df991c4e1e9bc9c823ccb71e70c6f397", "html_url": "https://github.com/rust-lang/rust/commit/1d693976df991c4e1e9bc9c823ccb71e70c6f397"}], "stats": {"total": 140, "additions": 85, "deletions": 55}, "files": [{"sha": "7175fbe0e570dbc3e81401694be868de952fd21e", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 41, "deletions": 26, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/7cd8f69a4f06d41979f95c48ec6bca2310fae995/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd8f69a4f06d41979f95c48ec6bca2310fae995/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=7cd8f69a4f06d41979f95c48ec6bca2310fae995", "patch": "@@ -125,6 +125,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n             hir::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n                 let def_id = self.tcx.tables.borrow().method_map[&method_call].def_id;\n+\n+                // Mark the trait item (and, possibly, its default impl) as reachable\n+                // Or mark inherent impl item as reachable\n                 if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n                     if self.def_id_represents_local_inlined_item(def_id) {\n                         self.worklist.push(node_id)\n@@ -322,57 +325,69 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             }\n         }\n     }\n+}\n \n-    // Step 3: Mark all destructors as reachable.\n-    //\n-    // FIXME #10732: This is a conservative overapproximation, but fixing\n-    // this properly would result in the necessity of computing *type*\n-    // reachability, which might result in a compile time loss.\n-    fn mark_destructors_reachable(&mut self) {\n-        let drop_trait = match self.tcx.lang_items.drop_trait() {\n-            Some(id) => self.tcx.lookup_trait_def(id), None => { return }\n-        };\n-        drop_trait.for_each_impl(self.tcx, |drop_impl| {\n-            for destructor in &self.tcx.impl_items.borrow()[&drop_impl] {\n-                let destructor_did = destructor.def_id();\n-                if let Some(destructor_node_id) = self.tcx.map.as_local_node_id(destructor_did) {\n-                    self.reachable_symbols.insert(destructor_node_id);\n+// Some methods from non-exported (completely private) trait impls still have to be\n+// reachable if they are called from inlinable code. Generally, it's not known until\n+// monomorphization if a specific trait impl item can be reachable or not. So, we\n+// conservatively mark all of them as reachable.\n+// FIXME: One possible strategy for pruning the reachable set is to avoid marking impl\n+// items of non-exported traits (or maybe all local traits?) unless their respective\n+// trait items are used from inlinable code through method call syntax or UFCS, or their\n+// trait is a lang item.\n+struct CollectPrivateImplItemsVisitor<'a> {\n+    exported_items: &'a privacy::ExportedItems,\n+    worklist: &'a mut Vec<ast::NodeId>,\n+}\n+\n+impl<'a, 'v> Visitor<'v> for CollectPrivateImplItemsVisitor<'a> {\n+    fn visit_item(&mut self, item: &hir::Item) {\n+        // We need only trait impls here, not inherent impls, and only non-exported ones\n+        if let hir::ItemImpl(_, _, _, Some(_), _, ref impl_items) = item.node {\n+            if !self.exported_items.contains(&item.id) {\n+                for impl_item in impl_items {\n+                    self.worklist.push(impl_item.id);\n                 }\n             }\n-        })\n+        }\n+\n+        visit::walk_item(self, item);\n     }\n }\n \n pub fn find_reachable(tcx: &ty::ctxt,\n                       exported_items: &privacy::ExportedItems)\n                       -> NodeSet {\n+\n     let mut reachable_context = ReachableContext::new(tcx);\n \n     // Step 1: Seed the worklist with all nodes which were found to be public as\n-    //         a result of the privacy pass along with all local lang items. If\n-    //         other crates link to us, they're going to expect to be able to\n+    //         a result of the privacy pass along with all local lang items and impl items.\n+    //         If other crates link to us, they're going to expect to be able to\n     //         use the lang items, so we need to be sure to mark them as\n     //         exported.\n     for id in exported_items {\n         reachable_context.worklist.push(*id);\n     }\n     for (_, item) in tcx.lang_items.items() {\n-        match *item {\n-            Some(did) => {\n-                if let Some(node_id) = tcx.map.as_local_node_id(did) {\n-                    reachable_context.worklist.push(node_id);\n-                }\n+        if let Some(did) = *item {\n+            if let Some(node_id) = tcx.map.as_local_node_id(did) {\n+                reachable_context.worklist.push(node_id);\n             }\n-            _ => {}\n         }\n     }\n+    {\n+        let mut collect_private_impl_items = CollectPrivateImplItemsVisitor {\n+            exported_items: exported_items,\n+            worklist: &mut reachable_context.worklist,\n+        };\n+\n+        visit::walk_crate(&mut collect_private_impl_items, tcx.map.krate());\n+    }\n \n     // Step 2: Mark all symbols that the symbols on the worklist touch.\n     reachable_context.propagate();\n \n-    // Step 3: Mark all destructors as reachable.\n-    reachable_context.mark_destructors_reachable();\n-\n     // Return the set of reachable symbols.\n     reachable_context.reachable_symbols\n }"}, {"sha": "491c8a2c4524ac833783cdeab14cd524d7fa6642", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7cd8f69a4f06d41979f95c48ec6bca2310fae995/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd8f69a4f06d41979f95c48ec6bca2310fae995/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=7cd8f69a4f06d41979f95c48ec6bca2310fae995", "patch": "@@ -165,13 +165,6 @@ struct EmbargoVisitor<'a, 'tcx: 'a> {\n     // may jump across private boundaries through reexport statements or type aliases.\n     exported_items: ExportedItems,\n \n-    // This sets contains all the destination nodes which are publicly\n-    // re-exported. This is *not* a set of all reexported nodes, only a set of\n-    // all nodes which are reexported *and* reachable from external crates. This\n-    // means that the destination of the reexport is exported, and hence the\n-    // destination must also be exported.\n-    reexports: NodeSet,\n-\n     // Items that are directly public without help of reexports or type aliases.\n     // These two fields are closely related to one another in that they are only\n     // used for generation of the `public_items` set, not for privacy checking at\n@@ -185,7 +178,9 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     fn is_public_exported_ty(&self, ty: &hir::Ty) -> (bool, bool) {\n         if let hir::TyPath(..) = ty.node {\n             match self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def() {\n-                def::DefPrimTy(..) | def::DefSelfTy(..) => (true, true),\n+                def::DefPrimTy(..) | def::DefSelfTy(..) | def::DefTyParam(..) => {\n+                    (true, true)\n+                }\n                 def => {\n                     if let Some(node_id) = self.tcx.map.as_local_node_id(def.def_id()) {\n                         (self.public_items.contains(&node_id),\n@@ -235,7 +230,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             _ => {\n                 self.prev_public = self.prev_public && item.vis == hir::Public;\n                 self.prev_exported = (self.prev_exported && item.vis == hir::Public) ||\n-                                     self.reexports.contains(&item.id);\n+                                     self.exported_items.contains(&item.id);\n \n                 self.maybe_insert_id(item.id);\n             }\n@@ -272,25 +267,26 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                 }\n             }\n \n-            // It's not known until monomorphization if a trait impl item should be reachable\n-            // from external crates or not. So, we conservatively mark all of them exported and\n-            // the reachability pass (middle::reachable) marks all exported items as reachable.\n-            // For example of private trait impl for private type that should be reachable see\n-            // src/test/auxiliary/issue-11225-3.rs\n+            // Trait impl and its items are public/exported if both the self type and the trait\n+            // of this impl are public/exported\n             hir::ItemImpl(_, _, _, Some(ref trait_ref), ref ty, ref impl_items) => {\n-                let (public_ty, _exported_ty) = self.is_public_exported_ty(&ty);\n-                let (public_trait, _exported_trait) = self.is_public_exported_trait(trait_ref);\n+                let (public_ty, exported_ty) = self.is_public_exported_ty(&ty);\n+                let (public_trait, exported_trait) = self.is_public_exported_trait(trait_ref);\n \n                 if public_ty && public_trait {\n                     self.public_items.insert(item.id);\n                 }\n-                self.exported_items.insert(item.id);\n+                if exported_ty && exported_trait {\n+                    self.exported_items.insert(item.id);\n+                }\n \n                 for impl_item in impl_items {\n                     if public_ty && public_trait {\n                         self.public_items.insert(impl_item.id);\n                     }\n-                    self.exported_items.insert(impl_item.id);\n+                    if exported_ty && exported_trait {\n+                        self.exported_items.insert(impl_item.id);\n+                    }\n                 }\n             }\n \n@@ -332,8 +328,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                     match self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def() {\n                         def::DefPrimTy(..) | def::DefSelfTy(..) | def::DefTyParam(..) => {},\n                         def => {\n-                            let did = def.def_id();\n-                            if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n+                            if let Some(node_id) = self.tcx.map.as_local_node_id(def.def_id()) {\n                                 self.exported_items.insert(node_id);\n                             }\n                         }\n@@ -345,7 +340,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                 for foreign_item in &foreign_mod.items {\n                     let public = self.prev_public && foreign_item.vis == hir::Public;\n                     let exported = (self.prev_exported && foreign_item.vis == hir::Public) ||\n-                                   self.reexports.contains(&foreign_item.id);\n+                                   self.exported_items.contains(&foreign_item.id);\n \n                     if public {\n                         self.public_items.insert(foreign_item.id);\n@@ -385,7 +380,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             assert!(self.export_map.contains_key(&id), \"wut {}\", id);\n             for export in self.export_map.get(&id).unwrap() {\n                 if let Some(node_id) = self.tcx.map.as_local_node_id(export.def_id) {\n-                    self.reexports.insert(node_id);\n+                    self.exported_items.insert(node_id);\n                 }\n             }\n         }\n@@ -1530,17 +1525,14 @@ pub fn check_crate(tcx: &ty::ctxt,\n         tcx: tcx,\n         exported_items: NodeSet(),\n         public_items: NodeSet(),\n-        reexports: NodeSet(),\n         export_map: export_map,\n         prev_exported: true,\n         prev_public: true,\n     };\n     loop {\n-        let before = (visitor.exported_items.len(), visitor.public_items.len(),\n-                      visitor.reexports.len());\n+        let before = (visitor.exported_items.len(), visitor.public_items.len());\n         visit::walk_crate(&mut visitor, krate);\n-        let after = (visitor.exported_items.len(), visitor.public_items.len(),\n-                     visitor.reexports.len());\n+        let after = (visitor.exported_items.len(), visitor.public_items.len());\n         if after == before {\n             break\n         }"}, {"sha": "e1ec15be9279f1301b3bc501106cb0593b63b6aa", "filename": "src/test/auxiliary/issue-11225-1.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7cd8f69a4f06d41979f95c48ec6bca2310fae995/src%2Ftest%2Fauxiliary%2Fissue-11225-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd8f69a4f06d41979f95c48ec6bca2310fae995/src%2Ftest%2Fauxiliary%2Fissue-11225-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-11225-1.rs?ref=7cd8f69a4f06d41979f95c48ec6bca2310fae995", "patch": "@@ -11,13 +11,18 @@\n mod inner {\n     pub trait Trait {\n         fn f(&self) { f(); }\n+        fn f_ufcs(&self) { f_ufcs(); }\n     }\n \n     impl Trait for isize {}\n \n     fn f() {}\n+    fn f_ufcs() {}\n }\n \n pub fn foo<T: inner::Trait>(t: T) {\n     t.f();\n }\n+pub fn foo_ufcs<T: inner::Trait>(t: T) {\n+    T::f_ufcs(&t);\n+}"}, {"sha": "25110edda270634ddc4784ddda9b2aab71a1e05d", "filename": "src/test/auxiliary/issue-11225-2.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7cd8f69a4f06d41979f95c48ec6bca2310fae995/src%2Ftest%2Fauxiliary%2Fissue-11225-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd8f69a4f06d41979f95c48ec6bca2310fae995/src%2Ftest%2Fauxiliary%2Fissue-11225-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-11225-2.rs?ref=7cd8f69a4f06d41979f95c48ec6bca2310fae995", "patch": "@@ -14,19 +14,25 @@ mod inner {\n     pub struct Foo;\n     pub trait Trait {\n         fn f(&self);\n+        fn f_ufcs(&self);\n     }\n \n     impl Trait for Foo {\n         fn f(&self) { }\n+        fn f_ufcs(&self) { }\n     }\n }\n \n pub trait Outer {\n     fn foo<T: Trait>(&self, t: T) { t.f(); }\n+    fn foo_ufcs<T: Trait>(&self, t: T) { T::f(&t); }\n }\n \n impl Outer for isize {}\n \n pub fn foo<T: Outer>(t: T) {\n     t.foo(inner::Foo);\n }\n+pub fn foo_ufcs<T: Outer>(t: T) {\n+    T::foo_ufcs(&t, inner::Foo)\n+}"}, {"sha": "d48fb68ba0ffd5a42c87287498282226ccf86462", "filename": "src/test/auxiliary/issue-11225-3.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7cd8f69a4f06d41979f95c48ec6bca2310fae995/src%2Ftest%2Fauxiliary%2Fissue-11225-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd8f69a4f06d41979f95c48ec6bca2310fae995/src%2Ftest%2Fauxiliary%2Fissue-11225-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-11225-3.rs?ref=7cd8f69a4f06d41979f95c48ec6bca2310fae995", "patch": "@@ -10,20 +10,29 @@\n \n trait PrivateTrait {\n     fn private_trait_method(&self);\n+    fn private_trait_method_ufcs(&self);\n }\n \n struct PrivateStruct;\n \n impl PrivateStruct {\n     fn private_inherent_method(&self) { }\n+    fn private_inherent_method_ufcs(&self) { }\n }\n \n impl PrivateTrait for PrivateStruct {\n     fn private_trait_method(&self) { }\n+    fn private_trait_method_ufcs(&self) { }\n }\n \n #[inline]\n-pub fn public_generic_function() {\n+pub fn public_inlinable_function() {\n     PrivateStruct.private_trait_method();\n     PrivateStruct.private_inherent_method();\n }\n+\n+#[inline]\n+pub fn public_inlinable_function_ufcs() {\n+    PrivateStruct::private_trait_method(&PrivateStruct);\n+    PrivateStruct::private_inherent_method(&PrivateStruct);\n+}"}, {"sha": "60789be62b353b8a0be9b042f698f8792fc5d317", "filename": "src/test/run-pass/issue-11225-1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7cd8f69a4f06d41979f95c48ec6bca2310fae995/src%2Ftest%2Frun-pass%2Fissue-11225-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd8f69a4f06d41979f95c48ec6bca2310fae995/src%2Ftest%2Frun-pass%2Fissue-11225-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11225-1.rs?ref=7cd8f69a4f06d41979f95c48ec6bca2310fae995", "patch": "@@ -16,4 +16,5 @@ extern crate issue_11225_1 as foo;\n \n pub fn main() {\n     foo::foo(1);\n+    foo::foo_ufcs(1);\n }"}, {"sha": "540183b7ef432cc648e786b6d7ea5482c2c43d5c", "filename": "src/test/run-pass/issue-11225-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7cd8f69a4f06d41979f95c48ec6bca2310fae995/src%2Ftest%2Frun-pass%2Fissue-11225-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd8f69a4f06d41979f95c48ec6bca2310fae995/src%2Ftest%2Frun-pass%2Fissue-11225-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11225-2.rs?ref=7cd8f69a4f06d41979f95c48ec6bca2310fae995", "patch": "@@ -16,4 +16,5 @@ extern crate issue_11225_2 as foo;\n \n pub fn main() {\n     foo::foo(1);\n+    foo::foo_ufcs(1);\n }"}, {"sha": "317c3d3222d342ba364c415e6ef63641d26efdd7", "filename": "src/test/run-pass/issue-11225-3.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7cd8f69a4f06d41979f95c48ec6bca2310fae995/src%2Ftest%2Frun-pass%2Fissue-11225-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd8f69a4f06d41979f95c48ec6bca2310fae995/src%2Ftest%2Frun-pass%2Fissue-11225-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11225-3.rs?ref=7cd8f69a4f06d41979f95c48ec6bca2310fae995", "patch": "@@ -15,5 +15,6 @@\n extern crate issue_11225_3;\n \n pub fn main() {\n-    issue_11225_3::public_generic_function();\n+    issue_11225_3::public_inlinable_function();\n+    issue_11225_3::public_inlinable_function_ufcs();\n }"}]}