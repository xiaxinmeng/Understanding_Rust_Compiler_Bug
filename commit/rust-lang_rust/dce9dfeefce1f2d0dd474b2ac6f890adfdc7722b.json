{"sha": "dce9dfeefce1f2d0dd474b2ac6f890adfdc7722b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjZTlkZmVlZmNlMWYyZDBkZDQ3NGIyYWM2Zjg5MGFkZmRjNzcyMmI=", "commit": {"author": {"name": "Erik Rose", "email": "erik@mozilla.com", "date": "2011-09-26T05:15:44Z"}, "committer": {"name": "Erik Rose", "email": "erik@mozilla.com", "date": "2011-09-26T05:25:15Z"}, "message": "Fix some typos and grammar in the docs.", "tree": {"sha": "b58268d417e79547761bb19ec5577eb12ac9a121", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b58268d417e79547761bb19ec5577eb12ac9a121"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dce9dfeefce1f2d0dd474b2ac6f890adfdc7722b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dce9dfeefce1f2d0dd474b2ac6f890adfdc7722b", "html_url": "https://github.com/rust-lang/rust/commit/dce9dfeefce1f2d0dd474b2ac6f890adfdc7722b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dce9dfeefce1f2d0dd474b2ac6f890adfdc7722b/comments", "author": {"login": "erikrose", "id": 295816, "node_id": "MDQ6VXNlcjI5NTgxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/295816?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erikrose", "html_url": "https://github.com/erikrose", "followers_url": "https://api.github.com/users/erikrose/followers", "following_url": "https://api.github.com/users/erikrose/following{/other_user}", "gists_url": "https://api.github.com/users/erikrose/gists{/gist_id}", "starred_url": "https://api.github.com/users/erikrose/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erikrose/subscriptions", "organizations_url": "https://api.github.com/users/erikrose/orgs", "repos_url": "https://api.github.com/users/erikrose/repos", "events_url": "https://api.github.com/users/erikrose/events{/privacy}", "received_events_url": "https://api.github.com/users/erikrose/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erikrose", "id": 295816, "node_id": "MDQ6VXNlcjI5NTgxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/295816?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erikrose", "html_url": "https://github.com/erikrose", "followers_url": "https://api.github.com/users/erikrose/followers", "following_url": "https://api.github.com/users/erikrose/following{/other_user}", "gists_url": "https://api.github.com/users/erikrose/gists{/gist_id}", "starred_url": "https://api.github.com/users/erikrose/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erikrose/subscriptions", "organizations_url": "https://api.github.com/users/erikrose/orgs", "repos_url": "https://api.github.com/users/erikrose/repos", "events_url": "https://api.github.com/users/erikrose/events{/privacy}", "received_events_url": "https://api.github.com/users/erikrose/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93f0e9bac36b3487a2359a939a84bd9b35df8660", "url": "https://api.github.com/repos/rust-lang/rust/commits/93f0e9bac36b3487a2359a939a84bd9b35df8660", "html_url": "https://github.com/rust-lang/rust/commit/93f0e9bac36b3487a2359a939a84bd9b35df8660"}], "stats": {"total": 20, "additions": 10, "deletions": 10}, "files": [{"sha": "1972350d5a169d66bfd3c3cbe1f4388e43d5d57b", "filename": "doc/rust.texi", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dce9dfeefce1f2d0dd474b2ac6f890adfdc7722b/doc%2Frust.texi", "raw_url": "https://github.com/rust-lang/rust/raw/dce9dfeefce1f2d0dd474b2ac6f890adfdc7722b/doc%2Frust.texi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.texi?ref=dce9dfeefce1f2d0dd474b2ac6f890adfdc7722b", "patch": "@@ -185,7 +185,7 @@ features of Rust, relative to other languages.\n The initialization state of every slot is statically computed as part of the\n typestate system (see below), and requires that all slots are initialized\n before use. There is no @code{null} value; uninitialized slots are\n-uninitialized, and can only be written to, not read.\n+uninitialized and can only be written to, not read.\n \n The common use for @code{null} in other languages -- as a sentinel value -- is\n subsumed into the more general facility of disjoint union types. A program\n@@ -197,10 +197,10 @@ must explicitly model its use of such types.\n Like many @emph{actor} languages, Rust provides an isolation (and concurrency)\n model based on lightweight tasks scheduled by the language runtime. These\n tasks are very inexpensive and statically unable to manipulate one another's\n-local memory. Breaking the rule of task isolation is only possible by calling\n+local memory. Breaking the rule of task isolation is possible only by calling\n external (C/C++) code.\n \n-Inter-task communication is typed, asynchronous and simplex, based on passing\n+Inter-task communication is typed, asynchronous, and simplex, based on passing\n messages over channels to ports.\n \n @sp 1\n@@ -1136,7 +1136,7 @@ module bar @{\n @end example\n \n In future versions of Rust, user-provided extensions to the compiler will be able\n-to use interpret attributes. When this facility is provided, a distinction will be\n+to interpret attributes. When this facility is provided, a distinction will be\n made between language-reserved and user-available attributes.\n \n At present, only the Rust compiler interprets attributes, so all attribute\n@@ -1328,13 +1328,13 @@ Local slots are always implicitly mutable.\n Local slots are not initialized when allocated; the entire frame worth of\n local slots are allocated at once, on frame-entry, in an uninitialized\n state. Subsequent statements within a function may or may not initialize the\n-local slots. Local slots can only be used after they have been initialized;\n+local slots. Local slots can be used only after they have been initialized;\n this condition is guaranteed by the typestate system.\n \n References are created for function arguments. If the compiler can not prove\n that the referred-to value will outlive the reference, it will try to set\n aside a copy of that value to refer to. If this is not sematically safe (for\n-example, if the referred-to value contains mutable fields), it reject the\n+example, if the referred-to value contains mutable fields), it will reject the\n program. If the compiler deems copying the value expensive, it will warn.\n \n A function can be declared to take an argument by mutable reference. This\n@@ -1996,7 +1996,7 @@ The output type of an iterator is the type of value that the function will\n @code{put}, before it eventually evaluates a @code{ret} or @code{be} expression\n of type @code{()} and completes its execution.\n \n-An iterator can only be called in the loop header of a matching @code{for\n+An iterator can be called only in the loop header of a matching @code{for\n each} loop or as the argument in a @code{put each} expression.\n @xref{Ref.Expr.Foreach}.\n \n@@ -2108,10 +2108,10 @@ The constructors of a @code{tag} type may be recursive: that is, each constructo\n may take an argument that refers, directly or indirectly, to the tag type the constructor\n is a member of. Such recursion has restrictions:\n @itemize\n-@item Recursive types can only be introduced through @code{tag} constructors.\n+@item Recursive types can be introduced only through @code{tag} constructors.\n @item A recursive @code{tag} item must have at least one non-recursive\n constructor (in order to give the recursion a basis case).\n-@item The recursively argument of recursive tag constructors must be @emph{box}\n+@item The recursive argument of recursive tag constructors must be @emph{box}\n values (in order to bound the in-memory size of the constructor).\n @item Recursive type definitions can cross module boundaries, but not module\n @emph{visibility} boundaries, nor crate boundaries (in order to simplify the\n@@ -2360,7 +2360,7 @@ values similar to the record type-constructor. The differences are as follows:\n \n @itemize\n @item tuple elements cannot be mutable, unlike record fields\n-@item tuple elements are not named, and can only be accessed by pattern-matching\n+@item tuple elements are not named and can be accessed only by pattern-matching\n @end itemize\n \n Tuple types and values are denoted by listing the types or values of"}]}