{"sha": "459e1424134423d28a94a392e071300675677342", "node_id": "C_kwDOAAsO6NoAKDQ1OWUxNDI0MTM0NDIzZDI4YTk0YTM5MmUwNzEzMDA2NzU2NzczNDI", "commit": {"author": {"name": "Alan Egerton", "email": "eggyal@gmail.com", "date": "2023-02-10T16:14:18Z"}, "committer": {"name": "Alan Egerton", "email": "eggyal@gmail.com", "date": "2023-02-13T10:24:50Z"}, "message": "Move folding and visiting traits into type library", "tree": {"sha": "7d4292ed2b139d552ec4064f747ebf900f13dcab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d4292ed2b139d552ec4064f747ebf900f13dcab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/459e1424134423d28a94a392e071300675677342", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJFBAABCAAvFiEEvrRBFuOXsbT1OVTHfUwvbCISJTIFAmPqD/IRHGVnZ3lhbEBn\nbWFpbC5jb20ACgkQfUwvbCISJTKFzQ/+NmdZn+/82+PDErH63aVFODhn0bg/6UaB\nuqGPa0mK8ej03eCDYiq4TCWTNaYnJC9YuaeQf4LBZ0QGfRvWsSyJ5WXjWPE6Fdfv\nuFZTg+leqZ/qnxju6ylTA5P2rE88I/KqAcDAnoCuf0G86i4CbcTdRBvVtmhPeTJf\nSCzWDmnQwWqjSQSLPv/jxtFYmX0BludZJirKcH8Ypgit8nNc30Y4fELeA5TiOwGD\nL7dHyAiZgn5uBBmIQdfWvLbfEpYZgtKayzqVTTNbOJjUvirdDh4ezj+lSzXFwh+V\nyTvKm83HAFN2xmQDBreJTq8DaN5hgFLGM62IkMs7sIDKPOs5bnT4zlwK46HMiqoz\nQOOkpei23s97Z3cAPrvA+gTbB3fnSDBhdrc+5jG/52BIgokTZxS1VAZ0Nz7qDmpR\nUMCIWi8TcIYyIx0mHAKCRQmG3f0Sf+7VEAf3xbg9BjncwKAFYw9GmEU3xfIBfTdn\nbebf0wAllaCCO0mJM21y9c+Pr8DT+rMEZ6wknrc0/B/8KaOwzsvzFi+ughfXBgSL\nAlK98eZ4JaPdKJsraYQdvp5L3ORsb6uJ36+aIe7532qBQvCaLGZ51G0ud5k0pzZn\n01MUH1mBMf/ZuAUJy250UlYRYXy0fHenDQVr6t93wABw+yPkya2VfiChoWTJHPPg\nFxiTQlRKayw=\n=oAwF\n-----END PGP SIGNATURE-----", "payload": "tree 7d4292ed2b139d552ec4064f747ebf900f13dcab\nparent 9fa6bb2aa0d076cffac5699643eb5f473b6eba16\nauthor Alan Egerton <eggyal@gmail.com> 1676045658 +0000\ncommitter Alan Egerton <eggyal@gmail.com> 1676283890 +0000\n\nMove folding and visiting traits into type library\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/459e1424134423d28a94a392e071300675677342", "html_url": "https://github.com/rust-lang/rust/commit/459e1424134423d28a94a392e071300675677342", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/459e1424134423d28a94a392e071300675677342/comments", "author": {"login": "eggyal", "id": 3089613, "node_id": "MDQ6VXNlcjMwODk2MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3089613?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eggyal", "html_url": "https://github.com/eggyal", "followers_url": "https://api.github.com/users/eggyal/followers", "following_url": "https://api.github.com/users/eggyal/following{/other_user}", "gists_url": "https://api.github.com/users/eggyal/gists{/gist_id}", "starred_url": "https://api.github.com/users/eggyal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eggyal/subscriptions", "organizations_url": "https://api.github.com/users/eggyal/orgs", "repos_url": "https://api.github.com/users/eggyal/repos", "events_url": "https://api.github.com/users/eggyal/events{/privacy}", "received_events_url": "https://api.github.com/users/eggyal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eggyal", "id": 3089613, "node_id": "MDQ6VXNlcjMwODk2MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3089613?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eggyal", "html_url": "https://github.com/eggyal", "followers_url": "https://api.github.com/users/eggyal/followers", "following_url": "https://api.github.com/users/eggyal/following{/other_user}", "gists_url": "https://api.github.com/users/eggyal/gists{/gist_id}", "starred_url": "https://api.github.com/users/eggyal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eggyal/subscriptions", "organizations_url": "https://api.github.com/users/eggyal/orgs", "repos_url": "https://api.github.com/users/eggyal/repos", "events_url": "https://api.github.com/users/eggyal/events{/privacy}", "received_events_url": "https://api.github.com/users/eggyal/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fa6bb2aa0d076cffac5699643eb5f473b6eba16", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fa6bb2aa0d076cffac5699643eb5f473b6eba16", "html_url": "https://github.com/rust-lang/rust/commit/9fa6bb2aa0d076cffac5699643eb5f473b6eba16"}], "stats": {"total": 1560, "additions": 805, "deletions": 755}, "files": [{"sha": "e6cd38c0f1584661073539e572ec350bed32fb89", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/459e1424134423d28a94a392e071300675677342/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459e1424134423d28a94a392e071300675677342/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=459e1424134423d28a94a392e071300675677342", "patch": "@@ -48,12 +48,10 @@\n #![feature(associated_type_bounds)]\n #![feature(rustc_attrs)]\n #![feature(control_flow_enum)]\n-#![feature(associated_type_defaults)]\n #![feature(trusted_step)]\n #![feature(try_blocks)]\n #![feature(try_reserve_kind)]\n #![feature(nonzero_ops)]\n-#![feature(unwrap_infallible)]\n #![feature(decl_macro)]\n #![feature(drain_filter)]\n #![feature(intra_doc_pointers)]"}, {"sha": "57d66ac6a039e27cb79af4e543264ec56c89f103", "filename": "compiler/rustc_middle/src/macros.rs", "status": "modified", "additions": 4, "deletions": 170, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/459e1424134423d28a94a392e071300675677342/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459e1424134423d28a94a392e071300675677342/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs?ref=459e1424134423d28a94a392e071300675677342", "patch": "@@ -100,35 +100,11 @@ macro_rules! TrivialTypeTraversalImpls {\n     };\n \n     ($($ty:ty,)+) => {\n-        $(\n-            impl<I: $crate::ty::Interner> $crate::ty::fold::ir::TypeFoldable<I> for $ty {\n-                fn try_fold_with<F: $crate::ty::fold::ir::FallibleTypeFolder<I>>(\n-                    self,\n-                    _: &mut F,\n-                ) -> ::std::result::Result<Self, F::Error> {\n-                    Ok(self)\n-                }\n-\n-                #[inline]\n-                fn fold_with<F: $crate::ty::fold::ir::TypeFolder<I>>(\n-                    self,\n-                    _: &mut F,\n-                ) -> Self {\n-                    self\n-                }\n-            }\n-\n-            impl<I: $crate::ty::Interner> $crate::ty::visit::ir::TypeVisitable<I> for $ty {\n-                #[inline]\n-                fn visit_with<F: $crate::ty::visit::ir::TypeVisitor<I>>(\n-                    &self,\n-                    _: &mut F)\n-                    -> ::std::ops::ControlFlow<F::BreakTy>\n-                {\n-                    ::std::ops::ControlFlow::Continue(())\n-                }\n+        TrivialTypeTraversalImpls! {\n+            for<'tcx> {\n+                $($ty,)+\n             }\n-        )+\n+        }\n     };\n }\n \n@@ -139,145 +115,3 @@ macro_rules! TrivialTypeTraversalAndLiftImpls {\n         CloneLiftImpls! { $($t)* }\n     }\n }\n-\n-#[macro_export]\n-macro_rules! EnumTypeTraversalImpl {\n-    (impl<$($p:tt),*> TypeFoldable<$tcx:tt> for $s:path {\n-        $($variants:tt)*\n-    } $(where $($wc:tt)*)*) => {\n-        impl<$($p),*> $crate::ty::fold::ir::TypeFoldable<$tcx> for $s\n-            $(where $($wc)*)*\n-        {\n-            fn try_fold_with<V: $crate::ty::fold::ir::FallibleTypeFolder<$tcx>>(\n-                self,\n-                folder: &mut V,\n-            ) -> ::std::result::Result<Self, V::Error> {\n-                EnumTypeTraversalImpl!(@FoldVariants(self, folder) input($($variants)*) output())\n-            }\n-        }\n-    };\n-\n-    (impl<$($p:tt),*> TypeVisitable<$tcx:tt> for $s:path {\n-        $($variants:tt)*\n-    } $(where $($wc:tt)*)*) => {\n-        impl<$($p),*> $crate::ty::visit::ir::TypeVisitable<$tcx> for $s\n-            $(where $($wc)*)*\n-        {\n-            fn visit_with<V: $crate::ty::visit::ir::TypeVisitor<$tcx>>(\n-                &self,\n-                visitor: &mut V,\n-            ) -> ::std::ops::ControlFlow<V::BreakTy> {\n-                EnumTypeTraversalImpl!(@VisitVariants(self, visitor) input($($variants)*) output())\n-            }\n-        }\n-    };\n-\n-    (@FoldVariants($this:expr, $folder:expr) input() output($($output:tt)*)) => {\n-        Ok(match $this {\n-            $($output)*\n-        })\n-    };\n-\n-    (@FoldVariants($this:expr, $folder:expr)\n-     input( ($variant:path) ( $($variant_arg:ident),* ) , $($input:tt)*)\n-     output( $($output:tt)*) ) => {\n-        EnumTypeTraversalImpl!(\n-            @FoldVariants($this, $folder)\n-                input($($input)*)\n-                output(\n-                    $variant ( $($variant_arg),* ) => {\n-                        $variant (\n-                            $($crate::ty::fold::ir::TypeFoldable::try_fold_with($variant_arg, $folder)?),*\n-                        )\n-                    }\n-                    $($output)*\n-                )\n-        )\n-    };\n-\n-    (@FoldVariants($this:expr, $folder:expr)\n-     input( ($variant:path) { $($variant_arg:ident),* $(,)? } , $($input:tt)*)\n-     output( $($output:tt)*) ) => {\n-        EnumTypeTraversalImpl!(\n-            @FoldVariants($this, $folder)\n-                input($($input)*)\n-                output(\n-                    $variant { $($variant_arg),* } => {\n-                        $variant {\n-                            $($variant_arg: $crate::ty::fold::ir::TypeFoldable::fold_with(\n-                                $variant_arg, $folder\n-                            )?),* }\n-                    }\n-                    $($output)*\n-                )\n-        )\n-    };\n-\n-    (@FoldVariants($this:expr, $folder:expr)\n-     input( ($variant:path), $($input:tt)*)\n-     output( $($output:tt)*) ) => {\n-        EnumTypeTraversalImpl!(\n-            @FoldVariants($this, $folder)\n-                input($($input)*)\n-                output(\n-                    $variant => { $variant }\n-                    $($output)*\n-                )\n-        )\n-    };\n-\n-    (@VisitVariants($this:expr, $visitor:expr) input() output($($output:tt)*)) => {\n-        match $this {\n-            $($output)*\n-        }\n-    };\n-\n-    (@VisitVariants($this:expr, $visitor:expr)\n-     input( ($variant:path) ( $($variant_arg:ident),* ) , $($input:tt)*)\n-     output( $($output:tt)*) ) => {\n-        EnumTypeTraversalImpl!(\n-            @VisitVariants($this, $visitor)\n-                input($($input)*)\n-                output(\n-                    $variant ( $($variant_arg),* ) => {\n-                        $($crate::ty::visit::ir::TypeVisitable::visit_with(\n-                            $variant_arg, $visitor\n-                        )?;)*\n-                        ::std::ops::ControlFlow::Continue(())\n-                    }\n-                    $($output)*\n-                )\n-        )\n-    };\n-\n-    (@VisitVariants($this:expr, $visitor:expr)\n-     input( ($variant:path) { $($variant_arg:ident),* $(,)? } , $($input:tt)*)\n-     output( $($output:tt)*) ) => {\n-        EnumTypeTraversalImpl!(\n-            @VisitVariants($this, $visitor)\n-                input($($input)*)\n-                output(\n-                    $variant { $($variant_arg),* } => {\n-                        $($crate::ty::visit::ir::TypeVisitable::visit_with(\n-                            $variant_arg, $visitor\n-                        )?;)*\n-                        ::std::ops::ControlFlow::Continue(())\n-                    }\n-                    $($output)*\n-                )\n-        )\n-    };\n-\n-    (@VisitVariants($this:expr, $visitor:expr)\n-     input( ($variant:path), $($input:tt)*)\n-     output( $($output:tt)*) ) => {\n-        EnumTypeTraversalImpl!(\n-            @VisitVariants($this, $visitor)\n-                input($($input)*)\n-                output(\n-                    $variant => { ::std::ops::ControlFlow::Continue(()) }\n-                    $($output)*\n-                )\n-        )\n-    };\n-}"}, {"sha": "84bd3de0f14039f224d2484e4b213d7dc0a390bc", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 3, "deletions": 239, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/459e1424134423d28a94a392e071300675677342/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459e1424134423d28a94a392e071300675677342/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=459e1424134423d28a94a392e071300675677342", "patch": "@@ -1,47 +1,3 @@\n-//! A folding traversal mechanism for complex data structures that contain type\n-//! information.\n-//!\n-//! This is a modifying traversal. It consumes the data structure, producing a\n-//! (possibly) modified version of it. Both fallible and infallible versions are\n-//! available. The name is potentially confusing, because this traversal is more\n-//! like `Iterator::map` than `Iterator::fold`.\n-//!\n-//! This traversal has limited flexibility. Only a small number of \"types of\n-//! interest\" within the complex data structures can receive custom\n-//! modification. These are the ones containing the most important type-related\n-//! information, such as `Ty`, `Predicate`, `Region`, and `Const`.\n-//!\n-//! There are three groups of traits involved in each traversal.\n-//! - `TypeFoldable`. This is implemented once for many types, including:\n-//!   - Types of interest, for which the methods delegate to the folder.\n-//!   - All other types, including generic containers like `Vec` and `Option`.\n-//!     It defines a \"skeleton\" of how they should be folded.\n-//! - `TypeSuperFoldable`. This is implemented only for each type of interest,\n-//!   and defines the folding \"skeleton\" for these types.\n-//! - `TypeFolder`/`FallibleTypeFolder. One of these is implemented for each\n-//!   folder. This defines how types of interest are folded.\n-//!\n-//! This means each fold is a mixture of (a) generic folding operations, and (b)\n-//! custom fold operations that are specific to the folder.\n-//! - The `TypeFoldable` impls handle most of the traversal, and call into\n-//!   `TypeFolder`/`FallibleTypeFolder` when they encounter a type of interest.\n-//! - A `TypeFolder`/`FallibleTypeFolder` may call into another `TypeFoldable`\n-//!   impl, because some of the types of interest are recursive and can contain\n-//!   other types of interest.\n-//! - A `TypeFolder`/`FallibleTypeFolder` may also call into a `TypeSuperFoldable`\n-//!   impl, because each folder might provide custom handling only for some types\n-//!   of interest, or only for some variants of each type of interest, and then\n-//!   use default traversal for the remaining cases.\n-//!\n-//! For example, if you have `struct S(Ty, U)` where `S: TypeFoldable` and `U:\n-//! TypeFoldable`, and an instance `s = S(ty, u)`, it would be folded like so:\n-//! ```text\n-//! s.fold_with(folder) calls\n-//! - ty.fold_with(folder) calls\n-//!   - folder.fold_ty(ty) may call\n-//!     - ty.super_fold_with(folder)\n-//! - u.fold_with(folder)\n-//! ```\n use crate::ty::{self, Binder, BoundTy, Ty, TyCtxt, TypeVisitable};\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir::def_id::DefId;\n@@ -54,201 +10,9 @@ pub trait TypeFolder<'tcx> = ir::TypeFolder<TyCtxt<'tcx>>;\n pub trait FallibleTypeFolder<'tcx> = ir::FallibleTypeFolder<TyCtxt<'tcx>>;\n \n pub mod ir {\n-    use crate::ty::{ir::TypeVisitable, Interner};\n-\n-    /// This trait is implemented for every type that can be folded,\n-    /// providing the skeleton of the traversal.\n-    ///\n-    /// To implement this conveniently, use the derive macro located in\n-    /// `rustc_macros`.\n-    pub trait TypeFoldable<I: Interner>: TypeVisitable<I> {\n-        /// The entry point for folding. To fold a value `t` with a folder `f`\n-        /// call: `t.try_fold_with(f)`.\n-        ///\n-        /// For most types, this just traverses the value, calling `try_fold_with`\n-        /// on each field/element.\n-        ///\n-        /// For types of interest (such as `Ty`), the implementation of method\n-        /// calls a folder method specifically for that type (such as\n-        /// `F::try_fold_ty`). This is where control transfers from `TypeFoldable`\n-        /// to `TypeFolder`.\n-        fn try_fold_with<F: FallibleTypeFolder<I>>(self, folder: &mut F) -> Result<Self, F::Error>;\n-\n-        /// A convenient alternative to `try_fold_with` for use with infallible\n-        /// folders. Do not override this method, to ensure coherence with\n-        /// `try_fold_with`.\n-        fn fold_with<F: TypeFolder<I>>(self, folder: &mut F) -> Self {\n-            self.try_fold_with(folder).into_ok()\n-        }\n-    }\n-\n-    // This trait is implemented for types of interest.\n-    pub trait TypeSuperFoldable<I: Interner>: TypeFoldable<I> {\n-        /// Provides a default fold for a type of interest. This should only be\n-        /// called within `TypeFolder` methods, when a non-custom traversal is\n-        /// desired for the value of the type of interest passed to that method.\n-        /// For example, in `MyFolder::try_fold_ty(ty)`, it is valid to call\n-        /// `ty.try_super_fold_with(self)`, but any other folding should be done\n-        /// with `xyz.try_fold_with(self)`.\n-        fn try_super_fold_with<F: FallibleTypeFolder<I>>(\n-            self,\n-            folder: &mut F,\n-        ) -> Result<Self, F::Error>;\n-\n-        /// A convenient alternative to `try_super_fold_with` for use with\n-        /// infallible folders. Do not override this method, to ensure coherence\n-        /// with `try_super_fold_with`.\n-        fn super_fold_with<F: TypeFolder<I>>(self, folder: &mut F) -> Self {\n-            self.try_super_fold_with(folder).into_ok()\n-        }\n-    }\n-\n-    /// This trait is implemented for every infallible folding traversal. There is\n-    /// a fold method defined for every type of interest. Each such method has a\n-    /// default that does an \"identity\" fold. Implementations of these methods\n-    /// often fall back to a `super_fold_with` method if the primary argument\n-    /// doesn't satisfy a particular condition.\n-    ///\n-    /// A blanket implementation of [`FallibleTypeFolder`] will defer to\n-    /// the infallible methods of this trait to ensure that the two APIs\n-    /// are coherent.\n-    pub trait TypeFolder<I: Interner>: FallibleTypeFolder<I, Error = !> {\n-        fn tcx(&self) -> I;\n-\n-        fn fold_binder<T>(&mut self, t: I::Binder<T>) -> I::Binder<T>\n-        where\n-            T: TypeFoldable<I>,\n-            I::Binder<T>: TypeSuperFoldable<I>,\n-        {\n-            t.super_fold_with(self)\n-        }\n-\n-        fn fold_ty(&mut self, t: I::Ty) -> I::Ty\n-        where\n-            I::Ty: TypeSuperFoldable<I>,\n-        {\n-            t.super_fold_with(self)\n-        }\n-\n-        fn fold_region(&mut self, r: I::Region) -> I::Region\n-        where\n-            I::Region: TypeSuperFoldable<I>,\n-        {\n-            r.super_fold_with(self)\n-        }\n-\n-        fn fold_const(&mut self, c: I::Const) -> I::Const\n-        where\n-            I::Const: TypeSuperFoldable<I>,\n-        {\n-            c.super_fold_with(self)\n-        }\n-\n-        fn fold_predicate(&mut self, p: I::Predicate) -> I::Predicate\n-        where\n-            I::Predicate: TypeSuperFoldable<I>,\n-        {\n-            p.super_fold_with(self)\n-        }\n-    }\n-\n-    /// This trait is implemented for every folding traversal. There is a fold\n-    /// method defined for every type of interest. Each such method has a default\n-    /// that does an \"identity\" fold.\n-    ///\n-    /// A blanket implementation of this trait (that defers to the relevant\n-    /// method of [`TypeFolder`]) is provided for all infallible folders in\n-    /// order to ensure the two APIs are coherent.\n-    pub trait FallibleTypeFolder<I: Interner>: Sized {\n-        type Error;\n-\n-        fn tcx<'a>(&'a self) -> I;\n-\n-        fn try_fold_binder<T>(&mut self, t: I::Binder<T>) -> Result<I::Binder<T>, Self::Error>\n-        where\n-            T: TypeFoldable<I>,\n-            I::Binder<T>: TypeSuperFoldable<I>,\n-        {\n-            t.try_super_fold_with(self)\n-        }\n-\n-        fn try_fold_ty(&mut self, t: I::Ty) -> Result<I::Ty, Self::Error>\n-        where\n-            I::Ty: TypeSuperFoldable<I>,\n-        {\n-            t.try_super_fold_with(self)\n-        }\n-\n-        fn try_fold_region(&mut self, r: I::Region) -> Result<I::Region, Self::Error>\n-        where\n-            I::Region: TypeSuperFoldable<I>,\n-        {\n-            r.try_super_fold_with(self)\n-        }\n-\n-        fn try_fold_const(&mut self, c: I::Const) -> Result<I::Const, Self::Error>\n-        where\n-            I::Const: TypeSuperFoldable<I>,\n-        {\n-            c.try_super_fold_with(self)\n-        }\n-\n-        fn try_fold_predicate(&mut self, p: I::Predicate) -> Result<I::Predicate, Self::Error>\n-        where\n-            I::Predicate: TypeSuperFoldable<I>,\n-        {\n-            p.try_super_fold_with(self)\n-        }\n-    }\n-\n-    // This blanket implementation of the fallible trait for infallible folders\n-    // delegates to infallible methods to ensure coherence.\n-    impl<I: Interner, F> FallibleTypeFolder<I> for F\n-    where\n-        F: TypeFolder<I>,\n-    {\n-        type Error = !;\n-\n-        fn tcx<'a>(&'a self) -> I {\n-            TypeFolder::tcx(self)\n-        }\n-\n-        fn try_fold_binder<T>(&mut self, t: I::Binder<T>) -> Result<I::Binder<T>, !>\n-        where\n-            T: TypeFoldable<I>,\n-            I::Binder<T>: TypeSuperFoldable<I>,\n-        {\n-            Ok(self.fold_binder(t))\n-        }\n-\n-        fn try_fold_ty(&mut self, t: I::Ty) -> Result<I::Ty, !>\n-        where\n-            I::Ty: TypeSuperFoldable<I>,\n-        {\n-            Ok(self.fold_ty(t))\n-        }\n-\n-        fn try_fold_region(&mut self, r: I::Region) -> Result<I::Region, !>\n-        where\n-            I::Region: TypeSuperFoldable<I>,\n-        {\n-            Ok(self.fold_region(r))\n-        }\n-\n-        fn try_fold_const(&mut self, c: I::Const) -> Result<I::Const, !>\n-        where\n-            I::Const: TypeSuperFoldable<I>,\n-        {\n-            Ok(self.fold_const(c))\n-        }\n-\n-        fn try_fold_predicate(&mut self, p: I::Predicate) -> Result<I::Predicate, !>\n-        where\n-            I::Predicate: TypeSuperFoldable<I>,\n-        {\n-            Ok(self.fold_predicate(p))\n-        }\n-    }\n+    pub use rustc_type_ir::fold::{\n+        FallibleTypeFolder, TypeFoldable, TypeFolder, TypeSuperFoldable,\n+    };\n }\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "cb5f40170ff37d9c4f1058c0cc3c9d1a2910131c", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 19, "deletions": 226, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/459e1424134423d28a94a392e071300675677342/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459e1424134423d28a94a392e071300675677342/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=459e1424134423d28a94a392e071300675677342", "patch": "@@ -1,20 +1,19 @@\n-//! This module contains implements of the `Lift` and `TypeFoldable`\n-//! traits for various types in the Rust compiler. Most are written by\n-//! hand, though we've recently added some macros and proc-macros to help with the tedium.\n+//! This module contains implementations of the `Lift`, `TypeFoldable` and\n+//! `TypeVisitable` traits for various types in the Rust compiler. Most are\n+//! written by hand, though we've recently added some macros and proc-macros\n+//! to help with the tedium.\n \n use crate::mir::interpret;\n use crate::mir::{Field, ProjectionKind};\n use crate::ty::fold::{ir::TypeSuperFoldable, FallibleTypeFolder, TypeFoldable};\n use crate::ty::print::{with_no_trimmed_paths, FmtPrinter, Printer};\n use crate::ty::visit::{ir::TypeSuperVisitable, TypeVisitable, TypeVisitor};\n-use crate::ty::{self, ir, AliasTy, InferConst, Interner, Lift, Term, TermKind, Ty, TyCtxt};\n-use rustc_data_structures::functor::IdFunctor;\n+use crate::ty::{self, ir, AliasTy, InferConst, Lift, Term, TermKind, Ty, TyCtxt};\n use rustc_hir::def::Namespace;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_target::abi::TyAndLayout;\n \n use std::fmt;\n-use std::mem::ManuallyDrop;\n use std::ops::ControlFlow;\n use std::rc::Rc;\n use std::sync::Arc;\n@@ -195,17 +194,27 @@ impl<'tcx> fmt::Debug for AliasTy<'tcx> {\n // Atomic structs\n //\n // For things that don't carry any arena-allocated data (and are\n-// copy...), just add them to this list.\n+// copy...), just add them to one of these lists as appropriat.\n \n-TrivialTypeTraversalAndLiftImpls! {\n+// For things for which the type library provides traversal implementations\n+// for all Interners, we only need to provide a Lift implementation:\n+CloneLiftImpls! {\n     (),\n     bool,\n     usize,\n-    ::rustc_target::abi::VariantIdx,\n     u16,\n     u32,\n     u64,\n     String,\n+    rustc_type_ir::DebruijnIndex,\n+}\n+\n+// For things about which the type library does not know, or does not\n+// provide any traversal implementations, we need to provide both a Lift\n+// implementation and traversal implementations (the latter only for\n+// TyCtxt<'_> interners).\n+TrivialTypeTraversalAndLiftImpls! {\n+    ::rustc_target::abi::VariantIdx,\n     crate::middle::region::Scope,\n     crate::ty::FloatTy,\n     ::rustc_ast::InlineAsmOptions,\n@@ -257,7 +266,6 @@ TrivialTypeTraversalAndLiftImpls! {\n     Field,\n     interpret::Scalar,\n     rustc_target::abi::Size,\n-    rustc_type_ir::DebruijnIndex,\n     ty::BoundVar,\n     ty::Placeholder<ty::BoundVar>,\n }\n@@ -360,7 +368,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ParamEnv<'a> {\n }\n \n ///////////////////////////////////////////////////////////////////////////\n-// TypeFoldable implementations.\n+// Traversal implementations.\n \n /// AdtDefs are basically the same as a DefId.\n impl<'tcx> ir::TypeFoldable<TyCtxt<'tcx>> for ty::AdtDef<'tcx> {\n@@ -375,209 +383,6 @@ impl<'tcx> ir::TypeVisitable<TyCtxt<'tcx>> for ty::AdtDef<'tcx> {\n     }\n }\n \n-impl<I: Interner, T: ir::TypeFoldable<I>, U: ir::TypeFoldable<I>> ir::TypeFoldable<I> for (T, U) {\n-    fn try_fold_with<F: ir::FallibleTypeFolder<I>>(\n-        self,\n-        folder: &mut F,\n-    ) -> Result<(T, U), F::Error> {\n-        Ok((self.0.try_fold_with(folder)?, self.1.try_fold_with(folder)?))\n-    }\n-}\n-\n-impl<I: Interner, T: ir::TypeVisitable<I>, U: ir::TypeVisitable<I>> ir::TypeVisitable<I>\n-    for (T, U)\n-{\n-    fn visit_with<V: ir::TypeVisitor<I>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        self.0.visit_with(visitor)?;\n-        self.1.visit_with(visitor)\n-    }\n-}\n-\n-impl<I: Interner, A: ir::TypeFoldable<I>, B: ir::TypeFoldable<I>, C: ir::TypeFoldable<I>>\n-    ir::TypeFoldable<I> for (A, B, C)\n-{\n-    fn try_fold_with<F: ir::FallibleTypeFolder<I>>(\n-        self,\n-        folder: &mut F,\n-    ) -> Result<(A, B, C), F::Error> {\n-        Ok((\n-            self.0.try_fold_with(folder)?,\n-            self.1.try_fold_with(folder)?,\n-            self.2.try_fold_with(folder)?,\n-        ))\n-    }\n-}\n-\n-impl<I: Interner, A: ir::TypeVisitable<I>, B: ir::TypeVisitable<I>, C: ir::TypeVisitable<I>>\n-    ir::TypeVisitable<I> for (A, B, C)\n-{\n-    fn visit_with<V: ir::TypeVisitor<I>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        self.0.visit_with(visitor)?;\n-        self.1.visit_with(visitor)?;\n-        self.2.visit_with(visitor)\n-    }\n-}\n-\n-EnumTypeTraversalImpl! {\n-    impl<I, T> TypeFoldable<I> for Option<T> {\n-        (Some)(a),\n-        (None),\n-    } where I: Interner, T: ir::TypeFoldable<I>\n-}\n-EnumTypeTraversalImpl! {\n-    impl<I, T> TypeVisitable<I> for Option<T> {\n-        (Some)(a),\n-        (None),\n-    } where I: Interner, T: ir::TypeVisitable<I>\n-}\n-\n-EnumTypeTraversalImpl! {\n-    impl<I, T, E> TypeFoldable<I> for Result<T, E> {\n-        (Ok)(a),\n-        (Err)(a),\n-    } where I: Interner, T: ir::TypeFoldable<I>, E: ir::TypeFoldable<I>,\n-}\n-EnumTypeTraversalImpl! {\n-    impl<I, T, E> TypeVisitable<I> for Result<T, E> {\n-        (Ok)(a),\n-        (Err)(a),\n-    } where I: Interner, T: ir::TypeVisitable<I>, E: ir::TypeVisitable<I>,\n-}\n-\n-impl<I: Interner, T: ir::TypeFoldable<I>> ir::TypeFoldable<I> for Rc<T> {\n-    fn try_fold_with<F: ir::FallibleTypeFolder<I>>(\n-        mut self,\n-        folder: &mut F,\n-    ) -> Result<Self, F::Error> {\n-        // We merely want to replace the contained `T`, if at all possible,\n-        // so that we don't needlessly allocate a new `Rc` or indeed clone\n-        // the contained type.\n-        unsafe {\n-            // First step is to ensure that we have a unique reference to\n-            // the contained type, which `Rc::make_mut` will accomplish (by\n-            // allocating a new `Rc` and cloning the `T` only if required).\n-            // This is done *before* casting to `Rc<ManuallyDrop<T>>` so that\n-            // panicking during `make_mut` does not leak the `T`.\n-            Rc::make_mut(&mut self);\n-\n-            // Casting to `Rc<ManuallyDrop<T>>` is safe because `ManuallyDrop`\n-            // is `repr(transparent)`.\n-            let ptr = Rc::into_raw(self).cast::<ManuallyDrop<T>>();\n-            let mut unique = Rc::from_raw(ptr);\n-\n-            // Call to `Rc::make_mut` above guarantees that `unique` is the\n-            // sole reference to the contained value, so we can avoid doing\n-            // a checked `get_mut` here.\n-            let slot = Rc::get_mut_unchecked(&mut unique);\n-\n-            // Semantically move the contained type out from `unique`, fold\n-            // it, then move the folded value back into `unique`. Should\n-            // folding fail, `ManuallyDrop` ensures that the \"moved-out\"\n-            // value is not re-dropped.\n-            let owned = ManuallyDrop::take(slot);\n-            let folded = owned.try_fold_with(folder)?;\n-            *slot = ManuallyDrop::new(folded);\n-\n-            // Cast back to `Rc<T>`.\n-            Ok(Rc::from_raw(Rc::into_raw(unique).cast()))\n-        }\n-    }\n-}\n-\n-impl<I: Interner, T: ir::TypeVisitable<I>> ir::TypeVisitable<I> for Rc<T> {\n-    fn visit_with<V: ir::TypeVisitor<I>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        (**self).visit_with(visitor)\n-    }\n-}\n-\n-impl<I: Interner, T: ir::TypeFoldable<I>> ir::TypeFoldable<I> for Arc<T> {\n-    fn try_fold_with<F: ir::FallibleTypeFolder<I>>(\n-        mut self,\n-        folder: &mut F,\n-    ) -> Result<Self, F::Error> {\n-        // We merely want to replace the contained `T`, if at all possible,\n-        // so that we don't needlessly allocate a new `Arc` or indeed clone\n-        // the contained type.\n-        unsafe {\n-            // First step is to ensure that we have a unique reference to\n-            // the contained type, which `Arc::make_mut` will accomplish (by\n-            // allocating a new `Arc` and cloning the `T` only if required).\n-            // This is done *before* casting to `Arc<ManuallyDrop<T>>` so that\n-            // panicking during `make_mut` does not leak the `T`.\n-            Arc::make_mut(&mut self);\n-\n-            // Casting to `Arc<ManuallyDrop<T>>` is safe because `ManuallyDrop`\n-            // is `repr(transparent)`.\n-            let ptr = Arc::into_raw(self).cast::<ManuallyDrop<T>>();\n-            let mut unique = Arc::from_raw(ptr);\n-\n-            // Call to `Arc::make_mut` above guarantees that `unique` is the\n-            // sole reference to the contained value, so we can avoid doing\n-            // a checked `get_mut` here.\n-            let slot = Arc::get_mut_unchecked(&mut unique);\n-\n-            // Semantically move the contained type out from `unique`, fold\n-            // it, then move the folded value back into `unique`. Should\n-            // folding fail, `ManuallyDrop` ensures that the \"moved-out\"\n-            // value is not re-dropped.\n-            let owned = ManuallyDrop::take(slot);\n-            let folded = owned.try_fold_with(folder)?;\n-            *slot = ManuallyDrop::new(folded);\n-\n-            // Cast back to `Arc<T>`.\n-            Ok(Arc::from_raw(Arc::into_raw(unique).cast()))\n-        }\n-    }\n-}\n-\n-impl<I: Interner, T: ir::TypeVisitable<I>> ir::TypeVisitable<I> for Arc<T> {\n-    fn visit_with<V: ir::TypeVisitor<I>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        (**self).visit_with(visitor)\n-    }\n-}\n-\n-impl<I: Interner, T: ir::TypeFoldable<I>> ir::TypeFoldable<I> for Box<T> {\n-    fn try_fold_with<F: ir::FallibleTypeFolder<I>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        self.try_map_id(|value| value.try_fold_with(folder))\n-    }\n-}\n-\n-impl<I: Interner, T: ir::TypeVisitable<I>> ir::TypeVisitable<I> for Box<T> {\n-    fn visit_with<V: ir::TypeVisitor<I>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        (**self).visit_with(visitor)\n-    }\n-}\n-\n-impl<I: Interner, T: ir::TypeFoldable<I>> ir::TypeFoldable<I> for Vec<T> {\n-    fn try_fold_with<F: ir::FallibleTypeFolder<I>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        self.try_map_id(|t| t.try_fold_with(folder))\n-    }\n-}\n-\n-impl<I: Interner, T: ir::TypeVisitable<I>> ir::TypeVisitable<I> for Vec<T> {\n-    fn visit_with<V: ir::TypeVisitor<I>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        self.iter().try_for_each(|t| t.visit_with(visitor))\n-    }\n-}\n-\n-impl<I: Interner, T: ir::TypeVisitable<I>> ir::TypeVisitable<I> for &[T] {\n-    fn visit_with<V: ir::TypeVisitor<I>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        self.iter().try_for_each(|t| t.visit_with(visitor))\n-    }\n-}\n-\n-impl<I: Interner, T: ir::TypeFoldable<I>> ir::TypeFoldable<I> for Box<[T]> {\n-    fn try_fold_with<F: ir::FallibleTypeFolder<I>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        self.try_map_id(|t| t.try_fold_with(folder))\n-    }\n-}\n-\n-impl<I: Interner, T: ir::TypeVisitable<I>> ir::TypeVisitable<I> for Box<[T]> {\n-    fn visit_with<V: ir::TypeVisitor<I>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        self.iter().try_for_each(|t| t.visit_with(visitor))\n-    }\n-}\n-\n impl<'tcx, T: TypeFoldable<'tcx>> ir::TypeFoldable<TyCtxt<'tcx>> for ty::Binder<'tcx, T> {\n     fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         folder.try_fold_binder(self)\n@@ -790,18 +595,6 @@ impl<'tcx> ir::TypeFoldable<TyCtxt<'tcx>> for &'tcx ty::List<ty::Predicate<'tcx>\n     }\n }\n \n-impl<I: Interner, T: ir::TypeFoldable<I>, Ix: Idx> ir::TypeFoldable<I> for IndexVec<Ix, T> {\n-    fn try_fold_with<F: ir::FallibleTypeFolder<I>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        self.try_map_id(|x| x.try_fold_with(folder))\n-    }\n-}\n-\n-impl<I: Interner, T: ir::TypeVisitable<I>, Ix: Idx> ir::TypeVisitable<I> for IndexVec<Ix, T> {\n-    fn visit_with<V: ir::TypeVisitor<I>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        self.iter().try_for_each(|t| t.visit_with(visitor))\n-    }\n-}\n-\n impl<'tcx> ir::TypeFoldable<TyCtxt<'tcx>> for ty::Const<'tcx> {\n     fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         folder.try_fold_const(self)"}, {"sha": "8a93b59900e15e267a6507613907c96ca1774fa2", "filename": "compiler/rustc_middle/src/ty/visit.rs", "status": "modified", "additions": 1, "deletions": 118, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/459e1424134423d28a94a392e071300675677342/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459e1424134423d28a94a392e071300675677342/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs?ref=459e1424134423d28a94a392e071300675677342", "patch": "@@ -1,43 +1,3 @@\n-//! A visiting traversal mechanism for complex data structures that contain type\n-//! information.\n-//!\n-//! This is a read-only traversal of the data structure.\n-//!\n-//! This traversal has limited flexibility. Only a small number of \"types of\n-//! interest\" within the complex data structures can receive custom\n-//! visitation. These are the ones containing the most important type-related\n-//! information, such as `Ty`, `Predicate`, `Region`, and `Const`.\n-//!\n-//! There are three groups of traits involved in each traversal.\n-//! - `TypeVisitable`. This is implemented once for many types, including:\n-//!   - Types of interest, for which the methods delegate to the visitor.\n-//!   - All other types, including generic containers like `Vec` and `Option`.\n-//!     It defines a \"skeleton\" of how they should be visited.\n-//! - `TypeSuperVisitable`. This is implemented only for each type of interest,\n-//!   and defines the visiting \"skeleton\" for these types.\n-//! - `TypeVisitor`. This is implemented for each visitor. This defines how\n-//!   types of interest are visited.\n-//!\n-//! This means each visit is a mixture of (a) generic visiting operations, and (b)\n-//! custom visit operations that are specific to the visitor.\n-//! - The `TypeVisitable` impls handle most of the traversal, and call into\n-//!   `TypeVisitor` when they encounter a type of interest.\n-//! - A `TypeVisitor` may call into another `TypeVisitable` impl, because some of\n-//!   the types of interest are recursive and can contain other types of interest.\n-//! - A `TypeVisitor` may also call into a `TypeSuperVisitable` impl, because each\n-//!   visitor might provide custom handling only for some types of interest, or\n-//!   only for some variants of each type of interest, and then use default\n-//!   traversal for the remaining cases.\n-//!\n-//! For example, if you have `struct S(Ty, U)` where `S: TypeVisitable` and `U:\n-//! TypeVisitable`, and an instance `s = S(ty, u)`, it would be visited like so:\n-//! ```text\n-//! s.visit_with(visitor) calls\n-//! - ty.visit_with(visitor) calls\n-//!   - visitor.visit_ty(ty) may call\n-//!     - ty.super_visit_with(visitor)\n-//! - u.visit_with(visitor)\n-//! ```\n use crate::ty::{self, flags::FlagComputation, Binder, Ty, TyCtxt, TypeFlags};\n use rustc_errors::ErrorGuaranteed;\n \n@@ -50,84 +10,7 @@ pub trait TypeSuperVisitable<'tcx> = ir::TypeSuperVisitable<TyCtxt<'tcx>>;\n pub trait TypeVisitor<'tcx> = ir::TypeVisitor<TyCtxt<'tcx>>;\n \n pub mod ir {\n-    use crate::ty::Interner;\n-\n-    use std::fmt;\n-    use std::ops::ControlFlow;\n-\n-    /// This trait is implemented for every type that can be visited,\n-    /// providing the skeleton of the traversal.\n-    ///\n-    /// To implement this conveniently, use the derive macro located in\n-    /// `rustc_macros`.\n-    pub trait TypeVisitable<I: Interner>: fmt::Debug + Clone {\n-        /// The entry point for visiting. To visit a value `t` with a visitor `v`\n-        /// call: `t.visit_with(v)`.\n-        ///\n-        /// For most types, this just traverses the value, calling `visit_with` on\n-        /// each field/element.\n-        ///\n-        /// For types of interest (such as `Ty`), the implementation of this method\n-        /// that calls a visitor method specifically for that type (such as\n-        /// `V::visit_ty`). This is where control transfers from `TypeFoldable` to\n-        /// `TypeVisitor`.\n-        fn visit_with<V: TypeVisitor<I>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy>;\n-    }\n-\n-    pub trait TypeSuperVisitable<I: Interner>: TypeVisitable<I> {\n-        /// Provides a default visit for a type of interest. This should only be\n-        /// called within `TypeVisitor` methods, when a non-custom traversal is\n-        /// desired for the value of the type of interest passed to that method.\n-        /// For example, in `MyVisitor::visit_ty(ty)`, it is valid to call\n-        /// `ty.super_visit_with(self)`, but any other visiting should be done\n-        /// with `xyz.visit_with(self)`.\n-        fn super_visit_with<V: TypeVisitor<I>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy>;\n-    }\n-\n-    /// This trait is implemented for every visiting traversal. There is a visit\n-    /// method defined for every type of interest. Each such method has a default\n-    /// that recurses into the type's fields in a non-custom fashion.\n-    pub trait TypeVisitor<I: Interner>: Sized {\n-        type BreakTy = !;\n-\n-        fn visit_binder<T: TypeVisitable<I>>(\n-            &mut self,\n-            t: &I::Binder<T>,\n-        ) -> ControlFlow<Self::BreakTy>\n-        where\n-            I::Binder<T>: TypeSuperVisitable<I>,\n-        {\n-            t.super_visit_with(self)\n-        }\n-\n-        fn visit_ty(&mut self, t: I::Ty) -> ControlFlow<Self::BreakTy>\n-        where\n-            I::Ty: TypeSuperVisitable<I>,\n-        {\n-            t.super_visit_with(self)\n-        }\n-\n-        fn visit_region(&mut self, r: I::Region) -> ControlFlow<Self::BreakTy>\n-        where\n-            I::Region: TypeSuperVisitable<I>,\n-        {\n-            r.super_visit_with(self)\n-        }\n-\n-        fn visit_const(&mut self, c: I::Const) -> ControlFlow<Self::BreakTy>\n-        where\n-            I::Const: TypeSuperVisitable<I>,\n-        {\n-            c.super_visit_with(self)\n-        }\n-\n-        fn visit_predicate(&mut self, p: I::Predicate) -> ControlFlow<Self::BreakTy>\n-        where\n-            I::Predicate: TypeSuperVisitable<I>,\n-        {\n-            p.super_visit_with(self)\n-        }\n-    }\n+    pub use rustc_type_ir::visit::{TypeSuperVisitable, TypeVisitable, TypeVisitor};\n }\n \n pub trait TypeVisitableExt<'tcx>: ir::TypeVisitable<TyCtxt<'tcx>> {"}, {"sha": "113ab36ccf190beeb106d46bbbdb3e27e03c82ba", "filename": "compiler/rustc_type_ir/src/fold.rs", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/459e1424134423d28a94a392e071300675677342/compiler%2Frustc_type_ir%2Fsrc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459e1424134423d28a94a392e071300675677342/compiler%2Frustc_type_ir%2Fsrc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Ffold.rs?ref=459e1424134423d28a94a392e071300675677342", "patch": "@@ -0,0 +1,239 @@\n+//! A folding traversal mechanism for complex data structures that contain type\n+//! information.\n+//!\n+//! This is a modifying traversal. It consumes the data structure, producing a\n+//! (possibly) modified version of it. Both fallible and infallible versions are\n+//! available. The name is potentially confusing, because this traversal is more\n+//! like `Iterator::map` than `Iterator::fold`.\n+//!\n+//! This traversal has limited flexibility. Only a small number of \"types of\n+//! interest\" within the complex data structures can receive custom\n+//! modification. These are the ones containing the most important type-related\n+//! information, such as `Ty`, `Predicate`, `Region`, and `Const`.\n+//!\n+//! There are three groups of traits involved in each traversal.\n+//! - `TypeFoldable`. This is implemented once for many types, including:\n+//!   - Types of interest, for which the methods delegate to the folder.\n+//!   - All other types, including generic containers like `Vec` and `Option`.\n+//!     It defines a \"skeleton\" of how they should be folded.\n+//! - `TypeSuperFoldable`. This is implemented only for each type of interest,\n+//!   and defines the folding \"skeleton\" for these types.\n+//! - `TypeFolder`/`FallibleTypeFolder. One of these is implemented for each\n+//!   folder. This defines how types of interest are folded.\n+//!\n+//! This means each fold is a mixture of (a) generic folding operations, and (b)\n+//! custom fold operations that are specific to the folder.\n+//! - The `TypeFoldable` impls handle most of the traversal, and call into\n+//!   `TypeFolder`/`FallibleTypeFolder` when they encounter a type of interest.\n+//! - A `TypeFolder`/`FallibleTypeFolder` may call into another `TypeFoldable`\n+//!   impl, because some of the types of interest are recursive and can contain\n+//!   other types of interest.\n+//! - A `TypeFolder`/`FallibleTypeFolder` may also call into a `TypeSuperFoldable`\n+//!   impl, because each folder might provide custom handling only for some types\n+//!   of interest, or only for some variants of each type of interest, and then\n+//!   use default traversal for the remaining cases.\n+//!\n+//! For example, if you have `struct S(Ty, U)` where `S: TypeFoldable` and `U:\n+//! TypeFoldable`, and an instance `s = S(ty, u)`, it would be folded like so:\n+//! ```text\n+//! s.fold_with(folder) calls\n+//! - ty.fold_with(folder) calls\n+//!   - folder.fold_ty(ty) may call\n+//!     - ty.super_fold_with(folder)\n+//! - u.fold_with(folder)\n+//! ```\n+use crate::{visit::TypeVisitable, Interner};\n+\n+/// This trait is implemented for every type that can be folded,\n+/// providing the skeleton of the traversal.\n+///\n+/// To implement this conveniently, use the derive macro located in\n+/// `rustc_macros`.\n+pub trait TypeFoldable<I: Interner>: TypeVisitable<I> {\n+    /// The entry point for folding. To fold a value `t` with a folder `f`\n+    /// call: `t.try_fold_with(f)`.\n+    ///\n+    /// For most types, this just traverses the value, calling `try_fold_with`\n+    /// on each field/element.\n+    ///\n+    /// For types of interest (such as `Ty`), the implementation of method\n+    /// calls a folder method specifically for that type (such as\n+    /// `F::try_fold_ty`). This is where control transfers from `TypeFoldable`\n+    /// to `TypeFolder`.\n+    fn try_fold_with<F: FallibleTypeFolder<I>>(self, folder: &mut F) -> Result<Self, F::Error>;\n+\n+    /// A convenient alternative to `try_fold_with` for use with infallible\n+    /// folders. Do not override this method, to ensure coherence with\n+    /// `try_fold_with`.\n+    fn fold_with<F: TypeFolder<I>>(self, folder: &mut F) -> Self {\n+        self.try_fold_with(folder).into_ok()\n+    }\n+}\n+\n+// This trait is implemented for types of interest.\n+pub trait TypeSuperFoldable<I: Interner>: TypeFoldable<I> {\n+    /// Provides a default fold for a type of interest. This should only be\n+    /// called within `TypeFolder` methods, when a non-custom traversal is\n+    /// desired for the value of the type of interest passed to that method.\n+    /// For example, in `MyFolder::try_fold_ty(ty)`, it is valid to call\n+    /// `ty.try_super_fold_with(self)`, but any other folding should be done\n+    /// with `xyz.try_fold_with(self)`.\n+    fn try_super_fold_with<F: FallibleTypeFolder<I>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error>;\n+\n+    /// A convenient alternative to `try_super_fold_with` for use with\n+    /// infallible folders. Do not override this method, to ensure coherence\n+    /// with `try_super_fold_with`.\n+    fn super_fold_with<F: TypeFolder<I>>(self, folder: &mut F) -> Self {\n+        self.try_super_fold_with(folder).into_ok()\n+    }\n+}\n+\n+/// This trait is implemented for every infallible folding traversal. There is\n+/// a fold method defined for every type of interest. Each such method has a\n+/// default that does an \"identity\" fold. Implementations of these methods\n+/// often fall back to a `super_fold_with` method if the primary argument\n+/// doesn't satisfy a particular condition.\n+///\n+/// A blanket implementation of [`FallibleTypeFolder`] will defer to\n+/// the infallible methods of this trait to ensure that the two APIs\n+/// are coherent.\n+pub trait TypeFolder<I: Interner>: FallibleTypeFolder<I, Error = !> {\n+    fn tcx(&self) -> I;\n+\n+    fn fold_binder<T>(&mut self, t: I::Binder<T>) -> I::Binder<T>\n+    where\n+        T: TypeFoldable<I>,\n+        I::Binder<T>: TypeSuperFoldable<I>,\n+    {\n+        t.super_fold_with(self)\n+    }\n+\n+    fn fold_ty(&mut self, t: I::Ty) -> I::Ty\n+    where\n+        I::Ty: TypeSuperFoldable<I>,\n+    {\n+        t.super_fold_with(self)\n+    }\n+\n+    fn fold_region(&mut self, r: I::Region) -> I::Region\n+    where\n+        I::Region: TypeSuperFoldable<I>,\n+    {\n+        r.super_fold_with(self)\n+    }\n+\n+    fn fold_const(&mut self, c: I::Const) -> I::Const\n+    where\n+        I::Const: TypeSuperFoldable<I>,\n+    {\n+        c.super_fold_with(self)\n+    }\n+\n+    fn fold_predicate(&mut self, p: I::Predicate) -> I::Predicate\n+    where\n+        I::Predicate: TypeSuperFoldable<I>,\n+    {\n+        p.super_fold_with(self)\n+    }\n+}\n+\n+/// This trait is implemented for every folding traversal. There is a fold\n+/// method defined for every type of interest. Each such method has a default\n+/// that does an \"identity\" fold.\n+///\n+/// A blanket implementation of this trait (that defers to the relevant\n+/// method of [`TypeFolder`]) is provided for all infallible folders in\n+/// order to ensure the two APIs are coherent.\n+pub trait FallibleTypeFolder<I: Interner>: Sized {\n+    type Error;\n+\n+    fn tcx<'a>(&'a self) -> I;\n+\n+    fn try_fold_binder<T>(&mut self, t: I::Binder<T>) -> Result<I::Binder<T>, Self::Error>\n+    where\n+        T: TypeFoldable<I>,\n+        I::Binder<T>: TypeSuperFoldable<I>,\n+    {\n+        t.try_super_fold_with(self)\n+    }\n+\n+    fn try_fold_ty(&mut self, t: I::Ty) -> Result<I::Ty, Self::Error>\n+    where\n+        I::Ty: TypeSuperFoldable<I>,\n+    {\n+        t.try_super_fold_with(self)\n+    }\n+\n+    fn try_fold_region(&mut self, r: I::Region) -> Result<I::Region, Self::Error>\n+    where\n+        I::Region: TypeSuperFoldable<I>,\n+    {\n+        r.try_super_fold_with(self)\n+    }\n+\n+    fn try_fold_const(&mut self, c: I::Const) -> Result<I::Const, Self::Error>\n+    where\n+        I::Const: TypeSuperFoldable<I>,\n+    {\n+        c.try_super_fold_with(self)\n+    }\n+\n+    fn try_fold_predicate(&mut self, p: I::Predicate) -> Result<I::Predicate, Self::Error>\n+    where\n+        I::Predicate: TypeSuperFoldable<I>,\n+    {\n+        p.try_super_fold_with(self)\n+    }\n+}\n+\n+// This blanket implementation of the fallible trait for infallible folders\n+// delegates to infallible methods to ensure coherence.\n+impl<I: Interner, F> FallibleTypeFolder<I> for F\n+where\n+    F: TypeFolder<I>,\n+{\n+    type Error = !;\n+\n+    fn tcx<'a>(&'a self) -> I {\n+        TypeFolder::tcx(self)\n+    }\n+\n+    fn try_fold_binder<T>(&mut self, t: I::Binder<T>) -> Result<I::Binder<T>, !>\n+    where\n+        T: TypeFoldable<I>,\n+        I::Binder<T>: TypeSuperFoldable<I>,\n+    {\n+        Ok(self.fold_binder(t))\n+    }\n+\n+    fn try_fold_ty(&mut self, t: I::Ty) -> Result<I::Ty, !>\n+    where\n+        I::Ty: TypeSuperFoldable<I>,\n+    {\n+        Ok(self.fold_ty(t))\n+    }\n+\n+    fn try_fold_region(&mut self, r: I::Region) -> Result<I::Region, !>\n+    where\n+        I::Region: TypeSuperFoldable<I>,\n+    {\n+        Ok(self.fold_region(r))\n+    }\n+\n+    fn try_fold_const(&mut self, c: I::Const) -> Result<I::Const, !>\n+    where\n+        I::Const: TypeSuperFoldable<I>,\n+    {\n+        Ok(self.fold_const(c))\n+    }\n+\n+    fn try_fold_predicate(&mut self, p: I::Predicate) -> Result<I::Predicate, !>\n+    where\n+        I::Predicate: TypeSuperFoldable<I>,\n+    {\n+        Ok(self.fold_predicate(p))\n+    }\n+}"}, {"sha": "29d261fda8d9c3c8cd3f203ba959e8ac58adbe42", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/459e1424134423d28a94a392e071300675677342/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459e1424134423d28a94a392e071300675677342/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=459e1424134423d28a94a392e071300675677342", "patch": "@@ -1,6 +1,10 @@\n+#![feature(associated_type_defaults)]\n #![feature(fmt_helpers_for_derive)]\n+#![feature(get_mut_unchecked)]\n #![feature(min_specialization)]\n+#![feature(never_type)]\n #![feature(rustc_attrs)]\n+#![feature(unwrap_infallible)]\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n \n@@ -18,8 +22,14 @@ use std::hash::Hash;\n use std::mem::discriminant;\n \n pub mod codec;\n+pub mod fold;\n pub mod sty;\n pub mod ty_info;\n+pub mod visit;\n+\n+#[macro_use]\n+mod macros;\n+mod structural_impls;\n \n pub use codec::*;\n pub use sty::*;"}, {"sha": "6c181039730b7a5e6574a008665c4c29c3f9e445", "filename": "compiler/rustc_type_ir/src/macros.rs", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/459e1424134423d28a94a392e071300675677342/compiler%2Frustc_type_ir%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459e1424134423d28a94a392e071300675677342/compiler%2Frustc_type_ir%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fmacros.rs?ref=459e1424134423d28a94a392e071300675677342", "patch": "@@ -0,0 +1,176 @@\n+/// Used for types that are `Copy` and which **do not care arena\n+/// allocated data** (i.e., don't need to be folded).\n+macro_rules! TrivialTypeTraversalImpls {\n+    ($($ty:ty,)+) => {\n+        $(\n+            impl<I: $crate::Interner> $crate::fold::TypeFoldable<I> for $ty {\n+                fn try_fold_with<F: $crate::fold::FallibleTypeFolder<I>>(\n+                    self,\n+                    _: &mut F,\n+                ) -> ::std::result::Result<Self, F::Error> {\n+                    Ok(self)\n+                }\n+\n+                #[inline]\n+                fn fold_with<F: $crate::fold::TypeFolder<I>>(\n+                    self,\n+                    _: &mut F,\n+                ) -> Self {\n+                    self\n+                }\n+            }\n+\n+            impl<I: $crate::Interner> $crate::visit::TypeVisitable<I> for $ty {\n+                #[inline]\n+                fn visit_with<F: $crate::visit::TypeVisitor<I>>(\n+                    &self,\n+                    _: &mut F)\n+                    -> ::std::ops::ControlFlow<F::BreakTy>\n+                {\n+                    ::std::ops::ControlFlow::Continue(())\n+                }\n+            }\n+        )+\n+    };\n+}\n+\n+macro_rules! EnumTypeTraversalImpl {\n+    (impl<$($p:tt),*> TypeFoldable<$tcx:tt> for $s:path {\n+        $($variants:tt)*\n+    } $(where $($wc:tt)*)*) => {\n+        impl<$($p),*> $crate::fold::TypeFoldable<$tcx> for $s\n+            $(where $($wc)*)*\n+        {\n+            fn try_fold_with<V: $crate::fold::FallibleTypeFolder<$tcx>>(\n+                self,\n+                folder: &mut V,\n+            ) -> ::std::result::Result<Self, V::Error> {\n+                EnumTypeTraversalImpl!(@FoldVariants(self, folder) input($($variants)*) output())\n+            }\n+        }\n+    };\n+\n+    (impl<$($p:tt),*> TypeVisitable<$tcx:tt> for $s:path {\n+        $($variants:tt)*\n+    } $(where $($wc:tt)*)*) => {\n+        impl<$($p),*> $crate::visit::TypeVisitable<$tcx> for $s\n+            $(where $($wc)*)*\n+        {\n+            fn visit_with<V: $crate::visit::TypeVisitor<$tcx>>(\n+                &self,\n+                visitor: &mut V,\n+            ) -> ::std::ops::ControlFlow<V::BreakTy> {\n+                EnumTypeTraversalImpl!(@VisitVariants(self, visitor) input($($variants)*) output())\n+            }\n+        }\n+    };\n+\n+    (@FoldVariants($this:expr, $folder:expr) input() output($($output:tt)*)) => {\n+        Ok(match $this {\n+            $($output)*\n+        })\n+    };\n+\n+    (@FoldVariants($this:expr, $folder:expr)\n+     input( ($variant:path) ( $($variant_arg:ident),* ) , $($input:tt)*)\n+     output( $($output:tt)*) ) => {\n+        EnumTypeTraversalImpl!(\n+            @FoldVariants($this, $folder)\n+                input($($input)*)\n+                output(\n+                    $variant ( $($variant_arg),* ) => {\n+                        $variant (\n+                            $($crate::fold::TypeFoldable::try_fold_with($variant_arg, $folder)?),*\n+                        )\n+                    }\n+                    $($output)*\n+                )\n+        )\n+    };\n+\n+    (@FoldVariants($this:expr, $folder:expr)\n+     input( ($variant:path) { $($variant_arg:ident),* $(,)? } , $($input:tt)*)\n+     output( $($output:tt)*) ) => {\n+        EnumTypeTraversalImpl!(\n+            @FoldVariants($this, $folder)\n+                input($($input)*)\n+                output(\n+                    $variant { $($variant_arg),* } => {\n+                        $variant {\n+                            $($variant_arg: $crate::fold::TypeFoldable::fold_with(\n+                                $variant_arg, $folder\n+                            )?),* }\n+                    }\n+                    $($output)*\n+                )\n+        )\n+    };\n+\n+    (@FoldVariants($this:expr, $folder:expr)\n+     input( ($variant:path), $($input:tt)*)\n+     output( $($output:tt)*) ) => {\n+        EnumTypeTraversalImpl!(\n+            @FoldVariants($this, $folder)\n+                input($($input)*)\n+                output(\n+                    $variant => { $variant }\n+                    $($output)*\n+                )\n+        )\n+    };\n+\n+    (@VisitVariants($this:expr, $visitor:expr) input() output($($output:tt)*)) => {\n+        match $this {\n+            $($output)*\n+        }\n+    };\n+\n+    (@VisitVariants($this:expr, $visitor:expr)\n+     input( ($variant:path) ( $($variant_arg:ident),* ) , $($input:tt)*)\n+     output( $($output:tt)*) ) => {\n+        EnumTypeTraversalImpl!(\n+            @VisitVariants($this, $visitor)\n+                input($($input)*)\n+                output(\n+                    $variant ( $($variant_arg),* ) => {\n+                        $($crate::visit::TypeVisitable::visit_with(\n+                            $variant_arg, $visitor\n+                        )?;)*\n+                        ::std::ops::ControlFlow::Continue(())\n+                    }\n+                    $($output)*\n+                )\n+        )\n+    };\n+\n+    (@VisitVariants($this:expr, $visitor:expr)\n+     input( ($variant:path) { $($variant_arg:ident),* $(,)? } , $($input:tt)*)\n+     output( $($output:tt)*) ) => {\n+        EnumTypeTraversalImpl!(\n+            @VisitVariants($this, $visitor)\n+                input($($input)*)\n+                output(\n+                    $variant { $($variant_arg),* } => {\n+                        $($crate::visit::TypeVisitable::visit_with(\n+                            $variant_arg, $visitor\n+                        )?;)*\n+                        ::std::ops::ControlFlow::Continue(())\n+                    }\n+                    $($output)*\n+                )\n+        )\n+    };\n+\n+    (@VisitVariants($this:expr, $visitor:expr)\n+     input( ($variant:path), $($input:tt)*)\n+     output( $($output:tt)*) ) => {\n+        EnumTypeTraversalImpl!(\n+            @VisitVariants($this, $visitor)\n+                input($($input)*)\n+                output(\n+                    $variant => { ::std::ops::ControlFlow::Continue(()) }\n+                    $($output)*\n+                )\n+        )\n+    };\n+}"}, {"sha": "b6abe9a7357339cb9df80c87c55fa097090676fb", "filename": "compiler/rustc_type_ir/src/structural_impls.rs", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/459e1424134423d28a94a392e071300675677342/compiler%2Frustc_type_ir%2Fsrc%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459e1424134423d28a94a392e071300675677342/compiler%2Frustc_type_ir%2Fsrc%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fstructural_impls.rs?ref=459e1424134423d28a94a392e071300675677342", "patch": "@@ -0,0 +1,238 @@\n+//! This module contains implementations of the `TypeFoldable` and `TypeVisitable`\n+//! traits for various types in the Rust compiler. Most are written by hand, though\n+//! we've recently added some macros and proc-macros to help with the tedium.\n+\n+use crate::fold::{FallibleTypeFolder, TypeFoldable};\n+use crate::visit::{TypeVisitable, TypeVisitor};\n+use crate::Interner;\n+use rustc_data_structures::functor::IdFunctor;\n+use rustc_index::vec::{Idx, IndexVec};\n+\n+use std::mem::ManuallyDrop;\n+use std::ops::ControlFlow;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Atomic structs\n+//\n+// For things that don't carry any arena-allocated data (and are\n+// copy...), just add them to this list.\n+\n+TrivialTypeTraversalImpls! {\n+    (),\n+    bool,\n+    usize,\n+    u16,\n+    u32,\n+    u64,\n+    String,\n+    crate::DebruijnIndex,\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Traversal implementations.\n+\n+impl<I: Interner, T: TypeFoldable<I>, U: TypeFoldable<I>> TypeFoldable<I> for (T, U) {\n+    fn try_fold_with<F: FallibleTypeFolder<I>>(self, folder: &mut F) -> Result<(T, U), F::Error> {\n+        Ok((self.0.try_fold_with(folder)?, self.1.try_fold_with(folder)?))\n+    }\n+}\n+\n+impl<I: Interner, T: TypeVisitable<I>, U: TypeVisitable<I>> TypeVisitable<I> for (T, U) {\n+    fn visit_with<V: TypeVisitor<I>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n+        self.0.visit_with(visitor)?;\n+        self.1.visit_with(visitor)\n+    }\n+}\n+\n+impl<I: Interner, A: TypeFoldable<I>, B: TypeFoldable<I>, C: TypeFoldable<I>> TypeFoldable<I>\n+    for (A, B, C)\n+{\n+    fn try_fold_with<F: FallibleTypeFolder<I>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<(A, B, C), F::Error> {\n+        Ok((\n+            self.0.try_fold_with(folder)?,\n+            self.1.try_fold_with(folder)?,\n+            self.2.try_fold_with(folder)?,\n+        ))\n+    }\n+}\n+\n+impl<I: Interner, A: TypeVisitable<I>, B: TypeVisitable<I>, C: TypeVisitable<I>> TypeVisitable<I>\n+    for (A, B, C)\n+{\n+    fn visit_with<V: TypeVisitor<I>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n+        self.0.visit_with(visitor)?;\n+        self.1.visit_with(visitor)?;\n+        self.2.visit_with(visitor)\n+    }\n+}\n+\n+EnumTypeTraversalImpl! {\n+    impl<I, T> TypeFoldable<I> for Option<T> {\n+        (Some)(a),\n+        (None),\n+    } where I: Interner, T: TypeFoldable<I>\n+}\n+EnumTypeTraversalImpl! {\n+    impl<I, T> TypeVisitable<I> for Option<T> {\n+        (Some)(a),\n+        (None),\n+    } where I: Interner, T: TypeVisitable<I>\n+}\n+\n+EnumTypeTraversalImpl! {\n+    impl<I, T, E> TypeFoldable<I> for Result<T, E> {\n+        (Ok)(a),\n+        (Err)(a),\n+    } where I: Interner, T: TypeFoldable<I>, E: TypeFoldable<I>,\n+}\n+EnumTypeTraversalImpl! {\n+    impl<I, T, E> TypeVisitable<I> for Result<T, E> {\n+        (Ok)(a),\n+        (Err)(a),\n+    } where I: Interner, T: TypeVisitable<I>, E: TypeVisitable<I>,\n+}\n+\n+impl<I: Interner, T: TypeFoldable<I>> TypeFoldable<I> for Rc<T> {\n+    fn try_fold_with<F: FallibleTypeFolder<I>>(mut self, folder: &mut F) -> Result<Self, F::Error> {\n+        // We merely want to replace the contained `T`, if at all possible,\n+        // so that we don't needlessly allocate a new `Rc` or indeed clone\n+        // the contained type.\n+        unsafe {\n+            // First step is to ensure that we have a unique reference to\n+            // the contained type, which `Rc::make_mut` will accomplish (by\n+            // allocating a new `Rc` and cloning the `T` only if required).\n+            // This is done *before* casting to `Rc<ManuallyDrop<T>>` so that\n+            // panicking during `make_mut` does not leak the `T`.\n+            Rc::make_mut(&mut self);\n+\n+            // Casting to `Rc<ManuallyDrop<T>>` is safe because `ManuallyDrop`\n+            // is `repr(transparent)`.\n+            let ptr = Rc::into_raw(self).cast::<ManuallyDrop<T>>();\n+            let mut unique = Rc::from_raw(ptr);\n+\n+            // Call to `Rc::make_mut` above guarantees that `unique` is the\n+            // sole reference to the contained value, so we can avoid doing\n+            // a checked `get_mut` here.\n+            let slot = Rc::get_mut_unchecked(&mut unique);\n+\n+            // Semantically move the contained type out from `unique`, fold\n+            // it, then move the folded value back into `unique`. Should\n+            // folding fail, `ManuallyDrop` ensures that the \"moved-out\"\n+            // value is not re-dropped.\n+            let owned = ManuallyDrop::take(slot);\n+            let folded = owned.try_fold_with(folder)?;\n+            *slot = ManuallyDrop::new(folded);\n+\n+            // Cast back to `Rc<T>`.\n+            Ok(Rc::from_raw(Rc::into_raw(unique).cast()))\n+        }\n+    }\n+}\n+\n+impl<I: Interner, T: TypeVisitable<I>> TypeVisitable<I> for Rc<T> {\n+    fn visit_with<V: TypeVisitor<I>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n+        (**self).visit_with(visitor)\n+    }\n+}\n+\n+impl<I: Interner, T: TypeFoldable<I>> TypeFoldable<I> for Arc<T> {\n+    fn try_fold_with<F: FallibleTypeFolder<I>>(mut self, folder: &mut F) -> Result<Self, F::Error> {\n+        // We merely want to replace the contained `T`, if at all possible,\n+        // so that we don't needlessly allocate a new `Arc` or indeed clone\n+        // the contained type.\n+        unsafe {\n+            // First step is to ensure that we have a unique reference to\n+            // the contained type, which `Arc::make_mut` will accomplish (by\n+            // allocating a new `Arc` and cloning the `T` only if required).\n+            // This is done *before* casting to `Arc<ManuallyDrop<T>>` so that\n+            // panicking during `make_mut` does not leak the `T`.\n+            Arc::make_mut(&mut self);\n+\n+            // Casting to `Arc<ManuallyDrop<T>>` is safe because `ManuallyDrop`\n+            // is `repr(transparent)`.\n+            let ptr = Arc::into_raw(self).cast::<ManuallyDrop<T>>();\n+            let mut unique = Arc::from_raw(ptr);\n+\n+            // Call to `Arc::make_mut` above guarantees that `unique` is the\n+            // sole reference to the contained value, so we can avoid doing\n+            // a checked `get_mut` here.\n+            let slot = Arc::get_mut_unchecked(&mut unique);\n+\n+            // Semantically move the contained type out from `unique`, fold\n+            // it, then move the folded value back into `unique`. Should\n+            // folding fail, `ManuallyDrop` ensures that the \"moved-out\"\n+            // value is not re-dropped.\n+            let owned = ManuallyDrop::take(slot);\n+            let folded = owned.try_fold_with(folder)?;\n+            *slot = ManuallyDrop::new(folded);\n+\n+            // Cast back to `Arc<T>`.\n+            Ok(Arc::from_raw(Arc::into_raw(unique).cast()))\n+        }\n+    }\n+}\n+\n+impl<I: Interner, T: TypeVisitable<I>> TypeVisitable<I> for Arc<T> {\n+    fn visit_with<V: TypeVisitor<I>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n+        (**self).visit_with(visitor)\n+    }\n+}\n+\n+impl<I: Interner, T: TypeFoldable<I>> TypeFoldable<I> for Box<T> {\n+    fn try_fold_with<F: FallibleTypeFolder<I>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        self.try_map_id(|value| value.try_fold_with(folder))\n+    }\n+}\n+\n+impl<I: Interner, T: TypeVisitable<I>> TypeVisitable<I> for Box<T> {\n+    fn visit_with<V: TypeVisitor<I>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n+        (**self).visit_with(visitor)\n+    }\n+}\n+\n+impl<I: Interner, T: TypeFoldable<I>> TypeFoldable<I> for Vec<T> {\n+    fn try_fold_with<F: FallibleTypeFolder<I>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        self.try_map_id(|t| t.try_fold_with(folder))\n+    }\n+}\n+\n+impl<I: Interner, T: TypeVisitable<I>> TypeVisitable<I> for Vec<T> {\n+    fn visit_with<V: TypeVisitor<I>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n+        self.iter().try_for_each(|t| t.visit_with(visitor))\n+    }\n+}\n+\n+impl<I: Interner, T: TypeVisitable<I>> TypeVisitable<I> for &[T] {\n+    fn visit_with<V: TypeVisitor<I>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n+        self.iter().try_for_each(|t| t.visit_with(visitor))\n+    }\n+}\n+\n+impl<I: Interner, T: TypeFoldable<I>> TypeFoldable<I> for Box<[T]> {\n+    fn try_fold_with<F: FallibleTypeFolder<I>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        self.try_map_id(|t| t.try_fold_with(folder))\n+    }\n+}\n+\n+impl<I: Interner, T: TypeVisitable<I>> TypeVisitable<I> for Box<[T]> {\n+    fn visit_with<V: TypeVisitor<I>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n+        self.iter().try_for_each(|t| t.visit_with(visitor))\n+    }\n+}\n+\n+impl<I: Interner, T: TypeFoldable<I>, Ix: Idx> TypeFoldable<I> for IndexVec<Ix, T> {\n+    fn try_fold_with<F: FallibleTypeFolder<I>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        self.try_map_id(|x| x.try_fold_with(folder))\n+    }\n+}\n+\n+impl<I: Interner, T: TypeVisitable<I>, Ix: Idx> TypeVisitable<I> for IndexVec<Ix, T> {\n+    fn visit_with<V: TypeVisitor<I>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n+        self.iter().try_for_each(|t| t.visit_with(visitor))\n+    }\n+}"}, {"sha": "62239fd20066a8ea727ce3a792b68f8b6306cdde", "filename": "compiler/rustc_type_ir/src/visit.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/459e1424134423d28a94a392e071300675677342/compiler%2Frustc_type_ir%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459e1424134423d28a94a392e071300675677342/compiler%2Frustc_type_ir%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fvisit.rs?ref=459e1424134423d28a94a392e071300675677342", "patch": "@@ -0,0 +1,115 @@\n+//! A visiting traversal mechanism for complex data structures that contain type\n+//! information.\n+//!\n+//! This is a read-only traversal of the data structure.\n+//!\n+//! This traversal has limited flexibility. Only a small number of \"types of\n+//! interest\" within the complex data structures can receive custom\n+//! visitation. These are the ones containing the most important type-related\n+//! information, such as `Ty`, `Predicate`, `Region`, and `Const`.\n+//!\n+//! There are three groups of traits involved in each traversal.\n+//! - `TypeVisitable`. This is implemented once for many types, including:\n+//!   - Types of interest, for which the methods delegate to the visitor.\n+//!   - All other types, including generic containers like `Vec` and `Option`.\n+//!     It defines a \"skeleton\" of how they should be visited.\n+//! - `TypeSuperVisitable`. This is implemented only for each type of interest,\n+//!   and defines the visiting \"skeleton\" for these types.\n+//! - `TypeVisitor`. This is implemented for each visitor. This defines how\n+//!   types of interest are visited.\n+//!\n+//! This means each visit is a mixture of (a) generic visiting operations, and (b)\n+//! custom visit operations that are specific to the visitor.\n+//! - The `TypeVisitable` impls handle most of the traversal, and call into\n+//!   `TypeVisitor` when they encounter a type of interest.\n+//! - A `TypeVisitor` may call into another `TypeVisitable` impl, because some of\n+//!   the types of interest are recursive and can contain other types of interest.\n+//! - A `TypeVisitor` may also call into a `TypeSuperVisitable` impl, because each\n+//!   visitor might provide custom handling only for some types of interest, or\n+//!   only for some variants of each type of interest, and then use default\n+//!   traversal for the remaining cases.\n+//!\n+//! For example, if you have `struct S(Ty, U)` where `S: TypeVisitable` and `U:\n+//! TypeVisitable`, and an instance `s = S(ty, u)`, it would be visited like so:\n+//! ```text\n+//! s.visit_with(visitor) calls\n+//! - ty.visit_with(visitor) calls\n+//!   - visitor.visit_ty(ty) may call\n+//!     - ty.super_visit_with(visitor)\n+//! - u.visit_with(visitor)\n+//! ```\n+use crate::Interner;\n+\n+use std::fmt;\n+use std::ops::ControlFlow;\n+\n+/// This trait is implemented for every type that can be visited,\n+/// providing the skeleton of the traversal.\n+///\n+/// To implement this conveniently, use the derive macro located in\n+/// `rustc_macros`.\n+pub trait TypeVisitable<I: Interner>: fmt::Debug + Clone {\n+    /// The entry point for visiting. To visit a value `t` with a visitor `v`\n+    /// call: `t.visit_with(v)`.\n+    ///\n+    /// For most types, this just traverses the value, calling `visit_with` on\n+    /// each field/element.\n+    ///\n+    /// For types of interest (such as `Ty`), the implementation of this method\n+    /// that calls a visitor method specifically for that type (such as\n+    /// `V::visit_ty`). This is where control transfers from `TypeFoldable` to\n+    /// `TypeVisitor`.\n+    fn visit_with<V: TypeVisitor<I>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy>;\n+}\n+\n+pub trait TypeSuperVisitable<I: Interner>: TypeVisitable<I> {\n+    /// Provides a default visit for a type of interest. This should only be\n+    /// called within `TypeVisitor` methods, when a non-custom traversal is\n+    /// desired for the value of the type of interest passed to that method.\n+    /// For example, in `MyVisitor::visit_ty(ty)`, it is valid to call\n+    /// `ty.super_visit_with(self)`, but any other visiting should be done\n+    /// with `xyz.visit_with(self)`.\n+    fn super_visit_with<V: TypeVisitor<I>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy>;\n+}\n+\n+/// This trait is implemented for every visiting traversal. There is a visit\n+/// method defined for every type of interest. Each such method has a default\n+/// that recurses into the type's fields in a non-custom fashion.\n+pub trait TypeVisitor<I: Interner>: Sized {\n+    type BreakTy = !;\n+\n+    fn visit_binder<T: TypeVisitable<I>>(&mut self, t: &I::Binder<T>) -> ControlFlow<Self::BreakTy>\n+    where\n+        I::Binder<T>: TypeSuperVisitable<I>,\n+    {\n+        t.super_visit_with(self)\n+    }\n+\n+    fn visit_ty(&mut self, t: I::Ty) -> ControlFlow<Self::BreakTy>\n+    where\n+        I::Ty: TypeSuperVisitable<I>,\n+    {\n+        t.super_visit_with(self)\n+    }\n+\n+    fn visit_region(&mut self, r: I::Region) -> ControlFlow<Self::BreakTy>\n+    where\n+        I::Region: TypeSuperVisitable<I>,\n+    {\n+        r.super_visit_with(self)\n+    }\n+\n+    fn visit_const(&mut self, c: I::Const) -> ControlFlow<Self::BreakTy>\n+    where\n+        I::Const: TypeSuperVisitable<I>,\n+    {\n+        c.super_visit_with(self)\n+    }\n+\n+    fn visit_predicate(&mut self, p: I::Predicate) -> ControlFlow<Self::BreakTy>\n+    where\n+        I::Predicate: TypeSuperVisitable<I>,\n+    {\n+        p.super_visit_with(self)\n+    }\n+}"}]}