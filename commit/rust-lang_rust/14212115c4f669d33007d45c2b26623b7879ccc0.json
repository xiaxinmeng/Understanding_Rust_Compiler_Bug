{"sha": "14212115c4f669d33007d45c2b26623b7879ccc0", "node_id": "C_kwDOAAsO6NoAKDE0MjEyMTE1YzRmNjY5ZDMzMDA3ZDQ1YzJiMjY2MjNiNzg3OWNjYzA", "commit": {"author": {"name": "kyoto7250", "email": "50972773+kyoto7250@users.noreply.github.com", "date": "2022-06-09T13:50:00Z"}, "committer": {"name": "kyoto7250", "email": "50972773+kyoto7250@users.noreply.github.com", "date": "2022-06-26T23:11:58Z"}, "message": "rewrite without if_chain macro", "tree": {"sha": "b278bbd3061c262cebab4939798605baad97c060", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b278bbd3061c262cebab4939798605baad97c060"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14212115c4f669d33007d45c2b26623b7879ccc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14212115c4f669d33007d45c2b26623b7879ccc0", "html_url": "https://github.com/rust-lang/rust/commit/14212115c4f669d33007d45c2b26623b7879ccc0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14212115c4f669d33007d45c2b26623b7879ccc0/comments", "author": {"login": "kyoto7250", "id": 50972773, "node_id": "MDQ6VXNlcjUwOTcyNzcz", "avatar_url": "https://avatars.githubusercontent.com/u/50972773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kyoto7250", "html_url": "https://github.com/kyoto7250", "followers_url": "https://api.github.com/users/kyoto7250/followers", "following_url": "https://api.github.com/users/kyoto7250/following{/other_user}", "gists_url": "https://api.github.com/users/kyoto7250/gists{/gist_id}", "starred_url": "https://api.github.com/users/kyoto7250/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kyoto7250/subscriptions", "organizations_url": "https://api.github.com/users/kyoto7250/orgs", "repos_url": "https://api.github.com/users/kyoto7250/repos", "events_url": "https://api.github.com/users/kyoto7250/events{/privacy}", "received_events_url": "https://api.github.com/users/kyoto7250/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kyoto7250", "id": 50972773, "node_id": "MDQ6VXNlcjUwOTcyNzcz", "avatar_url": "https://avatars.githubusercontent.com/u/50972773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kyoto7250", "html_url": "https://github.com/kyoto7250", "followers_url": "https://api.github.com/users/kyoto7250/followers", "following_url": "https://api.github.com/users/kyoto7250/following{/other_user}", "gists_url": "https://api.github.com/users/kyoto7250/gists{/gist_id}", "starred_url": "https://api.github.com/users/kyoto7250/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kyoto7250/subscriptions", "organizations_url": "https://api.github.com/users/kyoto7250/orgs", "repos_url": "https://api.github.com/users/kyoto7250/repos", "events_url": "https://api.github.com/users/kyoto7250/events{/privacy}", "received_events_url": "https://api.github.com/users/kyoto7250/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd629c0cde26d727fbc19580455a4efd04a84828", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd629c0cde26d727fbc19580455a4efd04a84828", "html_url": "https://github.com/rust-lang/rust/commit/fd629c0cde26d727fbc19580455a4efd04a84828"}], "stats": {"total": 146, "additions": 60, "deletions": 86}, "files": [{"sha": "7c57020761cd3c034bb6e3d8a177538ac92700fc", "filename": "clippy_lints/src/use_retain.rs", "status": "modified", "additions": 60, "deletions": 86, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/14212115c4f669d33007d45c2b26623b7879ccc0/clippy_lints%2Fsrc%2Fuse_retain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14212115c4f669d33007d45c2b26623b7879ccc0/clippy_lints%2Fsrc%2Fuse_retain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_retain.rs?ref=14212115c4f669d33007d45c2b26623b7879ccc0", "patch": "@@ -50,21 +50,16 @@ declare_lint_pass!(UseRetain => [USE_RETAIN]);\n \n impl<'tcx> LateLintPass<'tcx> for UseRetain {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if_chain! {\n-            if let Some(parent_expr) = get_parent_expr(cx, expr);\n-            if let Assign(left_expr, collect_expr, _) = &parent_expr.kind;\n-            if let hir::ExprKind::MethodCall(seg, _, _) = &collect_expr.kind;\n-            if seg.args.is_none();\n-\n-            if let hir::ExprKind::MethodCall(_, [target_expr], _) = &collect_expr.kind;\n-            if let Some(collect_def_id) = cx.typeck_results().type_dependent_def_id(collect_expr.hir_id);\n-            if match_def_path(cx, collect_def_id, &paths::CORE_ITER_COLLECT);\n-\n-            then {\n-                check_into_iter(cx, parent_expr, left_expr, target_expr);\n-                check_iter(cx, parent_expr, left_expr, target_expr);\n-                check_to_owned(cx, parent_expr, left_expr, target_expr);\n-            }\n+        if let Some(parent_expr) = get_parent_expr(cx, expr)\n+            && let Assign(left_expr, collect_expr, _) = &parent_expr.kind\n+            && let hir::ExprKind::MethodCall(seg, _, _) = &collect_expr.kind\n+            && seg.args.is_none()\n+            && let hir::ExprKind::MethodCall(_, [target_expr], _) = &collect_expr.kind\n+            && let Some(collect_def_id) = cx.typeck_results().type_dependent_def_id(collect_expr.hir_id)\n+            && match_def_path(cx, collect_def_id, &paths::CORE_ITER_COLLECT) {\n+            check_into_iter(cx, parent_expr, left_expr, target_expr);\n+            check_iter(cx, parent_expr, left_expr, target_expr);\n+            check_to_owned(cx, parent_expr, left_expr, target_expr);\n         }\n     }\n }\n@@ -75,21 +70,15 @@ fn check_into_iter(\n     left_expr: &hir::Expr<'_>,\n     target_expr: &hir::Expr<'_>,\n ) {\n-    if_chain! {\n-        if let hir::ExprKind::MethodCall(_, [into_iter_expr, _], _) = &target_expr.kind;\n-        if let Some(filter_def_id) = cx.typeck_results().type_dependent_def_id(target_expr.hir_id);\n-        if match_def_path(cx, filter_def_id, &paths::CORE_ITER_FILTER);\n-\n-        if let hir::ExprKind::MethodCall(_, [struct_expr], _) = &into_iter_expr.kind;\n-        if let Some(into_iter_def_id) = cx.typeck_results().type_dependent_def_id(into_iter_expr.hir_id);\n-        if match_def_path(cx, into_iter_def_id, &paths::CORE_ITER_INTO_ITER);\n-        if match_acceptable_type(cx, left_expr);\n-\n-        if SpanlessEq::new(cx).eq_expr(left_expr, struct_expr);\n-\n-        then {\n-            suggest(cx, parent_expr, left_expr, target_expr);\n-        }\n+    if let hir::ExprKind::MethodCall(_, [into_iter_expr, _], _) = &target_expr.kind\n+        && let Some(filter_def_id) = cx.typeck_results().type_dependent_def_id(target_expr.hir_id)\n+        && match_def_path(cx, filter_def_id, &paths::CORE_ITER_FILTER)\n+        && let hir::ExprKind::MethodCall(_, [struct_expr], _) = &into_iter_expr.kind\n+        && let Some(into_iter_def_id) = cx.typeck_results().type_dependent_def_id(into_iter_expr.hir_id)\n+        && match_def_path(cx, into_iter_def_id, &paths::CORE_ITER_INTO_ITER)\n+        && match_acceptable_type(cx, left_expr)\n+        && SpanlessEq::new(cx).eq_expr(left_expr, struct_expr) {\n+        suggest(cx, parent_expr, left_expr, target_expr);\n     }\n }\n \n@@ -99,24 +88,19 @@ fn check_iter(\n     left_expr: &hir::Expr<'_>,\n     target_expr: &hir::Expr<'_>,\n ) {\n-    if_chain! {\n-        if let hir::ExprKind::MethodCall(_, [filter_expr], _) = &target_expr.kind;\n-        if let Some(copied_def_id) = cx.typeck_results().type_dependent_def_id(target_expr.hir_id);\n-        if match_def_path(cx, copied_def_id, &paths::CORE_ITER_COPIED) || match_def_path(cx, copied_def_id, &paths::CORE_ITER_CLONED);\n-\n-        if let hir::ExprKind::MethodCall(_, [iter_expr, _], _) = &filter_expr.kind;\n-        if let Some(filter_def_id) = cx.typeck_results().type_dependent_def_id(filter_expr.hir_id);\n-        if match_def_path(cx, filter_def_id, &paths::CORE_ITER_FILTER);\n-\n-        if let hir::ExprKind::MethodCall(_, [struct_expr], _) = &iter_expr.kind;\n-        if let Some(iter_expr_def_id) = cx.typeck_results().type_dependent_def_id(iter_expr.hir_id);\n-        if match_acceptable_def_path(cx, iter_expr_def_id);\n-        if match_acceptable_type(cx, left_expr);\n-        if SpanlessEq::new(cx).eq_expr(left_expr, struct_expr);\n-\n-        then {\n-            suggest(cx, parent_expr, left_expr, filter_expr);\n-        }\n+    if let hir::ExprKind::MethodCall(_, [filter_expr], _) = &target_expr.kind\n+        && let Some(copied_def_id) = cx.typeck_results().type_dependent_def_id(target_expr.hir_id)\n+        && (match_def_path(cx, copied_def_id, &paths::CORE_ITER_COPIED)\n+            || match_def_path(cx, copied_def_id, &paths::CORE_ITER_CLONED))\n+        && let hir::ExprKind::MethodCall(_, [iter_expr, _], _) = &filter_expr.kind\n+        && let Some(filter_def_id) = cx.typeck_results().type_dependent_def_id(filter_expr.hir_id)\n+        && match_def_path(cx, filter_def_id, &paths::CORE_ITER_FILTER)\n+        && let hir::ExprKind::MethodCall(_, [struct_expr], _) = &iter_expr.kind\n+        && let Some(iter_expr_def_id) = cx.typeck_results().type_dependent_def_id(iter_expr.hir_id)\n+        && match_acceptable_def_path(cx, iter_expr_def_id)\n+        && match_acceptable_type(cx, left_expr)\n+        && SpanlessEq::new(cx).eq_expr(left_expr, struct_expr) {\n+        suggest(cx, parent_expr, left_expr, filter_expr);\n     }\n }\n \n@@ -126,36 +110,28 @@ fn check_to_owned(\n     left_expr: &hir::Expr<'_>,\n     target_expr: &hir::Expr<'_>,\n ) {\n-    if_chain! {\n-        if let hir::ExprKind::MethodCall(_, [filter_expr], _) = &target_expr.kind;\n-        if let Some(to_owned_def_id) = cx.typeck_results().type_dependent_def_id(target_expr.hir_id);\n-        if match_def_path(cx, to_owned_def_id, &paths::TO_OWNED_METHOD);\n-\n-        if let hir::ExprKind::MethodCall(_, [chars_expr, _], _) = &filter_expr.kind;\n-        if let Some(filter_def_id) = cx.typeck_results().type_dependent_def_id(filter_expr.hir_id);\n-        if match_def_path(cx, filter_def_id, &paths::CORE_ITER_FILTER);\n-\n-        if let hir::ExprKind::MethodCall(_, [str_expr], _) = &chars_expr.kind;\n-        if let Some(chars_expr_def_id) = cx.typeck_results().type_dependent_def_id(chars_expr.hir_id);\n-        if match_def_path(cx, chars_expr_def_id, &paths::STR_CHARS);\n-\n-        let ty = cx.typeck_results().expr_ty(str_expr).peel_refs();\n-        if is_type_diagnostic_item(cx, ty, sym::String);\n-        if SpanlessEq::new(cx).eq_expr(left_expr, str_expr);\n-\n-        then {\n-            suggest(cx, parent_expr, left_expr, filter_expr);\n-        }\n+    if let hir::ExprKind::MethodCall(_, [filter_expr], _) = &target_expr.kind\n+        && let Some(to_owned_def_id) = cx.typeck_results().type_dependent_def_id(target_expr.hir_id)\n+        && match_def_path(cx, to_owned_def_id, &paths::TO_OWNED_METHOD)\n+        && let hir::ExprKind::MethodCall(_, [chars_expr, _], _) = &filter_expr.kind\n+        && let Some(filter_def_id) = cx.typeck_results().type_dependent_def_id(filter_expr.hir_id)\n+        && match_def_path(cx, filter_def_id, &paths::CORE_ITER_FILTER)\n+        && let hir::ExprKind::MethodCall(_, [str_expr], _) = &chars_expr.kind\n+        && let Some(chars_expr_def_id) = cx.typeck_results().type_dependent_def_id(chars_expr.hir_id)\n+        && match_def_path(cx, chars_expr_def_id, &paths::STR_CHARS)\n+        && let ty = cx.typeck_results().expr_ty(str_expr).peel_refs()\n+        && is_type_diagnostic_item(cx, ty, sym::String)\n+        && SpanlessEq::new(cx).eq_expr(left_expr, str_expr) {\n+        suggest(cx, parent_expr, left_expr, filter_expr);\n     }\n }\n \n fn suggest(cx: &LateContext<'_>, parent_expr: &hir::Expr<'_>, left_expr: &hir::Expr<'_>, filter_expr: &hir::Expr<'_>) {\n-    if_chain! {\n-        if let hir::ExprKind::MethodCall(_, [_, closure], _) = filter_expr.kind;\n-        if let hir::ExprKind::Closure(_, _, filter_body_id, ..) = closure.kind;\n-        let filter_body = cx.tcx.hir().body(filter_body_id);\n-        if let [filter_params] = filter_body.params;\n-        if let Some(sugg) = match filter_params.pat.kind {\n+    if let hir::ExprKind::MethodCall(_, [_, closure], _) = filter_expr.kind\n+        && let hir::ExprKind::Closure(_, _, filter_body_id, ..) = closure.kind\n+        && let filter_body = cx.tcx.hir().body(filter_body_id)\n+        && let [filter_params] = filter_body.params\n+        && let Some(sugg) = match filter_params.pat.kind {\n             hir::PatKind::Binding(_, _, filter_param_ident, None) => {\n                 Some(format!(\"{}.retain(|{}| {})\", snippet(cx, left_expr.span, \"..\"), filter_param_ident, snippet(cx, filter_body.value.span, \"..\")))\n             },\n@@ -171,18 +147,16 @@ fn suggest(cx: &LateContext<'_>, parent_expr: &hir::Expr<'_>, left_expr: &hir::E\n                 }\n             },\n             _ => None\n-        };\n-        then {\n-            span_lint_and_sugg(\n-                cx,\n-                USE_RETAIN,\n-                parent_expr.span,\n-                \"this expression can be written more simply using `.retain()`\",\n-                \"consider calling `.retain()` instead\",\n-                sugg,\n-                Applicability::MachineApplicable\n-            );\n-        }\n+        } {\n+        span_lint_and_sugg(\n+            cx,\n+            USE_RETAIN,\n+            parent_expr.span,\n+            \"this expression can be written more simply using `.retain()`\",\n+            \"consider calling `.retain()` instead\",\n+            sugg,\n+            Applicability::MachineApplicable\n+        );\n     }\n }\n "}]}