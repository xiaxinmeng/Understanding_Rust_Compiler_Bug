{"sha": "5599a45e58402b529ef8c724c560e8cfe6e5b72b", "node_id": "C_kwDOAAsO6NoAKDU1OTlhNDVlNTg0MDJiNTI5ZWY4YzcyNGM1NjBlOGNmZTZlNWI3MmI", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-09-09T05:50:25Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-09-12T02:00:20Z"}, "message": "Fix ICE in opt_suggest_box_span", "tree": {"sha": "73df28ebcb3eeabb9bcbf65b3662c49b94293714", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73df28ebcb3eeabb9bcbf65b3662c49b94293714"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5599a45e58402b529ef8c724c560e8cfe6e5b72b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5599a45e58402b529ef8c724c560e8cfe6e5b72b", "html_url": "https://github.com/rust-lang/rust/commit/5599a45e58402b529ef8c724c560e8cfe6e5b72b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5599a45e58402b529ef8c724c560e8cfe6e5b72b/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a605d33cdd2acccbe46141086fce0c500281a6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a605d33cdd2acccbe46141086fce0c500281a6f", "html_url": "https://github.com/rust-lang/rust/commit/0a605d33cdd2acccbe46141086fce0c500281a6f"}], "stats": {"total": 164, "additions": 114, "deletions": 50}, "files": [{"sha": "8c9ddf866320cd3036461792755406a07b6befc6", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5599a45e58402b529ef8c724c560e8cfe6e5b72b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5599a45e58402b529ef8c724c560e8cfe6e5b72b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=5599a45e58402b529ef8c724c560e8cfe6e5b72b", "patch": "@@ -73,7 +73,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     // for opaque types, and then use that kind to fix the spans for type errors\n                     // that we see later on.\n                     let ty_var = self.next_ty_var(TypeVariableOrigin {\n-                        kind: TypeVariableOriginKind::TypeInference,\n+                        kind: TypeVariableOriginKind::OpaqueTypeInference(def_id),\n                         span,\n                     });\n                     obligations.extend("}, {"sha": "7ff086452536bbfafa30d80f7a9050f9540eeed6", "filename": "compiler/rustc_infer/src/infer/type_variable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5599a45e58402b529ef8c724c560e8cfe6e5b72b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5599a45e58402b529ef8c724c560e8cfe6e5b72b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs?ref=5599a45e58402b529ef8c724c560e8cfe6e5b72b", "patch": "@@ -122,6 +122,7 @@ pub enum TypeVariableOriginKind {\n     MiscVariable,\n     NormalizeProjectionType,\n     TypeInference,\n+    OpaqueTypeInference(DefId),\n     TypeParameterDefinition(Symbol, Option<DefId>),\n \n     /// One of the upvars or closure kind parameters in a `ClosureSubsts`"}, {"sha": "20332e75c425ebef9034a2fce92696cad79613c2", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 62, "deletions": 49, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/5599a45e58402b529ef8c724c560e8cfe6e5b72b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5599a45e58402b529ef8c724c560e8cfe6e5b72b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=5599a45e58402b529ef8c724c560e8cfe6e5b72b", "patch": "@@ -4,7 +4,7 @@ use rustc_errors::{Applicability, MultiSpan};\n use rustc_hir::{self as hir, ExprKind};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::traits::Obligation;\n-use rustc_middle::ty::{self, ToPredicate, Ty};\n+use rustc_middle::ty::{self, Subst, ToPredicate, Ty};\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::{\n@@ -143,7 +143,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .find_by_def_id(self.body_id.owner)\n                         .and_then(|owner| owner.fn_decl())\n                         .map(|decl| decl.output.span())\n-                        else { return; };\n+                    else { return; };\n                     let Expectation::IsLast(stmt) = orig_expected else {\n                         return\n                     };\n@@ -472,64 +472,77 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    // When we have a `match` as a tail expression in a `fn` with a returned `impl Trait`\n-    // we check if the different arms would work with boxed trait objects instead and\n-    // provide a structured suggestion in that case.\n+    /// When we have a `match` as a tail expression in a `fn` with a returned `impl Trait`\n+    /// we check if the different arms would work with boxed trait objects instead and\n+    /// provide a structured suggestion in that case.\n     pub(crate) fn opt_suggest_box_span(\n         &self,\n         first_ty: Ty<'tcx>,\n         second_ty: Ty<'tcx>,\n         orig_expected: Expectation<'tcx>,\n     ) -> Option<Span> {\n+        // FIXME(compiler-errors): This really shouldn't need to be done during the\n+        // \"good\" path of typeck, but here we are.\n         match orig_expected {\n-            Expectation::ExpectHasType(expected)\n-                if self.in_tail_expr\n-                    && self.return_type_has_opaque\n-                    && self.can_coerce(first_ty, expected)\n-                    && self.can_coerce(second_ty, expected) =>\n-            {\n-                let obligations = self.fulfillment_cx.borrow().pending_obligations();\n-                let mut suggest_box = !obligations.is_empty();\n-                'outer: for o in obligations {\n-                    for outer_ty in &[first_ty, second_ty] {\n-                        match o.predicate.kind().skip_binder() {\n-                            ty::PredicateKind::Trait(t) => {\n-                                let pred = ty::Binder::dummy(ty::PredicateKind::Trait(\n-                                    ty::TraitPredicate {\n-                                        trait_ref: ty::TraitRef {\n-                                            def_id: t.def_id(),\n-                                            substs: self.tcx.mk_substs_trait(*outer_ty, &[]),\n-                                        },\n-                                        constness: t.constness,\n-                                        polarity: t.polarity,\n-                                    },\n-                                ));\n-                                let obl = Obligation::new(\n-                                    o.cause.clone(),\n-                                    self.param_env,\n-                                    pred.to_predicate(self.tcx),\n-                                );\n-                                suggest_box &= self.predicate_must_hold_modulo_regions(&obl);\n-                                if !suggest_box {\n-                                    // We've encountered some obligation that didn't hold, so the\n-                                    // return expression can't just be boxed. We don't need to\n-                                    // evaluate the rest of the obligations.\n-                                    break 'outer;\n-                                }\n+            Expectation::ExpectHasType(expected) => {\n+                let TypeVariableOrigin {\n+                    span,\n+                    kind: TypeVariableOriginKind::OpaqueTypeInference(rpit_def_id),\n+                    ..\n+                } = self.type_var_origin(expected)? else { return None; };\n+\n+                let sig = *self\n+                    .typeck_results\n+                    .borrow()\n+                    .liberated_fn_sigs()\n+                    .get(hir::HirId::make_owner(self.body_id.owner))?;\n+\n+                let substs = sig.output().walk().find_map(|arg| {\n+                    if let ty::GenericArgKind::Type(ty) = arg.unpack()\n+                        && let ty::Opaque(def_id, substs) = *ty.kind()\n+                        && def_id == rpit_def_id\n+                    {\n+                        Some(substs)\n+                    } else {\n+                        None\n+                    }\n+                })?;\n+                let opaque_ty = self.tcx.mk_opaque(rpit_def_id, substs);\n+\n+                if !self.can_coerce(first_ty, expected) || !self.can_coerce(second_ty, expected) {\n+                    return None;\n+                }\n+\n+                for ty in [first_ty, second_ty] {\n+                    for pred in self.tcx.bound_explicit_item_bounds(rpit_def_id).transpose_iter() {\n+                        let pred = pred.map_bound(|(pred, _)| *pred).subst(self.tcx, substs);\n+                        let pred = match pred.kind().skip_binder() {\n+                            ty::PredicateKind::Trait(mut trait_pred) => {\n+                                assert_eq!(trait_pred.trait_ref.self_ty(), opaque_ty);\n+                                trait_pred.trait_ref.substs =\n+                                    self.tcx.mk_substs_trait(ty, &trait_pred.trait_ref.substs[1..]);\n+                                pred.kind().rebind(trait_pred).to_predicate(self.tcx)\n+                            }\n+                            ty::PredicateKind::Projection(mut proj_pred) => {\n+                                assert_eq!(proj_pred.projection_ty.self_ty(), opaque_ty);\n+                                proj_pred.projection_ty.substs = self\n+                                    .tcx\n+                                    .mk_substs_trait(ty, &proj_pred.projection_ty.substs[1..]);\n+                                pred.kind().rebind(proj_pred).to_predicate(self.tcx)\n                             }\n-                            _ => {}\n+                            _ => continue,\n+                        };\n+                        if !self.predicate_must_hold_modulo_regions(&Obligation::new(\n+                            ObligationCause::misc(span, self.body_id),\n+                            self.param_env,\n+                            pred,\n+                        )) {\n+                            return None;\n                         }\n                     }\n                 }\n-                if suggest_box {\n-                    self.tcx\n-                        .hir()\n-                        .find_by_def_id(self.body_id.owner)\n-                        .and_then(|owner| owner.fn_decl())\n-                        .map(|decl| decl.output.span())\n-                } else {\n-                    None\n-                }\n+\n+                Some(span)\n             }\n             _ => None,\n         }"}, {"sha": "8e42e2c22243464c7d4aaaff8f1e28422427f9b8", "filename": "src/test/ui/suggestions/issue-101465.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5599a45e58402b529ef8c724c560e8cfe6e5b72b/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101465.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5599a45e58402b529ef8c724c560e8cfe6e5b72b/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101465.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101465.rs?ref=5599a45e58402b529ef8c724c560e8cfe6e5b72b", "patch": "@@ -0,0 +1,25 @@\n+#![feature(trait_alias)]\n+\n+struct B;\n+struct C;\n+\n+trait Tr {}\n+\n+impl Tr for B {}\n+impl Tr for C {}\n+\n+trait Tr2<S> = Into<S>;\n+\n+fn foo2<T: Tr2<()>>() {}\n+\n+fn foo() -> impl Tr {\n+    let x = foo2::<_>();\n+\n+    match true {\n+        true => B,\n+        false => C,\n+        //~^ `match` arms have incompatible types\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "e2ca7771257da6e35666d06cf46c06ba55ff4dcf", "filename": "src/test/ui/suggestions/issue-101465.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5599a45e58402b529ef8c724c560e8cfe6e5b72b/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101465.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5599a45e58402b529ef8c724c560e8cfe6e5b72b/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101465.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101465.stderr?ref=5599a45e58402b529ef8c724c560e8cfe6e5b72b", "patch": "@@ -0,0 +1,25 @@\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/issue-101465.rs:20:18\n+   |\n+LL | /     match true {\n+LL | |         true => B,\n+   | |                 - this is found to be of type `B`\n+LL | |         false => C,\n+   | |                  ^ expected struct `B`, found struct `C`\n+LL | |\n+LL | |     }\n+   | |_____- `match` arms have incompatible types\n+   |\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn foo() -> Box<dyn Tr> {\n+   |             ~~~~~~~   +\n+help: if you change the return type to expect trait objects, box the returned expressions\n+   |\n+LL ~         true => Box::new(B),\n+LL ~         false => Box::new(C),\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}