{"sha": "ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhNzFjNmVjNWJiODEwNjEyMWNiZTMzZWVjNWE2YTljYTc3ODYwMzk=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-11T05:23:07Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-11T05:24:08Z"}, "message": "librustc: Make all external functions unsafe. r=tjc", "tree": {"sha": "c03eaac0b8667217ac99aeff3bd05b603a12f9c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c03eaac0b8667217ac99aeff3bd05b603a12f9c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "html_url": "https://github.com/rust-lang/rust/commit/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d97ab7888f17329dcb18ec462261021994e17d1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d97ab7888f17329dcb18ec462261021994e17d1d", "html_url": "https://github.com/rust-lang/rust/commit/d97ab7888f17329dcb18ec462261021994e17d1d"}], "stats": {"total": 7338, "additions": 4258, "deletions": 3080}, "files": [{"sha": "6e61fcabe0bcebf64ee9372dffa6564a10a6adce", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -118,14 +118,16 @@ fn writeclose(fd: c_int, s: Option<~str>) {\n }\n \n fn readclose(fd: c_int) -> ~str {\n-    // Copied from run::program_output\n-    let file = os::fdopen(fd);\n-    let reader = io::FILE_reader(file, false);\n-    let mut buf = ~\"\";\n-    while !reader.eof() {\n-        let bytes = reader.read_bytes(4096u);\n-        str::push_str(&mut buf, str::from_bytes(bytes));\n+    unsafe {\n+        // Copied from run::program_output\n+        let file = os::fdopen(fd);\n+        let reader = io::FILE_reader(file, false);\n+        let mut buf = ~\"\";\n+        while !reader.eof() {\n+            let bytes = reader.read_bytes(4096u);\n+            str::push_str(&mut buf, str::from_bytes(bytes));\n+        }\n+        os::fclose(file);\n+        return buf;\n     }\n-    os::fclose(file);\n-    return buf;\n }"}, {"sha": "1b6ac13ceab86d924748af6a3818a10be02bb2e4", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -30,9 +30,9 @@ use vec;\n #[abi = \"cdecl\"]\n pub extern mod rustrt {\n     #[legacy_exports];\n-    fn vec_reserve_shared_actual(++t: *sys::TypeDesc,\n-                                 ++v: **vec::raw::VecRepr,\n-                                 ++n: libc::size_t);\n+    unsafe fn vec_reserve_shared_actual(++t: *sys::TypeDesc,\n+                                        ++v: **vec::raw::VecRepr,\n+                                        ++n: libc::size_t);\n }\n \n #[abi = \"rust-intrinsic\"]"}, {"sha": "92cddf7718726ac240bc77de3dc43e1fe7e885fe", "filename": "src/libcore/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcleanup.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -160,6 +160,6 @@ pub unsafe fn annihilate() {\n extern mod rustrt {\n     #[legacy_exports];\n     #[rust_stack]\n-    /*priv*/ fn rust_get_task() -> *c_void;\n+    /*priv*/ unsafe fn rust_get_task() -> *c_void;\n }\n "}, {"sha": "6341481809e21685875edef693821a0ec27ff32f", "filename": "src/libcore/cmath.rs", "status": "modified", "additions": 95, "deletions": 94, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmath.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -26,73 +26,74 @@ pub extern mod c_double_utils {\n \n     // Alpabetically sorted by link_name\n \n-    pure fn acos(n: c_double) -> c_double;\n-    pure fn asin(n: c_double) -> c_double;\n-    pure fn atan(n: c_double) -> c_double;\n-    pure fn atan2(a: c_double, b: c_double) -> c_double;\n-    pure fn cbrt(n: c_double) -> c_double;\n-    pure fn ceil(n: c_double) -> c_double;\n-    pure fn copysign(x: c_double, y: c_double) -> c_double;\n-    pure fn cos(n: c_double) -> c_double;\n-    pure fn cosh(n: c_double) -> c_double;\n-    pure fn erf(n: c_double) -> c_double;\n-    pure fn erfc(n: c_double) -> c_double;\n-    pure fn exp(n: c_double) -> c_double;\n-    pure fn expm1(n: c_double) -> c_double;\n-    pure fn exp2(n: c_double) -> c_double;\n-    #[link_name=\"fabs\"] pure fn abs(n: c_double) -> c_double;\n+    unsafe fn acos(n: c_double) -> c_double;\n+    unsafe fn asin(n: c_double) -> c_double;\n+    unsafe fn atan(n: c_double) -> c_double;\n+    unsafe fn atan2(a: c_double, b: c_double) -> c_double;\n+    unsafe fn cbrt(n: c_double) -> c_double;\n+    unsafe fn ceil(n: c_double) -> c_double;\n+    unsafe fn copysign(x: c_double, y: c_double) -> c_double;\n+    unsafe fn cos(n: c_double) -> c_double;\n+    unsafe fn cosh(n: c_double) -> c_double;\n+    unsafe fn erf(n: c_double) -> c_double;\n+    unsafe fn erfc(n: c_double) -> c_double;\n+    unsafe fn exp(n: c_double) -> c_double;\n+    unsafe fn expm1(n: c_double) -> c_double;\n+    unsafe fn exp2(n: c_double) -> c_double;\n+    #[link_name=\"fabs\"] unsafe fn abs(n: c_double) -> c_double;\n     // rename: for clarity and consistency with add/sub/mul/div\n-    #[link_name=\"fdim\"] pure fn abs_sub(a: c_double, b: c_double) -> c_double;\n-    pure fn floor(n: c_double) -> c_double;\n+    #[link_name=\"fdim\"]\n+    unsafe fn abs_sub(a: c_double, b: c_double) -> c_double;\n+    unsafe fn floor(n: c_double) -> c_double;\n     // rename: for clarity and consistency with add/sub/mul/div\n-    #[link_name=\"fma\"] pure fn mul_add(a: c_double, b: c_double,\n+    #[link_name=\"fma\"] unsafe fn mul_add(a: c_double, b: c_double,\n                                        c: c_double) -> c_double;\n-    #[link_name=\"fmax\"] pure fn fmax(a: c_double, b: c_double) -> c_double;\n-    #[link_name=\"fmin\"] pure fn fmin(a: c_double, b: c_double) -> c_double;\n-    pure fn nextafter(x: c_double, y: c_double) -> c_double;\n-    pure fn frexp(n: c_double, value: &mut c_int) -> c_double;\n-    pure fn hypot(x: c_double, y: c_double) -> c_double;\n-    pure fn ldexp(x: c_double, n: c_int) -> c_double;\n+    #[link_name=\"fmax\"] unsafe fn fmax(a: c_double, b: c_double) -> c_double;\n+    #[link_name=\"fmin\"] unsafe fn fmin(a: c_double, b: c_double) -> c_double;\n+    unsafe fn nextafter(x: c_double, y: c_double) -> c_double;\n+    unsafe fn frexp(n: c_double, value: &mut c_int) -> c_double;\n+    unsafe fn hypot(x: c_double, y: c_double) -> c_double;\n+    unsafe fn ldexp(x: c_double, n: c_int) -> c_double;\n     #[cfg(unix)]\n-    #[link_name=\"lgamma_r\"] pure fn lgamma(n: c_double,\n+    #[link_name=\"lgamma_r\"] unsafe fn lgamma(n: c_double,\n                                            sign: &mut c_int) -> c_double;\n     #[cfg(windows)]\n-    #[link_name=\"__lgamma_r\"] pure fn lgamma(n: c_double,\n+    #[link_name=\"__lgamma_r\"] unsafe fn lgamma(n: c_double,\n                                              sign: &mut c_int) -> c_double;\n     // renamed: log is a reserved keyword; ln seems more natural, too\n-    #[link_name=\"log\"] pure fn ln(n: c_double) -> c_double;\n+    #[link_name=\"log\"] unsafe fn ln(n: c_double) -> c_double;\n     // renamed: \"logb\" /often/ is confused for log2 by beginners\n-    #[link_name=\"logb\"] pure fn log_radix(n: c_double) -> c_double;\n+    #[link_name=\"logb\"] unsafe fn log_radix(n: c_double) -> c_double;\n     // renamed: to be consitent with log as ln\n-    #[link_name=\"log1p\"] pure fn ln1p(n: c_double) -> c_double;\n-    pure fn log10(n: c_double) -> c_double;\n-    pure fn log2(n: c_double) -> c_double;\n-    #[link_name=\"ilogb\"] pure fn ilog_radix(n: c_double) -> c_int;\n-    pure fn modf(n: c_double, iptr: &mut c_double) -> c_double;\n-    pure fn pow(n: c_double, e: c_double) -> c_double;\n+    #[link_name=\"log1p\"] unsafe fn ln1p(n: c_double) -> c_double;\n+    unsafe fn log10(n: c_double) -> c_double;\n+    unsafe fn log2(n: c_double) -> c_double;\n+    #[link_name=\"ilogb\"] unsafe fn ilog_radix(n: c_double) -> c_int;\n+    unsafe fn modf(n: c_double, iptr: &mut c_double) -> c_double;\n+    unsafe fn pow(n: c_double, e: c_double) -> c_double;\n // FIXME (#1379): enable when rounding modes become available\n-//    pure fn rint(n: c_double) -> c_double;\n-    pure fn round(n: c_double) -> c_double;\n+//    unsafe fn rint(n: c_double) -> c_double;\n+    unsafe fn round(n: c_double) -> c_double;\n     // rename: for consistency with logradix\n-    #[link_name=\"scalbn\"] pure fn ldexp_radix(n: c_double, i: c_int) ->\n+    #[link_name=\"scalbn\"] unsafe fn ldexp_radix(n: c_double, i: c_int) ->\n         c_double;\n-    pure fn sin(n: c_double) -> c_double;\n-    pure fn sinh(n: c_double) -> c_double;\n-    pure fn sqrt(n: c_double) -> c_double;\n-    pure fn tan(n: c_double) -> c_double;\n-    pure fn tanh(n: c_double) -> c_double;\n-    pure fn tgamma(n: c_double) -> c_double;\n-    pure fn trunc(n: c_double) -> c_double;\n+    unsafe fn sin(n: c_double) -> c_double;\n+    unsafe fn sinh(n: c_double) -> c_double;\n+    unsafe fn sqrt(n: c_double) -> c_double;\n+    unsafe fn tan(n: c_double) -> c_double;\n+    unsafe fn tanh(n: c_double) -> c_double;\n+    unsafe fn tgamma(n: c_double) -> c_double;\n+    unsafe fn trunc(n: c_double) -> c_double;\n \n     // These are commonly only available for doubles\n \n-    pure fn j0(n: c_double) -> c_double;\n-    pure fn j1(n: c_double) -> c_double;\n-    pure fn jn(i: c_int, n: c_double) -> c_double;\n+    unsafe fn j0(n: c_double) -> c_double;\n+    unsafe fn j1(n: c_double) -> c_double;\n+    unsafe fn jn(i: c_int, n: c_double) -> c_double;\n \n-    pure fn y0(n: c_double) -> c_double;\n-    pure fn y1(n: c_double) -> c_double;\n-    pure fn yn(i: c_int, n: c_double) -> c_double;\n+    unsafe fn y0(n: c_double) -> c_double;\n+    unsafe fn y1(n: c_double) -> c_double;\n+    unsafe fn yn(i: c_int, n: c_double) -> c_double;\n }\n \n #[link_name = \"m\"]\n@@ -101,64 +102,64 @@ pub extern mod c_float_utils {\n \n     // Alpabetically sorted by link_name\n \n-    #[link_name=\"acosf\"] pure fn acos(n: c_float) -> c_float;\n-    #[link_name=\"asinf\"] pure fn asin(n: c_float) -> c_float;\n-    #[link_name=\"atanf\"] pure fn atan(n: c_float) -> c_float;\n-    #[link_name=\"atan2f\"] pure fn atan2(a: c_float, b: c_float) -> c_float;\n-    #[link_name=\"cbrtf\"] pure fn cbrt(n: c_float) -> c_float;\n-    #[link_name=\"ceilf\"] pure fn ceil(n: c_float) -> c_float;\n-    #[link_name=\"copysignf\"] pure fn copysign(x: c_float,\n+    #[link_name=\"acosf\"] unsafe fn acos(n: c_float) -> c_float;\n+    #[link_name=\"asinf\"] unsafe fn asin(n: c_float) -> c_float;\n+    #[link_name=\"atanf\"] unsafe fn atan(n: c_float) -> c_float;\n+    #[link_name=\"atan2f\"] unsafe fn atan2(a: c_float, b: c_float) -> c_float;\n+    #[link_name=\"cbrtf\"] unsafe fn cbrt(n: c_float) -> c_float;\n+    #[link_name=\"ceilf\"] unsafe fn ceil(n: c_float) -> c_float;\n+    #[link_name=\"copysignf\"] unsafe fn copysign(x: c_float,\n                                               y: c_float) -> c_float;\n-    #[link_name=\"cosf\"] pure fn cos(n: c_float) -> c_float;\n-    #[link_name=\"coshf\"] pure fn cosh(n: c_float) -> c_float;\n-    #[link_name=\"erff\"] pure fn erf(n: c_float) -> c_float;\n-    #[link_name=\"erfcf\"] pure fn erfc(n: c_float) -> c_float;\n-    #[link_name=\"expf\"] pure fn exp(n: c_float) -> c_float;\n-    #[link_name=\"expm1f\"]pure fn expm1(n: c_float) -> c_float;\n-    #[link_name=\"exp2f\"] pure fn exp2(n: c_float) -> c_float;\n-    #[link_name=\"fabsf\"] pure fn abs(n: c_float) -> c_float;\n-    #[link_name=\"fdimf\"] pure fn abs_sub(a: c_float, b: c_float) -> c_float;\n-    #[link_name=\"floorf\"] pure fn floor(n: c_float) -> c_float;\n-    #[link_name=\"frexpf\"] pure fn frexp(n: c_float,\n+    #[link_name=\"cosf\"] unsafe fn cos(n: c_float) -> c_float;\n+    #[link_name=\"coshf\"] unsafe fn cosh(n: c_float) -> c_float;\n+    #[link_name=\"erff\"] unsafe fn erf(n: c_float) -> c_float;\n+    #[link_name=\"erfcf\"] unsafe fn erfc(n: c_float) -> c_float;\n+    #[link_name=\"expf\"] unsafe fn exp(n: c_float) -> c_float;\n+    #[link_name=\"expm1f\"]unsafe fn expm1(n: c_float) -> c_float;\n+    #[link_name=\"exp2f\"] unsafe fn exp2(n: c_float) -> c_float;\n+    #[link_name=\"fabsf\"] unsafe fn abs(n: c_float) -> c_float;\n+    #[link_name=\"fdimf\"] unsafe fn abs_sub(a: c_float, b: c_float) -> c_float;\n+    #[link_name=\"floorf\"] unsafe fn floor(n: c_float) -> c_float;\n+    #[link_name=\"frexpf\"] unsafe fn frexp(n: c_float,\n                                         value: &mut c_int) -> c_float;\n-    #[link_name=\"fmaf\"] pure fn mul_add(a: c_float,\n+    #[link_name=\"fmaf\"] unsafe fn mul_add(a: c_float,\n                                         b: c_float, c: c_float) -> c_float;\n-    #[link_name=\"fmaxf\"] pure fn fmax(a: c_float, b: c_float) -> c_float;\n-    #[link_name=\"fminf\"] pure fn fmin(a: c_float, b: c_float) -> c_float;\n-    #[link_name=\"nextafterf\"] pure fn nextafter(x: c_float,\n+    #[link_name=\"fmaxf\"] unsafe fn fmax(a: c_float, b: c_float) -> c_float;\n+    #[link_name=\"fminf\"] unsafe fn fmin(a: c_float, b: c_float) -> c_float;\n+    #[link_name=\"nextafterf\"] unsafe fn nextafter(x: c_float,\n                                                 y: c_float) -> c_float;\n-    #[link_name=\"hypotf\"] pure fn hypot(x: c_float, y: c_float) -> c_float;\n-    #[link_name=\"ldexpf\"] pure fn ldexp(x: c_float, n: c_int) -> c_float;\n+    #[link_name=\"hypotf\"] unsafe fn hypot(x: c_float, y: c_float) -> c_float;\n+    #[link_name=\"ldexpf\"] unsafe fn ldexp(x: c_float, n: c_int) -> c_float;\n \n     #[cfg(unix)]\n-    #[link_name=\"lgammaf_r\"] pure fn lgamma(n: c_float,\n+    #[link_name=\"lgammaf_r\"] unsafe fn lgamma(n: c_float,\n                                             sign: &mut c_int) -> c_float;\n \n     #[cfg(windows)]\n-    #[link_name=\"__lgammaf_r\"] pure fn lgamma(n: c_float,\n+    #[link_name=\"__lgammaf_r\"] unsafe fn lgamma(n: c_float,\n                                               sign: &mut c_int) -> c_float;\n \n-    #[link_name=\"logf\"] pure fn ln(n: c_float) -> c_float;\n-    #[link_name=\"logbf\"] pure fn log_radix(n: c_float) -> c_float;\n-    #[link_name=\"log1pf\"] pure fn ln1p(n: c_float) -> c_float;\n-    #[link_name=\"log2f\"] pure fn log2(n: c_float) -> c_float;\n-    #[link_name=\"log10f\"] pure fn log10(n: c_float) -> c_float;\n-    #[link_name=\"ilogbf\"] pure fn ilog_radix(n: c_float) -> c_int;\n-    #[link_name=\"modff\"] pure fn modf(n: c_float,\n+    #[link_name=\"logf\"] unsafe fn ln(n: c_float) -> c_float;\n+    #[link_name=\"logbf\"] unsafe fn log_radix(n: c_float) -> c_float;\n+    #[link_name=\"log1pf\"] unsafe fn ln1p(n: c_float) -> c_float;\n+    #[link_name=\"log2f\"] unsafe fn log2(n: c_float) -> c_float;\n+    #[link_name=\"log10f\"] unsafe fn log10(n: c_float) -> c_float;\n+    #[link_name=\"ilogbf\"] unsafe fn ilog_radix(n: c_float) -> c_int;\n+    #[link_name=\"modff\"] unsafe fn modf(n: c_float,\n                                       iptr: &mut c_float) -> c_float;\n-    #[link_name=\"powf\"] pure fn pow(n: c_float, e: c_float) -> c_float;\n+    #[link_name=\"powf\"] unsafe fn pow(n: c_float, e: c_float) -> c_float;\n // FIXME (#1379): enable when rounding modes become available\n-//    #[link_name=\"rintf\"] pure fn rint(n: c_float) -> c_float;\n-    #[link_name=\"roundf\"] pure fn round(n: c_float) -> c_float;\n-    #[link_name=\"scalbnf\"] pure fn ldexp_radix(n: c_float, i: c_int)\n+//    #[link_name=\"rintf\"] unsafe fn rint(n: c_float) -> c_float;\n+    #[link_name=\"roundf\"] unsafe fn round(n: c_float) -> c_float;\n+    #[link_name=\"scalbnf\"] unsafe fn ldexp_radix(n: c_float, i: c_int)\n         -> c_float;\n-    #[link_name=\"sinf\"] pure fn sin(n: c_float) -> c_float;\n-    #[link_name=\"sinhf\"] pure fn sinh(n: c_float) -> c_float;\n-    #[link_name=\"sqrtf\"] pure fn sqrt(n: c_float) -> c_float;\n-    #[link_name=\"tanf\"] pure fn tan(n: c_float) -> c_float;\n-    #[link_name=\"tanhf\"] pure fn tanh(n: c_float) -> c_float;\n-    #[link_name=\"tgammaf\"] pure fn tgamma(n: c_float) -> c_float;\n-    #[link_name=\"truncf\"] pure fn trunc(n: c_float) -> c_float;\n+    #[link_name=\"sinf\"] unsafe fn sin(n: c_float) -> c_float;\n+    #[link_name=\"sinhf\"] unsafe fn sinh(n: c_float) -> c_float;\n+    #[link_name=\"sqrtf\"] unsafe fn sqrt(n: c_float) -> c_float;\n+    #[link_name=\"tanf\"] unsafe fn tan(n: c_float) -> c_float;\n+    #[link_name=\"tanhf\"] unsafe fn tanh(n: c_float) -> c_float;\n+    #[link_name=\"tgammaf\"] unsafe fn tgamma(n: c_float) -> c_float;\n+    #[link_name=\"truncf\"] unsafe fn trunc(n: c_float) -> c_float;\n }\n \n // PORT check these by running src/etc/machconsts.c for your architecture"}, {"sha": "734cfc1108044a6fa6b1c3e983e914f8fee334dd", "filename": "src/libcore/f32.rs", "status": "modified", "additions": 77, "deletions": 1, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff32.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -14,12 +14,88 @@\n \n //! Operations and constants for `f32`\n \n+use cmath;\n use cmp;\n+use libc::{c_float, c_int};\n use num;\n \n-pub use cmath::c_float_utils::*;\n pub use cmath::c_float_targ_consts::*;\n \n+macro_rules! delegate(\n+    (\n+        fn $name:ident(\n+            $(\n+                $arg:ident : $arg_ty:ty\n+            ),*\n+        ) -> $rv:ty = $bound_name:path\n+    ) => (\n+        pub pure fn $name($( $arg : $arg_ty ),*) -> $rv {\n+            unsafe {\n+                $bound_name($( $arg ),*)\n+            }\n+        }\n+    )\n+)\n+\n+delegate!(fn acos(n: c_float) -> c_float = cmath::c_float_utils::acos)\n+delegate!(fn asin(n: c_float) -> c_float = cmath::c_float_utils::asin)\n+delegate!(fn atan(n: c_float) -> c_float = cmath::c_float_utils::atan)\n+delegate!(fn atan2(a: c_float, b: c_float) -> c_float =\n+    cmath::c_float_utils::atan2)\n+delegate!(fn cbrt(n: c_float) -> c_float = cmath::c_float_utils::cbrt)\n+delegate!(fn ceil(n: c_float) -> c_float = cmath::c_float_utils::ceil)\n+delegate!(fn copysign(x: c_float, y: c_float) -> c_float =\n+    cmath::c_float_utils::copysign)\n+delegate!(fn cos(n: c_float) -> c_float = cmath::c_float_utils::cos)\n+delegate!(fn cosh(n: c_float) -> c_float = cmath::c_float_utils::cosh)\n+delegate!(fn erf(n: c_float) -> c_float = cmath::c_float_utils::erf)\n+delegate!(fn erfc(n: c_float) -> c_float = cmath::c_float_utils::erfc)\n+delegate!(fn exp(n: c_float) -> c_float = cmath::c_float_utils::exp)\n+delegate!(fn expm1(n: c_float) -> c_float = cmath::c_float_utils::expm1)\n+delegate!(fn exp2(n: c_float) -> c_float = cmath::c_float_utils::exp2)\n+delegate!(fn abs(n: c_float) -> c_float = cmath::c_float_utils::abs)\n+delegate!(fn abs_sub(a: c_float, b: c_float) -> c_float =\n+    cmath::c_float_utils::abs_sub)\n+delegate!(fn floor(n: c_float) -> c_float = cmath::c_float_utils::floor)\n+delegate!(fn mul_add(a: c_float, b: c_float, c: c_float) -> c_float =\n+    cmath::c_float_utils::mul_add)\n+delegate!(fn fmax(a: c_float, b: c_float) -> c_float =\n+    cmath::c_float_utils::fmax)\n+delegate!(fn fmin(a: c_float, b: c_float) -> c_float =\n+    cmath::c_float_utils::fmin)\n+delegate!(fn nextafter(x: c_float, y: c_float) -> c_float =\n+    cmath::c_float_utils::nextafter)\n+delegate!(fn frexp(n: c_float, value: &mut c_int) -> c_float =\n+    cmath::c_float_utils::frexp)\n+delegate!(fn hypot(x: c_float, y: c_float) -> c_float =\n+    cmath::c_float_utils::hypot)\n+delegate!(fn ldexp(x: c_float, n: c_int) -> c_float =\n+    cmath::c_float_utils::ldexp)\n+delegate!(fn lgamma(n: c_float, sign: &mut c_int) -> c_float =\n+    cmath::c_float_utils::lgamma)\n+delegate!(fn ln(n: c_float) -> c_float = cmath::c_float_utils::ln)\n+delegate!(fn log_radix(n: c_float) -> c_float =\n+    cmath::c_float_utils::log_radix)\n+delegate!(fn ln1p(n: c_float) -> c_float = cmath::c_float_utils::ln1p)\n+delegate!(fn log10(n: c_float) -> c_float = cmath::c_float_utils::log10)\n+delegate!(fn log2(n: c_float) -> c_float = cmath::c_float_utils::log2)\n+delegate!(fn ilog_radix(n: c_float) -> c_int =\n+    cmath::c_float_utils::ilog_radix)\n+delegate!(fn modf(n: c_float, iptr: &mut c_float) -> c_float =\n+    cmath::c_float_utils::modf)\n+delegate!(fn pow(n: c_float, e: c_float) -> c_float =\n+    cmath::c_float_utils::pow)\n+delegate!(fn round(n: c_float) -> c_float = cmath::c_float_utils::round)\n+delegate!(fn ldexp_radix(n: c_float, i: c_int) -> c_float =\n+    cmath::c_float_utils::ldexp_radix)\n+delegate!(fn sin(n: c_float) -> c_float = cmath::c_float_utils::sin)\n+delegate!(fn sinh(n: c_float) -> c_float = cmath::c_float_utils::sinh)\n+delegate!(fn sqrt(n: c_float) -> c_float = cmath::c_float_utils::sqrt)\n+delegate!(fn tan(n: c_float) -> c_float = cmath::c_float_utils::tan)\n+delegate!(fn tanh(n: c_float) -> c_float = cmath::c_float_utils::tanh)\n+delegate!(fn tgamma(n: c_float) -> c_float = cmath::c_float_utils::tgamma)\n+delegate!(fn trunc(n: c_float) -> c_float = cmath::c_float_utils::trunc)\n+\n // These are not defined inside consts:: for consistency with\n // the integer types\n "}, {"sha": "e0c47b509f1cbfad50f93b84e57f6021617a032d", "filename": "src/libcore/f64.rs", "status": "modified", "additions": 84, "deletions": 5, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff64.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -16,12 +16,95 @@\n \n use cmath;\n use cmp;\n+use libc::{c_double, c_int};\n use libc;\n use num;\n \n-pub use cmath::c_double_utils::*;\n pub use cmath::c_double_targ_consts::*;\n \n+macro_rules! delegate(\n+    (\n+        fn $name:ident(\n+            $(\n+                $arg:ident : $arg_ty:ty\n+            ),*\n+        ) -> $rv:ty = $bound_name:path\n+    ) => (\n+        pub pure fn $name($( $arg : $arg_ty ),*) -> $rv {\n+            unsafe {\n+                $bound_name($( $arg ),*)\n+            }\n+        }\n+    )\n+)\n+\n+delegate!(fn acos(n: c_double) -> c_double = cmath::c_double_utils::acos)\n+delegate!(fn asin(n: c_double) -> c_double = cmath::c_double_utils::asin)\n+delegate!(fn atan(n: c_double) -> c_double = cmath::c_double_utils::atan)\n+delegate!(fn atan2(a: c_double, b: c_double) -> c_double =\n+    cmath::c_double_utils::atan2)\n+delegate!(fn cbrt(n: c_double) -> c_double = cmath::c_double_utils::cbrt)\n+delegate!(fn ceil(n: c_double) -> c_double = cmath::c_double_utils::ceil)\n+delegate!(fn copysign(x: c_double, y: c_double) -> c_double =\n+    cmath::c_double_utils::copysign)\n+delegate!(fn cos(n: c_double) -> c_double = cmath::c_double_utils::cos)\n+delegate!(fn cosh(n: c_double) -> c_double = cmath::c_double_utils::cosh)\n+delegate!(fn erf(n: c_double) -> c_double = cmath::c_double_utils::erf)\n+delegate!(fn erfc(n: c_double) -> c_double = cmath::c_double_utils::erfc)\n+delegate!(fn exp(n: c_double) -> c_double = cmath::c_double_utils::exp)\n+delegate!(fn expm1(n: c_double) -> c_double = cmath::c_double_utils::expm1)\n+delegate!(fn exp2(n: c_double) -> c_double = cmath::c_double_utils::exp2)\n+delegate!(fn abs(n: c_double) -> c_double = cmath::c_double_utils::abs)\n+delegate!(fn abs_sub(a: c_double, b: c_double) -> c_double =\n+    cmath::c_double_utils::abs_sub)\n+delegate!(fn floor(n: c_double) -> c_double = cmath::c_double_utils::floor)\n+delegate!(fn mul_add(a: c_double, b: c_double, c: c_double) -> c_double =\n+    cmath::c_double_utils::mul_add)\n+delegate!(fn fmax(a: c_double, b: c_double) -> c_double =\n+    cmath::c_double_utils::fmax)\n+delegate!(fn fmin(a: c_double, b: c_double) -> c_double =\n+    cmath::c_double_utils::fmin)\n+delegate!(fn nextafter(x: c_double, y: c_double) -> c_double =\n+    cmath::c_double_utils::nextafter)\n+delegate!(fn frexp(n: c_double, value: &mut c_int) -> c_double =\n+    cmath::c_double_utils::frexp)\n+delegate!(fn hypot(x: c_double, y: c_double) -> c_double =\n+    cmath::c_double_utils::hypot)\n+delegate!(fn ldexp(x: c_double, n: c_int) -> c_double =\n+    cmath::c_double_utils::ldexp)\n+delegate!(fn lgamma(n: c_double, sign: &mut c_int) -> c_double =\n+    cmath::c_double_utils::lgamma)\n+delegate!(fn ln(n: c_double) -> c_double = cmath::c_double_utils::ln)\n+delegate!(fn log_radix(n: c_double) -> c_double =\n+    cmath::c_double_utils::log_radix)\n+delegate!(fn ln1p(n: c_double) -> c_double = cmath::c_double_utils::ln1p)\n+delegate!(fn log10(n: c_double) -> c_double = cmath::c_double_utils::log10)\n+delegate!(fn log2(n: c_double) -> c_double = cmath::c_double_utils::log2)\n+delegate!(fn ilog_radix(n: c_double) -> c_int =\n+    cmath::c_double_utils::ilog_radix)\n+delegate!(fn modf(n: c_double, iptr: &mut c_double) -> c_double =\n+    cmath::c_double_utils::modf)\n+delegate!(fn pow(n: c_double, e: c_double) -> c_double =\n+    cmath::c_double_utils::pow)\n+delegate!(fn round(n: c_double) -> c_double = cmath::c_double_utils::round)\n+delegate!(fn ldexp_radix(n: c_double, i: c_int) -> c_double =\n+    cmath::c_double_utils::ldexp_radix)\n+delegate!(fn sin(n: c_double) -> c_double = cmath::c_double_utils::sin)\n+delegate!(fn sinh(n: c_double) -> c_double = cmath::c_double_utils::sinh)\n+delegate!(fn sqrt(n: c_double) -> c_double = cmath::c_double_utils::sqrt)\n+delegate!(fn tan(n: c_double) -> c_double = cmath::c_double_utils::tan)\n+delegate!(fn tanh(n: c_double) -> c_double = cmath::c_double_utils::tanh)\n+delegate!(fn tgamma(n: c_double) -> c_double = cmath::c_double_utils::tgamma)\n+delegate!(fn trunc(n: c_double) -> c_double = cmath::c_double_utils::trunc)\n+delegate!(fn j0(n: c_double) -> c_double = cmath::c_double_utils::j0)\n+delegate!(fn j1(n: c_double) -> c_double = cmath::c_double_utils::j1)\n+delegate!(fn jn(i: c_int, n: c_double) -> c_double =\n+    cmath::c_double_utils::jn)\n+delegate!(fn y0(n: c_double) -> c_double = cmath::c_double_utils::y0)\n+delegate!(fn y1(n: c_double) -> c_double = cmath::c_double_utils::y1)\n+delegate!(fn yn(i: c_int, n: c_double) -> c_double =\n+    cmath::c_double_utils::yn)\n+\n // FIXME (#1433): obtain these in a different way\n \n // These are not defined inside consts:: for consistency with\n@@ -73,10 +156,6 @@ pub pure fn ge(x: f64, y: f64) -> bool { return x >= y; }\n \n pub pure fn gt(x: f64, y: f64) -> bool { return x > y; }\n \n-pub pure fn sqrt(x: f64) -> f64 {\n-    cmath::c_double_utils::sqrt(x as libc::c_double) as f64\n-}\n-\n /// Returns true if `x` is a positive number, including +0.0f640 and +Infinity\n pub pure fn is_positive(x: f64) -> bool\n     { return x > 0.0f64 || (1.0f64/x) == infinity; }"}, {"sha": "39a3aa890df97228541f1ac5f8ba41c678154206", "filename": "src/libcore/flate.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fflate.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -25,15 +25,15 @@ use rand;\n use vec;\n \n extern mod rustrt {\n-    fn tdefl_compress_mem_to_heap(psrc_buf: *const c_void,\n-                                  src_buf_len: size_t,\n-                                  pout_len: *size_t,\n-                                  flags: c_int) -> *c_void;\n+    unsafe fn tdefl_compress_mem_to_heap(psrc_buf: *const c_void,\n+                                         src_buf_len: size_t,\n+                                         pout_len: *size_t,\n+                                         flags: c_int) -> *c_void;\n \n-    fn tinfl_decompress_mem_to_heap(psrc_buf: *const c_void,\n-                                    src_buf_len: size_t,\n-                                    pout_len: *size_t,\n-                                    flags: c_int) -> *c_void;\n+    unsafe fn tinfl_decompress_mem_to_heap(psrc_buf: *const c_void,\n+                                           src_buf_len: size_t,\n+                                           pout_len: *size_t,\n+                                           flags: c_int) -> *c_void;\n }\n \n const lz_none : c_int = 0x0;   // Huffman-coding only."}, {"sha": "92efe9c498120ae1bc15999df8198ee9bf3b818f", "filename": "src/libcore/float.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -409,12 +409,24 @@ pub pure fn is_infinite(x: float) -> bool { f64::is_infinite(x as f64) }\n pub pure fn is_finite(x: float) -> bool { f64::is_finite(x as f64) }\n pub pure fn is_NaN(x: float) -> bool { f64::is_NaN(x as f64) }\n \n-pub pure fn abs(x: float) -> float { f64::abs(x as f64) as float }\n-pub pure fn sqrt(x: float) -> float { f64::sqrt(x as f64) as float }\n-pub pure fn atan(x: float) -> float { f64::atan(x as f64) as float }\n-pub pure fn sin(x: float) -> float { f64::sin(x as f64) as float }\n-pub pure fn cos(x: float) -> float { f64::cos(x as f64) as float }\n-pub pure fn tan(x: float) -> float { f64::tan(x as f64) as float }\n+pub pure fn abs(x: float) -> float {\n+    unsafe { f64::abs(x as f64) as float }\n+}\n+pub pure fn sqrt(x: float) -> float {\n+    unsafe { f64::sqrt(x as f64) as float }\n+}\n+pub pure fn atan(x: float) -> float {\n+    unsafe { f64::atan(x as f64) as float }\n+}\n+pub pure fn sin(x: float) -> float {\n+    unsafe { f64::sin(x as f64) as float }\n+}\n+pub pure fn cos(x: float) -> float {\n+    unsafe { f64::cos(x as f64) as float }\n+}\n+pub pure fn tan(x: float) -> float {\n+    unsafe { f64::tan(x as f64) as float }\n+}\n \n #[cfg(notest)]\n impl float : Eq {"}, {"sha": "8bb3610ffb4419607c8565281d0018e8712c332d", "filename": "src/libcore/gc.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fgc.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -61,12 +61,14 @@ struct StackSegment {\n extern mod rustrt {\n     #[legacy_exports];\n     #[rust_stack]\n-    fn rust_call_tydesc_glue(root: *Word, tydesc: *Word, field: size_t);\n+    unsafe fn rust_call_tydesc_glue(root: *Word,\n+                                    tydesc: *Word,\n+                                    field: size_t);\n \n     #[rust_stack]\n-    fn rust_gc_metadata() -> *Word;\n+    unsafe fn rust_gc_metadata() -> *Word;\n \n-    fn rust_get_stack_segment() -> *StackSegment;\n+    unsafe fn rust_get_stack_segment() -> *StackSegment;\n }\n \n unsafe fn bump<T, U>(ptr: *T, count: uint) -> *U {"}, {"sha": "5cc1c9d583c40b913624c73d2854f048ac88c5f7", "filename": "src/libcore/io.rs", "status": "modified", "additions": 127, "deletions": 66, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -40,9 +40,9 @@ pub type fd_t = c_int;\n \n #[abi = \"cdecl\"]\n extern mod rustrt {\n-    fn rust_get_stdin() -> *libc::FILE;\n-    fn rust_get_stdout() -> *libc::FILE;\n-    fn rust_get_stderr() -> *libc::FILE;\n+    unsafe fn rust_get_stdin() -> *libc::FILE;\n+    unsafe fn rust_get_stdout() -> *libc::FILE;\n+    unsafe fn rust_get_stderr() -> *libc::FILE;\n }\n \n // Reading\n@@ -420,22 +420,39 @@ fn convert_whence(whence: SeekStyle) -> i32 {\n \n impl *libc::FILE: Reader {\n     fn read(&self, bytes: &[mut u8], len: uint) -> uint {\n-        do vec::as_mut_buf(bytes) |buf_p, buf_len| {\n-            assert buf_len >= len;\n+        unsafe {\n+            do vec::as_mut_buf(bytes) |buf_p, buf_len| {\n+                assert buf_len >= len;\n \n-            let count = libc::fread(buf_p as *mut c_void, 1u as size_t,\n-                                    len as size_t, *self);\n+                let count = libc::fread(buf_p as *mut c_void, 1u as size_t,\n+                                        len as size_t, *self);\n \n-            count as uint\n+                count as uint\n+            }\n+        }\n+    }\n+    fn read_byte(&self) -> int {\n+        unsafe {\n+            libc::fgetc(*self) as int\n+        }\n+    }\n+    fn eof(&self) -> bool {\n+        unsafe {\n+            return libc::feof(*self) != 0 as c_int;\n         }\n     }\n-    fn read_byte(&self) -> int { return libc::fgetc(*self) as int; }\n-    fn eof(&self) -> bool { return libc::feof(*self) != 0 as c_int; }\n     fn seek(&self, offset: int, whence: SeekStyle) {\n-        assert libc::fseek(*self, offset as c_long, convert_whence(whence))\n-            == 0 as c_int;\n+        unsafe {\n+            assert libc::fseek(*self,\n+                               offset as c_long,\n+                               convert_whence(whence)) == 0 as c_int;\n+        }\n+    }\n+    fn tell(&self) -> uint {\n+        unsafe {\n+            return libc::ftell(*self) as uint;\n+        }\n     }\n-    fn tell(&self) -> uint { return libc::ftell(*self) as uint; }\n }\n \n // A forwarding impl of reader that also holds on to a resource for the\n@@ -455,7 +472,11 @@ impl<T: Reader, C> {base: T, cleanup: C}: Reader {\n \n pub struct FILERes {\n     f: *libc::FILE,\n-    drop { libc::fclose(self.f); }\n+    drop {\n+        unsafe {\n+            libc::fclose(self.f);\n+        }\n+    }\n }\n \n pub fn FILERes(f: *libc::FILE) -> FILERes {\n@@ -476,18 +497,24 @@ pub fn FILE_reader(f: *libc::FILE, cleanup: bool) -> Reader {\n // top-level functions that take a reader, or a set of default methods on\n // reader (which can then be called reader)\n \n-pub fn stdin() -> Reader { rustrt::rust_get_stdin() as Reader }\n+pub fn stdin() -> Reader {\n+    unsafe {\n+        rustrt::rust_get_stdin() as Reader\n+    }\n+}\n \n pub fn file_reader(path: &Path) -> Result<Reader, ~str> {\n-    let f = os::as_c_charp(path.to_str(), |pathbuf| {\n-        os::as_c_charp(\"r\", |modebuf|\n-            libc::fopen(pathbuf, modebuf)\n-        )\n-    });\n-    return if f as uint == 0u { result::Err(~\"error opening \"\n-                                            + path.to_str()) }\n-    else {\n-        result::Ok(FILE_reader(f, true))\n+    unsafe {\n+        let f = os::as_c_charp(path.to_str(), |pathbuf| {\n+            os::as_c_charp(\"r\", |modebuf|\n+                libc::fopen(pathbuf, modebuf)\n+            )\n+        });\n+        return if f as uint == 0u { result::Err(~\"error opening \"\n+                                                + path.to_str()) }\n+        else {\n+            result::Ok(FILE_reader(f, true))\n+        }\n     }\n }\n \n@@ -570,25 +597,43 @@ impl<T: Writer, C> {base: T, cleanup: C}: Writer {\n \n impl *libc::FILE: Writer {\n     fn write(&self, v: &[const u8]) {\n-        do vec::as_const_buf(v) |vbuf, len| {\n-            let nout = libc::fwrite(vbuf as *c_void, 1, len as size_t, *self);\n-            if nout != len as size_t {\n-                error!(\"error writing buffer\");\n-                log(error, os::last_os_error());\n-                fail;\n+        unsafe {\n+            do vec::as_const_buf(v) |vbuf, len| {\n+                let nout = libc::fwrite(vbuf as *c_void,\n+                                        1,\n+                                        len as size_t,\n+                                        *self);\n+                if nout != len as size_t {\n+                    error!(\"error writing buffer\");\n+                    log(error, os::last_os_error());\n+                    fail;\n+                }\n             }\n         }\n     }\n     fn seek(&self, offset: int, whence: SeekStyle) {\n-        assert libc::fseek(*self, offset as c_long, convert_whence(whence))\n-            == 0 as c_int;\n+        unsafe {\n+            assert libc::fseek(*self,\n+                               offset as c_long,\n+                               convert_whence(whence)) == 0 as c_int;\n+        }\n+    }\n+    fn tell(&self) -> uint {\n+        unsafe {\n+            libc::ftell(*self) as uint\n+        }\n+    }\n+    fn flush(&self) -> int {\n+        unsafe {\n+            libc::fflush(*self) as int\n+        }\n     }\n-    fn tell(&self) -> uint { libc::ftell(*self) as uint }\n-    fn flush(&self) -> int { libc::fflush(*self) as int }\n     fn get_type(&self) -> WriterType {\n-        let fd = libc::fileno(*self);\n-        if libc::isatty(fd) == 0 { File   }\n-        else                     { Screen }\n+        unsafe {\n+            let fd = libc::fileno(*self);\n+            if libc::isatty(fd) == 0 { File   }\n+            else                     { Screen }\n+        }\n     }\n }\n \n@@ -602,17 +647,19 @@ pub fn FILE_writer(f: *libc::FILE, cleanup: bool) -> Writer {\n \n impl fd_t: Writer {\n     fn write(&self, v: &[const u8]) {\n-        let mut count = 0u;\n-        do vec::as_const_buf(v) |vbuf, len| {\n-            while count < len {\n-                let vb = ptr::const_offset(vbuf, count) as *c_void;\n-                let nout = libc::write(*self, vb, len as size_t);\n-                if nout < 0 as ssize_t {\n-                    error!(\"error writing buffer\");\n-                    log(error, os::last_os_error());\n-                    fail;\n+        unsafe {\n+            let mut count = 0u;\n+            do vec::as_const_buf(v) |vbuf, len| {\n+                while count < len {\n+                    let vb = ptr::const_offset(vbuf, count) as *c_void;\n+                    let nout = libc::write(*self, vb, len as size_t);\n+                    if nout < 0 as ssize_t {\n+                        error!(\"error writing buffer\");\n+                        log(error, os::last_os_error());\n+                        fail;\n+                    }\n+                    count += nout as uint;\n                 }\n-                count += nout as uint;\n             }\n         }\n     }\n@@ -626,13 +673,19 @@ impl fd_t: Writer {\n     }\n     fn flush(&self) -> int { 0 }\n     fn get_type(&self) -> WriterType {\n-        if libc::isatty(*self) == 0 { File } else { Screen }\n+        unsafe {\n+            if libc::isatty(*self) == 0 { File } else { Screen }\n+        }\n     }\n }\n \n pub struct FdRes {\n     fd: fd_t,\n-    drop { libc::close(self.fd); }\n+    drop {\n+        unsafe {\n+            libc::close(self.fd);\n+        }\n+    }\n }\n \n pub fn FdRes(fd: fd_t) -> FdRes {\n@@ -668,9 +721,11 @@ pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n           NoFlag => ()\n         }\n     }\n-    let fd = do os::as_c_charp(path.to_str()) |pathbuf| {\n-        libc::open(pathbuf, fflags,\n-                   (S_IRUSR | S_IWUSR) as c_int)\n+    let fd = unsafe {\n+        do os::as_c_charp(path.to_str()) |pathbuf| {\n+            libc::open(pathbuf, fflags,\n+                       (S_IRUSR | S_IWUSR) as c_int)\n+        }\n     };\n     if fd < (0 as c_int) {\n         result::Err(fmt!(\"error opening %s: %s\", path.to_str(),\n@@ -913,14 +968,16 @@ pub fn file_writer(path: &Path, flags: &[FileFlag]) -> Result<Writer, ~str> {\n \n // FIXME: fileflags // #2004\n pub fn buffered_file_writer(path: &Path) -> Result<Writer, ~str> {\n-    let f = do os::as_c_charp(path.to_str()) |pathbuf| {\n-        do os::as_c_charp(\"w\") |modebuf| {\n-            libc::fopen(pathbuf, modebuf)\n-        }\n-    };\n-    return if f as uint == 0u { result::Err(~\"error opening \"\n-                                            + path.to_str()) }\n-    else { result::Ok(FILE_writer(f, true)) }\n+    unsafe {\n+        let f = do os::as_c_charp(path.to_str()) |pathbuf| {\n+            do os::as_c_charp(\"w\") |modebuf| {\n+                libc::fopen(pathbuf, modebuf)\n+            }\n+        };\n+        return if f as uint == 0u { result::Err(~\"error opening \"\n+                                                + path.to_str()) }\n+        else { result::Ok(FILE_writer(f, true)) }\n+    }\n }\n \n // FIXME (#2004) it would be great if this could be a const\n@@ -1081,12 +1138,16 @@ pub mod fsync {\n     // outer res\n     pub fn FILE_res_sync(file: &FILERes, opt_level: Option<Level>,\n                          blk: fn(v: Res<*libc::FILE>)) {\n-        blk(move Res({\n-            val: file.f, opt_level: opt_level,\n-            fsync_fn: fn@(file: *libc::FILE, l: Level) -> int {\n-                return os::fsync_fd(libc::fileno(file), l) as int;\n-            }\n-        }));\n+        unsafe {\n+            blk(move Res({\n+                val: file.f, opt_level: opt_level,\n+                fsync_fn: fn@(file: *libc::FILE, l: Level) -> int {\n+                    unsafe {\n+                        return os::fsync_fd(libc::fileno(file), l) as int;\n+                    }\n+                }\n+            }));\n+        }\n     }\n \n     // fsync fd after executing blk"}, {"sha": "cc9e4d1c5a9affe089c9f10b9807ecfa999cb53f", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 200, "deletions": 194, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -1013,116 +1013,118 @@ pub mod funcs {\n         #[nolink]\n         #[abi = \"cdecl\"]\n         pub extern mod ctype {\n-            fn isalnum(c: c_int) -> c_int;\n-            fn isalpha(c: c_int) -> c_int;\n-            fn iscntrl(c: c_int) -> c_int;\n-            fn isdigit(c: c_int) -> c_int;\n-            fn isgraph(c: c_int) -> c_int;\n-            fn islower(c: c_int) -> c_int;\n-            fn isprint(c: c_int) -> c_int;\n-            fn ispunct(c: c_int) -> c_int;\n-            fn isspace(c: c_int) -> c_int;\n-            fn isupper(c: c_int) -> c_int;\n-            fn isxdigit(c: c_int) -> c_int;\n-            fn tolower(c: c_char) -> c_char;\n-            fn toupper(c: c_char) -> c_char;\n+            unsafe fn isalnum(c: c_int) -> c_int;\n+            unsafe fn isalpha(c: c_int) -> c_int;\n+            unsafe fn iscntrl(c: c_int) -> c_int;\n+            unsafe fn isdigit(c: c_int) -> c_int;\n+            unsafe fn isgraph(c: c_int) -> c_int;\n+            unsafe fn islower(c: c_int) -> c_int;\n+            unsafe fn isprint(c: c_int) -> c_int;\n+            unsafe fn ispunct(c: c_int) -> c_int;\n+            unsafe fn isspace(c: c_int) -> c_int;\n+            unsafe fn isupper(c: c_int) -> c_int;\n+            unsafe fn isxdigit(c: c_int) -> c_int;\n+            unsafe fn tolower(c: c_char) -> c_char;\n+            unsafe fn toupper(c: c_char) -> c_char;\n         }\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n         pub extern mod stdio {\n-            fn fopen(filename: *c_char, mode: *c_char) -> *FILE;\n-            fn freopen(filename: *c_char, mode: *c_char,\n+            unsafe fn fopen(filename: *c_char, mode: *c_char) -> *FILE;\n+            unsafe fn freopen(filename: *c_char, mode: *c_char,\n                        file: *FILE) -> *FILE;\n-            fn fflush(file: *FILE) -> c_int;\n-            fn fclose(file: *FILE) -> c_int;\n-            fn remove(filename: *c_char) -> c_int;\n-            fn rename(oldname: *c_char, newname: *c_char) -> c_int;\n-            fn tmpfile() -> *FILE;\n-            fn setvbuf(stream: *FILE, buffer: *c_char,\n+            unsafe fn fflush(file: *FILE) -> c_int;\n+            unsafe fn fclose(file: *FILE) -> c_int;\n+            unsafe fn remove(filename: *c_char) -> c_int;\n+            unsafe fn rename(oldname: *c_char, newname: *c_char) -> c_int;\n+            unsafe fn tmpfile() -> *FILE;\n+            unsafe fn setvbuf(stream: *FILE, buffer: *c_char,\n                        mode: c_int, size: size_t) -> c_int;\n-            fn setbuf(stream: *FILE, buf: *c_char);\n+            unsafe fn setbuf(stream: *FILE, buf: *c_char);\n             // Omitted: printf and scanf variants.\n-            fn fgetc(stream: *FILE) -> c_int;\n-            fn fgets(buf: *mut c_char, n: c_int,\n+            unsafe fn fgetc(stream: *FILE) -> c_int;\n+            unsafe fn fgets(buf: *mut c_char, n: c_int,\n                      stream: *FILE) -> *c_char;\n-            fn fputc(c: c_int, stream: *FILE) -> c_int;\n-            fn fputs(s: *c_char, stream: *FILE) -> *c_char;\n+            unsafe fn fputc(c: c_int, stream: *FILE) -> c_int;\n+            unsafe fn fputs(s: *c_char, stream: *FILE) -> *c_char;\n             // Omitted: getc, getchar (might be macros).\n \n             // Omitted: gets, so ridiculously unsafe that it should not\n             // survive.\n \n             // Omitted: putc, putchar (might be macros).\n-            fn puts(s: *c_char) -> c_int;\n-            fn ungetc(c: c_int, stream: *FILE) -> c_int;\n-            fn fread(ptr: *mut c_void, size: size_t,\n+            unsafe fn puts(s: *c_char) -> c_int;\n+            unsafe fn ungetc(c: c_int, stream: *FILE) -> c_int;\n+            unsafe fn fread(ptr: *mut c_void, size: size_t,\n                      nobj: size_t, stream: *FILE) -> size_t;\n-            fn fwrite(ptr: *c_void, size: size_t,\n+            unsafe fn fwrite(ptr: *c_void, size: size_t,\n                       nobj: size_t, stream: *FILE) -> size_t;\n-            fn fseek(stream: *FILE, offset: c_long,\n+            unsafe fn fseek(stream: *FILE, offset: c_long,\n                      whence: c_int) -> c_int;\n-            fn ftell(stream: *FILE) -> c_long;\n-            fn rewind(stream: *FILE);\n-            fn fgetpos(stream: *FILE, ptr: *fpos_t) -> c_int;\n-            fn fsetpos(stream: *FILE, ptr: *fpos_t) -> c_int;\n-            fn feof(stream: *FILE) -> c_int;\n-            fn ferror(stream: *FILE) -> c_int;\n-            fn perror(s: *c_char);\n+            unsafe fn ftell(stream: *FILE) -> c_long;\n+            unsafe fn rewind(stream: *FILE);\n+            unsafe fn fgetpos(stream: *FILE, ptr: *fpos_t) -> c_int;\n+            unsafe fn fsetpos(stream: *FILE, ptr: *fpos_t) -> c_int;\n+            unsafe fn feof(stream: *FILE) -> c_int;\n+            unsafe fn ferror(stream: *FILE) -> c_int;\n+            unsafe fn perror(s: *c_char);\n         }\n \n \n         #[nolink]\n         #[abi = \"cdecl\"]\n         pub extern mod stdlib {\n-            fn abs(i: c_int) -> c_int;\n-            fn labs(i: c_long) -> c_long;\n+            unsafe fn abs(i: c_int) -> c_int;\n+            unsafe fn labs(i: c_long) -> c_long;\n             // Omitted: div, ldiv (return pub type incomplete).\n-            fn atof(s: *c_char) -> c_double;\n-            fn atoi(s: *c_char) -> c_int;\n-            fn strtod(s: *c_char, endp: **c_char) -> c_double;\n-            fn strtol(s: *c_char, endp: **c_char, base: c_int) -> c_long;\n-            fn strtoul(s: *c_char, endp: **c_char,\n-                       base: c_int) -> c_ulong;\n-            fn calloc(nobj: size_t, size: size_t) -> *c_void;\n-            fn malloc(size: size_t) -> *c_void;\n-            fn realloc(p: *c_void, size: size_t) -> *c_void;\n-            fn free(p: *c_void);\n-            fn abort() -> !;\n-            fn exit(status: c_int) -> !;\n+            unsafe fn atof(s: *c_char) -> c_double;\n+            unsafe fn atoi(s: *c_char) -> c_int;\n+            unsafe fn strtod(s: *c_char, endp: **c_char) -> c_double;\n+            unsafe fn strtol(s: *c_char, endp: **c_char, base: c_int)\n+                          -> c_long;\n+            unsafe fn strtoul(s: *c_char, endp: **c_char, base: c_int)\n+                           -> c_ulong;\n+            unsafe fn calloc(nobj: size_t, size: size_t) -> *c_void;\n+            unsafe fn malloc(size: size_t) -> *c_void;\n+            unsafe fn realloc(p: *c_void, size: size_t) -> *c_void;\n+            unsafe fn free(p: *c_void);\n+            unsafe fn abort() -> !;\n+            unsafe fn exit(status: c_int) -> !;\n             // Omitted: atexit.\n-            fn system(s: *c_char) -> c_int;\n-            fn getenv(s: *c_char) -> *c_char;\n+            unsafe fn system(s: *c_char) -> c_int;\n+            unsafe fn getenv(s: *c_char) -> *c_char;\n             // Omitted: bsearch, qsort\n-            fn rand() -> c_int;\n-            fn srand(seed: c_uint);\n+            unsafe fn rand() -> c_int;\n+            unsafe fn srand(seed: c_uint);\n         }\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n         pub extern mod string {\n-            fn strcpy(dst: *c_char, src: *c_char) -> *c_char;\n-            fn strncpy(dst: *c_char, src: *c_char, n: size_t) -> *c_char;\n-            fn strcat(s: *c_char, ct: *c_char) -> *c_char;\n-            fn strncat(s: *c_char, ct: *c_char, n: size_t) -> *c_char;\n-            fn strcmp(cs: *c_char, ct: *c_char) -> c_int;\n-            fn strncmp(cs: *c_char, ct: *c_char, n: size_t) -> c_int;\n-            fn strcoll(cs: *c_char, ct: *c_char) -> c_int;\n-            fn strchr(cs: *c_char, c: c_int) -> *c_char;\n-            fn strrchr(cs: *c_char, c: c_int) -> *c_char;\n-            fn strspn(cs: *c_char, ct: *c_char) -> size_t;\n-            fn strcspn(cs: *c_char, ct: *c_char) -> size_t;\n-            fn strpbrk(cs: *c_char, ct: *c_char) -> *c_char;\n-            fn strstr(cs: *c_char, ct: *c_char) -> *c_char;\n-            fn strlen(cs: *c_char) -> size_t;\n-            fn strerror(n: c_int) -> *c_char;\n-            fn strtok(s: *c_char, t: *c_char) -> *c_char;\n-            fn strxfrm(s: *c_char, ct: *c_char, n: size_t) -> size_t;\n-            fn memcpy(s: *c_void, ct: *c_void, n: size_t) -> *c_void;\n-            fn memmove(s: *c_void, ct: *c_void, n: size_t) -> *c_void;\n-            fn memcmp(cx: *c_void, ct: *c_void, n: size_t) -> c_int;\n-            fn memchr(cx: *c_void, c: c_int, n: size_t) -> *c_void;\n-            fn memset(s: *c_void, c: c_int, n: size_t) -> *c_void;\n+            unsafe fn strcpy(dst: *c_char, src: *c_char) -> *c_char;\n+            unsafe fn strncpy(dst: *c_char, src: *c_char, n: size_t)\n+                           -> *c_char;\n+            unsafe fn strcat(s: *c_char, ct: *c_char) -> *c_char;\n+            unsafe fn strncat(s: *c_char, ct: *c_char, n: size_t) -> *c_char;\n+            unsafe fn strcmp(cs: *c_char, ct: *c_char) -> c_int;\n+            unsafe fn strncmp(cs: *c_char, ct: *c_char, n: size_t) -> c_int;\n+            unsafe fn strcoll(cs: *c_char, ct: *c_char) -> c_int;\n+            unsafe fn strchr(cs: *c_char, c: c_int) -> *c_char;\n+            unsafe fn strrchr(cs: *c_char, c: c_int) -> *c_char;\n+            unsafe fn strspn(cs: *c_char, ct: *c_char) -> size_t;\n+            unsafe fn strcspn(cs: *c_char, ct: *c_char) -> size_t;\n+            unsafe fn strpbrk(cs: *c_char, ct: *c_char) -> *c_char;\n+            unsafe fn strstr(cs: *c_char, ct: *c_char) -> *c_char;\n+            unsafe fn strlen(cs: *c_char) -> size_t;\n+            unsafe fn strerror(n: c_int) -> *c_char;\n+            unsafe fn strtok(s: *c_char, t: *c_char) -> *c_char;\n+            unsafe fn strxfrm(s: *c_char, ct: *c_char, n: size_t) -> size_t;\n+            unsafe fn memcpy(s: *c_void, ct: *c_void, n: size_t) -> *c_void;\n+            unsafe fn memmove(s: *c_void, ct: *c_void, n: size_t) -> *c_void;\n+            unsafe fn memcmp(cx: *c_void, ct: *c_void, n: size_t) -> c_int;\n+            unsafe fn memchr(cx: *c_void, c: c_int, n: size_t) -> *c_void;\n+            unsafe fn memset(s: *c_void, c: c_int, n: size_t) -> *c_void;\n         }\n     }\n \n@@ -1141,16 +1143,16 @@ pub mod funcs {\n             use libc::types::os::arch::c95::{c_int, c_char};\n \n             #[link_name = \"_chmod\"]\n-            fn chmod(path: *c_char, mode: c_int) -> c_int;\n+            unsafe fn chmod(path: *c_char, mode: c_int) -> c_int;\n \n             #[link_name = \"_mkdir\"]\n-            fn mkdir(path: *c_char) -> c_int;\n+            unsafe fn mkdir(path: *c_char) -> c_int;\n \n             #[link_name = \"_fstat64\"]\n-            fn fstat(fildes: c_int, buf: *mut stat) -> c_int;\n+            unsafe fn fstat(fildes: c_int, buf: *mut stat) -> c_int;\n \n             #[link_name = \"_stat64\"]\n-            fn stat(path: *c_char, buf: *mut stat) -> c_int;\n+            unsafe fn stat(path: *c_char, buf: *mut stat) -> c_int;\n         }\n \n         #[nolink]\n@@ -1160,16 +1162,16 @@ pub mod funcs {\n             use libc::types::os::arch::c95::{c_int, c_char};\n \n             #[link_name = \"_popen\"]\n-            fn popen(command: *c_char, mode: *c_char) -> *FILE;\n+            unsafe fn popen(command: *c_char, mode: *c_char) -> *FILE;\n \n             #[link_name = \"_pclose\"]\n-            fn pclose(stream: *FILE) -> c_int;\n+            unsafe fn pclose(stream: *FILE) -> c_int;\n \n             #[link_name = \"_fdopen\"]\n-            fn fdopen(fd: c_int, mode: *c_char) -> *FILE;\n+            unsafe fn fdopen(fd: c_int, mode: *c_char) -> *FILE;\n \n             #[link_name = \"_fileno\"]\n-            fn fileno(stream: *FILE) -> c_int;\n+            unsafe fn fileno(stream: *FILE) -> c_int;\n         }\n \n         #[nolink]\n@@ -1178,10 +1180,10 @@ pub mod funcs {\n             use libc::types::os::arch::c95::{c_int, c_char};\n \n             #[link_name = \"_open\"]\n-            fn open(path: *c_char, oflag: c_int, mode: c_int) -> c_int;\n+            unsafe fn open(path: *c_char, oflag: c_int, mode: c_int) -> c_int;\n \n             #[link_name = \"_creat\"]\n-            fn creat(path: *c_char, mode: c_int) -> c_int;\n+            unsafe fn creat(path: *c_char, mode: c_int) -> c_int;\n         }\n \n         #[nolink]\n@@ -1199,61 +1201,63 @@ pub mod funcs {\n             use libc::types::os::arch::c99::intptr_t;\n \n             #[link_name = \"_access\"]\n-            fn access(path: *c_char, amode: c_int) -> c_int;\n+            unsafe fn access(path: *c_char, amode: c_int) -> c_int;\n \n             #[link_name = \"_chdir\"]\n-            fn chdir(dir: *c_char) -> c_int;\n+            unsafe fn chdir(dir: *c_char) -> c_int;\n \n             #[link_name = \"_close\"]\n-            fn close(fd: c_int) -> c_int;\n+            unsafe fn close(fd: c_int) -> c_int;\n \n             #[link_name = \"_dup\"]\n-            fn dup(fd: c_int) -> c_int;\n+            unsafe fn dup(fd: c_int) -> c_int;\n \n             #[link_name = \"_dup2\"]\n-            fn dup2(src: c_int, dst: c_int) -> c_int;\n+            unsafe fn dup2(src: c_int, dst: c_int) -> c_int;\n \n             #[link_name = \"_execv\"]\n-            fn execv(prog: *c_char, argv: **c_char) -> intptr_t;\n+            unsafe fn execv(prog: *c_char, argv: **c_char) -> intptr_t;\n \n             #[link_name = \"_execve\"]\n-            fn execve(prog: *c_char, argv: **c_char,\n+            unsafe fn execve(prog: *c_char, argv: **c_char,\n                       envp: **c_char) -> c_int;\n \n             #[link_name = \"_execvp\"]\n-            fn execvp(c: *c_char, argv: **c_char) -> c_int;\n+            unsafe fn execvp(c: *c_char, argv: **c_char) -> c_int;\n \n             #[link_name = \"_execvpe\"]\n-            fn execvpe(c: *c_char, argv: **c_char,\n+            unsafe fn execvpe(c: *c_char, argv: **c_char,\n                        envp: **c_char) -> c_int;\n \n             #[link_name = \"_getcwd\"]\n-            fn getcwd(buf: *c_char, size: size_t) -> *c_char;\n+            unsafe fn getcwd(buf: *c_char, size: size_t) -> *c_char;\n \n             #[link_name = \"_getpid\"]\n-            fn getpid() -> c_int;\n+            unsafe fn getpid() -> c_int;\n \n             #[link_name = \"_isatty\"]\n-            fn isatty(fd: c_int) -> c_int;\n+            unsafe fn isatty(fd: c_int) -> c_int;\n \n             #[link_name = \"_lseek\"]\n-            fn lseek(fd: c_int, offset: c_long, origin: c_int) -> c_long;\n+            unsafe fn lseek(fd: c_int, offset: c_long, origin: c_int)\n+                         -> c_long;\n \n             #[link_name = \"_pipe\"]\n-            fn pipe(fds: *mut c_int, psize: c_uint,\n+            unsafe fn pipe(fds: *mut c_int, psize: c_uint,\n                     textmode: c_int) -> c_int;\n \n             #[link_name = \"_read\"]\n-            fn read(fd: c_int, buf: *mut c_void, count: c_uint) -> c_int;\n+            unsafe fn read(fd: c_int, buf: *mut c_void, count: c_uint)\n+                        -> c_int;\n \n             #[link_name = \"_rmdir\"]\n-            fn rmdir(path: *c_char) -> c_int;\n+            unsafe fn rmdir(path: *c_char) -> c_int;\n \n             #[link_name = \"_unlink\"]\n-            fn unlink(c: *c_char) -> c_int;\n+            unsafe fn unlink(c: *c_char) -> c_int;\n \n             #[link_name = \"_write\"]\n-            fn write(fd: c_int, buf: *c_void, count: c_uint) -> c_int;\n+            unsafe fn write(fd: c_int, buf: *c_void, count: c_uint) -> c_int;\n \n         }\n     }\n@@ -1274,104 +1278,106 @@ pub mod funcs {\n         #[nolink]\n         #[abi = \"cdecl\"]\n         pub extern mod stat_ {\n-            fn chmod(path: *c_char, mode: mode_t) -> c_int;\n-            fn fchmod(fd: c_int, mode: mode_t) -> c_int;\n+            unsafe fn chmod(path: *c_char, mode: mode_t) -> c_int;\n+            unsafe fn fchmod(fd: c_int, mode: mode_t) -> c_int;\n \n             #[cfg(target_os = \"linux\")]\n             #[cfg(target_os = \"freebsd\")]\n-            fn fstat(fildes: c_int, buf: *mut stat) -> c_int;\n+            unsafe fn fstat(fildes: c_int, buf: *mut stat) -> c_int;\n \n             #[cfg(target_os = \"macos\")]\n             #[link_name = \"fstat64\"]\n-            fn fstat(fildes: c_int, buf: *mut stat) -> c_int;\n+            unsafe fn fstat(fildes: c_int, buf: *mut stat) -> c_int;\n \n-            fn mkdir(path: *c_char, mode: mode_t) -> c_int;\n-            fn mkfifo(path: *c_char, mode: mode_t) -> c_int;\n+            unsafe fn mkdir(path: *c_char, mode: mode_t) -> c_int;\n+            unsafe fn mkfifo(path: *c_char, mode: mode_t) -> c_int;\n \n             #[cfg(target_os = \"linux\")]\n             #[cfg(target_os = \"freebsd\")]\n-            fn stat(path: *c_char, buf: *mut stat) -> c_int;\n+            unsafe fn stat(path: *c_char, buf: *mut stat) -> c_int;\n \n             #[cfg(target_os = \"macos\")]\n             #[link_name = \"stat64\"]\n-            fn stat(path: *c_char, buf: *mut stat) -> c_int;\n+            unsafe fn stat(path: *c_char, buf: *mut stat) -> c_int;\n         }\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n         pub extern mod stdio {\n-            fn popen(command: *c_char, mode: *c_char) -> *FILE;\n-            fn pclose(stream: *FILE) -> c_int;\n-            fn fdopen(fd: c_int, mode: *c_char) -> *FILE;\n-            fn fileno(stream: *FILE) -> c_int;\n+            unsafe fn popen(command: *c_char, mode: *c_char) -> *FILE;\n+            unsafe fn pclose(stream: *FILE) -> c_int;\n+            unsafe fn fdopen(fd: c_int, mode: *c_char) -> *FILE;\n+            unsafe fn fileno(stream: *FILE) -> c_int;\n         }\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n         pub extern mod fcntl {\n-            fn open(path: *c_char, oflag: c_int, mode: c_int) -> c_int;\n-            fn creat(path: *c_char, mode: mode_t) -> c_int;\n-            fn fcntl(fd: c_int, cmd: c_int) -> c_int;\n+            unsafe fn open(path: *c_char, oflag: c_int, mode: c_int) -> c_int;\n+            unsafe fn creat(path: *c_char, mode: mode_t) -> c_int;\n+            unsafe fn fcntl(fd: c_int, cmd: c_int) -> c_int;\n         }\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n         pub extern mod dirent {\n-            fn opendir(dirname: *c_char) -> *DIR;\n-            fn closedir(dirp: *DIR) -> c_int;\n-            fn readdir(dirp: *DIR) -> *dirent_t;\n-            fn rewinddir(dirp: *DIR);\n-            fn seekdir(dirp: *DIR, loc: c_long);\n-            fn telldir(dirp: *DIR) -> c_long;\n+            unsafe fn opendir(dirname: *c_char) -> *DIR;\n+            unsafe fn closedir(dirp: *DIR) -> c_int;\n+            unsafe fn readdir(dirp: *DIR) -> *dirent_t;\n+            unsafe fn rewinddir(dirp: *DIR);\n+            unsafe fn seekdir(dirp: *DIR, loc: c_long);\n+            unsafe fn telldir(dirp: *DIR) -> c_long;\n         }\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n         pub extern mod unistd {\n-            fn access(path: *c_char, amode: c_int) -> c_int;\n-            fn alarm(seconds: c_uint) -> c_uint;\n-            fn chdir(dir: *c_char) -> c_int;\n-            fn chown(path: *c_char, uid: uid_t, gid: gid_t) -> c_int;\n-            fn close(fd: c_int) -> c_int;\n-            fn dup(fd: c_int) -> c_int;\n-            fn dup2(src: c_int, dst: c_int) -> c_int;\n-            fn execv(prog: *c_char, argv: **c_char) -> c_int;\n-            fn execve(prog: *c_char, argv: **c_char,\n-                      envp: **c_char) -> c_int;\n-            fn execvp(c: *c_char, argv: **c_char) -> c_int;\n-            fn fork() -> pid_t;\n-            fn fpathconf(filedes: c_int, name: c_int) -> c_long;\n-            fn getcwd(buf: *c_char, size: size_t) -> *c_char;\n-            fn getegid() -> gid_t;\n-            fn geteuid() -> uid_t;\n-            fn getgid() -> gid_t ;\n-            fn getgroups(ngroups_max: c_int, groups: *mut gid_t) -> c_int;\n-            fn getlogin() -> *c_char;\n-            fn getopt(argc: c_int, argv: **c_char,\n-                      optstr: *c_char) -> c_int;\n-            fn getpgrp() -> pid_t;\n-            fn getpid() -> pid_t;\n-            fn getppid() -> pid_t;\n-            fn getuid() -> uid_t;\n-            fn isatty(fd: c_int) -> c_int;\n-            fn link(src: *c_char, dst: *c_char) -> c_int;\n-            fn lseek(fd: c_int, offset: off_t, whence: c_int) -> off_t;\n-            fn pathconf(path: *c_char, name: c_int) -> c_long;\n-            fn pause() -> c_int;\n-            fn pipe(fds: *mut c_int) -> c_int;\n-            fn read(fd: c_int, buf: *mut c_void,\n+            unsafe fn access(path: *c_char, amode: c_int) -> c_int;\n+            unsafe fn alarm(seconds: c_uint) -> c_uint;\n+            unsafe fn chdir(dir: *c_char) -> c_int;\n+            unsafe fn chown(path: *c_char, uid: uid_t, gid: gid_t) -> c_int;\n+            unsafe fn close(fd: c_int) -> c_int;\n+            unsafe fn dup(fd: c_int) -> c_int;\n+            unsafe fn dup2(src: c_int, dst: c_int) -> c_int;\n+            unsafe fn execv(prog: *c_char, argv: **c_char) -> c_int;\n+            unsafe fn execve(prog: *c_char, argv: **c_char, envp: **c_char)\n+                          -> c_int;\n+            unsafe fn execvp(c: *c_char, argv: **c_char) -> c_int;\n+            unsafe fn fork() -> pid_t;\n+            unsafe fn fpathconf(filedes: c_int, name: c_int) -> c_long;\n+            unsafe fn getcwd(buf: *c_char, size: size_t) -> *c_char;\n+            unsafe fn getegid() -> gid_t;\n+            unsafe fn geteuid() -> uid_t;\n+            unsafe fn getgid() -> gid_t ;\n+            unsafe fn getgroups(ngroups_max: c_int, groups: *mut gid_t)\n+                             -> c_int;\n+            unsafe fn getlogin() -> *c_char;\n+            unsafe fn getopt(argc: c_int, argv: **c_char, optstr: *c_char)\n+                          -> c_int;\n+            unsafe fn getpgrp() -> pid_t;\n+            unsafe fn getpid() -> pid_t;\n+            unsafe fn getppid() -> pid_t;\n+            unsafe fn getuid() -> uid_t;\n+            unsafe fn isatty(fd: c_int) -> c_int;\n+            unsafe fn link(src: *c_char, dst: *c_char) -> c_int;\n+            unsafe fn lseek(fd: c_int, offset: off_t, whence: c_int) -> off_t;\n+            unsafe fn pathconf(path: *c_char, name: c_int) -> c_long;\n+            unsafe fn pause() -> c_int;\n+            unsafe fn pipe(fds: *mut c_int) -> c_int;\n+            unsafe fn read(fd: c_int, buf: *mut c_void,\n                     count: size_t) -> ssize_t;\n-            fn rmdir(path: *c_char) -> c_int;\n-            fn setgid(gid: gid_t) -> c_int;\n-            fn setpgid(pid: pid_t, pgid: pid_t) -> c_int;\n-            fn setsid() -> pid_t;\n-            fn setuid(uid: uid_t) -> c_int;\n-            fn sleep(secs: c_uint) -> c_uint;\n-            fn sysconf(name: c_int) -> c_long;\n-            fn tcgetpgrp(fd: c_int) -> pid_t;\n-            fn ttyname(fd: c_int) -> *c_char;\n-            fn unlink(c: *c_char) -> c_int;\n-            fn write(fd: c_int, buf: *c_void, count: size_t) -> ssize_t;\n+            unsafe fn rmdir(path: *c_char) -> c_int;\n+            unsafe fn setgid(gid: gid_t) -> c_int;\n+            unsafe fn setpgid(pid: pid_t, pgid: pid_t) -> c_int;\n+            unsafe fn setsid() -> pid_t;\n+            unsafe fn setuid(uid: uid_t) -> c_int;\n+            unsafe fn sleep(secs: c_uint) -> c_uint;\n+            unsafe fn sysconf(name: c_int) -> c_long;\n+            unsafe fn tcgetpgrp(fd: c_int) -> pid_t;\n+            unsafe fn ttyname(fd: c_int) -> *c_char;\n+            unsafe fn unlink(c: *c_char) -> c_int;\n+            unsafe fn write(fd: c_int, buf: *c_void, count: size_t)\n+                         -> ssize_t;\n         }\n     }\n \n@@ -1388,36 +1394,36 @@ pub mod funcs {\n         pub extern mod stat_ {\n             #[cfg(target_os = \"linux\")]\n             #[cfg(target_os = \"freebsd\")]\n-            fn lstat(path: *c_char, buf: *mut stat) -> c_int;\n+            unsafe fn lstat(path: *c_char, buf: *mut stat) -> c_int;\n \n             #[cfg(target_os = \"macos\")]\n             #[link_name = \"lstat64\"]\n-            fn lstat(path: *c_char, buf: *mut stat) -> c_int;\n+            unsafe fn lstat(path: *c_char, buf: *mut stat) -> c_int;\n         }\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n         pub extern mod unistd {\n-            fn readlink(path: *c_char, buf: *mut c_char,\n+            unsafe fn readlink(path: *c_char, buf: *mut c_char,\n                         bufsz: size_t) -> ssize_t;\n \n-            fn fsync(fd: c_int) -> c_int;\n+            unsafe fn fsync(fd: c_int) -> c_int;\n \n             #[cfg(target_os = \"linux\")]\n-            fn fdatasync(fd: c_int) -> c_int;\n+            unsafe fn fdatasync(fd: c_int) -> c_int;\n \n-            fn setenv(name: *c_char, val: *c_char,\n+            unsafe fn setenv(name: *c_char, val: *c_char,\n                       overwrite: c_int) -> c_int;\n-            fn unsetenv(name: *c_char) -> c_int;\n-            fn putenv(string: *c_char) -> c_int;\n+            unsafe fn unsetenv(name: *c_char) -> c_int;\n+            unsafe fn putenv(string: *c_char) -> c_int;\n \n-            fn symlink(path1: *c_char, path2: *c_char) -> c_int;\n+            unsafe fn symlink(path1: *c_char, path2: *c_char) -> c_int;\n         }\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n         pub extern mod wait {\n-            fn waitpid(pid: pid_t, status: *mut c_int,\n+            unsafe fn waitpid(pid: pid_t, status: *mut c_int,\n                        options: c_int) -> pid_t;\n         }\n     }\n@@ -1453,15 +1459,15 @@ pub mod funcs {\n         use libc::types::common::c95::{c_void};\n         use libc::types::os::arch::c95::{c_char, c_int, c_uint, size_t};\n \n-        fn sysctl(name: *c_int, namelen: c_uint,\n+        unsafe fn sysctl(name: *c_int, namelen: c_uint,\n                   oldp: *mut c_void, oldlenp: *mut size_t,\n                   newp: *c_void, newlen: size_t) -> c_int;\n \n-        fn sysctlbyname(name: *c_char,\n+        unsafe fn sysctlbyname(name: *c_char,\n                         oldp: *mut c_void, oldlenp: *mut size_t,\n                         newp: *c_void, newlen: size_t) -> c_int;\n \n-        fn sysctlnametomib(name: *c_char, mibp: *mut c_int,\n+        unsafe fn sysctlnametomib(name: *c_char, mibp: *mut c_int,\n                            sizep: *mut size_t) -> c_int;\n     }\n \n@@ -1477,7 +1483,7 @@ pub mod funcs {\n     pub extern mod extra {\n         use libc::types::os::arch::c95::{c_char, c_int};\n \n-        fn _NSGetExecutablePath(buf: *mut c_char,\n+        unsafe fn _NSGetExecutablePath(buf: *mut c_char,\n                                 bufsize: *mut u32) -> c_int;\n     }\n \n@@ -1498,32 +1504,32 @@ pub mod funcs {\n \n         #[abi = \"stdcall\"]\n         pub extern mod kernel32 {\n-            fn GetEnvironmentVariableW(n: LPCWSTR,\n+            unsafe fn GetEnvironmentVariableW(n: LPCWSTR,\n                                        v: LPWSTR,\n                                        nsize: DWORD) -> DWORD;\n-            fn SetEnvironmentVariableW(n: LPCWSTR, v: LPCWSTR) -> BOOL;\n+            unsafe fn SetEnvironmentVariableW(n: LPCWSTR, v: LPCWSTR) -> BOOL;\n \n-            fn GetModuleFileNameW(hModule: HMODULE,\n+            unsafe fn GetModuleFileNameW(hModule: HMODULE,\n                                   lpFilename: LPWSTR,\n                                   nSize: DWORD) -> DWORD;\n-            fn CreateDirectoryW(lpPathName: LPCWSTR,\n+            unsafe fn CreateDirectoryW(lpPathName: LPCWSTR,\n                                 lpSecurityAttributes:\n                                 LPSECURITY_ATTRIBUTES) -> BOOL;\n-            fn CopyFileW(lpExistingFileName: LPCWSTR,\n+            unsafe fn CopyFileW(lpExistingFileName: LPCWSTR,\n                          lpNewFileName: LPCWSTR,\n                          bFailIfExists: BOOL) -> BOOL;\n-            fn DeleteFileW(lpPathName: LPCWSTR) -> BOOL;\n-            fn RemoveDirectoryW(lpPathName: LPCWSTR) -> BOOL;\n-            fn SetCurrentDirectoryW(lpPathName: LPCWSTR) -> BOOL;\n+            unsafe fn DeleteFileW(lpPathName: LPCWSTR) -> BOOL;\n+            unsafe fn RemoveDirectoryW(lpPathName: LPCWSTR) -> BOOL;\n+            unsafe fn SetCurrentDirectoryW(lpPathName: LPCWSTR) -> BOOL;\n \n-            fn GetLastError() -> DWORD;\n+            unsafe fn GetLastError() -> DWORD;\n         }\n \n         #[abi = \"cdecl\"]\n         #[nolink]\n         pub extern mod msvcrt {\n             #[link_name = \"_commit\"]\n-            pub fn commit(fd: c_int) -> c_int;\n+            unsafe fn commit(fd: c_int) -> c_int;\n         }\n     }\n }"}, {"sha": "922995a5af79ca680f08dfbbb679f80888b4fceb", "filename": "src/libcore/logging.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flogging.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -22,14 +22,18 @@ use vec;\n \n #[nolink]\n extern mod rustrt {\n-    fn rust_log_console_on();\n-    fn rust_log_console_off();\n-    fn rust_log_str(level: u32, string: *libc::c_char, size: libc::size_t);\n+    unsafe fn rust_log_console_on();\n+    unsafe fn rust_log_console_off();\n+    unsafe fn rust_log_str(level: u32,\n+                           string: *libc::c_char,\n+                           size: libc::size_t);\n }\n \n /// Turns on logging to stdout globally\n pub fn console_on() {\n-    rustrt::rust_log_console_on();\n+    unsafe {\n+        rustrt::rust_log_console_on();\n+    }\n }\n \n /**\n@@ -40,7 +44,9 @@ pub fn console_on() {\n  * the RUST_LOG environment variable\n  */\n pub fn console_off() {\n-    rustrt::rust_log_console_off();\n+    unsafe {\n+        rustrt::rust_log_console_off();\n+    }\n }\n \n #[cfg(notest)]"}, {"sha": "65aaf1fe428088b8d6ab4e4e18bc149ba74c24f2", "filename": "src/libcore/oldcomm.rs", "status": "modified", "additions": 94, "deletions": 77, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Foldcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Foldcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foldcomm.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -90,7 +90,9 @@ pub enum Chan<T: Owned> {\n \n /// Constructs a port\n pub fn Port<T: Owned>() -> Port<T> {\n-    Port_(@PortPtr(rustrt::new_port(sys::size_of::<T>() as size_t)))\n+    unsafe {\n+        Port_(@PortPtr(rustrt::new_port(sys::size_of::<T>() as size_t)))\n+    }\n }\n \n impl<T: Owned> Port<T> {\n@@ -159,11 +161,13 @@ fn as_raw_port<T: Owned, U>(ch: Chan<T>, f: fn(*rust_port) -> U) -> U {\n \n     struct PortRef {\n         p: *rust_port,\n-       drop {\n-         if !ptr::is_null(self.p) {\n-           rustrt::rust_port_drop(self.p);\n-         }\n-       }\n+        drop {\n+            unsafe {\n+                if !ptr::is_null(self.p) {\n+                    rustrt::rust_port_drop(self.p);\n+                }\n+            }\n+        }\n     }\n \n     fn PortRef(p: *rust_port) -> PortRef {\n@@ -172,38 +176,44 @@ fn as_raw_port<T: Owned, U>(ch: Chan<T>, f: fn(*rust_port) -> U) -> U {\n         }\n     }\n \n-    let p = PortRef(rustrt::rust_port_take(*ch));\n+    unsafe {\n+        let p = PortRef(rustrt::rust_port_take(*ch));\n \n-    if ptr::is_null(p.p) {\n-        fail ~\"unable to locate port for channel\"\n-    } else if rustrt::get_task_id() != rustrt::rust_port_task(p.p) {\n-        fail ~\"unable to access unowned port\"\n-    }\n+        if ptr::is_null(p.p) {\n+            fail ~\"unable to locate port for channel\"\n+        } else if rustrt::get_task_id() != rustrt::rust_port_task(p.p) {\n+            fail ~\"unable to access unowned port\"\n+        }\n \n-    f(p.p)\n+        f(p.p)\n+    }\n }\n \n /**\n  * Constructs a channel. The channel is bound to the port used to\n  * construct it.\n  */\n pub fn Chan<T: Owned>(p: &Port<T>) -> Chan<T> {\n-    Chan_(rustrt::get_port_id((**p).po))\n+    unsafe {\n+        Chan_(rustrt::get_port_id((**p).po))\n+    }\n }\n \n /**\n  * Sends data over a channel. The sent data is moved into the channel,\n  * whereupon the caller loses access to it.\n  */\n pub fn send<T: Owned>(ch: Chan<T>, data: T) {\n-    let Chan_(p) = ch;\n-    let data_ptr = ptr::addr_of(&data) as *();\n-    let res = rustrt::rust_port_id_send(p, data_ptr);\n-    if res != 0 unsafe {\n-        // Data sent successfully\n-        cast::forget(move data);\n+    unsafe {\n+        let Chan_(p) = ch;\n+        let data_ptr = ptr::addr_of(&data) as *();\n+        let res = rustrt::rust_port_id_send(p, data_ptr);\n+        if res != 0 unsafe {\n+            // Data sent successfully\n+            cast::forget(move data);\n+        }\n+        task::yield();\n     }\n-    task::yield();\n }\n \n /**\n@@ -226,61 +236,67 @@ fn peek_chan<T: Owned>(ch: Chan<T>) -> bool {\n \n /// Receive on a raw port pointer\n fn recv_<T: Owned>(p: *rust_port) -> T {\n-    let yield = 0;\n-    let yieldp = ptr::addr_of(&yield);\n-    let mut res;\n-    res = rusti::init::<T>();\n-    rustrt::port_recv(ptr::addr_of(&res) as *uint, p, yieldp);\n-\n-    if yield != 0 {\n-        // Data isn't available yet, so res has not been initialized.\n-        task::yield();\n-    } else {\n-        // In the absence of compiler-generated preemption points\n-        // this is a good place to yield\n-        task::yield();\n+    unsafe {\n+        let yield = 0;\n+        let yieldp = ptr::addr_of(&yield);\n+        let mut res;\n+        res = rusti::init::<T>();\n+        rustrt::port_recv(ptr::addr_of(&res) as *uint, p, yieldp);\n+\n+        if yield != 0 {\n+            // Data isn't available yet, so res has not been initialized.\n+            task::yield();\n+        } else {\n+            // In the absence of compiler-generated preemption points\n+            // this is a good place to yield\n+            task::yield();\n+        }\n+        move res\n     }\n-    move res\n }\n \n fn peek_(p: *rust_port) -> bool {\n-    // Yield here before we check to see if someone sent us a message\n-    // FIXME #524, if the compiler generates yields, we don't need this\n-    task::yield();\n-    rustrt::rust_port_size(p) != 0 as libc::size_t\n+    unsafe {\n+        // Yield here before we check to see if someone sent us a message\n+        // FIXME #524, if the compiler generates yields, we don't need this\n+        task::yield();\n+        rustrt::rust_port_size(p) != 0 as libc::size_t\n+    }\n }\n \n /// Receive on one of two ports\n pub fn select2<A: Owned, B: Owned>(p_a: Port<A>, p_b: Port<B>)\n     -> Either<A, B> {\n-    let ports = ~[(**p_a).po, (**p_b).po];\n-    let yield = 0, yieldp = ptr::addr_of(&yield);\n-\n-    let mut resport: *rust_port;\n-    resport = rusti::init::<*rust_port>();\n-    do vec::as_imm_buf(ports) |ports, n_ports| {\n-        rustrt::rust_port_select(ptr::addr_of(&resport), ports,\n-                                 n_ports as size_t, yieldp);\n-    }\n+    unsafe {\n+        let ports = ~[(**p_a).po, (**p_b).po];\n+        let yield = 0, yieldp = ptr::addr_of(&yield);\n+\n+        let mut resport: *rust_port;\n+        resport = rusti::init::<*rust_port>();\n+        do vec::as_imm_buf(ports) |ports, n_ports| {\n+            rustrt::rust_port_select(ptr::addr_of(&resport), ports,\n+                                     n_ports as size_t, yieldp);\n+        }\n \n-    if yield != 0 {\n-        // Wait for data\n-        task::yield();\n-    } else {\n-        // As in recv, this is a good place to yield anyway until\n-        // the compiler generates yield calls\n-        task::yield();\n-    }\n+        if yield != 0 {\n+            // Wait for data\n+            task::yield();\n+        } else {\n+            // As in recv, this is a good place to yield anyway until\n+            // the compiler generates yield calls\n+            task::yield();\n+        }\n \n-    // Now we know the port we're supposed to receive from\n-    assert resport != ptr::null();\n+        // Now we know the port we're supposed to receive from\n+        assert resport != ptr::null();\n \n-    if resport == (**p_a).po {\n-        either::Left(recv(p_a))\n-    } else if resport == (**p_b).po {\n-        either::Right(recv(p_b))\n-    } else {\n-        fail ~\"unexpected result from rust_port_select\";\n+        if resport == (**p_a).po {\n+            either::Left(recv(p_a))\n+        } else if resport == (**p_b).po {\n+            either::Right(recv(p_b))\n+        } else {\n+            fail ~\"unexpected result from rust_port_select\";\n+        }\n     }\n }\n \n@@ -295,24 +311,25 @@ type port_id = int;\n \n #[abi = \"cdecl\"]\n extern mod rustrt {\n-    fn rust_port_id_send(target_port: port_id, data: *()) -> libc::uintptr_t;\n+    unsafe fn rust_port_id_send(target_port: port_id, data: *())\n+                             -> libc::uintptr_t;\n \n-    fn new_port(unit_sz: libc::size_t) -> *rust_port;\n-    fn del_port(po: *rust_port);\n-    fn rust_port_begin_detach(po: *rust_port,\n+    unsafe fn new_port(unit_sz: libc::size_t) -> *rust_port;\n+    unsafe fn del_port(po: *rust_port);\n+    unsafe fn rust_port_begin_detach(po: *rust_port,\n                               yield: *libc::uintptr_t);\n-    fn rust_port_end_detach(po: *rust_port);\n-    fn get_port_id(po: *rust_port) -> port_id;\n-    fn rust_port_size(po: *rust_port) -> libc::size_t;\n-    fn port_recv(dptr: *uint, po: *rust_port,\n+    unsafe fn rust_port_end_detach(po: *rust_port);\n+    unsafe fn get_port_id(po: *rust_port) -> port_id;\n+    unsafe fn rust_port_size(po: *rust_port) -> libc::size_t;\n+    unsafe fn port_recv(dptr: *uint, po: *rust_port,\n                  yield: *libc::uintptr_t);\n-    fn rust_port_select(dptr: **rust_port, ports: **rust_port,\n+    unsafe fn rust_port_select(dptr: **rust_port, ports: **rust_port,\n                         n_ports: libc::size_t,\n                         yield: *libc::uintptr_t);\n-    fn rust_port_take(port_id: port_id) -> *rust_port;\n-    fn rust_port_drop(p: *rust_port);\n-    fn rust_port_task(p: *rust_port) -> libc::uintptr_t;\n-    fn get_task_id() -> libc::uintptr_t;\n+    unsafe fn rust_port_take(port_id: port_id) -> *rust_port;\n+    unsafe fn rust_port_drop(p: *rust_port);\n+    unsafe fn rust_port_task(p: *rust_port) -> libc::uintptr_t;\n+    unsafe fn get_task_id() -> libc::uintptr_t;\n }\n \n #[abi = \"rust-intrinsic\"]"}, {"sha": "3a2b606e1eae2ffce781fa2b108693f7a9c1bf89", "filename": "src/libcore/os.rs", "status": "modified", "additions": 234, "deletions": 166, "changes": 400, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -47,27 +47,35 @@ use task::TaskBuilder;\n use uint;\n use vec;\n \n-pub use libc::{close, fclose};\n+pub use libc::fclose;\n pub use os::consts::*;\n \n // FIXME: move these to str perhaps? #2620\n \n+pub fn close(fd: c_int) -> c_int {\n+    unsafe {\n+        libc::close(fd)\n+    }\n+}\n+\n extern mod rustrt {\n-    fn rust_get_argc() -> c_int;\n-    fn rust_get_argv() -> **c_char;\n-    fn rust_getcwd() -> ~str;\n-    fn rust_path_is_dir(path: *libc::c_char) -> c_int;\n-    fn rust_path_exists(path: *libc::c_char) -> c_int;\n-    fn rust_list_files2(&&path: ~str) -> ~[~str];\n-    fn rust_process_wait(handle: c_int) -> c_int;\n-    fn last_os_error() -> ~str;\n-    fn rust_set_exit_status(code: libc::intptr_t);\n+    unsafe fn rust_get_argc() -> c_int;\n+    unsafe fn rust_get_argv() -> **c_char;\n+    unsafe fn rust_getcwd() -> ~str;\n+    unsafe fn rust_path_is_dir(path: *libc::c_char) -> c_int;\n+    unsafe fn rust_path_exists(path: *libc::c_char) -> c_int;\n+    unsafe fn rust_list_files2(&&path: ~str) -> ~[~str];\n+    unsafe fn rust_process_wait(handle: c_int) -> c_int;\n+    unsafe fn last_os_error() -> ~str;\n+    unsafe fn rust_set_exit_status(code: libc::intptr_t);\n }\n \n pub const tmpbuf_sz : uint = 1000u;\n \n pub fn getcwd() -> Path {\n-    Path(rustrt::rust_getcwd())\n+    unsafe {\n+        Path(rustrt::rust_getcwd())\n+    }\n }\n \n pub fn as_c_charp<T>(s: &str, f: fn(*c_char) -> T) -> T {\n@@ -152,7 +160,7 @@ mod global_env {\n     use task;\n \n     extern mod rustrt {\n-        fn rust_global_env_chan_ptr() -> *libc::uintptr_t;\n+        unsafe fn rust_global_env_chan_ptr() -> *libc::uintptr_t;\n     }\n \n     enum Msg {\n@@ -186,8 +194,8 @@ mod global_env {\n     }\n \n     fn get_global_env_chan() -> oldcomm::Chan<Msg> {\n-        let global_ptr = rustrt::rust_global_env_chan_ptr();\n         unsafe {\n+            let global_ptr = rustrt::rust_global_env_chan_ptr();\n             private::chan_from_global_ptr(global_ptr, || {\n                 // FIXME (#2621): This would be a good place to use a very\n                 // small foreign stack\n@@ -227,23 +235,25 @@ mod global_env {\n         use vec;\n \n         extern mod rustrt {\n-            fn rust_env_pairs() -> ~[~str];\n+            unsafe fn rust_env_pairs() -> ~[~str];\n         }\n \n         pub fn env() -> ~[(~str,~str)] {\n-            let mut pairs = ~[];\n-            for vec::each(rustrt::rust_env_pairs()) |p| {\n-                let vs = str::splitn_char(*p, '=', 1u);\n-                assert vec::len(vs) == 2u;\n-                pairs.push((copy vs[0], copy vs[1]));\n+            unsafe {\n+                let mut pairs = ~[];\n+                for vec::each(rustrt::rust_env_pairs()) |p| {\n+                    let vs = str::splitn_char(*p, '=', 1u);\n+                    assert vec::len(vs) == 2u;\n+                    pairs.push((copy vs[0], copy vs[1]));\n+                }\n+                move pairs\n             }\n-            move pairs\n         }\n \n         #[cfg(unix)]\n         pub fn getenv(n: &str) -> Option<~str> {\n             unsafe {\n-                let s = str::as_c_str(n, libc::getenv);\n+                let s = str::as_c_str(n, |s| libc::getenv(s));\n                 return if ptr::null::<u8>() == cast::reinterpret_cast(&s) {\n                     option::None::<~str>\n                 } else {\n@@ -255,31 +265,37 @@ mod global_env {\n \n         #[cfg(windows)]\n         pub fn getenv(n: &str) -> Option<~str> {\n-            use os::win32::{as_utf16_p, fill_utf16_buf_and_decode};\n-            do as_utf16_p(n) |u| {\n-                do fill_utf16_buf_and_decode() |buf, sz| {\n-                    libc::GetEnvironmentVariableW(u, buf, sz)\n+            unsafe {\n+                use os::win32::{as_utf16_p, fill_utf16_buf_and_decode};\n+                do as_utf16_p(n) |u| {\n+                    do fill_utf16_buf_and_decode() |buf, sz| {\n+                        libc::GetEnvironmentVariableW(u, buf, sz)\n+                    }\n                 }\n             }\n         }\n \n \n         #[cfg(unix)]\n         pub fn setenv(n: &str, v: &str) {\n-            do str::as_c_str(n) |nbuf| {\n-                do str::as_c_str(v) |vbuf| {\n-                    libc::funcs::posix01::unistd::setenv(nbuf, vbuf, 1i32);\n+            unsafe {\n+                do str::as_c_str(n) |nbuf| {\n+                    do str::as_c_str(v) |vbuf| {\n+                        libc::funcs::posix01::unistd::setenv(nbuf, vbuf, 1);\n+                    }\n                 }\n             }\n         }\n \n \n         #[cfg(windows)]\n         pub fn setenv(n: &str, v: &str) {\n-            use os::win32::as_utf16_p;\n-            do as_utf16_p(n) |nbuf| {\n-                do as_utf16_p(v) |vbuf| {\n-                    libc::SetEnvironmentVariableW(nbuf, vbuf);\n+            unsafe {\n+                use os::win32::as_utf16_p;\n+                do as_utf16_p(n) |nbuf| {\n+                    do as_utf16_p(v) |vbuf| {\n+                        libc::SetEnvironmentVariableW(nbuf, vbuf);\n+                    }\n                 }\n             }\n         }\n@@ -288,9 +304,11 @@ mod global_env {\n }\n \n pub fn fdopen(fd: c_int) -> *FILE {\n-    return do as_c_charp(\"r\") |modebuf| {\n-        libc::fdopen(fd, modebuf)\n-    };\n+    unsafe {\n+        return do as_c_charp(\"r\") |modebuf| {\n+            libc::fdopen(fd, modebuf)\n+        };\n+    }\n }\n \n \n@@ -314,74 +332,89 @@ pub fn fsync_fd(fd: c_int, level: io::fsync::Level) -> c_int {\n \n #[cfg(target_os = \"macos\")]\n pub fn fsync_fd(fd: c_int, level: io::fsync::Level) -> c_int {\n-    use libc::consts::os::extra::*;\n-    use libc::funcs::posix88::fcntl::*;\n-    use libc::funcs::posix01::unistd::*;\n-    match level {\n-      io::fsync::FSync => return fsync(fd),\n-      _ => {\n-        // According to man fnctl, the ok retval is only specified to be !=-1\n-        if (fcntl(F_FULLFSYNC as c_int, fd) == -1 as c_int)\n-            { return -1 as c_int; }\n-        else\n-            { return 0 as c_int; }\n-      }\n+    unsafe {\n+        use libc::consts::os::extra::*;\n+        use libc::funcs::posix88::fcntl::*;\n+        use libc::funcs::posix01::unistd::*;\n+        match level {\n+          io::fsync::FSync => return fsync(fd),\n+          _ => {\n+            // According to man fnctl, the ok retval is only specified to be\n+            // !=-1\n+            if (fcntl(F_FULLFSYNC as c_int, fd) == -1 as c_int)\n+                { return -1 as c_int; }\n+            else\n+                { return 0 as c_int; }\n+          }\n+        }\n     }\n }\n \n #[cfg(target_os = \"freebsd\")]\n pub fn fsync_fd(fd: c_int, _l: io::fsync::Level) -> c_int {\n-    use libc::funcs::posix01::unistd::*;\n-    return fsync(fd);\n+    unsafe {\n+        use libc::funcs::posix01::unistd::*;\n+        return fsync(fd);\n+    }\n }\n \n \n #[cfg(windows)]\n pub fn waitpid(pid: pid_t) -> c_int {\n-    return rustrt::rust_process_wait(pid);\n+    unsafe {\n+        return rustrt::rust_process_wait(pid);\n+    }\n }\n \n #[cfg(unix)]\n pub fn waitpid(pid: pid_t) -> c_int {\n-    use libc::funcs::posix01::wait::*;\n-    let status = 0 as c_int;\n+    unsafe {\n+        use libc::funcs::posix01::wait::*;\n+        let status = 0 as c_int;\n \n-    assert (waitpid(pid, ptr::mut_addr_of(&status),\n-                    0 as c_int) != (-1 as c_int));\n-    return status;\n+        assert (waitpid(pid, ptr::mut_addr_of(&status),\n+                        0 as c_int) != (-1 as c_int));\n+        return status;\n+    }\n }\n \n \n #[cfg(unix)]\n pub fn pipe() -> {in: c_int, out: c_int} {\n-    let fds = {mut in: 0 as c_int,\n-               mut out: 0 as c_int };\n-    assert (libc::pipe(ptr::mut_addr_of(&(fds.in))) == (0 as c_int));\n-    return {in: fds.in, out: fds.out};\n+    unsafe {\n+        let fds = {mut in: 0 as c_int,\n+                   mut out: 0 as c_int };\n+        assert (libc::pipe(ptr::mut_addr_of(&(fds.in))) == (0 as c_int));\n+        return {in: fds.in, out: fds.out};\n+    }\n }\n \n \n \n #[cfg(windows)]\n pub fn pipe() -> {in: c_int, out: c_int} {\n-    // Windows pipes work subtly differently than unix pipes, and their\n-    // inheritance has to be handled in a different way that I do not fully\n-    // understand. Here we explicitly make the pipe non-inheritable, which\n-    // means to pass it to a subprocess they need to be duplicated first, as\n-    // in rust_run_program.\n-    let fds = { mut in: 0 as c_int,\n-                mut out: 0 as c_int };\n-    let res = libc::pipe(ptr::mut_addr_of(&(fds.in)),\n-                         1024 as c_uint,\n-                         (libc::O_BINARY | libc::O_NOINHERIT) as c_int);\n-    assert (res == 0 as c_int);\n-    assert (fds.in != -1 as c_int && fds.in != 0 as c_int);\n-    assert (fds.out != -1 as c_int && fds.in != 0 as c_int);\n-    return {in: fds.in, out: fds.out};\n+    unsafe {\n+        // Windows pipes work subtly differently than unix pipes, and their\n+        // inheritance has to be handled in a different way that I do not\n+        // fully understand. Here we explicitly make the pipe non-inheritable,\n+        // which means to pass it to a subprocess they need to be duplicated\n+        // first, as in rust_run_program.\n+        let fds = { mut in: 0 as c_int,\n+                    mut out: 0 as c_int };\n+        let res = libc::pipe(ptr::mut_addr_of(&(fds.in)),\n+                             1024 as c_uint,\n+                             (libc::O_BINARY | libc::O_NOINHERIT) as c_int);\n+        assert (res == 0 as c_int);\n+        assert (fds.in != -1 as c_int && fds.in != 0 as c_int);\n+        assert (fds.out != -1 as c_int && fds.in != 0 as c_int);\n+        return {in: fds.in, out: fds.out};\n+    }\n }\n \n fn dup2(src: c_int, dst: c_int) -> c_int {\n-    libc::dup2(src, dst)\n+    unsafe {\n+        libc::dup2(src, dst)\n+    }\n }\n \n \n@@ -411,27 +444,33 @@ pub fn self_exe_path() -> Option<Path> {\n \n     #[cfg(target_os = \"linux\")]\n     fn load_self() -> Option<~str> {\n-        use libc::funcs::posix01::unistd::readlink;\n-        do fill_charp_buf() |buf, sz| {\n-            do as_c_charp(\"/proc/self/exe\") |proc_self_buf| {\n-                readlink(proc_self_buf, buf, sz) != (-1 as ssize_t)\n+        unsafe {\n+            use libc::funcs::posix01::unistd::readlink;\n+            do fill_charp_buf() |buf, sz| {\n+                do as_c_charp(\"/proc/self/exe\") |proc_self_buf| {\n+                    readlink(proc_self_buf, buf, sz) != (-1 as ssize_t)\n+                }\n             }\n         }\n     }\n \n     #[cfg(target_os = \"macos\")]\n     fn load_self() -> Option<~str> {\n-        do fill_charp_buf() |buf, sz| {\n-            libc::funcs::extra::_NSGetExecutablePath(\n-                buf, ptr::mut_addr_of(&(sz as u32))) == (0 as c_int)\n+        unsafe {\n+            do fill_charp_buf() |buf, sz| {\n+                libc::funcs::extra::_NSGetExecutablePath(\n+                    buf, ptr::mut_addr_of(&(sz as u32))) == (0 as c_int)\n+            }\n         }\n     }\n \n     #[cfg(windows)]\n     fn load_self() -> Option<~str> {\n-        use os::win32::fill_utf16_buf_and_decode;\n-        do fill_utf16_buf_and_decode() |buf, sz| {\n-            libc::GetModuleFileNameW(0u as libc::DWORD, buf, sz)\n+        unsafe {\n+            use os::win32::fill_utf16_buf_and_decode;\n+            do fill_utf16_buf_and_decode() |buf, sz| {\n+                libc::GetModuleFileNameW(0u as libc::DWORD, buf, sz)\n+            }\n         }\n     }\n \n@@ -555,15 +594,19 @@ pub fn walk_dir(p: &Path, f: fn(&Path) -> bool) {\n \n /// Indicates whether a path represents a directory\n pub fn path_is_dir(p: &Path) -> bool {\n-    do str::as_c_str(p.to_str()) |buf| {\n-        rustrt::rust_path_is_dir(buf) != 0 as c_int\n+    unsafe {\n+        do str::as_c_str(p.to_str()) |buf| {\n+            rustrt::rust_path_is_dir(buf) != 0 as c_int\n+        }\n     }\n }\n \n /// Indicates whether a path exists\n pub fn path_exists(p: &Path) -> bool {\n-    do str::as_c_str(p.to_str()) |buf| {\n-        rustrt::rust_path_exists(buf) != 0 as c_int\n+    unsafe {\n+        do str::as_c_str(p.to_str()) |buf| {\n+            rustrt::rust_path_exists(buf) != 0 as c_int\n+        }\n     }\n }\n \n@@ -592,36 +635,41 @@ pub fn make_dir(p: &Path, mode: c_int) -> bool {\n \n     #[cfg(windows)]\n     fn mkdir(p: &Path, _mode: c_int) -> bool {\n-        use os::win32::as_utf16_p;\n-        // FIXME: turn mode into something useful? #2623\n-        do as_utf16_p(p.to_str()) |buf| {\n-            libc::CreateDirectoryW(buf, unsafe {\n-                cast::reinterpret_cast(&0)\n-            })\n-                != (0 as libc::BOOL)\n+        unsafe {\n+            use os::win32::as_utf16_p;\n+            // FIXME: turn mode into something useful? #2623\n+            do as_utf16_p(p.to_str()) |buf| {\n+                libc::CreateDirectoryW(buf, unsafe {\n+                    cast::reinterpret_cast(&0)\n+                })\n+                    != (0 as libc::BOOL)\n+            }\n         }\n     }\n \n     #[cfg(unix)]\n     fn mkdir(p: &Path, mode: c_int) -> bool {\n-        do as_c_charp(p.to_str()) |c| {\n-            libc::mkdir(c, mode as mode_t) == (0 as c_int)\n+        unsafe {\n+            do as_c_charp(p.to_str()) |c| {\n+                libc::mkdir(c, mode as mode_t) == (0 as c_int)\n+            }\n         }\n     }\n }\n \n /// Lists the contents of a directory\n #[allow(non_implicitly_copyable_typarams)]\n pub fn list_dir(p: &Path) -> ~[~str] {\n+    unsafe {\n+        #[cfg(unix)]\n+        fn star(p: &Path) -> Path { copy *p }\n \n-    #[cfg(unix)]\n-    fn star(p: &Path) -> Path { copy *p }\n-\n-    #[cfg(windows)]\n-    fn star(p: &Path) -> Path { p.push(\"*\") }\n+        #[cfg(windows)]\n+        fn star(p: &Path) -> Path { p.push(\"*\") }\n \n-    do rustrt::rust_list_files2(star(p).to_str()).filtered |filename| {\n-        *filename != ~\".\" && *filename != ~\"..\"\n+        do rustrt::rust_list_files2(star(p).to_str()).filtered |filename| {\n+            *filename != ~\".\" && *filename != ~\"..\"\n+        }\n     }\n }\n \n@@ -640,17 +688,21 @@ pub fn remove_dir(p: &Path) -> bool {\n \n     #[cfg(windows)]\n     fn rmdir(p: &Path) -> bool {\n-        use os::win32::as_utf16_p;\n-        return do as_utf16_p(p.to_str()) |buf| {\n-            libc::RemoveDirectoryW(buf) != (0 as libc::BOOL)\n-        };\n+        unsafe {\n+            use os::win32::as_utf16_p;\n+            return do as_utf16_p(p.to_str()) |buf| {\n+                libc::RemoveDirectoryW(buf) != (0 as libc::BOOL)\n+            };\n+        }\n     }\n \n     #[cfg(unix)]\n     fn rmdir(p: &Path) -> bool {\n-        return do as_c_charp(p.to_str()) |buf| {\n-            libc::rmdir(buf) == (0 as c_int)\n-        };\n+        unsafe {\n+            return do as_c_charp(p.to_str()) |buf| {\n+                libc::rmdir(buf) == (0 as c_int)\n+            };\n+        }\n     }\n }\n \n@@ -659,17 +711,21 @@ pub fn change_dir(p: &Path) -> bool {\n \n     #[cfg(windows)]\n     fn chdir(p: &Path) -> bool {\n-        use os::win32::as_utf16_p;\n-        return do as_utf16_p(p.to_str()) |buf| {\n-            libc::SetCurrentDirectoryW(buf) != (0 as libc::BOOL)\n-        };\n+        unsafe {\n+            use os::win32::as_utf16_p;\n+            return do as_utf16_p(p.to_str()) |buf| {\n+                libc::SetCurrentDirectoryW(buf) != (0 as libc::BOOL)\n+            };\n+        }\n     }\n \n     #[cfg(unix)]\n     fn chdir(p: &Path) -> bool {\n-        return do as_c_charp(p.to_str()) |buf| {\n-            libc::chdir(buf) == (0 as c_int)\n-        };\n+        unsafe {\n+            return do as_c_charp(p.to_str()) |buf| {\n+                libc::chdir(buf) == (0 as c_int)\n+            };\n+        }\n     }\n }\n \n@@ -679,57 +735,61 @@ pub fn copy_file(from: &Path, to: &Path) -> bool {\n \n     #[cfg(windows)]\n     fn do_copy_file(from: &Path, to: &Path) -> bool {\n-        use os::win32::as_utf16_p;\n-        return do as_utf16_p(from.to_str()) |fromp| {\n-            do as_utf16_p(to.to_str()) |top| {\n-                libc::CopyFileW(fromp, top, (0 as libc::BOOL)) !=\n-                    (0 as libc::BOOL)\n+        unsafe {\n+            use os::win32::as_utf16_p;\n+            return do as_utf16_p(from.to_str()) |fromp| {\n+                do as_utf16_p(to.to_str()) |top| {\n+                    libc::CopyFileW(fromp, top, (0 as libc::BOOL)) !=\n+                        (0 as libc::BOOL)\n+                }\n             }\n         }\n     }\n \n     #[cfg(unix)]\n     fn do_copy_file(from: &Path, to: &Path) -> bool {\n-        let istream = do as_c_charp(from.to_str()) |fromp| {\n-            do as_c_charp(\"rb\") |modebuf| {\n-                libc::fopen(fromp, modebuf)\n+        unsafe {\n+            let istream = do as_c_charp(from.to_str()) |fromp| {\n+                do as_c_charp(\"rb\") |modebuf| {\n+                    libc::fopen(fromp, modebuf)\n+                }\n+            };\n+            if istream as uint == 0u {\n+                return false;\n             }\n-        };\n-        if istream as uint == 0u {\n-            return false;\n-        }\n-        let ostream = do as_c_charp(to.to_str()) |top| {\n-            do as_c_charp(\"w+b\") |modebuf| {\n-                libc::fopen(top, modebuf)\n+            let ostream = do as_c_charp(to.to_str()) |top| {\n+                do as_c_charp(\"w+b\") |modebuf| {\n+                    libc::fopen(top, modebuf)\n+                }\n+            };\n+            if ostream as uint == 0u {\n+                fclose(istream);\n+                return false;\n             }\n-        };\n-        if ostream as uint == 0u {\n-            fclose(istream);\n-            return false;\n-        }\n-        let bufsize = 8192u;\n-        let mut buf = vec::with_capacity::<u8>(bufsize);\n-        let mut done = false;\n-        let mut ok = true;\n-        while !done {\n-            do vec::as_mut_buf(buf) |b, _sz| {\n-              let nread = libc::fread(b as *mut c_void, 1u as size_t,\n-                                      bufsize as size_t,\n-                                      istream);\n-              if nread > 0 as size_t {\n-                  if libc::fwrite(b as *c_void, 1u as size_t, nread,\n-                                  ostream) != nread {\n-                      ok = false;\n+            let bufsize = 8192u;\n+            let mut buf = vec::with_capacity::<u8>(bufsize);\n+            let mut done = false;\n+            let mut ok = true;\n+            while !done {\n+                do vec::as_mut_buf(buf) |b, _sz| {\n+                  let nread = libc::fread(b as *mut c_void, 1u as size_t,\n+                                          bufsize as size_t,\n+                                          istream);\n+                  if nread > 0 as size_t {\n+                      if libc::fwrite(b as *c_void, 1u as size_t, nread,\n+                                      ostream) != nread {\n+                          ok = false;\n+                          done = true;\n+                      }\n+                  } else {\n                       done = true;\n                   }\n-              } else {\n-                  done = true;\n               }\n-          }\n+            }\n+            fclose(istream);\n+            fclose(ostream);\n+            return ok;\n         }\n-        fclose(istream);\n-        fclose(ostream);\n-        return ok;\n     }\n }\n \n@@ -739,23 +799,29 @@ pub fn remove_file(p: &Path) -> bool {\n \n     #[cfg(windows)]\n     fn unlink(p: &Path) -> bool {\n-        use os::win32::as_utf16_p;\n-        return do as_utf16_p(p.to_str()) |buf| {\n-            libc::DeleteFileW(buf) != (0 as libc::BOOL)\n-        };\n+        unsafe {\n+            use os::win32::as_utf16_p;\n+            return do as_utf16_p(p.to_str()) |buf| {\n+                libc::DeleteFileW(buf) != (0 as libc::BOOL)\n+            };\n+        }\n     }\n \n     #[cfg(unix)]\n     fn unlink(p: &Path) -> bool {\n-        return do as_c_charp(p.to_str()) |buf| {\n-            libc::unlink(buf) == (0 as c_int)\n-        };\n+        unsafe {\n+            return do as_c_charp(p.to_str()) |buf| {\n+                libc::unlink(buf) == (0 as c_int)\n+            };\n+        }\n     }\n }\n \n /// Get a string representing the platform-dependent last error\n pub fn last_os_error() -> ~str {\n-    rustrt::last_os_error()\n+    unsafe {\n+        rustrt::last_os_error()\n+    }\n }\n \n /**\n@@ -767,7 +833,9 @@ pub fn last_os_error() -> ~str {\n  * ignored and the process exits with the default failure status\n  */\n pub fn set_exit_status(code: int) {\n-    rustrt::rust_set_exit_status(code as libc::intptr_t);\n+    unsafe {\n+        rustrt::rust_set_exit_status(code as libc::intptr_t);\n+    }\n }\n \n unsafe fn load_argc_and_argv(argc: c_int, argv: **c_char) -> ~[~str] {"}, {"sha": "cf1188b1f350986dc5374043e538d259578b88fb", "filename": "src/libcore/path.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -243,21 +243,25 @@ mod stat {\n \n impl Path {\n     fn stat(&self) -> Option<libc::stat> {\n-         do str::as_c_str(self.to_str()) |buf| {\n-            let mut st = stat::arch::default_stat();\n-            let r = libc::stat(buf, ptr::mut_addr_of(&st));\n+        unsafe {\n+             do str::as_c_str(self.to_str()) |buf| {\n+                let mut st = stat::arch::default_stat();\n+                let r = libc::stat(buf, ptr::mut_addr_of(&st));\n \n-            if r == 0 { Some(move st) } else { None }\n+                if r == 0 { Some(move st) } else { None }\n+            }\n         }\n     }\n \n     #[cfg(unix)]\n     fn lstat(&self) -> Option<libc::stat> {\n-         do str::as_c_str(self.to_str()) |buf| {\n-            let mut st = stat::arch::default_stat();\n-            let r = libc::lstat(buf, ptr::mut_addr_of(&st));\n+        unsafe {\n+            do str::as_c_str(self.to_str()) |buf| {\n+                let mut st = stat::arch::default_stat();\n+                let r = libc::lstat(buf, ptr::mut_addr_of(&st));\n \n-            if r == 0 { Some(move st) } else { None }\n+                if r == 0 { Some(move st) } else { None }\n+            }\n         }\n     }\n "}, {"sha": "db730fb52b46de279f03180d344d5e1fc75d6eeb", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 58, "deletions": 30, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -173,7 +173,11 @@ impl PacketHeader {\n \n     unsafe fn unblock() {\n         let old_task = swap_task(&mut self.blocked_task, ptr::null());\n-        if !old_task.is_null() { rustrt::rust_task_deref(old_task) }\n+        if !old_task.is_null() {\n+            unsafe {\n+                rustrt::rust_task_deref(old_task)\n+            }\n+        }\n         match swap_state_acq(&mut self.state, Empty) {\n           Empty | Blocked => (),\n           Terminated => self.state = Terminated,\n@@ -300,27 +304,30 @@ type rust_task = libc::c_void;\n #[doc(hidden)]\n extern mod rustrt {\n     #[rust_stack]\n-    fn rust_get_task() -> *rust_task;\n+    unsafe fn rust_get_task() -> *rust_task;\n     #[rust_stack]\n-    fn rust_task_ref(task: *rust_task);\n-    fn rust_task_deref(task: *rust_task);\n+    unsafe fn rust_task_ref(task: *rust_task);\n+    unsafe fn rust_task_deref(task: *rust_task);\n \n     #[rust_stack]\n-    fn task_clear_event_reject(task: *rust_task);\n+    unsafe fn task_clear_event_reject(task: *rust_task);\n \n-    fn task_wait_event(this: *rust_task, killed: &mut *libc::c_void) -> bool;\n-    pure fn task_signal_event(target: *rust_task, event: *libc::c_void);\n+    unsafe fn task_wait_event(this: *rust_task, killed: &mut *libc::c_void)\n+                        -> bool;\n+    unsafe fn task_signal_event(target: *rust_task, event: *libc::c_void);\n }\n \n #[doc(hidden)]\n fn wait_event(this: *rust_task) -> *libc::c_void {\n-    let mut event = ptr::null();\n+    unsafe {\n+        let mut event = ptr::null();\n \n-    let killed = rustrt::task_wait_event(this, &mut event);\n-    if killed && !task::failing() {\n-        fail ~\"killed\"\n+        let killed = rustrt::task_wait_event(this, &mut event);\n+        if killed && !task::failing() {\n+            fail ~\"killed\"\n+        }\n+        event\n     }\n-    event\n }\n \n #[doc(hidden)]\n@@ -397,9 +404,12 @@ pub fn send<T: Owned, Tbuffer: Owned>(p: SendPacketBuffered<T, Tbuffer>,\n             debug!(\"waking up task for %?\", p_);\n             let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n             if !old_task.is_null() {\n-                rustrt::task_signal_event(\n-                    old_task, ptr::addr_of(&(p.header)) as *libc::c_void);\n-                rustrt::rust_task_deref(old_task);\n+                unsafe {\n+                    rustrt::task_signal_event(\n+                        old_task,\n+                        ptr::addr_of(&(p.header)) as *libc::c_void);\n+                    rustrt::rust_task_deref(old_task);\n+                }\n             }\n \n             // The receiver will eventually clean this up.\n@@ -445,7 +455,9 @@ pub fn try_recv<T: Owned, Tbuffer: Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n                 let old_task = swap_task(&mut self.p.blocked_task,\n                                          ptr::null());\n                 if !old_task.is_null() {\n-                    rustrt::rust_task_deref(old_task);\n+                    unsafe {\n+                        rustrt::rust_task_deref(old_task);\n+                    }\n                 }\n             }\n         }\n@@ -466,9 +478,11 @@ pub fn try_recv<T: Owned, Tbuffer: Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n     }\n \n     // regular path\n-    let this = rustrt::rust_get_task();\n-    rustrt::task_clear_event_reject(this);\n-    rustrt::rust_task_ref(this);\n+    let this = unsafe { rustrt::rust_get_task() };\n+    unsafe {\n+        rustrt::task_clear_event_reject(this);\n+        rustrt::rust_task_ref(this);\n+    };\n     debug!(\"blocked = %x this = %x\", p.header.blocked_task as uint,\n            this as uint);\n     let old_task = swap_task(&mut p.header.blocked_task, this);\n@@ -479,7 +493,10 @@ pub fn try_recv<T: Owned, Tbuffer: Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n     let mut first = true;\n     let mut count = SPIN_COUNT;\n     loop {\n-        rustrt::task_clear_event_reject(this);\n+        unsafe {\n+            rustrt::task_clear_event_reject(this);\n+        }\n+\n         let old_state = swap_state_acq(&mut p.header.state,\n                                        Blocked);\n         match old_state {\n@@ -507,7 +524,9 @@ pub fn try_recv<T: Owned, Tbuffer: Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n             payload <-> p.payload;\n             let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n             if !old_task.is_null() {\n-                rustrt::rust_task_deref(old_task);\n+                unsafe {\n+                    rustrt::rust_task_deref(old_task);\n+                }\n             }\n             p.header.state = Empty;\n             return Some(option::unwrap(move payload))\n@@ -519,7 +538,9 @@ pub fn try_recv<T: Owned, Tbuffer: Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n \n             let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n             if !old_task.is_null() {\n-                rustrt::rust_task_deref(old_task);\n+                unsafe {\n+                    rustrt::rust_task_deref(old_task);\n+                }\n             }\n             return None;\n           }\n@@ -554,10 +575,12 @@ fn sender_terminate<T: Owned>(p: *Packet<T>) {\n         // wake up the target\n         let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n         if !old_task.is_null() {\n-            rustrt::task_signal_event(\n-                old_task,\n-                ptr::addr_of(&(p.header)) as *libc::c_void);\n-            rustrt::rust_task_deref(old_task);\n+            unsafe {\n+                rustrt::task_signal_event(\n+                    old_task,\n+                    ptr::addr_of(&(p.header)) as *libc::c_void);\n+                rustrt::rust_task_deref(old_task);\n+            }\n         }\n         // The receiver will eventually clean up.\n       }\n@@ -583,8 +606,10 @@ fn receiver_terminate<T: Owned>(p: *Packet<T>) {\n       Blocked => {\n         let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n         if !old_task.is_null() {\n-            rustrt::rust_task_deref(old_task);\n-            assert old_task == rustrt::rust_get_task();\n+            unsafe {\n+                rustrt::rust_task_deref(old_task);\n+                assert old_task == rustrt::rust_get_task();\n+            }\n         }\n       }\n       Terminated | Full => {\n@@ -605,9 +630,12 @@ closed by the sender or has a message waiting to be received.\n \n */\n fn wait_many<T: Selectable>(pkts: &[T]) -> uint {\n-    let this = rustrt::rust_get_task();\n+    let this = unsafe { rustrt::rust_get_task() };\n+\n+    unsafe {\n+        rustrt::task_clear_event_reject(this);\n+    }\n \n-    rustrt::task_clear_event_reject(this);\n     let mut data_avail = false;\n     let mut ready_packet = pkts.len();\n     for pkts.eachi |i, p| unsafe {"}, {"sha": "b9b6f10a185b772a59f560051dc35416ba44ef51", "filename": "src/libcore/private.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -30,18 +30,17 @@ use uint;\n \n extern mod rustrt {\n     #[legacy_exports];\n-    fn rust_task_weaken(ch: rust_port_id);\n-    fn rust_task_unweaken(ch: rust_port_id);\n+    unsafe fn rust_task_weaken(ch: rust_port_id);\n+    unsafe fn rust_task_unweaken(ch: rust_port_id);\n \n-    fn rust_create_little_lock() -> rust_little_lock;\n-    fn rust_destroy_little_lock(lock: rust_little_lock);\n-    fn rust_lock_little_lock(lock: rust_little_lock);\n-    fn rust_unlock_little_lock(lock: rust_little_lock);\n+    unsafe fn rust_create_little_lock() -> rust_little_lock;\n+    unsafe fn rust_destroy_little_lock(lock: rust_little_lock);\n+    unsafe fn rust_lock_little_lock(lock: rust_little_lock);\n+    unsafe fn rust_unlock_little_lock(lock: rust_little_lock);\n }\n \n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n-\n     fn atomic_cxchg(dst: &mut int, old: int, src: int) -> int;\n     fn atomic_xadd(dst: &mut int, src: int) -> int;\n     fn atomic_xsub(dst: &mut int, src: int) -> int;\n@@ -490,12 +489,18 @@ type rust_little_lock = *libc::c_void;\n \n struct LittleLock {\n     l: rust_little_lock,\n-    drop { rustrt::rust_destroy_little_lock(self.l); }\n+    drop {\n+        unsafe {\n+            rustrt::rust_destroy_little_lock(self.l);\n+        }\n+    }\n }\n \n fn LittleLock() -> LittleLock {\n-    LittleLock {\n-        l: rustrt::rust_create_little_lock()\n+    unsafe {\n+        LittleLock {\n+            l: rustrt::rust_create_little_lock()\n+        }\n     }\n }\n \n@@ -504,7 +509,11 @@ impl LittleLock {\n     unsafe fn lock<T>(f: fn() -> T) -> T {\n         struct Unlock {\n             l: rust_little_lock,\n-            drop { rustrt::rust_unlock_little_lock(self.l); }\n+            drop {\n+                unsafe {\n+                    rustrt::rust_unlock_little_lock(self.l);\n+                }\n+            }\n         }\n \n         fn Unlock(l: rust_little_lock) -> Unlock {"}, {"sha": "d8c3c74ba2e49642176801f34f45feffb09937fb", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -26,16 +26,22 @@ use vec;\n #[abi = \"cdecl\"]\n extern mod libc_ {\n     #[rust_stack]\n-    fn memcpy(dest: *mut c_void, src: *const c_void,\n-              n: libc::size_t) -> *c_void;\n+    unsafe fn memcpy(dest: *mut c_void,\n+                     src: *const c_void,\n+                     n: libc::size_t)\n+                  -> *c_void;\n \n     #[rust_stack]\n-    fn memmove(dest: *mut c_void, src: *const c_void,\n-               n: libc::size_t) -> *c_void;\n+    unsafe fn memmove(dest: *mut c_void,\n+                      src: *const c_void,\n+                      n: libc::size_t)\n+                   -> *c_void;\n \n     #[rust_stack]\n-    fn memset(dest: *mut c_void, c: libc::c_int,\n-              len: libc::size_t) -> *c_void;\n+    unsafe fn memset(dest: *mut c_void,\n+                     c: libc::c_int,\n+                     len: libc::size_t)\n+                  -> *c_void;\n }\n \n #[abi = \"rust-intrinsic\"]"}, {"sha": "e2101e06bfab9ebdff7f674a7d4066364151d0dd", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -28,11 +28,11 @@ enum rctx {}\n \n #[abi = \"cdecl\"]\n extern mod rustrt {\n-    fn rand_seed() -> ~[u8];\n-    fn rand_new() -> *rctx;\n-    fn rand_new_seeded2(&&seed: ~[u8]) -> *rctx;\n-    fn rand_next(c: *rctx) -> u32;\n-    fn rand_free(c: *rctx);\n+    unsafe fn rand_seed() -> ~[u8];\n+    unsafe fn rand_new() -> *rctx;\n+    unsafe fn rand_new_seeded2(&&seed: ~[u8]) -> *rctx;\n+    unsafe fn rand_next(c: *rctx) -> u32;\n+    unsafe fn rand_free(c: *rctx);\n }\n \n /// A random number generator\n@@ -265,7 +265,11 @@ impl Rng {\n \n struct RandRes {\n     c: *rctx,\n-    drop { rustrt::rand_free(self.c); }\n+    drop {\n+        unsafe {\n+            rustrt::rand_free(self.c);\n+        }\n+    }\n }\n \n fn RandRes(c: *rctx) -> RandRes {\n@@ -275,17 +279,25 @@ fn RandRes(c: *rctx) -> RandRes {\n }\n \n impl @RandRes: Rng {\n-    fn next() -> u32 { return rustrt::rand_next((*self).c); }\n+    fn next() -> u32 {\n+        unsafe {\n+            return rustrt::rand_next((*self).c);\n+        }\n+    }\n }\n \n /// Create a new random seed for seeded_rng\n pub fn seed() -> ~[u8] {\n-    rustrt::rand_seed()\n+    unsafe {\n+        rustrt::rand_seed()\n+    }\n }\n \n /// Create a random number generator with a system specified seed\n pub fn Rng() -> Rng {\n-    @RandRes(rustrt::rand_new()) as Rng\n+    unsafe {\n+        @RandRes(rustrt::rand_new()) as Rng\n+    }\n }\n \n /**\n@@ -295,7 +307,9 @@ pub fn Rng() -> Rng {\n  * length.\n  */\n pub fn seeded_rng(seed: &~[u8]) -> Rng {\n-    @RandRes(rustrt::rand_new_seeded2(*seed)) as Rng\n+    unsafe {\n+        @RandRes(rustrt::rand_new_seeded2(*seed)) as Rng\n+    }\n }\n \n type XorShiftState = {\n@@ -343,11 +357,11 @@ pub fn task_rng() -> Rng {\n     }\n     match r {\n         None => {\n-            let rng = @RandRes(rustrt::rand_new());\n             unsafe {\n+                let rng = @RandRes(rustrt::rand_new());\n                 task::local_data::local_data_set(tls_rng_state, rng);\n+                rng as Rng\n             }\n-            rng as Rng\n         }\n         Some(rng) => rng as Rng\n     }"}, {"sha": "e0eb2fcfd83e9d9512058ef58741150bf270919d", "filename": "src/libcore/rt.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -26,16 +26,17 @@ pub type rust_task = c_void;\n \n extern mod rustrt {\n     #[rust_stack]\n-    fn rust_upcall_exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char;\n+    unsafe fn rust_upcall_exchange_malloc(td: *c_char, size: uintptr_t)\n+                                       -> *c_char;\n \n     #[rust_stack]\n-    fn rust_upcall_exchange_free(ptr: *c_char);\n+    unsafe fn rust_upcall_exchange_free(ptr: *c_char);\n \n     #[rust_stack]\n-    fn rust_upcall_malloc(td: *c_char, size: uintptr_t) -> *c_char;\n+    unsafe fn rust_upcall_malloc(td: *c_char, size: uintptr_t) -> *c_char;\n \n     #[rust_stack]\n-    fn rust_upcall_free(ptr: *c_char);\n+    unsafe fn rust_upcall_free(ptr: *c_char);\n }\n \n #[rt(fail_)]\n@@ -46,8 +47,8 @@ pub fn rt_fail_(expr: *c_char, file: *c_char, line: size_t) -> ! {\n \n #[rt(fail_bounds_check)]\n #[lang=\"fail_bounds_check\"]\n-pub fn rt_fail_bounds_check(file: *c_char, line: size_t,\n-                        index: size_t, len: size_t) {\n+pub unsafe fn rt_fail_bounds_check(file: *c_char, line: size_t,\n+                                   index: size_t, len: size_t) {\n     let msg = fmt!(\"index out of bounds: the len is %d but the index is %d\",\n                     len as int, index as int);\n     do str::as_buf(msg) |p, _len| {\n@@ -57,7 +58,7 @@ pub fn rt_fail_bounds_check(file: *c_char, line: size_t,\n \n #[rt(exchange_malloc)]\n #[lang=\"exchange_malloc\"]\n-pub fn rt_exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n+pub unsafe fn rt_exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n     return rustrt::rust_upcall_exchange_malloc(td, size);\n }\n \n@@ -66,13 +67,13 @@ pub fn rt_exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n // problem occurs, call exit instead.\n #[rt(exchange_free)]\n #[lang=\"exchange_free\"]\n-pub fn rt_exchange_free(ptr: *c_char) {\n+pub unsafe fn rt_exchange_free(ptr: *c_char) {\n     rustrt::rust_upcall_exchange_free(ptr);\n }\n \n #[rt(malloc)]\n #[lang=\"malloc\"]\n-pub fn rt_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n+pub unsafe fn rt_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n     return rustrt::rust_upcall_malloc(td, size);\n }\n \n@@ -81,7 +82,7 @@ pub fn rt_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n // problem occurs, call exit instead.\n #[rt(free)]\n #[lang=\"free\"]\n-pub fn rt_free(ptr: *c_char) {\n+pub unsafe fn rt_free(ptr: *c_char) {\n     rustrt::rust_upcall_free(ptr);\n }\n "}, {"sha": "435feb160235192f24cad1a39f6ab36685b3aa74", "filename": "src/libcore/run.rs", "status": "modified", "additions": 146, "deletions": 127, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -29,10 +29,10 @@ use vec;\n \n #[abi = \"cdecl\"]\n extern mod rustrt {\n-    fn rust_run_program(argv: **libc::c_char, envp: *c_void,\n-                        dir: *libc::c_char,\n-                        in_fd: c_int, out_fd: c_int, err_fd: c_int)\n-        -> pid_t;\n+    unsafe fn rust_run_program(argv: **libc::c_char, envp: *c_void,\n+                               dir: *libc::c_char,\n+                               in_fd: c_int, out_fd: c_int, err_fd: c_int)\n+                            -> pid_t;\n }\n \n /// A value representing a child process\n@@ -84,12 +84,14 @@ pub fn spawn_process(prog: &str, args: &[~str],\n                  env: &Option<~[(~str,~str)]>,\n                  dir: &Option<~str>,\n                  in_fd: c_int, out_fd: c_int, err_fd: c_int)\n-   -> pid_t {\n-    do with_argv(prog, args) |argv| {\n-        do with_envp(env) |envp| {\n-            do with_dirp(dir) |dirp| {\n-                rustrt::rust_run_program(argv, envp, dirp,\n-                                         in_fd, out_fd, err_fd)\n+              -> pid_t {\n+    unsafe {\n+        do with_argv(prog, args) |argv| {\n+            do with_envp(env) |envp| {\n+                do with_dirp(dir) |dirp| {\n+                    rustrt::rust_run_program(argv, envp, dirp,\n+                                             in_fd, out_fd, err_fd)\n+                }\n             }\n         }\n     }\n@@ -202,69 +204,83 @@ pub fn run_program(prog: &str, args: &[~str]) -> int {\n  * A class with a <program> field\n  */\n pub fn start_program(prog: &str, args: &[~str]) -> Program {\n-    let pipe_input = os::pipe();\n-    let pipe_output = os::pipe();\n-    let pipe_err = os::pipe();\n-    let pid =\n-        spawn_process(prog, args, &None, &None,\n-                      pipe_input.in, pipe_output.out,\n-                      pipe_err.out);\n+    unsafe {\n+        let pipe_input = os::pipe();\n+        let pipe_output = os::pipe();\n+        let pipe_err = os::pipe();\n+        let pid =\n+            spawn_process(prog, args, &None, &None,\n+                          pipe_input.in, pipe_output.out,\n+                          pipe_err.out);\n+\n+        unsafe {\n+            if pid == -1 as pid_t { fail; }\n+            libc::close(pipe_input.in);\n+            libc::close(pipe_output.out);\n+            libc::close(pipe_err.out);\n+        }\n \n-    if pid == -1 as pid_t { fail; }\n-    libc::close(pipe_input.in);\n-    libc::close(pipe_output.out);\n-    libc::close(pipe_err.out);\n-\n-    type ProgRepr = {pid: pid_t,\n-                     mut in_fd: c_int,\n-                     out_file: *libc::FILE,\n-                     err_file: *libc::FILE,\n-                     mut finished: bool};\n-\n-    fn close_repr_input(r: &ProgRepr) {\n-        let invalid_fd = -1i32;\n-        if r.in_fd != invalid_fd {\n-            libc::close(r.in_fd);\n-            r.in_fd = invalid_fd;\n+        type ProgRepr = {pid: pid_t,\n+                         mut in_fd: c_int,\n+                         out_file: *libc::FILE,\n+                         err_file: *libc::FILE,\n+                         mut finished: bool};\n+\n+        fn close_repr_input(r: &ProgRepr) {\n+            let invalid_fd = -1i32;\n+            if r.in_fd != invalid_fd {\n+                unsafe {\n+                    libc::close(r.in_fd);\n+                }\n+                r.in_fd = invalid_fd;\n+            }\n+        }\n+        fn finish_repr(r: &ProgRepr) -> int {\n+            if r.finished { return 0; }\n+            r.finished = true;\n+            close_repr_input(r);\n+            return waitpid(r.pid);\n+        }\n+        fn destroy_repr(r: &ProgRepr) {\n+            unsafe {\n+                finish_repr(r);\n+                libc::fclose(r.out_file);\n+                libc::fclose(r.err_file);\n+            }\n+        }\n+        struct ProgRes {\n+            r: ProgRepr,\n+            drop { destroy_repr(&self.r); }\n         }\n-    }\n-    fn finish_repr(r: &ProgRepr) -> int {\n-        if r.finished { return 0; }\n-        r.finished = true;\n-        close_repr_input(r);\n-        return waitpid(r.pid);\n-    }\n-    fn destroy_repr(r: &ProgRepr) {\n-        finish_repr(r);\n-       libc::fclose(r.out_file);\n-       libc::fclose(r.err_file);\n-    }\n-    struct ProgRes {\n-        r: ProgRepr,\n-        drop { destroy_repr(&self.r); }\n-    }\n \n-    fn ProgRes(r: ProgRepr) -> ProgRes {\n-        ProgRes {\n-            r: move r\n+        fn ProgRes(r: ProgRepr) -> ProgRes {\n+            ProgRes {\n+                r: move r\n+            }\n         }\n-    }\n \n-    impl ProgRes: Program {\n-        fn get_id() -> pid_t { return self.r.pid; }\n-        fn input() -> io::Writer { io::fd_writer(self.r.in_fd, false) }\n-        fn output() -> io::Reader { io::FILE_reader(self.r.out_file, false) }\n-        fn err() -> io::Reader { io::FILE_reader(self.r.err_file, false) }\n-        fn close_input() { close_repr_input(&self.r); }\n-        fn finish() -> int { finish_repr(&self.r) }\n-        fn destroy() { destroy_repr(&self.r); }\n+        impl ProgRes: Program {\n+            fn get_id() -> pid_t { return self.r.pid; }\n+            fn input() -> io::Writer {\n+                io::fd_writer(self.r.in_fd, false)\n+            }\n+            fn output() -> io::Reader {\n+                io::FILE_reader(self.r.out_file, false)\n+            }\n+            fn err() -> io::Reader {\n+                io::FILE_reader(self.r.err_file, false)\n+            }\n+            fn close_input() { close_repr_input(&self.r); }\n+            fn finish() -> int { finish_repr(&self.r) }\n+            fn destroy() { destroy_repr(&self.r); }\n+        }\n+        let repr = {pid: pid,\n+                    mut in_fd: pipe_input.out,\n+                    out_file: os::fdopen(pipe_output.in),\n+                    err_file: os::fdopen(pipe_err.in),\n+                    mut finished: false};\n+        return ProgRes(move repr) as Program;\n     }\n-    let repr = {pid: pid,\n-                mut in_fd: pipe_input.out,\n-                out_file: os::fdopen(pipe_output.in),\n-                err_file: os::fdopen(pipe_err.in),\n-                mut finished: false};\n-    return ProgRes(move repr) as Program;\n }\n \n fn read_all(rd: io::Reader) -> ~str {\n@@ -294,60 +310,61 @@ fn read_all(rd: io::Reader) -> ~str {\n  */\n pub fn program_output(prog: &str, args: &[~str]) ->\n    {status: int, out: ~str, err: ~str} {\n+    unsafe {\n+        let pipe_in = os::pipe();\n+        let pipe_out = os::pipe();\n+        let pipe_err = os::pipe();\n+        let pid = spawn_process(prog, args, &None, &None,\n+                                pipe_in.in, pipe_out.out, pipe_err.out);\n \n-    let pipe_in = os::pipe();\n-    let pipe_out = os::pipe();\n-    let pipe_err = os::pipe();\n-    let pid = spawn_process(prog, args, &None, &None,\n-                            pipe_in.in, pipe_out.out, pipe_err.out);\n+        os::close(pipe_in.in);\n+        os::close(pipe_out.out);\n+        os::close(pipe_err.out);\n+        if pid == -1i32 {\n+            os::close(pipe_in.out);\n+            os::close(pipe_out.in);\n+            os::close(pipe_err.in);\n+            fail;\n+        }\n \n-    os::close(pipe_in.in);\n-    os::close(pipe_out.out);\n-    os::close(pipe_err.out);\n-    if pid == -1i32 {\n         os::close(pipe_in.out);\n-        os::close(pipe_out.in);\n-        os::close(pipe_err.in);\n-        fail;\n-    }\n \n-    os::close(pipe_in.out);\n-\n-    // Spawn two entire schedulers to read both stdout and sterr\n-    // in parallel so we don't deadlock while blocking on one\n-    // or the other. FIXME (#2625): Surely there's a much more\n-    // clever way to do this.\n-    let p = oldcomm::Port();\n-    let ch = oldcomm::Chan(&p);\n-    do task::spawn_sched(task::SingleThreaded) {\n-        let errput = readclose(pipe_err.in);\n-        oldcomm::send(ch, (2, move errput));\n-    };\n-    do task::spawn_sched(task::SingleThreaded) {\n-        let output = readclose(pipe_out.in);\n-        oldcomm::send(ch, (1, move output));\n-    };\n-    let status = run::waitpid(pid);\n-    let mut errs = ~\"\";\n-    let mut outs = ~\"\";\n-    let mut count = 2;\n-    while count > 0 {\n-        let stream = oldcomm::recv(p);\n-        match stream {\n-            (1, copy s) => {\n-                outs = move s;\n-            }\n-            (2, copy s) => {\n-                errs = move s;\n-            }\n-            (n, _) => {\n-                fail(fmt!(\"program_output received an unexpected file \\\n-                           number: %u\", n));\n-            }\n+        // Spawn two entire schedulers to read both stdout and sterr\n+        // in parallel so we don't deadlock while blocking on one\n+        // or the other. FIXME (#2625): Surely there's a much more\n+        // clever way to do this.\n+        let p = oldcomm::Port();\n+        let ch = oldcomm::Chan(&p);\n+        do task::spawn_sched(task::SingleThreaded) {\n+            let errput = readclose(pipe_err.in);\n+            oldcomm::send(ch, (2, move errput));\n         };\n-        count -= 1;\n-    };\n-    return {status: status, out: move outs, err: move errs};\n+        do task::spawn_sched(task::SingleThreaded) {\n+            let output = readclose(pipe_out.in);\n+            oldcomm::send(ch, (1, move output));\n+        };\n+        let status = run::waitpid(pid);\n+        let mut errs = ~\"\";\n+        let mut outs = ~\"\";\n+        let mut count = 2;\n+        while count > 0 {\n+            let stream = oldcomm::recv(p);\n+            match stream {\n+                (1, copy s) => {\n+                    outs = move s;\n+                }\n+                (2, copy s) => {\n+                    errs = move s;\n+                }\n+                (n, _) => {\n+                    fail(fmt!(\"program_output received an unexpected file \\\n+                               number: %u\", n));\n+                }\n+            };\n+            count -= 1;\n+        };\n+        return {status: status, out: move outs, err: move errs};\n+    }\n }\n \n pub fn writeclose(fd: c_int, s: ~str) {\n@@ -361,17 +378,19 @@ pub fn writeclose(fd: c_int, s: ~str) {\n }\n \n pub fn readclose(fd: c_int) -> ~str {\n-    let file = os::fdopen(fd);\n-    let reader = io::FILE_reader(file, false);\n-    let buf = io::with_bytes_writer(|writer| {\n-        let mut bytes = [mut 0, ..4096];\n-        while !reader.eof() {\n-            let nread = reader.read(bytes, bytes.len());\n-            writer.write(bytes.view(0, nread));\n-        }\n-    });\n-    os::fclose(file);\n-    str::from_bytes(buf)\n+    unsafe {\n+        let file = os::fdopen(fd);\n+        let reader = io::FILE_reader(file, false);\n+        let buf = io::with_bytes_writer(|writer| {\n+            let mut bytes = [mut 0, ..4096];\n+            while !reader.eof() {\n+                let nread = reader.read(bytes, bytes.len());\n+                writer.write(bytes.view(0, nread));\n+            }\n+        });\n+        os::fclose(file);\n+        str::from_bytes(buf)\n+    }\n }\n \n /// Waits for a process to exit and returns the exit code"}, {"sha": "0395cc76542da8b68b6fcaf0225621f0f9c620bc", "filename": "src/libcore/stackwalk.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstackwalk.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -85,16 +85,20 @@ fn test_simple_deep() {\n }\n \n fn breakpoint() {\n-    rustrt::rust_dbg_breakpoint()\n+    unsafe {\n+        rustrt::rust_dbg_breakpoint()\n+    }\n }\n \n fn frame_address(f: fn(++x: *u8)) {\n-    rusti::frame_address(f)\n+    unsafe {\n+        rusti::frame_address(f)\n+    }\n }\n \n extern mod rustrt {\n     #[legacy_exports];\n-    fn rust_dbg_breakpoint();\n+    unsafe fn rust_dbg_breakpoint();\n }\n \n #[abi = \"rust-intrinsic\"]"}, {"sha": "ad9c3d1e51d135a7d916a31301325f298cb14467", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -53,7 +53,7 @@ extern mod rusti {\n \n extern mod rustrt {\n     #[rust_stack]\n-    fn rust_upcall_fail(expr: *c_char, file: *c_char, line: size_t);\n+    unsafe fn rust_upcall_fail(expr: *c_char, file: *c_char, line: size_t);\n }\n \n /// Compares contents of two pointers using the default method."}, {"sha": "04ecf1553620fb6fc2878f0e4c8949ef7c44fe79", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -947,12 +947,12 @@ fn test_spawn_sched_childs_on_same_sched() {\n #[nolink]\n #[cfg(test)]\n extern mod testrt {\n-    fn rust_dbg_lock_create() -> *libc::c_void;\n-    fn rust_dbg_lock_destroy(lock: *libc::c_void);\n-    fn rust_dbg_lock_lock(lock: *libc::c_void);\n-    fn rust_dbg_lock_unlock(lock: *libc::c_void);\n-    fn rust_dbg_lock_wait(lock: *libc::c_void);\n-    fn rust_dbg_lock_signal(lock: *libc::c_void);\n+    unsafe fn rust_dbg_lock_create() -> *libc::c_void;\n+    unsafe fn rust_dbg_lock_destroy(lock: *libc::c_void);\n+    unsafe fn rust_dbg_lock_lock(lock: *libc::c_void);\n+    unsafe fn rust_dbg_lock_unlock(lock: *libc::c_void);\n+    unsafe fn rust_dbg_lock_wait(lock: *libc::c_void);\n+    unsafe fn rust_dbg_lock_signal(lock: *libc::c_void);\n }\n \n #[test]"}, {"sha": "b9cefa89aa7425b6a146651fe47bebabd043c091", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -30,9 +30,9 @@ use vec;\n \n #[abi = \"cdecl\"]\n pub extern mod rustrt {\n-    fn vec_reserve_shared(++t: *sys::TypeDesc,\n-                          ++v: **raw::VecRepr,\n-                          ++n: libc::size_t);\n+    unsafe fn vec_reserve_shared(++t: *sys::TypeDesc,\n+                                 ++v: **raw::VecRepr,\n+                                 ++n: libc::size_t);\n }\n \n #[abi = \"rust-intrinsic\"]"}, {"sha": "0512994f99404dd0a6b4a7e6d9fcedcc2ef79bb3", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 179, "deletions": 164, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -76,10 +76,18 @@ pub fn WriteOutputFile(sess: Session,\n         Output: *c_char, FileType: c_uint,\n         OptLevel: c_int,\n         EnableSegmentedStacks: bool) {\n-    let result = llvm::LLVMRustWriteOutputFile(\n-            PM, M, Triple, Output, FileType, OptLevel, EnableSegmentedStacks);\n-    if (!result) {\n-        llvm_err(sess, ~\"Could not write output\");\n+    unsafe {\n+        let result = llvm::LLVMRustWriteOutputFile(\n+                PM,\n+                M,\n+                Triple,\n+                Output,\n+                FileType,\n+                OptLevel,\n+                EnableSegmentedStacks);\n+        if (!result) {\n+            llvm_err(sess, ~\"Could not write output\");\n+        }\n     }\n }\n \n@@ -190,146 +198,170 @@ mod write {\n     }\n \n     fn run_passes(sess: Session, llmod: ModuleRef, output: &Path) {\n-        let opts = sess.opts;\n-        if sess.time_llvm_passes() { llvm::LLVMRustEnableTimePasses(); }\n-        let mut pm = mk_pass_manager();\n-        let td = mk_target_data(\n-            /*bad*/copy sess.targ_cfg.target_strs.data_layout);\n-        llvm::LLVMAddTargetData(td.lltd, pm.llpm);\n-        // FIXME (#2812): run the linter here also, once there are llvm-c\n-        // bindings for it.\n-\n-        // Generate a pre-optimization intermediate file if -save-temps was\n-        // specified.\n-\n-\n-        if opts.save_temps {\n-            match opts.output_type {\n-              output_type_bitcode => {\n-                if opts.optimize != session::No {\n-                    let filename = output.with_filetype(\"no-opt.bc\");\n+        unsafe {\n+            let opts = sess.opts;\n+            if sess.time_llvm_passes() { llvm::LLVMRustEnableTimePasses(); }\n+            let mut pm = mk_pass_manager();\n+            let td = mk_target_data(\n+                /*bad*/copy sess.targ_cfg.target_strs.data_layout);\n+            llvm::LLVMAddTargetData(td.lltd, pm.llpm);\n+            // FIXME (#2812): run the linter here also, once there are llvm-c\n+            // bindings for it.\n+\n+            // Generate a pre-optimization intermediate file if -save-temps\n+            // was specified.\n+\n+\n+            if opts.save_temps {\n+                match opts.output_type {\n+                  output_type_bitcode => {\n+                    if opts.optimize != session::No {\n+                        let filename = output.with_filetype(\"no-opt.bc\");\n+                        str::as_c_str(filename.to_str(), |buf| {\n+                            llvm::LLVMWriteBitcodeToFile(llmod, buf)\n+                        });\n+                    }\n+                  }\n+                  _ => {\n+                    let filename = output.with_filetype(\"bc\");\n                     str::as_c_str(filename.to_str(), |buf| {\n                         llvm::LLVMWriteBitcodeToFile(llmod, buf)\n                     });\n+                  }\n                 }\n-              }\n-              _ => {\n-                let filename = output.with_filetype(\"bc\");\n-                str::as_c_str(filename.to_str(), |buf| {\n-                    llvm::LLVMWriteBitcodeToFile(llmod, buf)\n-                });\n-              }\n-            }\n-        }\n-        if !sess.no_verify() { llvm::LLVMAddVerifierPass(pm.llpm); }\n-        // FIXME (#2396): This is mostly a copy of the bits of opt's -O2 that\n-        // are available in the C api.\n-        // Also: We might want to add optimization levels like -O1, -O2,\n-        // -Os, etc\n-        // Also: Should we expose and use the pass lists used by the opt\n-        // tool?\n-\n-        if opts.optimize != session::No {\n-            let fpm = mk_pass_manager();\n-            llvm::LLVMAddTargetData(td.lltd, fpm.llpm);\n-\n-            let FPMB = llvm::LLVMPassManagerBuilderCreate();\n-            llvm::LLVMPassManagerBuilderSetOptLevel(FPMB, 2u as c_uint);\n-            llvm::LLVMPassManagerBuilderPopulateFunctionPassManager(FPMB,\n-                                                                    fpm.llpm);\n-            llvm::LLVMPassManagerBuilderDispose(FPMB);\n-\n-            llvm::LLVMRunPassManager(fpm.llpm, llmod);\n-            let mut threshold = 225;\n-            if opts.optimize == session::Aggressive { threshold = 275; }\n-\n-            let MPMB = llvm::LLVMPassManagerBuilderCreate();\n-            llvm::LLVMPassManagerBuilderSetOptLevel(MPMB,\n-                                                    opts.optimize as c_uint);\n-            llvm::LLVMPassManagerBuilderSetSizeLevel(MPMB, False);\n-            llvm::LLVMPassManagerBuilderSetDisableUnitAtATime(MPMB, False);\n-            llvm::LLVMPassManagerBuilderSetDisableUnrollLoops(MPMB, False);\n-            llvm::LLVMPassManagerBuilderSetDisableSimplifyLibCalls(MPMB,\n-                                                                   False);\n-\n-            if threshold != 0u {\n-                llvm::LLVMPassManagerBuilderUseInlinerWithThreshold\n-                    (MPMB, threshold as c_uint);\n             }\n-            llvm::LLVMPassManagerBuilderPopulateModulePassManager(MPMB,\n-                                                                  pm.llpm);\n+            if !sess.no_verify() { llvm::LLVMAddVerifierPass(pm.llpm); }\n+            // FIXME (#2396): This is mostly a copy of the bits of opt's -O2\n+            // that are available in the C api.\n+            // Also: We might want to add optimization levels like -O1, -O2,\n+            // -Os, etc\n+            // Also: Should we expose and use the pass lists used by the opt\n+            // tool?\n+\n+            if opts.optimize != session::No {\n+                let fpm = mk_pass_manager();\n+                llvm::LLVMAddTargetData(td.lltd, fpm.llpm);\n+\n+                let FPMB = llvm::LLVMPassManagerBuilderCreate();\n+                llvm::LLVMPassManagerBuilderSetOptLevel(FPMB, 2u as c_uint);\n+                llvm::LLVMPassManagerBuilderPopulateFunctionPassManager(\n+                    FPMB, fpm.llpm);\n+                llvm::LLVMPassManagerBuilderDispose(FPMB);\n+\n+                llvm::LLVMRunPassManager(fpm.llpm, llmod);\n+                let mut threshold = 225;\n+                if opts.optimize == session::Aggressive { threshold = 275; }\n+\n+                let MPMB = llvm::LLVMPassManagerBuilderCreate();\n+                llvm::LLVMPassManagerBuilderSetOptLevel(MPMB,\n+                                                        opts.optimize as\n+                                                            c_uint);\n+                llvm::LLVMPassManagerBuilderSetSizeLevel(MPMB, False);\n+                llvm::LLVMPassManagerBuilderSetDisableUnitAtATime(MPMB,\n+                                                                  False);\n+                llvm::LLVMPassManagerBuilderSetDisableUnrollLoops(MPMB,\n+                                                                  False);\n+                llvm::LLVMPassManagerBuilderSetDisableSimplifyLibCalls(MPMB,\n+                                                                       False);\n+\n+                if threshold != 0u {\n+                    llvm::LLVMPassManagerBuilderUseInlinerWithThreshold\n+                        (MPMB, threshold as c_uint);\n+                }\n+                llvm::LLVMPassManagerBuilderPopulateModulePassManager(\n+                    MPMB, pm.llpm);\n \n-            llvm::LLVMPassManagerBuilderDispose(MPMB);\n-        }\n-        if !sess.no_verify() { llvm::LLVMAddVerifierPass(pm.llpm); }\n-        if is_object_or_assembly_or_exe(opts.output_type) || opts.jit {\n-            let LLVMOptNone       = 0 as c_int; // -O0\n-            let LLVMOptLess       = 1 as c_int; // -O1\n-            let LLVMOptDefault    = 2 as c_int; // -O2, -Os\n-            let LLVMOptAggressive = 3 as c_int; // -O3\n-\n-            let mut CodeGenOptLevel = match opts.optimize {\n-              session::No => LLVMOptNone,\n-              session::Less => LLVMOptLess,\n-              session::Default => LLVMOptDefault,\n-              session::Aggressive => LLVMOptAggressive\n-            };\n+                llvm::LLVMPassManagerBuilderDispose(MPMB);\n+            }\n+            if !sess.no_verify() { llvm::LLVMAddVerifierPass(pm.llpm); }\n+            if is_object_or_assembly_or_exe(opts.output_type) || opts.jit {\n+                let LLVMOptNone       = 0 as c_int; // -O0\n+                let LLVMOptLess       = 1 as c_int; // -O1\n+                let LLVMOptDefault    = 2 as c_int; // -O2, -Os\n+                let LLVMOptAggressive = 3 as c_int; // -O3\n+\n+                let mut CodeGenOptLevel = match opts.optimize {\n+                  session::No => LLVMOptNone,\n+                  session::Less => LLVMOptLess,\n+                  session::Default => LLVMOptDefault,\n+                  session::Aggressive => LLVMOptAggressive\n+                };\n \n-            if opts.jit {\n-                // If we are using JIT, go ahead and create and\n-                // execute the engine now.\n-                // JIT execution takes ownership of the module,\n-                // so don't dispose and return.\n+                if opts.jit {\n+                    // If we are using JIT, go ahead and create and\n+                    // execute the engine now.\n+                    // JIT execution takes ownership of the module,\n+                    // so don't dispose and return.\n \n-                jit::exec(sess, pm.llpm, llmod, CodeGenOptLevel, true);\n+                    jit::exec(sess, pm.llpm, llmod, CodeGenOptLevel, true);\n \n-                if sess.time_llvm_passes() {\n-                    llvm::LLVMRustPrintPassTimings();\n+                    if sess.time_llvm_passes() {\n+                        llvm::LLVMRustPrintPassTimings();\n+                    }\n+                    return;\n                 }\n-                return;\n-            }\n \n-            let mut FileType;\n-            if opts.output_type == output_type_object ||\n-                   opts.output_type == output_type_exe {\n-               FileType = lib::llvm::ObjectFile;\n-            } else { FileType = lib::llvm::AssemblyFile; }\n-            // Write optimized bitcode if --save-temps was on.\n+                let mut FileType;\n+                if opts.output_type == output_type_object ||\n+                       opts.output_type == output_type_exe {\n+                   FileType = lib::llvm::ObjectFile;\n+                } else { FileType = lib::llvm::AssemblyFile; }\n+                // Write optimized bitcode if --save-temps was on.\n \n-            if opts.save_temps {\n-                // Always output the bitcode file with --save-temps\n+                if opts.save_temps {\n+                    // Always output the bitcode file with --save-temps\n \n-                let filename = output.with_filetype(\"opt.bc\");\n-                llvm::LLVMRunPassManager(pm.llpm, llmod);\n-                str::as_c_str(filename.to_str(), |buf| {\n-                    llvm::LLVMWriteBitcodeToFile(llmod, buf)\n-                });\n-                pm = mk_pass_manager();\n-                // Save the assembly file if -S is used\n+                    let filename = output.with_filetype(\"opt.bc\");\n+                    llvm::LLVMRunPassManager(pm.llpm, llmod);\n+                    str::as_c_str(filename.to_str(), |buf| {\n+                        llvm::LLVMWriteBitcodeToFile(llmod, buf)\n+                    });\n+                    pm = mk_pass_manager();\n+                    // Save the assembly file if -S is used\n+\n+                    if opts.output_type == output_type_assembly {\n+                        let _: () = str::as_c_str(\n+                            sess.targ_cfg.target_strs.target_triple,\n+                            |buf_t| {\n+                                str::as_c_str(output.to_str(), |buf_o| {\n+                                    WriteOutputFile(\n+                                        sess,\n+                                        pm.llpm,\n+                                        llmod,\n+                                        buf_t,\n+                                        buf_o,\n+                                        lib::llvm::AssemblyFile as c_uint,\n+                                        CodeGenOptLevel,\n+                                        true)\n+                                })\n+                            });\n+                    }\n \n-                if opts.output_type == output_type_assembly {\n-                    let _: () = str::as_c_str(\n-                        sess.targ_cfg.target_strs.target_triple,\n-                        |buf_t| {\n-                            str::as_c_str(output.to_str(), |buf_o| {\n-                                WriteOutputFile(\n-                                    sess,\n-                                    pm.llpm,\n-                                    llmod,\n-                                    buf_t,\n-                                    buf_o,\n-                                    lib::llvm::AssemblyFile as c_uint,\n-                                    CodeGenOptLevel,\n-                                    true)\n-                            })\n-                        });\n-                }\n \n+                    // Save the object file for -c or --save-temps alone\n+                    // This .o is needed when an exe is built\n+                    if opts.output_type == output_type_object ||\n+                           opts.output_type == output_type_exe {\n+                        let _: () = str::as_c_str(\n+                            sess.targ_cfg.target_strs.target_triple,\n+                            |buf_t| {\n+                                str::as_c_str(output.to_str(), |buf_o| {\n+                                    WriteOutputFile(\n+                                        sess,\n+                                        pm.llpm,\n+                                        llmod,\n+                                        buf_t,\n+                                        buf_o,\n+                                        lib::llvm::ObjectFile as c_uint,\n+                                        CodeGenOptLevel,\n+                                        true)\n+                                })\n+                            });\n+                    }\n+                } else {\n+                    // If we aren't saving temps then just output the file\n+                    // type corresponding to the '-c' or '-S' flag used\n \n-                // Save the object file for -c or --save-temps alone\n-                // This .o is needed when an exe is built\n-                if opts.output_type == output_type_object ||\n-                       opts.output_type == output_type_exe {\n                     let _: () = str::as_c_str(\n                         sess.targ_cfg.target_strs.target_triple,\n                         |buf_t| {\n@@ -340,53 +372,36 @@ mod write {\n                                     llmod,\n                                     buf_t,\n                                     buf_o,\n-                                    lib::llvm::ObjectFile as c_uint,\n+                                    FileType as c_uint,\n                                     CodeGenOptLevel,\n                                     true)\n                             })\n                         });\n                 }\n+                // Clean up and return\n+\n+                llvm::LLVMDisposeModule(llmod);\n+                if sess.time_llvm_passes() {\n+                    llvm::LLVMRustPrintPassTimings();\n+                }\n+                return;\n+            }\n+\n+            if opts.output_type == output_type_llvm_assembly {\n+                // Given options \"-S --emit-llvm\": output LLVM assembly\n+                str::as_c_str(output.to_str(), |buf_o| {\n+                    llvm::LLVMRustAddPrintModulePass(pm.llpm, llmod, buf_o)});\n             } else {\n-                // If we aren't saving temps then just output the file\n-                // type corresponding to the '-c' or '-S' flag used\n-\n-                let _: () = str::as_c_str(\n-                    sess.targ_cfg.target_strs.target_triple,\n-                    |buf_t| {\n-                        str::as_c_str(output.to_str(), |buf_o| {\n-                            WriteOutputFile(\n-                                sess,\n-                                pm.llpm,\n-                                llmod,\n-                                buf_t,\n-                                buf_o,\n-                                FileType as c_uint,\n-                                CodeGenOptLevel,\n-                                true)\n-                        })\n-                    });\n+                // If only a bitcode file is asked for by using the\n+                // '--emit-llvm' flag, then output it here\n+                llvm::LLVMRunPassManager(pm.llpm, llmod);\n+                str::as_c_str(output.to_str(),\n+                            |buf| llvm::LLVMWriteBitcodeToFile(llmod, buf) );\n             }\n-            // Clean up and return\n \n             llvm::LLVMDisposeModule(llmod);\n             if sess.time_llvm_passes() { llvm::LLVMRustPrintPassTimings(); }\n-            return;\n         }\n-\n-        if opts.output_type == output_type_llvm_assembly {\n-            // Given options \"-S --emit-llvm\": output LLVM assembly\n-            str::as_c_str(output.to_str(), |buf_o| {\n-                llvm::LLVMRustAddPrintModulePass(pm.llpm, llmod, buf_o)});\n-        } else {\n-            // If only a bitcode file is asked for by using the '--emit-llvm'\n-            // flag, then output it here\n-            llvm::LLVMRunPassManager(pm.llpm, llmod);\n-            str::as_c_str(output.to_str(),\n-                        |buf| llvm::LLVMWriteBitcodeToFile(llmod, buf) );\n-        }\n-\n-        llvm::LLVMDisposeModule(llmod);\n-        if sess.time_llvm_passes() { llvm::LLVMRustPrintPassTimings(); }\n     }\n }\n "}, {"sha": "1e1e1d2b32582e09572ac8610717c5fa2435f053", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -542,7 +542,9 @@ fn build_session_options(+binary: ~str,\n         debugging_opts |= this_bit;\n     }\n     if debugging_opts & session::debug_llvm != 0 {\n-        llvm::LLVMSetDebug(1);\n+        unsafe {\n+            llvm::LLVMSetDebug(1);\n+        }\n     }\n \n     let jit = opt_present(matches, ~\"jit\");"}, {"sha": "dd23dbe83dc9fc79d950ec86c981261e4d0e5d09", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 817, "deletions": 602, "changes": 1419, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -257,754 +257,930 @@ type SectionIteratorRef = *SectionIterator_opaque;\n extern mod llvm {\n     #[legacy_exports];\n     /* Create and destroy contexts. */\n-    fn LLVMContextCreate() -> ContextRef;\n-    fn LLVMGetGlobalContext() -> ContextRef;\n-    fn LLVMContextDispose(C: ContextRef);\n-    fn LLVMGetMDKindIDInContext(C: ContextRef, Name: *c_char, SLen: c_uint) ->\n-       c_uint;\n-    fn LLVMGetMDKindID(Name: *c_char, SLen: c_uint) -> c_uint;\n+    unsafe fn LLVMContextCreate() -> ContextRef;\n+    unsafe fn LLVMGetGlobalContext() -> ContextRef;\n+    unsafe fn LLVMContextDispose(C: ContextRef);\n+    unsafe fn LLVMGetMDKindIDInContext(C: ContextRef,\n+                                       Name: *c_char,\n+                                       SLen: c_uint)\n+                                    -> c_uint;\n+    unsafe fn LLVMGetMDKindID(Name: *c_char, SLen: c_uint) -> c_uint;\n \n     /* Create and destroy modules. */\n-    fn LLVMModuleCreateWithNameInContext(ModuleID: *c_char, C: ContextRef) ->\n-       ModuleRef;\n-    fn LLVMDisposeModule(M: ModuleRef);\n+    unsafe fn LLVMModuleCreateWithNameInContext(ModuleID: *c_char,\n+                                                C: ContextRef)\n+                                             -> ModuleRef;\n+    unsafe fn LLVMDisposeModule(M: ModuleRef);\n \n     /** Data layout. See Module::getDataLayout. */\n-    fn LLVMGetDataLayout(M: ModuleRef) -> *c_char;\n-    fn LLVMSetDataLayout(M: ModuleRef, Triple: *c_char);\n+    unsafe fn LLVMGetDataLayout(M: ModuleRef) -> *c_char;\n+    unsafe fn LLVMSetDataLayout(M: ModuleRef, Triple: *c_char);\n \n     /** Target triple. See Module::getTargetTriple. */\n-    fn LLVMGetTarget(M: ModuleRef) -> *c_char;\n-    fn LLVMSetTarget(M: ModuleRef, Triple: *c_char);\n+    unsafe fn LLVMGetTarget(M: ModuleRef) -> *c_char;\n+    unsafe fn LLVMSetTarget(M: ModuleRef, Triple: *c_char);\n \n     /** See Module::dump. */\n-    fn LLVMDumpModule(M: ModuleRef);\n+    unsafe fn LLVMDumpModule(M: ModuleRef);\n \n     /** See Module::setModuleInlineAsm. */\n-    fn LLVMSetModuleInlineAsm(M: ModuleRef, Asm: *c_char);\n+    unsafe fn LLVMSetModuleInlineAsm(M: ModuleRef, Asm: *c_char);\n \n     /** See llvm::LLVMTypeKind::getTypeID. */\n-    fn LLVMGetTypeKind(Ty: TypeRef) -> TypeKind;\n+    unsafe fn LLVMGetTypeKind(Ty: TypeRef) -> TypeKind;\n \n     /** See llvm::LLVMType::getContext. */\n-    fn LLVMGetTypeContext(Ty: TypeRef) -> ContextRef;\n+    unsafe fn LLVMGetTypeContext(Ty: TypeRef) -> ContextRef;\n \n     /* Operations on integer types */\n-    fn LLVMInt1TypeInContext(C: ContextRef) -> TypeRef;\n-    fn LLVMInt8TypeInContext(C: ContextRef) -> TypeRef;\n-    fn LLVMInt16TypeInContext(C: ContextRef) -> TypeRef;\n-    fn LLVMInt32TypeInContext(C: ContextRef) -> TypeRef;\n-    fn LLVMInt64TypeInContext(C: ContextRef) -> TypeRef;\n-    fn LLVMIntTypeInContext(C: ContextRef, NumBits: c_uint) -> TypeRef;\n-\n-    fn LLVMInt1Type() -> TypeRef;\n-    fn LLVMInt8Type() -> TypeRef;\n-    fn LLVMInt16Type() -> TypeRef;\n-    fn LLVMInt32Type() -> TypeRef;\n-    fn LLVMInt64Type() -> TypeRef;\n-    fn LLVMIntType(NumBits: c_uint) -> TypeRef;\n-    fn LLVMGetIntTypeWidth(IntegerTy: TypeRef) -> c_uint;\n+    unsafe fn LLVMInt1TypeInContext(C: ContextRef) -> TypeRef;\n+    unsafe fn LLVMInt8TypeInContext(C: ContextRef) -> TypeRef;\n+    unsafe fn LLVMInt16TypeInContext(C: ContextRef) -> TypeRef;\n+    unsafe fn LLVMInt32TypeInContext(C: ContextRef) -> TypeRef;\n+    unsafe fn LLVMInt64TypeInContext(C: ContextRef) -> TypeRef;\n+    unsafe fn LLVMIntTypeInContext(C: ContextRef, NumBits: c_uint) -> TypeRef;\n+\n+    unsafe fn LLVMInt1Type() -> TypeRef;\n+    unsafe fn LLVMInt8Type() -> TypeRef;\n+    unsafe fn LLVMInt16Type() -> TypeRef;\n+    unsafe fn LLVMInt32Type() -> TypeRef;\n+    unsafe fn LLVMInt64Type() -> TypeRef;\n+    unsafe fn LLVMIntType(NumBits: c_uint) -> TypeRef;\n+    unsafe fn LLVMGetIntTypeWidth(IntegerTy: TypeRef) -> c_uint;\n \n     /* Operations on real types */\n-    fn LLVMFloatTypeInContext(C: ContextRef) -> TypeRef;\n-    fn LLVMDoubleTypeInContext(C: ContextRef) -> TypeRef;\n-    fn LLVMX86FP80TypeInContext(C: ContextRef) -> TypeRef;\n-    fn LLVMFP128TypeInContext(C: ContextRef) -> TypeRef;\n-    fn LLVMPPCFP128TypeInContext(C: ContextRef) -> TypeRef;\n-\n-    fn LLVMFloatType() -> TypeRef;\n-    fn LLVMDoubleType() -> TypeRef;\n-    fn LLVMX86FP80Type() -> TypeRef;\n-    fn LLVMFP128Type() -> TypeRef;\n-    fn LLVMPPCFP128Type() -> TypeRef;\n+    unsafe fn LLVMFloatTypeInContext(C: ContextRef) -> TypeRef;\n+    unsafe fn LLVMDoubleTypeInContext(C: ContextRef) -> TypeRef;\n+    unsafe fn LLVMX86FP80TypeInContext(C: ContextRef) -> TypeRef;\n+    unsafe fn LLVMFP128TypeInContext(C: ContextRef) -> TypeRef;\n+    unsafe fn LLVMPPCFP128TypeInContext(C: ContextRef) -> TypeRef;\n+\n+    unsafe fn LLVMFloatType() -> TypeRef;\n+    unsafe fn LLVMDoubleType() -> TypeRef;\n+    unsafe fn LLVMX86FP80Type() -> TypeRef;\n+    unsafe fn LLVMFP128Type() -> TypeRef;\n+    unsafe fn LLVMPPCFP128Type() -> TypeRef;\n \n     /* Operations on function types */\n-    fn LLVMFunctionType(ReturnType: TypeRef, ParamTypes: *TypeRef,\n+    unsafe fn LLVMFunctionType(ReturnType: TypeRef, ParamTypes: *TypeRef,\n                         ParamCount: c_uint, IsVarArg: Bool) -> TypeRef;\n-    fn LLVMIsFunctionVarArg(FunctionTy: TypeRef) -> Bool;\n-    fn LLVMGetReturnType(FunctionTy: TypeRef) -> TypeRef;\n-    fn LLVMCountParamTypes(FunctionTy: TypeRef) -> c_uint;\n-    fn LLVMGetParamTypes(FunctionTy: TypeRef, Dest: *TypeRef);\n+    unsafe fn LLVMIsFunctionVarArg(FunctionTy: TypeRef) -> Bool;\n+    unsafe fn LLVMGetReturnType(FunctionTy: TypeRef) -> TypeRef;\n+    unsafe fn LLVMCountParamTypes(FunctionTy: TypeRef) -> c_uint;\n+    unsafe fn LLVMGetParamTypes(FunctionTy: TypeRef, Dest: *TypeRef);\n \n     /* Operations on struct types */\n-    fn LLVMStructTypeInContext(C: ContextRef, ElementTypes: *TypeRef,\n+    unsafe fn LLVMStructTypeInContext(C: ContextRef, ElementTypes: *TypeRef,\n                                ElementCount: c_uint,\n                                Packed: Bool) -> TypeRef;\n-    fn LLVMStructType(ElementTypes: *TypeRef, ElementCount: c_uint,\n+    unsafe fn LLVMStructType(ElementTypes: *TypeRef, ElementCount: c_uint,\n                       Packed: Bool) -> TypeRef;\n-    fn LLVMCountStructElementTypes(StructTy: TypeRef) -> c_uint;\n-    fn LLVMGetStructElementTypes(StructTy: TypeRef, Dest: *mut TypeRef);\n-    fn LLVMIsPackedStruct(StructTy: TypeRef) -> Bool;\n+    unsafe fn LLVMCountStructElementTypes(StructTy: TypeRef) -> c_uint;\n+    unsafe fn LLVMGetStructElementTypes(StructTy: TypeRef,\n+                                        Dest: *mut TypeRef);\n+    unsafe fn LLVMIsPackedStruct(StructTy: TypeRef) -> Bool;\n \n     /* Operations on array, pointer, and vector types (sequence types) */\n-    fn LLVMArrayType(ElementType: TypeRef,\n+    unsafe fn LLVMArrayType(ElementType: TypeRef,\n                      ElementCount: c_uint) -> TypeRef;\n-    fn LLVMPointerType(ElementType: TypeRef,\n+    unsafe fn LLVMPointerType(ElementType: TypeRef,\n                        AddressSpace: c_uint) -> TypeRef;\n-    fn LLVMVectorType(ElementType: TypeRef,\n+    unsafe fn LLVMVectorType(ElementType: TypeRef,\n                       ElementCount: c_uint) -> TypeRef;\n \n-    fn LLVMGetElementType(Ty: TypeRef) -> TypeRef;\n-    fn LLVMGetArrayLength(ArrayTy: TypeRef) -> c_uint;\n-    fn LLVMGetPointerAddressSpace(PointerTy: TypeRef) -> c_uint;\n-    fn LLVMGetVectorSize(VectorTy: TypeRef) -> c_uint;\n+    unsafe fn LLVMGetElementType(Ty: TypeRef) -> TypeRef;\n+    unsafe fn LLVMGetArrayLength(ArrayTy: TypeRef) -> c_uint;\n+    unsafe fn LLVMGetPointerAddressSpace(PointerTy: TypeRef) -> c_uint;\n+    unsafe fn LLVMGetVectorSize(VectorTy: TypeRef) -> c_uint;\n \n     /* Operations on other types */\n-    fn LLVMVoidTypeInContext(C: ContextRef) -> TypeRef;\n-    fn LLVMLabelTypeInContext(C: ContextRef) -> TypeRef;\n-    fn LLVMMetadataTypeInContext(C: ContextRef) -> TypeRef;\n+    unsafe fn LLVMVoidTypeInContext(C: ContextRef) -> TypeRef;\n+    unsafe fn LLVMLabelTypeInContext(C: ContextRef) -> TypeRef;\n+    unsafe fn LLVMMetadataTypeInContext(C: ContextRef) -> TypeRef;\n \n-    fn LLVMVoidType() -> TypeRef;\n-    fn LLVMLabelType() -> TypeRef;\n-    fn LLVMMetadataType() -> TypeRef;\n+    unsafe fn LLVMVoidType() -> TypeRef;\n+    unsafe fn LLVMLabelType() -> TypeRef;\n+    unsafe fn LLVMMetadataType() -> TypeRef;\n \n     /* Operations on all values */\n-    fn LLVMTypeOf(Val: ValueRef) -> TypeRef;\n-    fn LLVMGetValueName(Val: ValueRef) -> *c_char;\n-    fn LLVMSetValueName(Val: ValueRef, Name: *c_char);\n-    fn LLVMDumpValue(Val: ValueRef);\n-    fn LLVMReplaceAllUsesWith(OldVal: ValueRef, NewVal: ValueRef);\n-    fn LLVMHasMetadata(Val: ValueRef) -> c_int;\n-    fn LLVMGetMetadata(Val: ValueRef, KindID: c_uint) -> ValueRef;\n-    fn LLVMSetMetadata(Val: ValueRef, KindID: c_uint, Node: ValueRef);\n+    unsafe fn LLVMTypeOf(Val: ValueRef) -> TypeRef;\n+    unsafe fn LLVMGetValueName(Val: ValueRef) -> *c_char;\n+    unsafe fn LLVMSetValueName(Val: ValueRef, Name: *c_char);\n+    unsafe fn LLVMDumpValue(Val: ValueRef);\n+    unsafe fn LLVMReplaceAllUsesWith(OldVal: ValueRef, NewVal: ValueRef);\n+    unsafe fn LLVMHasMetadata(Val: ValueRef) -> c_int;\n+    unsafe fn LLVMGetMetadata(Val: ValueRef, KindID: c_uint) -> ValueRef;\n+    unsafe fn LLVMSetMetadata(Val: ValueRef, KindID: c_uint, Node: ValueRef);\n \n     /* Operations on Uses */\n-    fn LLVMGetFirstUse(Val: ValueRef) -> UseRef;\n-    fn LLVMGetNextUse(U: UseRef) -> UseRef;\n-    fn LLVMGetUser(U: UseRef) -> ValueRef;\n-    fn LLVMGetUsedValue(U: UseRef) -> ValueRef;\n+    unsafe fn LLVMGetFirstUse(Val: ValueRef) -> UseRef;\n+    unsafe fn LLVMGetNextUse(U: UseRef) -> UseRef;\n+    unsafe fn LLVMGetUser(U: UseRef) -> ValueRef;\n+    unsafe fn LLVMGetUsedValue(U: UseRef) -> ValueRef;\n \n     /* Operations on Users */\n-    fn LLVMGetOperand(Val: ValueRef, Index: c_uint) -> ValueRef;\n-    fn LLVMSetOperand(Val: ValueRef, Index: c_uint, Op: ValueRef);\n+    unsafe fn LLVMGetOperand(Val: ValueRef, Index: c_uint) -> ValueRef;\n+    unsafe fn LLVMSetOperand(Val: ValueRef, Index: c_uint, Op: ValueRef);\n \n     /* Operations on constants of any type */\n-    fn LLVMConstNull(Ty: TypeRef) -> ValueRef;\n+    unsafe fn LLVMConstNull(Ty: TypeRef) -> ValueRef;\n     /* all zeroes */\n-    fn LLVMConstAllOnes(Ty: TypeRef) -> ValueRef;\n+    unsafe fn LLVMConstAllOnes(Ty: TypeRef) -> ValueRef;\n     /* only for int/vector */\n-    fn LLVMGetUndef(Ty: TypeRef) -> ValueRef;\n-    fn LLVMIsConstant(Val: ValueRef) -> Bool;\n-    fn LLVMIsNull(Val: ValueRef) -> Bool;\n-    fn LLVMIsUndef(Val: ValueRef) -> Bool;\n-    fn LLVMConstPointerNull(Ty: TypeRef) -> ValueRef;\n+    unsafe fn LLVMGetUndef(Ty: TypeRef) -> ValueRef;\n+    unsafe fn LLVMIsConstant(Val: ValueRef) -> Bool;\n+    unsafe fn LLVMIsNull(Val: ValueRef) -> Bool;\n+    unsafe fn LLVMIsUndef(Val: ValueRef) -> Bool;\n+    unsafe fn LLVMConstPointerNull(Ty: TypeRef) -> ValueRef;\n \n     /* Operations on metadata */\n-    fn LLVMMDStringInContext(C: ContextRef, Str: *c_char, SLen: c_uint) ->\n-       ValueRef;\n-    fn LLVMMDString(Str: *c_char, SLen: c_uint) -> ValueRef;\n-    fn LLVMMDNodeInContext(C: ContextRef, Vals: *ValueRef, Count: c_uint) ->\n-       ValueRef;\n-    fn LLVMMDNode(Vals: *ValueRef, Count: c_uint) -> ValueRef;\n-    fn LLVMAddNamedMetadataOperand(M: ModuleRef, Str: *c_char,\n+    unsafe fn LLVMMDStringInContext(C: ContextRef,\n+                                    Str: *c_char,\n+                                    SLen: c_uint)\n+                                 -> ValueRef;\n+    unsafe fn LLVMMDString(Str: *c_char, SLen: c_uint) -> ValueRef;\n+    unsafe fn LLVMMDNodeInContext(C: ContextRef,\n+                                  Vals: *ValueRef,\n+                                  Count: c_uint)\n+                               -> ValueRef;\n+    unsafe fn LLVMMDNode(Vals: *ValueRef, Count: c_uint) -> ValueRef;\n+    unsafe fn LLVMAddNamedMetadataOperand(M: ModuleRef, Str: *c_char,\n                                    Val: ValueRef);\n \n     /* Operations on scalar constants */\n-    fn LLVMConstInt(IntTy: TypeRef, N: c_ulonglong, SignExtend: Bool) ->\n-       ValueRef;\n-    fn LLVMConstIntOfString(IntTy: TypeRef, Text: *c_char, Radix: u8) ->\n-       ValueRef;\n-    fn LLVMConstIntOfStringAndSize(IntTy: TypeRef, Text: *c_char,\n+    unsafe fn LLVMConstInt(IntTy: TypeRef,\n+                           N: c_ulonglong,\n+                           SignExtend: Bool)\n+                        -> ValueRef;\n+    unsafe fn LLVMConstIntOfString(IntTy: TypeRef,\n+                                   Text: *c_char,\n+                                   Radix: u8)\n+                                -> ValueRef;\n+    unsafe fn LLVMConstIntOfStringAndSize(IntTy: TypeRef, Text: *c_char,\n                                    SLen: c_uint,\n                                    Radix: u8) -> ValueRef;\n-    fn LLVMConstReal(RealTy: TypeRef, N: f64) -> ValueRef;\n-    fn LLVMConstRealOfString(RealTy: TypeRef, Text: *c_char) -> ValueRef;\n-    fn LLVMConstRealOfStringAndSize(RealTy: TypeRef, Text: *c_char,\n+    unsafe fn LLVMConstReal(RealTy: TypeRef, N: f64) -> ValueRef;\n+    unsafe fn LLVMConstRealOfString(RealTy: TypeRef,\n+                                    Text: *c_char)\n+                                 -> ValueRef;\n+    unsafe fn LLVMConstRealOfStringAndSize(RealTy: TypeRef, Text: *c_char,\n                                     SLen: c_uint) -> ValueRef;\n-    fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef) -> c_ulonglong;\n-    fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> c_longlong;\n+    unsafe fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef) -> c_ulonglong;\n+    unsafe fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> c_longlong;\n \n \n     /* Operations on composite constants */\n-    fn LLVMConstStringInContext(C: ContextRef, Str: *c_char, Length: c_uint,\n-                                DontNullTerminate: Bool) -> ValueRef;\n-    fn LLVMConstStructInContext(C: ContextRef, ConstantVals: *ValueRef,\n+    unsafe fn LLVMConstStringInContext(C: ContextRef,\n+                                       Str: *c_char,\n+                                       Length: c_uint,\n+                                       DontNullTerminate: Bool)\n+                                    -> ValueRef;\n+    unsafe fn LLVMConstStructInContext(C: ContextRef, ConstantVals: *ValueRef,\n                                 Count: c_uint, Packed: Bool) -> ValueRef;\n \n-    fn LLVMConstString(Str: *c_char, Length: c_uint,\n+    unsafe fn LLVMConstString(Str: *c_char, Length: c_uint,\n                        DontNullTerminate: Bool) -> ValueRef;\n-    fn LLVMConstArray(ElementTy: TypeRef, ConstantVals: *ValueRef,\n+    unsafe fn LLVMConstArray(ElementTy: TypeRef, ConstantVals: *ValueRef,\n                       Length: c_uint) -> ValueRef;\n-    fn LLVMConstStruct(ConstantVals: *ValueRef,\n+    unsafe fn LLVMConstStruct(ConstantVals: *ValueRef,\n                        Count: c_uint, Packed: Bool) -> ValueRef;\n-    fn LLVMConstVector(ScalarConstantVals: *ValueRef,\n+    unsafe fn LLVMConstVector(ScalarConstantVals: *ValueRef,\n                        Size: c_uint) -> ValueRef;\n \n     /* Constant expressions */\n-    fn LLVMAlignOf(Ty: TypeRef) -> ValueRef;\n-    fn LLVMSizeOf(Ty: TypeRef) -> ValueRef;\n-    fn LLVMConstNeg(ConstantVal: ValueRef) -> ValueRef;\n-    fn LLVMConstNSWNeg(ConstantVal: ValueRef) -> ValueRef;\n-    fn LLVMConstNUWNeg(ConstantVal: ValueRef) -> ValueRef;\n-    fn LLVMConstFNeg(ConstantVal: ValueRef) -> ValueRef;\n-    fn LLVMConstNot(ConstantVal: ValueRef) -> ValueRef;\n-    fn LLVMConstAdd(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    fn LLVMConstNSWAdd(LHSConstant: ValueRef, RHSConstant: ValueRef) ->\n-       ValueRef;\n-    fn LLVMConstNUWAdd(LHSConstant: ValueRef, RHSConstant: ValueRef) ->\n-       ValueRef;\n-    fn LLVMConstFAdd(LHSConstant: ValueRef, RHSConstant: ValueRef) ->\n-       ValueRef;\n-    fn LLVMConstSub(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    fn LLVMConstNSWSub(LHSConstant: ValueRef, RHSConstant: ValueRef) ->\n-       ValueRef;\n-    fn LLVMConstNUWSub(LHSConstant: ValueRef, RHSConstant: ValueRef) ->\n-       ValueRef;\n-    fn LLVMConstFSub(LHSConstant: ValueRef, RHSConstant: ValueRef) ->\n-       ValueRef;\n-    fn LLVMConstMul(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    fn LLVMConstNSWMul(LHSConstant: ValueRef, RHSConstant: ValueRef) ->\n+    unsafe fn LLVMAlignOf(Ty: TypeRef) -> ValueRef;\n+    unsafe fn LLVMSizeOf(Ty: TypeRef) -> ValueRef;\n+    unsafe fn LLVMConstNeg(ConstantVal: ValueRef) -> ValueRef;\n+    unsafe fn LLVMConstNSWNeg(ConstantVal: ValueRef) -> ValueRef;\n+    unsafe fn LLVMConstNUWNeg(ConstantVal: ValueRef) -> ValueRef;\n+    unsafe fn LLVMConstFNeg(ConstantVal: ValueRef) -> ValueRef;\n+    unsafe fn LLVMConstNot(ConstantVal: ValueRef) -> ValueRef;\n+    unsafe fn LLVMConstAdd(LHSConstant: ValueRef,\n+                           RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    unsafe fn LLVMConstNSWAdd(LHSConstant: ValueRef,\n+                              RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    unsafe fn LLVMConstNUWAdd(LHSConstant: ValueRef,\n+                              RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    unsafe fn LLVMConstFAdd(LHSConstant: ValueRef,\n+                            RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    unsafe fn LLVMConstSub(LHSConstant: ValueRef,\n+                           RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    unsafe fn LLVMConstNSWSub(LHSConstant: ValueRef,\n+                              RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    unsafe fn LLVMConstNUWSub(LHSConstant: ValueRef,\n+                              RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    unsafe fn LLVMConstFSub(LHSConstant: ValueRef, RHSConstant: ValueRef) ->\n        ValueRef;\n-    fn LLVMConstNUWMul(LHSConstant: ValueRef, RHSConstant: ValueRef) ->\n+    unsafe fn LLVMConstMul(LHSConstant: ValueRef,\n+                           RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    unsafe fn LLVMConstNSWMul(LHSConstant: ValueRef,\n+                              RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    unsafe fn LLVMConstNUWMul(LHSConstant: ValueRef,\n+                              RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    unsafe fn LLVMConstFMul(LHSConstant: ValueRef,\n+                            RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    unsafe fn LLVMConstUDiv(LHSConstant: ValueRef,\n+                            RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    unsafe fn LLVMConstSDiv(LHSConstant: ValueRef,\n+                            RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    unsafe fn LLVMConstExactSDiv(LHSConstant: ValueRef,\n+                                 RHSConstant: ValueRef)\n+                              -> ValueRef;\n+    unsafe fn LLVMConstFDiv(LHSConstant: ValueRef,\n+                            RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    unsafe fn LLVMConstURem(LHSConstant: ValueRef,\n+                            RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    unsafe fn LLVMConstSRem(LHSConstant: ValueRef,\n+                            RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    unsafe fn LLVMConstFRem(LHSConstant: ValueRef,\n+                            RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    unsafe fn LLVMConstAnd(LHSConstant: ValueRef,\n+                           RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    unsafe fn LLVMConstOr(LHSConstant: ValueRef,\n+                          RHSConstant: ValueRef)\n+                       -> ValueRef;\n+    unsafe fn LLVMConstXor(LHSConstant: ValueRef,\n+                           RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    unsafe fn LLVMConstShl(LHSConstant: ValueRef,\n+                           RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    unsafe fn LLVMConstLShr(LHSConstant: ValueRef, RHSConstant: ValueRef) ->\n        ValueRef;\n-    fn LLVMConstFMul(LHSConstant: ValueRef, RHSConstant: ValueRef) ->\n+    unsafe fn LLVMConstAShr(LHSConstant: ValueRef, RHSConstant: ValueRef) ->\n        ValueRef;\n-    fn LLVMConstUDiv(LHSConstant: ValueRef, RHSConstant: ValueRef) ->\n-       ValueRef;\n-    fn LLVMConstSDiv(LHSConstant: ValueRef, RHSConstant: ValueRef) ->\n-       ValueRef;\n-    fn LLVMConstExactSDiv(LHSConstant: ValueRef, RHSConstant: ValueRef) ->\n-       ValueRef;\n-    fn LLVMConstFDiv(LHSConstant: ValueRef, RHSConstant: ValueRef) ->\n-       ValueRef;\n-    fn LLVMConstURem(LHSConstant: ValueRef, RHSConstant: ValueRef) ->\n-       ValueRef;\n-    fn LLVMConstSRem(LHSConstant: ValueRef, RHSConstant: ValueRef) ->\n-       ValueRef;\n-    fn LLVMConstFRem(LHSConstant: ValueRef, RHSConstant: ValueRef) ->\n-       ValueRef;\n-    fn LLVMConstAnd(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    fn LLVMConstOr(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    fn LLVMConstXor(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    fn LLVMConstShl(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    fn LLVMConstLShr(LHSConstant: ValueRef, RHSConstant: ValueRef) ->\n-       ValueRef;\n-    fn LLVMConstAShr(LHSConstant: ValueRef, RHSConstant: ValueRef) ->\n-       ValueRef;\n-    fn LLVMConstGEP(ConstantVal: ValueRef,\n+    unsafe fn LLVMConstGEP(ConstantVal: ValueRef,\n                     ConstantIndices: *ValueRef,\n                     NumIndices: c_uint) -> ValueRef;\n-    fn LLVMConstInBoundsGEP(ConstantVal: ValueRef,\n-                            ConstantIndices: *ValueRef,\n-                            NumIndices: c_uint) -> ValueRef;\n-    fn LLVMConstTrunc(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    fn LLVMConstSExt(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    fn LLVMConstZExt(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    fn LLVMConstFPTrunc(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    fn LLVMConstFPExt(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    fn LLVMConstUIToFP(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    fn LLVMConstSIToFP(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    fn LLVMConstFPToUI(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    fn LLVMConstFPToSI(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    fn LLVMConstPtrToInt(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    fn LLVMConstIntToPtr(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    fn LLVMConstBitCast(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    fn LLVMConstZExtOrBitCast(ConstantVal: ValueRef, ToType: TypeRef) ->\n-       ValueRef;\n-    fn LLVMConstSExtOrBitCast(ConstantVal: ValueRef, ToType: TypeRef) ->\n-       ValueRef;\n-    fn LLVMConstTruncOrBitCast(ConstantVal: ValueRef, ToType: TypeRef) ->\n-       ValueRef;\n-    fn LLVMConstPointerCast(ConstantVal: ValueRef, ToType: TypeRef) ->\n-       ValueRef;\n-    fn LLVMConstIntCast(ConstantVal: ValueRef, ToType: TypeRef,\n+    unsafe fn LLVMConstInBoundsGEP(ConstantVal: ValueRef,\n+                                   ConstantIndices: *ValueRef,\n+                                   NumIndices: c_uint)\n+                                -> ValueRef;\n+    unsafe fn LLVMConstTrunc(ConstantVal: ValueRef,\n+                             ToType: TypeRef)\n+                          -> ValueRef;\n+    unsafe fn LLVMConstSExt(ConstantVal: ValueRef,\n+                            ToType: TypeRef)\n+                         -> ValueRef;\n+    unsafe fn LLVMConstZExt(ConstantVal: ValueRef,\n+                            ToType: TypeRef)\n+                         -> ValueRef;\n+    unsafe fn LLVMConstFPTrunc(ConstantVal: ValueRef,\n+                               ToType: TypeRef)\n+                            -> ValueRef;\n+    unsafe fn LLVMConstFPExt(ConstantVal: ValueRef,\n+                             ToType: TypeRef)\n+                          -> ValueRef;\n+    unsafe fn LLVMConstUIToFP(ConstantVal: ValueRef,\n+                              ToType: TypeRef)\n+                           -> ValueRef;\n+    unsafe fn LLVMConstSIToFP(ConstantVal: ValueRef,\n+                              ToType: TypeRef)\n+                           -> ValueRef;\n+    unsafe fn LLVMConstFPToUI(ConstantVal: ValueRef,\n+                              ToType: TypeRef)\n+                           -> ValueRef;\n+    unsafe fn LLVMConstFPToSI(ConstantVal: ValueRef,\n+                              ToType: TypeRef)\n+                           -> ValueRef;\n+    unsafe fn LLVMConstPtrToInt(ConstantVal: ValueRef,\n+                                ToType: TypeRef)\n+                             -> ValueRef;\n+    unsafe fn LLVMConstIntToPtr(ConstantVal: ValueRef,\n+                                ToType: TypeRef)\n+                             -> ValueRef;\n+    unsafe fn LLVMConstBitCast(ConstantVal: ValueRef,\n+                               ToType: TypeRef)\n+                            -> ValueRef;\n+    unsafe fn LLVMConstZExtOrBitCast(ConstantVal: ValueRef,\n+                                     ToType: TypeRef)\n+                                  -> ValueRef;\n+    unsafe fn LLVMConstSExtOrBitCast(ConstantVal: ValueRef,\n+                                     ToType: TypeRef)\n+                                  -> ValueRef;\n+    unsafe fn LLVMConstTruncOrBitCast(ConstantVal: ValueRef,\n+                                      ToType: TypeRef)\n+                                   -> ValueRef;\n+    unsafe fn LLVMConstPointerCast(ConstantVal: ValueRef,\n+                                   ToType: TypeRef)\n+                                -> ValueRef;\n+    unsafe fn LLVMConstIntCast(ConstantVal: ValueRef, ToType: TypeRef,\n                         isSigned: Bool) -> ValueRef;\n-    fn LLVMConstFPCast(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    fn LLVMConstSelect(ConstantCondition: ValueRef, ConstantIfTrue: ValueRef,\n-                       ConstantIfFalse: ValueRef) -> ValueRef;\n-    fn LLVMConstExtractElement(VectorConstant: ValueRef,\n+    unsafe fn LLVMConstFPCast(ConstantVal: ValueRef,\n+                              ToType: TypeRef)\n+                           -> ValueRef;\n+    unsafe fn LLVMConstSelect(ConstantCondition: ValueRef,\n+                              ConstantIfTrue: ValueRef,\n+                              ConstantIfFalse: ValueRef)\n+                           -> ValueRef;\n+    unsafe fn LLVMConstExtractElement(VectorConstant: ValueRef,\n                                IndexConstant: ValueRef) -> ValueRef;\n-    fn LLVMConstInsertElement(VectorConstant: ValueRef,\n+    unsafe fn LLVMConstInsertElement(VectorConstant: ValueRef,\n                               ElementValueConstant: ValueRef,\n                               IndexConstant: ValueRef) -> ValueRef;\n-    fn LLVMConstShuffleVector(VectorAConstant: ValueRef,\n+    unsafe fn LLVMConstShuffleVector(VectorAConstant: ValueRef,\n                               VectorBConstant: ValueRef,\n                               MaskConstant: ValueRef) -> ValueRef;\n-    fn LLVMConstExtractValue(AggConstant: ValueRef, IdxList: *c_uint,\n+    unsafe fn LLVMConstExtractValue(AggConstant: ValueRef, IdxList: *c_uint,\n                              NumIdx: c_uint) -> ValueRef;\n-    fn LLVMConstInsertValue(AggConstant: ValueRef,\n+    unsafe fn LLVMConstInsertValue(AggConstant: ValueRef,\n                             ElementValueConstant: ValueRef, IdxList: *c_uint,\n                             NumIdx: c_uint) -> ValueRef;\n-    fn LLVMConstInlineAsm(Ty: TypeRef, AsmString: *c_char,\n+    unsafe fn LLVMConstInlineAsm(Ty: TypeRef, AsmString: *c_char,\n                           Constraints: *c_char, HasSideEffects: Bool,\n                           IsAlignStack: Bool) -> ValueRef;\n-    fn LLVMBlockAddress(F: ValueRef, BB: BasicBlockRef) -> ValueRef;\n+    unsafe fn LLVMBlockAddress(F: ValueRef, BB: BasicBlockRef) -> ValueRef;\n \n \n \n     /* Operations on global variables, functions, and aliases (globals) */\n-    fn LLVMGetGlobalParent(Global: ValueRef) -> ModuleRef;\n-    fn LLVMIsDeclaration(Global: ValueRef) -> Bool;\n-    fn LLVMGetLinkage(Global: ValueRef) -> c_uint;\n-    fn LLVMSetLinkage(Global: ValueRef, Link: c_uint);\n-    fn LLVMGetSection(Global: ValueRef) -> *c_char;\n-    fn LLVMSetSection(Global: ValueRef, Section: *c_char);\n-    fn LLVMGetVisibility(Global: ValueRef) -> c_uint;\n-    fn LLVMSetVisibility(Global: ValueRef, Viz: c_uint);\n-    fn LLVMGetAlignment(Global: ValueRef) -> c_uint;\n-    fn LLVMSetAlignment(Global: ValueRef, Bytes: c_uint);\n+    unsafe fn LLVMGetGlobalParent(Global: ValueRef) -> ModuleRef;\n+    unsafe fn LLVMIsDeclaration(Global: ValueRef) -> Bool;\n+    unsafe fn LLVMGetLinkage(Global: ValueRef) -> c_uint;\n+    unsafe fn LLVMSetLinkage(Global: ValueRef, Link: c_uint);\n+    unsafe fn LLVMGetSection(Global: ValueRef) -> *c_char;\n+    unsafe fn LLVMSetSection(Global: ValueRef, Section: *c_char);\n+    unsafe fn LLVMGetVisibility(Global: ValueRef) -> c_uint;\n+    unsafe fn LLVMSetVisibility(Global: ValueRef, Viz: c_uint);\n+    unsafe fn LLVMGetAlignment(Global: ValueRef) -> c_uint;\n+    unsafe fn LLVMSetAlignment(Global: ValueRef, Bytes: c_uint);\n \n \n     /* Operations on global variables */\n-    fn LLVMAddGlobal(M: ModuleRef, Ty: TypeRef, Name: *c_char) -> ValueRef;\n-    fn LLVMAddGlobalInAddressSpace(M: ModuleRef, Ty: TypeRef, Name: *c_char,\n-                                   AddressSpace: c_uint) -> ValueRef;\n-    fn LLVMGetNamedGlobal(M: ModuleRef, Name: *c_char) -> ValueRef;\n-    fn LLVMGetFirstGlobal(M: ModuleRef) -> ValueRef;\n-    fn LLVMGetLastGlobal(M: ModuleRef) -> ValueRef;\n-    fn LLVMGetNextGlobal(GlobalVar: ValueRef) -> ValueRef;\n-    fn LLVMGetPreviousGlobal(GlobalVar: ValueRef) -> ValueRef;\n-    fn LLVMDeleteGlobal(GlobalVar: ValueRef);\n-    fn LLVMGetInitializer(GlobalVar: ValueRef) -> ValueRef;\n-    fn LLVMSetInitializer(GlobalVar: ValueRef, ConstantVal: ValueRef);\n-    fn LLVMIsThreadLocal(GlobalVar: ValueRef) -> Bool;\n-    fn LLVMSetThreadLocal(GlobalVar: ValueRef, IsThreadLocal: Bool);\n-    fn LLVMIsGlobalConstant(GlobalVar: ValueRef) -> Bool;\n-    fn LLVMSetGlobalConstant(GlobalVar: ValueRef, IsConstant: Bool);\n+    unsafe fn LLVMAddGlobal(M: ModuleRef,\n+                            Ty: TypeRef,\n+                            Name: *c_char)\n+                         -> ValueRef;\n+    unsafe fn LLVMAddGlobalInAddressSpace(M: ModuleRef,\n+                                          Ty: TypeRef,\n+                                          Name: *c_char,\n+                                          AddressSpace: c_uint)\n+                                       -> ValueRef;\n+    unsafe fn LLVMGetNamedGlobal(M: ModuleRef, Name: *c_char) -> ValueRef;\n+    unsafe fn LLVMGetFirstGlobal(M: ModuleRef) -> ValueRef;\n+    unsafe fn LLVMGetLastGlobal(M: ModuleRef) -> ValueRef;\n+    unsafe fn LLVMGetNextGlobal(GlobalVar: ValueRef) -> ValueRef;\n+    unsafe fn LLVMGetPreviousGlobal(GlobalVar: ValueRef) -> ValueRef;\n+    unsafe fn LLVMDeleteGlobal(GlobalVar: ValueRef);\n+    unsafe fn LLVMGetInitializer(GlobalVar: ValueRef) -> ValueRef;\n+    unsafe fn LLVMSetInitializer(GlobalVar: ValueRef, ConstantVal: ValueRef);\n+    unsafe fn LLVMIsThreadLocal(GlobalVar: ValueRef) -> Bool;\n+    unsafe fn LLVMSetThreadLocal(GlobalVar: ValueRef, IsThreadLocal: Bool);\n+    unsafe fn LLVMIsGlobalConstant(GlobalVar: ValueRef) -> Bool;\n+    unsafe fn LLVMSetGlobalConstant(GlobalVar: ValueRef, IsConstant: Bool);\n \n     /* Operations on aliases */\n-    fn LLVMAddAlias(M: ModuleRef, Ty: TypeRef, Aliasee: ValueRef,\n+    unsafe fn LLVMAddAlias(M: ModuleRef, Ty: TypeRef, Aliasee: ValueRef,\n                     Name: *c_char) -> ValueRef;\n \n     /* Operations on functions */\n-    fn LLVMAddFunction(M: ModuleRef, Name: *c_char, FunctionTy: TypeRef) ->\n-       ValueRef;\n-    fn LLVMGetNamedFunction(M: ModuleRef, Name: *c_char) -> ValueRef;\n-    fn LLVMGetFirstFunction(M: ModuleRef) -> ValueRef;\n-    fn LLVMGetLastFunction(M: ModuleRef) -> ValueRef;\n-    fn LLVMGetNextFunction(Fn: ValueRef) -> ValueRef;\n-    fn LLVMGetPreviousFunction(Fn: ValueRef) -> ValueRef;\n-    fn LLVMDeleteFunction(Fn: ValueRef);\n-    fn LLVMGetOrInsertFunction(M: ModuleRef, Name: *c_char,\n+    unsafe fn LLVMAddFunction(M: ModuleRef,\n+                              Name: *c_char,\n+                              FunctionTy: TypeRef)\n+                           -> ValueRef;\n+    unsafe fn LLVMGetNamedFunction(M: ModuleRef, Name: *c_char) -> ValueRef;\n+    unsafe fn LLVMGetFirstFunction(M: ModuleRef) -> ValueRef;\n+    unsafe fn LLVMGetLastFunction(M: ModuleRef) -> ValueRef;\n+    unsafe fn LLVMGetNextFunction(Fn: ValueRef) -> ValueRef;\n+    unsafe fn LLVMGetPreviousFunction(Fn: ValueRef) -> ValueRef;\n+    unsafe fn LLVMDeleteFunction(Fn: ValueRef);\n+    unsafe fn LLVMGetOrInsertFunction(M: ModuleRef, Name: *c_char,\n                                FunctionTy: TypeRef) -> ValueRef;\n-    fn LLVMGetIntrinsicID(Fn: ValueRef) -> c_uint;\n-    fn LLVMGetFunctionCallConv(Fn: ValueRef) -> c_uint;\n-    fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: c_uint);\n-    fn LLVMGetGC(Fn: ValueRef) -> *c_char;\n-    fn LLVMSetGC(Fn: ValueRef, Name: *c_char);\n-    fn LLVMAddFunctionAttr(Fn: ValueRef, PA: c_ulonglong, HighPA:\n+    unsafe fn LLVMGetIntrinsicID(Fn: ValueRef) -> c_uint;\n+    unsafe fn LLVMGetFunctionCallConv(Fn: ValueRef) -> c_uint;\n+    unsafe fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: c_uint);\n+    unsafe fn LLVMGetGC(Fn: ValueRef) -> *c_char;\n+    unsafe fn LLVMSetGC(Fn: ValueRef, Name: *c_char);\n+    unsafe fn LLVMAddFunctionAttr(Fn: ValueRef, PA: c_ulonglong, HighPA:\n                            c_ulonglong);\n-    fn LLVMGetFunctionAttr(Fn: ValueRef) -> c_ulonglong;\n-    fn LLVMRemoveFunctionAttr(Fn: ValueRef, PA: c_ulonglong, HighPA:\n+    unsafe fn LLVMGetFunctionAttr(Fn: ValueRef) -> c_ulonglong;\n+    unsafe fn LLVMRemoveFunctionAttr(Fn: ValueRef, PA: c_ulonglong, HighPA:\n                               c_ulonglong);\n \n     /* Operations on parameters */\n-    fn LLVMCountParams(Fn: ValueRef) -> c_uint;\n-    fn LLVMGetParams(Fn: ValueRef, Params: *ValueRef);\n-    fn LLVMGetParam(Fn: ValueRef, Index: c_uint) -> ValueRef;\n-    fn LLVMGetParamParent(Inst: ValueRef) -> ValueRef;\n-    fn LLVMGetFirstParam(Fn: ValueRef) -> ValueRef;\n-    fn LLVMGetLastParam(Fn: ValueRef) -> ValueRef;\n-    fn LLVMGetNextParam(Arg: ValueRef) -> ValueRef;\n-    fn LLVMGetPreviousParam(Arg: ValueRef) -> ValueRef;\n-    fn LLVMAddAttribute(Arg: ValueRef, PA: c_uint);\n-    fn LLVMRemoveAttribute(Arg: ValueRef, PA: c_uint);\n-    fn LLVMGetAttribute(Arg: ValueRef) -> c_uint;\n-    fn LLVMSetParamAlignment(Arg: ValueRef, align: c_uint);\n+    unsafe fn LLVMCountParams(Fn: ValueRef) -> c_uint;\n+    unsafe fn LLVMGetParams(Fn: ValueRef, Params: *ValueRef);\n+    unsafe fn LLVMGetParam(Fn: ValueRef, Index: c_uint) -> ValueRef;\n+    unsafe fn LLVMGetParamParent(Inst: ValueRef) -> ValueRef;\n+    unsafe fn LLVMGetFirstParam(Fn: ValueRef) -> ValueRef;\n+    unsafe fn LLVMGetLastParam(Fn: ValueRef) -> ValueRef;\n+    unsafe fn LLVMGetNextParam(Arg: ValueRef) -> ValueRef;\n+    unsafe fn LLVMGetPreviousParam(Arg: ValueRef) -> ValueRef;\n+    unsafe fn LLVMAddAttribute(Arg: ValueRef, PA: c_uint);\n+    unsafe fn LLVMRemoveAttribute(Arg: ValueRef, PA: c_uint);\n+    unsafe fn LLVMGetAttribute(Arg: ValueRef) -> c_uint;\n+    unsafe fn LLVMSetParamAlignment(Arg: ValueRef, align: c_uint);\n \n     /* Operations on basic blocks */\n-    fn LLVMBasicBlockAsValue(BB: BasicBlockRef) -> ValueRef;\n-    fn LLVMValueIsBasicBlock(Val: ValueRef) -> Bool;\n-    fn LLVMValueAsBasicBlock(Val: ValueRef) -> BasicBlockRef;\n-    fn LLVMGetBasicBlockParent(BB: BasicBlockRef) -> ValueRef;\n-    fn LLVMCountBasicBlocks(Fn: ValueRef) -> c_uint;\n-    fn LLVMGetBasicBlocks(Fn: ValueRef, BasicBlocks: *ValueRef);\n-    fn LLVMGetFirstBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n-    fn LLVMGetLastBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n-    fn LLVMGetNextBasicBlock(BB: BasicBlockRef) -> BasicBlockRef;\n-    fn LLVMGetPreviousBasicBlock(BB: BasicBlockRef) -> BasicBlockRef;\n-    fn LLVMGetEntryBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n-\n-    fn LLVMAppendBasicBlockInContext(C: ContextRef, Fn: ValueRef,\n+    unsafe fn LLVMBasicBlockAsValue(BB: BasicBlockRef) -> ValueRef;\n+    unsafe fn LLVMValueIsBasicBlock(Val: ValueRef) -> Bool;\n+    unsafe fn LLVMValueAsBasicBlock(Val: ValueRef) -> BasicBlockRef;\n+    unsafe fn LLVMGetBasicBlockParent(BB: BasicBlockRef) -> ValueRef;\n+    unsafe fn LLVMCountBasicBlocks(Fn: ValueRef) -> c_uint;\n+    unsafe fn LLVMGetBasicBlocks(Fn: ValueRef, BasicBlocks: *ValueRef);\n+    unsafe fn LLVMGetFirstBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n+    unsafe fn LLVMGetLastBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n+    unsafe fn LLVMGetNextBasicBlock(BB: BasicBlockRef) -> BasicBlockRef;\n+    unsafe fn LLVMGetPreviousBasicBlock(BB: BasicBlockRef) -> BasicBlockRef;\n+    unsafe fn LLVMGetEntryBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n+\n+    unsafe fn LLVMAppendBasicBlockInContext(C: ContextRef, Fn: ValueRef,\n                                      Name: *c_char) -> BasicBlockRef;\n-    fn LLVMInsertBasicBlockInContext(C: ContextRef, BB: BasicBlockRef,\n+    unsafe fn LLVMInsertBasicBlockInContext(C: ContextRef, BB: BasicBlockRef,\n                                      Name: *c_char) -> BasicBlockRef;\n \n-    fn LLVMAppendBasicBlock(Fn: ValueRef, Name: *c_char) -> BasicBlockRef;\n-    fn LLVMInsertBasicBlock(InsertBeforeBB: BasicBlockRef, Name: *c_char) ->\n-       BasicBlockRef;\n-    fn LLVMDeleteBasicBlock(BB: BasicBlockRef);\n+    unsafe fn LLVMAppendBasicBlock(Fn: ValueRef,\n+                                   Name: *c_char)\n+                                -> BasicBlockRef;\n+    unsafe fn LLVMInsertBasicBlock(InsertBeforeBB: BasicBlockRef,\n+                                   Name: *c_char)\n+                                -> BasicBlockRef;\n+    unsafe fn LLVMDeleteBasicBlock(BB: BasicBlockRef);\n \n     /* Operations on instructions */\n-    fn LLVMGetInstructionParent(Inst: ValueRef) -> BasicBlockRef;\n-    fn LLVMGetFirstInstruction(BB: BasicBlockRef) -> ValueRef;\n-    fn LLVMGetLastInstruction(BB: BasicBlockRef) -> ValueRef;\n-    fn LLVMGetNextInstruction(Inst: ValueRef) -> ValueRef;\n-    fn LLVMGetPreviousInstruction(Inst: ValueRef) -> ValueRef;\n+    unsafe fn LLVMGetInstructionParent(Inst: ValueRef) -> BasicBlockRef;\n+    unsafe fn LLVMGetFirstInstruction(BB: BasicBlockRef) -> ValueRef;\n+    unsafe fn LLVMGetLastInstruction(BB: BasicBlockRef) -> ValueRef;\n+    unsafe fn LLVMGetNextInstruction(Inst: ValueRef) -> ValueRef;\n+    unsafe fn LLVMGetPreviousInstruction(Inst: ValueRef) -> ValueRef;\n \n     /* Operations on call sites */\n-    fn LLVMSetInstructionCallConv(Instr: ValueRef, CC: c_uint);\n-    fn LLVMGetInstructionCallConv(Instr: ValueRef) -> c_uint;\n-    fn LLVMAddInstrAttribute(Instr: ValueRef, index: c_uint, IA: c_uint);\n-    fn LLVMRemoveInstrAttribute(Instr: ValueRef, index: c_uint,\n+    unsafe fn LLVMSetInstructionCallConv(Instr: ValueRef, CC: c_uint);\n+    unsafe fn LLVMGetInstructionCallConv(Instr: ValueRef) -> c_uint;\n+    unsafe fn LLVMAddInstrAttribute(Instr: ValueRef,\n+                                    index: c_uint,\n+                                    IA: c_uint);\n+    unsafe fn LLVMRemoveInstrAttribute(Instr: ValueRef, index: c_uint,\n                                 IA: c_uint);\n-    fn LLVMSetInstrParamAlignment(Instr: ValueRef, index: c_uint,\n+    unsafe fn LLVMSetInstrParamAlignment(Instr: ValueRef, index: c_uint,\n                                   align: c_uint);\n \n     /* Operations on call instructions (only) */\n-    fn LLVMIsTailCall(CallInst: ValueRef) -> Bool;\n-    fn LLVMSetTailCall(CallInst: ValueRef, IsTailCall: Bool);\n+    unsafe fn LLVMIsTailCall(CallInst: ValueRef) -> Bool;\n+    unsafe fn LLVMSetTailCall(CallInst: ValueRef, IsTailCall: Bool);\n \n     /* Operations on phi nodes */\n-    fn LLVMAddIncoming(PhiNode: ValueRef, IncomingValues: *ValueRef,\n+    unsafe fn LLVMAddIncoming(PhiNode: ValueRef, IncomingValues: *ValueRef,\n                        IncomingBlocks: *BasicBlockRef, Count: c_uint);\n-    fn LLVMCountIncoming(PhiNode: ValueRef) -> c_uint;\n-    fn LLVMGetIncomingValue(PhiNode: ValueRef, Index: c_uint) -> ValueRef;\n-    fn LLVMGetIncomingBlock(PhiNode: ValueRef,\n+    unsafe fn LLVMCountIncoming(PhiNode: ValueRef) -> c_uint;\n+    unsafe fn LLVMGetIncomingValue(PhiNode: ValueRef,\n+                                   Index: c_uint)\n+                                -> ValueRef;\n+    unsafe fn LLVMGetIncomingBlock(PhiNode: ValueRef,\n                             Index: c_uint) -> BasicBlockRef;\n \n     /* Instruction builders */\n-    fn LLVMCreateBuilderInContext(C: ContextRef) -> BuilderRef;\n-    fn LLVMCreateBuilder() -> BuilderRef;\n-    fn LLVMPositionBuilder(Builder: BuilderRef, Block: BasicBlockRef,\n+    unsafe fn LLVMCreateBuilderInContext(C: ContextRef) -> BuilderRef;\n+    unsafe fn LLVMCreateBuilder() -> BuilderRef;\n+    unsafe fn LLVMPositionBuilder(Builder: BuilderRef, Block: BasicBlockRef,\n                            Instr: ValueRef);\n-    fn LLVMPositionBuilderBefore(Builder: BuilderRef, Instr: ValueRef);\n-    fn LLVMPositionBuilderAtEnd(Builder: BuilderRef, Block: BasicBlockRef);\n-    fn LLVMGetInsertBlock(Builder: BuilderRef) -> BasicBlockRef;\n-    fn LLVMClearInsertionPosition(Builder: BuilderRef);\n-    fn LLVMInsertIntoBuilder(Builder: BuilderRef, Instr: ValueRef);\n-    fn LLVMInsertIntoBuilderWithName(Builder: BuilderRef, Instr: ValueRef,\n-                                     Name: *c_char);\n-    fn LLVMDisposeBuilder(Builder: BuilderRef);\n+    unsafe fn LLVMPositionBuilderBefore(Builder: BuilderRef, Instr: ValueRef);\n+    unsafe fn LLVMPositionBuilderAtEnd(Builder: BuilderRef,\n+                                       Block: BasicBlockRef);\n+    unsafe fn LLVMGetInsertBlock(Builder: BuilderRef) -> BasicBlockRef;\n+    unsafe fn LLVMClearInsertionPosition(Builder: BuilderRef);\n+    unsafe fn LLVMInsertIntoBuilder(Builder: BuilderRef, Instr: ValueRef);\n+    unsafe fn LLVMInsertIntoBuilderWithName(Builder: BuilderRef,\n+                                            Instr: ValueRef,\n+                                            Name: *c_char);\n+    unsafe fn LLVMDisposeBuilder(Builder: BuilderRef);\n \n     /* Metadata */\n-    fn LLVMSetCurrentDebugLocation(Builder: BuilderRef, L: ValueRef);\n-    fn LLVMGetCurrentDebugLocation(Builder: BuilderRef) -> ValueRef;\n-    fn LLVMSetInstDebugLocation(Builder: BuilderRef, Inst: ValueRef);\n+    unsafe fn LLVMSetCurrentDebugLocation(Builder: BuilderRef, L: ValueRef);\n+    unsafe fn LLVMGetCurrentDebugLocation(Builder: BuilderRef) -> ValueRef;\n+    unsafe fn LLVMSetInstDebugLocation(Builder: BuilderRef, Inst: ValueRef);\n \n     /* Terminators */\n-    fn LLVMBuildRetVoid(B: BuilderRef) -> ValueRef;\n-    fn LLVMBuildRet(B: BuilderRef, V: ValueRef) -> ValueRef;\n-    fn LLVMBuildAggregateRet(B: BuilderRef, RetVals: *ValueRef,\n+    unsafe fn LLVMBuildRetVoid(B: BuilderRef) -> ValueRef;\n+    unsafe fn LLVMBuildRet(B: BuilderRef, V: ValueRef) -> ValueRef;\n+    unsafe fn LLVMBuildAggregateRet(B: BuilderRef, RetVals: *ValueRef,\n                              N: c_uint) -> ValueRef;\n-    fn LLVMBuildBr(B: BuilderRef, Dest: BasicBlockRef) -> ValueRef;\n-    fn LLVMBuildCondBr(B: BuilderRef, If: ValueRef, Then: BasicBlockRef,\n-                       Else: BasicBlockRef) -> ValueRef;\n-    fn LLVMBuildSwitch(B: BuilderRef, V: ValueRef, Else: BasicBlockRef,\n+    unsafe fn LLVMBuildBr(B: BuilderRef, Dest: BasicBlockRef) -> ValueRef;\n+    unsafe fn LLVMBuildCondBr(B: BuilderRef,\n+                              If: ValueRef,\n+                              Then: BasicBlockRef,\n+                              Else: BasicBlockRef)\n+                           -> ValueRef;\n+    unsafe fn LLVMBuildSwitch(B: BuilderRef, V: ValueRef, Else: BasicBlockRef,\n                        NumCases: c_uint) -> ValueRef;\n-    fn LLVMBuildIndirectBr(B: BuilderRef, Addr: ValueRef,\n+    unsafe fn LLVMBuildIndirectBr(B: BuilderRef, Addr: ValueRef,\n                            NumDests: c_uint) -> ValueRef;\n-    fn LLVMBuildInvoke(B: BuilderRef, Fn: ValueRef, Args: *ValueRef,\n+    unsafe fn LLVMBuildInvoke(B: BuilderRef, Fn: ValueRef, Args: *ValueRef,\n                        NumArgs: c_uint, Then: BasicBlockRef,\n                        Catch: BasicBlockRef, Name: *c_char) -> ValueRef;\n-    fn LLVMBuildLandingPad(B: BuilderRef, Ty: TypeRef, PersFn: ValueRef,\n-                           NumClauses: c_uint, Name: *c_char) -> ValueRef;\n-    fn LLVMBuildResume(B: BuilderRef, Exn: ValueRef) -> ValueRef;\n-    fn LLVMBuildUnreachable(B: BuilderRef) -> ValueRef;\n+    unsafe fn LLVMBuildLandingPad(B: BuilderRef,\n+                                  Ty: TypeRef,\n+                                  PersFn: ValueRef,\n+                                  NumClauses: c_uint,\n+                                  Name: *c_char)\n+                               -> ValueRef;\n+    unsafe fn LLVMBuildResume(B: BuilderRef, Exn: ValueRef) -> ValueRef;\n+    unsafe fn LLVMBuildUnreachable(B: BuilderRef) -> ValueRef;\n \n     /* Add a case to the switch instruction */\n-    fn LLVMAddCase(Switch: ValueRef, OnVal: ValueRef, Dest: BasicBlockRef);\n+    unsafe fn LLVMAddCase(Switch: ValueRef,\n+                          OnVal: ValueRef,\n+                          Dest: BasicBlockRef);\n \n     /* Add a destination to the indirectbr instruction */\n-    fn LLVMAddDestination(IndirectBr: ValueRef, Dest: BasicBlockRef);\n+    unsafe fn LLVMAddDestination(IndirectBr: ValueRef, Dest: BasicBlockRef);\n \n     /* Add a clause to the landing pad instruction */\n-    fn LLVMAddClause(LandingPad: ValueRef, ClauseVal: ValueRef);\n+    unsafe fn LLVMAddClause(LandingPad: ValueRef, ClauseVal: ValueRef);\n \n     /* Set the cleanup on a landing pad instruction */\n-    fn LLVMSetCleanup(LandingPad: ValueRef, Val: Bool);\n+    unsafe fn LLVMSetCleanup(LandingPad: ValueRef, Val: Bool);\n \n     /* Arithmetic */\n-    fn LLVMBuildAdd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    unsafe fn LLVMBuildAdd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                     Name: *c_char) -> ValueRef;\n-    fn LLVMBuildNSWAdd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    unsafe fn LLVMBuildNSWAdd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                        Name: *c_char) -> ValueRef;\n-    fn LLVMBuildNUWAdd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    unsafe fn LLVMBuildNUWAdd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                        Name: *c_char) -> ValueRef;\n-    fn LLVMBuildFAdd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    unsafe fn LLVMBuildFAdd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                      Name: *c_char) -> ValueRef;\n-    fn LLVMBuildSub(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    unsafe fn LLVMBuildSub(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                     Name: *c_char) -> ValueRef;\n-    fn LLVMBuildNSWSub(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    unsafe fn LLVMBuildNSWSub(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                        Name: *c_char) -> ValueRef;\n-    fn LLVMBuildNUWSub(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    unsafe fn LLVMBuildNUWSub(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                        Name: *c_char) -> ValueRef;\n-    fn LLVMBuildFSub(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    unsafe fn LLVMBuildFSub(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                      Name: *c_char) -> ValueRef;\n-    fn LLVMBuildMul(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    unsafe fn LLVMBuildMul(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                     Name: *c_char) -> ValueRef;\n-    fn LLVMBuildNSWMul(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    unsafe fn LLVMBuildNSWMul(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                        Name: *c_char) -> ValueRef;\n-    fn LLVMBuildNUWMul(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    unsafe fn LLVMBuildNUWMul(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                        Name: *c_char) -> ValueRef;\n-    fn LLVMBuildFMul(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    unsafe fn LLVMBuildFMul(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                      Name: *c_char) -> ValueRef;\n-    fn LLVMBuildUDiv(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    unsafe fn LLVMBuildUDiv(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                      Name: *c_char) -> ValueRef;\n-    fn LLVMBuildSDiv(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    unsafe fn LLVMBuildSDiv(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                      Name: *c_char) -> ValueRef;\n-    fn LLVMBuildExactSDiv(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    unsafe fn LLVMBuildExactSDiv(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                           Name: *c_char) -> ValueRef;\n-    fn LLVMBuildFDiv(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    unsafe fn LLVMBuildFDiv(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                      Name: *c_char) -> ValueRef;\n-    fn LLVMBuildURem(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    unsafe fn LLVMBuildURem(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                      Name: *c_char) -> ValueRef;\n-    fn LLVMBuildSRem(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    unsafe fn LLVMBuildSRem(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                      Name: *c_char) -> ValueRef;\n-    fn LLVMBuildFRem(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    unsafe fn LLVMBuildFRem(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                      Name: *c_char) -> ValueRef;\n-    fn LLVMBuildShl(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    unsafe fn LLVMBuildShl(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                     Name: *c_char) -> ValueRef;\n-    fn LLVMBuildLShr(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    unsafe fn LLVMBuildLShr(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                      Name: *c_char) -> ValueRef;\n-    fn LLVMBuildAShr(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    unsafe fn LLVMBuildAShr(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                      Name: *c_char) -> ValueRef;\n-    fn LLVMBuildAnd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    unsafe fn LLVMBuildAnd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                     Name: *c_char) -> ValueRef;\n-    fn LLVMBuildOr(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    unsafe fn LLVMBuildOr(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                    Name: *c_char) -> ValueRef;\n-    fn LLVMBuildXor(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    unsafe fn LLVMBuildXor(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                     Name: *c_char) -> ValueRef;\n-    fn LLVMBuildBinOp(B: BuilderRef, Op: Opcode, LHS: ValueRef, RHS: ValueRef,\n-                      Name: *c_char) -> ValueRef;\n-    fn LLVMBuildNeg(B: BuilderRef, V: ValueRef, Name: *c_char) -> ValueRef;\n-    fn LLVMBuildNSWNeg(B: BuilderRef, V: ValueRef, Name: *c_char) -> ValueRef;\n-    fn LLVMBuildNUWNeg(B: BuilderRef, V: ValueRef, Name: *c_char) -> ValueRef;\n-    fn LLVMBuildFNeg(B: BuilderRef, V: ValueRef, Name: *c_char) -> ValueRef;\n-    fn LLVMBuildNot(B: BuilderRef, V: ValueRef, Name: *c_char) -> ValueRef;\n+    unsafe fn LLVMBuildBinOp(B: BuilderRef,\n+                             Op: Opcode,\n+                             LHS: ValueRef,\n+                             RHS: ValueRef,\n+                             Name: *c_char)\n+                          -> ValueRef;\n+    unsafe fn LLVMBuildNeg(B: BuilderRef,\n+                           V: ValueRef,\n+                           Name: *c_char)\n+                        -> ValueRef;\n+    unsafe fn LLVMBuildNSWNeg(B: BuilderRef,\n+                              V: ValueRef,\n+                              Name: *c_char)\n+                           -> ValueRef;\n+    unsafe fn LLVMBuildNUWNeg(B: BuilderRef,\n+                              V: ValueRef,\n+                              Name: *c_char)\n+                           -> ValueRef;\n+    unsafe fn LLVMBuildFNeg(B: BuilderRef,\n+                            V: ValueRef,\n+                            Name: *c_char)\n+                         -> ValueRef;\n+    unsafe fn LLVMBuildNot(B: BuilderRef,\n+                           V: ValueRef,\n+                           Name: *c_char)\n+                        -> ValueRef;\n \n     /* Memory */\n-    fn LLVMBuildMalloc(B: BuilderRef, Ty: TypeRef, Name: *c_char) -> ValueRef;\n-    fn LLVMBuildArrayMalloc(B: BuilderRef, Ty: TypeRef, Val: ValueRef,\n+    unsafe fn LLVMBuildMalloc(B: BuilderRef,\n+                              Ty: TypeRef,\n+                              Name: *c_char)\n+                           -> ValueRef;\n+    unsafe fn LLVMBuildArrayMalloc(B: BuilderRef, Ty: TypeRef, Val: ValueRef,\n                             Name: *c_char) -> ValueRef;\n-    fn LLVMBuildAlloca(B: BuilderRef, Ty: TypeRef, Name: *c_char) -> ValueRef;\n-    fn LLVMBuildArrayAlloca(B: BuilderRef, Ty: TypeRef, Val: ValueRef,\n+    unsafe fn LLVMBuildAlloca(B: BuilderRef,\n+                              Ty: TypeRef,\n+                              Name: *c_char)\n+                           -> ValueRef;\n+    unsafe fn LLVMBuildArrayAlloca(B: BuilderRef, Ty: TypeRef, Val: ValueRef,\n                             Name: *c_char) -> ValueRef;\n-    fn LLVMBuildFree(B: BuilderRef, PointerVal: ValueRef) -> ValueRef;\n-    fn LLVMBuildLoad(B: BuilderRef, PointerVal: ValueRef, Name: *c_char) ->\n-       ValueRef;\n-    fn LLVMBuildStore(B: BuilderRef, Val: ValueRef, Ptr: ValueRef) ->\n+    unsafe fn LLVMBuildFree(B: BuilderRef, PointerVal: ValueRef) -> ValueRef;\n+    unsafe fn LLVMBuildLoad(B: BuilderRef,\n+                            PointerVal: ValueRef,\n+                            Name: *c_char)\n+                         -> ValueRef;\n+    unsafe fn LLVMBuildStore(B: BuilderRef, Val: ValueRef, Ptr: ValueRef) ->\n        ValueRef;\n-    fn LLVMBuildGEP(B: BuilderRef, Pointer: ValueRef, Indices: *ValueRef,\n-                    NumIndices: c_uint, Name: *c_char) -> ValueRef;\n-    fn LLVMBuildInBoundsGEP(B: BuilderRef, Pointer: ValueRef,\n+    unsafe fn LLVMBuildGEP(B: BuilderRef,\n+                           Pointer: ValueRef,\n+                           Indices: *ValueRef,\n+                           NumIndices: c_uint,\n+                           Name: *c_char)\n+                        -> ValueRef;\n+    unsafe fn LLVMBuildInBoundsGEP(B: BuilderRef, Pointer: ValueRef,\n                             Indices: *ValueRef, NumIndices: c_uint,\n                             Name: *c_char)\n        -> ValueRef;\n-    fn LLVMBuildStructGEP(B: BuilderRef, Pointer: ValueRef, Idx: c_uint,\n-                          Name: *c_char) -> ValueRef;\n-    fn LLVMBuildGlobalString(B: BuilderRef, Str: *c_char, Name: *c_char) ->\n-       ValueRef;\n-    fn LLVMBuildGlobalStringPtr(B: BuilderRef, Str: *c_char, Name: *c_char) ->\n-       ValueRef;\n+    unsafe fn LLVMBuildStructGEP(B: BuilderRef,\n+                                 Pointer: ValueRef,\n+                                 Idx: c_uint,\n+                                 Name: *c_char)\n+                              -> ValueRef;\n+    unsafe fn LLVMBuildGlobalString(B: BuilderRef,\n+                                    Str: *c_char,\n+                                    Name: *c_char)\n+                                 -> ValueRef;\n+    unsafe fn LLVMBuildGlobalStringPtr(B: BuilderRef,\n+                                       Str: *c_char,\n+                                       Name: *c_char)\n+                                    -> ValueRef;\n \n     /* Casts */\n-    fn LLVMBuildTrunc(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n+    unsafe fn LLVMBuildTrunc(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n                       Name: *c_char) -> ValueRef;\n-    fn LLVMBuildZExt(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n+    unsafe fn LLVMBuildZExt(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n                      Name: *c_char) -> ValueRef;\n-    fn LLVMBuildSExt(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n+    unsafe fn LLVMBuildSExt(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n                      Name: *c_char) -> ValueRef;\n-    fn LLVMBuildFPToUI(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n+    unsafe fn LLVMBuildFPToUI(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n                        Name: *c_char) -> ValueRef;\n-    fn LLVMBuildFPToSI(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n+    unsafe fn LLVMBuildFPToSI(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n                        Name: *c_char) -> ValueRef;\n-    fn LLVMBuildUIToFP(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n+    unsafe fn LLVMBuildUIToFP(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n                        Name: *c_char) -> ValueRef;\n-    fn LLVMBuildSIToFP(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n+    unsafe fn LLVMBuildSIToFP(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n                        Name: *c_char) -> ValueRef;\n-    fn LLVMBuildFPTrunc(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n+    unsafe fn LLVMBuildFPTrunc(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n                         Name: *c_char) -> ValueRef;\n-    fn LLVMBuildFPExt(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n+    unsafe fn LLVMBuildFPExt(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n                       Name: *c_char) -> ValueRef;\n-    fn LLVMBuildPtrToInt(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n+    unsafe fn LLVMBuildPtrToInt(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n                          Name: *c_char) -> ValueRef;\n-    fn LLVMBuildIntToPtr(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n+    unsafe fn LLVMBuildIntToPtr(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n                          Name: *c_char) -> ValueRef;\n-    fn LLVMBuildBitCast(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n+    unsafe fn LLVMBuildBitCast(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n                         Name: *c_char) -> ValueRef;\n-    fn LLVMBuildZExtOrBitCast(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                              Name: *c_char) -> ValueRef;\n-    fn LLVMBuildSExtOrBitCast(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                              Name: *c_char) -> ValueRef;\n-    fn LLVMBuildTruncOrBitCast(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                               Name: *c_char) -> ValueRef;\n-    fn LLVMBuildCast(B: BuilderRef, Op: Opcode, Val: ValueRef,\n+    unsafe fn LLVMBuildZExtOrBitCast(B: BuilderRef,\n+                                     Val: ValueRef,\n+                                     DestTy: TypeRef,\n+                                     Name: *c_char)\n+                                  -> ValueRef;\n+    unsafe fn LLVMBuildSExtOrBitCast(B: BuilderRef,\n+                                     Val: ValueRef,\n+                                     DestTy: TypeRef,\n+                                     Name: *c_char)\n+                                  -> ValueRef;\n+    unsafe fn LLVMBuildTruncOrBitCast(B: BuilderRef,\n+                                      Val: ValueRef,\n+                                      DestTy: TypeRef,\n+                                      Name: *c_char)\n+                                   -> ValueRef;\n+    unsafe fn LLVMBuildCast(B: BuilderRef, Op: Opcode, Val: ValueRef,\n                      DestTy: TypeRef, Name: *c_char) -> ValueRef;\n-    fn LLVMBuildPointerCast(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                            Name: *c_char) -> ValueRef;\n-    fn LLVMBuildIntCast(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n+    unsafe fn LLVMBuildPointerCast(B: BuilderRef,\n+                                   Val: ValueRef,\n+                                   DestTy: TypeRef,\n+                                   Name: *c_char)\n+                                -> ValueRef;\n+    unsafe fn LLVMBuildIntCast(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n                         Name: *c_char) -> ValueRef;\n-    fn LLVMBuildFPCast(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n+    unsafe fn LLVMBuildFPCast(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n                        Name: *c_char) -> ValueRef;\n \n     /* Comparisons */\n-    fn LLVMBuildICmp(B: BuilderRef, Op: c_uint, LHS: ValueRef,\n+    unsafe fn LLVMBuildICmp(B: BuilderRef, Op: c_uint, LHS: ValueRef,\n                      RHS: ValueRef, Name: *c_char) -> ValueRef;\n-    fn LLVMBuildFCmp(B: BuilderRef, Op: c_uint, LHS: ValueRef,\n+    unsafe fn LLVMBuildFCmp(B: BuilderRef, Op: c_uint, LHS: ValueRef,\n                      RHS: ValueRef, Name: *c_char) -> ValueRef;\n \n     /* Miscellaneous instructions */\n-    fn LLVMBuildPhi(B: BuilderRef, Ty: TypeRef, Name: *c_char) -> ValueRef;\n-    fn LLVMBuildCall(B: BuilderRef, Fn: ValueRef, Args: *ValueRef,\n+    unsafe fn LLVMBuildPhi(B: BuilderRef,\n+                           Ty: TypeRef,\n+                           Name: *c_char)\n+                        -> ValueRef;\n+    unsafe fn LLVMBuildCall(B: BuilderRef, Fn: ValueRef, Args: *ValueRef,\n                      NumArgs: c_uint, Name: *c_char) -> ValueRef;\n-    fn LLVMBuildSelect(B: BuilderRef, If: ValueRef, Then: ValueRef,\n+    unsafe fn LLVMBuildSelect(B: BuilderRef, If: ValueRef, Then: ValueRef,\n                        Else: ValueRef, Name: *c_char) -> ValueRef;\n-    fn LLVMBuildVAArg(B: BuilderRef, list: ValueRef, Ty: TypeRef,\n+    unsafe fn LLVMBuildVAArg(B: BuilderRef, list: ValueRef, Ty: TypeRef,\n                       Name: *c_char)\n        -> ValueRef;\n-    fn LLVMBuildExtractElement(B: BuilderRef, VecVal: ValueRef,\n-                               Index: ValueRef, Name: *c_char) -> ValueRef;\n-    fn LLVMBuildInsertElement(B: BuilderRef, VecVal: ValueRef,\n-                              EltVal: ValueRef, Index: ValueRef,\n-                              Name: *c_char)\n-       -> ValueRef;\n-    fn LLVMBuildShuffleVector(B: BuilderRef, V1: ValueRef, V2: ValueRef,\n-                              Mask: ValueRef, Name: *c_char) -> ValueRef;\n-    fn LLVMBuildExtractValue(B: BuilderRef, AggVal: ValueRef, Index: c_uint,\n-                             Name: *c_char) -> ValueRef;\n-    fn LLVMBuildInsertValue(B: BuilderRef, AggVal: ValueRef, EltVal: ValueRef,\n-                            Index: c_uint, Name: *c_char) -> ValueRef;\n-\n-    fn LLVMBuildIsNull(B: BuilderRef, Val: ValueRef,\n-                       Name: *c_char) -> ValueRef;\n-    fn LLVMBuildIsNotNull(B: BuilderRef, Val: ValueRef, Name: *c_char) ->\n-       ValueRef;\n-    fn LLVMBuildPtrDiff(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    unsafe fn LLVMBuildExtractElement(B: BuilderRef,\n+                                      VecVal: ValueRef,\n+                                      Index: ValueRef,\n+                                      Name: *c_char)\n+                                   -> ValueRef;\n+    unsafe fn LLVMBuildInsertElement(B: BuilderRef,\n+                                     VecVal: ValueRef,\n+                                     EltVal: ValueRef,\n+                                     Index: ValueRef,\n+                                     Name: *c_char)\n+                                  -> ValueRef;\n+    unsafe fn LLVMBuildShuffleVector(B: BuilderRef,\n+                                     V1: ValueRef,\n+                                     V2: ValueRef,\n+                                     Mask: ValueRef,\n+                                     Name: *c_char)\n+                                  -> ValueRef;\n+    unsafe fn LLVMBuildExtractValue(B: BuilderRef,\n+                                    AggVal: ValueRef,\n+                                    Index: c_uint,\n+                                    Name: *c_char)\n+                                 -> ValueRef;\n+    unsafe fn LLVMBuildInsertValue(B: BuilderRef,\n+                                   AggVal: ValueRef,\n+                                   EltVal: ValueRef,\n+                                   Index: c_uint,\n+                                   Name: *c_char)\n+                                -> ValueRef;\n+\n+    unsafe fn LLVMBuildIsNull(B: BuilderRef, Val: ValueRef, Name: *c_char)\n+                           -> ValueRef;\n+    unsafe fn LLVMBuildIsNotNull(B: BuilderRef, Val: ValueRef, Name: *c_char)\n+                              -> ValueRef;\n+    unsafe fn LLVMBuildPtrDiff(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                         Name: *c_char) -> ValueRef;\n \n     /* Atomic Operations */\n-    fn LLVMBuildAtomicCmpXchg(B: BuilderRef, LHS: ValueRef,\n+    unsafe fn LLVMBuildAtomicCmpXchg(B: BuilderRef, LHS: ValueRef,\n                               CMP: ValueRef, RHS: ValueRef,\n                               ++Order: AtomicOrdering) -> ValueRef;\n-    fn LLVMBuildAtomicRMW(B: BuilderRef, ++Op: AtomicBinOp,\n+    unsafe fn LLVMBuildAtomicRMW(B: BuilderRef, ++Op: AtomicBinOp,\n                           LHS: ValueRef, RHS: ValueRef,\n                           ++Order: AtomicOrdering) -> ValueRef;\n \n     /* Selected entries from the downcasts. */\n-    fn LLVMIsATerminatorInst(Inst: ValueRef) -> ValueRef;\n+    unsafe fn LLVMIsATerminatorInst(Inst: ValueRef) -> ValueRef;\n \n     /** Writes a module to the specified path. Returns 0 on success. */\n-    fn LLVMWriteBitcodeToFile(M: ModuleRef, Path: *c_char) -> c_int;\n+    unsafe fn LLVMWriteBitcodeToFile(M: ModuleRef, Path: *c_char) -> c_int;\n \n     /** Creates target data from a target layout string. */\n-    fn LLVMCreateTargetData(StringRep: *c_char) -> TargetDataRef;\n+    unsafe fn LLVMCreateTargetData(StringRep: *c_char) -> TargetDataRef;\n     /** Adds the target data to the given pass manager. The pass manager\n         references the target data only weakly. */\n-    fn LLVMAddTargetData(TD: TargetDataRef, PM: PassManagerRef);\n+    unsafe fn LLVMAddTargetData(TD: TargetDataRef, PM: PassManagerRef);\n     /** Number of bytes clobbered when doing a Store to *T. */\n-    fn LLVMStoreSizeOfType(TD: TargetDataRef, Ty: TypeRef) -> c_ulonglong;\n+    unsafe fn LLVMStoreSizeOfType(TD: TargetDataRef, Ty: TypeRef)\n+        -> c_ulonglong;\n \n     /** Number of bytes clobbered when doing a Store to *T. */\n-    fn LLVMSizeOfTypeInBits(TD: TargetDataRef, Ty: TypeRef) -> c_ulonglong;\n+    unsafe fn LLVMSizeOfTypeInBits(TD: TargetDataRef, Ty: TypeRef)\n+        -> c_ulonglong;\n \n     /** Distance between successive elements in an array of T.\n     Includes ABI padding. */\n-    fn LLVMABISizeOfType(TD: TargetDataRef, Ty: TypeRef) -> c_uint;\n+    unsafe fn LLVMABISizeOfType(TD: TargetDataRef, Ty: TypeRef) -> c_uint;\n \n     /** Returns the preferred alignment of a type. */\n-    fn LLVMPreferredAlignmentOfType(TD: TargetDataRef,\n+    unsafe fn LLVMPreferredAlignmentOfType(TD: TargetDataRef,\n                                     Ty: TypeRef) -> c_uint;\n     /** Returns the minimum alignment of a type. */\n-    fn LLVMABIAlignmentOfType(TD: TargetDataRef,\n+    unsafe fn LLVMABIAlignmentOfType(TD: TargetDataRef,\n                               Ty: TypeRef) -> c_uint;\n     /** Returns the minimum alignment of a type when part of a call frame. */\n-    fn LLVMCallFrameAlignmentOfType(TD: TargetDataRef,\n+    unsafe fn LLVMCallFrameAlignmentOfType(TD: TargetDataRef,\n                                     Ty: TypeRef) -> c_uint;\n \n     /** Disposes target data. */\n-    fn LLVMDisposeTargetData(TD: TargetDataRef);\n+    unsafe fn LLVMDisposeTargetData(TD: TargetDataRef);\n \n     /** Creates a pass manager. */\n-    fn LLVMCreatePassManager() -> PassManagerRef;\n+    unsafe fn LLVMCreatePassManager() -> PassManagerRef;\n     /** Disposes a pass manager. */\n-    fn LLVMDisposePassManager(PM: PassManagerRef);\n+    unsafe fn LLVMDisposePassManager(PM: PassManagerRef);\n     /** Runs a pass manager on a module. */\n-    fn LLVMRunPassManager(PM: PassManagerRef, M: ModuleRef) -> Bool;\n+    unsafe fn LLVMRunPassManager(PM: PassManagerRef, M: ModuleRef) -> Bool;\n \n     /** Adds a verification pass. */\n-    fn LLVMAddVerifierPass(PM: PassManagerRef);\n-\n-    fn LLVMAddGlobalOptimizerPass(PM: PassManagerRef);\n-    fn LLVMAddIPSCCPPass(PM: PassManagerRef);\n-    fn LLVMAddDeadArgEliminationPass(PM: PassManagerRef);\n-    fn LLVMAddInstructionCombiningPass(PM: PassManagerRef);\n-    fn LLVMAddCFGSimplificationPass(PM: PassManagerRef);\n-    fn LLVMAddFunctionInliningPass(PM: PassManagerRef);\n-    fn LLVMAddFunctionAttrsPass(PM: PassManagerRef);\n-    fn LLVMAddScalarReplAggregatesPass(PM: PassManagerRef);\n-    fn LLVMAddScalarReplAggregatesPassSSA(PM: PassManagerRef);\n-    fn LLVMAddJumpThreadingPass(PM: PassManagerRef);\n-    fn LLVMAddConstantPropagationPass(PM: PassManagerRef);\n-    fn LLVMAddReassociatePass(PM: PassManagerRef);\n-    fn LLVMAddLoopRotatePass(PM: PassManagerRef);\n-    fn LLVMAddLICMPass(PM: PassManagerRef);\n-    fn LLVMAddLoopUnswitchPass(PM: PassManagerRef);\n-    fn LLVMAddLoopDeletionPass(PM: PassManagerRef);\n-    fn LLVMAddLoopUnrollPass(PM: PassManagerRef);\n-    fn LLVMAddGVNPass(PM: PassManagerRef);\n-    fn LLVMAddMemCpyOptPass(PM: PassManagerRef);\n-    fn LLVMAddSCCPPass(PM: PassManagerRef);\n-    fn LLVMAddDeadStoreEliminationPass(PM: PassManagerRef);\n-    fn LLVMAddStripDeadPrototypesPass(PM: PassManagerRef);\n-    fn LLVMAddConstantMergePass(PM: PassManagerRef);\n-    fn LLVMAddArgumentPromotionPass(PM: PassManagerRef);\n-    fn LLVMAddTailCallEliminationPass(PM: PassManagerRef);\n-    fn LLVMAddIndVarSimplifyPass(PM: PassManagerRef);\n-    fn LLVMAddAggressiveDCEPass(PM: PassManagerRef);\n-    fn LLVMAddGlobalDCEPass(PM: PassManagerRef);\n-    fn LLVMAddCorrelatedValuePropagationPass(PM: PassManagerRef);\n-    fn LLVMAddPruneEHPass(PM: PassManagerRef);\n-    fn LLVMAddSimplifyLibCallsPass(PM: PassManagerRef);\n-    fn LLVMAddLoopIdiomPass(PM: PassManagerRef);\n-    fn LLVMAddEarlyCSEPass(PM: PassManagerRef);\n-    fn LLVMAddTypeBasedAliasAnalysisPass(PM: PassManagerRef);\n-    fn LLVMAddBasicAliasAnalysisPass(PM: PassManagerRef);\n-\n-    fn LLVMPassManagerBuilderCreate() -> PassManagerBuilderRef;\n-    fn LLVMPassManagerBuilderDispose(PMB: PassManagerBuilderRef);\n-    fn LLVMPassManagerBuilderSetOptLevel(PMB: PassManagerBuilderRef,\n+    unsafe fn LLVMAddVerifierPass(PM: PassManagerRef);\n+\n+    unsafe fn LLVMAddGlobalOptimizerPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddIPSCCPPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddDeadArgEliminationPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddInstructionCombiningPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddCFGSimplificationPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddFunctionInliningPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddFunctionAttrsPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddScalarReplAggregatesPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddScalarReplAggregatesPassSSA(PM: PassManagerRef);\n+    unsafe fn LLVMAddJumpThreadingPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddConstantPropagationPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddReassociatePass(PM: PassManagerRef);\n+    unsafe fn LLVMAddLoopRotatePass(PM: PassManagerRef);\n+    unsafe fn LLVMAddLICMPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddLoopUnswitchPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddLoopDeletionPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddLoopUnrollPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddGVNPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddMemCpyOptPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddSCCPPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddDeadStoreEliminationPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddStripDeadPrototypesPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddConstantMergePass(PM: PassManagerRef);\n+    unsafe fn LLVMAddArgumentPromotionPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddTailCallEliminationPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddIndVarSimplifyPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddAggressiveDCEPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddGlobalDCEPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddCorrelatedValuePropagationPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddPruneEHPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddSimplifyLibCallsPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddLoopIdiomPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddEarlyCSEPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddTypeBasedAliasAnalysisPass(PM: PassManagerRef);\n+    unsafe fn LLVMAddBasicAliasAnalysisPass(PM: PassManagerRef);\n+\n+    unsafe fn LLVMPassManagerBuilderCreate() -> PassManagerBuilderRef;\n+    unsafe fn LLVMPassManagerBuilderDispose(PMB: PassManagerBuilderRef);\n+    unsafe fn LLVMPassManagerBuilderSetOptLevel(PMB: PassManagerBuilderRef,\n                                          OptimizationLevel: c_uint);\n-    fn LLVMPassManagerBuilderSetSizeLevel(PMB: PassManagerBuilderRef,\n+    unsafe fn LLVMPassManagerBuilderSetSizeLevel(PMB: PassManagerBuilderRef,\n                                           Value: Bool);\n-    fn LLVMPassManagerBuilderSetDisableUnitAtATime(PMB: PassManagerBuilderRef,\n-                                                   Value: Bool);\n-    fn LLVMPassManagerBuilderSetDisableUnrollLoops(PMB: PassManagerBuilderRef,\n-                                                   Value: Bool);\n-    fn LLVMPassManagerBuilderSetDisableSimplifyLibCalls\n+    unsafe fn LLVMPassManagerBuilderSetDisableUnitAtATime(\n+        PMB: PassManagerBuilderRef, Value: Bool);\n+    unsafe fn LLVMPassManagerBuilderSetDisableUnrollLoops(\n+        PMB: PassManagerBuilderRef, Value: Bool);\n+    unsafe fn LLVMPassManagerBuilderSetDisableSimplifyLibCalls\n         (PMB: PassManagerBuilderRef, Value: Bool);\n-    fn LLVMPassManagerBuilderUseInlinerWithThreshold\n+    unsafe fn LLVMPassManagerBuilderUseInlinerWithThreshold\n         (PMB: PassManagerBuilderRef, threshold: c_uint);\n-    fn LLVMPassManagerBuilderPopulateModulePassManager\n+    unsafe fn LLVMPassManagerBuilderPopulateModulePassManager\n         (PMB: PassManagerBuilderRef, PM: PassManagerRef);\n \n-    fn LLVMPassManagerBuilderPopulateFunctionPassManager\n+    unsafe fn LLVMPassManagerBuilderPopulateFunctionPassManager\n         (PMB: PassManagerBuilderRef, PM: PassManagerRef);\n \n     /** Destroys a memory buffer. */\n-    fn LLVMDisposeMemoryBuffer(MemBuf: MemoryBufferRef);\n+    unsafe fn LLVMDisposeMemoryBuffer(MemBuf: MemoryBufferRef);\n \n \n     /* Stuff that's in rustllvm/ because it's not upstream yet. */\n \n     /** Opens an object file. */\n-    fn LLVMCreateObjectFile(MemBuf: MemoryBufferRef) -> ObjectFileRef;\n+    unsafe fn LLVMCreateObjectFile(MemBuf: MemoryBufferRef) -> ObjectFileRef;\n     /** Closes an object file. */\n-    fn LLVMDisposeObjectFile(ObjFile: ObjectFileRef);\n+    unsafe fn LLVMDisposeObjectFile(ObjFile: ObjectFileRef);\n \n     /** Enumerates the sections in an object file. */\n-    fn LLVMGetSections(ObjFile: ObjectFileRef) -> SectionIteratorRef;\n+    unsafe fn LLVMGetSections(ObjFile: ObjectFileRef) -> SectionIteratorRef;\n     /** Destroys a section iterator. */\n-    fn LLVMDisposeSectionIterator(SI: SectionIteratorRef);\n+    unsafe fn LLVMDisposeSectionIterator(SI: SectionIteratorRef);\n     /** Returns true if the section iterator is at the end of the section\n         list: */\n-    fn LLVMIsSectionIteratorAtEnd(ObjFile: ObjectFileRef,\n+    unsafe fn LLVMIsSectionIteratorAtEnd(ObjFile: ObjectFileRef,\n                                   SI: SectionIteratorRef) -> Bool;\n     /** Moves the section iterator to point to the next section. */\n-    fn LLVMMoveToNextSection(SI: SectionIteratorRef);\n+    unsafe fn LLVMMoveToNextSection(SI: SectionIteratorRef);\n     /** Returns the current section name. */\n-    fn LLVMGetSectionName(SI: SectionIteratorRef) -> *c_char;\n+    unsafe fn LLVMGetSectionName(SI: SectionIteratorRef) -> *c_char;\n     /** Returns the current section size. */\n-    fn LLVMGetSectionSize(SI: SectionIteratorRef) -> c_ulonglong;\n+    unsafe fn LLVMGetSectionSize(SI: SectionIteratorRef) -> c_ulonglong;\n     /** Returns the current section contents as a string buffer. */\n-    fn LLVMGetSectionContents(SI: SectionIteratorRef) -> *c_char;\n+    unsafe fn LLVMGetSectionContents(SI: SectionIteratorRef) -> *c_char;\n \n     /** Reads the given file and returns it as a memory buffer. Use\n         LLVMDisposeMemoryBuffer() to get rid of it. */\n-    fn LLVMRustCreateMemoryBufferWithContentsOfFile(Path: *c_char) ->\n+    unsafe fn LLVMRustCreateMemoryBufferWithContentsOfFile(Path: *c_char) ->\n        MemoryBufferRef;\n \n-    fn LLVMRustWriteOutputFile(PM: PassManagerRef, M: ModuleRef,\n+    unsafe fn LLVMRustWriteOutputFile(PM: PassManagerRef, M: ModuleRef,\n                                Triple: *c_char,\n                                // FIXME: When #2334 is fixed, change\n                                // c_uint to FileType\n@@ -1014,57 +1190,63 @@ extern mod llvm {\n \n     /** Returns a string describing the last error caused by an LLVMRust*\n         call. */\n-    fn LLVMRustGetLastError() -> *c_char;\n+    unsafe fn LLVMRustGetLastError() -> *c_char;\n \n     /** Prepare the JIT. Returns a memory manager that can load crates. */\n-    fn LLVMRustPrepareJIT(__morestack: *()) -> *();\n+    unsafe fn LLVMRustPrepareJIT(__morestack: *()) -> *();\n \n     /** Load a crate into the memory manager. */\n-    fn LLVMRustLoadCrate(MM: *(),\n+    unsafe fn LLVMRustLoadCrate(MM: *(),\n                          Filename: *c_char) -> bool;\n \n     /** Execute the JIT engine. */\n-    fn LLVMRustExecuteJIT(MM: *(),\n+    unsafe fn LLVMRustExecuteJIT(MM: *(),\n                           PM: PassManagerRef,\n                           M: ModuleRef,\n                           OptLevel: c_int,\n                           EnableSegmentedStacks: bool) -> *();\n \n     /** Parses the bitcode in the given memory buffer. */\n-    fn LLVMRustParseBitcode(MemBuf: MemoryBufferRef) -> ModuleRef;\n+    unsafe fn LLVMRustParseBitcode(MemBuf: MemoryBufferRef) -> ModuleRef;\n \n     /** Parses LLVM asm in the given file */\n-    fn LLVMRustParseAssemblyFile(Filename: *c_char) -> ModuleRef;\n+    unsafe fn LLVMRustParseAssemblyFile(Filename: *c_char) -> ModuleRef;\n \n-    fn LLVMRustAddPrintModulePass(PM: PassManagerRef, M: ModuleRef,\n+    unsafe fn LLVMRustAddPrintModulePass(PM: PassManagerRef, M: ModuleRef,\n                                   Output: *c_char);\n \n     /** Turn on LLVM pass-timing. */\n-    fn LLVMRustEnableTimePasses();\n+    unsafe fn LLVMRustEnableTimePasses();\n \n     /** Print the pass timings since static dtors aren't picking them up. */\n-    fn LLVMRustPrintPassTimings();\n+    unsafe fn LLVMRustPrintPassTimings();\n \n-    fn LLVMStructCreateNamed(C: ContextRef, Name: *c_char) -> TypeRef;\n+    unsafe fn LLVMStructCreateNamed(C: ContextRef, Name: *c_char) -> TypeRef;\n \n-    fn LLVMStructSetBody(StructTy: TypeRef, ElementTypes: *TypeRef,\n+    unsafe fn LLVMStructSetBody(StructTy: TypeRef, ElementTypes: *TypeRef,\n                          ElementCount: c_uint, Packed: Bool);\n \n-    fn LLVMConstNamedStruct(S: TypeRef, ConstantVals: *ValueRef,\n+    unsafe fn LLVMConstNamedStruct(S: TypeRef, ConstantVals: *ValueRef,\n                             Count: c_uint) -> ValueRef;\n \n     /** Enables LLVM debug output. */\n-    fn LLVMSetDebug(Enabled: c_int);\n+    unsafe fn LLVMSetDebug(Enabled: c_int);\n }\n \n fn SetInstructionCallConv(Instr: ValueRef, CC: CallConv) {\n-    llvm::LLVMSetInstructionCallConv(Instr, CC as c_uint);\n+    unsafe {\n+        llvm::LLVMSetInstructionCallConv(Instr, CC as c_uint);\n+    }\n }\n fn SetFunctionCallConv(Fn: ValueRef, CC: CallConv) {\n-    llvm::LLVMSetFunctionCallConv(Fn, CC as c_uint);\n+    unsafe {\n+        llvm::LLVMSetFunctionCallConv(Fn, CC as c_uint);\n+    }\n }\n fn SetLinkage(Global: ValueRef, Link: Linkage) {\n-    llvm::LLVMSetLinkage(Global, Link as c_uint);\n+    unsafe {\n+        llvm::LLVMSetLinkage(Global, Link as c_uint);\n+    }\n }\n \n /* Memory-managed object interface to type handles. */\n@@ -1097,108 +1279,117 @@ fn type_to_str(names: type_names, ty: TypeRef) -> ~str {\n \n fn type_to_str_inner(names: type_names, +outer0: ~[TypeRef], ty: TypeRef) ->\n    ~str {\n-    match type_has_name(names, ty) {\n-      option::Some(ref n) => return (/*bad*/copy *n),\n-      _ => {}\n-    }\n+    unsafe {\n+        match type_has_name(names, ty) {\n+          option::Some(ref n) => return (/*bad*/copy *n),\n+          _ => {}\n+        }\n \n-    // XXX: Bad copy.\n-    let outer = vec::append_one(copy outer0, ty);\n+        // XXX: Bad copy.\n+        let outer = vec::append_one(copy outer0, ty);\n \n-    let kind = llvm::LLVMGetTypeKind(ty);\n+        let kind = llvm::LLVMGetTypeKind(ty);\n \n-    fn tys_str(names: type_names, outer: ~[TypeRef],\n-               tys: ~[TypeRef]) -> ~str {\n-        let mut s: ~str = ~\"\";\n-        let mut first: bool = true;\n-        for tys.each |t| {\n-            if first { first = false; } else { s += ~\", \"; }\n-            s += type_to_str_inner(names, outer, *t);\n+        fn tys_str(names: type_names, outer: ~[TypeRef],\n+                   tys: ~[TypeRef]) -> ~str {\n+            let mut s: ~str = ~\"\";\n+            let mut first: bool = true;\n+            for tys.each |t| {\n+                if first { first = false; } else { s += ~\", \"; }\n+                s += type_to_str_inner(names, outer, *t);\n+            }\n+            return s;\n         }\n-        return s;\n-    }\n \n-    match kind {\n-      Void => return ~\"Void\",\n-      Half => return ~\"Half\",\n-      Float => return ~\"Float\",\n-      Double => return ~\"Double\",\n-      X86_FP80 => return ~\"X86_FP80\",\n-      FP128 => return ~\"FP128\",\n-      PPC_FP128 => return ~\"PPC_FP128\",\n-      Label => return ~\"Label\",\n-      Integer => {\n-        return ~\"i\" + int::str(llvm::LLVMGetIntTypeWidth(ty) as int);\n-      }\n-      Function => {\n-        let mut s = ~\"fn(\";\n-        let out_ty: TypeRef = llvm::LLVMGetReturnType(ty);\n-        let n_args = llvm::LLVMCountParamTypes(ty) as uint;\n-        let args = vec::from_elem(n_args, 0 as TypeRef);\n-        unsafe {\n-            llvm::LLVMGetParamTypes(ty, vec::raw::to_ptr(args));\n-        }\n-        s += tys_str(names, outer, args);\n-        s += ~\") -> \";\n-        s += type_to_str_inner(names, outer, out_ty);\n-        return s;\n-      }\n-      Struct => {\n-        let mut s: ~str = ~\"{\";\n-        let n_elts = llvm::LLVMCountStructElementTypes(ty) as uint;\n-        let mut elts = vec::from_elem(n_elts, 0 as TypeRef);\n-        llvm::LLVMGetStructElementTypes(ty,\n-                                        ptr::to_mut_unsafe_ptr(&mut elts[0]));\n-        s += tys_str(names, outer, elts);\n-        s += ~\"}\";\n-        return s;\n-      }\n-      Array => {\n-        let el_ty = llvm::LLVMGetElementType(ty);\n-        return ~\"[\" + type_to_str_inner(names, outer, el_ty) + ~\" x \" +\n-            uint::str(llvm::LLVMGetArrayLength(ty) as uint) + ~\"]\";\n-      }\n-      Pointer => {\n-        let mut i: uint = 0u;\n-        for outer0.each |tout| {\n-            i += 1u;\n-            if *tout as int == ty as int {\n-                let n: uint = vec::len::<TypeRef>(outer0) - i;\n-                return ~\"*\\\\\" + int::str(n as int);\n+        match kind {\n+          Void => return ~\"Void\",\n+          Half => return ~\"Half\",\n+          Float => return ~\"Float\",\n+          Double => return ~\"Double\",\n+          X86_FP80 => return ~\"X86_FP80\",\n+          FP128 => return ~\"FP128\",\n+          PPC_FP128 => return ~\"PPC_FP128\",\n+          Label => return ~\"Label\",\n+          Integer => {\n+            return ~\"i\" + int::str(llvm::LLVMGetIntTypeWidth(ty) as int);\n+          }\n+          Function => {\n+            let mut s = ~\"fn(\";\n+            let out_ty: TypeRef = llvm::LLVMGetReturnType(ty);\n+            let n_args = llvm::LLVMCountParamTypes(ty) as uint;\n+            let args = vec::from_elem(n_args, 0 as TypeRef);\n+            unsafe {\n+                llvm::LLVMGetParamTypes(ty, vec::raw::to_ptr(args));\n             }\n-        }\n-        let addrstr = {\n-            let addrspace = llvm::LLVMGetPointerAddressSpace(ty) as uint;\n-            if addrspace == 0u {\n-                ~\"\"\n-            } else {\n-                fmt!(\"addrspace(%u)\", addrspace)\n+            s += tys_str(names, outer, args);\n+            s += ~\") -> \";\n+            s += type_to_str_inner(names, outer, out_ty);\n+            return s;\n+          }\n+          Struct => {\n+            let mut s: ~str = ~\"{\";\n+            let n_elts = llvm::LLVMCountStructElementTypes(ty) as uint;\n+            let mut elts = vec::from_elem(n_elts, 0 as TypeRef);\n+            llvm::LLVMGetStructElementTypes(ty,\n+                                            ptr::to_mut_unsafe_ptr(\n+                                                &mut elts[0]));\n+            s += tys_str(names, outer, elts);\n+            s += ~\"}\";\n+            return s;\n+          }\n+          Array => {\n+            let el_ty = llvm::LLVMGetElementType(ty);\n+            return ~\"[\" + type_to_str_inner(names, outer, el_ty) + ~\" x \" +\n+                uint::str(llvm::LLVMGetArrayLength(ty) as uint) + ~\"]\";\n+          }\n+          Pointer => {\n+            let mut i: uint = 0u;\n+            for outer0.each |tout| {\n+                i += 1u;\n+                if *tout as int == ty as int {\n+                    let n: uint = vec::len::<TypeRef>(outer0) - i;\n+                    return ~\"*\\\\\" + int::str(n as int);\n+                }\n             }\n-        };\n-        return addrstr + ~\"*\" +\n-                type_to_str_inner(names, outer, llvm::LLVMGetElementType(ty));\n-      }\n-      Vector => return ~\"Vector\",\n-      Metadata => return ~\"Metadata\",\n-      X86_MMX => return ~\"X86_MMAX\"\n+            let addrstr = {\n+                let addrspace = llvm::LLVMGetPointerAddressSpace(ty) as uint;\n+                if addrspace == 0u {\n+                    ~\"\"\n+                } else {\n+                    fmt!(\"addrspace(%u)\", addrspace)\n+                }\n+            };\n+            return addrstr + ~\"*\" +\n+                    type_to_str_inner(names,\n+                                      outer,\n+                                      llvm::LLVMGetElementType(ty));\n+          }\n+          Vector => return ~\"Vector\",\n+          Metadata => return ~\"Metadata\",\n+          X86_MMX => return ~\"X86_MMAX\"\n+        }\n     }\n }\n \n fn float_width(llt: TypeRef) -> uint {\n-    return match llvm::LLVMGetTypeKind(llt) as int {\n-          1 => 32u,\n-          2 => 64u,\n-          3 => 80u,\n-          4 | 5 => 128u,\n-          _ => fail ~\"llvm_float_width called on a non-float type\"\n-        };\n+    unsafe {\n+        return match llvm::LLVMGetTypeKind(llt) as int {\n+              1 => 32u,\n+              2 => 64u,\n+              3 => 80u,\n+              4 | 5 => 128u,\n+              _ => fail ~\"llvm_float_width called on a non-float type\"\n+            };\n+    }\n }\n \n fn fn_ty_param_tys(fn_ty: TypeRef) -> ~[TypeRef] unsafe {\n-    let args = vec::from_elem(llvm::LLVMCountParamTypes(fn_ty) as uint,\n-                             0 as TypeRef);\n-    llvm::LLVMGetParamTypes(fn_ty, vec::raw::to_ptr(args));\n-    return args;\n+    unsafe {\n+        let args = vec::from_elem(llvm::LLVMCountParamTypes(fn_ty) as uint,\n+                                 0 as TypeRef);\n+        llvm::LLVMGetParamTypes(fn_ty, vec::raw::to_ptr(args));\n+        return args;\n+    }\n }\n \n fn struct_element_types(struct_ty: TypeRef) -> ~[TypeRef] {\n@@ -1218,7 +1409,11 @@ fn struct_element_types(struct_ty: TypeRef) -> ~[TypeRef] {\n \n struct target_data_res {\n     TD: TargetDataRef,\n-    drop { llvm::LLVMDisposeTargetData(self.TD); }\n+    drop {\n+        unsafe {\n+            llvm::LLVMDisposeTargetData(self.TD);\n+        }\n+    }\n }\n \n fn target_data_res(TD: TargetDataRef) -> target_data_res {\n@@ -1231,15 +1426,21 @@ type target_data = {lltd: TargetDataRef, dtor: @target_data_res};\n \n fn mk_target_data(string_rep: ~str) -> target_data {\n     let lltd =\n-        str::as_c_str(string_rep, |buf| llvm::LLVMCreateTargetData(buf) );\n+        str::as_c_str(string_rep, |buf| unsafe {\n+            llvm::LLVMCreateTargetData(buf)\n+        });\n     return {lltd: lltd, dtor: @target_data_res(lltd)};\n }\n \n /* Memory-managed interface to pass managers. */\n \n struct pass_manager_res {\n     PM: PassManagerRef,\n-    drop { llvm::LLVMDisposePassManager(self.PM); }\n+    drop {\n+        unsafe {\n+            llvm::LLVMDisposePassManager(self.PM);\n+        }\n+    }\n }\n \n fn pass_manager_res(PM: PassManagerRef) -> pass_manager_res {\n@@ -1251,15 +1452,21 @@ fn pass_manager_res(PM: PassManagerRef) -> pass_manager_res {\n type pass_manager = {llpm: PassManagerRef, dtor: @pass_manager_res};\n \n fn mk_pass_manager() -> pass_manager {\n-    let llpm = llvm::LLVMCreatePassManager();\n-    return {llpm: llpm, dtor: @pass_manager_res(llpm)};\n+    unsafe {\n+        let llpm = llvm::LLVMCreatePassManager();\n+        return {llpm: llpm, dtor: @pass_manager_res(llpm)};\n+    }\n }\n \n /* Memory-managed interface to object files. */\n \n struct object_file_res {\n     ObjectFile: ObjectFileRef,\n-    drop { llvm::LLVMDisposeObjectFile(self.ObjectFile); }\n+    drop {\n+        unsafe {\n+            llvm::LLVMDisposeObjectFile(self.ObjectFile);\n+        }\n+    }\n }\n \n fn object_file_res(ObjFile: ObjectFileRef) -> object_file_res {\n@@ -1271,16 +1478,22 @@ fn object_file_res(ObjFile: ObjectFileRef) -> object_file_res {\n type object_file = {llof: ObjectFileRef, dtor: @object_file_res};\n \n fn mk_object_file(llmb: MemoryBufferRef) -> Option<object_file> {\n-    let llof = llvm::LLVMCreateObjectFile(llmb);\n-    if llof as int == 0 { return option::None::<object_file>; }\n-    return option::Some({llof: llof, dtor: @object_file_res(llof)});\n+    unsafe {\n+        let llof = llvm::LLVMCreateObjectFile(llmb);\n+        if llof as int == 0 { return option::None::<object_file>; }\n+        return option::Some({llof: llof, dtor: @object_file_res(llof)});\n+    }\n }\n \n /* Memory-managed interface to section iterators. */\n \n struct section_iter_res {\n     SI: SectionIteratorRef,\n-    drop { llvm::LLVMDisposeSectionIterator(self.SI); }\n+    drop {\n+        unsafe {\n+            llvm::LLVMDisposeSectionIterator(self.SI);\n+        }\n+    }\n }\n \n fn section_iter_res(SI: SectionIteratorRef) -> section_iter_res {\n@@ -1292,8 +1505,10 @@ fn section_iter_res(SI: SectionIteratorRef) -> section_iter_res {\n type section_iter = {llsi: SectionIteratorRef, dtor: @section_iter_res};\n \n fn mk_section_iter(llof: ObjectFileRef) -> section_iter {\n-    let llsi = llvm::LLVMGetSections(llof);\n-    return {llsi: llsi, dtor: @section_iter_res(llsi)};\n+    unsafe {\n+        let llsi = llvm::LLVMGetSections(llof);\n+        return {llsi: llsi, dtor: @section_iter_res(llsi)};\n+    }\n }\n \n //"}, {"sha": "cc2a0ebcbd79c65759f637abbad987fa53aa10dd", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -1395,8 +1395,10 @@ fn compile_submatch(bcx: block,\n               switch => {\n                   match trans_opt(bcx, opt) {\n                       single_result(r) => {\n+                        unsafe {\n                           llvm::LLVMAddCase(sw, r.val, opt_cx.llbb);\n                           bcx = r.bcx;\n+                        }\n                       }\n                       _ => {\n                           bcx.sess().bug("}, {"sha": "c543b52889ccc9fb409ab0b1e96d70fb7ce364d4", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 359, "deletions": 248, "changes": 607, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -138,9 +138,13 @@ fn log_fn_time(ccx: @crate_ctxt, +name: ~str, start: time::Timespec,\n fn decl_fn(llmod: ModuleRef, name: ~str, cc: lib::llvm::CallConv,\n            llty: TypeRef) -> ValueRef {\n     let llfn: ValueRef = str::as_c_str(name, |buf| {\n-        llvm::LLVMGetOrInsertFunction(llmod, buf, llty)\n+        unsafe {\n+            llvm::LLVMGetOrInsertFunction(llmod, buf, llty)\n+        }\n     });\n-    lib::llvm::SetFunctionCallConv(llfn, cc);\n+    unsafe {\n+        lib::llvm::SetFunctionCallConv(llfn, cc);\n+    }\n     return llfn;\n }\n \n@@ -172,11 +176,15 @@ fn get_extern_fn(externs: HashMap<~str, ValueRef>,\n \n fn get_extern_const(externs: HashMap<~str, ValueRef>, llmod: ModuleRef,\n                     +name: ~str, ty: TypeRef) -> ValueRef {\n-    // XXX: Bad copy.\n-    if externs.contains_key(copy name) { return externs.get(name); }\n-    let c = str::as_c_str(name, |buf| llvm::LLVMAddGlobal(llmod, ty, buf));\n-    externs.insert(name, c);\n-    return c;\n+    unsafe {\n+        // XXX: Bad copy.\n+        if externs.contains_key(copy name) { return externs.get(name); }\n+        let c = str::as_c_str(name, |buf| {\n+            llvm::LLVMAddGlobal(llmod, ty, buf)\n+        });\n+        externs.insert(name, c);\n+        return c;\n+    }\n }\n \n fn get_simple_extern_fn(cx: block,\n@@ -314,12 +322,14 @@ fn malloc_raw_dyn(bcx: block,\n * wrong address space and thus be the wrong type.\n */\n fn non_gc_box_cast(bcx: block, val: ValueRef) -> ValueRef {\n-    debug!(\"non_gc_box_cast\");\n-    add_comment(bcx, ~\"non_gc_box_cast\");\n-    assert(llvm::LLVMGetPointerAddressSpace(val_ty(val)) == gc_box_addrspace\n-           || bcx.unreachable);\n-    let non_gc_t = T_ptr(llvm::LLVMGetElementType(val_ty(val)));\n-    PointerCast(bcx, val, non_gc_t)\n+    unsafe {\n+        debug!(\"non_gc_box_cast\");\n+        add_comment(bcx, ~\"non_gc_box_cast\");\n+        assert(llvm::LLVMGetPointerAddressSpace(val_ty(val)) ==\n+                gc_box_addrspace || bcx.unreachable);\n+        let non_gc_t = T_ptr(llvm::LLVMGetElementType(val_ty(val)));\n+        PointerCast(bcx, val, non_gc_t)\n+    }\n }\n \n // malloc_raw: expects an unboxed type and returns a pointer to\n@@ -373,25 +383,36 @@ fn get_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n }\n \n fn set_no_inline(f: ValueRef) {\n-    llvm::LLVMAddFunctionAttr(f, lib::llvm::NoInlineAttribute as c_ulonglong,\n-                              0u as c_ulonglong);\n+    unsafe {\n+        llvm::LLVMAddFunctionAttr(f,\n+                                  lib::llvm::NoInlineAttribute as c_ulonglong,\n+                                  0u as c_ulonglong);\n+    }\n }\n \n fn set_no_unwind(f: ValueRef) {\n-    llvm::LLVMAddFunctionAttr(f, lib::llvm::NoUnwindAttribute as c_ulonglong,\n-                              0u as c_ulonglong);\n+    unsafe {\n+        llvm::LLVMAddFunctionAttr(f,\n+                                  lib::llvm::NoUnwindAttribute as c_ulonglong,\n+                                  0u as c_ulonglong);\n+    }\n }\n \n // Tell LLVM to emit the information necessary to unwind the stack for the\n // function f.\n fn set_uwtable(f: ValueRef) {\n-    llvm::LLVMAddFunctionAttr(f, lib::llvm::UWTableAttribute as c_ulonglong,\n-                              0u as c_ulonglong);\n+    unsafe {\n+        llvm::LLVMAddFunctionAttr(f,\n+                                  lib::llvm::UWTableAttribute as c_ulonglong,\n+                                  0u as c_ulonglong);\n+    }\n }\n \n fn set_inline_hint(f: ValueRef) {\n-    llvm::LLVMAddFunctionAttr(f, lib::llvm::InlineHintAttribute\n-                              as c_ulonglong, 0u as c_ulonglong);\n+    unsafe {\n+        llvm::LLVMAddFunctionAttr(f, lib::llvm::InlineHintAttribute\n+                                  as c_ulonglong, 0u as c_ulonglong);\n+    }\n }\n \n fn set_inline_hint_if_appr(attrs: ~[ast::attribute],\n@@ -405,12 +426,16 @@ fn set_inline_hint_if_appr(attrs: ~[ast::attribute],\n }\n \n fn set_always_inline(f: ValueRef) {\n-    llvm::LLVMAddFunctionAttr(f, lib::llvm::AlwaysInlineAttribute\n-                              as c_ulonglong, 0u as c_ulonglong);\n+    unsafe {\n+        llvm::LLVMAddFunctionAttr(f, lib::llvm::AlwaysInlineAttribute\n+                                  as c_ulonglong, 0u as c_ulonglong);\n+    }\n }\n \n fn set_custom_stack_growth_fn(f: ValueRef) {\n-    llvm::LLVMAddFunctionAttr(f, 0u as c_ulonglong, 1u as c_ulonglong);\n+    unsafe {\n+        llvm::LLVMAddFunctionAttr(f, 0u as c_ulonglong, 1u as c_ulonglong);\n+    }\n }\n \n fn set_glue_inlining(f: ValueRef, t: ty::t) {\n@@ -456,7 +481,11 @@ fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id,\n // Structural comparison: a rather involved form of glue.\n fn maybe_name_value(cx: @crate_ctxt, v: ValueRef, s: ~str) {\n     if cx.sess.opts.save_temps {\n-        let _: () = str::as_c_str(s, |buf| llvm::LLVMSetValueName(v, buf));\n+        let _: () = str::as_c_str(s, |buf| {\n+            unsafe {\n+                llvm::LLVMSetValueName(v, buf)\n+            }\n+        });\n     }\n }\n \n@@ -670,8 +699,11 @@ fn cast_shift_expr_rhs(cx: block, op: ast::binop,\n \n fn cast_shift_const_rhs(op: ast::binop,\n                         lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    cast_shift_rhs(op, lhs, rhs,\n-                   llvm::LLVMConstTrunc, llvm::LLVMConstZExt)\n+    unsafe {\n+        cast_shift_rhs(op, lhs, rhs,\n+                       |a, b| unsafe { llvm::LLVMConstTrunc(a, b) },\n+                       |a, b| unsafe { llvm::LLVMConstZExt(a, b) })\n+    }\n }\n \n fn cast_shift_rhs(op: ast::binop,\n@@ -680,22 +712,24 @@ fn cast_shift_rhs(op: ast::binop,\n                   zext: fn(ValueRef, TypeRef) -> ValueRef\n                  ) -> ValueRef {\n     // Shifts may have any size int on the rhs\n-    if ast_util::is_shift_binop(op) {\n-        let rhs_llty = val_ty(rhs);\n-        let lhs_llty = val_ty(lhs);\n-        let rhs_sz = llvm::LLVMGetIntTypeWidth(rhs_llty);\n-        let lhs_sz = llvm::LLVMGetIntTypeWidth(lhs_llty);\n-        if lhs_sz < rhs_sz {\n-            trunc(rhs, lhs_llty)\n-        } else if lhs_sz > rhs_sz {\n-            // FIXME (#1877: If shifting by negative\n-            // values becomes not undefined then this is wrong.\n-            zext(rhs, lhs_llty)\n+    unsafe {\n+        if ast_util::is_shift_binop(op) {\n+            let rhs_llty = val_ty(rhs);\n+            let lhs_llty = val_ty(lhs);\n+            let rhs_sz = llvm::LLVMGetIntTypeWidth(rhs_llty);\n+            let lhs_sz = llvm::LLVMGetIntTypeWidth(lhs_llty);\n+            if lhs_sz < rhs_sz {\n+                trunc(rhs, lhs_llty)\n+            } else if lhs_sz > rhs_sz {\n+                // FIXME (#1877: If shifting by negative\n+                // values becomes not undefined then this is wrong.\n+                zext(rhs, lhs_llty)\n+            } else {\n+                rhs\n+            }\n         } else {\n             rhs\n         }\n-    } else {\n-        rhs\n     }\n }\n \n@@ -746,21 +780,23 @@ fn trans_external_path(ccx: @crate_ctxt, did: ast::def_id, t: ty::t)\n }\n \n fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n-    let _icx = ccx.insn_ctxt(\"lookup_discriminant\");\n-    match ccx.discrims.find(vid) {\n-      None => {\n-        // It's an external discriminant that we haven't seen yet.\n-        assert (vid.crate != ast::local_crate);\n-        let sym = csearch::get_symbol(ccx.sess.cstore, vid);\n-        let gvar = str::as_c_str(sym, |buf| {\n-            llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n-        });\n-        lib::llvm::SetLinkage(gvar, lib::llvm::ExternalLinkage);\n-        llvm::LLVMSetGlobalConstant(gvar, True);\n-        ccx.discrims.insert(vid, gvar);\n-        return gvar;\n-      }\n-      Some(llval) => return llval,\n+    unsafe {\n+        let _icx = ccx.insn_ctxt(\"lookup_discriminant\");\n+        match ccx.discrims.find(vid) {\n+            None => {\n+                // It's an external discriminant that we haven't seen yet.\n+                assert (vid.crate != ast::local_crate);\n+                let sym = csearch::get_symbol(ccx.sess.cstore, vid);\n+                let gvar = str::as_c_str(sym, |buf| {\n+                    llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n+                });\n+                lib::llvm::SetLinkage(gvar, lib::llvm::ExternalLinkage);\n+                llvm::LLVMSetGlobalConstant(gvar, True);\n+                ccx.discrims.insert(vid, gvar);\n+                return gvar;\n+            }\n+            Some(llval) => return llval,\n+        }\n     }\n }\n \n@@ -1094,15 +1130,24 @@ fn new_block(cx: fn_ctxt, parent: Option<block>, +kind: block_kind,\n \n     let s = if cx.ccx.sess.opts.save_temps || cx.ccx.sess.opts.debuginfo {\n         (cx.ccx.names)(name)\n-    } else { special_idents::invalid };\n-    let llbb: BasicBlockRef = str::as_c_str(cx.ccx.sess.str_of(s), |buf| {\n-        llvm::LLVMAppendBasicBlock(cx.llfn, buf)\n-    });\n-    let bcx = mk_block(llbb, parent, move kind, is_lpad, opt_node_info, cx);\n-    do option::iter(&parent) |cx| {\n-        if cx.unreachable { Unreachable(bcx); }\n+    } else {\n+        special_idents::invalid\n     };\n-    return bcx;\n+    unsafe {\n+        let llbb: BasicBlockRef = str::as_c_str(cx.ccx.sess.str_of(s), |buf| {\n+            llvm::LLVMAppendBasicBlock(cx.llfn, buf)\n+        });\n+        let bcx = mk_block(llbb,\n+                           parent,\n+                           move kind,\n+                           is_lpad,\n+                           opt_node_info,\n+                           cx);\n+        do option::iter(&parent) |cx| {\n+            if cx.unreachable { Unreachable(bcx); }\n+        };\n+        return bcx;\n+    }\n }\n \n fn simple_block_scope() -> block_kind {\n@@ -1317,7 +1362,9 @@ fn alloc_local(cx: block, local: @ast::local) -> block {\n     if cx.sess().opts.debuginfo {\n         do option::iter(&simple_name) |name| {\n             str::as_c_str(cx.ccx().sess.str_of(*name), |buf| {\n-                llvm::LLVMSetValueName(val, buf)\n+                unsafe {\n+                    llvm::LLVMSetValueName(val, buf)\n+                }\n             });\n         }\n     }\n@@ -1424,7 +1471,11 @@ fn alloca_zeroed(cx: block, t: TypeRef) -> ValueRef {\n \n fn alloca_maybe_zeroed(cx: block, t: TypeRef, zero: bool) -> ValueRef {\n     let _icx = cx.insn_ctxt(\"alloca\");\n-    if cx.unreachable { return llvm::LLVMGetUndef(t); }\n+    if cx.unreachable {\n+        unsafe {\n+            return llvm::LLVMGetUndef(t);\n+        }\n+    }\n     let initcx = base::raw_block(cx.fcx, false, cx.fcx.llstaticallocas);\n     let p = Alloca(initcx, t);\n     if zero { memzero(initcx, p, t); }\n@@ -1433,18 +1484,24 @@ fn alloca_maybe_zeroed(cx: block, t: TypeRef, zero: bool) -> ValueRef {\n \n fn arrayalloca(cx: block, t: TypeRef, v: ValueRef) -> ValueRef {\n     let _icx = cx.insn_ctxt(\"arrayalloca\");\n-    if cx.unreachable { return llvm::LLVMGetUndef(t); }\n+    if cx.unreachable {\n+        unsafe {\n+            return llvm::LLVMGetUndef(t);\n+        }\n+    }\n     return ArrayAlloca(\n         base::raw_block(cx.fcx, false, cx.fcx.llstaticallocas), t, v);\n }\n \n // Creates the standard set of basic blocks for a function\n fn mk_standard_basic_blocks(llfn: ValueRef) ->\n    {sa: BasicBlockRef, rt: BasicBlockRef} {\n-    {sa: str::as_c_str(~\"static_allocas\",\n-                       |buf| llvm::LLVMAppendBasicBlock(llfn, buf)),\n-     rt: str::as_c_str(~\"return\",\n-                       |buf| llvm::LLVMAppendBasicBlock(llfn, buf))}\n+    unsafe {\n+        {sa: str::as_c_str(~\"static_allocas\",\n+                           |buf| llvm::LLVMAppendBasicBlock(llfn, buf)),\n+         rt: str::as_c_str(~\"return\",\n+                           |buf| llvm::LLVMAppendBasicBlock(llfn, buf))}\n+    }\n }\n \n \n@@ -1464,8 +1521,8 @@ fn new_fn_ctxt_w_id(ccx: @crate_ctxt,\n     let llbbs = mk_standard_basic_blocks(llfndecl);\n     return @fn_ctxt_ {\n           llfn: llfndecl,\n-          llenv: llvm::LLVMGetParam(llfndecl, 1u as c_uint),\n-          llretptr: llvm::LLVMGetParam(llfndecl, 0u as c_uint),\n+          llenv: unsafe { llvm::LLVMGetParam(llfndecl, 1u as c_uint) },\n+          llretptr: unsafe { llvm::LLVMGetParam(llfndecl, 0u as c_uint) },\n           mut llstaticallocas: llbbs.sa,\n           mut llloadenv: None,\n           mut llreturn: llbbs.rt,\n@@ -1532,8 +1589,10 @@ fn create_llargs_for_fn_args(cx: fn_ctxt,\n     // Return an array containing the ValueRefs that we get from\n     // llvm::LLVMGetParam for each argument.\n     vec::from_fn(args.len(), |i| {\n-        let arg_n = first_real_arg + i;\n-        llvm::LLVMGetParam(cx.llfn, arg_n as c_uint)\n+        unsafe {\n+            let arg_n = first_real_arg + i;\n+            llvm::LLVMGetParam(cx.llfn, arg_n as c_uint)\n+        }\n     })\n }\n \n@@ -1664,7 +1723,9 @@ fn trans_closure(ccx: @crate_ctxt,\n     // Set GC for function.\n     if ccx.sess.opts.gc {\n         do str::as_c_str(\"generic\") |strategy| {\n-            llvm::LLVMSetGC(fcx.llfn, strategy);\n+            unsafe {\n+                llvm::LLVMSetGC(fcx.llfn, strategy);\n+            }\n         }\n         ccx.uses_gc = true;\n     }\n@@ -2085,8 +2146,8 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef) {\n         let lltop = bcx.llbb;\n \n         // Call main.\n-        let lloutputarg = llvm::LLVMGetParam(llfdecl, 0 as c_uint);\n-        let llenvarg = llvm::LLVMGetParam(llfdecl, 1 as c_uint);\n+        let lloutputarg = unsafe { llvm::LLVMGetParam(llfdecl, 0 as c_uint) };\n+        let llenvarg = unsafe { llvm::LLVMGetParam(llfdecl, 1 as c_uint) };\n         let mut args = ~[lloutputarg, llenvarg];\n         Call(bcx, main_llfn, args);\n \n@@ -2103,22 +2164,34 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef) {\n         let llfty = T_fn(~[ccx.int_type, ccx.int_type], ccx.int_type);\n         let llfn = decl_cdecl_fn(ccx.llmod, main_name(), llfty);\n         let llbb = str::as_c_str(~\"top\", |buf| {\n-            llvm::LLVMAppendBasicBlock(llfn, buf)\n+            unsafe {\n+                llvm::LLVMAppendBasicBlock(llfn, buf)\n+            }\n         });\n         let bld = ccx.builder.B;\n-        llvm::LLVMPositionBuilderAtEnd(bld, llbb);\n+        unsafe {\n+            llvm::LLVMPositionBuilderAtEnd(bld, llbb);\n+        }\n         let crate_map = ccx.crate_map;\n         let start_ty = T_fn(~[val_ty(rust_main), ccx.int_type, ccx.int_type,\n                              val_ty(crate_map)], ccx.int_type);\n         let start = decl_cdecl_fn(ccx.llmod, ~\"rust_start\", start_ty);\n \n-        let args = ~[rust_main, llvm::LLVMGetParam(llfn, 0 as c_uint),\n-                    llvm::LLVMGetParam(llfn, 1 as c_uint), crate_map];\n+        let args = unsafe {\n+            ~[\n+                rust_main,\n+                llvm::LLVMGetParam(llfn, 0 as c_uint),\n+                llvm::LLVMGetParam(llfn, 1 as c_uint),\n+                crate_map\n+            ]\n+        };\n         let result = unsafe {\n             llvm::LLVMBuildCall(bld, start, vec::raw::to_ptr(args),\n                                 args.len() as c_uint, noname())\n         };\n-        llvm::LLVMBuildRet(bld, result);\n+        unsafe {\n+            llvm::LLVMBuildRet(bld, result);\n+        }\n     }\n }\n \n@@ -2199,7 +2272,9 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n                 let typ = ty::node_id_to_type(ccx.tcx, i.id);\n                 let s = mangle_exported_name(ccx, my_path, typ);\n                 let g = str::as_c_str(s, |buf| {\n-                    llvm::LLVMAddGlobal(ccx.llmod, type_of(ccx, typ), buf)\n+                    unsafe {\n+                        llvm::LLVMAddGlobal(ccx.llmod, type_of(ccx, typ), buf)\n+                    }\n                 });\n                 ccx.item_symbols.insert(i.id, s);\n                 g\n@@ -2246,7 +2321,11 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n                     let typ = ty::node_id_to_type(ccx.tcx, ni.id);\n                     let ident = ccx.sess.parse_sess.interner.get(ni.ident);\n                     let g = do str::as_c_str(*ident) |buf| {\n-                        llvm::LLVMAddGlobal(ccx.llmod, type_of(ccx, typ), buf)\n+                        unsafe {\n+                            llvm::LLVMAddGlobal(ccx.llmod,\n+                                                type_of(ccx, typ),\n+                                                buf)\n+                        }\n                     };\n                     g\n                 }\n@@ -2262,9 +2341,13 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n             let class_ty = ty::lookup_item_type(tcx, parent_id).ty;\n             // This code shouldn't be reached if the class is generic\n             assert !ty::type_has_params(class_ty);\n-            let lldty = T_fn(~[T_ptr(type_of(ccx, ty::mk_nil(tcx))),\n-                    T_ptr(type_of(ccx, class_ty))],\n-                                   llvm::LLVMVoidType());\n+            let lldty = unsafe {\n+                T_fn(~[\n+                    T_ptr(type_of(ccx, ty::mk_nil(tcx))),\n+                    T_ptr(type_of(ccx, class_ty))\n+                ],\n+                llvm::LLVMVoidType())\n+            };\n             let s = get_dtor_symbol(ccx, /*bad*/copy *pt, dt.node.id, None);\n \n             /* Make the declaration for the dtor */\n@@ -2357,10 +2440,14 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n             // XXX: Bad copy.\n             note_unique_llvm_symbol(ccx, copy s);\n             let discrim_gvar = str::as_c_str(s, |buf| {\n-                llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n+                unsafe {\n+                    llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n+                }\n             });\n-            llvm::LLVMSetInitializer(discrim_gvar, C_int(ccx, disr_val));\n-            llvm::LLVMSetGlobalConstant(discrim_gvar, True);\n+            unsafe {\n+                llvm::LLVMSetInitializer(discrim_gvar, C_int(ccx, disr_val));\n+                llvm::LLVMSetGlobalConstant(discrim_gvar, True);\n+            }\n             ccx.discrims.insert(\n                 local_def(variant.node.id), discrim_gvar);\n             ccx.discrim_symbols.insert(variant.node.id, s);\n@@ -2386,7 +2473,9 @@ fn vp2i(cx: block, v: ValueRef) -> ValueRef {\n }\n \n fn p2i(ccx: @crate_ctxt, v: ValueRef) -> ValueRef {\n-    return llvm::LLVMConstPtrToInt(v, ccx.int_type);\n+    unsafe {\n+        return llvm::LLVMConstPtrToInt(v, ccx.int_type);\n+    }\n }\n \n fn declare_intrinsics(llmod: ModuleRef) -> HashMap<~str, ValueRef> {\n@@ -2602,20 +2691,28 @@ fn decl_gc_metadata(ccx: @crate_ctxt, llmod_id: ~str) {\n \n     let gc_metadata_name = ~\"_gc_module_metadata_\" + llmod_id;\n     let gc_metadata = do str::as_c_str(gc_metadata_name) |buf| {\n-        llvm::LLVMAddGlobal(ccx.llmod, T_i32(), buf)\n+        unsafe {\n+            llvm::LLVMAddGlobal(ccx.llmod, T_i32(), buf)\n+        }\n     };\n-    llvm::LLVMSetGlobalConstant(gc_metadata, True);\n-    lib::llvm::SetLinkage(gc_metadata, lib::llvm::ExternalLinkage);\n-    ccx.module_data.insert(~\"_gc_module_metadata\", gc_metadata);\n+    unsafe {\n+        llvm::LLVMSetGlobalConstant(gc_metadata, True);\n+        lib::llvm::SetLinkage(gc_metadata, lib::llvm::ExternalLinkage);\n+        ccx.module_data.insert(~\"_gc_module_metadata\", gc_metadata);\n+    }\n }\n \n fn create_module_map(ccx: @crate_ctxt) -> ValueRef {\n     let elttype = T_struct(~[ccx.int_type, ccx.int_type]);\n     let maptype = T_array(elttype, ccx.module_data.size() + 1u);\n     let map = str::as_c_str(~\"_rust_mod_map\", |buf| {\n-        llvm::LLVMAddGlobal(ccx.llmod, maptype, buf)\n+        unsafe {\n+            llvm::LLVMAddGlobal(ccx.llmod, maptype, buf)\n+        }\n     });\n-    lib::llvm::SetLinkage(map, lib::llvm::InternalLinkage);\n+    unsafe {\n+        lib::llvm::SetLinkage(map, lib::llvm::InternalLinkage);\n+    }\n     let mut elts: ~[ValueRef] = ~[];\n     for ccx.module_data.each |key, val| {\n         let elt = C_struct(~[p2i(ccx, C_cstr(ccx, key)),\n@@ -2624,7 +2721,9 @@ fn create_module_map(ccx: @crate_ctxt) -> ValueRef {\n     }\n     let term = C_struct(~[C_int(ccx, 0), C_int(ccx, 0)]);\n     elts.push(term);\n-    llvm::LLVMSetInitializer(map, C_array(elttype, elts));\n+    unsafe {\n+        llvm::LLVMSetInitializer(map, C_array(elttype, elts));\n+    }\n     return map;\n }\n \n@@ -2643,7 +2742,9 @@ fn decl_crate_map(sess: session::Session, mapmeta: link_meta,\n     let arrtype = T_array(int_type, n_subcrates as uint);\n     let maptype = T_struct(~[T_i32(), T_ptr(T_i8()), int_type, arrtype]);\n     let map = str::as_c_str(sym_name, |buf| {\n-        llvm::LLVMAddGlobal(llmod, maptype, buf)\n+        unsafe {\n+            llvm::LLVMAddGlobal(llmod, maptype, buf)\n+        }\n     });\n     lib::llvm::SetLinkage(map, lib::llvm::ExternalLinkage);\n     return map;\n@@ -2659,7 +2760,9 @@ fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n             ~\"_\" + cstore::get_crate_vers(cstore, i) +\n             ~\"_\" + cstore::get_crate_hash(cstore, i);\n         let cr = str::as_c_str(nm, |buf| {\n-            llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n+            unsafe {\n+                llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n+            }\n         });\n         subcrates.push(p2i(ccx, cr));\n         i += 1;\n@@ -2678,12 +2781,14 @@ fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n                                              annihilate_fn_type);\n     }\n \n-    llvm::LLVMSetInitializer(map, C_struct(\n-        ~[C_i32(1),\n-          lib::llvm::llvm::LLVMConstPointerCast(llannihilatefn,\n-                                                T_ptr(T_i8())),\n-          p2i(ccx, create_module_map(ccx)),\n-          C_array(ccx.int_type, subcrates)]));\n+    unsafe {\n+        llvm::LLVMSetInitializer(map, C_struct(\n+            ~[C_i32(1),\n+              lib::llvm::llvm::LLVMConstPointerCast(llannihilatefn,\n+                                                    T_ptr(T_i8())),\n+              p2i(ccx, create_module_map(ccx)),\n+              C_array(ccx.int_type, subcrates)]));\n+    }\n }\n \n fn crate_ctxt_to_encode_parms(cx: @crate_ctxt) -> encoder::encode_parms {\n@@ -2710,21 +2815,25 @@ fn write_metadata(cx: @crate_ctxt, crate: @ast::crate) {\n     let llmeta = C_bytes(encoder::encode_metadata(encode_parms, crate));\n     let llconst = C_struct(~[llmeta]);\n     let mut llglobal = str::as_c_str(~\"rust_metadata\", |buf| {\n-        llvm::LLVMAddGlobal(cx.llmod, val_ty(llconst), buf)\n-    });\n-    llvm::LLVMSetInitializer(llglobal, llconst);\n-    str::as_c_str(cx.sess.targ_cfg.target_strs.meta_sect_name, |buf| {\n-        llvm::LLVMSetSection(llglobal, buf)\n+        unsafe {\n+            llvm::LLVMAddGlobal(cx.llmod, val_ty(llconst), buf)\n+        }\n     });\n-    lib::llvm::SetLinkage(llglobal, lib::llvm::InternalLinkage);\n+    unsafe {\n+        llvm::LLVMSetInitializer(llglobal, llconst);\n+        str::as_c_str(cx.sess.targ_cfg.target_strs.meta_sect_name, |buf| {\n+            llvm::LLVMSetSection(llglobal, buf)\n+        });\n+        lib::llvm::SetLinkage(llglobal, lib::llvm::InternalLinkage);\n \n-    let t_ptr_i8 = T_ptr(T_i8());\n-    llglobal = llvm::LLVMConstBitCast(llglobal, t_ptr_i8);\n-    let llvm_used = str::as_c_str(~\"llvm.used\", |buf| {\n-        llvm::LLVMAddGlobal(cx.llmod, T_array(t_ptr_i8, 1u), buf)\n-    });\n-    lib::llvm::SetLinkage(llvm_used, lib::llvm::AppendingLinkage);\n-    llvm::LLVMSetInitializer(llvm_used, C_array(t_ptr_i8, ~[llglobal]));\n+        let t_ptr_i8 = T_ptr(T_i8());\n+        llglobal = llvm::LLVMConstBitCast(llglobal, t_ptr_i8);\n+        let llvm_used = str::as_c_str(~\"llvm.used\", |buf| {\n+            llvm::LLVMAddGlobal(cx.llmod, T_array(t_ptr_i8, 1u), buf)\n+        });\n+        lib::llvm::SetLinkage(llvm_used, lib::llvm::AppendingLinkage);\n+        llvm::LLVMSetInitializer(llvm_used, C_array(t_ptr_i8, ~[llglobal]));\n+    }\n }\n \n // Writes the current ABI version into the crate.\n@@ -2757,140 +2866,142 @@ fn trans_crate(sess: session::Session,\n     // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n     let llmod_id = link_meta.name + ~\".rc\";\n \n-    let llmod = str::as_c_str(llmod_id, |buf| {\n-        llvm::LLVMModuleCreateWithNameInContext\n-            (buf, llvm::LLVMGetGlobalContext())\n-    });\n-    let data_layout = /*bad*/copy sess.targ_cfg.target_strs.data_layout;\n-    let targ_triple = /*bad*/copy sess.targ_cfg.target_strs.target_triple;\n-    let _: () =\n-        str::as_c_str(data_layout,\n-                    |buf| llvm::LLVMSetDataLayout(llmod, buf));\n-    let _: () =\n-        str::as_c_str(targ_triple,\n-                    |buf| llvm::LLVMSetTarget(llmod, buf));\n-    let targ_cfg = sess.targ_cfg;\n-    let td = mk_target_data(\n-        /*bad*/copy sess.targ_cfg.target_strs.data_layout);\n-    let tn = mk_type_names();\n-    let intrinsics = declare_intrinsics(llmod);\n-    if sess.opts.extra_debuginfo {\n-        declare_dbg_intrinsics(llmod, intrinsics);\n-    }\n-    let int_type = T_int(targ_cfg);\n-    let float_type = T_float(targ_cfg);\n-    let task_type = T_task(targ_cfg);\n-    let taskptr_type = T_ptr(task_type);\n-    lib::llvm::associate_type(tn, ~\"taskptr\", taskptr_type);\n-    let tydesc_type = T_tydesc(targ_cfg);\n-    lib::llvm::associate_type(tn, ~\"tydesc\", tydesc_type);\n-    let crate_map = decl_crate_map(sess, link_meta, llmod);\n-    let dbg_cx = if sess.opts.debuginfo {\n-        Some(debuginfo::mk_ctxt(copy llmod_id, sess.parse_sess.interner))\n-    } else {\n-        None\n-    };\n+    unsafe {\n+        let llmod = str::as_c_str(llmod_id, |buf| {\n+            llvm::LLVMModuleCreateWithNameInContext\n+                (buf, llvm::LLVMGetGlobalContext())\n+        });\n+        let data_layout = /*bad*/copy sess.targ_cfg.target_strs.data_layout;\n+        let targ_triple = /*bad*/copy sess.targ_cfg.target_strs.target_triple;\n+        let _: () =\n+            str::as_c_str(data_layout,\n+                        |buf| llvm::LLVMSetDataLayout(llmod, buf));\n+        let _: () =\n+            str::as_c_str(targ_triple,\n+                        |buf| llvm::LLVMSetTarget(llmod, buf));\n+        let targ_cfg = sess.targ_cfg;\n+        let td = mk_target_data(\n+            /*bad*/copy sess.targ_cfg.target_strs.data_layout);\n+        let tn = mk_type_names();\n+        let intrinsics = declare_intrinsics(llmod);\n+        if sess.opts.extra_debuginfo {\n+            declare_dbg_intrinsics(llmod, intrinsics);\n+        }\n+        let int_type = T_int(targ_cfg);\n+        let float_type = T_float(targ_cfg);\n+        let task_type = T_task(targ_cfg);\n+        let taskptr_type = T_ptr(task_type);\n+        lib::llvm::associate_type(tn, ~\"taskptr\", taskptr_type);\n+        let tydesc_type = T_tydesc(targ_cfg);\n+        lib::llvm::associate_type(tn, ~\"tydesc\", tydesc_type);\n+        let crate_map = decl_crate_map(sess, link_meta, llmod);\n+        let dbg_cx = if sess.opts.debuginfo {\n+            Some(debuginfo::mk_ctxt(copy llmod_id, sess.parse_sess.interner))\n+        } else {\n+            None\n+        };\n \n-    let ccx = @crate_ctxt {\n-          sess: sess,\n-          llmod: llmod,\n-          td: td,\n-          tn: tn,\n-          externs: HashMap(),\n-          intrinsics: intrinsics,\n-          item_vals: HashMap(),\n-          exp_map2: emap2,\n-          reachable: reachable,\n-          item_symbols: HashMap(),\n-          mut main_fn: None::<ValueRef>,\n-          link_meta: copy link_meta,    // XXX: Bad copy.\n-          enum_sizes: ty::new_ty_hash(),\n-          discrims: HashMap(),\n-          discrim_symbols: HashMap(),\n-          tydescs: ty::new_ty_hash(),\n-          mut finished_tydescs: false,\n-          external: HashMap(),\n-          monomorphized: HashMap(),\n-          monomorphizing: HashMap(),\n-          type_use_cache: HashMap(),\n-          vtables: map::HashMap(),\n-          const_cstr_cache: HashMap(),\n-          const_globals: HashMap(),\n-          const_values: HashMap(),\n-          module_data: HashMap(),\n-          lltypes: ty::new_ty_hash(),\n-          names: new_namegen(sess.parse_sess.interner),\n-          next_addrspace: new_addrspace_gen(),\n-          symbol_hasher: symbol_hasher,\n-          type_hashcodes: ty::new_ty_hash(),\n-          type_short_names: ty::new_ty_hash(),\n-          all_llvm_symbols: HashMap(),\n-          tcx: tcx,\n-          maps: maps,\n-          stats:\n-              {mut n_static_tydescs: 0u,\n-               mut n_glues_created: 0u,\n-               mut n_null_glues: 0u,\n-               mut n_real_glues: 0u,\n-               mut n_fns: 0u,\n-               mut n_monos: 0u,\n-               mut n_inlines: 0u,\n-               mut n_closures: 0u,\n-               llvm_insn_ctxt: @mut ~[],\n-               llvm_insns: HashMap(),\n-               fn_times: @mut ~[]},\n-          upcalls: upcall::declare_upcalls(targ_cfg, llmod),\n-          tydesc_type: tydesc_type,\n-          int_type: int_type,\n-          float_type: float_type,\n-          task_type: task_type,\n-          opaque_vec_type: T_opaque_vec(targ_cfg),\n-          builder: BuilderRef_res(llvm::LLVMCreateBuilder()),\n-          shape_cx: mk_ctxt(llmod),\n-          crate_map: crate_map,\n-          mut uses_gc: false,\n-          dbg_cx: dbg_cx,\n-          mut do_not_commit_warning_issued: false\n-    };\n+        let ccx = @crate_ctxt {\n+              sess: sess,\n+              llmod: llmod,\n+              td: td,\n+              tn: tn,\n+              externs: HashMap(),\n+              intrinsics: intrinsics,\n+              item_vals: HashMap(),\n+              exp_map2: emap2,\n+              reachable: reachable,\n+              item_symbols: HashMap(),\n+              mut main_fn: None::<ValueRef>,\n+              link_meta: copy link_meta,    // XXX: Bad copy.\n+              enum_sizes: ty::new_ty_hash(),\n+              discrims: HashMap(),\n+              discrim_symbols: HashMap(),\n+              tydescs: ty::new_ty_hash(),\n+              mut finished_tydescs: false,\n+              external: HashMap(),\n+              monomorphized: HashMap(),\n+              monomorphizing: HashMap(),\n+              type_use_cache: HashMap(),\n+              vtables: map::HashMap(),\n+              const_cstr_cache: HashMap(),\n+              const_globals: HashMap(),\n+              const_values: HashMap(),\n+              module_data: HashMap(),\n+              lltypes: ty::new_ty_hash(),\n+              names: new_namegen(sess.parse_sess.interner),\n+              next_addrspace: new_addrspace_gen(),\n+              symbol_hasher: symbol_hasher,\n+              type_hashcodes: ty::new_ty_hash(),\n+              type_short_names: ty::new_ty_hash(),\n+              all_llvm_symbols: HashMap(),\n+              tcx: tcx,\n+              maps: maps,\n+              stats:\n+                  {mut n_static_tydescs: 0u,\n+                   mut n_glues_created: 0u,\n+                   mut n_null_glues: 0u,\n+                   mut n_real_glues: 0u,\n+                   mut n_fns: 0u,\n+                   mut n_monos: 0u,\n+                   mut n_inlines: 0u,\n+                   mut n_closures: 0u,\n+                   llvm_insn_ctxt: @mut ~[],\n+                   llvm_insns: HashMap(),\n+                   fn_times: @mut ~[]},\n+              upcalls: upcall::declare_upcalls(targ_cfg, llmod),\n+              tydesc_type: tydesc_type,\n+              int_type: int_type,\n+              float_type: float_type,\n+              task_type: task_type,\n+              opaque_vec_type: T_opaque_vec(targ_cfg),\n+              builder: BuilderRef_res(unsafe { llvm::LLVMCreateBuilder() }),\n+              shape_cx: mk_ctxt(llmod),\n+              crate_map: crate_map,\n+              mut uses_gc: false,\n+              dbg_cx: dbg_cx,\n+              mut do_not_commit_warning_issued: false\n+        };\n \n-    {\n-        let _icx = ccx.insn_ctxt(\"data\");\n-        trans_constants(ccx, crate);\n-    }\n+        {\n+            let _icx = ccx.insn_ctxt(\"data\");\n+            trans_constants(ccx, crate);\n+        }\n \n-    {\n-        let _icx = ccx.insn_ctxt(\"text\");\n-        trans_mod(ccx, crate.node.module);\n-    }\n-\n-    decl_gc_metadata(ccx, llmod_id);\n-    fill_crate_map(ccx, crate_map);\n-    glue::emit_tydescs(ccx);\n-    write_abi_version(ccx);\n-\n-    // Translate the metadata.\n-    write_metadata(ccx, crate);\n-    if ccx.sess.trans_stats() {\n-        io::println(~\"--- trans stats ---\");\n-        io::println(fmt!(\"n_static_tydescs: %u\",\n-                         ccx.stats.n_static_tydescs));\n-        io::println(fmt!(\"n_glues_created: %u\",\n-                         ccx.stats.n_glues_created));\n-        io::println(fmt!(\"n_null_glues: %u\", ccx.stats.n_null_glues));\n-        io::println(fmt!(\"n_real_glues: %u\", ccx.stats.n_real_glues));\n-\n-        io::println(fmt!(\"n_fns: %u\", ccx.stats.n_fns));\n-        io::println(fmt!(\"n_monos: %u\", ccx.stats.n_monos));\n-        io::println(fmt!(\"n_inlines: %u\", ccx.stats.n_inlines));\n-        io::println(fmt!(\"n_closures: %u\", ccx.stats.n_closures));\n-    }\n-\n-    if ccx.sess.count_llvm_insns() {\n-        for ccx.stats.llvm_insns.each |k, v| {\n-            io::println(fmt!(\"%-7u %s\", v, k));\n+        {\n+            let _icx = ccx.insn_ctxt(\"text\");\n+            trans_mod(ccx, crate.node.module);\n+        }\n+\n+        decl_gc_metadata(ccx, llmod_id);\n+        fill_crate_map(ccx, crate_map);\n+        glue::emit_tydescs(ccx);\n+        write_abi_version(ccx);\n+\n+        // Translate the metadata.\n+        write_metadata(ccx, crate);\n+        if ccx.sess.trans_stats() {\n+            io::println(~\"--- trans stats ---\");\n+            io::println(fmt!(\"n_static_tydescs: %u\",\n+                             ccx.stats.n_static_tydescs));\n+            io::println(fmt!(\"n_glues_created: %u\",\n+                             ccx.stats.n_glues_created));\n+            io::println(fmt!(\"n_null_glues: %u\", ccx.stats.n_null_glues));\n+            io::println(fmt!(\"n_real_glues: %u\", ccx.stats.n_real_glues));\n+\n+            io::println(fmt!(\"n_fns: %u\", ccx.stats.n_fns));\n+            io::println(fmt!(\"n_monos: %u\", ccx.stats.n_monos));\n+            io::println(fmt!(\"n_inlines: %u\", ccx.stats.n_inlines));\n+            io::println(fmt!(\"n_closures: %u\", ccx.stats.n_closures));\n+        }\n+\n+        if ccx.sess.count_llvm_insns() {\n+            for ccx.stats.llvm_insns.each |k, v| {\n+                io::println(fmt!(\"%-7u %s\", v, k));\n+            }\n         }\n+        return (llmod, link_meta);\n     }\n-    return (llmod, link_meta);\n }\n //\n // Local Variables:"}, {"sha": "dcf1b488d6fa7e28f0243c397054a8fd2b555aa4", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 524, "deletions": 340, "changes": 864, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -25,9 +25,11 @@ use std::map::HashMap;\n use syntax::codemap;\n \n fn B(cx: block) -> BuilderRef {\n-    let b = cx.fcx.ccx.builder.B;\n-    llvm::LLVMPositionBuilderAtEnd(b, cx.llbb);\n-    return b;\n+    unsafe {\n+        let b = cx.fcx.ccx.builder.B;\n+        llvm::LLVMPositionBuilderAtEnd(b, cx.llbb);\n+        return b;\n+    }\n }\n \n fn count_insn(cx: block, category: &str) {\n@@ -82,19 +84,23 @@ fn count_insn(cx: block, category: &str) {\n // further instructions to the block should simply be ignored.\n \n fn RetVoid(cx: block) {\n-    if cx.unreachable { return; }\n-    assert (!cx.terminated);\n-    cx.terminated = true;\n-    count_insn(cx, \"retvoid\");\n-    llvm::LLVMBuildRetVoid(B(cx));\n+    unsafe {\n+        if cx.unreachable { return; }\n+        assert (!cx.terminated);\n+        cx.terminated = true;\n+        count_insn(cx, \"retvoid\");\n+        llvm::LLVMBuildRetVoid(B(cx));\n+    }\n }\n \n fn Ret(cx: block, V: ValueRef) {\n-    if cx.unreachable { return; }\n-    assert (!cx.terminated);\n-    cx.terminated = true;\n-    count_insn(cx, \"ret\");\n-    llvm::LLVMBuildRet(B(cx), V);\n+    unsafe {\n+        if cx.unreachable { return; }\n+        assert (!cx.terminated);\n+        cx.terminated = true;\n+        count_insn(cx, \"ret\");\n+        llvm::LLVMBuildRet(B(cx), V);\n+    }\n }\n \n fn AggregateRet(cx: block, RetVals: ~[ValueRef]) {\n@@ -108,41 +114,51 @@ fn AggregateRet(cx: block, RetVals: ~[ValueRef]) {\n }\n \n fn Br(cx: block, Dest: BasicBlockRef) {\n-    if cx.unreachable { return; }\n-    assert (!cx.terminated);\n-    cx.terminated = true;\n-    count_insn(cx, \"br\");\n-    llvm::LLVMBuildBr(B(cx), Dest);\n+    unsafe {\n+        if cx.unreachable { return; }\n+        assert (!cx.terminated);\n+        cx.terminated = true;\n+        count_insn(cx, \"br\");\n+        llvm::LLVMBuildBr(B(cx), Dest);\n+    }\n }\n \n fn CondBr(cx: block, If: ValueRef, Then: BasicBlockRef,\n           Else: BasicBlockRef) {\n-    if cx.unreachable { return; }\n-    assert (!cx.terminated);\n-    cx.terminated = true;\n-    count_insn(cx, \"condbr\");\n-    llvm::LLVMBuildCondBr(B(cx), If, Then, Else);\n+    unsafe {\n+        if cx.unreachable { return; }\n+        assert (!cx.terminated);\n+        cx.terminated = true;\n+        count_insn(cx, \"condbr\");\n+        llvm::LLVMBuildCondBr(B(cx), If, Then, Else);\n+    }\n }\n \n fn Switch(cx: block, V: ValueRef, Else: BasicBlockRef, NumCases: uint)\n     -> ValueRef {\n-    if cx.unreachable { return _Undef(V); }\n-    assert !cx.terminated;\n-    cx.terminated = true;\n-    return llvm::LLVMBuildSwitch(B(cx), V, Else, NumCases as c_uint);\n+    unsafe {\n+        if cx.unreachable { return _Undef(V); }\n+        assert !cx.terminated;\n+        cx.terminated = true;\n+        return llvm::LLVMBuildSwitch(B(cx), V, Else, NumCases as c_uint);\n+    }\n }\n \n fn AddCase(S: ValueRef, OnVal: ValueRef, Dest: BasicBlockRef) {\n-    if llvm::LLVMIsUndef(S) == lib::llvm::True { return; }\n-    llvm::LLVMAddCase(S, OnVal, Dest);\n+    unsafe {\n+        if llvm::LLVMIsUndef(S) == lib::llvm::True { return; }\n+        llvm::LLVMAddCase(S, OnVal, Dest);\n+    }\n }\n \n fn IndirectBr(cx: block, Addr: ValueRef, NumDests: uint) {\n-    if cx.unreachable { return; }\n-    assert (!cx.terminated);\n-    cx.terminated = true;\n-    count_insn(cx, \"indirectbr\");\n-    llvm::LLVMBuildIndirectBr(B(cx), Addr, NumDests as c_uint);\n+    unsafe {\n+        if cx.unreachable { return; }\n+        assert (!cx.terminated);\n+        cx.terminated = true;\n+        count_insn(cx, \"indirectbr\");\n+        llvm::LLVMBuildIndirectBr(B(cx), Addr, NumDests as c_uint);\n+    }\n }\n \n // This is a really awful way to get a zero-length c-string, but better (and a\n@@ -184,263 +200,342 @@ fn FastInvoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n }\n \n fn Unreachable(cx: block) {\n-    if cx.unreachable { return; }\n-    cx.unreachable = true;\n-    if !cx.terminated {\n-        count_insn(cx, \"unreachable\");\n-        llvm::LLVMBuildUnreachable(B(cx));\n+    unsafe {\n+        if cx.unreachable { return; }\n+        cx.unreachable = true;\n+        if !cx.terminated {\n+            count_insn(cx, \"unreachable\");\n+            llvm::LLVMBuildUnreachable(B(cx));\n+        }\n     }\n }\n \n fn _Undef(val: ValueRef) -> ValueRef {\n-    return llvm::LLVMGetUndef(val_ty(val));\n+    unsafe {\n+        return llvm::LLVMGetUndef(val_ty(val));\n+    }\n }\n \n /* Arithmetic */\n fn Add(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, \"add\");\n-    return llvm::LLVMBuildAdd(B(cx), LHS, RHS, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(LHS); }\n+        count_insn(cx, \"add\");\n+        return llvm::LLVMBuildAdd(B(cx), LHS, RHS, noname());\n+    }\n }\n \n fn NSWAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, \"nswadd\");\n-    return llvm::LLVMBuildNSWAdd(B(cx), LHS, RHS, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(LHS); }\n+        count_insn(cx, \"nswadd\");\n+        return llvm::LLVMBuildNSWAdd(B(cx), LHS, RHS, noname());\n+    }\n }\n \n fn NUWAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, \"nuwadd\");\n-    return llvm::LLVMBuildNUWAdd(B(cx), LHS, RHS, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(LHS); }\n+        count_insn(cx, \"nuwadd\");\n+        return llvm::LLVMBuildNUWAdd(B(cx), LHS, RHS, noname());\n+    }\n }\n \n fn FAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, \"fadd\");\n-    return llvm::LLVMBuildFAdd(B(cx), LHS, RHS, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(LHS); }\n+        count_insn(cx, \"fadd\");\n+        return llvm::LLVMBuildFAdd(B(cx), LHS, RHS, noname());\n+    }\n }\n \n fn Sub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, \"sub\");\n-    return llvm::LLVMBuildSub(B(cx), LHS, RHS, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(LHS); }\n+        count_insn(cx, \"sub\");\n+        return llvm::LLVMBuildSub(B(cx), LHS, RHS, noname());\n+    }\n }\n \n fn NSWSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, \"nwsub\");\n-    return llvm::LLVMBuildNSWSub(B(cx), LHS, RHS, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(LHS); }\n+        count_insn(cx, \"nwsub\");\n+        return llvm::LLVMBuildNSWSub(B(cx), LHS, RHS, noname());\n+    }\n }\n \n fn NUWSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, \"nuwsub\");\n-    return llvm::LLVMBuildNUWSub(B(cx), LHS, RHS, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(LHS); }\n+        count_insn(cx, \"nuwsub\");\n+        return llvm::LLVMBuildNUWSub(B(cx), LHS, RHS, noname());\n+    }\n }\n \n fn FSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, \"sub\");\n-    return llvm::LLVMBuildFSub(B(cx), LHS, RHS, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(LHS); }\n+        count_insn(cx, \"sub\");\n+        return llvm::LLVMBuildFSub(B(cx), LHS, RHS, noname());\n+    }\n }\n \n fn Mul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, \"mul\");\n-    return llvm::LLVMBuildMul(B(cx), LHS, RHS, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(LHS); }\n+        count_insn(cx, \"mul\");\n+        return llvm::LLVMBuildMul(B(cx), LHS, RHS, noname());\n+    }\n }\n \n fn NSWMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, \"nswmul\");\n-    return llvm::LLVMBuildNSWMul(B(cx), LHS, RHS, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(LHS); }\n+        count_insn(cx, \"nswmul\");\n+        return llvm::LLVMBuildNSWMul(B(cx), LHS, RHS, noname());\n+    }\n }\n \n fn NUWMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, \"nuwmul\");\n-    return llvm::LLVMBuildNUWMul(B(cx), LHS, RHS, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(LHS); }\n+        count_insn(cx, \"nuwmul\");\n+        return llvm::LLVMBuildNUWMul(B(cx), LHS, RHS, noname());\n+    }\n }\n \n fn FMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, \"fmul\");\n-    return llvm::LLVMBuildFMul(B(cx), LHS, RHS, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(LHS); }\n+        count_insn(cx, \"fmul\");\n+        return llvm::LLVMBuildFMul(B(cx), LHS, RHS, noname());\n+    }\n }\n \n fn UDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, \"udiv\");\n-    return llvm::LLVMBuildUDiv(B(cx), LHS, RHS, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(LHS); }\n+        count_insn(cx, \"udiv\");\n+        return llvm::LLVMBuildUDiv(B(cx), LHS, RHS, noname());\n+    }\n }\n \n fn SDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, \"sdiv\");\n-    return llvm::LLVMBuildSDiv(B(cx), LHS, RHS, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(LHS); }\n+        count_insn(cx, \"sdiv\");\n+        return llvm::LLVMBuildSDiv(B(cx), LHS, RHS, noname());\n+    }\n }\n \n fn ExactSDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, \"extractsdiv\");\n-    return llvm::LLVMBuildExactSDiv(B(cx), LHS, RHS, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(LHS); }\n+        count_insn(cx, \"extractsdiv\");\n+        return llvm::LLVMBuildExactSDiv(B(cx), LHS, RHS, noname());\n+    }\n }\n \n fn FDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, \"fdiv\");\n-    return llvm::LLVMBuildFDiv(B(cx), LHS, RHS, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(LHS); }\n+        count_insn(cx, \"fdiv\");\n+        return llvm::LLVMBuildFDiv(B(cx), LHS, RHS, noname());\n+    }\n }\n \n fn URem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, \"urem\");\n-    return llvm::LLVMBuildURem(B(cx), LHS, RHS, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(LHS); }\n+        count_insn(cx, \"urem\");\n+        return llvm::LLVMBuildURem(B(cx), LHS, RHS, noname());\n+    }\n }\n \n fn SRem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, \"srem\");\n-    return llvm::LLVMBuildSRem(B(cx), LHS, RHS, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(LHS); }\n+        count_insn(cx, \"srem\");\n+        return llvm::LLVMBuildSRem(B(cx), LHS, RHS, noname());\n+    }\n }\n \n fn FRem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, \"frem\");\n-    return llvm::LLVMBuildFRem(B(cx), LHS, RHS, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(LHS); }\n+        count_insn(cx, \"frem\");\n+        return llvm::LLVMBuildFRem(B(cx), LHS, RHS, noname());\n+    }\n }\n \n fn Shl(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, \"shl\");\n-    return llvm::LLVMBuildShl(B(cx), LHS, RHS, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(LHS); }\n+        count_insn(cx, \"shl\");\n+        return llvm::LLVMBuildShl(B(cx), LHS, RHS, noname());\n+    }\n }\n \n fn LShr(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, \"lshr\");\n-    return llvm::LLVMBuildLShr(B(cx), LHS, RHS, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(LHS); }\n+        count_insn(cx, \"lshr\");\n+        return llvm::LLVMBuildLShr(B(cx), LHS, RHS, noname());\n+    }\n }\n \n fn AShr(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, \"ashr\");\n-    return llvm::LLVMBuildAShr(B(cx), LHS, RHS, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(LHS); }\n+        count_insn(cx, \"ashr\");\n+        return llvm::LLVMBuildAShr(B(cx), LHS, RHS, noname());\n+    }\n }\n \n fn And(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, \"and\");\n-    return llvm::LLVMBuildAnd(B(cx), LHS, RHS, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(LHS); }\n+        count_insn(cx, \"and\");\n+        return llvm::LLVMBuildAnd(B(cx), LHS, RHS, noname());\n+    }\n }\n \n fn Or(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, \"or\");\n-    return llvm::LLVMBuildOr(B(cx), LHS, RHS, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(LHS); }\n+        count_insn(cx, \"or\");\n+        return llvm::LLVMBuildOr(B(cx), LHS, RHS, noname());\n+    }\n }\n \n fn Xor(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, \"xor\");\n-    return llvm::LLVMBuildXor(B(cx), LHS, RHS, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(LHS); }\n+        count_insn(cx, \"xor\");\n+        return llvm::LLVMBuildXor(B(cx), LHS, RHS, noname());\n+    }\n }\n \n-fn BinOp(cx: block, Op: Opcode, LHS: ValueRef, RHS: ValueRef) ->\n-   ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, \"binop\");\n-    return llvm::LLVMBuildBinOp(B(cx), Op, LHS, RHS, noname());\n+fn BinOp(cx: block, Op: Opcode, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    unsafe {\n+        if cx.unreachable { return _Undef(LHS); }\n+        count_insn(cx, \"binop\");\n+        return llvm::LLVMBuildBinOp(B(cx), Op, LHS, RHS, noname());\n+    }\n }\n \n fn Neg(cx: block, V: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(V); }\n-    count_insn(cx, \"neg\");\n-    return llvm::LLVMBuildNeg(B(cx), V, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(V); }\n+        count_insn(cx, \"neg\");\n+        return llvm::LLVMBuildNeg(B(cx), V, noname());\n+    }\n }\n \n fn NSWNeg(cx: block, V: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(V); }\n-    count_insn(cx, \"nswneg\");\n-    return llvm::LLVMBuildNSWNeg(B(cx), V, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(V); }\n+        count_insn(cx, \"nswneg\");\n+        return llvm::LLVMBuildNSWNeg(B(cx), V, noname());\n+    }\n }\n \n fn NUWNeg(cx: block, V: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(V); }\n-    count_insn(cx, \"nuwneg\");\n-    return llvm::LLVMBuildNUWNeg(B(cx), V, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(V); }\n+        count_insn(cx, \"nuwneg\");\n+        return llvm::LLVMBuildNUWNeg(B(cx), V, noname());\n+    }\n }\n fn FNeg(cx: block, V: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(V); }\n-    count_insn(cx, \"fneg\");\n-    return llvm::LLVMBuildFNeg(B(cx), V, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(V); }\n+        count_insn(cx, \"fneg\");\n+        return llvm::LLVMBuildFNeg(B(cx), V, noname());\n+    }\n }\n \n fn Not(cx: block, V: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(V); }\n-    count_insn(cx, \"not\");\n-    return llvm::LLVMBuildNot(B(cx), V, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(V); }\n+        count_insn(cx, \"not\");\n+        return llvm::LLVMBuildNot(B(cx), V, noname());\n+    }\n }\n \n /* Memory */\n fn Malloc(cx: block, Ty: TypeRef) -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n-    count_insn(cx, \"malloc\");\n-    return llvm::LLVMBuildMalloc(B(cx), Ty, noname());\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n+        count_insn(cx, \"malloc\");\n+        return llvm::LLVMBuildMalloc(B(cx), Ty, noname());\n+    }\n }\n \n fn ArrayMalloc(cx: block, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n-    count_insn(cx, \"arraymalloc\");\n-    return llvm::LLVMBuildArrayMalloc(B(cx), Ty, Val, noname());\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n+        count_insn(cx, \"arraymalloc\");\n+        return llvm::LLVMBuildArrayMalloc(B(cx), Ty, Val, noname());\n+    }\n }\n \n fn Alloca(cx: block, Ty: TypeRef) -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(Ty)); }\n-    count_insn(cx, \"alloca\");\n-    return llvm::LLVMBuildAlloca(B(cx), Ty, noname());\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(Ty)); }\n+        count_insn(cx, \"alloca\");\n+        return llvm::LLVMBuildAlloca(B(cx), Ty, noname());\n+    }\n }\n \n fn ArrayAlloca(cx: block, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(Ty)); }\n-    count_insn(cx, \"arrayalloca\");\n-    return llvm::LLVMBuildArrayAlloca(B(cx), Ty, Val, noname());\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(Ty)); }\n+        count_insn(cx, \"arrayalloca\");\n+        return llvm::LLVMBuildArrayAlloca(B(cx), Ty, Val, noname());\n+    }\n }\n \n fn Free(cx: block, PointerVal: ValueRef) {\n-    if cx.unreachable { return; }\n-    count_insn(cx, \"free\");\n-    llvm::LLVMBuildFree(B(cx), PointerVal);\n+    unsafe {\n+        if cx.unreachable { return; }\n+        count_insn(cx, \"free\");\n+        llvm::LLVMBuildFree(B(cx), PointerVal);\n+    }\n }\n \n fn Load(cx: block, PointerVal: ValueRef) -> ValueRef {\n-    let ccx = cx.fcx.ccx;\n-    if cx.unreachable {\n-        let ty = val_ty(PointerVal);\n-        let eltty = if llvm::LLVMGetTypeKind(ty) == lib::llvm::Array {\n-            llvm::LLVMGetElementType(ty) } else { ccx.int_type };\n-        return llvm::LLVMGetUndef(eltty);\n+    unsafe {\n+        let ccx = cx.fcx.ccx;\n+        if cx.unreachable {\n+            let ty = val_ty(PointerVal);\n+            let eltty = if llvm::LLVMGetTypeKind(ty) == lib::llvm::Array {\n+                llvm::LLVMGetElementType(ty) } else { ccx.int_type };\n+            return llvm::LLVMGetUndef(eltty);\n+        }\n+        count_insn(cx, \"load\");\n+        return llvm::LLVMBuildLoad(B(cx), PointerVal, noname());\n     }\n-    count_insn(cx, \"load\");\n-    return llvm::LLVMBuildLoad(B(cx), PointerVal, noname());\n }\n \n fn Store(cx: block, Val: ValueRef, Ptr: ValueRef) {\n-    if cx.unreachable { return; }\n-    debug!(\"Store %s -> %s\",\n-           val_str(cx.ccx().tn, Val),\n-           val_str(cx.ccx().tn, Ptr));\n-    count_insn(cx, \"store\");\n-    llvm::LLVMBuildStore(B(cx), Val, Ptr);\n+    unsafe {\n+        if cx.unreachable { return; }\n+        debug!(\"Store %s -> %s\",\n+               val_str(cx.ccx().tn, Val),\n+               val_str(cx.ccx().tn, Ptr));\n+        count_insn(cx, \"store\");\n+        llvm::LLVMBuildStore(B(cx), Val, Ptr);\n+    }\n }\n \n fn GEP(cx: block, Pointer: ValueRef, Indices: ~[ValueRef]) -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_nil())); }\n     unsafe {\n-    count_insn(cx, \"gep\");\n-    return llvm::LLVMBuildGEP(B(cx), Pointer, vec::raw::to_ptr(Indices),\n-                               Indices.len() as c_uint, noname());\n+        if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_nil())); }\n+        count_insn(cx, \"gep\");\n+        return llvm::LLVMBuildGEP(B(cx), Pointer, vec::raw::to_ptr(Indices),\n+                                   Indices.len() as c_uint, noname());\n     }\n }\n \n@@ -456,182 +551,234 @@ fn GEPi(cx: block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n \n fn InBoundsGEP(cx: block, Pointer: ValueRef, Indices: &[ValueRef]) ->\n    ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_nil())); }\n     unsafe {\n-        count_insn(cx, \"inboundsgep\");\n-    return llvm::LLVMBuildInBoundsGEP(B(cx), Pointer,\n-                                       vec::raw::to_ptr(Indices),\n-                                       Indices.len() as c_uint,\n-                                       noname());\n+        if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_nil())); }\n+        unsafe {\n+            count_insn(cx, \"inboundsgep\");\n+        return llvm::LLVMBuildInBoundsGEP(B(cx), Pointer,\n+                                           vec::raw::to_ptr(Indices),\n+                                           Indices.len() as c_uint,\n+                                           noname());\n+        }\n     }\n }\n \n fn StructGEP(cx: block, Pointer: ValueRef, Idx: uint) -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_nil())); }\n-    count_insn(cx, \"structgep\");\n-    return llvm::LLVMBuildStructGEP(B(cx), Pointer, Idx as c_uint, noname());\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_nil())); }\n+        count_insn(cx, \"structgep\");\n+        return llvm::LLVMBuildStructGEP(B(cx),\n+                                        Pointer,\n+                                        Idx as c_uint,\n+                                        noname());\n+    }\n }\n \n fn GlobalString(cx: block, _Str: *libc::c_char) -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n-    count_insn(cx, \"globalstring\");\n-    return llvm::LLVMBuildGlobalString(B(cx), _Str, noname());\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n+        count_insn(cx, \"globalstring\");\n+        return llvm::LLVMBuildGlobalString(B(cx), _Str, noname());\n+    }\n }\n \n fn GlobalStringPtr(cx: block, _Str: *libc::c_char) -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n-    count_insn(cx, \"globalstringptr\");\n-    return llvm::LLVMBuildGlobalStringPtr(B(cx), _Str, noname());\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n+        count_insn(cx, \"globalstringptr\");\n+        return llvm::LLVMBuildGlobalStringPtr(B(cx), _Str, noname());\n+    }\n }\n \n /* Casts */\n fn Trunc(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, \"trunc\");\n-    return llvm::LLVMBuildTrunc(B(cx), Val, DestTy, noname());\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        count_insn(cx, \"trunc\");\n+        return llvm::LLVMBuildTrunc(B(cx), Val, DestTy, noname());\n+    }\n }\n \n fn ZExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, \"zext\");\n-    return llvm::LLVMBuildZExt(B(cx), Val, DestTy, noname());\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        count_insn(cx, \"zext\");\n+        return llvm::LLVMBuildZExt(B(cx), Val, DestTy, noname());\n+    }\n }\n \n fn SExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, \"sext\");\n-    return llvm::LLVMBuildSExt(B(cx), Val, DestTy, noname());\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        count_insn(cx, \"sext\");\n+        return llvm::LLVMBuildSExt(B(cx), Val, DestTy, noname());\n+    }\n }\n \n fn FPToUI(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, \"fptoui\");\n-    return llvm::LLVMBuildFPToUI(B(cx), Val, DestTy, noname());\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        count_insn(cx, \"fptoui\");\n+        return llvm::LLVMBuildFPToUI(B(cx), Val, DestTy, noname());\n+    }\n }\n \n fn FPToSI(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, \"fptosi\");\n-    return llvm::LLVMBuildFPToSI(B(cx), Val, DestTy, noname());\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        count_insn(cx, \"fptosi\");\n+        return llvm::LLVMBuildFPToSI(B(cx), Val, DestTy, noname());\n+    }\n }\n \n fn UIToFP(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, \"uitofp\");\n-    return llvm::LLVMBuildUIToFP(B(cx), Val, DestTy, noname());\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        count_insn(cx, \"uitofp\");\n+        return llvm::LLVMBuildUIToFP(B(cx), Val, DestTy, noname());\n+    }\n }\n \n fn SIToFP(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, \"sitofp\");\n-    return llvm::LLVMBuildSIToFP(B(cx), Val, DestTy, noname());\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        count_insn(cx, \"sitofp\");\n+        return llvm::LLVMBuildSIToFP(B(cx), Val, DestTy, noname());\n+    }\n }\n \n fn FPTrunc(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, \"fptrunc\");\n-    return llvm::LLVMBuildFPTrunc(B(cx), Val, DestTy, noname());\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        count_insn(cx, \"fptrunc\");\n+        return llvm::LLVMBuildFPTrunc(B(cx), Val, DestTy, noname());\n+    }\n }\n \n fn FPExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, \"fpext\");\n-    return llvm::LLVMBuildFPExt(B(cx), Val, DestTy, noname());\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        count_insn(cx, \"fpext\");\n+        return llvm::LLVMBuildFPExt(B(cx), Val, DestTy, noname());\n+    }\n }\n \n fn PtrToInt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, \"ptrtoint\");\n-    return llvm::LLVMBuildPtrToInt(B(cx), Val, DestTy, noname());\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        count_insn(cx, \"ptrtoint\");\n+        return llvm::LLVMBuildPtrToInt(B(cx), Val, DestTy, noname());\n+    }\n }\n \n fn IntToPtr(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, \"inttoptr\");\n-    return llvm::LLVMBuildIntToPtr(B(cx), Val, DestTy, noname());\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        count_insn(cx, \"inttoptr\");\n+        return llvm::LLVMBuildIntToPtr(B(cx), Val, DestTy, noname());\n+    }\n }\n \n fn BitCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, \"bitcast\");\n-    return llvm::LLVMBuildBitCast(B(cx), Val, DestTy, noname());\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        count_insn(cx, \"bitcast\");\n+        return llvm::LLVMBuildBitCast(B(cx), Val, DestTy, noname());\n+    }\n }\n \n-fn ZExtOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) ->\n-   ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, \"zextorbitcast\");\n-    return llvm::LLVMBuildZExtOrBitCast(B(cx), Val, DestTy, noname());\n+fn ZExtOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        count_insn(cx, \"zextorbitcast\");\n+        return llvm::LLVMBuildZExtOrBitCast(B(cx), Val, DestTy, noname());\n+    }\n }\n \n-fn SExtOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) ->\n-   ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, \"sextorbitcast\");\n-    return llvm::LLVMBuildSExtOrBitCast(B(cx), Val, DestTy, noname());\n+fn SExtOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        count_insn(cx, \"sextorbitcast\");\n+        return llvm::LLVMBuildSExtOrBitCast(B(cx), Val, DestTy, noname());\n+    }\n }\n \n-fn TruncOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) ->\n-   ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, \"truncorbitcast\");\n-    return llvm::LLVMBuildTruncOrBitCast(B(cx), Val, DestTy, noname());\n+fn TruncOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        count_insn(cx, \"truncorbitcast\");\n+        return llvm::LLVMBuildTruncOrBitCast(B(cx), Val, DestTy, noname());\n+    }\n }\n \n-fn Cast(cx: block, Op: Opcode, Val: ValueRef, DestTy: TypeRef,\n-        _Name: *u8) -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, \"cast\");\n-    return llvm::LLVMBuildCast(B(cx), Op, Val, DestTy, noname());\n+fn Cast(cx: block, Op: Opcode, Val: ValueRef, DestTy: TypeRef, _: *u8)\n+     -> ValueRef {\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        count_insn(cx, \"cast\");\n+        return llvm::LLVMBuildCast(B(cx), Op, Val, DestTy, noname());\n+    }\n }\n \n fn PointerCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, \"pointercast\");\n-    return llvm::LLVMBuildPointerCast(B(cx), Val, DestTy, noname());\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        count_insn(cx, \"pointercast\");\n+        return llvm::LLVMBuildPointerCast(B(cx), Val, DestTy, noname());\n+    }\n }\n \n fn IntCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, \"intcast\");\n-    return llvm::LLVMBuildIntCast(B(cx), Val, DestTy, noname());\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        count_insn(cx, \"intcast\");\n+        return llvm::LLVMBuildIntCast(B(cx), Val, DestTy, noname());\n+    }\n }\n \n fn FPCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, \"fpcast\");\n-    return llvm::LLVMBuildFPCast(B(cx), Val, DestTy, noname());\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        count_insn(cx, \"fpcast\");\n+        return llvm::LLVMBuildFPCast(B(cx), Val, DestTy, noname());\n+    }\n }\n \n \n /* Comparisons */\n fn ICmp(cx: block, Op: IntPredicate, LHS: ValueRef, RHS: ValueRef)\n-    -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n-    count_insn(cx, \"icmp\");\n-    return llvm::LLVMBuildICmp(B(cx), Op as c_uint, LHS, RHS, noname());\n+     -> ValueRef {\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n+        count_insn(cx, \"icmp\");\n+        return llvm::LLVMBuildICmp(B(cx), Op as c_uint, LHS, RHS, noname());\n+    }\n }\n \n fn FCmp(cx: block, Op: RealPredicate, LHS: ValueRef, RHS: ValueRef)\n-    -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n-    count_insn(cx, \"fcmp\");\n-    return llvm::LLVMBuildFCmp(B(cx), Op as c_uint, LHS, RHS, noname());\n+     -> ValueRef {\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n+        count_insn(cx, \"fcmp\");\n+        return llvm::LLVMBuildFCmp(B(cx), Op as c_uint, LHS, RHS, noname());\n+    }\n }\n \n /* Miscellaneous instructions */\n fn EmptyPhi(cx: block, Ty: TypeRef) -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(Ty); }\n-    count_insn(cx, \"emptyphi\");\n-    return llvm::LLVMBuildPhi(B(cx), Ty, noname());\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(Ty); }\n+        count_insn(cx, \"emptyphi\");\n+        return llvm::LLVMBuildPhi(B(cx), Ty, noname());\n+    }\n }\n \n fn Phi(cx: block, Ty: TypeRef, vals: ~[ValueRef], bbs: ~[BasicBlockRef])\n-   -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(Ty); }\n-    assert vals.len() == bbs.len();\n-    let phi = EmptyPhi(cx, Ty);\n+    -> ValueRef {\n     unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(Ty); }\n+        assert vals.len() == bbs.len();\n+        let phi = EmptyPhi(cx, Ty);\n         count_insn(cx, \"addincoming\");\n         llvm::LLVMAddIncoming(phi, vec::raw::to_ptr(vals),\n                               vec::raw::to_ptr(bbs),\n@@ -641,21 +788,23 @@ fn Phi(cx: block, Ty: TypeRef, vals: ~[ValueRef], bbs: ~[BasicBlockRef])\n }\n \n fn AddIncomingToPhi(phi: ValueRef, val: ValueRef, bb: BasicBlockRef) {\n-    if llvm::LLVMIsUndef(phi) == lib::llvm::True { return; }\n     unsafe {\n+        if llvm::LLVMIsUndef(phi) == lib::llvm::True { return; }\n         let valptr = cast::reinterpret_cast(&ptr::addr_of(&val));\n         let bbptr = cast::reinterpret_cast(&ptr::addr_of(&bb));\n         llvm::LLVMAddIncoming(phi, valptr, bbptr, 1 as c_uint);\n     }\n }\n \n fn _UndefReturn(cx: block, Fn: ValueRef) -> ValueRef {\n-    let ccx = cx.fcx.ccx;\n-    let ty = val_ty(Fn);\n-    let retty = if llvm::LLVMGetTypeKind(ty) == lib::llvm::Integer {\n-        llvm::LLVMGetReturnType(ty) } else { ccx.int_type };\n-        count_insn(cx, ~\"\");\n-    return llvm::LLVMGetUndef(retty);\n+    unsafe {\n+        let ccx = cx.fcx.ccx;\n+        let ty = val_ty(Fn);\n+        let retty = if llvm::LLVMGetTypeKind(ty) == lib::llvm::Integer {\n+            llvm::LLVMGetReturnType(ty) } else { ccx.int_type };\n+            count_insn(cx, ~\"\");\n+        return llvm::LLVMGetUndef(retty);\n+    }\n }\n \n fn add_span_comment(bcx: block, sp: span, text: ~str) {\n@@ -669,18 +818,21 @@ fn add_span_comment(bcx: block, sp: span, text: ~str) {\n }\n \n fn add_comment(bcx: block, text: ~str) {\n-    let ccx = bcx.ccx();\n-    if !ccx.sess.no_asm_comments() {\n-        let sanitized = str::replace(text, ~\"$\", ~\"\");\n-        let comment_text = ~\"# \" + str::replace(sanitized, ~\"\\n\", ~\"\\n\\t# \");\n-        let asm = str::as_c_str(comment_text, |c| {\n-            str::as_c_str(~\"\", |e| {\n-                count_insn(bcx, ~\"inlineasm\");\n-                llvm::LLVMConstInlineAsm(T_fn(~[], T_void()), c, e,\n-                                         False, False)\n-            })\n-        });\n-        Call(bcx, asm, ~[]);\n+    unsafe {\n+        let ccx = bcx.ccx();\n+        if !ccx.sess.no_asm_comments() {\n+            let sanitized = str::replace(text, ~\"$\", ~\"\");\n+            let comment_text = ~\"# \" +\n+                str::replace(sanitized, ~\"\\n\", ~\"\\n\\t# \");\n+            let asm = str::as_c_str(comment_text, |c| {\n+                str::as_c_str(~\"\", |e| {\n+                    count_insn(bcx, ~\"inlineasm\");\n+                    llvm::LLVMConstInlineAsm(T_fn(~[], T_void()), c, e,\n+                                             False, False)\n+                })\n+            });\n+            Call(bcx, asm, ~[]);\n+        }\n     }\n }\n \n@@ -724,120 +876,152 @@ fn CallWithConv(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n \n fn Select(cx: block, If: ValueRef, Then: ValueRef, Else: ValueRef) ->\n    ValueRef {\n-    if cx.unreachable { return _Undef(Then); }\n-    count_insn(cx, \"select\");\n-    return llvm::LLVMBuildSelect(B(cx), If, Then, Else, noname());\n+    unsafe {\n+        if cx.unreachable { return _Undef(Then); }\n+        count_insn(cx, \"select\");\n+        return llvm::LLVMBuildSelect(B(cx), If, Then, Else, noname());\n+    }\n }\n \n fn VAArg(cx: block, list: ValueRef, Ty: TypeRef) -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(Ty); }\n-    count_insn(cx, \"vaarg\");\n-    return llvm::LLVMBuildVAArg(B(cx), list, Ty, noname());\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(Ty); }\n+        count_insn(cx, \"vaarg\");\n+        return llvm::LLVMBuildVAArg(B(cx), list, Ty, noname());\n+    }\n }\n \n fn ExtractElement(cx: block, VecVal: ValueRef, Index: ValueRef) ->\n    ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(T_nil()); }\n-    count_insn(cx, \"extractelement\");\n-    return llvm::LLVMBuildExtractElement(B(cx), VecVal, Index, noname());\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(T_nil()); }\n+        count_insn(cx, \"extractelement\");\n+        return llvm::LLVMBuildExtractElement(B(cx), VecVal, Index, noname());\n+    }\n }\n \n fn InsertElement(cx: block, VecVal: ValueRef, EltVal: ValueRef,\n                  Index: ValueRef) {\n-    if cx.unreachable { return; }\n-    count_insn(cx, \"insertelement\");\n-    llvm::LLVMBuildInsertElement(B(cx), VecVal, EltVal, Index, noname());\n+    unsafe {\n+        if cx.unreachable { return; }\n+        count_insn(cx, \"insertelement\");\n+        llvm::LLVMBuildInsertElement(B(cx), VecVal, EltVal, Index, noname());\n+    }\n }\n \n fn ShuffleVector(cx: block, V1: ValueRef, V2: ValueRef,\n                  Mask: ValueRef) {\n-    if cx.unreachable { return; }\n-    count_insn(cx, \"shufflevector\");\n-    llvm::LLVMBuildShuffleVector(B(cx), V1, V2, Mask, noname());\n+    unsafe {\n+        if cx.unreachable { return; }\n+        count_insn(cx, \"shufflevector\");\n+        llvm::LLVMBuildShuffleVector(B(cx), V1, V2, Mask, noname());\n+    }\n }\n \n fn ExtractValue(cx: block, AggVal: ValueRef, Index: uint) -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(T_nil()); }\n-    count_insn(cx, \"extractvalue\");\n-    return llvm::LLVMBuildExtractValue(\n-        B(cx), AggVal, Index as c_uint, noname());\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(T_nil()); }\n+        count_insn(cx, \"extractvalue\");\n+        return llvm::LLVMBuildExtractValue(\n+            B(cx), AggVal, Index as c_uint, noname());\n+    }\n }\n \n fn InsertValue(cx: block, AggVal: ValueRef, EltVal: ValueRef,\n                Index: uint) {\n-    if cx.unreachable { return; }\n-    count_insn(cx, \"insertvalue\");\n-    llvm::LLVMBuildInsertValue(B(cx), AggVal, EltVal, Index as c_uint,\n-                               noname());\n+    unsafe {\n+        if cx.unreachable { return; }\n+        count_insn(cx, \"insertvalue\");\n+        llvm::LLVMBuildInsertValue(B(cx), AggVal, EltVal, Index as c_uint,\n+                                   noname());\n+    }\n }\n \n fn IsNull(cx: block, Val: ValueRef) -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n-    count_insn(cx, \"isnull\");\n-    return llvm::LLVMBuildIsNull(B(cx), Val, noname());\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n+        count_insn(cx, \"isnull\");\n+        return llvm::LLVMBuildIsNull(B(cx), Val, noname());\n+    }\n }\n \n fn IsNotNull(cx: block, Val: ValueRef) -> ValueRef {\n-    if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n-    count_insn(cx, \"isnotnull\");\n-    return llvm::LLVMBuildIsNotNull(B(cx), Val, noname());\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n+        count_insn(cx, \"isnotnull\");\n+        return llvm::LLVMBuildIsNotNull(B(cx), Val, noname());\n+    }\n }\n \n fn PtrDiff(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    let ccx = cx.fcx.ccx;\n-    if cx.unreachable { return llvm::LLVMGetUndef(ccx.int_type); }\n-    count_insn(cx, \"ptrdiff\");\n-    return llvm::LLVMBuildPtrDiff(B(cx), LHS, RHS, noname());\n+    unsafe {\n+        let ccx = cx.fcx.ccx;\n+        if cx.unreachable { return llvm::LLVMGetUndef(ccx.int_type); }\n+        count_insn(cx, \"ptrdiff\");\n+        return llvm::LLVMBuildPtrDiff(B(cx), LHS, RHS, noname());\n+    }\n }\n \n fn Trap(cx: block) {\n-    if cx.unreachable { return; }\n-    let b = B(cx);\n-    let BB: BasicBlockRef = llvm::LLVMGetInsertBlock(b);\n-    let FN: ValueRef = llvm::LLVMGetBasicBlockParent(BB);\n-    let M: ModuleRef = llvm::LLVMGetGlobalParent(FN);\n-    let T: ValueRef = str::as_c_str(~\"llvm.trap\", |buf| {\n-        llvm::LLVMGetNamedFunction(M, buf)\n-    });\n-    assert (T as int != 0);\n-    let Args: ~[ValueRef] = ~[];\n     unsafe {\n-        count_insn(cx, \"trap\");\n-        llvm::LLVMBuildCall(b, T, vec::raw::to_ptr(Args),\n-                            Args.len() as c_uint, noname());\n+        if cx.unreachable { return; }\n+        let b = B(cx);\n+        let BB: BasicBlockRef = llvm::LLVMGetInsertBlock(b);\n+        let FN: ValueRef = llvm::LLVMGetBasicBlockParent(BB);\n+        let M: ModuleRef = llvm::LLVMGetGlobalParent(FN);\n+        let T: ValueRef = str::as_c_str(~\"llvm.trap\", |buf| {\n+            llvm::LLVMGetNamedFunction(M, buf)\n+        });\n+        assert (T as int != 0);\n+        let Args: ~[ValueRef] = ~[];\n+        unsafe {\n+            count_insn(cx, \"trap\");\n+            llvm::LLVMBuildCall(b, T, vec::raw::to_ptr(Args),\n+                                Args.len() as c_uint, noname());\n+        }\n     }\n }\n \n fn LandingPad(cx: block, Ty: TypeRef, PersFn: ValueRef,\n               NumClauses: uint) -> ValueRef {\n-    assert !cx.terminated && !cx.unreachable;\n-    count_insn(cx, \"landingpad\");\n-    return llvm::LLVMBuildLandingPad(B(cx), Ty, PersFn,\n-                                  NumClauses as c_uint, noname());\n+    unsafe {\n+        assert !cx.terminated && !cx.unreachable;\n+        count_insn(cx, \"landingpad\");\n+        return llvm::LLVMBuildLandingPad(B(cx), Ty, PersFn,\n+                                      NumClauses as c_uint, noname());\n+    }\n }\n \n fn SetCleanup(cx: block, LandingPad: ValueRef) {\n-    count_insn(cx, \"setcleanup\");\n-    llvm::LLVMSetCleanup(LandingPad, lib::llvm::True);\n+    unsafe {\n+        count_insn(cx, \"setcleanup\");\n+        llvm::LLVMSetCleanup(LandingPad, lib::llvm::True);\n+    }\n }\n \n fn Resume(cx: block, Exn: ValueRef) -> ValueRef {\n-    assert (!cx.terminated);\n-    cx.terminated = true;\n-    count_insn(cx, \"resume\");\n-    return llvm::LLVMBuildResume(B(cx), Exn);\n+    unsafe {\n+        assert (!cx.terminated);\n+        cx.terminated = true;\n+        count_insn(cx, \"resume\");\n+        return llvm::LLVMBuildResume(B(cx), Exn);\n+    }\n }\n \n // Atomic Operations\n fn AtomicCmpXchg(cx: block, dst: ValueRef,\n                  cmp: ValueRef, src: ValueRef,\n                  order: AtomicOrdering) -> ValueRef {\n-    llvm::LLVMBuildAtomicCmpXchg(B(cx), dst, cmp, src, order)\n+    unsafe {\n+        llvm::LLVMBuildAtomicCmpXchg(B(cx), dst, cmp, src, order)\n+    }\n }\n fn AtomicRMW(cx: block, op: AtomicBinOp,\n              dst: ValueRef, src: ValueRef,\n              order: AtomicOrdering) -> ValueRef {\n-    llvm::LLVMBuildAtomicRMW(B(cx), op, dst, src, order)\n+    unsafe {\n+        llvm::LLVMBuildAtomicRMW(B(cx), op, dst, src, order)\n+    }\n }\n \n //"}, {"sha": "2f43f421abbece0f4a0277c9d86ac7dac5d2ef4d", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -440,25 +440,27 @@ fn trans_call_inner(\n             Some(flag)\n         } else { None };\n \n-        let (llfn, llenv) = match callee.data {\n-            Fn(d) => {\n-                (d.llfn, llvm::LLVMGetUndef(T_opaque_box_ptr(ccx)))\n-            }\n-            Method(d) => {\n-                // Weird but true: we pass self in the *environment* slot!\n-                let llself = PointerCast(bcx, d.llself,\n-                                         T_opaque_box_ptr(ccx));\n-                (d.llfn, llself)\n-            }\n-            Closure(d) => {\n-                // Closures are represented as (llfn, llclosure) pair:\n-                // load the requisite values out.\n-                let pair = d.to_ref_llval(bcx);\n-                let llfn = GEPi(bcx, pair, [0u, abi::fn_field_code]);\n-                let llfn = Load(bcx, llfn);\n-                let llenv = GEPi(bcx, pair, [0u, abi::fn_field_box]);\n-                let llenv = Load(bcx, llenv);\n-                (llfn, llenv)\n+        let (llfn, llenv) = unsafe {\n+            match callee.data {\n+                Fn(d) => {\n+                    (d.llfn, llvm::LLVMGetUndef(T_opaque_box_ptr(ccx)))\n+                }\n+                Method(d) => {\n+                    // Weird but true: we pass self in the *environment* slot!\n+                    let llself = PointerCast(bcx, d.llself,\n+                                             T_opaque_box_ptr(ccx));\n+                    (d.llfn, llself)\n+                }\n+                Closure(d) => {\n+                    // Closures are represented as (llfn, llclosure) pair:\n+                    // load the requisite values out.\n+                    let pair = d.to_ref_llval(bcx);\n+                    let llfn = GEPi(bcx, pair, [0u, abi::fn_field_code]);\n+                    let llfn = Load(bcx, llfn);\n+                    let llenv = GEPi(bcx, pair, [0u, abi::fn_field_box]);\n+                    let llenv = Load(bcx, llenv);\n+                    (llfn, llenv)\n+                }\n             }\n         };\n \n@@ -493,8 +495,10 @@ fn trans_call_inner(\n         bcx = base::invoke(bcx, llfn, llargs);\n         match dest { // drop the value if it is not being saved.\n             expr::Ignore => {\n-                if llvm::LLVMIsUndef(llretslot) != lib::llvm::True {\n-                    bcx = glue::drop_ty(bcx, llretslot, ret_ty);\n+                unsafe {\n+                    if llvm::LLVMIsUndef(llretslot) != lib::llvm::True {\n+                        bcx = glue::drop_ty(bcx, llretslot, ret_ty);\n+                    }\n                 }\n             }\n             expr::SaveIn(_) => { }\n@@ -545,7 +549,9 @@ fn trans_args(cx: block,\n         expr::SaveIn(dst) => dst,\n         expr::Ignore => {\n             if ty::type_is_nil(retty) {\n-                llvm::LLVMGetUndef(T_ptr(T_nil()))\n+                unsafe {\n+                    llvm::LLVMGetUndef(T_ptr(T_nil()))\n+                }\n             } else {\n                 alloc_ty(bcx, retty)\n             }\n@@ -662,7 +668,9 @@ fn trans_arg_expr(bcx: block,\n         // be inspected. It's important for the value\n         // to have type lldestty (the callee's expected type).\n         let llformal_ty = type_of::type_of(ccx, formal_ty.ty);\n-        val = llvm::LLVMGetUndef(llformal_ty);\n+        unsafe {\n+            val = llvm::LLVMGetUndef(llformal_ty);\n+        }\n     } else {\n         // FIXME(#3548) use the adjustments table\n         match autoref_arg {"}, {"sha": "0e0ff7ef5be6cf70a7392a0a7afce557f5390051", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -339,7 +339,9 @@ fn load_environment(fcx: fn_ctxt,\n             let ll =\n                 str::as_c_str(~\"load_env\",\n                               |buf|\n-                              llvm::LLVMAppendBasicBlock(fcx.llfn, buf));\n+                              unsafe {\n+                                llvm::LLVMAppendBasicBlock(fcx.llfn, buf)\n+                              });\n             fcx.llloadenv = Some(ll);\n             ll\n         }"}, {"sha": "0fbe94a4b0eb368148e233f82f6bc73a87a2d2bd", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 155, "deletions": 87, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -137,7 +137,11 @@ type stats =\n \n struct BuilderRef_res {\n     B: BuilderRef,\n-    drop { llvm::LLVMDisposeBuilder(self.B); }\n+    drop {\n+        unsafe {\n+            llvm::LLVMDisposeBuilder(self.B);\n+        }\n+    }\n }\n \n fn BuilderRef_res(B: BuilderRef) -> BuilderRef_res {\n@@ -613,20 +617,27 @@ fn ty_str(tn: type_names, t: TypeRef) -> ~str {\n     return lib::llvm::type_to_str(tn, t);\n }\n \n-fn val_ty(v: ValueRef) -> TypeRef { return llvm::LLVMTypeOf(v); }\n+fn val_ty(v: ValueRef) -> TypeRef {\n+    unsafe {\n+        return llvm::LLVMTypeOf(v);\n+    }\n+}\n \n fn val_str(tn: type_names, v: ValueRef) -> ~str {\n     return ty_str(tn, val_ty(v));\n }\n \n // Returns the nth element of the given LLVM structure type.\n fn struct_elt(llstructty: TypeRef, n: uint) -> TypeRef unsafe {\n-    let elt_count = llvm::LLVMCountStructElementTypes(llstructty) as uint;\n-    assert (n < elt_count);\n-    let mut elt_tys = vec::from_elem(elt_count, T_nil());\n-    llvm::LLVMGetStructElementTypes(llstructty,\n-                                    ptr::to_mut_unsafe_ptr(&mut elt_tys[0]));\n-    return llvm::LLVMGetElementType(elt_tys[n]);\n+    unsafe {\n+        let elt_count = llvm::LLVMCountStructElementTypes(llstructty) as uint;\n+        assert (n < elt_count);\n+        let mut elt_tys = vec::from_elem(elt_count, T_nil());\n+        llvm::LLVMGetStructElementTypes(\n+            llstructty,\n+            ptr::to_mut_unsafe_ptr(&mut elt_tys[0]));\n+        return llvm::LLVMGetElementType(elt_tys[n]);\n+    }\n }\n \n fn in_scope_cx(cx: block, f: fn(scope_info)) {\n@@ -722,30 +733,34 @@ fn T_void() -> TypeRef {\n     // of 10 nil values will have 10-bit size -- but it doesn't seem like we\n     // have any other options until it's fixed upstream.\n \n-    return llvm::LLVMVoidType();\n+    unsafe {\n+        return llvm::LLVMVoidType();\n+    }\n }\n \n fn T_nil() -> TypeRef {\n     // NB: See above in T_void().\n \n-    return llvm::LLVMInt1Type();\n+    unsafe {\n+        return llvm::LLVMInt1Type();\n+    }\n }\n \n-fn T_metadata() -> TypeRef { return llvm::LLVMMetadataType(); }\n+fn T_metadata() -> TypeRef { unsafe { return llvm::LLVMMetadataType(); } }\n \n-fn T_i1() -> TypeRef { return llvm::LLVMInt1Type(); }\n+fn T_i1() -> TypeRef { unsafe { return llvm::LLVMInt1Type(); } }\n \n-fn T_i8() -> TypeRef { return llvm::LLVMInt8Type(); }\n+fn T_i8() -> TypeRef { unsafe { return llvm::LLVMInt8Type(); } }\n \n-fn T_i16() -> TypeRef { return llvm::LLVMInt16Type(); }\n+fn T_i16() -> TypeRef { unsafe { return llvm::LLVMInt16Type(); } }\n \n-fn T_i32() -> TypeRef { return llvm::LLVMInt32Type(); }\n+fn T_i32() -> TypeRef { unsafe { return llvm::LLVMInt32Type(); } }\n \n-fn T_i64() -> TypeRef { return llvm::LLVMInt64Type(); }\n+fn T_i64() -> TypeRef { unsafe { return llvm::LLVMInt64Type(); } }\n \n-fn T_f32() -> TypeRef { return llvm::LLVMFloatType(); }\n+fn T_f32() -> TypeRef { unsafe { return llvm::LLVMFloatType(); } }\n \n-fn T_f64() -> TypeRef { return llvm::LLVMDoubleType(); }\n+fn T_f64() -> TypeRef { unsafe { return llvm::LLVMDoubleType(); } }\n \n fn T_bool() -> TypeRef { return T_i1(); }\n \n@@ -811,25 +826,39 @@ fn T_fn_pair(cx: @crate_ctxt, tfn: TypeRef) -> TypeRef {\n }\n \n fn T_ptr(t: TypeRef) -> TypeRef {\n-    return llvm::LLVMPointerType(t, default_addrspace);\n+    unsafe {\n+        return llvm::LLVMPointerType(t, default_addrspace);\n+    }\n }\n \n fn T_root(t: TypeRef, addrspace: addrspace) -> TypeRef {\n-    return llvm::LLVMPointerType(t, addrspace);\n+    unsafe {\n+        return llvm::LLVMPointerType(t, addrspace);\n+    }\n }\n \n fn T_struct(elts: ~[TypeRef]) -> TypeRef unsafe {\n-    return llvm::LLVMStructType(to_ptr(elts), elts.len() as c_uint, False);\n+    unsafe {\n+        return llvm::LLVMStructType(to_ptr(elts),\n+                                    elts.len() as c_uint,\n+                                    False);\n+    }\n }\n \n fn T_named_struct(name: ~str) -> TypeRef {\n-    let c = llvm::LLVMGetGlobalContext();\n-    return str::as_c_str(name, |buf| llvm::LLVMStructCreateNamed(c, buf));\n+    unsafe {\n+        let c = llvm::LLVMGetGlobalContext();\n+        return str::as_c_str(name, |buf| llvm::LLVMStructCreateNamed(c, buf));\n+    }\n }\n \n fn set_struct_body(t: TypeRef, elts: ~[TypeRef]) unsafe {\n-    llvm::LLVMStructSetBody(t, to_ptr(elts),\n-                            elts.len() as c_uint, False);\n+    unsafe {\n+        llvm::LLVMStructSetBody(t,\n+                                to_ptr(elts),\n+                                elts.len() as c_uint,\n+                                False);\n+    }\n }\n \n fn T_empty_struct() -> TypeRef { return T_struct(~[]); }\n@@ -865,14 +894,16 @@ fn T_task(targ_cfg: @session::config) -> TypeRef {\n fn T_tydesc_field(cx: @crate_ctxt, field: uint) -> TypeRef unsafe {\n     // Bit of a kludge: pick the fn typeref out of the tydesc..\n \n-    let mut tydesc_elts: ~[TypeRef] =\n-        vec::from_elem::<TypeRef>(abi::n_tydesc_fields,\n-                                 T_nil());\n-    llvm::LLVMGetStructElementTypes(\n-        cx.tydesc_type,\n-        ptr::to_mut_unsafe_ptr(&mut tydesc_elts[0]));\n-    let t = llvm::LLVMGetElementType(tydesc_elts[field]);\n-    return t;\n+    unsafe {\n+        let mut tydesc_elts: ~[TypeRef] =\n+            vec::from_elem::<TypeRef>(abi::n_tydesc_fields,\n+                                     T_nil());\n+        llvm::LLVMGetStructElementTypes(\n+            cx.tydesc_type,\n+            ptr::to_mut_unsafe_ptr(&mut tydesc_elts[0]));\n+        let t = llvm::LLVMGetElementType(tydesc_elts[field]);\n+        return t;\n+    }\n }\n \n fn T_generic_glue_fn(cx: @crate_ctxt) -> TypeRef {\n@@ -904,7 +935,9 @@ fn T_tydesc(targ_cfg: @session::config) -> TypeRef {\n }\n \n fn T_array(t: TypeRef, n: uint) -> TypeRef {\n-    return llvm::LLVMArrayType(t, n as c_uint);\n+    unsafe {\n+        return llvm::LLVMArrayType(t, n as c_uint);\n+    }\n }\n \n // Interior vector.\n@@ -947,7 +980,9 @@ fn T_box(cx: @crate_ctxt, t: TypeRef) -> TypeRef {\n }\n \n fn T_box_ptr(t: TypeRef) -> TypeRef {\n-    return llvm::LLVMPointerType(t, gc_box_addrspace);\n+    unsafe {\n+        return llvm::LLVMPointerType(t, gc_box_addrspace);\n+    }\n }\n \n fn T_opaque_box(cx: @crate_ctxt) -> TypeRef {\n@@ -963,7 +998,9 @@ fn T_unique(cx: @crate_ctxt, t: TypeRef) -> TypeRef {\n }\n \n fn T_unique_ptr(t: TypeRef) -> TypeRef {\n-    return llvm::LLVMPointerType(t, gc_box_addrspace);\n+    unsafe {\n+        return llvm::LLVMPointerType(t, gc_box_addrspace);\n+    }\n }\n \n fn T_port(cx: @crate_ctxt, _t: TypeRef) -> TypeRef {\n@@ -1042,14 +1079,22 @@ fn T_opaque_chan_ptr() -> TypeRef { return T_ptr(T_i8()); }\n \n \n // LLVM constant constructors.\n-fn C_null(t: TypeRef) -> ValueRef { return llvm::LLVMConstNull(t); }\n+fn C_null(t: TypeRef) -> ValueRef {\n+    unsafe {\n+        return llvm::LLVMConstNull(t);\n+    }\n+}\n \n fn C_integral(t: TypeRef, u: u64, sign_extend: Bool) -> ValueRef {\n-    return llvm::LLVMConstInt(t, u, sign_extend);\n+    unsafe {\n+        return llvm::LLVMConstInt(t, u, sign_extend);\n+    }\n }\n \n fn C_floating(s: ~str, t: TypeRef) -> ValueRef {\n-    return str::as_c_str(s, |buf| llvm::LLVMConstRealOfString(t, buf));\n+    unsafe {\n+        return str::as_c_str(s, |buf| llvm::LLVMConstRealOfString(t, buf));\n+    }\n }\n \n fn C_nil() -> ValueRef {\n@@ -1084,92 +1129,115 @@ fn C_u8(i: uint) -> ValueRef { return C_integral(T_i8(), i as u64, False); }\n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n fn C_cstr(cx: @crate_ctxt, +s: ~str) -> ValueRef {\n-    match cx.const_cstr_cache.find(s) {\n-      Some(llval) => return llval,\n-      None => ()\n-    }\n+    unsafe {\n+        match cx.const_cstr_cache.find(s) {\n+          Some(llval) => return llval,\n+          None => ()\n+        }\n \n-    let sc = do str::as_c_str(s) |buf| {\n-        llvm::LLVMConstString(buf, str::len(s) as c_uint, False)\n-    };\n-    let g =\n-        str::as_c_str(fmt!(\"str%u\", (cx.names)(~\"str\").repr),\n-                    |buf| llvm::LLVMAddGlobal(cx.llmod, val_ty(sc), buf));\n-    llvm::LLVMSetInitializer(g, sc);\n-    llvm::LLVMSetGlobalConstant(g, True);\n-    lib::llvm::SetLinkage(g, lib::llvm::InternalLinkage);\n+        let sc = do str::as_c_str(s) |buf| {\n+            llvm::LLVMConstString(buf, str::len(s) as c_uint, False)\n+        };\n+        let g =\n+            str::as_c_str(fmt!(\"str%u\", (cx.names)(~\"str\").repr),\n+                        |buf| llvm::LLVMAddGlobal(cx.llmod, val_ty(sc), buf));\n+        llvm::LLVMSetInitializer(g, sc);\n+        llvm::LLVMSetGlobalConstant(g, True);\n+        lib::llvm::SetLinkage(g, lib::llvm::InternalLinkage);\n \n-    cx.const_cstr_cache.insert(s, g);\n+        cx.const_cstr_cache.insert(s, g);\n \n-    return g;\n+        return g;\n+    }\n }\n \n // NB: Do not use `do_spill_noroot` to make this into a constant string, or\n // you will be kicked off fast isel. See issue #4352 for an example of this.\n fn C_estr_slice(cx: @crate_ctxt, +s: ~str) -> ValueRef {\n-    let len = str::len(s);\n-    let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s), T_ptr(T_i8()));\n-    C_struct(~[cs, C_uint(cx, len + 1u /* +1 for null */)])\n+    unsafe {\n+        let len = str::len(s);\n+        let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s), T_ptr(T_i8()));\n+        C_struct(~[cs, C_uint(cx, len + 1u /* +1 for null */)])\n+    }\n }\n \n // Returns a Plain Old LLVM String:\n fn C_postr(s: ~str) -> ValueRef {\n-    return do str::as_c_str(s) |buf| {\n-        llvm::LLVMConstString(buf, str::len(s) as c_uint, False)\n-    };\n+    unsafe {\n+        return do str::as_c_str(s) |buf| {\n+            llvm::LLVMConstString(buf, str::len(s) as c_uint, False)\n+        };\n+    }\n }\n \n fn C_zero_byte_arr(size: uint) -> ValueRef unsafe {\n-    let mut i = 0u;\n-    let mut elts: ~[ValueRef] = ~[];\n-    while i < size { elts.push(C_u8(0u)); i += 1u; }\n-    return llvm::LLVMConstArray(T_i8(), vec::raw::to_ptr(elts),\n-                             elts.len() as c_uint);\n+    unsafe {\n+        let mut i = 0u;\n+        let mut elts: ~[ValueRef] = ~[];\n+        while i < size { elts.push(C_u8(0u)); i += 1u; }\n+        return llvm::LLVMConstArray(T_i8(),\n+                                    vec::raw::to_ptr(elts),\n+                                    elts.len() as c_uint);\n+    }\n }\n \n fn C_struct(elts: &[ValueRef]) -> ValueRef {\n-    do vec::as_imm_buf(elts) |ptr, len| {\n-        llvm::LLVMConstStruct(ptr, len as c_uint, False)\n+    unsafe {\n+        do vec::as_imm_buf(elts) |ptr, len| {\n+            llvm::LLVMConstStruct(ptr, len as c_uint, False)\n+        }\n     }\n }\n \n fn C_named_struct(T: TypeRef, elts: &[ValueRef]) -> ValueRef {\n-    do vec::as_imm_buf(elts) |ptr, len| {\n-        llvm::LLVMConstNamedStruct(T, ptr, len as c_uint)\n+    unsafe {\n+        do vec::as_imm_buf(elts) |ptr, len| {\n+            llvm::LLVMConstNamedStruct(T, ptr, len as c_uint)\n+        }\n     }\n }\n \n fn C_array(ty: TypeRef, elts: ~[ValueRef]) -> ValueRef unsafe {\n-    return llvm::LLVMConstArray(ty, vec::raw::to_ptr(elts),\n-                             elts.len() as c_uint);\n+    unsafe {\n+        return llvm::LLVMConstArray(ty, vec::raw::to_ptr(elts),\n+                                 elts.len() as c_uint);\n+    }\n }\n \n fn C_bytes(bytes: ~[u8]) -> ValueRef unsafe {\n-    return llvm::LLVMConstString(\n-        cast::reinterpret_cast(&vec::raw::to_ptr(bytes)),\n-        bytes.len() as c_uint, True);\n+    unsafe {\n+        return llvm::LLVMConstString(\n+            cast::reinterpret_cast(&vec::raw::to_ptr(bytes)),\n+            bytes.len() as c_uint, True);\n+    }\n }\n \n fn C_bytes_plus_null(bytes: ~[u8]) -> ValueRef unsafe {\n-    return llvm::LLVMConstString(\n-        cast::reinterpret_cast(&vec::raw::to_ptr(bytes)),\n-        bytes.len() as c_uint, False);\n+    unsafe {\n+        return llvm::LLVMConstString(\n+            cast::reinterpret_cast(&vec::raw::to_ptr(bytes)),\n+            bytes.len() as c_uint, False);\n+    }\n }\n \n fn C_shape(ccx: @crate_ctxt, +bytes: ~[u8]) -> ValueRef {\n-    let llshape = C_bytes_plus_null(bytes);\n-    let name = fmt!(\"shape%u\", (ccx.names)(~\"shape\").repr);\n-    let llglobal = str::as_c_str(name, |buf| {\n-        llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape), buf)\n-    });\n-    llvm::LLVMSetInitializer(llglobal, llshape);\n-    llvm::LLVMSetGlobalConstant(llglobal, True);\n-    lib::llvm::SetLinkage(llglobal, lib::llvm::InternalLinkage);\n-    return llvm::LLVMConstPointerCast(llglobal, T_ptr(T_i8()));\n+    unsafe {\n+        let llshape = C_bytes_plus_null(bytes);\n+        let name = fmt!(\"shape%u\", (ccx.names)(~\"shape\").repr);\n+        let llglobal = str::as_c_str(name, |buf| {\n+            llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape), buf)\n+        });\n+        llvm::LLVMSetInitializer(llglobal, llshape);\n+        llvm::LLVMSetGlobalConstant(llglobal, True);\n+        lib::llvm::SetLinkage(llglobal, lib::llvm::InternalLinkage);\n+        return llvm::LLVMConstPointerCast(llglobal, T_ptr(T_i8()));\n+    }\n }\n \n fn get_param(fndecl: ValueRef, param: uint) -> ValueRef {\n-    llvm::LLVMGetParam(fndecl, param as c_uint)\n+    unsafe {\n+        llvm::LLVMGetParam(fndecl, param as c_uint)\n+    }\n }\n \n // Used to identify cached monomorphized functions and vtables"}, {"sha": "588a64229f955903b70ca7cb31f4839ef7dd1515", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 353, "deletions": 330, "changes": 683, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -59,41 +59,49 @@ fn const_lit(cx: @crate_ctxt, e: @ast::expr, lit: ast::lit)\n }\n \n fn const_ptrcast(cx: @crate_ctxt, a: ValueRef, t: TypeRef) -> ValueRef {\n-    let b = llvm::LLVMConstPointerCast(a, T_ptr(t));\n-    assert cx.const_globals.insert(b as int, a);\n-    b\n+    unsafe {\n+        let b = llvm::LLVMConstPointerCast(a, T_ptr(t));\n+        assert cx.const_globals.insert(b as int, a);\n+        b\n+    }\n }\n \n fn const_vec(cx: @crate_ctxt, e: @ast::expr, es: &[@ast::expr])\n     -> (ValueRef, ValueRef, TypeRef) {\n-    let vec_ty = ty::expr_ty(cx.tcx, e);\n-    let unit_ty = ty::sequence_element_type(cx.tcx, vec_ty);\n-    let llunitty = type_of::type_of(cx, unit_ty);\n-    let v = C_array(llunitty, es.map(|e| const_expr(cx, *e)));\n-    let unit_sz = shape::llsize_of(cx, llunitty);\n-    let sz = llvm::LLVMConstMul(C_uint(cx, es.len()), unit_sz);\n-    return (v, sz, llunitty);\n+    unsafe {\n+        let vec_ty = ty::expr_ty(cx.tcx, e);\n+        let unit_ty = ty::sequence_element_type(cx.tcx, vec_ty);\n+        let llunitty = type_of::type_of(cx, unit_ty);\n+        let v = C_array(llunitty, es.map(|e| const_expr(cx, *e)));\n+        let unit_sz = shape::llsize_of(cx, llunitty);\n+        let sz = llvm::LLVMConstMul(C_uint(cx, es.len()), unit_sz);\n+        return (v, sz, llunitty);\n+    }\n }\n \n fn const_deref(cx: @crate_ctxt, v: ValueRef) -> ValueRef {\n-    let v = match cx.const_globals.find(v as int) {\n-        Some(v) => v,\n-        None => v\n-    };\n-    assert llvm::LLVMIsGlobalConstant(v) == True;\n-    let v = llvm::LLVMGetInitializer(v);\n-    v\n+    unsafe {\n+        let v = match cx.const_globals.find(v as int) {\n+            Some(v) => v,\n+            None => v\n+        };\n+        assert llvm::LLVMIsGlobalConstant(v) == True;\n+        let v = llvm::LLVMGetInitializer(v);\n+        v\n+    }\n }\n \n fn const_get_elt(cx: @crate_ctxt, v: ValueRef, us: &[c_uint]) -> ValueRef {\n-    let r = do vec::as_imm_buf(us) |p, len| {\n-        llvm::LLVMConstExtractValue(v, p, len as c_uint)\n-    };\n+    unsafe {\n+        let r = do vec::as_imm_buf(us) |p, len| {\n+            llvm::LLVMConstExtractValue(v, p, len as c_uint)\n+        };\n \n-    debug!(\"const_get_elt(v=%s, us=%?, r=%s)\",\n-           val_str(cx.tn, v), us, val_str(cx.tn, r));\n+        debug!(\"const_get_elt(v=%s, us=%?, r=%s)\",\n+               val_str(cx.tn, v), us, val_str(cx.tn, r));\n \n-    return r;\n+        return r;\n+    }\n }\n \n fn const_autoderef(cx: @crate_ctxt, ty: ty::t, v: ValueRef)\n@@ -130,345 +138,360 @@ fn get_const_val(cx: @crate_ctxt, def_id: ast::def_id) -> ValueRef {\n }\n \n fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n-    let _icx = cx.insn_ctxt(\"const_expr\");\n-    return match /*bad*/copy e.node {\n-      ast::expr_lit(lit) => consts::const_lit(cx, e, *lit),\n-      ast::expr_binary(b, e1, e2) => {\n-        let te1 = const_expr(cx, e1);\n-        let te2 = const_expr(cx, e2);\n+    unsafe {\n+        let _icx = cx.insn_ctxt(\"const_expr\");\n+        return match /*bad*/copy e.node {\n+          ast::expr_lit(lit) => consts::const_lit(cx, e, *lit),\n+          ast::expr_binary(b, e1, e2) => {\n+            let te1 = const_expr(cx, e1);\n+            let te2 = const_expr(cx, e2);\n \n-        let te2 = base::cast_shift_const_rhs(b, te1, te2);\n+            let te2 = base::cast_shift_const_rhs(b, te1, te2);\n \n-        /* Neither type is bottom, and we expect them to be unified already,\n-         * so the following is safe. */\n-        let ty = ty::expr_ty(cx.tcx, e1);\n-        let is_float = ty::type_is_fp(ty);\n-        let signed = ty::type_is_signed(ty);\n-        return match b {\n-          ast::add   => {\n-            if is_float { llvm::LLVMConstFAdd(te1, te2) }\n-            else        { llvm::LLVMConstAdd(te1, te2) }\n-          }\n-          ast::subtract => {\n-            if is_float { llvm::LLVMConstFSub(te1, te2) }\n-            else        { llvm::LLVMConstSub(te1, te2) }\n-          }\n-          ast::mul    => {\n-            if is_float { llvm::LLVMConstFMul(te1, te2) }\n-            else        { llvm::LLVMConstMul(te1, te2) }\n-          }\n-          ast::div    => {\n-            if is_float    { llvm::LLVMConstFDiv(te1, te2) }\n-            else if signed { llvm::LLVMConstSDiv(te1, te2) }\n-            else           { llvm::LLVMConstUDiv(te1, te2) }\n-          }\n-          ast::rem    => {\n-            if is_float    { llvm::LLVMConstFRem(te1, te2) }\n-            else if signed { llvm::LLVMConstSRem(te1, te2) }\n-            else           { llvm::LLVMConstURem(te1, te2) }\n-          }\n-          ast::and    |\n-          ast::or     => cx.sess.span_unimpl(e.span, ~\"binop logic\"),\n-          ast::bitxor => llvm::LLVMConstXor(te1, te2),\n-          ast::bitand => llvm::LLVMConstAnd(te1, te2),\n-          ast::bitor  => llvm::LLVMConstOr(te1, te2),\n-          ast::shl    => llvm::LLVMConstShl(te1, te2),\n-          ast::shr    => {\n-            if signed { llvm::LLVMConstAShr(te1, te2) }\n-            else      { llvm::LLVMConstLShr(te1, te2) }\n+            /* Neither type is bottom, and we expect them to be unified\n+             * already, so the following is safe. */\n+            let ty = ty::expr_ty(cx.tcx, e1);\n+            let is_float = ty::type_is_fp(ty);\n+            let signed = ty::type_is_signed(ty);\n+            return match b {\n+              ast::add   => {\n+                if is_float { llvm::LLVMConstFAdd(te1, te2) }\n+                else        { llvm::LLVMConstAdd(te1, te2) }\n+              }\n+              ast::subtract => {\n+                if is_float { llvm::LLVMConstFSub(te1, te2) }\n+                else        { llvm::LLVMConstSub(te1, te2) }\n+              }\n+              ast::mul    => {\n+                if is_float { llvm::LLVMConstFMul(te1, te2) }\n+                else        { llvm::LLVMConstMul(te1, te2) }\n+              }\n+              ast::div    => {\n+                if is_float    { llvm::LLVMConstFDiv(te1, te2) }\n+                else if signed { llvm::LLVMConstSDiv(te1, te2) }\n+                else           { llvm::LLVMConstUDiv(te1, te2) }\n+              }\n+              ast::rem    => {\n+                if is_float    { llvm::LLVMConstFRem(te1, te2) }\n+                else if signed { llvm::LLVMConstSRem(te1, te2) }\n+                else           { llvm::LLVMConstURem(te1, te2) }\n+              }\n+              ast::and    |\n+              ast::or     => cx.sess.span_unimpl(e.span, ~\"binop logic\"),\n+              ast::bitxor => llvm::LLVMConstXor(te1, te2),\n+              ast::bitand => llvm::LLVMConstAnd(te1, te2),\n+              ast::bitor  => llvm::LLVMConstOr(te1, te2),\n+              ast::shl    => llvm::LLVMConstShl(te1, te2),\n+              ast::shr    => {\n+                if signed { llvm::LLVMConstAShr(te1, te2) }\n+                else      { llvm::LLVMConstLShr(te1, te2) }\n+              }\n+              ast::eq     |\n+              ast::lt     |\n+              ast::le     |\n+              ast::ne     |\n+              ast::ge     |\n+              ast::gt     => cx.sess.span_unimpl(e.span, ~\"binop comparator\")\n+            }\n           }\n-          ast::eq     |\n-          ast::lt     |\n-          ast::le     |\n-          ast::ne     |\n-          ast::ge     |\n-          ast::gt     => cx.sess.span_unimpl(e.span, ~\"binop comparator\")\n-        }\n-      }\n-      ast::expr_unary(u, e) => {\n-        let te = const_expr(cx, e);\n-        let ty = ty::expr_ty(cx.tcx, e);\n-        let is_float = ty::type_is_fp(ty);\n-        return match u {\n-          ast::box(_)  |\n-          ast::uniq(_) |\n-          ast::deref  => const_deref(cx, te),\n-          ast::not    => llvm::LLVMConstNot(te),\n-          ast::neg    => {\n-            if is_float { llvm::LLVMConstFNeg(te) }\n-            else        { llvm::LLVMConstNeg(te) }\n+          ast::expr_unary(u, e) => {\n+            let te = const_expr(cx, e);\n+            let ty = ty::expr_ty(cx.tcx, e);\n+            let is_float = ty::type_is_fp(ty);\n+            return match u {\n+              ast::box(_)  |\n+              ast::uniq(_) |\n+              ast::deref  => const_deref(cx, te),\n+              ast::not    => llvm::LLVMConstNot(te),\n+              ast::neg    => {\n+                if is_float { llvm::LLVMConstFNeg(te) }\n+                else        { llvm::LLVMConstNeg(te) }\n+              }\n+            }\n           }\n-        }\n-      }\n-      ast::expr_field(base, field, _) => {\n-          let bt = ty::expr_ty(cx.tcx, base);\n-          let bv = const_expr(cx, base);\n-          let (bt, bv) = const_autoderef(cx, bt, bv);\n-          do expr::with_field_tys(cx.tcx, bt, None) |_has_dtor, field_tys| {\n-              let ix = ty::field_idx_strict(cx.tcx, field, field_tys);\n+          ast::expr_field(base, field, _) => {\n+              let bt = ty::expr_ty(cx.tcx, base);\n+              let bv = const_expr(cx, base);\n+              let (bt, bv) = const_autoderef(cx, bt, bv);\n+              do expr::with_field_tys(cx.tcx, bt, None) |_, field_tys| {\n+                  let ix = ty::field_idx_strict(cx.tcx, field, field_tys);\n \n-              // Note: ideally, we'd use `struct_field()` here instead\n-              // of hardcoding [0, ix], but we can't because it yields\n-              // the wrong type and also inserts an extra 0 that is\n-              // not needed in the constant variety:\n-              const_get_elt(cx, bv, [0, ix as c_uint])\n+                  // Note: ideally, we'd use `struct_field()` here instead\n+                  // of hardcoding [0, ix], but we can't because it yields\n+                  // the wrong type and also inserts an extra 0 that is\n+                  // not needed in the constant variety:\n+                  const_get_elt(cx, bv, [0, ix as c_uint])\n+              }\n           }\n-      }\n \n-      ast::expr_index(base, index) => {\n-          let bt = ty::expr_ty(cx.tcx, base);\n-          let bv = const_expr(cx, base);\n-          let (bt, bv) = const_autoderef(cx, bt, bv);\n-          let iv = match const_eval::eval_const_expr(cx.tcx, index) {\n-              const_eval::const_int(i) => i as u64,\n-              const_eval::const_uint(u) => u,\n-              _ => cx.sess.span_bug(index.span,\n-                                    ~\"index is not an integer-constant \\\n-                                      expression\")\n-          };\n-          let (arr, _len) = match ty::get(bt).sty {\n-              ty::ty_evec(_, vstore) | ty::ty_estr(vstore) =>\n-                  match vstore {\n-                  ty::vstore_fixed(u) =>\n-                      (bv, C_uint(cx, u)),\n+          ast::expr_index(base, index) => {\n+              let bt = ty::expr_ty(cx.tcx, base);\n+              let bv = const_expr(cx, base);\n+              let (bt, bv) = const_autoderef(cx, bt, bv);\n+              let iv = match const_eval::eval_const_expr(cx.tcx, index) {\n+                  const_eval::const_int(i) => i as u64,\n+                  const_eval::const_uint(u) => u,\n+                  _ => cx.sess.span_bug(index.span,\n+                                        ~\"index is not an integer-constant \\\n+                                          expression\")\n+              };\n+              let (arr, _len) = match ty::get(bt).sty {\n+                  ty::ty_evec(_, vstore) | ty::ty_estr(vstore) =>\n+                      match vstore {\n+                      ty::vstore_fixed(u) =>\n+                          (bv, C_uint(cx, u)),\n \n-                  ty::vstore_slice(_) => {\n-                      let unit_ty = ty::sequence_element_type(cx.tcx, bt);\n-                      let llunitty = type_of::type_of(cx, unit_ty);\n-                      let unit_sz = shape::llsize_of(cx, llunitty);\n+                      ty::vstore_slice(_) => {\n+                          let unit_ty = ty::sequence_element_type(cx.tcx, bt);\n+                          let llunitty = type_of::type_of(cx, unit_ty);\n+                          let unit_sz = shape::llsize_of(cx, llunitty);\n \n-                      (const_deref(cx, const_get_elt(cx, bv, [0])),\n-                       llvm::LLVMConstUDiv(const_get_elt(cx, bv, [1]),\n-                                           unit_sz))\n+                          (const_deref(cx, const_get_elt(cx, bv, [0])),\n+                           llvm::LLVMConstUDiv(const_get_elt(cx, bv, [1]),\n+                                               unit_sz))\n+                      },\n+                      _ => cx.sess.span_bug(base.span,\n+                                            ~\"index-expr base must be \\\n+                                              fixed-size or slice\")\n                   },\n-                  _ => cx.sess.span_bug(base.span,\n-                                        ~\"index-expr base must be \\\n-                                          fixed-size or slice\")\n-              },\n-              _ =>  cx.sess.span_bug(base.span,\n-                                     ~\"index-expr base must be \\\n-                                       a vector or string type\")\n-          };\n+                  _ =>  cx.sess.span_bug(base.span,\n+                                         ~\"index-expr base must be \\\n+                                           a vector or string type\")\n+              };\n \n-          // FIXME #3169: This is a little odd but it arises due to a weird\n-          // wrinkle in LLVM: it doesn't appear willing to let us call\n-          // LLVMConstIntGetZExtValue on the size element of the slice, or\n-          // seemingly any integer-const involving a sizeof() call. Despite\n-          // that being \"a const\", it's not the kind of const you can ask\n-          // for the integer-value of, evidently. This might be an LLVM\n-          // bug, not sure. In any case, to work around this we drop down\n-          // to the array-type level here and just ask how long the\n-          // array-type itself is, ignoring the length we pulled out of the\n-          // slice. This in turn only works because we picked out the\n-          // original globalvar via const_deref and so can recover the\n-          // array-size of the underlying array, and all this will hold\n-          // together exactly as long as we _don't_ support const\n-          // sub-slices (that is, slices that represent something other\n-          // than a whole array).  At that point we'll have more and uglier\n-          // work to do here, but for now this should work.\n-          //\n-          // In the future, what we should be doing here is the\n-          // moral equivalent of:\n-          //\n-          // let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n-          //\n-          // but we might have to do substantially more magic to\n-          // make it work. Or figure out what is causing LLVM to\n-          // not want to consider sizeof() a constant expression\n-          // we can get the value (as a number) out of.\n+              // FIXME #3169: This is a little odd but it arises due to a\n+              // weird wrinkle in LLVM: it doesn't appear willing to let us\n+              // call LLVMConstIntGetZExtValue on the size element of the\n+              // slice, or seemingly any integer-const involving a sizeof()\n+              // call. Despite that being \"a const\", it's not the kind of\n+              // const you can ask for the integer-value of, evidently. This\n+              // might be an LLVM bug, not sure. In any case, to work around\n+              // this we drop down to the array-type level here and just ask\n+              // how long the array-type itself is, ignoring the length we\n+              // pulled out of the slice. This in turn only works because we\n+              // picked out the original globalvar via const_deref and so can\n+              // recover the array-size of the underlying array, and all this\n+              // will hold together exactly as long as we _don't_ support\n+              // const sub-slices (that is, slices that represent something\n+              // other than a whole array).  At that point we'll have more and\n+              // uglier work to do here, but for now this should work.\n+              //\n+              // In the future, what we should be doing here is the\n+              // moral equivalent of:\n+              //\n+              // let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n+              //\n+              // but we might have to do substantially more magic to\n+              // make it work. Or figure out what is causing LLVM to\n+              // not want to consider sizeof() a constant expression\n+              // we can get the value (as a number) out of.\n \n-          let len = llvm::LLVMGetArrayLength(val_ty(arr)) as u64;\n-          let len = match ty::get(bt).sty {\n-              ty::ty_estr(*) => {assert len > 0; len - 1},\n-              _ => len\n-          };\n-          if iv >= len {\n-              // FIXME #3170: report this earlier on in the const-eval\n-              // pass. Reporting here is a bit late.\n-              cx.sess.span_err(e.span,\n-                               ~\"const index-expr is out of bounds\");\n+              let len = llvm::LLVMGetArrayLength(val_ty(arr)) as u64;\n+              let len = match ty::get(bt).sty {\n+                  ty::ty_estr(*) => {assert len > 0; len - 1},\n+                  _ => len\n+              };\n+              if iv >= len {\n+                  // FIXME #3170: report this earlier on in the const-eval\n+                  // pass. Reporting here is a bit late.\n+                  cx.sess.span_err(e.span,\n+                                   ~\"const index-expr is out of bounds\");\n+              }\n+              const_get_elt(cx, arr, [iv as c_uint])\n           }\n-          const_get_elt(cx, arr, [iv as c_uint])\n-      }\n-      ast::expr_cast(base, _) => {\n-        let ety = ty::expr_ty(cx.tcx, e), llty = type_of::type_of(cx, ety);\n-        let basety = ty::expr_ty(cx.tcx, base);\n-        let v = const_expr(cx, base);\n-        match (expr::cast_type_kind(basety),\n-               expr::cast_type_kind(ety)) {\n+          ast::expr_cast(base, _) => {\n+            let ety = ty::expr_ty(cx.tcx, e);\n+            let llty = type_of::type_of(cx, ety);\n+            let basety = ty::expr_ty(cx.tcx, base);\n+            let v = const_expr(cx, base);\n+            match (expr::cast_type_kind(basety),\n+                   expr::cast_type_kind(ety)) {\n \n-          (expr::cast_integral, expr::cast_integral) => {\n-            let s = if ty::type_is_signed(basety) { True } else { False };\n-            llvm::LLVMConstIntCast(v, llty, s)\n-          }\n-          (expr::cast_integral, expr::cast_float) => {\n-            if ty::type_is_signed(basety) { llvm::LLVMConstSIToFP(v, llty) }\n-            else { llvm::LLVMConstUIToFP(v, llty) }\n-          }\n-          (expr::cast_float, expr::cast_float) => {\n-            llvm::LLVMConstFPCast(v, llty)\n-          }\n-          (expr::cast_float, expr::cast_integral) => {\n-            if ty::type_is_signed(ety) { llvm::LLVMConstFPToSI(v, llty) }\n-            else { llvm::LLVMConstFPToUI(v, llty) }\n-          }\n-          _ => cx.sess.impossible_case(e.span,\n-                                       ~\"bad combination of types for cast\")\n-        }\n-      }\n-      ast::expr_addr_of(ast::m_imm, sub) => {\n-        let cv = const_expr(cx, sub);\n-        let subty = ty::expr_ty(cx.tcx, sub),\n-        llty = type_of::type_of(cx, subty);\n-        let gv = do str::as_c_str(\"const\") |name| {\n-            llvm::LLVMAddGlobal(cx.llmod, llty, name)\n-        };\n-        llvm::LLVMSetInitializer(gv, cv);\n-        llvm::LLVMSetGlobalConstant(gv, True);\n-        gv\n-      }\n-      ast::expr_tup(es) => {\n-        C_struct(es.map(|e| const_expr(cx, *e)))\n-      }\n-      ast::expr_rec(ref fs, None) => {\n-          C_struct([C_struct(\n-              (*fs).map(|f| const_expr(cx, f.node.expr)))])\n-      }\n-      ast::expr_struct(_, ref fs, _) => {\n-          let ety = ty::expr_ty(cx.tcx, e);\n-          let cs = do expr::with_field_tys(cx.tcx,\n-                                           ety,\n-                                           None) |_hd, field_tys| {\n-              field_tys.map(|field_ty| {\n-                  match fs.find(|f| field_ty.ident == f.node.ident) {\n-                      Some(ref f) => const_expr(cx, (*f).node.expr),\n-                      None => {\n-                          cx.tcx.sess.span_bug(\n-                              e.span, ~\"missing struct field\");\n-                      }\n-                  }\n-              })\n-          };\n-          let llty = type_of::type_of(cx, ety);\n-          C_named_struct(llty, [C_struct(cs)])\n-      }\n-      ast::expr_vec(es, ast::m_imm) => {\n-        let (v, _, _) = const_vec(cx, e, es);\n-        v\n-      }\n-      ast::expr_vstore(e, ast::expr_vstore_fixed(_)) => {\n-        const_expr(cx, e)\n-      }\n-      ast::expr_vstore(sub, ast::expr_vstore_slice) => {\n-        match /*bad*/copy sub.node {\n-          ast::expr_lit(lit) => {\n-            match lit.node {\n-              ast::lit_str(*) => { const_expr(cx, sub) }\n-              _ => { cx.sess.span_bug(e.span,\n-                                      ~\"bad const-slice lit\") }\n+              (expr::cast_integral, expr::cast_integral) => {\n+                let s = if ty::type_is_signed(basety) { True } else { False };\n+                llvm::LLVMConstIntCast(v, llty, s)\n+              }\n+              (expr::cast_integral, expr::cast_float) => {\n+                if ty::type_is_signed(basety) {\n+                    llvm::LLVMConstSIToFP(v, llty)\n+                } else {\n+                    llvm::LLVMConstUIToFP(v, llty)\n+                }\n+              }\n+              (expr::cast_float, expr::cast_float) => {\n+                llvm::LLVMConstFPCast(v, llty)\n+              }\n+              (expr::cast_float, expr::cast_integral) => {\n+                if ty::type_is_signed(ety) { llvm::LLVMConstFPToSI(v, llty) }\n+                else { llvm::LLVMConstFPToUI(v, llty) }\n+              }\n+              _ => {\n+                cx.sess.impossible_case(e.span,\n+                                        ~\"bad combination of types for cast\")\n+              }\n             }\n           }\n-          ast::expr_vec(es, ast::m_imm) => {\n-            let (cv, sz, llunitty) = const_vec(cx, e, es);\n-            let llty = val_ty(cv);\n+          ast::expr_addr_of(ast::m_imm, sub) => {\n+            let cv = const_expr(cx, sub);\n+            let subty = ty::expr_ty(cx.tcx, sub),\n+            llty = type_of::type_of(cx, subty);\n             let gv = do str::as_c_str(\"const\") |name| {\n                 llvm::LLVMAddGlobal(cx.llmod, llty, name)\n             };\n             llvm::LLVMSetInitializer(gv, cv);\n             llvm::LLVMSetGlobalConstant(gv, True);\n-            let p = const_ptrcast(cx, gv, llunitty);\n-            C_struct(~[p, sz])\n+            gv\n           }\n-          _ => cx.sess.span_bug(e.span,\n-                                ~\"bad const-slice expr\")\n-        }\n-      }\n-      ast::expr_path(pth) => {\n-        assert pth.types.len() == 0;\n-        match cx.tcx.def_map.find(e.id) {\n-            Some(ast::def_fn(def_id, _)) => {\n-                assert ast_util::is_local(def_id);\n-                let f = base::get_item_val(cx, def_id.node);\n-                C_struct(~[f, C_null(T_opaque_box_ptr(cx))])\n-            }\n-            Some(ast::def_const(def_id)) => {\n-                get_const_val(cx, def_id)\n+          ast::expr_tup(es) => {\n+            C_struct(es.map(|e| const_expr(cx, *e)))\n+          }\n+          ast::expr_rec(ref fs, None) => {\n+              C_struct([C_struct(\n+                  (*fs).map(|f| const_expr(cx, f.node.expr)))])\n+          }\n+          ast::expr_struct(_, ref fs, _) => {\n+              let ety = ty::expr_ty(cx.tcx, e);\n+              let cs = do expr::with_field_tys(cx.tcx,\n+                                               ety,\n+                                               None) |_hd, field_tys| {\n+                  field_tys.map(|field_ty| {\n+                      match fs.find(|f| field_ty.ident == f.node.ident) {\n+                          Some(ref f) => const_expr(cx, (*f).node.expr),\n+                          None => {\n+                              cx.tcx.sess.span_bug(\n+                                  e.span, ~\"missing struct field\");\n+                          }\n+                      }\n+                  })\n+              };\n+              let llty = type_of::type_of(cx, ety);\n+              C_named_struct(llty, [C_struct(cs)])\n+          }\n+          ast::expr_vec(es, ast::m_imm) => {\n+            let (v, _, _) = const_vec(cx, e, es);\n+            v\n+          }\n+          ast::expr_vstore(e, ast::expr_vstore_fixed(_)) => {\n+            const_expr(cx, e)\n+          }\n+          ast::expr_vstore(sub, ast::expr_vstore_slice) => {\n+            match /*bad*/copy sub.node {\n+              ast::expr_lit(lit) => {\n+                match lit.node {\n+                  ast::lit_str(*) => { const_expr(cx, sub) }\n+                  _ => { cx.sess.span_bug(e.span,\n+                                          ~\"bad const-slice lit\") }\n+                }\n+              }\n+              ast::expr_vec(es, ast::m_imm) => {\n+                let (cv, sz, llunitty) = const_vec(cx, e, es);\n+                let llty = val_ty(cv);\n+                let gv = do str::as_c_str(\"const\") |name| {\n+                    llvm::LLVMAddGlobal(cx.llmod, llty, name)\n+                };\n+                llvm::LLVMSetInitializer(gv, cv);\n+                llvm::LLVMSetGlobalConstant(gv, True);\n+                let p = const_ptrcast(cx, gv, llunitty);\n+                C_struct(~[p, sz])\n+              }\n+              _ => cx.sess.span_bug(e.span,\n+                                    ~\"bad const-slice expr\")\n             }\n-            Some(ast::def_variant(enum_did, variant_did)) => {\n-                // Note that we know this is a C-like (nullary) enum variant,\n-                // or we wouldn't have gotten here -- the constant checker\n-                // forbids paths that don't map to C-like enum variants.\n-                let ety = ty::expr_ty(cx.tcx, e);\n-                let llty = type_of::type_of(cx, ety);\n-\n-                // Can't use `discrims` from the crate context here because\n-                // those discriminants have an extra level of indirection,\n-                // and there's no LLVM constant load instruction.\n-                let mut lldiscrim_opt = None;\n-                for ty::enum_variants(cx.tcx, enum_did).each |variant_info| {\n-                    if variant_info.id == variant_did {\n-                        lldiscrim_opt = Some(C_int(cx,\n-                                                   variant_info.disr_val));\n-                        break;\n-                    }\n+          }\n+          ast::expr_path(pth) => {\n+            assert pth.types.len() == 0;\n+            match cx.tcx.def_map.find(e.id) {\n+                Some(ast::def_fn(def_id, _)) => {\n+                    assert ast_util::is_local(def_id);\n+                    let f = base::get_item_val(cx, def_id.node);\n+                    C_struct(~[f, C_null(T_opaque_box_ptr(cx))])\n+                }\n+                Some(ast::def_const(def_id)) => {\n+                    get_const_val(cx, def_id)\n                 }\n+                Some(ast::def_variant(enum_did, variant_did)) => {\n+                    // Note that we know this is a C-like (nullary) enum\n+                    // variant or we wouldn't have gotten here -- the constant\n+                    // checker forbids paths that don't map to C-like enum\n+                    // variants.\n+                    let ety = ty::expr_ty(cx.tcx, e);\n+                    let llty = type_of::type_of(cx, ety);\n \n-                let lldiscrim;\n-                match lldiscrim_opt {\n-                    None => {\n-                        cx.tcx.sess.span_bug(e.span,\n-                                             ~\"didn't find discriminant?!\");\n+                    // Can't use `discrims` from the crate context here\n+                    // because those discriminants have an extra level of\n+                    // indirection, and there's no LLVM constant load\n+                    // instruction.\n+                    let mut lldiscrim_opt = None;\n+                    for ty::enum_variants(cx.tcx, enum_did).each\n+                            |variant_info| {\n+                        if variant_info.id == variant_did {\n+                            lldiscrim_opt = Some(C_int(cx,\n+                                variant_info.disr_val));\n+                            break;\n+                        }\n                     }\n-                    Some(found_lldiscrim) => {\n-                        lldiscrim = found_lldiscrim;\n+\n+                    let lldiscrim;\n+                    match lldiscrim_opt {\n+                        None => {\n+                            cx.tcx.sess.span_bug(e.span,\n+                                ~\"didn't find discriminant?!\");\n+                        }\n+                        Some(found_lldiscrim) => {\n+                            lldiscrim = found_lldiscrim;\n+                        }\n                     }\n-                }\n-                let fields = if ty::enum_is_univariant(cx.tcx, enum_did) {\n-                    ~[lldiscrim]\n-                } else {\n-                    let llstructtys = lib::llvm::struct_element_types(llty);\n-                    ~[lldiscrim, C_null(llstructtys[1])]\n-                };\n+                    let fields = if ty::enum_is_univariant(cx.tcx, enum_did) {\n+                        ~[lldiscrim]\n+                    } else {\n+                        let llstructtys =\n+                            lib::llvm::struct_element_types(llty);\n+                        ~[lldiscrim, C_null(llstructtys[1])]\n+                    };\n \n-                C_named_struct(llty, fields)\n-            }\n-            Some(ast::def_struct(_)) => {\n-                let ety = ty::expr_ty(cx.tcx, e);\n-                let llty = type_of::type_of(cx, ety);\n-                C_null(llty)\n-            }\n-            _ => {\n-                cx.sess.span_bug(e.span,\n-                                 ~\"expected a const, fn, or variant def\")\n+                    C_named_struct(llty, fields)\n+                }\n+                Some(ast::def_struct(_)) => {\n+                    let ety = ty::expr_ty(cx.tcx, e);\n+                    let llty = type_of::type_of(cx, ety);\n+                    C_null(llty)\n+                }\n+                _ => {\n+                    cx.sess.span_bug(e.span,\n+                                     ~\"expected a const, fn, or variant def\")\n+                }\n             }\n-        }\n-      }\n-      ast::expr_call(callee, args, _) => {\n-        match cx.tcx.def_map.find(callee.id) {\n-            Some(ast::def_struct(def_id)) => {\n-                let ety = ty::expr_ty(cx.tcx, e);\n-                let llty = type_of::type_of(cx, ety);\n-                let llstructbody = C_struct(args.map(|a| const_expr(cx, *a)));\n-                if ty::ty_dtor(cx.tcx, def_id).is_present() {\n-                    C_named_struct(llty, ~[ llstructbody, C_u8(0) ])\n-                } else {\n-                    C_named_struct(llty, ~[ llstructbody ])\n+          }\n+          ast::expr_call(callee, args, _) => {\n+            match cx.tcx.def_map.find(callee.id) {\n+                Some(ast::def_struct(def_id)) => {\n+                    let ety = ty::expr_ty(cx.tcx, e);\n+                    let llty = type_of::type_of(cx, ety);\n+                    let llstructbody =\n+                        C_struct(args.map(|a| const_expr(cx, *a)));\n+                    if ty::ty_dtor(cx.tcx, def_id).is_present() {\n+                        C_named_struct(llty, ~[ llstructbody, C_u8(0) ])\n+                    } else {\n+                        C_named_struct(llty, ~[ llstructbody ])\n+                    }\n                 }\n+                _ => cx.sess.span_bug(e.span, ~\"expected a struct def\")\n             }\n-            _ => cx.sess.span_bug(e.span, ~\"expected a struct def\")\n-        }\n-      }\n-      ast::expr_paren(e) => { return const_expr(cx, e); }\n-      _ => cx.sess.span_bug(e.span,\n-            ~\"bad constant expression type in consts::const_expr\")\n-    };\n+          }\n+          ast::expr_paren(e) => { return const_expr(cx, e); }\n+          _ => cx.sess.span_bug(e.span,\n+                ~\"bad constant expression type in consts::const_expr\")\n+        };\n+    }\n }\n \n fn trans_const(ccx: @crate_ctxt, e: @ast::expr, id: ast::node_id) {\n-    let _icx = ccx.insn_ctxt(\"trans_const\");\n-    let g = base::get_item_val(ccx, id);\n-    let v = const_expr(ccx, e);\n-    ccx.const_values.insert(id, v);\n-    llvm::LLVMSetInitializer(g, v);\n-    llvm::LLVMSetGlobalConstant(g, True);\n+    unsafe {\n+        let _icx = ccx.insn_ctxt(\"trans_const\");\n+        let g = base::get_item_val(ccx, id);\n+        let v = const_expr(ccx, e);\n+        ccx.const_values.insert(id, v);\n+        llvm::LLVMSetInitializer(g, v);\n+        llvm::LLVMSetGlobalConstant(g, True);\n+    }\n }"}, {"sha": "b325e33f03a1897ac640be4b19e6dcafc5769af2", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -186,12 +186,15 @@ fn trans_log(log_ex: @ast::expr,\n     } else {\n         let s = link::mangle_internal_name_by_path_and_seq(\n             ccx, modpath, ~\"loglevel\");\n-        let global = str::as_c_str(s, |buf| {\n-            llvm::LLVMAddGlobal(ccx.llmod, T_i32(), buf)\n-        });\n-        llvm::LLVMSetGlobalConstant(global, False);\n-        llvm::LLVMSetInitializer(global, C_null(T_i32()));\n-        lib::llvm::SetLinkage(global, lib::llvm::InternalLinkage);\n+        let global;\n+        unsafe {\n+            global = str::as_c_str(s, |buf| {\n+                llvm::LLVMAddGlobal(ccx.llmod, T_i32(), buf)\n+            });\n+            llvm::LLVMSetGlobalConstant(global, False);\n+            llvm::LLVMSetInitializer(global, C_null(T_i32()));\n+            lib::llvm::SetLinkage(global, lib::llvm::InternalLinkage);\n+        }\n         ccx.module_data.insert(modname, global);\n         global\n     };"}, {"sha": "95ff77c16b95f802d70b0bb9fab6268470f1fea0", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -69,7 +69,9 @@ const DW_ATE_unsigned_char: int = 0x08;\n \n fn llstr(s: ~str) -> ValueRef {\n     str::as_c_str(s, |sbuf| {\n-        llvm::LLVMMDString(sbuf, str::len(s) as libc::c_uint)\n+        unsafe {\n+            llvm::LLVMMDString(sbuf, str::len(s) as libc::c_uint)\n+        }\n     })\n }\n fn lltag(lltag: int) -> ValueRef {\n@@ -85,8 +87,10 @@ fn lli1(bval: bool) -> ValueRef {\n     C_bool(bval)\n }\n fn llmdnode(elems: ~[ValueRef]) -> ValueRef unsafe {\n-    llvm::LLVMMDNode(vec::raw::to_ptr(elems),\n-                     vec::len(elems) as libc::c_uint)\n+    unsafe {\n+        llvm::LLVMMDNode(vec::raw::to_ptr(elems),\n+                         vec::len(elems) as libc::c_uint)\n+    }\n }\n fn llunused() -> ValueRef {\n     lli32(0x0)\n@@ -97,7 +101,9 @@ fn llnull() -> ValueRef unsafe {\n \n fn add_named_metadata(cx: @crate_ctxt, name: ~str, val: ValueRef) {\n     str::as_c_str(name, |sbuf| {\n-        llvm::LLVMAddNamedMetadataOperand(cx.llmod, sbuf, val)\n+        unsafe {\n+            llvm::LLVMAddNamedMetadataOperand(cx.llmod, sbuf, val)\n+        }\n     })\n }\n \n@@ -744,7 +750,9 @@ fn update_source_pos(cx: block, s: span) {\n                      blockmd.node,\n                      llnull()];\n     let dbgscope = llmdnode(scopedata);\n-    llvm::LLVMSetCurrentDebugLocation(trans::build::B(cx), dbgscope);\n+    unsafe {\n+        llvm::LLVMSetCurrentDebugLocation(trans::build::B(cx), dbgscope);\n+    }\n }\n \n fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {"}, {"sha": "a13aa73f330d17c05afee98d0dfae66e8f9ac18b", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -1483,15 +1483,19 @@ fn trans_overloaded_op(bcx: block,\n fn int_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n             llsrc: ValueRef, signed: bool) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"int_cast\");\n-    let srcsz = llvm::LLVMGetIntTypeWidth(llsrctype);\n-    let dstsz = llvm::LLVMGetIntTypeWidth(lldsttype);\n-    return if dstsz == srcsz {\n-        BitCast(bcx, llsrc, lldsttype)\n-    } else if srcsz > dstsz {\n-        TruncOrBitCast(bcx, llsrc, lldsttype)\n-    } else if signed {\n-        SExtOrBitCast(bcx, llsrc, lldsttype)\n-    } else { ZExtOrBitCast(bcx, llsrc, lldsttype) };\n+    unsafe {\n+        let srcsz = llvm::LLVMGetIntTypeWidth(llsrctype);\n+        let dstsz = llvm::LLVMGetIntTypeWidth(lldsttype);\n+        return if dstsz == srcsz {\n+            BitCast(bcx, llsrc, lldsttype)\n+        } else if srcsz > dstsz {\n+            TruncOrBitCast(bcx, llsrc, lldsttype)\n+        } else if signed {\n+            SExtOrBitCast(bcx, llsrc, lldsttype)\n+        } else {\n+            ZExtOrBitCast(bcx, llsrc, lldsttype)\n+        };\n+    }\n }\n \n fn float_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,"}, {"sha": "c4231bfea8fe7d7b6644c5d2fc28dec894918448", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 173, "deletions": 155, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -92,56 +92,62 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n     }\n \n     fn struct_tys(ty: TypeRef) -> ~[TypeRef] {\n-        let n = llvm::LLVMCountStructElementTypes(ty);\n-        let mut elts = vec::from_elem(n as uint, ptr::null());\n-        llvm::LLVMGetStructElementTypes(ty,\n-                                        ptr::to_mut_unsafe_ptr(&mut elts[0]));\n-        return elts;\n+        unsafe {\n+            let n = llvm::LLVMCountStructElementTypes(ty);\n+            let mut elts = vec::from_elem(n as uint, ptr::null());\n+            llvm::LLVMGetStructElementTypes(ty,\n+                ptr::to_mut_unsafe_ptr(&mut elts[0]));\n+            return elts;\n+        }\n     }\n \n     fn ty_align(ty: TypeRef) -> uint {\n-        return match llvm::LLVMGetTypeKind(ty) {\n-            Integer => {\n-                ((llvm::LLVMGetIntTypeWidth(ty) as uint) + 7) / 8\n-            }\n-            Pointer => 8,\n-            Float => 4,\n-            Double => 8,\n-            Struct => {\n-              do vec::foldl(0, struct_tys(ty)) |a, t| {\n-                  uint::max(a, ty_align(*t))\n-              }\n-            }\n-            Array => {\n-                let elt = llvm::LLVMGetElementType(ty);\n-                ty_align(elt)\n-            }\n-            _ => fail ~\"ty_size: unhandled type\"\n-        };\n+        unsafe {\n+            return match llvm::LLVMGetTypeKind(ty) {\n+                Integer => {\n+                    ((llvm::LLVMGetIntTypeWidth(ty) as uint) + 7) / 8\n+                }\n+                Pointer => 8,\n+                Float => 4,\n+                Double => 8,\n+                Struct => {\n+                  do vec::foldl(0, struct_tys(ty)) |a, t| {\n+                      uint::max(a, ty_align(*t))\n+                  }\n+                }\n+                Array => {\n+                    let elt = llvm::LLVMGetElementType(ty);\n+                    ty_align(elt)\n+                }\n+                _ => fail ~\"ty_size: unhandled type\"\n+            };\n+        }\n     }\n \n     fn ty_size(ty: TypeRef) -> uint {\n-        return match llvm::LLVMGetTypeKind(ty) {\n-            Integer => {\n-                ((llvm::LLVMGetIntTypeWidth(ty) as uint) + 7) / 8\n-            }\n-            Pointer => 8,\n-            Float => 4,\n-            Double => 8,\n-            Struct => {\n-              let size = do vec::foldl(0, struct_tys(ty)) |s, t| {\n-                  align(s, *t) + ty_size(*t)\n-              };\n-              align(size, ty)\n-            }\n-            Array => {\n-              let len = llvm::LLVMGetArrayLength(ty) as uint;\n-              let elt = llvm::LLVMGetElementType(ty);\n-              let eltsz = ty_size(elt);\n-              len * eltsz\n-            }\n-            _ => fail ~\"ty_size: unhandled type\"\n-        };\n+        unsafe {\n+            return match llvm::LLVMGetTypeKind(ty) {\n+                Integer => {\n+                    ((llvm::LLVMGetIntTypeWidth(ty) as uint) + 7) / 8\n+                }\n+                Pointer => 8,\n+                Float => 4,\n+                Double => 8,\n+                Struct => {\n+                  let size = do vec::foldl(0, struct_tys(ty)) |s, t| {\n+                      align(s, *t) + ty_size(*t)\n+                  };\n+                  align(size, ty)\n+                }\n+                Array => {\n+                  let len = llvm::LLVMGetArrayLength(ty) as uint;\n+                  let elt = llvm::LLVMGetElementType(ty);\n+                  let eltsz = ty_size(elt);\n+                  len * eltsz\n+                }\n+                _ => fail ~\"ty_size: unhandled type\"\n+            };\n+        }\n     }\n \n     fn all_mem(cls: &[mut x86_64_reg_class]) {\n@@ -193,94 +199,98 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n     fn classify(ty: TypeRef,\n                 cls: &[mut x86_64_reg_class], ix: uint,\n                 off: uint) {\n-        let t_align = ty_align(ty);\n-        let t_size = ty_size(ty);\n-\n-        let misalign = off % t_align;\n-        if misalign != 0u {\n-            let mut i = off / 8u;\n-            let e = (off + t_size + 7u) / 8u;\n-            while i < e {\n-                unify(cls, ix + i, memory_class);\n-                i += 1u;\n+        unsafe {\n+            let t_align = ty_align(ty);\n+            let t_size = ty_size(ty);\n+\n+            let misalign = off % t_align;\n+            if misalign != 0u {\n+                let mut i = off / 8u;\n+                let e = (off + t_size + 7u) / 8u;\n+                while i < e {\n+                    unify(cls, ix + i, memory_class);\n+                    i += 1u;\n+                }\n+                return;\n             }\n-            return;\n-        }\n \n-        match llvm::LLVMGetTypeKind(ty) as int {\n-            8 /* integer */ |\n-            12 /* pointer */ => {\n-                unify(cls, ix + off / 8u, integer_class);\n-            }\n-            2 /* float */ => {\n-                if off % 8u == 4u {\n-                    unify(cls, ix + off / 8u, sse_fv_class);\n-                } else {\n-                    unify(cls, ix + off / 8u, sse_fs_class);\n+            match llvm::LLVMGetTypeKind(ty) as int {\n+                8 /* integer */ |\n+                12 /* pointer */ => {\n+                    unify(cls, ix + off / 8u, integer_class);\n                 }\n-            }\n-            3 /* double */ => {\n-                unify(cls, ix + off / 8u, sse_ds_class);\n-            }\n-            10 /* struct */ => {\n-                classify_struct(struct_tys(ty), cls, ix, off);\n-            }\n-            11 /* array */ => {\n-                let elt = llvm::LLVMGetElementType(ty);\n-                let eltsz = ty_size(elt);\n-                let len = llvm::LLVMGetArrayLength(ty) as uint;\n-                let mut i = 0u;\n-                while i < len {\n-                    classify(elt, cls, ix, off + i * eltsz);\n-                    i += 1u;\n+                2 /* float */ => {\n+                    if off % 8u == 4u {\n+                        unify(cls, ix + off / 8u, sse_fv_class);\n+                    } else {\n+                        unify(cls, ix + off / 8u, sse_fs_class);\n+                    }\n+                }\n+                3 /* double */ => {\n+                    unify(cls, ix + off / 8u, sse_ds_class);\n                 }\n+                10 /* struct */ => {\n+                    classify_struct(struct_tys(ty), cls, ix, off);\n+                }\n+                11 /* array */ => {\n+                    let elt = llvm::LLVMGetElementType(ty);\n+                    let eltsz = ty_size(elt);\n+                    let len = llvm::LLVMGetArrayLength(ty) as uint;\n+                    let mut i = 0u;\n+                    while i < len {\n+                        classify(elt, cls, ix, off + i * eltsz);\n+                        i += 1u;\n+                    }\n+                }\n+                _ => fail ~\"classify: unhandled type\"\n             }\n-            _ => fail ~\"classify: unhandled type\"\n         }\n     }\n \n     fn fixup(ty: TypeRef, cls: &[mut x86_64_reg_class]) {\n-        let mut i = 0u;\n-        let llty = llvm::LLVMGetTypeKind(ty) as int;\n-        let e = vec::len(cls);\n-        if vec::len(cls) > 2u &&\n-           (llty == 10 /* struct */ ||\n-            llty == 11 /* array */) {\n-            if is_sse(cls[i]) {\n-                i += 1u;\n+        unsafe {\n+            let mut i = 0u;\n+            let llty = llvm::LLVMGetTypeKind(ty) as int;\n+            let e = vec::len(cls);\n+            if vec::len(cls) > 2u &&\n+               (llty == 10 /* struct */ ||\n+                llty == 11 /* array */) {\n+                if is_sse(cls[i]) {\n+                    i += 1u;\n+                    while i < e {\n+                        if cls[i] != sseup_class {\n+                            all_mem(cls);\n+                            return;\n+                        }\n+                        i += 1u;\n+                    }\n+                } else {\n+                    all_mem(cls);\n+                    return\n+                }\n+            } else {\n                 while i < e {\n-                    if cls[i] != sseup_class {\n+                    if cls[i] == memory_class {\n                         all_mem(cls);\n                         return;\n                     }\n-                    i += 1u;\n-                }\n-            } else {\n-                all_mem(cls);\n-                return\n-            }\n-        } else {\n-            while i < e {\n-                if cls[i] == memory_class {\n-                    all_mem(cls);\n-                    return;\n-                }\n-                if cls[i] == x87up_class {\n-                    // for darwin\n-                    // cls[i] = sse_ds_class;\n-                    all_mem(cls);\n-                    return;\n-                }\n-                if cls[i] == sseup_class {\n-                    cls[i] = sse_int_class;\n-                } else if is_sse(cls[i]) {\n-                    i += 1;\n-                    while cls[i] == sseup_class { i += 1u; }\n-                } else if cls[i] == x87_class {\n-                    i += 1;\n-                    while cls[i] == x87up_class { i += 1u; }\n-                } else {\n-                    i += 1;\n+                    if cls[i] == x87up_class {\n+                        // for darwin\n+                        // cls[i] = sse_ds_class;\n+                        all_mem(cls);\n+                        return;\n+                    }\n+                    if cls[i] == sseup_class {\n+                        cls[i] = sse_int_class;\n+                    } else if is_sse(cls[i]) {\n+                        i += 1;\n+                        while cls[i] == sseup_class { i += 1u; }\n+                    } else if cls[i] == x87_class {\n+                        i += 1;\n+                        while cls[i] == x87up_class { i += 1u; }\n+                    } else {\n+                        i += 1;\n+                    }\n                 }\n             }\n         }\n@@ -309,33 +319,35 @@ fn llreg_ty(cls: &[x86_64_reg_class]) -> TypeRef {\n         return len;\n     }\n \n-    let mut tys = ~[];\n-    let mut i = 0u;\n-    let e = vec::len(cls);\n-    while i < e {\n-        match cls[i] {\n-            integer_class => {\n-                tys.push(T_i64());\n-            }\n-            sse_fv_class => {\n-                let vec_len = llvec_len(vec::tailn(cls, i + 1u)) * 2u;\n-                let vec_ty = llvm::LLVMVectorType(T_f32(),\n-                                                  vec_len as c_uint);\n-                tys.push(vec_ty);\n-                i += vec_len;\n-                loop;\n-            }\n-            sse_fs_class => {\n-                tys.push(T_f32());\n-            }\n-            sse_ds_class => {\n-                tys.push(T_f64());\n+    unsafe {\n+        let mut tys = ~[];\n+        let mut i = 0u;\n+        let e = vec::len(cls);\n+        while i < e {\n+            match cls[i] {\n+                integer_class => {\n+                    tys.push(T_i64());\n+                }\n+                sse_fv_class => {\n+                    let vec_len = llvec_len(vec::tailn(cls, i + 1u)) * 2u;\n+                    let vec_ty = llvm::LLVMVectorType(T_f32(),\n+                                                      vec_len as c_uint);\n+                    tys.push(vec_ty);\n+                    i += vec_len;\n+                    loop;\n+                }\n+                sse_fs_class => {\n+                    tys.push(T_f32());\n+                }\n+                sse_ds_class => {\n+                    tys.push(T_f64());\n+                }\n+                _ => fail ~\"llregtype: unhandled class\"\n             }\n-            _ => fail ~\"llregtype: unhandled class\"\n+            i += 1u;\n         }\n-        i += 1u;\n+        return T_struct(tys);\n     }\n-    return T_struct(tys);\n }\n \n type x86_64_llty = {\n@@ -354,13 +366,15 @@ fn x86_64_tys(atys: &[TypeRef],\n               rty: TypeRef,\n               ret_def: bool) -> x86_64_tys {\n     fn is_reg_ty(ty: TypeRef) -> bool {\n-        return match llvm::LLVMGetTypeKind(ty) as int {\n-            8 /* integer */ |\n-            12 /* pointer */ |\n-            2 /* float */ |\n-            3 /* double */ => true,\n-            _ => false\n-        };\n+        unsafe {\n+            return match llvm::LLVMGetTypeKind(ty) as int {\n+                8 /* integer */ |\n+                12 /* pointer */ |\n+                2 /* float */ |\n+                3 /* double */ => true,\n+                _ => false\n+            };\n+        }\n     }\n \n     fn is_pass_byval(cls: &[x86_64_reg_class]) -> bool {\n@@ -431,8 +445,10 @@ fn decl_x86_64_fn(tys: x86_64_tys,\n     for vec::eachi(tys.attrs) |i, a| {\n         match *a {\n             option::Some(attr) => {\n-                let llarg = get_param(llfn, i);\n-                llvm::LLVMAddAttribute(llarg, attr as c_uint);\n+                unsafe {\n+                    let llarg = get_param(llfn, i);\n+                    llvm::LLVMAddAttribute(llarg, attr as c_uint);\n+                }\n             }\n             _ => ()\n         }\n@@ -664,9 +680,11 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n                   for vec::eachi((*x86_64).attrs) |i, a| {\n                         match *a {\n                             Some(attr) => {\n-                                llvm::LLVMAddInstrAttribute(\n-                                    llretval, (i + 1u) as c_uint,\n-                                              attr as c_uint);\n+                                unsafe {\n+                                    llvm::LLVMAddInstrAttribute(\n+                                        llretval, (i + 1u) as c_uint,\n+                                                  attr as c_uint);\n+                                }\n                             }\n                             _ => ()\n                         }"}, {"sha": "3067051e428d9ac1f6cb452aed6b29a4cab68c4a", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 42, "deletions": 27, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -452,8 +452,10 @@ fn trans_struct_drop(bcx: block,\n                                      class_did, /*bad*/copy substs.tps);\n \n         // The second argument is the \"self\" argument for drop\n-        let params = lib::llvm::fn_ty_param_tys(\n-            llvm::LLVMGetElementType(llvm::LLVMTypeOf(dtor_addr)));\n+        let params = unsafe {\n+            lib::llvm::fn_ty_param_tys(\n+                llvm::LLVMGetElementType(llvm::LLVMTypeOf(dtor_addr)))\n+        };\n \n         // Class dtors have no explicit args, so the params should\n         // just consist of the output pointer and the environment\n@@ -662,7 +664,9 @@ fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n     note_unique_llvm_symbol(ccx, copy name);\n     log(debug, fmt!(\"+++ declare_tydesc %s %s\", ty_to_str(ccx.tcx, t), name));\n     let gvar = str::as_c_str(name, |buf| {\n-        llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type, buf)\n+        unsafe {\n+            llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type, buf)\n+        }\n     });\n     let inf =\n         @{ty: t,\n@@ -715,7 +719,7 @@ fn make_generic_glue_inner(ccx: @crate_ctxt, t: ty::t,\n \n     let bcx = top_scope_block(fcx, None);\n     let lltop = bcx.llbb;\n-    let llrawptr0 = llvm::LLVMGetParam(llfn, 3u as c_uint);\n+    let llrawptr0 = unsafe { llvm::LLVMGetParam(llfn, 3u as c_uint) };\n     helper(bcx, llrawptr0, t);\n     finish_fn(fcx, lltop);\n     return llfn;\n@@ -753,32 +757,40 @@ fn emit_tydescs(ccx: @crate_ctxt) {\n             match copy ti.take_glue {\n               None => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n               Some(v) => {\n-                ccx.stats.n_real_glues += 1u;\n-                llvm::LLVMConstPointerCast(v, glue_fn_ty)\n+                unsafe {\n+                    ccx.stats.n_real_glues += 1u;\n+                    llvm::LLVMConstPointerCast(v, glue_fn_ty)\n+                }\n               }\n             };\n         let drop_glue =\n             match copy ti.drop_glue {\n               None => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n               Some(v) => {\n-                ccx.stats.n_real_glues += 1u;\n-                llvm::LLVMConstPointerCast(v, glue_fn_ty)\n+                unsafe {\n+                    ccx.stats.n_real_glues += 1u;\n+                    llvm::LLVMConstPointerCast(v, glue_fn_ty)\n+                }\n               }\n             };\n         let free_glue =\n             match copy ti.free_glue {\n               None => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n               Some(v) => {\n-                ccx.stats.n_real_glues += 1u;\n-                llvm::LLVMConstPointerCast(v, glue_fn_ty)\n+                unsafe {\n+                    ccx.stats.n_real_glues += 1u;\n+                    llvm::LLVMConstPointerCast(v, glue_fn_ty)\n+                }\n               }\n             };\n         let visit_glue =\n             match copy ti.visit_glue {\n               None => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n               Some(v) => {\n-                ccx.stats.n_real_glues += 1u;\n-                llvm::LLVMConstPointerCast(v, glue_fn_ty)\n+                unsafe {\n+                    ccx.stats.n_real_glues += 1u;\n+                    llvm::LLVMConstPointerCast(v, glue_fn_ty)\n+                }\n               }\n             };\n \n@@ -796,21 +808,24 @@ fn emit_tydescs(ccx: @crate_ctxt) {\n                              shape, // shape\n                              shape_tables]); // shape_tables\n \n-        let gvar = ti.tydesc;\n-        llvm::LLVMSetInitializer(gvar, tydesc);\n-        llvm::LLVMSetGlobalConstant(gvar, True);\n-        lib::llvm::SetLinkage(gvar, lib::llvm::InternalLinkage);\n-\n-        // Index tydesc by addrspace.\n-        if ti.addrspace > gc_box_addrspace {\n-            let llty = T_ptr(ccx.tydesc_type);\n-            let addrspace_name = fmt!(\"_gc_addrspace_metadata_%u\",\n-                                      ti.addrspace as uint);\n-            let addrspace_gvar = str::as_c_str(addrspace_name, |buf| {\n-                llvm::LLVMAddGlobal(ccx.llmod, llty, buf)\n-            });\n-            lib::llvm::SetLinkage(addrspace_gvar, lib::llvm::InternalLinkage);\n-            llvm::LLVMSetInitializer(addrspace_gvar, gvar);\n+        unsafe {\n+            let gvar = ti.tydesc;\n+            llvm::LLVMSetInitializer(gvar, tydesc);\n+            llvm::LLVMSetGlobalConstant(gvar, True);\n+            lib::llvm::SetLinkage(gvar, lib::llvm::InternalLinkage);\n+\n+            // Index tydesc by addrspace.\n+            if ti.addrspace > gc_box_addrspace {\n+                let llty = T_ptr(ccx.tydesc_type);\n+                let addrspace_name = fmt!(\"_gc_addrspace_metadata_%u\",\n+                                          ti.addrspace as uint);\n+                let addrspace_gvar = str::as_c_str(addrspace_name, |buf| {\n+                    llvm::LLVMAddGlobal(ccx.llmod, llty, buf)\n+                });\n+                lib::llvm::SetLinkage(addrspace_gvar,\n+                                      lib::llvm::InternalLinkage);\n+                llvm::LLVMSetInitializer(addrspace_gvar, gvar);\n+            }\n         }\n     };\n }"}, {"sha": "0e778e2d705a6a5e234e6e0bebaf0e17e21dc55e", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -79,13 +79,17 @@ pub type tag_metrics = {\n \n // Returns the number of bytes clobbered by a Store to this type.\n pub fn llsize_of_store(cx: @crate_ctxt, t: TypeRef) -> uint {\n-    return llvm::LLVMStoreSizeOfType(cx.td.lltd, t) as uint;\n+    unsafe {\n+        return llvm::LLVMStoreSizeOfType(cx.td.lltd, t) as uint;\n+    }\n }\n \n // Returns the number of bytes between successive elements of type T in an\n // array of T. This is the \"ABI\" size. It includes any ABI-mandated padding.\n pub fn llsize_of_alloc(cx: @crate_ctxt, t: TypeRef) -> uint {\n-    return llvm::LLVMABISizeOfType(cx.td.lltd, t) as uint;\n+    unsafe {\n+        return llvm::LLVMABISizeOfType(cx.td.lltd, t) as uint;\n+    }\n }\n \n // Returns, as near as we can figure, the \"real\" size of a type. As in, the\n@@ -97,18 +101,22 @@ pub fn llsize_of_alloc(cx: @crate_ctxt, t: TypeRef) -> uint {\n // at the codegen level! In general you should prefer `llbitsize_of_real`\n // below.\n pub fn llsize_of_real(cx: @crate_ctxt, t: TypeRef) -> uint {\n-    let nbits = llvm::LLVMSizeOfTypeInBits(cx.td.lltd, t) as uint;\n-    if nbits & 7u != 0u {\n-        // Not an even number of bytes, spills into \"next\" byte.\n-        1u + (nbits >> 3)\n-    } else {\n-        nbits >> 3\n+    unsafe {\n+        let nbits = llvm::LLVMSizeOfTypeInBits(cx.td.lltd, t) as uint;\n+        if nbits & 7u != 0u {\n+            // Not an even number of bytes, spills into \"next\" byte.\n+            1u + (nbits >> 3)\n+        } else {\n+            nbits >> 3\n+        }\n     }\n }\n \n /// Returns the \"real\" size of the type in bits.\n pub fn llbitsize_of_real(cx: @crate_ctxt, t: TypeRef) -> uint {\n-    llvm::LLVMSizeOfTypeInBits(cx.td.lltd, t) as uint\n+    unsafe {\n+        llvm::LLVMSizeOfTypeInBits(cx.td.lltd, t) as uint\n+    }\n }\n \n // Returns the \"default\" size of t, which is calculated by casting null to a\n@@ -117,31 +125,40 @@ pub fn llbitsize_of_real(cx: @crate_ctxt, t: TypeRef) -> uint {\n // (i.e. including alignment-padding), but goodness knows which alignment it\n // winds up using. Probably the ABI one? Not recommended.\n pub fn llsize_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n-    return llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMSizeOf(t), cx.int_type,\n-                               False);\n+    unsafe {\n+        return llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMSizeOf(t),\n+                                      cx.int_type,\n+                                      False);\n+    }\n }\n \n // Returns the preferred alignment of the given type for the current target.\n // The preffered alignment may be larger than the alignment used when\n // packing the type into structs. This will be used for things like\n // allocations inside a stack frame, which LLVM has a free hand in.\n pub fn llalign_of_pref(cx: @crate_ctxt, t: TypeRef) -> uint {\n-    return llvm::LLVMPreferredAlignmentOfType(cx.td.lltd, t) as uint;\n+    unsafe {\n+        return llvm::LLVMPreferredAlignmentOfType(cx.td.lltd, t) as uint;\n+    }\n }\n \n // Returns the minimum alignment of a type required by the plattform.\n // This is the alignment that will be used for struct fields, arrays,\n // and similar ABI-mandated things.\n pub fn llalign_of_min(cx: @crate_ctxt, t: TypeRef) -> uint {\n-    return llvm::LLVMABIAlignmentOfType(cx.td.lltd, t) as uint;\n+    unsafe {\n+        return llvm::LLVMABIAlignmentOfType(cx.td.lltd, t) as uint;\n+    }\n }\n \n // Returns the \"default\" alignment of t, which is calculated by casting\n // null to a record containing a single-bit followed by a t value, then\n // doing gep(0,1) to get at the trailing (and presumably padded) t cell.\n pub fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n-    return llvm::LLVMConstIntCast(\n-        lib::llvm::llvm::LLVMAlignOf(t), cx.int_type, False);\n+    unsafe {\n+        return llvm::LLVMConstIntCast(\n+            lib::llvm::llvm::LLVMAlignOf(t), cx.int_type, False);\n+    }\n }\n \n // Computes the size of the data part of an enum."}, {"sha": "0fbeb2aadc337c1a2a7f48b2515e1c586ec225ba", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -755,16 +755,18 @@ fn get_vtable(ccx: @crate_ctxt, +origin: typeck::vtable_origin) -> ValueRef {\n }\n \n fn make_vtable(ccx: @crate_ctxt, ptrs: ~[ValueRef]) -> ValueRef {\n-    let _icx = ccx.insn_ctxt(\"impl::make_vtable\");\n-    let tbl = C_struct(ptrs);\n-    let vt_gvar =\n-            str::as_c_str(ccx.sess.str_of((ccx.names)(~\"vtable\")), |buf| {\n-        llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl), buf)\n-    });\n-    llvm::LLVMSetInitializer(vt_gvar, tbl);\n-    llvm::LLVMSetGlobalConstant(vt_gvar, lib::llvm::True);\n-    lib::llvm::SetLinkage(vt_gvar, lib::llvm::InternalLinkage);\n-    vt_gvar\n+    unsafe {\n+        let _icx = ccx.insn_ctxt(\"impl::make_vtable\");\n+        let tbl = C_struct(ptrs);\n+        let vt_gvar =\n+                str::as_c_str(ccx.sess.str_of((ccx.names)(~\"vtable\")), |buf| {\n+            llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl), buf)\n+        });\n+        llvm::LLVMSetInitializer(vt_gvar, tbl);\n+        llvm::LLVMSetGlobalConstant(vt_gvar, lib::llvm::True);\n+        lib::llvm::SetLinkage(vt_gvar, lib::llvm::InternalLinkage);\n+        vt_gvar\n+    }\n }\n \n fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: ~[ty::t],"}, {"sha": "b6f2a00f520019090609902a25c18c8186c445d8", "filename": "src/librustc/middle/trans/shape.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -38,26 +38,31 @@ type ctxt = {mut next_tag_id: u16, pad: u16, pad2: u32};\n \n fn mk_global(ccx: @crate_ctxt, name: ~str, llval: ValueRef, internal: bool) ->\n    ValueRef {\n-    let llglobal = do str::as_c_str(name) |buf| {\n-        llvm::LLVMAddGlobal(ccx.llmod, val_ty(llval), buf)\n-    };\n-    llvm::LLVMSetInitializer(llglobal, llval);\n-    llvm::LLVMSetGlobalConstant(llglobal, True);\n+    unsafe {\n+        let llglobal = do str::as_c_str(name) |buf| {\n+            llvm::LLVMAddGlobal(ccx.llmod, val_ty(llval), buf)\n+        };\n+        llvm::LLVMSetInitializer(llglobal, llval);\n+        llvm::LLVMSetGlobalConstant(llglobal, True);\n \n-    if internal {\n-        ::lib::llvm::SetLinkage(llglobal, ::lib::llvm::InternalLinkage);\n-    }\n+        if internal {\n+            ::lib::llvm::SetLinkage(llglobal,\n+                                    ::lib::llvm::InternalLinkage);\n+        }\n \n-    return llglobal;\n+        return llglobal;\n+    }\n }\n \n fn mk_ctxt(llmod: ModuleRef) -> ctxt {\n-    let llshapetablesty = trans::common::T_named_struct(~\"shapes\");\n-    let _llshapetables = str::as_c_str(~\"shapes\", |buf| {\n-        llvm::LLVMAddGlobal(llmod, llshapetablesty, buf)\n-    });\n+    unsafe {\n+        let llshapetablesty = trans::common::T_named_struct(~\"shapes\");\n+        let _llshapetables = str::as_c_str(~\"shapes\", |buf| {\n+            llvm::LLVMAddGlobal(llmod, llshapetablesty, buf)\n+        });\n \n-    return {mut next_tag_id: 0u16, pad: 0u16, pad2: 0u32};\n+        return {mut next_tag_id: 0u16, pad: 0u16, pad2: 0u32};\n+    }\n }\n \n /*"}, {"sha": "e85b7fe14dc3db221e4ff8b47a22a7159d113b1f", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -256,13 +256,20 @@ fn trans_lit_str(bcx: block,\n     match dest {\n         Ignore => bcx,\n         SaveIn(lldest) => {\n-            let bytes = lit_str.len() + 1; // count null-terminator too\n-            let llbytes = C_uint(bcx.ccx(), bytes);\n-            let llcstr = C_cstr(bcx.ccx(), /*bad*/copy *lit_str);\n-            let llcstr = llvm::LLVMConstPointerCast(llcstr, T_ptr(T_i8()));\n-            Store(bcx, llcstr, GEPi(bcx, lldest, [0u, abi::slice_elt_base]));\n-            Store(bcx, llbytes, GEPi(bcx, lldest, [0u, abi::slice_elt_len]));\n-            bcx\n+            unsafe {\n+                let bytes = lit_str.len() + 1; // count null-terminator too\n+                let llbytes = C_uint(bcx.ccx(), bytes);\n+                let llcstr = C_cstr(bcx.ccx(), /*bad*/copy *lit_str);\n+                let llcstr = llvm::LLVMConstPointerCast(llcstr,\n+                                                        T_ptr(T_i8()));\n+                Store(bcx,\n+                      llcstr,\n+                      GEPi(bcx, lldest, [0u, abi::slice_elt_base]));\n+                Store(bcx,\n+                      llbytes,\n+                      GEPi(bcx, lldest, [0u, abi::slice_elt_len]));\n+                bcx\n+            }\n         }\n     }\n }"}, {"sha": "c79cf45ec4bbaac26e5e5bc78c03398102af96c6", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -50,17 +50,19 @@ fn type_of_explicit_args(ccx: @crate_ctxt, inputs: ~[ty::arg]) -> ~[TypeRef] {\n \n fn type_of_fn(cx: @crate_ctxt, inputs: ~[ty::arg],\n               output: ty::t) -> TypeRef {\n-    let mut atys: ~[TypeRef] = ~[];\n+    unsafe {\n+        let mut atys: ~[TypeRef] = ~[];\n \n-    // Arg 0: Output pointer.\n-    atys.push(T_ptr(type_of(cx, output)));\n+        // Arg 0: Output pointer.\n+        atys.push(T_ptr(type_of(cx, output)));\n \n-    // Arg 1: Environment\n-    atys.push(T_opaque_box_ptr(cx));\n+        // Arg 1: Environment\n+        atys.push(T_opaque_box_ptr(cx));\n \n-    // ... then explicit args.\n-    atys.push_all(type_of_explicit_args(cx, inputs));\n-    return T_fn(atys, llvm::LLVMVoidType());\n+        // ... then explicit args.\n+        atys.push_all(type_of_explicit_args(cx, inputs));\n+        return T_fn(atys, llvm::LLVMVoidType());\n+    }\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n@@ -279,9 +281,11 @@ fn llvm_type_name(cx: @crate_ctxt,\n }\n \n fn type_of_dtor(ccx: @crate_ctxt, self_ty: ty::t) -> TypeRef {\n-    T_fn(~[T_ptr(type_of(ccx, ty::mk_nil(ccx.tcx))), // output pointer\n-           T_ptr(type_of(ccx, self_ty))],            // self arg\n-         llvm::LLVMVoidType())\n+    unsafe {\n+        T_fn(~[T_ptr(type_of(ccx, ty::mk_nil(ccx.tcx))), // output pointer\n+               T_ptr(type_of(ccx, self_ty))],            // self arg\n+             llvm::LLVMVoidType())\n+    }\n }\n \n fn type_of_rooted(ccx: @crate_ctxt, t: ty::t) -> TypeRef {"}, {"sha": "2a8a777ef6974b423fa7b01d5c18f47e3ef5d970", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -151,17 +151,19 @@ fn pandoc_writer(\n \n fn readclose(fd: libc::c_int) -> ~str {\n     // Copied from run::program_output\n-    let file = os::fdopen(fd);\n-    let reader = io::FILE_reader(file, false);\n-    let buf = io::with_bytes_writer(|writer| {\n-        let mut bytes = [mut 0, ..4096];\n-        while !reader.eof() {\n-            let nread = reader.read(bytes, bytes.len());\n-            writer.write(bytes.view(0, nread));\n-        }\n-    });\n-    os::fclose(file);\n-    str::from_bytes(buf)\n+    unsafe {\n+        let file = os::fdopen(fd);\n+        let reader = io::FILE_reader(file, false);\n+        let buf = io::with_bytes_writer(|writer| {\n+            let mut bytes = [mut 0, ..4096];\n+            while !reader.eof() {\n+                let nread = reader.read(bytes, bytes.len());\n+                writer.write(bytes.view(0, nread));\n+            }\n+        });\n+        os::fclose(file);\n+        str::from_bytes(buf)\n+    }\n }\n \n fn generic_writer(+process: fn~(+markdown: ~str)) -> Writer {"}, {"sha": "a669adc6dc8a4bb7b3abce7a34bc53ff22a93906", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -57,7 +57,9 @@ extern mod rusti {\n \n extern mod rustrt {\n     #[rust_stack]\n-    fn rust_call_tydesc_glue(root: *u8, tydesc: *TypeDesc, field: size_t);\n+    unsafe fn rust_call_tydesc_glue(root: *u8,\n+                                    tydesc: *TypeDesc,\n+                                    field: size_t);\n }\n // This probably belongs somewhere else. Needs to be kept in sync with\n // changes to glue..."}, {"sha": "9a910a2256cc6503f3ae733483aedec3fff96a9a", "filename": "src/libstd/dbg.rs", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibstd%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibstd%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdbg.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -18,33 +18,47 @@ use core::sys;\n #[abi = \"cdecl\"]\n extern mod rustrt {\n     #[legacy_exports];\n-    fn debug_tydesc(td: *sys::TypeDesc);\n-    fn debug_opaque(td: *sys::TypeDesc, x: *());\n-    fn debug_box(td: *sys::TypeDesc, x: *());\n-    fn debug_tag(td: *sys::TypeDesc, x: *());\n-    fn debug_fn(td: *sys::TypeDesc, x: *());\n-    fn debug_ptrcast(td: *sys::TypeDesc, x: *()) -> *();\n-    fn rust_dbg_breakpoint();\n+    unsafe fn debug_tydesc(td: *sys::TypeDesc);\n+    unsafe fn debug_opaque(td: *sys::TypeDesc, x: *());\n+    unsafe fn debug_box(td: *sys::TypeDesc, x: *());\n+    unsafe fn debug_tag(td: *sys::TypeDesc, x: *());\n+    unsafe fn debug_fn(td: *sys::TypeDesc, x: *());\n+    unsafe fn debug_ptrcast(td: *sys::TypeDesc, x: *()) -> *();\n+    unsafe fn rust_dbg_breakpoint();\n }\n \n pub fn debug_tydesc<T>() {\n-    rustrt::debug_tydesc(sys::get_type_desc::<T>());\n+    unsafe {\n+        rustrt::debug_tydesc(sys::get_type_desc::<T>());\n+    }\n }\n \n pub fn debug_opaque<T>(x: T) {\n-    rustrt::debug_opaque(sys::get_type_desc::<T>(), ptr::addr_of(&x) as *());\n+    unsafe {\n+        rustrt::debug_opaque(sys::get_type_desc::<T>(),\n+                             ptr::addr_of(&x) as *());\n+    }\n }\n \n pub fn debug_box<T>(x: @T) {\n-    rustrt::debug_box(sys::get_type_desc::<T>(), ptr::addr_of(&x) as *());\n+    unsafe {\n+        rustrt::debug_box(sys::get_type_desc::<T>(),\n+                          ptr::addr_of(&x) as *());\n+    }\n }\n \n pub fn debug_tag<T>(x: T) {\n-    rustrt::debug_tag(sys::get_type_desc::<T>(), ptr::addr_of(&x) as *());\n+    unsafe {\n+        rustrt::debug_tag(sys::get_type_desc::<T>(),\n+                          ptr::addr_of(&x) as *());\n+    }\n }\n \n pub fn debug_fn<T>(x: T) {\n-    rustrt::debug_fn(sys::get_type_desc::<T>(), ptr::addr_of(&x) as *());\n+    unsafe {\n+        rustrt::debug_fn(sys::get_type_desc::<T>(),\n+                         ptr::addr_of(&x) as *());\n+    }\n }\n \n pub unsafe fn ptr_cast<T, U>(x: @T) -> @U {\n@@ -55,7 +69,9 @@ pub unsafe fn ptr_cast<T, U>(x: @T) -> @U {\n \n /// Triggers a debugger breakpoint\n pub fn breakpoint() {\n-    rustrt::rust_dbg_breakpoint();\n+    unsafe {\n+        rustrt::rust_dbg_breakpoint();\n+    }\n }\n \n #[test]"}, {"sha": "1177ca4d69d575e6c4e5ce2169909b5aa211e248", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -33,9 +33,10 @@ use core::vec;\n \n #[nolink]\n extern mod rustrt {\n-    fn rust_uv_current_kernel_malloc(size: libc::c_uint) -> *libc::c_void;\n-    fn rust_uv_current_kernel_free(mem: *libc::c_void);\n-    fn rust_uv_helper_uv_tcp_t_size() -> libc::c_uint;\n+    unsafe fn rust_uv_current_kernel_malloc(size: libc::c_uint)\n+                                         -> *libc::c_void;\n+    unsafe fn rust_uv_current_kernel_free(mem: *libc::c_void);\n+    unsafe fn rust_uv_helper_uv_tcp_t_size() -> libc::c_uint;\n }\n \n /**"}, {"sha": "70c7161b4cfaa4d99dc19e99fe71b3e81b96ed5b", "filename": "src/libstd/rl.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibstd%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibstd%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frl.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -18,13 +18,13 @@ use core::task;\n \n extern mod rustrt {\n     #[legacy_exports];\n-    fn linenoise(prompt: *c_char) -> *c_char;\n-    fn linenoiseHistoryAdd(line: *c_char) -> c_int;\n-    fn linenoiseHistorySetMaxLen(len: c_int) -> c_int;\n-    fn linenoiseHistorySave(file: *c_char) -> c_int;\n-    fn linenoiseHistoryLoad(file: *c_char) -> c_int;\n-    fn linenoiseSetCompletionCallback(callback: *u8);\n-    fn linenoiseAddCompletion(completions: *(), line: *c_char);\n+    unsafe fn linenoise(prompt: *c_char) -> *c_char;\n+    unsafe fn linenoiseHistoryAdd(line: *c_char) -> c_int;\n+    unsafe fn linenoiseHistorySetMaxLen(len: c_int) -> c_int;\n+    unsafe fn linenoiseHistorySave(file: *c_char) -> c_int;\n+    unsafe fn linenoiseHistoryLoad(file: *c_char) -> c_int;\n+    unsafe fn linenoiseSetCompletionCallback(callback: *u8);\n+    unsafe fn linenoiseAddCompletion(completions: *(), line: *c_char);\n }\n \n /// Add a line to history"}, {"sha": "95523c1e5789f7d9c516d2db4ed3887bd9765d67", "filename": "src/libstd/test.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -39,7 +39,7 @@ use core::vec;\n #[abi = \"cdecl\"]\n extern mod rustrt {\n     #[legacy_exports];\n-    fn rust_sched_threads() -> size_t;\n+    unsafe fn rust_sched_threads() -> size_t;\n }\n \n // The name of a test. By convention this follows the rules for rust\n@@ -335,9 +335,11 @@ const sched_overcommit : uint = 1u;\n const sched_overcommit : uint = 4u;\n \n fn get_concurrency() -> uint {\n-    let threads = rustrt::rust_sched_threads() as uint;\n-    if threads == 1u { 1u }\n-    else { threads * sched_overcommit }\n+    unsafe {\n+        let threads = rustrt::rust_sched_threads() as uint;\n+        if threads == 1u { 1u }\n+        else { threads * sched_overcommit }\n+    }\n }\n \n #[allow(non_implicitly_copyable_typarams)]"}, {"sha": "8cc6d0245a1e31aebb7ca4ba22512f69fe0e436e", "filename": "src/libstd/time.rs", "status": "modified", "additions": 41, "deletions": 29, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -23,16 +23,16 @@ use core::str;\n #[abi = \"cdecl\"]\n extern mod rustrt {\n     #[legacy_exports]\n-    fn get_time(sec: &mut i64, nsec: &mut i32);\n+    unsafe fn get_time(sec: &mut i64, nsec: &mut i32);\n \n-    fn precise_time_ns(ns: &mut u64);\n+    unsafe fn precise_time_ns(ns: &mut u64);\n \n-    fn rust_tzset();\n+    unsafe fn rust_tzset();\n     // FIXME: The i64 values can be passed by-val when #2064 is fixed.\n-    fn rust_gmtime(&&sec: i64, &&nsec: i32, &&result: Tm);\n-    fn rust_localtime(&&sec: i64, &&nsec: i32, &&result: Tm);\n-    fn rust_timegm(&&tm: Tm, sec: &mut i64);\n-    fn rust_mktime(&&tm: Tm, sec: &mut i64);\n+    unsafe fn rust_gmtime(&&sec: i64, &&nsec: i32, &&result: Tm);\n+    unsafe fn rust_localtime(&&sec: i64, &&nsec: i32, &&result: Tm);\n+    unsafe fn rust_timegm(&&tm: Tm, sec: &mut i64);\n+    unsafe fn rust_mktime(&&tm: Tm, sec: &mut i64);\n }\n \n /// A record specifying a time value in seconds and nanoseconds.\n@@ -58,10 +58,12 @@ impl Timespec : Eq {\n  * nanoseconds since 1970-01-01T00:00:00Z.\n  */\n pub fn get_time() -> Timespec {\n-    let mut sec = 0i64;\n-    let mut nsec = 0i32;\n-    rustrt::get_time(&mut sec, &mut nsec);\n-    return Timespec::new(sec, nsec);\n+    unsafe {\n+        let mut sec = 0i64;\n+        let mut nsec = 0i32;\n+        rustrt::get_time(&mut sec, &mut nsec);\n+        return Timespec::new(sec, nsec);\n+    }\n }\n \n \n@@ -70,9 +72,11 @@ pub fn get_time() -> Timespec {\n  * in nanoseconds since an unspecified epoch.\n  */\n pub fn precise_time_ns() -> u64 {\n-    let mut ns = 0u64;\n-    rustrt::precise_time_ns(&mut ns);\n-    ns\n+    unsafe {\n+        let mut ns = 0u64;\n+        rustrt::precise_time_ns(&mut ns);\n+        ns\n+    }\n }\n \n \n@@ -85,7 +89,9 @@ pub fn precise_time_s() -> float {\n }\n \n pub fn tzset() {\n-    rustrt::rust_tzset();\n+    unsafe {\n+        rustrt::rust_tzset();\n+    }\n }\n \n #[auto_encode]\n@@ -142,10 +148,12 @@ pub pure fn empty_tm() -> Tm {\n \n /// Returns the specified time in UTC\n pub fn at_utc(clock: Timespec) -> Tm {\n-    let mut Timespec { sec, nsec } = clock;\n-    let mut tm = empty_tm();\n-    rustrt::rust_gmtime(sec, nsec, tm);\n-    move tm\n+    unsafe {\n+        let mut Timespec { sec, nsec } = clock;\n+        let mut tm = empty_tm();\n+        rustrt::rust_gmtime(sec, nsec, tm);\n+        move tm\n+    }\n }\n \n /// Returns the current time in UTC\n@@ -155,10 +163,12 @@ pub fn now_utc() -> Tm {\n \n /// Returns the specified time in the local timezone\n pub fn at(clock: Timespec) -> Tm {\n-    let mut Timespec { sec, nsec } = clock;\n-    let mut tm = empty_tm();\n-    rustrt::rust_localtime(sec, nsec, tm);\n-    move tm\n+    unsafe {\n+        let mut Timespec { sec, nsec } = clock;\n+        let mut tm = empty_tm();\n+        rustrt::rust_localtime(sec, nsec, tm);\n+        move tm\n+    }\n }\n \n /// Returns the current time in the local timezone\n@@ -183,13 +193,15 @@ pub pure fn strftime(format: &str, tm: &Tm) -> ~str {\n impl Tm {\n     /// Convert time to the seconds from January 1, 1970\n     fn to_timespec() -> Timespec {\n-        let mut sec = 0i64;\n-        if self.tm_gmtoff == 0_i32 {\n-            rustrt::rust_timegm(self, &mut sec);\n-        } else {\n-            rustrt::rust_mktime(self, &mut sec);\n+        unsafe {\n+            let mut sec = 0i64;\n+            if self.tm_gmtoff == 0_i32 {\n+                rustrt::rust_timegm(self, &mut sec);\n+            } else {\n+                rustrt::rust_mktime(self, &mut sec);\n+            }\n+            Timespec::new(sec, self.tm_nsec)\n         }\n-        Timespec::new(sec, self.tm_nsec)\n     }\n \n     /// Convert time to the local timezone"}, {"sha": "baf3610591a71bb53c5a244a5cf0ba37fca840e9", "filename": "src/libstd/unicode.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibstd%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibstd%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funicode.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -160,13 +160,13 @@ pub mod icu {\n     #[link_name = \"icuuc\"]\n     #[abi = \"cdecl\"]\n     pub extern mod libicu {\n-        pure fn u_hasBinaryProperty(c: UChar32, which: UProperty) -> UBool;\n-        pure fn u_isdigit(c: UChar32) -> UBool;\n-        pure fn u_islower(c: UChar32) -> UBool;\n-        pure fn u_isspace(c: UChar32) -> UBool;\n-        pure fn u_isupper(c: UChar32) -> UBool;\n-        pure fn u_tolower(c: UChar32) -> UChar32;\n-        pure fn u_toupper(c: UChar32) -> UChar32;\n+        unsafe fn u_hasBinaryProperty(c: UChar32, which: UProperty) -> UBool;\n+        unsafe fn u_isdigit(c: UChar32) -> UBool;\n+        unsafe fn u_islower(c: UChar32) -> UBool;\n+        unsafe fn u_isspace(c: UChar32) -> UBool;\n+        unsafe fn u_isupper(c: UChar32) -> UBool;\n+        unsafe fn u_tolower(c: UChar32) -> UChar32;\n+        unsafe fn u_toupper(c: UChar32) -> UChar32;\n     }\n }\n "}, {"sha": "276cb9cab6431ddc4cee3ad1596226318c0f6091", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -27,7 +27,7 @@ use core::task;\n use core::vec;\n \n extern mod rustrt {\n-    fn rust_uv_get_kernel_global_chan_ptr() -> *libc::uintptr_t;\n+    unsafe fn rust_uv_get_kernel_global_chan_ptr() -> *libc::uintptr_t;\n }\n \n /**"}, {"sha": "c9ff5e3796b178af51950a3f58f56877be91b28e", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 109, "deletions": 94, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "patch": "@@ -581,127 +581,142 @@ pub mod uv_ll_struct_stubgen {\n #[nolink]\n extern mod rustrt {\n     // libuv public API\n-    fn rust_uv_loop_new() -> *libc::c_void;\n-    fn rust_uv_loop_delete(lp: *libc::c_void);\n-    fn rust_uv_loop_refcount(loop_ptr: *libc::c_void) -> libc::c_int;\n-    fn rust_uv_run(loop_handle: *libc::c_void);\n-    fn rust_uv_close(handle: *libc::c_void, cb: *u8);\n-    fn rust_uv_async_send(handle: *uv_async_t);\n-    fn rust_uv_async_init(loop_handle: *libc::c_void,\n+    unsafe fn rust_uv_loop_new() -> *libc::c_void;\n+    unsafe fn rust_uv_loop_delete(lp: *libc::c_void);\n+    unsafe fn rust_uv_loop_refcount(loop_ptr: *libc::c_void) -> libc::c_int;\n+    unsafe fn rust_uv_run(loop_handle: *libc::c_void);\n+    unsafe fn rust_uv_close(handle: *libc::c_void, cb: *u8);\n+    unsafe fn rust_uv_async_send(handle: *uv_async_t);\n+    unsafe fn rust_uv_async_init(loop_handle: *libc::c_void,\n                           async_handle: *uv_async_t,\n                           cb: *u8) -> libc::c_int;\n-    fn rust_uv_tcp_init(\n+    unsafe fn rust_uv_tcp_init(\n         loop_handle: *libc::c_void,\n         handle_ptr: *uv_tcp_t) -> libc::c_int;\n     // FIXME ref #2604 .. ?\n-    fn rust_uv_buf_init(out_buf: *uv_buf_t, base: *u8,\n+    unsafe fn rust_uv_buf_init(out_buf: *uv_buf_t, base: *u8,\n                         len: libc::size_t);\n-    fn rust_uv_last_error(loop_handle: *libc::c_void) -> uv_err_t;\n+    unsafe fn rust_uv_last_error(loop_handle: *libc::c_void) -> uv_err_t;\n     // FIXME ref #2064\n-    fn rust_uv_strerror(err: *uv_err_t) -> *libc::c_char;\n+    unsafe fn rust_uv_strerror(err: *uv_err_t) -> *libc::c_char;\n     // FIXME ref #2064\n-    fn rust_uv_err_name(err: *uv_err_t) -> *libc::c_char;\n-    fn rust_uv_ip4_addr(ip: *u8, port: libc::c_int)\n+    unsafe fn rust_uv_err_name(err: *uv_err_t) -> *libc::c_char;\n+    unsafe fn rust_uv_ip4_addr(ip: *u8, port: libc::c_int)\n         -> sockaddr_in;\n-    fn rust_uv_ip6_addr(ip: *u8, port: libc::c_int)\n+    unsafe fn rust_uv_ip6_addr(ip: *u8, port: libc::c_int)\n         -> sockaddr_in6;\n-    fn rust_uv_ip4_name(src: *sockaddr_in, dst: *u8, size: libc::size_t)\n-        -> libc::c_int;\n-    fn rust_uv_ip6_name(src: *sockaddr_in6, dst: *u8, size: libc::size_t)\n-        -> libc::c_int;\n-    fn rust_uv_ip4_port(src: *sockaddr_in) -> libc::c_uint;\n-    fn rust_uv_ip6_port(src: *sockaddr_in6) -> libc::c_uint;\n+    unsafe fn rust_uv_ip4_name(src: *sockaddr_in,\n+                               dst: *u8,\n+                               size: libc::size_t)\n+                            -> libc::c_int;\n+    unsafe fn rust_uv_ip6_name(src: *sockaddr_in6,\n+                               dst: *u8,\n+                               size: libc::size_t)\n+                            -> libc::c_int;\n+    unsafe fn rust_uv_ip4_port(src: *sockaddr_in) -> libc::c_uint;\n+    unsafe fn rust_uv_ip6_port(src: *sockaddr_in6) -> libc::c_uint;\n     // FIXME ref #2064\n-    fn rust_uv_tcp_connect(connect_ptr: *uv_connect_t,\n-                           tcp_handle_ptr: *uv_tcp_t,\n-                           ++after_cb: *u8,\n-                           ++addr: *sockaddr_in) -> libc::c_int;\n+    unsafe fn rust_uv_tcp_connect(connect_ptr: *uv_connect_t,\n+                                  tcp_handle_ptr: *uv_tcp_t,\n+                                  ++after_cb: *u8,\n+                                  ++addr: *sockaddr_in) -> libc::c_int;\n     // FIXME ref #2064\n-    fn rust_uv_tcp_bind(tcp_server: *uv_tcp_t,\n-                        ++addr: *sockaddr_in) -> libc::c_int;\n+    unsafe fn rust_uv_tcp_bind(tcp_server: *uv_tcp_t,\n+                               ++addr: *sockaddr_in) -> libc::c_int;\n     // FIXME ref #2064\n-    fn rust_uv_tcp_connect6(connect_ptr: *uv_connect_t,\n-                           tcp_handle_ptr: *uv_tcp_t,\n-                           ++after_cb: *u8,\n-                           ++addr: *sockaddr_in6) -> libc::c_int;\n+    unsafe fn rust_uv_tcp_connect6(connect_ptr: *uv_connect_t,\n+                                   tcp_handle_ptr: *uv_tcp_t,\n+                                   ++after_cb: *u8,\n+                                   ++addr: *sockaddr_in6) -> libc::c_int;\n     // FIXME ref #2064\n-    fn rust_uv_tcp_bind6(tcp_server: *uv_tcp_t,\n-                        ++addr: *sockaddr_in6) -> libc::c_int;\n-    fn rust_uv_tcp_getpeername(tcp_handle_ptr: *uv_tcp_t,\n-                               ++name: *sockaddr_in) -> libc::c_int;\n-    fn rust_uv_tcp_getpeername6(tcp_handle_ptr: *uv_tcp_t,\n-                                ++name: *sockaddr_in6) ->libc::c_int;\n-    fn rust_uv_listen(stream: *libc::c_void, backlog: libc::c_int,\n-                      cb: *u8) -> libc::c_int;\n-    fn rust_uv_accept(server: *libc::c_void, client: *libc::c_void)\n-        -> libc::c_int;\n-    fn rust_uv_write(req: *libc::c_void, stream: *libc::c_void,\n-             ++buf_in: *uv_buf_t, buf_cnt: libc::c_int,\n-             cb: *u8) -> libc::c_int;\n-    fn rust_uv_read_start(stream: *libc::c_void, on_alloc: *u8,\n-                          on_read: *u8) -> libc::c_int;\n-    fn rust_uv_read_stop(stream: *libc::c_void) -> libc::c_int;\n-    fn rust_uv_timer_init(loop_handle: *libc::c_void,\n-                          timer_handle: *uv_timer_t) -> libc::c_int;\n-    fn rust_uv_timer_start(\n+    unsafe fn rust_uv_tcp_bind6(tcp_server: *uv_tcp_t,\n+                                ++addr: *sockaddr_in6) -> libc::c_int;\n+    unsafe fn rust_uv_tcp_getpeername(tcp_handle_ptr: *uv_tcp_t,\n+                                      ++name: *sockaddr_in) -> libc::c_int;\n+    unsafe fn rust_uv_tcp_getpeername6(tcp_handle_ptr: *uv_tcp_t,\n+                                       ++name: *sockaddr_in6) ->libc::c_int;\n+    unsafe fn rust_uv_listen(stream: *libc::c_void,\n+                             backlog: libc::c_int,\n+                             cb: *u8) -> libc::c_int;\n+    unsafe fn rust_uv_accept(server: *libc::c_void, client: *libc::c_void)\n+                          -> libc::c_int;\n+    unsafe fn rust_uv_write(req: *libc::c_void,\n+                            stream: *libc::c_void,\n+                            ++buf_in: *uv_buf_t,\n+                            buf_cnt: libc::c_int,\n+                            cb: *u8)\n+                         -> libc::c_int;\n+    unsafe fn rust_uv_read_start(stream: *libc::c_void,\n+                                 on_alloc: *u8,\n+                                 on_read: *u8)\n+                              -> libc::c_int;\n+    unsafe fn rust_uv_read_stop(stream: *libc::c_void) -> libc::c_int;\n+    unsafe fn rust_uv_timer_init(loop_handle: *libc::c_void,\n+                                 timer_handle: *uv_timer_t)\n+                              -> libc::c_int;\n+    unsafe fn rust_uv_timer_start(\n         timer_handle: *uv_timer_t,\n         cb: *u8,\n         timeout: libc::c_uint,\n         repeat: libc::c_uint) -> libc::c_int;\n-    fn rust_uv_timer_stop(handle: *uv_timer_t) -> libc::c_int;\n-\n-    fn rust_uv_getaddrinfo(loop_ptr: *libc::c_void,\n-                           handle: *uv_getaddrinfo_t,\n-                           cb: *u8,\n-                           node_name_ptr: *u8,\n-                           service_name_ptr: *u8,\n-                           // should probably only pass ptr::null()\n-                           hints: *addrinfo) -> libc::c_int;\n-    fn rust_uv_freeaddrinfo(res: *addrinfo);\n+    unsafe fn rust_uv_timer_stop(handle: *uv_timer_t) -> libc::c_int;\n+\n+    unsafe fn rust_uv_getaddrinfo(loop_ptr: *libc::c_void,\n+                                  handle: *uv_getaddrinfo_t,\n+                                  cb: *u8,\n+                                  node_name_ptr: *u8,\n+                                  service_name_ptr: *u8,\n+                                  // should probably only pass ptr::null()\n+                                  hints: *addrinfo)\n+                               -> libc::c_int;\n+    unsafe fn rust_uv_freeaddrinfo(res: *addrinfo);\n \n     // data accessors/helpers for rust-mapped uv structs\n-    fn rust_uv_helper_get_INADDR_NONE() -> u32;\n-    fn rust_uv_is_ipv4_addrinfo(input: *addrinfo) -> bool;\n-    fn rust_uv_is_ipv6_addrinfo(input: *addrinfo) -> bool;\n-    fn rust_uv_get_next_addrinfo(input: *addrinfo) -> *addrinfo;\n-    fn rust_uv_addrinfo_as_sockaddr_in(input: *addrinfo) -> *sockaddr_in;\n-    fn rust_uv_addrinfo_as_sockaddr_in6(input: *addrinfo) -> *sockaddr_in6;\n-    fn rust_uv_malloc_buf_base_of(sug_size: libc::size_t) -> *u8;\n-    fn rust_uv_free_base_of_buf(++buf: uv_buf_t);\n-    fn rust_uv_get_stream_handle_from_connect_req(\n+    unsafe fn rust_uv_helper_get_INADDR_NONE() -> u32;\n+    unsafe fn rust_uv_is_ipv4_addrinfo(input: *addrinfo) -> bool;\n+    unsafe fn rust_uv_is_ipv6_addrinfo(input: *addrinfo) -> bool;\n+    unsafe fn rust_uv_get_next_addrinfo(input: *addrinfo) -> *addrinfo;\n+    unsafe fn rust_uv_addrinfo_as_sockaddr_in(input: *addrinfo)\n+                                           -> *sockaddr_in;\n+    unsafe fn rust_uv_addrinfo_as_sockaddr_in6(input: *addrinfo)\n+                                            -> *sockaddr_in6;\n+    unsafe fn rust_uv_malloc_buf_base_of(sug_size: libc::size_t) -> *u8;\n+    unsafe fn rust_uv_free_base_of_buf(++buf: uv_buf_t);\n+    unsafe fn rust_uv_get_stream_handle_from_connect_req(\n         connect_req: *uv_connect_t)\n         -> *uv_stream_t;\n-    fn rust_uv_get_stream_handle_from_write_req(\n+    unsafe fn rust_uv_get_stream_handle_from_write_req(\n         write_req: *uv_write_t)\n         -> *uv_stream_t;\n-    fn rust_uv_get_loop_for_uv_handle(handle: *libc::c_void)\n-        -> *libc::c_void;\n-    fn rust_uv_get_data_for_uv_loop(loop_ptr: *libc::c_void) -> *libc::c_void;\n-    fn rust_uv_set_data_for_uv_loop(loop_ptr: *libc::c_void,\n-                                    data: *libc::c_void);\n-    fn rust_uv_get_data_for_uv_handle(handle: *libc::c_void)\n+    unsafe fn rust_uv_get_loop_for_uv_handle(handle: *libc::c_void)\n         -> *libc::c_void;\n-    fn rust_uv_set_data_for_uv_handle(handle: *libc::c_void,\n-                                      data: *libc::c_void);\n-    fn rust_uv_get_data_for_req(req: *libc::c_void) -> *libc::c_void;\n-    fn rust_uv_set_data_for_req(req: *libc::c_void,\n-                                data: *libc::c_void);\n-    fn rust_uv_get_base_from_buf(++buf: uv_buf_t) -> *u8;\n-    fn rust_uv_get_len_from_buf(++buf: uv_buf_t) -> libc::size_t;\n+    unsafe fn rust_uv_get_data_for_uv_loop(loop_ptr: *libc::c_void)\n+                                        -> *libc::c_void;\n+    unsafe fn rust_uv_set_data_for_uv_loop(loop_ptr: *libc::c_void,\n+                                           data: *libc::c_void);\n+    unsafe fn rust_uv_get_data_for_uv_handle(handle: *libc::c_void)\n+                                          -> *libc::c_void;\n+    unsafe fn rust_uv_set_data_for_uv_handle(handle: *libc::c_void,\n+                                             data: *libc::c_void);\n+    unsafe fn rust_uv_get_data_for_req(req: *libc::c_void) -> *libc::c_void;\n+    unsafe fn rust_uv_set_data_for_req(req: *libc::c_void,\n+                                       data: *libc::c_void);\n+    unsafe fn rust_uv_get_base_from_buf(++buf: uv_buf_t) -> *u8;\n+    unsafe fn rust_uv_get_len_from_buf(++buf: uv_buf_t) -> libc::size_t;\n \n     // sizeof testing helpers\n-    fn rust_uv_helper_uv_tcp_t_size() -> libc::c_uint;\n-    fn rust_uv_helper_uv_connect_t_size() -> libc::c_uint;\n-    fn rust_uv_helper_uv_buf_t_size() -> libc::c_uint;\n-    fn rust_uv_helper_uv_write_t_size() -> libc::c_uint;\n-    fn rust_uv_helper_uv_err_t_size() -> libc::c_uint;\n-    fn rust_uv_helper_sockaddr_in_size() -> libc::c_uint;\n-    fn rust_uv_helper_sockaddr_in6_size() -> libc::c_uint;\n-    fn rust_uv_helper_uv_async_t_size() -> libc::c_uint;\n-    fn rust_uv_helper_uv_timer_t_size() -> libc::c_uint;\n-    fn rust_uv_helper_uv_getaddrinfo_t_size() -> libc::c_uint;\n-    fn rust_uv_helper_addrinfo_size() -> libc::c_uint;\n-    fn rust_uv_helper_addr_in_size() -> libc::c_uint;\n+    unsafe fn rust_uv_helper_uv_tcp_t_size() -> libc::c_uint;\n+    unsafe fn rust_uv_helper_uv_connect_t_size() -> libc::c_uint;\n+    unsafe fn rust_uv_helper_uv_buf_t_size() -> libc::c_uint;\n+    unsafe fn rust_uv_helper_uv_write_t_size() -> libc::c_uint;\n+    unsafe fn rust_uv_helper_uv_err_t_size() -> libc::c_uint;\n+    unsafe fn rust_uv_helper_sockaddr_in_size() -> libc::c_uint;\n+    unsafe fn rust_uv_helper_sockaddr_in6_size() -> libc::c_uint;\n+    unsafe fn rust_uv_helper_uv_async_t_size() -> libc::c_uint;\n+    unsafe fn rust_uv_helper_uv_timer_t_size() -> libc::c_uint;\n+    unsafe fn rust_uv_helper_uv_getaddrinfo_t_size() -> libc::c_uint;\n+    unsafe fn rust_uv_helper_addrinfo_size() -> libc::c_uint;\n+    unsafe fn rust_uv_helper_addr_in_size() -> libc::c_uint;\n }\n \n pub unsafe fn loop_new() -> *libc::c_void {"}]}