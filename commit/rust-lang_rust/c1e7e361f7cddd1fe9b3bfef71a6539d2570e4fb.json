{"sha": "c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxZTdlMzYxZjdjZGRkMWZlOWIzYmZlZjcxYTY1MzlkMjU3MGU0ZmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-12T05:59:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-12T05:59:28Z"}, "message": "Auto merge of #84278 - Aaron1011:feature/new-proc-macro-meta-span, r=estebank\n\nImplement span quoting for proc-macros\n\nThis PR implements span quoting, allowing proc-macros to produce spans\npointing *into their own crate*. This is used by the unstable\n`proc_macro::quote!` macro, allowing us to get error messages like this:\n\n```\nerror[E0412]: cannot find type `MissingType` in this scope\n  --> $DIR/auxiliary/span-from-proc-macro.rs:37:20\n   |\nLL | pub fn error_from_attribute(_args: TokenStream, _input: TokenStream) -> TokenStream {\n   | ----------------------------------------------------------------------------------- in this expansion of procedural macro `#[error_from_attribute]`\n...\nLL |             field: MissingType\n   |                    ^^^^^^^^^^^ not found in this scope\n   |\n  ::: $DIR/span-from-proc-macro.rs:8:1\n   |\nLL | #[error_from_attribute]\n   | ----------------------- in this macro invocation\n```\n\nHere, `MissingType` occurs inside the implementation of the proc-macro\n`#[error_from_attribute]`. Previosuly, this would always result in a\nspan pointing at `#[error_from_attribute]`\n\nThis will make many proc-macro-related error message much more useful -\nwhen a proc-macro generates code containing an error, users will get an\nerror message pointing directly at that code (within the macro\ndefinition), instead of always getting a span pointing at the macro\ninvocation site.\n\nThis is implemented as follows:\n* When a proc-macro crate is being *compiled*, it causes the `quote!`\n  macro to get run. This saves all of the sapns in the input to `quote!`\n  into the metadata of *the proc-macro-crate* (which we are currently\n  compiling). The `quote!` macro then expands to a call to\n  `proc_macro::Span::recover_proc_macro_span(id)`, where `id` is an\nopaque identifier for the span in the crate metadata.\n* When the same proc-macro crate is *run* (e.g. it is loaded from disk\n  and invoked by some consumer crate), the call to\n`proc_macro::Span::recover_proc_macro_span` causes us to load the span\nfrom the proc-macro crate's metadata. The proc-macro then produces a\n`TokenStream` containing a `Span` pointing into the proc-macro crate\nitself.\n\nThe recursive nature of 'quote!' can be difficult to understand at\nfirst. The file `src/test/ui/proc-macro/quote-debug.stdout` shows\nthe output of the `quote!` macro, which should make this eaier to\nunderstand.\n\nThis PR also supports custom quoting spans in custom quote macros (e.g.\nthe `quote` crate). All span quoting goes through the\n`proc_macro::quote_span` method, which can be called by a custom quote\nmacro to perform span quoting. An example of this usage is provided in\n`src/test/ui/proc-macro/auxiliary/custom-quote.rs`\n\nCustom quoting currently has a few limitations:\n\nIn order to quote a span, we need to generate a call to\n`proc_macro::Span::recover_proc_macro_span`. However, proc-macros\nsupport renaming the `proc_macro` crate, so we can't simply hardcode\nthis path. Previously, the `quote_span` method used the path\n`crate::Span` - however, this only works when it is called by the\nbuiltin `quote!` macro in the same crate. To support being called from\narbitrary crates, we need access to the name of the `proc_macro` crate\nto generate a path. This PR adds an additional argument to `quote_span`\nto specify the name of the `proc_macro` crate. Howver, this feels kind\nof hacky, and we may want to change this before stabilizing anything\nquote-related.\n\nAdditionally, using `quote_span` currently requires enabling the\n`proc_macro_internals` feature. The builtin `quote!` macro\nhas an `#[allow_internal_unstable]` attribute, but this won't work for\ncustom quote implementations. This will likely require some additional\ntricks to apply `allow_internal_unstable` to the span of\n`proc_macro::Span::recover_proc_macro_span`.", "tree": {"sha": "1d4e4b28fb027c4cf8fbb0f2403c3a7007a45ba8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d4e4b28fb027c4cf8fbb0f2403c3a7007a45ba8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "html_url": "https://github.com/rust-lang/rust/commit/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f6717c15e516935641ff93f4521d3d76030763c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f6717c15e516935641ff93f4521d3d76030763c", "html_url": "https://github.com/rust-lang/rust/commit/9f6717c15e516935641ff93f4521d3d76030763c"}, {"sha": "dbf49102aac1515bd56c996fdfcfa20f7ee977ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbf49102aac1515bd56c996fdfcfa20f7ee977ea", "html_url": "https://github.com/rust-lang/rust/commit/dbf49102aac1515bd56c996fdfcfa20f7ee977ea"}], "stats": {"total": 596, "additions": 503, "deletions": 93}, "files": [{"sha": "65a141e1112372fe4bbaafa8acdd135026ae05a8", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -20,6 +20,7 @@ use crate::deriving::*;\n \n use rustc_expand::base::{MacroExpanderFn, ResolverExpand, SyntaxExtensionKind};\n use rustc_expand::proc_macro::BangProcMacro;\n+use rustc_span::def_id::LOCAL_CRATE;\n use rustc_span::symbol::sym;\n \n mod asm;\n@@ -114,5 +115,8 @@ pub fn register_builtin_macros(resolver: &mut dyn ResolverExpand) {\n     }\n \n     let client = proc_macro::bridge::client::Client::expand1(proc_macro::quote);\n-    register(sym::quote, SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client })));\n+    register(\n+        sym::quote,\n+        SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client, krate: LOCAL_CRATE })),\n+    );\n }"}, {"sha": "61870eede1dd5daa112e92ffb65ae6c28e1110e1", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -309,7 +309,9 @@ pub trait Emitter {\n                     // are some which do actually involve macros.\n                     ExpnKind::Inlined | ExpnKind::Desugaring(..) | ExpnKind::AstPass(..) => None,\n \n-                    ExpnKind::Macro(macro_kind, _) => Some(macro_kind),\n+                    ExpnKind::Macro { kind: macro_kind, name: _, proc_macro: _ } => {\n+                        Some(macro_kind)\n+                    }\n                 }\n             });\n \n@@ -371,10 +373,19 @@ pub trait Emitter {\n                     new_labels\n                         .push((trace.call_site, \"in the inlined copy of this code\".to_string()));\n                 } else if always_backtrace {\n+                    let proc_macro = if let ExpnKind::Macro { kind: _, name: _, proc_macro: true } =\n+                        trace.kind\n+                    {\n+                        \"procedural macro \"\n+                    } else {\n+                        \"\"\n+                    };\n+\n                     new_labels.push((\n                         trace.def_site,\n                         format!(\n-                            \"in this expansion of `{}`{}\",\n+                            \"in this expansion of {}`{}`{}\",\n+                            proc_macro,\n                             trace.kind.descr(),\n                             if macro_backtrace.len() > 1 {\n                                 // if macro_backtrace.len() == 1 it'll be\n@@ -400,7 +411,11 @@ pub trait Emitter {\n                 // and it needs an \"in this macro invocation\" label to match that.\n                 let redundant_span = trace.call_site.contains(sp);\n \n-                if !redundant_span && matches!(trace.kind, ExpnKind::Macro(MacroKind::Bang, _))\n+                if !redundant_span\n+                    && matches!(\n+                        trace.kind,\n+                        ExpnKind::Macro { kind: MacroKind::Bang, name: _, proc_macro: _ }\n+                    )\n                     || always_backtrace\n                 {\n                     new_labels.push(("}, {"sha": "0e966d0bf793d9b9511a0e6e888be69467db7f19", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -14,7 +14,7 @@ use rustc_lint_defs::builtin::PROC_MACRO_BACK_COMPAT;\n use rustc_lint_defs::BuiltinLintDiagnostics;\n use rustc_parse::{self, nt_to_tokenstream, parser, MACRO_ARGUMENTS};\n use rustc_session::{parse::ParseSess, Limit, Session};\n-use rustc_span::def_id::DefId;\n+use rustc_span::def_id::{CrateNum, DefId};\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::{AstPass, ExpnData, ExpnId, ExpnKind};\n use rustc_span::source_map::SourceMap;\n@@ -810,8 +810,16 @@ impl SyntaxExtension {\n         descr: Symbol,\n         macro_def_id: Option<DefId>,\n     ) -> ExpnData {\n+        use SyntaxExtensionKind::*;\n+        let proc_macro = match self.kind {\n+            // User-defined proc macro\n+            Bang(..) | Attr(..) | Derive(..) => true,\n+            // Consider everthing else to be not a proc\n+            // macro for diagnostic purposes\n+            LegacyBang(..) | LegacyAttr(..) | NonMacroAttr { .. } | LegacyDerive(..) => false,\n+        };\n         ExpnData::new(\n-            ExpnKind::Macro(self.macro_kind(), descr),\n+            ExpnKind::Macro { kind: self.macro_kind(), name: descr, proc_macro },\n             parent,\n             call_site,\n             self.span,\n@@ -873,6 +881,10 @@ pub trait ResolverExpand {\n     fn take_derive_resolutions(&mut self, expn_id: ExpnId) -> Option<DeriveResolutions>;\n     /// Path resolution logic for `#[cfg_accessible(path)]`.\n     fn cfg_accessible(&mut self, expn_id: ExpnId, path: &ast::Path) -> Result<bool, Indeterminate>;\n+\n+    /// Decodes the proc-macro quoted span in the specified crate, with the specified id.\n+    /// No caching is performed.\n+    fn get_proc_macro_quoted_span(&self, krate: CrateNum, id: usize) -> Span;\n }\n \n #[derive(Clone, Default)]"}, {"sha": "494b3fb61ee970d38f1535c83dcd185f202beea1", "filename": "compiler/rustc_expand/src/proc_macro.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -9,12 +9,14 @@ use rustc_data_structures::sync::Lrc;\n use rustc_errors::ErrorReported;\n use rustc_parse::nt_to_tokenstream;\n use rustc_parse::parser::ForceCollect;\n+use rustc_span::def_id::CrateNum;\n use rustc_span::{Span, DUMMY_SP};\n \n const EXEC_STRATEGY: pm::bridge::server::SameThread = pm::bridge::server::SameThread;\n \n pub struct BangProcMacro {\n     pub client: pm::bridge::client::Client<fn(pm::TokenStream) -> pm::TokenStream>,\n+    pub krate: CrateNum,\n }\n \n impl base::ProcMacro for BangProcMacro {\n@@ -24,7 +26,7 @@ impl base::ProcMacro for BangProcMacro {\n         span: Span,\n         input: TokenStream,\n     ) -> Result<TokenStream, ErrorReported> {\n-        let server = proc_macro_server::Rustc::new(ecx);\n+        let server = proc_macro_server::Rustc::new(ecx, self.krate);\n         self.client.run(&EXEC_STRATEGY, server, input, ecx.ecfg.proc_macro_backtrace).map_err(|e| {\n             let mut err = ecx.struct_span_err(span, \"proc macro panicked\");\n             if let Some(s) = e.as_str() {\n@@ -38,6 +40,7 @@ impl base::ProcMacro for BangProcMacro {\n \n pub struct AttrProcMacro {\n     pub client: pm::bridge::client::Client<fn(pm::TokenStream, pm::TokenStream) -> pm::TokenStream>,\n+    pub krate: CrateNum,\n }\n \n impl base::AttrProcMacro for AttrProcMacro {\n@@ -48,7 +51,7 @@ impl base::AttrProcMacro for AttrProcMacro {\n         annotation: TokenStream,\n         annotated: TokenStream,\n     ) -> Result<TokenStream, ErrorReported> {\n-        let server = proc_macro_server::Rustc::new(ecx);\n+        let server = proc_macro_server::Rustc::new(ecx, self.krate);\n         self.client\n             .run(&EXEC_STRATEGY, server, annotation, annotated, ecx.ecfg.proc_macro_backtrace)\n             .map_err(|e| {\n@@ -64,6 +67,7 @@ impl base::AttrProcMacro for AttrProcMacro {\n \n pub struct ProcMacroDerive {\n     pub client: pm::bridge::client::Client<fn(pm::TokenStream) -> pm::TokenStream>,\n+    pub krate: CrateNum,\n }\n \n impl MultiItemModifier for ProcMacroDerive {\n@@ -97,7 +101,7 @@ impl MultiItemModifier for ProcMacroDerive {\n             nt_to_tokenstream(&item, &ecx.sess.parse_sess, CanSynthesizeMissingTokens::No)\n         };\n \n-        let server = proc_macro_server::Rustc::new(ecx);\n+        let server = proc_macro_server::Rustc::new(ecx, self.krate);\n         let stream =\n             match self.client.run(&EXEC_STRATEGY, server, input, ecx.ecfg.proc_macro_backtrace) {\n                 Ok(stream) => stream,"}, {"sha": "f6645448fccbc9dedec9897a8240c2311e37b7f4", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 67, "deletions": 7, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -1,4 +1,4 @@\n-use crate::base::ExtCtxt;\n+use crate::base::{ExtCtxt, ResolverExpand};\n \n use rustc_ast as ast;\n use rustc_ast::token;\n@@ -7,13 +7,16 @@ use rustc_ast::token::NtIdent;\n use rustc_ast::tokenstream::{self, CanSynthesizeMissingTokens};\n use rustc_ast::tokenstream::{DelimSpan, Spacing::*, TokenStream, TreeAndSpacing};\n use rustc_ast_pretty::pprust;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::Diagnostic;\n use rustc_lint_defs::builtin::PROC_MACRO_BACK_COMPAT;\n use rustc_lint_defs::BuiltinLintDiagnostics;\n use rustc_parse::lexer::nfc_normalize;\n use rustc_parse::{nt_to_tokenstream, parse_stream_from_source_str};\n use rustc_session::parse::ParseSess;\n+use rustc_span::def_id::CrateNum;\n+use rustc_span::hygiene::ExpnId;\n use rustc_span::hygiene::ExpnKind;\n use rustc_span::symbol::{self, kw, sym, Symbol};\n use rustc_span::{BytePos, FileName, MultiSpan, Pos, RealFileName, SourceFile, Span};\n@@ -355,22 +358,34 @@ pub struct Literal {\n }\n \n pub(crate) struct Rustc<'a> {\n+    resolver: &'a dyn ResolverExpand,\n     sess: &'a ParseSess,\n     def_site: Span,\n     call_site: Span,\n     mixed_site: Span,\n     span_debug: bool,\n+    krate: CrateNum,\n+    expn_id: ExpnId,\n+    rebased_spans: FxHashMap<usize, Span>,\n }\n \n impl<'a> Rustc<'a> {\n-    pub fn new(cx: &'a ExtCtxt<'_>) -> Self {\n+    pub fn new(cx: &'a ExtCtxt<'_>, krate: CrateNum) -> Self {\n         let expn_data = cx.current_expansion.id.expn_data();\n+        let def_site = cx.with_def_site_ctxt(expn_data.def_site);\n+        let call_site = cx.with_call_site_ctxt(expn_data.call_site);\n+        let mixed_site = cx.with_mixed_site_ctxt(expn_data.call_site);\n+        let sess = cx.parse_sess();\n         Rustc {\n-            sess: &cx.sess.parse_sess,\n-            def_site: cx.with_def_site_ctxt(expn_data.def_site),\n-            call_site: cx.with_call_site_ctxt(expn_data.call_site),\n-            mixed_site: cx.with_mixed_site_ctxt(expn_data.call_site),\n+            resolver: cx.resolver,\n+            sess,\n+            def_site,\n+            call_site,\n+            mixed_site,\n             span_debug: cx.ecfg.span_debug,\n+            krate,\n+            expn_id: cx.current_expansion.id,\n+            rebased_spans: FxHashMap::default(),\n         }\n     }\n \n@@ -713,6 +728,51 @@ impl server::Span for Rustc<'_> {\n     fn source_text(&mut self, span: Self::Span) -> Option<String> {\n         self.sess.source_map().span_to_snippet(span).ok()\n     }\n+    /// Saves the provided span into the metadata of\n+    /// *the crate we are currently compiling*, which must\n+    /// be a proc-macro crate. This id can be passed to\n+    /// `recover_proc_macro_span` when our current crate\n+    /// is *run* as a proc-macro.\n+    ///\n+    /// Let's suppose that we have two crates - `my_client`\n+    /// and `my_proc_macro`. The `my_proc_macro` crate\n+    /// contains a procedural macro `my_macro`, which\n+    /// is implemented as: `quote! { \"hello\" }`\n+    ///\n+    /// When we *compile* `my_proc_macro`, we will execute\n+    /// the `quote` proc-macro. This will save the span of\n+    /// \"hello\" into the metadata of `my_proc_macro`. As a result,\n+    /// the body of `my_proc_macro` (after expansion) will end\n+    /// up containg a call that looks like this:\n+    /// `proc_macro::Ident::new(\"hello\", proc_macro::Span::recover_proc_macro_span(0))`\n+    ///\n+    /// where `0` is the id returned by this function.\n+    /// When `my_proc_macro` *executes* (during the compilation of `my_client`),\n+    /// the call to `recover_proc_macro_span` will load the corresponding\n+    /// span from the metadata of `my_proc_macro` (which we have access to,\n+    /// since we've loaded `my_proc_macro` from disk in order to execute it).\n+    /// In this way, we have obtained a span pointing into `my_proc_macro`\n+    fn save_span(&mut self, mut span: Self::Span) -> usize {\n+        // Throw away the `SyntaxContext`, since we currently\n+        // skip serializing `SyntaxContext`s for proc-macro crates\n+        span = span.with_ctxt(rustc_span::SyntaxContext::root());\n+        self.sess.save_proc_macro_span(span)\n+    }\n+    fn recover_proc_macro_span(&mut self, id: usize) -> Self::Span {\n+        let resolver = self.resolver;\n+        let krate = self.krate;\n+        let expn_id = self.expn_id;\n+        *self.rebased_spans.entry(id).or_insert_with(|| {\n+            let raw_span = resolver.get_proc_macro_quoted_span(krate, id);\n+            // Ignore the deserialized `SyntaxContext` entirely.\n+            // FIXME: Preserve the macro backtrace from the serialized span\n+            // For example, if a proc-macro crate has code like\n+            // `macro_one!() -> macro_two!() -> quote!()`, we might\n+            // want to 'concatenate' this backtrace with the backtrace from\n+            // our current call site.\n+            raw_span.with_def_site_ctxt(expn_id)\n+        })\n+    }\n }\n \n // See issue #74616 for details\n@@ -722,7 +782,7 @@ fn ident_name_compatibility_hack(\n     rustc: &mut Rustc<'_>,\n ) -> Option<(rustc_span::symbol::Ident, bool)> {\n     if let NtIdent(ident, is_raw) = nt {\n-        if let ExpnKind::Macro(_, macro_name) = orig_span.ctxt().outer_expn_data().kind {\n+        if let ExpnKind::Macro { name: macro_name, .. } = orig_span.ctxt().outer_expn_data().kind {\n             let source_map = rustc.sess.source_map();\n             let filename = source_map.span_to_filename(orig_span);\n             if let FileName::Real(RealFileName::Named(path)) = filename {"}, {"sha": "0398d4a99618a9fe1498bea256be428c69956945", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -248,10 +248,21 @@ impl EarlyLintPass for LintPassImpl {\n                 if last.ident.name == sym::LintPass {\n                     let expn_data = lint_pass.path.span.ctxt().outer_expn_data();\n                     let call_site = expn_data.call_site;\n-                    if expn_data.kind != ExpnKind::Macro(MacroKind::Bang, sym::impl_lint_pass)\n-                        && call_site.ctxt().outer_expn_data().kind\n-                            != ExpnKind::Macro(MacroKind::Bang, sym::declare_lint_pass)\n-                    {\n+                    if !matches!(\n+                        expn_data.kind,\n+                        ExpnKind::Macro {\n+                            kind: MacroKind::Bang,\n+                            name: sym::impl_lint_pass,\n+                            proc_macro: _\n+                        }\n+                    ) && !matches!(\n+                        call_site.ctxt().outer_expn_data().kind,\n+                        ExpnKind::Macro {\n+                            kind: MacroKind::Bang,\n+                            name: sym::declare_lint_pass,\n+                            proc_macro: _\n+                        }\n+                    ) {\n                         cx.struct_span_lint(\n                             LINT_PASS_IMPL_WITHOUT_MACRO,\n                             lint_pass.path.span,"}, {"sha": "c91dc37b374f861d221f149d5b7badd552333dce", "filename": "compiler/rustc_lint/src/non_fmt_panic.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -248,10 +248,11 @@ fn panic_call<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>) -> (Span,\n         }\n     }\n \n-    let macro_symbol = if let hygiene::ExpnKind::Macro(_, symbol) = expn.kind {\n-        symbol\n-    } else {\n-        Symbol::intern(\"panic\")\n-    };\n+    let macro_symbol =\n+        if let hygiene::ExpnKind::Macro { kind: _, name: symbol, proc_macro: _ } = expn.kind {\n+            symbol\n+        } else {\n+            Symbol::intern(\"panic\")\n+        };\n     (expn.call_site, panic_macro, macro_symbol.as_str())\n }"}, {"sha": "4a01731b512761fc09f3d3d2dccd52c3b6b537fb", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -716,30 +716,37 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .decode((self, sess))\n     }\n \n-    fn load_proc_macro(&self, id: DefIndex, sess: &Session) -> SyntaxExtension {\n-        let (name, kind, helper_attrs) = match *self.raw_proc_macro(id) {\n+    fn load_proc_macro(&self, def_id: DefId, sess: &Session) -> SyntaxExtension {\n+        let (name, kind, helper_attrs) = match *self.raw_proc_macro(def_id.index) {\n             ProcMacro::CustomDerive { trait_name, attributes, client } => {\n                 let helper_attrs =\n                     attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n                 (\n                     trait_name,\n-                    SyntaxExtensionKind::Derive(Box::new(ProcMacroDerive { client })),\n+                    SyntaxExtensionKind::Derive(Box::new(ProcMacroDerive {\n+                        client,\n+                        krate: def_id.krate,\n+                    })),\n                     helper_attrs,\n                 )\n             }\n-            ProcMacro::Attr { name, client } => {\n-                (name, SyntaxExtensionKind::Attr(Box::new(AttrProcMacro { client })), Vec::new())\n-            }\n-            ProcMacro::Bang { name, client } => {\n-                (name, SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client })), Vec::new())\n-            }\n+            ProcMacro::Attr { name, client } => (\n+                name,\n+                SyntaxExtensionKind::Attr(Box::new(AttrProcMacro { client, krate: def_id.krate })),\n+                Vec::new(),\n+            ),\n+            ProcMacro::Bang { name, client } => (\n+                name,\n+                SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client, krate: def_id.krate })),\n+                Vec::new(),\n+            ),\n         };\n \n-        let attrs: Vec<_> = self.get_item_attrs(id, sess).collect();\n+        let attrs: Vec<_> = self.get_item_attrs(def_id.index, sess).collect();\n         SyntaxExtension::new(\n             sess,\n             kind,\n-            self.get_span(id, sess),\n+            self.get_span(def_id.index, sess),\n             helper_attrs,\n             self.root.edition,\n             Symbol::intern(name),\n@@ -1379,6 +1386,15 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n+    fn get_proc_macro_quoted_span(&self, index: usize, sess: &Session) -> Span {\n+        self.root\n+            .tables\n+            .proc_macro_quoted_spans\n+            .get(self, index)\n+            .unwrap_or_else(|| panic!(\"Missing proc macro quoted span: {:?}\", index))\n+            .decode((self, sess))\n+    }\n+\n     fn get_foreign_modules(&self, tcx: TyCtxt<'tcx>) -> Lrc<FxHashMap<DefId, ForeignModule>> {\n         if self.root.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* foreign modules."}, {"sha": "cda57f48cae6b8a7f1fe8226993f523ae668c4a3", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -411,7 +411,7 @@ impl CStore {\n \n         let data = self.get_crate_data(id.krate);\n         if data.root.is_proc_macro_crate() {\n-            return LoadedMacro::ProcMacro(data.load_proc_macro(id.index, sess));\n+            return LoadedMacro::ProcMacro(data.load_proc_macro(id, sess));\n         }\n \n         let span = data.get_span(id.index, sess);\n@@ -461,6 +461,15 @@ impl CStore {\n     pub fn item_attrs(&self, def_id: DefId, sess: &Session) -> Vec<ast::Attribute> {\n         self.get_crate_data(def_id.krate).get_item_attrs(def_id.index, sess).collect()\n     }\n+\n+    pub fn get_proc_macro_quoted_span_untracked(\n+        &self,\n+        cnum: CrateNum,\n+        id: usize,\n+        sess: &Session,\n+    ) -> Span {\n+        self.get_crate_data(cnum).get_proc_macro_quoted_span(id, sess)\n+    }\n }\n \n impl CrateStore for CStore {"}, {"sha": "c61417f99981dd850ddda1204cb5585985f445e3", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -1579,6 +1579,11 @@ impl EncodeContext<'a, 'tcx> {\n             let proc_macro_decls_static = tcx.proc_macro_decls_static(LOCAL_CRATE).unwrap().index;\n             let stability = tcx.lookup_stability(DefId::local(CRATE_DEF_INDEX)).copied();\n             let macros = self.lazy(hir.krate().proc_macros.iter().map(|p| p.owner.local_def_index));\n+            let spans = self.tcx.sess.parse_sess.proc_macro_quoted_spans();\n+            for (i, span) in spans.into_iter().enumerate() {\n+                let span = self.lazy(span);\n+                self.tables.proc_macro_quoted_spans.set(i, span);\n+            }\n \n             record!(self.tables.def_kind[LOCAL_CRATE.as_def_id()] <- DefKind::Mod);\n             record!(self.tables.span[LOCAL_CRATE.as_def_id()] <- tcx.def_span(LOCAL_CRATE.as_def_id()));"}, {"sha": "6b375045f14bb443e2688b87130b93e4cf7be6b3", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -258,15 +258,15 @@ crate struct TraitImpls {\n \n /// Define `LazyTables` and `TableBuilders` at the same time.\n macro_rules! define_tables {\n-    ($($name:ident: Table<DefIndex, $T:ty>),+ $(,)?) => {\n+    ($($name:ident: Table<$IDX:ty, $T:ty>),+ $(,)?) => {\n         #[derive(MetadataEncodable, MetadataDecodable)]\n         crate struct LazyTables<'tcx> {\n-            $($name: Lazy!(Table<DefIndex, $T>)),+\n+            $($name: Lazy!(Table<$IDX, $T>)),+\n         }\n \n         #[derive(Default)]\n         struct TableBuilders<'tcx> {\n-            $($name: TableBuilder<DefIndex, $T>),+\n+            $($name: TableBuilder<$IDX, $T>),+\n         }\n \n         impl TableBuilders<'tcx> {\n@@ -315,6 +315,7 @@ define_tables! {\n     // definitions from any given crate.\n     def_keys: Table<DefIndex, Lazy<DefKey>>,\n     def_path_hashes: Table<DefIndex, Lazy<DefPathHash>>,\n+    proc_macro_quoted_spans: Table<usize, Lazy<Span>>,\n }\n \n #[derive(Copy, Clone, MetadataEncodable, MetadataDecodable)]"}, {"sha": "38d0793a6825fd9c4e545c61d1ebaa240fa3e4d8", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -389,7 +389,7 @@ pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n             false\n         }\n         ExpnKind::AstPass(_) | ExpnKind::Desugaring(_) => true, // well, it's \"external\"\n-        ExpnKind::Macro(MacroKind::Bang, _) => {\n+        ExpnKind::Macro { kind: MacroKind::Bang, name: _, proc_macro: _ } => {\n             // Dummy span for the `def_site` means it's an external macro.\n             expn_data.def_site.is_dummy() || sess.source_map().is_imported(expn_data.def_site)\n         }"}, {"sha": "aca11de4516673e7258a07b7742ff1da486176b0", "filename": "compiler/rustc_mir/src/transform/coverage/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -128,7 +128,7 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n                 if expn_data.is_root() {\n                     break;\n                 }\n-                if let ExpnKind::Macro(..) = expn_data.kind {\n+                if let ExpnKind::Macro { .. } = expn_data.kind {\n                     body_span = expn_data.call_site;\n                 } else {\n                     break;"}, {"sha": "444b4e2ca19142ea102aa59f813629226f4221b4", "filename": "compiler/rustc_mir/src/transform/coverage/spans.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -184,8 +184,11 @@ impl CoverageSpan {\n         self.current_macro_or_none\n             .borrow_mut()\n             .get_or_insert_with(|| {\n-                if let ExpnKind::Macro(MacroKind::Bang, current_macro) =\n-                    self.expn_span.ctxt().outer_expn_data().kind\n+                if let ExpnKind::Macro {\n+                    kind: MacroKind::Bang,\n+                    name: current_macro,\n+                    proc_macro: _,\n+                } = self.expn_span.ctxt().outer_expn_data().kind\n                 {\n                     return Some(current_macro);\n                 }"}, {"sha": "300d2c01cb5d08f03567603637a2fac365113902", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -1770,9 +1770,11 @@ impl<'a> Resolver<'a> {\n                     let expn_data = expn_id.expn_data();\n                     match expn_data.kind {\n                         ExpnKind::Root\n-                        | ExpnKind::Macro(MacroKind::Bang | MacroKind::Derive, _) => {\n-                            Scope::DeriveHelpersCompat\n-                        }\n+                        | ExpnKind::Macro {\n+                            kind: MacroKind::Bang | MacroKind::Derive,\n+                            name: _,\n+                            proc_macro: _,\n+                        } => Scope::DeriveHelpersCompat,\n                         _ => Scope::DeriveHelpers(expn_data.parent),\n                     }\n                 }"}, {"sha": "3f7db2b6962fa51bb50122e238e00c5d18795160", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -20,7 +20,7 @@ use rustc_expand::compile_declarative_macro;\n use rustc_expand::expand::{AstFragment, Invocation, InvocationKind, SupportsMacroExpansion};\n use rustc_feature::is_builtin_attr_name;\n use rustc_hir::def::{self, DefKind, NonMacroAttrKind};\n-use rustc_hir::def_id;\n+use rustc_hir::def_id::{self, CrateNum};\n use rustc_hir::PrimTy;\n use rustc_middle::middle::stability;\n use rustc_middle::ty;\n@@ -325,7 +325,11 @@ impl<'a> ResolverExpand for Resolver<'a> {\n                         let expn_data = expn_id.expn_data();\n                         match expn_data.kind {\n                             ExpnKind::Root\n-                            | ExpnKind::Macro(MacroKind::Bang | MacroKind::Derive, _) => {\n+                            | ExpnKind::Macro {\n+                                name: _,\n+                                kind: MacroKind::Bang | MacroKind::Derive,\n+                                proc_macro: _,\n+                            } => {\n                                 break;\n                             }\n                             _ => expn_id = expn_data.parent,\n@@ -462,6 +466,10 @@ impl<'a> ResolverExpand for Resolver<'a> {\n             .emit();\n         Ok(false)\n     }\n+\n+    fn get_proc_macro_quoted_span(&self, krate: CrateNum, id: usize) -> Span {\n+        self.crate_loader.cstore().get_proc_macro_quoted_span_untracked(krate, id, self.session)\n+    }\n }\n \n impl<'a> Resolver<'a> {"}, {"sha": "7256e68b87adc0b113d35cdadf3b62524d46df38", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -786,7 +786,7 @@ impl<'tcx> SaveContext<'tcx> {\n         let callee = span.source_callee()?;\n \n         let mac_name = match callee.kind {\n-            ExpnKind::Macro(kind, name) => match kind {\n+            ExpnKind::Macro { kind, name, proc_macro: _ } => match kind {\n                 MacroKind::Bang => name,\n \n                 // Ignore attribute macros, their spans are usually mangled"}, {"sha": "7b7878e9c7f4223ef501d21753524f0484e44d89", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -137,6 +137,9 @@ pub struct ParseSess {\n     pub type_ascription_path_suggestions: Lock<FxHashSet<Span>>,\n     /// Whether cfg(version) should treat the current release as incomplete\n     pub assume_incomplete_release: bool,\n+    /// Spans passed to `proc_macro::quote_span`. Each span has a numerical\n+    /// identifier represented by its position in the vector.\n+    pub proc_macro_quoted_spans: Lock<Vec<Span>>,\n }\n \n impl ParseSess {\n@@ -164,6 +167,7 @@ impl ParseSess {\n             env_depinfo: Default::default(),\n             type_ascription_path_suggestions: Default::default(),\n             assume_incomplete_release: false,\n+            proc_macro_quoted_spans: Default::default(),\n         }\n     }\n \n@@ -236,4 +240,14 @@ impl ParseSess {\n             );\n         }\n     }\n+\n+    pub fn save_proc_macro_span(&self, span: Span) -> usize {\n+        let mut spans = self.proc_macro_quoted_spans.lock();\n+        spans.push(span);\n+        return spans.len() - 1;\n+    }\n+\n+    pub fn proc_macro_quoted_spans(&self) -> Vec<Span> {\n+        self.proc_macro_quoted_spans.lock().clone()\n+    }\n }"}, {"sha": "8f3b8cc2d0efce8ebec4e3061c997c2fc72b0ddc", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -144,7 +144,10 @@ impl ExpnId {\n             let expn_data = self.expn_data();\n             // Stop going up the backtrace once include! is encountered\n             if expn_data.is_root()\n-                || expn_data.kind == ExpnKind::Macro(MacroKind::Bang, sym::include)\n+                || matches!(\n+                    expn_data.kind,\n+                    ExpnKind::Macro { kind: MacroKind::Bang, name: sym::include, proc_macro: _ }\n+                )\n             {\n                 break;\n             }\n@@ -839,7 +842,13 @@ pub enum ExpnKind {\n     /// No expansion, aka root expansion. Only `ExpnId::root()` has this kind.\n     Root,\n     /// Expansion produced by a macro.\n-    Macro(MacroKind, Symbol),\n+    Macro {\n+        kind: MacroKind,\n+        name: Symbol,\n+        /// If `true`, this macro is a procedural macro. This\n+        /// flag is only used for diagnostic purposes\n+        proc_macro: bool,\n+    },\n     /// Transform done by the compiler on the AST.\n     AstPass(AstPass),\n     /// Desugaring done by the compiler during HIR lowering.\n@@ -852,7 +861,7 @@ impl ExpnKind {\n     pub fn descr(&self) -> String {\n         match *self {\n             ExpnKind::Root => kw::PathRoot.to_string(),\n-            ExpnKind::Macro(macro_kind, name) => match macro_kind {\n+            ExpnKind::Macro { kind, name, proc_macro: _ } => match kind {\n                 MacroKind::Bang => format!(\"{}!\", name),\n                 MacroKind::Attr => format!(\"#[{}]\", name),\n                 MacroKind::Derive => format!(\"#[derive({})]\", name),"}, {"sha": "d56b434ca85eaec217775e0c1158a22c585db017", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -394,7 +394,10 @@ impl Span {\n \n     /// Returns `true` if `span` originates in a derive-macro's expansion.\n     pub fn in_derive_expansion(self) -> bool {\n-        matches!(self.ctxt().outer_expn_data().kind, ExpnKind::Macro(MacroKind::Derive, _))\n+        matches!(\n+            self.ctxt().outer_expn_data().kind,\n+            ExpnKind::Macro { kind: MacroKind::Derive, name: _, proc_macro: _ }\n+        )\n     }\n \n     #[inline]"}, {"sha": "355ad1f9f881cb3c44b71ae411a3ea9d7f6d9fda", "filename": "library/proc_macro/src/bridge/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -162,6 +162,8 @@ macro_rules! with_api {\n                 fn join($self: $S::Span, other: $S::Span) -> Option<$S::Span>;\n                 fn resolved_at($self: $S::Span, at: $S::Span) -> $S::Span;\n                 fn source_text($self: $S::Span) -> Option<String>;\n+                fn save_span($self: $S::Span) -> usize;\n+                fn recover_proc_macro_span(id: usize) -> $S::Span;\n             },\n         }\n     };\n@@ -338,6 +340,7 @@ mark_noop! {\n     &'a [u8],\n     &'a str,\n     String,\n+    usize,\n     Delimiter,\n     Level,\n     LineColumn,"}, {"sha": "525fd0fbe3431e3a8d8fdc270af8b7194ea2c5a2", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -265,7 +265,7 @@ pub mod token_stream {\n /// Unquoting is done with `$`, and works by taking the single next ident as the unquoted term.\n /// To quote `$` itself, use `$$`.\n #[unstable(feature = \"proc_macro_quote\", issue = \"54722\")]\n-#[allow_internal_unstable(proc_macro_def_site)]\n+#[allow_internal_unstable(proc_macro_def_site, proc_macro_internals)]\n #[rustc_builtin_macro]\n pub macro quote($($t:tt)*) {\n     /* compiler built-in */\n@@ -394,6 +394,20 @@ impl Span {\n         self.0.source_text()\n     }\n \n+    // Used by the implementation of `Span::quote`\n+    #[doc(hidden)]\n+    #[unstable(feature = \"proc_macro_internals\", issue = \"27812\")]\n+    pub fn save_span(&self) -> usize {\n+        self.0.save_span()\n+    }\n+\n+    // Used by the implementation of `Span::quote`\n+    #[doc(hidden)]\n+    #[unstable(feature = \"proc_macro_internals\", issue = \"27812\")]\n+    pub fn recover_proc_macro_span(id: usize) -> Span {\n+        Span(bridge::client::Span::recover_proc_macro_span(id))\n+    }\n+\n     diagnostic_method!(error, Level::Error);\n     diagnostic_method!(warning, Level::Warning);\n     diagnostic_method!(note, Level::Note);"}, {"sha": "1fd59889709b211f7828314f6d52c5e814c150e5", "filename": "library/proc_macro/src/quote.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/library%2Fproc_macro%2Fsrc%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/library%2Fproc_macro%2Fsrc%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fquote.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -65,6 +65,7 @@ pub fn quote(stream: TokenStream) -> TokenStream {\n     if stream.is_empty() {\n         return quote!(crate::TokenStream::new());\n     }\n+    let proc_macro_crate = quote!(crate);\n     let mut after_dollar = false;\n     let tokens = stream\n         .into_iter()\n@@ -105,7 +106,7 @@ pub fn quote(stream: TokenStream) -> TokenStream {\n                 ))),\n                 TokenTree::Ident(tt) => quote!(crate::TokenTree::Ident(crate::Ident::new(\n                     (@ TokenTree::from(Literal::string(&tt.to_string()))),\n-                    (@ quote_span(tt.span())),\n+                    (@ quote_span(proc_macro_crate.clone(), tt.span())),\n                 ))),\n                 TokenTree::Literal(tt) => quote!(crate::TokenTree::Literal({\n                     let mut iter = (@ TokenTree::from(Literal::string(&tt.to_string())))\n@@ -115,7 +116,7 @@ pub fn quote(stream: TokenStream) -> TokenStream {\n                     if let (Some(crate::TokenTree::Literal(mut lit)), None) =\n                         (iter.next(), iter.next())\n                     {\n-                        lit.set_span((@ quote_span(tt.span())));\n+                        lit.set_span((@ quote_span(proc_macro_crate.clone(), tt.span())));\n                         lit\n                     } else {\n                         unreachable!()\n@@ -135,6 +136,7 @@ pub fn quote(stream: TokenStream) -> TokenStream {\n /// Quote a `Span` into a `TokenStream`.\n /// This is needed to implement a custom quoter.\n #[unstable(feature = \"proc_macro_quote\", issue = \"54722\")]\n-pub fn quote_span(_: Span) -> TokenStream {\n-    quote!(crate::Span::def_site())\n+pub fn quote_span(proc_macro_crate: TokenStream, span: Span) -> TokenStream {\n+    let id = span.save_span();\n+    quote!((@ proc_macro_crate ) ::Span::recover_proc_macro_span((@ TokenTree::from(Literal::usize_unsuffixed(id)))))\n }"}, {"sha": "e3445a4b80f7b00564a98746ccd9330a0e839ff9", "filename": "src/test/ui/hygiene/unpretty-debug.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/src%2Ftest%2Fui%2Fhygiene%2Funpretty-debug.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/src%2Ftest%2Fui%2Fhygiene%2Funpretty-debug.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Funpretty-debug.stdout?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -20,7 +20,7 @@ fn y /* 0#0 */() { }\n /*\n Expansions:\n 0: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: Root\n-1: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro(Bang, \"foo\")\n+1: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro { kind: Bang, name: \"foo\", proc_macro: false }\n \n SyntaxContexts:\n #0: parent: #0, outer_mark: (ExpnId(0), Opaque)"}, {"sha": "1331480d835a495c12eabc399288357f984ee6df", "filename": "src/test/ui/macros/auxiliary/proc_macro_sequence.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2Fproc_macro_sequence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2Fproc_macro_sequence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2Fproc_macro_sequence.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -23,24 +23,5 @@ pub fn make_foo(_: TokenStream) -> TokenStream {\n         }\n     };\n \n-    // Check that all spans are equal.\n-    // FIXME: `quote!` gives def-site spans to idents and literals,\n-    // but leaves (default) call-site spans on groups and punctuation.\n-    let mut span_call = None;\n-    let mut span_def = None;\n-    for tt in result.clone() {\n-        match tt {\n-            TokenTree::Ident(..) | TokenTree::Literal(..) => match span_def {\n-                None => span_def = Some(tt.span()),\n-                Some(span) => assert_same_span(tt.span(), span),\n-            }\n-            TokenTree::Punct(..) | TokenTree::Group(..) => match span_call {\n-                None => span_call = Some(tt.span()),\n-                Some(span) => assert_same_span(tt.span(), span),\n-            }\n-        }\n-\n-    }\n-\n     result\n }"}, {"sha": "911775eb4176c44e0d83dd6d060a3018faa6739a", "filename": "src/test/ui/macros/same-sequence-span.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -17,11 +17,15 @@ LL |                $(= $z:tt)*\n error: `$x:expr` may be followed by `$y:tt`, which is not allowed for `expr` fragments\n   --> $DIR/same-sequence-span.rs:19:1\n    |\n-LL | proc_macro_sequence::make_foo!();\n-   | ---------------------------------^^^^^^^^^^^^^\n+LL |   proc_macro_sequence::make_foo!();\n+   |   ^--------------------------------\n+   |   |\n+   |  _in this macro invocation\n    | |\n-   | not allowed after `expr` fragments\n-   | in this macro invocation\n+LL | |\n+LL | |\n+LL | | fn main() {}\n+   | |_________________________________^ not allowed after `expr` fragments\n    |\n    = note: allowed there are: `=>`, `,` or `;`\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)"}, {"sha": "714417deee5872b53b6b7025a4bf652a700e683f", "filename": "src/test/ui/proc-macro/auxiliary/custom-quote.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fcustom-quote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fcustom-quote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fcustom-quote.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -0,0 +1,31 @@\n+// force-host\n+// no-prefer-dynamic\n+// ignore-tidy-linelength\n+\n+#![feature(proc_macro_quote)]\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use std::str::FromStr;\n+use proc_macro::*;\n+\n+#[proc_macro]\n+pub fn custom_quote(input: TokenStream) -> TokenStream {\n+    let mut tokens: Vec<_> = input.into_iter().collect();\n+    assert_eq!(tokens.len(), 1, \"Unexpected input: {:?}\", tokens);\n+    match tokens.pop() {\n+        Some(TokenTree::Ident(ident)) => {\n+            assert_eq!(ident.to_string(), \"my_ident\");\n+\n+            let proc_macro_crate = TokenStream::from_str(\"::proc_macro\").unwrap();\n+            let quoted_span = proc_macro::quote_span(proc_macro_crate, ident.span());\n+            let prefix = TokenStream::from_str(r#\"let mut ident = proc_macro::Ident::new(\"my_ident\", proc_macro::Span::call_site());\"#).unwrap();\n+            let set_span_method = TokenStream::from_str(\"ident.set_span\").unwrap();\n+            let set_span_arg = TokenStream::from(TokenTree::Group(Group::new(Delimiter::Parenthesis, quoted_span)));\n+            let suffix = TokenStream::from_str(\";proc_macro::TokenStream::from(proc_macro::TokenTree::Ident(ident))\").unwrap();\n+            let full_stream: TokenStream = std::array::IntoIter::new([prefix, set_span_method, set_span_arg, suffix]).collect();\n+            full_stream\n+        }\n+        _ => unreachable!()\n+    }\n+}"}, {"sha": "49292acfea746bc41e55940fc6caa3a5b50ebda9", "filename": "src/test/ui/proc-macro/auxiliary/span-from-proc-macro.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fspan-from-proc-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fspan-from-proc-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fspan-from-proc-macro.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -0,0 +1,49 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![feature(proc_macro_quote)]\n+#![feature(proc_macro_internals)] // FIXME - this shouldn't be necessary\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+extern crate custom_quote;\n+\n+use proc_macro::{quote, TokenStream};\n+\n+macro_rules! expand_to_quote {\n+    () => {\n+        quote! {\n+            let bang_error: bool = 25;\n+        }\n+    }\n+}\n+\n+#[proc_macro]\n+pub fn error_from_bang(_input: TokenStream) -> TokenStream {\n+    expand_to_quote!()\n+}\n+\n+#[proc_macro]\n+pub fn other_error_from_bang(_input: TokenStream) -> TokenStream {\n+    custom_quote::custom_quote! {\n+        my_ident\n+    }\n+}\n+\n+#[proc_macro_attribute]\n+pub fn error_from_attribute(_args: TokenStream, _input: TokenStream) -> TokenStream {\n+    quote! {\n+        struct AttributeError {\n+            field: MissingType\n+        }\n+    }\n+}\n+\n+#[proc_macro_derive(ErrorFromDerive)]\n+pub fn error_from_derive(_input: TokenStream) -> TokenStream {\n+    quote! {\n+        enum DeriveError {\n+            Variant(OtherMissingType)\n+        }\n+    }\n+}"}, {"sha": "d9337fb361bee262b78af084242627824556e334", "filename": "src/test/ui/proc-macro/meta-macro-hygiene.stdout", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.stdout?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -45,10 +45,10 @@ fn main /* 0#0 */() { ; }\n Expansions:\n 0: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: Root\n 1: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: AstPass(StdImports)\n-2: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro(Bang, \"produce_it\")\n+2: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro { kind: Bang, name: \"produce_it\", proc_macro: false }\n 3: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: AstPass(StdImports)\n-4: parent: ExpnId(2), call_site_ctxt: #4, def_site_ctxt: #0, kind: Macro(Bang, \"meta_macro::print_def_site\")\n-5: parent: ExpnId(4), call_site_ctxt: #5, def_site_ctxt: #0, kind: Macro(Bang, \"$crate::dummy\")\n+4: parent: ExpnId(2), call_site_ctxt: #4, def_site_ctxt: #0, kind: Macro { kind: Bang, name: \"meta_macro::print_def_site\", proc_macro: true }\n+5: parent: ExpnId(4), call_site_ctxt: #5, def_site_ctxt: #0, kind: Macro { kind: Bang, name: \"$crate::dummy\", proc_macro: true }\n \n SyntaxContexts:\n #0: parent: #0, outer_mark: (ExpnId(0), Opaque)"}, {"sha": "54dc856bfb03a4871e186d17110e98ea12ca6a6a", "filename": "src/test/ui/proc-macro/nonterminal-token-hygiene.stdout", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-token-hygiene.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-token-hygiene.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-token-hygiene.stdout?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -69,10 +69,10 @@ fn main /* 0#0 */() { }\n Expansions:\n 0: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: Root\n 1: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: AstPass(StdImports)\n-2: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro(Bang, \"outer\")\n+2: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro { kind: Bang, name: \"outer\", proc_macro: false }\n 3: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: AstPass(StdImports)\n-4: parent: ExpnId(2), call_site_ctxt: #4, def_site_ctxt: #4, kind: Macro(Bang, \"inner\")\n-5: parent: ExpnId(4), call_site_ctxt: #6, def_site_ctxt: #0, kind: Macro(Bang, \"print_bang\")\n+4: parent: ExpnId(2), call_site_ctxt: #4, def_site_ctxt: #4, kind: Macro { kind: Bang, name: \"inner\", proc_macro: false }\n+5: parent: ExpnId(4), call_site_ctxt: #6, def_site_ctxt: #0, kind: Macro { kind: Bang, name: \"print_bang\", proc_macro: true }\n \n SyntaxContexts:\n #0: parent: #0, outer_mark: (ExpnId(0), Opaque)"}, {"sha": "e0304a01405a5293af118328180999a39f9e54c4", "filename": "src/test/ui/proc-macro/quote-debug.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/src%2Ftest%2Fui%2Fproc-macro%2Fquote-debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/src%2Ftest%2Fui%2Fproc-macro%2Fquote-debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fquote-debug.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -0,0 +1,18 @@\n+// check-pass\n+// force-host\n+// no-prefer-dynamic\n+// compile-flags: -Z unpretty=expanded\n+//\n+// This file is not actually used as a proc-macro - instead,\n+// it's just used to show the output of the `quote!` macro\n+\n+#![feature(proc_macro_quote)]\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+fn main() {\n+    proc_macro::quote! {\n+        let hello = \"world\";\n+    }\n+}"}, {"sha": "4bdc04b9ac4306654f3d97a1584589df3ea0f935", "filename": "src/test/ui/proc-macro/quote-debug.stdout", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/src%2Ftest%2Fui%2Fproc-macro%2Fquote-debug.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/src%2Ftest%2Fui%2Fproc-macro%2Fquote-debug.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fquote-debug.stdout?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -0,0 +1,52 @@\n+#![feature(prelude_import)]\n+#![no_std]\n+// check-pass\n+// force-host\n+// no-prefer-dynamic\n+// compile-flags: -Z unpretty=expanded\n+//\n+// This file is not actually used as a proc-macro - instead,\n+// it's just used to show the output of the `quote!` macro\n+\n+#![feature(proc_macro_quote)]\n+#![crate_type = \"proc-macro\"]\n+#[prelude_import]\n+use ::std::prelude::rust_2015::*;\n+#[macro_use]\n+extern crate std;\n+\n+extern crate proc_macro;\n+\n+fn main() {\n+    [crate::TokenStream::from(crate::TokenTree::Ident(crate::Ident::new(\"let\",\n+                                                                        crate::Span::recover_proc_macro_span(0)))),\n+     crate::TokenStream::from(crate::TokenTree::Ident(crate::Ident::new(\"hello\",\n+                                                                        crate::Span::recover_proc_macro_span(1)))),\n+     crate::TokenStream::from(crate::TokenTree::Punct(crate::Punct::new('\\u{3d}',\n+                                                                        crate::Spacing::Alone))),\n+     crate::TokenStream::from(crate::TokenTree::Literal({\n+                                                            let mut iter =\n+                                                                \"\\\"world\\\"\".parse::<crate::TokenStream>().unwrap().into_iter();\n+                                                            if let (Some(crate::TokenTree::Literal(mut lit)),\n+                                                                    None) =\n+                                                                   (iter.next(),\n+                                                                    iter.next())\n+                                                               {\n+                                                                lit.set_span(crate::Span::recover_proc_macro_span(2));\n+                                                                lit\n+                                                            } else {\n+                                                                {\n+                                                                    ::core::panicking::panic(\"internal error: entered unreachable code\")\n+                                                                }\n+                                                            }\n+                                                        })),\n+     crate::TokenStream::from(crate::TokenTree::Punct(crate::Punct::new('\\u{3b}',\n+                                                                        crate::Spacing::Alone)))].iter().cloned().collect::<crate::TokenStream>()\n+}\n+const _: () =\n+    {\n+        extern crate proc_macro;\n+        #[rustc_proc_macro_decls]\n+        #[allow(deprecated)]\n+        static _DECLS: &[proc_macro::bridge::client::ProcMacro] = &[];\n+    };"}, {"sha": "ecff2d72587971189c103d41e41e485f5e69fb20", "filename": "src/test/ui/proc-macro/span-from-proc-macro.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/src%2Ftest%2Fui%2Fproc-macro%2Fspan-from-proc-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/src%2Ftest%2Fui%2Fproc-macro%2Fspan-from-proc-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fspan-from-proc-macro.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -0,0 +1,17 @@\n+// aux-build:custom-quote.rs\n+// aux-build:span-from-proc-macro.rs\n+// compile-flags: -Z macro-backtrace\n+\n+#[macro_use]\n+extern crate span_from_proc_macro;\n+\n+#[error_from_attribute] //~ ERROR cannot find type `MissingType`\n+struct ShouldBeRemoved;\n+\n+#[derive(ErrorFromDerive)] //~ ERROR cannot find type `OtherMissingType`\n+struct Kept;\n+\n+fn main() {\n+    error_from_bang!(); //~ ERROR mismatched types\n+    other_error_from_bang!(); //~ ERROR cannot find value `my_ident`\n+}"}, {"sha": "2cbe91afacdd18557031dd1873ac779e28816059", "filename": "src/test/ui/proc-macro/span-from-proc-macro.stderr", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/src%2Ftest%2Fui%2Fproc-macro%2Fspan-from-proc-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/src%2Ftest%2Fui%2Fproc-macro%2Fspan-from-proc-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fspan-from-proc-macro.stderr?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -0,0 +1,62 @@\n+error[E0412]: cannot find type `MissingType` in this scope\n+  --> $DIR/auxiliary/span-from-proc-macro.rs:37:20\n+   |\n+LL | pub fn error_from_attribute(_args: TokenStream, _input: TokenStream) -> TokenStream {\n+   | ----------------------------------------------------------------------------------- in this expansion of procedural macro `#[error_from_attribute]`\n+...\n+LL |             field: MissingType\n+   |                    ^^^^^^^^^^^ not found in this scope\n+   | \n+  ::: $DIR/span-from-proc-macro.rs:8:1\n+   |\n+LL | #[error_from_attribute]\n+   | ----------------------- in this macro invocation\n+\n+error[E0412]: cannot find type `OtherMissingType` in this scope\n+  --> $DIR/auxiliary/span-from-proc-macro.rs:46:21\n+   |\n+LL | pub fn error_from_derive(_input: TokenStream) -> TokenStream {\n+   | ------------------------------------------------------------ in this expansion of procedural macro `#[derive(ErrorFromDerive)]`\n+...\n+LL |             Variant(OtherMissingType)\n+   |                     ^^^^^^^^^^^^^^^^ not found in this scope\n+   | \n+  ::: $DIR/span-from-proc-macro.rs:11:10\n+   |\n+LL | #[derive(ErrorFromDerive)]\n+   |          --------------- in this macro invocation\n+\n+error[E0425]: cannot find value `my_ident` in this scope\n+  --> $DIR/auxiliary/span-from-proc-macro.rs:29:9\n+   |\n+LL | pub fn other_error_from_bang(_input: TokenStream) -> TokenStream {\n+   | ---------------------------------------------------------------- in this expansion of procedural macro `other_error_from_bang!`\n+LL |     custom_quote::custom_quote! {\n+LL |         my_ident\n+   |         ^^^^^^^^ not found in this scope\n+   | \n+  ::: $DIR/span-from-proc-macro.rs:16:5\n+   |\n+LL |     other_error_from_bang!();\n+   |     ------------------------- in this macro invocation\n+\n+error[E0308]: mismatched types\n+  --> $DIR/auxiliary/span-from-proc-macro.rs:16:36\n+   |\n+LL |             let bang_error: bool = 25;\n+   |                             ----   ^^ expected `bool`, found integer\n+   |                             |\n+   |                             expected due to this\n+...\n+LL | pub fn error_from_bang(_input: TokenStream) -> TokenStream {\n+   | ---------------------------------------------------------- in this expansion of procedural macro `error_from_bang!`\n+   | \n+  ::: $DIR/span-from-proc-macro.rs:15:5\n+   |\n+LL |     error_from_bang!();\n+   |     ------------------- in this macro invocation\n+\n+error: aborting due to 4 previous errors\n+\n+Some errors have detailed explanations: E0308, E0412, E0425.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "6966d798c537a8e963cac529d724f22e072142a0", "filename": "src/tools/clippy/clippy_lints/src/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -660,7 +660,7 @@ fn in_attributes_expansion(expr: &Expr<'_>) -> bool {\n     use rustc_span::hygiene::MacroKind;\n     if expr.span.from_expansion() {\n         let data = expr.span.ctxt().outer_expn_data();\n-        matches!(data.kind, ExpnKind::Macro(MacroKind::Attr, _))\n+        matches!(data.kind, ExpnKind::Macro { kind: MacroKind::Attr, name: _, proc_macro: _ })\n     } else {\n         false\n     }"}, {"sha": "d22f7d9a96bf112b59baef5c1ae5ad4c863ec8f4", "filename": "src/tools/clippy/clippy_lints/src/unit_types/unit_cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_types%2Funit_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_types%2Funit_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_types%2Funit_cmp.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -8,7 +8,7 @@ use super::UNIT_CMP;\n pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if expr.span.from_expansion() {\n         if let Some(callee) = expr.span.source_callee() {\n-            if let ExpnKind::Macro(MacroKind::Bang, symbol) = callee.kind {\n+            if let ExpnKind::Macro { kind: MacroKind::Bang, name: symbol, proc_macro: _ } = callee.kind {\n                 if let ExprKind::Binary(ref cmp, left, _) = expr.kind {\n                     let op = cmp.node;\n                     if op.is_comparison() && cx.typeck_results().expr_ty(left).is_unit() {"}, {"sha": "9a0b72f06bbc939f7a4cb2f8f3938c3de91d25fe", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=c1e7e361f7cddd1fe9b3bfef71a6539d2570e4fb", "patch": "@@ -947,7 +947,7 @@ pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n             let data = span.ctxt().outer_expn_data();\n             let new_span = data.call_site;\n \n-            if let ExpnKind::Macro(MacroKind::Bang, mac_name) = data.kind {\n+            if let ExpnKind::Macro { kind: MacroKind::Bang, name: mac_name, proc_macro: _ } = data.kind {\n                 if mac_name.as_str() == name {\n                     return Some(new_span);\n                 }\n@@ -975,7 +975,7 @@ pub fn is_direct_expn_of(span: Span, name: &str) -> Option<Span> {\n         let data = span.ctxt().outer_expn_data();\n         let new_span = data.call_site;\n \n-        if let ExpnKind::Macro(MacroKind::Bang, mac_name) = data.kind {\n+        if let ExpnKind::Macro { kind: MacroKind::Bang, name: mac_name, proc_macro: _ } = data.kind {\n             if mac_name.as_str() == name {\n                 return Some(new_span);\n             }"}]}