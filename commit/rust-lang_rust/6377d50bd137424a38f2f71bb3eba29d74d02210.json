{"sha": "6377d50bd137424a38f2f71bb3eba29d74d02210", "node_id": "C_kwDOAAsO6NoAKDYzNzdkNTBiZDEzNzQyNGEzOGYyZjcxYmIzZWJhMjlkNzRkMDIyMTA", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-02T07:48:50Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-06T17:39:09Z"}, "message": "Support \"for loop\" MIR lowering", "tree": {"sha": "7fb096501ac0d1f083be6918974fdcbb3d643316", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fb096501ac0d1f083be6918974fdcbb3d643316"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6377d50bd137424a38f2f71bb3eba29d74d02210", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6377d50bd137424a38f2f71bb3eba29d74d02210", "html_url": "https://github.com/rust-lang/rust/commit/6377d50bd137424a38f2f71bb3eba29d74d02210", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6377d50bd137424a38f2f71bb3eba29d74d02210/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac04bfd7a7223cc7077f6745c35f8b655ea13c73", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac04bfd7a7223cc7077f6745c35f8b655ea13c73", "html_url": "https://github.com/rust-lang/rust/commit/ac04bfd7a7223cc7077f6745c35f8b655ea13c73"}], "stats": {"total": 371, "additions": 292, "deletions": 79}, "files": [{"sha": "e255bd798ecb6c32d8cb447e4d0353b95a824c79", "filename": "crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/6377d50bd137424a38f2f71bb3eba29d74d02210/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6377d50bd137424a38f2f71bb3eba29d74d02210/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=6377d50bd137424a38f2f71bb3eba29d74d02210", "patch": "@@ -415,6 +415,43 @@ fn loops() {\n     );\n }\n \n+#[test]\n+fn for_loops() {\n+    check_number(\n+        r#\"\n+    //- minicore: iterator\n+\n+    struct Range {\n+        start: u8,\n+        end: u8,\n+    }\n+\n+    impl Iterator for Range {\n+        type Item = u8;\n+        fn next(&mut self) -> Option<u8> {\n+            if self.start >= self.end {\n+                None\n+            } else {\n+                let r = self.start;\n+                self.start = self.start + 1;\n+                Some(r)\n+            }\n+        }\n+    }\n+\n+    const GOAL: u8 = {\n+        let mut sum = 0;\n+        let ar = Range { start: 1, end: 11 };\n+        for i in ar {\n+            sum = sum + i;\n+        }\n+        sum\n+    };\n+        \"#,\n+        55,\n+    );\n+}\n+\n #[test]\n fn recursion() {\n     check_number(\n@@ -518,6 +555,33 @@ fn tuples() {\n     );\n }\n \n+#[test]\n+fn path_pattern_matching() {\n+    check_number(\n+        r#\"\n+    enum Season {\n+        Spring,\n+        Summer,\n+        Fall,\n+        Winter,\n+    }\n+\n+    use Season::*;\n+\n+    const fn f(x: Season) -> i32 {\n+        match x {\n+            Spring => 1,\n+            Summer => 2,\n+            Fall => 3,\n+            Winter => 4,\n+        }\n+    }\n+    const GOAL: i32 = f(Spring) + 10 * f(Summer) + 100 * f(Fall) + 1000 * f(Winter);\n+        \"#,\n+        4321,\n+    );\n+}\n+\n #[test]\n fn pattern_matching_ergonomics() {\n     check_number("}, {"sha": "262c562e9fce5b75398be4eed80bc835d9cfee8a", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6377d50bd137424a38f2f71bb3eba29d74d02210/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6377d50bd137424a38f2f71bb3eba29d74d02210/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=6377d50bd137424a38f2f71bb3eba29d74d02210", "patch": "@@ -354,6 +354,8 @@ pub struct InferenceResult {\n     pub type_of_pat: ArenaMap<PatId, Ty>,\n     pub type_of_binding: ArenaMap<BindingId, Ty>,\n     pub type_of_rpit: ArenaMap<RpitId, Ty>,\n+    /// Type of the result of `.into_iter()` on the for. `ExprId` is the one of the whole for loop.\n+    pub type_of_for_iterator: ArenaMap<ExprId, Ty>,\n     type_mismatches: FxHashMap<ExprOrPatId, TypeMismatch>,\n     /// Interned common types to return references to.\n     standard_types: InternedStandardTypes,\n@@ -549,6 +551,9 @@ impl<'a> InferenceContext<'a> {\n         for ty in result.type_of_rpit.values_mut() {\n             *ty = table.resolve_completely(ty.clone());\n         }\n+        for ty in result.type_of_for_iterator.values_mut() {\n+            *ty = table.resolve_completely(ty.clone());\n+        }\n         for mismatch in result.type_mismatches.values_mut() {\n             mismatch.expected = table.resolve_completely(mismatch.expected.clone());\n             mismatch.actual = table.resolve_completely(mismatch.actual.clone());"}, {"sha": "535189ff0288bd039b6edbd20cfe72c47a7d23fa", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6377d50bd137424a38f2f71bb3eba29d74d02210/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6377d50bd137424a38f2f71bb3eba29d74d02210/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=6377d50bd137424a38f2f71bb3eba29d74d02210", "patch": "@@ -242,8 +242,10 @@ impl<'a> InferenceContext<'a> {\n                 let iterable_ty = self.infer_expr(iterable, &Expectation::none());\n                 let into_iter_ty =\n                     self.resolve_associated_type(iterable_ty, self.resolve_into_iter_item());\n-                let pat_ty =\n-                    self.resolve_associated_type(into_iter_ty, self.resolve_iterator_item());\n+                let pat_ty = self\n+                    .resolve_associated_type(into_iter_ty.clone(), self.resolve_iterator_item());\n+\n+                self.result.type_of_for_iterator.insert(tgt_expr, into_iter_ty);\n \n                 self.infer_top_pat(pat, &pat_ty);\n                 self.with_breakable_ctx(BreakableKind::Loop, None, label, |this| {"}, {"sha": "7c1cbbdf53d27f40ecfa8c54b9d1f917b3cbd8ce", "filename": "crates/hir-ty/src/mir.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6377d50bd137424a38f2f71bb3eba29d74d02210/crates%2Fhir-ty%2Fsrc%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6377d50bd137424a38f2f71bb3eba29d74d02210/crates%2Fhir-ty%2Fsrc%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir.rs?ref=6377d50bd137424a38f2f71bb3eba29d74d02210", "patch": "@@ -83,6 +83,10 @@ impl Operand {\n     fn from_bytes(data: Vec<u8>, ty: Ty) -> Self {\n         Operand::from_concrete_const(data, MemoryMap::default(), ty)\n     }\n+\n+    fn const_zst(ty: Ty) -> Operand {\n+        Self::from_bytes(vec![], ty)\n+    }\n }\n \n #[derive(Debug, PartialEq, Eq, Clone)]"}, {"sha": "b0b09fcd53b5c4528c0c3a14311414efd559b40f", "filename": "crates/hir-ty/src/mir/eval.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6377d50bd137424a38f2f71bb3eba29d74d02210/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6377d50bd137424a38f2f71bb3eba29d74d02210/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs?ref=6377d50bd137424a38f2f71bb3eba29d74d02210", "patch": "@@ -1122,7 +1122,12 @@ impl Evaluator<'_> {\n     }\n \n     fn detect_lang_function(&self, def: FunctionId) -> Option<LangItem> {\n-        lang_attr(self.db.upcast(), def)\n+        let candidate = lang_attr(self.db.upcast(), def)?;\n+        // filter normal lang functions out\n+        if [LangItem::IntoIterIntoIter, LangItem::IteratorNext].contains(&candidate) {\n+            return None;\n+        }\n+        Some(candidate)\n     }\n \n     fn create_memory_map(&self, bytes: &[u8], ty: &Ty, locals: &Locals<'_>) -> Result<MemoryMap> {"}, {"sha": "f9a66286b286c1c809fc5bb9fea0726d27ad486b", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 179, "deletions": 76, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/6377d50bd137424a38f2f71bb3eba29d74d02210/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6377d50bd137424a38f2f71bb3eba29d74d02210/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=6377d50bd137424a38f2f71bb3eba29d74d02210", "patch": "@@ -9,6 +9,7 @@ use hir_def::{\n         Array, BindingAnnotation, BindingId, ExprId, LabelId, Literal, MatchArm, Pat, PatId,\n         RecordLitField,\n     },\n+    lang_item::{LangItem, LangItemTarget},\n     layout::LayoutError,\n     resolver::{resolver_for_expr, ResolveValueResult, ValueNs},\n     DefWithBodyId, EnumVariantId, HasModule,\n@@ -17,8 +18,8 @@ use la_arena::ArenaMap;\n \n use crate::{\n     consteval::ConstEvalError, db::HirDatabase, display::HirDisplay, infer::TypeMismatch,\n-    inhabitedness::is_ty_uninhabited_from, layout::layout_of_ty, mapping::ToChalk, utils::generics,\n-    Adjust, AutoBorrow, CallableDefId, TyBuilder, TyExt,\n+    inhabitedness::is_ty_uninhabited_from, layout::layout_of_ty, mapping::ToChalk, static_lifetime,\n+    utils::generics, Adjust, AutoBorrow, CallableDefId, TyBuilder, TyExt,\n };\n \n use super::*;\n@@ -59,6 +60,7 @@ pub enum MirLowerError {\n     Loop,\n     /// Something that should never happen and is definitely a bug, but we don't want to panic if it happened\n     ImplementationError(&'static str),\n+    LangItemNotFound(LangItem),\n }\n \n macro_rules! not_supported {\n@@ -484,13 +486,64 @@ impl MirLowerCtx<'_> {\n                     Ok(())\n                 })\n             }\n-            Expr::For { .. } => not_supported!(\"for loop\"),\n+            &Expr::For { iterable, pat, body, label } => {\n+                let into_iter_fn = self.resolve_lang_item(LangItem::IntoIterIntoIter)?\n+                    .as_function().ok_or(MirLowerError::LangItemNotFound(LangItem::IntoIterIntoIter))?;\n+                let iter_next_fn = self.resolve_lang_item(LangItem::IteratorNext)?\n+                    .as_function().ok_or(MirLowerError::LangItemNotFound(LangItem::IteratorNext))?;\n+                let option_some = self.resolve_lang_item(LangItem::OptionSome)?\n+                    .as_enum_variant().ok_or(MirLowerError::LangItemNotFound(LangItem::OptionSome))?;\n+                let option = option_some.parent;\n+                let into_iter_fn_op = Operand::const_zst(\n+                    TyKind::FnDef(\n+                        self.db.intern_callable_def(CallableDefId::FunctionId(into_iter_fn)).into(),\n+                        Substitution::from1(Interner, self.expr_ty(iterable))\n+                    ).intern(Interner));\n+                let iter_next_fn_op = Operand::const_zst(\n+                    TyKind::FnDef(\n+                        self.db.intern_callable_def(CallableDefId::FunctionId(iter_next_fn)).into(),\n+                        Substitution::from1(Interner, self.expr_ty(iterable))\n+                    ).intern(Interner));\n+                let iterator_ty = &self.infer.type_of_for_iterator[expr_id];\n+                let ref_mut_iterator_ty = TyKind::Ref(Mutability::Mut, static_lifetime(), iterator_ty.clone()).intern(Interner);\n+                let item_ty = &self.infer.type_of_pat[pat];\n+                let option_item_ty = TyKind::Adt(chalk_ir::AdtId(option.into()), Substitution::from1(Interner, item_ty.clone())).intern(Interner);\n+                let iterator_place: Place = self.temp(iterator_ty.clone())?.into();\n+                let option_item_place: Place = self.temp(option_item_ty.clone())?.into();\n+                let ref_mut_iterator_place: Place = self.temp(ref_mut_iterator_ty)?.into();\n+                let Some(current) = self.lower_call_and_args(into_iter_fn_op, Some(iterable).into_iter(), iterator_place.clone(), current, false)?\n+                else {\n+                    return Ok(None);\n+                };\n+                self.push_assignment(current, ref_mut_iterator_place.clone(), Rvalue::Ref(BorrowKind::Mut { allow_two_phase_borrow: false }, iterator_place), expr_id.into());\n+                self.lower_loop(current, label, |this, begin| {\n+                    this.push_storage_live(pat, begin)?;\n+                    let Some(current) = this.lower_call(iter_next_fn_op, vec![Operand::Copy(ref_mut_iterator_place)], option_item_place.clone(), begin, false)?\n+                    else {\n+                        return Ok(());\n+                    };\n+                    let end = this.current_loop_end()?;\n+                    let (current, _) = this.pattern_matching_variant(\n+                        option_item_ty.clone(),\n+                        BindingAnnotation::Unannotated,\n+                        option_item_place.into(),\n+                        option_some.into(),\n+                        current,\n+                        pat.into(),\n+                        Some(end),\n+                        &[pat], &None)?;\n+                    if let (_, Some(block)) = this.lower_expr_to_some_place(body, current)? {\n+                        this.set_goto(block, begin);\n+                    }\n+                    Ok(())\n+                })\n+            },\n             Expr::Call { callee, args, .. } => {\n                 let callee_ty = self.expr_ty_after_adjustments(*callee);\n                 match &callee_ty.data(Interner).kind {\n                     chalk_ir::TyKind::FnDef(..) => {\n                         let func = Operand::from_bytes(vec![], callee_ty.clone());\n-                        self.lower_call(func, args.iter().copied(), place, current, self.is_uninhabited(expr_id))\n+                        self.lower_call_and_args(func, args.iter().copied(), place, current, self.is_uninhabited(expr_id))\n                     }\n                     TyKind::Scalar(_)\n                     | TyKind::Tuple(_, _)\n@@ -527,7 +580,7 @@ impl MirLowerCtx<'_> {\n                 )\n                 .intern(Interner);\n                 let func = Operand::from_bytes(vec![], ty);\n-                self.lower_call(\n+                self.lower_call_and_args(\n                     func,\n                     iter::once(*receiver).chain(args.iter().copied()),\n                     place,\n@@ -962,7 +1015,7 @@ impl MirLowerCtx<'_> {\n         Ok(prev_block)\n     }\n \n-    fn lower_call(\n+    fn lower_call_and_args(\n         &mut self,\n         func: Operand,\n         args: impl Iterator<Item = ExprId>,\n@@ -983,6 +1036,17 @@ impl MirLowerCtx<'_> {\n         else {\n             return Ok(None);\n         };\n+        self.lower_call(func, args, place, current, is_uninhabited)\n+    }\n+\n+    fn lower_call(\n+        &mut self,\n+        func: Operand,\n+        args: Vec<Operand>,\n+        place: Place,\n+        current: BasicBlockId,\n+        is_uninhabited: bool,\n+    ) -> Result<Option<BasicBlockId>> {\n         let b = if is_uninhabited { None } else { Some(self.new_basic_block()) };\n         self.set_terminator(\n             current,\n@@ -1112,7 +1176,22 @@ impl MirLowerCtx<'_> {\n             Pat::Record { .. } => not_supported!(\"record pattern\"),\n             Pat::Range { .. } => not_supported!(\"range pattern\"),\n             Pat::Slice { .. } => not_supported!(\"slice pattern\"),\n-            Pat::Path(_) => not_supported!(\"path pattern\"),\n+            Pat::Path(_) => {\n+                let Some(variant) = self.infer.variant_resolution_for_pat(pattern) else {\n+                    not_supported!(\"unresolved variant\");\n+                };\n+                self.pattern_matching_variant(\n+                    cond_ty,\n+                    binding_mode,\n+                    cond_place,\n+                    variant,\n+                    current,\n+                    pattern.into(),\n+                    current_else,\n+                    &[],\n+                    &None,\n+                )?\n+            }\n             Pat::Lit(l) => {\n                 let then_target = self.new_basic_block();\n                 let else_target = current_else.unwrap_or_else(|| self.new_basic_block());\n@@ -1183,82 +1262,101 @@ impl MirLowerCtx<'_> {\n                 let Some(variant) = self.infer.variant_resolution_for_pat(pattern) else {\n                     not_supported!(\"unresolved variant\");\n                 };\n-                pattern_matching_dereference(&mut cond_ty, &mut binding_mode, &mut cond_place);\n-                let subst = match cond_ty.kind(Interner) {\n-                    TyKind::Adt(_, s) => s,\n-                    _ => {\n-                        return Err(MirLowerError::TypeError(\n-                            \"non adt type matched with tuple struct\",\n-                        ))\n-                    }\n-                };\n-                let fields_type = self.db.field_types(variant);\n-                match variant {\n-                    VariantId::EnumVariantId(v) => {\n-                        let e = self.db.const_eval_discriminant(v)? as u128;\n-                        let next = self.new_basic_block();\n-                        let tmp = self.discr_temp_place();\n-                        self.push_assignment(\n-                            current,\n-                            tmp.clone(),\n-                            Rvalue::Discriminant(cond_place.clone()),\n-                            pattern.into(),\n-                        );\n-                        let else_target = current_else.unwrap_or_else(|| self.new_basic_block());\n-                        self.set_terminator(\n-                            current,\n-                            Terminator::SwitchInt {\n-                                discr: Operand::Copy(tmp),\n-                                targets: SwitchTargets::static_if(e, next, else_target),\n-                            },\n-                        );\n-                        let enum_data = self.db.enum_data(v.parent);\n-                        let fields =\n-                            enum_data.variants[v.local_id].variant_data.fields().iter().map(\n-                                |(x, _)| {\n-                                    (\n-                                        PlaceElem::Field(FieldId { parent: v.into(), local_id: x }),\n-                                        fields_type[x].clone().substitute(Interner, subst),\n-                                    )\n-                                },\n-                            );\n-                        self.pattern_match_tuple_like(\n-                            next,\n-                            Some(else_target),\n-                            args.iter().zip(fields).map(|(x, y)| (y.0, *x, y.1)),\n-                            *ellipsis,\n-                            &cond_place,\n-                            binding_mode,\n-                        )?\n-                    }\n-                    VariantId::StructId(s) => {\n-                        let struct_data = self.db.struct_data(s);\n-                        let fields = struct_data.variant_data.fields().iter().map(|(x, _)| {\n-                            (\n-                                PlaceElem::Field(FieldId { parent: s.into(), local_id: x }),\n-                                fields_type[x].clone().substitute(Interner, subst),\n-                            )\n-                        });\n-                        self.pattern_match_tuple_like(\n-                            current,\n-                            current_else,\n-                            args.iter().zip(fields).map(|(x, y)| (y.0, *x, y.1)),\n-                            *ellipsis,\n-                            &cond_place,\n-                            binding_mode,\n-                        )?\n-                    }\n-                    VariantId::UnionId(_) => {\n-                        return Err(MirLowerError::TypeError(\"pattern matching on union\"))\n-                    }\n-                }\n+                self.pattern_matching_variant(\n+                    cond_ty,\n+                    binding_mode,\n+                    cond_place,\n+                    variant,\n+                    current,\n+                    pattern.into(),\n+                    current_else,\n+                    args,\n+                    ellipsis,\n+                )?\n             }\n             Pat::Ref { .. } => not_supported!(\"& pattern\"),\n             Pat::Box { .. } => not_supported!(\"box pattern\"),\n             Pat::ConstBlock(_) => not_supported!(\"const block pattern\"),\n         })\n     }\n \n+    fn pattern_matching_variant(\n+        &mut self,\n+        mut cond_ty: Ty,\n+        mut binding_mode: BindingAnnotation,\n+        mut cond_place: Place,\n+        variant: VariantId,\n+        current: BasicBlockId,\n+        span: MirSpan,\n+        current_else: Option<BasicBlockId>,\n+        args: &[PatId],\n+        ellipsis: &Option<usize>,\n+    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n+        pattern_matching_dereference(&mut cond_ty, &mut binding_mode, &mut cond_place);\n+        let subst = match cond_ty.kind(Interner) {\n+            TyKind::Adt(_, s) => s,\n+            _ => return Err(MirLowerError::TypeError(\"non adt type matched with tuple struct\")),\n+        };\n+        let fields_type = self.db.field_types(variant);\n+        Ok(match variant {\n+            VariantId::EnumVariantId(v) => {\n+                let e = self.db.const_eval_discriminant(v)? as u128;\n+                let next = self.new_basic_block();\n+                let tmp = self.discr_temp_place();\n+                self.push_assignment(\n+                    current,\n+                    tmp.clone(),\n+                    Rvalue::Discriminant(cond_place.clone()),\n+                    span,\n+                );\n+                let else_target = current_else.unwrap_or_else(|| self.new_basic_block());\n+                self.set_terminator(\n+                    current,\n+                    Terminator::SwitchInt {\n+                        discr: Operand::Copy(tmp),\n+                        targets: SwitchTargets::static_if(e, next, else_target),\n+                    },\n+                );\n+                let enum_data = self.db.enum_data(v.parent);\n+                let fields =\n+                    enum_data.variants[v.local_id].variant_data.fields().iter().map(|(x, _)| {\n+                        (\n+                            PlaceElem::Field(FieldId { parent: v.into(), local_id: x }),\n+                            fields_type[x].clone().substitute(Interner, subst),\n+                        )\n+                    });\n+                self.pattern_match_tuple_like(\n+                    next,\n+                    Some(else_target),\n+                    args.iter().zip(fields).map(|(x, y)| (y.0, *x, y.1)),\n+                    *ellipsis,\n+                    &cond_place,\n+                    binding_mode,\n+                )?\n+            }\n+            VariantId::StructId(s) => {\n+                let struct_data = self.db.struct_data(s);\n+                let fields = struct_data.variant_data.fields().iter().map(|(x, _)| {\n+                    (\n+                        PlaceElem::Field(FieldId { parent: s.into(), local_id: x }),\n+                        fields_type[x].clone().substitute(Interner, subst),\n+                    )\n+                });\n+                self.pattern_match_tuple_like(\n+                    current,\n+                    current_else,\n+                    args.iter().zip(fields).map(|(x, y)| (y.0, *x, y.1)),\n+                    *ellipsis,\n+                    &cond_place,\n+                    binding_mode,\n+                )?\n+            }\n+            VariantId::UnionId(_) => {\n+                return Err(MirLowerError::TypeError(\"pattern matching on union\"))\n+            }\n+        })\n+    }\n+\n     fn pattern_match_tuple_like(\n         &mut self,\n         mut current: BasicBlockId,\n@@ -1384,6 +1482,11 @@ impl MirLowerCtx<'_> {\n         });\n         Ok(())\n     }\n+\n+    fn resolve_lang_item(&self, item: LangItem) -> Result<LangItemTarget> {\n+        let crate_id = self.owner.module(self.db.upcast()).krate();\n+        self.db.lang_item(crate_id, item).ok_or(MirLowerError::LangItemNotFound(item))\n+    }\n }\n \n fn pattern_matching_dereference("}, {"sha": "a6aa069e27b3446e8cd1a3fa99c30f4498740c3d", "filename": "crates/ide-diagnostics/src/handlers/mutability_errors.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6377d50bd137424a38f2f71bb3eba29d74d02210/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6377d50bd137424a38f2f71bb3eba29d74d02210/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs?ref=6377d50bd137424a38f2f71bb3eba29d74d02210", "patch": "@@ -507,6 +507,22 @@ fn f(x: i32) {\n    x = 5;\n  //^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn for_loop() {\n+        check_diagnostics(\n+            r#\"\n+//- minicore: iterators\n+fn f(x: [(i32, u8); 10]) {\n+    for (a, mut b) in x {\n+          //^^^^^ \ud83d\udca1 weak: remove this `mut`\n+        a = 2;\n+      //^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `a`\n+    }\n+}\n \"#,\n         );\n     }"}, {"sha": "44d7f69061f2a22d4a9ba2b89a4c8351134a579f", "filename": "crates/test-utils/src/minicore.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6377d50bd137424a38f2f71bb3eba29d74d02210/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6377d50bd137424a38f2f71bb3eba29d74d02210/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=6377d50bd137424a38f2f71bb3eba29d74d02210", "patch": "@@ -728,6 +728,20 @@ pub mod iter {\n                     self\n                 }\n             }\n+            pub struct IntoIter<T, const N: usize>([T; N]);\n+            impl<T, const N: usize> IntoIterator for [T; N] {\n+                type Item = T;\n+                type IntoIter = IntoIter<T, N>;\n+                fn into_iter(self) -> I {\n+                    IntoIter(self)\n+                }\n+            }\n+            impl<T, const N: usize> Iterator for IntoIter<T, N> {\n+                type Item = T;\n+                fn next(&mut self) -> Option<T> {\n+                    loop {}\n+                }\n+            }\n         }\n         pub use self::collect::IntoIterator;\n     }"}]}