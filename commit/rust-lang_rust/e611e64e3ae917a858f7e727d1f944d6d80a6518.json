{"sha": "e611e64e3ae917a858f7e727d1f944d6d80a6518", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2MTFlNjRlM2FlOTE3YTg1OGY3ZTcyN2QxZjk0NGQ2ZDgwYTY1MTg=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-05-15T11:29:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-15T11:29:49Z"}, "message": "Rollup merge of #85215 - richkadel:ice-fixes-minus-dead-blocks, r=tmandry\n\ncoverage bug fixes and some refactoring\n\nThis replaces the relevant commits (2 and 3) from PR #85082, and also corrects an error querying for coverageinfo.\n\n1. `coverageinfo` query needs to use the same MIR as codegen\n\nI ran into an error trying to fix dead block coverage and realized the\n`coverageinfo` query is getting a different MIR compared to the\ncodegenned MIR, which can sometimes be a problem during mapgen.\n\nI changed that query to use the `InstandeDef` (which includes the\ngeneric parameter substitutions, prosibly specific to const params)\ninstead of the `DefId` (without unknown/default const substitutions).\n\n2. Simplified body_span and filtered span code\n\n  Some code cleanup extracted from future (but unfinished) commit to fix\n  coverage in attr macro functions.\n\n3. Spanview needs the relevant body_span used for coverage\n\nThe coverage body_span doesn't always match the function body_span.\n\nr? ```@tmandry```", "tree": {"sha": "7f545827fb7d9ff3213f94554de94259bc190053", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f545827fb7d9ff3213f94554de94259bc190053"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e611e64e3ae917a858f7e727d1f944d6d80a6518", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgn7CuCRBK7hj4Ov3rIwAAPlMIACG6F73g+gCrgFMyoBY3HH6a\nGsJ28XHrPMFtcXnfjLaA7JGxniQNq9XayAidqEMYZecN48u2ux6TAR1XqdIeSKzP\n4ZhSXND6VwvzswORxmD/A5rlwKzpc8QVRS70cKZclKiWRw68+QPjmsxIDSfRapbx\nR9p7HGSgWNrE5BnRMyEeCSLajX6Ch/l5SBO1yK7FsdZxC2rCPO6myYwBIJSx32FJ\n+9hruCWAv9UVa+zEOjPXpX+oPjh9hqN72swgyL99aulISGMXm8RVJ799VY1oaJ8t\nWIiwMvBquUB/ebxZhyVMGWawhLYfEmF0ZBRIDs2FV1jjRsZVLkbMhQt44THWIuI=\n=Ln7K\n-----END PGP SIGNATURE-----\n", "payload": "tree 7f545827fb7d9ff3213f94554de94259bc190053\nparent c4f81c12eaec615addb36ebc6531dfcdca7fc915\nparent aed8ef5a4d81bb66917ca31a589d5922c9bcf065\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1621078189 +0200\ncommitter GitHub <noreply@github.com> 1621078189 +0200\n\nRollup merge of #85215 - richkadel:ice-fixes-minus-dead-blocks, r=tmandry\n\ncoverage bug fixes and some refactoring\n\nThis replaces the relevant commits (2 and 3) from PR #85082, and also corrects an error querying for coverageinfo.\n\n1. `coverageinfo` query needs to use the same MIR as codegen\n\nI ran into an error trying to fix dead block coverage and realized the\n`coverageinfo` query is getting a different MIR compared to the\ncodegenned MIR, which can sometimes be a problem during mapgen.\n\nI changed that query to use the `InstandeDef` (which includes the\ngeneric parameter substitutions, prosibly specific to const params)\ninstead of the `DefId` (without unknown/default const substitutions).\n\n2. Simplified body_span and filtered span code\n\n  Some code cleanup extracted from future (but unfinished) commit to fix\n  coverage in attr macro functions.\n\n3. Spanview needs the relevant body_span used for coverage\n\nThe coverage body_span doesn't always match the function body_span.\n\nr? ```@tmandry```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e611e64e3ae917a858f7e727d1f944d6d80a6518", "html_url": "https://github.com/rust-lang/rust/commit/e611e64e3ae917a858f7e727d1f944d6d80a6518", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e611e64e3ae917a858f7e727d1f944d6d80a6518/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4f81c12eaec615addb36ebc6531dfcdca7fc915", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4f81c12eaec615addb36ebc6531dfcdca7fc915", "html_url": "https://github.com/rust-lang/rust/commit/c4f81c12eaec615addb36ebc6531dfcdca7fc915"}, {"sha": "aed8ef5a4d81bb66917ca31a589d5922c9bcf065", "url": "https://api.github.com/repos/rust-lang/rust/commits/aed8ef5a4d81bb66917ca31a589d5922c9bcf065", "html_url": "https://github.com/rust-lang/rust/commit/aed8ef5a4d81bb66917ca31a589d5922c9bcf065"}], "stats": {"total": 186, "additions": 95, "deletions": 91}, "files": [{"sha": "08442c588f87902ba3dede3d04cd3f7cf87f8090", "filename": "compiler/rustc_codegen_ssa/src/coverageinfo/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e611e64e3ae917a858f7e727d1f944d6d80a6518/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e611e64e3ae917a858f7e727d1f944d6d80a6518/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs?ref=e611e64e3ae917a858f7e727d1f944d6d80a6518", "patch": "@@ -49,9 +49,9 @@ impl<'tcx> FunctionCoverage<'tcx> {\n     }\n \n     fn create(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>, is_used: bool) -> Self {\n-        let coverageinfo = tcx.coverageinfo(instance.def_id());\n+        let coverageinfo = tcx.coverageinfo(instance.def);\n         debug!(\n-            \"FunctionCoverage::new(instance={:?}) has coverageinfo={:?}. is_used={}\",\n+            \"FunctionCoverage::create(instance={:?}) has coverageinfo={:?}. is_used={}\",\n             instance, coverageinfo, is_used\n         );\n         Self {"}, {"sha": "a283bf1de763a9da378109d255792eeef0d2f8ff", "filename": "compiler/rustc_codegen_ssa/src/mir/coverageinfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e611e64e3ae917a858f7e727d1f944d6d80a6518/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e611e64e3ae917a858f7e727d1f944d6d80a6518/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs?ref=e611e64e3ae917a858f7e727d1f944d6d80a6518", "patch": "@@ -31,7 +31,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         bx.add_coverage_counter(instance, id, code_region);\n                     }\n \n-                    let coverageinfo = bx.tcx().coverageinfo(instance.def_id());\n+                    let coverageinfo = bx.tcx().coverageinfo(instance.def);\n \n                     let fn_name = bx.get_pgo_func_name_var(instance);\n                     let hash = bx.const_u64(function_source_hash);"}, {"sha": "d6c4ac99085e969c2366488c5f16582589b5993d", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e611e64e3ae917a858f7e727d1f944d6d80a6518/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e611e64e3ae917a858f7e727d1f944d6d80a6518/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=e611e64e3ae917a858f7e727d1f944d6d80a6518", "patch": "@@ -335,10 +335,9 @@ rustc_queries! {\n \n     /// Returns coverage summary info for a function, after executing the `InstrumentCoverage`\n     /// MIR pass (assuming the -Zinstrument-coverage option is enabled).\n-    query coverageinfo(key: DefId) -> mir::CoverageInfo {\n-        desc { |tcx| \"retrieving coverage info from MIR for `{}`\", tcx.def_path_str(key) }\n+    query coverageinfo(key: ty::InstanceDef<'tcx>) -> mir::CoverageInfo {\n+        desc { |tcx| \"retrieving coverage info from MIR for `{}`\", tcx.def_path_str(key.def_id()) }\n         storage(ArenaCacheSelector<'tcx>)\n-        cache_on_disk_if { key.is_local() }\n     }\n \n     /// Returns the name of the file that contains the function body, if instrumented for coverage."}, {"sha": "2397d627880f337f63fbfa470757f8b40d7d3185", "filename": "compiler/rustc_mir/src/transform/coverage/debug.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e611e64e3ae917a858f7e727d1f944d6d80a6518/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e611e64e3ae917a858f7e727d1f944d6d80a6518/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs?ref=e611e64e3ae917a858f7e727d1f944d6d80a6518", "patch": "@@ -120,6 +120,7 @@ use rustc_index::vec::Idx;\n use rustc_middle::mir::coverage::*;\n use rustc_middle::mir::{self, BasicBlock, TerminatorKind};\n use rustc_middle::ty::TyCtxt;\n+use rustc_span::Span;\n \n use std::iter;\n use std::lazy::SyncOnceCell;\n@@ -636,6 +637,7 @@ pub(super) fn dump_coverage_spanview(\n     mir_body: &mir::Body<'tcx>,\n     basic_coverage_blocks: &CoverageGraph,\n     pass_name: &str,\n+    body_span: Span,\n     coverage_spans: &Vec<CoverageSpan>,\n ) {\n     let mir_source = mir_body.source;\n@@ -647,7 +649,7 @@ pub(super) fn dump_coverage_spanview(\n     let crate_name = tcx.crate_name(def_id.krate);\n     let item_name = tcx.def_path(def_id).to_filename_friendly_no_crate();\n     let title = format!(\"{}.{} - Coverage Spans\", crate_name, item_name);\n-    spanview::write_document(tcx, def_id, span_viewables, &title, &mut file)\n+    spanview::write_document(tcx, body_span, span_viewables, &title, &mut file)\n         .expect(\"Unexpected IO error dumping coverage spans as HTML\");\n }\n "}, {"sha": "71c244fdd4a3ae5e991340a2b67251eca40c8ca9", "filename": "compiler/rustc_mir/src/transform/coverage/mod.rs", "status": "modified", "additions": 41, "deletions": 28, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e611e64e3ae917a858f7e727d1f944d6d80a6518/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e611e64e3ae917a858f7e727d1f944d6d80a6518/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs?ref=e611e64e3ae917a858f7e727d1f944d6d80a6518", "patch": "@@ -95,7 +95,7 @@ impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n \n         trace!(\"InstrumentCoverage starting for {:?}\", mir_source.def_id());\n         Instrumentor::new(&self.name(), tcx, mir_body).inject_counters();\n-        trace!(\"InstrumentCoverage starting for {:?}\", mir_source.def_id());\n+        trace!(\"InstrumentCoverage done for {:?}\", mir_source.def_id());\n     }\n }\n \n@@ -116,25 +116,7 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n         let def_id = mir_body.source.def_id();\n         let (some_fn_sig, hir_body) = fn_sig_and_body(tcx, def_id);\n \n-        let mut body_span = hir_body.value.span;\n-\n-        if tcx.is_closure(def_id) {\n-            // If the MIR function is a closure, and if the closure body span\n-            // starts from a macro, but it's content is not in that macro, try\n-            // to find a non-macro callsite, and instrument the spans there\n-            // instead.\n-            loop {\n-                let expn_data = body_span.ctxt().outer_expn_data();\n-                if expn_data.is_root() {\n-                    break;\n-                }\n-                if let ExpnKind::Macro { .. } = expn_data.kind {\n-                    body_span = expn_data.call_site;\n-                } else {\n-                    break;\n-                }\n-            }\n-        }\n+        let body_span = get_body_span(tcx, hir_body, mir_body);\n \n         let source_file = source_map.lookup_source_file(body_span.lo());\n         let fn_sig_span = match some_fn_sig.filter(|fn_sig| {\n@@ -144,6 +126,15 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n             Some(fn_sig) => fn_sig.span.with_hi(body_span.lo()),\n             None => body_span.shrink_to_lo(),\n         };\n+\n+        debug!(\n+            \"instrumenting {}: {:?}, fn sig span: {:?}, body span: {:?}\",\n+            if tcx.is_closure(def_id) { \"closure\" } else { \"function\" },\n+            def_id,\n+            fn_sig_span,\n+            body_span\n+        );\n+\n         let function_source_hash = hash_mir_source(tcx, hir_body);\n         let basic_coverage_blocks = CoverageGraph::from_mir(mir_body);\n         Self {\n@@ -160,19 +151,11 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n \n     fn inject_counters(&'a mut self) {\n         let tcx = self.tcx;\n-        let source_map = tcx.sess.source_map();\n         let mir_source = self.mir_body.source;\n         let def_id = mir_source.def_id();\n         let fn_sig_span = self.fn_sig_span;\n         let body_span = self.body_span;\n \n-        debug!(\n-            \"instrumenting {:?}, fn sig span: {}, body span: {}\",\n-            def_id,\n-            source_map.span_to_diagnostic_string(fn_sig_span),\n-            source_map.span_to_diagnostic_string(body_span)\n-        );\n-\n         let mut graphviz_data = debug::GraphvizData::new();\n         let mut debug_used_expressions = debug::UsedExpressions::new();\n \n@@ -204,6 +187,7 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n                 self.mir_body,\n                 &self.basic_coverage_blocks,\n                 self.pass_name,\n+                body_span,\n                 &coverage_spans,\n             );\n         }\n@@ -560,6 +544,35 @@ fn fn_sig_and_body<'tcx>(\n     (hir::map::fn_sig(hir_node), tcx.hir().body(fn_body_id))\n }\n \n+fn get_body_span<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    hir_body: &rustc_hir::Body<'tcx>,\n+    mir_body: &mut mir::Body<'tcx>,\n+) -> Span {\n+    let mut body_span = hir_body.value.span;\n+    let def_id = mir_body.source.def_id();\n+\n+    if tcx.is_closure(def_id) {\n+        // If the MIR function is a closure, and if the closure body span\n+        // starts from a macro, but it's content is not in that macro, try\n+        // to find a non-macro callsite, and instrument the spans there\n+        // instead.\n+        loop {\n+            let expn_data = body_span.ctxt().outer_expn_data();\n+            if expn_data.is_root() {\n+                break;\n+            }\n+            if let ExpnKind::Macro { .. } = expn_data.kind {\n+                body_span = expn_data.call_site;\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+    body_span\n+}\n+\n fn hash_mir_source<'tcx>(tcx: TyCtxt<'tcx>, hir_body: &'tcx rustc_hir::Body<'tcx>) -> u64 {\n     let mut hcx = tcx.create_no_span_stable_hashing_context();\n     hash(&mut hcx, &hir_body.value).to_smaller_hash()"}, {"sha": "760f16eae6b1f85be18bea6412b0f260c77b4ed8", "filename": "compiler/rustc_mir/src/transform/coverage/query.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e611e64e3ae917a858f7e727d1f944d6d80a6518/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e611e64e3ae917a858f7e727d1f944d6d80a6518/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fquery.rs?ref=e611e64e3ae917a858f7e727d1f944d6d80a6518", "patch": "@@ -120,8 +120,8 @@ impl CoverageVisitor {\n     }\n }\n \n-fn coverageinfo<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> CoverageInfo {\n-    let mir_body = mir_body(tcx, def_id);\n+fn coverageinfo<'tcx>(tcx: TyCtxt<'tcx>, instance_def: ty::InstanceDef<'tcx>) -> CoverageInfo {\n+    let mir_body = tcx.instance_mir(instance_def);\n \n     let mut coverage_visitor = CoverageVisitor {\n         // num_counters always has at least the `ZERO` counter."}, {"sha": "f62171b3c535c757fe25accb398462dfa7bce5b3", "filename": "compiler/rustc_mir/src/transform/coverage/spans.rs", "status": "modified", "additions": 35, "deletions": 43, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/e611e64e3ae917a858f7e727d1f944d6d80a6518/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e611e64e3ae917a858f7e727d1f944d6d80a6518/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs?ref=e611e64e3ae917a858f7e727d1f944d6d80a6518", "patch": "@@ -530,17 +530,25 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n                     .iter()\n                     .enumerate()\n                     .filter_map(move |(index, statement)| {\n-                        filtered_statement_span(statement, self.body_span).map(\n-                            |(span, expn_span)| {\n-                                CoverageSpan::for_statement(\n-                                    statement, span, expn_span, bcb, bb, index,\n-                                )\n-                            },\n-                        )\n+                        filtered_statement_span(statement).map(|span| {\n+                            CoverageSpan::for_statement(\n+                                statement,\n+                                function_source_span(span, self.body_span),\n+                                span,\n+                                bcb,\n+                                bb,\n+                                index,\n+                            )\n+                        })\n                     })\n-                    .chain(filtered_terminator_span(data.terminator(), self.body_span).map(\n-                        |(span, expn_span)| CoverageSpan::for_terminator(span, expn_span, bcb, bb),\n-                    ))\n+                    .chain(filtered_terminator_span(data.terminator()).map(|span| {\n+                        CoverageSpan::for_terminator(\n+                            function_source_span(span, self.body_span),\n+                            span,\n+                            bcb,\n+                            bb,\n+                        )\n+                    }))\n             })\n             .collect()\n     }\n@@ -795,13 +803,9 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n     }\n }\n \n-/// See `function_source_span()` for a description of the two returned spans.\n-/// If the MIR `Statement` is not contributive to computing coverage spans,\n-/// returns `None`.\n-pub(super) fn filtered_statement_span(\n-    statement: &'a Statement<'tcx>,\n-    body_span: Span,\n-) -> Option<(Span, Span)> {\n+/// If the MIR `Statement` has a span contributive to computing coverage spans,\n+/// return it; otherwise return `None`.\n+pub(super) fn filtered_statement_span(statement: &'a Statement<'tcx>) -> Option<Span> {\n     match statement.kind {\n         // These statements have spans that are often outside the scope of the executed source code\n         // for their parent `BasicBlock`.\n@@ -838,18 +842,14 @@ pub(super) fn filtered_statement_span(\n         | StatementKind::LlvmInlineAsm(_)\n         | StatementKind::Retag(_, _)\n         | StatementKind::AscribeUserType(_, _) => {\n-            Some(function_source_span(statement.source_info.span, body_span))\n+            Some(statement.source_info.span)\n         }\n     }\n }\n \n-/// See `function_source_span()` for a description of the two returned spans.\n-/// If the MIR `Terminator` is not contributive to computing coverage spans,\n-/// returns `None`.\n-pub(super) fn filtered_terminator_span(\n-    terminator: &'a Terminator<'tcx>,\n-    body_span: Span,\n-) -> Option<(Span, Span)> {\n+/// If the MIR `Terminator` has a span contributive to computing coverage spans,\n+/// return it; otherwise return `None`.\n+pub(super) fn filtered_terminator_span(terminator: &'a Terminator<'tcx>) -> Option<Span> {\n     match terminator.kind {\n         // These terminators have spans that don't positively contribute to computing a reasonable\n         // span of actually executed source code. (For example, SwitchInt terminators extracted from\n@@ -873,7 +873,7 @@ pub(super) fn filtered_terminator_span(\n                     span = span.with_lo(constant.span.lo());\n                 }\n             }\n-            Some(function_source_span(span, body_span))\n+            Some(span)\n         }\n \n         // Retain spans from all other terminators\n@@ -884,28 +884,20 @@ pub(super) fn filtered_terminator_span(\n         | TerminatorKind::GeneratorDrop\n         | TerminatorKind::FalseUnwind { .. }\n         | TerminatorKind::InlineAsm { .. } => {\n-            Some(function_source_span(terminator.source_info.span, body_span))\n+            Some(terminator.source_info.span)\n         }\n     }\n }\n \n-/// Returns two spans from the given span (the span associated with a\n-/// `Statement` or `Terminator`):\n-///\n-///   1. An extrapolated span (pre-expansion[^1]) corresponding to a range within\n-///      the function's body source. This span is guaranteed to be contained\n-///      within, or equal to, the `body_span`. If the extrapolated span is not\n-///      contained within the `body_span`, the `body_span` is returned.\n-///   2. The actual `span` value from the `Statement`, before expansion.\n-///\n-/// Only the first span is used when computing coverage code regions. The second\n-/// span is useful if additional expansion data is needed (such as to look up\n-/// the macro name for a composed span within that macro).)\n+/// Returns an extrapolated span (pre-expansion[^1]) corresponding to a range\n+/// within the function's body source. This span is guaranteed to be contained\n+/// within, or equal to, the `body_span`. If the extrapolated span is not\n+/// contained within the `body_span`, the `body_span` is returned.\n ///\n-/// [^1]Expansions result from Rust syntax including macros, syntactic\n-/// sugar, etc.).\n+/// [^1]Expansions result from Rust syntax including macros, syntactic sugar,\n+/// etc.).\n #[inline]\n-fn function_source_span(span: Span, body_span: Span) -> (Span, Span) {\n+pub(super) fn function_source_span(span: Span, body_span: Span) -> Span {\n     let original_span = original_sp(span, body_span).with_ctxt(body_span.ctxt());\n-    (if body_span.contains(original_span) { original_span } else { body_span }, span)\n+    if body_span.contains(original_span) { original_span } else { body_span }\n }"}, {"sha": "b04c2d542d459fda4a9b5aa30f1e0208b65bede1", "filename": "compiler/rustc_mir/src/transform/coverage/tests.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e611e64e3ae917a858f7e727d1f944d6d80a6518/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e611e64e3ae917a858f7e727d1f944d6d80a6518/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs?ref=e611e64e3ae917a858f7e727d1f944d6d80a6518", "patch": "@@ -683,12 +683,10 @@ fn test_make_bcb_counters() {\n         let mut basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n         let mut coverage_spans = Vec::new();\n         for (bcb, data) in basic_coverage_blocks.iter_enumerated() {\n-            if let Some((span, expn_span)) =\n-                spans::filtered_terminator_span(data.terminator(&mir_body), body_span)\n-            {\n+            if let Some(span) = spans::filtered_terminator_span(data.terminator(&mir_body)) {\n                 coverage_spans.push(spans::CoverageSpan::for_terminator(\n+                    spans::function_source_span(span, body_span),\n                     span,\n-                    expn_span,\n                     bcb,\n                     data.last_bb(),\n                 ));"}, {"sha": "42683dac426e3b1fdd5271658149c50ca42bd014", "filename": "compiler/rustc_mir/src/util/spanview.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e611e64e3ae917a858f7e727d1f944d6d80a6518/compiler%2Frustc_mir%2Fsrc%2Futil%2Fspanview.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e611e64e3ae917a858f7e727d1f944d6d80a6518/compiler%2Frustc_mir%2Fsrc%2Futil%2Fspanview.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fspanview.rs?ref=e611e64e3ae917a858f7e727d1f944d6d80a6518", "patch": "@@ -131,32 +131,32 @@ where\n             }\n         }\n     }\n-    write_document(tcx, def_id, span_viewables, title, w)?;\n+    write_document(tcx, fn_span(tcx, def_id), span_viewables, title, w)?;\n     Ok(())\n }\n \n /// Generate a spanview HTML+CSS document for the given local function `def_id`, and a pre-generated\n /// list `SpanViewable`s.\n pub fn write_document<'tcx, W>(\n     tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n+    spanview_span: Span,\n     mut span_viewables: Vec<SpanViewable>,\n     title: &str,\n     w: &mut W,\n ) -> io::Result<()>\n where\n     W: Write,\n {\n-    let fn_span = fn_span(tcx, def_id);\n-    let mut from_pos = fn_span.lo();\n-    let end_pos = fn_span.hi();\n+    let mut from_pos = spanview_span.lo();\n+    let end_pos = spanview_span.hi();\n     let source_map = tcx.sess.source_map();\n     let start = source_map.lookup_char_pos(from_pos);\n     let indent_to_initial_start_col = \" \".repeat(start.col.to_usize());\n     debug!(\n-        \"fn_span source is:\\n{}{}\",\n+        \"spanview_span={:?}; source is:\\n{}{}\",\n+        spanview_span,\n         indent_to_initial_start_col,\n-        source_map.span_to_snippet(fn_span).expect(\"function should have printable source\")\n+        source_map.span_to_snippet(spanview_span).expect(\"function should have printable source\")\n     );\n     writeln!(w, \"{}\", HEADER)?;\n     writeln!(w, \"<title>{}</title>\", title)?;"}]}