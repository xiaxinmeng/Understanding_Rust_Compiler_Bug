{"sha": "172df2e3a224f58eb0fe162436fa1aa8d87e224b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3MmRmMmUzYTIyNGY1OGViMGZlMTYyNDM2ZmExYWE4ZDg3ZTIyNGI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-09-16T17:49:05Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-09-16T17:58:02Z"}, "message": "Add non_ty_var precondition for type_of_fn, plus minor cleanup", "tree": {"sha": "013980629060e01d27d6919f684932f25da2cc92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/013980629060e01d27d6919f684932f25da2cc92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/172df2e3a224f58eb0fe162436fa1aa8d87e224b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/172df2e3a224f58eb0fe162436fa1aa8d87e224b", "html_url": "https://github.com/rust-lang/rust/commit/172df2e3a224f58eb0fe162436fa1aa8d87e224b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/172df2e3a224f58eb0fe162436fa1aa8d87e224b/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "469853d5ffef308f49f64110a8c057ecb842cb2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/469853d5ffef308f49f64110a8c057ecb842cb2e", "html_url": "https://github.com/rust-lang/rust/commit/469853d5ffef308f49f64110a8c057ecb842cb2e"}], "stats": {"total": 27, "additions": 17, "deletions": 10}, "files": [{"sha": "a369d109875e7613fc5c7dc7c43e8bb31f32a864", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/172df2e3a224f58eb0fe162436fa1aa8d87e224b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/172df2e3a224f58eb0fe162436fa1aa8d87e224b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=172df2e3a224f58eb0fe162436fa1aa8d87e224b", "patch": "@@ -74,11 +74,11 @@ fn type_of_explicit_args(cx: @crate_ctxt, sp: span, inputs: [ty::arg]) ->\n //  - trans_args\n fn type_of_fn(cx: @crate_ctxt, sp: span, proto: ast::proto,\n               is_method: bool, ret_ref: bool, inputs: [ty::arg],\n-              output: ty::t, ty_param_count: uint) -> TypeRef {\n+              output: ty::t, ty_param_count: uint)\n+   : non_ty_var(cx, output) -> TypeRef {\n     let atys: [TypeRef] = [];\n \n     // Arg 0: Output pointer.\n-    check non_ty_var(cx, output);\n     let out_ty = T_ptr(type_of_inner(cx, sp, output));\n     atys += [ret_ref ? T_ptr(out_ty) : out_ty];\n \n@@ -2073,6 +2073,7 @@ fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n         // If we're here, it must be a temporary.\n         ret revoke_clean(cx, src_val, t);\n     }\n+    /* FIXME: suggests a type constraint */\n     bcx_ccx(cx).sess.bug(\"unexpected type in trans::move_val: \" +\n                              ty_to_str(tcx, t));\n }\n@@ -2999,12 +3000,18 @@ fn trans_field(cx: @block_ctxt, sp: span, v: ValueRef, t0: ty::t,\n \n         let v = GEP(r.bcx, vtbl, [C_int(0), C_int(ix as int)]);\n         let tcx = bcx_tcx(cx);\n+        let ccx = bcx_ccx(cx);\n+\n         let fn_ty: ty::t = ty::method_ty_to_fn_ty(tcx, methods[ix]);\n+        let ret_ty = ty::ty_fn_ret(tcx, fn_ty);\n         let ret_ref = ast_util::ret_by_ref(ty::ty_fn_ret_style(tcx, fn_ty));\n+        // FIXME: constrain ty_obj?\n+        check non_ty_var(ccx, ret_ty);\n+\n         let ll_fn_ty =\n-            type_of_fn(bcx_ccx(cx), sp, ty::ty_fn_proto(tcx, fn_ty),\n+            type_of_fn(ccx, sp, ty::ty_fn_proto(tcx, fn_ty),\n                        true, ret_ref, ty::ty_fn_args(tcx, fn_ty),\n-                       ty::ty_fn_ret(tcx, fn_ty), 0u);\n+                       ret_ty, 0u);\n         v = PointerCast(r.bcx, v, T_ptr(T_ptr(ll_fn_ty)));\n         let lvo = lval_mem(r.bcx, v);\n         ret {llobj: some::<ValueRef>(r.val) with lvo};\n@@ -4581,7 +4588,7 @@ fn trans_stmt(cx: @block_ctxt, s: ast::stmt) -> result {\n       }\n       _ { bcx_ccx(cx).sess.unimpl(\"stmt variant\"); }\n     }\n-    ret rslt(bcx, C_nil());\n+    rslt(bcx, C_nil())\n }\n \n // You probably don't want to use this one. See the\n@@ -5438,7 +5445,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n         let vecarg_ty: ty::arg =\n             {mode: ast::by_ref,\n              ty: ty::mk_vec(ccx.tcx, {ty: unit_ty, mut: ast::imm})};\n-        // FIXME: mk_nil should have a post condition\n+        // FIXME: mk_nil should have a postcondition\n         let nt = ty::mk_nil(ccx.tcx);\n         check non_ty_var(ccx, nt);\n "}, {"sha": "1b36cbdee742596a633c92b1ca8b5d4df59dfbb7", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/172df2e3a224f58eb0fe162436fa1aa8d87e224b/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/172df2e3a224f58eb0fe162436fa1aa8d87e224b/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=172df2e3a224f58eb0fe162436fa1aa8d87e224b", "patch": "@@ -885,9 +885,9 @@ fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,\n                        ty_params: [ast::ty_param]) -> ValueRef {\n \n     let llfnty = T_nil();\n+    let ccx = cx.ccx;\n     alt ty::struct(cx.ccx.tcx, node_id_type(cx.ccx, m.node.id)) {\n       ty::ty_fn(proto, inputs, output, rs, _) {\n-        let ccx = cx.ccx;\n         check non_ty_var(ccx, output);\n         llfnty = type_of_fn(ccx, m.span, proto, true,\n                             ast_util::ret_by_ref(rs), inputs, output,\n@@ -897,13 +897,13 @@ fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,\n     let mcx: @local_ctxt =\n         @{path: cx.path + [\"method\", m.node.ident] with *cx};\n     let s: str = mangle_internal_name_by_path(mcx.ccx, mcx.path);\n-    let llfn: ValueRef = decl_internal_fastcall_fn(cx.ccx.llmod, s, llfnty);\n+    let llfn: ValueRef = decl_internal_fastcall_fn(ccx.llmod, s, llfnty);\n \n     // Every method on an object gets its node_id inserted into the crate-wide\n     // item_ids map, together with the ValueRef that points to where that\n     // method's definition will be in the executable.\n-    cx.ccx.item_ids.insert(m.node.id, llfn);\n-    cx.ccx.item_symbols.insert(m.node.id, s);\n+    ccx.item_ids.insert(m.node.id, llfn);\n+    ccx.item_symbols.insert(m.node.id, s);\n     trans_fn(mcx, m.span, m.node.meth, llfn, some(self_ty), ty_params,\n              m.node.id);\n "}]}