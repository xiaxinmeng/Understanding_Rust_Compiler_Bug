{"sha": "bb85981a3ac31c32d2f5924eb812c0a71baabf38", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiODU5ODFhM2FjMzFjMzJkMmY1OTI0ZWI4MTJjMGE3MWJhYWJmMzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-25T23:37:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-25T23:37:07Z"}, "message": "Auto merge of #74670 - tmandry:issue-73818, r=matthewjasper\n\nNormalize bounds fully when checking defaulted types\n\nWhen checking that the default type for `<T as X>::Y` is valid in this example:\n\n```\ntrait X { type Y: PartialEq<<Self as X>::Y> }\nimpl X for T { default type Y = S; }\n```\n\nWe will have to prove the bound `S: PartialEq<<T as X>::Y>`. In this case\nwe want `<T as X>::Y` to normalize to `S`. This is valid because we are\nchecking the default value specifically here. Add `<T as X>::Y = S` to the\nParamEnv for normalization _of the bound we are checking_ only.\n\nFixes #73818.\n\n---\n\nI noticed that adding this to the env for bounds checking didn't break any tests. Not sure if this is because we can't rely on it to prove anything, or because of missing test coverage.\n\nr? @matthewjasper, @nikomatsakis", "tree": {"sha": "3d4e1f293f43cfea473ae9b52e7b41dba9932963", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d4e1f293f43cfea473ae9b52e7b41dba9932963"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb85981a3ac31c32d2f5924eb812c0a71baabf38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb85981a3ac31c32d2f5924eb812c0a71baabf38", "html_url": "https://github.com/rust-lang/rust/commit/bb85981a3ac31c32d2f5924eb812c0a71baabf38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb85981a3ac31c32d2f5924eb812c0a71baabf38/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6953df14657f5932270ad2b33bccafe6f39fad4", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6953df14657f5932270ad2b33bccafe6f39fad4", "html_url": "https://github.com/rust-lang/rust/commit/d6953df14657f5932270ad2b33bccafe6f39fad4"}, {"sha": "e35d2867f14a36094bdceadc731fdd1d26882fc9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e35d2867f14a36094bdceadc731fdd1d26882fc9", "html_url": "https://github.com/rust-lang/rust/commit/e35d2867f14a36094bdceadc731fdd1d26882fc9"}], "stats": {"total": 100, "additions": 52, "deletions": 48}, "files": [{"sha": "b739e2fe1fbc4ffecb0aed169e2a8064bf34526d", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 27, "deletions": 48, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/bb85981a3ac31c32d2f5924eb812c0a71baabf38/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb85981a3ac31c32d2f5924eb812c0a71baabf38/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=bb85981a3ac31c32d2f5924eb812c0a71baabf38", "patch": "@@ -6,15 +6,14 @@ use rustc_hir::{GenericParamKind, ImplItemKind, TraitItemKind};\n use rustc_infer::infer::{self, InferOk, TyCtxtInferExt};\n use rustc_middle::ty;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n-use rustc_middle::ty::subst::{InternalSubsts, Subst, SubstsRef};\n+use rustc_middle::ty::subst::{InternalSubsts, Subst};\n use rustc_middle::ty::util::ExplicitSelf;\n-use rustc_middle::ty::{GenericParamDefKind, ToPredicate, TyCtxt, WithConstness};\n+use rustc_middle::ty::{GenericParamDefKind, ToPredicate, TyCtxt};\n use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n \n use super::{potentially_plural_count, FnCtxt, Inherited};\n-use std::iter;\n \n /// Checks that a method from an impl conforms to the signature of\n /// the same method as declared in the trait.\n@@ -1196,8 +1195,6 @@ fn compare_projection_bounds<'tcx>(\n         return Ok(());\n     }\n \n-    let param_env = tcx.param_env(impl_ty.def_id);\n-\n     // Given\n     //\n     // impl<A, B> Foo<u32> for (A, B) {\n@@ -1212,20 +1209,30 @@ fn compare_projection_bounds<'tcx>(\n         impl_ty_substs.rebase_onto(tcx, impl_ty.container.id(), impl_trait_ref.substs);\n     let impl_ty_value = tcx.type_of(impl_ty.def_id);\n \n-    // Map the predicate from the trait to the corresponding one for the impl.\n-    // For example:\n+    let param_env = tcx.param_env(impl_ty.def_id);\n+\n+    // When checking something like\n     //\n-    // trait X<A> { type Y<'a>: PartialEq<A> } impl X for T { type Y<'a> = &'a S; }\n-    // impl<'x> X<&'x u32> for () { type Y<'c> = &'c u32; }\n+    // trait X { type Y: PartialEq<<Self as X>::Y> }\n+    // impl X for T { default type Y = S; }\n     //\n-    // For the `for<'a> <<Self as X<A>>::Y<'a>: PartialEq<A>` bound, this\n-    // function would translate and partially normalize\n-    // `[<Self as X<A>>::Y<'a>, A]` to `[&'a u32, &'x u32]`.\n-    let translate_predicate_substs = move |predicate_substs: SubstsRef<'tcx>| {\n-        tcx.mk_substs(\n-            iter::once(impl_ty_value.into())\n-                .chain(predicate_substs[1..].iter().map(|s| s.subst(tcx, rebased_substs))),\n-        )\n+    // We will have to prove the bound S: PartialEq<<T as X>::Y>. In this case\n+    // we want <T as X>::Y to normalize to S. This is valid because we are\n+    // checking the default value specifically here. Add this equality to the\n+    // ParamEnv for normalization specifically.\n+    let normalize_param_env = {\n+        let mut predicates = param_env.caller_bounds().iter().collect::<Vec<_>>();\n+        predicates.push(\n+            ty::Binder::dummy(ty::ProjectionPredicate {\n+                projection_ty: ty::ProjectionTy {\n+                    item_def_id: trait_ty.def_id,\n+                    substs: rebased_substs,\n+                },\n+                ty: impl_ty_value,\n+            })\n+            .to_predicate(tcx),\n+        );\n+        ty::ParamEnv::new(tcx.intern_predicates(&predicates), Reveal::UserFacing, None)\n     };\n \n     tcx.infer_ctxt().enter(move |infcx| {\n@@ -1242,46 +1249,18 @@ fn compare_projection_bounds<'tcx>(\n         );\n \n         let predicates = tcx.projection_predicates(trait_ty.def_id);\n-\n         debug!(\"compare_projection_bounds: projection_predicates={:?}\", predicates);\n \n         for predicate in predicates {\n-            let concrete_ty_predicate = match predicate.kind() {\n-                ty::PredicateKind::Trait(poly_tr, c) => poly_tr\n-                    .map_bound(|tr| {\n-                        let trait_substs = translate_predicate_substs(tr.trait_ref.substs);\n-                        ty::TraitRef { def_id: tr.def_id(), substs: trait_substs }\n-                    })\n-                    .with_constness(*c)\n-                    .to_predicate(tcx),\n-                ty::PredicateKind::Projection(poly_projection) => poly_projection\n-                    .map_bound(|projection| {\n-                        let projection_substs =\n-                            translate_predicate_substs(projection.projection_ty.substs);\n-                        ty::ProjectionPredicate {\n-                            projection_ty: ty::ProjectionTy {\n-                                substs: projection_substs,\n-                                item_def_id: projection.projection_ty.item_def_id,\n-                            },\n-                            ty: projection.ty.subst(tcx, rebased_substs),\n-                        }\n-                    })\n-                    .to_predicate(tcx),\n-                ty::PredicateKind::TypeOutlives(poly_outlives) => poly_outlives\n-                    .map_bound(|outlives| {\n-                        ty::OutlivesPredicate(impl_ty_value, outlives.1.subst(tcx, rebased_substs))\n-                    })\n-                    .to_predicate(tcx),\n-                _ => bug!(\"unexepected projection predicate kind: `{:?}`\", predicate),\n-            };\n+            let concrete_ty_predicate = predicate.subst(tcx, rebased_substs);\n+            debug!(\"compare_projection_bounds: concrete predicate = {:?}\", concrete_ty_predicate);\n \n             let traits::Normalized { value: normalized_predicate, obligations } = traits::normalize(\n                 &mut selcx,\n-                param_env,\n+                normalize_param_env,\n                 normalize_cause.clone(),\n                 &concrete_ty_predicate,\n             );\n-\n             debug!(\"compare_projection_bounds: normalized predicate = {:?}\", normalized_predicate);\n \n             inh.register_predicates(obligations);"}, {"sha": "bb890f72a32cfd3b943fd06140673798813e4951", "filename": "src/test/ui/associated-type-bounds/issue-73818.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bb85981a3ac31c32d2f5924eb812c0a71baabf38/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fissue-73818.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb85981a3ac31c32d2f5924eb812c0a71baabf38/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fissue-73818.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fissue-73818.rs?ref=bb85981a3ac31c32d2f5924eb812c0a71baabf38", "patch": "@@ -0,0 +1,25 @@\n+// Test that associated type bounds are correctly normalized when checking\n+// default associated type values.\n+// check-pass\n+\n+#![allow(incomplete_features)]\n+#![feature(specialization)]\n+\n+#[derive(PartialEq)]\n+enum Never {}\n+trait Foo {\n+    type Assoc: PartialEq; // PartialEq<<Self as Foo>::Assoc>\n+}\n+impl<T> Foo for T {\n+    default type Assoc = Never;\n+}\n+\n+trait Trait1 {\n+    type Selection: PartialEq;\n+}\n+trait Trait2: PartialEq<Self> {}\n+impl<T: Trait2> Trait1 for T {\n+    default type Selection = T;\n+}\n+\n+fn main() {}"}]}