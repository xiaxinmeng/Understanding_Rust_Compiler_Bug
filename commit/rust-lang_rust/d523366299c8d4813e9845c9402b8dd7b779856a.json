{"sha": "d523366299c8d4813e9845c9402b8dd7b779856a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1MjMzNjYyOTljOGQ0ODEzZTk4NDVjOTQwMmI4ZGQ3Yjc3OTg1NmE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-13T08:59:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-13T08:59:48Z"}, "message": "Merge #2226\n\n2226: Use strongly-typed ast building for early-return assist r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "1e42b170b230271a5a906f0e9c19cbec27429929", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e42b170b230271a5a906f0e9c19cbec27429929"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d523366299c8d4813e9845c9402b8dd7b779856a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdy8YECRBK7hj4Ov3rIwAAdHIIAFQzK8bYt+05vQQswAfvc3PI\neZz4hineybn103S78FW6c8nsQmABhmsSmGub6dnX5owHUJe9/SyeMT2vba53VCP5\n3F3RoshOr1f07ReUQ4B9qfw6Jw3S2AJDCg2mELO4EsWUYtYfC/FvOHyfgHqTYwpi\ngw7qs6eTU8GPTJok8lBl2VJW3+5C3xs4Z+QblrE6/aV19i/qNnHBCmaa6D/3hf/3\nXOOsWrpkbx2+MpWwzNjmZHKT8baiAsJOg6k1eSfTaZ6eUdWAi0CBVs38UGf5lE1l\nZS+AhLYmz3YH235grwPVUUjXNxdCgTtALbo2yj3c0+j04JND1OXoQKXak33Fq2A=\n=I5vk\n-----END PGP SIGNATURE-----\n", "payload": "tree 1e42b170b230271a5a906f0e9c19cbec27429929\nparent 6ca0d79cff8746ea4f0c8fb8645d14b8b81bc7fc\nparent 4cea6bb6f11e28a2d1d2e023d46caa82b0f38796\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1573635588 +0000\ncommitter GitHub <noreply@github.com> 1573635588 +0000\n\nMerge #2226\n\n2226: Use strongly-typed ast building for early-return assist r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d523366299c8d4813e9845c9402b8dd7b779856a", "html_url": "https://github.com/rust-lang/rust/commit/d523366299c8d4813e9845c9402b8dd7b779856a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d523366299c8d4813e9845c9402b8dd7b779856a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ca0d79cff8746ea4f0c8fb8645d14b8b81bc7fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ca0d79cff8746ea4f0c8fb8645d14b8b81bc7fc", "html_url": "https://github.com/rust-lang/rust/commit/6ca0d79cff8746ea4f0c8fb8645d14b8b81bc7fc"}, {"sha": "4cea6bb6f11e28a2d1d2e023d46caa82b0f38796", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cea6bb6f11e28a2d1d2e023d46caa82b0f38796", "html_url": "https://github.com/rust-lang/rust/commit/4cea6bb6f11e28a2d1d2e023d46caa82b0f38796"}], "stats": {"total": 203, "additions": 132, "deletions": 71}, "files": [{"sha": "26441252662b97c015386bf040f7ebbf4d102918", "filename": "crates/ra_assists/src/assists/early_return.rs", "status": "modified", "additions": 88, "deletions": 40, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/d523366299c8d4813e9845c9402b8dd7b779856a/crates%2Fra_assists%2Fsrc%2Fassists%2Fearly_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d523366299c8d4813e9845c9402b8dd7b779856a/crates%2Fra_assists%2Fsrc%2Fassists%2Fearly_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fearly_return.rs?ref=d523366299c8d4813e9845c9402b8dd7b779856a", "patch": "@@ -1,4 +1,4 @@\n-use std::ops::RangeInclusive;\n+use std::{iter::once, ops::RangeInclusive};\n \n use hir::db::HirDatabase;\n use ra_syntax::{\n@@ -38,27 +38,30 @@ use crate::{\n // ```\n pub(crate) fn convert_to_guarded_return(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let if_expr: ast::IfExpr = ctx.find_node_at_offset()?;\n+    if if_expr.else_branch().is_some() {\n+        return None;\n+    }\n+\n     let cond = if_expr.condition()?;\n-    let mut if_let_ident: Option<String> = None;\n \n     // Check if there is an IfLet that we can handle.\n-    match cond.pat() {\n-        None => {} // No IfLet, supported.\n-        Some(TupleStructPat(ref pat)) if pat.args().count() == 1usize => match &pat.path() {\n-            Some(p) => match p.qualifier() {\n-                None => if_let_ident = Some(p.syntax().text().to_string()),\n-                _ => return None,\n-            },\n-            _ => return None,\n-        },\n-        _ => return None, // Unsupported IfLet.\n+    let if_let_pat = match cond.pat() {\n+        None => None, // No IfLet, supported.\n+        Some(TupleStructPat(pat)) if pat.args().count() == 1 => {\n+            let path = pat.path()?;\n+            match path.qualifier() {\n+                None => {\n+                    let bound_ident = pat.args().next().unwrap();\n+                    Some((path, bound_ident))\n+                }\n+                Some(_) => return None,\n+            }\n+        }\n+        Some(_) => return None, // Unsupported IfLet.\n     };\n \n-    let expr = cond.expr()?;\n+    let cond_expr = cond.expr()?;\n     let then_block = if_expr.then_branch()?.block()?;\n-    if if_expr.else_branch().is_some() {\n-        return None;\n-    }\n \n     let parent_block = if_expr.syntax().parent()?.ancestors().find_map(ast::Block::cast)?;\n \n@@ -79,11 +82,11 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx<impl HirDatabase>) -> Opt\n \n     let parent_container = parent_block.syntax().parent()?.parent()?;\n \n-    let early_expression = match parent_container.kind() {\n-        WHILE_EXPR | LOOP_EXPR => Some(\"continue\"),\n-        FN_DEF => Some(\"return\"),\n-        _ => None,\n-    }?;\n+    let early_expression: ast::Expr = match parent_container.kind() {\n+        WHILE_EXPR | LOOP_EXPR => make::expr_continue().into(),\n+        FN_DEF => make::expr_return().into(),\n+        _ => return None,\n+    };\n \n     if then_block.syntax().first_child_or_token().map(|t| t.kind() == L_CURLY).is_none() {\n         return None;\n@@ -94,30 +97,51 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx<impl HirDatabase>) -> Opt\n \n     ctx.add_assist(AssistId(\"convert_to_guarded_return\"), \"convert to guarded return\", |edit| {\n         let if_indent_level = IndentLevel::from_node(&if_expr.syntax());\n-        let new_block = match if_let_ident {\n+        let new_block = match if_let_pat {\n             None => {\n                 // If.\n-                let early_expression = &(early_expression.to_owned() + \";\");\n-                let new_expr =\n-                    if_indent_level.increase_indent(make::if_expression(&expr, early_expression));\n-                replace(new_expr, &then_block, &parent_block, &if_expr)\n+                let early_expression = &(early_expression.syntax().to_string() + \";\");\n+                let new_expr = if_indent_level\n+                    .increase_indent(make::if_expression(&cond_expr, early_expression));\n+                replace(new_expr.syntax(), &then_block, &parent_block, &if_expr)\n             }\n-            Some(if_let_ident) => {\n+            Some((path, bound_ident)) => {\n                 // If-let.\n-                let new_expr = if_indent_level.increase_indent(make::let_match_early(\n-                    expr,\n-                    &if_let_ident,\n-                    early_expression,\n-                ));\n-                replace(new_expr, &then_block, &parent_block, &if_expr)\n+                let match_expr = {\n+                    let happy_arm = make::match_arm(\n+                        once(\n+                            make::tuple_struct_pat(\n+                                path,\n+                                once(make::bind_pat(make::name(\"it\")).into()),\n+                            )\n+                            .into(),\n+                        ),\n+                        make::expr_path(make::path_from_name_ref(make::name_ref(\"it\"))).into(),\n+                    );\n+\n+                    let sad_arm = make::match_arm(\n+                        // FIXME: would be cool to use `None` or `Err(_)` if appropriate\n+                        once(make::placeholder_pat().into()),\n+                        early_expression.into(),\n+                    );\n+\n+                    make::expr_match(cond_expr, make::match_arm_list(vec![happy_arm, sad_arm]))\n+                };\n+\n+                let let_stmt = make::let_stmt(\n+                    make::bind_pat(make::name(&bound_ident.syntax().to_string())).into(),\n+                    Some(match_expr.into()),\n+                );\n+                let let_stmt = if_indent_level.increase_indent(let_stmt);\n+                replace(let_stmt.syntax(), &then_block, &parent_block, &if_expr)\n             }\n         };\n         edit.target(if_expr.syntax().text_range());\n         edit.replace_ast(parent_block, ast::Block::cast(new_block).unwrap());\n         edit.set_cursor(cursor_position);\n \n         fn replace(\n-            new_expr: impl AstNode,\n+            new_expr: &SyntaxNode,\n             then_block: &Block,\n             parent_block: &Block,\n             if_expr: &ast::IfExpr,\n@@ -130,7 +154,7 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx<impl HirDatabase>) -> Opt\n                 } else {\n                     end_of_then\n                 };\n-            let mut then_statements = new_expr.syntax().children_with_tokens().chain(\n+            let mut then_statements = new_expr.children_with_tokens().chain(\n                 then_block_items\n                     .syntax()\n                     .children_with_tokens()\n@@ -151,9 +175,10 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx<impl HirDatabase>) -> Opt\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n     use crate::helpers::{check_assist, check_assist_not_applicable};\n \n+    use super::*;\n+\n     #[test]\n     fn convert_inside_fn() {\n         check_assist(\n@@ -204,7 +229,7 @@ mod tests {\n                 bar();\n                 le<|>t n = match n {\n                     Some(it) => it,\n-                    None => return,\n+                    _ => return,\n                 };\n                 foo(n);\n \n@@ -215,6 +240,29 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn convert_if_let_result() {\n+        check_assist(\n+            convert_to_guarded_return,\n+            r#\"\n+            fn main() {\n+                if<|> let Ok(x) = Err(92) {\n+                    foo(x);\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main() {\n+                le<|>t x = match Err(92) {\n+                    Ok(it) => it,\n+                    _ => return,\n+                };\n+                foo(x);\n+            }\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn convert_let_ok_inside_fn() {\n         check_assist(\n@@ -235,7 +283,7 @@ mod tests {\n                 bar();\n                 le<|>t n = match n {\n                     Ok(it) => it,\n-                    None => return,\n+                    _ => return,\n                 };\n                 foo(n);\n \n@@ -293,7 +341,7 @@ mod tests {\n                 while true {\n                     le<|>t n = match n {\n                         Some(it) => it,\n-                        None => continue,\n+                        _ => continue,\n                     };\n                     foo(n);\n                     bar();\n@@ -350,7 +398,7 @@ mod tests {\n                 loop {\n                     le<|>t n = match n {\n                         Some(it) => it,\n-                        None => continue,\n+                        _ => continue,\n                     };\n                     foo(n);\n                     bar();"}, {"sha": "6f005a2d88c9b0f9dccc4956ebfec057592d29ca", "filename": "crates/ra_syntax/src/ast/edit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d523366299c8d4813e9845c9402b8dd7b779856a/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d523366299c8d4813e9845c9402b8dd7b779856a/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs?ref=d523366299c8d4813e9845c9402b8dd7b779856a", "patch": "@@ -358,7 +358,7 @@ fn replace_children<N: AstNode>(\n fn test_increase_indent() {\n     let arm_list = {\n         let arm = make::match_arm(iter::once(make::placeholder_pat().into()), make::expr_unit());\n-        make::match_arm_list(vec![arm.clone(), arm].into_iter())\n+        make::match_arm_list(vec![arm.clone(), arm])\n     };\n     assert_eq!(\n         arm_list.syntax().to_string(),"}, {"sha": "9749327fa45a55cdb7ea96d574882d7440ae0fc1", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 42, "deletions": 29, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/d523366299c8d4813e9845c9402b8dd7b779856a/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d523366299c8d4813e9845c9402b8dd7b779856a/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=d523366299c8d4813e9845c9402b8dd7b779856a", "patch": "@@ -4,6 +4,10 @@ use itertools::Itertools;\n \n use crate::{ast, AstNode, SourceFile};\n \n+pub fn name(text: &str) -> ast::Name {\n+    ast_from_text(&format!(\"mod {};\", text))\n+}\n+\n pub fn name_ref(text: &str) -> ast::NameRef {\n     ast_from_text(&format!(\"fn f() {{ {}; }}\", text))\n }\n@@ -43,6 +47,21 @@ pub fn expr_unit() -> ast::Expr {\n pub fn expr_unimplemented() -> ast::Expr {\n     expr_from_text(\"unimplemented!()\")\n }\n+pub fn expr_path(path: ast::Path) -> ast::Expr {\n+    expr_from_text(&path.syntax().to_string())\n+}\n+pub fn expr_continue() -> ast::Expr {\n+    expr_from_text(\"continue\")\n+}\n+pub fn expr_break() -> ast::Expr {\n+    expr_from_text(\"break\")\n+}\n+pub fn expr_return() -> ast::Expr {\n+    expr_from_text(\"return\")\n+}\n+pub fn expr_match(expr: ast::Expr, match_arm_list: ast::MatchArmList) -> ast::Expr {\n+    expr_from_text(&format!(\"match {} {}\", expr.syntax(), match_arm_list.syntax()))\n+}\n fn expr_from_text(text: &str) -> ast::Expr {\n     ast_from_text(&format!(\"const C: () = {};\", text))\n }\n@@ -65,18 +84,18 @@ pub fn placeholder_pat() -> ast::PlaceholderPat {\n \n pub fn tuple_struct_pat(\n     path: ast::Path,\n-    pats: impl Iterator<Item = ast::Pat>,\n+    pats: impl IntoIterator<Item = ast::Pat>,\n ) -> ast::TupleStructPat {\n-    let pats_str = pats.map(|p| p.syntax().to_string()).join(\", \");\n+    let pats_str = pats.into_iter().map(|p| p.syntax().to_string()).join(\", \");\n     return from_text(&format!(\"{}({})\", path.syntax(), pats_str));\n \n     fn from_text(text: &str) -> ast::TupleStructPat {\n         ast_from_text(&format!(\"fn f({}: ())\", text))\n     }\n }\n \n-pub fn record_pat(path: ast::Path, pats: impl Iterator<Item = ast::Pat>) -> ast::RecordPat {\n-    let pats_str = pats.map(|p| p.syntax().to_string()).join(\", \");\n+pub fn record_pat(path: ast::Path, pats: impl IntoIterator<Item = ast::Pat>) -> ast::RecordPat {\n+    let pats_str = pats.into_iter().map(|p| p.syntax().to_string()).join(\", \");\n     return from_text(&format!(\"{} {{ {} }}\", path.syntax(), pats_str));\n \n     fn from_text(text: &str) -> ast::RecordPat {\n@@ -92,52 +111,38 @@ pub fn path_pat(path: ast::Path) -> ast::PathPat {\n     }\n }\n \n-pub fn match_arm(pats: impl Iterator<Item = ast::Pat>, expr: ast::Expr) -> ast::MatchArm {\n-    let pats_str = pats.map(|p| p.syntax().to_string()).join(\" | \");\n+pub fn match_arm(pats: impl IntoIterator<Item = ast::Pat>, expr: ast::Expr) -> ast::MatchArm {\n+    let pats_str = pats.into_iter().map(|p| p.syntax().to_string()).join(\" | \");\n     return from_text(&format!(\"{} => {}\", pats_str, expr.syntax()));\n \n     fn from_text(text: &str) -> ast::MatchArm {\n         ast_from_text(&format!(\"fn f() {{ match () {{{}}} }}\", text))\n     }\n }\n \n-pub fn match_arm_list(arms: impl Iterator<Item = ast::MatchArm>) -> ast::MatchArmList {\n-    let arms_str = arms.map(|arm| format!(\"\\n    {}\", arm.syntax())).join(\",\");\n+pub fn match_arm_list(arms: impl IntoIterator<Item = ast::MatchArm>) -> ast::MatchArmList {\n+    let arms_str = arms.into_iter().map(|arm| format!(\"\\n    {}\", arm.syntax())).join(\",\");\n     return from_text(&format!(\"{},\\n\", arms_str));\n \n     fn from_text(text: &str) -> ast::MatchArmList {\n         ast_from_text(&format!(\"fn f() {{ match () {{{}}} }}\", text))\n     }\n }\n \n-pub fn let_match_early(expr: ast::Expr, path: &str, early_expression: &str) -> ast::LetStmt {\n-    return from_text(&format!(\n-        r#\"let {} = match {} {{\n-    {}(it) => it,\n-    None => {},\n-}};\"#,\n-        expr.syntax().text(),\n-        expr.syntax().text(),\n-        path,\n-        early_expression\n-    ));\n-\n-    fn from_text(text: &str) -> ast::LetStmt {\n-        ast_from_text(&format!(\"fn f() {{ {} }}\", text))\n-    }\n-}\n-\n-pub fn where_pred(path: ast::Path, bounds: impl Iterator<Item = ast::TypeBound>) -> ast::WherePred {\n-    let bounds = bounds.map(|b| b.syntax().to_string()).join(\" + \");\n+pub fn where_pred(\n+    path: ast::Path,\n+    bounds: impl IntoIterator<Item = ast::TypeBound>,\n+) -> ast::WherePred {\n+    let bounds = bounds.into_iter().map(|b| b.syntax().to_string()).join(\" + \");\n     return from_text(&format!(\"{}: {}\", path.syntax(), bounds));\n \n     fn from_text(text: &str) -> ast::WherePred {\n         ast_from_text(&format!(\"fn f() where {} {{ }}\", text))\n     }\n }\n \n-pub fn where_clause(preds: impl Iterator<Item = ast::WherePred>) -> ast::WhereClause {\n-    let preds = preds.map(|p| p.syntax().to_string()).join(\", \");\n+pub fn where_clause(preds: impl IntoIterator<Item = ast::WherePred>) -> ast::WhereClause {\n+    let preds = preds.into_iter().map(|p| p.syntax().to_string()).join(\", \");\n     return from_text(preds.as_str());\n \n     fn from_text(text: &str) -> ast::WhereClause {\n@@ -153,6 +158,14 @@ pub fn if_expression(condition: &ast::Expr, statement: &str) -> ast::IfExpr {\n     ))\n }\n \n+pub fn let_stmt(pattern: ast::Pat, initializer: Option<ast::Expr>) -> ast::LetStmt {\n+    let text = match initializer {\n+        Some(it) => format!(\"let {} = {};\", pattern.syntax(), it.syntax()),\n+        None => format!(\"let {};\", pattern.syntax()),\n+    };\n+    ast_from_text(&format!(\"fn f() {{ {} }}\", text))\n+}\n+\n fn ast_from_text<N: AstNode>(text: &str) -> N {\n     let parse = SourceFile::parse(text);\n     let res = parse.tree().syntax().descendants().find_map(N::cast).unwrap();"}, {"sha": "c46eaa407ab15bc0e6730e068b2904c08fd39351", "filename": "xtask/src/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d523366299c8d4813e9845c9402b8dd7b779856a/xtask%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d523366299c8d4813e9845c9402b8dd7b779856a/xtask%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fmain.rs?ref=d523366299c8d4813e9845c9402b8dd7b779856a", "patch": "@@ -19,7 +19,7 @@ use xtask::{\n };\n \n // Latest stable, feel free to send a PR if this lags behind.\n-const REQUIRED_RUST_VERSION: u32 = 38;\n+const REQUIRED_RUST_VERSION: u32 = 39;\n \n struct InstallOpt {\n     client: Option<ClientOpt>,"}]}