{"sha": "bf2ba159723dfe88cfdf301efde4efb7881d98f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmMmJhMTU5NzIzZGZlODhjZmRmMzAxZWZkZTRlZmI3ODgxZDk4Zjk=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-05-01T15:06:59Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-06-30T16:59:58Z"}, "message": "When casting enum to integer sign extend the discriminant if necessary", "tree": {"sha": "da9bc7ad8e59e783f74fd27fedbf236586d24608", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da9bc7ad8e59e783f74fd27fedbf236586d24608"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf2ba159723dfe88cfdf301efde4efb7881d98f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf2ba159723dfe88cfdf301efde4efb7881d98f9", "html_url": "https://github.com/rust-lang/rust/commit/bf2ba159723dfe88cfdf301efde4efb7881d98f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf2ba159723dfe88cfdf301efde4efb7881d98f9/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc0268fa1ad6aab1b4b7d34a86ad3f9962675d78", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc0268fa1ad6aab1b4b7d34a86ad3f9962675d78", "html_url": "https://github.com/rust-lang/rust/commit/cc0268fa1ad6aab1b4b7d34a86ad3f9962675d78"}], "stats": {"total": 43, "additions": 37, "deletions": 6}, "files": [{"sha": "85c0c21c33daaea51d61786ecf077af3209e4c31", "filename": "src/base.rs", "status": "modified", "additions": 37, "deletions": 6, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/bf2ba159723dfe88cfdf301efde4efb7881d98f9/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf2ba159723dfe88cfdf301efde4efb7881d98f9/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=bf2ba159723dfe88cfdf301efde4efb7881d98f9", "patch": "@@ -515,12 +515,43 @@ fn trans_stmt<'tcx>(\n                             _ => unreachable!(\"cast adt {} -> {}\", from_ty, to_ty),\n                         }\n \n-                        let discr = crate::discriminant::codegen_get_discriminant(\n-                            fx,\n-                            operand,\n-                            fx.layout_of(to_ty),\n-                        );\n-                        lval.write_cvalue(fx, discr);\n+                        use rustc_target::abi::{TagEncoding, Int, Variants};\n+\n+                        match &operand.layout().variants {\n+                            Variants::Single { index } => {\n+                                let discr = operand.layout().ty.discriminant_for_variant(fx.tcx, *index).unwrap();\n+                                let discr = if discr.ty.is_signed() {\n+                                    rustc_middle::mir::interpret::sign_extend(discr.val, fx.layout_of(discr.ty).size)\n+                                } else {\n+                                    discr.val\n+                                };\n+\n+                                let discr = CValue::const_val(fx, fx.layout_of(to_ty), discr);\n+                                lval.write_cvalue(fx, discr);\n+                            }\n+                            Variants::Multiple {\n+                                tag,\n+                                tag_field,\n+                                tag_encoding: TagEncoding::Direct,\n+                                variants: _,\n+                            } => {\n+                                let cast_to = fx.clif_type(dest_layout.ty).unwrap();\n+\n+                                // Read the tag/niche-encoded discriminant from memory.\n+                                let encoded_discr = operand.value_field(fx, mir::Field::new(*tag_field));\n+                                let encoded_discr = encoded_discr.load_scalar(fx);\n+\n+                                // Decode the discriminant (specifically if it's niche-encoded).\n+                                let signed = match tag.value {\n+                                    Int(_, signed) => signed,\n+                                    _ => false,\n+                                };\n+                                let val = clif_intcast(fx, encoded_discr, cast_to, signed);\n+                                let val = CValue::by_val(val, dest_layout);\n+                                lval.write_cvalue(fx, val);\n+                            }\n+                            Variants::Multiple { ..} => unreachable!(),\n+                        }\n                     } else {\n                         let to_clif_ty = fx.clif_type(to_ty).unwrap();\n                         let from = operand.load_scalar(fx);"}]}