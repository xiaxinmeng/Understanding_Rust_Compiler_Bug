{"sha": "6ed2fd233b569d01169fc888f30c358dd289d260", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlZDJmZDIzM2I1NjlkMDExNjlmYzg4OGYzMGMzNThkZDI4OWQyNjA=", "commit": {"author": {"name": "cynecx", "email": "me@cynecx.net", "date": "2021-04-18T17:56:13Z"}, "committer": {"name": "cynecx", "email": "me@cynecx.net", "date": "2021-04-18T17:56:13Z"}, "message": "hir_ty: keep body::Expander in TyLoweringContext", "tree": {"sha": "d5ff73fef371ac596e7c98db1c39c9dd3112f571", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5ff73fef371ac596e7c98db1c39c9dd3112f571"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ed2fd233b569d01169fc888f30c358dd289d260", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ed2fd233b569d01169fc888f30c358dd289d260", "html_url": "https://github.com/rust-lang/rust/commit/6ed2fd233b569d01169fc888f30c358dd289d260", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ed2fd233b569d01169fc888f30c358dd289d260/comments", "author": {"login": "cynecx", "id": 5961244, "node_id": "MDQ6VXNlcjU5NjEyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5961244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cynecx", "html_url": "https://github.com/cynecx", "followers_url": "https://api.github.com/users/cynecx/followers", "following_url": "https://api.github.com/users/cynecx/following{/other_user}", "gists_url": "https://api.github.com/users/cynecx/gists{/gist_id}", "starred_url": "https://api.github.com/users/cynecx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cynecx/subscriptions", "organizations_url": "https://api.github.com/users/cynecx/orgs", "repos_url": "https://api.github.com/users/cynecx/repos", "events_url": "https://api.github.com/users/cynecx/events{/privacy}", "received_events_url": "https://api.github.com/users/cynecx/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cynecx", "id": 5961244, "node_id": "MDQ6VXNlcjU5NjEyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5961244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cynecx", "html_url": "https://github.com/cynecx", "followers_url": "https://api.github.com/users/cynecx/followers", "following_url": "https://api.github.com/users/cynecx/following{/other_user}", "gists_url": "https://api.github.com/users/cynecx/gists{/gist_id}", "starred_url": "https://api.github.com/users/cynecx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cynecx/subscriptions", "organizations_url": "https://api.github.com/users/cynecx/orgs", "repos_url": "https://api.github.com/users/cynecx/repos", "events_url": "https://api.github.com/users/cynecx/events{/privacy}", "received_events_url": "https://api.github.com/users/cynecx/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d39e77003c5fe5ed9f8f3ac00a170f3804f8337", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d39e77003c5fe5ed9f8f3ac00a170f3804f8337", "html_url": "https://github.com/rust-lang/rust/commit/3d39e77003c5fe5ed9f8f3ac00a170f3804f8337"}], "stats": {"total": 153, "additions": 94, "deletions": 59}, "files": [{"sha": "131f424cc8ba79b97fb5067ebb65f90d28520deb", "filename": "crates/hir_def/src/body.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6ed2fd233b569d01169fc888f30c358dd289d260/crates%2Fhir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed2fd233b569d01169fc888f30c358dd289d260/crates%2Fhir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody.rs?ref=6ed2fd233b569d01169fc888f30c358dd289d260", "patch": "@@ -37,13 +37,15 @@ use crate::{\n \n /// A subset of Expander that only deals with cfg attributes. We only need it to\n /// avoid cyclic queries in crate def map during enum processing.\n+#[derive(Debug)]\n pub(crate) struct CfgExpander {\n     cfg_options: CfgOptions,\n     hygiene: Hygiene,\n     krate: CrateId,\n }\n \n-pub(crate) struct Expander {\n+#[derive(Debug)]\n+pub struct Expander {\n     cfg_expander: CfgExpander,\n     def_map: Arc<DefMap>,\n     current_file_id: HirFileId,\n@@ -80,11 +82,7 @@ impl CfgExpander {\n }\n \n impl Expander {\n-    pub(crate) fn new(\n-        db: &dyn DefDatabase,\n-        current_file_id: HirFileId,\n-        module: ModuleId,\n-    ) -> Expander {\n+    pub fn new(db: &dyn DefDatabase, current_file_id: HirFileId, module: ModuleId) -> Expander {\n         let cfg_expander = CfgExpander::new(db, current_file_id, module.krate);\n         let def_map = module.def_map(db);\n         let ast_id_map = db.ast_id_map(current_file_id);\n@@ -98,7 +96,7 @@ impl Expander {\n         }\n     }\n \n-    pub(crate) fn enter_expand<T: ast::AstNode>(\n+    pub fn enter_expand<T: ast::AstNode>(\n         &mut self,\n         db: &dyn DefDatabase,\n         macro_call: ast::MacroCall,\n@@ -170,7 +168,7 @@ impl Expander {\n         Ok(ExpandResult { value: Some((mark, node)), err })\n     }\n \n-    pub(crate) fn exit(&mut self, db: &dyn DefDatabase, mut mark: Mark) {\n+    pub fn exit(&mut self, db: &dyn DefDatabase, mut mark: Mark) {\n         self.cfg_expander.hygiene = Hygiene::new(db.upcast(), mark.file_id);\n         self.current_file_id = mark.file_id;\n         self.ast_id_map = mem::take(&mut mark.ast_id_map);\n@@ -190,7 +188,7 @@ impl Expander {\n         &self.cfg_expander.cfg_options\n     }\n \n-    pub(crate) fn current_file_id(&self) -> HirFileId {\n+    pub fn current_file_id(&self) -> HirFileId {\n         self.current_file_id\n     }\n \n@@ -210,7 +208,7 @@ impl Expander {\n }\n \n #[derive(Debug)]\n-pub(crate) struct Mark {\n+pub struct Mark {\n     file_id: HirFileId,\n     ast_id_map: Arc<AstIdMap>,\n     bomb: DropBomb,"}, {"sha": "ea29da5daae49f75677b08954fc810bd163b7db1", "filename": "crates/hir_def/src/type_ref.rs", "status": "modified", "additions": 3, "deletions": 35, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6ed2fd233b569d01169fc888f30c358dd289d260/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed2fd233b569d01169fc888f30c358dd289d260/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs?ref=6ed2fd233b569d01169fc888f30c358dd289d260", "patch": "@@ -1,15 +1,10 @@\n //! HIR for references to types. Paths in these are not yet resolved. They can\n //! be directly created from an ast::TypeRef, without further queries.\n \n-use hir_expand::{name::Name, AstId, ExpandResult, InFile};\n+use hir_expand::{name::Name, AstId, InFile};\n use syntax::ast;\n \n-use crate::{\n-    body::{Expander, LowerCtx},\n-    db::DefDatabase,\n-    path::Path,\n-    ModuleId,\n-};\n+use crate::{body::LowerCtx, path::Path};\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Mutability {\n@@ -124,7 +119,7 @@ pub enum TypeBound {\n \n impl TypeRef {\n     /// Converts an `ast::TypeRef` to a `hir::TypeRef`.\n-    pub(crate) fn from_ast(ctx: &LowerCtx, node: ast::Type) -> Self {\n+    pub fn from_ast(ctx: &LowerCtx, node: ast::Type) -> Self {\n         match node {\n             ast::Type::ParenType(inner) => TypeRef::from_ast_opt(&ctx, inner.ty()),\n             ast::Type::TupleType(inner) => {\n@@ -303,30 +298,3 @@ impl TypeBound {\n         }\n     }\n }\n-\n-pub fn expand_macro_type(\n-    db: &dyn DefDatabase,\n-    module_id: ModuleId,\n-    macro_type: &TypeRef,\n-) -> Option<TypeRef> {\n-    let macro_call = match macro_type {\n-        TypeRef::Macro(macro_call) => macro_call,\n-        _ => panic!(\"expected TypeRef::Macro\"),\n-    };\n-\n-    let file_id = macro_call.file_id;\n-    let macro_call = macro_call.to_node(db.upcast());\n-\n-    let mut expander = Expander::new(db, file_id, module_id);\n-    let (file_id, expanded) = match expander.enter_expand::<ast::Type>(db, macro_call.clone()) {\n-        Ok(ExpandResult { value: Some((mark, expanded)), .. }) => {\n-            let file_id = expander.current_file_id();\n-            expander.exit(db, mark);\n-            (file_id, expanded)\n-        }\n-        _ => return None,\n-    };\n-\n-    let ctx = LowerCtx::new(db, file_id);\n-    return Some(TypeRef::from_ast(&ctx, expanded));\n-}"}, {"sha": "a883334afbb5fa893b8dd2f7cd7e6caefb704bd9", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 57, "deletions": 14, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6ed2fd233b569d01169fc888f30c358dd289d260/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed2fd233b569d01169fc888f30c358dd289d260/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=6ed2fd233b569d01169fc888f30c358dd289d260", "patch": "@@ -5,25 +5,28 @@\n //!  - Building the type for an item: This happens through the `type_for_def` query.\n //!\n //! This usually involves resolving names, collecting generic arguments etc.\n+use std::cell::{Cell, RefCell};\n use std::{iter, sync::Arc};\n \n use base_db::CrateId;\n use chalk_ir::{cast::Cast, fold::Shift, interner::HasInterner, Mutability, Safety};\n use hir_def::{\n     adt::StructKind,\n+    body::{Expander, LowerCtx},\n     builtin_type::BuiltinType,\n     generics::{TypeParamProvenance, WherePredicate, WherePredicateTypeTarget},\n     path::{GenericArg, Path, PathSegment, PathSegments},\n     resolver::{HasResolver, Resolver, TypeNs},\n-    type_ref::{expand_macro_type, TraitRef as HirTraitRef, TypeBound, TypeRef},\n+    type_ref::{TraitRef as HirTraitRef, TypeBound, TypeRef},\n     AdtId, AssocContainerId, AssocItemId, ConstId, ConstParamId, EnumId, EnumVariantId, FunctionId,\n     GenericDefId, HasModule, ImplId, LocalFieldId, Lookup, StaticId, StructId, TraitId,\n     TypeAliasId, TypeParamId, UnionId, VariantId,\n };\n-use hir_expand::name::Name;\n+use hir_expand::{name::Name, ExpandResult};\n use la_arena::ArenaMap;\n use smallvec::SmallVec;\n use stdx::impl_from;\n+use syntax::ast;\n \n use crate::{\n     db::HirDatabase,\n@@ -50,7 +53,7 @@ pub struct TyLoweringContext<'a> {\n     /// possible currently, so this should be fine for now.\n     pub type_param_mode: TypeParamLoweringMode,\n     pub impl_trait_mode: ImplTraitLoweringMode,\n-    impl_trait_counter: std::cell::Cell<u16>,\n+    impl_trait_counter: Cell<u16>,\n     /// When turning `impl Trait` into opaque types, we have to collect the\n     /// bounds at the same time to get the IDs correct (without becoming too\n     /// complicated). I don't like using interior mutability (as for the\n@@ -59,16 +62,17 @@ pub struct TyLoweringContext<'a> {\n     /// we're grouping the mutable data (the counter and this field) together\n     /// with the immutable context (the references to the DB and resolver).\n     /// Splitting this up would be a possible fix.\n-    opaque_type_data: std::cell::RefCell<Vec<ReturnTypeImplTrait>>,\n+    opaque_type_data: RefCell<Vec<ReturnTypeImplTrait>>,\n+    expander: RefCell<Option<Expander>>,\n }\n \n impl<'a> TyLoweringContext<'a> {\n     pub fn new(db: &'a dyn HirDatabase, resolver: &'a Resolver) -> Self {\n-        let impl_trait_counter = std::cell::Cell::new(0);\n+        let impl_trait_counter = Cell::new(0);\n         let impl_trait_mode = ImplTraitLoweringMode::Disallowed;\n         let type_param_mode = TypeParamLoweringMode::Placeholder;\n         let in_binders = DebruijnIndex::INNERMOST;\n-        let opaque_type_data = std::cell::RefCell::new(Vec::new());\n+        let opaque_type_data = RefCell::new(Vec::new());\n         Self {\n             db,\n             resolver,\n@@ -77,6 +81,7 @@ impl<'a> TyLoweringContext<'a> {\n             impl_trait_counter,\n             type_param_mode,\n             opaque_type_data,\n+            expander: RefCell::new(None),\n         }\n     }\n \n@@ -86,15 +91,18 @@ impl<'a> TyLoweringContext<'a> {\n         f: impl FnOnce(&TyLoweringContext) -> T,\n     ) -> T {\n         let opaque_ty_data_vec = self.opaque_type_data.replace(Vec::new());\n+        let expander = self.expander.replace(None);\n         let new_ctx = Self {\n             in_binders: debruijn,\n-            impl_trait_counter: std::cell::Cell::new(self.impl_trait_counter.get()),\n-            opaque_type_data: std::cell::RefCell::new(opaque_ty_data_vec),\n+            impl_trait_counter: Cell::new(self.impl_trait_counter.get()),\n+            opaque_type_data: RefCell::new(opaque_ty_data_vec),\n+            expander: RefCell::new(expander),\n             ..*self\n         };\n         let result = f(&new_ctx);\n         self.impl_trait_counter.set(new_ctx.impl_trait_counter.get());\n         self.opaque_type_data.replace(new_ctx.opaque_type_data.into_inner());\n+        self.expander.replace(new_ctx.expander.into_inner());\n         result\n     }\n \n@@ -287,15 +295,50 @@ impl<'a> TyLoweringContext<'a> {\n                     }\n                 }\n             }\n-            mt @ TypeRef::Macro(_) => {\n-                if let Some(module_id) = self.resolver.module() {\n-                    match expand_macro_type(self.db.upcast(), module_id, mt) {\n-                        Some(type_ref) => self.lower_ty(&type_ref),\n-                        None => TyKind::Error.intern(&Interner),\n+            TypeRef::Macro(macro_call) => {\n+                let (expander, recursion_start) = match self.expander.borrow_mut() {\n+                    expander if expander.is_some() => (Some(expander), false),\n+                    mut expander => {\n+                        if let Some(module_id) = self.resolver.module() {\n+                            *expander = Some(Expander::new(\n+                                self.db.upcast(),\n+                                macro_call.file_id,\n+                                module_id,\n+                            ));\n+                            (Some(expander), true)\n+                        } else {\n+                            (None, false)\n+                        }\n+                    }\n+                };\n+                let ty = if let Some(mut expander) = expander {\n+                    let expander_mut = expander.as_mut().unwrap();\n+                    let macro_call = macro_call.to_node(self.db.upcast());\n+                    match expander_mut.enter_expand::<ast::Type>(self.db.upcast(), macro_call) {\n+                        Ok(ExpandResult { value: Some((mark, expanded)), .. }) => {\n+                            let ctx =\n+                                LowerCtx::new(self.db.upcast(), expander_mut.current_file_id());\n+                            let type_ref = TypeRef::from_ast(&ctx, expanded);\n+\n+                            drop(expander);\n+                            let ty = self.lower_ty(&type_ref);\n+\n+                            self.expander\n+                                .borrow_mut()\n+                                .as_mut()\n+                                .unwrap()\n+                                .exit(self.db.upcast(), mark);\n+                            Some(ty)\n+                        }\n+                        _ => None,\n                     }\n                 } else {\n-                    TyKind::Error.intern(&Interner)\n+                    None\n+                };\n+                if recursion_start {\n+                    *self.expander.borrow_mut() = None;\n                 }\n+                ty.unwrap_or_else(|| TyKind::Error.intern(&Interner))\n             }\n             TypeRef::Error => TyKind::Error.intern(&Interner),\n         };"}, {"sha": "8de1e229f0d1a4c6d302c4965fadd51c5dfe3da5", "filename": "crates/hir_ty/src/tests/macros.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6ed2fd233b569d01169fc888f30c358dd289d260/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ed2fd233b569d01169fc888f30c358dd289d260/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=6ed2fd233b569d01169fc888f30c358dd289d260", "patch": "@@ -1243,3 +1243,29 @@ fn macros_in_type_generics() {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn infinitely_recursive_macro_type() {\n+    check_infer(\n+        r#\"\n+        struct Bar<T>(T);\n+\n+        macro_rules! Foo {\n+            () => { Foo!() }\n+        }\n+\n+        type A = Foo!();\n+        type B = Bar<Foo!()>;\n+\n+        fn main() {\n+            let a: A;\n+            let b: B;\n+        }\n+        \"#,\n+        expect![[r#\"\n+            112..143 '{     ...: B; }': ()\n+            122..123 'a': {unknown}\n+            136..137 'b': Bar<{unknown}>\n+        \"#]],\n+    );\n+}"}]}