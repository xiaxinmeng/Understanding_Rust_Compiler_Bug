{"sha": "933fc1eb1837a902def314d400c0f3a6dd2c1283", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzM2ZjMWViMTgzN2E5MDJkZWYzMTRkNDAwYzBmM2E2ZGQyYzEyODM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-09-17T13:00:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-17T13:00:25Z"}, "message": "Merge #6016\n\n6016: Emit diagnostics for unresolved imports and extern crates r=jonas-schievink a=jonas-schievink\n\nAFAIK, we don't have any major bugs in name resolution that would cause a lot of false positives here (except procedural attribute macro support and some rare issues around `#[path]` on module files), so these are *not* marked as experimental diagnostics right now.\r\n\r\nI noticed that diagnostics in a file sometimes don't get displayed after opening, but require some edit to be performed. This seems like a preexisting issue though.\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>", "tree": {"sha": "95325c5d387fbbf13ac1caca9717e7ab0f3cdede", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95325c5d387fbbf13ac1caca9717e7ab0f3cdede"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/933fc1eb1837a902def314d400c0f3a6dd2c1283", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfY13pCRBK7hj4Ov3rIwAAdHIIAEXufCncHx4AiUrVIXJbyOLm\nOtWLX0Nst8512ETYa0KgaT3ZhTqzfP5wn+I/KzCL7vAN93XvxbTpgQ1tjHJeiN+9\nW1brhCB7m5KIC/Ytmw+BdmWSuApcG1RZ5qPGOcSt8wkpvb+9JaRdkQZQQLlB6i7M\neNF+Gz1jC/STG96SmhqLmApWNbK/kd3jNnoFq/NOEc9xY9zH9r0iN5agK5X+nJjK\nYitd0yilkc6rBhISQIQu9djzNZnoU+2RFLSTpMIdiDZt47YNwZ2RcbH0OTzyQT/a\noF79sGQ9AASQnUm+lm2YlPWSPFP7qz/af5wrKvxEVSYW1iQcDYq46m2U09ww7PM=\n=AJbN\n-----END PGP SIGNATURE-----\n", "payload": "tree 95325c5d387fbbf13ac1caca9717e7ab0f3cdede\nparent af92bdb8270f238fbb8af8c749bf6e9fc6a06710\nparent 0dca7acf0fb65545f0c46f0c604bb15400aa6d91\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1600347625 +0000\ncommitter GitHub <noreply@github.com> 1600347625 +0000\n\nMerge #6016\n\n6016: Emit diagnostics for unresolved imports and extern crates r=jonas-schievink a=jonas-schievink\n\nAFAIK, we don't have any major bugs in name resolution that would cause a lot of false positives here (except procedural attribute macro support and some rare issues around `#[path]` on module files), so these are *not* marked as experimental diagnostics right now.\r\n\r\nI noticed that diagnostics in a file sometimes don't get displayed after opening, but require some edit to be performed. This seems like a preexisting issue though.\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/933fc1eb1837a902def314d400c0f3a6dd2c1283", "html_url": "https://github.com/rust-lang/rust/commit/933fc1eb1837a902def314d400c0f3a6dd2c1283", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/933fc1eb1837a902def314d400c0f3a6dd2c1283/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af92bdb8270f238fbb8af8c749bf6e9fc6a06710", "url": "https://api.github.com/repos/rust-lang/rust/commits/af92bdb8270f238fbb8af8c749bf6e9fc6a06710", "html_url": "https://github.com/rust-lang/rust/commit/af92bdb8270f238fbb8af8c749bf6e9fc6a06710"}, {"sha": "0dca7acf0fb65545f0c46f0c604bb15400aa6d91", "url": "https://api.github.com/repos/rust-lang/rust/commits/0dca7acf0fb65545f0c46f0c604bb15400aa6d91", "html_url": "https://github.com/rust-lang/rust/commit/0dca7acf0fb65545f0c46f0c604bb15400aa6d91"}], "stats": {"total": 522, "additions": 445, "deletions": 77}, "files": [{"sha": "2ec0fd3fb721c946c4e3dd2a17a35a7be452cd59", "filename": "crates/hir_def/src/diagnostics.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/933fc1eb1837a902def314d400c0f3a6dd2c1283/crates%2Fhir_def%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/933fc1eb1837a902def314d400c0f3a6dd2c1283/crates%2Fhir_def%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdiagnostics.rs?ref=933fc1eb1837a902def314d400c0f3a6dd2c1283", "patch": "@@ -28,3 +28,45 @@ impl Diagnostic for UnresolvedModule {\n         self\n     }\n }\n+\n+#[derive(Debug)]\n+pub struct UnresolvedExternCrate {\n+    pub file: HirFileId,\n+    pub item: AstPtr<ast::ExternCrate>,\n+}\n+\n+impl Diagnostic for UnresolvedExternCrate {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"unresolved-extern-crate\")\n+    }\n+    fn message(&self) -> String {\n+        \"unresolved extern crate\".to_string()\n+    }\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile::new(self.file, self.item.clone().into())\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct UnresolvedImport {\n+    pub file: HirFileId,\n+    pub node: AstPtr<ast::UseTree>,\n+}\n+\n+impl Diagnostic for UnresolvedImport {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"unresolved-import\")\n+    }\n+    fn message(&self) -> String {\n+        \"unresolved import\".to_string()\n+    }\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile::new(self.file, self.node.clone().into())\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}"}, {"sha": "db3b4a985c803b5bc409d80c5053caec341ff33b", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/933fc1eb1837a902def314d400c0f3a6dd2c1283/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/933fc1eb1837a902def314d400c0f3a6dd2c1283/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=933fc1eb1837a902def314d400c0f3a6dd2c1283", "patch": "@@ -291,7 +291,6 @@ pub enum AttrOwner {\n \n     Variant(Idx<Variant>),\n     Field(Idx<Field>),\n-    // FIXME: Store variant and field attrs, and stop reparsing them in `attrs_query`.\n }\n \n macro_rules! from_attrs {\n@@ -483,6 +482,11 @@ pub struct Import {\n     /// AST ID of the `use` or `extern crate` item this import was derived from. Note that many\n     /// `Import`s can map to the same `use` item.\n     pub ast_id: FileAstId<ast::Use>,\n+    /// Index of this `Import` when the containing `Use` is visited via `ModPath::expand_use_item`.\n+    ///\n+    /// This can be used to get the `UseTree` this `Import` corresponds to and allows emitting\n+    /// precise diagnostics.\n+    pub index: usize,\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]"}, {"sha": "da62e1297c9c5fe9f236dd497c5ad567b68a9978", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/933fc1eb1837a902def314d400c0f3a6dd2c1283/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/933fc1eb1837a902def314d400c0f3a6dd2c1283/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=933fc1eb1837a902def314d400c0f3a6dd2c1283", "patch": "@@ -483,14 +483,15 @@ impl Ctx {\n         ModPath::expand_use_item(\n             InFile::new(self.file, use_item.clone()),\n             &self.hygiene,\n-            |path, _tree, is_glob, alias| {\n+            |path, _use_tree, is_glob, alias| {\n                 imports.push(id(tree.imports.alloc(Import {\n                     path,\n                     alias,\n                     visibility,\n                     is_glob,\n                     is_prelude,\n                     ast_id,\n+                    index: imports.len(),\n                 })));\n             },\n         );"}, {"sha": "4d0a3b7e6ca4121b6cec59a4533512141bcc35fe", "filename": "crates/hir_def/src/item_tree/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/933fc1eb1837a902def314d400c0f3a6dd2c1283/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/933fc1eb1837a902def314d400c0f3a6dd2c1283/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs?ref=933fc1eb1837a902def314d400c0f3a6dd2c1283", "patch": "@@ -228,9 +228,9 @@ fn smoke() {\n \n             top-level items:\n             #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_on_use\"))] }, input: None }]) }]\n-            Import { path: ModPath { kind: Plain, segments: [Name(Text(\"a\"))] }, alias: None, visibility: RawVisibilityId(\"pub(self)\"), is_glob: false, is_prelude: false, ast_id: FileAstId::<syntax::ast::generated::nodes::Use>(0) }\n+            Import { path: ModPath { kind: Plain, segments: [Name(Text(\"a\"))] }, alias: None, visibility: RawVisibilityId(\"pub(self)\"), is_glob: false, is_prelude: false, ast_id: FileAstId::<syntax::ast::generated::nodes::Use>(0), index: 0 }\n             #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_on_use\"))] }, input: None }]) }]\n-            Import { path: ModPath { kind: Plain, segments: [Name(Text(\"b\"))] }, alias: None, visibility: RawVisibilityId(\"pub(self)\"), is_glob: true, is_prelude: false, ast_id: FileAstId::<syntax::ast::generated::nodes::Use>(0) }\n+            Import { path: ModPath { kind: Plain, segments: [Name(Text(\"b\"))] }, alias: None, visibility: RawVisibilityId(\"pub(self)\"), is_glob: true, is_prelude: false, ast_id: FileAstId::<syntax::ast::generated::nodes::Use>(0), index: 1 }\n             #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"ext_crate\"))] }, input: None }]) }]\n             ExternCrate { path: ModPath { kind: Plain, segments: [Name(Text(\"krate\"))] }, alias: None, visibility: RawVisibilityId(\"pub(self)\"), is_macro_use: false, ast_id: FileAstId::<syntax::ast::generated::nodes::ExternCrate>(1) }\n             #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"on_trait\"))] }, input: None }]) }]"}, {"sha": "5e4d73c1ffc6608f1da074b5ce7c9d32704f2379", "filename": "crates/hir_def/src/nameres.rs", "status": "modified", "additions": 81, "deletions": 12, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/933fc1eb1837a902def314d400c0f3a6dd2c1283/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/933fc1eb1837a902def314d400c0f3a6dd2c1283/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres.rs?ref=933fc1eb1837a902def314d400c0f3a6dd2c1283", "patch": "@@ -288,38 +288,107 @@ pub enum ModuleSource {\n \n mod diagnostics {\n     use hir_expand::diagnostics::DiagnosticSink;\n+    use hir_expand::hygiene::Hygiene;\n+    use hir_expand::InFile;\n     use syntax::{ast, AstPtr};\n \n-    use crate::{db::DefDatabase, diagnostics::UnresolvedModule, nameres::LocalModuleId, AstId};\n+    use crate::path::ModPath;\n+    use crate::{db::DefDatabase, diagnostics::*, nameres::LocalModuleId, AstId};\n \n     #[derive(Debug, PartialEq, Eq)]\n-    pub(super) enum DefDiagnostic {\n-        UnresolvedModule {\n-            module: LocalModuleId,\n-            declaration: AstId<ast::Module>,\n-            candidate: String,\n-        },\n+    enum DiagnosticKind {\n+        UnresolvedModule { declaration: AstId<ast::Module>, candidate: String },\n+\n+        UnresolvedExternCrate { ast: AstId<ast::ExternCrate> },\n+\n+        UnresolvedImport { ast: AstId<ast::Use>, index: usize },\n+    }\n+\n+    #[derive(Debug, PartialEq, Eq)]\n+    pub(super) struct DefDiagnostic {\n+        in_module: LocalModuleId,\n+        kind: DiagnosticKind,\n     }\n \n     impl DefDiagnostic {\n+        pub(super) fn unresolved_module(\n+            container: LocalModuleId,\n+            declaration: AstId<ast::Module>,\n+            candidate: String,\n+        ) -> Self {\n+            Self {\n+                in_module: container,\n+                kind: DiagnosticKind::UnresolvedModule { declaration, candidate },\n+            }\n+        }\n+\n+        pub(super) fn unresolved_extern_crate(\n+            container: LocalModuleId,\n+            declaration: AstId<ast::ExternCrate>,\n+        ) -> Self {\n+            Self {\n+                in_module: container,\n+                kind: DiagnosticKind::UnresolvedExternCrate { ast: declaration },\n+            }\n+        }\n+\n+        pub(super) fn unresolved_import(\n+            container: LocalModuleId,\n+            ast: AstId<ast::Use>,\n+            index: usize,\n+        ) -> Self {\n+            Self { in_module: container, kind: DiagnosticKind::UnresolvedImport { ast, index } }\n+        }\n+\n         pub(super) fn add_to(\n             &self,\n             db: &dyn DefDatabase,\n             target_module: LocalModuleId,\n             sink: &mut DiagnosticSink,\n         ) {\n-            match self {\n-                DefDiagnostic::UnresolvedModule { module, declaration, candidate } => {\n-                    if *module != target_module {\n-                        return;\n-                    }\n+            if self.in_module != target_module {\n+                return;\n+            }\n+\n+            match &self.kind {\n+                DiagnosticKind::UnresolvedModule { declaration, candidate } => {\n                     let decl = declaration.to_node(db.upcast());\n                     sink.push(UnresolvedModule {\n                         file: declaration.file_id,\n                         decl: AstPtr::new(&decl),\n                         candidate: candidate.clone(),\n                     })\n                 }\n+\n+                DiagnosticKind::UnresolvedExternCrate { ast } => {\n+                    let item = ast.to_node(db.upcast());\n+                    sink.push(UnresolvedExternCrate {\n+                        file: ast.file_id,\n+                        item: AstPtr::new(&item),\n+                    });\n+                }\n+\n+                DiagnosticKind::UnresolvedImport { ast, index } => {\n+                    let use_item = ast.to_node(db.upcast());\n+                    let hygiene = Hygiene::new(db.upcast(), ast.file_id);\n+                    let mut cur = 0;\n+                    let mut tree = None;\n+                    ModPath::expand_use_item(\n+                        InFile::new(ast.file_id, use_item),\n+                        &hygiene,\n+                        |_mod_path, use_tree, _is_glob, _alias| {\n+                            if cur == *index {\n+                                tree = Some(use_tree.clone());\n+                            }\n+\n+                            cur += 1;\n+                        },\n+                    );\n+\n+                    if let Some(tree) = tree {\n+                        sink.push(UnresolvedImport { file: ast.file_id, node: AstPtr::new(&tree) });\n+                    }\n+                }\n             }\n         }\n     }"}, {"sha": "8180081696334a82cd44e0304c1b92b8f88f853b", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 82, "deletions": 20, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/933fc1eb1837a902def314d400c0f3a6dd2c1283/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/933fc1eb1837a902def314d400c0f3a6dd2c1283/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=933fc1eb1837a902def314d400c0f3a6dd2c1283", "patch": "@@ -5,6 +5,7 @@\n \n use base_db::{CrateId, FileId, ProcMacroId};\n use cfg::CfgOptions;\n+use hir_expand::InFile;\n use hir_expand::{\n     ast_id_map::FileAstId,\n     builtin_derive::find_builtin_derive,\n@@ -14,16 +15,15 @@ use hir_expand::{\n     HirFileId, MacroCallId, MacroDefId, MacroDefKind,\n };\n use rustc_hash::FxHashMap;\n+use rustc_hash::FxHashSet;\n use syntax::ast;\n use test_utils::mark;\n \n use crate::{\n     attr::Attrs,\n     db::DefDatabase,\n     item_scope::{ImportType, PerNsGlobImports},\n-    item_tree::{\n-        self, FileItemTreeId, ItemTree, ItemTreeId, MacroCall, Mod, ModItem, ModKind, StructDefKind,\n-    },\n+    item_tree::{self, ItemTree, ItemTreeId, MacroCall, Mod, ModItem, ModKind, StructDefKind},\n     nameres::{\n         diagnostics::DefDiagnostic, mod_resolution::ModDir, path_resolution::ReachedFixedPoint,\n         BuiltinShadowMode, CrateDefMap, ModuleData, ModuleOrigin, ResolveMode,\n@@ -111,6 +111,12 @@ impl PartialResolvedImport {\n     }\n }\n \n+#[derive(Clone, Debug, Eq, PartialEq)]\n+enum ImportSource {\n+    Import(ItemTreeId<item_tree::Import>),\n+    ExternCrate(ItemTreeId<item_tree::ExternCrate>),\n+}\n+\n #[derive(Clone, Debug, Eq, PartialEq)]\n struct Import {\n     pub path: ModPath,\n@@ -120,11 +126,12 @@ struct Import {\n     pub is_prelude: bool,\n     pub is_extern_crate: bool,\n     pub is_macro_use: bool,\n+    source: ImportSource,\n }\n \n impl Import {\n-    fn from_use(tree: &ItemTree, id: FileItemTreeId<item_tree::Import>) -> Self {\n-        let it = &tree[id];\n+    fn from_use(tree: &ItemTree, id: ItemTreeId<item_tree::Import>) -> Self {\n+        let it = &tree[id.value];\n         let visibility = &tree[it.visibility];\n         Self {\n             path: it.path.clone(),\n@@ -134,11 +141,12 @@ impl Import {\n             is_prelude: it.is_prelude,\n             is_extern_crate: false,\n             is_macro_use: false,\n+            source: ImportSource::Import(id),\n         }\n     }\n \n-    fn from_extern_crate(tree: &ItemTree, id: FileItemTreeId<item_tree::ExternCrate>) -> Self {\n-        let it = &tree[id];\n+    fn from_extern_crate(tree: &ItemTree, id: ItemTreeId<item_tree::ExternCrate>) -> Self {\n+        let it = &tree[id.value];\n         let visibility = &tree[it.visibility];\n         Self {\n             path: it.path.clone(),\n@@ -148,6 +156,7 @@ impl Import {\n             is_prelude: false,\n             is_extern_crate: true,\n             is_macro_use: it.is_macro_use,\n+            source: ImportSource::ExternCrate(id),\n         }\n     }\n }\n@@ -245,9 +254,10 @@ impl DefCollector<'_> {\n \n         let unresolved_imports = std::mem::replace(&mut self.unresolved_imports, Vec::new());\n         // show unresolved imports in completion, etc\n-        for directive in unresolved_imports {\n-            self.record_resolved_import(&directive)\n+        for directive in &unresolved_imports {\n+            self.record_resolved_import(directive)\n         }\n+        self.unresolved_imports = unresolved_imports;\n \n         // Record proc-macros\n         self.collect_proc_macro();\n@@ -420,7 +430,11 @@ impl DefCollector<'_> {\n                     .as_ident()\n                     .expect(\"extern crate should have been desugared to one-element path\"),\n             );\n-            PartialResolvedImport::Resolved(res)\n+            if res.is_none() {\n+                PartialResolvedImport::Unresolved\n+            } else {\n+                PartialResolvedImport::Resolved(res)\n+            }\n         } else {\n             let res = self.def_map.resolve_path_fp_with_macro(\n                 self.db,\n@@ -774,7 +788,51 @@ impl DefCollector<'_> {\n         .collect(item_tree.top_level_items());\n     }\n \n-    fn finish(self) -> CrateDefMap {\n+    fn finish(mut self) -> CrateDefMap {\n+        // Emit diagnostics for all remaining unresolved imports.\n+\n+        // We'd like to avoid emitting a diagnostics avalanche when some `extern crate` doesn't\n+        // resolve. We first emit diagnostics for unresolved extern crates and collect the missing\n+        // crate names. Then we emit diagnostics for unresolved imports, but only if the import\n+        // doesn't start with an unresolved crate's name. Due to renaming and reexports, this is a\n+        // heuristic, but it works in practice.\n+        let mut diagnosed_extern_crates = FxHashSet::default();\n+        for directive in &self.unresolved_imports {\n+            if let ImportSource::ExternCrate(krate) = directive.import.source {\n+                let item_tree = self.db.item_tree(krate.file_id);\n+                let extern_crate = &item_tree[krate.value];\n+\n+                diagnosed_extern_crates.insert(extern_crate.path.segments[0].clone());\n+\n+                self.def_map.diagnostics.push(DefDiagnostic::unresolved_extern_crate(\n+                    directive.module_id,\n+                    InFile::new(krate.file_id, extern_crate.ast_id),\n+                ));\n+            }\n+        }\n+\n+        for directive in &self.unresolved_imports {\n+            if let ImportSource::Import(import) = &directive.import.source {\n+                let item_tree = self.db.item_tree(import.file_id);\n+                let import_data = &item_tree[import.value];\n+\n+                match (import_data.path.segments.first(), &import_data.path.kind) {\n+                    (Some(krate), PathKind::Plain) | (Some(krate), PathKind::Abs) => {\n+                        if diagnosed_extern_crates.contains(krate) {\n+                            continue;\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+\n+                self.def_map.diagnostics.push(DefDiagnostic::unresolved_import(\n+                    directive.module_id,\n+                    InFile::new(import.file_id, import_data.ast_id),\n+                    import_data.index,\n+                ));\n+            }\n+        }\n+\n         self.def_map\n     }\n }\n@@ -830,14 +888,20 @@ impl ModCollector<'_, '_> {\n                     ModItem::Import(import_id) => {\n                         self.def_collector.unresolved_imports.push(ImportDirective {\n                             module_id: self.module_id,\n-                            import: Import::from_use(&self.item_tree, import_id),\n+                            import: Import::from_use(\n+                                &self.item_tree,\n+                                InFile::new(self.file_id, import_id),\n+                            ),\n                             status: PartialResolvedImport::Unresolved,\n                         })\n                     }\n                     ModItem::ExternCrate(import_id) => {\n                         self.def_collector.unresolved_imports.push(ImportDirective {\n                             module_id: self.module_id,\n-                            import: Import::from_extern_crate(&self.item_tree, import_id),\n+                            import: Import::from_extern_crate(\n+                                &self.item_tree,\n+                                InFile::new(self.file_id, import_id),\n+                            ),\n                             status: PartialResolvedImport::Unresolved,\n                         })\n                     }\n@@ -1051,13 +1115,11 @@ impl ModCollector<'_, '_> {\n                             self.import_all_legacy_macros(module_id);\n                         }\n                     }\n-                    Err(candidate) => self.def_collector.def_map.diagnostics.push(\n-                        DefDiagnostic::UnresolvedModule {\n-                            module: self.module_id,\n-                            declaration: ast_id,\n-                            candidate,\n-                        },\n-                    ),\n+                    Err(candidate) => {\n+                        self.def_collector.def_map.diagnostics.push(\n+                            DefDiagnostic::unresolved_module(self.module_id, ast_id, candidate),\n+                        );\n+                    }\n                 };\n             }\n         }"}, {"sha": "11d84f8082ebaa211e6ede6e3af10ffe83707f36", "filename": "crates/hir_def/src/nameres/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/933fc1eb1837a902def314d400c0f3a6dd2c1283/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/933fc1eb1837a902def314d400c0f3a6dd2c1283/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests.rs?ref=933fc1eb1837a902def314d400c0f3a6dd2c1283", "patch": "@@ -2,6 +2,7 @@ mod globs;\n mod incremental;\n mod macros;\n mod mod_resolution;\n+mod diagnostics;\n mod primitives;\n \n use std::sync::Arc;"}, {"sha": "576b813d2ae070e6b581649b64c1eaf7e60177dc", "filename": "crates/hir_def/src/nameres/tests/diagnostics.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/933fc1eb1837a902def314d400c0f3a6dd2c1283/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/933fc1eb1837a902def314d400c0f3a6dd2c1283/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs?ref=933fc1eb1837a902def314d400c0f3a6dd2c1283", "patch": "@@ -0,0 +1,131 @@\n+use base_db::fixture::WithFixture;\n+use base_db::FileId;\n+use base_db::SourceDatabaseExt;\n+use hir_expand::db::AstDatabase;\n+use rustc_hash::FxHashMap;\n+use syntax::TextRange;\n+use syntax::TextSize;\n+\n+use crate::test_db::TestDB;\n+\n+fn check_diagnostics(ra_fixture: &str) {\n+    let db: TestDB = TestDB::with_files(ra_fixture);\n+    let annotations = db.extract_annotations();\n+    assert!(!annotations.is_empty());\n+\n+    let mut actual: FxHashMap<FileId, Vec<(TextRange, String)>> = FxHashMap::default();\n+    db.diagnostics(|d| {\n+        let src = d.display_source();\n+        let root = db.parse_or_expand(src.file_id).unwrap();\n+        // FIXME: macros...\n+        let file_id = src.file_id.original_file(&db);\n+        let range = src.value.to_node(&root).text_range();\n+        let message = d.message().to_owned();\n+        actual.entry(file_id).or_default().push((range, message));\n+    });\n+\n+    for (file_id, diags) in actual.iter_mut() {\n+        diags.sort_by_key(|it| it.0.start());\n+        let text = db.file_text(*file_id);\n+        // For multiline spans, place them on line start\n+        for (range, content) in diags {\n+            if text[*range].contains('\\n') {\n+                *range = TextRange::new(range.start(), range.start() + TextSize::from(1));\n+                *content = format!(\"... {}\", content);\n+            }\n+        }\n+    }\n+\n+    assert_eq!(annotations, actual);\n+}\n+\n+#[test]\n+fn unresolved_import() {\n+    check_diagnostics(\n+        r\"\n+        use does_exist;\n+        use does_not_exist;\n+          //^^^^^^^^^^^^^^ unresolved import\n+\n+        mod does_exist {}\n+        \",\n+    );\n+}\n+\n+#[test]\n+fn unresolved_import_in_use_tree() {\n+    // Only the relevant part of a nested `use` item should be highlighted.\n+    check_diagnostics(\n+        r\"\n+        use does_exist::{Exists, DoesntExist};\n+                               //^^^^^^^^^^^ unresolved import\n+\n+        use {does_not_exist::*, does_exist};\n+           //^^^^^^^^^^^^^^^^^ unresolved import\n+\n+        use does_not_exist::{\n+            a,\n+          //^ unresolved import\n+            b,\n+          //^ unresolved import\n+            c,\n+          //^ unresolved import\n+        };\n+\n+        mod does_exist {\n+            pub struct Exists;\n+        }\n+        \",\n+    );\n+}\n+\n+#[test]\n+fn unresolved_extern_crate() {\n+    check_diagnostics(\n+        r\"\n+        //- /main.rs crate:main deps:core\n+        extern crate core;\n+          extern crate doesnotexist;\n+        //^^^^^^^^^^^^^^^^^^^^^^^^^^ unresolved extern crate\n+        //- /lib.rs crate:core\n+        \",\n+    );\n+}\n+\n+#[test]\n+fn dedup_unresolved_import_from_unresolved_crate() {\n+    check_diagnostics(\n+        r\"\n+        //- /main.rs crate:main\n+        mod a {\n+            extern crate doesnotexist;\n+          //^^^^^^^^^^^^^^^^^^^^^^^^^^ unresolved extern crate\n+\n+            // Should not error, since we already errored for the missing crate.\n+            use doesnotexist::{self, bla, *};\n+\n+            use crate::doesnotexist;\n+              //^^^^^^^^^^^^^^^^^^^ unresolved import\n+        }\n+\n+        mod m {\n+            use super::doesnotexist;\n+              //^^^^^^^^^^^^^^^^^^^ unresolved import\n+        }\n+        \",\n+    );\n+}\n+\n+#[test]\n+fn unresolved_module() {\n+    check_diagnostics(\n+        r\"\n+        //- /lib.rs\n+        mod foo;\n+          mod bar;\n+        //^^^^^^^^ unresolved module\n+        mod baz {}\n+        //- /foo.rs\n+        \",\n+    );\n+}"}, {"sha": "f93337a6ea767ae7c5e38c051bccf39da6b82868", "filename": "crates/hir_def/src/nameres/tests/mod_resolution.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/933fc1eb1837a902def314d400c0f3a6dd2c1283/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/933fc1eb1837a902def314d400c0f3a6dd2c1283/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs?ref=933fc1eb1837a902def314d400c0f3a6dd2c1283", "patch": "@@ -671,42 +671,6 @@ pub struct Baz;\n     );\n }\n \n-#[test]\n-fn unresolved_module_diagnostics() {\n-    let db = TestDB::with_files(\n-        r\"\n-        //- /lib.rs\n-        mod foo;\n-        mod bar;\n-        mod baz {}\n-        //- /foo.rs\n-        \",\n-    );\n-    let krate = db.test_crate();\n-\n-    let crate_def_map = db.crate_def_map(krate);\n-\n-    expect![[r#\"\n-        [\n-            UnresolvedModule {\n-                module: Idx::<ModuleData>(0),\n-                declaration: InFile {\n-                    file_id: HirFileId(\n-                        FileId(\n-                            FileId(\n-                                0,\n-                            ),\n-                        ),\n-                    ),\n-                    value: FileAstId::<syntax::ast::generated::nodes::Module>(1),\n-                },\n-                candidate: \"bar.rs\",\n-            },\n-        ]\n-    \"#]]\n-    .assert_debug_eq(&crate_def_map.diagnostics);\n-}\n-\n #[test]\n fn module_resolution_decl_inside_module_in_non_crate_root_2() {\n     check("}, {"sha": "fb1d3c974353bcbf2cd9a96f488cad2ea0f2d0f4", "filename": "crates/hir_def/src/test_db.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/933fc1eb1837a902def314d400c0f3a6dd2c1283/crates%2Fhir_def%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/933fc1eb1837a902def314d400c0f3a6dd2c1283/crates%2Fhir_def%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ftest_db.rs?ref=933fc1eb1837a902def314d400c0f3a6dd2c1283", "patch": "@@ -5,9 +5,15 @@ use std::{\n     sync::{Arc, Mutex},\n };\n \n+use base_db::SourceDatabase;\n use base_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, Upcast};\n use hir_expand::db::AstDatabase;\n+use hir_expand::diagnostics::Diagnostic;\n+use hir_expand::diagnostics::DiagnosticSinkBuilder;\n+use rustc_hash::FxHashMap;\n use rustc_hash::FxHashSet;\n+use syntax::TextRange;\n+use test_utils::extract_annotations;\n \n use crate::db::DefDatabase;\n \n@@ -98,4 +104,40 @@ impl TestDB {\n             })\n             .collect()\n     }\n+\n+    pub fn extract_annotations(&self) -> FxHashMap<FileId, Vec<(TextRange, String)>> {\n+        let mut files = Vec::new();\n+        let crate_graph = self.crate_graph();\n+        for krate in crate_graph.iter() {\n+            let crate_def_map = self.crate_def_map(krate);\n+            for (module_id, _) in crate_def_map.modules.iter() {\n+                let file_id = crate_def_map[module_id].origin.file_id();\n+                files.extend(file_id)\n+            }\n+        }\n+        assert!(!files.is_empty());\n+        files\n+            .into_iter()\n+            .filter_map(|file_id| {\n+                let text = self.file_text(file_id);\n+                let annotations = extract_annotations(&text);\n+                if annotations.is_empty() {\n+                    return None;\n+                }\n+                Some((file_id, annotations))\n+            })\n+            .collect()\n+    }\n+\n+    pub fn diagnostics<F: FnMut(&dyn Diagnostic)>(&self, mut cb: F) {\n+        let crate_graph = self.crate_graph();\n+        for krate in crate_graph.iter() {\n+            let crate_def_map = self.crate_def_map(krate);\n+\n+            let mut sink = DiagnosticSinkBuilder::new().build(&mut cb);\n+            for (module_id, _) in crate_def_map.modules.iter() {\n+                crate_def_map.add_diagnostics(self, module_id, &mut sink);\n+            }\n+        }\n+    }\n }"}, {"sha": "dc815a48380df2db7badb620efd9e04ea5781c8d", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 57, "deletions": 5, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/933fc1eb1837a902def314d400c0f3a6dd2c1283/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/933fc1eb1837a902def314d400c0f3a6dd2c1283/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=933fc1eb1837a902def314d400c0f3a6dd2c1283", "patch": "@@ -622,13 +622,65 @@ pub struct Foo { pub a: i32, pub b: i32 }\n             r#\"\n use a;\n use a::{c, d::e};\n+\n+mod a {\n+    mod c {}\n+    mod d {\n+        mod e {}\n+    }\n+}\n \"#,\n         );\n-        check_fix(r#\"use {<|>b};\"#, r#\"use b;\"#);\n-        check_fix(r#\"use {b<|>};\"#, r#\"use b;\"#);\n-        check_fix(r#\"use a::{c<|>};\"#, r#\"use a::c;\"#);\n-        check_fix(r#\"use a::{self<|>};\"#, r#\"use a;\"#);\n-        check_fix(r#\"use a::{c, d::{e<|>}};\"#, r#\"use a::{c, d::e};\"#);\n+        check_fix(\n+            r\"\n+            mod b {}\n+            use {<|>b};\n+            \",\n+            r\"\n+            mod b {}\n+            use b;\n+            \",\n+        );\n+        check_fix(\n+            r\"\n+            mod b {}\n+            use {b<|>};\n+            \",\n+            r\"\n+            mod b {}\n+            use b;\n+            \",\n+        );\n+        check_fix(\n+            r\"\n+            mod a { mod c {} }\n+            use a::{c<|>};\n+            \",\n+            r\"\n+            mod a { mod c {} }\n+            use a::c;\n+            \",\n+        );\n+        check_fix(\n+            r\"\n+            mod a {}\n+            use a::{self<|>};\n+            \",\n+            r\"\n+            mod a {}\n+            use a;\n+            \",\n+        );\n+        check_fix(\n+            r\"\n+            mod a { mod c {} mod d { mod e {} } }\n+            use a::{c, d::{e<|>}};\n+            \",\n+            r\"\n+            mod a { mod c {} mod d { mod e {} } }\n+            use a::{c, d::e};\n+            \",\n+        );\n     }\n \n     #[test]"}]}