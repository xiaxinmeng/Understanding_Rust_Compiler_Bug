{"sha": "12c5fc5877f708e8e4df05bf834261f5237ac437", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyYzVmYzU4NzdmNzA4ZThlNGRmMDViZjgzNDI2MWY1MjM3YWM0Mzc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-01-21T16:19:35Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-01-21T16:19:35Z"}, "message": "Flag all TLS functions as inline(never)\n\nThere's lots of fun rationale in the comments of the diff.\n\nCloses #11683", "tree": {"sha": "2b6ec30fe22a58869e927be142d145a783f749f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b6ec30fe22a58869e927be142d145a783f749f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12c5fc5877f708e8e4df05bf834261f5237ac437", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12c5fc5877f708e8e4df05bf834261f5237ac437", "html_url": "https://github.com/rust-lang/rust/commit/12c5fc5877f708e8e4df05bf834261f5237ac437", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12c5fc5877f708e8e4df05bf834261f5237ac437/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43cffe9d719170bd342b10d1bb81911f0e14a7c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/43cffe9d719170bd342b10d1bb81911f0e14a7c4", "html_url": "https://github.com/rust-lang/rust/commit/43cffe9d719170bd342b10d1bb81911f0e14a7c4"}], "stats": {"total": 62, "additions": 58, "deletions": 4}, "files": [{"sha": "b89c06edda35b2d72695f0123403d5d92eb086e8", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 58, "deletions": 4, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/12c5fc5877f708e8e4df05bf834261f5237ac437/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c5fc5877f708e8e4df05bf834261f5237ac437/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=12c5fc5877f708e8e4df05bf834261f5237ac437", "patch": "@@ -94,12 +94,63 @@ pub mod compiled {\n \n     pub unsafe fn cleanup() {}\n \n+    // Rationale for all of these functions being inline(never)\n+    //\n+    // The #[thread_local] annotation gets propagated all the way through to\n+    // LLVM, meaning the global is specially treated by LLVM to lower it to an\n+    // efficient sequence of instructions. This also involves dealing with fun\n+    // stuff in object files and whatnot. Regardless, it turns out this causes\n+    // trouble with green threads and lots of optimizations turned on. The\n+    // following case study was done on linux x86_64, but I would imagine that\n+    // other platforms are similar.\n+    //\n+    // On linux, the instruction sequence for loading the tls pointer global\n+    // looks like:\n+    //\n+    //      mov %fs:0x0, %rax\n+    //      mov -0x8(%rax), %rbx\n+    //\n+    // This code leads me to believe that (%fs:0x0) is a table, and then the\n+    // table contains the TLS values for the process. Hence, the slot at offset\n+    // -0x8 is the task TLS pointer. This leads us to the conclusion that this\n+    // table is the actual thread local part of each thread. The kernel sets up\n+    // the fs segment selector to point at the right region of memory for each\n+    // thread.\n+    //\n+    // Optimizations lead me to believe that this code is lowered to these\n+    // instructions in the LLVM codegen passes, because you'll see code like\n+    // this when everything is optimized:\n+    //\n+    //      mov %fs:0x0, %r14\n+    //      mov -0x8(%r14), %rbx\n+    //      // do something with %rbx, the rust Task pointer\n+    //\n+    //      ... // <- do more things\n+    //\n+    //      mov -0x8(%r14), %rbx\n+    //      // do something else with %rbx\n+    //\n+    // Note that the optimization done here is that the first load is not\n+    // duplicated during the lower instructions. This means that the %fs:0x0\n+    // memory location is only dereferenced once.\n+    //\n+    // Normally, this is actually a good thing! With green threads, however,\n+    // it's very possible for the code labeled \"do more things\" to context\n+    // switch to another thread. If this happens, then we *must* re-load %fs:0x0\n+    // because it's changed (we're on a different thread). If we don't re-load\n+    // the table location, then we'll be reading the original thread's TLS\n+    // values, not our thread's TLS values.\n+    //\n+    // Hence, we never inline these functions. By never inlining, we're\n+    // guaranteed that loading the table is a local decision which is forced to\n+    // *always* happen.\n+\n     /// Give a pointer to thread-local storage.\n     ///\n     /// # Safety note\n     ///\n     /// Does not validate the pointer type.\n-    #[inline]\n+    #[inline(never)] // see comments above\n     pub unsafe fn put<T>(sched: ~T) {\n         RT_TLS_PTR = cast::transmute(sched)\n     }\n@@ -109,7 +160,7 @@ pub mod compiled {\n     /// # Safety note\n     ///\n     /// Does not validate the pointer type.\n-    #[inline]\n+    #[inline(never)] // see comments above\n     pub unsafe fn take<T>() -> ~T {\n         let ptr = RT_TLS_PTR;\n         rtassert!(!ptr.is_null());\n@@ -124,7 +175,7 @@ pub mod compiled {\n     /// # Safety note\n     ///\n     /// Does not validate the pointer type.\n-    #[inline]\n+    #[inline(never)] // see comments above\n     pub unsafe fn try_take<T>() -> Option<~T> {\n         let ptr = RT_TLS_PTR;\n         if ptr.is_null() {\n@@ -143,25 +194,28 @@ pub mod compiled {\n     ///\n     /// Does not validate the pointer type.\n     /// Leaves the old pointer in TLS for speed.\n-    #[inline]\n+    #[inline(never)] // see comments above\n     pub unsafe fn unsafe_take<T>() -> ~T {\n         cast::transmute(RT_TLS_PTR)\n     }\n \n     /// Check whether there is a thread-local pointer installed.\n+    #[inline(never)] // see comments above\n     pub fn exists() -> bool {\n         unsafe {\n             RT_TLS_PTR.is_not_null()\n         }\n     }\n \n+    #[inline(never)] // see comments above\n     pub unsafe fn unsafe_borrow<T>() -> *mut T {\n         if RT_TLS_PTR.is_null() {\n             rtabort!(\"thread-local pointer is null. bogus!\");\n         }\n         RT_TLS_PTR as *mut T\n     }\n \n+    #[inline(never)] // see comments above\n     pub unsafe fn try_unsafe_borrow<T>() -> Option<*mut T> {\n         if RT_TLS_PTR.is_null() {\n             None"}]}