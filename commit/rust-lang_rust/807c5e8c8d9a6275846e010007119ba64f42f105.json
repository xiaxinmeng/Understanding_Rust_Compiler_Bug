{"sha": "807c5e8c8d9a6275846e010007119ba64f42f105", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwN2M1ZThjOGQ5YTYyNzU4NDZlMDEwMDA3MTE5YmE2NGY0MmYxMDU=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-06T21:53:18Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-13T22:03:46Z"}, "message": "librbml: fix fallout", "tree": {"sha": "00115f69241a234c7dff43390ce98c3fb408177a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00115f69241a234c7dff43390ce98c3fb408177a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/807c5e8c8d9a6275846e010007119ba64f42f105", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/807c5e8c8d9a6275846e010007119ba64f42f105", "html_url": "https://github.com/rust-lang/rust/commit/807c5e8c8d9a6275846e010007119ba64f42f105", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/807c5e8c8d9a6275846e010007119ba64f42f105/comments", "author": null, "committer": null, "parents": [{"sha": "a8aff7e95c92bbccd4093ca71e53353912a17024", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8aff7e95c92bbccd4093ca71e53353912a17024", "html_url": "https://github.com/rust-lang/rust/commit/a8aff7e95c92bbccd4093ca71e53353912a17024"}], "stats": {"total": 257, "additions": 133, "deletions": 124}, "files": [{"sha": "ef59b4742faf8c1c4c33016084f6d2e41e4e182c", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 133, "deletions": 124, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/807c5e8c8d9a6275846e010007119ba64f42f105/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/807c5e8c8d9a6275846e010007119ba64f42f105/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=807c5e8c8d9a6275846e010007119ba64f42f105", "patch": "@@ -25,6 +25,7 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![allow(unknown_features)]\n #![feature(macro_rules, phase, slicing_syntax, globs)]\n+#![feature(unboxed_closures)]\n #![allow(missing_docs)]\n \n extern crate serialize;\n@@ -378,8 +379,9 @@ pub mod reader {\n             Ok(r_doc)\n         }\n \n-        fn push_doc<T>(&mut self, exp_tag: EbmlEncoderTag,\n-                       f: |&mut Decoder<'doc>| -> DecodeResult<T>) -> DecodeResult<T> {\n+        fn push_doc<T, F>(&mut self, exp_tag: EbmlEncoderTag, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n             let d = try!(self.next_doc(exp_tag));\n             let old_parent = self.parent;\n             let old_pos = self.pos;\n@@ -471,9 +473,9 @@ pub mod reader {\n         }\n \n         // Compound types:\n-        fn read_enum<T>(&mut self,\n-                        name: &str,\n-                        f: |&mut Decoder<'doc>| -> DecodeResult<T>) -> DecodeResult<T> {\n+        fn read_enum<T, F>(&mut self, name: &str, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n             debug!(\"read_enum({})\", name);\n             try!(self._check_label(name));\n \n@@ -490,10 +492,9 @@ pub mod reader {\n             Ok(result)\n         }\n \n-        fn read_enum_variant<T>(&mut self,\n-                                _: &[&str],\n-                                f: |&mut Decoder<'doc>, uint| -> DecodeResult<T>)\n-                                -> DecodeResult<T> {\n+        fn read_enum_variant<T, F>(&mut self, _: &[&str], f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n+        {\n             debug!(\"read_enum_variant()\");\n             let idx = try!(self._next_uint(EsEnumVid));\n             debug!(\"  idx={}\", idx);\n@@ -511,17 +512,16 @@ pub mod reader {\n             Ok(result)\n         }\n \n-        fn read_enum_variant_arg<T>(&mut self,\n-                                    idx: uint,\n-                                    f: |&mut Decoder<'doc>| -> DecodeResult<T>) -> DecodeResult<T> {\n+        fn read_enum_variant_arg<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n             debug!(\"read_enum_variant_arg(idx={})\", idx);\n             f(self)\n         }\n \n-        fn read_enum_struct_variant<T>(&mut self,\n-                                       _: &[&str],\n-                                       f: |&mut Decoder<'doc>, uint| -> DecodeResult<T>)\n-                                       -> DecodeResult<T> {\n+        fn read_enum_struct_variant<T, F>(&mut self, _: &[&str], f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n+        {\n             debug!(\"read_enum_struct_variant()\");\n             let idx = try!(self._next_uint(EsEnumVid));\n             debug!(\"  idx={}\", idx);\n@@ -539,39 +539,37 @@ pub mod reader {\n             Ok(result)\n         }\n \n-        fn read_enum_struct_variant_field<T>(&mut self,\n-                                             name: &str,\n-                                             idx: uint,\n-                                             f: |&mut Decoder<'doc>| -> DecodeResult<T>)\n-                                             -> DecodeResult<T> {\n-            debug!(\"read_enum_struct_variant_arg(name={}, idx={})\", name, idx);\n+        fn read_enum_struct_variant_field<T, F>(&mut self,\n+                                                name: &str,\n+                                                idx: uint,\n+                                                f: F)\n+                                                -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n+                debug!(\"read_enum_struct_variant_arg(name={}, idx={})\", name, idx);\n             f(self)\n         }\n \n-        fn read_struct<T>(&mut self,\n-                          name: &str,\n-                          _: uint,\n-                          f: |&mut Decoder<'doc>| -> DecodeResult<T>)\n-                          -> DecodeResult<T> {\n+        fn read_struct<T, F>(&mut self, name: &str, _: uint, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n             debug!(\"read_struct(name={})\", name);\n             f(self)\n         }\n \n-        fn read_struct_field<T>(&mut self,\n-                                name: &str,\n-                                idx: uint,\n-                                f: |&mut Decoder<'doc>| -> DecodeResult<T>)\n-                                -> DecodeResult<T> {\n+        fn read_struct_field<T, F>(&mut self, name: &str, idx: uint, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n             debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n             try!(self._check_label(name));\n             f(self)\n         }\n \n-        fn read_tuple<T>(&mut self,\n-                         tuple_len: uint,\n-                         f: |&mut Decoder<'doc>| -> DecodeResult<T>) -> DecodeResult<T> {\n+        fn read_tuple<T, F>(&mut self, tuple_len: uint, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n             debug!(\"read_tuple()\");\n-            self.read_seq(|d, len| {\n+            self.read_seq(move |d, len| {\n                 if len == tuple_len {\n                     f(d)\n                 } else {\n@@ -581,34 +579,36 @@ pub mod reader {\n             })\n         }\n \n-        fn read_tuple_arg<T>(&mut self, idx: uint, f: |&mut Decoder<'doc>| -> DecodeResult<T>)\n-                             -> DecodeResult<T> {\n+        fn read_tuple_arg<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n             debug!(\"read_tuple_arg(idx={})\", idx);\n             self.read_seq_elt(idx, f)\n         }\n \n-        fn read_tuple_struct<T>(&mut self,\n-                                name: &str,\n-                                len: uint,\n-                                f: |&mut Decoder<'doc>| -> DecodeResult<T>)\n-                                -> DecodeResult<T> {\n+        fn read_tuple_struct<T, F>(&mut self, name: &str, len: uint, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n             debug!(\"read_tuple_struct(name={})\", name);\n             self.read_tuple(len, f)\n         }\n \n-        fn read_tuple_struct_arg<T>(&mut self,\n-                                    idx: uint,\n-                                    f: |&mut Decoder<'doc>| -> DecodeResult<T>)\n-                                    -> DecodeResult<T> {\n+        fn read_tuple_struct_arg<T, F>(&mut self,\n+                                       idx: uint,\n+                                       f: F)\n+                                       -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n             debug!(\"read_tuple_struct_arg(idx={})\", idx);\n             self.read_tuple_arg(idx, f)\n         }\n \n-        fn read_option<T>(&mut self,\n-                          f: |&mut Decoder<'doc>, bool| -> DecodeResult<T>) -> DecodeResult<T> {\n+        fn read_option<T, F>(&mut self, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>, bool) -> DecodeResult<T>,\n+        {\n             debug!(\"read_option()\");\n-            self.read_enum(\"Option\", |this| {\n-                this.read_enum_variant(&[\"None\", \"Some\"], |this, idx| {\n+            self.read_enum(\"Option\", move |this| {\n+                this.read_enum_variant(&[\"None\", \"Some\"], move |this, idx| {\n                     match idx {\n                         0 => f(this, false),\n                         1 => f(this, true),\n@@ -620,40 +620,45 @@ pub mod reader {\n             })\n         }\n \n-        fn read_seq<T>(&mut self,\n-                       f: |&mut Decoder<'doc>, uint| -> DecodeResult<T>) -> DecodeResult<T> {\n+        fn read_seq<T, F>(&mut self, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n+        {\n             debug!(\"read_seq()\");\n-            self.push_doc(EsVec, |d| {\n+            self.push_doc(EsVec, move |d| {\n                 let len = try!(d._next_uint(EsVecLen));\n                 debug!(\"  len={}\", len);\n                 f(d, len)\n             })\n         }\n \n-        fn read_seq_elt<T>(&mut self, idx: uint, f: |&mut Decoder<'doc>| -> DecodeResult<T>)\n-                           -> DecodeResult<T> {\n+        fn read_seq_elt<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n             debug!(\"read_seq_elt(idx={})\", idx);\n             self.push_doc(EsVecElt, f)\n         }\n \n-        fn read_map<T>(&mut self,\n-                       f: |&mut Decoder<'doc>, uint| -> DecodeResult<T>) -> DecodeResult<T> {\n+        fn read_map<T, F>(&mut self, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n+        {\n             debug!(\"read_map()\");\n-            self.push_doc(EsMap, |d| {\n+            self.push_doc(EsMap, move |d| {\n                 let len = try!(d._next_uint(EsMapLen));\n                 debug!(\"  len={}\", len);\n                 f(d, len)\n             })\n         }\n \n-        fn read_map_elt_key<T>(&mut self, idx: uint, f: |&mut Decoder<'doc>| -> DecodeResult<T>)\n-                               -> DecodeResult<T> {\n+        fn read_map_elt_key<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n             debug!(\"read_map_elt_key(idx={})\", idx);\n             self.push_doc(EsMapKey, f)\n         }\n \n-        fn read_map_elt_val<T>(&mut self, idx: uint, f: |&mut Decoder<'doc>| -> DecodeResult<T>)\n-                               -> DecodeResult<T> {\n+        fn read_map_elt_val<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n             debug!(\"read_map_elt_val(idx={})\", idx);\n             self.push_doc(EsMapVal, f)\n         }\n@@ -916,140 +921,144 @@ pub mod writer {\n             self.wr_tagged_str(EsStr as uint, v)\n         }\n \n-        fn emit_enum(&mut self,\n-                     name: &str,\n-                     f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_enum<F>(&mut self, name: &str, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n             try!(self._emit_label(name));\n             try!(self.start_tag(EsEnum as uint));\n             try!(f(self));\n             self.end_tag()\n         }\n \n-        fn emit_enum_variant(&mut self,\n-                             _: &str,\n-                             v_id: uint,\n-                             _: uint,\n-                             f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_enum_variant<F>(&mut self,\n+                                _: &str,\n+                                v_id: uint,\n+                                _: uint,\n+                                f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n             try!(self._emit_tagged_uint(EsEnumVid, v_id));\n             try!(self.start_tag(EsEnumBody as uint));\n             try!(f(self));\n             self.end_tag()\n         }\n \n-        fn emit_enum_variant_arg(&mut self,\n-                                 _: uint,\n-                                 f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_enum_variant_arg<F>(&mut self, _: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n             f(self)\n         }\n \n-        fn emit_enum_struct_variant(&mut self,\n-                                    v_name: &str,\n-                                    v_id: uint,\n-                                    cnt: uint,\n-                                    f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_enum_struct_variant<F>(&mut self,\n+                                       v_name: &str,\n+                                       v_id: uint,\n+                                       cnt: uint,\n+                                       f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n             self.emit_enum_variant(v_name, v_id, cnt, f)\n         }\n \n-        fn emit_enum_struct_variant_field(&mut self,\n-                                          _: &str,\n-                                          idx: uint,\n-                                          f: |&mut Encoder<'a, W>| -> EncodeResult)\n-            -> EncodeResult {\n+        fn emit_enum_struct_variant_field<F>(&mut self,\n+                                             _: &str,\n+                                             idx: uint,\n+                                             f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n             self.emit_enum_variant_arg(idx, f)\n         }\n \n-        fn emit_struct(&mut self,\n-                       _: &str,\n-                       _len: uint,\n-                       f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_struct<F>(&mut self, _: &str, _len: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n             f(self)\n         }\n \n-        fn emit_struct_field(&mut self,\n-                             name: &str,\n-                             _: uint,\n-                             f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_struct_field<F>(&mut self, name: &str, _: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n             try!(self._emit_label(name));\n             f(self)\n         }\n \n-        fn emit_tuple(&mut self,\n-                      len: uint,\n-                      f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_tuple<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n             self.emit_seq(len, f)\n         }\n-        fn emit_tuple_arg(&mut self,\n-                          idx: uint,\n-                          f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_tuple_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n             self.emit_seq_elt(idx, f)\n         }\n \n-        fn emit_tuple_struct(&mut self,\n-                             _: &str,\n-                             len: uint,\n-                             f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_tuple_struct<F>(&mut self, _: &str, len: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n             self.emit_seq(len, f)\n         }\n-        fn emit_tuple_struct_arg(&mut self,\n-                                 idx: uint,\n-                                 f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_tuple_struct_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n             self.emit_seq_elt(idx, f)\n         }\n \n-        fn emit_option(&mut self,\n-                       f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_option<F>(&mut self, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n             self.emit_enum(\"Option\", f)\n         }\n         fn emit_option_none(&mut self) -> EncodeResult {\n             self.emit_enum_variant(\"None\", 0, 0, |_| Ok(()))\n         }\n-        fn emit_option_some(&mut self,\n-                            f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_option_some<F>(&mut self, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n \n             self.emit_enum_variant(\"Some\", 1, 1, f)\n         }\n \n-        fn emit_seq(&mut self,\n-                    len: uint,\n-                    f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_seq<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n \n             try!(self.start_tag(EsVec as uint));\n             try!(self._emit_tagged_uint(EsVecLen, len));\n             try!(f(self));\n             self.end_tag()\n         }\n \n-        fn emit_seq_elt(&mut self,\n-                        _idx: uint,\n-                        f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_seq_elt<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n \n             try!(self.start_tag(EsVecElt as uint));\n             try!(f(self));\n             self.end_tag()\n         }\n \n-        fn emit_map(&mut self,\n-                    len: uint,\n-                    f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_map<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n \n             try!(self.start_tag(EsMap as uint));\n             try!(self._emit_tagged_uint(EsMapLen, len));\n             try!(f(self));\n             self.end_tag()\n         }\n \n-        fn emit_map_elt_key(&mut self,\n-                            _idx: uint,\n-                            f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_map_elt_key<F>(&mut self, _idx: uint, mut f: F) -> EncodeResult where\n+            F: FnMut(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n \n             try!(self.start_tag(EsMapKey as uint));\n             try!(f(self));\n             self.end_tag()\n         }\n \n-        fn emit_map_elt_val(&mut self,\n-                            _idx: uint,\n-                            f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_map_elt_val<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n             try!(self.start_tag(EsMapVal as uint));\n             try!(f(self));\n             self.end_tag()"}]}