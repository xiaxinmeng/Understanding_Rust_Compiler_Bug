{"sha": "57891067374a4cf3fff8c2be4bd0804cb4ef7fbe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3ODkxMDY3Mzc0YTRjZjNmZmY4YzJiZTRiZDA4MDRjYjRlZjdmYmU=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-28T20:20:36Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-28T20:20:36Z"}, "message": "many many pnkfelix fixes", "tree": {"sha": "52bd3bc473825afb6823984d3a981ffcf247882f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52bd3bc473825afb6823984d3a981ffcf247882f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57891067374a4cf3fff8c2be4bd0804cb4ef7fbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57891067374a4cf3fff8c2be4bd0804cb4ef7fbe", "html_url": "https://github.com/rust-lang/rust/commit/57891067374a4cf3fff8c2be4bd0804cb4ef7fbe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57891067374a4cf3fff8c2be4bd0804cb4ef7fbe/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05bb1dbc43a620fbbd65ae830bb53ba9768ac185", "url": "https://api.github.com/repos/rust-lang/rust/commits/05bb1dbc43a620fbbd65ae830bb53ba9768ac185", "html_url": "https://github.com/rust-lang/rust/commit/05bb1dbc43a620fbbd65ae830bb53ba9768ac185"}], "stats": {"total": 326, "additions": 200, "deletions": 126}, "files": [{"sha": "d75d12e716e3158bb2112366aab8604c9d3a17f0", "filename": "src/doc/tarpl/exotic-sizes.md", "status": "modified", "additions": 49, "deletions": 30, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/57891067374a4cf3fff8c2be4bd0804cb4ef7fbe/src%2Fdoc%2Ftarpl%2Fexotic-sizes.md", "raw_url": "https://github.com/rust-lang/rust/raw/57891067374a4cf3fff8c2be4bd0804cb4ef7fbe/src%2Fdoc%2Ftarpl%2Fexotic-sizes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fexotic-sizes.md?ref=57891067374a4cf3fff8c2be4bd0804cb4ef7fbe", "patch": "@@ -9,19 +9,24 @@ is not always the case, however.\n \n # Dynamically Sized Types (DSTs)\n \n-Rust also supports types without a statically known size. On the surface, this\n-is a bit nonsensical: Rust *must* know the size of something in order to work\n-with it! DSTs are generally produced as views, or through type-erasure of types\n-that *do* have a known size. Due to their lack of a statically known size, these\n-types can only exist *behind* some kind of pointer. They consequently produce a\n-*fat* pointer consisting of the pointer and the information that *completes*\n-them.\n-\n-For instance, the slice type, `[T]`, is some statically unknown number of\n-elements stored contiguously. `&[T]` consequently consists of a `(&T, usize)`\n-pair that specifies where the slice starts, and how many elements it contains.\n-Similarly, Trait Objects support interface-oriented type erasure through a\n-`(data_ptr, vtable_ptr)` pair.\n+Rust in fact supports Dynamically Sized Types (DSTs): types without a statically\n+known size or alignment. On the surface, this is a bit nonsensical: Rust *must*\n+know the size and alignment of something in order to correctly work with it! In\n+this regard, DSTs are not normal types. Due to their lack of a statically known\n+size, these types can only exist behind some kind of pointer. Any pointer to a\n+DST consequently becomes a *fat* pointer consisting of the pointer and the\n+information that \"completes\" them (more on this below).\n+\n+There are two major DSTs exposed by the language: trait objects, and slices.\n+\n+A trait object represents some type that implements the traits it specifies.\n+The exact original type is *erased* in favour of runtime reflection\n+with a vtable containing all the information necessary to use the type.\n+This is the information that completes a trait object: a pointer to its vtable.\n+\n+A slice is simply a view into some contiguous storage -- typically an array or\n+`Vec`. The information that completes a slice is just the number of elements\n+it points to.\n \n Structs can actually store a single DST directly as their last field, but this\n makes them a DST as well:\n@@ -34,8 +39,8 @@ struct Foo {\n }\n ```\n \n-**NOTE: As of Rust 1.0 struct DSTs are broken if the last field has\n-a variable position based on its alignment.**\n+**NOTE: [As of Rust 1.0 struct DSTs are broken if the last field has\n+a variable position based on its alignment][dst-issue].**\n \n \n \n@@ -56,22 +61,32 @@ struct Baz {\n }\n ```\n \n-On their own, ZSTs are, for obvious reasons, pretty useless. However as with\n-many curious layout choices in Rust, their potential is realized in a generic\n-context.\n-\n-Rust largely understands that any operation that produces or stores a ZST can be\n-reduced to a no-op. For instance, a `HashSet<T>` can be effeciently implemented\n-as a thin wrapper around `HashMap<T, ()>` because all the operations `HashMap`\n-normally does to store and retrieve values will be completely stripped in\n-monomorphization.\n-\n-Similarly `Result<(), ()>` and `Option<()>` are effectively just fancy `bool`s.\n+On their own, Zero Sized Types (ZSTs) are, for obvious reasons, pretty useless.\n+However as with many curious layout choices in Rust, their potential is realized\n+in a generic context: Rust largely understands that any operation that  produces\n+or stores a ZST can be reduced to a no-op. First off, storing it  doesn't even\n+make sense -- it doesn't occupy any space. Also there's only one  value of that\n+type, so anything that loads it can just produce it from the  aether -- which is\n+also a no-op since it doesn't occupy any space.\n+\n+One of the most extreme example's of this is Sets and Maps. Given a\n+`Map<Key, Value>`, it is common to implement a `Set<Key>` as just a thin wrapper\n+around `Map<Key, UselessJunk>`. In many languages, this would necessitate\n+allocating space for UselessJunk and doing work to store and load UselessJunk\n+only to discard it. Proving this unnecessary would be a difficult analysis for\n+the compiler.\n+\n+However in Rust, we can just say that  `Set<Key> = Map<Key, ()>`. Now Rust\n+statically knows that every load and store is useless, and no allocation has any\n+size. The result is that the monomorphized code is basically a custom\n+implementation of a HashSet with none of the overhead that HashMap would have to\n+support values.\n \n Safe code need not worry about ZSTs, but *unsafe* code must be careful about the\n consequence of types with no size. In particular, pointer offsets are no-ops,\n-and standard allocators (including jemalloc, the one used by Rust) generally\n-consider passing in `0` as Undefined Behaviour.\n+and standard allocators (including jemalloc, the one used by default in Rust)\n+generally consider passing in `0` for the size of an allocation as Undefined\n+Behaviour.\n \n \n \n@@ -93,11 +108,12 @@ return a Result in general, but a specific case actually is infallible. It's\n actually possible to communicate this at the type level by returning a\n `Result<T, Void>`. Consumers of the API can confidently unwrap such a Result\n knowing that it's *statically impossible* for this value to be an `Err`, as\n-this would require providing a value of type Void.\n+this would require providing a value of type `Void`.\n \n In principle, Rust can do some interesting analyses and optimizations based\n on this fact. For instance, `Result<T, Void>` could be represented as just `T`,\n-because the Err case doesn't actually exist. The following *could* also compile:\n+because the `Err` case doesn't actually exist. The following *could* also\n+compile:\n \n ```rust,ignore\n enum Void {}\n@@ -116,3 +132,6 @@ actually valid to construct, but dereferencing them is Undefined Behaviour\n because that doesn't actually make sense. That is, you could model C's `void *`\n type with `*const Void`, but this doesn't necessarily gain anything over using\n e.g. `*const ()`, which *is* safe to randomly dereference.\n+\n+\n+[dst-issue]: https://github.com/rust-lang/rust/issues/26403"}, {"sha": "a5e3136c54acf10da82c47e24463c3178907c1ec", "filename": "src/doc/tarpl/meet-safe-and-unsafe.md", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/57891067374a4cf3fff8c2be4bd0804cb4ef7fbe/src%2Fdoc%2Ftarpl%2Fmeet-safe-and-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/57891067374a4cf3fff8c2be4bd0804cb4ef7fbe/src%2Fdoc%2Ftarpl%2Fmeet-safe-and-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fmeet-safe-and-unsafe.md?ref=57891067374a4cf3fff8c2be4bd0804cb4ef7fbe", "patch": "@@ -2,7 +2,7 @@\n \n Programmers in safe \"high-level\" languages face a fundamental dilemma. On one\n hand, it would be *really* great to just say what you want and not worry about\n-how it's done. On the other hand, that can lead to some *really* poor\n+how it's done. On the other hand, that can lead to unacceptably poor\n performance. It may be necessary to drop down to less clear or idiomatic\n practices to get the performance characteristics you want. Or maybe you just\n throw up your hands in disgust and decide to shell out to an implementation in\n@@ -12,21 +12,22 @@ Worse, when you want to talk directly to the operating system, you *have* to\n talk to an unsafe language: *C*. C is ever-present and unavoidable. It's the\n lingua-franca of the programming world.\n Even other safe languages generally expose C interfaces for the world at large!\n-Regardless of *why* you're doing it, as soon as your program starts talking to\n+Regardless of why you're doing it, as soon as your program starts talking to\n C it stops being safe.\n \n With that said, Rust is *totally* a safe programming language.\n \n Well, Rust *has* a safe programming language. Let's step back a bit.\n \n-Rust can be thought of as being composed of two\n-programming languages: *Safe* and *Unsafe*. Safe is For Reals Totally Safe.\n-Unsafe, unsurprisingly, is *not* For Reals Totally Safe. In fact, Unsafe lets\n-you do some really crazy unsafe things.\n+Rust can be thought of as being composed of two programming languages: *Safe\n+Rust* and *Unsafe Rust*. Safe Rust is For Reals  Totally Safe. Unsafe Rust,\n+unsurprisingly, is *not* For Reals Totally Safe.  In fact, Unsafe Rust lets you\n+do some really crazy unsafe things.\n \n-Safe is *the* Rust programming language. If all you do is write Safe Rust,\n-you will never have to worry about type-safety or memory-safety. You will never\n-endure a null or dangling pointer, or any of that Undefined Behaviour nonsense.\n+Safe Rust is the *true* Rust programming language. If all you do is write Safe\n+Rust, you will never have to worry about type-safety or memory-safety. You will\n+never endure a null or dangling pointer, or any of that Undefined Behaviour\n+nonsense.\n \n *That's totally awesome*.\n \n@@ -69,17 +70,16 @@ language cares about is preventing the following things:\n     * A non-utf8 `str`\n * Unwinding into another language\n * Causing a [data race][race]\n-* Double-dropping a value\n \n-That's it. That's all the Undefined Behaviour baked into Rust. Of course, unsafe\n-functions and traits are free to declare arbitrary other constraints that a\n-program must maintain to avoid Undefined Behaviour. However these are generally\n-just things that will transitively lead to one of the above problems. Some\n-additional constraints may also derive from compiler intrinsics that make special\n-assumptions about how code can be optimized.\n+That's it. That's all the causes of Undefined Behaviour baked into Rust. Of\n+course, unsafe functions and traits are free to declare arbitrary other\n+constraints that a program must maintain to avoid Undefined Behaviour. However,\n+generally violations of these constraints will just transitively lead to one of\n+the above problems. Some additional constraints may also derive from compiler\n+intrinsics that make special assumptions about how code can be optimized.\n \n-Rust is otherwise quite permissive with respect to other dubious operations. Rust\n-considers it \"safe\" to:\n+Rust is otherwise quite permissive with respect to other dubious operations.\n+Rust considers it \"safe\" to:\n \n * Deadlock\n * Have a [race condition][race]"}, {"sha": "93ef2c13cdf8c5de5b2ad459b9aa0cfc9313b786", "filename": "src/doc/tarpl/other-reprs.md", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/57891067374a4cf3fff8c2be4bd0804cb4ef7fbe/src%2Fdoc%2Ftarpl%2Fother-reprs.md", "raw_url": "https://github.com/rust-lang/rust/raw/57891067374a4cf3fff8c2be4bd0804cb4ef7fbe/src%2Fdoc%2Ftarpl%2Fother-reprs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fother-reprs.md?ref=57891067374a4cf3fff8c2be4bd0804cb4ef7fbe", "patch": "@@ -12,21 +12,21 @@ The order, size, and alignment of fields is exactly what you would expect from C\n or C++. Any type you expect to pass through an FFI boundary should have\n `repr(C)`, as C is the lingua-franca of the programming world. This is also\n necessary to soundly do more elaborate tricks with data layout such as\n-reintepretting values as a different type.\n+reinterpreting values as a different type.\n \n However, the interaction with Rust's more exotic data layout features must be\n kept in mind. Due to its dual purpose as \"for FFI\" and \"for layout control\",\n `repr(C)` can be applied to types that will be nonsensical or problematic if\n passed through the FFI boundary.\n \n-* ZSTs are still zero-sized, even though this is not a standard behaviour   in\n+* ZSTs are still zero-sized, even though this is not a standard behaviour in\n C, and is explicitly contrary to the behaviour of an empty type in C++, which\n still consumes a byte of space.\n \n * DSTs, tuples, and tagged unions are not a concept in C and as such are never\n FFI safe.\n \n-* **The [drop flag][] will still be added**\n+* **If the type would have any [drop flags][], they will still be added**\n \n * This is equivalent to one of `repr(u*)` (see the next section) for enums. The\n chosen size is the default enum size for the target platform's C ABI. Note that\n@@ -39,10 +39,10 @@ compiled with certain flags.\n # repr(u8), repr(u16), repr(u32), repr(u64)\n \n These specify the size to make a C-like enum. If the discriminant overflows the\n-integer it has to fit in, it will be an error. You can manually ask Rust to\n-allow this by setting the overflowing element to explicitly be 0. However Rust\n-will not allow you to create an enum where two variants have the same\n-discriminant.\n+integer it has to fit in, it will produce a compile-time error. You can manually\n+ask Rust to allow this by setting the overflowing element to explicitly be 0.\n+However Rust will not allow you to create an enum where two variants have the\n+same discriminant.\n \n On non-C-like enums, this will inhibit certain optimizations like the null-\n pointer optimization.\n@@ -65,9 +65,12 @@ compiler might be able to paper over alignment issues with shifts and masks.\n However if you take a reference to a packed field, it's unlikely that the\n compiler will be able to emit code to avoid an unaligned load.\n \n+**[As of Rust 1.0 this can cause undefined behaviour.][ub loads]**\n+\n `repr(packed)` is not to be used lightly. Unless you have extreme requirements,\n this should not be used.\n \n This repr is a modifier on `repr(C)` and `repr(rust)`.\n \n-[drop flag]: drop-flags.html\n+[drop flags]: drop-flags.html\n+[ub loads]: https://github.com/rust-lang/rust/issues/27060"}, {"sha": "f79cd92479f0b1e61800d4cb2c8cb28c1c451afb", "filename": "src/doc/tarpl/ownership.md", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/57891067374a4cf3fff8c2be4bd0804cb4ef7fbe/src%2Fdoc%2Ftarpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/57891067374a4cf3fff8c2be4bd0804cb4ef7fbe/src%2Fdoc%2Ftarpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fownership.md?ref=57891067374a4cf3fff8c2be4bd0804cb4ef7fbe", "patch": "@@ -5,16 +5,17 @@ memory-safe and efficient, while avoiding garbage collection. Before getting\n into the ownership system in detail, we will consider the motivation of this\n design.\n \n-We will assume that you accept that garbage collection is not always an optimal\n-solution, and that it is desirable to manually manage memory to some extent.\n-If you do not accept this, might I interest you in a different language?\n+We will assume that you accept that garbage collection (GC) is not always an\n+optimal solution, and that it is desirable to manually manage memory in some\n+contexts. If you do not accept this, might I interest you in a different\n+language?\n \n Regardless of your feelings on GC, it is pretty clearly a *massive* boon to\n making code safe. You never have to worry about things going away *too soon*\n (although whether you still *wanted* to be pointing at that thing is a different\n-issue...). This is a pervasive problem that C and C++ need to deal with.\n-Consider this simple mistake that all of us who have used a non-GC'd language\n-have made at one point:\n+issue...). This is a pervasive problem that C and C++ programs need to deal\n+with. Consider this simple mistake that all of us who have used a non-GC'd\n+language have made at one point:\n \n ```rust,ignore\n fn as_str(data: &u32) -> &str {\n@@ -40,7 +41,7 @@ be forced to accept your program on the assumption that it is correct.\n This will never happen to Rust. It's up to the programmer to prove to the\n compiler that everything is sound.\n \n-Of course, rust's story around ownership is much more complicated than just\n+Of course, Rust's story around ownership is much more complicated than just\n verifying that references don't escape the scope of their referent. That's\n because ensuring pointers are always valid is much more complicated than this.\n For instance in this code,"}, {"sha": "639d64adc18b8dae273e9960cbe67606c9f5bf6b", "filename": "src/doc/tarpl/repr-rust.md", "status": "modified", "additions": 54, "deletions": 30, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/57891067374a4cf3fff8c2be4bd0804cb4ef7fbe/src%2Fdoc%2Ftarpl%2Frepr-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/57891067374a4cf3fff8c2be4bd0804cb4ef7fbe/src%2Fdoc%2Ftarpl%2Frepr-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Frepr-rust.md?ref=57891067374a4cf3fff8c2be4bd0804cb4ef7fbe", "patch": "@@ -1,5 +1,19 @@\n % repr(Rust)\n \n+First and foremost, all types have an alignment specified in bytes. The\n+alignment of a type specifies what addresses are valid to store the value at. A\n+value of alignment `n` must only be stored at an address that is a multiple of\n+`n`. So alignment 2 means you must be stored at an even address, and 1 means\n+that you can be stored anywhere. Alignment is at least 1, and always a power of\n+2. Most primitives are generally aligned to their size, although this is\n+platform-specific behaviour. In particular, on x86 `u64` and `f64` may be only\n+aligned to 32 bits.\n+\n+A type's size must always be a multiple of its alignment. This ensures that an\n+array of that type may always be indexed by offsetting by a multiple of its\n+size. Note that the size and alignment of a type may not be known\n+statically in the case of [dynamically sized types][dst].\n+\n Rust gives you the following ways to lay out composite data:\n \n * structs (named product types)\n@@ -9,17 +23,10 @@ Rust gives you the following ways to lay out composite data:\n \n An enum is said to be *C-like* if none of its variants have associated data.\n \n-For all these, individual fields are aligned to their preferred alignment. For\n-primitives this is usually equal to their size. For instance, a u32 will be\n-aligned to a multiple of 32 bits, and a u16 will be aligned to a multiple of 16\n-bits. Note that some primitives may be emulated on different platforms, and as\n-such may have strange alignment. For instance, a u64 on x86 may actually be\n-emulated as a pair of u32s, and thus only have 32-bit alignment.\n-\n-Composite structures will have a preferred alignment equal to the maximum\n-of their fields' preferred alignment, and a size equal to a multiple of their\n-preferred alignment. This ensures that arrays of T can be correctly iterated\n-by offsetting by their size. So for instance,\n+Composite structures will have an alignment equal to the maximum\n+of their fields' alignment. Rust will consequently insert padding where\n+necessary to ensure that all fields are properly aligned and that the overall\n+type's size is a multiple of its alignment. For instance:\n \n ```rust\n struct A {\n@@ -29,12 +36,24 @@ struct A {\n }\n ```\n \n-will have a size that is a multiple of 32-bits, and 32-bit alignment.\n+will be 32-bit aligned assuming these primitives are aligned to their size.\n+It will therefore have a size that is a multiple of 32-bits. It will potentially\n+*really* become:\n \n-There is *no indirection* for these types; all data is stored contiguously as you would\n-expect in C. However with the exception of arrays (which are densely packed and\n-in-order), the layout of data is not by default specified in Rust. Given the two\n-following struct definitions:\n+```rust\n+struct A {\n+    a: u8,\n+    _pad1: [u8; 3], // to align `b`\n+    b: u32,\n+    c: u16,\n+    _pad2: [u8; 2], // to make overall size multiple of 4\n+}\n+```\n+\n+There is *no indirection* for these types; all data is stored contiguously as\n+you would expect in C. However with the exception of arrays (which are densely\n+packed and in-order), the layout of data is not by default specified in Rust.\n+Given the two following struct definitions:\n \n ```rust\n struct A {\n@@ -48,13 +67,15 @@ struct B {\n }\n ```\n \n-Rust *does* guarantee that two instances of A have their data laid out in exactly\n-the same way. However Rust *does not* guarantee that an instance of A has the same\n-field ordering or padding as an instance of B (in practice there's no *particular*\n-reason why they wouldn't, other than that its not currently guaranteed).\n+Rust *does* guarantee that two instances of A have their data laid out in\n+exactly the same way. However Rust *does not* guarantee that an instance of A\n+has the same field ordering or padding as an instance of B (in practice there's\n+no *particular* reason why they wouldn't, other than that its not currently\n+guaranteed).\n \n-With A and B as written, this is basically nonsensical, but several other features\n-of Rust make it desirable for the language to play with data layout in complex ways.\n+With A and B as written, this is basically nonsensical, but several other\n+features of Rust make it desirable for the language to play with data layout in\n+complex ways.\n \n For instance, consider this struct:\n \n@@ -66,10 +87,10 @@ struct Foo<T, U> {\n }\n ```\n \n-Now consider the monomorphizations of `Foo<u32, u16>` and `Foo<u16, u32>`. If Rust lays out the\n-fields in the order specified, we expect it to *pad* the values in the struct to satisfy\n-their *alignment* requirements. So if Rust didn't reorder fields, we would expect Rust to\n-produce the following:\n+Now consider the monomorphizations of `Foo<u32, u16>` and `Foo<u16, u32>`. If\n+Rust lays out the fields in the order specified, we expect it to *pad* the\n+values in the struct to satisfy their *alignment* requirements. So if Rust\n+didn't reorder fields, we would expect Rust to produce the following:\n \n ```rust,ignore\n struct Foo<u16, u32> {\n@@ -87,10 +108,11 @@ struct Foo<u32, u16> {\n }\n ```\n \n-The latter case quite simply wastes space. An optimal use of space therefore requires\n-different monomorphizations to have *different field orderings*.\n+The latter case quite simply wastes space. An optimal use of space therefore\n+requires different monomorphizations to have *different field orderings*.\n \n-**Note: this is a hypothetical optimization that is not yet implemented in Rust 1.0**\n+**Note: this is a hypothetical optimization that is not yet implemented in Rust\n+**1.0\n \n Enums make this consideration even more complicated. Naively, an enum such as:\n \n@@ -121,8 +143,10 @@ by using null as a special value. The net result is that\n \n There are many types in Rust that are, or contain, \"not null\" pointers such as\n `Box<T>`, `Vec<T>`, `String`, `&T`, and `&mut T`. Similarly, one can imagine\n-nested enums pooling their tags into a single descriminant, as they are by\n+nested enums pooling their tags into a single discriminant, as they are by\n definition known to have a limited range of valid values. In principle enums can\n use fairly elaborate algorithms to cache bits throughout nested types with\n special constrained representations. As such it is *especially* desirable that\n we leave enum layout unspecified today.\n+\n+[dst]: exotic-sizes.html#dynamically-sized-types-(dsts)"}, {"sha": "c7210f8e2cf9849bffd4c7239efd3cb90b103841", "filename": "src/doc/tarpl/safe-unsafe-meaning.md", "status": "modified", "additions": 37, "deletions": 19, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/57891067374a4cf3fff8c2be4bd0804cb4ef7fbe/src%2Fdoc%2Ftarpl%2Fsafe-unsafe-meaning.md", "raw_url": "https://github.com/rust-lang/rust/raw/57891067374a4cf3fff8c2be4bd0804cb4ef7fbe/src%2Fdoc%2Ftarpl%2Fsafe-unsafe-meaning.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fsafe-unsafe-meaning.md?ref=57891067374a4cf3fff8c2be4bd0804cb4ef7fbe", "patch": "@@ -1,29 +1,30 @@\n % How Safe and Unsafe Interact\n \n-So what's the relationship between Safe and Unsafe? How do they interact?\n+So what's the relationship between Safe and Unsafe Rust? How do they interact?\n \n-Rust models the seperation between Safe and Unsafe with the `unsafe` keyword, which\n-can be thought as a sort of *foreign function interface* (FFI) between Safe and Unsafe.\n-This is the magic behind why we can say Safe is a safe language: all the scary unsafe\n-bits are relagated *exclusively* to FFI *just like every other safe language*.\n+Rust models the separation between Safe and Unsafe Rust with the `unsafe`\n+keyword, which can be thought as a sort of *foreign function interface* (FFI)\n+between Safe and Unsafe Rust. This is the magic behind why we can say Safe Rust\n+is a safe language: all the scary unsafe bits are relegated *exclusively* to FFI\n+*just like every other safe language*.\n \n However because one language is a subset of the other, the two can be cleanly\n-intermixed as long as the boundary between Safe and Unsafe is denoted with the\n-`unsafe` keyword. No need to write headers, initialize runtimes, or any of that\n-other FFI boiler-plate.\n+intermixed as long as the boundary between Safe and Unsafe Rust is denoted with\n+the `unsafe` keyword. No need to write headers, initialize runtimes, or any of\n+that other FFI boiler-plate.\n \n There are several places `unsafe` can appear in Rust today, which can largely be\n grouped into two categories:\n \n * There are unchecked contracts here. To declare you understand this, I require\n you to write `unsafe` elsewhere:\n-    * On functions, `unsafe` is declaring the function to be unsafe to call. Users\n-      of the function must check the documentation to determine what this means,\n-      and then have to write `unsafe` somewhere to identify that they're aware of\n-      the danger.\n+    * On functions, `unsafe` is declaring the function to be unsafe to call.\n+      Users of the function must check the documentation to determine what this\n+      means, and then have to write `unsafe` somewhere to identify that they're\n+      aware of the danger.\n     * On trait declarations, `unsafe` is declaring that *implementing* the trait\n-      is an unsafe operation, as it has contracts that other unsafe code is free to\n-      trust blindly. (More on this below.)\n+      is an unsafe operation, as it has contracts that other unsafe code is free\n+      to trust blindly. (More on this below.)\n \n * I am declaring that I have, to the best of my knowledge, adhered to the\n unchecked contracts:\n@@ -64,9 +65,9 @@ This means that Unsafe, **the royal vanguard of Undefined Behaviour**, has to be\n *super paranoid* about generic safe code. Unsafe is free to trust *specific* safe\n code (or else you would degenerate into infinite spirals of paranoid despair).\n It is generally regarded as ok to trust the standard library to be correct, as\n-std is effectively an extension of the language (and you *really* just have to trust\n-the language). If `std` fails to uphold the guarantees it declares, then it's\n-basically a language bug.\n+`std` is effectively an extension of the language (and you *really* just have\n+to trust the language). If `std` fails to uphold the guarantees it declares,\n+then it's basically a language bug.\n \n That said, it would be best to minimize *needlessly* relying on properties of\n concrete safe code. Bugs happen! Of course, I must reinforce that this is only\n@@ -89,7 +90,7 @@ Ord for a type, but don't actually provide a proper total ordering, BTreeMap wil\n get *really confused* and start making a total mess of itself. Data that is\n inserted may be impossible to find!\n \n-But that's ok. BTreeMap is safe, so it guarantees that even if you give it a\n+But that's okay. BTreeMap is safe, so it guarantees that even if you give it a\n *completely* garbage Ord implementation, it will still do something *safe*. You\n won't start reading uninitialized memory or unallocated memory. In fact, BTreeMap\n manages to not actually lose any of your data. When the map is dropped, all the\n@@ -104,7 +105,24 @@ Safe's responsibility to uphold.\n But wouldn't it be grand if there was some way for Unsafe to trust *some* trait\n contracts *somewhere*? This is the problem that unsafe traits tackle: by marking\n *the trait itself* as unsafe *to implement*, Unsafe can trust the implementation\n-to be correct.\n+to uphold the trait's contract. Although the trait implementation may be\n+incorrect in arbitrary other ways.\n+\n+For instance, given a hypothetical UnsafeOrd trait, this is technically a valid\n+implementation:\n+\n+```rust\n+# use std::cmp::Ordering;\n+# struct MyType;\n+# pub unsafe trait UnsafeOrd { fn cmp(&self, other: &Self) -> Ordering; }\n+unsafe impl UnsafeOrd for MyType {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        Ordering::Equal\n+    }\n+}\n+```\n+\n+But it's probably not the implementation you want.\n \n Rust has traditionally avoided making traits unsafe because it makes Unsafe\n pervasive, which is not desirable. Send and Sync are unsafe is because"}, {"sha": "b20dff72e1c6a38cac2f391f648e6bfb2793c4da", "filename": "src/doc/tarpl/working-with-unsafe.md", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/57891067374a4cf3fff8c2be4bd0804cb4ef7fbe/src%2Fdoc%2Ftarpl%2Fworking-with-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/57891067374a4cf3fff8c2be4bd0804cb4ef7fbe/src%2Fdoc%2Ftarpl%2Fworking-with-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fworking-with-unsafe.md?ref=57891067374a4cf3fff8c2be4bd0804cb4ef7fbe", "patch": "@@ -1,8 +1,8 @@\n % Working with Unsafe\n \n-Rust generally only gives us the tools to talk about Unsafe in a scoped and\n-binary manner. Unfortunately, reality is significantly more complicated than that.\n-For instance, consider the following toy function:\n+Rust generally only gives us the tools to talk about Unsafe Rust in a scoped and\n+binary manner. Unfortunately, reality is significantly more complicated than\n+that. For instance, consider the following toy function:\n \n ```rust\n fn index(idx: usize, arr: &[u8]) -> Option<u8> {\n@@ -35,10 +35,15 @@ fn index(idx: usize, arr: &[u8]) -> Option<u8> {\n \n This program is now unsound, and yet *we only modified safe code*. This is the\n fundamental problem of safety: it's non-local. The soundness of our unsafe\n-operations necessarily depends on the state established by \"safe\" operations.\n-Although safety *is* modular (we *still* don't need to worry about about\n-unrelated safety issues like uninitialized memory), it quickly contaminates the\n-surrounding code.\n+operations necessarily depends on the state established by otherwise\n+\"safe\" operations.\n+\n+Safety is modular in the sense that opting into unsafety doesn't require you\n+to consider arbitrary other kinds of badness. For instance, doing an unchecked\n+index into a slice doesn't mean you suddenly need to worry about the slice being\n+null or containing uninitialized memory. Nothing fundamentally changes. However\n+safety *isn't* modular in the sense that programs are inherently stateful and\n+your unsafe operations may depend on arbitrary other state.\n \n Trickier than that is when we get into actual statefulness. Consider a simple\n implementation of `Vec`:\n@@ -84,10 +89,10 @@ fn make_room(&mut self) {\n }\n ```\n \n-This code is safe, but it is also completely unsound. Changing the capacity\n-violates the invariants of Vec (that `cap` reflects the allocated space in the\n-Vec). This is not something the rest of Vec can guard against. It *has* to\n-trust the capacity field because there's no way to verify it.\n+This code is 100% Safe Rust but it is also completely unsound. Changing the\n+capacity violates the invariants of Vec (that `cap` reflects the allocated space\n+in the Vec). This is not something the rest of Vec can guard against. It *has*\n+to trust the capacity field because there's no way to verify it.\n \n `unsafe` does more than pollute a whole function: it pollutes a whole *module*.\n Generally, the only bullet-proof way to limit the scope of unsafe code is at the\n@@ -102,9 +107,13 @@ as Vec.\n It is therefore possible for us to write a completely safe abstraction that\n relies on complex invariants. This is *critical* to the relationship between\n Safe Rust and Unsafe Rust. We have already seen that Unsafe code must trust\n-*some* Safe code, but can't trust *arbitrary* Safe code. However if Unsafe\n-couldn't prevent client Safe code from messing with its state in arbitrary ways,\n-safety would be a lost cause.\n+*some* Safe code, but can't trust *generic* Safe code. It can't trust an\n+arbitrary implementor of a trait or any function that was passed to it to be\n+well-behaved in a way that safe code doesn't care about.\n+\n+However if unsafe code couldn't prevent client safe code from messing with its\n+state in arbitrary ways, safety would be a lost cause. Thankfully, it *can*\n+prevent arbitrary code from messing with critical state due to privacy.\n \n Safety lives!\n "}]}