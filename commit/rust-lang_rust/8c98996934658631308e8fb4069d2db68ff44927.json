{"sha": "8c98996934658631308e8fb4069d2db68ff44927", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjOTg5OTY5MzQ2NTg2MzEzMDhlOGZiNDA2OWQyZGI2OGZmNDQ5Mjc=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-03-01T23:48:16Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-03-10T16:08:32Z"}, "message": "Avoid using `Mark` and `Invocation` for macro defs.", "tree": {"sha": "36fe4e73db38f0582b4b508175ddbf5435624f88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36fe4e73db38f0582b4b508175ddbf5435624f88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c98996934658631308e8fb4069d2db68ff44927", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c98996934658631308e8fb4069d2db68ff44927", "html_url": "https://github.com/rust-lang/rust/commit/8c98996934658631308e8fb4069d2db68ff44927", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c98996934658631308e8fb4069d2db68ff44927/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e83948631836555c61f9eb97e8657f28c74ba433", "url": "https://api.github.com/repos/rust-lang/rust/commits/e83948631836555c61f9eb97e8657f28c74ba433", "html_url": "https://github.com/rust-lang/rust/commit/e83948631836555c61f9eb97e8657f28c74ba433"}], "stats": {"total": 193, "additions": 100, "deletions": 93}, "files": [{"sha": "aa6614b0af4f7b492dd84a49635fa0614a12c428", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c98996934658631308e8fb4069d2db68ff44927/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c98996934658631308e8fb4069d2db68ff44927/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=8c98996934658631308e8fb4069d2db68ff44927", "patch": "@@ -1276,7 +1276,7 @@ impl<'a> LoweringContext<'a> {\n         let mut name = i.ident.name;\n         let attrs = self.lower_attrs(&i.attrs);\n         let mut vis = self.lower_visibility(&i.vis);\n-        if let ItemKind::MacroDef(ref tts, _) = i.node {\n+        if let ItemKind::MacroDef(ref tts) = i.node {\n             if i.attrs.iter().any(|attr| attr.name() == \"macro_export\") {\n                 self.exported_macros.push(hir::MacroDef {\n                     name: name, attrs: attrs, id: i.id, span: i.span, body: tts.clone().into(),"}, {"sha": "2a67b79eaa52e6022ef699ee90fcbad76e91380c", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c98996934658631308e8fb4069d2db68ff44927/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c98996934658631308e8fb4069d2db68ff44927/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=8c98996934658631308e8fb4069d2db68ff44927", "patch": "@@ -34,7 +34,6 @@ use std::rc::Rc;\n \n use syntax::ast;\n use syntax::attr;\n-use syntax::ext::hygiene::Mark;\n use syntax::parse::filemap_to_stream;\n use syntax::symbol::Symbol;\n use syntax_pos::{mk_sp, Span};\n@@ -420,7 +419,7 @@ impl CrateStore for cstore::CStore {\n             id: ast::DUMMY_NODE_ID,\n             span: local_span,\n             attrs: attrs,\n-            node: ast::ItemKind::MacroDef(body.into(), Mark::fresh()),\n+            node: ast::ItemKind::MacroDef(body.into()),\n             vis: ast::Visibility::Inherited,\n         })\n     }"}, {"sha": "03c61067d64c20d44b2a7aebf412519f68739b8e", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8c98996934658631308e8fb4069d2db68ff44927/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c98996934658631308e8fb4069d2db68ff44927/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=8c98996934658631308e8fb4069d2db68ff44927", "patch": "@@ -492,6 +492,16 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n+    pub fn macro_def_scope(&mut self, expansion: Mark) -> Module<'a> {\n+        let def_id = self.macro_defs[&expansion];\n+        if let Some(id) = self.definitions.as_local_node_id(def_id) {\n+            self.local_macro_def_scopes[&id]\n+        } else {\n+            let module_def_id = ty::DefIdTree::parent(&*self, def_id).unwrap();\n+            self.get_extern_crate_root(module_def_id.krate)\n+        }\n+    }\n+\n     pub fn get_macro(&mut self, def: Def) -> Rc<SyntaxExtension> {\n         let def_id = match def {\n             Def::Macro(def_id, ..) => def_id,\n@@ -506,15 +516,6 @@ impl<'a> Resolver<'a> {\n             LoadedMacro::ProcMacro(ext) => return ext,\n         };\n \n-        let invocation = self.arenas.alloc_invocation_data(InvocationData {\n-            module: Cell::new(self.get_extern_crate_root(def_id.krate)),\n-            // FIXME(jseyfried) the following are irrelevant\n-            def_index: CRATE_DEF_INDEX, const_expr: false,\n-            legacy_scope: Cell::new(LegacyScope::Empty), expansion: Cell::new(LegacyScope::Empty),\n-        });\n-        if let ast::ItemKind::MacroDef(_, mark) = macro_def.node {\n-            self.invocations.insert(mark, invocation);\n-        }\n         let ext = Rc::new(macro_rules::compile(&self.session.parse_sess, &macro_def));\n         self.macro_map.insert(def_id, ext.clone());\n         ext"}, {"sha": "0958748ed092fc88ffd76c61b5d2076a39cf29d7", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 34, "deletions": 21, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8c98996934658631308e8fb4069d2db68ff44927/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c98996934658631308e8fb4069d2db68ff44927/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8c98996934658631308e8fb4069d2db68ff44927", "patch": "@@ -779,8 +779,8 @@ enum RibKind<'a> {\n     // We passed through a module.\n     ModuleRibKind(Module<'a>),\n \n-    // We passed through a `macro_rules!` statement with the given expansion\n-    MacroDefinition(Mark),\n+    // We passed through a `macro_rules!` statement\n+    MacroDefinition(DefId),\n \n     // All bindings in this rib are type parameters that can't be used\n     // from the default of a type parameter because they're not declared\n@@ -997,14 +997,18 @@ impl<'a> NameBinding<'a> {\n         }\n     }\n \n-    fn get_macro(&self, resolver: &mut Resolver<'a>) -> Rc<SyntaxExtension> {\n+    fn def_ignoring_ambiguity(&self) -> Def {\n         match self.kind {\n-            NameBindingKind::Import { binding, .. } => binding.get_macro(resolver),\n-            NameBindingKind::Ambiguity { b1, .. } => b1.get_macro(resolver),\n-            _ => resolver.get_macro(self.def()),\n+            NameBindingKind::Import { binding, .. } => binding.def_ignoring_ambiguity(),\n+            NameBindingKind::Ambiguity { b1, .. } => b1.def_ignoring_ambiguity(),\n+            _ => self.def(),\n         }\n     }\n \n+    fn get_macro(&self, resolver: &mut Resolver<'a>) -> Rc<SyntaxExtension> {\n+        resolver.get_macro(self.def_ignoring_ambiguity())\n+    }\n+\n     // We sometimes need to treat variants as `pub` for backwards compatibility\n     fn pseudo_vis(&self) -> ty::Visibility {\n         if self.is_variant() { ty::Visibility::Public } else { self.vis }\n@@ -1172,6 +1176,8 @@ pub struct Resolver<'a> {\n     builtin_macros: FxHashMap<Name, &'a NameBinding<'a>>,\n     lexical_macro_resolutions: Vec<(Name, &'a Cell<LegacyScope<'a>>)>,\n     macro_map: FxHashMap<DefId, Rc<SyntaxExtension>>,\n+    macro_defs: FxHashMap<Mark, DefId>,\n+    local_macro_def_scopes: FxHashMap<NodeId, Module<'a>>,\n     macro_exports: Vec<Export>,\n     pub whitelisted_legacy_custom_derives: Vec<Name>,\n     pub found_unresolved_macro: bool,\n@@ -1300,6 +1306,9 @@ impl<'a> Resolver<'a> {\n \n         let features = session.features.borrow();\n \n+        let mut macro_defs = FxHashMap();\n+        macro_defs.insert(Mark::root(), root_def_id);\n+\n         Resolver {\n             session: session,\n \n@@ -1366,6 +1375,8 @@ impl<'a> Resolver<'a> {\n             macro_map: FxHashMap(),\n             macro_exports: Vec::new(),\n             invocations: invocations,\n+            macro_defs: macro_defs,\n+            local_macro_def_scopes: FxHashMap(),\n             name_already_seen: FxHashMap(),\n             whitelisted_legacy_custom_derives: Vec::new(),\n             proc_macro_enabled: features.proc_macro,\n@@ -1503,24 +1514,25 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n \n-            if let MacroDefinition(mac) = self.ribs[ns][i].kind {\n+            if let MacroDefinition(def) = self.ribs[ns][i].kind {\n                 // If an invocation of this macro created `ident`, give up on `ident`\n                 // and switch to `ident`'s source from the macro definition.\n-                let (source_ctxt, source_macro) = ident.ctxt.source();\n-                if source_macro == mac {\n-                    ident.ctxt = source_ctxt;\n+                let ctxt_data = ident.ctxt.data();\n+                if def == self.macro_defs[&ctxt_data.outer_mark] {\n+                    ident.ctxt = ctxt_data.prev_ctxt;\n                 }\n             }\n         }\n \n         None\n     }\n \n-    fn resolve_crate_var(&mut self, mut crate_var_ctxt: SyntaxContext) -> Module<'a> {\n-        while crate_var_ctxt.source().0 != SyntaxContext::empty() {\n-            crate_var_ctxt = crate_var_ctxt.source().0;\n+    fn resolve_crate_var(&mut self, crate_var_ctxt: SyntaxContext) -> Module<'a> {\n+        let mut ctxt_data = crate_var_ctxt.data();\n+        while ctxt_data.prev_ctxt != SyntaxContext::empty() {\n+            ctxt_data = ctxt_data.prev_ctxt.data();\n         }\n-        let module = self.invocations[&crate_var_ctxt.source().1].module.get();\n+        let module = self.macro_def_scope(ctxt_data.outer_mark);\n         if module.is_local() { self.graph_root } else { module }\n     }\n \n@@ -1572,12 +1584,12 @@ impl<'a> Resolver<'a> {\n                 NormalRibKind => {\n                     // Continue\n                 }\n-                MacroDefinition(mac) => {\n+                MacroDefinition(def) => {\n                     // If an invocation of this macro created `ident`, give up on `ident`\n                     // and switch to `ident`'s source from the macro definition.\n-                    let (source_ctxt, source_macro) = ident.ctxt.source();\n-                    if source_macro == mac {\n-                        ident.ctxt = source_ctxt;\n+                    let ctxt_data = ident.ctxt.data();\n+                    if def == self.macro_defs[&ctxt_data.outer_mark] {\n+                        ident.ctxt = ctxt_data.prev_ctxt;\n                     }\n                 }\n                 _ => {\n@@ -2025,10 +2037,11 @@ impl<'a> Resolver<'a> {\n         // Descend into the block.\n         for stmt in &block.stmts {\n             if let ast::StmtKind::Item(ref item) = stmt.node {\n-                if let ast::ItemKind::MacroDef(_, mark) = item.node {\n+                if let ast::ItemKind::MacroDef(..) = item.node {\n                     num_macro_definition_ribs += 1;\n-                    self.ribs[ValueNS].push(Rib::new(MacroDefinition(mark)));\n-                    self.label_ribs.push(Rib::new(MacroDefinition(mark)));\n+                    let def = self.definitions.local_def_id(item.id);\n+                    self.ribs[ValueNS].push(Rib::new(MacroDefinition(def)));\n+                    self.label_ribs.push(Rib::new(MacroDefinition(def)));\n                 }\n             }\n "}, {"sha": "7ad122d1c31d8d13373dfc90eff69071702beb7e", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 43, "deletions": 36, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/8c98996934658631308e8fb4069d2db68ff44927/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c98996934658631308e8fb4069d2db68ff44927/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=8c98996934658631308e8fb4069d2db68ff44927", "patch": "@@ -74,7 +74,7 @@ pub enum LegacyScope<'a> {\n pub struct LegacyBinding<'a> {\n     pub parent: Cell<LegacyScope<'a>>,\n     pub name: ast::Name,\n-    ext: Rc<SyntaxExtension>,\n+    def_id: DefId,\n     pub span: Span,\n }\n \n@@ -239,15 +239,34 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n     fn resolve_invoc(&mut self, invoc: &mut Invocation, scope: Mark, force: bool)\n                      -> Result<Option<Rc<SyntaxExtension>>, Determinacy> {\n-        let (attr, traits, item) = match invoc.kind {\n+        let def = match invoc.kind {\n             InvocationKind::Attr { attr: None, .. } => return Ok(None),\n+            _ => match self.resolve_invoc_to_def(invoc, scope, force) {\n+                Ok(def) => def,\n+                Err(determinacy) => return Err(determinacy),\n+            },\n+        };\n+        self.macro_defs.insert(invoc.expansion_data.mark, def.def_id());\n+        Ok(Some(self.get_macro(def)))\n+    }\n+\n+    fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)\n+                     -> Result<Rc<SyntaxExtension>, Determinacy> {\n+        self.resolve_macro_to_def(scope, path, kind, force).map(|def| self.get_macro(def))\n+    }\n+}\n+\n+impl<'a> Resolver<'a> {\n+    fn resolve_invoc_to_def(&mut self, invoc: &mut Invocation, scope: Mark, force: bool)\n+                            -> Result<Def, Determinacy> {\n+        let (attr, traits, item) = match invoc.kind {\n             InvocationKind::Attr { ref mut attr, ref traits, ref mut item } => (attr, traits, item),\n             InvocationKind::Bang { ref mac, .. } => {\n-                return self.resolve_macro(scope, &mac.node.path, MacroKind::Bang, force).map(Some);\n+                return self.resolve_macro_to_def(scope, &mac.node.path, MacroKind::Bang, force);\n             }\n             InvocationKind::Derive { name, span, .. } => {\n                 let path = ast::Path::from_ident(span, Ident::with_empty_ctxt(name));\n-                return self.resolve_macro(scope, &path, MacroKind::Derive, force).map(Some);\n+                return self.resolve_macro_to_def(scope, &path, MacroKind::Derive, force);\n             }\n         };\n \n@@ -257,8 +276,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n         };\n \n         let mut determined = true;\n-        match self.resolve_macro(scope, &path, MacroKind::Attr, force) {\n-            Ok(ext) => return Ok(Some(ext)),\n+        match self.resolve_macro_to_def(scope, &path, MacroKind::Attr, force) {\n+            Ok(def) => return Ok(def),\n             Err(Determinacy::Undetermined) => determined = false,\n             Err(Determinacy::Determined) if force => return Err(Determinacy::Determined),\n             Err(Determinacy::Determined) => {}\n@@ -293,8 +312,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n         Err(if determined { Determinacy::Determined } else { Determinacy::Undetermined })\n     }\n \n-    fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)\n-                     -> Result<Rc<SyntaxExtension>, Determinacy> {\n+    fn resolve_macro_to_def(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)\n+                            -> Result<Def, Determinacy> {\n         let ast::Path { ref segments, span } = *path;\n         if segments.iter().any(|segment| segment.parameters.is_some()) {\n             let kind =\n@@ -317,10 +336,10 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 return Err(Determinacy::Determined);\n             }\n \n-            let ext = match self.resolve_path(&path, Some(MacroNS), None) {\n+            let def = match self.resolve_path(&path, Some(MacroNS), None) {\n                 PathResult::NonModule(path_res) => match path_res.base_def() {\n                     Def::Err => Err(Determinacy::Determined),\n-                    def @ _ => Ok(self.get_macro(def)),\n+                    def @ _ => Ok(def),\n                 },\n                 PathResult::Module(..) => unreachable!(),\n                 PathResult::Indeterminate if !force => return Err(Determinacy::Undetermined),\n@@ -331,15 +350,15 @@ impl<'a> base::Resolver for Resolver<'a> {\n             };\n             self.current_module.macro_resolutions.borrow_mut()\n                 .push((path.into_boxed_slice(), span));\n-            return ext;\n+            return def;\n         }\n \n         let name = path[0].name;\n         let result = match self.resolve_legacy_scope(&invocation.legacy_scope, name, false) {\n-            Some(MacroBinding::Legacy(binding)) => Ok(binding.ext.clone()),\n-            Some(MacroBinding::Modern(binding)) => Ok(binding.get_macro(self)),\n+            Some(MacroBinding::Legacy(binding)) => Ok(Def::Macro(binding.def_id, MacroKind::Bang)),\n+            Some(MacroBinding::Modern(binding)) => Ok(binding.def_ignoring_ambiguity()),\n             None => match self.resolve_lexical_macro_path_segment(path[0], MacroNS, None) {\n-                Ok(binding) => Ok(binding.get_macro(self)),\n+                Ok(binding) => Ok(binding.def_ignoring_ambiguity()),\n                 Err(Determinacy::Undetermined) if !force =>\n                     return Err(Determinacy::Undetermined),\n                 Err(_) => {\n@@ -354,9 +373,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n         result\n     }\n-}\n \n-impl<'a> Resolver<'a> {\n     // Resolve the initial segment of a non-global macro path (e.g. `foo` in `foo::bar!();`)\n     pub fn resolve_lexical_macro_path_segment(&mut self,\n                                               ident: Ident,\n@@ -597,33 +614,23 @@ impl<'a> Resolver<'a> {\n     }\n \n     pub fn define_macro(&mut self, item: &ast::Item, legacy_scope: &mut LegacyScope<'a>) {\n-        if item.ident.name == \"macro_rules\" {\n+        self.local_macro_def_scopes.insert(item.id, self.current_module);\n+        let ident = item.ident;\n+        if ident.name == \"macro_rules\" {\n             self.session.span_err(item.span, \"user-defined macros may not be named `macro_rules`\");\n         }\n \n-        let invocation = self.arenas.alloc_invocation_data(InvocationData {\n-            module: Cell::new(self.current_module),\n-            // FIXME(jseyfried) the following are irrelevant\n-            def_index: CRATE_DEF_INDEX, const_integer: false,\n-            legacy_scope: Cell::new(LegacyScope::Empty), expansion: Cell::new(LegacyScope::Empty),\n-        });\n-        if let ast::ItemKind::MacroDef(_, mark) = item.node {\n-            self.invocations.insert(mark, invocation);\n-        }\n-\n+        let def_id = self.definitions.local_def_id(item.id);\n+        let ext = Rc::new(macro_rules::compile(&self.session.parse_sess, item));\n+        self.macro_map.insert(def_id, ext);\n         *legacy_scope = LegacyScope::Binding(self.arenas.alloc_legacy_binding(LegacyBinding {\n-            parent: Cell::new(*legacy_scope),\n-            name: item.ident.name,\n-            ext: Rc::new(macro_rules::compile(&self.session.parse_sess, item)),\n-            span: item.span,\n+            parent: Cell::new(*legacy_scope), name: ident.name, def_id: def_id, span: item.span,\n         }));\n-        self.macro_names.insert(item.ident.name);\n+        self.macro_names.insert(ident.name);\n \n         if attr::contains_name(&item.attrs, \"macro_export\") {\n-            self.macro_exports.push(Export {\n-                name: item.ident.name,\n-                def: Def::Macro(self.definitions.local_def_id(item.id), MacroKind::Bang),\n-            });\n+            let def = Def::Macro(def_id, MacroKind::Bang);\n+            self.macro_exports.push(Export { name: ident.name, def: def });\n         }\n     }\n "}, {"sha": "b80de3cc505464450aa0a00483fe73ca5dd67495", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c98996934658631308e8fb4069d2db68ff44927/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c98996934658631308e8fb4069d2db68ff44927/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=8c98996934658631308e8fb4069d2db68ff44927", "patch": "@@ -211,7 +211,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                         LoadedMacro::ProcMacro(..) => continue,\n                     };\n \n-                    let matchers = if let ast::ItemKind::MacroDef(ref tokens, _) = def.node {\n+                    let matchers = if let ast::ItemKind::MacroDef(ref tokens) = def.node {\n                         let tts: Vec<_> = TokenStream::from(tokens.clone()).into_trees().collect();\n                         tts.chunks(4).map(|arm| arm[0].span()).collect()\n                     } else {"}, {"sha": "981667337d59a9d02b839ab772411276d6344436", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c98996934658631308e8fb4069d2db68ff44927/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c98996934658631308e8fb4069d2db68ff44927/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8c98996934658631308e8fb4069d2db68ff44927", "patch": "@@ -20,7 +20,7 @@ pub use util::ThinVec;\n use syntax_pos::{mk_sp, Span, DUMMY_SP, ExpnId};\n use codemap::{respan, Spanned};\n use abi::Abi;\n-use ext::hygiene::{Mark, SyntaxContext};\n+use ext::hygiene::SyntaxContext;\n use print::pprust;\n use ptr::P;\n use symbol::{Symbol, keywords};\n@@ -1860,7 +1860,7 @@ pub enum ItemKind {\n     Mac(Mac),\n \n     /// A macro definition.\n-    MacroDef(ThinTokenStream, Mark /* FIXME(jseyfried) remove this */),\n+    MacroDef(ThinTokenStream),\n }\n \n impl ItemKind {"}, {"sha": "96fcea7148bfa67a529c0063ae9d73f978149bba", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c98996934658631308e8fb4069d2db68ff44927/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c98996934658631308e8fb4069d2db68ff44927/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=8c98996934658631308e8fb4069d2db68ff44927", "patch": "@@ -154,7 +154,7 @@ impl ExpansionKind {\n pub struct Invocation {\n     pub kind: InvocationKind,\n     expansion_kind: ExpansionKind,\n-    expansion_data: ExpansionData,\n+    pub expansion_data: ExpansionData,\n }\n \n pub enum InvocationKind {\n@@ -432,7 +432,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n         let extname = path.segments.last().unwrap().identifier.name;\n         let ident = ident.unwrap_or(keywords::Invalid.ident());\n-        let marked_tts = mark_tts(mac.node.stream(), mark);\n+        let marked_tts =\n+            noop_fold_tts(mac.node.stream(), &mut Marker { mark: mark, expn_id: None });\n         let opt_expanded = match *ext {\n             NormalTT(ref expandfun, exp_span, allow_internal_unstable) => {\n                 if ident.name != keywords::Invalid.name() {\n@@ -1094,8 +1095,3 @@ impl Folder for Marker {\n         span\n     }\n }\n-\n-// apply a given mark to the given token trees. Used prior to expansion of a macro.\n-pub fn mark_tts(tts: TokenStream, m: Mark) -> TokenStream {\n-    noop_fold_tts(tts, &mut Marker{mark:m, expn_id: None})\n-}"}, {"sha": "57f5ab73d37062fbbb4079dae08a649e273e0f0c", "filename": "src/libsyntax/ext/hygiene.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8c98996934658631308e8fb4069d2db68ff44927/src%2Flibsyntax%2Fext%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c98996934658631308e8fb4069d2db68ff44927/src%2Flibsyntax%2Fext%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fhygiene.rs?ref=8c98996934658631308e8fb4069d2db68ff44927", "patch": "@@ -118,13 +118,6 @@ impl SyntaxContext {\n             })\n         })\n     }\n-\n-    /// If `ident` is macro expanded, return the source ident from the macro definition\n-    /// and the mark of the expansion that created the macro definition.\n-    pub fn source(self) -> (Self /* source context */, Mark /* source macro */) {\n-         let macro_def_ctxt = self.data().prev_ctxt.data();\n-         (macro_def_ctxt.prev_ctxt, macro_def_ctxt.outer_mark)\n-    }\n }\n \n impl fmt::Debug for SyntaxContext {"}, {"sha": "7aa1230f9aeea9a9eb664be80fed382307e9039a", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c98996934658631308e8fb4069d2db68ff44927/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c98996934658631308e8fb4069d2db68ff44927/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=8c98996934658631308e8fb4069d2db68ff44927", "patch": "@@ -12,7 +12,7 @@ use {ast, attr};\n use syntax_pos::{Span, DUMMY_SP};\n use ext::base::{DummyResult, ExtCtxt, MacResult, SyntaxExtension};\n use ext::base::{NormalTT, TTMacroExpander};\n-use ext::expand::{Expansion, ExpansionKind, mark_tts};\n+use ext::expand::{Expansion, ExpansionKind};\n use ext::tt::macro_parser::{Success, Error, Failure};\n use ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n use ext::tt::macro_parser::{parse, parse_failure_msg};\n@@ -184,7 +184,7 @@ pub fn compile(sess: &ParseSess, def: &ast::Item) -> SyntaxExtension {\n \n     // Parse the macro_rules! invocation\n     let body = match def.node {\n-        ast::ItemKind::MacroDef(ref body, mark) => mark_tts(body.clone().into(), mark),\n+        ast::ItemKind::MacroDef(ref body) => body.clone().into(),\n         _ => unreachable!(),\n     };\n     let argument_map = match parse(sess, body, &argument_gram, None) {"}, {"sha": "fb4eb19be2b15d8f1a1f56fb019d3fa32cdbf80c", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c98996934658631308e8fb4069d2db68ff44927/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c98996934658631308e8fb4069d2db68ff44927/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=8c98996934658631308e8fb4069d2db68ff44927", "patch": "@@ -899,8 +899,7 @@ pub fn noop_fold_item_kind<T: Folder>(i: ItemKind, folder: &mut T) -> ItemKind {\n             items.move_flat_map(|item| folder.fold_trait_item(item)),\n         ),\n         ItemKind::Mac(m) => ItemKind::Mac(folder.fold_mac(m)),\n-        ItemKind::MacroDef(tts, mark) => ItemKind::MacroDef(folder.fold_tts(tts.into()).into(),\n-                                                            mark),\n+        ItemKind::MacroDef(tts) => ItemKind::MacroDef(folder.fold_tts(tts.into()).into()),\n     }\n }\n "}, {"sha": "6446d38e5ef707e616e995c989afb3ac1c3038b5", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c98996934658631308e8fb4069d2db68ff44927/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c98996934658631308e8fb4069d2db68ff44927/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8c98996934658631308e8fb4069d2db68ff44927", "patch": "@@ -43,7 +43,6 @@ use {ast, attr};\n use codemap::{self, CodeMap, Spanned, spanned, respan};\n use syntax_pos::{self, Span, Pos, BytePos, mk_sp};\n use errors::{self, DiagnosticBuilder};\n-use ext::hygiene::Mark;\n use parse::{self, classify, token};\n use parse::common::SeqSep;\n use parse::lexer::TokenAndSpan;\n@@ -3731,7 +3730,7 @@ impl<'a> Parser<'a> {\n         }\n \n         let hi = self.prev_span.hi;\n-        let kind = ItemKind::MacroDef(tts, Mark::fresh());\n+        let kind = ItemKind::MacroDef(tts);\n         Ok(Some(self.mk_item(lo, hi, id, kind, Visibility::Inherited, attrs.to_owned())))\n     }\n "}, {"sha": "3efadbd00d1e080924cd28dd33a46a6a9613b183", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c98996934658631308e8fb4069d2db68ff44927/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c98996934658631308e8fb4069d2db68ff44927/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=8c98996934658631308e8fb4069d2db68ff44927", "patch": "@@ -1328,7 +1328,7 @@ impl<'a> State<'a> {\n                 word(&mut self.s, \";\")?;\n                 self.end()?;\n             }\n-            ast::ItemKind::MacroDef(ref tts, _) => {\n+            ast::ItemKind::MacroDef(ref tts) => {\n                 word(&mut self.s, \"macro_rules! \")?;\n                 self.print_ident(item.ident)?;\n                 self.cbox(INDENT_UNIT)?;"}]}