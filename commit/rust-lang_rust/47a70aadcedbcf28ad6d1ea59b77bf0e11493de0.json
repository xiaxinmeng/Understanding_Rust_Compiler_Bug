{"sha": "47a70aadcedbcf28ad6d1ea59b77bf0e11493de0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3YTcwYWFkY2VkYmNmMjhhZDZkMWVhNTliNzdiZjBlMTE0OTNkZTA=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-01-21T15:28:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-21T15:28:40Z"}, "message": "Merge #7375\n\n7375: Add support for running name resolution in block expressions r=jonas-schievink a=jonas-schievink\n\nThis adds a `block_def_map` query that runs the name resolution algorithm on a block expression, and returns a `DefMap` that stores links to the parent `DefMap` (either the containing block or the crate-level `DefMap`). Blocks with no inner items return the parent's `DefMap` as-is, to avoid creating unnecessarily long `DefMap` chains.\r\n\r\nPath resolution is updated to recurse into the parent `DefMap` after looking up a path in the original `DefMap`.\r\n\r\nI've added a few new tests for this, but outside of those this isn't used yet.\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "e5f494422dacc1a6bcae2b696d06f937b64d9163", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5f494422dacc1a6bcae2b696d06f937b64d9163"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47a70aadcedbcf28ad6d1ea59b77bf0e11493de0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgCZ2oCRBK7hj4Ov3rIwAAdHIIABluYkOkpKLjZG8vD4qCJFMe\nNo5OY2w43W8tx88Sv7nFjoLsaLDaZ69Tw9HVBuZXVxynhqQn0AgU0RuP9utYCm6v\naFY74gQ72IXOqu3m2zfCJ1Cfsxv0/Y6mQ6LYTgTcLL6NOeHBenSqhdBofFRt4TBS\nvboh2J53oPbFvfzE6rSAMhjp1B4JhkIrMWnMIGmyDTYnPcS6ivG2osqaHip9oBIy\nftx+CfOR76v05vpf3w0oECnrAYS+oxkH+29CefkXWA4iTpdKleyUyXibSQsL72G7\n2qW1Ztrmrk/SIdErZd8wMFMnIiteZfL8APlqtC3dJxrCS5UCEox+tNvRdk7zyLM=\n=ulKp\n-----END PGP SIGNATURE-----\n", "payload": "tree e5f494422dacc1a6bcae2b696d06f937b64d9163\nparent 323138f32ea74cfe9f5381e9e170cf87e7592818\nparent ec4a1dc297eb90dde4c22c682a35606aaa50b4d4\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1611242920 +0000\ncommitter GitHub <noreply@github.com> 1611242920 +0000\n\nMerge #7375\n\n7375: Add support for running name resolution in block expressions r=jonas-schievink a=jonas-schievink\n\nThis adds a `block_def_map` query that runs the name resolution algorithm on a block expression, and returns a `DefMap` that stores links to the parent `DefMap` (either the containing block or the crate-level `DefMap`). Blocks with no inner items return the parent's `DefMap` as-is, to avoid creating unnecessarily long `DefMap` chains.\r\n\r\nPath resolution is updated to recurse into the parent `DefMap` after looking up a path in the original `DefMap`.\r\n\r\nI've added a few new tests for this, but outside of those this isn't used yet.\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47a70aadcedbcf28ad6d1ea59b77bf0e11493de0", "html_url": "https://github.com/rust-lang/rust/commit/47a70aadcedbcf28ad6d1ea59b77bf0e11493de0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47a70aadcedbcf28ad6d1ea59b77bf0e11493de0/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "323138f32ea74cfe9f5381e9e170cf87e7592818", "url": "https://api.github.com/repos/rust-lang/rust/commits/323138f32ea74cfe9f5381e9e170cf87e7592818", "html_url": "https://github.com/rust-lang/rust/commit/323138f32ea74cfe9f5381e9e170cf87e7592818"}, {"sha": "ec4a1dc297eb90dde4c22c682a35606aaa50b4d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec4a1dc297eb90dde4c22c682a35606aaa50b4d4", "html_url": "https://github.com/rust-lang/rust/commit/ec4a1dc297eb90dde4c22c682a35606aaa50b4d4"}], "stats": {"total": 349, "additions": 291, "deletions": 58}, "files": [{"sha": "d444f4bbb17b4a7601ae757d27c6f491a8e2fc45", "filename": "crates/hir/src/db.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/47a70aadcedbcf28ad6d1ea59b77bf0e11493de0/crates%2Fhir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47a70aadcedbcf28ad6d1ea59b77bf0e11493de0/crates%2Fhir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdb.rs?ref=47a70aadcedbcf28ad6d1ea59b77bf0e11493de0", "patch": "@@ -1,13 +1,13 @@\n //! FIXME: write short doc here\n \n pub use hir_def::db::{\n-    AttrsQuery, BodyQuery, BodyWithSourceMapQuery, ConstDataQuery, CrateDefMapQueryQuery,\n-    CrateLangItemsQuery, DefDatabase, DefDatabaseStorage, EnumDataQuery, ExprScopesQuery,\n-    FunctionDataQuery, GenericParamsQuery, ImplDataQuery, ImportMapQuery, InternConstQuery,\n-    InternDatabase, InternDatabaseStorage, InternEnumQuery, InternFunctionQuery, InternImplQuery,\n-    InternStaticQuery, InternStructQuery, InternTraitQuery, InternTypeAliasQuery, InternUnionQuery,\n-    ItemTreeQuery, LangItemQuery, StaticDataQuery, StructDataQuery, TraitDataQuery,\n-    TypeAliasDataQuery, UnionDataQuery,\n+    AttrsQuery, BlockDefMapQuery, BodyQuery, BodyWithSourceMapQuery, ConstDataQuery,\n+    CrateDefMapQueryQuery, CrateLangItemsQuery, DefDatabase, DefDatabaseStorage, EnumDataQuery,\n+    ExprScopesQuery, FunctionDataQuery, GenericParamsQuery, ImplDataQuery, ImportMapQuery,\n+    InternConstQuery, InternDatabase, InternDatabaseStorage, InternEnumQuery, InternFunctionQuery,\n+    InternImplQuery, InternStaticQuery, InternStructQuery, InternTraitQuery, InternTypeAliasQuery,\n+    InternUnionQuery, ItemTreeQuery, LangItemQuery, StaticDataQuery, StructDataQuery,\n+    TraitDataQuery, TypeAliasDataQuery, UnionDataQuery,\n };\n pub use hir_expand::db::{\n     AstDatabase, AstDatabaseStorage, AstIdMapQuery, HygieneFrameQuery, InternEagerExpansionQuery,"}, {"sha": "a87c80b8a1c5f811c5f89d92d7469d5c9be5a5f1", "filename": "crates/hir_def/src/db.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/47a70aadcedbcf28ad6d1ea59b77bf0e11493de0/crates%2Fhir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47a70aadcedbcf28ad6d1ea59b77bf0e11493de0/crates%2Fhir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdb.rs?ref=47a70aadcedbcf28ad6d1ea59b77bf0e11493de0", "patch": "@@ -2,9 +2,9 @@\n use std::sync::Arc;\n \n use base_db::{salsa, CrateId, SourceDatabase, Upcast};\n-use hir_expand::{db::AstDatabase, HirFileId};\n+use hir_expand::{db::AstDatabase, AstId, HirFileId};\n use la_arena::ArenaMap;\n-use syntax::SmolStr;\n+use syntax::{ast, SmolStr};\n \n use crate::{\n     adt::{EnumData, StructData},\n@@ -55,6 +55,9 @@ pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n     #[salsa::invoke(DefMap::crate_def_map_query)]\n     fn crate_def_map_query(&self, krate: CrateId) -> Arc<DefMap>;\n \n+    #[salsa::invoke(DefMap::block_def_map_query)]\n+    fn block_def_map(&self, krate: CrateId, block: AstId<ast::BlockExpr>) -> Arc<DefMap>;\n+\n     #[salsa::invoke(StructData::struct_data_query)]\n     fn struct_data(&self, id: StructId) -> Arc<StructData>;\n     #[salsa::invoke(StructData::union_data_query)]"}, {"sha": "1226d7d8538e7057e6039c2ac3a6759a0d0fcafd", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/47a70aadcedbcf28ad6d1ea59b77bf0e11493de0/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47a70aadcedbcf28ad6d1ea59b77bf0e11493de0/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=47a70aadcedbcf28ad6d1ea59b77bf0e11493de0", "patch": "@@ -195,6 +195,13 @@ impl ItemTree {\n         }\n     }\n \n+    pub fn inner_items_of_block(&self, block: FileAstId<ast::BlockExpr>) -> &[ModItem] {\n+        match &self.data {\n+            Some(data) => data.inner_items.get(&block).map(|it| &**it).unwrap_or(&[]),\n+            None => &[],\n+        }\n+    }\n+\n     pub fn source<S: ItemTreeNode>(&self, db: &dyn DefDatabase, of: ItemTreeId<S>) -> S::Source {\n         // This unwrap cannot fail, since it has either succeeded above, or resulted in an empty\n         // ItemTree (in which case there is no valid `FileItemTreeId` to call this method with)."}, {"sha": "61cbbbc8f05dff06b01b98084116fca382cfea0f", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/47a70aadcedbcf28ad6d1ea59b77bf0e11493de0/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47a70aadcedbcf28ad6d1ea59b77bf0e11493de0/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=47a70aadcedbcf28ad6d1ea59b77bf0e11493de0", "patch": "@@ -151,23 +151,31 @@ impl Ctx {\n     fn collect_inner_items(&mut self, container: &SyntaxNode) {\n         let forced_vis = self.forced_visibility.take();\n \n-        let mut current_block = None;\n+        let mut block_stack = Vec::new();\n         for event in container.preorder().skip(1) {\n-            if let WalkEvent::Enter(node) = event {\n-                match_ast! {\n-                    match node {\n-                        ast::BlockExpr(block) => {\n-                            current_block = Some(self.source_ast_id_map.ast_id(&block));\n-                        },\n-                        ast::Item(item) => {\n-                            let mod_items = self.lower_mod_item(&item, true);\n-                            if let (Some(mod_items), Some(block)) = (mod_items, current_block) {\n-                                if !mod_items.0.is_empty() {\n-                                    self.data().inner_items.entry(block).or_default().extend(mod_items.0.iter().copied());\n+            match event {\n+                WalkEvent::Enter(node) => {\n+                    match_ast! {\n+                        match node {\n+                            ast::BlockExpr(block) => {\n+                                block_stack.push(self.source_ast_id_map.ast_id(&block));\n+                            },\n+                            ast::Item(item) => {\n+                                let mod_items = self.lower_mod_item(&item, true);\n+                                let current_block = block_stack.last();\n+                                if let (Some(mod_items), Some(block)) = (mod_items, current_block) {\n+                                    if !mod_items.0.is_empty() {\n+                                        self.data().inner_items.entry(*block).or_default().extend(mod_items.0.iter().copied());\n+                                    }\n                                 }\n-                            }\n-                        },\n-                        _ => {}\n+                            },\n+                            _ => {}\n+                        }\n+                    }\n+                }\n+                WalkEvent::Leave(node) => {\n+                    if ast::BlockExpr::cast(node).is_some() {\n+                        block_stack.pop();\n                     }\n                 }\n             }"}, {"sha": "93931a21af886cb0c6d3f86e1dcde6d7b479f4b5", "filename": "crates/hir_def/src/nameres.rs", "status": "modified", "additions": 78, "deletions": 17, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/47a70aadcedbcf28ad6d1ea59b77bf0e11493de0/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47a70aadcedbcf28ad6d1ea59b77bf0e11493de0/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres.rs?ref=47a70aadcedbcf28ad6d1ea59b77bf0e11493de0", "patch": "@@ -61,7 +61,7 @@ use hir_expand::{diagnostics::DiagnosticSink, name::Name, InFile};\n use la_arena::Arena;\n use rustc_hash::FxHashMap;\n use stdx::format_to;\n-use syntax::ast;\n+use syntax::{ast, AstNode};\n \n use crate::{\n     db::DefDatabase,\n@@ -75,6 +75,7 @@ use crate::{\n /// Contains all top-level defs from a macro-expanded crate\n #[derive(Debug, PartialEq, Eq)]\n pub struct DefMap {\n+    parent: Option<Arc<DefMap>>,\n     root: LocalModuleId,\n     modules: Arena<ModuleData>,\n     krate: CrateId,\n@@ -181,24 +182,50 @@ impl DefMap {\n         let _p = profile::span(\"crate_def_map_query\").detail(|| {\n             db.crate_graph()[krate].display_name.as_deref().unwrap_or_default().to_string()\n         });\n-        let def_map = {\n-            let edition = db.crate_graph()[krate].edition;\n-            let mut modules: Arena<ModuleData> = Arena::default();\n-            let root = modules.alloc(ModuleData::default());\n-            DefMap {\n-                krate,\n-                edition,\n-                extern_prelude: FxHashMap::default(),\n-                prelude: None,\n-                root,\n-                modules,\n-                diagnostics: Vec::new(),\n-            }\n-        };\n-        let def_map = collector::collect_defs(db, def_map);\n+        let edition = db.crate_graph()[krate].edition;\n+        let def_map = DefMap::empty(krate, edition);\n+        let def_map = collector::collect_defs(db, def_map, None);\n+        Arc::new(def_map)\n+    }\n+\n+    pub(crate) fn block_def_map_query(\n+        db: &dyn DefDatabase,\n+        krate: CrateId,\n+        block: AstId<ast::BlockExpr>,\n+    ) -> Arc<DefMap> {\n+        let item_tree = db.item_tree(block.file_id);\n+        let block_items = item_tree.inner_items_of_block(block.value);\n+\n+        let parent = parent_def_map(db, krate, block);\n+\n+        if block_items.is_empty() {\n+            // If there are no inner items, nothing new is brought into scope, so we can just return\n+            // the parent DefMap. This keeps DefMap parent chains short.\n+            return parent;\n+        }\n+\n+        let mut def_map = DefMap::empty(krate, parent.edition);\n+        def_map.parent = Some(parent);\n+\n+        let def_map = collector::collect_defs(db, def_map, Some(block.value));\n         Arc::new(def_map)\n     }\n \n+    fn empty(krate: CrateId, edition: Edition) -> DefMap {\n+        let mut modules: Arena<ModuleData> = Arena::default();\n+        let root = modules.alloc(ModuleData::default());\n+        DefMap {\n+            parent: None,\n+            krate,\n+            edition,\n+            extern_prelude: FxHashMap::default(),\n+            prelude: None,\n+            root,\n+            modules,\n+            diagnostics: Vec::new(),\n+        }\n+    }\n+\n     pub fn add_diagnostics(\n         &self,\n         db: &dyn DefDatabase,\n@@ -251,7 +278,12 @@ impl DefMap {\n     // even), as this should be a great debugging aid.\n     pub fn dump(&self) -> String {\n         let mut buf = String::new();\n-        go(&mut buf, self, \"crate\", self.root);\n+        let mut current_map = self;\n+        while let Some(parent) = &current_map.parent {\n+            go(&mut buf, current_map, \"block scope\", current_map.root);\n+            current_map = &**parent;\n+        }\n+        go(&mut buf, current_map, \"crate\", current_map.root);\n         return buf;\n \n         fn go(buf: &mut String, map: &DefMap, path: &str, module: LocalModuleId) {\n@@ -303,6 +335,35 @@ impl ModuleData {\n     }\n }\n \n+fn parent_def_map(\n+    db: &dyn DefDatabase,\n+    krate: CrateId,\n+    block: AstId<ast::BlockExpr>,\n+) -> Arc<DefMap> {\n+    // FIXME: store this info in the item tree instead of reparsing here\n+    let ast_id_map = db.ast_id_map(block.file_id);\n+    let block_ptr = ast_id_map.get(block.value);\n+    let root = match db.parse_or_expand(block.file_id) {\n+        Some(it) => it,\n+        None => {\n+            return Arc::new(DefMap::empty(krate, Edition::Edition2018));\n+        }\n+    };\n+    let ast = block_ptr.to_node(&root);\n+\n+    for ancestor in ast.syntax().ancestors().skip(1) {\n+        if let Some(block_expr) = ast::BlockExpr::cast(ancestor) {\n+            let ancestor_id = ast_id_map.ast_id(&block_expr);\n+            let ast_id = InFile::new(block.file_id, ancestor_id);\n+            let parent_map = db.block_def_map(krate, ast_id);\n+            return parent_map;\n+        }\n+    }\n+\n+    // No enclosing block scope, so the parent is the crate-level DefMap.\n+    db.crate_def_map(krate)\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum ModuleSource {\n     SourceFile(ast::SourceFile),"}, {"sha": "cd68efbe67872e66d9e5cff970daf41a00b19881", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 41, "deletions": 17, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/47a70aadcedbcf28ad6d1ea59b77bf0e11493de0/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47a70aadcedbcf28ad6d1ea59b77bf0e11493de0/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=47a70aadcedbcf28ad6d1ea59b77bf0e11493de0", "patch": "@@ -45,7 +45,11 @@ const GLOB_RECURSION_LIMIT: usize = 100;\n const EXPANSION_DEPTH_LIMIT: usize = 128;\n const FIXED_POINT_LIMIT: usize = 8192;\n \n-pub(super) fn collect_defs(db: &dyn DefDatabase, mut def_map: DefMap) -> DefMap {\n+pub(super) fn collect_defs(\n+    db: &dyn DefDatabase,\n+    mut def_map: DefMap,\n+    block: Option<FileAstId<ast::BlockExpr>>,\n+) -> DefMap {\n     let crate_graph = db.crate_graph();\n \n     // populate external prelude\n@@ -93,6 +97,14 @@ pub(super) fn collect_defs(db: &dyn DefDatabase, mut def_map: DefMap) -> DefMap\n         exports_proc_macros: false,\n         from_glob_import: Default::default(),\n     };\n+    match block {\n+        Some(block) => {\n+            collector.seed_with_inner(block);\n+        }\n+        None => {\n+            collector.seed_with_top_level();\n+        }\n+    }\n     collector.collect();\n     collector.finish()\n }\n@@ -228,7 +240,7 @@ struct DefCollector<'a> {\n }\n \n impl DefCollector<'_> {\n-    fn collect(&mut self) {\n+    fn seed_with_top_level(&mut self) {\n         let file_id = self.db.crate_graph()[self.def_map.krate].root_file_id;\n         let item_tree = self.db.item_tree(file_id.into());\n         let module_id = self.def_map.root;\n@@ -248,7 +260,31 @@ impl DefCollector<'_> {\n             }\n             .collect(item_tree.top_level_items());\n         }\n+    }\n+\n+    fn seed_with_inner(&mut self, block: FileAstId<ast::BlockExpr>) {\n+        let file_id = self.db.crate_graph()[self.def_map.krate].root_file_id;\n+        let item_tree = self.db.item_tree(file_id.into());\n+        let module_id = self.def_map.root;\n+        self.def_map.modules[module_id].origin = ModuleOrigin::CrateRoot { definition: file_id };\n+        if item_tree\n+            .top_level_attrs(self.db, self.def_map.krate)\n+            .cfg()\n+            .map_or(true, |cfg| self.cfg_options.check(&cfg) != Some(false))\n+        {\n+            ModCollector {\n+                def_collector: &mut *self,\n+                macro_depth: 0,\n+                module_id,\n+                file_id: file_id.into(),\n+                item_tree: &item_tree,\n+                mod_dir: ModDir::root(),\n+            }\n+            .collect(item_tree.inner_items_of_block(block));\n+        }\n+    }\n \n+    fn collect(&mut self) {\n         // main name resolution fixed-point loop.\n         let mut i = 0;\n         loop {\n@@ -1470,7 +1506,6 @@ impl ModCollector<'_, '_> {\n mod tests {\n     use crate::{db::DefDatabase, test_db::TestDB};\n     use base_db::{fixture::WithFixture, SourceDatabase};\n-    use la_arena::Arena;\n \n     use super::*;\n \n@@ -1489,6 +1524,7 @@ mod tests {\n             exports_proc_macros: false,\n             from_glob_import: Default::default(),\n         };\n+        collector.seed_with_top_level();\n         collector.collect();\n         collector.def_map\n     }\n@@ -1497,20 +1533,8 @@ mod tests {\n         let (db, _file_id) = TestDB::with_single_file(&code);\n         let krate = db.test_crate();\n \n-        let def_map = {\n-            let edition = db.crate_graph()[krate].edition;\n-            let mut modules: Arena<ModuleData> = Arena::default();\n-            let root = modules.alloc(ModuleData::default());\n-            DefMap {\n-                krate,\n-                edition,\n-                extern_prelude: FxHashMap::default(),\n-                prelude: None,\n-                root,\n-                modules,\n-                diagnostics: Vec::new(),\n-            }\n-        };\n+        let edition = db.crate_graph()[krate].edition;\n+        let def_map = DefMap::empty(krate, edition);\n         do_collect_defs(&db, def_map)\n     }\n "}, {"sha": "ec90f4e65054e96b250d6493943649cf0d0d8dd9", "filename": "crates/hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/47a70aadcedbcf28ad6d1ea59b77bf0e11493de0/crates%2Fhir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47a70aadcedbcf28ad6d1ea59b77bf0e11493de0/crates%2Fhir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=47a70aadcedbcf28ad6d1ea59b77bf0e11493de0", "patch": "@@ -103,6 +103,43 @@ impl DefMap {\n         original_module: LocalModuleId,\n         path: &ModPath,\n         shadow: BuiltinShadowMode,\n+    ) -> ResolvePathResult {\n+        let mut result = ResolvePathResult::empty(ReachedFixedPoint::No);\n+        result.segment_index = Some(usize::max_value());\n+\n+        let mut current_map = self;\n+        loop {\n+            let new = current_map.resolve_path_fp_with_macro_single(\n+                db,\n+                mode,\n+                original_module,\n+                path,\n+                shadow,\n+            );\n+\n+            // Merge `new` into `result`.\n+            result.resolved_def = result.resolved_def.or(new.resolved_def);\n+            if result.reached_fixedpoint == ReachedFixedPoint::No {\n+                result.reached_fixedpoint = new.reached_fixedpoint;\n+            }\n+            // FIXME: this doesn't seem right; what if the different namespace resolutions come from different crates?\n+            result.krate = result.krate.or(new.krate);\n+            result.segment_index = result.segment_index.min(new.segment_index);\n+\n+            match &current_map.parent {\n+                Some(map) => current_map = map,\n+                None => return result,\n+            }\n+        }\n+    }\n+\n+    pub(super) fn resolve_path_fp_with_macro_single(\n+        &self,\n+        db: &dyn DefDatabase,\n+        mode: ResolveMode,\n+        original_module: LocalModuleId,\n+        path: &ModPath,\n+        shadow: BuiltinShadowMode,\n     ) -> ResolvePathResult {\n         let mut segments = path.segments.iter().enumerate();\n         let mut curr_per_ns: PerNs = match path.kind {"}, {"sha": "73e3a4702bfded46da17b38df87c1e381ae0263f", "filename": "crates/hir_def/src/nameres/tests.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/47a70aadcedbcf28ad6d1ea59b77bf0e11493de0/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47a70aadcedbcf28ad6d1ea59b77bf0e11493de0/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests.rs?ref=47a70aadcedbcf28ad6d1ea59b77bf0e11493de0", "patch": "@@ -4,11 +4,13 @@ mod macros;\n mod mod_resolution;\n mod diagnostics;\n mod primitives;\n+mod block;\n \n use std::sync::Arc;\n \n use base_db::{fixture::WithFixture, SourceDatabase};\n use expect_test::{expect, Expect};\n+use hir_expand::db::AstDatabase;\n use test_utils::mark;\n \n use crate::{db::DefDatabase, nameres::*, test_db::TestDB};\n@@ -19,12 +21,30 @@ fn compute_crate_def_map(ra_fixture: &str) -> Arc<DefMap> {\n     db.crate_def_map(krate)\n }\n \n+fn compute_block_def_map(ra_fixture: &str) -> Arc<DefMap> {\n+    let (db, position) = TestDB::with_position(ra_fixture);\n+    let module = db.module_for_file(position.file_id);\n+    let ast_map = db.ast_id_map(position.file_id.into());\n+    let ast = db.parse(position.file_id);\n+    let block: ast::BlockExpr =\n+        syntax::algo::find_node_at_offset(&ast.syntax_node(), position.offset).unwrap();\n+    let block_id = ast_map.ast_id(&block);\n+\n+    db.block_def_map(module.krate, InFile::new(position.file_id.into(), block_id))\n+}\n+\n fn check(ra_fixture: &str, expect: Expect) {\n     let def_map = compute_crate_def_map(ra_fixture);\n     let actual = def_map.dump();\n     expect.assert_eq(&actual);\n }\n \n+fn check_at(ra_fixture: &str, expect: Expect) {\n+    let def_map = compute_block_def_map(ra_fixture);\n+    let actual = def_map.dump();\n+    expect.assert_eq(&actual);\n+}\n+\n #[test]\n fn crate_def_map_smoke_test() {\n     check("}, {"sha": "ab7ec9d62daf2310263c9f78da9e1fd0169a59e7", "filename": "crates/hir_def/src/nameres/tests/block.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/47a70aadcedbcf28ad6d1ea59b77bf0e11493de0/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47a70aadcedbcf28ad6d1ea59b77bf0e11493de0/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fblock.rs?ref=47a70aadcedbcf28ad6d1ea59b77bf0e11493de0", "patch": "@@ -0,0 +1,72 @@\n+use super::*;\n+\n+#[test]\n+fn inner_item_smoke() {\n+    check_at(\n+        r#\"\n+//- /lib.rs\n+struct inner {}\n+fn outer() {\n+    $0\n+    fn inner() {}\n+}\n+\"#,\n+        expect![[r#\"\n+            block scope\n+            inner: v\n+            crate\n+            inner: t\n+            outer: v\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn use_from_crate() {\n+    check_at(\n+        r#\"\n+//- /lib.rs\n+struct Struct;\n+fn outer() {\n+    use Struct;\n+    use crate::Struct as CrateStruct;\n+    use self::Struct as SelfStruct;\n+    $0\n+}\n+\"#,\n+        expect![[r#\"\n+            block scope\n+            CrateStruct: t v\n+            SelfStruct: t v\n+            Struct: t v\n+            crate\n+            Struct: t v\n+            outer: v\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn merge_namespaces() {\n+    check_at(\n+        r#\"\n+//- /lib.rs\n+struct name {}\n+fn outer() {\n+    fn name() {}\n+\n+    use name as imported; // should import both `name`s\n+\n+    $0\n+}\n+\"#,\n+        expect![[r#\"\n+            block scope\n+            imported: t v\n+            name: v\n+            crate\n+            name: t\n+            outer: v\n+        \"#]],\n+    );\n+}"}, {"sha": "9d9b6de7a15b34e05dabe6b2166522d76b9de7c4", "filename": "crates/ide_db/src/apply_change.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/47a70aadcedbcf28ad6d1ea59b77bf0e11493de0/crates%2Fide_db%2Fsrc%2Fapply_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47a70aadcedbcf28ad6d1ea59b77bf0e11493de0/crates%2Fide_db%2Fsrc%2Fapply_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fapply_change.rs?ref=47a70aadcedbcf28ad6d1ea59b77bf0e11493de0", "patch": "@@ -149,6 +149,7 @@ impl RootDatabase {\n \n             // DefDatabase\n             hir::db::ItemTreeQuery\n+            hir::db::BlockDefMapQuery\n             hir::db::CrateDefMapQueryQuery\n             hir::db::StructDataQuery\n             hir::db::UnionDataQuery"}]}