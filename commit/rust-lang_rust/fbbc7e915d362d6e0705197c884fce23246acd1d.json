{"sha": "fbbc7e915d362d6e0705197c884fce23246acd1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiYmM3ZTkxNWQzNjJkNmUwNzA1MTk3Yzg4NGZjZTIzMjQ2YWNkMWQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-12-08T09:26:34Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T07:26:13Z"}, "message": "rustc: rewrite PrintCx::parameterized to be much simpler and more general.", "tree": {"sha": "3e6879c4fe02759fee3eaa8606c2ad13b11e11e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e6879c4fe02759fee3eaa8606c2ad13b11e11e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbbc7e915d362d6e0705197c884fce23246acd1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbbc7e915d362d6e0705197c884fce23246acd1d", "html_url": "https://github.com/rust-lang/rust/commit/fbbc7e915d362d6e0705197c884fce23246acd1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbbc7e915d362d6e0705197c884fce23246acd1d/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "939c69c71f8583e37f536a0c6da75c31bc878383", "url": "https://api.github.com/repos/rust-lang/rust/commits/939c69c71f8583e37f536a0c6da75c31bc878383", "html_url": "https://github.com/rust-lang/rust/commit/939c69c71f8583e37f536a0c6da75c31bc878383"}], "stats": {"total": 333, "additions": 124, "deletions": 209}, "files": [{"sha": "20acbb5b9c7122d37517bf21db7e1bcadeb66faf", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc7e915d362d6e0705197c884fce23246acd1d/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc7e915d362d6e0705197c884fce23246acd1d/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=fbbc7e915d362d6e0705197c884fce23246acd1d", "patch": "@@ -616,7 +616,7 @@ impl<'tcx> List<ExistentialPredicate<'tcx>> {\n \n     #[inline]\n     pub fn projection_bounds<'a>(&'a self) ->\n-        impl Iterator<Item=ExistentialProjection<'tcx>> + Clone + 'a {\n+        impl Iterator<Item=ExistentialProjection<'tcx>> + 'a {\n         self.iter().filter_map(|predicate| {\n             match *predicate {\n                 ExistentialPredicate::Projection(p) => Some(p),"}, {"sha": "8c67cdf62b62f3e85d024bcb5e709b649b0ac2f0", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc7e915d362d6e0705197c884fce23246acd1d/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc7e915d362d6e0705197c884fce23246acd1d/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=fbbc7e915d362d6e0705197c884fce23246acd1d", "patch": "@@ -114,8 +114,6 @@ impl<'tcx> Kind<'tcx> {\n     }\n }\n \n-            UnpackedKind::Const(ct) => write!(f, \"{:?}\", ct),\n-            UnpackedKind::Const(ct) => write!(f, \"{}\", ct),\n impl<'a, 'tcx> Lift<'tcx> for Kind<'a> {\n     type Lifted = Kind<'tcx>;\n "}, {"sha": "8dfa924c1dfc9865f1b0c53182a4218fed757e01", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 123, "deletions": 206, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc7e915d362d6e0705197c884fce23246acd1d/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc7e915d362d6e0705197c884fce23246acd1d/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=fbbc7e915d362d6e0705197c884fce23246acd1d", "patch": "@@ -8,7 +8,7 @@ use crate::ty::{Error, Str, Array, Slice, Float, FnDef, FnPtr};\n use crate::ty::{Param, Bound, RawPtr, Ref, Never, Tuple};\n use crate::ty::{Closure, Generator, GeneratorWitness, Foreign, Projection, Opaque};\n use crate::ty::{Placeholder, UnnormalizedProjection, Dynamic, Int, Uint, Infer};\n-use crate::ty::{self, Ty, TypeFoldable, GenericParamCount, GenericParamDefKind, ParamConst};\n+use crate::ty::{self, ParamConst, Ty, TypeFoldable};\n use crate::ty::print::{PrintCx, Print};\n use crate::mir::interpret::ConstValue;\n \n@@ -314,225 +314,130 @@ impl PrintCx<'a, 'gcx, 'tcx> {\n     fn parameterized<F: fmt::Write>(\n         &mut self,\n         f: &mut F,\n-        did: DefId,\n+        mut def_id: DefId,\n         substs: SubstsRef<'tcx>,\n-        projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>> + Clone,\n+        projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n     ) -> fmt::Result {\n-        let key = self.tcx.def_key(did);\n-\n-        let verbose = self.is_verbose;\n-        let mut num_supplied_defaults = 0;\n-        let has_self;\n-        let mut own_counts: GenericParamCount = Default::default();\n-        let mut is_value_path = false;\n-        let mut item_name = Some(key.disambiguated_data.data.as_interned_str());\n-        let mut path_def_id = did;\n-        {\n-            // Unfortunately, some kinds of items (e.g., closures) don't have\n-            // generics. So walk back up the find the closest parent that DOES\n-            // have them.\n-            let mut item_def_id = did;\n-            loop {\n-                let key = self.tcx.def_key(item_def_id);\n-                match key.disambiguated_data.data {\n-                    DefPathData::AssocTypeInTrait(_) |\n-                    DefPathData::AssocTypeInImpl(_) |\n-                    DefPathData::AssocExistentialInImpl(_) |\n-                    DefPathData::Trait(_) |\n-                    DefPathData::TraitAlias(_) |\n-                    DefPathData::Impl |\n-                    DefPathData::TypeNs(_) => {\n-                        break;\n-                    }\n-                    DefPathData::ValueNs(_) |\n-                    DefPathData::EnumVariant(_) => {\n-                        is_value_path = true;\n-                        break;\n-                    }\n-                    DefPathData::CrateRoot |\n-                    DefPathData::Misc |\n-                    DefPathData::Module(_) |\n-                    DefPathData::MacroDef(_) |\n-                    DefPathData::ClosureExpr |\n-                    DefPathData::TypeParam(_) |\n-                    DefPathData::LifetimeParam(_) |\n-                    DefPathData::ConstParam(_) |\n-                    DefPathData::Field(_) |\n-                    DefPathData::StructCtor |\n-                    DefPathData::AnonConst |\n-                    DefPathData::ImplTrait |\n-                    DefPathData::GlobalMetaData(_) => {\n-                        // if we're making a symbol for something, there ought\n-                        // to be a value or type-def or something in there\n-                        // *somewhere*\n-                        item_def_id.index = key.parent.unwrap_or_else(|| {\n-                            bug!(\"finding type for {:?}, encountered def-id {:?} with no \\\n-                                 parent\", did, item_def_id);\n-                        });\n-                    }\n-                }\n+        let mut key = self.tcx.def_key(def_id);\n+        let is_value_ns = match key.disambiguated_data.data {\n+            DefPathData::ValueNs(_) |\n+            DefPathData::EnumVariant(_) => true,\n+\n+            // Skip `StructCtor` so that `Struct::<T>` will be printed,\n+            // instead of the less pretty `Struct<T>::{{constructor}}`.\n+            DefPathData::StructCtor => {\n+                def_id.index = key.parent.unwrap();\n+                key = self.tcx.def_key(def_id);\n+                true\n             }\n-            let mut generics = self.tcx.generics_of(item_def_id);\n-            let child_own_counts = generics.own_counts();\n-            has_self = generics.has_self;\n-\n-            let mut child_types = 0;\n-            if let Some(def_id) = generics.parent {\n-                // Methods.\n-                assert!(is_value_path);\n-                child_types = child_own_counts.types;\n-                generics = self.tcx.generics_of(def_id);\n-                own_counts = generics.own_counts();\n-\n-                if has_self {\n-                    print!(f, self, write(\"<\"), print_display(substs.type_at(0)), write(\" as \"))?;\n-                }\n \n-                path_def_id = def_id;\n-            } else {\n-                item_name = None;\n-\n-                if is_value_path {\n-                    // Functions.\n-                    assert_eq!(has_self, false);\n-                } else {\n-                    // Types and traits.\n-                    own_counts = child_own_counts;\n-                }\n-            }\n+            _ => false,\n+        };\n \n-            if !verbose {\n-                let mut type_params =\n-                    generics.params.iter().rev().filter_map(|param| match param.kind {\n-                        GenericParamDefKind::Lifetime => None,\n-                        GenericParamDefKind::Type { has_default, .. } => {\n-                            Some((param.def_id, has_default))\n-                        }\n-                        GenericParamDefKind::Const => None, // FIXME(const_generics:defaults)\n-                    }).peekable();\n-                let has_default = {\n-                    let has_default = type_params.peek().map(|(_, has_default)| has_default);\n-                    *has_default.unwrap_or(&false)\n-                };\n-                if has_default {\n-                    let types = substs.types().rev().skip(child_types);\n-                    for ((def_id, has_default), actual) in type_params.zip(types) {\n-                        if !has_default {\n-                            break;\n-                        }\n-                        if self.tcx.type_of(def_id).subst(self.tcx, substs) != actual {\n-                            break;\n-                        }\n-                        num_supplied_defaults += 1;\n-                    }\n-                }\n+        let generics = self.tcx.generics_of(def_id);\n+\n+        if let Some(parent_def_id) = generics.parent {\n+            assert_eq!(parent_def_id, DefId { index: key.parent.unwrap(), ..def_id });\n+\n+            let parent_generics = self.tcx.generics_of(parent_def_id);\n+            let parent_has_own_self =\n+                parent_generics.has_self && parent_generics.parent_count == 0;\n+            if parent_has_own_self {\n+                print!(f, self, write(\"<\"), print_display(substs.type_at(0)), write(\" as \"))?;\n             }\n-        }\n-        print!(f, self, write(\"{}\", self.tcx.item_path_str(path_def_id)))?;\n-        let fn_trait_kind = self.tcx.lang_items().fn_trait_kind(path_def_id);\n-\n-        if !verbose && fn_trait_kind.is_some() {\n-            if let Tuple(ref args) = substs.type_at(1).sty {\n-                let mut projections = projections.clone();\n-                if let (Some(proj), None) = (projections.next(), projections.next()) {\n-                    return self.fn_sig(f, args, false, proj.ty);\n-                }\n+            self.parameterized(f, parent_def_id, substs, iter::empty())?;\n+            if parent_has_own_self {\n+                write!(f, \">\")?;\n             }\n+\n+            write!(f, \"::{}\", key.disambiguated_data.data.as_interned_str())?;\n+        } else {\n+            print!(f, self, write(\"{}\", self.tcx.item_path_str(def_id)))?;\n         }\n \n-        let empty = Cell::new(true);\n-        let start_or_continue = |f: &mut F, start: &str, cont: &str| {\n-            if empty.get() {\n-                empty.set(false);\n+        let mut empty = true;\n+        let mut start_or_continue = |f: &mut F, start: &str, cont: &str| {\n+            if empty {\n+                empty = false;\n                 write!(f, \"{}\", start)\n             } else {\n                 write!(f, \"{}\", cont)\n             }\n         };\n \n-        let print_regions = |f: &mut F, start: &str, skip, count| {\n-            // Don't print any regions if they're all erased.\n-            let regions = || substs.regions().skip(skip).take(count);\n-            if regions().all(|r: ty::Region<'_>| *r == ty::ReErased) {\n-                return Ok(());\n+        let start = if is_value_ns { \"::<\" } else { \"<\" };\n+\n+        let has_own_self = generics.has_self && generics.parent_count == 0;\n+        let params = &generics.params[has_own_self as usize..];\n+\n+        // Don't print any regions if they're all erased.\n+        let print_regions = params.iter().any(|param| {\n+            match substs[param.index as usize].unpack() {\n+                UnpackedKind::Lifetime(r) => *r != ty::ReErased,\n+                _ => false,\n             }\n+        });\n+\n+        // Don't print args that are the defaults of their respective parameters.\n+        let num_supplied_defaults = if self.is_verbose {\n+            0\n+        } else {\n+            params.iter().rev().take_while(|param| {\n+                match param.kind {\n+                    ty::GenericParamDefKind::Lifetime => false,\n+                    ty::GenericParamDefKind::Type { has_default, .. } => {\n+                        has_default && substs[param.index as usize] == Kind::from(\n+                            self.tcx.type_of(param.def_id).subst(self.tcx, substs)\n+                        )\n+                    }\n+                    ty::GenericParamDefKind::Const => false, // FIXME(const_generics:defaults)\n+                }\n+            }).count()\n+        };\n \n-            for region in regions() {\n-                let region: ty::Region<'_> = region;\n-                start_or_continue(f, start, \", \")?;\n-                if verbose {\n-                    write!(f, \"{:?}\", region)?;\n-                } else {\n-                    let s = region.to_string();\n-                    if s.is_empty() {\n-                        // This happens when the value of the region\n-                        // parameter is not easily serialized. This may be\n-                        // because the user omitted it in the first place,\n-                        // or because it refers to some block in the code,\n-                        // etc. I'm not sure how best to serialize this.\n-                        write!(f, \"'_\")?;\n+        for param in &params[..params.len() - num_supplied_defaults] {\n+            match substs[param.index as usize].unpack() {\n+                UnpackedKind::Lifetime(region) => {\n+                    if !print_regions {\n+                        continue;\n+                    }\n+                    start_or_continue(f, start, \", \")?;\n+                    if self.is_verbose {\n+                        write!(f, \"{:?}\", region)?;\n                     } else {\n-                        write!(f, \"{}\", s)?;\n+                        let s = region.to_string();\n+                        if s.is_empty() {\n+                            // This happens when the value of the region\n+                            // parameter is not easily serialized. This may be\n+                            // because the user omitted it in the first place,\n+                            // or because it refers to some block in the code,\n+                            // etc. I'm not sure how best to serialize this.\n+                            write!(f, \"'_\")?;\n+                        } else {\n+                            write!(f, \"{}\", s)?;\n+                        }\n                     }\n                 }\n+                UnpackedKind::Type(ty) => {\n+                    start_or_continue(f, start, \", \")?;\n+                    ty.print_display(f, self)?;\n+                }\n+                UnpackedKind::Const(ct) => {\n+                    start_or_continue(f, start, \", \")?;\n+                    ct.print_display(f, self)?;\n+                }\n             }\n-\n-            Ok(())\n-        };\n-\n-        print_regions(f, \"<\", 0, own_counts.lifetimes)?;\n-\n-        let tps = substs.types()\n-                        .take(own_counts.types - num_supplied_defaults)\n-                        .skip(has_self as usize);\n-\n-        for ty in tps {\n-            start_or_continue(f, \"<\", \", \")?;\n-            ty.print_display(f, self)?;\n         }\n \n         for projection in projections {\n-            start_or_continue(f, \"<\", \", \")?;\n+            start_or_continue(f, start, \", \")?;\n             print!(f, self,\n                     write(\"{}=\",\n                             self.tcx.associated_item(projection.item_def_id).ident),\n                     print_display(projection.ty))?;\n         }\n \n-        // FIXME(const_generics::defaults)\n-        let consts = substs.consts();\n-\n-        for ct in consts {\n-            start_or_continue(f, \"<\", \", \")?;\n-            ct.print_display(f, self)?;\n-        }\n-\n-        start_or_continue(f, \"\", \">\")?;\n-\n-        // For values, also print their name and type parameters.\n-        if is_value_path {\n-            empty.set(true);\n-\n-            if has_self {\n-                write!(f, \">\")?;\n-            }\n-\n-            if let Some(item_name) = item_name {\n-                write!(f, \"::{}\", item_name)?;\n-            }\n-\n-            print_regions(f, \"::<\", own_counts.lifetimes, usize::MAX)?;\n-\n-            // FIXME: consider being smart with defaults here too\n-            for ty in substs.types().skip(own_counts.types) {\n-                start_or_continue(f, \"::<\", \", \")?;\n-                ty.print_display(f, self)?;\n-            }\n-\n-            start_or_continue(f, \"\", \">\")?;\n-        }\n-\n-        Ok(())\n+        start_or_continue(f, \"\", \">\")\n     }\n \n     fn in_binder<T, F>(&mut self, f: &mut F, value: &ty::Binder<T>) -> fmt::Result\n@@ -626,19 +531,34 @@ define_print! {\n     ('tcx) &'tcx ty::List<ty::ExistentialPredicate<'tcx>>, (self, f, cx) {\n         display {\n             // Generate the main trait ref, including associated types.\n-\n-            // Use a type that can't appear in defaults of type parameters.\n-            let dummy_self = cx.tcx.mk_infer(ty::FreshTy(0));\n             let mut first = true;\n \n             if let Some(principal) = self.principal() {\n-                let principal = principal.with_self_ty(cx.tcx, dummy_self);\n-                cx.parameterized(\n-                    f,\n-                    principal.def_id,\n-                    principal.substs,\n-                    self.projection_bounds(),\n-                )?;\n+                let mut resugared_principal = false;\n+\n+                // Special-case `Fn(...) -> ...` and resugar it.\n+                if !cx.is_verbose && cx.tcx.lang_items().fn_trait_kind(principal.def_id).is_some() {\n+                    if let Tuple(ref args) = principal.substs.type_at(0).sty {\n+                        let mut projections = self.projection_bounds();\n+                        if let (Some(proj), None) = (projections.next(), projections.next()) {\n+                            print!(f, cx, write(\"{}\", cx.tcx.item_path_str(principal.def_id)))?;\n+                            cx.fn_sig(f, args, false, proj.ty)?;\n+                            resugared_principal = true;\n+                        }\n+                    }\n+                }\n+\n+                if !resugared_principal {\n+                    // Use a type that can't appear in defaults of type parameters.\n+                    let dummy_self = cx.tcx.mk_infer(ty::FreshTy(0));\n+                    let principal = principal.with_self_ty(cx.tcx, dummy_self);\n+                    cx.parameterized(\n+                        f,\n+                        principal.def_id,\n+                        principal.substs,\n+                        self.projection_bounds(),\n+                    )?;\n+                }\n                 first = false;\n             }\n \n@@ -1468,12 +1388,7 @@ define_print! {\n define_print! {\n     ('tcx) ty::ProjectionTy<'tcx>, (self, f, cx) {\n         display {\n-            // FIXME(tschottdorf): use something like\n-            //   parameterized(f, self.substs, self.item_def_id, &[])\n-            // (which currently ICEs).\n-            let trait_ref = self.trait_ref(cx.tcx);\n-            let item_name = cx.tcx.associated_item(self.item_def_id).ident;\n-            print!(f, cx, print_debug(trait_ref), write(\"::{}\", item_name))\n+            cx.parameterized(f, self.item_def_id, self.substs, iter::empty())\n         }\n     }\n }\n@@ -1542,12 +1457,14 @@ define_print! {\n             match self.unpack() {\n                 UnpackedKind::Lifetime(lt) => print!(f, cx, print(lt)),\n                 UnpackedKind::Type(ty) => print!(f, cx, print(ty)),\n+                UnpackedKind::Const(ct) => print!(f, cx, print(ct)),\n             }\n         }\n         debug {\n             match self.unpack() {\n                 UnpackedKind::Lifetime(lt) => print!(f, cx, print(lt)),\n                 UnpackedKind::Type(ty) => print!(f, cx, print(ty)),\n+                UnpackedKind::Const(ct) => print!(f, cx, print(ct)),\n             }\n         }\n     }"}]}