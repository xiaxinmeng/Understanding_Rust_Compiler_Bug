{"sha": "09b37d743328bd497939bd27135f82350f1b0bd7", "node_id": "C_kwDOAAsO6NoAKDA5YjM3ZDc0MzMyOGJkNDk3OTM5YmQyNzEzNWY4MjM1MGYxYjBiZDc", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-09-21T05:56:45Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-09-21T15:04:44Z"}, "message": "Use ZST for fmt unsafety\n\nThis allows the format_args! macro to keep the pre-expansion code out of\nthe unsafe block without doing gymnastics with nested `match`\nexpressions. This reduces codegen.", "tree": {"sha": "48d14423db8c6c1d1fcd2049f25dc5b88db024c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48d14423db8c6c1d1fcd2049f25dc5b88db024c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09b37d743328bd497939bd27135f82350f1b0bd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09b37d743328bd497939bd27135f82350f1b0bd7", "html_url": "https://github.com/rust-lang/rust/commit/09b37d743328bd497939bd27135f82350f1b0bd7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09b37d743328bd497939bd27135f82350f1b0bd7/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db1fb85cff63ad5fffe435e17128f99f9e1d970c", "url": "https://api.github.com/repos/rust-lang/rust/commits/db1fb85cff63ad5fffe435e17128f99f9e1d970c", "html_url": "https://github.com/rust-lang/rust/commit/db1fb85cff63ad5fffe435e17128f99f9e1d970c"}], "stats": {"total": 208, "additions": 108, "deletions": 100}, "files": [{"sha": "9b9adc2d7f3b8be490900c8282dd03e9be8ad415", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/09b37d743328bd497939bd27135f82350f1b0bd7/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09b37d743328bd497939bd27135f82350f1b0bd7/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=09b37d743328bd497939bd27135f82350f1b0bd7", "patch": "@@ -845,8 +845,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             self.ecx.expr_match(self.macsp, head, vec![arm])\n         };\n \n-        let ident = Ident::from_str_and_span(\"args\", self.macsp);\n-        let args_slice = self.ecx.expr_ident(self.macsp, ident);\n+        let args_slice = self.ecx.expr_addr_of(self.macsp, args_match);\n \n         // Now create the fmt::Arguments struct with all our locals we created.\n         let (fn_name, fn_args) = if self.all_pieces_simple {\n@@ -856,25 +855,22 @@ impl<'a, 'b> Context<'a, 'b> {\n             // nonstandard placeholders, if there are any.\n             let fmt = self.ecx.expr_vec_slice(self.macsp, self.pieces);\n \n-            (\"new_v1_formatted\", vec![pieces, args_slice, fmt])\n+            let path = self.ecx.std_path(&[sym::fmt, sym::UnsafeArg, sym::new]);\n+            let unsafe_arg = self.ecx.expr_call_global(self.macsp, path, Vec::new());\n+            let unsafe_expr = self.ecx.expr_block(P(ast::Block {\n+                stmts: vec![self.ecx.stmt_expr(unsafe_arg)],\n+                id: ast::DUMMY_NODE_ID,\n+                rules: BlockCheckMode::Unsafe(UnsafeSource::CompilerGenerated),\n+                span: self.macsp,\n+                tokens: None,\n+                could_be_bare_literal: false,\n+            }));\n+\n+            (\"new_v1_formatted\", vec![pieces, args_slice, fmt, unsafe_expr])\n         };\n \n         let path = self.ecx.std_path(&[sym::fmt, sym::Arguments, Symbol::intern(fn_name)]);\n-        let arguments = self.ecx.expr_call_global(self.macsp, path, fn_args);\n-        let body = self.ecx.expr_block(P(ast::Block {\n-            stmts: vec![self.ecx.stmt_expr(arguments)],\n-            id: ast::DUMMY_NODE_ID,\n-            rules: BlockCheckMode::Unsafe(UnsafeSource::CompilerGenerated),\n-            span: self.macsp,\n-            tokens: None,\n-            could_be_bare_literal: false,\n-        }));\n-\n-        let ident = Ident::from_str_and_span(\"args\", self.macsp);\n-        let binding_mode = ast::BindingMode::ByRef(ast::Mutability::Not);\n-        let pat = self.ecx.pat_ident_binding_mode(self.macsp, ident, binding_mode);\n-        let arm = self.ecx.arm(self.macsp, pat, body);\n-        self.ecx.expr_match(self.macsp, args_match, vec![arm])\n+        self.ecx.expr_call_global(self.macsp, path, fn_args)\n     }\n \n     fn format_arg("}, {"sha": "be6f5fc2978900c2b043ba92fb32a978e9f00b48", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/09b37d743328bd497939bd27135f82350f1b0bd7/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09b37d743328bd497939bd27135f82350f1b0bd7/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=09b37d743328bd497939bd27135f82350f1b0bd7", "patch": "@@ -253,6 +253,7 @@ symbols! {\n         TyCtxt,\n         TyKind,\n         Unknown,\n+        UnsafeArg,\n         Vec,\n         Yield,\n         _DECLS,"}, {"sha": "8fa941c42fc214c1b5e4a6d68869b829696b5380", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 44, "deletions": 9, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/09b37d743328bd497939bd27135f82350f1b0bd7/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09b37d743328bd497939bd27135f82350f1b0bd7/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=09b37d743328bd497939bd27135f82350f1b0bd7", "patch": "@@ -265,6 +265,26 @@ pub struct ArgumentV1<'a> {\n     formatter: fn(&Opaque, &mut Formatter<'_>) -> Result,\n }\n \n+/// This struct represents the unsafety of constructing an `Arguments`.\n+/// It exists, rather than an unsafe function, in order to simplify the expansion\n+/// of `format_args!(..)` and reduce the scope of the `unsafe` block.\n+#[allow(missing_debug_implementations)]\n+#[doc(hidden)]\n+#[non_exhaustive]\n+#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n+pub struct UnsafeArg;\n+\n+impl UnsafeArg {\n+    /// See documentation where `UnsafeArg` is required to know when it is safe to\n+    /// create and use `UnsafeArg`.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n+    #[inline(always)]\n+    pub unsafe fn new() -> Self {\n+        Self\n+    }\n+}\n+\n // This guarantees a single stable value for the function pointer associated with\n // indices/counts in the formatting infrastructure.\n //\n@@ -337,22 +357,37 @@ impl<'a> Arguments<'a> {\n     #[inline]\n     #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n     #[rustc_const_unstable(feature = \"const_fmt_arguments_new\", issue = \"none\")]\n-    pub const unsafe fn new_v1(\n-        pieces: &'a [&'static str],\n-        args: &'a [ArgumentV1<'a>],\n-    ) -> Arguments<'a> {\n+    pub const fn new_v1(pieces: &'a [&'static str], args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n         if pieces.len() < args.len() || pieces.len() > args.len() + 1 {\n             panic!(\"invalid args\");\n         }\n         Arguments { pieces, fmt: None, args }\n     }\n \n     /// This function is used to specify nonstandard formatting parameters.\n-    /// The `pieces` array must be at least as long as `fmt` to construct\n-    /// a valid Arguments structure. Also, any `Count` within `fmt` that is\n-    /// `CountIsParam` or `CountIsNextParam` has to point to an argument\n-    /// created with `argumentusize`. However, failing to do so doesn't cause\n-    /// unsafety, but will ignore invalid .\n+    ///\n+    /// An `UnsafeArg` is required because the following invariants must be held\n+    /// in order for this function to be safe:\n+    /// 1. The `pieces` slice must be at least as long as `fmt`.\n+    /// 2. Every [`rt::v1::Argument::position`] value within `fmt` must be a\n+    ///    valid index of `args`.\n+    /// 3. Every [`Count::Param`] within `fmt` must contain a valid index of\n+    ///    `args`.\n+    #[cfg(not(bootstrap))]\n+    #[doc(hidden)]\n+    #[inline]\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n+    #[rustc_const_unstable(feature = \"const_fmt_arguments_new\", issue = \"none\")]\n+    pub const fn new_v1_formatted(\n+        pieces: &'a [&'static str],\n+        args: &'a [ArgumentV1<'a>],\n+        fmt: &'a [rt::v1::Argument],\n+        _unsafe_arg: UnsafeArg,\n+    ) -> Arguments<'a> {\n+        Arguments { pieces, fmt: Some(fmt), args }\n+    }\n+\n+    #[cfg(bootstrap)]\n     #[doc(hidden)]\n     #[inline]\n     #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]"}, {"sha": "6d3ec6ae8612a109987df7a91c59d319bdbe8fcd", "filename": "library/core/src/panicking.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/09b37d743328bd497939bd27135f82350f1b0bd7/library%2Fcore%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09b37d743328bd497939bd27135f82350f1b0bd7/library%2Fcore%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanicking.rs?ref=09b37d743328bd497939bd27135f82350f1b0bd7", "patch": "@@ -47,10 +47,7 @@ pub fn panic(expr: &'static str) -> ! {\n     // truncation and padding (even though none is used here). Using\n     // Arguments::new_v1 may allow the compiler to omit Formatter::pad from the\n     // output binary, saving up to a few kilobytes.\n-    panic_fmt(\n-        // SAFETY: Arguments::new_v1 is safe with exactly one str and zero args\n-        unsafe { fmt::Arguments::new_v1(&[expr], &[]) },\n-    );\n+    panic_fmt(fmt::Arguments::new_v1(&[expr], &[]));\n }\n \n #[inline]"}, {"sha": "f4be3c1c63a84e5d8fda7b09ff7cf076ed3bebe6", "filename": "src/test/pretty/dollar-crate.pp", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/09b37d743328bd497939bd27135f82350f1b0bd7/src%2Ftest%2Fpretty%2Fdollar-crate.pp", "raw_url": "https://github.com/rust-lang/rust/raw/09b37d743328bd497939bd27135f82350f1b0bd7/src%2Ftest%2Fpretty%2Fdollar-crate.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fdollar-crate.pp?ref=09b37d743328bd497939bd27135f82350f1b0bd7", "patch": "@@ -10,11 +10,9 @@\n \n fn main() {\n     {\n-        ::std::io::_print(match match () { () => [], } {\n-                              ref args => unsafe {\n-                                  ::core::fmt::Arguments::new_v1(&[\"rust\\n\"],\n-                                                                 args)\n-                              }\n-                          });\n+        ::std::io::_print(::core::fmt::Arguments::new_v1(&[\"rust\\n\"],\n+                                                         &match () {\n+                                                              () => [],\n+                                                          }));\n     };\n }"}, {"sha": "199aee05622beed636c3966d6a00f091fae86cdd", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 23, "deletions": 33, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/09b37d743328bd497939bd27135f82350f1b0bd7/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/09b37d743328bd497939bd27135f82350f1b0bd7/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=09b37d743328bd497939bd27135f82350f1b0bd7", "patch": "@@ -32,39 +32,29 @@\n                   ({\n                        let res =\n                            ((::alloc::fmt::format as\n-                                for<'r> fn(Arguments<'r>) -> String {format})((match (match (()\n-                                                                                                as\n-                                                                                                ())\n-                                                                                          {\n-                                                                                          ()\n-                                                                                          =>\n-                                                                                          ([]\n-                                                                                              as\n-                                                                                              [ArgumentV1; 0]),\n-                                                                                      }\n-                                                                                         as\n-                                                                                         [ArgumentV1; 0])\n-                                                                                   {\n-                                                                                   ref args\n-                                                                                   =>\n-                                                                                   unsafe\n-                                                                                   {\n-                                                                                       ((::core::fmt::Arguments::new_v1\n-                                                                                            as\n-                                                                                            unsafe fn(&[&'static str], &[ArgumentV1]) -> Arguments {Arguments::new_v1})((&([(\"test\"\n-                                                                                                                                                                                as\n-                                                                                                                                                                                &str)]\n-                                                                                                                                                                              as\n-                                                                                                                                                                              [&str; 1])\n-                                                                                                                                                                            as\n-                                                                                                                                                                            &[&str; 1]),\n-                                                                                                                                                                        (args\n-                                                                                                                                                                            as\n-                                                                                                                                                                            &[ArgumentV1; 0]))\n-                                                                                           as\n-                                                                                           Arguments)\n-                                                                                   }\n-                                                                               }\n+                                for<'r> fn(Arguments<'r>) -> String {format})(((::core::fmt::Arguments::new_v1\n+                                                                                   as\n+                                                                                   fn(&[&'static str], &[ArgumentV1]) -> Arguments {Arguments::new_v1})((&([(\"test\"\n+                                                                                                                                                                as\n+                                                                                                                                                                &str)]\n+                                                                                                                                                              as\n+                                                                                                                                                              [&str; 1])\n+                                                                                                                                                            as\n+                                                                                                                                                            &[&str; 1]),\n+                                                                                                                                                        (&(match (()\n+                                                                                                                                                                     as\n+                                                                                                                                                                     ())\n+                                                                                                                                                               {\n+                                                                                                                                                               ()\n+                                                                                                                                                               =>\n+                                                                                                                                                               ([]\n+                                                                                                                                                                   as\n+                                                                                                                                                                   [ArgumentV1; 0]),\n+                                                                                                                                                           }\n+                                                                                                                                                              as\n+                                                                                                                                                              [ArgumentV1; 0])\n+                                                                                                                                                            as\n+                                                                                                                                                            &[ArgumentV1; 0]))\n                                                                                   as\n                                                                                   Arguments))\n                                as String);"}, {"sha": "31e93ef54f26034ffdf2a558bbcc403c47fd4177", "filename": "src/test/ui/attributes/key-value-expansion.stderr", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/09b37d743328bd497939bd27135f82350f1b0bd7/src%2Ftest%2Fui%2Fattributes%2Fkey-value-expansion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09b37d743328bd497939bd27135f82350f1b0bd7/src%2Ftest%2Fui%2Fattributes%2Fkey-value-expansion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fkey-value-expansion.stderr?ref=09b37d743328bd497939bd27135f82350f1b0bd7", "patch": "@@ -17,16 +17,12 @@ LL | bug!();\n \n error: unexpected token: `{\n     let res =\n-        ::alloc::fmt::format(match match (&\"u8\",) {\n-                                       (arg0,) =>\n-                                       [::core::fmt::ArgumentV1::new(arg0,\n-                                                                     ::core::fmt::Display::fmt)],\n-                                   } {\n-                                 ref args => unsafe {\n-                                     ::core::fmt::Arguments::new_v1(&[\"\"],\n-                                                                    args)\n-                                 }\n-                             });\n+        ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&[\"\"],\n+                                                            &match (&\"u8\",) {\n+                                                                 (arg0,) =>\n+                                                                 [::core::fmt::ArgumentV1::new(arg0,\n+                                                                                               ::core::fmt::Display::fmt)],\n+                                                             }));\n     res\n }.as_str()`\n   --> $DIR/key-value-expansion.rs:48:23"}, {"sha": "ff55ff35a13432bfb2940c02c6ea1f4825f7eaee", "filename": "src/tools/clippy/clippy_utils/src/higher.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/09b37d743328bd497939bd27135f82350f1b0bd7/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09b37d743328bd497939bd27135f82350f1b0bd7/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs?ref=09b37d743328bd497939bd27135f82350f1b0bd7", "patch": "@@ -524,28 +524,12 @@ impl FormatArgsExpn<'tcx> {\n             if let ExpnKind::Macro(_, name) = expr.span.ctxt().outer_expn_data().kind;\n             let name = name.as_str();\n             if name.ends_with(\"format_args\") || name.ends_with(\"format_args_nl\");\n-\n-            if let ExprKind::Match(inner_match, [arm], _) = expr.kind;\n-\n-            // `match match`, if you will\n-            if let ExprKind::Match(args, [inner_arm], _) = inner_match.kind;\n-            if let ExprKind::Tup(value_args) = args.kind;\n-            if let Some(value_args) = value_args\n-                .iter()\n-                .map(|e| match e.kind {\n-                    ExprKind::AddrOf(_, _, e) => Some(e),\n-                    _ => None,\n-                })\n-                .collect();\n-            if let ExprKind::Array(args) = inner_arm.body.kind;\n-\n-            if let ExprKind::Block(Block { stmts: [], expr: Some(expr), .. }, _) = arm.body.kind;\n-            if let ExprKind::Call(_, call_args) = expr.kind;\n-            if let Some((strs_ref, fmt_expr)) = match call_args {\n+            if let ExprKind::Call(_, args) = expr.kind;\n+            if let Some((strs_ref, args, fmt_expr)) = match args {\n                 // Arguments::new_v1\n-                [strs_ref, _] => Some((strs_ref, None)),\n+                [strs_ref, args] => Some((strs_ref, args, None)),\n                 // Arguments::new_v1_formatted\n-                [strs_ref, _, fmt_expr] => Some((strs_ref, Some(fmt_expr))),\n+                [strs_ref, args, fmt_expr, _unsafe_arg] => Some((strs_ref, args, Some(fmt_expr))),\n                 _ => None,\n             };\n             if let ExprKind::AddrOf(BorrowKind::Ref, _, strs_arr) = strs_ref.kind;\n@@ -561,6 +545,17 @@ impl FormatArgsExpn<'tcx> {\n                     None\n                 })\n                 .collect();\n+            if let ExprKind::AddrOf(BorrowKind::Ref, _, args) = args.kind;\n+            if let ExprKind::Match(args, [arm], _) = args.kind;\n+            if let ExprKind::Tup(value_args) = args.kind;\n+            if let Some(value_args) = value_args\n+                .iter()\n+                .map(|e| match e.kind {\n+                    ExprKind::AddrOf(_, _, e) => Some(e),\n+                    _ => None,\n+                })\n+                .collect();\n+            if let ExprKind::Array(args) = arm.body.kind;\n             then {\n                 Some(FormatArgsExpn {\n                     format_string_span: strs_ref.span,"}]}