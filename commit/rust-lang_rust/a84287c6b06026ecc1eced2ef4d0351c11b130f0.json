{"sha": "a84287c6b06026ecc1eced2ef4d0351c11b130f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4NDI4N2M2YjA2MDI2ZWNjMWVjZWQyZWY0ZDAzNTFjMTFiMTMwZjA=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-28T08:56:01Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-28T08:56:01Z"}, "message": "Comments in function decls and annotations/doc comments", "tree": {"sha": "046f4d583e815f28777c36534edfd3c4023decb9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/046f4d583e815f28777c36534edfd3c4023decb9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a84287c6b06026ecc1eced2ef4d0351c11b130f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a84287c6b06026ecc1eced2ef4d0351c11b130f0", "html_url": "https://github.com/rust-lang/rust/commit/a84287c6b06026ecc1eced2ef4d0351c11b130f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a84287c6b06026ecc1eced2ef4d0351c11b130f0/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c00970f5e946a9c451360455e079a24ecb5eb786", "url": "https://api.github.com/repos/rust-lang/rust/commits/c00970f5e946a9c451360455e079a24ecb5eb786", "html_url": "https://github.com/rust-lang/rust/commit/c00970f5e946a9c451360455e079a24ecb5eb786"}], "stats": {"total": 121, "additions": 98, "deletions": 23}, "files": [{"sha": "0afcb66f64a1b966aa3219c407446379aa98c76e", "filename": "src/functions.rs", "status": "modified", "additions": 31, "deletions": 16, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a84287c6b06026ecc1eced2ef4d0351c11b130f0/src%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a84287c6b06026ecc1eced2ef4d0351c11b130f0/src%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffunctions.rs?ref=a84287c6b06026ecc1eced2ef4d0351c11b130f0", "patch": "@@ -80,9 +80,6 @@ impl<'a> FmtVisitor<'a> {\n                                            span_for_return(&fd.output)));\n         result.push(')');\n \n-        // Where clause.\n-        result.push_str(&self.rewrite_where_clause(where_clause, indent, next_span));\n-\n         // Return type.\n         if ret_str.len() > 0 {\n             // If we've already gone multi-line, or the return type would push\n@@ -91,10 +88,13 @@ impl<'a> FmtVisitor<'a> {\n                result.len() + indent + ret_str.len() > MAX_WIDTH {\n                 let indent = match FN_RETURN_INDENT {\n                     ReturnIndent::WithWhereClause => indent + 4,\n+                    ReturnIndent::WithWhereClauseOrArgs if where_clause.predicates.len() > 0 => {\n+                        indent + 4\n+                    }\n                     // TODO we might want to check that using the arg indent doesn't\n                     // blow our budget, and if it does, then fallback to the where\n                     // clause indent.\n-                    ReturnIndent::WithArgs => arg_indent,\n+                    _ => arg_indent,\n                 };\n \n                 result.push('\\n');\n@@ -103,9 +103,27 @@ impl<'a> FmtVisitor<'a> {\n                 result.push(' ');\n             }\n             result.push_str(&ret_str);\n+\n+            // Comment between return type and the end of the decl.\n+            let snippet_lo = fd.output.span().hi;\n+            if where_clause.predicates.len() == 0 {\n+                let snippet_hi = next_span.lo;\n+                let snippet = self.snippet(codemap::mk_sp(snippet_lo, snippet_hi));\n+                let snippet = snippet.trim();\n+                if snippet.len() > 0 {\n+                    println!(\"found comment {}\", snippet);\n+                    result.push(' ');\n+                    result.push_str(snippet);\n+                }\n+            } else {\n+                // FIXME it would be nice to catch comments between the return type\n+                // and the where clause, but we don't have a span for the where\n+                // clause.\n+            }\n         }\n \n-        // TODO any comments here?\n+        // Where clause.\n+        result.push_str(&self.rewrite_where_clause(where_clause, indent, next_span));\n \n         // Prepare for the function body by possibly adding a newline and indent.\n         // FIXME we'll miss anything between the end of the signature and the start\n@@ -236,7 +254,7 @@ impl<'a> FmtVisitor<'a> {\n         // The fix is comments in the AST or a span for the closing paren.\n         let snippet = self.snippet(codemap::mk_sp(prev_end, next_span_start));\n         let snippet = snippet.trim();\n-        let snippet = &snippet[..snippet.find(terminator).unwrap()];\n+        let snippet = &snippet[..snippet.find(terminator).unwrap_or(snippet.len())];\n         let snippet = snippet.trim();\n         result.push(snippet.to_string());\n \n@@ -377,16 +395,13 @@ impl<'a> FmtVisitor<'a> {\n         result.push_str(&make_indent(indent + 4));\n         result.push_str(\"where \");\n \n-        let comments = vec![String::new(); where_clause.predicates.len()];\n-        // TODO uncomment when spans are fixed\n-        // println!(\"{:?} {:?}\", where_clause.predicates.iter().map(|p| self.snippet(span_for_where_pred(p))).collect::<Vec<_>>(), next_span.lo);\n-        // let comments = self.make_comments_for_list(Vec::new(),\n-        //                                            where_clause.predicates.iter(),\n-        //                                            \",\",\n-        //                                            \"{\",\n-        //                                            |pred| span_for_where_pred(pred).lo,\n-        //                                            |pred| span_for_where_pred(pred).hi,\n-        //                                            next_span.lo);\n+        let comments = self.make_comments_for_list(Vec::new(),\n+                                                   where_clause.predicates.iter(),\n+                                                   \",\",\n+                                                   \"{\",\n+                                                   |pred| span_for_where_pred(pred).lo,\n+                                                   |pred| span_for_where_pred(pred).hi,\n+                                                   next_span.lo);\n         let where_strs: Vec<_> = where_clause.predicates.iter()\n                                                         .map(|p| (self.rewrite_pred(p)))\n                                                         .zip(comments.into_iter())"}, {"sha": "537752d17a3056416d94fac218c1d3ef968bd03f", "filename": "src/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a84287c6b06026ecc1eced2ef4d0351c11b130f0/src%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a84287c6b06026ecc1eced2ef4d0351c11b130f0/src%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmod.rs?ref=a84287c6b06026ecc1eced2ef4d0351c11b130f0", "patch": "@@ -20,8 +20,9 @@\n // TODO for lint violations of names, emit a refactor script\n \n // TODO priorities\n+// annotations/doc comments\n // Fix fns and methods properly\n-//   dead spans (comments) - in where clause (wait for fixed spans, test)\n+//   dead spans (comments) - in where clause - test\n //\n // Smoke testing till we can use it\n // take config options from a file\n@@ -67,7 +68,7 @@ const MAX_WIDTH: usize = 100;\n const MIN_STRING: usize = 10;\n const TAB_SPACES: usize = 4;\n const FN_BRACE_STYLE: BraceStyle = BraceStyle::SameLineWhere;\n-const FN_RETURN_INDENT: ReturnIndent = ReturnIndent::WithArgs;\n+const FN_RETURN_INDENT: ReturnIndent = ReturnIndent::WithWhereClauseOrArgs;\n // When we get scoped annotations, we should have rustfmt::skip.\n const SKIP_ANNOTATION: &'static str = \"rustfmt_skip\";\n \n@@ -98,6 +99,8 @@ enum ReturnIndent {\n     WithArgs,\n     // Aligned with the where clause\n     WithWhereClause,\n+    // Aligned with the where clause if there is one, otherwise the args.\n+    WithWhereClauseOrArgs,\n }\n \n // Formatting which depends on the AST.\n@@ -354,6 +357,7 @@ mod test {\n             if result[file_name] != text {\n                 fails += 1;\n                 println!(\"Mismatch in {}.\", file_name);\n+                println!(\"{}\", result[file_name]);\n             }\n         }\n "}, {"sha": "df974b7e8fa9e165c6f3fd864bf87864bc941837", "filename": "src/visitor.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a84287c6b06026ecc1eced2ef4d0351c11b130f0/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a84287c6b06026ecc1eced2ef4d0351c11b130f0/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=a84287c6b06026ecc1eced2ef4d0351c11b130f0", "patch": "@@ -75,8 +75,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n         self.format_missing(s.lo);\n         self.last_pos = s.lo;\n \n-        // TODO need to check against expected indent\n-        let indent = self.codemap.lookup_char_pos(s.lo).col.0;\n+        let indent = self.block_indent;\n         match fk {\n             visit::FkItemFn(ident, ref generics, ref unsafety, ref abi, vis) => {\n                 let new_fn = self.rewrite_fn(indent,\n@@ -110,7 +109,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n     }\n \n     fn visit_item(&mut self, item: &'v ast::Item) {\n-        if item.attrs.iter().any(|a| is_skip(&a.node.value)) {\n+        if self.visit_attrs(&item.attrs) {\n             return;\n         }\n \n@@ -147,14 +146,14 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n     }\n \n     fn visit_trait_item(&mut self, ti: &'v ast::TraitItem) {\n-        if ti.attrs.iter().any(|a| is_skip(&a.node.value)) {\n+        if self.visit_attrs(&ti.attrs) {\n             return;\n         }\n         visit::walk_trait_item(self, ti)\n     }\n \n     fn visit_impl_item(&mut self, ii: &'v ast::ImplItem) {\n-        if ii.attrs.iter().any(|a| is_skip(&a.node.value)) {\n+        if self.visit_attrs(&ii.attrs) {\n             return;\n         }\n         visit::walk_impl_item(self, ii)\n@@ -195,6 +194,22 @@ impl<'a> FmtVisitor<'a> {\n             }\n         }\n     }\n+\n+    // Returns true if we should skip the following item.\n+    fn visit_attrs(&mut self, attrs: &[ast::Attribute]) -> bool {\n+        for a in attrs {\n+            self.format_missing_with_indent(a.span.lo);\n+            if is_skip(&a.node.value) {\n+                return true;\n+            }\n+\n+            let attr_str = self.snippet(a.span);\n+            self.changes.push_str_span(a.span, &attr_str);\n+            self.last_pos = a.span.hi;\n+        }\n+\n+        false\n+    }\n }\n \n fn is_skip(meta_item: &ast::MetaItem) -> bool {"}, {"sha": "b66be08c7284b5120a50fcd80308f8f744e6df01", "filename": "tests/idem/attrib.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a84287c6b06026ecc1eced2ef4d0351c11b130f0/tests%2Fidem%2Fattrib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a84287c6b06026ecc1eced2ef4d0351c11b130f0/tests%2Fidem%2Fattrib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fidem%2Fattrib.rs?ref=a84287c6b06026ecc1eced2ef4d0351c11b130f0", "patch": "@@ -0,0 +1,22 @@\n+// Test attributes and doc comments are preserved.\n+\n+/// Blah blah blah.\n+impl Bar {\n+    /// Blah blah blooo.\n+    #[an_attribute]\n+    fn foo(&mut self) -> isize {}\n+\n+    /// Blah blah bing.\n+    pub fn f2(self) {\n+        (foo, bar)\n+    }\n+\n+    #[another_attribute]\n+    fn f3(self) -> Dog {\n+    }\n+}\n+\n+/// Blah\n+fn main() {\n+    println!(\"Hello world!\");\n+}"}, {"sha": "ec1b87cde0d05c996fc2102e811a5f6e325850fd", "filename": "tests/idem/comments-fn.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a84287c6b06026ecc1eced2ef4d0351c11b130f0/tests%2Fidem%2Fcomments-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a84287c6b06026ecc1eced2ef4d0351c11b130f0/tests%2Fidem%2Fcomments-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fidem%2Fcomments-fn.rs?ref=a84287c6b06026ecc1eced2ef4d0351c11b130f0", "patch": "@@ -0,0 +1,19 @@\n+// Test comments on functions are preserved.\n+\n+// Comment on foo.\n+fn foo<F, G>(a: aaaaaaaaaaaaa, // A comment\n+             b: bbbbbbbbbbbbb, /* a second comment */\n+             c: ccccccccccccc,\n+             d: ddddddddddddd,\n+             e: eeeeeeeeeeeee /* comment before paren*/)\n+    -> bar\n+    where F: Foo, // COmment after where clause\n+          G: Goo /* final comment */\n+{\n+\n+}\n+\n+fn bar<F /* comment on F */, G /* comment on G */>() {}\n+\n+fn baz() -> Baz /* Comment after return type */ {\n+}"}]}