{"sha": "b795abeb1dc0f6d27e49d980a48936b687754b28", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3OTVhYmViMWRjMGY2ZDI3ZTQ5ZDk4MGE0ODkzNmI2ODc3NTRiMjg=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-01-17T18:18:29Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-01-24T19:56:02Z"}, "message": "Refactor parsing of generic arguments/parameters and where clauses", "tree": {"sha": "9ff19f184b8c7063635179b62f2293aba8d04f34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ff19f184b8c7063635179b62f2293aba8d04f34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b795abeb1dc0f6d27e49d980a48936b687754b28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b795abeb1dc0f6d27e49d980a48936b687754b28", "html_url": "https://github.com/rust-lang/rust/commit/b795abeb1dc0f6d27e49d980a48936b687754b28", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b795abeb1dc0f6d27e49d980a48936b687754b28/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe597dc9a9f325de9b2b11d69e190e1c22c4e7dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe597dc9a9f325de9b2b11d69e190e1c22c4e7dc", "html_url": "https://github.com/rust-lang/rust/commit/fe597dc9a9f325de9b2b11d69e190e1c22c4e7dc"}], "stats": {"total": 811, "additions": 342, "deletions": 469}, "files": [{"sha": "9720bb8426475b6a476d450ecc8f2374e54acf01", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=b795abeb1dc0f6d27e49d980a48936b687754b28", "patch": "@@ -146,6 +146,12 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             TyKind::TraitObject(ref bounds) => {\n                 self.no_questions_in_bounds(bounds, \"trait object types\", false);\n             }\n+            TyKind::ImplTrait(ref bounds) => {\n+                if !bounds.iter()\n+                          .any(|b| if let TraitTyParamBound(..) = *b { true } else { false }) {\n+                    self.err_handler().span_err(ty.span, \"at least one trait must be specified\");\n+                }\n+            }\n             _ => {}\n         }\n \n@@ -284,6 +290,26 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n \n         visit::walk_vis(self, vis)\n     }\n+\n+    fn visit_generics(&mut self, g: &'a Generics) {\n+        let mut seen_default = None;\n+        for ty_param in &g.ty_params {\n+            if ty_param.default.is_some() {\n+                seen_default = Some(ty_param.span);\n+            } else if let Some(span) = seen_default {\n+                self.err_handler()\n+                    .span_err(span, \"type parameters with a default must be trailing\");\n+                break\n+            }\n+        }\n+        for predicate in &g.where_clause.predicates {\n+            if let WherePredicate::EqPredicate(ref predicate) = *predicate {\n+                self.err_handler().span_err(predicate.span, \"equality constraints are not yet \\\n+                                                             supported in where clauses (#20041)\");\n+            }\n+        }\n+        visit::walk_generics(self, g)\n+    }\n }\n \n pub fn check_crate(session: &Session, krate: &Crate) {"}, {"sha": "b9ee1c2b84cb0be352f5fb666f3847853011e54d", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=b795abeb1dc0f6d27e49d980a48936b687754b28", "patch": "@@ -1833,11 +1833,8 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                 }\n             }\n \n-            &hir::WherePredicate::EqPredicate(ref eq_pred) => {\n+            &hir::WherePredicate::EqPredicate(..) => {\n                 // FIXME(#20041)\n-                span_bug!(eq_pred.span,\n-                         \"Equality constraints are not yet \\\n-                          implemented (#20041)\")\n             }\n         }\n     }"}, {"sha": "77f0482e11318c1b4bd6c659d0ef5479bbffce89", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b795abeb1dc0f6d27e49d980a48936b687754b28", "patch": "@@ -842,8 +842,11 @@ impl Clean<WherePredicate> for hir::WherePredicate {\n                 }\n             }\n \n-            hir::WherePredicate::EqPredicate(_) => {\n-                unimplemented!() // FIXME(#20041)\n+            hir::WherePredicate::EqPredicate(ref wrp) => {\n+                WherePredicate::EqPredicate {\n+                    lhs: wrp.lhs_ty.clean(cx),\n+                    rhs: wrp.rhs_ty.clean(cx)\n+                }\n             }\n         }\n     }"}, {"sha": "c589f1a7aaaa00481c8955a6d00a27b45c4ea96d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 248, "deletions": 433, "changes": 681, "blob_url": "https://github.com/rust-lang/rust/blob/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b795abeb1dc0f6d27e49d980a48936b687754b28", "patch": "@@ -22,7 +22,7 @@ use ast::{Expr, ExprKind, RangeLimits};\n use ast::{Field, FnDecl};\n use ast::{ForeignItem, ForeignItemKind, FunctionRetTy};\n use ast::{Ident, ImplItem, Item, ItemKind};\n-use ast::{Lit, LitKind, UintTy};\n+use ast::{Lifetime, LifetimeDef, Lit, LitKind, UintTy};\n use ast::Local;\n use ast::MacStmtStyle;\n use ast::Mac_;\n@@ -638,13 +638,7 @@ impl<'a> Parser<'a> {\n                 let lo = span.lo + BytePos(1);\n                 Ok(self.bump_with(token::Eq, lo, span.hi))\n             }\n-            _ => {\n-                let gt_str = Parser::token_to_string(&token::Gt);\n-                let this_token_str = self.this_token_to_string();\n-                Err(self.fatal(&format!(\"expected `{}`, found `{}`\",\n-                                        gt_str,\n-                                        this_token_str)))\n-            }\n+            _ => self.unexpected()\n         }\n     }\n \n@@ -971,20 +965,11 @@ impl<'a> Parser<'a> {\n         Parses whatever can come after a `for` keyword in a type.\n         The `for` hasn't been consumed.\n \n-        Deprecated:\n-\n-        - for <'lt> |S| -> T\n-\n-        Eventually:\n-\n         - for <'lt> [unsafe] [extern \"ABI\"] fn (S) -> T\n-        - for <'lt> path::foo(a, b)\n-\n+        - for <'lt> path::foo(a, b) + Trait + 'a\n         */\n \n-        // parse <'lt>\n         let lo = self.span.lo;\n-\n         let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n \n         // examine next token to decide to do\n@@ -993,9 +978,9 @@ impl<'a> Parser<'a> {\n         } else {\n             let hi = self.span.hi;\n             let trait_ref = self.parse_trait_ref()?;\n-            let poly_trait_ref = ast::PolyTraitRef { bound_lifetimes: lifetime_defs,\n-                                                     trait_ref: trait_ref,\n-                                                     span: mk_sp(lo, hi)};\n+            let poly_trait_ref = PolyTraitRef { bound_lifetimes: lifetime_defs,\n+                                                trait_ref: trait_ref,\n+                                                span: mk_sp(lo, hi)};\n             let other_bounds = if self.eat(&token::BinOp(token::Plus)) {\n                 self.parse_ty_param_bounds()?\n             } else {\n@@ -1010,26 +995,17 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn parse_impl_trait_type(&mut self) -> PResult<'a, TyKind> {\n-        /*\n-        Parses whatever can come after a `impl` keyword in a type.\n-        The `impl` has already been consumed.\n-        */\n-\n-        let bounds = self.parse_ty_param_bounds()?;\n-\n-        if !bounds.iter().any(|b| if let TraitTyParamBound(..) = *b { true } else { false }) {\n-            self.span_err(self.prev_span, \"at least one trait must be specified\");\n-        }\n-\n-        Ok(ast::TyKind::ImplTrait(bounds))\n+        // Parses whatever can come after a `impl` keyword in a type.\n+        // The `impl` has already been consumed.\n+        Ok(ast::TyKind::ImplTrait(self.parse_ty_param_bounds()?))\n     }\n \n     pub fn parse_ty_path(&mut self) -> PResult<'a, TyKind> {\n         Ok(TyKind::Path(None, self.parse_path(PathStyle::Type)?))\n     }\n \n     /// parse a TyKind::BareFn type:\n-    pub fn parse_ty_bare_fn(&mut self, lifetime_defs: Vec<ast::LifetimeDef>)\n+    pub fn parse_ty_bare_fn(&mut self, lifetime_defs: Vec<LifetimeDef>)\n                             -> PResult<'a, TyKind> {\n         /*\n \n@@ -1201,13 +1177,6 @@ impl<'a> Parser<'a> {\n             })\n     }\n \n-    /// Parse a possibly mutable type\n-    pub fn parse_mt(&mut self) -> PResult<'a, MutTy> {\n-        let mutbl = self.parse_mutability()?;\n-        let t = self.parse_ty_no_plus()?;\n-        Ok(MutTy { ty: t, mutbl: mutbl })\n-    }\n-\n     /// Parse optional return type [ -> TY ] in function decl\n     pub fn parse_ret_ty(&mut self) -> PResult<'a, FunctionRetTy> {\n         if self.eat(&token::RArrow) {\n@@ -1259,8 +1228,8 @@ impl<'a> Parser<'a> {\n                                             pprust::ty_to_string(&lhs));\n             err.span_label(lhs.span, &format!(\"expected a path\"));\n             let hi = bounds.iter().map(|x| match *x {\n-                ast::TraitTyParamBound(ref tr, _) => tr.span.hi,\n-                ast::RegionTyParamBound(ref r) => r.span.hi,\n+                TraitTyParamBound(ref tr, _) => tr.span.hi,\n+                RegionTyParamBound(ref r) => r.span.hi,\n             }).max_by_key(|x| x.to_usize());\n             let full_span = hi.map(|hi| Span {\n                 lo: lhs.span.lo,\n@@ -1308,19 +1277,16 @@ impl<'a> Parser<'a> {\n \n         let lo = self.span.lo;\n \n-        let t = if self.check(&token::OpenDelim(token::Paren)) {\n-            self.bump();\n-\n+        let t = if self.eat(&token::OpenDelim(token::Paren)) {\n             // (t) is a parenthesized ty\n             // (t,) is the type of a tuple with only one field,\n             // of type t\n             let mut ts = vec![];\n             let mut last_comma = false;\n             while self.token != token::CloseDelim(token::Paren) {\n                 ts.push(self.parse_ty()?);\n-                if self.check(&token::Comma) {\n+                if self.eat(&token::Comma) {\n                     last_comma = true;\n-                    self.bump();\n                 } else {\n                     last_comma = false;\n                     break;\n@@ -1335,13 +1301,11 @@ impl<'a> Parser<'a> {\n             }\n         } else if self.eat(&token::Not) {\n             TyKind::Never\n-        } else if self.check(&token::BinOp(token::Star)) {\n+        } else if self.eat(&token::BinOp(token::Star)) {\n             // STAR POINTER (bare pointer?)\n-            self.bump();\n             TyKind::Ptr(self.parse_ptr()?)\n-        } else if self.check(&token::OpenDelim(token::Bracket)) {\n+        } else if self.eat(&token::OpenDelim(token::Bracket)) {\n             // VECTOR\n-            self.expect(&token::OpenDelim(token::Bracket))?;\n             let t = self.parse_ty()?;\n \n             // Parse the `; e` in `[ i32; e ]`\n@@ -1353,13 +1317,15 @@ impl<'a> Parser<'a> {\n             self.expect(&token::CloseDelim(token::Bracket))?;\n             t\n         } else if self.check(&token::BinOp(token::And)) ||\n-                  self.token == token::AndAnd {\n+                  self.check(&token::AndAnd) {\n             // BORROWED POINTER\n             self.expect_and()?;\n             self.parse_borrowed_pointee()?\n         } else if self.check_keyword(keywords::For) {\n+            // FIXME plus priority\n             self.parse_for_in_type()?\n         } else if self.eat_keyword(keywords::Impl) {\n+            // FIXME plus priority\n             self.parse_impl_trait_type()?\n         } else if self.token_is_bare_fn_keyword() {\n             // BARE FUNCTION\n@@ -1372,10 +1338,7 @@ impl<'a> Parser<'a> {\n             self.expect(&token::CloseDelim(token::Paren))?;\n             TyKind::Typeof(e)\n         } else if self.eat_lt() {\n-\n-            let (qself, path) =\n-                 self.parse_qualified_path(PathStyle::Type)?;\n-\n+            let (qself, path) = self.parse_qualified_path(PathStyle::Type)?;\n             TyKind::Path(Some(qself), path)\n         } else if self.token.is_path_start() {\n             let path = self.parse_path(PathStyle::Type)?;\n@@ -1405,10 +1368,10 @@ impl<'a> Parser<'a> {\n \n     pub fn parse_borrowed_pointee(&mut self) -> PResult<'a, TyKind> {\n         // look for `&'lt` or `&'foo ` and interpret `foo` as the region name:\n-        let opt_lifetime = self.parse_opt_lifetime()?;\n-\n-        let mt = self.parse_mt()?;\n-        return Ok(TyKind::Rptr(opt_lifetime, mt));\n+        let opt_lifetime = self.eat_lifetime();\n+        let mutbl = self.parse_mutability()?;\n+        let ty = self.parse_ty_no_plus()?;\n+        return Ok(TyKind::Rptr(opt_lifetime, MutTy { ty: ty, mutbl: mutbl }));\n     }\n \n     pub fn parse_ptr(&mut self) -> PResult<'a, MutTy> {\n@@ -1504,8 +1467,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn maybe_parse_fixed_length_of_vec(&mut self) -> PResult<'a, Option<P<ast::Expr>>> {\n-        if self.check(&token::Semi) {\n-            self.bump();\n+        if self.eat(&token::Semi) {\n             Ok(Some(self.parse_expr()?))\n         } else {\n             Ok(None)\n@@ -1727,7 +1689,8 @@ impl<'a> Parser<'a> {\n \n             // Parse types, optionally.\n             let parameters = if self.eat_lt() {\n-                let (lifetimes, types, bindings) = self.parse_generic_values_after_lt()?;\n+                let (lifetimes, types, bindings) = self.parse_generic_args()?;\n+                self.expect_gt()?;\n                 ast::AngleBracketedParameterData {\n                     lifetimes: lifetimes,\n                     types: types,\n@@ -1785,7 +1748,8 @@ impl<'a> Parser<'a> {\n             // Check for a type segment.\n             if self.eat_lt() {\n                 // Consumed `a::b::<`, go look for types\n-                let (lifetimes, types, bindings) = self.parse_generic_values_after_lt()?;\n+                let (lifetimes, types, bindings) = self.parse_generic_args()?;\n+                self.expect_gt()?;\n                 segments.push(ast::PathSegment {\n                     identifier: identifier,\n                     parameters: ast::AngleBracketedParameterData {\n@@ -1827,121 +1791,18 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// parses 0 or 1 lifetime\n-    pub fn parse_opt_lifetime(&mut self) -> PResult<'a, Option<ast::Lifetime>> {\n-        match self.token {\n-            token::Lifetime(..) => {\n-                Ok(Some(self.parse_lifetime()?))\n-            }\n-            _ => {\n-                Ok(None)\n-            }\n-        }\n-    }\n-\n-    /// Parses a single lifetime\n-    /// Matches lifetime = LIFETIME\n-    pub fn parse_lifetime(&mut self) -> PResult<'a, ast::Lifetime> {\n+    /// Parse single lifetime 'a or nothing.\n+    pub fn eat_lifetime(&mut self) -> Option<Lifetime> {\n         match self.token {\n-            token::Lifetime(i) => {\n-                let span = self.span;\n+            token::Lifetime(ident) => {\n                 self.bump();\n-                return Ok(ast::Lifetime {\n+                Some(Lifetime {\n                     id: ast::DUMMY_NODE_ID,\n-                    span: span,\n-                    name: i.name\n-                });\n-            }\n-            _ => {\n-                return Err(self.fatal(\"expected a lifetime name\"));\n-            }\n-        }\n-    }\n-\n-    /// Parses `lifetime_defs = [ lifetime_defs { ',' lifetime_defs } ]` where `lifetime_def  =\n-    /// lifetime [':' lifetimes]`\n-    ///\n-    /// If `followed_by_ty_params` is None, then we are in a context\n-    /// where only lifetime parameters are allowed, and thus we should\n-    /// error if we encounter attributes after the bound lifetimes.\n-    ///\n-    /// If `followed_by_ty_params` is Some(r), then there may be type\n-    /// parameter bindings after the lifetimes, so we should pass\n-    /// along the parsed attributes to be attached to the first such\n-    /// type parmeter.\n-    pub fn parse_lifetime_defs(&mut self,\n-                               followed_by_ty_params: Option<&mut Vec<ast::Attribute>>)\n-                               -> PResult<'a, Vec<ast::LifetimeDef>>\n-    {\n-        let mut res = Vec::new();\n-        loop {\n-            let attrs = self.parse_outer_attributes()?;\n-            match self.token {\n-                token::Lifetime(_) => {\n-                    let lifetime = self.parse_lifetime()?;\n-                    let bounds =\n-                        if self.eat(&token::Colon) {\n-                            self.parse_lifetimes(token::BinOp(token::Plus))?\n-                        } else {\n-                            Vec::new()\n-                        };\n-                    res.push(ast::LifetimeDef { attrs: attrs.into(),\n-                                                lifetime: lifetime,\n-                                                bounds: bounds });\n-                }\n-\n-                _ => {\n-                    if let Some(recv) = followed_by_ty_params {\n-                        assert!(recv.is_empty());\n-                        *recv = attrs;\n-                        debug!(\"parse_lifetime_defs ret {:?}\", res);\n-                        return Ok(res);\n-                    } else if !attrs.is_empty() {\n-                        let msg = \"trailing attribute after lifetime parameters\";\n-                        return Err(self.fatal(msg));\n-                    }\n-                }\n-            }\n-\n-            match self.token {\n-                token::Comma => { self.bump();}\n-                token::Gt => { return Ok(res); }\n-                token::BinOp(token::Shr) => { return Ok(res); }\n-                _ => {\n-                    let this_token_str = self.this_token_to_string();\n-                    let msg = format!(\"expected `,` or `>` after lifetime \\\n-                                      name, found `{}`\",\n-                                      this_token_str);\n-                    return Err(self.fatal(&msg[..]));\n-                }\n-            }\n-        }\n-    }\n-\n-    /// matches lifetimes = ( lifetime ) | ( lifetime , lifetimes ) actually, it matches the empty\n-    /// one too, but putting that in there messes up the grammar....\n-    ///\n-    /// Parses zero or more comma separated lifetimes. Expects each lifetime to be followed by\n-    /// either a comma or `>`.  Used when parsing type parameter lists, where we expect something\n-    /// like `<'a, 'b, T>`.\n-    pub fn parse_lifetimes(&mut self, sep: token::Token) -> PResult<'a, Vec<ast::Lifetime>> {\n-\n-        let mut res = Vec::new();\n-        loop {\n-            match self.token {\n-                token::Lifetime(_) => {\n-                    res.push(self.parse_lifetime()?);\n-                }\n-                _ => {\n-                    return Ok(res);\n-                }\n-            }\n-\n-            if self.token != sep {\n-                return Ok(res);\n+                    span: self.prev_span,\n+                    name: ident.name\n+                })\n             }\n-\n-            self.bump();\n+            _ => None\n         }\n     }\n \n@@ -2458,7 +2319,9 @@ impl<'a> Parser<'a> {\n                         -> PResult<'a, P<Expr>> {\n         let (_, tys, bindings) = if self.eat(&token::ModSep) {\n             self.expect_lt()?;\n-            self.parse_generic_values_after_lt()?\n+            let args = self.parse_generic_args()?;\n+            self.expect_gt()?;\n+            args\n         } else {\n             (Vec::new(), Vec::new(), Vec::new())\n         };\n@@ -4075,69 +3938,76 @@ impl<'a> Parser<'a> {\n         }).emit();\n     }\n \n-    // Parses a sequence of bounds if a `:` is found,\n-    // otherwise returns empty list.\n-    fn parse_colon_then_ty_param_bounds(&mut self) -> PResult<'a, TyParamBounds>\n-    {\n-        if !self.eat(&token::Colon) {\n-            Ok(Vec::new())\n-        } else {\n-            self.parse_ty_param_bounds()\n-        }\n-    }\n-\n-    // matches bounds    = ( boundseq )?\n-    // where   boundseq  = ( polybound + boundseq ) | polybound\n-    // and     polybound = ( 'for' '<' 'region '>' )? bound\n-    // and     bound     = 'region | trait_ref\n+    // Parse bounds of a type parameter `BOUND + BOUND + BOUND` without trailing `+`.\n+    // BOUND = TY_BOUND | LT_BOUND\n+    // LT_BOUND = LIFETIME (e.g. `'a`)\n+    // TY_BOUND = [?] [for<LT_PARAM_DEFS>] SIMPLE_PATH (e.g. `?for<'a: 'b> m::Trait<'a>`)\n     fn parse_ty_param_bounds(&mut self) -> PResult<'a, TyParamBounds>\n     {\n-        let mut result = vec![];\n+        let mut bounds = Vec::new();\n         loop {\n-            let question_span = self.span;\n-            let ate_question = self.eat(&token::Question);\n-            match self.token {\n-                token::Lifetime(lifetime) => {\n-                    if ate_question {\n-                        self.span_err(question_span,\n-                                      \"`?` may only modify trait bounds, not lifetime bounds\");\n-                    }\n-                    result.push(RegionTyParamBound(ast::Lifetime {\n-                        id: ast::DUMMY_NODE_ID,\n-                        span: self.span,\n-                        name: lifetime.name\n-                    }));\n-                    self.bump();\n+            let question = if self.eat(&token::Question) { Some(self.prev_span) } else { None };\n+            if let Some(lifetime) = self.eat_lifetime() {\n+                if let Some(question_span) = question {\n+                    self.span_err(question_span,\n+                                  \"`?` may only modify trait bounds, not lifetime bounds\");\n                 }\n-                _ if self.token.is_path_start() || self.token.is_keyword(keywords::For) => {\n-                    let poly_trait_ref = self.parse_poly_trait_ref()?;\n-                    let modifier = if ate_question {\n-                        TraitBoundModifier::Maybe\n-                    } else {\n-                        TraitBoundModifier::None\n-                    };\n-                    result.push(TraitTyParamBound(poly_trait_ref, modifier))\n-                }\n-                _ => break,\n+                bounds.push(RegionTyParamBound(lifetime));\n+            } else if self.token.is_keyword(keywords::For) || self.token.is_path_start() {\n+                let poly_trait_ref = self.parse_poly_trait_ref()?;\n+                let modifier = if question.is_some() {\n+                    TraitBoundModifier::Maybe\n+                } else {\n+                    TraitBoundModifier::None\n+                };\n+                bounds.push(TraitTyParamBound(poly_trait_ref, modifier));\n+            } else {\n+                break\n             }\n \n-            if !self.eat(&token::BinOp(token::Plus)) {\n-                break;\n+            // Trailing plus is not allowed for now and we have to detect it.\n+            let is_bound_start = |token: &token::Token| {\n+                token == &token::Question || token.is_lifetime() ||\n+                token.is_keyword(keywords::For) || token.is_path_start()\n+            };\n+            if self.check(&token::BinOp(token::Plus)) && self.look_ahead(1, is_bound_start) {\n+                self.bump();\n+            } else {\n+                break\n             }\n         }\n \n-        return Ok(result);\n+        return Ok(bounds);\n+    }\n+\n+    // Parse bounds of a type parameter `BOUND + BOUND + BOUND` without trailing `+`.\n+    // BOUND = LT_BOUND (e.g. `'a`)\n+    fn parse_lt_param_bounds(&mut self) -> Vec<Lifetime> {\n+        let mut lifetimes = Vec::new();\n+        while let Some(lifetime) = self.eat_lifetime() {\n+            lifetimes.push(lifetime);\n+            if self.check(&token::BinOp(token::Plus)) && self.look_ahead(1, |t| t.is_lifetime()) {\n+                self.bump();\n+            } else {\n+                break\n+            }\n+        }\n+        lifetimes\n     }\n \n     /// Matches typaram = IDENT (`?` unbound)? optbounds ( EQ ty )?\n-    fn parse_ty_param(&mut self, preceding_attrs: Vec<ast::Attribute>) -> PResult<'a, TyParam> {\n+    fn parse_ty_param(&mut self, preceding_attrs: Vec<Attribute>) -> PResult<'a, TyParam> {\n         let span = self.span;\n         let ident = self.parse_ident()?;\n \n-        let bounds = self.parse_colon_then_ty_param_bounds()?;\n+        // Parse optional colon and param bounds.\n+        let bounds = if self.eat(&token::Colon) {\n+            self.parse_ty_param_bounds()?\n+        } else {\n+            Vec::new()\n+        };\n \n-        let default = if self.check(&token::Eq) {\n-            self.bump();\n+        let default = if self.eat(&token::Eq) {\n             Some(self.parse_ty()?)\n         } else {\n             None\n@@ -4153,6 +4023,51 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n+    /// Parses (possibly empty) list of lifetime and type parameters, possibly including\n+    /// trailing comma and erroneous trailing attributes.\n+    pub fn parse_generic_params(&mut self) -> PResult<'a, (Vec<LifetimeDef>, Vec<TyParam>)> {\n+        let mut lifetime_defs = Vec::new();\n+        let mut ty_params = Vec::new();\n+        let mut seen_ty_param = false;\n+        loop {\n+            let attrs = self.parse_outer_attributes()?;\n+            if let Some(lifetime) = self.eat_lifetime() {\n+                // Parse lifetime parameter.\n+                let bounds = if self.eat(&token::Colon) {\n+                    self.parse_lt_param_bounds()\n+                } else {\n+                    Vec::new()\n+                };\n+                lifetime_defs.push(LifetimeDef {\n+                    attrs: attrs.into(),\n+                    lifetime: lifetime,\n+                    bounds: bounds,\n+                });\n+                if seen_ty_param {\n+                    self.span_err(self.prev_span,\n+                        \"lifetime parameters must be declared prior to type parameters\");\n+                }\n+            } else if self.token.is_ident() {\n+                // Parse type parameter.\n+                ty_params.push(self.parse_ty_param(attrs)?);\n+                seen_ty_param = true;\n+            } else {\n+                // Check for trailing attributes and stop parsing.\n+                if !attrs.is_empty() {\n+                    let param_kind = if seen_ty_param { \"type\" } else { \"lifetime\" };\n+                    self.span_err(attrs[0].span,\n+                        &format!(\"trailing attribute after {} parameters\", param_kind));\n+                }\n+                break\n+            }\n+\n+            if !self.eat(&token::Comma) {\n+                break\n+            }\n+        }\n+        Ok((lifetime_defs, ty_params))\n+    }\n+\n     /// Parse a set of optional generic type parameter declarations. Where\n     /// clauses are not parsed here, and must be added later via\n     /// `parse_where_clause()`.\n@@ -4162,45 +4077,11 @@ impl<'a> Parser<'a> {\n     /// where   typaramseq = ( typaram ) | ( typaram , typaramseq )\n     pub fn parse_generics(&mut self) -> PResult<'a, ast::Generics> {\n         maybe_whole!(self, NtGenerics, |x| x);\n-        let span_lo = self.span.lo;\n \n-        if self.eat(&token::Lt) {\n-            // Upon encountering attribute in generics list, we do not\n-            // know if it is attached to lifetime or to type param.\n-            //\n-            // Solution: 1. eagerly parse attributes in tandem with\n-            // lifetime defs, 2. store last set of parsed (and unused)\n-            // attributes in `attrs`, and 3. pass in those attributes\n-            // when parsing formal type param after lifetime defs.\n-            let mut attrs = vec![];\n-            let lifetime_defs = self.parse_lifetime_defs(Some(&mut attrs))?;\n-            let mut seen_default = false;\n-            let mut post_lifetime_attrs = Some(attrs);\n-            let ty_params = self.parse_seq_to_gt(Some(token::Comma), |p| {\n-                p.forbid_lifetime()?;\n-                // Move out of `post_lifetime_attrs` if present. O/w\n-                // not first type param: parse attributes anew.\n-                let attrs = match post_lifetime_attrs.as_mut() {\n-                    None => p.parse_outer_attributes()?,\n-                    Some(attrs) => mem::replace(attrs, vec![]),\n-                };\n-                post_lifetime_attrs = None;\n-                let ty_param = p.parse_ty_param(attrs)?;\n-                if ty_param.default.is_some() {\n-                    seen_default = true;\n-                } else if seen_default {\n-                    let prev_span = p.prev_span;\n-                    p.span_err(prev_span,\n-                               \"type parameters with a default must be trailing\");\n-                }\n-                Ok(ty_param)\n-            })?;\n-            if let Some(attrs) = post_lifetime_attrs {\n-                if !attrs.is_empty() {\n-                    self.span_err(attrs[0].span,\n-                                  \"trailing attribute after lifetime parameters\");\n-                }\n-            }\n+        let span_lo = self.span.lo;\n+        if self.eat_lt() {\n+            let (lifetime_defs, ty_params) = self.parse_generic_params()?;\n+            self.expect_gt()?;\n             Ok(ast::Generics {\n                 lifetimes: lifetime_defs,\n                 ty_params: ty_params,\n@@ -4215,93 +4096,61 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_generic_values_after_lt(&mut self) -> PResult<'a, (Vec<ast::Lifetime>,\n-                                                            Vec<P<Ty>>,\n-                                                            Vec<TypeBinding>)> {\n-        let span_lo = self.span.lo;\n-        let lifetimes = self.parse_lifetimes(token::Comma)?;\n-\n-        let missing_comma = !lifetimes.is_empty() &&\n-                            !self.token.is_like_gt() &&\n-                            self.prev_token_kind != PrevTokenKind::Comma;\n-\n-        if missing_comma {\n-\n-            let msg = format!(\"expected `,` or `>` after lifetime \\\n-                              name, found `{}`\",\n-                              self.this_token_to_string());\n-            let mut err = self.diagnostic().struct_span_err(self.span, &msg);\n-\n-            let span_hi = self.span.hi;\n-            let span_hi = match self.parse_ty_no_plus() {\n-                Ok(..) => self.span.hi,\n-                Err(ref mut err) => {\n-                    self.cancel(err);\n-                    span_hi\n-                }\n-            };\n-\n-            let msg = format!(\"did you mean a single argument type &'a Type, \\\n-                              or did you mean the comma-separated arguments \\\n-                              'a, Type?\");\n-            err.span_note(mk_sp(span_lo, span_hi), &msg);\n-            return Err(err);\n-        }\n-\n-        // First parse types.\n-        let (types, returned) = self.parse_seq_to_gt_or_return(\n-            Some(token::Comma),\n-            |p| {\n-                p.forbid_lifetime()?;\n-                if p.look_ahead(1, |t| t == &token::Eq) {\n-                    Ok(None)\n-                } else {\n-                    Ok(Some(p.parse_ty()?))\n+    /// Parses (possibly empty) list of lifetime and type arguments and associated type bindings,\n+    /// possibly including trailing comma.\n+    fn parse_generic_args(&mut self) -> PResult<'a, (Vec<Lifetime>, Vec<P<Ty>>, Vec<TypeBinding>)> {\n+        let mut lifetimes = Vec::new();\n+        let mut types = Vec::new();\n+        let mut bindings = Vec::new();\n+        let mut seen_type = false;\n+        let mut seen_binding = false;\n+        loop {\n+            let eq_is_next = self.look_ahead(1, |t| t == &token::Eq); // borrowck workaround\n+            if let Some(lifetime) = self.eat_lifetime() {\n+                // Parse lifetime argument.\n+                lifetimes.push(lifetime);\n+                if seen_type || seen_binding {\n+                    self.span_err(self.prev_span,\n+                        \"lifetime parameters must be declared prior to type parameters\");\n                 }\n-            }\n-        )?;\n-\n-        // If we found the `>`, don't continue.\n-        if !returned {\n-            return Ok((lifetimes, types, Vec::new()));\n-        }\n-\n-        // Then parse type bindings.\n-        let bindings = self.parse_seq_to_gt(\n-            Some(token::Comma),\n-            |p| {\n-                p.forbid_lifetime()?;\n-                let lo = p.span.lo;\n-                let ident = p.parse_ident()?;\n-                p.expect(&token::Eq)?;\n-                let ty = p.parse_ty_no_plus()?;\n-                let hi = ty.span.hi;\n-                let span = mk_sp(lo, hi);\n-                return Ok(TypeBinding{id: ast::DUMMY_NODE_ID,\n+            } else if self.token.is_ident() && eq_is_next {\n+                // Parse associated type binding.\n+                let lo = self.span.lo;\n+                let ident = self.parse_ident()?;\n+                self.bump();\n+                let ty = self.parse_ty()?;\n+                bindings.push(TypeBinding {\n+                    id: ast::DUMMY_NODE_ID,\n                     ident: ident,\n                     ty: ty,\n-                    span: span,\n+                    span: mk_sp(lo, self.prev_span.hi),\n                 });\n+                seen_binding = true;\n+            } else if self.token.can_begin_type() {\n+                // Parse type argument.\n+                types.push(self.parse_ty()?);\n+                if seen_binding {\n+                    self.span_err(types[types.len() - 1].span,\n+                        \"type parameters must be declared prior to associated type bindings\");\n+                }\n+                seen_type = true;\n+            } else {\n+                break\n             }\n-        )?;\n-        Ok((lifetimes, types, bindings))\n-    }\n \n-    fn forbid_lifetime(&mut self) -> PResult<'a, ()> {\n-        if self.token.is_lifetime() {\n-            let span = self.span;\n-            return Err(self.diagnostic().struct_span_err(span, \"lifetime parameters must be \\\n-                                                                declared prior to type parameters\"))\n+            if !self.eat(&token::Comma) {\n+                break\n+            }\n         }\n-        Ok(())\n+        Ok((lifetimes, types, bindings))\n     }\n \n     /// Parses an optional `where` clause and places it in `generics`.\n     ///\n     /// ```ignore\n     /// where T : Trait<U, V> + 'b, 'a : 'b\n     /// ```\n-    pub fn parse_where_clause(&mut self) -> PResult<'a, ast::WhereClause> {\n+    pub fn parse_where_clause(&mut self) -> PResult<'a, WhereClause> {\n         maybe_whole!(self, NtWhereClause, |x| x);\n \n         let mut where_clause = WhereClause {\n@@ -4313,7 +4162,7 @@ impl<'a> Parser<'a> {\n             return Ok(where_clause);\n         }\n \n-        // This is a temporary hack.\n+        // This is a temporary future proofing.\n         //\n         // We are considering adding generics to the `where` keyword as an alternative higher-rank\n         // parameter syntax (as in `where<'a>` or `where<T>`. To avoid that being a breaking\n@@ -4330,106 +4179,64 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        let mut parsed_something = false;\n         loop {\n             let lo = self.span.lo;\n-            match self.token {\n-                token::OpenDelim(token::Brace) => {\n-                    break\n-                }\n-\n-                token::Lifetime(..) => {\n-                    let bounded_lifetime =\n-                        self.parse_lifetime()?;\n-\n-                    self.expect(&token::Colon)?;\n-\n-                    let bounds =\n-                        self.parse_lifetimes(token::BinOp(token::Plus))?;\n-\n-                    let hi = self.prev_span.hi;\n-                    let span = mk_sp(lo, hi);\n-\n-                    where_clause.predicates.push(ast::WherePredicate::RegionPredicate(\n-                        ast::WhereRegionPredicate {\n-                            span: span,\n-                            lifetime: bounded_lifetime,\n-                            bounds: bounds\n+            if let Some(lifetime) = self.eat_lifetime() {\n+                // Bounds starting with a colon are mandatory, but possibly empty.\n+                self.expect(&token::Colon)?;\n+                let bounds = self.parse_lt_param_bounds();\n+                where_clause.predicates.push(ast::WherePredicate::RegionPredicate(\n+                    ast::WhereRegionPredicate {\n+                        span: mk_sp(lo, self.prev_span.hi),\n+                        lifetime: lifetime,\n+                        bounds: bounds,\n+                    }\n+                ));\n+            } else if self.token.can_begin_type() {\n+                // Parse optional `for<'a, 'b>`.\n+                // This `for` is parsed greedily and applies to the whole predicate,\n+                // the bounded type can have its own `for` applying only to it.\n+                // Example 1: for<'a> Trait1<'a>: Trait2<'a /*ok*/>\n+                // Example 2: (for<'a> Trait1<'a>): Trait2<'a /*not ok*/>\n+                // Example 3: for<'a> for<'b> Trait1<'a, 'b>: Trait2<'a /*ok*/, 'b /*not ok*/>\n+                let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n+\n+                // Parse type with mandatory colon and (possibly empty) bounds,\n+                // or with mandatory equality sign and the second type.\n+                let ty = self.parse_ty()?;\n+                if self.eat(&token::Colon) {\n+                    let bounds = self.parse_ty_param_bounds()?;\n+                    where_clause.predicates.push(ast::WherePredicate::BoundPredicate(\n+                        ast::WhereBoundPredicate {\n+                            span: mk_sp(lo, self.prev_span.hi),\n+                            bound_lifetimes: lifetime_defs,\n+                            bounded_ty: ty,\n+                            bounds: bounds,\n                         }\n                     ));\n-\n-                    parsed_something = true;\n-                }\n-\n-                _ => {\n-                    let bound_lifetimes = if self.eat_keyword(keywords::For) {\n-                        // Higher ranked constraint.\n-                        self.expect(&token::Lt)?;\n-                        let lifetime_defs = self.parse_lifetime_defs(None)?;\n-                        self.expect_gt()?;\n-                        lifetime_defs\n-                    } else {\n-                        vec![]\n-                    };\n-\n-                    let bounded_ty = self.parse_ty_no_plus()?;\n-\n-                    if self.eat(&token::Colon) {\n-                        let bounds = self.parse_ty_param_bounds()?;\n-                        let hi = self.prev_span.hi;\n-                        let span = mk_sp(lo, hi);\n-\n-                        if bounds.is_empty() {\n-                            self.span_err(span,\n-                                          \"each predicate in a `where` clause must have \\\n-                                           at least one bound in it\");\n+                // FIXME: Decide what should be used here, `=` or `==`.\n+                } else if self.eat(&token::Eq) || self.eat(&token::EqEq) {\n+                    let rhs_ty = self.parse_ty()?;\n+                    where_clause.predicates.push(ast::WherePredicate::EqPredicate(\n+                        ast::WhereEqPredicate {\n+                            span: mk_sp(lo, self.prev_span.hi),\n+                            lhs_ty: ty,\n+                            rhs_ty: rhs_ty,\n+                            id: ast::DUMMY_NODE_ID,\n                         }\n-\n-                        where_clause.predicates.push(ast::WherePredicate::BoundPredicate(\n-                                ast::WhereBoundPredicate {\n-                                    span: span,\n-                                    bound_lifetimes: bound_lifetimes,\n-                                    bounded_ty: bounded_ty,\n-                                    bounds: bounds,\n-                        }));\n-\n-                        parsed_something = true;\n-                    } else if self.eat(&token::Eq) {\n-                        // let ty = try!(self.parse_ty_no_plus());\n-                        let hi = self.prev_span.hi;\n-                        let span = mk_sp(lo, hi);\n-                        // where_clause.predicates.push(\n-                        //     ast::WherePredicate::EqPredicate(ast::WhereEqPredicate {\n-                        //         id: ast::DUMMY_NODE_ID,\n-                        //         span: span,\n-                        //         path: panic!(\"NYI\"), //bounded_ty,\n-                        //         ty: ty,\n-                        // }));\n-                        // parsed_something = true;\n-                        // // FIXME(#18433)\n-                        self.span_err(span,\n-                                     \"equality constraints are not yet supported \\\n-                                     in where clauses (#20041)\");\n-                    } else {\n-                        let prev_span = self.prev_span;\n-                        self.span_err(prev_span,\n-                              \"unexpected token in `where` clause\");\n-                    }\n+                    ));\n+                } else {\n+                    return self.unexpected();\n                 }\n-            };\n+            } else {\n+                break\n+            }\n \n             if !self.eat(&token::Comma) {\n                 break\n             }\n         }\n \n-        if !parsed_something {\n-            let prev_span = self.prev_span;\n-            self.span_err(prev_span,\n-                          \"a `where` clause must have at least one predicate \\\n-                           in it\");\n-        }\n-\n         Ok(where_clause)\n     }\n \n@@ -4528,13 +4335,13 @@ impl<'a> Parser<'a> {\n                 } else if self.look_ahead(1, |t| t.is_lifetime()) &&\n                           isolated_self(self, 2) {\n                     self.bump();\n-                    let lt = self.parse_lifetime()?;\n+                    let lt = self.eat_lifetime().expect(\"not a lifetime\");\n                     (SelfKind::Region(Some(lt), Mutability::Immutable), expect_ident(self))\n                 } else if self.look_ahead(1, |t| t.is_lifetime()) &&\n                           self.look_ahead(2, |t| t.is_keyword(keywords::Mut)) &&\n                           isolated_self(self, 3) {\n                     self.bump();\n-                    let lt = self.parse_lifetime()?;\n+                    let lt = self.eat_lifetime().expect(\"not a lifetime\");\n                     self.bump();\n                     (SelfKind::Region(Some(lt), Mutability::Mutable), expect_ident(self))\n                 } else {\n@@ -4836,8 +4643,12 @@ impl<'a> Parser<'a> {\n         let ident = self.parse_ident()?;\n         let mut tps = self.parse_generics()?;\n \n-        // Parse supertrait bounds.\n-        let bounds = self.parse_colon_then_ty_param_bounds()?;\n+        // Parse optional colon and supertrait bounds.\n+        let bounds = if self.eat(&token::Colon) {\n+            self.parse_ty_param_bounds()?\n+        } else {\n+            Vec::new()\n+        };\n \n         tps.where_clause = self.parse_where_clause()?;\n \n@@ -4928,17 +4739,21 @@ impl<'a> Parser<'a> {\n \n     /// Parse a::B<String,i32>\n     fn parse_trait_ref(&mut self) -> PResult<'a, TraitRef> {\n-        Ok(ast::TraitRef {\n+        Ok(TraitRef {\n             path: self.parse_path(PathStyle::Type)?,\n             ref_id: ast::DUMMY_NODE_ID,\n         })\n     }\n \n-    fn parse_late_bound_lifetime_defs(&mut self) -> PResult<'a, Vec<ast::LifetimeDef>> {\n+    fn parse_late_bound_lifetime_defs(&mut self) -> PResult<'a, Vec<LifetimeDef>> {\n         if self.eat_keyword(keywords::For) {\n-            self.expect(&token::Lt)?;\n-            let lifetime_defs = self.parse_lifetime_defs(None)?;\n+            self.expect_lt()?;\n+            let (lifetime_defs, ty_params) = self.parse_generic_params()?;\n             self.expect_gt()?;\n+            if !ty_params.is_empty() {\n+                self.span_err(ty_params[0].span,\n+                              \"only lifetime parameters can be used in this context\");\n+            }\n             Ok(lifetime_defs)\n         } else {\n             Ok(Vec::new())\n@@ -4950,7 +4765,7 @@ impl<'a> Parser<'a> {\n         let lo = self.span.lo;\n         let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n \n-        Ok(ast::PolyTraitRef {\n+        Ok(PolyTraitRef {\n             bound_lifetimes: lifetime_defs,\n             trait_ref: self.parse_trait_ref()?,\n             span: mk_sp(lo, self.prev_span.hi),"}, {"sha": "d9e47a6b56e8f1cd5c0f12f18f0d58d6f79e72e3", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=b795abeb1dc0f6d27e49d980a48936b687754b28", "patch": "@@ -187,6 +187,29 @@ impl Token {\n         }\n     }\n \n+    /// Returns `true` if the token can appear at the start of a type.\n+    pub fn can_begin_type(&self) -> bool {\n+        match *self {\n+            OpenDelim(Paren)            => true, // tuple\n+            OpenDelim(Bracket)          => true, // array\n+            Ident(..)                   => true, // type name or keyword\n+            Underscore                  => true, // placeholder\n+            Not                         => true, // never\n+            BinOp(Star)                 => true, // raw pointer\n+            BinOp(And)                  => true, // reference\n+            AndAnd                      => true, // double reference\n+            Lt | BinOp(Shl)             => true, // associated path\n+            ModSep                      => true, // global path\n+            Interpolated(ref nt) => match **nt {\n+                NtTy(..) => true,\n+                NtIdent(..) => true,\n+                NtPath(..) => true,\n+                _ => false,\n+            },\n+            _ => false,\n+        }\n+    }\n+\n     /// Returns `true` if the token is any literal\n     pub fn is_lit(&self) -> bool {\n         match *self {"}, {"sha": "5e09473ab77da9ee2987123bc7c740a158247908", "filename": "src/test/compile-fail/attrs-with-no-formal-in-generics-2.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fcompile-fail%2Fattrs-with-no-formal-in-generics-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fcompile-fail%2Fattrs-with-no-formal-in-generics-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattrs-with-no-formal-in-generics-2.rs?ref=b795abeb1dc0f6d27e49d980a48936b687754b28", "patch": "@@ -17,10 +17,7 @@\n \n struct RefAny<'a, T>(&'a T);\n \n-impl<#[rustc_1] 'a, #[rustc_2] T, #[oops]> RefAny<'a, T> {\n-    //~^ ERROR expected identifier, found `>`\n-}\n+impl<#[rustc_1] 'a, #[rustc_2] T, #[oops]> RefAny<'a, T> {}\n+//~^ ERROR trailing attribute after type parameters\n \n-fn main() {\n-\n-}\n+fn main() {}"}, {"sha": "77e5520326379e21193ee7d5ff1320aa8fc9ba7b", "filename": "src/test/compile-fail/generic-non-trailing-defaults.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fcompile-fail%2Fgeneric-non-trailing-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fcompile-fail%2Fgeneric-non-trailing-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgeneric-non-trailing-defaults.rs?ref=b795abeb1dc0f6d27e49d980a48936b687754b28", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Heap;\n+\n+struct Vec<A = Heap, T>;\n+//~^ ERROR type parameters with a default must be trailing\n+\n+struct Foo<A, B = Vec<C>, C>;\n+//~^ ERROR type parameters with a default must be trailing\n+//~| ERROR type parameters with a default cannot use forward declared identifiers\n+\n+fn main() {}"}, {"sha": "a1949df661a34a699e9708864f1ad069d16c3867", "filename": "src/test/compile-fail/issue-20616-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fcompile-fail%2Fissue-20616-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fcompile-fail%2Fissue-20616-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20616-1.rs?ref=b795abeb1dc0f6d27e49d980a48936b687754b28", "patch": "@@ -16,7 +16,7 @@\n type Type_1_<'a, T> = &'a T;\n \n \n-type Type_1<'a T> = &'a T; //~ error: expected `,` or `>` after lifetime name, found `T`\n+type Type_1<'a T> = &'a T; //~ error: expected one of `,`, `:`, or `>`, found `T`\n \n \n //type Type_2 = Type_1_<'static ()>; // error: expected `,` or `>` after lifetime name, found `(`"}, {"sha": "87b836d68727480b74e09e10d68b37a26056daba", "filename": "src/test/compile-fail/issue-20616-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fcompile-fail%2Fissue-20616-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fcompile-fail%2Fissue-20616-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20616-2.rs?ref=b795abeb1dc0f6d27e49d980a48936b687754b28", "patch": "@@ -19,7 +19,7 @@ type Type_1_<'a, T> = &'a T;\n //type Type_1<'a T> = &'a T; // error: expected `,` or `>` after lifetime name, found `T`\n \n \n-type Type_2 = Type_1_<'static ()>; //~ error: expected `,` or `>` after lifetime name, found `(`\n+type Type_2 = Type_1_<'static ()>; //~ error: expected one of `,` or `>`, found `(`\n \n \n //type Type_3<T> = Box<T,,>; // error: expected type, found `,`"}, {"sha": "9a5972a7a1641ae0b85e416d02ba6c727e802fd6", "filename": "src/test/compile-fail/issue-20616-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fcompile-fail%2Fissue-20616-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fcompile-fail%2Fissue-20616-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20616-3.rs?ref=b795abeb1dc0f6d27e49d980a48936b687754b28", "patch": "@@ -22,7 +22,7 @@ type Type_1_<'a, T> = &'a T;\n //type Type_2 = Type_1_<'static ()>; // error: expected `,` or `>` after lifetime name, found `(`\n \n \n-type Type_3<T> = Box<T,,>; //~ error: expected type, found `,`\n+type Type_3<T> = Box<T,,>; //~ error: expected `>`, found `,`\n \n \n //type Type_4<T> = Type_1_<'static,, T>; // error: expected type, found `,`"}, {"sha": "1567698e476ba0b90af6307247abc98543b8e271", "filename": "src/test/compile-fail/issue-20616-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fcompile-fail%2Fissue-20616-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fcompile-fail%2Fissue-20616-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20616-4.rs?ref=b795abeb1dc0f6d27e49d980a48936b687754b28", "patch": "@@ -25,7 +25,7 @@ type Type_1_<'a, T> = &'a T;\n //type Type_3<T> = Box<T,,>; // error: expected type, found `,`\n \n \n-type Type_4<T> = Type_1_<'static,, T>; //~ error: expected type, found `,`\n+type Type_4<T> = Type_1_<'static,, T>; //~ error: expected `>`, found `,`\n \n \n type Type_5_<'a> = Type_1_<'a, ()>;"}, {"sha": "c5a0624574d0e2b79b529a2d0c9bc1242a210ee3", "filename": "src/test/compile-fail/issue-20616-5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fcompile-fail%2Fissue-20616-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fcompile-fail%2Fissue-20616-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20616-5.rs?ref=b795abeb1dc0f6d27e49d980a48936b687754b28", "patch": "@@ -31,7 +31,7 @@ type Type_1_<'a, T> = &'a T;\n type Type_5_<'a> = Type_1_<'a, ()>;\n \n \n-type Type_5<'a> = Type_1_<'a, (),,>; //~ error: expected type, found `,`\n+type Type_5<'a> = Type_1_<'a, (),,>; //~ error: expected `>`, found `,`\n \n \n //type Type_6 = Type_5_<'a,,>; // error: expected type, found `,`"}, {"sha": "56578409546ff758ee98d6789e4a645fc1fbcbda", "filename": "src/test/compile-fail/issue-20616-6.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fcompile-fail%2Fissue-20616-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fcompile-fail%2Fissue-20616-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20616-6.rs?ref=b795abeb1dc0f6d27e49d980a48936b687754b28", "patch": "@@ -34,7 +34,7 @@ type Type_5_<'a> = Type_1_<'a, ()>;\n //type Type_5<'a> = Type_1_<'a, (),,>; // error: expected type, found `,`\n \n \n-type Type_6 = Type_5_<'a,,>; //~ error: expected type, found `,`\n+type Type_6 = Type_5_<'a,,>; //~ error: expected `>`, found `,`\n \n \n //type Type_7 = Box<(),,>; // error: expected type, found `,`"}, {"sha": "ecd0a467cf6b069bdaf6596086adc1a47354d4db", "filename": "src/test/compile-fail/issue-20616-7.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fcompile-fail%2Fissue-20616-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fcompile-fail%2Fissue-20616-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20616-7.rs?ref=b795abeb1dc0f6d27e49d980a48936b687754b28", "patch": "@@ -37,7 +37,7 @@ type Type_5_<'a> = Type_1_<'a, ()>;\n //type Type_6 = Type_5_<'a,,>; // error: expected type, found `,`\n \n \n-type Type_7 = Box<(),,>; //~ error: expected type, found `,`\n+type Type_7 = Box<(),,>; //~ error: expected `>`, found `,`\n \n \n //type Type_8<'a,,> = &'a (); // error: expected ident, found `,`"}, {"sha": "535672c65e46e457eabd39e170ac73968878323e", "filename": "src/test/compile-fail/issue-20616-8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fcompile-fail%2Fissue-20616-8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fcompile-fail%2Fissue-20616-8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20616-8.rs?ref=b795abeb1dc0f6d27e49d980a48936b687754b28", "patch": "@@ -40,7 +40,7 @@ type Type_5_<'a> = Type_1_<'a, ()>;\n //type Type_7 = Box<(),,>; // error: expected type, found `,`\n \n \n-type Type_8<'a,,> = &'a (); //~ error: expected identifier, found `,`\n+type Type_8<'a,,> = &'a (); //~ error: expected `>`, found `,`\n \n \n //type Type_9<T,,> = Box<T>; // error: expected identifier, found `,`"}, {"sha": "b666a8b67aa3f09a7334ffcbcc96fdf272bd2401", "filename": "src/test/compile-fail/issue-20616-9.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fcompile-fail%2Fissue-20616-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fcompile-fail%2Fissue-20616-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20616-9.rs?ref=b795abeb1dc0f6d27e49d980a48936b687754b28", "patch": "@@ -43,4 +43,4 @@ type Type_5_<'a> = Type_1_<'a, ()>;\n //type Type_8<'a,,> = &'a (); // error: expected identifier, found `,`\n \n \n-type Type_9<T,,> = Box<T>; //~ error: expected identifier, found `,`\n+type Type_9<T,,> = Box<T>; //~ error: expected `>`, found `,`"}, {"sha": "f0d1feffec80bbe57568f53000e64adde3120d2f", "filename": "src/test/parse-fail/issue-14303-path.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fparse-fail%2Fissue-14303-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fparse-fail%2Fissue-14303-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-14303-path.rs?ref=b795abeb1dc0f6d27e49d980a48936b687754b28", "patch": "@@ -12,4 +12,3 @@\n \n fn bar<'a, T>(x: mymodule::X<'a, T, 'b, 'c>) {}\n //~^ ERROR lifetime parameters must be declared prior to type parameters\n-//~^^ ERROR expected pattern, found `'c`"}, {"sha": "3f41c0edd2e6feed384e4d6ad8bec116f7c628d9", "filename": "src/test/parse-fail/issue-17904-2.rs", "status": "renamed", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fparse-fail%2Fissue-17904-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fparse-fail%2Fissue-17904-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-17904-2.rs?ref=b795abeb1dc0f6d27e49d980a48936b687754b28", "patch": "@@ -10,10 +10,6 @@\n \n // compile-flags: -Z parse-only -Z continue-parse-after-error\n \n-struct Heap;\n-\n-struct Vec<A = Heap, T>; //~ ERROR type parameters with a default must be trailing\n-\n-struct Foo<A, B = Vec<C>, C>; //~ ERROR type parameters with a default must be trailing\n+struct Bar<T> { x: T } where T: Copy //~ ERROR expected item, found `where`\n \n fn main() {}", "previous_filename": "src/test/parse-fail/generic-non-trailing-defaults.rs"}, {"sha": "ae28ac76acb9827621a2453983861190cb164d81", "filename": "src/test/parse-fail/issue-17904.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fparse-fail%2Fissue-17904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fparse-fail%2Fissue-17904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-17904.rs?ref=b795abeb1dc0f6d27e49d980a48936b687754b28", "patch": "@@ -13,7 +13,6 @@\n struct Baz<U> where U: Eq(U); //This is parsed as the new Fn* style parenthesis syntax.\n struct Baz<U> where U: Eq(U) -> R; // Notice this parses as well.\n struct Baz<U>(U) where U: Eq; // This rightfully signals no error as well.\n-struct Foo<T> where T: Copy, (T); //~ ERROR unexpected token in `where` clause\n-struct Bar<T> { x: T } where T: Copy //~ ERROR expected item, found `where`\n+struct Foo<T> where T: Copy, (T); //~ ERROR expected one of `+`, `:`, `==`, or `=`, found `;`\n \n fn main() {}"}, {"sha": "9e200094093683d3ba9e9b38f83902c53e191bd1", "filename": "src/test/parse-fail/issue-32214.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fparse-fail%2Fissue-32214.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fparse-fail%2Fissue-32214.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-32214.rs?ref=b795abeb1dc0f6d27e49d980a48936b687754b28", "patch": "@@ -10,8 +10,7 @@\n \n // compile-flags: -Z parse-only -Z continue-parse-after-error\n \n-pub fn test<W, I: Iterator<Item=(), W> >() {\n-    //~^ ERROR expected `=`, found `>`\n-}\n+pub fn test<W, I: Iterator<Item=(), W> >() {}\n+//~^ ERROR type parameters must be declared prior to associated type bindings\n \n fn main() { }"}, {"sha": "e1975952fca3ea268bb7bfe1c861d663535bd860", "filename": "src/test/parse-fail/lifetime-semicolon.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fparse-fail%2Flifetime-semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fparse-fail%2Flifetime-semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Flifetime-semicolon.rs?ref=b795abeb1dc0f6d27e49d980a48936b687754b28", "patch": "@@ -15,5 +15,4 @@ struct Foo<'a, 'b> {\n }\n \n fn foo<'a, 'b>(x: &mut Foo<'a; 'b>) {}\n-//~^ ERROR expected `,` or `>` after lifetime name, found `;`\n-//~^^ NOTE did you mean a single argument type &'a Type, or did you mean the comma-separated\n+//~^ ERROR expected one of `,` or `>`, found `;`"}, {"sha": "cf67b518fff9180eba63d68eddf72feff8f330ad", "filename": "src/test/parse-fail/where-clauses-no-bounds-or-predicates.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fparse-fail%2Fwhere-clauses-no-bounds-or-predicates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b795abeb1dc0f6d27e49d980a48936b687754b28/src%2Ftest%2Fparse-fail%2Fwhere-clauses-no-bounds-or-predicates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fwhere-clauses-no-bounds-or-predicates.rs?ref=b795abeb1dc0f6d27e49d980a48936b687754b28", "patch": "@@ -10,13 +10,13 @@\n \n // compile-flags: -Z parse-only -Z continue-parse-after-error\n \n+// Empty predicate list is OK\n fn equal1<T>(_: &T, _: &T) -> bool where {\n-//~^ ERROR a `where` clause must have at least one predicate in it\n     true\n }\n \n+// Empty bound list is OK\n fn equal2<T>(_: &T, _: &T) -> bool where T: {\n-//~^ ERROR each predicate in a `where` clause must have at least one bound\n     true\n }\n "}]}