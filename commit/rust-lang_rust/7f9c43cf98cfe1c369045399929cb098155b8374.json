{"sha": "7f9c43cf98cfe1c369045399929cb098155b8374", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmOWM0M2NmOThjZmUxYzM2OTA0NTM5OTkyOWNiMDk4MTU1YjgzNzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-23T18:50:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-23T18:50:01Z"}, "message": "Auto merge of #79788 - pietroalbini:bootstrap-tarball, r=Mark-Simulacrum\n\nRefactor dist tarballs generation\n\nBefore this PR, each tarball we ship as part of a release was generated by manually creating the directory structure and invoking `rust-installer generate`. This means each tarball was slightly different, adding new ones meant copy-pasting the code generating another tarball and removing the useless parts, and more importantly refactoring how tarballs are generated is extremely time-consuming.\n\nThis PR introduces a new abstraction in rustbuild, `Tarball`. The `Tarball` struct provides a trivial API to generate simple tarballs, and can get out of the way when more complex tarballs have to generate. For example, the whole code to generate the `build-manifest` tarball is now the following:\n\n```rust\nlet tarball = Tarball::new(builder, \"build-manifest\", &self.target.triple);\ntarball.add_file(&build_manifest, \"bin\", 0o755);\ntarball.generate()\n```\n\nOne notable change between the old tarballs and the new ones is that the \"overlay\" (README.md, COPYRIGHT, LICENSE-APACHE and LICENSE-MIT) is now available in every produced tarball, while before each tarball inconsistently had or didn't have those files. Tarballs that need a different overlay have a way to change which files to include (with the `set_overlay` method):\n\n```rust\nlet mut tarball = Tarball::new(builder, \"rustfmt\", &target.triple);\ntarball.set_overlay(OverlayKind::Rustfmt);\ntarball.add_file(rustfmt, \"bin\", 0o755);\ntarball.add_file(cargofmt, \"bin\", 0o755);\ntarball.add_legal_and_readme_to(\"share/doc/rustfmt\");\nSome(tarball.generate())\n```\n\nThe PR should be reviewed commit-by-commit, as each commit migrated a separate tarball to use `Tarball`. During development i made sure every tarball can still be generated, and for the most compex tarballs I manually ensured the list of files between the old and new tarballs did not have unexpected changes.\n\nr? `@Mark-Simulacrum`", "tree": {"sha": "70c2a2142d7da9798840620279aa4b201e3de191", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70c2a2142d7da9798840620279aa4b201e3de191"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f9c43cf98cfe1c369045399929cb098155b8374", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f9c43cf98cfe1c369045399929cb098155b8374", "html_url": "https://github.com/rust-lang/rust/commit/7f9c43cf98cfe1c369045399929cb098155b8374", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f9c43cf98cfe1c369045399929cb098155b8374/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e937ae9493d0ade1b0d3edd61d7cc32b91a363c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e937ae9493d0ade1b0d3edd61d7cc32b91a363c1", "html_url": "https://github.com/rust-lang/rust/commit/e937ae9493d0ade1b0d3edd61d7cc32b91a363c1"}, {"sha": "8736731f70be86b169a0dcc6a1900ccc05d2db85", "url": "https://api.github.com/repos/rust-lang/rust/commits/8736731f70be86b169a0dcc6a1900ccc05d2db85", "html_url": "https://github.com/rust-lang/rust/commit/8736731f70be86b169a0dcc6a1900ccc05d2db85"}], "stats": {"total": 1299, "additions": 459, "deletions": 840}, "files": [{"sha": "0a79d09b27fed29598f66cbe41e7ac28a0b215c0", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 160, "deletions": 836, "changes": 996, "blob_url": "https://github.com/rust-lang/rust/blob/7f9c43cf98cfe1c369045399929cb098155b8374/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f9c43cf98cfe1c369045399929cb098155b8374/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=7f9c43cf98cfe1c369045399929cb098155b8374", "patch": "@@ -19,6 +19,7 @@ use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::cache::{Interned, INTERNER};\n use crate::compile;\n use crate::config::TargetSelection;\n+use crate::tarball::{OverlayKind, Tarball};\n use crate::tool::{self, Tool};\n use crate::util::{exe, is_dylib, timeit};\n use crate::{Compiler, DependencyType, Mode, LLVM_TOOLS};\n@@ -36,10 +37,6 @@ pub fn tmpdir(builder: &Builder<'_>) -> PathBuf {\n     builder.out.join(\"tmp/dist\")\n }\n \n-fn rust_installer(builder: &Builder<'_>) -> Command {\n-    builder.tool_cmd(Tool::RustInstaller)\n-}\n-\n fn missing_tool(tool_name: &str, skip: bool) {\n     if skip {\n         println!(\"Unable to build {}, skipping dist\", tool_name)\n@@ -54,7 +51,7 @@ pub struct Docs {\n }\n \n impl Step for Docs {\n-    type Output = PathBuf;\n+    type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -66,48 +63,20 @@ impl Step for Docs {\n     }\n \n     /// Builds the `rust-docs` installer component.\n-    fn run(self, builder: &Builder<'_>) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n         let host = self.host;\n-\n-        let name = pkgname(builder, \"rust-docs\");\n-\n         if !builder.config.docs {\n-            return distdir(builder).join(format!(\"{}-{}.tar.gz\", name, host.triple));\n+            return None;\n         }\n-\n         builder.default_doc(None);\n \n-        builder.info(&format!(\"Dist docs ({})\", host));\n-        let _time = timeit(builder);\n+        let dest = \"share/doc/rust/html\";\n \n-        let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, host.triple));\n-        let _ = fs::remove_dir_all(&image);\n-\n-        let dst = image.join(\"share/doc/rust/html\");\n-        t!(fs::create_dir_all(&dst));\n-        let src = builder.doc_out(host);\n-        builder.cp_r(&src, &dst);\n-        builder.install(&builder.src.join(\"src/doc/robots.txt\"), &dst, 0o644);\n-\n-        let mut cmd = rust_installer(builder);\n-        cmd.arg(\"generate\")\n-            .arg(\"--product-name=Rust-Documentation\")\n-            .arg(\"--rel-manifest-dir=rustlib\")\n-            .arg(\"--success-message=Rust-documentation-is-installed.\")\n-            .arg(\"--image-dir\")\n-            .arg(&image)\n-            .arg(\"--work-dir\")\n-            .arg(&tmpdir(builder))\n-            .arg(\"--output-dir\")\n-            .arg(&distdir(builder))\n-            .arg(format!(\"--package-name={}-{}\", name, host.triple))\n-            .arg(\"--component-name=rust-docs\")\n-            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n-            .arg(\"--bulk-dirs=share/doc/rust/html\");\n-        builder.run(&mut cmd);\n-        builder.remove_dir(&image);\n-\n-        distdir(builder).join(format!(\"{}-{}.tar.gz\", name, host.triple))\n+        let mut tarball = Tarball::new(builder, \"rust-docs\", &host.triple);\n+        tarball.set_product_name(\"Rust Documentation\");\n+        tarball.add_dir(&builder.doc_out(host), dest);\n+        tarball.add_file(&builder.src.join(\"src/doc/robots.txt\"), dest, 0o644);\n+        Some(tarball.generate())\n     }\n }\n \n@@ -117,7 +86,7 @@ pub struct RustcDocs {\n }\n \n impl Step for RustcDocs {\n-    type Output = PathBuf;\n+    type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -129,47 +98,17 @@ impl Step for RustcDocs {\n     }\n \n     /// Builds the `rustc-docs` installer component.\n-    fn run(self, builder: &Builder<'_>) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n         let host = self.host;\n-\n-        let name = pkgname(builder, \"rustc-docs\");\n-\n         if !builder.config.compiler_docs {\n-            return distdir(builder).join(format!(\"{}-{}.tar.gz\", name, host.triple));\n+            return None;\n         }\n-\n         builder.default_doc(None);\n \n-        let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, host.triple));\n-        let _ = fs::remove_dir_all(&image);\n-\n-        let dst = image.join(\"share/doc/rust/html/rustc\");\n-        t!(fs::create_dir_all(&dst));\n-        let src = builder.compiler_doc_out(host);\n-        builder.cp_r(&src, &dst);\n-\n-        let mut cmd = rust_installer(builder);\n-        cmd.arg(\"generate\")\n-            .arg(\"--product-name=Rustc-Documentation\")\n-            .arg(\"--rel-manifest-dir=rustlib\")\n-            .arg(\"--success-message=Rustc-documentation-is-installed.\")\n-            .arg(\"--image-dir\")\n-            .arg(&image)\n-            .arg(\"--work-dir\")\n-            .arg(&tmpdir(builder))\n-            .arg(\"--output-dir\")\n-            .arg(&distdir(builder))\n-            .arg(format!(\"--package-name={}-{}\", name, host.triple))\n-            .arg(\"--component-name=rustc-docs\")\n-            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n-            .arg(\"--bulk-dirs=share/doc/rust/html/rustc\");\n-\n-        builder.info(&format!(\"Dist compiler docs ({})\", host));\n-        let _time = timeit(builder);\n-        builder.run(&mut cmd);\n-        builder.remove_dir(&image);\n-\n-        distdir(builder).join(format!(\"{}-{}.tar.gz\", name, host.triple))\n+        let mut tarball = Tarball::new(builder, \"rustc-docs\", &host.triple);\n+        tarball.set_product_name(\"Rustc Documentation\");\n+        tarball.add_dir(&builder.compiler_doc_out(host), \"share/doc/rust/html/rustc\");\n+        Some(tarball.generate())\n     }\n }\n \n@@ -345,41 +284,20 @@ impl Step for Mingw {\n     /// without any extra installed software (e.g., we bundle gcc, libraries, etc).\n     fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n         let host = self.host;\n-\n         if !host.contains(\"pc-windows-gnu\") {\n             return None;\n         }\n \n-        builder.info(&format!(\"Dist mingw ({})\", host));\n-        let _time = timeit(builder);\n-        let name = pkgname(builder, \"rust-mingw\");\n-        let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, host.triple));\n-        let _ = fs::remove_dir_all(&image);\n-        t!(fs::create_dir_all(&image));\n+        let mut tarball = Tarball::new(builder, \"rust-mingw\", &host.triple);\n+        tarball.set_product_name(\"Rust MinGW\");\n \n         // The first argument is a \"temporary directory\" which is just\n         // thrown away (this contains the runtime DLLs included in the rustc package\n         // above) and the second argument is where to place all the MinGW components\n         // (which is what we want).\n-        make_win_dist(&tmpdir(builder), &image, host, &builder);\n-\n-        let mut cmd = rust_installer(builder);\n-        cmd.arg(\"generate\")\n-            .arg(\"--product-name=Rust-MinGW\")\n-            .arg(\"--rel-manifest-dir=rustlib\")\n-            .arg(\"--success-message=Rust-MinGW-is-installed.\")\n-            .arg(\"--image-dir\")\n-            .arg(&image)\n-            .arg(\"--work-dir\")\n-            .arg(&tmpdir(builder))\n-            .arg(\"--output-dir\")\n-            .arg(&distdir(builder))\n-            .arg(format!(\"--package-name={}-{}\", name, host.triple))\n-            .arg(\"--component-name=rust-mingw\")\n-            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n-        builder.run(&mut cmd);\n-        t!(fs::remove_dir_all(&image));\n-        Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, host.triple)))\n+        make_win_dist(&tmpdir(builder), tarball.image_dir(), host, &builder);\n+\n+        Some(tarball.generate())\n     }\n }\n \n@@ -407,30 +325,10 @@ impl Step for Rustc {\n         let compiler = self.compiler;\n         let host = self.compiler.host;\n \n-        let name = pkgname(builder, \"rustc\");\n-        let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, host.triple));\n-        let _ = fs::remove_dir_all(&image);\n-        let overlay = tmpdir(builder).join(format!(\"{}-{}-overlay\", name, host.triple));\n-        let _ = fs::remove_dir_all(&overlay);\n+        let tarball = Tarball::new(builder, \"rustc\", &host.triple);\n \n         // Prepare the rustc \"image\", what will actually end up getting installed\n-        prepare_image(builder, compiler, &image);\n-\n-        // Prepare the overlay which is part of the tarball but won't actually be\n-        // installed\n-        let cp = |file: &str| {\n-            builder.install(&builder.src.join(file), &overlay, 0o644);\n-        };\n-        cp(\"COPYRIGHT\");\n-        cp(\"LICENSE-APACHE\");\n-        cp(\"LICENSE-MIT\");\n-        cp(\"README.md\");\n-        // tiny morsel of metadata is used by rust-packaging\n-        let version = builder.rust_version();\n-        builder.create(&overlay.join(\"version\"), &version);\n-        if let Some(sha) = builder.rust_sha() {\n-            builder.create(&overlay.join(\"git-commit-hash\"), &sha);\n-        }\n+        prepare_image(builder, compiler, tarball.image_dir());\n \n         // On MinGW we've got a few runtime DLL dependencies that we need to\n         // include. The first argument to this script is where to put these DLLs\n@@ -443,38 +341,11 @@ impl Step for Rustc {\n         // install will *also* include the rust-mingw package, which also needs\n         // licenses, so to be safe we just include it here in all MinGW packages.\n         if host.contains(\"pc-windows-gnu\") {\n-            make_win_dist(&image, &tmpdir(builder), host, builder);\n-\n-            let dst = image.join(\"share/doc\");\n-            t!(fs::create_dir_all(&dst));\n-            builder.cp_r(&builder.src.join(\"src/etc/third-party\"), &dst);\n+            make_win_dist(tarball.image_dir(), &tmpdir(builder), host, builder);\n+            tarball.add_dir(builder.src.join(\"src/etc/third-party\"), \"share/doc\");\n         }\n \n-        // Finally, wrap everything up in a nice tarball!\n-        let mut cmd = rust_installer(builder);\n-        cmd.arg(\"generate\")\n-            .arg(\"--product-name=Rust\")\n-            .arg(\"--rel-manifest-dir=rustlib\")\n-            .arg(\"--success-message=Rust-is-ready-to-roll.\")\n-            .arg(\"--image-dir\")\n-            .arg(&image)\n-            .arg(\"--work-dir\")\n-            .arg(&tmpdir(builder))\n-            .arg(\"--output-dir\")\n-            .arg(&distdir(builder))\n-            .arg(\"--non-installed-overlay\")\n-            .arg(&overlay)\n-            .arg(format!(\"--package-name={}-{}\", name, host.triple))\n-            .arg(\"--component-name=rustc\")\n-            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n-\n-        builder.info(&format!(\"Dist rustc stage{} ({})\", compiler.stage, host.triple));\n-        let _time = timeit(builder);\n-        builder.run(&mut cmd);\n-        builder.remove_dir(&image);\n-        builder.remove_dir(&overlay);\n-\n-        return distdir(builder).join(format!(\"{}-{}.tar.gz\", name, host.triple));\n+        return tarball.generate();\n \n         fn prepare_image(builder: &Builder<'_>, compiler: Compiler, image: &Path) {\n             let host = compiler.host;\n@@ -684,7 +555,7 @@ pub struct Std {\n }\n \n impl Step for Std {\n-    type Output = PathBuf;\n+    type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -702,46 +573,24 @@ impl Step for Std {\n         });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n         let compiler = self.compiler;\n         let target = self.target;\n \n-        let name = pkgname(builder, \"rust-std\");\n-        let archive = distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target.triple));\n         if skip_host_target_lib(builder, compiler) {\n-            return archive;\n+            return None;\n         }\n \n         builder.ensure(compile::Std { compiler, target });\n \n-        let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, target.triple));\n-        let _ = fs::remove_dir_all(&image);\n+        let mut tarball = Tarball::new(builder, \"rust-std\", &target.triple);\n+        tarball.include_target_in_component_name(true);\n \n         let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n         let stamp = compile::libstd_stamp(builder, compiler_to_use, target);\n-        copy_target_libs(builder, target, &image, &stamp);\n-\n-        let mut cmd = rust_installer(builder);\n-        cmd.arg(\"generate\")\n-            .arg(\"--product-name=Rust\")\n-            .arg(\"--rel-manifest-dir=rustlib\")\n-            .arg(\"--success-message=std-is-standing-at-the-ready.\")\n-            .arg(\"--image-dir\")\n-            .arg(&image)\n-            .arg(\"--work-dir\")\n-            .arg(&tmpdir(builder))\n-            .arg(\"--output-dir\")\n-            .arg(&distdir(builder))\n-            .arg(format!(\"--package-name={}-{}\", name, target.triple))\n-            .arg(format!(\"--component-name=rust-std-{}\", target.triple))\n-            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n-\n-        builder\n-            .info(&format!(\"Dist std stage{} ({} -> {})\", compiler.stage, &compiler.host, target));\n-        let _time = timeit(builder);\n-        builder.run(&mut cmd);\n-        builder.remove_dir(&image);\n-        archive\n+        copy_target_libs(builder, target, &tarball.image_dir(), &stamp);\n+\n+        Some(tarball.generate())\n     }\n }\n \n@@ -752,7 +601,7 @@ pub struct RustcDev {\n }\n \n impl Step for RustcDev {\n-    type Output = PathBuf;\n+    type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n@@ -771,60 +620,36 @@ impl Step for RustcDev {\n         });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n         let compiler = self.compiler;\n         let target = self.target;\n-\n-        let name = pkgname(builder, \"rustc-dev\");\n-        let archive = distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target.triple));\n         if skip_host_target_lib(builder, compiler) {\n-            return archive;\n+            return None;\n         }\n \n         builder.ensure(compile::Rustc { compiler, target });\n \n-        let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, target.triple));\n-        let _ = fs::remove_dir_all(&image);\n+        let tarball = Tarball::new(builder, \"rustc-dev\", &target.triple);\n \n         let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n         let stamp = compile::librustc_stamp(builder, compiler_to_use, target);\n-        copy_target_libs(builder, target, &image, &stamp);\n-\n-        // Copy compiler sources.\n-        let dst_src = image.join(\"lib/rustlib/rustc-src/rust\");\n-        t!(fs::create_dir_all(&dst_src));\n+        copy_target_libs(builder, target, tarball.image_dir(), &stamp);\n \n-        let src_files = [\"Cargo.lock\"];\n+        let src_files = &[\"Cargo.lock\"];\n         // This is the reduced set of paths which will become the rustc-dev component\n         // (essentially the compiler crates and all of their path dependencies).\n-        copy_src_dirs(builder, &builder.src, &[\"compiler\"], &[], &dst_src);\n-        for file in src_files.iter() {\n-            builder.copy(&builder.src.join(file), &dst_src.join(file));\n+        copy_src_dirs(\n+            builder,\n+            &builder.src,\n+            &[\"compiler\"],\n+            &[],\n+            &tarball.image_dir().join(\"lib/rustlib/rustc-src/rust\"),\n+        );\n+        for file in src_files {\n+            tarball.add_file(builder.src.join(file), \"lib/rustlib/rustc-src/rust\", 0o644);\n         }\n \n-        let mut cmd = rust_installer(builder);\n-        cmd.arg(\"generate\")\n-            .arg(\"--product-name=Rust\")\n-            .arg(\"--rel-manifest-dir=rustlib\")\n-            .arg(\"--success-message=Rust-is-ready-to-develop.\")\n-            .arg(\"--image-dir\")\n-            .arg(&image)\n-            .arg(\"--work-dir\")\n-            .arg(&tmpdir(builder))\n-            .arg(\"--output-dir\")\n-            .arg(&distdir(builder))\n-            .arg(format!(\"--package-name={}-{}\", name, target.triple))\n-            .arg(format!(\"--component-name=rustc-dev-{}\", target.triple))\n-            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n-\n-        builder.info(&format!(\n-            \"Dist rustc-dev stage{} ({} -> {})\",\n-            compiler.stage, &compiler.host, target\n-        ));\n-        let _time = timeit(builder);\n-        builder.run(&mut cmd);\n-        builder.remove_dir(&image);\n-        archive\n+        Some(tarball.generate())\n     }\n }\n \n@@ -835,7 +660,7 @@ pub struct Analysis {\n }\n \n impl Step for Analysis {\n-    type Output = PathBuf;\n+    type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -858,52 +683,26 @@ impl Step for Analysis {\n     }\n \n     /// Creates a tarball of save-analysis metadata, if available.\n-    fn run(self, builder: &Builder<'_>) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n         let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n-        let name = pkgname(builder, \"rust-analysis\");\n-\n         if compiler.host != builder.config.build {\n-            return distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target.triple));\n+            return None;\n         }\n \n         builder.ensure(compile::Std { compiler, target });\n-\n-        let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, target.triple));\n-\n         let src = builder\n             .stage_out(compiler, Mode::Std)\n             .join(target.triple)\n             .join(builder.cargo_dir())\n-            .join(\"deps\");\n+            .join(\"deps\")\n+            .join(\"save-analysis\");\n \n-        let image_src = src.join(\"save-analysis\");\n-        let dst = image.join(\"lib/rustlib\").join(target.triple).join(\"analysis\");\n-        t!(fs::create_dir_all(&dst));\n-        builder.info(&format!(\"image_src: {:?}, dst: {:?}\", image_src, dst));\n-        builder.cp_r(&image_src, &dst);\n-\n-        let mut cmd = rust_installer(builder);\n-        cmd.arg(\"generate\")\n-            .arg(\"--product-name=Rust\")\n-            .arg(\"--rel-manifest-dir=rustlib\")\n-            .arg(\"--success-message=save-analysis-saved.\")\n-            .arg(\"--image-dir\")\n-            .arg(&image)\n-            .arg(\"--work-dir\")\n-            .arg(&tmpdir(builder))\n-            .arg(\"--output-dir\")\n-            .arg(&distdir(builder))\n-            .arg(format!(\"--package-name={}-{}\", name, target.triple))\n-            .arg(format!(\"--component-name=rust-analysis-{}\", target.triple))\n-            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n-\n-        builder.info(\"Dist analysis\");\n-        let _time = timeit(builder);\n-        builder.run(&mut cmd);\n-        builder.remove_dir(&image);\n-        distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target.triple))\n+        let mut tarball = Tarball::new(builder, \"rust-analysis\", &target.triple);\n+        tarball.include_target_in_component_name(true);\n+        tarball.add_dir(src, format!(\"lib/rustlib/{}/analysis\", target.triple));\n+        Some(tarball.generate())\n     }\n }\n \n@@ -1011,9 +810,7 @@ impl Step for Src {\n \n     /// Creates the `rust-src` installer component\n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n-        let name = pkgname(builder, \"rust-src\");\n-        let image = tmpdir(builder).join(format!(\"{}-image\", name));\n-        let _ = fs::remove_dir_all(&image);\n+        let tarball = Tarball::new_targetless(builder, \"rust-src\");\n \n         // A lot of tools expect the rust-src component to be entirely in this directory, so if you\n         // change that (e.g. by adding another directory `lib/rustlib/src/foo` or\n@@ -1022,8 +819,7 @@ impl Step for Src {\n         //\n         // NOTE: if you update the paths here, you also should update the \"virtual\" path\n         // translation code in `imported_source_files` in `src/librustc_metadata/rmeta/decoder.rs`\n-        let dst_src = image.join(\"lib/rustlib/src/rust\");\n-        t!(fs::create_dir_all(&dst_src));\n+        let dst_src = tarball.image_dir().join(\"lib/rustlib/src/rust\");\n \n         let src_files = [\"Cargo.lock\"];\n         // This is the reduced set of paths which will become the rust-src component\n@@ -1043,28 +839,7 @@ impl Step for Src {\n             builder.copy(&builder.src.join(file), &dst_src.join(file));\n         }\n \n-        // Create source tarball in rust-installer format\n-        let mut cmd = rust_installer(builder);\n-        cmd.arg(\"generate\")\n-            .arg(\"--product-name=Rust\")\n-            .arg(\"--rel-manifest-dir=rustlib\")\n-            .arg(\"--success-message=Awesome-Source.\")\n-            .arg(\"--image-dir\")\n-            .arg(&image)\n-            .arg(\"--work-dir\")\n-            .arg(&tmpdir(builder))\n-            .arg(\"--output-dir\")\n-            .arg(&distdir(builder))\n-            .arg(format!(\"--package-name={}\", name))\n-            .arg(\"--component-name=rust-src\")\n-            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n-\n-        builder.info(\"Dist src\");\n-        let _time = timeit(builder);\n-        builder.run(&mut cmd);\n-\n-        builder.remove_dir(&image);\n-        distdir(builder).join(&format!(\"{}.tar.gz\", name))\n+        tarball.generate()\n     }\n }\n \n@@ -1088,11 +863,8 @@ impl Step for PlainSourceTarball {\n \n     /// Creates the plain source tarball\n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n-        // Make sure that the root folder of tarball has the correct name\n-        let plain_name = format!(\"{}-src\", pkgname(builder, \"rustc\"));\n-        let plain_dst_src = tmpdir(builder).join(&plain_name);\n-        let _ = fs::remove_dir_all(&plain_dst_src);\n-        t!(fs::create_dir_all(&plain_dst_src));\n+        let tarball = Tarball::new(builder, \"rustc\", \"src\");\n+        let plain_dst_src = tarball.image_dir();\n \n         // This is the set of root paths which will become part of the source package\n         let src_files = [\n@@ -1135,28 +907,7 @@ impl Step for PlainSourceTarball {\n             builder.run(&mut cmd);\n         }\n \n-        // Create plain source tarball\n-        let plain_name = format!(\"rustc-{}-src\", builder.rust_package_vers());\n-        let mut tarball = distdir(builder).join(&format!(\"{}.tar.gz\", plain_name));\n-        tarball.set_extension(\"\"); // strip .gz\n-        tarball.set_extension(\"\"); // strip .tar\n-        if let Some(dir) = tarball.parent() {\n-            builder.create_dir(&dir);\n-        }\n-        builder.info(\"running installer\");\n-        let mut cmd = rust_installer(builder);\n-        cmd.arg(\"tarball\")\n-            .arg(\"--input\")\n-            .arg(&plain_name)\n-            .arg(\"--output\")\n-            .arg(&tarball)\n-            .arg(\"--work-dir=.\")\n-            .current_dir(tmpdir(builder));\n-\n-        builder.info(\"Create plain source tarball\");\n-        let _time = timeit(builder);\n-        builder.run(&mut cmd);\n-        distdir(builder).join(&format!(\"{}.tar.gz\", plain_name))\n+        tarball.bare()\n     }\n }\n \n@@ -1212,72 +963,28 @@ impl Step for Cargo {\n         let compiler = self.compiler;\n         let target = self.target;\n \n+        let cargo = builder.ensure(tool::Cargo { compiler, target });\n         let src = builder.src.join(\"src/tools/cargo\");\n         let etc = src.join(\"src/etc\");\n-        let release_num = builder.release_num(\"cargo\");\n-        let name = pkgname(builder, \"cargo\");\n-        let version = builder.cargo_info.version(builder, &release_num);\n-\n-        let tmp = tmpdir(builder);\n-        let image = tmp.join(\"cargo-image\");\n-        drop(fs::remove_dir_all(&image));\n-        builder.create_dir(&image);\n \n         // Prepare the image directory\n-        builder.create_dir(&image.join(\"share/zsh/site-functions\"));\n-        builder.create_dir(&image.join(\"etc/bash_completion.d\"));\n-        let cargo = builder.ensure(tool::Cargo { compiler, target });\n-        builder.install(&cargo, &image.join(\"bin\"), 0o755);\n+        let mut tarball = Tarball::new(builder, \"cargo\", &target.triple);\n+        tarball.set_overlay(OverlayKind::Cargo);\n+\n+        tarball.add_file(&cargo, \"bin\", 0o755);\n+        tarball.add_file(etc.join(\"_cargo\"), \"share/zsh/site-functions\", 0o644);\n+        tarball.add_renamed_file(etc.join(\"cargo.bashcomp.sh\"), \"etc/bash_completion.d\", \"cargo\");\n+        tarball.add_dir(etc.join(\"man\"), \"share/man/man1\");\n+        tarball.add_legal_and_readme_to(\"share/doc/cargo\");\n+\n         for dirent in fs::read_dir(cargo.parent().unwrap()).expect(\"read_dir\") {\n             let dirent = dirent.expect(\"read dir entry\");\n             if dirent.file_name().to_str().expect(\"utf8\").starts_with(\"cargo-credential-\") {\n-                builder.install(&dirent.path(), &image.join(\"libexec\"), 0o755);\n+                tarball.add_file(&dirent.path(), \"libexec\", 0o755);\n             }\n         }\n-        for man in t!(etc.join(\"man\").read_dir()) {\n-            let man = t!(man);\n-            builder.install(&man.path(), &image.join(\"share/man/man1\"), 0o644);\n-        }\n-        builder.install(&etc.join(\"_cargo\"), &image.join(\"share/zsh/site-functions\"), 0o644);\n-        builder.copy(&etc.join(\"cargo.bashcomp.sh\"), &image.join(\"etc/bash_completion.d/cargo\"));\n-        let doc = image.join(\"share/doc/cargo\");\n-        builder.install(&src.join(\"README.md\"), &doc, 0o644);\n-        builder.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n-        builder.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n-        builder.install(&src.join(\"LICENSE-THIRD-PARTY\"), &doc, 0o644);\n-\n-        // Prepare the overlay\n-        let overlay = tmp.join(\"cargo-overlay\");\n-        drop(fs::remove_dir_all(&overlay));\n-        builder.create_dir(&overlay);\n-        builder.install(&src.join(\"README.md\"), &overlay, 0o644);\n-        builder.install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n-        builder.install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-        builder.install(&src.join(\"LICENSE-THIRD-PARTY\"), &overlay, 0o644);\n-        builder.create(&overlay.join(\"version\"), &version);\n-\n-        // Generate the installer tarball\n-        let mut cmd = rust_installer(builder);\n-        cmd.arg(\"generate\")\n-            .arg(\"--product-name=Rust\")\n-            .arg(\"--rel-manifest-dir=rustlib\")\n-            .arg(\"--success-message=Rust-is-ready-to-roll.\")\n-            .arg(\"--image-dir\")\n-            .arg(&image)\n-            .arg(\"--work-dir\")\n-            .arg(&tmpdir(builder))\n-            .arg(\"--output-dir\")\n-            .arg(&distdir(builder))\n-            .arg(\"--non-installed-overlay\")\n-            .arg(&overlay)\n-            .arg(format!(\"--package-name={}-{}\", name, target.triple))\n-            .arg(\"--component-name=cargo\")\n-            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n-\n-        builder.info(&format!(\"Dist cargo stage{} ({})\", compiler.stage, target));\n-        let _time = timeit(builder);\n-        builder.run(&mut cmd);\n-        distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target.triple))\n+\n+        tarball.generate()\n     }\n }\n \n@@ -1311,63 +1018,19 @@ impl Step for Rls {\n         let target = self.target;\n         assert!(builder.config.extended);\n \n-        let src = builder.src.join(\"src/tools/rls\");\n-        let release_num = builder.release_num(\"rls\");\n-        let name = pkgname(builder, \"rls\");\n-        let version = builder.rls_info.version(builder, &release_num);\n-\n-        let tmp = tmpdir(builder);\n-        let image = tmp.join(\"rls-image\");\n-        drop(fs::remove_dir_all(&image));\n-        t!(fs::create_dir_all(&image));\n-\n-        // Prepare the image directory\n-        // We expect RLS to build, because we've exited this step above if tool\n-        // state for RLS isn't testing.\n         let rls = builder\n             .ensure(tool::Rls { compiler, target, extra_features: Vec::new() })\n             .or_else(|| {\n                 missing_tool(\"RLS\", builder.build.config.missing_tools);\n                 None\n             })?;\n \n-        builder.install(&rls, &image.join(\"bin\"), 0o755);\n-        let doc = image.join(\"share/doc/rls\");\n-        builder.install(&src.join(\"README.md\"), &doc, 0o644);\n-        builder.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n-        builder.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n-\n-        // Prepare the overlay\n-        let overlay = tmp.join(\"rls-overlay\");\n-        drop(fs::remove_dir_all(&overlay));\n-        t!(fs::create_dir_all(&overlay));\n-        builder.install(&src.join(\"README.md\"), &overlay, 0o644);\n-        builder.install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n-        builder.install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-        builder.create(&overlay.join(\"version\"), &version);\n-\n-        // Generate the installer tarball\n-        let mut cmd = rust_installer(builder);\n-        cmd.arg(\"generate\")\n-            .arg(\"--product-name=Rust\")\n-            .arg(\"--rel-manifest-dir=rustlib\")\n-            .arg(\"--success-message=RLS-ready-to-serve.\")\n-            .arg(\"--image-dir\")\n-            .arg(&image)\n-            .arg(\"--work-dir\")\n-            .arg(&tmpdir(builder))\n-            .arg(\"--output-dir\")\n-            .arg(&distdir(builder))\n-            .arg(\"--non-installed-overlay\")\n-            .arg(&overlay)\n-            .arg(format!(\"--package-name={}-{}\", name, target.triple))\n-            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n-            .arg(\"--component-name=rls-preview\");\n-\n-        builder.info(&format!(\"Dist RLS stage{} ({})\", compiler.stage, target.triple));\n-        let _time = timeit(builder);\n-        builder.run(&mut cmd);\n-        Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target.triple)))\n+        let mut tarball = Tarball::new(builder, \"rls\", &target.triple);\n+        tarball.set_overlay(OverlayKind::RLS);\n+        tarball.is_preview(true);\n+        tarball.add_file(rls, \"bin\", 0o755);\n+        tarball.add_legal_and_readme_to(\"share/doc/rls\");\n+        Some(tarball.generate())\n     }\n }\n \n@@ -1407,60 +1070,16 @@ impl Step for RustAnalyzer {\n             return None;\n         }\n \n-        let src = builder.src.join(\"src/tools/rust-analyzer\");\n-        let release_num = builder.release_num(\"rust-analyzer/crates/rust-analyzer\");\n-        let name = pkgname(builder, \"rust-analyzer\");\n-        let version = builder.rust_analyzer_info.version(builder, &release_num);\n-\n-        let tmp = tmpdir(builder);\n-        let image = tmp.join(\"rust-analyzer-image\");\n-        drop(fs::remove_dir_all(&image));\n-        builder.create_dir(&image);\n-\n-        // Prepare the image directory\n-        // We expect rust-analyer to always build, as it doesn't depend on rustc internals\n-        // and doesn't have associated toolstate.\n         let rust_analyzer = builder\n             .ensure(tool::RustAnalyzer { compiler, target, extra_features: Vec::new() })\n             .expect(\"rust-analyzer always builds\");\n \n-        builder.install(&rust_analyzer, &image.join(\"bin\"), 0o755);\n-        let doc = image.join(\"share/doc/rust-analyzer\");\n-        builder.install(&src.join(\"README.md\"), &doc, 0o644);\n-        builder.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n-        builder.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n-\n-        // Prepare the overlay\n-        let overlay = tmp.join(\"rust-analyzer-overlay\");\n-        drop(fs::remove_dir_all(&overlay));\n-        t!(fs::create_dir_all(&overlay));\n-        builder.install(&src.join(\"README.md\"), &overlay, 0o644);\n-        builder.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n-        builder.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n-        builder.create(&overlay.join(\"version\"), &version);\n-\n-        // Generate the installer tarball\n-        let mut cmd = rust_installer(builder);\n-        cmd.arg(\"generate\")\n-            .arg(\"--product-name=Rust\")\n-            .arg(\"--rel-manifest-dir=rustlib\")\n-            .arg(\"--success-message=rust-analyzer-ready-to-serve.\")\n-            .arg(\"--image-dir\")\n-            .arg(&image)\n-            .arg(\"--work-dir\")\n-            .arg(&tmpdir(builder))\n-            .arg(\"--output-dir\")\n-            .arg(&distdir(builder))\n-            .arg(\"--non-installed-overlay\")\n-            .arg(&overlay)\n-            .arg(format!(\"--package-name={}-{}\", name, target.triple))\n-            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n-            .arg(\"--component-name=rust-analyzer-preview\");\n-\n-        builder.info(&format!(\"Dist rust-analyzer stage{} ({})\", compiler.stage, target));\n-        let _time = timeit(builder);\n-        builder.run(&mut cmd);\n-        Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target.triple)))\n+        let mut tarball = Tarball::new(builder, \"rust-analyzer\", &target.triple);\n+        tarball.set_overlay(OverlayKind::RustAnalyzer);\n+        tarball.is_preview(true);\n+        tarball.add_file(rust_analyzer, \"bin\", 0o755);\n+        tarball.add_legal_and_readme_to(\"share/doc/rust-analyzer\");\n+        Some(tarball.generate())\n     }\n }\n \n@@ -1494,16 +1113,6 @@ impl Step for Clippy {\n         let target = self.target;\n         assert!(builder.config.extended);\n \n-        let src = builder.src.join(\"src/tools/clippy\");\n-        let release_num = builder.release_num(\"clippy\");\n-        let name = pkgname(builder, \"clippy\");\n-        let version = builder.clippy_info.version(builder, &release_num);\n-\n-        let tmp = tmpdir(builder);\n-        let image = tmp.join(\"clippy-image\");\n-        drop(fs::remove_dir_all(&image));\n-        builder.create_dir(&image);\n-\n         // Prepare the image directory\n         // We expect clippy to build, because we've exited this step above if tool\n         // state for clippy isn't testing.\n@@ -1514,44 +1123,13 @@ impl Step for Clippy {\n             .ensure(tool::CargoClippy { compiler, target, extra_features: Vec::new() })\n             .expect(\"clippy expected to build - essential tool\");\n \n-        builder.install(&clippy, &image.join(\"bin\"), 0o755);\n-        builder.install(&cargoclippy, &image.join(\"bin\"), 0o755);\n-        let doc = image.join(\"share/doc/clippy\");\n-        builder.install(&src.join(\"README.md\"), &doc, 0o644);\n-        builder.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n-        builder.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n-\n-        // Prepare the overlay\n-        let overlay = tmp.join(\"clippy-overlay\");\n-        drop(fs::remove_dir_all(&overlay));\n-        t!(fs::create_dir_all(&overlay));\n-        builder.install(&src.join(\"README.md\"), &overlay, 0o644);\n-        builder.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n-        builder.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n-        builder.create(&overlay.join(\"version\"), &version);\n-\n-        // Generate the installer tarball\n-        let mut cmd = rust_installer(builder);\n-        cmd.arg(\"generate\")\n-            .arg(\"--product-name=Rust\")\n-            .arg(\"--rel-manifest-dir=rustlib\")\n-            .arg(\"--success-message=clippy-ready-to-serve.\")\n-            .arg(\"--image-dir\")\n-            .arg(&image)\n-            .arg(\"--work-dir\")\n-            .arg(&tmpdir(builder))\n-            .arg(\"--output-dir\")\n-            .arg(&distdir(builder))\n-            .arg(\"--non-installed-overlay\")\n-            .arg(&overlay)\n-            .arg(format!(\"--package-name={}-{}\", name, target.triple))\n-            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n-            .arg(\"--component-name=clippy-preview\");\n-\n-        builder.info(&format!(\"Dist clippy stage{} ({})\", compiler.stage, target));\n-        let _time = timeit(builder);\n-        builder.run(&mut cmd);\n-        distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target.triple))\n+        let mut tarball = Tarball::new(builder, \"clippy\", &target.triple);\n+        tarball.set_overlay(OverlayKind::Clippy);\n+        tarball.is_preview(true);\n+        tarball.add_file(clippy, \"bin\", 0o755);\n+        tarball.add_file(cargoclippy, \"bin\", 0o755);\n+        tarball.add_legal_and_readme_to(\"share/doc/clippy\");\n+        tarball.generate()\n     }\n }\n \n@@ -1585,19 +1163,6 @@ impl Step for Miri {\n         let target = self.target;\n         assert!(builder.config.extended);\n \n-        let src = builder.src.join(\"src/tools/miri\");\n-        let release_num = builder.release_num(\"miri\");\n-        let name = pkgname(builder, \"miri\");\n-        let version = builder.miri_info.version(builder, &release_num);\n-\n-        let tmp = tmpdir(builder);\n-        let image = tmp.join(\"miri-image\");\n-        drop(fs::remove_dir_all(&image));\n-        builder.create_dir(&image);\n-\n-        // Prepare the image directory\n-        // We expect miri to build, because we've exited this step above if tool\n-        // state for miri isn't testing.\n         let miri = builder\n             .ensure(tool::Miri { compiler, target, extra_features: Vec::new() })\n             .or_else(|| {\n@@ -1611,44 +1176,13 @@ impl Step for Miri {\n                 None\n             })?;\n \n-        builder.install(&miri, &image.join(\"bin\"), 0o755);\n-        builder.install(&cargomiri, &image.join(\"bin\"), 0o755);\n-        let doc = image.join(\"share/doc/miri\");\n-        builder.install(&src.join(\"README.md\"), &doc, 0o644);\n-        builder.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n-        builder.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n-\n-        // Prepare the overlay\n-        let overlay = tmp.join(\"miri-overlay\");\n-        drop(fs::remove_dir_all(&overlay));\n-        t!(fs::create_dir_all(&overlay));\n-        builder.install(&src.join(\"README.md\"), &overlay, 0o644);\n-        builder.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n-        builder.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n-        builder.create(&overlay.join(\"version\"), &version);\n-\n-        // Generate the installer tarball\n-        let mut cmd = rust_installer(builder);\n-        cmd.arg(\"generate\")\n-            .arg(\"--product-name=Rust\")\n-            .arg(\"--rel-manifest-dir=rustlib\")\n-            .arg(\"--success-message=miri-ready-to-serve.\")\n-            .arg(\"--image-dir\")\n-            .arg(&image)\n-            .arg(\"--work-dir\")\n-            .arg(&tmpdir(builder))\n-            .arg(\"--output-dir\")\n-            .arg(&distdir(builder))\n-            .arg(\"--non-installed-overlay\")\n-            .arg(&overlay)\n-            .arg(format!(\"--package-name={}-{}\", name, target.triple))\n-            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n-            .arg(\"--component-name=miri-preview\");\n-\n-        builder.info(&format!(\"Dist miri stage{} ({})\", compiler.stage, target));\n-        let _time = timeit(builder);\n-        builder.run(&mut cmd);\n-        Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target.triple)))\n+        let mut tarball = Tarball::new(builder, \"miri\", &target.triple);\n+        tarball.set_overlay(OverlayKind::Miri);\n+        tarball.is_preview(true);\n+        tarball.add_file(miri, \"bin\", 0o755);\n+        tarball.add_file(cargomiri, \"bin\", 0o755);\n+        tarball.add_legal_and_readme_to(\"share/doc/miri\");\n+        Some(tarball.generate())\n     }\n }\n \n@@ -1681,17 +1215,6 @@ impl Step for Rustfmt {\n         let compiler = self.compiler;\n         let target = self.target;\n \n-        let src = builder.src.join(\"src/tools/rustfmt\");\n-        let release_num = builder.release_num(\"rustfmt\");\n-        let name = pkgname(builder, \"rustfmt\");\n-        let version = builder.rustfmt_info.version(builder, &release_num);\n-\n-        let tmp = tmpdir(builder);\n-        let image = tmp.join(\"rustfmt-image\");\n-        drop(fs::remove_dir_all(&image));\n-        builder.create_dir(&image);\n-\n-        // Prepare the image directory\n         let rustfmt = builder\n             .ensure(tool::Rustfmt { compiler, target, extra_features: Vec::new() })\n             .or_else(|| {\n@@ -1705,44 +1228,13 @@ impl Step for Rustfmt {\n                 None\n             })?;\n \n-        builder.install(&rustfmt, &image.join(\"bin\"), 0o755);\n-        builder.install(&cargofmt, &image.join(\"bin\"), 0o755);\n-        let doc = image.join(\"share/doc/rustfmt\");\n-        builder.install(&src.join(\"README.md\"), &doc, 0o644);\n-        builder.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n-        builder.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n-\n-        // Prepare the overlay\n-        let overlay = tmp.join(\"rustfmt-overlay\");\n-        drop(fs::remove_dir_all(&overlay));\n-        builder.create_dir(&overlay);\n-        builder.install(&src.join(\"README.md\"), &overlay, 0o644);\n-        builder.install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n-        builder.install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-        builder.create(&overlay.join(\"version\"), &version);\n-\n-        // Generate the installer tarball\n-        let mut cmd = rust_installer(builder);\n-        cmd.arg(\"generate\")\n-            .arg(\"--product-name=Rust\")\n-            .arg(\"--rel-manifest-dir=rustlib\")\n-            .arg(\"--success-message=rustfmt-ready-to-fmt.\")\n-            .arg(\"--image-dir\")\n-            .arg(&image)\n-            .arg(\"--work-dir\")\n-            .arg(&tmpdir(builder))\n-            .arg(\"--output-dir\")\n-            .arg(&distdir(builder))\n-            .arg(\"--non-installed-overlay\")\n-            .arg(&overlay)\n-            .arg(format!(\"--package-name={}-{}\", name, target.triple))\n-            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n-            .arg(\"--component-name=rustfmt-preview\");\n-\n-        builder.info(&format!(\"Dist Rustfmt stage{} ({})\", compiler.stage, target));\n-        let _time = timeit(builder);\n-        builder.run(&mut cmd);\n-        Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target.triple)))\n+        let mut tarball = Tarball::new(builder, \"rustfmt\", &target.triple);\n+        tarball.set_overlay(OverlayKind::Rustfmt);\n+        tarball.is_preview(true);\n+        tarball.add_file(rustfmt, \"bin\", 0o755);\n+        tarball.add_file(cargofmt, \"bin\", 0o755);\n+        tarball.add_legal_and_readme_to(\"share/doc/rustfmt\");\n+        Some(tarball.generate())\n     }\n }\n \n@@ -1791,24 +1283,14 @@ impl Step for Extended {\n         let analysis_installer = builder.ensure(Analysis { compiler, target });\n \n         let docs_installer = builder.ensure(Docs { host: target });\n-        let std_installer =\n-            builder.ensure(Std { compiler: builder.compiler(stage, target), target });\n+        let std_installer = builder.ensure(Std { compiler, target });\n \n-        let tmp = tmpdir(builder);\n-        let overlay = tmp.join(\"extended-overlay\");\n         let etc = builder.src.join(\"src/etc/installer\");\n-        let work = tmp.join(\"work\");\n-\n-        let _ = fs::remove_dir_all(&overlay);\n-        builder.install(&builder.src.join(\"COPYRIGHT\"), &overlay, 0o644);\n-        builder.install(&builder.src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-        builder.install(&builder.src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n-        let version = builder.rust_version();\n-        builder.create(&overlay.join(\"version\"), &version);\n-        if let Some(sha) = builder.rust_sha() {\n-            builder.create(&overlay.join(\"git-commit-hash\"), &sha);\n+\n+        // Avoid producing tarballs during a dry run.\n+        if builder.config.dry_run {\n+            return;\n         }\n-        builder.install(&etc.join(\"README.md\"), &overlay, 0o644);\n \n         // When rust-std package split from rustc, we needed to ensure that during\n         // upgrades rustc was upgraded before rust-std. To avoid rustc clobbering\n@@ -1823,39 +1305,22 @@ impl Step for Extended {\n         tarballs.extend(miri_installer.clone());\n         tarballs.extend(rustfmt_installer.clone());\n         tarballs.extend(llvm_tools_installer);\n-        tarballs.push(analysis_installer);\n-        tarballs.push(std_installer);\n-        if builder.config.docs {\n+        if let Some(analysis_installer) = analysis_installer {\n+            tarballs.push(analysis_installer);\n+        }\n+        tarballs.push(std_installer.expect(\"missing std\"));\n+        if let Some(docs_installer) = docs_installer {\n             tarballs.push(docs_installer);\n         }\n         if target.contains(\"pc-windows-gnu\") {\n             tarballs.push(mingw_installer.unwrap());\n         }\n-        let mut input_tarballs = tarballs[0].as_os_str().to_owned();\n-        for tarball in &tarballs[1..] {\n-            input_tarballs.push(\",\");\n-            input_tarballs.push(tarball);\n-        }\n \n-        builder.info(\"building combined installer\");\n-        let mut cmd = rust_installer(builder);\n-        cmd.arg(\"combine\")\n-            .arg(\"--product-name=Rust\")\n-            .arg(\"--rel-manifest-dir=rustlib\")\n-            .arg(\"--success-message=Rust-is-ready-to-roll.\")\n-            .arg(\"--work-dir\")\n-            .arg(&work)\n-            .arg(\"--output-dir\")\n-            .arg(&distdir(builder))\n-            .arg(format!(\"--package-name={}-{}\", pkgname(builder, \"rust\"), target.triple))\n-            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n-            .arg(\"--input-tarballs\")\n-            .arg(input_tarballs)\n-            .arg(\"--non-installed-overlay\")\n-            .arg(&overlay);\n-        let time = timeit(&builder);\n-        builder.run(&mut cmd);\n-        drop(time);\n+        let mut tarball = Tarball::new(builder, \"rust\", &target.triple);\n+        let work = tarball.persist_work_dir();\n+        tarball.combine(&tarballs);\n+\n+        let tmp = tmpdir(builder).join(\"combined-tarball\");\n \n         let mut license = String::new();\n         license += &builder.read(&builder.src.join(\"COPYRIGHT\"));\n@@ -2428,58 +1893,25 @@ impl Step for LlvmTools {\n             }\n         }\n \n-        builder.info(&format!(\"Dist LlvmTools ({})\", target));\n-        let _time = timeit(builder);\n-        let src = builder.src.join(\"src/llvm-project/llvm\");\n-        let name = pkgname(builder, \"llvm-tools\");\n-\n-        let tmp = tmpdir(builder);\n-        let image = tmp.join(\"llvm-tools-image\");\n-        drop(fs::remove_dir_all(&image));\n+        let mut tarball = Tarball::new(builder, \"llvm-tools\", &target.triple);\n+        tarball.set_overlay(OverlayKind::LLVM);\n+        tarball.is_preview(true);\n \n         // Prepare the image directory\n         let src_bindir = builder.llvm_out(target).join(\"bin\");\n-        let dst_bindir = image.join(\"lib/rustlib\").join(&*target.triple).join(\"bin\");\n-        t!(fs::create_dir_all(&dst_bindir));\n+        let dst_bindir = format!(\"lib/rustlib/{}/bin\", target.triple);\n         for tool in LLVM_TOOLS {\n             let exe = src_bindir.join(exe(tool, target));\n-            builder.install(&exe, &dst_bindir, 0o755);\n+            tarball.add_file(&exe, &dst_bindir, 0o755);\n         }\n \n         // Copy libLLVM.so to the target lib dir as well, so the RPATH like\n         // `$ORIGIN/../lib` can find it. It may also be used as a dependency\n         // of `rustc-dev` to support the inherited `-lLLVM` when using the\n         // compiler libraries.\n-        maybe_install_llvm_target(builder, target, &image);\n-\n-        // Prepare the overlay\n-        let overlay = tmp.join(\"llvm-tools-overlay\");\n-        drop(fs::remove_dir_all(&overlay));\n-        builder.create_dir(&overlay);\n-        builder.install(&src.join(\"README.txt\"), &overlay, 0o644);\n-        builder.install(&src.join(\"LICENSE.TXT\"), &overlay, 0o644);\n-        builder.create(&overlay.join(\"version\"), &builder.llvm_tools_vers());\n-\n-        // Generate the installer tarball\n-        let mut cmd = rust_installer(builder);\n-        cmd.arg(\"generate\")\n-            .arg(\"--product-name=Rust\")\n-            .arg(\"--rel-manifest-dir=rustlib\")\n-            .arg(\"--success-message=llvm-tools-installed.\")\n-            .arg(\"--image-dir\")\n-            .arg(&image)\n-            .arg(\"--work-dir\")\n-            .arg(&tmpdir(builder))\n-            .arg(\"--output-dir\")\n-            .arg(&distdir(builder))\n-            .arg(\"--non-installed-overlay\")\n-            .arg(&overlay)\n-            .arg(format!(\"--package-name={}-{}\", name, target.triple))\n-            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n-            .arg(\"--component-name=llvm-tools-preview\");\n-\n-        builder.run(&mut cmd);\n-        Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target.triple)))\n+        maybe_install_llvm_target(builder, target, tarball.image_dir());\n+\n+        Some(tarball.generate())\n     }\n }\n \n@@ -2515,70 +1947,35 @@ impl Step for RustDev {\n             }\n         }\n \n-        builder.info(&format!(\"Dist RustDev ({})\", target));\n-        let _time = timeit(builder);\n-        let src = builder.src.join(\"src/llvm-project/llvm\");\n-        let name = pkgname(builder, \"rust-dev\");\n-\n-        let tmp = tmpdir(builder);\n-        let image = tmp.join(\"rust-dev-image\");\n-        drop(fs::remove_dir_all(&image));\n-\n-        // Prepare the image directory\n-        let dst_bindir = image.join(\"bin\");\n-        t!(fs::create_dir_all(&dst_bindir));\n+        let mut tarball = Tarball::new(builder, \"rust-dev\", &target.triple);\n+        tarball.set_overlay(OverlayKind::LLVM);\n \n         let src_bindir = builder.llvm_out(target).join(\"bin\");\n-        let install_bin =\n-            |name| builder.install(&src_bindir.join(exe(name, target)), &dst_bindir, 0o755);\n-        install_bin(\"llvm-config\");\n-        install_bin(\"llvm-ar\");\n-        install_bin(\"llvm-objdump\");\n-        install_bin(\"llvm-profdata\");\n-        install_bin(\"llvm-bcanalyzer\");\n-        install_bin(\"llvm-cov\");\n-        install_bin(\"llvm-dwp\");\n-        builder.install(&builder.llvm_filecheck(target), &dst_bindir, 0o755);\n+        for bin in &[\n+            \"llvm-config\",\n+            \"llvm-ar\",\n+            \"llvm-objdump\",\n+            \"llvm-profdata\",\n+            \"llvm-bcanalyzer\",\n+            \"llvm-cov\",\n+            \"llvm-dwp\",\n+        ] {\n+            tarball.add_file(src_bindir.join(exe(bin, target)), \"bin\", 0o755);\n+        }\n+        tarball.add_file(&builder.llvm_filecheck(target), \"bin\", 0o755);\n \n         // Copy the include directory as well; needed mostly to build\n         // librustc_llvm properly (e.g., llvm-config.h is in here). But also\n         // just broadly useful to be able to link against the bundled LLVM.\n-        builder.cp_r(&builder.llvm_out(target).join(\"include\"), &image.join(\"include\"));\n+        tarball.add_dir(&builder.llvm_out(target).join(\"include\"), \"include\");\n \n         // Copy libLLVM.so to the target lib dir as well, so the RPATH like\n         // `$ORIGIN/../lib` can find it. It may also be used as a dependency\n         // of `rustc-dev` to support the inherited `-lLLVM` when using the\n         // compiler libraries.\n-        maybe_install_llvm(builder, target, &image.join(\"lib\"));\n-\n-        // Prepare the overlay\n-        let overlay = tmp.join(\"rust-dev-overlay\");\n-        drop(fs::remove_dir_all(&overlay));\n-        builder.create_dir(&overlay);\n-        builder.install(&src.join(\"README.txt\"), &overlay, 0o644);\n-        builder.install(&src.join(\"LICENSE.TXT\"), &overlay, 0o644);\n-        builder.create(&overlay.join(\"version\"), &builder.rust_version());\n-\n-        // Generate the installer tarball\n-        let mut cmd = rust_installer(builder);\n-        cmd.arg(\"generate\")\n-            .arg(\"--product-name=Rust\")\n-            .arg(\"--rel-manifest-dir=rustlib\")\n-            .arg(\"--success-message=rust-dev-installed.\")\n-            .arg(\"--image-dir\")\n-            .arg(&image)\n-            .arg(\"--work-dir\")\n-            .arg(&tmpdir(builder))\n-            .arg(\"--output-dir\")\n-            .arg(&distdir(builder))\n-            .arg(\"--non-installed-overlay\")\n-            .arg(&overlay)\n-            .arg(format!(\"--package-name={}-{}\", name, target.triple))\n-            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n-            .arg(\"--component-name=rust-dev\");\n-\n-        builder.run(&mut cmd);\n-        Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target.triple)))\n+        maybe_install_llvm(builder, target, &tarball.image_dir().join(\"lib\"));\n+\n+        Some(tarball.generate())\n     }\n }\n \n@@ -2607,45 +2004,9 @@ impl Step for BuildManifest {\n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n         let build_manifest = builder.tool_exe(Tool::BuildManifest);\n \n-        let name = pkgname(builder, \"build-manifest\");\n-        let tmp = tmpdir(builder);\n-\n-        // Prepare the image.\n-        let image = tmp.join(\"build-manifest-image\");\n-        let image_bin = image.join(\"bin\");\n-        let _ = fs::remove_dir_all(&image);\n-        t!(fs::create_dir_all(&image_bin));\n-        builder.install(&build_manifest, &image_bin, 0o755);\n-\n-        // Prepare the overlay.\n-        let overlay = tmp.join(\"build-manifest-overlay\");\n-        let _ = fs::remove_dir_all(&overlay);\n-        builder.create_dir(&overlay);\n-        builder.create(&overlay.join(\"version\"), &builder.rust_version());\n-        for file in &[\"COPYRIGHT\", \"LICENSE-APACHE\", \"LICENSE-MIT\", \"README.md\"] {\n-            builder.install(&builder.src.join(file), &overlay, 0o644);\n-        }\n-\n-        // Create the final tarball.\n-        let mut cmd = rust_installer(builder);\n-        cmd.arg(\"generate\")\n-            .arg(\"--product-name=Rust\")\n-            .arg(\"--rel-manifest-dir=rustlib\")\n-            .arg(\"--success-message=build-manifest installed.\")\n-            .arg(\"--image-dir\")\n-            .arg(&image)\n-            .arg(\"--work-dir\")\n-            .arg(&tmpdir(builder))\n-            .arg(\"--output-dir\")\n-            .arg(&distdir(builder))\n-            .arg(\"--non-installed-overlay\")\n-            .arg(&overlay)\n-            .arg(format!(\"--package-name={}-{}\", name, self.target.triple))\n-            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n-            .arg(\"--component-name=build-manifest\");\n-\n-        builder.run(&mut cmd);\n-        distdir(builder).join(format!(\"{}-{}.tar.gz\", name, self.target.triple))\n+        let tarball = Tarball::new(builder, \"build-manifest\", &self.target.triple);\n+        tarball.add_file(&build_manifest, \"bin\", 0o755);\n+        tarball.generate()\n     }\n }\n \n@@ -2673,47 +2034,10 @@ impl Step for ReproducibleArtifacts {\n     }\n \n     fn run(self, builder: &Builder<'_>) -> Self::Output {\n-        let name = pkgname(builder, \"reproducible-artifacts\");\n-        let tmp = tmpdir(builder);\n-\n-        // Prepare the image.\n-        let image = tmp.join(\"reproducible-artifacts-image\");\n-        let _ = fs::remove_dir_all(&image);\n-\n-        if let Some(path) = &builder.config.rust_profile_use {\n-            builder.install(std::path::Path::new(path), &image, 0o644);\n-        } else {\n-            return None;\n-        }\n-\n-        // Prepare the overlay.\n-        let overlay = tmp.join(\"reproducible-artifacts-overlay\");\n-        let _ = fs::remove_dir_all(&overlay);\n-        builder.create_dir(&overlay);\n-        builder.create(&overlay.join(\"version\"), &builder.rust_version());\n-        for file in &[\"COPYRIGHT\", \"LICENSE-APACHE\", \"LICENSE-MIT\", \"README.md\"] {\n-            builder.install(&builder.src.join(file), &overlay, 0o644);\n-        }\n+        let path = builder.config.rust_profile_use.as_ref()?;\n \n-        // Create the final tarball.\n-        let mut cmd = rust_installer(builder);\n-        cmd.arg(\"generate\")\n-            .arg(\"--product-name=Rust\")\n-            .arg(\"--rel-manifest-dir=rustlib\")\n-            .arg(\"--success-message=reproducible-artifacts installed.\")\n-            .arg(\"--image-dir\")\n-            .arg(&image)\n-            .arg(\"--work-dir\")\n-            .arg(&tmpdir(builder))\n-            .arg(\"--output-dir\")\n-            .arg(&distdir(builder))\n-            .arg(\"--non-installed-overlay\")\n-            .arg(&overlay)\n-            .arg(format!(\"--package-name={}-{}\", name, self.target.triple))\n-            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n-            .arg(\"--component-name=reproducible-artifacts\");\n-\n-        builder.run(&mut cmd);\n-        Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, self.target.triple)))\n+        let tarball = Tarball::new(builder, \"reproducible-artifacts\", &self.target.triple);\n+        tarball.add_file(path, \".\", 0o644);\n+        Some(tarball.generate())\n     }\n }"}, {"sha": "a47ddfbcc1f180c13deeb18bef9c449efd1d5dad", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f9c43cf98cfe1c369045399929cb098155b8374/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f9c43cf98cfe1c369045399929cb098155b8374/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=7f9c43cf98cfe1c369045399929cb098155b8374", "patch": "@@ -142,6 +142,7 @@ mod native;\n mod run;\n mod sanity;\n mod setup;\n+mod tarball;\n mod test;\n mod tool;\n mod toolstate;\n@@ -1068,10 +1069,6 @@ impl Build {\n         self.package_vers(&self.version)\n     }\n \n-    fn llvm_tools_vers(&self) -> String {\n-        self.rust_version()\n-    }\n-\n     fn llvm_link_tools_dynamically(&self, target: TargetSelection) -> bool {\n         target.contains(\"linux-gnu\") || target.contains(\"apple-darwin\")\n     }"}, {"sha": "5d73a655427b20fa3049080bf7339eb488fb6c0b", "filename": "src/bootstrap/tarball.rs", "status": "added", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/7f9c43cf98cfe1c369045399929cb098155b8374/src%2Fbootstrap%2Ftarball.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f9c43cf98cfe1c369045399929cb098155b8374/src%2Fbootstrap%2Ftarball.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftarball.rs?ref=7f9c43cf98cfe1c369045399929cb098155b8374", "patch": "@@ -0,0 +1,298 @@\n+use std::{\n+    path::{Path, PathBuf},\n+    process::Command,\n+};\n+\n+use build_helper::t;\n+\n+use crate::builder::Builder;\n+\n+#[derive(Copy, Clone)]\n+pub(crate) enum OverlayKind {\n+    Rust,\n+    LLVM,\n+    Cargo,\n+    Clippy,\n+    Miri,\n+    Rustfmt,\n+    RLS,\n+    RustAnalyzer,\n+}\n+\n+impl OverlayKind {\n+    fn legal_and_readme(&self) -> &[&str] {\n+        match self {\n+            OverlayKind::Rust => &[\"COPYRIGHT\", \"LICENSE-APACHE\", \"LICENSE-MIT\", \"README.md\"],\n+            OverlayKind::LLVM => {\n+                &[\"src/llvm-project/llvm/LICENSE.TXT\", \"src/llvm-project/llvm/README.txt\"]\n+            }\n+            OverlayKind::Cargo => &[\n+                \"src/tools/cargo/README.md\",\n+                \"src/tools/cargo/LICENSE-MIT\",\n+                \"src/tools/cargo/LICENSE-APACHE\",\n+                \"src/tools/cargo/LICENSE-THIRD-PARTY\",\n+            ],\n+            OverlayKind::Clippy => &[\n+                \"src/tools/clippy/README.md\",\n+                \"src/tools/clippy/LICENSE-APACHE\",\n+                \"src/tools/clippy/LICENSE-MIT\",\n+            ],\n+            OverlayKind::Miri => &[\n+                \"src/tools/miri/README.md\",\n+                \"src/tools/miri/LICENSE-APACHE\",\n+                \"src/tools/miri/LICENSE-MIT\",\n+            ],\n+            OverlayKind::Rustfmt => &[\n+                \"src/tools/rustfmt/README.md\",\n+                \"src/tools/rustfmt/LICENSE-APACHE\",\n+                \"src/tools/rustfmt/LICENSE-MIT\",\n+            ],\n+            OverlayKind::RLS => &[\n+                \"src/tools/rls/README.md\",\n+                \"src/tools/rls/LICENSE-APACHE\",\n+                \"src/tools/rls/LICENSE-MIT\",\n+            ],\n+            OverlayKind::RustAnalyzer => &[\n+                \"src/tools/rust-analyzer/README.md\",\n+                \"src/tools/rust-analyzer/LICENSE-APACHE\",\n+                \"src/tools/rust-analyzer/LICENSE-MIT\",\n+            ],\n+        }\n+    }\n+\n+    fn version(&self, builder: &Builder<'_>) -> String {\n+        match self {\n+            OverlayKind::Rust => builder.rust_version(),\n+            OverlayKind::LLVM => builder.rust_version(),\n+            OverlayKind::Cargo => {\n+                builder.cargo_info.version(builder, &builder.release_num(\"cargo\"))\n+            }\n+            OverlayKind::Clippy => {\n+                builder.clippy_info.version(builder, &builder.release_num(\"clippy\"))\n+            }\n+            OverlayKind::Miri => builder.miri_info.version(builder, &builder.release_num(\"miri\")),\n+            OverlayKind::Rustfmt => {\n+                builder.rustfmt_info.version(builder, &builder.release_num(\"rustfmt\"))\n+            }\n+            OverlayKind::RLS => builder.rls_info.version(builder, &builder.release_num(\"rls\")),\n+            OverlayKind::RustAnalyzer => builder\n+                .rust_analyzer_info\n+                .version(builder, &builder.release_num(\"rust-analyzer/crates/rust-analyzer\")),\n+        }\n+    }\n+}\n+\n+pub(crate) struct Tarball<'a> {\n+    builder: &'a Builder<'a>,\n+\n+    pkgname: String,\n+    component: String,\n+    target: Option<String>,\n+    product_name: String,\n+    overlay: OverlayKind,\n+\n+    temp_dir: PathBuf,\n+    image_dir: PathBuf,\n+    overlay_dir: PathBuf,\n+\n+    include_target_in_component_name: bool,\n+    is_preview: bool,\n+    delete_temp_dir: bool,\n+}\n+\n+impl<'a> Tarball<'a> {\n+    pub(crate) fn new(builder: &'a Builder<'a>, component: &str, target: &str) -> Self {\n+        Self::new_inner(builder, component, Some(target.into()))\n+    }\n+\n+    pub(crate) fn new_targetless(builder: &'a Builder<'a>, component: &str) -> Self {\n+        Self::new_inner(builder, component, None)\n+    }\n+\n+    fn new_inner(builder: &'a Builder<'a>, component: &str, target: Option<String>) -> Self {\n+        let pkgname = crate::dist::pkgname(builder, component);\n+\n+        let mut temp_dir = builder.out.join(\"tmp\").join(\"tarball\");\n+        if let Some(target) = &target {\n+            temp_dir = temp_dir.join(target);\n+        }\n+        let _ = std::fs::remove_dir_all(&temp_dir);\n+\n+        let image_dir = temp_dir.join(\"image\");\n+        let overlay_dir = temp_dir.join(\"overlay\");\n+\n+        Self {\n+            builder,\n+\n+            pkgname,\n+            component: component.into(),\n+            target,\n+            product_name: \"Rust\".into(),\n+            overlay: OverlayKind::Rust,\n+\n+            temp_dir,\n+            image_dir,\n+            overlay_dir,\n+\n+            include_target_in_component_name: false,\n+            is_preview: false,\n+            delete_temp_dir: true,\n+        }\n+    }\n+\n+    pub(crate) fn set_overlay(&mut self, overlay: OverlayKind) {\n+        self.overlay = overlay;\n+    }\n+\n+    pub(crate) fn set_product_name(&mut self, name: &str) {\n+        self.product_name = name.into();\n+    }\n+\n+    pub(crate) fn include_target_in_component_name(&mut self, include: bool) {\n+        self.include_target_in_component_name = include;\n+    }\n+\n+    pub(crate) fn is_preview(&mut self, is: bool) {\n+        self.is_preview = is;\n+    }\n+\n+    pub(crate) fn image_dir(&self) -> &Path {\n+        t!(std::fs::create_dir_all(&self.image_dir));\n+        &self.image_dir\n+    }\n+\n+    pub(crate) fn add_file(&self, src: impl AsRef<Path>, destdir: impl AsRef<Path>, perms: u32) {\n+        // create_dir_all fails to create `foo/bar/.`, so when the destination is \".\" this simply\n+        // uses the base directory as the destination directory.\n+        let destdir = if destdir.as_ref() == Path::new(\".\") {\n+            self.image_dir.clone()\n+        } else {\n+            self.image_dir.join(destdir.as_ref())\n+        };\n+\n+        t!(std::fs::create_dir_all(&destdir));\n+        self.builder.install(src.as_ref(), &destdir, perms);\n+    }\n+\n+    pub(crate) fn add_renamed_file(\n+        &self,\n+        src: impl AsRef<Path>,\n+        destdir: impl AsRef<Path>,\n+        new_name: &str,\n+    ) {\n+        let destdir = self.image_dir.join(destdir.as_ref());\n+        t!(std::fs::create_dir_all(&destdir));\n+        self.builder.copy(src.as_ref(), &destdir.join(new_name));\n+    }\n+\n+    pub(crate) fn add_legal_and_readme_to(&self, destdir: impl AsRef<Path>) {\n+        for file in self.overlay.legal_and_readme() {\n+            self.add_file(self.builder.src.join(file), destdir.as_ref(), 0o644);\n+        }\n+    }\n+\n+    pub(crate) fn add_dir(&self, src: impl AsRef<Path>, dest: impl AsRef<Path>) {\n+        let dest = self.image_dir.join(dest.as_ref());\n+\n+        t!(std::fs::create_dir_all(&dest));\n+        self.builder.cp_r(src.as_ref(), &dest);\n+    }\n+\n+    pub(crate) fn persist_work_dir(&mut self) -> PathBuf {\n+        self.delete_temp_dir = false;\n+        self.temp_dir.clone()\n+    }\n+\n+    pub(crate) fn generate(self) -> PathBuf {\n+        let mut component_name = self.component.clone();\n+        if self.is_preview {\n+            component_name.push_str(\"-preview\");\n+        }\n+        if self.include_target_in_component_name {\n+            component_name.push('-');\n+            component_name.push_str(\n+                &self\n+                    .target\n+                    .as_ref()\n+                    .expect(\"include_target_in_component_name used in a targetless tarball\"),\n+            );\n+        }\n+\n+        self.run(|this, cmd| {\n+            cmd.arg(\"generate\")\n+                .arg(\"--image-dir\")\n+                .arg(&this.image_dir)\n+                .arg(format!(\"--component-name={}\", &component_name));\n+            this.non_bare_args(cmd);\n+        })\n+    }\n+\n+    pub(crate) fn combine(self, tarballs: &[PathBuf]) {\n+        let mut input_tarballs = tarballs[0].as_os_str().to_os_string();\n+        for tarball in &tarballs[1..] {\n+            input_tarballs.push(\",\");\n+            input_tarballs.push(tarball);\n+        }\n+\n+        self.run(|this, cmd| {\n+            cmd.arg(\"combine\").arg(\"--input-tarballs\").arg(input_tarballs);\n+            this.non_bare_args(cmd);\n+        });\n+    }\n+\n+    pub(crate) fn bare(self) -> PathBuf {\n+        self.run(|this, cmd| {\n+            cmd.arg(\"tarball\")\n+                .arg(\"--input\")\n+                .arg(&this.image_dir)\n+                .arg(\"--output\")\n+                .arg(crate::dist::distdir(this.builder).join(this.package_name()));\n+        })\n+    }\n+\n+    fn package_name(&self) -> String {\n+        if let Some(target) = &self.target {\n+            format!(\"{}-{}\", self.pkgname, target)\n+        } else {\n+            self.pkgname.clone()\n+        }\n+    }\n+\n+    fn non_bare_args(&self, cmd: &mut Command) {\n+        cmd.arg(\"--rel-manifest-dir=rustlib\")\n+            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n+            .arg(format!(\"--product-name={}\", self.product_name))\n+            .arg(format!(\"--success-message={} installed.\", self.component))\n+            .arg(format!(\"--package-name={}\", self.package_name()))\n+            .arg(\"--non-installed-overlay\")\n+            .arg(&self.overlay_dir)\n+            .arg(\"--output-dir\")\n+            .arg(crate::dist::distdir(self.builder));\n+    }\n+\n+    fn run(self, build_cli: impl FnOnce(&Tarball<'a>, &mut Command)) -> PathBuf {\n+        t!(std::fs::create_dir_all(&self.overlay_dir));\n+        self.builder.create(&self.overlay_dir.join(\"version\"), &self.overlay.version(self.builder));\n+        if let Some(sha) = self.builder.rust_sha() {\n+            self.builder.create(&self.overlay_dir.join(\"git-commit-hash\"), &sha);\n+        }\n+        for file in self.overlay.legal_and_readme() {\n+            self.builder.install(&self.builder.src.join(file), &self.overlay_dir, 0o644);\n+        }\n+\n+        let mut cmd = self.builder.tool_cmd(crate::tool::Tool::RustInstaller);\n+\n+        let package_name = self.package_name();\n+        self.builder.info(&format!(\"Dist {}\", package_name));\n+        let _time = crate::util::timeit(self.builder);\n+\n+        build_cli(&self, &mut cmd);\n+        cmd.arg(\"--work-dir\").arg(&self.temp_dir);\n+        self.builder.run(&mut cmd);\n+        if self.delete_temp_dir {\n+            t!(std::fs::remove_dir_all(&self.temp_dir));\n+        }\n+\n+        crate::dist::distdir(self.builder).join(format!(\"{}.tar.gz\", package_name))\n+    }\n+}"}]}