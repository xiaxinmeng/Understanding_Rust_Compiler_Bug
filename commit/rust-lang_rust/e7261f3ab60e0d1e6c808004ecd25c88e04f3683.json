{"sha": "e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3MjYxZjNhYjYwZTBkMWU2YzgwODAwNGVjZDI1Yzg4ZTA0ZjM2ODM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-14T15:26:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-14T15:26:09Z"}, "message": "Auto merge of #27641 - nikomatsakis:soundness-rfc-1214, r=nrc\n\nThis PR implements the majority of RFC 1214. In particular, it implements:\r\n\r\n- the new outlives relation\r\n- comprehensive WF checking\r\n\r\nFor the most part, new code receives warnings, not errors, though 3 regressions were found via a crater run. \r\n\r\nThere are some deviations from RFC 1214. Most notably:\r\n\r\n- we still consider implied bounds from fn ret; this intersects other soundness issues that I intend to address in detail in a follow-up RFC. Fixing this without breaking a lot of code probably requires rewriting compare-method somewhat (which is probably a good thing).\r\n- object types do not check trait bounds for fear of encountering `Self`; this was left as an unresolved question in RFC 1214, but ultimately feels inconsistent.\r\n\r\nBoth of those two issues are highlighted in the tracking issue, https://github.com/rust-lang/rust/issues/27579. #27579 also includes a testing matrix with new tests that I wrote -- these probably duplicate some existing tests, I tried to check but wasn't quite sure what to look for. I tried to be thorough in testing the WF relation, at least, but would welcome suggestions for missing tests.\r\n\r\nr? @nrc (or perhaps someone else?)", "tree": {"sha": "43c443aa413ef4bec429ae0f29b7c802943a8c74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43c443aa413ef4bec429ae0f29b7c802943a8c74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "html_url": "https://github.com/rust-lang/rust/commit/e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0649b16ade40d1fb02ea5c390293278bd876854a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0649b16ade40d1fb02ea5c390293278bd876854a", "html_url": "https://github.com/rust-lang/rust/commit/0649b16ade40d1fb02ea5c390293278bd876854a"}, {"sha": "7f8942c18d552837033dc543e03a4156200896e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f8942c18d552837033dc543e03a4156200896e8", "html_url": "https://github.com/rust-lang/rust/commit/7f8942c18d552837033dc543e03a4156200896e8"}], "stats": {"total": 5383, "additions": 4732, "deletions": 651}, "files": [{"sha": "0471a08cd78f11b0c37cb863f6e3d0534a7c1117", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -2135,7 +2135,7 @@ impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>\n /// two `Step` objects.\n #[unstable(feature = \"step_trait\",\n            reason = \"likely to be replaced by finer-grained traits\")]\n-pub trait Step: PartialOrd {\n+pub trait Step: PartialOrd+Sized {\n     /// Steps `self` if possible.\n     fn step(&self, by: &Self) -> Option<Self>;\n "}, {"sha": "923872501b056fda9749be6320cd53f4cdfea8a8", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -56,7 +56,7 @@ pub trait Sized {\n /// Types that can be \"unsized\" to a dynamically sized type.\n #[unstable(feature = \"unsize\")]\n #[lang=\"unsize\"]\n-pub trait Unsize<T> {\n+pub trait Unsize<T: ?Sized> {\n     // Empty.\n }\n "}, {"sha": "e96a2cf3b88e5462b73d7efa85059aba94f261d4", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -19,7 +19,7 @@ use char::CharExt;\n use cmp::{Eq, PartialOrd};\n use fmt;\n use intrinsics;\n-use marker::Copy;\n+use marker::{Copy, Sized};\n use mem::size_of;\n use option::Option::{self, Some, None};\n use result::Result::{self, Ok, Err};\n@@ -1263,7 +1263,7 @@ pub enum FpCategory {\n #[doc(hidden)]\n #[unstable(feature = \"core_float\",\n            reason = \"stable interface is via `impl f{32,64}` in later crates\")]\n-pub trait Float {\n+pub trait Float: Sized {\n     /// Returns the NaN value.\n     fn nan() -> Self;\n     /// Returns the infinite value."}, {"sha": "d5bceb3ba623ccdc49cc22cf40ec36530400c2ac", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -25,6 +25,7 @@ use default::Default;\n use fmt;\n use iter::ExactSizeIterator;\n use iter::{Map, Iterator, DoubleEndedIterator};\n+use marker::Sized;\n use mem;\n use ops::{Fn, FnMut, FnOnce};\n use option::Option::{self, None, Some};\n@@ -37,7 +38,7 @@ pub mod pattern;\n /// A trait to abstract the idea of creating a new instance of a type from a\n /// string.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait FromStr {\n+pub trait FromStr: Sized {\n     /// The associated error which can be returned from parsing.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Err;"}, {"sha": "a0b571b65ab5c9614d797de9fa4740593795d4d2", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -561,7 +561,7 @@ pub type Edges<'a,E> = Cow<'a,[E]>;\n /// `Cow<[T]>` to leave implementers the freedom to create\n /// entirely new vectors or to pass back slices into internally owned\n /// vectors.\n-pub trait GraphWalk<'a, N, E> {\n+pub trait GraphWalk<'a, N: Clone, E: Clone> {\n     /// Returns all the nodes in this graph.\n     fn nodes(&'a self) -> Nodes<'a, N>;\n     /// Returns all of the edges in this graph."}, {"sha": "26f92ee3b1cf079641a9e3dcd727d856c7a93593", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -12,6 +12,7 @@\n \n // this is surprisingly complicated to be both generic & correct\n \n+use core::marker::Sized;\n use Rng;\n use distributions::{Sample, IndependentSample};\n \n@@ -57,7 +58,7 @@ impl<Sup: SampleRange> IndependentSample<Sup> for Range<Sup> {\n /// uniformly between two values. This should not be used directly,\n /// and is only to facilitate `Range`.\n #[doc(hidden)]\n-pub trait SampleRange {\n+pub trait SampleRange: Sized {\n     /// Construct the `Range` object that `sample_range`\n     /// requires. This should not ever be called directly, only via\n     /// `Range::new`, which will check that `low < high`, so this"}, {"sha": "e0d13340be82afed49e041ddbdb6becb75e63325", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -129,6 +129,7 @@ pub mod middle {\n     pub mod lang_items;\n     pub mod liveness;\n     pub mod mem_categorization;\n+    pub mod outlives;\n     pub mod pat_util;\n     pub mod privacy;\n     pub mod reachable;\n@@ -143,6 +144,7 @@ pub mod middle {\n     pub mod ty_match;\n     pub mod ty_relate;\n     pub mod ty_walk;\n+    pub mod wf;\n     pub mod weak_lang_items;\n }\n "}, {"sha": "a8b22846b786dc3730dfab07613e34aa019d820f", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -790,6 +790,12 @@ fn parse_predicate_<'a,'tcx, F>(st: &mut PState<'a, 'tcx>,\n         'o' => ty::Binder(ty::OutlivesPredicate(parse_ty_(st, conv),\n                                                 parse_region_(st, conv))).to_predicate(),\n         'p' => ty::Binder(parse_projection_predicate_(st, conv)).to_predicate(),\n+        'w' => ty::Predicate::WellFormed(parse_ty_(st, conv)),\n+        'O' => {\n+            let def_id = parse_def_(st, NominalType, conv);\n+            assert_eq!(next(st), '|');\n+            ty::Predicate::ObjectSafe(def_id)\n+        }\n         c => panic!(\"Encountered invalid character in metadata: {}\", c)\n     }\n }"}, {"sha": "7170a3681713a28d22d7e18a1798ef56f7602be8", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -457,6 +457,13 @@ pub fn enc_predicate<'a, 'tcx>(w: &mut Encoder,\n             mywrite!(w, \"p\");\n             enc_projection_predicate(w, cx, data)\n         }\n+        ty::Predicate::WellFormed(data) => {\n+            mywrite!(w, \"w\");\n+            enc_ty(w, cx, data);\n+        }\n+        ty::Predicate::ObjectSafe(trait_def_id) => {\n+            mywrite!(w, \"O{}|\", (cx.ds)(trait_def_id));\n+        }\n     }\n }\n "}, {"sha": "c064b31173f98dc60f1788f503aa8ba57e60ed73", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -1061,7 +1061,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     }\n }\n \n-trait doc_decoder_helpers {\n+trait doc_decoder_helpers: Sized {\n     fn as_int(&self) -> isize;\n     fn opt_child(&self, tag: c::astencode_tag) -> Option<Self>;\n }"}, {"sha": "e5ee2ca0d4022ba3e1dd38fe554ef09c4a554884", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -239,7 +239,7 @@ impl OverloadedCallType {\n // supplies types from the tree. After type checking is complete, you\n // can just use the tcx as the typer.\n \n-pub struct ExprUseVisitor<'d,'t,'a: 't, 'tcx:'a> {\n+pub struct ExprUseVisitor<'d, 't, 'a: 't, 'tcx:'a+'d> {\n     typer: &'t infer::InferCtxt<'a, 'tcx>,\n     mc: mc::MemCategorizationContext<'t, 'a, 'tcx>,\n     delegate: &'d mut (Delegate<'tcx>+'d),\n@@ -273,7 +273,8 @@ enum PassArgs {\n impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n     pub fn new(delegate: &'d mut Delegate<'tcx>,\n                typer: &'t infer::InferCtxt<'a, 'tcx>)\n-               -> ExprUseVisitor<'d,'t,'a, 'tcx> {\n+               -> ExprUseVisitor<'d,'t,'a,'tcx>\n+    {\n         ExprUseVisitor {\n             typer: typer,\n             mc: mc::MemCategorizationContext::new(typer),"}, {"sha": "5af37e9530ccea22ba6475fcdc81da8a5f6155bd", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -10,7 +10,7 @@\n \n //! This file defines\n \n-use middle::implicator::Implication;\n+use middle::wf::ImpliedBound;\n use middle::ty::{self, FreeRegion};\n use util::common::can_reach;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n@@ -30,18 +30,19 @@ impl FreeRegionMap {\n         FreeRegionMap { map: FnvHashMap(), statics: FnvHashSet() }\n     }\n \n-    pub fn relate_free_regions_from_implications<'tcx>(&mut self,\n-                                                       implications: &[Implication<'tcx>])\n+    pub fn relate_free_regions_from_implied_bounds<'tcx>(&mut self,\n+                                                        implied_bounds: &[ImpliedBound<'tcx>])\n     {\n-        for implication in implications {\n-            debug!(\"implication: {:?}\", implication);\n-            match *implication {\n-                Implication::RegionSubRegion(_, ty::ReFree(free_a), ty::ReFree(free_b)) => {\n+        debug!(\"relate_free_regions_from_implied_bounds()\");\n+        for implied_bound in implied_bounds {\n+            debug!(\"implied bound: {:?}\", implied_bound);\n+            match *implied_bound {\n+                ImpliedBound::RegionSubRegion(ty::ReFree(free_a), ty::ReFree(free_b)) => {\n                     self.relate_free_regions(free_a, free_b);\n                 }\n-                Implication::RegionSubRegion(..) |\n-                Implication::RegionSubGeneric(..) |\n-                Implication::Predicate(..) => {\n+                ImpliedBound::RegionSubRegion(..) |\n+                ImpliedBound::RegionSubParam(..) |\n+                ImpliedBound::RegionSubProjection(..) => {\n                 }\n             }\n         }\n@@ -56,6 +57,8 @@ impl FreeRegionMap {\n                 ty::Predicate::Projection(..) |\n                 ty::Predicate::Trait(..) |\n                 ty::Predicate::Equate(..) |\n+                ty::Predicate::WellFormed(..) |\n+                ty::Predicate::ObjectSafe(..) |\n                 ty::Predicate::TypeOutlives(..) => {\n                     // No region bounds here\n                 }"}, {"sha": "1961c15d6e607b6d4339815c649184761d31c0a5", "filename": "src/librustc/middle/implicator.rs", "status": "modified", "additions": 5, "deletions": 51, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fimplicator.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -13,7 +13,7 @@\n use middle::infer::{InferCtxt, GenericKind};\n use middle::subst::Substs;\n use middle::traits;\n-use middle::ty::{self, RegionEscape, ToPolyTraitRef, ToPredicate, Ty};\n+use middle::ty::{self, RegionEscape, ToPredicate, Ty};\n use middle::ty_fold::{TypeFoldable, TypeFolder};\n \n use syntax::ast;\n@@ -278,9 +278,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n \n         for predicate in predicates.predicates.as_slice() {\n             match *predicate {\n-                ty::Predicate::Trait(ref data) => {\n-                    self.accumulate_from_assoc_types_transitive(data);\n-                }\n+                ty::Predicate::Trait(..) => { }\n                 ty::Predicate::Equate(..) => { }\n                 ty::Predicate::Projection(..) => { }\n                 ty::Predicate::RegionOutlives(ref data) => {\n@@ -301,6 +299,9 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                         }\n                     }\n                 }\n+                ty::Predicate::ObjectSafe(_) |\n+                ty::Predicate::WellFormed(_) => {\n+                }\n             }\n         }\n \n@@ -349,53 +350,6 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n         }\n     }\n \n-    /// Given that there is a requirement that `Foo<X> : 'a`, where\n-    /// `Foo` is declared like `struct Foo<T> where T : SomeTrait`,\n-    /// this code finds all the associated types defined in\n-    /// `SomeTrait` (and supertraits) and adds a requirement that `<X\n-    /// as SomeTrait>::N : 'a` (where `N` is some associated type\n-    /// defined in `SomeTrait`). This rule only applies to\n-    /// trait-bounds that are not higher-ranked, because we cannot\n-    /// project out of a HRTB. This rule helps code using associated\n-    /// types to compile, see Issue #22246 for an example.\n-    fn accumulate_from_assoc_types_transitive(&mut self,\n-                                              data: &ty::PolyTraitPredicate<'tcx>)\n-    {\n-        debug!(\"accumulate_from_assoc_types_transitive({:?})\",\n-               data);\n-\n-        for poly_trait_ref in traits::supertraits(self.tcx(), data.to_poly_trait_ref()) {\n-            match self.tcx().no_late_bound_regions(&poly_trait_ref) {\n-                Some(trait_ref) => { self.accumulate_from_assoc_types(trait_ref); }\n-                None => { }\n-            }\n-        }\n-    }\n-\n-    fn accumulate_from_assoc_types(&mut self,\n-                                   trait_ref: ty::TraitRef<'tcx>)\n-    {\n-        debug!(\"accumulate_from_assoc_types({:?})\",\n-               trait_ref);\n-\n-        let trait_def_id = trait_ref.def_id;\n-        let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n-        let assoc_type_projections: Vec<_> =\n-            trait_def.associated_type_names\n-                     .iter()\n-                     .map(|&name| self.tcx().mk_projection(trait_ref.clone(), name))\n-                     .collect();\n-        debug!(\"accumulate_from_assoc_types: assoc_type_projections={:?}\",\n-               assoc_type_projections);\n-        let tys = match self.fully_normalize(&assoc_type_projections) {\n-            Ok(tys) => { tys }\n-            Err(ErrorReported) => { return; }\n-        };\n-        for ty in tys {\n-            self.accumulate_from_ty(ty);\n-        }\n-    }\n-\n     fn accumulate_from_object_ty(&mut self,\n                                  ty: Ty<'tcx>,\n                                  region_bound: ty::Region,"}, {"sha": "44eceb1f213af848ff5106d74230ab7367e7f188", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 59, "deletions": 11, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -239,8 +239,7 @@ pub trait ErrorReporting<'tcx> {\n     fn report_generic_bound_failure(&self,\n                                     origin: SubregionOrigin<'tcx>,\n                                     kind: GenericKind<'tcx>,\n-                                    sub: Region,\n-                                    sups: Vec<Region>);\n+                                    sub: Region);\n \n     fn report_sub_sup_conflict(&self,\n                                var_origin: RegionVariableOrigin,\n@@ -292,8 +291,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     self.report_concrete_failure(origin, sub, sup);\n                 }\n \n-                GenericBoundFailure(kind, param_ty, sub, sups) => {\n-                    self.report_generic_bound_failure(kind, param_ty, sub, sups);\n+                GenericBoundFailure(kind, param_ty, sub) => {\n+                    self.report_generic_bound_failure(kind, param_ty, sub);\n                 }\n \n                 SubSupConflict(var_origin,\n@@ -527,14 +526,18 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n     fn report_generic_bound_failure(&self,\n                                     origin: SubregionOrigin<'tcx>,\n                                     bound_kind: GenericKind<'tcx>,\n-                                    sub: Region,\n-                                    _sups: Vec<Region>)\n+                                    sub: Region)\n     {\n         // FIXME: it would be better to report the first error message\n         // with the span of the parameter itself, rather than the span\n         // where the error was detected. But that span is not readily\n         // accessible.\n \n+        let is_warning = match origin {\n+            infer::RFC1214Subregion(_) => true,\n+            _ => false,\n+        };\n+\n         let labeled_user_string = match bound_kind {\n             GenericKind::Param(ref p) =>\n                 format!(\"the parameter type `{}`\", p),\n@@ -545,7 +548,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         match sub {\n             ty::ReFree(ty::FreeRegion {bound_region: ty::BrNamed(..), ..}) => {\n                 // Does the required lifetime have a nice name we can print?\n-                span_err!(self.tcx.sess, origin.span(), E0309,\n+                span_err_or_warn!(\n+                    is_warning, self.tcx.sess, origin.span(), E0309,\n                     \"{} may not live long enough\", labeled_user_string);\n                 self.tcx.sess.fileline_help(\n                     origin.span(),\n@@ -557,7 +561,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n             ty::ReStatic => {\n                 // Does the required lifetime have a nice name we can print?\n-                span_err!(self.tcx.sess, origin.span(), E0310,\n+                span_err_or_warn!(\n+                    is_warning, self.tcx.sess, origin.span(), E0310,\n                     \"{} may not live long enough\", labeled_user_string);\n                 self.tcx.sess.fileline_help(\n                     origin.span(),\n@@ -568,9 +573,10 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n             _ => {\n                 // If not, be less specific.\n-                span_err!(self.tcx.sess, origin.span(), E0311,\n-                        \"{} may not live long enough\",\n-                        labeled_user_string);\n+                span_err_or_warn!(\n+                    is_warning, self.tcx.sess, origin.span(), E0311,\n+                    \"{} may not live long enough\",\n+                    labeled_user_string);\n                 self.tcx.sess.fileline_help(\n                     origin.span(),\n                     &format!(\n@@ -583,6 +589,10 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n         }\n \n+        if is_warning {\n+            self.tcx.sess.note_rfc_1214(origin.span());\n+        }\n+\n         self.note_region_origin(&origin);\n     }\n \n@@ -591,6 +601,13 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                sub: Region,\n                                sup: Region) {\n         match origin {\n+            infer::RFC1214Subregion(ref suborigin) => {\n+                // Ideally, this would be a warning, but it doesn't\n+                // seem to come up in practice, since the changes from\n+                // RFC1214 mostly trigger errors in type definitions\n+                // that don't wind up coming down this path.\n+                self.report_concrete_failure((**suborigin).clone(), sub, sup);\n+            }\n             infer::Subtype(trace) => {\n                 let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n                 self.report_and_explain_type_error(trace, &terr);\n@@ -819,6 +836,23 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     sup,\n                     \"\");\n             }\n+            infer::ParameterInScope(_, span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    &format!(\"type/lifetime parameter not in scope here\"));\n+                self.tcx.note_and_explain_region(\n+                    \"the parameter is only valid for \",\n+                    sub,\n+                    \"\");\n+            }\n+            infer::DataBorrowed(ty, span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    &format!(\"a value of type `{}` is borrowed for too long\",\n+                             self.ty_to_string(ty)));\n+                self.tcx.note_and_explain_region(\"the type is valid for \", sub, \"\");\n+                self.tcx.note_and_explain_region(\"but the borrow lasts for \", sup, \"\");\n+            }\n             infer::ReferenceOutlivesReferent(ty, span) => {\n                 self.tcx.sess.span_err(\n                     span,\n@@ -1567,6 +1601,9 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn note_region_origin(&self, origin: &SubregionOrigin<'tcx>) {\n         match *origin {\n+            infer::RFC1214Subregion(ref suborigin) => {\n+                self.note_region_origin(suborigin);\n+            }\n             infer::Subtype(ref trace) => {\n                 let desc = match trace.origin {\n                     infer::Misc(_) => {\n@@ -1714,6 +1751,17 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     \"...so that variable is valid at time of its declaration\");\n             }\n+            infer::ParameterInScope(_, span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    &format!(\"...so that a type/lifetime parameter is in scope here\"));\n+            }\n+            infer::DataBorrowed(ty, span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    &format!(\"...so that the type `{}` is not borrowed for too long\",\n+                             self.ty_to_string(ty)));\n+            }\n             infer::ReferenceOutlivesReferent(ty, span) => {\n                 self.tcx.sess.span_note(\n                     span,"}, {"sha": "578b39af88cb42f7b3cc95f7669de7b14d0162b1", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -17,7 +17,7 @@ pub use self::TypeOrigin::*;\n pub use self::ValuePairs::*;\n pub use middle::ty::IntVarValue;\n pub use self::freshen::TypeFreshener;\n-pub use self::region_inference::GenericKind;\n+pub use self::region_inference::{GenericKind, VerifyBound};\n \n use middle::free_region::FreeRegionMap;\n use middle::mem_categorization as mc;\n@@ -35,6 +35,7 @@ use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n use rustc_data_structures::unify::{self, UnificationTable};\n use std::cell::{RefCell, Ref};\n use std::fmt;\n+use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap;\n use syntax::codemap::{Span, DUMMY_SP};\n@@ -188,6 +189,11 @@ pub struct TypeTrace<'tcx> {\n /// See `error_reporting.rs` for more details\n #[derive(Clone, Debug)]\n pub enum SubregionOrigin<'tcx> {\n+    // Marker to indicate a constraint that only arises due to new\n+    // provisions from RFC 1214. This will result in a warning, not an\n+    // error.\n+    RFC1214Subregion(Rc<SubregionOrigin<'tcx>>),\n+\n     // Arose from a subtyping relation\n     Subtype(TypeTrace<'tcx>),\n \n@@ -229,9 +235,15 @@ pub enum SubregionOrigin<'tcx> {\n     // Creating a pointer `b` to contents of an upvar\n     ReborrowUpvar(Span, ty::UpvarId),\n \n+    // Data with type `Ty<'tcx>` was borrowed\n+    DataBorrowed(Ty<'tcx>, Span),\n+\n     // (&'a &'b T) where a >= b\n     ReferenceOutlivesReferent(Ty<'tcx>, Span),\n \n+    // Type or region parameters must be in scope.\n+    ParameterInScope(ParameterOrigin, Span),\n+\n     // The type T of an expression E must outlive the lifetime for E.\n     ExprTypeIsNotInScope(Ty<'tcx>, Span),\n \n@@ -260,6 +272,15 @@ pub enum SubregionOrigin<'tcx> {\n     SafeDestructor(Span),\n }\n \n+/// Places that type/region parameters can appear.\n+#[derive(Clone, Copy, Debug)]\n+pub enum ParameterOrigin {\n+    Path, // foo::bar\n+    MethodCall, // foo.bar() <-- parameters on impl providing bar()\n+    OverloadedOperator, // a + b when overloaded\n+    OverloadedDeref, // *a when overloaded\n+}\n+\n /// Times when we replace late-bound regions with variables:\n #[derive(Clone, Copy, Debug)]\n pub enum LateBoundRegionConversionTime {\n@@ -1398,13 +1419,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                 origin: SubregionOrigin<'tcx>,\n                                 kind: GenericKind<'tcx>,\n                                 a: ty::Region,\n-                                bs: Vec<ty::Region>) {\n+                                bound: VerifyBound) {\n         debug!(\"verify_generic_bound({:?}, {:?} <: {:?})\",\n                kind,\n                a,\n-               bs);\n+               bound);\n \n-        self.region_vars.verify_generic_bound(origin, kind, a, bs);\n+        self.region_vars.verify_generic_bound(origin, kind, a, bound);\n     }\n \n     pub fn can_equate<'b,T>(&'b self, a: &T, b: &T) -> UnitResult<'tcx>\n@@ -1565,6 +1586,7 @@ impl TypeOrigin {\n impl<'tcx> SubregionOrigin<'tcx> {\n     pub fn span(&self) -> Span {\n         match *self {\n+            RFC1214Subregion(ref a) => a.span(),\n             Subtype(ref a) => a.span(),\n             InfStackClosure(a) => a,\n             InvokeClosure(a) => a,\n@@ -1577,7 +1599,9 @@ impl<'tcx> SubregionOrigin<'tcx> {\n             RelateDefaultParamBound(a, _) => a,\n             Reborrow(a) => a,\n             ReborrowUpvar(a, _) => a,\n+            DataBorrowed(_, a) => a,\n             ReferenceOutlivesReferent(_, a) => a,\n+            ParameterInScope(_, a) => a,\n             ExprTypeIsNotInScope(_, a) => a,\n             BindingTypeIsNotValidAtDecl(a) => a,\n             CallRcvr(a) => a,"}, {"sha": "e8f8dbfbb0e638cf5123abac14d1abd831354599", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 153, "deletions": 40, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -64,15 +64,41 @@ pub enum Verify<'tcx> {\n     // outlive `RS`. Therefore verify that `R <= RS[i]` for some\n     // `i`. Inference variables may be involved (but this verification\n     // step doesn't influence inference).\n-    VerifyGenericBound(GenericKind<'tcx>, SubregionOrigin<'tcx>, Region, Vec<Region>),\n+    VerifyGenericBound(GenericKind<'tcx>, SubregionOrigin<'tcx>, Region, VerifyBound),\n }\n \n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Copy, Clone, PartialEq, Eq)]\n pub enum GenericKind<'tcx> {\n     Param(ty::ParamTy),\n     Projection(ty::ProjectionTy<'tcx>),\n }\n \n+// When we introduce a verification step, we wish to test that a\n+// particular region (let's call it `'min`) meets some bound.\n+// The bound is described the by the following grammar:\n+#[derive(Debug)]\n+pub enum VerifyBound {\n+    // B = exists {R} --> some 'r in {R} must outlive 'min\n+    //\n+    // Put another way, the subject value is known to outlive all\n+    // regions in {R}, so if any of those outlives 'min, then the\n+    // bound is met.\n+    AnyRegion(Vec<Region>),\n+\n+    // B = forall {R} --> all 'r in {R} must outlive 'min\n+    //\n+    // Put another way, the subject value is known to outlive some\n+    // region in {R}, so if all of those outlives 'min, then the bound\n+    // is met.\n+    AllRegions(Vec<Region>),\n+\n+    // B = exists {B} --> 'min must meet some bound b in {B}\n+    AnyBound(Vec<VerifyBound>),\n+\n+    // B = forall {B} --> 'min must meet all bounds b in {B}\n+    AllBounds(Vec<VerifyBound>),\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub struct TwoRegions {\n     a: Region,\n@@ -102,12 +128,11 @@ pub enum RegionResolutionError<'tcx> {\n     /// `o` requires that `a <= b`, but this does not hold\n     ConcreteFailure(SubregionOrigin<'tcx>, Region, Region),\n \n-    /// `GenericBoundFailure(p, s, a, bs)\n+    /// `GenericBoundFailure(p, s, a)\n     ///\n     /// The parameter/associated-type `p` must be known to outlive the lifetime\n-    /// `a`, but it is only known to outlive `bs` (and none of the\n-    /// regions in `bs` outlive `a`).\n-    GenericBoundFailure(SubregionOrigin<'tcx>, GenericKind<'tcx>, Region, Vec<Region>),\n+    /// `a` (but none of the known bounds are sufficient).\n+    GenericBoundFailure(SubregionOrigin<'tcx>, GenericKind<'tcx>, Region),\n \n     /// `SubSupConflict(v, sub_origin, sub_r, sup_origin, sup_r)`:\n     ///\n@@ -408,6 +433,14 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         debug!(\"RegionVarBindings: add_verify({:?})\",\n                verify);\n \n+        // skip no-op cases known to be satisfied\n+        match verify {\n+            VerifyGenericBound(_, _, _, VerifyBound::AllBounds(ref bs)) if bs.len() == 0 => {\n+                return;\n+            }\n+            _ => { }\n+        }\n+\n         let mut verifys = self.verifys.borrow_mut();\n         let index = verifys.len();\n         verifys.push(verify);\n@@ -497,8 +530,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                                 origin: SubregionOrigin<'tcx>,\n                                 kind: GenericKind<'tcx>,\n                                 sub: Region,\n-                                sups: Vec<Region>) {\n-        self.add_verify(VerifyGenericBound(kind, origin, sub, sups));\n+                                bound: VerifyBound) {\n+        self.add_verify(VerifyGenericBound(kind, origin, sub, bound));\n     }\n \n     pub fn lub_regions(&self,\n@@ -663,12 +696,11 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                                     &mut result_set, r,\n                                     a, b);\n                             }\n-                            VerifyGenericBound(_, _, a, ref bs) => {\n-                                for &b in bs {\n-                                    consider_adding_bidirectional_edges(\n-                                        &mut result_set, r,\n-                                        a, b);\n-                                }\n+                            VerifyGenericBound(_, _, a, ref bound) => {\n+                                bound.for_each_region(&mut |b| {\n+                                    consider_adding_bidirectional_edges(&mut result_set, r,\n+                                                                        a, b)\n+                                });\n                             }\n                         }\n                     }\n@@ -1258,26 +1290,22 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                         continue;\n                     }\n \n-                    debug!(\"ConcreteFailure: !(sub <= sup): sub={:?}, sup={:?}\",\n-                           sub,\n-                           sup);\n+                    debug!(\"region inference error at {:?}: {:?} <= {:?} is not true\",\n+                           origin, sub, sup);\n+\n                     errors.push(ConcreteFailure((*origin).clone(), sub, sup));\n                 }\n \n-                VerifyGenericBound(ref kind, ref origin, sub, ref sups) => {\n+                VerifyGenericBound(ref kind, ref origin, sub, ref bound) => {\n                     let sub = normalize(values, sub);\n-                    if sups.iter()\n-                           .map(|&sup| normalize(values, sup))\n-                           .any(|sup| free_regions.is_subregion_of(self.tcx, sub, sup))\n-                    {\n+                    if bound.is_met(self.tcx, free_regions, values, sub) {\n                         continue;\n                     }\n \n-                    let sups = sups.iter().map(|&sup| normalize(values, sup))\n-                                          .collect();\n-                    errors.push(\n-                        GenericBoundFailure(\n-                            (*origin).clone(), kind.clone(), sub, sups));\n+                    debug!(\"region inference error at {:?}: verifying {:?} <= {:?}\",\n+                           origin, sub, bound);\n+\n+                    errors.push(GenericBoundFailure((*origin).clone(), kind.clone(), sub));\n                 }\n             }\n         }\n@@ -1438,10 +1466,12 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 if !free_regions.is_subregion_of(self.tcx,\n                                                  lower_bound.region,\n                                                  upper_bound.region) {\n-                    debug!(\"pushing SubSupConflict sub: {:?} sup: {:?}\",\n-                           lower_bound.region, upper_bound.region);\n+                    let origin = (*self.var_origins.borrow())[node_idx.index as usize].clone();\n+                    debug!(\"region inference error at {:?} for {:?}: \\\n+                            SubSupConflict sub: {:?} sup: {:?}\",\n+                           origin, node_idx, lower_bound.region, upper_bound.region);\n                     errors.push(SubSupConflict(\n-                        (*self.var_origins.borrow())[node_idx.index as usize].clone(),\n+                        origin,\n                         lower_bound.origin.clone(),\n                         lower_bound.region,\n                         upper_bound.origin.clone(),\n@@ -1484,16 +1514,20 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 match self.glb_concrete_regions(free_regions,\n                                                 upper_bound_1.region,\n                                                 upper_bound_2.region) {\n-                  Ok(_) => {}\n-                  Err(_) => {\n-                    errors.push(SupSupConflict(\n-                        (*self.var_origins.borrow())[node_idx.index as usize].clone(),\n-                        upper_bound_1.origin.clone(),\n-                        upper_bound_1.region,\n-                        upper_bound_2.origin.clone(),\n-                        upper_bound_2.region));\n-                    return;\n-                  }\n+                    Ok(_) => {}\n+                    Err(_) => {\n+                        let origin = (*self.var_origins.borrow())[node_idx.index as usize].clone();\n+                        debug!(\"region inference error at {:?} for {:?}: \\\n+                                SupSupConflict sub: {:?} sup: {:?}\",\n+                               origin, node_idx, upper_bound_1.region, upper_bound_2.region);\n+                        errors.push(SupSupConflict(\n+                            origin,\n+                            upper_bound_1.origin.clone(),\n+                            upper_bound_1.region,\n+                            upper_bound_2.origin.clone(),\n+                            upper_bound_2.region));\n+                        return;\n+                    }\n                 }\n             }\n         }\n@@ -1676,3 +1710,82 @@ impl<'tcx> GenericKind<'tcx> {\n         }\n     }\n }\n+\n+impl VerifyBound {\n+    fn for_each_region(&self, f: &mut FnMut(ty::Region)) {\n+        match self {\n+            &VerifyBound::AnyRegion(ref rs) |\n+            &VerifyBound::AllRegions(ref rs) =>\n+                for &r in rs { f(r); },\n+\n+            &VerifyBound::AnyBound(ref bs) |\n+            &VerifyBound::AllBounds(ref bs) =>\n+                for b in bs { b.for_each_region(f); },\n+        }\n+    }\n+\n+    pub fn must_hold(&self) -> bool {\n+        match self {\n+            &VerifyBound::AnyRegion(ref bs) => bs.contains(&ty::ReStatic),\n+            &VerifyBound::AllRegions(ref bs) => bs.is_empty(),\n+            &VerifyBound::AnyBound(ref bs) => bs.iter().any(|b| b.must_hold()),\n+            &VerifyBound::AllBounds(ref bs) => bs.iter().all(|b| b.must_hold()),\n+        }\n+    }\n+\n+    pub fn cannot_hold(&self) -> bool {\n+        match self {\n+            &VerifyBound::AnyRegion(ref bs) => bs.is_empty(),\n+            &VerifyBound::AllRegions(ref bs) => bs.contains(&ty::ReEmpty),\n+            &VerifyBound::AnyBound(ref bs) => bs.iter().all(|b| b.cannot_hold()),\n+            &VerifyBound::AllBounds(ref bs) => bs.iter().any(|b| b.cannot_hold()),\n+        }\n+    }\n+\n+    pub fn or(self, vb: VerifyBound) -> VerifyBound {\n+        if self.must_hold() || vb.cannot_hold() {\n+            self\n+        } else if self.cannot_hold() || vb.must_hold() {\n+            vb\n+        } else {\n+            VerifyBound::AnyBound(vec![self, vb])\n+        }\n+    }\n+\n+    pub fn and(self, vb: VerifyBound) -> VerifyBound {\n+        if self.must_hold() && vb.must_hold() {\n+            self\n+        } else if self.cannot_hold() && vb.cannot_hold() {\n+            self\n+        } else {\n+            VerifyBound::AllBounds(vec![self, vb])\n+        }\n+    }\n+\n+    fn is_met<'tcx>(&self,\n+                    tcx: &ty::ctxt<'tcx>,\n+                    free_regions: &FreeRegionMap,\n+                    var_values: &Vec<VarValue>,\n+                    min: ty::Region)\n+                    -> bool {\n+        match self {\n+            &VerifyBound::AnyRegion(ref rs) =>\n+                rs.iter()\n+                  .map(|&r| normalize(var_values, r))\n+                  .any(|r| free_regions.is_subregion_of(tcx, min, r)),\n+\n+            &VerifyBound::AllRegions(ref rs) =>\n+                rs.iter()\n+                  .map(|&r| normalize(var_values, r))\n+                  .all(|r| free_regions.is_subregion_of(tcx, min, r)),\n+\n+            &VerifyBound::AnyBound(ref bs) =>\n+                bs.iter()\n+                  .any(|b| b.is_met(tcx, free_regions, var_values, min)),\n+\n+            &VerifyBound::AllBounds(ref bs) =>\n+                bs.iter()\n+                  .all(|b| b.is_met(tcx, free_regions, var_values, min)),\n+        }\n+    }\n+}"}, {"sha": "9a2570d710d387bf6d353648c53023be2ddd0deb", "filename": "src/librustc/middle/outlives.rs", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Foutlives.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,231 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// The outlines relation `T: 'a` or `'a: 'b`. This code frequently\n+// refers to rules defined in RFC 1214 (`OutlivesFooBar`), so see that\n+// RFC for reference.\n+\n+use middle::infer::InferCtxt;\n+use middle::ty::{self, RegionEscape, Ty};\n+\n+#[derive(Debug)]\n+pub enum Component<'tcx> {\n+    Region(ty::Region),\n+    Param(ty::ParamTy),\n+    UnresolvedInferenceVariable(ty::InferTy),\n+\n+    // Projections like `T::Foo` are tricky because a constraint like\n+    // `T::Foo: 'a` can be satisfied in so many ways. There may be a\n+    // where-clause that says `T::Foo: 'a`, or the defining trait may\n+    // include a bound like `type Foo: 'static`, or -- in the most\n+    // conservative way -- we can prove that `T: 'a` (more generally,\n+    // that all components in the projection outlive `'a`). This code\n+    // is not in a position to judge which is the best technique, so\n+    // we just product the projection as a component and leave it to\n+    // the consumer to decide (but see `EscapingProjection` below).\n+    Projection(ty::ProjectionTy<'tcx>),\n+\n+    // In the case where a projection has escaping regions -- meaning\n+    // regions bound within the type itself -- we always use\n+    // the most conservative rule, which requires that all components\n+    // outlive the bound. So for example if we had a type like this:\n+    //\n+    //     for<'a> Trait1<  <T as Trait2<'a,'b>>::Foo  >\n+    //                      ~~~~~~~~~~~~~~~~~~~~~~~~~\n+    //\n+    // then the inner projection (underlined) has an escaping region\n+    // `'a`. We consider that outer trait `'c` to meet a bound if `'b`\n+    // outlives `'b: 'c`, and we don't consider whether the trait\n+    // declares that `Foo: 'static` etc. Therefore, we just return the\n+    // free components of such a projection (in this case, `'b`).\n+    //\n+    // However, in the future, we may want to get smarter, and\n+    // actually return a \"higher-ranked projection\" here. Therefore,\n+    // we mark that these components are part of an escaping\n+    // projection, so that implied bounds code can avoid relying on\n+    // them. This gives us room to improve the regionck reasoning in\n+    // the future without breaking backwards compat.\n+    EscapingProjection(Vec<Component<'tcx>>),\n+\n+    // This is a temporary marker indicating \"outlives components\"\n+    // that are due to the new rules introduced by RFC 1214.  For the\n+    // time being, violations of these requirements generally induce\n+    // warnings, not errors.\n+    RFC1214(Vec<Component<'tcx>>),\n+}\n+\n+/// Returns all the things that must outlive `'a` for the condition\n+/// `ty0: 'a` to hold.\n+pub fn components<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                           ty0: Ty<'tcx>)\n+                           -> Vec<Component<'tcx>> {\n+    let mut components = vec![];\n+    compute_components(infcx, ty0, &mut components);\n+    debug!(\"components({:?}) = {:?}\", ty0, components);\n+    components\n+}\n+\n+fn compute_components<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                               ty: Ty<'tcx>,\n+                               out: &mut Vec<Component<'tcx>>) {\n+    // Descend through the types, looking for the various \"base\"\n+    // components and collecting them into `out`. This is not written\n+    // with `collect()` because of the need to sometimes skip subtrees\n+    // in the `subtys` iterator (e.g., when encountering a\n+    // projection).\n+    match ty.sty {\n+        ty::TyClosure(_, ref substs) => {\n+            // FIXME(#27086). We do not accumulate from substs, since they\n+            // don't represent reachable data. This means that, in\n+            // practice, some of the lifetime parameters might not\n+            // be in scope when the body runs, so long as there is\n+            // no reachable data with that lifetime. For better or\n+            // worse, this is consistent with fn types, however,\n+            // which can also encapsulate data in this fashion\n+            // (though it's somewhat harder, and typically\n+            // requires virtual dispatch).\n+            //\n+            // Note that changing this (in a naive way, at least)\n+            // causes regressions for what appears to be perfectly\n+            // reasonable code like this:\n+            //\n+            // ```\n+            // fn foo<'a>(p: &Data<'a>) {\n+            //    bar(|q: &mut Parser| q.read_addr())\n+            // }\n+            // fn bar(p: Box<FnMut(&mut Parser)+'static>) {\n+            // }\n+            // ```\n+            //\n+            // Note that `p` (and `'a`) are not used in the\n+            // closure at all, but to meet the requirement that\n+            // the closure type `C: 'static` (so it can be coerced\n+            // to the object type), we get the requirement that\n+            // `'a: 'static` since `'a` appears in the closure\n+            // type `C`.\n+            //\n+            // A smarter fix might \"prune\" unused `func_substs` --\n+            // this would avoid breaking simple examples like\n+            // this, but would still break others (which might\n+            // indeed be invalid, depending on your POV). Pruning\n+            // would be a subtle process, since we have to see\n+            // what func/type parameters are used and unused,\n+            // taking into consideration UFCS and so forth.\n+\n+            for &upvar_ty in &substs.upvar_tys {\n+                compute_components(infcx, upvar_ty, out);\n+            }\n+        }\n+\n+        // Bare functions and traits are both binders. In the RFC,\n+        // this means we would add the bound regions to the \"bound\n+        // regions list\".  In our representation, no such list is\n+        // maintained explicitly, because bound regions themselves can\n+        // be readily identified. However, because the outlives\n+        // relation did not used to be applied to fn/trait-object\n+        // arguments, we wrap the resulting components in an RFC1214\n+        // wrapper so we can issue warnings.\n+        ty::TyBareFn(..) | ty::TyTrait(..) => {\n+            // OutlivesFunction, OutlivesObject, OutlivesFragment\n+            let subcomponents = capture_components(infcx, ty);\n+            out.push(Component::RFC1214(subcomponents));\n+        }\n+\n+        // OutlivesTypeParameterEnv -- the actual checking that `X:'a`\n+        // is implied by the environment is done in regionck.\n+        ty::TyParam(p) => {\n+            out.push(Component::Param(p));\n+        }\n+\n+        // For projections, we prefer to generate an obligation like\n+        // `<P0 as Trait<P1...Pn>>::Foo: 'a`, because this gives the\n+        // regionck more ways to prove that it holds. However,\n+        // regionck is not (at least currently) prepared to deal with\n+        // higher-ranked regions that may appear in the\n+        // trait-ref. Therefore, if we see any higher-ranke regions,\n+        // we simply fallback to the most restrictive rule, which\n+        // requires that `Pi: 'a` for all `i`.\n+        ty::TyProjection(ref data) => {\n+            if !data.has_escaping_regions() {\n+                // best case: no escaping regions, so push the\n+                // projection and skip the subtree (thus generating no\n+                // constraints for Pi). This defers the choice between\n+                // the rules OutlivesProjectionEnv,\n+                // OutlivesProjectionTraitDef, and\n+                // OutlivesProjectionComponents to regionck.\n+                out.push(Component::Projection(*data));\n+            } else {\n+                // fallback case: hard code\n+                // OutlivesProjectionComponents.  Continue walking\n+                // through and constrain Pi.\n+                let subcomponents = capture_components(infcx, ty);\n+                out.push(Component::EscapingProjection(subcomponents));\n+            }\n+        }\n+\n+        // If we encounter an inference variable, try to resolve it\n+        // and proceed with resolved version. If we cannot resolve it,\n+        // then record the unresolved variable as a component.\n+        ty::TyInfer(_) => {\n+            let ty = infcx.resolve_type_vars_if_possible(&ty);\n+            if let ty::TyInfer(infer_ty) = ty.sty {\n+                out.push(Component::UnresolvedInferenceVariable(infer_ty));\n+            } else {\n+                compute_components(infcx, ty, out);\n+            }\n+        }\n+\n+        // Most types do not introduce any region binders, nor\n+        // involve any other subtle cases, and so the WF relation\n+        // simply constraints any regions referenced directly by\n+        // the type and then visits the types that are lexically\n+        // contained within. (The comments refer to relevant rules\n+        // from RFC1214.)\n+        ty::TyBool(..) |        // OutlivesScalar\n+        ty::TyChar(..) |        // OutlivesScalar\n+        ty::TyInt(..) |         // OutlivesScalar\n+        ty::TyUint(..) |        // OutlivesScalar\n+        ty::TyFloat(..) |       // OutlivesScalar\n+        ty::TyEnum(..) |        // OutlivesNominalType\n+        ty::TyStruct(..) |      // OutlivesNominalType\n+        ty::TyBox(..) |         // OutlivesNominalType (ish)\n+        ty::TyStr(..) |         // OutlivesScalar (ish)\n+        ty::TyArray(..) |       // ...\n+        ty::TySlice(..) |       // ...\n+        ty::TyRawPtr(..) |      // ...\n+        ty::TyRef(..) |         // OutlivesReference\n+        ty::TyTuple(..) |       // ...\n+        ty::TyError(..) => {\n+            push_region_constraints(out, ty.regions());\n+            for subty in ty.walk_shallow() {\n+                compute_components(infcx, subty, out);\n+            }\n+        }\n+    }\n+}\n+\n+fn capture_components<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                               ty: Ty<'tcx>)\n+                               -> Vec<Component<'tcx>> {\n+    let mut temp = vec![];\n+    push_region_constraints(&mut temp, ty.regions());\n+    for subty in ty.walk_shallow() {\n+        compute_components(infcx, subty, &mut temp);\n+    }\n+    temp\n+}\n+\n+fn push_region_constraints<'tcx>(out: &mut Vec<Component<'tcx>>, regions: Vec<ty::Region>) {\n+    for r in regions {\n+        if !r.is_bound() {\n+            out.push(Component::Region(r));\n+        }\n+    }\n+}"}, {"sha": "467c752499b36ed6b6d15004ccfda8b4b5e7ae95", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 189, "deletions": 111, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -25,11 +25,12 @@ use super::{\n \n use fmt_macros::{Parser, Piece, Position};\n use middle::infer::InferCtxt;\n-use middle::ty::{self, ToPredicate, HasTypeFlags, ToPolyTraitRef, TraitRef};\n+use middle::ty::{self, ToPredicate, HasTypeFlags, ToPolyTraitRef, TraitRef, Ty};\n use middle::ty_fold::TypeFoldable;\n use std::collections::HashMap;\n use std::fmt;\n use syntax::codemap::Span;\n+use syntax::ast;\n use syntax::attr::{AttributeMethods, AttrMetaMethods};\n \n pub fn report_fulfillment_errors<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n@@ -54,22 +55,28 @@ fn report_fulfillment_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     }\n }\n \n+fn is_warning<T>(obligation: &Obligation<T>) -> bool {\n+    obligation.cause.code.is_rfc1214()\n+}\n+\n pub fn report_projection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                          obligation: &PredicateObligation<'tcx>,\n                                          error: &MismatchedProjectionTypes<'tcx>)\n {\n     let predicate =\n         infcx.resolve_type_vars_if_possible(&obligation.predicate);\n+\n     // The TyError created by normalize_to_error can end up being unified\n     // into all obligations: for example, if our obligation is something\n     // like `$X = <() as Foo<$X>>::Out` and () does not implement Foo<_>,\n     // then $X will be unified with TyError, but the error still needs to be\n     // reported.\n     if !infcx.tcx.sess.has_errors() || !predicate.references_error() {\n-        span_err!(infcx.tcx.sess, obligation.cause.span, E0271,\n-                \"type mismatch resolving `{}`: {}\",\n-                predicate,\n-                error.err);\n+        span_err_or_warn!(\n+            is_warning(obligation), infcx.tcx.sess, obligation.cause.span, E0271,\n+            \"type mismatch resolving `{}`: {}\",\n+            predicate,\n+            error.err);\n         note_obligation_cause(infcx, obligation);\n     }\n }\n@@ -173,66 +180,90 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                         obligation: &PredicateObligation<'tcx>,\n                                         error: &SelectionError<'tcx>)\n {\n+    let is_warning = is_warning(obligation);\n     match *error {\n         SelectionError::Unimplemented => {\n-            match &obligation.cause.code {\n-                &ObligationCauseCode::CompareImplMethodObligation => {\n-                    span_err!(infcx.tcx.sess, obligation.cause.span, E0276,\n-                            \"the requirement `{}` appears on the impl \\\n-                            method but not on the corresponding trait method\",\n-                            obligation.predicate);;\n-                }\n-                _ => {\n-                    match obligation.predicate {\n-                        ty::Predicate::Trait(ref trait_predicate) => {\n-                            let trait_predicate =\n-                                infcx.resolve_type_vars_if_possible(trait_predicate);\n-\n-                            if !infcx.tcx.sess.has_errors() ||\n-                               !trait_predicate.references_error() {\n-                                let trait_ref = trait_predicate.to_poly_trait_ref();\n-                                span_err!(infcx.tcx.sess, obligation.cause.span, E0277,\n-                                        \"the trait `{}` is not implemented for the type `{}`\",\n-                                        trait_ref,\n-                                        trait_ref.self_ty());\n-                                // Check if it has a custom \"#[rustc_on_unimplemented]\"\n-                                // error message, report with that message if it does\n-                                let custom_note = report_on_unimplemented(infcx, &trait_ref.0,\n-                                                                          obligation.cause.span);\n-                                if let Some(s) = custom_note {\n-                                    infcx.tcx.sess.span_note(obligation.cause.span,\n-                                                             &s);\n-                                }\n+            if let ObligationCauseCode::CompareImplMethodObligation = obligation.cause.code {\n+                span_err_or_warn!(\n+                    is_warning, infcx.tcx.sess, obligation.cause.span, E0276,\n+                    \"the requirement `{}` appears on the impl \\\n+                     method but not on the corresponding trait method\",\n+                    obligation.predicate);;\n+            } else {\n+                match obligation.predicate {\n+                    ty::Predicate::Trait(ref trait_predicate) => {\n+                        let trait_predicate =\n+                            infcx.resolve_type_vars_if_possible(trait_predicate);\n+\n+                        if !infcx.tcx.sess.has_errors() || !trait_predicate.references_error() {\n+                            let trait_ref = trait_predicate.to_poly_trait_ref();\n+                            span_err_or_warn!(\n+                                is_warning, infcx.tcx.sess, obligation.cause.span, E0277,\n+                                \"the trait `{}` is not implemented for the type `{}`\",\n+                                trait_ref, trait_ref.self_ty());\n+\n+                            // Check if it has a custom \"#[rustc_on_unimplemented]\"\n+                            // error message, report with that message if it does\n+                            let custom_note = report_on_unimplemented(infcx, &trait_ref.0,\n+                                                                      obligation.cause.span);\n+                            if let Some(s) = custom_note {\n+                                infcx.tcx.sess.span_note(obligation.cause.span, &s);\n                             }\n+                            note_obligation_cause(infcx, obligation);\n                         }\n+                    }\n \n-                        ty::Predicate::Equate(ref predicate) => {\n-                            let predicate = infcx.resolve_type_vars_if_possible(predicate);\n-                            let err = infcx.equality_predicate(obligation.cause.span,\n-                                                               &predicate).err().unwrap();\n-                            span_err!(infcx.tcx.sess, obligation.cause.span, E0278,\n-                                    \"the requirement `{}` is not satisfied (`{}`)\",\n-                                    predicate,\n-                                    err);\n-                        }\n+                    ty::Predicate::Equate(ref predicate) => {\n+                        let predicate = infcx.resolve_type_vars_if_possible(predicate);\n+                        let err = infcx.equality_predicate(obligation.cause.span,\n+                                                           &predicate).err().unwrap();\n+                        span_err_or_warn!(\n+                            is_warning, infcx.tcx.sess, obligation.cause.span, E0278,\n+                            \"the requirement `{}` is not satisfied (`{}`)\",\n+                            predicate,\n+                            err);\n+                        note_obligation_cause(infcx, obligation);\n+                    }\n \n-                        ty::Predicate::RegionOutlives(ref predicate) => {\n-                            let predicate = infcx.resolve_type_vars_if_possible(predicate);\n-                            let err = infcx.region_outlives_predicate(obligation.cause.span,\n-                                                                      &predicate).err().unwrap();\n-                            span_err!(infcx.tcx.sess, obligation.cause.span, E0279,\n-                                    \"the requirement `{}` is not satisfied (`{}`)\",\n-                                    predicate,\n-                                    err);\n-                        }\n+                    ty::Predicate::RegionOutlives(ref predicate) => {\n+                        let predicate = infcx.resolve_type_vars_if_possible(predicate);\n+                        let err = infcx.region_outlives_predicate(obligation.cause.span,\n+                                                                  &predicate).err().unwrap();\n+                        span_err_or_warn!(\n+                            is_warning, infcx.tcx.sess, obligation.cause.span, E0279,\n+                            \"the requirement `{}` is not satisfied (`{}`)\",\n+                            predicate,\n+                            err);\n+                        note_obligation_cause(infcx, obligation);\n+                    }\n \n-                        ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n-                                let predicate =\n-                                    infcx.resolve_type_vars_if_possible(&obligation.predicate);\n-                                span_err!(infcx.tcx.sess, obligation.cause.span, E0280,\n-                                        \"the requirement `{}` is not satisfied\",\n-                                        predicate);\n-                        }\n+                    ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n+                        let predicate =\n+                            infcx.resolve_type_vars_if_possible(&obligation.predicate);\n+                        span_err_or_warn!(\n+                            is_warning, infcx.tcx.sess, obligation.cause.span, E0280,\n+                            \"the requirement `{}` is not satisfied\",\n+                            predicate);\n+                        note_obligation_cause(infcx, obligation);\n+                    }\n+\n+                    ty::Predicate::ObjectSafe(trait_def_id) => {\n+                        report_object_safety_error(infcx.tcx,\n+                                                   obligation.cause.span,\n+                                                   trait_def_id,\n+                                                   is_warning);\n+                        note_obligation_cause(infcx, obligation);\n+                    }\n+\n+                    ty::Predicate::WellFormed(ty) => {\n+                        // WF predicates cannot themselves make\n+                        // errors. They can only block due to\n+                        // ambiguity; otherwise, they always\n+                        // degenerate into other obligations\n+                        // (which may fail).\n+                        infcx.tcx.sess.span_bug(\n+                            obligation.cause.span,\n+                            &format!(\"WF predicate not satisfied for {:?}\", ty));\n                     }\n                 }\n             }\n@@ -242,62 +273,73 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n             let expected_trait_ref = infcx.resolve_type_vars_if_possible(&*expected_trait_ref);\n             let actual_trait_ref = infcx.resolve_type_vars_if_possible(&*actual_trait_ref);\n             if !actual_trait_ref.self_ty().references_error() {\n-                span_err!(infcx.tcx.sess, obligation.cause.span, E0281,\n-                        \"type mismatch: the type `{}` implements the trait `{}`, \\\n-                        but the trait `{}` is required ({})\",\n-                        expected_trait_ref.self_ty(),\n-                        expected_trait_ref,\n-                        actual_trait_ref,\n-                        e);\n-                    note_obligation_cause(infcx, obligation);\n+                span_err_or_warn!(\n+                    is_warning, infcx.tcx.sess, obligation.cause.span, E0281,\n+                    \"type mismatch: the type `{}` implements the trait `{}`, \\\n+                     but the trait `{}` is required ({})\",\n+                    expected_trait_ref.self_ty(),\n+                    expected_trait_ref,\n+                    actual_trait_ref,\n+                    e);\n+                note_obligation_cause(infcx, obligation);\n             }\n         }\n \n         TraitNotObjectSafe(did) => {\n-            span_err!(infcx.tcx.sess, obligation.cause.span, E0038,\n-                \"cannot convert to a trait object because trait `{}` is not object-safe\",\n-                infcx.tcx.item_path_str(did));\n-\n-            for violation in object_safety_violations(infcx.tcx, did) {\n-                match violation {\n-                    ObjectSafetyViolation::SizedSelf => {\n-                        infcx.tcx.sess.span_note(\n-                            obligation.cause.span,\n-                            \"the trait cannot require that `Self : Sized`\");\n-                    }\n+            report_object_safety_error(infcx.tcx, obligation.cause.span, did, is_warning);\n+            note_obligation_cause(infcx, obligation);\n+        }\n+    }\n+}\n \n-                    ObjectSafetyViolation::SupertraitSelf => {\n-                        infcx.tcx.sess.span_note(\n-                            obligation.cause.span,\n-                            \"the trait cannot use `Self` as a type parameter \\\n-                            in the supertrait listing\");\n-                    }\n+pub fn report_object_safety_error<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                        span: Span,\n+                                        trait_def_id: ast::DefId,\n+                                        is_warning: bool)\n+{\n+    span_err_or_warn!(\n+        is_warning, tcx.sess, span, E0038,\n+        \"the trait `{}` cannot be made into an object\",\n+        tcx.item_path_str(trait_def_id));\n \n-                    ObjectSafetyViolation::Method(method,\n-                            MethodViolationCode::StaticMethod) => {\n-                        infcx.tcx.sess.span_note(\n-                            obligation.cause.span,\n-                            &format!(\"method `{}` has no receiver\",\n-                                    method.name));\n-                    }\n+    for violation in object_safety_violations(tcx, trait_def_id) {\n+        match violation {\n+            ObjectSafetyViolation::SizedSelf => {\n+                tcx.sess.span_note(\n+                    span,\n+                    \"the trait cannot require that `Self : Sized`\");\n+            }\n \n-                    ObjectSafetyViolation::Method(method,\n-                            MethodViolationCode::ReferencesSelf) => {\n-                        infcx.tcx.sess.span_note(\n-                            obligation.cause.span,\n-                            &format!(\"method `{}` references the `Self` type \\\n-                                    in its arguments or return type\",\n-                                    method.name));\n-                    }\n+            ObjectSafetyViolation::SupertraitSelf => {\n+                tcx.sess.span_note(\n+                    span,\n+                    \"the trait cannot use `Self` as a type parameter \\\n+                     in the supertrait listing\");\n+            }\n \n-                    ObjectSafetyViolation::Method(method,\n-                            MethodViolationCode::Generic) => {\n-                        infcx.tcx.sess.span_note(\n-                            obligation.cause.span,\n-                            &format!(\"method `{}` has generic type parameters\",\n-                                    method.name));\n-                    }\n-                }\n+            ObjectSafetyViolation::Method(method,\n+                                          MethodViolationCode::StaticMethod) => {\n+                tcx.sess.span_note(\n+                    span,\n+                    &format!(\"method `{}` has no receiver\",\n+                             method.name));\n+            }\n+\n+            ObjectSafetyViolation::Method(method,\n+                                          MethodViolationCode::ReferencesSelf) => {\n+                tcx.sess.span_note(\n+                    span,\n+                    &format!(\"method `{}` references the `Self` type \\\n+                              in its arguments or return type\",\n+                             method.name));\n+            }\n+\n+            ObjectSafetyViolation::Method(method,\n+                                          MethodViolationCode::Generic) => {\n+                tcx.sess.span_note(\n+                    span,\n+                    &format!(\"method `{}` has generic type parameters\",\n+                             method.name));\n             }\n         }\n     }\n@@ -342,14 +384,11 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                         infcx.tcx.lang_items.sized_trait()\n                         .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n                     {\n-                        span_err!(infcx.tcx.sess, obligation.cause.span, E0282,\n-                                \"unable to infer enough type information about `{}`; \\\n-                                 type annotations or generic parameter binding required\",\n-                                self_ty);\n+                        need_type_info(infcx, obligation.cause.span, self_ty);\n                     } else {\n                         span_err!(infcx.tcx.sess, obligation.cause.span, E0283,\n                                 \"type annotations required: cannot resolve `{}`\",\n-                                predicate);;\n+                                predicate);\n                         note_obligation_cause(infcx, obligation);\n                     }\n                 }\n@@ -366,6 +405,14 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n             }\n         }\n \n+        ty::Predicate::WellFormed(ty) => {\n+            // Same hacky approach as above to avoid deluging user\n+            // with error messages.\n+            if !ty.references_error() && !infcx.tcx.sess.has_errors() {\n+                need_type_info(infcx, obligation.cause.span, ty);\n+            }\n+        }\n+\n         _ => {\n             if !infcx.tcx.sess.has_errors() {\n                 span_err!(infcx.tcx.sess, obligation.cause.span, E0284,\n@@ -377,6 +424,16 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     }\n }\n \n+fn need_type_info<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                            span: Span,\n+                            ty: Ty<'tcx>)\n+{\n+    span_err!(infcx.tcx.sess, span, E0282,\n+              \"unable to infer enough type information about `{}`; \\\n+               type annotations or generic parameter binding required\",\n+              ty);\n+}\n+\n fn note_obligation_cause<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n                                       obligation: &Obligation<'tcx, T>)\n     where T: fmt::Display\n@@ -396,6 +453,27 @@ fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n     let tcx = infcx.tcx;\n     match *cause_code {\n         ObligationCauseCode::MiscObligation => { }\n+        ObligationCauseCode::RFC1214(ref subcode) => {\n+            tcx.sess.note_rfc_1214(cause_span);\n+            note_obligation_cause_code(infcx, predicate, cause_span, subcode);\n+        }\n+        ObligationCauseCode::SliceOrArrayElem => {\n+            tcx.sess.span_note(\n+                cause_span,\n+                &format!(\"slice and array elements must have `Sized` type\"));\n+        }\n+        ObligationCauseCode::ProjectionWf(data) => {\n+            tcx.sess.span_note(\n+                cause_span,\n+                &format!(\"required so that the projection `{}` is well-formed\",\n+                         data));\n+        }\n+        ObligationCauseCode::ReferenceOutlivesReferent(ref_ty) => {\n+            tcx.sess.span_note(\n+                cause_span,\n+                &format!(\"required so that reference `{}` does not outlive its referent\",\n+                         ref_ty));\n+        }\n         ObligationCauseCode::ItemObligation(item_def_id) => {\n             let item_name = tcx.item_path_str(item_def_id);\n             tcx.sess.span_note("}, {"sha": "1fca66f1379189ac3b205e199f457e33dded7cce", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 53, "deletions": 14, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -10,6 +10,7 @@\n \n use middle::infer::InferCtxt;\n use middle::ty::{self, RegionEscape, Ty, HasTypeFlags};\n+use middle::wf;\n \n use std::collections::HashSet;\n use std::fmt;\n@@ -20,16 +21,19 @@ use util::nodemap::NodeMap;\n use super::CodeAmbiguity;\n use super::CodeProjectionError;\n use super::CodeSelectionError;\n+use super::is_object_safe;\n use super::FulfillmentError;\n use super::ObligationCause;\n+use super::ObligationCauseCode;\n use super::PredicateObligation;\n use super::project;\n+use super::RFC1214Warning;\n use super::select::SelectionContext;\n use super::Unimplemented;\n use super::util::predicate_for_builtin_bound;\n \n pub struct FulfilledPredicates<'tcx> {\n-    set: HashSet<ty::Predicate<'tcx>>\n+    set: HashSet<(RFC1214Warning, ty::Predicate<'tcx>)>\n }\n \n /// The fulfillment context is used to drive trait resolution.  It\n@@ -187,7 +191,9 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n         assert!(!obligation.has_escaping_regions());\n \n-        if self.is_duplicate_or_add(infcx.tcx, &obligation.predicate) {\n+        let w = RFC1214Warning(obligation.cause.code.is_rfc1214());\n+\n+        if self.is_duplicate_or_add(infcx.tcx, w, &obligation.predicate) {\n             debug!(\"register_predicate({:?}) -- already seen, skip\", obligation);\n             return;\n         }\n@@ -250,7 +256,9 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         &self.predicates\n     }\n \n-    fn is_duplicate_or_add(&mut self, tcx: &ty::ctxt<'tcx>,\n+    fn is_duplicate_or_add(&mut self,\n+                           tcx: &ty::ctxt<'tcx>,\n+                           w: RFC1214Warning,\n                            predicate: &ty::Predicate<'tcx>)\n                            -> bool {\n         // This is a kind of dirty hack to allow us to avoid \"rederiving\"\n@@ -265,10 +273,12 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         // evaluating the 'nested obligations'.  This cache lets us\n         // skip those.\n \n-        if self.errors_will_be_reported && predicate.is_global() {\n-            tcx.fulfilled_predicates.borrow_mut().is_duplicate_or_add(predicate)\n+        let will_warn_due_to_rfc1214 = w.0;\n+        let errors_will_be_reported = self.errors_will_be_reported && !will_warn_due_to_rfc1214;\n+        if errors_will_be_reported && predicate.is_global() {\n+            tcx.fulfilled_predicates.borrow_mut().is_duplicate_or_add(w, predicate)\n         } else {\n-            self.duplicate_set.is_duplicate_or_add(predicate)\n+            self.duplicate_set.is_duplicate_or_add(w, predicate)\n         }\n     }\n \n@@ -472,6 +482,32 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                 }\n             }\n         }\n+\n+        ty::Predicate::ObjectSafe(trait_def_id) => {\n+            if !is_object_safe(selcx.tcx(), trait_def_id) {\n+                errors.push(FulfillmentError::new(\n+                    obligation.clone(),\n+                    CodeSelectionError(Unimplemented)));\n+            }\n+            true\n+        }\n+\n+        ty::Predicate::WellFormed(ty) => {\n+            let rfc1214 = match obligation.cause.code {\n+                ObligationCauseCode::RFC1214(_) => true,\n+                _ => false,\n+            };\n+            match wf::obligations(selcx.infcx(), obligation.cause.body_id,\n+                                  ty, obligation.cause.span, rfc1214) {\n+                Some(obligations) => {\n+                    new_obligations.extend(obligations);\n+                    true\n+                }\n+                None => {\n+                    false\n+                }\n+            }\n+        }\n     }\n }\n \n@@ -492,11 +528,12 @@ fn register_region_obligation<'tcx>(t_a: Ty<'tcx>,\n                                                sub_region: r_b,\n                                                cause: cause };\n \n-    debug!(\"register_region_obligation({:?})\",\n-           region_obligation);\n+    debug!(\"register_region_obligation({:?}, cause={:?})\",\n+           region_obligation, region_obligation.cause);\n \n-    region_obligations.entry(region_obligation.cause.body_id).or_insert(vec![])\n-        .push(region_obligation);\n+    region_obligations.entry(region_obligation.cause.body_id)\n+                      .or_insert(vec![])\n+                      .push(region_obligation);\n \n }\n \n@@ -507,11 +544,13 @@ impl<'tcx> FulfilledPredicates<'tcx> {\n         }\n     }\n \n-    pub fn is_duplicate(&self, p: &ty::Predicate<'tcx>) -> bool {\n-        self.set.contains(p)\n+    pub fn is_duplicate(&self, w: RFC1214Warning, p: &ty::Predicate<'tcx>) -> bool {\n+        let key = (w, p.clone());\n+        self.set.contains(&key)\n     }\n \n-    fn is_duplicate_or_add(&mut self, p: &ty::Predicate<'tcx>) -> bool {\n-        !self.set.insert(p.clone())\n+    fn is_duplicate_or_add(&mut self, w: RFC1214Warning, p: &ty::Predicate<'tcx>) -> bool {\n+        let key = (w, p.clone());\n+        !self.set.insert(key)\n     }\n }"}, {"sha": "6c501b1a609c4feeae55abe9e0e65d357f71b1d7", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -27,6 +27,7 @@ use syntax::codemap::{Span, DUMMY_SP};\n pub use self::error_reporting::report_fulfillment_errors;\n pub use self::error_reporting::report_overflow_error;\n pub use self::error_reporting::report_selection_error;\n+pub use self::error_reporting::report_object_safety_error;\n pub use self::error_reporting::suggest_new_overflow_limit;\n pub use self::coherence::orphan_check;\n pub use self::coherence::overlapping_impls;\n@@ -80,7 +81,7 @@ pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n \n /// Why did we incur this obligation? Used for error reporting.\n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub struct ObligationCause<'tcx> {\n     pub span: Span,\n \n@@ -95,15 +96,27 @@ pub struct ObligationCause<'tcx> {\n     pub code: ObligationCauseCode<'tcx>\n }\n \n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub enum ObligationCauseCode<'tcx> {\n     /// Not well classified or should be obvious from span.\n     MiscObligation,\n \n+    /// Obligation that triggers warning until RFC 1214 is fully in place.\n+    RFC1214(Rc<ObligationCauseCode<'tcx>>),\n+\n+    /// This is the trait reference from the given projection\n+    SliceOrArrayElem,\n+\n+    /// This is the trait reference from the given projection\n+    ProjectionWf(ty::ProjectionTy<'tcx>),\n+\n     /// In an impl of trait X for type Y, type Y must\n     /// also implement all supertraits of X.\n     ItemObligation(ast::DefId),\n \n+    /// A type like `&'a T` is WF only if `T: 'a`.\n+    ReferenceOutlivesReferent(Ty<'tcx>),\n+\n     /// Obligation incurred due to an object cast.\n     ObjectCastObligation(/* Object type */ Ty<'tcx>),\n \n@@ -124,15 +137,14 @@ pub enum ObligationCauseCode<'tcx> {\n     // static items must have `Sync` type\n     SharedStatic,\n \n-\n     BuiltinDerivedObligation(DerivedObligationCause<'tcx>),\n \n     ImplDerivedObligation(DerivedObligationCause<'tcx>),\n \n     CompareImplMethodObligation,\n }\n \n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub struct DerivedObligationCause<'tcx> {\n     /// The trait reference of the parent obligation that led to the\n     /// current obligation. Note that only trait obligations lead to\n@@ -516,6 +528,24 @@ impl<'tcx> ObligationCause<'tcx> {\n     }\n }\n \n+/// This marker is used in some caches to record whether the\n+/// predicate, if it is found to be false, will yield a warning (due\n+/// to RFC1214) or an error. We separate these two cases in the cache\n+/// so that if we see the same predicate twice, first resulting in a\n+/// warning, and next resulting in an error, we still report the\n+/// error, rather than considering it a duplicate.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct RFC1214Warning(bool);\n+\n+impl<'tcx> ObligationCauseCode<'tcx> {\n+    pub fn is_rfc1214(&self) -> bool {\n+        match *self {\n+            ObligationCauseCode::RFC1214(..) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n impl<'tcx, N> Vtable<'tcx, N> {\n     pub fn nested_obligations(self) -> Vec<N> {\n         match self {"}, {"sha": "9d300c0973167dc3c2a2c5237c2635424de49ed6", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -40,7 +40,7 @@ pub enum ObjectSafetyViolation<'tcx> {\n }\n \n /// Reasons a method might not be object-safe.\n-#[derive(Copy,Clone,Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum MethodViolationCode {\n     /// e.g., `fn foo()`\n     StaticMethod,\n@@ -140,6 +140,8 @@ fn supertraits_reference_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                  .any(is_self)\n                 }\n                 ty::Predicate::Projection(..) |\n+                ty::Predicate::WellFormed(..) |\n+                ty::Predicate::ObjectSafe(..) |\n                 ty::Predicate::TypeOutlives(..) |\n                 ty::Predicate::RegionOutlives(..) |\n                 ty::Predicate::Equate(..) => {\n@@ -181,6 +183,8 @@ fn generics_require_sized_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n                 ty::Predicate::Trait(..) |\n                 ty::Predicate::Equate(..) |\n                 ty::Predicate::RegionOutlives(..) |\n+                ty::Predicate::WellFormed(..) |\n+                ty::Predicate::ObjectSafe(..) |\n                 ty::Predicate::TypeOutlives(..) => {\n                     false\n                 }"}, {"sha": "f63523b77d60f64cb0ff04d965263f88a27c6b9f", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 39, "deletions": 7, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -27,6 +27,7 @@ use super::{ObligationCauseCode, BuiltinDerivedObligation, ImplDerivedObligation\n use super::{SelectionError, Unimplemented, OutputTypeParameterMismatch};\n use super::{ObjectCastObligation, Obligation};\n use super::TraitNotObjectSafe;\n+use super::RFC1214Warning;\n use super::Selection;\n use super::SelectionResult;\n use super::{VtableBuiltin, VtableImpl, VtableParam, VtableClosure,\n@@ -44,6 +45,7 @@ use middle::infer::{InferCtxt, TypeFreshener};\n use middle::ty_fold::TypeFoldable;\n use middle::ty_match;\n use middle::ty_relate::TypeRelation;\n+use middle::wf;\n \n use std::cell::RefCell;\n use std::fmt;\n@@ -444,7 +446,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // have been proven elsewhere. This cache only contains\n         // predicates that are global in scope and hence unaffected by\n         // the current environment.\n-        if self.tcx().fulfilled_predicates.borrow().is_duplicate(&obligation.predicate) {\n+        let w = RFC1214Warning(false);\n+        if self.tcx().fulfilled_predicates.borrow().is_duplicate(w, &obligation.predicate) {\n             return EvaluatedToOk;\n         }\n \n@@ -465,12 +468,31 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n+            ty::Predicate::WellFormed(ty) => {\n+                match wf::obligations(self.infcx, obligation.cause.body_id,\n+                                      ty, obligation.cause.span,\n+                                      obligation.cause.code.is_rfc1214()) {\n+                    Some(obligations) =>\n+                        self.evaluate_predicates_recursively(previous_stack, obligations.iter()),\n+                    None =>\n+                        EvaluatedToAmbig,\n+                }\n+            }\n+\n             ty::Predicate::TypeOutlives(..) | ty::Predicate::RegionOutlives(..) => {\n                 // we do not consider region relationships when\n                 // evaluating trait matches\n                 EvaluatedToOk\n             }\n \n+            ty::Predicate::ObjectSafe(trait_def_id) => {\n+                if object_safety::is_object_safe(self.tcx(), trait_def_id) {\n+                    EvaluatedToOk\n+                } else {\n+                    EvaluatedToErr(Unimplemented)\n+                }\n+            }\n+\n             ty::Predicate::Projection(ref data) => {\n                 self.infcx.probe(|_| {\n                     let project_obligation = obligation.with(data.clone());\n@@ -2900,13 +2922,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // chain. Ideally, we should have a way to configure this either\n         // by using -Z verbose or just a CLI argument.\n         if obligation.recursion_depth >= 0 {\n-            let derived_cause = DerivedObligationCause {\n-                parent_trait_ref: obligation.predicate.to_poly_trait_ref(),\n-                parent_code: Rc::new(obligation.cause.code.clone()),\n+            let derived_code = match obligation.cause.code {\n+                ObligationCauseCode::RFC1214(ref base_code) => {\n+                    let derived_cause = DerivedObligationCause {\n+                        parent_trait_ref: obligation.predicate.to_poly_trait_ref(),\n+                        parent_code: base_code.clone(),\n+                    };\n+                    ObligationCauseCode::RFC1214(Rc::new(variant(derived_cause)))\n+                }\n+                _ => {\n+                    let derived_cause = DerivedObligationCause {\n+                        parent_trait_ref: obligation.predicate.to_poly_trait_ref(),\n+                        parent_code: Rc::new(obligation.cause.code.clone())\n+                    };\n+                    variant(derived_cause)\n+                }\n             };\n-            ObligationCause::new(obligation.cause.span,\n-                                 obligation.cause.body_id,\n-                                 variant(derived_cause))\n+            ObligationCause::new(obligation.cause.span, obligation.cause.body_id, derived_code)\n         } else {\n             obligation.cause.clone()\n         }"}, {"sha": "6df13a3bdaf554c8bd106cdd689d8f4204068970", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -10,7 +10,7 @@\n \n use middle::subst::Substs;\n use middle::infer::InferCtxt;\n-use middle::ty::{self, Ty, ToPredicate, ToPolyTraitRef};\n+use middle::ty::{self, HasTypeFlags, Ty, ToPredicate, ToPolyTraitRef};\n use std::fmt;\n use syntax::ast;\n use syntax::codemap::Span;\n@@ -56,6 +56,12 @@ impl<'a,'tcx> PredicateSet<'a,'tcx> {\n \n             ty::Predicate::Projection(ref data) =>\n                 ty::Predicate::Projection(self.tcx.anonymize_late_bound_regions(data)),\n+\n+            ty::Predicate::WellFormed(data) =>\n+                ty::Predicate::WellFormed(data),\n+\n+            ty::Predicate::ObjectSafe(data) =>\n+                ty::Predicate::ObjectSafe(data),\n         };\n         self.set.insert(normalized_pred)\n     }\n@@ -136,6 +142,14 @@ impl<'cx, 'tcx> Elaborator<'cx, 'tcx> {\n \n                 self.stack.extend(predicates);\n             }\n+            ty::Predicate::WellFormed(..) => {\n+                // Currently, we do not elaborate WF predicates,\n+                // although we easily could.\n+            }\n+            ty::Predicate::ObjectSafe(..) => {\n+                // Currently, we do not elaborate object-safe\n+                // predicates.\n+            }\n             ty::Predicate::Equate(..) => {\n                 // Currently, we do not \"elaborate\" predicates like\n                 // `X == Y`, though conceivably we might. For example,\n@@ -562,3 +576,9 @@ impl<'tcx> fmt::Debug for super::MismatchedProjectionTypes<'tcx> {\n         write!(f, \"MismatchedProjectionTypes({:?})\", self.err)\n     }\n }\n+\n+impl<'tcx, T: HasTypeFlags> HasTypeFlags for Obligation<'tcx, T> {\n+    fn has_type_flags(&self, flags: ty::TypeFlags) -> bool {\n+        self.predicate.has_type_flags(flags)\n+    }\n+}"}, {"sha": "49bf0e580b9e0f3398f7e41b791114377c506671", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 169, "deletions": 45, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -1670,6 +1670,13 @@ impl Region {\n         }\n     }\n \n+    pub fn needs_infer(&self) -> bool {\n+        match *self {\n+            ty::ReInfer(..) => true,\n+            _ => false\n+        }\n+    }\n+\n     pub fn escapes_depth(&self, depth: u32) -> bool {\n         match *self {\n             ty::ReLateBound(debruijn, _) => debruijn.depth > depth,\n@@ -2410,6 +2417,12 @@ pub enum Predicate<'tcx> {\n     /// where <T as TraitRef>::Name == X, approximately.\n     /// See `ProjectionPredicate` struct for details.\n     Projection(PolyProjectionPredicate<'tcx>),\n+\n+    /// no syntax: T WF\n+    WellFormed(Ty<'tcx>),\n+\n+    /// trait must be object-safe\n+    ObjectSafe(ast::DefId),\n }\n \n impl<'tcx> Predicate<'tcx> {\n@@ -2495,6 +2508,10 @@ impl<'tcx> Predicate<'tcx> {\n                 Predicate::TypeOutlives(ty::Binder(data.subst(tcx, substs))),\n             Predicate::Projection(ty::Binder(ref data)) =>\n                 Predicate::Projection(ty::Binder(data.subst(tcx, substs))),\n+            Predicate::WellFormed(data) =>\n+                Predicate::WellFormed(data.subst(tcx, substs)),\n+            Predicate::ObjectSafe(trait_def_id) =>\n+                Predicate::ObjectSafe(trait_def_id),\n         }\n     }\n }\n@@ -2567,7 +2584,7 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n \n /// Represents the projection of an associated type. In explicit UFCS\n /// form this would be written `<T as Trait<..>>::N`.\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct ProjectionTy<'tcx> {\n     /// The trait reference `T as Trait<..>`.\n     pub trait_ref: ty::TraitRef<'tcx>,\n@@ -2682,6 +2699,12 @@ impl<'tcx> Predicate<'tcx> {\n                             .chain(Some(data.0.ty))\n                             .collect()\n             }\n+            ty::Predicate::WellFormed(data) => {\n+                vec![data]\n+            }\n+            ty::Predicate::ObjectSafe(_trait_def_id) => {\n+                vec![]\n+            }\n         };\n \n         // The only reason to collect into a vector here is that I was\n@@ -2699,6 +2722,8 @@ impl<'tcx> Predicate<'tcx> {\n             Predicate::RegionOutlives(ref p) => p.has_escaping_regions(),\n             Predicate::TypeOutlives(ref p) => p.has_escaping_regions(),\n             Predicate::Projection(ref p) => p.has_escaping_regions(),\n+            Predicate::WellFormed(p) => p.has_escaping_regions(),\n+            Predicate::ObjectSafe(_trait_def_id) => false,\n         }\n     }\n \n@@ -2710,6 +2735,8 @@ impl<'tcx> Predicate<'tcx> {\n             Predicate::Projection(..) |\n             Predicate::Equate(..) |\n             Predicate::RegionOutlives(..) |\n+            Predicate::WellFormed(..) |\n+            Predicate::ObjectSafe(..) |\n             Predicate::TypeOutlives(..) => {\n                 None\n             }\n@@ -2806,6 +2833,15 @@ pub struct ParameterEnvironment<'a, 'tcx:'a> {\n     /// Caches the results of trait selection. This cache is used\n     /// for things that have to do with the parameters in scope.\n     pub selection_cache: traits::SelectionCache<'tcx>,\n+\n+    /// Scope that is attached to free regions for this scope. This\n+    /// is usually the id of the fn body, but for more abstract scopes\n+    /// like structs we often use the node-id of the struct.\n+    ///\n+    /// FIXME(#3696). It would be nice to refactor so that free\n+    /// regions don't have this implicit scope and instead introduce\n+    /// relationships in the environment.\n+    pub free_id: ast::NodeId,\n }\n \n impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n@@ -2819,13 +2855,26 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n             implicit_region_bound: self.implicit_region_bound,\n             caller_bounds: caller_bounds,\n             selection_cache: traits::SelectionCache::new(),\n+            free_id: self.free_id,\n         }\n     }\n \n     pub fn for_item(cx: &'a ctxt<'tcx>, id: NodeId) -> ParameterEnvironment<'a, 'tcx> {\n         match cx.map.find(id) {\n             Some(ast_map::NodeImplItem(ref impl_item)) => {\n                 match impl_item.node {\n+                    ast::TypeImplItem(_) => {\n+                        // associated types don't have their own entry (for some reason),\n+                        // so for now just grab environment for the impl\n+                        let impl_id = cx.map.get_parent(id);\n+                        let impl_def_id = ast_util::local_def(impl_id);\n+                        let scheme = cx.lookup_item_type(impl_def_id);\n+                        let predicates = cx.lookup_predicates(impl_def_id);\n+                        cx.construct_parameter_environment(impl_item.span,\n+                                                           &scheme.generics,\n+                                                           &predicates,\n+                                                           id)\n+                    }\n                     ast::ConstImplItem(_, _) => {\n                         let def_id = ast_util::local_def(id);\n                         let scheme = cx.lookup_item_type(def_id);\n@@ -2854,42 +2903,37 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                             }\n                         }\n                     }\n-                    ast::TypeImplItem(_) => {\n-                        cx.sess.bug(\"ParameterEnvironment::for_item(): \\\n-                                     can't create a parameter environment \\\n-                                     for type impl items\")\n-                    }\n                     ast::MacImplItem(_) => cx.sess.bug(\"unexpanded macro\")\n                 }\n             }\n             Some(ast_map::NodeTraitItem(trait_item)) => {\n                 match trait_item.node {\n-                    ast::ConstTraitItem(_, ref default) => {\n-                        match *default {\n-                            Some(_) => {\n-                                let def_id = ast_util::local_def(id);\n-                                let scheme = cx.lookup_item_type(def_id);\n-                                let predicates = cx.lookup_predicates(def_id);\n-                                cx.construct_parameter_environment(trait_item.span,\n-                                                                   &scheme.generics,\n-                                                                   &predicates,\n-                                                                   id)\n-                            }\n-                            None => {\n-                                cx.sess.bug(\"ParameterEnvironment::from_item(): \\\n-                                             can't create a parameter environment \\\n-                                             for const trait items without defaults\")\n-                            }\n-                        }\n+                    ast::TypeTraitItem(..) => {\n+                        // associated types don't have their own entry (for some reason),\n+                        // so for now just grab environment for the trait\n+                        let trait_id = cx.map.get_parent(id);\n+                        let trait_def_id = ast_util::local_def(trait_id);\n+                        let trait_def = cx.lookup_trait_def(trait_def_id);\n+                        let predicates = cx.lookup_predicates(trait_def_id);\n+                        cx.construct_parameter_environment(trait_item.span,\n+                                                           &trait_def.generics,\n+                                                           &predicates,\n+                                                           id)\n                     }\n-                    ast::MethodTraitItem(_, None) => {\n-                        cx.sess.span_bug(trait_item.span,\n-                                         \"ParameterEnvironment::for_item():\n-                                          can't create a parameter \\\n-                                          environment for required trait \\\n-                                          methods\")\n+                    ast::ConstTraitItem(..) => {\n+                        let def_id = ast_util::local_def(id);\n+                        let scheme = cx.lookup_item_type(def_id);\n+                        let predicates = cx.lookup_predicates(def_id);\n+                        cx.construct_parameter_environment(trait_item.span,\n+                                                           &scheme.generics,\n+                                                           &predicates,\n+                                                           id)\n                     }\n-                    ast::MethodTraitItem(_, Some(ref body)) => {\n+                    ast::MethodTraitItem(_, ref body) => {\n+                        // for the body-id, use the id of the body\n+                        // block, unless this is a trait method with\n+                        // no default, then fallback to the method id.\n+                        let body_id = body.as_ref().map(|b| b.id).unwrap_or(id);\n                         let method_def_id = ast_util::local_def(id);\n                         match cx.impl_or_trait_item(method_def_id) {\n                             MethodTraitItem(ref method_ty) => {\n@@ -2899,7 +2943,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                     trait_item.span,\n                                     method_generics,\n                                     method_bounds,\n-                                    body.id)\n+                                    body_id)\n                             }\n                             _ => {\n                                 cx.sess\n@@ -2909,11 +2953,6 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                             }\n                         }\n                     }\n-                    ast::TypeTraitItem(..) => {\n-                        cx.sess.bug(\"ParameterEnvironment::from_item(): \\\n-                                     can't create a parameter environment \\\n-                                     for type trait items\")\n-                    }\n                 }\n             }\n             Some(ast_map::NodeItem(item)) => {\n@@ -2942,6 +2981,15 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                                            &predicates,\n                                                            id)\n                     }\n+                    ast::ItemTrait(..) => {\n+                        let def_id = ast_util::local_def(id);\n+                        let trait_def = cx.lookup_trait_def(def_id);\n+                        let predicates = cx.lookup_predicates(def_id);\n+                        cx.construct_parameter_environment(item.span,\n+                                                           &trait_def.generics,\n+                                                           &predicates,\n+                                                           id)\n+                    }\n                     _ => {\n                         cx.sess.span_bug(item.span,\n                                          \"ParameterEnvironment::from_item():\n@@ -4144,6 +4192,49 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n+    /// Returns the regions directly referenced from this type (but\n+    /// not types reachable from this type via `walk_tys`). This\n+    /// ignores late-bound regions binders.\n+    pub fn regions(&self) -> Vec<ty::Region> {\n+        match self.sty {\n+            TyRef(region, _) => {\n+                vec![*region]\n+            }\n+            TyTrait(ref obj) => {\n+                let mut v = vec![obj.bounds.region_bound];\n+                v.push_all(obj.principal.skip_binder().substs.regions().as_slice());\n+                v\n+            }\n+            TyEnum(_, substs) |\n+            TyStruct(_, substs) => {\n+                substs.regions().as_slice().to_vec()\n+            }\n+            TyClosure(_, ref substs) => {\n+                substs.func_substs.regions().as_slice().to_vec()\n+            }\n+            TyProjection(ref data) => {\n+                data.trait_ref.substs.regions().as_slice().to_vec()\n+            }\n+            TyBareFn(..) |\n+            TyBool |\n+            TyChar |\n+            TyInt(_) |\n+            TyUint(_) |\n+            TyFloat(_) |\n+            TyBox(_) |\n+            TyStr |\n+            TyArray(_, _) |\n+            TySlice(_) |\n+            TyRawPtr(_) |\n+            TyTuple(_) |\n+            TyParam(_) |\n+            TyInfer(_) |\n+            TyError => {\n+                vec![]\n+            }\n+        }\n+    }\n+\n     /// Walks `ty` and any types appearing within `ty`, invoking the\n     /// callback `f` on each type. If the callback returns false, then the\n     /// children of the current type are ignored.\n@@ -6142,13 +6233,18 @@ impl<'tcx> ctxt<'tcx> {\n     /// themselves. This should really be a unique type; `FreshTy(0)` is a\n     /// popular choice.\n     ///\n+    /// NB: in some cases, particularly around higher-ranked bounds,\n+    /// this function returns a kind of conservative approximation.\n+    /// That is, all regions returned by this function are definitely\n+    /// required, but there may be other region bounds that are not\n+    /// returned, as well as requirements like `for<'a> T: 'a`.\n+    ///\n     /// Requires that trait definitions have been processed so that we can\n     /// elaborate predicates and walk supertraits.\n     pub fn required_region_bounds(&self,\n                                   erased_self_ty: Ty<'tcx>,\n                                   predicates: Vec<ty::Predicate<'tcx>>)\n-                                  -> Vec<ty::Region>\n-    {\n+                                  -> Vec<ty::Region>    {\n         debug!(\"required_region_bounds(erased_self_ty={:?}, predicates={:?})\",\n                erased_self_ty,\n                predicates);\n@@ -6161,6 +6257,8 @@ impl<'tcx> ctxt<'tcx> {\n                     ty::Predicate::Projection(..) |\n                     ty::Predicate::Trait(..) |\n                     ty::Predicate::Equate(..) |\n+                    ty::Predicate::WellFormed(..) |\n+                    ty::Predicate::ObjectSafe(..) |\n                     ty::Predicate::RegionOutlives(..) => {\n                         None\n                     }\n@@ -6175,11 +6273,7 @@ impl<'tcx> ctxt<'tcx> {\n                         // construct such an object, but this seems\n                         // correct even if that code changes).\n                         if t == erased_self_ty && !r.has_escaping_regions() {\n-                            if r.has_escaping_regions() {\n-                                Some(ty::ReStatic)\n-                            } else {\n-                                Some(r)\n-                            }\n+                            Some(r)\n                         } else {\n                             None\n                         }\n@@ -6515,12 +6609,19 @@ impl<'tcx> ctxt<'tcx> {\n \n     /// Construct a parameter environment suitable for static contexts or other contexts where there\n     /// are no free type/lifetime parameters in scope.\n-    pub fn empty_parameter_environment<'a>(&'a self) -> ParameterEnvironment<'a,'tcx> {\n+    pub fn empty_parameter_environment<'a>(&'a self)\n+                                           -> ParameterEnvironment<'a,'tcx> {\n         ty::ParameterEnvironment { tcx: self,\n                                    free_substs: Substs::empty(),\n                                    caller_bounds: Vec::new(),\n                                    implicit_region_bound: ty::ReEmpty,\n-                                   selection_cache: traits::SelectionCache::new(), }\n+                                   selection_cache: traits::SelectionCache::new(),\n+\n+                                   // for an empty parameter\n+                                   // environment, there ARE no free\n+                                   // regions, so it shouldn't matter\n+                                   // what we use for the free id\n+                                   free_id: ast::DUMMY_NODE_ID }\n     }\n \n     /// Constructs and returns a substitution that can be applied to move from\n@@ -6604,6 +6705,7 @@ impl<'tcx> ctxt<'tcx> {\n             implicit_region_bound: ty::ReScope(free_id_outlive.to_code_extent()),\n             caller_bounds: predicates,\n             selection_cache: traits::SelectionCache::new(),\n+            free_id: free_id,\n         };\n \n         let cause = traits::ObligationCause::misc(span, free_id);\n@@ -6662,6 +6764,8 @@ impl<'tcx> ctxt<'tcx> {\n                     ty::Predicate::Equate(..) |\n                     ty::Predicate::RegionOutlives(..) |\n                     ty::Predicate::TypeOutlives(..) |\n+                    ty::Predicate::WellFormed(..) |\n+                    ty::Predicate::ObjectSafe(..) |\n                     ty::Predicate::Projection(..) => {\n                         // For now, assume all these where-clauses\n                         // may give drop implementation capabilty\n@@ -6906,6 +7010,8 @@ impl<'tcx> fmt::Debug for ty::Predicate<'tcx> {\n             Predicate::RegionOutlives(ref pair) => write!(f, \"{:?}\", pair),\n             Predicate::TypeOutlives(ref pair) => write!(f, \"{:?}\", pair),\n             Predicate::Projection(ref pair) => write!(f, \"{:?}\", pair),\n+            Predicate::WellFormed(ty) => write!(f, \"WF({:?})\", ty),\n+            Predicate::ObjectSafe(trait_def_id) => write!(f, \"ObjectSafe({:?})\", trait_def_id),\n         }\n     }\n }\n@@ -6951,6 +7057,20 @@ impl<'tcx> RegionEscape for Ty<'tcx> {\n     }\n }\n \n+impl<'tcx> RegionEscape for TraitTy<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.principal.has_regions_escaping_depth(depth) ||\n+            self.bounds.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for ExistentialBounds<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.region_bound.has_regions_escaping_depth(depth) ||\n+            self.projection_bounds.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n impl<'tcx> RegionEscape for Substs<'tcx> {\n     fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n         self.types.has_regions_escaping_depth(depth) ||\n@@ -7016,6 +7136,8 @@ impl<'tcx> RegionEscape for Predicate<'tcx> {\n             Predicate::RegionOutlives(ref data) => data.has_regions_escaping_depth(depth),\n             Predicate::TypeOutlives(ref data) => data.has_regions_escaping_depth(depth),\n             Predicate::Projection(ref data) => data.has_regions_escaping_depth(depth),\n+            Predicate::WellFormed(ty) => ty.has_regions_escaping_depth(depth),\n+            Predicate::ObjectSafe(_trait_def_id) => false,\n         }\n     }\n }\n@@ -7174,6 +7296,8 @@ impl<'tcx> HasTypeFlags for Predicate<'tcx> {\n             Predicate::RegionOutlives(ref data) => data.has_type_flags(flags),\n             Predicate::TypeOutlives(ref data) => data.has_type_flags(flags),\n             Predicate::Projection(ref data) => data.has_type_flags(flags),\n+            Predicate::WellFormed(data) => data.has_type_flags(flags),\n+            Predicate::ObjectSafe(_trait_def_id) => false,\n         }\n     }\n }"}, {"sha": "09c50804e836bc6f92734c8e21ee8a4a3392c572", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -394,6 +394,10 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n                 ty::Predicate::TypeOutlives(binder.fold_with(folder)),\n             ty::Predicate::Projection(ref binder) =>\n                 ty::Predicate::Projection(binder.fold_with(folder)),\n+            ty::Predicate::WellFormed(data) =>\n+                ty::Predicate::WellFormed(data.fold_with(folder)),\n+            ty::Predicate::ObjectSafe(trait_def_id) =>\n+                ty::Predicate::ObjectSafe(trait_def_id),\n         }\n     }\n }\n@@ -543,6 +547,7 @@ impl<'a, 'tcx> TypeFoldable<'tcx> for ty::ParameterEnvironment<'a, 'tcx> where '\n             implicit_region_bound: self.implicit_region_bound.fold_with(folder),\n             caller_bounds: self.caller_bounds.fold_with(folder),\n             selection_cache: traits::SelectionCache::new(),\n+            free_id: self.free_id,\n         }\n     }\n }"}, {"sha": "670b9d72d868bb25c649737057fed38f0148346b", "filename": "src/librustc/middle/wf.rs", "status": "added", "additions": 546, "deletions": 0, "changes": 546, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fmiddle%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fwf.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,546 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::infer::InferCtxt;\n+use middle::outlives::{self, Component};\n+use middle::subst::Substs;\n+use middle::traits;\n+use middle::ty::{self, RegionEscape, ToPredicate, Ty};\n+use std::iter::once;\n+use std::mem;\n+use std::rc::Rc;\n+use syntax::ast;\n+use syntax::codemap::Span;\n+use util::common::ErrorReported;\n+\n+/// Returns the set of obligations needed to make `ty` well-formed.\n+/// If `ty` contains unresolved inference variables, this may include\n+/// further WF obligations. However, if `ty` IS an unresolved\n+/// inference variable, returns `None`, because we are not able to\n+/// make any progress at all. This is to prevent \"livelock\" where we\n+/// say \"$0 is WF if $0 is WF\".\n+pub fn obligations<'a,'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                            body_id: ast::NodeId,\n+                            ty: Ty<'tcx>,\n+                            span: Span,\n+                            rfc1214: bool)\n+                            -> Option<Vec<traits::PredicateObligation<'tcx>>>\n+{\n+    let mut wf = WfPredicates { infcx: infcx,\n+                                body_id: body_id,\n+                                span: span,\n+                                out: vec![],\n+                                rfc1214: rfc1214 };\n+    if wf.compute(ty) {\n+        debug!(\"wf::obligations({:?}, body_id={:?}) = {:?}\", ty, body_id, wf.out);\n+        let result = wf.normalize();\n+        debug!(\"wf::obligations({:?}, body_id={:?}) ~~> {:?}\", ty, body_id, result);\n+        Some(result)\n+    } else {\n+        None // no progress made, return None\n+    }\n+}\n+\n+/// Returns the obligations that make this trait reference\n+/// well-formed.  For example, if there is a trait `Set` defined like\n+/// `trait Set<K:Eq>`, then the trait reference `Foo: Set<Bar>` is WF\n+/// if `Bar: Eq`.\n+pub fn trait_obligations<'a,'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                  body_id: ast::NodeId,\n+                                  trait_ref: &ty::TraitRef<'tcx>,\n+                                  span: Span,\n+                                  rfc1214: bool)\n+                                  -> Vec<traits::PredicateObligation<'tcx>>\n+{\n+    let mut wf = WfPredicates { infcx: infcx, body_id: body_id, span: span,\n+                                out: vec![], rfc1214: rfc1214 };\n+    wf.compute_trait_ref(trait_ref);\n+    wf.normalize()\n+}\n+\n+pub fn predicate_obligations<'a,'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                      body_id: ast::NodeId,\n+                                      predicate: &ty::Predicate<'tcx>,\n+                                      span: Span,\n+                                      rfc1214: bool)\n+                                      -> Vec<traits::PredicateObligation<'tcx>>\n+{\n+    let mut wf = WfPredicates { infcx: infcx, body_id: body_id, span: span,\n+                                out: vec![], rfc1214: rfc1214 };\n+\n+    // (*) ok to skip binders, because wf code is prepared for it\n+    match *predicate {\n+        ty::Predicate::Trait(ref t) => {\n+            wf.compute_trait_ref(&t.skip_binder().trait_ref); // (*)\n+        }\n+        ty::Predicate::Equate(ref t) => {\n+            wf.compute(t.skip_binder().0);\n+            wf.compute(t.skip_binder().1);\n+        }\n+        ty::Predicate::RegionOutlives(..) => {\n+        }\n+        ty::Predicate::TypeOutlives(ref t) => {\n+            wf.compute(t.skip_binder().0);\n+        }\n+        ty::Predicate::Projection(ref t) => {\n+            let t = t.skip_binder(); // (*)\n+            wf.compute_projection(t.projection_ty);\n+            wf.compute(t.ty);\n+        }\n+        ty::Predicate::WellFormed(t) => {\n+            wf.compute(t);\n+        }\n+        ty::Predicate::ObjectSafe(_) => {\n+        }\n+    }\n+\n+    wf.normalize()\n+}\n+\n+/// Implied bounds are region relationships that we deduce\n+/// automatically.  The idea is that (e.g.) a caller must check that a\n+/// function's argument types are well-formed immediately before\n+/// calling that fn, and hence the *callee* can assume that its\n+/// argument types are well-formed. This may imply certain relationships\n+/// between generic parameters. For example:\n+///\n+///     fn foo<'a,T>(x: &'a T)\n+///\n+/// can only be called with a `'a` and `T` such that `&'a T` is WF.\n+/// For `&'a T` to be WF, `T: 'a` must hold. So we can assume `T: 'a`.\n+#[derive(Debug)]\n+pub enum ImpliedBound<'tcx> {\n+    RegionSubRegion(ty::Region, ty::Region),\n+    RegionSubParam(ty::Region, ty::ParamTy),\n+    RegionSubProjection(ty::Region, ty::ProjectionTy<'tcx>),\n+}\n+\n+/// Compute the implied bounds that a callee/impl can assume based on\n+/// the fact that caller/projector has ensured that `ty` is WF.  See\n+/// the `ImpliedBound` type for more details.\n+pub fn implied_bounds<'a,'tcx>(\n+    infcx: &'a InferCtxt<'a,'tcx>,\n+    body_id: ast::NodeId,\n+    ty: Ty<'tcx>,\n+    span: Span)\n+    -> Vec<ImpliedBound<'tcx>>\n+{\n+    // Sometimes when we ask what it takes for T: WF, we get back that\n+    // U: WF is required; in that case, we push U onto this stack and\n+    // process it next. Currently (at least) these resulting\n+    // predicates are always guaranteed to be a subset of the original\n+    // type, so we need not fear non-termination.\n+    let mut wf_types = vec![ty];\n+\n+    let mut implied_bounds = vec![];\n+\n+    while let Some(ty) = wf_types.pop() {\n+        // Compute the obligations for `ty` to be well-formed. If `ty` is\n+        // an unresolved inference variable, just substituted an empty set\n+        // -- because the return type here is going to be things we *add*\n+        // to the environment, it's always ok for this set to be smaller\n+        // than the ultimate set. (Note: normally there won't be\n+        // unresolved inference variables here anyway, but there might be\n+        // during typeck under some circumstances.)\n+        let obligations = obligations(infcx, body_id, ty, span, false).unwrap_or(vec![]);\n+\n+        // From the full set of obligations, just filter down to the\n+        // region relationships.\n+        implied_bounds.extend(\n+            obligations\n+            .into_iter()\n+            .flat_map(|obligation| {\n+                assert!(!obligation.has_escaping_regions());\n+                match obligation.predicate {\n+                    ty::Predicate::Trait(..) |\n+                    ty::Predicate::Equate(..) |\n+                    ty::Predicate::Projection(..) |\n+                    ty::Predicate::ObjectSafe(..) =>\n+                        vec![],\n+\n+                    ty::Predicate::WellFormed(subty) => {\n+                        wf_types.push(subty);\n+                        vec![]\n+                    }\n+\n+                    ty::Predicate::RegionOutlives(ref data) =>\n+                        match infcx.tcx.no_late_bound_regions(data) {\n+                            None =>\n+                                vec![],\n+                            Some(ty::OutlivesPredicate(r_a, r_b)) =>\n+                                vec![ImpliedBound::RegionSubRegion(r_b, r_a)],\n+                        },\n+\n+                    ty::Predicate::TypeOutlives(ref data) =>\n+                        match infcx.tcx.no_late_bound_regions(data) {\n+                            None => vec![],\n+                            Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n+                                let components = outlives::components(infcx, ty_a);\n+                                implied_bounds_from_components(r_b, components)\n+                            }\n+                        },\n+                }}));\n+    }\n+\n+    implied_bounds\n+}\n+\n+/// When we have an implied bound that `T: 'a`, we can further break\n+/// this down to determine what relationships would have to hold for\n+/// `T: 'a` to hold. We get to assume that the caller has validated\n+/// those relationships.\n+fn implied_bounds_from_components<'tcx>(sub_region: ty::Region,\n+                                        sup_components: Vec<Component<'tcx>>)\n+                                        -> Vec<ImpliedBound<'tcx>>\n+{\n+    sup_components\n+        .into_iter()\n+        .flat_map(|component| {\n+            match component {\n+                Component::Region(r) =>\n+                    vec!(ImpliedBound::RegionSubRegion(sub_region, r)),\n+                Component::Param(p) =>\n+                    vec!(ImpliedBound::RegionSubParam(sub_region, p)),\n+                Component::Projection(p) =>\n+                    vec!(ImpliedBound::RegionSubProjection(sub_region, p)),\n+                Component::EscapingProjection(_) =>\n+                    // If the projection has escaping regions, don't\n+                    // try to infer any implied bounds even for its\n+                    // free components. This is conservative, because\n+                    // the caller will still have to prove that those\n+                    // free components outlive `sub_region`. But the\n+                    // idea is that the WAY that the caller proves\n+                    // that may change in the future and we want to\n+                    // give ourselves room to get smarter here.\n+                    vec!(),\n+                Component::UnresolvedInferenceVariable(..) =>\n+                    vec!(),\n+                Component::RFC1214(components) =>\n+                    implied_bounds_from_components(sub_region, components),\n+            }\n+        })\n+        .collect()\n+}\n+\n+struct WfPredicates<'a,'tcx:'a> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    body_id: ast::NodeId,\n+    span: Span,\n+    out: Vec<traits::PredicateObligation<'tcx>>,\n+    rfc1214: bool\n+}\n+\n+impl<'a,'tcx> WfPredicates<'a,'tcx> {\n+    fn rfc1214<R,F:FnOnce(&mut WfPredicates<'a,'tcx>) -> R>(&mut self, f: F) -> R {\n+        let b = mem::replace(&mut self.rfc1214, true);\n+        let r = f(self);\n+        self.rfc1214 = b;\n+        r\n+    }\n+\n+    fn cause(&mut self, code: traits::ObligationCauseCode<'tcx>) -> traits::ObligationCause<'tcx> {\n+        if !self.rfc1214 {\n+            traits::ObligationCause::new(self.span, self.body_id, code)\n+        } else {\n+            let code = traits::ObligationCauseCode::RFC1214(Rc::new(code));\n+            traits::ObligationCause::new(self.span, self.body_id, code)\n+        }\n+    }\n+\n+    fn normalize(&mut self) -> Vec<traits::PredicateObligation<'tcx>> {\n+        let cause = self.cause(traits::MiscObligation);\n+        let infcx = &mut self.infcx;\n+        self.out.iter()\n+                .inspect(|pred| assert!(!pred.has_escaping_regions()))\n+                .flat_map(|pred| {\n+                    let mut selcx = traits::SelectionContext::new(infcx);\n+                    let pred = traits::normalize(&mut selcx, cause.clone(), pred);\n+                    once(pred.value).chain(pred.obligations)\n+                })\n+                .collect()\n+    }\n+\n+    fn compute_rfc1214(&mut self, ty: Ty<'tcx>) {\n+        let b = mem::replace(&mut self.rfc1214, true);\n+        for subty in ty.walk().skip(1) {\n+            self.compute(subty);\n+        }\n+        self.rfc1214 = b;\n+    }\n+\n+    /// Pushes the obligations required for `trait_ref` to be WF into\n+    /// `self.out`.\n+    fn compute_trait_ref(&mut self, trait_ref: &ty::TraitRef<'tcx>) {\n+        let obligations = self.nominal_obligations(trait_ref.def_id, trait_ref.substs);\n+        self.out.extend(obligations);\n+\n+        let cause = self.cause(traits::MiscObligation);\n+        self.out.extend(\n+            trait_ref.substs.types\n+                            .as_slice()\n+                            .iter()\n+                            .filter(|ty| !ty.has_escaping_regions())\n+                            .map(|ty| traits::Obligation::new(cause.clone(),\n+                                                              ty::Predicate::WellFormed(ty))));\n+    }\n+\n+    /// Pushes the obligations required for `trait_ref::Item` to be WF\n+    /// into `self.out`.\n+    fn compute_projection(&mut self, data: ty::ProjectionTy<'tcx>) {\n+        // A projection is well-formed if (a) the trait ref itself is\n+        // WF WF and (b) the trait-ref holds.  (It may also be\n+        // normalizable and be WF that way.)\n+\n+        self.compute_trait_ref(&data.trait_ref);\n+\n+        if !data.has_escaping_regions() {\n+            let predicate = data.trait_ref.to_predicate();\n+            let cause = self.cause(traits::ProjectionWf(data));\n+            self.out.push(traits::Obligation::new(cause, predicate));\n+        }\n+    }\n+\n+    /// Push new obligations into `out`. Returns true if it was able\n+    /// to generate all the predicates needed to validate that `ty0`\n+    /// is WF. Returns false if `ty0` is an unresolved type variable,\n+    /// in which case we are not able to simplify at all.\n+    fn compute(&mut self, ty0: Ty<'tcx>) -> bool {\n+        let mut subtys = ty0.walk();\n+        while let Some(ty) = subtys.next() {\n+            match ty.sty {\n+                ty::TyBool |\n+                ty::TyChar |\n+                ty::TyInt(..) |\n+                ty::TyUint(..) |\n+                ty::TyFloat(..) |\n+                ty::TyError |\n+                ty::TyStr |\n+                ty::TyParam(_) => {\n+                    // WfScalar, WfParameter, etc\n+                }\n+\n+                ty::TySlice(subty) |\n+                ty::TyArray(subty, _) => {\n+                    self.rfc1214(|this| {\n+                        if !subty.has_escaping_regions() {\n+                            let cause = this.cause(traits::SliceOrArrayElem);\n+                            match traits::trait_ref_for_builtin_bound(this.infcx.tcx,\n+                                                                      ty::BoundSized,\n+                                                                      subty) {\n+                                Ok(trait_ref) => {\n+                                    this.out.push(\n+                                        traits::Obligation::new(cause,\n+                                                                trait_ref.to_predicate()));\n+                                }\n+                                Err(ErrorReported) => { }\n+                            }\n+                        }\n+                    })\n+                }\n+\n+                ty::TyBox(_) |\n+                ty::TyTuple(_) |\n+                ty::TyRawPtr(_) => {\n+                    // simple cases that are WF if their type args are WF\n+                }\n+\n+                ty::TyProjection(data) => {\n+                    subtys.skip_current_subtree(); // subtree handled by compute_projection\n+                    self.compute_projection(data);\n+                }\n+\n+                ty::TyEnum(def, substs) |\n+                ty::TyStruct(def, substs) => {\n+                    // WfNominalType\n+                    let obligations = self.nominal_obligations(def.did, substs);\n+                    self.out.extend(obligations);\n+                }\n+\n+                ty::TyRef(r, mt) => {\n+                    // WfReference\n+                    if !r.has_escaping_regions() && !mt.ty.has_escaping_regions() {\n+                        let cause = self.cause(traits::ReferenceOutlivesReferent(ty));\n+                        self.out.push(\n+                            traits::Obligation::new(\n+                                cause,\n+                                ty::Predicate::TypeOutlives(\n+                                    ty::Binder(\n+                                        ty::OutlivesPredicate(mt.ty, *r)))));\n+                    }\n+                }\n+\n+                ty::TyClosure(..) => {\n+                    // the types in a closure are always the types of\n+                    // local variables (or possibly references to local\n+                    // variables), which are separately checked w/r/t\n+                    // WFedness.\n+                }\n+\n+                ty::TyBareFn(..) => {\n+                    // process the bound types; because the old implicator\n+                    // did not do this, go into RFC1214 mode.\n+                    subtys.skip_current_subtree();\n+                    self.compute_rfc1214(ty);\n+                }\n+\n+                ty::TyTrait(ref data) => {\n+                    // WfObject\n+                    //\n+                    // Here, we defer WF checking due to higher-ranked\n+                    // regions. This is perhaps not ideal.\n+                    self.from_object_ty(ty, data);\n+\n+                    // FIXME(#27579) RFC also considers adding trait\n+                    // obligations that don't refer to Self and\n+                    // checking those\n+\n+                    let cause = self.cause(traits::MiscObligation);\n+                    self.out.push(\n+                        traits::Obligation::new(\n+                            cause,\n+                            ty::Predicate::ObjectSafe(data.principal_def_id())));\n+\n+                    // process the bound types; because the old implicator\n+                    // did not do this, go into RFC1214 mode.\n+                    subtys.skip_current_subtree();\n+                    self.compute_rfc1214(ty);\n+                }\n+\n+                // Inference variables are the complicated case, since we don't\n+                // know what type they are. We do two things:\n+                //\n+                // 1. Check if they have been resolved, and if so proceed with\n+                //    THAT type.\n+                // 2. If not, check whether this is the type that we\n+                //    started with (ty0). In that case, we've made no\n+                //    progress at all, so return false. Otherwise,\n+                //    we've at least simplified things (i.e., we went\n+                //    from `Vec<$0>: WF` to `$0: WF`, so we can\n+                //    register a pending obligation and keep\n+                //    moving. (Goal is that an \"inductive hypothesis\"\n+                //    is satisfied to ensure termination.)\n+                ty::TyInfer(_) => {\n+                    let ty = self.infcx.shallow_resolve(ty);\n+                    if let ty::TyInfer(_) = ty.sty { // not yet resolved...\n+                        if ty == ty0 { // ...this is the type we started from! no progress.\n+                            return false;\n+                        }\n+\n+                        let cause = self.cause(traits::MiscObligation);\n+                        self.out.push( // ...not the type we started from, so we made progress.\n+                            traits::Obligation::new(cause, ty::Predicate::WellFormed(ty)));\n+                    } else {\n+                        // Yes, resolved, proceed with the\n+                        // result. Should never return false because\n+                        // `ty` is not a TyInfer.\n+                        assert!(self.compute(ty));\n+                    }\n+                }\n+            }\n+        }\n+\n+        // if we made it through that loop above, we made progress!\n+        return true;\n+    }\n+\n+    fn nominal_obligations(&mut self,\n+                           def_id: ast::DefId,\n+                           substs: &Substs<'tcx>)\n+                           -> Vec<traits::PredicateObligation<'tcx>>\n+    {\n+        let predicates =\n+            self.infcx.tcx.lookup_predicates(def_id)\n+                          .instantiate(self.infcx.tcx, substs);\n+        let cause = self.cause(traits::ItemObligation(def_id));\n+        predicates.predicates\n+                  .into_iter()\n+                  .map(|pred| traits::Obligation::new(cause.clone(), pred))\n+                  .filter(|pred| !pred.has_escaping_regions())\n+                  .collect()\n+    }\n+\n+    fn from_object_ty(&mut self, ty: Ty<'tcx>, data: &ty::TraitTy<'tcx>) {\n+        // Imagine a type like this:\n+        //\n+        //     trait Foo { }\n+        //     trait Bar<'c> : 'c { }\n+        //\n+        //     &'b (Foo+'c+Bar<'d>)\n+        //         ^\n+        //\n+        // In this case, the following relationships must hold:\n+        //\n+        //     'b <= 'c\n+        //     'd <= 'c\n+        //\n+        // The first conditions is due to the normal region pointer\n+        // rules, which say that a reference cannot outlive its\n+        // referent.\n+        //\n+        // The final condition may be a bit surprising. In particular,\n+        // you may expect that it would have been `'c <= 'd`, since\n+        // usually lifetimes of outer things are conservative\n+        // approximations for inner things. However, it works somewhat\n+        // differently with trait objects: here the idea is that if the\n+        // user specifies a region bound (`'c`, in this case) it is the\n+        // \"master bound\" that *implies* that bounds from other traits are\n+        // all met. (Remember that *all bounds* in a type like\n+        // `Foo+Bar+Zed` must be met, not just one, hence if we write\n+        // `Foo<'x>+Bar<'y>`, we know that the type outlives *both* 'x and\n+        // 'y.)\n+        //\n+        // Note: in fact we only permit builtin traits, not `Bar<'d>`, I\n+        // am looking forward to the future here.\n+\n+        if !data.has_escaping_regions() {\n+            let implicit_bounds =\n+                object_region_bounds(self.infcx.tcx,\n+                                     &data.principal,\n+                                     data.bounds.builtin_bounds);\n+\n+            let explicit_bound = data.bounds.region_bound;\n+\n+            for implicit_bound in implicit_bounds {\n+                let cause = self.cause(traits::ReferenceOutlivesReferent(ty));\n+                let outlives = ty::Binder(ty::OutlivesPredicate(explicit_bound, implicit_bound));\n+                self.out.push(traits::Obligation::new(cause, outlives.to_predicate()));\n+            }\n+        }\n+    }\n+}\n+\n+/// Given an object type like `SomeTrait+Send`, computes the lifetime\n+/// bounds that must hold on the elided self type. These are derived\n+/// from the declarations of `SomeTrait`, `Send`, and friends -- if\n+/// they declare `trait SomeTrait : 'static`, for example, then\n+/// `'static` would appear in the list. The hard work is done by\n+/// `ty::required_region_bounds`, see that for more information.\n+pub fn object_region_bounds<'tcx>(\n+    tcx: &ty::ctxt<'tcx>,\n+    principal: &ty::PolyTraitRef<'tcx>,\n+    others: ty::BuiltinBounds)\n+    -> Vec<ty::Region>\n+{\n+    // Since we don't actually *know* the self type for an object,\n+    // this \"open(err)\" serves as a kind of dummy standin -- basically\n+    // a skolemized type.\n+    let open_ty = tcx.mk_infer(ty::FreshTy(0));\n+\n+    // Note that we preserve the overall binding levels here.\n+    assert!(!open_ty.has_escaping_regions());\n+    let substs = tcx.mk_substs(principal.0.substs.with_self_ty(open_ty));\n+    let trait_refs = vec!(ty::Binder(ty::TraitRef::new(principal.0.def_id, substs)));\n+\n+    let mut predicates = others.to_predicates(tcx, open_ty);\n+    predicates.extend(trait_refs.iter().map(|t| t.to_predicate()));\n+\n+    tcx.required_region_bounds(open_ty, predicates)\n+}\n+"}, {"sha": "ffb3a8ccb36ba94bf6473ecea1c93a7d883d1378", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -90,6 +90,13 @@ impl Session {\n         }\n         self.diagnostic().handler().fatal(msg)\n     }\n+    pub fn span_err_or_warn(&self, is_warning: bool, sp: Span, msg: &str) {\n+        if is_warning {\n+            self.span_warn(sp, msg);\n+        } else {\n+            self.span_err(sp, msg);\n+        }\n+    }\n     pub fn span_err(&self, sp: Span, msg: &str) {\n         if self.opts.treat_err_as_bug {\n             self.span_bug(sp, msg);\n@@ -99,6 +106,13 @@ impl Session {\n             None => self.diagnostic().span_err(sp, msg)\n         }\n     }\n+    pub fn note_rfc_1214(&self, span: Span) {\n+        self.span_note(\n+            span,\n+            &format!(\"this warning results from recent bug fixes and clarifications; \\\n+                      it will become a HARD ERROR in the next release. \\\n+                      See RFC 1214 for details.\"));\n+    }\n     pub fn span_err_with_code(&self, sp: Span, msg: &str, code: &str) {\n         if self.opts.treat_err_as_bug {\n             self.span_bug(sp, msg);"}, {"sha": "3e9a64a8eb61e05163ac2d79e4743a99ca05910d", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -831,6 +831,11 @@ impl<'tcx> fmt::Display for ty::Predicate<'tcx> {\n             ty::Predicate::RegionOutlives(ref predicate) => write!(f, \"{}\", predicate),\n             ty::Predicate::TypeOutlives(ref predicate) => write!(f, \"{}\", predicate),\n             ty::Predicate::Projection(ref predicate) => write!(f, \"{}\", predicate),\n+            ty::Predicate::WellFormed(ty) => write!(f, \"{} well-formed\", ty),\n+            ty::Predicate::ObjectSafe(trait_def_id) =>\n+                ty::tls::with(|tcx| {\n+                    write!(f, \"the trait `{}` is object-safe\", tcx.item_path_str(trait_def_id))\n+                }),\n         }\n     }\n }"}, {"sha": "4d79b1a64c1911464b0f8cf4901e0fd009227239", "filename": "src/librustc_data_structures/unify/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Funify%2Fmod.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -272,7 +272,7 @@ impl<'tcx,K> UnificationTable<K>\n \n impl<'tcx,K,V> UnificationTable<K>\n     where K: UnifyKey<Value=Option<V>>,\n-          V: Clone+PartialEq,\n+          V: Clone+PartialEq+Debug,\n {\n     pub fn unify_var_var(&mut self,\n                          a_id: K,"}, {"sha": "345026bdae6736cf41fb57a647cb440ed8e02b98", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -52,7 +52,7 @@ use middle::astconv_util::{prim_ty_to_ty, check_path_args, NO_TPS, NO_REGIONS};\n use middle::const_eval::{self, ConstVal};\n use middle::const_eval::EvalHint::UncheckedExprHint;\n use middle::def;\n-use middle::implicator::object_region_bounds;\n+use middle::wf::object_region_bounds;\n use middle::resolve_lifetime as rl;\n use middle::privacy::{AllPublic, LastMod};\n use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs, ParamSpace};\n@@ -1523,12 +1523,13 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                           ast_ty: &ast::Ty)\n                           -> Ty<'tcx>\n {\n-    debug!(\"ast_ty_to_ty(ast_ty={:?})\",\n-           ast_ty);\n+    debug!(\"ast_ty_to_ty(id={:?}, ast_ty={:?})\",\n+           ast_ty.id, ast_ty);\n \n     let tcx = this.tcx();\n \n     if let Some(&ty) = tcx.ast_ty_to_ty_cache.borrow().get(&ast_ty.id) {\n+        debug!(\"ast_ty_to_ty: id={:?} ty={:?} (cached)\", ast_ty.id, ty);\n         return ty;\n     }\n \n@@ -1667,6 +1668,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n         }\n     };\n \n+    debug!(\"ast_ty_to_ty: id={:?} ty={:?}\", ast_ty.id, typ);\n     tcx.ast_ty_to_ty_cache.borrow_mut().insert(ast_ty.id, typ);\n     return typ;\n }"}, {"sha": "9098b241e5b1d34e08e9cd0fee07637aab5945f5", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -177,6 +177,8 @@ fn deduce_expectations_from_obligations<'a,'tcx>(\n                 ty::Predicate::Equate(..) => None,\n                 ty::Predicate::RegionOutlives(..) => None,\n                 ty::Predicate::TypeOutlives(..) => None,\n+                ty::Predicate::WellFormed(..) => None,\n+                ty::Predicate::ObjectSafe(..) => None,\n             };\n             opt_trait_ref\n                 .and_then(|trait_ref| self_type_matches_expected_vid(fcx, trait_ref, expected_vid))"}, {"sha": "30a9d65661a36abd2547e94225a4e25b87c827a3", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -254,9 +254,9 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n /// This function is meant to by applied to the type for every\n /// expression in the program.\n pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n-                                                     typ: ty::Ty<'tcx>,\n-                                                     span: Span,\n-                                                     scope: region::CodeExtent) {\n+                                                         typ: ty::Ty<'tcx>,\n+                                                         span: Span,\n+                                                         scope: region::CodeExtent) {\n     debug!(\"check_safety_of_destructor_if_necessary typ: {:?} scope: {:?}\",\n            typ, scope);\n "}, {"sha": "d84cbe1f879e6a0ebdc8be36d4b3e7ed932ffee7", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -432,7 +432,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             traits::ObligationCause::misc(self.span, self.fcx.body_id),\n             method_predicates);\n \n-        self.fcx.add_default_region_param_bounds(\n+        // this is a projection from a trait reference, so we have to\n+        // make sure that the trait reference inputs are well-formed.\n+        self.fcx.add_wf_bounds(\n             all_substs,\n             self.call_expr);\n     }"}, {"sha": "f8235ace3dd6a9ada51c8c685f4f950339e12087", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -480,6 +480,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                     ty::Predicate::Equate(..) |\n                     ty::Predicate::Projection(..) |\n                     ty::Predicate::RegionOutlives(..) |\n+                    ty::Predicate::WellFormed(..) |\n+                    ty::Predicate::ObjectSafe(..) |\n                     ty::Predicate::TypeOutlives(..) => {\n                         None\n                     }"}, {"sha": "bf5d1373d0bf56a961aaa081518dbea6db4a141d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 101, "deletions": 36, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -90,7 +90,7 @@ use middle::infer;\n use middle::infer::type_variable;\n use middle::pat_util::{self, pat_id_map};\n use middle::privacy::{AllPublic, LastMod};\n-use middle::region::{self, CodeExtent};\n+use middle::region::{self};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace, TypeSpace};\n use middle::traits::{self, report_fulfillment_errors};\n use middle::ty::{FnSig, GenericPredicates, TypeScheme};\n@@ -133,7 +133,8 @@ pub mod coercion;\n pub mod demand;\n pub mod method;\n mod upvar;\n-pub mod wf;\n+mod wf;\n+mod wfcheck;\n mod cast;\n mod closure;\n mod callee;\n@@ -382,25 +383,47 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckItemBodiesVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_item_types(ccx: &CrateCtxt) {\n+pub fn check_wf_old(ccx: &CrateCtxt) {\n+    // FIXME(#25759). The new code below is much more reliable but (for now)\n+    // only generates warnings. So as to ensure that we continue\n+    // getting errors where we used to get errors, we run the old wf\n+    // code first and abort if it encounters any errors. If no abort\n+    // comes, we run the new code and issue warnings.\n     let krate = ccx.tcx.map.krate();\n     let mut visit = wf::CheckTypeWellFormedVisitor::new(ccx);\n     visit::walk_crate(&mut visit, krate);\n \n     // If types are not well-formed, it leads to all manner of errors\n     // downstream, so stop reporting errors at this point.\n     ccx.tcx.sess.abort_if_errors();\n+}\n \n-    let mut visit = CheckItemTypesVisitor { ccx: ccx };\n+pub fn check_wf_new(ccx: &CrateCtxt) {\n+    let krate = ccx.tcx.map.krate();\n+    let mut visit = wfcheck::CheckTypeWellFormedVisitor::new(ccx);\n     visit::walk_crate(&mut visit, krate);\n \n+    // If types are not well-formed, it leads to all manner of errors\n+    // downstream, so stop reporting errors at this point.\n+    ccx.tcx.sess.abort_if_errors();\n+}\n+\n+pub fn check_item_types(ccx: &CrateCtxt) {\n+    let krate = ccx.tcx.map.krate();\n+    let mut visit = CheckItemTypesVisitor { ccx: ccx };\n+    visit::walk_crate(&mut visit, krate);\n     ccx.tcx.sess.abort_if_errors();\n+}\n \n+pub fn check_item_bodies(ccx: &CrateCtxt) {\n+    let krate = ccx.tcx.map.krate();\n     let mut visit = CheckItemBodiesVisitor { ccx: ccx };\n     visit::walk_crate(&mut visit, krate);\n \n     ccx.tcx.sess.abort_if_errors();\n+}\n \n+pub fn check_drop_impls(ccx: &CrateCtxt) {\n     for drop_method_did in ccx.tcx.destructors.borrow().iter() {\n         if drop_method_did.krate == ast::LOCAL_CRATE {\n             let drop_impl_did = ccx.tcx.map.get_parent_did(drop_method_did.node);\n@@ -445,9 +468,8 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n             fcx.select_all_obligations_and_apply_defaults();\n             upvar::closure_analyze_fn(&fcx, fn_id, decl, body);\n-            fcx.select_all_obligations_or_error();\n+            fcx.select_obligations_where_possible();\n             fcx.check_casts();\n-\n             fcx.select_all_obligations_or_error(); // Casts can introduce new obligations.\n \n             regionck::regionck_fn(&fcx, fn_id, fn_span, decl, body);\n@@ -587,7 +609,7 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n \n     if let ty::FnConverging(ret_ty) = ret_ty {\n         fcx.require_type_is_sized(ret_ty, decl.output.span(), traits::ReturnType);\n-        fn_sig_tys.push(ret_ty);\n+        fn_sig_tys.push(ret_ty); // FIXME(#25759) just take implied bounds from the arguments\n     }\n \n     debug!(\"fn-sig-map: fn_id={} fn_sig_tys={:?}\",\n@@ -601,6 +623,14 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n \n         // Add formal parameters.\n         for (arg_ty, input) in arg_tys.iter().zip(&decl.inputs) {\n+            // The type of the argument must be well-formed.\n+            //\n+            // NB -- this is now checked in wfcheck, but that\n+            // currently only results in warnings, so we issue an\n+            // old-style WF obligation here so that we still get the\n+            // errors that we used to get.\n+            fcx.register_old_wf_obligation(arg_ty, input.ty.span, traits::MiscObligation);\n+\n             // Create type variables for each argument.\n             pat_util::pat_bindings(\n                 &tcx.def_map,\n@@ -1508,10 +1538,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn to_ty(&self, ast_t: &ast::Ty) -> Ty<'tcx> {\n         let t = ast_ty_to_ty(self, self, ast_t);\n \n-        let mut bounds_checker = wf::BoundsChecker::new(self,\n-                                                        self.body_id,\n-                                                        None);\n-        bounds_checker.check_ty(t, ast_t.span);\n+        // Generally speaking, we must check that types entered by the\n+        // user are well-formed. This is not true for `_`, since those\n+        // types are generated by inference. Now, you might think that\n+        // we could as well generate a WF obligation -- but\n+        // unfortunately that breaks code like `foo as *const _`,\n+        // because those type variables wind up being unconstrained\n+        // until very late. Nasty. Probably it'd be best to refactor\n+        // that code path, but that's tricky because of\n+        // defaults. Argh!\n+        match ast_t.node {\n+            ast::TyInfer => { }\n+            _ => { self.register_wf_obligation(t, ast_t.span, traits::MiscObligation); }\n+        }\n \n         t\n     }\n@@ -1630,15 +1669,38 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         fulfillment_cx.register_region_obligation(ty, region, cause);\n     }\n \n-    pub fn add_default_region_param_bounds(&self,\n-                                           substs: &Substs<'tcx>,\n-                                           expr: &ast::Expr)\n+    /// Registers an obligation for checking later, during regionck, that the type `ty` must\n+    /// outlive the region `r`.\n+    pub fn register_wf_obligation(&self,\n+                                  ty: Ty<'tcx>,\n+                                  span: Span,\n+                                  code: traits::ObligationCauseCode<'tcx>)\n+    {\n+        // WF obligations never themselves fail, so no real need to give a detailed cause:\n+        let cause = traits::ObligationCause::new(span, self.body_id, code);\n+        self.register_predicate(traits::Obligation::new(cause, ty::Predicate::WellFormed(ty)));\n+    }\n+\n+    pub fn register_old_wf_obligation(&self,\n+                                      ty: Ty<'tcx>,\n+                                      span: Span,\n+                                      code: traits::ObligationCauseCode<'tcx>)\n+    {\n+        // Registers an \"old-style\" WF obligation that uses the\n+        // implicator code.  This is basically a buggy version of\n+        // `register_wf_obligation` that is being kept around\n+        // temporarily just to help with phasing in the newer rules.\n+        //\n+        // FIXME(#27579) all uses of this should be migrated to register_wf_obligation eventually\n+        let cause = traits::ObligationCause::new(span, self.body_id, code);\n+        self.register_region_obligation(ty, ty::ReEmpty, cause);\n+    }\n+\n+    /// Registers obligations that all types appearing in `substs` are well-formed.\n+    pub fn add_wf_bounds(&self, substs: &Substs<'tcx>, expr: &ast::Expr)\n     {\n         for &ty in &substs.types {\n-            let default_bound = ty::ReScope(CodeExtent::from_node_id(expr.id));\n-            let cause = traits::ObligationCause::new(expr.span, self.body_id,\n-                                                     traits::MiscObligation);\n-            self.register_region_obligation(ty, default_bound, cause);\n+            self.register_wf_obligation(ty, expr.span, traits::MiscObligation);\n         }\n     }\n \n@@ -2370,6 +2432,12 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         1\n     };\n \n+    // All the input types from the fn signature must outlive the call\n+    // so as to validate implied bounds.\n+    for &fn_input_ty in fn_inputs {\n+        fcx.register_wf_obligation(fn_input_ty, sp, traits::MiscObligation);\n+    }\n+\n     let mut expected_arg_tys = expected_arg_tys;\n     let expected_arg_count = fn_inputs.len();\n     let formal_tys = if tuple_arguments == TupleArguments {\n@@ -2478,7 +2546,8 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     Expectation::rvalue_hint(fcx.tcx(), ty)\n                 });\n \n-                check_expr_with_unifier(fcx, &**arg,\n+                check_expr_with_unifier(fcx,\n+                                        &**arg,\n                                         expected.unwrap_or(ExpectHasType(formal_ty)),\n                                         NoPreference, || {\n                     // 2. Coerce to the most detailed type that could be coerced\n@@ -3363,7 +3432,9 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n           // We always require that the type provided as the value for\n           // a type parameter outlives the moment of instantiation.\n-          constrain_path_type_parameters(fcx, expr);\n+          fcx.opt_node_ty_substs(expr.id, |item_substs| {\n+              fcx.add_wf_bounds(&item_substs.substs, expr);\n+          });\n       }\n       ast::ExprInlineAsm(ref ia) => {\n           for &(_, ref input) in &ia.inputs {\n@@ -3476,16 +3547,18 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       }\n       ast::ExprCall(ref callee, ref args) => {\n           callee::check_call(fcx, expr, &**callee, &args[..], expected);\n+\n+          // we must check that return type of called functions is WF:\n+          let ret_ty = fcx.expr_ty(expr);\n+          fcx.register_wf_obligation(ret_ty, expr.span, traits::MiscObligation);\n       }\n       ast::ExprMethodCall(ident, ref tps, ref args) => {\n-        check_method_call(fcx, expr, ident, &args[..], &tps[..], expected, lvalue_pref);\n-        let arg_tys = args.iter().map(|a| fcx.expr_ty(&**a));\n-        let  args_err = arg_tys.fold(false,\n-             |rest_err, a| {\n-              rest_err || a.references_error()});\n-        if args_err {\n-            fcx.write_error(id);\n-        }\n+          check_method_call(fcx, expr, ident, &args[..], &tps[..], expected, lvalue_pref);\n+          let arg_tys = args.iter().map(|a| fcx.expr_ty(&**a));\n+          let args_err = arg_tys.fold(false, |rest_err, a| rest_err || a.references_error());\n+          if args_err {\n+              fcx.write_error(id);\n+          }\n       }\n       ast::ExprCast(ref e, ref t) => {\n         if let ast::TyFixedLengthVec(_, ref count_expr) = t.node {\n@@ -3904,14 +3977,6 @@ pub fn resolve_ty_and_def_ufcs<'a, 'b, 'tcx>(fcx: &FnCtxt<'b, 'tcx>,\n     }\n }\n \n-fn constrain_path_type_parameters(fcx: &FnCtxt,\n-                                  expr: &ast::Expr)\n-{\n-    fcx.opt_node_ty_substs(expr.id, |item_substs| {\n-        fcx.add_default_region_param_bounds(&item_substs.substs, expr);\n-    });\n-}\n-\n impl<'tcx> Expectation<'tcx> {\n     /// Provide an expectation for an rvalue expression given an *optional*\n     /// hint, which is not required for type safety (the resulting type might"}, {"sha": "ced3ee82de2bdc20721c724206594fe9d1e796ae", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 409, "deletions": 104, "changes": 513, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -86,15 +86,19 @@ use astconv::AstConv;\n use check::dropck;\n use check::FnCtxt;\n use middle::free_region::FreeRegionMap;\n-use middle::implicator;\n+use middle::implicator::{self, Implication};\n use middle::mem_categorization as mc;\n+use middle::outlives;\n use middle::region::CodeExtent;\n+use middle::subst::Substs;\n use middle::traits;\n-use middle::ty::{self, ReScope, Ty, MethodCall, HasTypeFlags};\n-use middle::infer::{self, GenericKind};\n+use middle::ty::{self, RegionEscape, ReScope, Ty, MethodCall, HasTypeFlags};\n+use middle::infer::{self, GenericKind, InferCtxt, SubregionOrigin, VerifyBound};\n use middle::pat_util;\n+use middle::wf::{self, ImpliedBound};\n \n use std::mem;\n+use std::rc::Rc;\n use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n use syntax::visit;\n@@ -120,12 +124,19 @@ pub fn regionck_expr(fcx: &FnCtxt, e: &ast::Expr) {\n     rcx.resolve_regions_and_report_errors();\n }\n \n-pub fn regionck_item(fcx: &FnCtxt, item: &ast::Item) {\n-    let mut rcx = Rcx::new(fcx, RepeatingScope(item.id), item.id, Subject(item.id));\n+/// Region checking during the WF phase for items. `wf_tys` are the\n+/// types from which we should derive implied bounds, if any.\n+pub fn regionck_item<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                              item_id: ast::NodeId,\n+                              span: Span,\n+                              wf_tys: &[Ty<'tcx>]) {\n+    debug!(\"regionck_item(item.id={:?}, wf_tys={:?}\", item_id, wf_tys);\n+    let mut rcx = Rcx::new(fcx, RepeatingScope(item_id), item_id, Subject(item_id));\n     let tcx = fcx.tcx();\n     rcx.free_region_map\n        .relate_free_regions_from_predicates(tcx, &fcx.infcx().parameter_environment.caller_bounds);\n-    rcx.visit_region_obligations(item.id);\n+    rcx.relate_free_regions(wf_tys, item_id, span);\n+    rcx.visit_region_obligations(item_id);\n     rcx.resolve_regions_and_report_errors();\n }\n \n@@ -154,22 +165,6 @@ pub fn regionck_fn(fcx: &FnCtxt,\n     fcx.tcx().store_free_region_map(fn_id, rcx.free_region_map);\n }\n \n-/// Checks that the types in `component_tys` are well-formed. This will add constraints into the\n-/// region graph. Does *not* run `resolve_regions_and_report_errors` and so forth.\n-pub fn regionck_ensure_component_tys_wf<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                                  span: Span,\n-                                                  component_tys: &[Ty<'tcx>]) {\n-    let mut rcx = Rcx::new(fcx, RepeatingScope(0), 0, SubjectNode::None);\n-    for &component_ty in component_tys {\n-        // Check that each type outlives the empty region. Since the\n-        // empty region is a subregion of all others, this can't fail\n-        // unless the type does not meet the well-formedness\n-        // requirements.\n-        type_must_outlive(&mut rcx, infer::RelateParamBound(span, component_ty),\n-                          component_ty, ty::ReEmpty);\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // INTERNALS\n \n@@ -213,6 +208,10 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         self.fcx.ccx.tcx\n     }\n \n+    pub fn infcx(&self) -> &InferCtxt<'a,'tcx> {\n+        self.fcx.infcx()\n+    }\n+\n     fn set_body_id(&mut self, body_id: ast::NodeId) -> ast::NodeId {\n         mem::replace(&mut self.body_id, body_id)\n     }\n@@ -325,18 +324,79 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n                 .to_vec();\n \n         for r_o in &region_obligations {\n-            debug!(\"visit_region_obligations: r_o={:?}\",\n-                   r_o);\n+            debug!(\"visit_region_obligations: r_o={:?} cause={:?}\",\n+                   r_o, r_o.cause);\n             let sup_type = self.resolve_type(r_o.sup_type);\n-            let origin = infer::RelateParamBound(r_o.cause.span, sup_type);\n-            type_must_outlive(self, origin, sup_type, r_o.sub_region);\n+            let origin = self.code_to_origin(r_o.cause.span, sup_type, &r_o.cause.code);\n+\n+            if r_o.sub_region != ty::ReEmpty {\n+                type_must_outlive(self, origin, sup_type, r_o.sub_region);\n+            } else {\n+                self.visit_old_school_wf(node_id, sup_type, origin);\n+            }\n         }\n \n         // Processing the region obligations should not cause the list to grow further:\n         assert_eq!(region_obligations.len(),\n                    self.fcx.inh.infcx.fulfillment_cx.borrow().region_obligations(node_id).len());\n     }\n \n+    fn visit_old_school_wf(&mut self,\n+                           body_id: ast::NodeId,\n+                           ty: Ty<'tcx>,\n+                           origin: infer::SubregionOrigin<'tcx>) {\n+        // As a weird kind of hack, we use a region of empty as a signal\n+        // to mean \"old-school WF rules\". The only reason the old-school\n+        // WF rules are not encoded using WF is that this leads to errors,\n+        // and we want to phase those in gradually.\n+\n+        // FIXME(#27579) remove this weird special case once we phase in new WF rules completely\n+        let implications = implicator::implications(self.infcx(),\n+                                                    body_id,\n+                                                    ty,\n+                                                    ty::ReEmpty,\n+                                                    origin.span());\n+        let origin_for_ty = |ty: Option<Ty<'tcx>>| match ty {\n+            None => origin.clone(),\n+            Some(ty) => infer::ReferenceOutlivesReferent(ty, origin.span()),\n+        };\n+        for implication in implications {\n+            match implication {\n+                Implication::RegionSubRegion(ty, r1, r2) => {\n+                    self.fcx.mk_subr(origin_for_ty(ty), r1, r2);\n+                }\n+                Implication::RegionSubGeneric(ty, r1, GenericKind::Param(param_ty)) => {\n+                    param_ty_must_outlive(self, origin_for_ty(ty), r1, param_ty);\n+                }\n+                Implication::RegionSubGeneric(ty, r1, GenericKind::Projection(proj_ty)) => {\n+                    projection_must_outlive(self, origin_for_ty(ty), r1, proj_ty);\n+                }\n+                Implication::Predicate(def_id, predicate) => {\n+                    let cause = traits::ObligationCause::new(origin.span(),\n+                                                             body_id,\n+                                                             traits::ItemObligation(def_id));\n+                    let obligation = traits::Obligation::new(cause, predicate);\n+                    self.fcx.register_predicate(obligation);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn code_to_origin(&self,\n+                      span: Span,\n+                      sup_type: Ty<'tcx>,\n+                      code: &traits::ObligationCauseCode<'tcx>)\n+                      -> SubregionOrigin<'tcx> {\n+        match *code {\n+            traits::ObligationCauseCode::RFC1214(ref code) =>\n+                infer::RFC1214Subregion(Rc::new(self.code_to_origin(span, sup_type, code))),\n+            traits::ObligationCauseCode::ReferenceOutlivesReferent(ref_type) =>\n+                infer::ReferenceOutlivesReferent(ref_type, span),\n+            _ =>\n+                infer::RelateParamBound(span, sup_type),\n+        }\n+    }\n+\n     /// This method populates the region map's `free_region_map`. It walks over the transformed\n     /// argument and return types for each function just before we check the body of that function,\n     /// looking for types where you have a borrowed pointer to other borrowed data (e.g., `&'a &'b\n@@ -356,33 +416,28 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         for &ty in fn_sig_tys {\n             let ty = self.resolve_type(ty);\n             debug!(\"relate_free_regions(t={:?})\", ty);\n-            let body_scope = CodeExtent::from_node_id(body_id);\n-            let body_scope = ty::ReScope(body_scope);\n-            let implications = implicator::implications(self.fcx.infcx(), body_id,\n-                                                        ty, body_scope, span);\n+            let implied_bounds = wf::implied_bounds(self.fcx.infcx(), body_id, ty, span);\n \n             // Record any relations between free regions that we observe into the free-region-map.\n-            self.free_region_map.relate_free_regions_from_implications(&implications);\n+            self.free_region_map.relate_free_regions_from_implied_bounds(&implied_bounds);\n \n             // But also record other relationships, such as `T:'x`,\n             // that don't go into the free-region-map but which we use\n             // here.\n-            for implication in implications {\n+            for implication in implied_bounds {\n                 debug!(\"implication: {:?}\", implication);\n                 match implication {\n-                    implicator::Implication::RegionSubRegion(_,\n-                                                             ty::ReFree(free_a),\n-                                                             ty::ReInfer(ty::ReVar(vid_b))) => {\n+                    ImpliedBound::RegionSubRegion(ty::ReFree(free_a),\n+                                                  ty::ReInfer(ty::ReVar(vid_b))) => {\n                         self.fcx.inh.infcx.add_given(free_a, vid_b);\n                     }\n-                    implicator::Implication::RegionSubGeneric(_, r_a, ref generic_b) => {\n-                        debug!(\"RegionSubGeneric: {:?} <= {:?}\",\n-                               r_a, generic_b);\n-\n-                        self.region_bound_pairs.push((r_a, generic_b.clone()));\n+                    ImpliedBound::RegionSubParam(r_a, param_b) => {\n+                        self.region_bound_pairs.push((r_a, GenericKind::Param(param_b)));\n                     }\n-                    implicator::Implication::RegionSubRegion(..) |\n-                    implicator::Implication::Predicate(..) => {\n+                    ImpliedBound::RegionSubProjection(r_a, projection_b) => {\n+                        self.region_bound_pairs.push((r_a, GenericKind::Projection(projection_b)));\n+                    }\n+                    ImpliedBound::RegionSubRegion(..) => {\n                         // In principle, we could record (and take\n                         // advantage of) every relationship here, but\n                         // we are also free not to -- it simply means\n@@ -492,12 +547,11 @@ fn constrain_bindings_in_pat(pat: &ast::Pat, rcx: &mut Rcx) {\n         // that the lifetime of any regions that appear in a\n         // variable's type enclose at least the variable's scope.\n \n-        let var_region = tcx.region_maps.var_region(id);\n-        type_of_node_must_outlive(\n-            rcx, infer::BindingTypeIsNotValidAtDecl(span),\n-            id, var_region);\n-\n         let var_scope = tcx.region_maps.var_scope(id);\n+\n+        let origin = infer::BindingTypeIsNotValidAtDecl(span);\n+        type_of_node_must_outlive(rcx, origin, id, ty::ReScope(var_scope));\n+\n         let typ = rcx.resolve_node_type(id);\n         dropck::check_safety_of_destructor_if_necessary(rcx, typ, span, var_scope);\n     })\n@@ -514,7 +568,29 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     type_must_outlive(rcx, infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n                       expr_ty, ty::ReScope(CodeExtent::from_node_id(expr.id)));\n \n-    let has_method_map = rcx.fcx.infcx().is_method_call(expr.id);\n+    let method_call = MethodCall::expr(expr.id);\n+    let opt_method_callee = rcx.fcx.inh.tables.borrow().method_map.get(&method_call).cloned();\n+    let has_method_map = opt_method_callee.is_some();\n+\n+    // the region corresponding to this expression\n+    let expr_region = ty::ReScope(CodeExtent::from_node_id(expr.id));\n+\n+    // If we are calling a method (either explicitly or via an\n+    // overloaded operator), check that all of the types provided as\n+    // arguments for its type parameters are well-formed, and all the regions\n+    // provided as arguments outlive the call.\n+    if let Some(callee) = opt_method_callee {\n+        let origin = match expr.node {\n+            ast::ExprMethodCall(..) =>\n+                infer::ParameterOrigin::MethodCall,\n+            ast::ExprUnary(op, _) if op == ast::UnDeref =>\n+                infer::ParameterOrigin::OverloadedDeref,\n+            _ =>\n+                infer::ParameterOrigin::OverloadedOperator\n+        };\n+\n+        substs_wf_in_scope(rcx, origin, &callee.substs, expr.span, expr_region);\n+    }\n \n     // Check any autoderefs or autorefs that appear.\n     let adjustment = rcx.fcx.inh.tables.borrow().adjustments.get(&expr.id).map(|a| a.clone());\n@@ -585,6 +661,13 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     }\n \n     match expr.node {\n+        ast::ExprPath(..) => {\n+            rcx.fcx.opt_node_ty_substs(expr.id, |item_substs| {\n+                let origin = infer::ParameterOrigin::Path;\n+                substs_wf_in_scope(rcx, origin, &item_substs.substs, expr.span, expr_region);\n+            });\n+        }\n+\n         ast::ExprCall(ref callee, ref args) => {\n             if has_method_map {\n                 constrain_call(rcx, expr, Some(&**callee),\n@@ -895,6 +978,9 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                 debug!(\"constrain_autoderefs: #{} is overloaded, method={:?}\",\n                        i, method);\n \n+                let origin = infer::ParameterOrigin::OverloadedDeref;\n+                substs_wf_in_scope(rcx, origin, method.substs, deref_expr.span, r_deref_expr);\n+\n                 // Treat overloaded autoderefs as if an AutoRef adjustment\n                 // was applied on the base type, as that is always the case.\n                 let fn_sig = method.ty.fn_sig();\n@@ -1196,6 +1282,9 @@ fn link_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     let mut borrow_cmt = borrow_cmt;\n     let mut borrow_kind = borrow_kind;\n \n+    let origin = infer::DataBorrowed(borrow_cmt.ty, span);\n+    type_must_outlive(rcx, origin, borrow_cmt.ty, *borrow_region);\n+\n     loop {\n         debug!(\"link_region(borrow_region={:?}, borrow_kind={:?}, borrow_cmt={:?})\",\n                borrow_region,\n@@ -1395,74 +1484,295 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     }\n }\n \n-/// Ensures that all borrowed data reachable via `ty` outlives `region`.\n-pub fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n-                               origin: infer::SubregionOrigin<'tcx>,\n-                               ty: Ty<'tcx>,\n-                               region: ty::Region)\n+/// Checks that the values provided for type/region arguments in a given\n+/// expression are well-formed and in-scope.\n+pub fn substs_wf_in_scope<'a,'tcx>(rcx: &mut Rcx<'a,'tcx>,\n+                                   origin: infer::ParameterOrigin,\n+                                   substs: &Substs<'tcx>,\n+                                   expr_span: Span,\n+                                   expr_region: ty::Region) {\n+    debug!(\"substs_wf_in_scope(substs={:?}, \\\n+            expr_region={:?}, \\\n+            origin={:?}, \\\n+            expr_span={:?})\",\n+           substs, expr_region, origin, expr_span);\n+\n+    let origin = infer::ParameterInScope(origin, expr_span);\n+\n+    for &region in substs.regions() {\n+        rcx.fcx.mk_subr(origin.clone(), expr_region, region);\n+    }\n+\n+    for &ty in &substs.types {\n+        let ty = rcx.resolve_type(ty);\n+        type_must_outlive(rcx, origin.clone(), ty, expr_region);\n+    }\n+}\n+\n+/// Ensures that type is well-formed in `region`, which implies (among\n+/// other things) that all borrowed data reachable via `ty` outlives\n+/// `region`.\n+pub fn type_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                                   origin: infer::SubregionOrigin<'tcx>,\n+                                   ty: Ty<'tcx>,\n+                                   region: ty::Region)\n {\n+    let ty = rcx.resolve_type(ty);\n+\n     debug!(\"type_must_outlive(ty={:?}, region={:?})\",\n            ty,\n            region);\n \n-    let implications = implicator::implications(rcx.fcx.infcx(), rcx.body_id,\n-                                                ty, region, origin.span());\n-    for implication in implications {\n-        debug!(\"implication: {:?}\", implication);\n-        match implication {\n-            implicator::Implication::RegionSubRegion(None, r_a, r_b) => {\n-                rcx.fcx.mk_subr(origin.clone(), r_a, r_b);\n+    assert!(!ty.has_escaping_regions());\n+\n+    let components = outlives::components(rcx.infcx(), ty);\n+    components_must_outlive(rcx, origin, components, region);\n+}\n+\n+fn components_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                                     origin: infer::SubregionOrigin<'tcx>,\n+                                     components: Vec<outlives::Component<'tcx>>,\n+                                     region: ty::Region)\n+{\n+    for component in components {\n+        let origin = origin.clone();\n+        match component {\n+            outlives::Component::Region(region1) => {\n+                rcx.fcx.mk_subr(origin, region, region1);\n+            }\n+            outlives::Component::Param(param_ty) => {\n+                param_ty_must_outlive(rcx, origin, region, param_ty);\n             }\n-            implicator::Implication::RegionSubRegion(Some(ty), r_a, r_b) => {\n-                let o1 = infer::ReferenceOutlivesReferent(ty, origin.span());\n-                rcx.fcx.mk_subr(o1, r_a, r_b);\n+            outlives::Component::Projection(projection_ty) => {\n+                projection_must_outlive(rcx, origin, region, projection_ty);\n             }\n-            implicator::Implication::RegionSubGeneric(None, r_a, ref generic_b) => {\n-                generic_must_outlive(rcx, origin.clone(), r_a, generic_b);\n+            outlives::Component::EscapingProjection(subcomponents) => {\n+                components_must_outlive(rcx, origin, subcomponents, region);\n             }\n-            implicator::Implication::RegionSubGeneric(Some(ty), r_a, ref generic_b) => {\n-                let o1 = infer::ReferenceOutlivesReferent(ty, origin.span());\n-                generic_must_outlive(rcx, o1, r_a, generic_b);\n+            outlives::Component::UnresolvedInferenceVariable(v) => {\n+                // ignore this, we presume it will yield an error\n+                // later, since if a type variable is not resolved by\n+                // this point it never will be\n+                rcx.tcx().sess.delay_span_bug(\n+                    origin.span(),\n+                    &format!(\"unresolved inference variable in outlives: {:?}\", v));\n             }\n-            implicator::Implication::Predicate(def_id, predicate) => {\n-                let cause = traits::ObligationCause::new(origin.span(),\n-                                                         rcx.body_id,\n-                                                         traits::ItemObligation(def_id));\n-                let obligation = traits::Obligation::new(cause, predicate);\n-                rcx.fcx.register_predicate(obligation);\n+            outlives::Component::RFC1214(subcomponents) => {\n+                let suborigin = infer::RFC1214Subregion(Rc::new(origin));\n+                components_must_outlive(rcx, suborigin, subcomponents, region);\n             }\n         }\n     }\n }\n \n-fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n-                                  origin: infer::SubregionOrigin<'tcx>,\n-                                  region: ty::Region,\n-                                  generic: &GenericKind<'tcx>) {\n-    let param_env = &rcx.fcx.inh.infcx.parameter_environment;\n+fn param_ty_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                                   origin: infer::SubregionOrigin<'tcx>,\n+                                   region: ty::Region,\n+                                   param_ty: ty::ParamTy) {\n+    debug!(\"param_ty_must_outlive(region={:?}, param_ty={:?}, origin={:?})\",\n+           region, param_ty, origin);\n \n-    debug!(\"param_must_outlive(region={:?}, generic={:?})\",\n-           region,\n-           generic);\n+    let verify_bound = param_bound(rcx, param_ty);\n+    let generic = GenericKind::Param(param_ty);\n+    rcx.fcx.infcx().verify_generic_bound(origin, generic, region, verify_bound);\n+}\n \n-    // To start, collect bounds from user:\n-    let mut param_bounds = rcx.tcx().required_region_bounds(generic.to_ty(rcx.tcx()),\n-                                                            param_env.caller_bounds.clone());\n+fn projection_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                                     origin: infer::SubregionOrigin<'tcx>,\n+                                     region: ty::Region,\n+                                     projection_ty: ty::ProjectionTy<'tcx>)\n+{\n+    debug!(\"projection_must_outlive(region={:?}, projection_ty={:?}, origin={:?})\",\n+           region, projection_ty, origin);\n+\n+    // This case is thorny for inference. The fundamental problem is\n+    // that there are many cases where we have choice, and inference\n+    // doesn't like choice (the current region inference in\n+    // particular). :) First off, we have to choose between using the\n+    // OutlivesProjectionEnv, OutlivesProjectionTraitDef, and\n+    // OutlivesProjectionComponent rules, any one of which is\n+    // sufficient.  If there are no inference variables involved, it's\n+    // not hard to pick the right rule, but if there are, we're in a\n+    // bit of a catch 22: if we picked which rule we were going to\n+    // use, we could add constraints to the region inference graph\n+    // that make it apply, but if we don't add those constraints, the\n+    // rule might not apply (but another rule might). For now, we err\n+    // on the side of adding too few edges into the graph.\n+\n+    // Compute the bounds we can derive from the environment or trait\n+    // definition.  We know that the projection outlives all the\n+    // regions in this list.\n+    let env_bounds = projection_declared_bounds(rcx, origin.span(), projection_ty);\n+\n+    debug!(\"projection_must_outlive: env_bounds={:?}\",\n+           env_bounds);\n+\n+    // If we know that the projection outlives 'static, then we're\n+    // done here.\n+    if env_bounds.contains(&ty::ReStatic) {\n+        debug!(\"projection_must_outlive: 'static as declared bound\");\n+        return;\n+    }\n \n-    // In the case of a projection T::Foo, we may be able to extract bounds from the trait def:\n-    match *generic {\n-        GenericKind::Param(..) => { }\n-        GenericKind::Projection(ref projection_ty) => {\n-            param_bounds.push_all(\n-                &projection_bounds(rcx, origin.span(), projection_ty));\n+    // If declared bounds list is empty, the only applicable rule is\n+    // OutlivesProjectionComponent. If there are inference variables,\n+    // then, we can break down the outlives into more primitive\n+    // components without adding unnecessary edges.\n+    //\n+    // If there are *no* inference variables, however, we COULD do\n+    // this, but we choose not to, because the error messages are less\n+    // good. For example, a requirement like `T::Item: 'r` would be\n+    // translated to a requirement that `T: 'r`; when this is reported\n+    // to the user, it will thus say \"T: 'r must hold so that T::Item:\n+    // 'r holds\". But that makes it sound like the only way to fix\n+    // the problem is to add `T: 'r`, which isn't true. So, if there are no\n+    // inference variables, we use a verify constraint instead of adding\n+    // edges, which winds up enforcing the same condition.\n+    let needs_infer = {\n+        projection_ty.trait_ref.substs.types.iter().any(|t| t.needs_infer()) ||\n+            projection_ty.trait_ref.substs.regions().iter().any(|r| r.needs_infer())\n+    };\n+    if env_bounds.is_empty() && needs_infer {\n+        debug!(\"projection_must_outlive: no declared bounds\");\n+\n+        for &component_ty in &projection_ty.trait_ref.substs.types {\n+            type_must_outlive(rcx, origin.clone(), component_ty, region);\n+        }\n+\n+        for &r in projection_ty.trait_ref.substs.regions() {\n+            rcx.fcx.mk_subr(origin.clone(), region, r);\n+        }\n+\n+        return;\n+    }\n+\n+    // If we find that there is a unique declared bound `'b`, and this bound\n+    // appears in the trait reference, then the best action is to require that `'b:'r`,\n+    // so do that. This is best no matter what rule we use:\n+    //\n+    // - OutlivesProjectionEnv or OutlivesProjectionTraitDef: these would translate to\n+    // the requirement that `'b:'r`\n+    // - OutlivesProjectionComponent: this would require `'b:'r` in addition to other conditions\n+    if !env_bounds.is_empty() && env_bounds[1..].iter().all(|b| *b == env_bounds[0]) {\n+        let unique_bound = env_bounds[0];\n+        debug!(\"projection_must_outlive: unique declared bound = {:?}\", unique_bound);\n+        if projection_ty.trait_ref.substs.regions()\n+                                         .iter()\n+                                         .any(|r| env_bounds.contains(r))\n+        {\n+            debug!(\"projection_must_outlive: unique declared bound appears in trait ref\");\n+            rcx.fcx.mk_subr(origin.clone(), region, unique_bound);\n+            return;\n         }\n     }\n \n+    // Fallback to verifying after the fact that there exists a\n+    // declared bound, or that all the components appearing in the\n+    // projection outlive; in some cases, this may add insufficient\n+    // edges into the inference graph, leading to inference failures\n+    // even though a satisfactory solution exists.\n+    let verify_bound = projection_bound(rcx, origin.span(), env_bounds, projection_ty);\n+    let generic = GenericKind::Projection(projection_ty);\n+    rcx.fcx.infcx().verify_generic_bound(origin, generic.clone(), region, verify_bound);\n+}\n+\n+fn type_bound<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>, span: Span, ty: Ty<'tcx>) -> VerifyBound {\n+    match ty.sty {\n+        ty::TyParam(p) => {\n+            param_bound(rcx, p)\n+        }\n+        ty::TyProjection(data) => {\n+            let declared_bounds = projection_declared_bounds(rcx, span, data);\n+            projection_bound(rcx, span, declared_bounds, data)\n+        }\n+        _ => {\n+            recursive_type_bound(rcx, span, ty)\n+        }\n+    }\n+}\n+\n+fn param_bound<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>, param_ty: ty::ParamTy) -> VerifyBound {\n+    let param_env = &rcx.infcx().parameter_environment;\n+\n+    debug!(\"param_bound(param_ty={:?})\",\n+           param_ty);\n+\n+    let mut param_bounds = declared_generic_bounds_from_env(rcx, GenericKind::Param(param_ty));\n+\n     // Add in the default bound of fn body that applies to all in\n     // scope type parameters:\n     param_bounds.push(param_env.implicit_region_bound);\n \n-    // Finally, collect regions we scraped from the well-formedness\n+    VerifyBound::AnyRegion(param_bounds)\n+}\n+\n+fn projection_declared_bounds<'a, 'tcx>(rcx: &Rcx<'a,'tcx>,\n+                                        span: Span,\n+                                        projection_ty: ty::ProjectionTy<'tcx>)\n+                                        -> Vec<ty::Region>\n+{\n+    // First assemble bounds from where clauses and traits.\n+\n+    let mut declared_bounds =\n+        declared_generic_bounds_from_env(rcx, GenericKind::Projection(projection_ty));\n+\n+    declared_bounds.push_all(\n+        &declared_projection_bounds_from_trait(rcx, span, projection_ty));\n+\n+    declared_bounds\n+}\n+\n+fn projection_bound<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                              span: Span,\n+                              declared_bounds: Vec<ty::Region>,\n+                              projection_ty: ty::ProjectionTy<'tcx>)\n+                              -> VerifyBound {\n+    debug!(\"projection_bound(declared_bounds={:?}, projection_ty={:?})\",\n+           declared_bounds, projection_ty);\n+\n+    // see the extensive comment in projection_must_outlive\n+\n+    let ty = rcx.tcx().mk_projection(projection_ty.trait_ref, projection_ty.item_name);\n+    let recursive_bound = recursive_type_bound(rcx, span, ty);\n+\n+    VerifyBound::AnyRegion(declared_bounds).or(recursive_bound)\n+}\n+\n+fn recursive_type_bound<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                                  span: Span,\n+                                  ty: Ty<'tcx>)\n+                                  -> VerifyBound {\n+    let mut bounds = vec![];\n+\n+    for subty in ty.walk_shallow() {\n+        bounds.push(type_bound(rcx, span, subty));\n+    }\n+\n+    let mut regions = ty.regions();\n+    regions.retain(|r| !r.is_bound()); // ignore late-bound regions\n+    bounds.push(VerifyBound::AllRegions(regions));\n+\n+    // remove bounds that must hold, since they are not interesting\n+    bounds.retain(|b| !b.must_hold());\n+\n+    if bounds.len() == 1 {\n+        bounds.pop().unwrap()\n+    } else {\n+        VerifyBound::AllBounds(bounds)\n+    }\n+}\n+\n+fn declared_generic_bounds_from_env<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                                              generic: GenericKind<'tcx>)\n+                                              -> Vec<ty::Region>\n+{\n+    let param_env = &rcx.infcx().parameter_environment;\n+\n+    // To start, collect bounds from user:\n+    let mut param_bounds = rcx.tcx().required_region_bounds(generic.to_ty(rcx.tcx()),\n+                                                            param_env.caller_bounds.clone());\n+\n+    // Next, collect regions we scraped from the well-formedness\n     // constraints in the fn signature. To do that, we walk the list\n     // of known relations from the fn ctxt.\n     //\n@@ -1473,27 +1783,22 @@ fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     // The problem is that the type of `x` is `&'a A`. To be\n     // well-formed, then, A must be lower-generic by `'a`, but we\n     // don't know that this holds from first principles.\n-    for &(ref r, ref p) in &rcx.region_bound_pairs {\n+    for &(r, p) in &rcx.region_bound_pairs {\n         debug!(\"generic={:?} p={:?}\",\n                generic,\n                p);\n         if generic == p {\n-            param_bounds.push(*r);\n+            param_bounds.push(r);\n         }\n     }\n \n-    // Inform region inference that this generic must be properly\n-    // bounded.\n-    rcx.fcx.infcx().verify_generic_bound(origin,\n-                                         generic.clone(),\n-                                         region,\n-                                         param_bounds);\n+    param_bounds\n }\n \n-fn projection_bounds<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n-                              span: Span,\n-                              projection_ty: &ty::ProjectionTy<'tcx>)\n-                              -> Vec<ty::Region>\n+fn declared_projection_bounds_from_trait<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                                                  span: Span,\n+                                                  projection_ty: ty::ProjectionTy<'tcx>)\n+                                                  -> Vec<ty::Region>\n {\n     let fcx = rcx.fcx;\n     let tcx = fcx.tcx();"}, {"sha": "47eb1f472c31d208bf32f316cb8a9cfd9939a512", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use astconv::AstConv;\n-use check::{FnCtxt, Inherited, blank_fn_ctxt, regionck};\n+use check::{FnCtxt, Inherited, blank_fn_ctxt, regionck, wfcheck};\n use constrained_type_params::{identify_constrained_type_params, Parameter};\n use CrateCtxt;\n use middle::region;\n@@ -23,7 +23,7 @@ use std::collections::HashSet;\n use syntax::ast;\n use syntax::ast_util::local_def;\n use syntax::codemap::{DUMMY_SP, Span};\n-use syntax::parse::token::special_idents;\n+use syntax::parse::token::{special_idents};\n use syntax::visit;\n use syntax::visit::Visitor;\n \n@@ -86,9 +86,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                     Some(ty::BoundSend) | Some(ty::BoundSync) => {}\n                     Some(_) | None => {\n                         if !ccx.tcx.trait_has_default_impl(trait_ref.def_id) {\n-                            span_err!(ccx.tcx.sess, item.span, E0192,\n-                                      \"negative impls are only allowed for traits with \\\n-                                       default impls (e.g., `Send` and `Sync`)\")\n+                            wfcheck::error_192(ccx, item.span);\n                         }\n                     }\n                 }\n@@ -122,9 +120,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 reject_non_type_param_bounds(ccx.tcx, item.span, &trait_predicates);\n                 if ccx.tcx.trait_has_default_impl(local_def(item.id)) {\n                     if !items.is_empty() {\n-                        span_err!(ccx.tcx.sess, item.span, E0380,\n-                                  \"traits with default impls (`e.g. unsafe impl \\\n-                                  Trait for ..`) must have no methods or associated items\")\n+                        wfcheck::error_380(ccx, item.span);\n                     }\n                 }\n             }\n@@ -149,7 +145,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(type_scheme.ty), item.id);\n         f(self, &fcx);\n         fcx.select_all_obligations_or_error();\n-        regionck::regionck_item(&fcx, item);\n+        regionck::regionck_item(&fcx, item.id, item.span, &[]);\n     }\n \n     /// In a type definition, we check that to ensure that the types of the fields are well-formed.\n@@ -182,11 +178,9 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 }\n             }\n \n-            let field_tys: Vec<Ty> =\n-                variants.iter().flat_map(|v| v.fields.iter().map(|f| f.ty)).collect();\n-\n-            regionck::regionck_ensure_component_tys_wf(\n-                fcx, item.span, &field_tys);\n+            for field in variants.iter().flat_map(|v| v.fields.iter()) {\n+                fcx.register_old_wf_obligation(field.ty, field.span, traits::MiscObligation);\n+            }\n         });\n     }\n \n@@ -355,8 +349,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                          span: Span,\n                          param_name: ast::Name)\n     {\n-        span_err!(self.tcx().sess, span, E0392,\n-            \"parameter `{}` is never used\", param_name);\n+        wfcheck::error_392(self.tcx(), span, param_name);\n \n         let suggested_marker_id = self.tcx().lang_items.phantom_data();\n         match suggested_marker_id {\n@@ -420,9 +413,7 @@ fn reject_shadowing_type_parameters<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     for method_param in generics.types.get_slice(subst::FnSpace) {\n         if impl_params.contains(&method_param.name) {\n-            span_err!(tcx.sess, span, E0194,\n-                \"type parameter `{}` shadows another type parameter of the same name\",\n-                          method_param.name);\n+            wfcheck::error_194(tcx, span, method_param.name);\n         }\n     }\n }\n@@ -521,11 +512,6 @@ impl<'cx,'tcx> BoundsChecker<'cx,'tcx> {\n         }\n     }\n \n-    pub fn check_ty(&mut self, ty: Ty<'tcx>, span: Span) {\n-        self.span = span;\n-        ty.fold_with(self);\n-    }\n-\n     fn check_traits_in_ty(&mut self, ty: Ty<'tcx>, span: Span) {\n         self.span = span;\n         // When checking types outside of a type def'n, we ignore\n@@ -709,6 +695,8 @@ fn filter_to_trait_obligations<'tcx>(bounds: ty::InstantiatedPredicates<'tcx>)\n             ty::Predicate::Projection(..) => {\n                 result.predicates.push(space, predicate.clone())\n             }\n+            ty::Predicate::WellFormed(..) |\n+            ty::Predicate::ObjectSafe(..) |\n             ty::Predicate::Equate(..) |\n             ty::Predicate::TypeOutlives(..) |\n             ty::Predicate::RegionOutlives(..) => {"}, {"sha": "03e6ae2dd15456b2d29ea7d31d090bcdc37dd5b3", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "added", "additions": 630, "deletions": 0, "changes": 630, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,630 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use astconv::AstConv;\n+use check::{FnCtxt, Inherited, blank_fn_ctxt, regionck};\n+use constrained_type_params::{identify_constrained_type_params, Parameter};\n+use CrateCtxt;\n+use middle::region::DestructionScopeData;\n+use middle::subst::{self, TypeSpace, FnSpace, ParamSpace, SelfSpace};\n+use middle::traits;\n+use middle::ty::{self, Ty};\n+use middle::ty_fold::{TypeFolder};\n+use middle::wf;\n+\n+use std::cell::RefCell;\n+use std::collections::HashSet;\n+use std::rc::Rc;\n+use syntax::ast;\n+use syntax::ast_util::local_def;\n+use syntax::codemap::{Span};\n+use syntax::parse::token::{special_idents};\n+use syntax::ptr::P;\n+use syntax::visit;\n+use syntax::visit::Visitor;\n+\n+pub struct CheckTypeWellFormedVisitor<'ccx, 'tcx:'ccx> {\n+    ccx: &'ccx CrateCtxt<'ccx, 'tcx>,\n+    code: traits::ObligationCauseCode<'tcx>,\n+}\n+\n+impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n+    pub fn new(ccx: &'ccx CrateCtxt<'ccx, 'tcx>)\n+               -> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n+        CheckTypeWellFormedVisitor {\n+            ccx: ccx,\n+            code: traits::ObligationCauseCode::RFC1214(\n+                Rc::new(traits::ObligationCauseCode::MiscObligation))\n+        }\n+    }\n+\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n+        self.ccx.tcx\n+    }\n+\n+    /// Checks that the field types (in a struct def'n) or argument types (in an enum def'n) are\n+    /// well-formed, meaning that they do not require any constraints not declared in the struct\n+    /// definition itself. For example, this definition would be illegal:\n+    ///\n+    ///     struct Ref<'a, T> { x: &'a T }\n+    ///\n+    /// because the type did not declare that `T:'a`.\n+    ///\n+    /// We do this check as a pre-pass before checking fn bodies because if these constraints are\n+    /// not included it frequently leads to confusing errors in fn bodies. So it's better to check\n+    /// the types first.\n+    fn check_item_well_formed(&mut self, item: &ast::Item) {\n+        let ccx = self.ccx;\n+        debug!(\"check_item_well_formed(it.id={}, it.ident={})\",\n+               item.id,\n+               ccx.tcx.item_path_str(local_def(item.id)));\n+\n+        match item.node {\n+            /// Right now we check that every default trait implementation\n+            /// has an implementation of itself. Basically, a case like:\n+            ///\n+            /// `impl Trait for T {}`\n+            ///\n+            /// has a requirement of `T: Trait` which was required for default\n+            /// method implementations. Although this could be improved now that\n+            /// there's a better infrastructure in place for this, it's being left\n+            /// for a follow-up work.\n+            ///\n+            /// Since there's such a requirement, we need to check *just* positive\n+            /// implementations, otherwise things like:\n+            ///\n+            /// impl !Send for T {}\n+            ///\n+            /// won't be allowed unless there's an *explicit* implementation of `Send`\n+            /// for `T`\n+            ast::ItemImpl(_, ast::ImplPolarity::Positive, _,\n+                          ref trait_ref, ref self_ty, _) => {\n+                self.check_impl(item, self_ty, trait_ref);\n+            }\n+            ast::ItemImpl(_, ast::ImplPolarity::Negative, _, Some(_), _, _) => {\n+                // FIXME(#27579) what amount of WF checking do we need for neg impls?\n+\n+                let trait_ref = ccx.tcx.impl_trait_ref(local_def(item.id)).unwrap();\n+                ccx.tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id);\n+                match ccx.tcx.lang_items.to_builtin_kind(trait_ref.def_id) {\n+                    Some(ty::BoundSend) | Some(ty::BoundSync) => {}\n+                    Some(_) | None => {\n+                        if !ccx.tcx.trait_has_default_impl(trait_ref.def_id) {\n+                            error_192(ccx, item.span);\n+                        }\n+                    }\n+                }\n+            }\n+            ast::ItemFn(_, _, _, _, _, ref body) => {\n+                self.check_item_fn(item, body);\n+            }\n+            ast::ItemStatic(..) => {\n+                self.check_item_type(item);\n+            }\n+            ast::ItemConst(..) => {\n+                self.check_item_type(item);\n+            }\n+            ast::ItemStruct(ref struct_def, ref ast_generics) => {\n+                self.check_type_defn(item, |fcx| {\n+                    vec![struct_variant(fcx, &**struct_def)]\n+                });\n+\n+                self.check_variances_for_type_defn(item, ast_generics);\n+            }\n+            ast::ItemEnum(ref enum_def, ref ast_generics) => {\n+                self.check_type_defn(item, |fcx| {\n+                    enum_variants(fcx, enum_def)\n+                });\n+\n+                self.check_variances_for_type_defn(item, ast_generics);\n+            }\n+            ast::ItemTrait(_, _, _, ref items) => {\n+                self.check_trait(item, items);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn check_trait_or_impl_item(&mut self, item_id: ast::NodeId, span: Span) {\n+        let code = self.code.clone();\n+        self.with_fcx(item_id, span, |fcx, this| {\n+            let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n+            let free_id = fcx.inh.infcx.parameter_environment.free_id;\n+\n+            let item = fcx.tcx().impl_or_trait_item(local_def(item_id));\n+\n+            let mut implied_bounds = match item.container() {\n+                ty::TraitContainer(_) => vec![],\n+                ty::ImplContainer(def_id) => impl_implied_bounds(fcx, def_id, span)\n+            };\n+\n+            match item {\n+                ty::ConstTraitItem(assoc_const) => {\n+                    let ty = fcx.instantiate_type_scheme(span, free_substs, &assoc_const.ty);\n+                    fcx.register_wf_obligation(ty, span, code.clone());\n+                }\n+                ty::MethodTraitItem(method) => {\n+                    reject_shadowing_type_parameters(fcx.tcx(), span, &method.generics);\n+                    let method_ty = fcx.instantiate_type_scheme(span, free_substs, &method.fty);\n+                    let predicates = fcx.instantiate_bounds(span, free_substs, &method.predicates);\n+                    this.check_fn_or_method(fcx, span, &method_ty, &predicates,\n+                                            free_id, &mut implied_bounds);\n+                }\n+                ty::TypeTraitItem(assoc_type) => {\n+                    if let Some(ref ty) = assoc_type.ty {\n+                        let ty = fcx.instantiate_type_scheme(span, free_substs, ty);\n+                        fcx.register_wf_obligation(ty, span, code.clone());\n+                    }\n+                }\n+            }\n+\n+            implied_bounds\n+        })\n+    }\n+\n+    fn with_item_fcx<F>(&mut self, item: &ast::Item, f: F) where\n+        F: for<'fcx> FnMut(&FnCtxt<'fcx, 'tcx>,\n+                           &mut CheckTypeWellFormedVisitor<'ccx,'tcx>) -> Vec<Ty<'tcx>>,\n+    {\n+        self.with_fcx(item.id, item.span, f)\n+    }\n+\n+    fn with_fcx<F>(&mut self, id: ast::NodeId, span: Span, mut f: F) where\n+        F: for<'fcx> FnMut(&FnCtxt<'fcx, 'tcx>,\n+                           &mut CheckTypeWellFormedVisitor<'ccx,'tcx>) -> Vec<Ty<'tcx>>,\n+    {\n+        let ccx = self.ccx;\n+        let param_env = ty::ParameterEnvironment::for_item(ccx.tcx, id);\n+        let tables = RefCell::new(ty::Tables::empty());\n+        let inh = Inherited::new(ccx.tcx, &tables, param_env);\n+        let fcx = blank_fn_ctxt(ccx, &inh, ty::FnDiverging, id);\n+        let wf_tys = f(&fcx, self);\n+        fcx.select_all_obligations_or_error();\n+        regionck::regionck_item(&fcx, id, span, &wf_tys);\n+    }\n+\n+    /// In a type definition, we check that to ensure that the types of the fields are well-formed.\n+    fn check_type_defn<F>(&mut self, item: &ast::Item, mut lookup_fields: F) where\n+        F: for<'fcx> FnMut(&FnCtxt<'fcx, 'tcx>) -> Vec<AdtVariant<'tcx>>,\n+    {\n+        self.with_item_fcx(item, |fcx, this| {\n+            let variants = lookup_fields(fcx);\n+\n+            for variant in &variants {\n+                // For DST, all intermediate types must be sized.\n+                if let Some((_, fields)) = variant.fields.split_last() {\n+                    for field in fields {\n+                        fcx.register_builtin_bound(\n+                            field.ty,\n+                            ty::BoundSized,\n+                            traits::ObligationCause::new(field.span,\n+                                                         fcx.body_id,\n+                                                         traits::FieldSized));\n+                    }\n+                }\n+\n+                // All field types must be well-formed.\n+                for field in &variant.fields {\n+                    fcx.register_wf_obligation(field.ty, field.span, this.code.clone())\n+                }\n+            }\n+\n+            let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n+            let predicates = fcx.tcx().lookup_predicates(local_def(item.id));\n+            let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n+            this.check_where_clauses(fcx, item.span, &predicates);\n+\n+            vec![] // no implied bounds in a struct def'n\n+        });\n+    }\n+\n+    fn check_trait(&mut self,\n+                   item: &ast::Item,\n+                   items: &[P<ast::TraitItem>])\n+    {\n+        let trait_def_id = local_def(item.id);\n+\n+        if self.ccx.tcx.trait_has_default_impl(trait_def_id) {\n+            if !items.is_empty() {\n+                error_380(self.ccx, item.span);\n+            }\n+        }\n+\n+        self.with_item_fcx(item, |fcx, this| {\n+            let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n+            let predicates = fcx.tcx().lookup_predicates(trait_def_id);\n+            let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n+            this.check_where_clauses(fcx, item.span, &predicates);\n+            vec![]\n+        });\n+    }\n+\n+    fn check_item_fn(&mut self,\n+                     item: &ast::Item,\n+                     body: &ast::Block)\n+    {\n+        self.with_item_fcx(item, |fcx, this| {\n+            let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n+            let type_scheme = fcx.tcx().lookup_item_type(local_def(item.id));\n+            let item_ty = fcx.instantiate_type_scheme(item.span, free_substs, &type_scheme.ty);\n+            let bare_fn_ty = match item_ty.sty {\n+                ty::TyBareFn(_, ref bare_fn_ty) => bare_fn_ty,\n+                _ => {\n+                    this.tcx().sess.span_bug(item.span, \"Fn item without bare fn type\");\n+                }\n+            };\n+\n+            let predicates = fcx.tcx().lookup_predicates(local_def(item.id));\n+            let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n+\n+            let mut implied_bounds = vec![];\n+            this.check_fn_or_method(fcx, item.span, bare_fn_ty, &predicates,\n+                                    body.id, &mut implied_bounds);\n+            implied_bounds\n+        })\n+    }\n+\n+    fn check_item_type(&mut self,\n+                       item: &ast::Item)\n+    {\n+        debug!(\"check_item_type: {:?}\", item);\n+\n+        self.with_item_fcx(item, |fcx, this| {\n+            let type_scheme = fcx.tcx().lookup_item_type(local_def(item.id));\n+            let item_ty = fcx.instantiate_type_scheme(item.span,\n+                                                      &fcx.inh\n+                                                          .infcx\n+                                                          .parameter_environment\n+                                                          .free_substs,\n+                                                      &type_scheme.ty);\n+\n+            fcx.register_wf_obligation(item_ty, item.span, this.code.clone());\n+\n+            vec![] // no implied bounds in a const etc\n+        });\n+    }\n+\n+    fn check_impl(&mut self,\n+                  item: &ast::Item,\n+                  ast_self_ty: &ast::Ty,\n+                  ast_trait_ref: &Option<ast::TraitRef>)\n+    {\n+        debug!(\"check_impl: {:?}\", item);\n+\n+        self.with_item_fcx(item, |fcx, this| {\n+            let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n+            let item_def_id = local_def(item.id);\n+\n+            match *ast_trait_ref {\n+                Some(ref ast_trait_ref) => {\n+                    let trait_ref = fcx.tcx().impl_trait_ref(item_def_id).unwrap();\n+                    let trait_ref =\n+                        fcx.instantiate_type_scheme(\n+                            ast_trait_ref.path.span, free_substs, &trait_ref);\n+                    let obligations =\n+                        wf::trait_obligations(fcx.infcx(),\n+                                              fcx.body_id,\n+                                              &trait_ref,\n+                                              ast_trait_ref.path.span,\n+                                              true);\n+                    for obligation in obligations {\n+                        fcx.register_predicate(obligation);\n+                    }\n+                }\n+                None => {\n+                    let self_ty = fcx.tcx().node_id_to_type(item.id);\n+                    let self_ty = fcx.instantiate_type_scheme(item.span, free_substs, &self_ty);\n+                    fcx.register_wf_obligation(self_ty, ast_self_ty.span, this.code.clone());\n+                }\n+            }\n+\n+            let predicates = fcx.tcx().lookup_predicates(item_def_id);\n+            let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n+            this.check_where_clauses(fcx, item.span, &predicates);\n+\n+            impl_implied_bounds(fcx, local_def(item.id), item.span)\n+        });\n+    }\n+\n+    fn check_where_clauses<'fcx>(&mut self,\n+                                 fcx: &FnCtxt<'fcx,'tcx>,\n+                                 span: Span,\n+                                 predicates: &ty::InstantiatedPredicates<'tcx>)\n+    {\n+        let obligations =\n+            predicates.predicates\n+                      .iter()\n+                      .flat_map(|p| wf::predicate_obligations(fcx.infcx(),\n+                                                              fcx.body_id,\n+                                                              p,\n+                                                              span,\n+                                                              true));\n+\n+        for obligation in obligations {\n+            fcx.register_predicate(obligation);\n+        }\n+    }\n+\n+    fn check_fn_or_method<'fcx>(&mut self,\n+                                fcx: &FnCtxt<'fcx,'tcx>,\n+                                span: Span,\n+                                fty: &ty::BareFnTy<'tcx>,\n+                                predicates: &ty::InstantiatedPredicates<'tcx>,\n+                                free_id: ast::NodeId,\n+                                implied_bounds: &mut Vec<Ty<'tcx>>)\n+    {\n+        let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n+        let fty = fcx.instantiate_type_scheme(span, free_substs, fty);\n+        let free_id_outlive = DestructionScopeData::new(free_id);\n+        let sig = fcx.tcx().liberate_late_bound_regions(free_id_outlive, &fty.sig);\n+\n+        for &input_ty in &sig.inputs {\n+            fcx.register_wf_obligation(input_ty, span, self.code.clone());\n+        }\n+        implied_bounds.extend(sig.inputs);\n+\n+        match sig.output {\n+            ty::FnConverging(output) => {\n+                fcx.register_wf_obligation(output, span, self.code.clone());\n+\n+                // FIXME(#25759) return types should not be implied bounds\n+                implied_bounds.push(output);\n+            }\n+            ty::FnDiverging => { }\n+        }\n+\n+        self.check_where_clauses(fcx, span, predicates);\n+    }\n+\n+    fn check_variances_for_type_defn(&self,\n+                                     item: &ast::Item,\n+                                     ast_generics: &ast::Generics)\n+    {\n+        let item_def_id = local_def(item.id);\n+        let ty_predicates = self.tcx().lookup_predicates(item_def_id);\n+        let variances = self.tcx().item_variances(item_def_id);\n+\n+        let mut constrained_parameters: HashSet<_> =\n+            variances.types\n+                     .iter_enumerated()\n+                     .filter(|&(_, _, &variance)| variance != ty::Bivariant)\n+                     .map(|(space, index, _)| self.param_ty(ast_generics, space, index))\n+                     .map(|p| Parameter::Type(p))\n+                     .collect();\n+\n+        identify_constrained_type_params(self.tcx(),\n+                                         ty_predicates.predicates.as_slice(),\n+                                         None,\n+                                         &mut constrained_parameters);\n+\n+        for (space, index, _) in variances.types.iter_enumerated() {\n+            let param_ty = self.param_ty(ast_generics, space, index);\n+            if constrained_parameters.contains(&Parameter::Type(param_ty)) {\n+                continue;\n+            }\n+            let span = self.ty_param_span(ast_generics, item, space, index);\n+            self.report_bivariance(span, param_ty.name);\n+        }\n+\n+        for (space, index, &variance) in variances.regions.iter_enumerated() {\n+            if variance != ty::Bivariant {\n+                continue;\n+            }\n+\n+            assert_eq!(space, TypeSpace);\n+            let span = ast_generics.lifetimes[index].lifetime.span;\n+            let name = ast_generics.lifetimes[index].lifetime.name;\n+            self.report_bivariance(span, name);\n+        }\n+    }\n+\n+    fn param_ty(&self,\n+                ast_generics: &ast::Generics,\n+                space: ParamSpace,\n+                index: usize)\n+                -> ty::ParamTy\n+    {\n+        let name = match space {\n+            TypeSpace => ast_generics.ty_params[index].ident.name,\n+            SelfSpace => special_idents::type_self.name,\n+            FnSpace => self.tcx().sess.bug(\"Fn space occupied?\"),\n+        };\n+\n+        ty::ParamTy { space: space, idx: index as u32, name: name }\n+    }\n+\n+    fn ty_param_span(&self,\n+                     ast_generics: &ast::Generics,\n+                     item: &ast::Item,\n+                     space: ParamSpace,\n+                     index: usize)\n+                     -> Span\n+    {\n+        match space {\n+            TypeSpace => ast_generics.ty_params[index].span,\n+            SelfSpace => item.span,\n+            FnSpace => self.tcx().sess.span_bug(item.span, \"Fn space occupied?\"),\n+        }\n+    }\n+\n+    fn report_bivariance(&self,\n+                         span: Span,\n+                         param_name: ast::Name)\n+    {\n+        error_392(self.tcx(), span, param_name);\n+\n+        let suggested_marker_id = self.tcx().lang_items.phantom_data();\n+        match suggested_marker_id {\n+            Some(def_id) => {\n+                self.tcx().sess.fileline_help(\n+                    span,\n+                    &format!(\"consider removing `{}` or using a marker such as `{}`\",\n+                             param_name,\n+                             self.tcx().item_path_str(def_id)));\n+            }\n+            None => {\n+                // no lang items, no help!\n+            }\n+        }\n+    }\n+}\n+\n+fn reject_shadowing_type_parameters<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                          span: Span,\n+                                          generics: &ty::Generics<'tcx>) {\n+    let impl_params = generics.types.get_slice(subst::TypeSpace).iter()\n+        .map(|tp| tp.name).collect::<HashSet<_>>();\n+\n+    for method_param in generics.types.get_slice(subst::FnSpace) {\n+        if impl_params.contains(&method_param.name) {\n+            error_194(tcx, span, method_param.name);\n+        }\n+    }\n+}\n+\n+impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n+    fn visit_item(&mut self, i: &ast::Item) {\n+        debug!(\"visit_item: {:?}\", i);\n+        self.check_item_well_formed(i);\n+        visit::walk_item(self, i);\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &'v ast::TraitItem) {\n+        debug!(\"visit_trait_item: {:?}\", trait_item);\n+        self.check_trait_or_impl_item(trait_item.id, trait_item.span);\n+        visit::walk_trait_item(self, trait_item)\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &'v ast::ImplItem) {\n+        debug!(\"visit_impl_item: {:?}\", impl_item);\n+        self.check_trait_or_impl_item(impl_item.id, impl_item.span);\n+        visit::walk_impl_item(self, impl_item)\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// ADT\n+\n+struct AdtVariant<'tcx> {\n+    fields: Vec<AdtField<'tcx>>,\n+}\n+\n+struct AdtField<'tcx> {\n+    ty: Ty<'tcx>,\n+    span: Span,\n+}\n+\n+fn struct_variant<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                            struct_def: &ast::StructDef)\n+                            -> AdtVariant<'tcx> {\n+    let fields =\n+        struct_def.fields\n+        .iter()\n+        .map(|field| {\n+            let field_ty = fcx.tcx().node_id_to_type(field.node.id);\n+            let field_ty = fcx.instantiate_type_scheme(field.span,\n+                                                       &fcx.inh\n+                                                           .infcx\n+                                                           .parameter_environment\n+                                                           .free_substs,\n+                                                       &field_ty);\n+            AdtField { ty: field_ty, span: field.span }\n+        })\n+        .collect();\n+    AdtVariant { fields: fields }\n+}\n+\n+fn enum_variants<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                           enum_def: &ast::EnumDef)\n+                           -> Vec<AdtVariant<'tcx>> {\n+    enum_def.variants.iter()\n+        .map(|variant| {\n+            match variant.node.kind {\n+                ast::TupleVariantKind(ref args) if !args.is_empty() => {\n+                    let ctor_ty = fcx.tcx().node_id_to_type(variant.node.id);\n+\n+                    // the regions in the argument types come from the\n+                    // enum def'n, and hence will all be early bound\n+                    let arg_tys = fcx.tcx().no_late_bound_regions(&ctor_ty.fn_args()).unwrap();\n+                    AdtVariant {\n+                        fields: args.iter().enumerate().map(|(index, arg)| {\n+                            let arg_ty = arg_tys[index];\n+                            let arg_ty =\n+                                fcx.instantiate_type_scheme(variant.span,\n+                                                            &fcx.inh\n+                                                                .infcx\n+                                                                .parameter_environment\n+                                                                .free_substs,\n+                                                            &arg_ty);\n+                            AdtField {\n+                                ty: arg_ty,\n+                                span: arg.ty.span\n+                            }\n+                        }).collect()\n+                    }\n+                }\n+                ast::TupleVariantKind(_) => {\n+                    AdtVariant {\n+                        fields: Vec::new()\n+                    }\n+                }\n+                ast::StructVariantKind(ref struct_def) => {\n+                    struct_variant(fcx, &**struct_def)\n+                }\n+            }\n+        })\n+        .collect()\n+}\n+\n+fn impl_implied_bounds<'fcx,'tcx>(fcx: &FnCtxt<'fcx, 'tcx>,\n+                                  impl_def_id: ast::DefId,\n+                                  span: Span)\n+                                  -> Vec<Ty<'tcx>>\n+{\n+    let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n+    match fcx.tcx().impl_trait_ref(impl_def_id) {\n+        Some(ref trait_ref) => {\n+            // Trait impl: take implied bounds from all types that\n+            // appear in the trait reference.\n+            let trait_ref = fcx.instantiate_type_scheme(span, free_substs, trait_ref);\n+            trait_ref.substs.types.as_slice().to_vec()\n+        }\n+\n+        None => {\n+            // Inherent impl: take implied bounds from the self type.\n+            let self_ty = fcx.tcx().lookup_item_type(impl_def_id).ty;\n+            let self_ty = fcx.instantiate_type_scheme(span, free_substs, &self_ty);\n+            vec![self_ty]\n+        }\n+    }\n+}\n+\n+pub fn error_192<'ccx,'tcx>(ccx: &'ccx CrateCtxt<'ccx, 'tcx>, span: Span) {\n+    span_err!(ccx.tcx.sess, span, E0192,\n+              \"negative impls are only allowed for traits with \\\n+               default impls (e.g., `Send` and `Sync`)\")\n+}\n+\n+pub fn error_380<'ccx,'tcx>(ccx: &'ccx CrateCtxt<'ccx, 'tcx>, span: Span) {\n+    span_err!(ccx.tcx.sess, span, E0380,\n+              \"traits with default impls (`e.g. unsafe impl \\\n+               Trait for ..`) must have no methods or associated items\")\n+}\n+\n+pub fn error_392<'tcx>(tcx: &ty::ctxt<'tcx>, span: Span, param_name: ast::Name)  {\n+    span_err!(tcx.sess, span, E0392,\n+              \"parameter `{}` is never used\", param_name);\n+}\n+\n+pub fn error_194<'tcx>(tcx: &ty::ctxt<'tcx>, span: Span, name: ast::Name) {\n+    span_err!(tcx.sess, span, E0194,\n+              \"type parameter `{}` shadows another type parameter of the same name\",\n+              name);\n+}"}, {"sha": "1652c67c531d3cb169f92567cc24d3c42d941c0b", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -200,10 +200,13 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                         // if Trait1 is a supertrait of Trait2 or Trait2 is not object safe.\n \n                         if !traits::is_object_safe(self.tcx, data.principal_def_id()) {\n-                            // this just means the self-ty is illegal,\n-                            // and probably this error should have\n-                            // been reported elsewhere, but I'm trying to avoid\n-                            // giving a misleading message below.\n+                            // FIXME(#27579). This just means the\n+                            // self-ty is illegal; WF will report this\n+                            // error. But it will do so as a warning\n+                            // for a release or two.  For backwards\n+                            // compat reasons, then, we continue to\n+                            // report it here so that things which\n+                            // were errors remain errors.\n                             span_err!(self.tcx.sess, self_ty.span, E0372,\n                                       \"the trait `{}` cannot be made into an object\",\n                                       self.tcx.item_path_str(data.principal_def_id()));"}, {"sha": "3c315e335c6376b2686860f1ea5b116e18695521", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -490,6 +490,8 @@ impl<'tcx> GetTypeParameterBounds<'tcx> for ty::GenericPredicates<'tcx> {\n                     }\n                     ty::Predicate::Equate(..) |\n                     ty::Predicate::RegionOutlives(..) |\n+                    ty::Predicate::WellFormed(..) |\n+                    ty::Predicate::ObjectSafe(..) |\n                     ty::Predicate::Projection(..) => {\n                         false\n                     }"}, {"sha": "e6824c811c58e598f47a9688bc7e735ae4ccf229", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -345,9 +345,23 @@ pub fn check_crate(tcx: &ty::ctxt, trait_map: ty::TraitMap) {\n     time(time_passes, \"coherence checking\", (), |_|\n         coherence::check_coherence(&ccx));\n \n-    time(time_passes, \"type checking\", (), |_|\n+    time(time_passes, \"wf checking (old)\", (), |_|\n+        check::check_wf_old(&ccx));\n+\n+    time(time_passes, \"item-types checking\", (), |_|\n         check::check_item_types(&ccx));\n \n+    time(time_passes, \"item-bodies checking\", (), |_|\n+        check::check_item_bodies(&ccx));\n+\n+    time(time_passes, \"drop-impl checking\", (), |_|\n+        check::check_drop_impls(&ccx));\n+\n+    // Do this last so that if there are errors in the old code, they\n+    // get reported, and we don't get extra warnings.\n+    time(time_passes, \"wf checking (new)\", (), |_|\n+        check::check_wf_new(&ccx));\n+\n     check_for_entry_fn(&ccx);\n     tcx.sess.abort_if_errors();\n }"}, {"sha": "04b1f8ee1b1d39f94c0031e425236db6450ce336", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -818,7 +818,9 @@ impl<'a> Clean<WherePredicate> for ty::Predicate<'a> {\n             Predicate::Equate(ref pred) => pred.clean(cx),\n             Predicate::RegionOutlives(ref pred) => pred.clean(cx),\n             Predicate::TypeOutlives(ref pred) => pred.clean(cx),\n-            Predicate::Projection(ref pred) => pred.clean(cx)\n+            Predicate::Projection(ref pred) => pred.clean(cx),\n+            Predicate::WellFormed(_) => panic!(\"not user writable\"),\n+            Predicate::ObjectSafe(_) => panic!(\"not user writable\"),\n         }\n     }\n }"}, {"sha": "5e96ec6ab0df39c8b7a5d68639b240c013fc35cc", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -194,7 +194,7 @@ pub trait Encodable {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error>;\n }\n \n-pub trait Decodable {\n+pub trait Decodable: Sized {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error>;\n }\n "}, {"sha": "773bd7f5606949f1da882b4b121825f4793ba7ab", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -369,7 +369,7 @@ mod tests {\n     use sync::{Arc, Mutex, StaticMutex, Condvar};\n     use thread;\n \n-    struct Packet<T: Send>(Arc<(Mutex<T>, Condvar)>);\n+    struct Packet<T>(Arc<(Mutex<T>, Condvar)>);\n \n     unsafe impl<T: Send> Send for Packet<T> {}\n     unsafe impl<T> Sync for Packet<T> {}"}, {"sha": "a228cbfd85ba320256edf7049dd810195a9a3b78", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -60,7 +60,7 @@ pub use self::imp::Key as __KeyInner;\n /// });\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct LocalKey<T> {\n+pub struct LocalKey<T:'static> {\n     // The key itself may be tagged with #[thread_local], and this `Key` is\n     // stored as a `static`, and it's not valid for a static to reference the\n     // address of another thread_local static. For this reason we kinda wonkily"}, {"sha": "810e3bb62f705a90c4707ab102e1b2b978088176", "filename": "src/libstd/thread/scoped_tls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibstd%2Fthread%2Fscoped_tls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibstd%2Fthread%2Fscoped_tls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fscoped_tls.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -55,7 +55,7 @@ pub use self::imp::KeyInner as __KeyInner;\n #[unstable(feature = \"scoped_tls\",\n            reason = \"scoped TLS has yet to have wide enough use to fully consider \\\n                      stabilizing its interface\")]\n-pub struct ScopedKey<T> { inner: fn() -> &'static imp::KeyInner<T> }\n+pub struct ScopedKey<T:'static> { inner: fn() -> &'static imp::KeyInner<T> }\n \n /// Declare a new scoped thread local storage key.\n ///"}, {"sha": "08c6dcc7f872a7c626da92b0d1ff1e642153d991", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -475,7 +475,7 @@ pub enum WherePredicate {\n     /// A lifetime predicate, e.g. `'a: 'b+'c`\n     RegionPredicate(WhereRegionPredicate),\n     /// An equality predicate (unsupported)\n-    EqPredicate(WhereEqPredicate)\n+    EqPredicate(WhereEqPredicate),\n }\n \n /// A type bound, eg `for<'c> Foo: Send+Clone+'c`"}, {"sha": "3c8347f8a8e0e165b3852e1c52cf95df903188e5", "filename": "src/libsyntax/diagnostics/macros.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -30,6 +30,18 @@ macro_rules! span_err {\n     })\n }\n \n+#[macro_export]\n+macro_rules! span_err_or_warn {\n+    ($is_warning:expr, $session:expr, $span:expr, $code:ident, $($message:tt)*) => ({\n+        __diagnostic_used!($code);\n+        if $is_warning {\n+            $session.span_warn_with_code($span, &format!($($message)*), stringify!($code))\n+        } else {\n+            $session.span_err_with_code($span, &format!($($message)*), stringify!($code))\n+        }\n+    })\n+}\n+\n #[macro_export]\n macro_rules! span_warn {\n     ($session:expr, $span:expr, $code:ident, $($message:tt)*) => ({"}, {"sha": "78d0394a6e5ad31dbff6090aaab5409e67b2d0bd", "filename": "src/test/auxiliary/issue13507.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fauxiliary%2Fissue13507.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fauxiliary%2Fissue13507.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue13507.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -72,7 +72,6 @@ pub mod testtypes {\n     // Tests TyTrait\n     pub trait FooTrait {\n         fn foo_method(&self) -> usize;\n-        fn foo_static_method() -> usize;\n     }\n \n     // Tests TyStruct"}, {"sha": "f070ab6799c08bd1ac075f636a1e36af8310846c", "filename": "src/test/compile-fail/associated-types-outlives.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fassociated-types-outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fassociated-types-outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-outlives.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for issue #24622. The older associated types code\n+// was erroneously assuming that all projections outlived the current\n+// fn body, causing this (invalid) code to be accepted.\n+\n+pub trait Foo<'a> {\n+    type Bar;\n+}\n+\n+impl<'a, T:'a> Foo<'a> for T {\n+    type Bar = &'a T;\n+}\n+\n+fn denormalise<'a, T>(t: &'a T) -> <T as Foo<'a>>::Bar {\n+    t\n+}\n+\n+pub fn free_and_use<T: for<'a> Foo<'a>,\n+                    F: for<'a> FnOnce(<T as Foo<'a>>::Bar)>(x: T, f: F) {\n+    let y;\n+    'body: loop { // lifetime annotations added for clarity\n+        's: loop { y = denormalise(&x); break }\n+        drop(x); //~ ERROR cannot move out of `x` because it is borrowed\n+        return f(y);\n+    }\n+}\n+\n+pub fn main() {\n+}"}, {"sha": "3f72391ff90c7e068dde8ad2cb895cc1e2dd4237", "filename": "src/test/compile-fail/associated-types-projection-to-unrelated-trait-in-method-without-default.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we get an error when you use `<Self as Get>::Value` in\n+// the trait definition even if there is no default method.\n+\n+trait Get {\n+    type Value;\n+}\n+\n+trait Other {\n+    fn okay<U:Get>(&self, foo: U, bar: <Self as Get>::Value);\n+    //~^ ERROR E0277\n+}\n+\n+impl Get for () {\n+    type Value = f32;\n+}\n+\n+impl Get for f64 {\n+    type Value = u32;\n+}\n+\n+impl Other for () {\n+    fn okay<U:Get>(&self, _foo: U, _bar: <Self as Get>::Value) { }\n+}\n+\n+impl Other for f64 {\n+    fn okay<U:Get>(&self, _foo: U, _bar: <Self as Get>::Value) { }\n+}\n+\n+fn main() { }"}, {"sha": "d18746cdf0ba5726cab195da4d15ed12bb637e14", "filename": "src/test/compile-fail/cast-to-unsized-trait-object-suggestion.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fcast-to-unsized-trait-object-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fcast-to-unsized-trait-object-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-to-unsized-trait-object-suggestion.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n fn main() {\n-    &1 as Copy;\n+    &1 as Send;\n     //~^ ERROR cast to unsized type\n     //~| HELP try casting to a reference instead:\n-    //~| SUGGESTION &1 as &Copy;\n-    Box::new(1) as Copy;\n+    //~| SUGGESTION &1 as &Send;\n+    Box::new(1) as Send;\n     //~^ ERROR cast to unsized type\n     //~| HELP try casting to a `Box` instead:\n-    //~| SUGGESTION Box::new(1) as Box<Copy>;\n+    //~| SUGGESTION Box::new(1) as Box<Send>;\n }"}, {"sha": "16ed73e9095e4381d9f38acf362c7798aff8180e", "filename": "src/test/compile-fail/closure-bounds-static-cant-capture-borrowed.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-static-cant-capture-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-static-cant-capture-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-static-cant-capture-borrowed.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -12,7 +12,9 @@ fn bar<F>(blk: F) where F: FnOnce() + 'static {\n }\n \n fn foo(x: &()) {\n-    bar(|| { //~ ERROR cannot infer an appropriate lifetime\n+    bar(|| {\n+        //~^ ERROR cannot infer\n+        //~| ERROR does not fulfill\n         let _ = x;\n     })\n }"}, {"sha": "ce6baeb204c93b67c8203bf61e4c3759ceda90b9", "filename": "src/test/compile-fail/coherence-impl-trait-for-trait-object-safe.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fcoherence-impl-trait-for-trait-object-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fcoherence-impl-trait-for-trait-object-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-impl-trait-for-trait-object-safe.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we give suitable error messages when the user attempts to\n+// impl a trait `Trait` for its own object type.\n+\n+// If the trait is not object-safe, we give a more tailored message\n+// because we're such schnuckels:\n+trait NotObjectSafe { fn eq(&self, other: Self); }\n+impl NotObjectSafe for NotObjectSafe { } //~ ERROR E0372\n+\n+fn main() { }"}, {"sha": "cd75b0e34f24b5a791f1f0e767b4ab5344abddf8", "filename": "src/test/compile-fail/coherence-impl-trait-for-trait.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fcoherence-impl-trait-for-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fcoherence-impl-trait-for-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-impl-trait-for-trait.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -24,9 +24,4 @@ impl Baz for Baz { }   //~ ERROR E0371\n trait Other { }\n impl Other for Baz { } // OK, Other not a supertrait of Baz\n \n-// If the trait is not object-safe, we give a more tailored message\n-// because we're such schnuckels:\n-trait NotObjectSafe { fn eq(&self, other: Self); }\n-impl NotObjectSafe for NotObjectSafe { } //~ ERROR E0372\n-\n fn main() { }"}, {"sha": "5432cbf402a0cbafcf1b5779e1f6e766daf66b42", "filename": "src/test/compile-fail/dropck-object-cycle.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fdropck-object-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fdropck-object-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck-object-cycle.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test used to be part of a run-pass test, but revised outlives\n+// rule means that it no longer compiles.\n+\n+#![allow(unused_variables)]\n+\n+trait Trait<'a> {\n+    fn long(&'a self) -> isize;\n+    fn short<'b>(&'b self) -> isize;\n+}\n+\n+fn object_invoke1<'d>(x: &'d Trait<'d>) -> (isize, isize) { loop { } }\n+\n+trait MakerTrait {\n+    fn mk() -> Self;\n+}\n+\n+fn make_val<T:MakerTrait>() -> T {\n+    MakerTrait::mk()\n+}\n+\n+impl<'t> MakerTrait for Box<Trait<'t>+'static> {\n+    fn mk() -> Box<Trait<'t>+'static> { loop { } }\n+}\n+\n+pub fn main() {\n+    let m : Box<Trait+'static> = make_val();\n+    assert_eq!(object_invoke1(&*m), (4,5));\n+    //~^ ERROR `*m` does not live long enough\n+\n+    // the problem here is that the full type of `m` is\n+    //\n+    //   Box<Trait<'m>+'static>\n+    //\n+    // Here `'m` must be exactly the lifetime of the variable `m`.\n+    // This is because of two requirements:\n+    // 1. First, the basic type rules require that the\n+    //    type of `m`'s value outlives the lifetime of `m`. This puts a lower\n+    //    bound `'m`.\n+    //\n+    // 2. Meanwhile, the signature of `object_invoke1` requires that\n+    //    we create a reference of type `&'d Trait<'d>` for some `'d`.\n+    //    `'d` cannot outlive `'m`, so that forces the lifetime to be `'m`.\n+    //\n+    // This then conflicts with the dropck rules, which require that\n+    // the type of `m` *strictly outlives* `'m`. Hence we get an\n+    // error.\n+}"}, {"sha": "9b02bf4cb85a8744dddd64a452bca81da8ae022b", "filename": "src/test/compile-fail/infinite-instantiation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -15,7 +15,7 @@\n // so for now just live with it.\n // This test case was originally for issue #2258.\n \n-trait ToOpt {\n+trait ToOpt: Sized {\n     fn to_option(&self) -> Option<Self>;\n }\n "}, {"sha": "dd7e8a869eca9c3c9d0119f70a03cf281aed76e4", "filename": "src/test/compile-fail/issue-16747.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fissue-16747.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fissue-16747.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16747.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -15,10 +15,10 @@ trait ListItem<'a> {\n trait Collection { fn len(&self) -> usize; }\n \n struct List<'a, T: ListItem<'a>> {\n+    slice: &'a [T]\n //~^ ERROR the parameter type `T` may not live long enough\n //~| HELP consider adding an explicit lifetime bound\n //~| NOTE ...so that the reference type `&'a [T]` does not outlive the data it points at\n-    slice: &'a [T]\n }\n impl<'a, T: ListItem<'a>> Collection for List<'a, T> {\n     fn len(&self) -> usize {"}, {"sha": "7d95082079f9f13bb2450dfa69024265ef6c44d3", "filename": "src/test/compile-fail/issue-18389.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fissue-18389.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fissue-18389.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18389.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -11,10 +11,7 @@\n use std::any::Any;\n use std::any::TypeId;\n \n-pub trait Pt {}\n-pub trait Rt {}\n-\n-trait Private<P: Pt, R: Rt> {\n+trait Private<P, R> {\n     fn call(&self, p: P, r: R);\n }\n pub trait Public: Private< //~ ERROR private trait in exported type parameter bound"}, {"sha": "95176da9020d566c9dfdcc8bf3703ad85b1ee5fe", "filename": "src/test/compile-fail/issue-18959.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fissue-18959.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fissue-18959.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18959.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -21,10 +21,11 @@ impl Foo for Thing {\n fn foo(b: &Bar) {\n     b.foo(&0)\n     //~^ ERROR the trait `Foo` is not implemented for the type `Bar`\n+    //~| ERROR E0038\n }\n \n fn main() {\n     let mut thing = Thing;\n-    let test: &Bar = &mut thing; //~ ERROR cannot convert to a trait object\n+    let test: &Bar = &mut thing; //~ ERROR E0038\n     foo(test);\n }"}, {"sha": "aae77c90b6bf2980e9820ae9fe0d9e363d3c59c1", "filename": "src/test/compile-fail/issue-19380.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fissue-19380.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fissue-19380.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19380.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -23,6 +23,6 @@ struct Bar {\n \n const FOO : Foo = Foo;\n const BAR : Bar = Bar { foos: &[&FOO]};\n-//~^ ERROR: cannot convert to a trait object because trait `Qiz` is not object-safe [E0038]\n+//~^ ERROR E0038\n \n fn main() { }"}, {"sha": "a6190500582620af5659fa756a9550f6c4af8c8f", "filename": "src/test/compile-fail/issue-19538.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fissue-19538.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fissue-19538.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19538.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -25,5 +25,6 @@ impl Bar for Thing { }\n fn main() {\n     let mut thing = Thing;\n     let test: &mut Bar = &mut thing;\n-    //~^ ERROR cannot convert to a trait object because trait `Bar` is not object-safe\n+    //~^ ERROR E0038\n+    //~| ERROR E0038\n }"}, {"sha": "041289c2ccdbdb4af3393b0e526e89c61cf3e6f4", "filename": "src/test/compile-fail/issue-20005.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fissue-20005.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fissue-20005.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20005.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -19,6 +19,7 @@ trait To {\n         self //~ error: the trait `core::marker::Sized` is not implemented\n     ) -> <Dst as From<Self>>::Result where Dst: From<Self> {\n         From::from( //~ error: the trait `core::marker::Sized` is not implemented\n+            //~^ ERROR E0277\n             self\n         )\n     }"}, {"sha": "c08cdd72b38258e74645ed96d7fc4a9b1ce3f941", "filename": "src/test/compile-fail/issue-23041.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fissue-23041.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fissue-23041.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23041.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -13,6 +13,5 @@ fn main()\n {\n     fn bar(x:i32) ->i32 { 3*x };\n     let b:Box<Any> = Box::new(bar as fn(_)->_);\n-    b.downcast_ref::<fn(_)->_>();\n-    //~^ ERROR cannot determine a type for this expression: unconstrained type\n+    b.downcast_ref::<fn(_)->_>(); //~ ERROR E0101\n }"}, {"sha": "df857a2e6eb1f9766a2cefabd0234aedf1b275dc", "filename": "src/test/compile-fail/issue-24013.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fissue-24013.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fissue-24013.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-24013.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -13,5 +13,5 @@ fn main() {\n     let a = 1;\n     let b = 2;\n     unsafe {swap::<&mut _>(transmute(&a), transmute(&b))};\n-    //~^ ERROR cannot determine a type for this expression: unconstrained type\n+    //~^ ERROR unable to infer enough type information about `_`\n }"}, {"sha": "ccf5eabc1110d473e427e8609840850d9c50dd69", "filename": "src/test/compile-fail/issue-27592.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fissue-27592.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fissue-27592.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27592.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for issue #27591.\n+\n+fn write<'a, F: ::std::ops::FnOnce()->::std::fmt::Arguments<'a> + 'a>(fcn: F) {\n+    use std::fmt::Write;\n+    let _ = match fcn() { a => write!(&mut Stream, \"{}\", a), };\n+}\n+\n+struct Stream;\n+impl ::std::fmt::Write for Stream {\n+    fn write_str(&mut self, _s: &str) -> ::std::fmt::Result {\n+        Ok( () )\n+    }\n+}\n+\n+fn main() {\n+    write(|| format_args!(\"{}\", \"Hello world\"));\n+    //~^ ERROR borrowed value does not live long enough\n+    //~| ERROR borrowed value does not live long enough\n+}"}, {"sha": "ee8bc7d6e290103ccfd30543c9db1f45e59a389e", "filename": "src/test/compile-fail/issue-3907-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fissue-3907-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fissue-3907-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3907-2.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -17,6 +17,7 @@ struct S {\n     name: isize\n }\n \n-fn bar(_x: Foo) {} //~ ERROR the trait `core::marker::Sized` is not implemented\n+fn bar(_x: Foo) {}\n+//~^ ERROR E0277\n \n fn main() {}"}, {"sha": "0731fbaf01c4306152b16a556ffdc07ae2effb16", "filename": "src/test/compile-fail/kindck-inherited-copy-bound.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fkindck-inherited-copy-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fkindck-inherited-copy-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-inherited-copy-bound.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -31,7 +31,9 @@ fn a() {\n fn b() {\n     let x: Box<_> = box 3;\n     let y = &x;\n-    let z = &x as &Foo; //~ ERROR E0038\n+    let z = &x as &Foo;\n+    //~^ ERROR E0038\n+    //~| ERROR E0038\n }\n \n fn main() { }"}, {"sha": "63e5718537cf9166881efafaa66be30ff683b1a0", "filename": "src/test/compile-fail/object-safety-generics.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fobject-safety-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fobject-safety-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-generics.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -23,14 +23,15 @@ trait Quux {\n \n fn make_bar<T:Bar>(t: &T) -> &Bar {\n     t\n-        //~^ ERROR `Bar` is not object-safe\n+        //~^ ERROR E0038\n         //~| NOTE method `bar` has generic type parameters\n }\n \n fn make_bar_explicit<T:Bar>(t: &T) -> &Bar {\n     t as &Bar\n-        //~^ ERROR `Bar` is not object-safe\n+        //~^ ERROR E0038\n         //~| NOTE method `bar` has generic type parameters\n+        //~| ERROR E0038\n }\n \n fn make_quux<T:Quux>(t: &T) -> &Quux {"}, {"sha": "de419a259a24cf4fc0efb6d21eb37bdc2af8c746", "filename": "src/test/compile-fail/object-safety-issue-22040.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fobject-safety-issue-22040.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fobject-safety-issue-22040.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-issue-22040.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -25,6 +25,7 @@ struct SExpr<'x> {\n impl<'x> PartialEq for SExpr<'x> {\n     fn eq(&self, other:&SExpr<'x>) -> bool {\n         println!(\"L1: {} L2: {}\", self.elements.len(), other.elements.len());\n+        //~^ ERROR E0038\n         let result = self.elements.len() == other.elements.len();\n \n         println!(\"Got compare {}\", result);\n@@ -43,8 +44,8 @@ impl <'x> Expr for SExpr<'x> {\n }\n \n fn main() {\n-    let a: Box<Expr> = Box::new(SExpr::new()); //~ ERROR trait `Expr` is not object-safe\n-    let b: Box<Expr> = Box::new(SExpr::new()); //~ ERROR trait `Expr` is not object-safe\n+    let a: Box<Expr> = Box::new(SExpr::new()); //~ ERROR E0038\n+    let b: Box<Expr> = Box::new(SExpr::new()); //~ ERROR E0038\n \n-    assert_eq!(a , b);\n+    // assert_eq!(a , b);\n }"}, {"sha": "55b780906355a8f8b1a21f12679ab1f132938cb5", "filename": "src/test/compile-fail/object-safety-mentions-Self.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fobject-safety-mentions-Self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fobject-safety-mentions-Self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-mentions-Self.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -26,26 +26,28 @@ trait Quux {\n \n fn make_bar<T:Bar>(t: &T) -> &Bar {\n     t\n-        //~^ ERROR `Bar` is not object-safe\n+        //~^ ERROR E0038\n         //~| NOTE method `bar` references the `Self` type in its arguments or return type\n }\n \n fn make_bar_explicit<T:Bar>(t: &T) -> &Bar {\n     t as &Bar\n-        //~^ ERROR `Bar` is not object-safe\n+        //~^ ERROR E0038\n         //~| NOTE method `bar` references the `Self` type in its arguments or return type\n+        //~| ERROR E0038\n }\n \n fn make_baz<T:Baz>(t: &T) -> &Baz {\n     t\n-        //~^ ERROR `Baz` is not object-safe\n+        //~^ ERROR E0038\n         //~| NOTE method `bar` references the `Self` type in its arguments or return type\n }\n \n fn make_baz_explicit<T:Baz>(t: &T) -> &Baz {\n     t as &Baz\n-        //~^ ERROR `Baz` is not object-safe\n+        //~^ ERROR E0038\n         //~| NOTE method `bar` references the `Self` type in its arguments or return type\n+        //~| ERROR E0038\n }\n \n fn make_quux<T:Quux>(t: &T) -> &Quux {"}, {"sha": "2dc7983d1b561d3f522177862a62ed295ef757d4", "filename": "src/test/compile-fail/object-safety-no-static.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fobject-safety-no-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fobject-safety-no-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-no-static.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -17,14 +17,15 @@ trait Foo {\n \n fn foo_implicit<T:Foo+'static>(b: Box<T>) -> Box<Foo+'static> {\n     b\n-        //~^ ERROR cannot convert to a trait object\n+        //~^ ERROR E0038\n         //~| NOTE method `foo` has no receiver\n }\n \n fn foo_explicit<T:Foo+'static>(b: Box<T>) -> Box<Foo+'static> {\n     b as Box<Foo>\n-        //~^ ERROR cannot convert to a trait object\n+        //~^ ERROR E0038\n         //~| NOTE method `foo` has no receiver\n+        //~| ERROR E0038\n }\n \n fn main() {"}, {"sha": "401602bd681a38b5a536e98fd533c8e8c2492c5f", "filename": "src/test/compile-fail/object-safety-sized-2.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fobject-safety-sized-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fobject-safety-sized-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-sized-2.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -19,14 +19,15 @@ trait Bar\n \n fn make_bar<T:Bar>(t: &T) -> &Bar {\n     t\n-        //~^ ERROR `Bar` is not object-safe\n+        //~^ ERROR E0038\n         //~| NOTE the trait cannot require that `Self : Sized`\n }\n \n fn make_bar_explicit<T:Bar>(t: &T) -> &Bar {\n     t as &Bar\n-        //~^ ERROR `Bar` is not object-safe\n+        //~^ ERROR E0038\n         //~| NOTE the trait cannot require that `Self : Sized`\n+        //~| ERROR E0038\n }\n \n fn main() {"}, {"sha": "29b4e4db65c36d11a70a7b04bbceb1e1dc988c11", "filename": "src/test/compile-fail/object-safety-sized.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fobject-safety-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fobject-safety-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-sized.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -17,14 +17,15 @@ trait Bar : Sized {\n \n fn make_bar<T:Bar>(t: &T) -> &Bar {\n     t\n-        //~^ ERROR `Bar` is not object-safe\n+        //~^ ERROR E0038\n         //~| NOTE the trait cannot require that `Self : Sized`\n }\n \n fn make_bar_explicit<T:Bar>(t: &T) -> &Bar {\n     t as &Bar\n-        //~^ ERROR `Bar` is not object-safe\n+        //~^ ERROR E0038\n         //~| NOTE the trait cannot require that `Self : Sized`\n+        //~| ERROR E0038\n }\n \n fn main() {"}, {"sha": "ba82635a4016e16a0b57c59ac7bec7e33017ab5d", "filename": "src/test/compile-fail/object-safety-supertrait-mentions-Self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fobject-safety-supertrait-mentions-Self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fobject-safety-supertrait-mentions-Self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-supertrait-mentions-Self.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -24,7 +24,7 @@ fn make_bar<T:Bar<u32>>(t: &T) -> &Bar<u32> {\n \n fn make_baz<T:Baz>(t: &T) -> &Baz {\n     t\n-        //~^ ERROR `Baz` is not object-safe\n+        //~^ ERROR E0038\n         //~| NOTE the trait cannot use `Self` as a type parameter in the supertrait listing\n }\n "}, {"sha": "f2ff877cd8236dc3f1cd6078c79ca6b4c0d3f8a1", "filename": "src/test/compile-fail/regions-assoc-type-in-supertrait-outlives-container.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-in-supertrait-outlives-container.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-in-supertrait-outlives-container.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-in-supertrait-outlives-container.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -47,7 +47,7 @@ fn with_assoc<'a,'b>() {\n     // outlive 'a. In this case, that means TheType<'b>::TheAssocType,\n     // which is &'b (), must outlive 'a.\n \n-    let _: &'a WithAssoc<TheType<'b>> = loop { }; //~ ERROR cannot infer\n+    let _: &'a WithAssoc<TheType<'b>> = loop { }; //~ ERROR reference has a longer lifetime\n }\n \n fn main() {"}, {"sha": "61897aac18769353f932d70296f4c36899784510", "filename": "src/test/compile-fail/regions-close-associated-type-into-object.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-close-associated-type-into-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-close-associated-type-into-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-associated-type-into-object.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -72,13 +72,12 @@ fn meh1<'a, T: Iter>(v: &'a T) -> Box<X+'a>\n     where T::Item : Clone\n {\n     // This case is kind of interesting. It's the same as `ok3` but\n-    // without the explicit declaration. In principle, it seems like\n-    // we ought to be able to infer that `T::Item : 'a` because we\n-    // invoked `v.as_self()` which yielded a value of type `&'a\n-    // T::Item`. But we're not that smart at present.\n+    // without the explicit declaration. This is valid because `T: 'a\n+    // => T::Item: 'a`, and the former we can deduce from our argument\n+    // of type `&'a T`.\n \n     let item = Clone::clone(v.as_item());\n-    Box::new(item) //~ ERROR associated type `<T as Iter>::Item` may not live\n+    Box::new(item)\n }\n \n fn main() {}"}, {"sha": "5d9818d624b7e273e729db38af14ee17bd586a4b", "filename": "src/test/compile-fail/regions-close-object-into-object-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-1.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -12,7 +12,7 @@\n #![allow(warnings)]\n \n trait A<T> { }\n-struct B<'a, T>(&'a (A<T>+'a));\n+struct B<'a, T:'a>(&'a (A<T>+'a));\n \n trait X { }\n "}, {"sha": "6cef9956655175019e34e9537d972b17d2eb4951", "filename": "src/test/compile-fail/regions-close-object-into-object-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-2.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -11,7 +11,7 @@\n #![feature(box_syntax)]\n \n trait A<T> { }\n-struct B<'a, T>(&'a (A<T>+'a));\n+struct B<'a, T:'a>(&'a (A<T>+'a));\n \n trait X { }\n impl<'a, T> X for B<'a, T> {}"}, {"sha": "3004245b15a24438397847458251434a5ce00a2d", "filename": "src/test/compile-fail/regions-close-object-into-object-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-3.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -12,7 +12,7 @@\n #![allow(warnings)]\n \n trait A<T> { }\n-struct B<'a, T>(&'a (A<T>+'a));\n+struct B<'a, T:'a>(&'a (A<T>+'a));\n \n trait X { }\n impl<'a, T> X for B<'a, T> {}"}, {"sha": "bc5b7b7cf7874325fdce0825a4e45a9638708e1f", "filename": "src/test/compile-fail/regions-close-object-into-object-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-4.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -11,7 +11,7 @@\n #![feature(box_syntax)]\n \n trait A<T> { }\n-struct B<'a, T>(&'a (A<T>+'a));\n+struct B<'a, T:'a>(&'a (A<T>+'a));\n \n trait X { }\n impl<'a, T> X for B<'a, T> {}"}, {"sha": "ac269a4d896f2566bbe0600366e7590d602a5d62", "filename": "src/test/compile-fail/regions-close-object-into-object-5.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-5.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -16,15 +16,22 @@ trait A<T>\n     fn get(&self) -> T { panic!() }\n }\n \n-struct B<'a, T>(&'a (A<T>+'a));\n+struct B<'a, T:'a>(&'a (A<T>+'a));\n \n trait X { fn foo(&self) {} }\n \n impl<'a, T> X for B<'a, T> {}\n \n fn f<'a, T, U>(v: Box<A<T>+'static>) -> Box<X+'static> {\n-    box B(&*v) as Box<X> //~ ERROR the parameter type `T` may not live long enough\n+    // oh dear!\n+    box B(&*v) as Box<X>\n         //~^ ERROR the parameter type `T` may not live long enough\n+        //~| WARNING the parameter type `T` may not live long enough\n+        //~| WARNING the parameter type `T` may not live long enough\n+        //~| ERROR the parameter type `T` may not live long enough\n+        //~| WARNING the parameter type `T` may not live long enough\n+        //~| ERROR the parameter type `T` may not live long enough\n+        //~| ERROR the parameter type `T` may not live long enough\n }\n \n fn main() {}"}, {"sha": "e21f92bc9b885947d84bc603015edeb5c1175413", "filename": "src/test/compile-fail/regions-enum-not-wf.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-enum-not-wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-enum-not-wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-enum-not-wf.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -12,25 +12,27 @@\n \n #![allow(dead_code)]\n \n-enum Ref1<'a, T> { //~ ERROR the parameter type `T` may not live long enough\n-    Ref1Variant1(&'a T)\n+enum Ref1<'a, T> {\n+    Ref1Variant1(&'a T) //~ ERROR the parameter type `T` may not live long enough\n }\n \n-enum Ref2<'a, T> { //~ ERROR the parameter type `T` may not live long enough\n+enum Ref2<'a, T> {\n     Ref2Variant1,\n-    Ref2Variant2(isize, &'a T),\n+    Ref2Variant2(isize, &'a T), //~ ERROR the parameter type `T` may not live long enough\n }\n \n enum RefOk<'a, T:'a> {\n     RefOkVariant1(&'a T)\n }\n \n-enum RefIndirect<'a, T> { //~ ERROR the parameter type `T` may not live long enough\n+enum RefIndirect<'a, T> {\n     RefIndirectVariant1(isize, RefOk<'a,T>)\n+        //~^ ERROR the parameter type `T` may not live long enough\n }\n \n-enum RefDouble<'a, 'b, T> { //~ ERROR reference has a longer lifetime than the data\n+enum RefDouble<'a, 'b, T> {\n     RefDoubleVariant1(&'a &'b T)\n+        //~^ ERROR reference has a longer lifetime than the data\n }\n \n fn main() { }"}, {"sha": "65594ab8f2e29220ee603252622bf2e83b52fbe0", "filename": "src/test/compile-fail/regions-implied-bounds-projection-gap-1.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-implied-bounds-projection-gap-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-implied-bounds-projection-gap-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-implied-bounds-projection-gap-1.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Illustrates the \"projection gap\": in this test, even though we know\n+// that `T::Foo: 'x`, that does not tell us that `T: 'x`, because\n+// there might be other ways for the caller of `func` to show that\n+// `T::Foo: 'x` holds (e.g., where-clause).\n+\n+trait Trait1<'x> {\n+    type Foo;\n+}\n+\n+// calling this fn should trigger a check that the type argument\n+// supplied is well-formed.\n+fn wf<T>() { }\n+\n+fn func<'x, T:Trait1<'x>>(t: &'x T::Foo)\n+{\n+    wf::<&'x T>();\n+    //~^ ERROR the parameter type `T` may not live long enough\n+}\n+\n+fn caller2<'x, T:Trait1<'x>>(t: &'x T)\n+{\n+    wf::<&'x T::Foo>(); // OK\n+}\n+\n+fn caller3<'x, T:Trait1<'x>>(t: &'x T::Foo)\n+{\n+    wf::<&'x T::Foo>(); // OK\n+}\n+\n+fn main() { }"}, {"sha": "b3037a1e187f4ca9f33062b662cbff7444bbc953", "filename": "src/test/compile-fail/regions-implied-bounds-projection-gap-2.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-implied-bounds-projection-gap-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-implied-bounds-projection-gap-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-implied-bounds-projection-gap-2.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Along with the other tests in this series, illustrates the\n+// \"projection gap\": in this test, we know that `T: 'x`, and that is\n+// enough to conclude that `T::Foo: 'x`.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+\n+trait Trait1<'x> {\n+    type Foo;\n+}\n+\n+// calling this fn should trigger a check that the type argument\n+// supplied is well-formed.\n+fn wf<T>() { }\n+\n+fn func<'x, T:Trait1<'x>>(t: &'x T)\n+{\n+    wf::<&'x T::Foo>();\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "a2e6de2137696f98e0009cdc5cf7d07580c6b06d", "filename": "src/test/compile-fail/regions-implied-bounds-projection-gap-3.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-implied-bounds-projection-gap-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-implied-bounds-projection-gap-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-implied-bounds-projection-gap-3.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Along with the other tests in this series, illustrates the\n+// \"projection gap\": in this test, we know that `T::Foo: 'x`, and that\n+// is (naturally) enough to conclude that `T::Foo: 'x`.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+\n+trait Trait1<'x> {\n+    type Foo;\n+}\n+\n+// calling this fn should trigger a check that the type argument\n+// supplied is well-formed.\n+fn wf<T>() { }\n+\n+fn func<'x, T:Trait1<'x>>(t: &'x T::Foo)\n+{\n+    wf::<&'x T::Foo>();\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "b8582f8c26b3147b3e991a9cf1a970e19b043b7a", "filename": "src/test/compile-fail/regions-implied-bounds-projection-gap-4.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-implied-bounds-projection-gap-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-implied-bounds-projection-gap-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-implied-bounds-projection-gap-4.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Along with the other tests in this series, illustrates the\n+// \"projection gap\": in this test, we know that `T: 'x`, and that\n+// is (naturally) enough to conclude that `T: 'x`.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+\n+trait Trait1<'x> {\n+    type Foo;\n+}\n+\n+// calling this fn should trigger a check that the type argument\n+// supplied is well-formed.\n+fn wf<T>() { }\n+\n+fn func<'x, T:Trait1<'x>>(t: &'x T)\n+{\n+    wf::<&'x T>();\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "47985f931dd34fe190cb588e123f6c69d1959a26", "filename": "src/test/compile-fail/regions-implied-bounds-projection-gap-hr-1.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-implied-bounds-projection-gap-hr-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-implied-bounds-projection-gap-hr-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-implied-bounds-projection-gap-hr-1.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// The \"projection gap\" is particularly \"fun\" around higher-ranked\n+// projections.  This is because the current code is hard-coded to say\n+// that a projection that contains escaping regions, like `<T as\n+// Trait2<'y, 'z>>::Foo` where `'z` is bound, can only be found to\n+// outlive a region if all components that appear free (`'y`, where)\n+// outlive that region. However, we DON'T add those components to the\n+// implied bounds set, but rather we treat projections with escaping\n+// regions as opaque entities, just like projections without escaping\n+// regions.\n+\n+trait Trait1<T> { }\n+\n+trait Trait2<'a, 'b> {\n+    type Foo;\n+}\n+\n+fn wf<T>() { }\n+\n+// As a side-effect of the conservative process above, this argument\n+// is not automatically considered well-formed, since for it to be WF,\n+// we would need to know that `'y: 'x`, but we do not infer that.\n+fn callee<'x, 'y, T>(\n+    t: &'x for<'z> Trait1< <T as Trait2<'y, 'z>>::Foo >)\n+{\n+    wf::<&'x &'y i32>();\n+    //~^ ERROR reference has a longer lifetime than the data it references\n+}\n+\n+fn main() { }"}, {"sha": "db25a0698fed4333e21c74f76b87a1407d06d431", "filename": "src/test/compile-fail/regions-outlives-nominal-type-enum-region-rev.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-outlives-nominal-type-enum-region-rev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-outlives-nominal-type-enum-region-rev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-outlives-nominal-type-enum-region-rev.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a nominal type (like `Foo<'a>`) outlives `'b` if its\n+// arguments (like `'a`) outlive `'b`.\n+//\n+// Rule OutlivesNominalType from RFC 1214.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+mod rev_variant_struct_region {\n+    struct Foo<'a> {\n+        x: fn(&'a i32),\n+    }\n+    enum Bar<'a,'b> {\n+        V(&'a Foo<'b>) //~ ERROR reference has a longer lifetime\n+    }\n+}\n+\n+#[rustc_error]\n+fn main() { }"}, {"sha": "403757042d2f3521783564870700ef2323abd7a9", "filename": "src/test/compile-fail/regions-outlives-nominal-type-enum-region.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-outlives-nominal-type-enum-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-outlives-nominal-type-enum-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-outlives-nominal-type-enum-region.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a nominal type (like `Foo<'a>`) outlives `'b` if its\n+// arguments (like `'a`) outlive `'b`.\n+//\n+// Rule OutlivesNominalType from RFC 1214.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+mod variant_struct_region {\n+    struct Foo<'a> {\n+        x: &'a i32,\n+    }\n+    enum Bar<'a,'b> {\n+        V(&'a Foo<'b>) //~ ERROR reference has a longer lifetime\n+    }\n+}\n+\n+#[rustc_error]\n+fn main() { }"}, {"sha": "cc294651db773cc91b5c44abfe268f89526f2a73", "filename": "src/test/compile-fail/regions-outlives-nominal-type-enum-type-rev.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-outlives-nominal-type-enum-type-rev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-outlives-nominal-type-enum-type-rev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-outlives-nominal-type-enum-type-rev.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a nominal type (like `Foo<'a>`) outlives `'b` if its\n+// arguments (like `'a`) outlive `'b`.\n+//\n+// Rule OutlivesNominalType from RFC 1214.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+mod rev_variant_struct_type {\n+    struct Foo<T> {\n+        x: fn(T)\n+    }\n+    enum Bar<'a,'b> {\n+        V(&'a Foo<&'b i32>) //~ ERROR reference has a longer lifetime\n+    }\n+}\n+\n+#[rustc_error]\n+fn main() { }"}, {"sha": "e269767cc1683a817feb16692387077aa5fcf532", "filename": "src/test/compile-fail/regions-outlives-nominal-type-enum-type.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-outlives-nominal-type-enum-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-outlives-nominal-type-enum-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-outlives-nominal-type-enum-type.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a nominal type (like `Foo<'a>`) outlives `'b` if its\n+// arguments (like `'a`) outlive `'b`.\n+//\n+// Rule OutlivesNominalType from RFC 1214.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+mod variant_struct_type {\n+    struct Foo<T> {\n+        x: T\n+    }\n+    enum Bar<'a,'b> {\n+        F(&'a Foo<&'b i32>) //~ ERROR reference has a longer lifetime\n+    }\n+}\n+\n+#[rustc_error]\n+fn main() { }"}, {"sha": "c7e6ace8b9224165050e505bbb6c603ebe2e02e4", "filename": "src/test/compile-fail/regions-outlives-nominal-type-struct-region-rev.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-outlives-nominal-type-struct-region-rev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-outlives-nominal-type-struct-region-rev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-outlives-nominal-type-struct-region-rev.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a nominal type (like `Foo<'a>`) outlives `'b` if its\n+// arguments (like `'a`) outlive `'b`.\n+//\n+// Rule OutlivesNominalType from RFC 1214.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+mod rev_variant_struct_region {\n+    struct Foo<'a> {\n+        x: fn(&'a i32),\n+    }\n+    struct Bar<'a,'b> {\n+        f: &'a Foo<'b> //~ ERROR reference has a longer lifetime\n+    }\n+}\n+\n+#[rustc_error]\n+fn main() { }"}, {"sha": "2fe6444c33aecd1d060c68c22b280fd99f63f54e", "filename": "src/test/compile-fail/regions-outlives-nominal-type-struct-region.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-outlives-nominal-type-struct-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-outlives-nominal-type-struct-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-outlives-nominal-type-struct-region.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a nominal type (like `Foo<'a>`) outlives `'b` if its\n+// arguments (like `'a`) outlive `'b`.\n+//\n+// Rule OutlivesNominalType from RFC 1214.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+mod variant_struct_region {\n+    struct Foo<'a> {\n+        x: &'a i32,\n+    }\n+    struct Bar<'a,'b> {\n+        f: &'a Foo<'b> //~ ERROR reference has a longer lifetime\n+    }\n+}\n+\n+#[rustc_error]\n+fn main() { }"}, {"sha": "c4b631bce98740d191b6ec3411c516075cd910b3", "filename": "src/test/compile-fail/regions-outlives-nominal-type-struct-type-rev.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-outlives-nominal-type-struct-type-rev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-outlives-nominal-type-struct-type-rev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-outlives-nominal-type-struct-type-rev.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a nominal type (like `Foo<'a>`) outlives `'b` if its\n+// arguments (like `'a`) outlive `'b`.\n+//\n+// Rule OutlivesNominalType from RFC 1214.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+mod rev_variant_struct_type {\n+    struct Foo<T> {\n+        x: fn(T)\n+    }\n+    struct Bar<'a,'b> {\n+        f: &'a Foo<&'b i32> //~ ERROR reference has a longer lifetime\n+    }\n+}\n+\n+#[rustc_error]\n+fn main() { }"}, {"sha": "1c9489444a6a3a70bdc8a78ed0d6f3dfaba702ee", "filename": "src/test/compile-fail/regions-outlives-nominal-type-struct-type.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-outlives-nominal-type-struct-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-outlives-nominal-type-struct-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-outlives-nominal-type-struct-type.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a nominal type (like `Foo<'a>`) outlives `'b` if its\n+// arguments (like `'a`) outlive `'b`.\n+//\n+// Rule OutlivesNominalType from RFC 1214.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+mod variant_struct_type {\n+    struct Foo<T> {\n+        x: T\n+    }\n+    struct Bar<'a,'b> {\n+        f: &'a Foo<&'b i32> //~ ERROR reference has a longer lifetime\n+    }\n+}\n+\n+#[rustc_error]\n+fn main() { }"}, {"sha": "b8c4a7f8a8c0555e2be24ab036cb96b4397795ef", "filename": "src/test/compile-fail/regions-outlives-projection-container-hrtb.rs", "status": "renamed", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-outlives-projection-container-hrtb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-outlives-projection-container-hrtb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-outlives-projection-container-hrtb.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -37,10 +37,10 @@ pub struct WithHrAssoc<T>\n }\n \n fn with_assoc<'a,'b>() {\n-    // We get no error here because the where clause has a higher-ranked assoc type,\n-    // which could not be projected from.\n+    // We get an error because beacuse 'b:'a does not hold:\n \n     let _: &'a WithHrAssoc<TheType<'b>> = loop { };\n+    //~^ ERROR reference has a longer lifetime\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -57,12 +57,13 @@ pub struct WithHrAssocSub<T>\n }\n \n fn with_assoc_sub<'a,'b>() {\n-    // Same here, because although the where clause is not HR, it\n-    // extends a trait in a HR way.\n+    // The error here is just because `'b:'a` must hold for the type\n+    // below to be well-formed, it is not related to the HR relation.\n \n     let _: &'a WithHrAssocSub<TheType<'b>> = loop { };\n+    //~^ ERROR reference has a longer lifetime\n }\n \n #[rustc_error]\n-fn main() { //~ ERROR compilation successful\n+fn main() {\n }", "previous_filename": "src/test/compile-fail/regions-assoc-type-outlives-container-hrtb.rs"}, {"sha": "71606ba812fac10b6bfeff57b08cc92220f1cd0c", "filename": "src/test/compile-fail/regions-outlives-projection-container-wc.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-outlives-projection-container-wc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-outlives-projection-container-wc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-outlives-projection-container-wc.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -41,7 +41,8 @@ fn with_assoc<'a,'b>() {\n     // outlive 'a. In this case, that means TheType<'b>::TheAssocType,\n     // which is &'b (), must outlive 'a.\n \n-    let _: &'a WithAssoc<TheType<'b>> = loop { }; //~ ERROR cannot infer\n+    let _: &'a WithAssoc<TheType<'b>> = loop { };\n+    //~^ ERROR reference has a longer lifetime\n }\n \n fn main() {", "previous_filename": "src/test/compile-fail/regions-assoc-type-outlives-container-wc.rs"}, {"sha": "957e56fe5109fed65344c54614d0b9b869c14cd2", "filename": "src/test/compile-fail/regions-outlives-projection-container.rs", "status": "renamed", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-outlives-projection-container.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-outlives-projection-container.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-outlives-projection-container.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -45,7 +45,7 @@ fn with_assoc<'a,'b>() {\n     // outlive 'a. In this case, that means TheType<'b>::TheAssocType,\n     // which is &'b (), must outlive 'a.\n \n-    let _: &'a WithAssoc<TheType<'b>> = loop { }; //~ ERROR cannot infer\n+    let _: &'a WithAssoc<TheType<'b>> = loop { }; //~ ERROR reference has a longer lifetime\n }\n \n fn with_assoc1<'a,'b>() where 'b : 'a {\n@@ -59,11 +59,10 @@ fn with_assoc1<'a,'b>() where 'b : 'a {\n }\n \n fn without_assoc<'a,'b>() {\n-    // Here there are no associated types and the `'b` appearing in\n-    // `TheType<'b>` is purely covariant, so there is no requirement\n-    // that `'b:'a` holds.\n+    // Here there are no associated types but there is a requirement\n+    // that `'b:'a` holds because the `'b` appears in `TheType<'b>`.\n \n-    let _: &'a WithoutAssoc<TheType<'b>> = loop { };\n+    let _: &'a WithoutAssoc<TheType<'b>> = loop { }; //~ ERROR reference has a longer lifetime\n }\n \n fn call_with_assoc<'a,'b>() {\n@@ -72,13 +71,13 @@ fn call_with_assoc<'a,'b>() {\n     // no data.\n \n     call::<&'a WithAssoc<TheType<'b>>>();\n-    //~^ ERROR cannot infer\n+    //~^ ERROR reference has a longer lifetime\n }\n \n fn call_without_assoc<'a,'b>() {\n     // As `without_assoc`, but in a distinct scenario.\n \n-    call::<&'a WithoutAssoc<TheType<'b>>>();\n+    call::<&'a WithoutAssoc<TheType<'b>>>(); //~ ERROR reference has a longer lifetime\n }\n \n fn call<T>() { }", "previous_filename": "src/test/compile-fail/regions-assoc-type-outlives-container.rs"}, {"sha": "2d271b7be73e083a064e816dd374cffe9b72a231", "filename": "src/test/compile-fail/regions-outlives-projection-hrtype.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-outlives-projection-hrtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-outlives-projection-hrtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-outlives-projection-hrtype.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test for the outlives relation when applied to a projection on a\n+// type with bound regions. In this case, we are checking that\n+// `<for<'r> fn(&'r T) as TheTrait>::TheType: 'a` If we're not\n+// careful, we could wind up with a constraint that `'r:'a`, but since\n+// `'r` is bound, that leads to badness. This test checks that\n+// everything works.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+trait TheTrait {\n+    type TheType;\n+}\n+\n+fn wf<T>() { }\n+\n+type FnType<T> = for<'r> fn(&'r T);\n+\n+fn foo<'a,'b,T>()\n+    where FnType<T>: TheTrait\n+{\n+    wf::< <FnType<T> as TheTrait>::TheType >();\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "04682a7729735121e61b4424e2a5077bd63de8e4", "filename": "src/test/compile-fail/regions-outlives-projection-trait-def.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-outlives-projection-trait-def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-outlives-projection-trait-def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-outlives-projection-trait-def.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that `<F as Foo<'a>>::Type: 'b`, where `trait Foo<'a> { Type:\n+// 'a; }`, does not require that `F: 'b`.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+trait SomeTrait<'a> {\n+    type Type: 'a;\n+}\n+\n+impl<'a: 'c, 'c, T> SomeTrait<'a> for &'c T where T: SomeTrait<'a> {\n+    type Type = <T as SomeTrait<'a>>::Type;\n+    //          ~~~~~~~~~~~~~~~~~~~~~~~~~~\n+    //                       |\n+    // Note that this type must outlive 'a, due to the trait\n+    // definition.  If we fall back to OutlivesProjectionComponents\n+    // here, then we would require that `T:'a`, which is too strong.\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "94f7a350cf787789b16f959666a663e28e92d94f", "filename": "src/test/compile-fail/regions-outlives-scalar.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-outlives-scalar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-outlives-scalar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-outlives-scalar.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that scalar values outlive all regions.\n+// Rule OutlivesScalar from RFC 1214.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+struct Foo<'a> {\n+    x: &'a i32,\n+    y: &'static i32\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "a7f1828970324868631255e73dceb297df9575bb", "filename": "src/test/compile-fail/regions-struct-not-wf.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-struct-not-wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-struct-not-wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-struct-not-wf.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -12,20 +12,23 @@\n \n #![allow(dead_code)]\n \n-struct Ref<'a, T> { //~ ERROR the parameter type `T` may not live long enough\n+struct Ref<'a, T> {\n     field: &'a T\n+        //~^ ERROR the parameter type `T` may not live long enough\n }\n \n struct RefOk<'a, T:'a> {\n     field: &'a T\n }\n \n-struct RefIndirect<'a, T> { //~ ERROR the parameter type `T` may not live long enough\n+struct RefIndirect<'a, T> {\n     field: RefOk<'a, T>\n+        //~^ ERROR the parameter type `T` may not live long enough\n }\n \n-struct DoubleRef<'a, 'b, T> { //~ ERROR reference has a longer lifetime than the data it references\n+struct DoubleRef<'a, 'b, T> {\n     field: &'a &'b T\n+        //~^ ERROR reference has a longer lifetime than the data it references\n }\n \n fn main() { }"}, {"sha": "e1f1fdaeb341d5bbcb10469de482e124e9d9ebf0", "filename": "src/test/compile-fail/regions-wf-trait-object.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-wf-trait-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fregions-wf-trait-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-wf-trait-object.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.t\n+\n+// Check that the explicit lifetime bound (`'b`, in this example) must\n+// outlive all the superbound from the trait (`'a`, in this example).\n+\n+trait TheTrait<'t>: 't { }\n+\n+struct Foo<'a,'b> {\n+    x: Box<TheTrait<'a>+'b>\n+        //~^ ERROR reference has a longer lifetime\n+}\n+\n+fn main() { }"}, {"sha": "50fd3fc961c1d808fa9e98147b594cb07bdcb5bf", "filename": "src/test/compile-fail/rfc1214-warn-and-error.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Frfc1214-warn-and-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Frfc1214-warn-and-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc1214-warn-and-error.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that an RFC1214 warning from an earlier function (`foo`) does\n+// not suppress an error for the same problem (`WantEq<NotEq>`,\n+// `NotEq: !Eq`) in a later function (`bar)`. Earlier versions of the\n+// warning mechanism had an issue due to caching.\n+\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+\n+struct WantEq<T:Eq> { t: T }\n+\n+struct NotEq;\n+\n+trait Trait<T> { }\n+\n+fn foo() {\n+    let x: Box<Trait<WantEq<NotEq>>> = loop { };\n+    //~^ WARN E0277\n+}\n+\n+fn bar() {\n+    wf::<WantEq<NotEq>>();\n+    //~^ ERROR E0277\n+}\n+\n+fn wf<T>() { }\n+\n+fn main() { }"}, {"sha": "dbfda61f5525a41a46283f78709a80006f54bac4", "filename": "src/test/compile-fail/trait-bounds-on-structs-and-enums-in-fns.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-in-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-in-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-in-fns.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Trait {}\n+\n+struct Foo<T:Trait> {\n+    x: T,\n+}\n+\n+enum Bar<T:Trait> {\n+    ABar(isize),\n+    BBar(T),\n+    CBar(usize),\n+}\n+\n+fn explode(x: Foo<u32>) {}\n+//~^ ERROR not implemented\n+\n+fn kaboom(y: Bar<f32>) {}\n+//~^ ERROR not implemented\n+\n+fn main() {\n+}"}, {"sha": "c647dd38ee38a5aba56257c845e68aa53045cd26", "filename": "src/test/compile-fail/trait-bounds-on-structs-and-enums-in-impls.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-in-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-in-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-in-impls.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Trait {}\n+\n+struct Foo<T:Trait> {\n+    x: T,\n+}\n+\n+enum Bar<T:Trait> {\n+    ABar(isize),\n+    BBar(T),\n+    CBar(usize),\n+}\n+\n+trait PolyTrait<T>\n+{\n+    fn whatever(&self, t: T) {}\n+}\n+\n+struct Struct;\n+\n+impl PolyTrait<Foo<u16>> for Struct {\n+//~^ ERROR not implemented\n+}\n+\n+fn main() {\n+}"}, {"sha": "e1b005b0c8533b3baf78494245c7744769ebea46", "filename": "src/test/compile-fail/trait-bounds-on-structs-and-enums.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -20,12 +20,6 @@ enum Bar<T:Trait> {\n     CBar(usize),\n }\n \n-fn explode(x: Foo<u32>) {}\n-//~^ ERROR not implemented\n-\n-fn kaboom(y: Bar<f32>) {}\n-//~^ ERROR not implemented\n-\n impl<T> Foo<T> {\n //~^ ERROR the trait `Trait` is not implemented\n     fn uhoh() {}\n@@ -55,16 +49,5 @@ enum Enum {\n     DictionaryLike { field: Bar<u8> }, //~ ERROR not implemented\n }\n \n-trait PolyTrait<T>\n-{\n-    fn whatever(&self, t: T) {}\n-}\n-\n-struct Struct;\n-\n-impl PolyTrait<Foo<u16>> for Struct {\n-//~^ ERROR not implemented\n-}\n-\n fn main() {\n }"}, {"sha": "baf239f5956d645b924686b0903e290d9c6b05de", "filename": "src/test/compile-fail/trait-object-safety.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Ftrait-object-safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Ftrait-object-safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-object-safety.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -22,5 +22,6 @@ impl Tr for St {\n }\n \n fn main() {\n-    let _: &Tr = &St; //~ ERROR cannot convert to a trait object because trait `Tr` is not\n+    let _: &Tr = &St; //~ ERROR E0038\n+    //~^ ERROR E0038\n }"}, {"sha": "b11cbde292969018ae9ec870d9b2be0895ad83e9", "filename": "src/test/compile-fail/trait-test-2.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -17,6 +17,8 @@ impl bar for u32 { fn dup(&self) -> u32 { *self } fn blah<X>(&self) {} }\n fn main() {\n     10.dup::<i32>(); //~ ERROR does not take type parameters\n     10.blah::<i32, i32>(); //~ ERROR incorrect number of type parameters\n-    (box 10 as Box<bar>).dup(); //~ ERROR cannot convert to a trait object\n-    //~^ ERROR the trait `bar` is not implemented for the type `bar`\n+    (box 10 as Box<bar>).dup();\n+    //~^ ERROR E0038\n+    //~| ERROR E0038\n+    //~| ERROR E0277\n }"}, {"sha": "80d2884ee60aaaa84ea870748a70a295cd98f7e9", "filename": "src/test/compile-fail/traits-issue-23003-overflow.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Ftraits-issue-23003-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Ftraits-issue-23003-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftraits-issue-23003-overflow.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -9,10 +9,11 @@\n // except according to those terms.\n \n // A variant of traits-issue-23003 in which an infinite series of\n-// types are required. This currently creates an overflow. This test\n-// is included to ensure that some controlled failure, at least,\n-// results -- but it might be that we should adjust the rules somewhat\n-// to make this legal. -nmatsakis\n+// types are required. This test now just compiles fine, since the\n+// relevant rules that triggered the overflow were removed.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n \n use std::marker::PhantomData;\n \n@@ -32,7 +33,7 @@ impl<B> Async for Complete<B> {\n     type Cancel = Receipt<Complete<Option<B>>>;\n }\n \n-fn foo(r: Receipt<Complete<()>>) { }\n-//~^ ERROR overflow\n+fn foo(_: Receipt<Complete<()>>) { }\n \n-fn main() { }\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "c37f45dcf50bb8911f9c3f6a140162942ebe9c15", "filename": "src/test/compile-fail/traits-negative-impls.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Ftraits-negative-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Ftraits-negative-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftraits-negative-impls.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -32,12 +32,23 @@ fn dummy() {\n \n     Outer(TestType);\n     //~^ ERROR the trait `core::marker::Send` is not implemented for the type `dummy::TestType`\n+    //~| ERROR the trait `core::marker::Send` is not implemented for the type `dummy::TestType`\n+}\n+\n+fn dummy1b() {\n+    struct TestType;\n+    impl !Send for TestType {}\n \n     is_send(TestType);\n-    //~^ ERROR the trait `core::marker::Send` is not implemented for the type `dummy::TestType`\n+    //~^ ERROR the trait `core::marker::Send` is not implemented for the type `dummy1b::TestType`\n+}\n+\n+fn dummy1c() {\n+    struct TestType;\n+    impl !Send for TestType {}\n \n     is_send((8, TestType));\n-    //~^ ERROR the trait `core::marker::Send` is not implemented for the type `dummy::TestType`\n+    //~^ ERROR the trait `core::marker::Send` is not implemented for the type `dummy1c::TestType`\n }\n \n fn dummy2() {"}, {"sha": "09687724656fa8febe373f1f01ed750e45efed27", "filename": "src/test/compile-fail/type-parameter-defaults-referencing-Self-ppaux.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Ftype-parameter-defaults-referencing-Self-ppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Ftype-parameter-defaults-referencing-Self-ppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-parameter-defaults-referencing-Self-ppaux.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -22,5 +22,6 @@ impl MyAdd for i32 {\n fn main() {\n     let x: i32 = 5;\n     let y = x as MyAdd<i32>;\n-    //~^ ERROR as `MyAdd<i32>`\n+    //~^ ERROR E0038\n+    //~| ERROR cast to unsized type: `i32` as `MyAdd<i32>`\n }"}, {"sha": "319b81bde36ed02bb556fca7367e5ca80a6e49d8", "filename": "src/test/compile-fail/variance-regions-direct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -42,7 +42,7 @@ struct Test4<'a, 'b:'a> { //~ ERROR regions=[[-, o];[];[]]\n // contravariant context:\n \n #[rustc_variance]\n-struct Test5<'a, 'b> { //~ ERROR regions=[[+, o];[];[]]\n+struct Test5<'a, 'b:'a> { //~ ERROR regions=[[+, o];[];[]]\n     x: extern \"Rust\" fn(&'a mut &'b isize),\n }\n \n@@ -52,7 +52,7 @@ struct Test5<'a, 'b> { //~ ERROR regions=[[+, o];[];[]]\n // argument list occurs in an invariant context.\n \n #[rustc_variance]\n-struct Test6<'a, 'b> { //~ ERROR regions=[[-, o];[];[]]\n+struct Test6<'a, 'b:'a> { //~ ERROR regions=[[-, o];[];[]]\n     x: &'a mut extern \"Rust\" fn(&'b isize),\n }\n "}, {"sha": "c8b7f35b3aa58355940f5201b3f79a2fab0c7f20", "filename": "src/test/compile-fail/wf-array-elem-sized.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-array-elem-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-array-elem-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-array-elem-sized.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that array elemen types must be Sized. Issue #25692.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+struct Foo {\n+    foo: [[u8]], //~ WARN E0277\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "c3015afd8dd0d95f00f8ae6841b61a831f9104a0", "filename": "src/test/compile-fail/wf-const-type.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-const-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-const-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-const-type.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we check the types of constants are well-formed.\n+\n+#![feature(associated_type_defaults)]\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+struct IsCopy<T:Copy> { t: T }\n+struct NotCopy;\n+\n+const FOO: IsCopy<Option<NotCopy>> = IsCopy { t: None };\n+//~^ ERROR E0277\n+\n+#[rustc_error]\n+fn main() { }"}, {"sha": "1d271d1530a75823fc7c3da83ab75e8d0eee0473", "filename": "src/test/compile-fail/wf-enum-bound.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-enum-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-enum-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-enum-bound.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we check enum bounds for WFedness.\n+\n+#![feature(associated_type_defaults)]\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+trait ExtraCopy<T:Copy> { }\n+\n+enum SomeEnum<T,U> //~ WARN E0277\n+    where T: ExtraCopy<U>\n+{\n+    SomeVariant(T,U)\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "5eb53e7edde6b8634bdb2f993da98fba90ae8cf1", "filename": "src/test/compile-fail/wf-enum-fields-struct-variant.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-enum-fields-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-enum-fields-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-enum-fields-struct-variant.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we check struct fields for WFedness.\n+\n+#![feature(associated_type_defaults)]\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+struct IsCopy<T:Copy> {\n+    value: T\n+}\n+\n+enum AnotherEnum<A> {\n+    AnotherVariant {\n+        f: IsCopy<A> //~ ERROR E0277\n+    }\n+}\n+\n+#[rustc_error]\n+fn main() { }"}, {"sha": "76ad40f845768280ca2b39a22d1d43aa8efcdea0", "filename": "src/test/compile-fail/wf-enum-fields.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-enum-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-enum-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-enum-fields.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we check struct fields for WFedness.\n+\n+#![feature(associated_type_defaults)]\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+struct IsCopy<T:Copy> {\n+    value: T\n+}\n+\n+enum SomeEnum<A> {\n+    SomeVariant(IsCopy<A>) //~ ERROR E0277\n+}\n+\n+#[rustc_error]\n+fn main() { }"}, {"sha": "769894613c76496dfb318e339ef46e2a9addc342", "filename": "src/test/compile-fail/wf-fn-where-clause.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-fn-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-fn-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-fn-where-clause.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we check where-clauses on fn items.\n+\n+#![feature(associated_type_defaults)]\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+trait ExtraCopy<T:Copy> { }\n+\n+fn foo<T,U>() where T: ExtraCopy<U> //~ WARN E0277\n+{\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "2d7727fff35033c2c98157c381bff06cf90ee414", "filename": "src/test/compile-fail/wf-impl-associated-type-region.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-impl-associated-type-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-impl-associated-type-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-impl-associated-type-region.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we require that associated types in an impl are well-formed.\n+\n+#![feature(rustc_attrs)]\n+\n+pub trait Foo<'a> {\n+    type Bar;\n+}\n+\n+impl<'a, T> Foo<'a> for T {\n+    type Bar = &'a T; //~ WARN E0309\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation"}, {"sha": "8a612c321570d4253a196955fc9de04be17e46fb", "filename": "src/test/compile-fail/wf-impl-associated-type-trait.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-impl-associated-type-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-impl-associated-type-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-impl-associated-type-trait.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we require that associated types in an impl are well-formed.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+pub trait MyHash { }\n+\n+pub struct MySet<T:MyHash> {\n+    data: Vec<T>\n+}\n+\n+pub trait Foo {\n+    type Bar;\n+}\n+\n+impl<T> Foo for T {\n+    type Bar = MySet<T>;\n+    //~^ WARN the trait `MyHash` is not implemented for the type `T`\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful\n+"}, {"sha": "e302cac0006b17e3fad01b7c2f1724c10613a0e2", "filename": "src/test/compile-fail/wf-in-fn-arg.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-in-fn-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-in-fn-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-in-fn-arg.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we enforce WF conditions also for argument types in fn items.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+struct MustBeCopy<T:Copy> {\n+    t: T\n+}\n+\n+fn bar<T>(_: &MustBeCopy<T>) //~ ERROR E0277\n+{\n+}\n+\n+fn main() { }"}, {"sha": "719bc9282ad7ddd9548e312ef0f5acc6b37fe0d2", "filename": "src/test/compile-fail/wf-in-fn-ret.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-in-fn-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-in-fn-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-in-fn-ret.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we enforce WF conditions also for return types in fn items.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+struct MustBeCopy<T:Copy> {\n+    t: T\n+}\n+\n+fn bar<T>() -> MustBeCopy<T> //~ ERROR E0277\n+{\n+}\n+\n+fn main() { }"}, {"sha": "08ee0e954ac2d73daae4b5833c73945b0685c42e", "filename": "src/test/compile-fail/wf-in-fn-type-arg.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-in-fn-type-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-in-fn-type-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-in-fn-type-arg.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we enforce WF conditions also for types in fns.\n+\n+struct MustBeCopy<T:Copy> {\n+    t: T\n+}\n+\n+struct Bar<T> {\n+    // needs T: Copy\n+    x: fn(MustBeCopy<T>) //~ ERROR E0277\n+}\n+\n+fn main() { }"}, {"sha": "6942f7860606090617208d81c2910d1a5c450adf", "filename": "src/test/compile-fail/wf-in-fn-type-ret.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-in-fn-type-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-in-fn-type-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-in-fn-type-ret.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we enforce WF conditions also for types in fns.\n+\n+struct MustBeCopy<T:Copy> {\n+    t: T\n+}\n+\n+struct Foo<T> {\n+    // needs T: 'static\n+    x: fn() -> MustBeCopy<T> //~ ERROR E0277\n+}\n+\n+fn main() { }"}, {"sha": "593c9435f6c751dc607575a58e2018a826507442", "filename": "src/test/compile-fail/wf-in-fn-type-static.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-in-fn-type-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-in-fn-type-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-in-fn-type-static.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we enforce WF conditions related to regions also for\n+// types in fns.\n+\n+#![allow(dead_code)]\n+#![feature(rustc_attrs)]\n+\n+struct MustBeCopy<T:Copy> {\n+    t: T\n+}\n+\n+struct Foo<T> {\n+    // needs T: 'static\n+    x: fn() -> &'static T //~ WARN E0310\n+}\n+\n+struct Bar<T> {\n+    // needs T: Copy\n+    x: fn(&'static T) //~ WARN E0310\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "fc3d234aac252d6ae31db99f70c9c46185e30602", "filename": "src/test/compile-fail/wf-in-fn-where-clause.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-in-fn-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-in-fn-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-in-fn-where-clause.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we enforce WF conditions also for where clauses in fn items.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+trait MustBeCopy<T:Copy> {\n+}\n+\n+fn bar<T,U>() //~ WARN E0277\n+    where T: MustBeCopy<U>\n+{\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "c697dfd50ad471c3b9add3da74dfd81b82e08878", "filename": "src/test/compile-fail/wf-in-obj-type-static.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-in-obj-type-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-in-obj-type-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-in-obj-type-static.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we enforce WF conditions also for types in fns.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+trait Object<T> { }\n+\n+struct MustBeCopy<T:Copy> {\n+    t: T\n+}\n+\n+struct Foo<T> {\n+    // needs T: 'static\n+    x: Object<&'static T> //~ WARN E0310\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "add48219c1d7eb5cdc6166b36b532e05a7447405", "filename": "src/test/compile-fail/wf-in-obj-type-trait.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-in-obj-type-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-in-obj-type-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-in-obj-type-trait.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we enforce WF conditions also for types in fns.\n+\n+trait Object<T> { }\n+\n+struct MustBeCopy<T:Copy> {\n+    t: T\n+}\n+\n+struct Bar<T> {\n+    // needs T: Copy\n+    x: Object<MustBeCopy<T>> //~ ERROR E0277\n+}\n+\n+fn main() { }"}, {"sha": "44671be8355336674ed49ef30e406ec064a2bda1", "filename": "src/test/compile-fail/wf-inherent-impl-method-where-clause.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-inherent-impl-method-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-inherent-impl-method-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-inherent-impl-method-where-clause.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we check where-clauses on inherent impl methods.\n+\n+#![feature(associated_type_defaults)]\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+trait ExtraCopy<T:Copy> { }\n+\n+struct Foo<T,U>(T,U);\n+\n+impl<T,U> Foo<T,U> {\n+    fn foo(self) where T: ExtraCopy<U> //~ WARN E0277\n+    {}\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "a0f588c1961d17ec2c9d6315e6b6bb20e6d270ca", "filename": "src/test/compile-fail/wf-inherent-impl-where-clause.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-inherent-impl-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-inherent-impl-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-inherent-impl-where-clause.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we check where-clauses on inherent impls.\n+\n+#![feature(associated_type_defaults)]\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+trait ExtraCopy<T:Copy> { }\n+\n+struct Foo<T,U>(T,U);\n+\n+impl<T,U> Foo<T,U> where T: ExtraCopy<U> //~ WARN E0277\n+{\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "92c0a8c5be8af92c0c15a14b38bddc4aa623c020", "filename": "src/test/compile-fail/wf-object-safe.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-object-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-object-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-object-safe.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that object-safe traits are not WF when used as object types.\n+// Issue #21953.\n+\n+trait A {\n+    fn foo(&self, _x: &Self);\n+}\n+\n+fn main() {\n+    let _x: &A; //~ ERROR E0038\n+}"}, {"sha": "dc0cbeff153a96c66447e498e5c566b7801918ff", "filename": "src/test/compile-fail/wf-outlives-ty-in-fn-or-trait.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-outlives-ty-in-fn-or-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-outlives-ty-in-fn-or-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-outlives-ty-in-fn-or-trait.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that an appearance of `T` in fn args or in a trait object must\n+// still meet the outlives bounds. Since this is a new requirement,\n+// this is currently only a warning, not a hard error.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+trait Trait<T> { }\n+\n+struct Foo<'a,T> {\n+    f: &'a fn(T),\n+    //~^ WARN E0309\n+}\n+\n+struct Bar<'a,T> {\n+    f: &'a Trait<T>,\n+    //~^ WARN E0309\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful\n+"}, {"sha": "ba02c5dca3e6d7d49635fb92edacae2a88c5dfca", "filename": "src/test/compile-fail/wf-static-type.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-static-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-static-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-static-type.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we check the types of statics are well-formed.\n+\n+#![feature(associated_type_defaults)]\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+struct IsCopy<T:Copy> { t: T }\n+struct NotCopy;\n+\n+static FOO: IsCopy<Option<NotCopy>> = IsCopy { t: None };\n+//~^ ERROR E0277\n+\n+#[rustc_error]\n+fn main() { }"}, {"sha": "43378061e40c0bc5e04f48e8c458847cfdc67692", "filename": "src/test/compile-fail/wf-struct-bound.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-struct-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-struct-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-struct-bound.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we check struct bounds for WFedness.\n+\n+#![feature(associated_type_defaults)]\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+trait ExtraCopy<T:Copy> { }\n+\n+struct SomeStruct<T,U> //~ WARN E0277\n+    where T: ExtraCopy<U>\n+{\n+    data: (T,U)\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "8a631a6c335a050598492ad1e5663006edd5e60f", "filename": "src/test/compile-fail/wf-struct-field.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-struct-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-struct-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-struct-field.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we check struct fields for WFedness.\n+\n+#![feature(associated_type_defaults)]\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+struct IsCopy<T:Copy> {\n+    value: T\n+}\n+\n+struct SomeStruct<A> {\n+    data: IsCopy<A> //~ ERROR E0277\n+}\n+\n+#[rustc_error]\n+fn main() { }"}, {"sha": "63a532138e3bd84b3464f78fa581c20818f9a5e1", "filename": "src/test/compile-fail/wf-trait-associated-type-bound.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-trait-associated-type-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-trait-associated-type-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-trait-associated-type-bound.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we check associated type bounds for WFedness.\n+\n+#![feature(associated_type_defaults)]\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+trait ExtraCopy<T:Copy> { }\n+\n+trait SomeTrait<T> { //~ WARN E0277\n+    type Type1: ExtraCopy<T>;\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "b3aa4e19c96560a4cb5c830b8a2da609acf1522f", "filename": "src/test/compile-fail/wf-trait-associated-type-region.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-trait-associated-type-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-trait-associated-type-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-trait-associated-type-region.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we check associated type default values for WFedness.\n+\n+#![feature(associated_type_defaults)]\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+trait SomeTrait<'a> {\n+    type Type1;\n+    type Type2 = &'a Self::Type1;\n+    //~^ WARN E0309\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "8c491e04c981dff443772c539de9a0334f06d8a6", "filename": "src/test/compile-fail/wf-trait-associated-type-trait.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-trait-associated-type-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-trait-associated-type-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-trait-associated-type-trait.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we check associated type default values for WFedness.\n+\n+#![feature(associated_type_defaults)]\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+struct IsCopy<T:Copy> { x: T }\n+\n+trait SomeTrait {\n+    type Type1;\n+    type Type2 = IsCopy<Self::Type1>;\n+    //~^ WARN E0277\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "147b3ce236d42d1e599e401ac82eb1399c418235", "filename": "src/test/compile-fail/wf-trait-bound.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-trait-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-trait-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-trait-bound.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we check supertrait bounds for WFedness.\n+\n+#![feature(associated_type_defaults)]\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+trait ExtraCopy<T:Copy> { }\n+\n+trait SomeTrait<T,U> //~ WARN E0277\n+    where T: ExtraCopy<U>\n+{\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "57c6c1979f87ed0094714a5f672c53964673af87", "filename": "src/test/compile-fail/wf-trait-default-fn-arg.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-trait-default-fn-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-trait-default-fn-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-trait-default-fn-arg.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we test WF conditions for fn arguments. Because the\n+// current code is so goofy, this is only a warning for now.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+\n+struct Bar<T:Eq+?Sized> { value: Box<T> }\n+\n+trait Foo {\n+    fn bar(&self, x: &Bar<Self>) {\n+        //~^ WARN E0277\n+        //\n+        // Here, Eq ought to be implemented.\n+    }\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "939876403e54db06d2dfb3e96b88f5c605ec59d5", "filename": "src/test/compile-fail/wf-trait-default-fn-ret.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-trait-default-fn-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-trait-default-fn-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-trait-default-fn-ret.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we test WF conditions for fn arguments. Because the\n+// current code is so goofy, this is only a warning for now.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+\n+struct Bar<T:Eq+?Sized> { value: Box<T> }\n+\n+trait Foo {\n+    fn bar(&self) -> Bar<Self> {\n+        //~^ WARN E0277\n+        //\n+        // Here, Eq ought to be implemented.\n+        loop { }\n+    }\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "b1c0d71fc5b3b75c784c8fb315c4c266931db5d6", "filename": "src/test/compile-fail/wf-trait-default-fn-where-clause.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-trait-default-fn-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-trait-default-fn-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-trait-default-fn-where-clause.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we test WF conditions for fn arguments. Because the\n+// current code is so goofy, this is only a warning for now.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+\n+trait Bar<T:Eq+?Sized> { }\n+\n+trait Foo {\n+    fn bar<A>(&self) where A: Bar<Self> {\n+        //~^ WARN E0277\n+        //\n+        // Here, Eq ought to be implemented.\n+    }\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "ff263c85eb371a6bce67ec6b1430c5c786424914", "filename": "src/test/compile-fail/wf-trait-fn-arg.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-trait-fn-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-trait-fn-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-trait-fn-arg.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we test WF conditions for fn arguments in a trait definition.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+\n+struct Bar<T:Eq+?Sized> { value: Box<T> }\n+\n+trait Foo {\n+    fn bar(&self, x: &Bar<Self>);\n+        //~^ WARN E0277\n+        //\n+        // Here, Eq ought to be implemented.\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "5c8f3030c2c21b947879a13dde2a9ac53e12459a", "filename": "src/test/compile-fail/wf-trait-fn-ret.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-trait-fn-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-trait-fn-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-trait-fn-ret.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we test WF conditions for fn return types in a trait definition.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+\n+struct Bar<T:Eq+?Sized> { value: Box<T> }\n+\n+trait Foo {\n+    fn bar(&self) -> &Bar<Self>;\n+        //~^ WARN E0277\n+        //\n+        // Here, Eq ought to be implemented.\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "51b5475e51fba1df8398509b65f3482983fcb5c9", "filename": "src/test/compile-fail/wf-trait-fn-where-clause.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-trait-fn-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-trait-fn-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-trait-fn-where-clause.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we test WF conditions for fn where clauses in a trait definition.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+\n+struct Bar<T:Eq+?Sized> { value: Box<T> }\n+\n+trait Foo {\n+    fn bar(&self) where Bar<Self>: Copy;\n+        //~^ WARN E0277\n+        //\n+        // Here, Eq ought to be implemented.\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "58ee766dad112fdb40c52ae89e9a03c8ab6cb794", "filename": "src/test/compile-fail/wf-trait-superbound.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-trait-superbound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Fcompile-fail%2Fwf-trait-superbound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-trait-superbound.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we check supertrait bounds for WFedness.\n+\n+#![feature(associated_type_defaults)]\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+trait ExtraCopy<T:Copy> { }\n+\n+trait SomeTrait<T>: ExtraCopy<T> { //~ WARN E0277\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "7968cc37090acffe1d09cc411bdd1c2fe813c5af", "filename": "src/test/compile-fail/where-clauses-not-parameter.rs", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0649b16ade40d1fb02ea5c390293278bd876854a/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-not-parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0649b16ade40d1fb02ea5c390293278bd876854a/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-not-parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-not-parameter.rs?ref=0649b16ade40d1fb02ea5c390293278bd876854a", "patch": "@@ -1,45 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn equal<T>(_: &T, _: &T) -> bool where isize : Eq {\n-    true //~^ ERROR cannot bound type `isize`, where clause bounds may only be attached\n-}\n-\n-// This should be fine involves a type parameter.\n-fn test<T: Eq>() -> bool where Option<T> : Eq {}\n-\n-// This should be rejected as well.\n-fn test2() -> bool where Option<isize> : Eq {}\n-//~^ ERROR cannot bound type `core::option::Option<isize>`, where clause bounds may\n-\n-#[derive(PartialEq)]\n-//~^ ERROR cannot bound type `isize`, where clause bounds\n-enum Foo<T> where isize : Eq { MkFoo(T) }\n-//~^ ERROR cannot bound type `isize`, where clause bounds\n-\n-fn test3<T: Eq>() -> bool where Option<Foo<T>> : Eq {}\n-\n-fn test4() -> bool where Option<Foo<isize>> : Eq {}\n-//~^ ERROR cannot bound type `core::option::Option<Foo<isize>>`, where clause bounds\n-\n-trait Baz<T> where isize : Eq {\n-    //~^ ERROR cannot bound type `isize`, where clause bounds may only\n-    fn baz(&self, t: T) where String : Eq; //~ ERROR cannot bound type `collections::string::String`\n-    //~^ ERROR cannot bound type `isize`, where clause\n-}\n-\n-impl Baz<isize> for isize where isize : Eq {\n-    //~^ ERROR cannot bound type `isize`, where clause bounds\n-    fn baz() where String : Eq {}\n-}\n-\n-fn main() {\n-    equal(&0, &0);\n-}"}, {"sha": "8059db5204ee625fbe017d8bf7f910813540610d", "filename": "src/test/run-pass/associated-types-projection-to-unrelated-trait.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Frun-pass%2Fassociated-types-projection-to-unrelated-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Frun-pass%2Fassociated-types-projection-to-unrelated-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-projection-to-unrelated-trait.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -21,7 +21,8 @@ trait Get {\n }\n \n trait Other {\n-    fn okay<U:Get>(&self, foo: U, bar: <Self as Get>::Value);\n+    fn okay<U:Get>(&self, foo: U, bar: <Self as Get>::Value)\n+        where Self: Get;\n }\n \n impl Get for () {"}, {"sha": "9049ae0548fa92dac36125bbf0f48b1352adb6b4", "filename": "src/test/run-pass/issue-14254.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Frun-pass%2Fissue-14254.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Frun-pass%2Fissue-14254.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14254.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -10,7 +10,7 @@\n \n // pretty-expanded FIXME #23616\n \n-trait Foo {\n+trait Foo: Sized {\n     fn bar(&self);\n     fn baz(&self) { }\n     fn bah(_: Option<Self>) { }"}, {"sha": "0ca936878148b6c54f2d477f9d43128beaf838b9", "filename": "src/test/run-pass/issue-21058.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Frun-pass%2Fissue-21058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Frun-pass%2Fissue-21058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-21058.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -21,10 +21,10 @@ fn main() {\n         // str\n         std::intrinsics::type_name::<str>(),\n         // Trait\n-        std::intrinsics::type_name::<Copy>(),\n+        std::intrinsics::type_name::<Send>(),\n         // Newtype\n         std::intrinsics::type_name::<NT>(),\n         // DST\n         std::intrinsics::type_name::<DST>()\n-    )}, (\"[u8]\", \"str\", \"core::marker::Copy + 'static\", \"NT\", \"DST\"));\n+    )}, (\"[u8]\", \"str\", \"core::marker::Send + 'static\", \"NT\", \"DST\"));\n }"}, {"sha": "6ab339510991510e54c2e61feb1fc564cab9d970", "filename": "src/test/run-pass/issue-5708.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Frun-pass%2Fissue-5708.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Frun-pass%2Fissue-5708.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5708.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -52,7 +52,7 @@ pub trait MyTrait<T> {\n     fn dummy(&self, t: T) -> T { panic!() }\n }\n \n-pub struct MyContainer<'a, T> {\n+pub struct MyContainer<'a, T:'a> {\n     foos: Vec<&'a (MyTrait<T>+'a)> ,\n }\n "}, {"sha": "9a6ea2272fea7c5ca453595a1c0f3343eed99212", "filename": "src/test/run-pass/project-defer-unification.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Frun-pass%2Fproject-defer-unification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Frun-pass%2Fproject-defer-unification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fproject-defer-unification.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -0,0 +1,105 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A regression test extracted from image-0.3.11. The point of\n+// failure was in `index_colors` below.\n+\n+use std::ops::{Deref, DerefMut};\n+\n+#[derive(Copy, Clone)]\n+pub struct Luma<T: Primitive> { pub data: [T; 1] }\n+\n+impl<T: Primitive + 'static> Pixel for Luma<T> {\n+    type Subpixel = T;\n+}\n+\n+pub struct ImageBuffer<P: Pixel, Container> {\n+    pixels: P,\n+    c: Container,\n+}\n+\n+pub trait GenericImage: Sized {\n+    type Pixel: Pixel;\n+}\n+\n+pub trait Pixel: Copy + Clone {\n+    type Subpixel: Primitive;\n+}\n+\n+pub trait Primitive: Copy + PartialOrd<Self> + Clone  {\n+}\n+\n+impl<P, Container> GenericImage for ImageBuffer<P, Container>\n+where P: Pixel + 'static,\n+      Container: Deref<Target=[P::Subpixel]> + DerefMut,\n+      P::Subpixel: 'static {\n+\n+    type Pixel = P;\n+}\n+\n+impl Primitive for u8 { }\n+\n+impl<P, Container> ImageBuffer<P, Container>\n+where P: Pixel + 'static,\n+      P::Subpixel: 'static,\n+      Container: Deref<Target=[P::Subpixel]>\n+{\n+    pub fn pixels<'a>(&'a self) -> Pixels<'a, Self> {\n+        loop { }\n+    }\n+\n+    pub fn pixels_mut(&mut self) -> PixelsMut<P> {\n+        loop { }\n+    }\n+}\n+\n+pub struct Pixels<'a, I: 'a> {\n+    image:  &'a I,\n+    x:      u32,\n+    y:      u32,\n+    width:  u32,\n+    height: u32\n+}\n+\n+impl<'a, I: GenericImage> Iterator for Pixels<'a, I> {\n+    type Item = (u32, u32, I::Pixel);\n+\n+    fn next(&mut self) -> Option<(u32, u32, I::Pixel)> {\n+        loop { }\n+    }\n+}\n+\n+pub struct PixelsMut<'a, P: Pixel + 'a> where P::Subpixel: 'a {\n+    chunks: &'a mut P::Subpixel\n+}\n+\n+impl<'a, P: Pixel + 'a> Iterator for PixelsMut<'a, P> where P::Subpixel: 'a {\n+    type Item = &'a mut P;\n+\n+    fn next(&mut self) -> Option<&'a mut P> {\n+        loop { }\n+    }\n+}\n+\n+pub fn index_colors<Pix>(image: &ImageBuffer<Pix, Vec<u8>>)\n+                         -> ImageBuffer<Luma<u8>, Vec<u8>>\n+where Pix: Pixel<Subpixel=u8> + 'static,\n+{\n+    let mut indices: ImageBuffer<_,Vec<_>> = loop { };\n+    for (pixel, idx) in image.pixels().zip(indices.pixels_mut()) {\n+        // failured occurred here ^^ because we were requiring that we\n+        // could project Pixel or Subpixel from `T_indices` (type of\n+        // `indices`), but the type is insufficiently constrained\n+        // until we reach the return below.\n+    }\n+    indices\n+}\n+\n+fn main() { }"}, {"sha": "72a214f4c9ad057eb5622997d630715c98c6330e", "filename": "src/test/run-pass/regions-early-bound-trait-param.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Frun-pass%2Fregions-early-bound-trait-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7261f3ab60e0d1e6c808004ecd25c88e04f3683/src%2Ftest%2Frun-pass%2Fregions-early-bound-trait-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-early-bound-trait-param.rs?ref=e7261f3ab60e0d1e6c808004ecd25c88e04f3683", "patch": "@@ -42,7 +42,7 @@ fn field_invoke1<'f, 'g>(x: &'g Struct1<'f>) -> (isize,isize) {\n     (l,s)\n }\n \n-struct Struct2<'h, 'i> {\n+struct Struct2<'h, 'i:'h> {\n     f: &'h (Trait<'i>+'h)\n }\n \n@@ -126,7 +126,10 @@ pub fn main() {\n     assert_eq!(field_invoke2(&s2), 3);\n \n     let m : Box<Trait> = make_val();\n-    assert_eq!(object_invoke1(&*m), (4,5));\n+    // assert_eq!(object_invoke1(&*m), (4,5));\n+    //            ~~~~~~~~~~~~~~~~~~~\n+    // this call yields a compilation error; see compile-fail/dropck-object-cycle.rs\n+    // for details.\n     assert_eq!(object_invoke2(&*m), 5);\n \n     // The RefMakerTrait above is pretty strange (i.e. it is strange"}]}