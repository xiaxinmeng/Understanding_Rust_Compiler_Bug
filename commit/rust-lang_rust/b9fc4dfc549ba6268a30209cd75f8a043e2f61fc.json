{"sha": "b9fc4dfc549ba6268a30209cd75f8a043e2f61fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5ZmM0ZGZjNTQ5YmE2MjY4YTMwMjA5Y2Q3NWY4YTA0M2UyZjYxZmM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-24T05:04:42Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-24T05:16:16Z"}, "message": "rustc: Cleanup trans_if, trans_alt", "tree": {"sha": "3e5d1ca678cc6ae17d1c87f72a8e1eabbc9a369b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e5d1ca678cc6ae17d1c87f72a8e1eabbc9a369b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9fc4dfc549ba6268a30209cd75f8a043e2f61fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9fc4dfc549ba6268a30209cd75f8a043e2f61fc", "html_url": "https://github.com/rust-lang/rust/commit/b9fc4dfc549ba6268a30209cd75f8a043e2f61fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9fc4dfc549ba6268a30209cd75f8a043e2f61fc/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05c0216654999e3d33373914b10aebf9dd7d4907", "url": "https://api.github.com/repos/rust-lang/rust/commits/05c0216654999e3d33373914b10aebf9dd7d4907", "html_url": "https://github.com/rust-lang/rust/commit/05c0216654999e3d33373914b10aebf9dd7d4907"}], "stats": {"total": 42, "additions": 6, "deletions": 36}, "files": [{"sha": "3f3bf9f665afae9c8866ce38f8ffc693fd03bf9c", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b9fc4dfc549ba6268a30209cd75f8a043e2f61fc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9fc4dfc549ba6268a30209cd75f8a043e2f61fc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=b9fc4dfc549ba6268a30209cd75f8a043e2f61fc", "patch": "@@ -4101,47 +4101,29 @@ fn trans_if(&@block_ctxt cx, &@ast::expr cond, &ast::block thn,\n     auto then_cx = new_scope_block_ctxt(cx, \"then\");\n     auto then_res = trans_block(then_cx, thn, output);\n     auto else_cx = new_scope_block_ctxt(cx, \"else\");\n-    auto else_res;\n-    auto expr_llty;\n-    alt (els) {\n+    auto else_res =  alt (els) {\n         case (some(?elexpr)) {\n             alt (elexpr.node) {\n                 case (ast::expr_if(_, _, _)) {\n                     // Synthesize a block here to act as the else block\n                     // containing an if expression. Needed in order for the\n                     // else scope to behave like a normal block scope. A tad\n                     // ugly.\n-\n-                    let ast::block_ elseif_blk_ =\n-                        rec(stmts=[],\n-                            expr=some[@ast::expr](elexpr),\n-                            id=elexpr.id);\n-                    auto elseif_blk = rec(node=elseif_blk_, span=elexpr.span);\n-                    else_res = trans_block(else_cx, elseif_blk, output);\n+                    auto elseif_blk = ast::block_from_expr(elexpr);\n+                    trans_block(else_cx, elseif_blk, output)\n                 }\n                 case (ast::expr_block(?blk)) {\n                     // Calling trans_block directly instead of trans_expr\n                     // because trans_expr will create another scope block\n                     // context for the block, but we've already got the\n                     // 'else' context\n \n-                    else_res = trans_block(else_cx, blk, output);\n-                }\n-            }\n-            // FIXME: This isn't quite right, particularly re: dynamic types\n-\n-            auto expr_ty = ty::node_id_to_type(cx.fcx.lcx.ccx.tcx, id);\n-            if (ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, expr_ty)) {\n-                expr_llty = T_typaram_ptr(cx.fcx.lcx.ccx.tn);\n-            } else {\n-                expr_llty = type_of(cx.fcx.lcx.ccx, elexpr.span, expr_ty);\n-                if (ty::type_is_structural(cx.fcx.lcx.ccx.tcx, expr_ty)) {\n-                    expr_llty = T_ptr(expr_llty);\n+                    trans_block(else_cx, blk, output)\n                 }\n             }\n         }\n-        case (_) { else_res = res(else_cx, C_nil()); expr_llty = T_nil(); }\n-    }\n+        case (_) { res(else_cx, C_nil()) }\n+    };\n     cond_res.bcx.build.CondBr(cond_res.val, then_cx.llbb, else_cx.llbb);\n     ret res(join_branches(cx, [then_res, else_res]), C_nil());\n }\n@@ -4599,18 +4581,6 @@ fn trans_alt(&@block_ctxt cx, &@ast::expr expr, &vec[ast::arm] arms,\n     auto default_res =\n         trans_fail(default_cx, some[common::span](expr.span),\n                    \"non-exhaustive match failure\");\n-    // FIXME: This isn't quite right, particularly re: dynamic types\n-\n-    auto expr_ty = ty::node_id_to_type(cx.fcx.lcx.ccx.tcx, id);\n-    auto expr_llty;\n-    if (ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, expr_ty)) {\n-        expr_llty = T_typaram_ptr(cx.fcx.lcx.ccx.tn);\n-    } else {\n-        expr_llty = type_of(cx.fcx.lcx.ccx, expr.span, expr_ty);\n-        if (ty::type_is_structural(cx.fcx.lcx.ccx.tcx, expr_ty)) {\n-            expr_llty = T_ptr(expr_llty);\n-        }\n-    }\n     ret res(join_branches(cx, arm_results), C_nil());\n }\n "}]}