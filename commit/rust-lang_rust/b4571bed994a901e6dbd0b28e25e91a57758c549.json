{"sha": "b4571bed994a901e6dbd0b28e25e91a57758c549", "node_id": "C_kwDOAAsO6NoAKGI0NTcxYmVkOTk0YTkwMWU2ZGJkMGIyOGUyNWU5MWE1Nzc1OGM1NDk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-02T21:28:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-02T21:28:53Z"}, "message": "Auto merge of #109729 - fortanix:raoul/bugfix_libtest_json_synchronization, r=pietroalbini\n\nEnsure test library issues json string line-by-line\n\n#108659 introduces a custom test display implementation. It does so by using libtest to output json. The stdout is read line by line and parsed. The code trims the line read and checks whether it starts with a `{` and ends with a `}`.\n\nUnfortunately, there is a race condition in how json data is written to stdout. The `write_message` function calls `self.out.write_all` repeatedly to write a buffer that contains (partial) json data, or a new line. There is no lock around the `self.out.write_all` functions. Similarly, the `write_message` function itself is called with only partial json data. As these functions are called from concurrent threads, this may result in json data ending up on the same stdout line. This PR avoids this by buffering the complete json data before issuing a single `self.out.write_all`.\n\n(#109484 implemented a partial fix for this issue; it only avoids that failed json parsing would result in a panic.)\n\ncc: `@jethrogb,` `@pietroalbini`", "tree": {"sha": "b53b9c2a5c3c872ccdd09aa4af7d6339273aed95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b53b9c2a5c3c872ccdd09aa4af7d6339273aed95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4571bed994a901e6dbd0b28e25e91a57758c549", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4571bed994a901e6dbd0b28e25e91a57758c549", "html_url": "https://github.com/rust-lang/rust/commit/b4571bed994a901e6dbd0b28e25e91a57758c549", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4571bed994a901e6dbd0b28e25e91a57758c549/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a368898de758e1b8def6c9060044a5b40eb79e84", "url": "https://api.github.com/repos/rust-lang/rust/commits/a368898de758e1b8def6c9060044a5b40eb79e84", "html_url": "https://github.com/rust-lang/rust/commit/a368898de758e1b8def6c9060044a5b40eb79e84"}, {"sha": "a18b750de2f0a01b11a015810ccfddca44549bca", "url": "https://api.github.com/repos/rust-lang/rust/commits/a18b750de2f0a01b11a015810ccfddca44549bca", "html_url": "https://github.com/rust-lang/rust/commit/a18b750de2f0a01b11a015810ccfddca44549bca"}], "stats": {"total": 132, "additions": 62, "deletions": 70}, "files": [{"sha": "47c4e7757e40cb96eccabdedc9acbab259d7ecea", "filename": "library/test/src/formatters/json.rs", "status": "modified", "additions": 62, "deletions": 70, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/b4571bed994a901e6dbd0b28e25e91a57758c549/library%2Ftest%2Fsrc%2Fformatters%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4571bed994a901e6dbd0b28e25e91a57758c549/library%2Ftest%2Fsrc%2Fformatters%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fformatters%2Fjson.rs?ref=b4571bed994a901e6dbd0b28e25e91a57758c549", "patch": "@@ -18,14 +18,10 @@ impl<T: Write> JsonFormatter<T> {\n     }\n \n     fn writeln_message(&mut self, s: &str) -> io::Result<()> {\n-        assert!(!s.contains('\\n'));\n-\n-        self.out.write_all(s.as_ref())?;\n-        self.out.write_all(b\"\\n\")\n-    }\n-\n-    fn write_message(&mut self, s: &str) -> io::Result<()> {\n-        assert!(!s.contains('\\n'));\n+        // self.out will take a lock, but that lock is released when write_all returns. This\n+        // results in a race condition and json output may not end with a new line. We avoid this\n+        // by issuing `write_all` calls line-by-line.\n+        assert_eq!(s.chars().last(), Some('\\n'));\n \n         self.out.write_all(s.as_ref())\n     }\n@@ -34,34 +30,35 @@ impl<T: Write> JsonFormatter<T> {\n         &mut self,\n         ty: &str,\n         name: &str,\n-        evt: &str,\n+        event: &str,\n         exec_time: Option<&time::TestExecTime>,\n         stdout: Option<Cow<'_, str>>,\n         extra: Option<&str>,\n     ) -> io::Result<()> {\n         // A doc test's name includes a filename which must be escaped for correct json.\n-        self.write_message(&format!(\n-            r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\"\"#,\n-            ty,\n-            EscapedString(name),\n-            evt\n-        ))?;\n-        if let Some(exec_time) = exec_time {\n-            self.write_message(&format!(r#\", \"exec_time\": {}\"#, exec_time.0.as_secs_f64()))?;\n-        }\n-        if let Some(stdout) = stdout {\n-            self.write_message(&format!(r#\", \"stdout\": \"{}\"\"#, EscapedString(stdout)))?;\n-        }\n-        if let Some(extra) = extra {\n-            self.write_message(&format!(r#\", {extra}\"#))?;\n-        }\n-        self.writeln_message(\" }\")\n+        let name = EscapedString(name);\n+        let exec_time_json = if let Some(exec_time) = exec_time {\n+            format!(r#\", \"exec_time\": {}\"#, exec_time.0.as_secs_f64())\n+        } else {\n+            String::from(\"\")\n+        };\n+        let stdout_json = if let Some(stdout) = stdout {\n+            format!(r#\", \"stdout\": \"{}\"\"#, EscapedString(stdout))\n+        } else {\n+            String::from(\"\")\n+        };\n+        let extra_json =\n+            if let Some(extra) = extra { format!(r#\", {extra}\"#) } else { String::from(\"\") };\n+        let newline = \"\\n\";\n+\n+        self.writeln_message(&format!(\n+                r#\"{{ \"type\": \"{ty}\", \"name\": \"{name}\", \"event\": \"{event}\"{exec_time_json}{stdout_json}{extra_json} }}{newline}\"#))\n     }\n }\n \n impl<T: Write> OutputFormatter for JsonFormatter<T> {\n     fn write_discovery_start(&mut self) -> io::Result<()> {\n-        self.writeln_message(&format!(r#\"{{ \"type\": \"suite\", \"event\": \"discovery\" }}\"#))\n+        self.writeln_message(concat!(r#\"{ \"type\": \"suite\", \"event\": \"discovery\" }\"#, \"\\n\"))\n     }\n \n     fn write_test_discovered(&mut self, desc: &TestDesc, test_type: &str) -> io::Result<()> {\n@@ -77,21 +74,24 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n             ..\n         } = desc;\n \n+        let name = EscapedString(name.as_slice());\n+        let ignore_message = ignore_message.unwrap_or(\"\");\n+        let source_path = EscapedString(source_file);\n+        let newline = \"\\n\";\n+\n         self.writeln_message(&format!(\n-            r#\"{{ \"type\": \"{test_type}\", \"event\": \"discovered\", \"name\": \"{}\", \"ignore\": {ignore}, \"ignore_message\": \"{}\", \"source_path\": \"{}\", \"start_line\": {start_line}, \"start_col\": {start_col}, \"end_line\": {end_line}, \"end_col\": {end_col} }}\"#,\n-            EscapedString(name.as_slice()),\n-            ignore_message.unwrap_or(\"\"),\n-            EscapedString(source_file),\n+            r#\"{{ \"type\": \"{test_type}\", \"event\": \"discovered\", \"name\": \"{name}\", \"ignore\": {ignore}, \"ignore_message\": \"{ignore_message}\", \"source_path\": \"{source_path}\", \"start_line\": {start_line}, \"start_col\": {start_col}, \"end_line\": {end_line}, \"end_col\": {end_col} }}{newline}\"#\n         ))\n     }\n \n     fn write_discovery_finish(&mut self, state: &ConsoleTestDiscoveryState) -> io::Result<()> {\n         let ConsoleTestDiscoveryState { tests, benchmarks, ignored, .. } = state;\n \n         let total = tests + benchmarks;\n+        let newline = \"\\n\";\n         self.writeln_message(&format!(\n-            r#\"{{ \"type\": \"suite\", \"event\": \"completed\", \"tests\": {tests}, \"benchmarks\": {benchmarks}, \"total\": {total}, \"ignored\": {ignored} }}\"#\n-        ))\n+            r#\"{{ \"type\": \"suite\", \"event\": \"completed\", \"tests\": {tests}, \"benchmarks\": {benchmarks}, \"total\": {total}, \"ignored\": {ignored} }}{newline}\"#\n+            ))\n     }\n \n     fn write_run_start(&mut self, test_count: usize, shuffle_seed: Option<u64>) -> io::Result<()> {\n@@ -100,15 +100,17 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n         } else {\n             String::new()\n         };\n+        let newline = \"\\n\";\n         self.writeln_message(&format!(\n-            r#\"{{ \"type\": \"suite\", \"event\": \"started\", \"test_count\": {test_count}{shuffle_seed_json} }}\"#\n-        ))\n+            r#\"{{ \"type\": \"suite\", \"event\": \"started\", \"test_count\": {test_count}{shuffle_seed_json} }}{newline}\"#\n+            ))\n     }\n \n     fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        let name = EscapedString(desc.name.as_slice());\n+        let newline = \"\\n\";\n         self.writeln_message(&format!(\n-            r#\"{{ \"type\": \"test\", \"event\": \"started\", \"name\": \"{}\" }}\"#,\n-            EscapedString(desc.name.as_slice())\n+            r#\"{{ \"type\": \"test\", \"event\": \"started\", \"name\": \"{name}\" }}{newline}\"#\n         ))\n     }\n \n@@ -173,53 +175,43 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n                 } else {\n                     format!(r#\", \"mib_per_second\": {}\"#, bs.mb_s)\n                 };\n+                let name = EscapedString(desc.name.as_slice());\n \n-                let line = format!(\n+                self.writeln_message(&format!(\n                     \"{{ \\\"type\\\": \\\"bench\\\", \\\n-                     \\\"name\\\": \\\"{}\\\", \\\n-                     \\\"median\\\": {}, \\\n-                     \\\"deviation\\\": {}{} }}\",\n-                    EscapedString(desc.name.as_slice()),\n-                    median,\n-                    deviation,\n-                    mbps\n-                );\n-\n-                self.writeln_message(&line)\n+                     \\\"name\\\": \\\"{name}\\\", \\\n+                     \\\"median\\\": {median}, \\\n+                     \\\"deviation\\\": {deviation}{mbps} }}\\n\",\n+                ))\n             }\n         }\n     }\n \n     fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        let name = EscapedString(desc.name.as_slice());\n+        let newline = \"\\n\";\n         self.writeln_message(&format!(\n-            r#\"{{ \"type\": \"test\", \"event\": \"timeout\", \"name\": \"{}\" }}\"#,\n-            EscapedString(desc.name.as_slice())\n+            r#\"{{ \"type\": \"test\", \"event\": \"timeout\", \"name\": \"{name}\" }}{newline}\"#,\n         ))\n     }\n \n     fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n-        self.write_message(&format!(\n-            \"{{ \\\"type\\\": \\\"suite\\\", \\\n-             \\\"event\\\": \\\"{}\\\", \\\n-             \\\"passed\\\": {}, \\\n-             \\\"failed\\\": {}, \\\n-             \\\"ignored\\\": {}, \\\n-             \\\"measured\\\": {}, \\\n-             \\\"filtered_out\\\": {}\",\n-            if state.failed == 0 { \"ok\" } else { \"failed\" },\n-            state.passed,\n-            state.failed,\n-            state.ignored,\n-            state.measured,\n-            state.filtered_out,\n-        ))?;\n-\n-        if let Some(ref exec_time) = state.exec_time {\n-            let time_str = format!(\", \\\"exec_time\\\": {}\", exec_time.0.as_secs_f64());\n-            self.write_message(&time_str)?;\n-        }\n+        let event = if state.failed == 0 { \"ok\" } else { \"failed\" };\n+        let passed = state.passed;\n+        let failed = state.failed;\n+        let ignored = state.ignored;\n+        let measured = state.measured;\n+        let filtered_out = state.filtered_out;\n+        let exec_time_json = if let Some(ref exec_time) = state.exec_time {\n+            format!(r#\", \"exec_time\": {}\"#, exec_time.0.as_secs_f64())\n+        } else {\n+            String::from(\"\")\n+        };\n+        let newline = \"\\n\";\n \n-        self.writeln_message(\" }\")?;\n+        self.writeln_message(&format!(\n+            r#\"{{ \"type\": \"suite\", \"event\": \"{event}\", \"passed\": {passed}, \"failed\": {failed}, \"ignored\": {ignored}, \"measured\": {measured}, \"filtered_out\": {filtered_out}{exec_time_json} }}{newline}\"#\n+        ))?;\n \n         Ok(state.failed == 0)\n     }"}]}