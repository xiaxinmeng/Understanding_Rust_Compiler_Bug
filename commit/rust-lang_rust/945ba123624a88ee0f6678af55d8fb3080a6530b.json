{"sha": "945ba123624a88ee0f6678af55d8fb3080a6530b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0NWJhMTIzNjI0YTg4ZWUwZjY2NzhhZjU1ZDhmYjMwODBhNjUzMGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-11T05:41:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-06-11T05:41:24Z"}, "message": "Auto merge of #34002 - jseyfried:strip_tests_in_cfg, r=nrc\n\nTreat `#[test]` like `#[cfg(test)]` in non-test builds\n\nThis PR treats `#[test]` like `#[cfg(test)]` in non-test builds. In particular, like `#[cfg(test)]`,\n - `#[test]` nodes are stripped during `cfg` processing, and\n - `#[test]` is disallowed on non-optional expressions.\n\nCloses #33946.\nr? @nrc", "tree": {"sha": "81a92be1682ac2a2f4567daae64126c66bcd2a0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81a92be1682ac2a2f4567daae64126c66bcd2a0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/945ba123624a88ee0f6678af55d8fb3080a6530b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/945ba123624a88ee0f6678af55d8fb3080a6530b", "html_url": "https://github.com/rust-lang/rust/commit/945ba123624a88ee0f6678af55d8fb3080a6530b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/945ba123624a88ee0f6678af55d8fb3080a6530b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f80ff7da394da0be629df6758b8fd513ee6ef438", "url": "https://api.github.com/repos/rust-lang/rust/commits/f80ff7da394da0be629df6758b8fd513ee6ef438", "html_url": "https://github.com/rust-lang/rust/commit/f80ff7da394da0be629df6758b8fd513ee6ef438"}, {"sha": "29c4b6726a1eaf87cf6e4bc76a398b19ca20e2cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/29c4b6726a1eaf87cf6e4bc76a398b19ca20e2cd", "html_url": "https://github.com/rust-lang/rust/commit/29c4b6726a1eaf87cf6e4bc76a398b19ca20e2cd"}], "stats": {"total": 92, "additions": 41, "deletions": 51}, "files": [{"sha": "af68b7632dd18a9c5b8d4286cf68fb851a76ccdd", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/945ba123624a88ee0f6678af55d8fb3080a6530b/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/945ba123624a88ee0f6678af55d8fb3080a6530b/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=945ba123624a88ee0f6678af55d8fb3080a6530b", "patch": "@@ -582,6 +582,7 @@ pub fn phase_2_configure_and_expand<'a>(sess: &Session,\n         sess.track_errors(|| {\n             syntax::config::strip_unconfigured_items(sess.diagnostic(),\n                                                      krate,\n+                                                     sess.opts.test,\n                                                      &mut feature_gated_cfgs)\n         })\n     })?;\n@@ -692,6 +693,7 @@ pub fn phase_2_configure_and_expand<'a>(sess: &Session,\n             features: Some(&features),\n             recursion_limit: sess.recursion_limit.get(),\n             trace_mac: sess.opts.debugging_opts.trace_macros,\n+            should_test: sess.opts.test,\n         };\n         let mut loader = macro_import::MacroLoader::new(sess, &cstore, crate_name);\n         let mut ecx = syntax::ext::base::ExtCtxt::new(&sess.parse_sess,"}, {"sha": "021f417279ef492ab063040af6e1180ac344b34c", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 33, "deletions": 37, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/945ba123624a88ee0f6678af55d8fb3080a6530b/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/945ba123624a88ee0f6678af55d8fb3080a6530b/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=945ba123624a88ee0f6678af55d8fb3080a6530b", "patch": "@@ -19,43 +19,37 @@ use ptr::P;\n \n use util::small_vector::SmallVector;\n \n-pub trait CfgFolder: fold::Folder {\n-    // Check if a node with the given attributes is in this configuration.\n-    fn in_cfg(&mut self, attrs: &[ast::Attribute]) -> bool;\n-\n-    // Update a node before checking if it is in this configuration (used to implement `cfg_attr`).\n-    fn process_attrs<T: HasAttrs>(&mut self, node: T) -> T { node }\n-\n-    // Visit attributes on expression and statements (but not attributes on items in blocks).\n-    fn visit_stmt_or_expr_attrs(&mut self, _attrs: &[ast::Attribute]) {}\n-\n-    // Visit unremovable (non-optional) expressions -- c.f. `fold_expr` vs `fold_opt_expr`.\n-    fn visit_unremovable_expr(&mut self, _expr: &ast::Expr) {}\n-\n-    fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n-        let node = self.process_attrs(node);\n-        if self.in_cfg(node.attrs()) { Some(node) } else { None }\n-    }\n-}\n-\n-/// A folder that strips out items that do not belong in the current\n-/// configuration.\n+/// A folder that strips out items that do not belong in the current configuration.\n pub struct StripUnconfigured<'a> {\n     diag: CfgDiagReal<'a, 'a>,\n+    should_test: bool,\n     config: &'a ast::CrateConfig,\n }\n \n impl<'a> StripUnconfigured<'a> {\n     pub fn new(config: &'a ast::CrateConfig,\n+               should_test: bool,\n                diagnostic: &'a Handler,\n                feature_gated_cfgs: &'a mut Vec<GatedCfgAttr>)\n                -> Self {\n         StripUnconfigured {\n             config: config,\n+            should_test: should_test,\n             diag: CfgDiagReal { diag: diagnostic, feature_gated_cfgs: feature_gated_cfgs },\n         }\n     }\n \n+    fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n+        let node = self.process_cfg_attrs(node);\n+        if self.in_cfg(node.attrs()) { Some(node) } else { None }\n+    }\n+\n+    fn process_cfg_attrs<T: HasAttrs>(&mut self, node: T) -> T {\n+        node.map_attrs(|attrs| {\n+            attrs.into_iter().filter_map(|attr| self.process_cfg_attr(attr)).collect()\n+        })\n+    }\n+\n     fn process_cfg_attr(&mut self, attr: ast::Attribute) -> Option<ast::Attribute> {\n         if !attr.check_name(\"cfg_attr\") {\n             return Some(attr);\n@@ -89,13 +83,15 @@ impl<'a> StripUnconfigured<'a> {\n             None\n         }\n     }\n-}\n \n-impl<'a> CfgFolder for StripUnconfigured<'a> {\n-    // Determine if an item should be translated in the current crate\n-    // configuration based on the item's attributes\n+    // Determine if a node with the given attributes should be included in this configuation.\n     fn in_cfg(&mut self, attrs: &[ast::Attribute]) -> bool {\n         attrs.iter().all(|attr| {\n+            // When not compiling with --test we should not compile the #[test] functions\n+            if !self.should_test && is_test_or_bench(attr) {\n+                return false;\n+            }\n+\n             let mis = match attr.node.value.node {\n                 ast::MetaItemKind::List(_, ref mis) if is_cfg(&attr) => mis,\n                 _ => return true\n@@ -112,21 +108,17 @@ impl<'a> CfgFolder for StripUnconfigured<'a> {\n         })\n     }\n \n-    fn process_attrs<T: HasAttrs>(&mut self, node: T) -> T {\n-        node.map_attrs(|attrs| {\n-            attrs.into_iter().filter_map(|attr| self.process_cfg_attr(attr)).collect()\n-        })\n-    }\n-\n+    // Visit attributes on expression and statements (but not attributes on items in blocks).\n     fn visit_stmt_or_expr_attrs(&mut self, attrs: &[ast::Attribute]) {\n         // flag the offending attributes\n         for attr in attrs.iter() {\n             self.diag.feature_gated_cfgs.push(GatedCfgAttr::GatedAttr(attr.span));\n         }\n     }\n \n+    // Visit unremovable (non-optional) expressions -- c.f. `fold_expr` vs `fold_opt_expr`.\n     fn visit_unremovable_expr(&mut self, expr: &ast::Expr) {\n-        if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(a)) {\n+        if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(a) || is_test_or_bench(a)) {\n             let msg = \"removing an expression is not supported in this position\";\n             self.diag.diag.span_err(attr.span, msg);\n         }\n@@ -135,15 +127,15 @@ impl<'a> CfgFolder for StripUnconfigured<'a> {\n \n // Support conditional compilation by transforming the AST, stripping out\n // any items that do not belong in the current configuration\n-pub fn strip_unconfigured_items(diagnostic: &Handler, krate: ast::Crate,\n+pub fn strip_unconfigured_items(diagnostic: &Handler, krate: ast::Crate, should_test: bool,\n                                 feature_gated_cfgs: &mut Vec<GatedCfgAttr>)\n                                 -> ast::Crate\n {\n     let config = &krate.config.clone();\n-    StripUnconfigured::new(config, diagnostic, feature_gated_cfgs).fold_crate(krate)\n+    StripUnconfigured::new(config, should_test, diagnostic, feature_gated_cfgs).fold_crate(krate)\n }\n \n-impl<T: CfgFolder> fold::Folder for T {\n+impl<'a> fold::Folder for StripUnconfigured<'a> {\n     fn fold_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod {\n         ast::ForeignMod {\n             abi: foreign_mod.abi,\n@@ -204,7 +196,7 @@ impl<T: CfgFolder> fold::Folder for T {\n         // NB: This is intentionally not part of the fold_expr() function\n         //     in order for fold_opt_expr() to be able to avoid this check\n         self.visit_unremovable_expr(&expr);\n-        let expr = self.process_attrs(expr);\n+        let expr = self.process_cfg_attrs(expr);\n         fold_expr(self, expr)\n     }\n \n@@ -256,7 +248,7 @@ impl<T: CfgFolder> fold::Folder for T {\n     }\n }\n \n-fn fold_expr<F: CfgFolder>(folder: &mut F, expr: P<ast::Expr>) -> P<ast::Expr> {\n+fn fold_expr(folder: &mut StripUnconfigured, expr: P<ast::Expr>) -> P<ast::Expr> {\n     expr.map(|ast::Expr {id, span, node, attrs}| {\n         fold::noop_fold_expr(ast::Expr {\n             id: id,\n@@ -278,6 +270,10 @@ fn is_cfg(attr: &ast::Attribute) -> bool {\n     attr.check_name(\"cfg\")\n }\n \n+fn is_test_or_bench(attr: &ast::Attribute) -> bool {\n+    attr.check_name(\"test\") || attr.check_name(\"bench\")\n+}\n+\n pub trait CfgDiag {\n     fn emit_error<F>(&mut self, f: F) where F: FnMut(&Handler);\n     fn flag_gated<F>(&mut self, f: F) where F: FnMut(&mut Vec<GatedCfgAttr>);"}, {"sha": "31971842d63fc72f7075d828678f95a36aa54a90", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/945ba123624a88ee0f6678af55d8fb3080a6530b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/945ba123624a88ee0f6678af55d8fb3080a6530b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=945ba123624a88ee0f6678af55d8fb3080a6530b", "patch": "@@ -1001,6 +1001,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n     fn strip_unconfigured(&mut self) -> StripUnconfigured {\n         StripUnconfigured::new(&self.cx.cfg,\n+                               self.cx.ecfg.should_test,\n                                &self.cx.parse_sess.span_diagnostic,\n                                self.cx.feature_gated_cfgs)\n     }\n@@ -1106,6 +1107,7 @@ pub struct ExpansionConfig<'feat> {\n     pub features: Option<&'feat Features>,\n     pub recursion_limit: usize,\n     pub trace_mac: bool,\n+    pub should_test: bool, // If false, strip `#[test]` nodes\n }\n \n macro_rules! feature_tests {\n@@ -1128,6 +1130,7 @@ impl<'feat> ExpansionConfig<'feat> {\n             features: None,\n             recursion_limit: 64,\n             trace_mac: false,\n+            should_test: false,\n         }\n     }\n "}, {"sha": "6e29505f00aaddd9de120ca945d9a6948da62ed3", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/945ba123624a88ee0f6678af55d8fb3080a6530b/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/945ba123624a88ee0f6678af55d8fb3080a6530b/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=945ba123624a88ee0f6678af55d8fb3080a6530b", "patch": "@@ -81,7 +81,7 @@ pub fn modify_for_testing(sess: &ParseSess,\n     if should_test {\n         generate_test_harness(sess, reexport_test_harness_main, krate, span_diagnostic)\n     } else {\n-        strip_test_functions(krate)\n+        krate\n     }\n }\n \n@@ -306,19 +306,6 @@ fn generate_test_harness(sess: &ParseSess,\n     return res;\n }\n \n-fn strip_test_functions(krate: ast::Crate) -> ast::Crate {\n-    // When not compiling with --test we should not compile the\n-    // #[test] functions\n-    struct StripTests;\n-    impl config::CfgFolder for StripTests {\n-        fn in_cfg(&mut self, attrs: &[ast::Attribute]) -> bool {\n-            !attr::contains_name(attrs, \"test\") && !attr::contains_name(attrs, \"bench\")\n-        }\n-    }\n-\n-    StripTests.fold_crate(krate)\n-}\n-\n /// Craft a span that will be ignored by the stability lint's\n /// call to codemap's is_internal check.\n /// The expanded code calls some unstable functions in the test crate."}, {"sha": "a4b24fa8b4bf6e04decef823fee7a34b08966a62", "filename": "src/test/compile-fail/cfg-non-opt-expr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/945ba123624a88ee0f6678af55d8fb3080a6530b/src%2Ftest%2Fcompile-fail%2Fcfg-non-opt-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/945ba123624a88ee0f6678af55d8fb3080a6530b/src%2Ftest%2Fcompile-fail%2Fcfg-non-opt-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcfg-non-opt-expr.rs?ref=945ba123624a88ee0f6678af55d8fb3080a6530b", "patch": "@@ -17,4 +17,6 @@ fn main() {\n     //~^ ERROR removing an expression is not supported in this position\n     let _ = [1, 2, 3][#[cfg(unset)] 1];\n     //~^ ERROR removing an expression is not supported in this position\n+    let _ = #[test] ();\n+    //~^ ERROR removing an expression is not supported in this position\n }"}]}