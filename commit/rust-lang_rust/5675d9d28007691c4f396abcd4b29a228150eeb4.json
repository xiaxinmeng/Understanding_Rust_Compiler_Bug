{"sha": "5675d9d28007691c4f396abcd4b29a228150eeb4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2NzVkOWQyODAwNzY5MWM0ZjM5NmFiY2Q0YjI5YTIyODE1MGVlYjQ=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-05T04:16:26Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-22T01:48:10Z"}, "message": "Clean up directory ownership semantics.", "tree": {"sha": "ff28ee180c2e904520168d953a6946574c94b18b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff28ee180c2e904520168d953a6946574c94b18b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5675d9d28007691c4f396abcd4b29a228150eeb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5675d9d28007691c4f396abcd4b29a228150eeb4", "html_url": "https://github.com/rust-lang/rust/commit/5675d9d28007691c4f396abcd4b29a228150eeb4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5675d9d28007691c4f396abcd4b29a228150eeb4/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b3eeea22c9b81f6e7277b79517a0dab25b9f383", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b3eeea22c9b81f6e7277b79517a0dab25b9f383", "html_url": "https://github.com/rust-lang/rust/commit/7b3eeea22c9b81f6e7277b79517a0dab25b9f383"}], "stats": {"total": 173, "additions": 94, "deletions": 79}, "files": [{"sha": "ddbca47429d1876298601836b0ed032e2d1ed1b7", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5675d9d28007691c4f396abcd4b29a228150eeb4/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5675d9d28007691c4f396abcd4b29a228150eeb4/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=5675d9d28007691c4f396abcd4b29a228150eeb4", "patch": "@@ -18,7 +18,7 @@ use errors::DiagnosticBuilder;\n use ext::expand::{self, Expansion};\n use ext::hygiene::Mark;\n use fold::{self, Folder};\n-use parse::{self, parser};\n+use parse::{self, parser, DirectoryOwnership};\n use parse::token;\n use ptr::P;\n use symbol::Symbol;\n@@ -568,9 +568,7 @@ pub struct ExpansionData {\n     pub depth: usize,\n     pub backtrace: ExpnId,\n     pub module: Rc<ModuleData>,\n-\n-    // True if non-inline modules without a `#[path]` are forbidden at the root of this expansion.\n-    pub no_noninline_mod: bool,\n+    pub directory_ownership: DirectoryOwnership,\n }\n \n /// One of these is made during expansion and incrementally updated as we go;\n@@ -601,7 +599,7 @@ impl<'a> ExtCtxt<'a> {\n                 depth: 0,\n                 backtrace: NO_EXPANSION,\n                 module: Rc::new(ModuleData { mod_path: Vec::new(), directory: PathBuf::new() }),\n-                no_noninline_mod: false,\n+                directory_ownership: DirectoryOwnership::Owned,\n             },\n         }\n     }"}, {"sha": "3e8f118ce62de43ff3c35feeb1fbc3e95f1ee2d1", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5675d9d28007691c4f396abcd4b29a228150eeb4/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5675d9d28007691c4f396abcd4b29a228150eeb4/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=5675d9d28007691c4f396abcd4b29a228150eeb4", "patch": "@@ -21,7 +21,7 @@ use ext::base::*;\n use feature_gate::{self, Features};\n use fold;\n use fold::*;\n-use parse::{ParseSess, PResult, lexer};\n+use parse::{ParseSess, DirectoryOwnership, PResult, lexer};\n use parse::parser::Parser;\n use parse::token;\n use print::pprust;\n@@ -727,9 +727,10 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     }\n \n     fn fold_block(&mut self, block: P<Block>) -> P<Block> {\n-        let no_noninline_mod = mem::replace(&mut self.cx.current_expansion.no_noninline_mod, true);\n+        let old_directory_ownership = self.cx.current_expansion.directory_ownership;\n+        self.cx.current_expansion.directory_ownership = DirectoryOwnership::UnownedViaBlock;\n         let result = noop_fold_block(block, self);\n-        self.cx.current_expansion.no_noninline_mod = no_noninline_mod;\n+        self.cx.current_expansion.directory_ownership = old_directory_ownership;\n         result\n     }\n \n@@ -768,7 +769,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                     return noop_fold_item(item, self);\n                 }\n \n-                let orig_no_noninline_mod = self.cx.current_expansion.no_noninline_mod;\n+                let orig_directory_ownership = self.cx.current_expansion.directory_ownership;\n                 let mut module = (*self.cx.current_expansion.module).clone();\n                 module.mod_path.push(item.ident);\n \n@@ -779,23 +780,28 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n                 if inline_module {\n                     if let Some(path) = attr::first_attr_value_str_by_name(&item.attrs, \"path\") {\n-                        self.cx.current_expansion.no_noninline_mod = false;\n+                        self.cx.current_expansion.directory_ownership = DirectoryOwnership::Owned;\n                         module.directory.push(&*path.as_str());\n                     } else {\n                         module.directory.push(&*item.ident.name.as_str());\n                     }\n                 } else {\n-                    self.cx.current_expansion.no_noninline_mod = false;\n-                    module.directory =\n+                    let mut path =\n                         PathBuf::from(self.cx.parse_sess.codemap().span_to_filename(inner));\n-                    module.directory.pop();\n+                    let directory_ownership = match path.file_name().unwrap().to_str() {\n+                        Some(\"mod.rs\") => DirectoryOwnership::Owned,\n+                        _ => DirectoryOwnership::UnownedViaMod,\n+                    };\n+                    path.pop();\n+                    module.directory = path;\n+                    self.cx.current_expansion.directory_ownership = directory_ownership;\n                 }\n \n                 let orig_module =\n                     mem::replace(&mut self.cx.current_expansion.module, Rc::new(module));\n                 let result = noop_fold_item(item, self);\n                 self.cx.current_expansion.module = orig_module;\n-                self.cx.current_expansion.no_noninline_mod = orig_no_noninline_mod;\n+                self.cx.current_expansion.directory_ownership = orig_directory_ownership;\n                 return result;\n             }\n             // Ensure that test functions are accessible from the test harness."}, {"sha": "39b92c7d007dec77b151fd23129b3b9b0e02fbfb", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5675d9d28007691c4f396abcd4b29a228150eeb4/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5675d9d28007691c4f396abcd4b29a228150eeb4/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=5675d9d28007691c4f396abcd4b29a228150eeb4", "patch": "@@ -13,7 +13,7 @@ use syntax_pos::{self, Pos, Span};\n use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n-use parse::token;\n+use parse::{token, DirectoryOwnership};\n use parse;\n use print::pprust;\n use ptr::P;\n@@ -90,7 +90,8 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::T\n     };\n     // The file will be added to the code map by the parser\n     let path = res_rel_file(cx, sp, Path::new(&file));\n-    let p = parse::new_sub_parser_from_file(cx.parse_sess(), &path, true, None, sp);\n+    let directory_ownership = DirectoryOwnership::Owned;\n+    let p = parse::new_sub_parser_from_file(cx.parse_sess(), &path, directory_ownership, None, sp);\n \n     struct ExpandResult<'a> {\n         p: parse::parser::Parser<'a>,"}, {"sha": "4164b4a93ec91d4c91d65bcc65950730eff905e5", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5675d9d28007691c4f396abcd4b29a228150eeb4/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5675d9d28007691c4f396abcd4b29a228150eeb4/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=5675d9d28007691c4f396abcd4b29a228150eeb4", "patch": "@@ -19,7 +19,7 @@ use ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n use ext::tt::macro_parser::{parse, parse_failure_msg};\n use parse::ParseSess;\n use parse::lexer::new_tt_reader;\n-use parse::parser::{Parser, Restrictions};\n+use parse::parser::Parser;\n use parse::token::{self, NtTT, Token};\n use parse::token::Token::*;\n use print;\n@@ -117,11 +117,12 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                 let trncbr =\n                     new_tt_reader(&cx.parse_sess.span_diagnostic, Some(named_matches), rhs);\n                 let mut p = Parser::new(cx.parse_sess(), Box::new(trncbr));\n-                p.directory = cx.current_expansion.module.directory.clone();\n-                p.restrictions = match cx.current_expansion.no_noninline_mod {\n-                    true => Restrictions::NO_NONINLINE_MOD,\n-                    false => Restrictions::empty(),\n-                };\n+                let module = &cx.current_expansion.module;\n+                p.directory.path = module.directory.clone();\n+                p.directory.ownership = cx.current_expansion.directory_ownership;\n+                p.root_module_name =\n+                    module.mod_path.last().map(|id| (*id.name.as_str()).to_owned());\n+\n                 p.check_unknown_macro_variable();\n                 // Let the context choose how to interpret the result.\n                 // Weird, but useful for X-macros."}, {"sha": "f969e45b83a8e4948dad65a44205da84833e5dfd", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5675d9d28007691c4f396abcd4b29a228150eeb4/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5675d9d28007691c4f396abcd4b29a228150eeb4/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=5675d9d28007691c4f396abcd4b29a228150eeb4", "patch": "@@ -76,6 +76,19 @@ impl ParseSess {\n     }\n }\n \n+#[derive(Clone)]\n+pub struct Directory {\n+    pub path: PathBuf,\n+    pub ownership: DirectoryOwnership,\n+}\n+\n+#[derive(Copy, Clone)]\n+pub enum DirectoryOwnership {\n+    Owned,\n+    UnownedViaBlock,\n+    UnownedViaMod,\n+}\n+\n // a bunch of utility functions of the form parse_<thing>_from_<source>\n // where <thing> includes crate, expr, item, stmt, tts, and one that\n // uses a HOF to parse anything, and <source> includes file and\n@@ -152,11 +165,11 @@ pub fn new_parser_from_file<'a>(sess: &'a ParseSess, path: &Path) -> Parser<'a>\n /// On an error, use the given span as the source of the problem.\n pub fn new_sub_parser_from_file<'a>(sess: &'a ParseSess,\n                                     path: &Path,\n-                                    owns_directory: bool,\n+                                    directory_ownership: DirectoryOwnership,\n                                     module_name: Option<String>,\n                                     sp: Span) -> Parser<'a> {\n     let mut p = filemap_to_parser(sess, file_to_filemap(sess, path, Some(sp)));\n-    p.owns_directory = owns_directory;\n+    p.directory.ownership = directory_ownership;\n     p.root_module_name = module_name;\n     p\n }"}, {"sha": "ee69125ffae8354578e341a90a461ac17dfcf9bd", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 51, "deletions": 55, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/5675d9d28007691c4f396abcd4b29a228150eeb4/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5675d9d28007691c4f396abcd4b29a228150eeb4/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5675d9d28007691c4f396abcd4b29a228150eeb4", "patch": "@@ -49,7 +49,7 @@ use parse::common::SeqSep;\n use parse::lexer::{Reader, TokenAndSpan};\n use parse::obsolete::ObsoleteSyntax;\n use parse::token::{self, MatchNt, SubstNt};\n-use parse::{new_sub_parser_from_file, ParseSess};\n+use parse::{new_sub_parser_from_file, ParseSess, Directory, DirectoryOwnership};\n use util::parser::{AssocOp, Fixity};\n use print::pprust;\n use ptr::P;\n@@ -68,7 +68,6 @@ bitflags! {\n     flags Restrictions: u8 {\n         const RESTRICTION_STMT_EXPR         = 1 << 0,\n         const RESTRICTION_NO_STRUCT_LITERAL = 1 << 1,\n-        const NO_NONINLINE_MOD  = 1 << 2,\n     }\n }\n \n@@ -200,12 +199,9 @@ pub struct Parser<'a> {\n     /// extra detail when the same error is seen twice\n     pub obsolete_set: HashSet<ObsoleteSyntax>,\n     /// Used to determine the path to externally loaded source files\n-    pub directory: PathBuf,\n+    pub directory: Directory,\n     /// Stack of open delimiters and their spans. Used for error message.\n     pub open_braces: Vec<(token::DelimToken, Span)>,\n-    /// Flag if this parser \"owns\" the directory that it is currently parsing\n-    /// in. This will affect how nested files are looked up.\n-    pub owns_directory: bool,\n     /// Name of the root module this parser originated from. If `None`, then the\n     /// name is not known. This does not change while the parser is descending\n     /// into modules, and sub-parsers have new values for this name.\n@@ -245,8 +241,8 @@ pub struct ModulePath {\n }\n \n pub struct ModulePathSuccess {\n-    pub path: ::std::path::PathBuf,\n-    pub owns_directory: bool,\n+    pub path: PathBuf,\n+    pub directory_ownership: DirectoryOwnership,\n }\n \n pub struct ModulePathError {\n@@ -296,9 +292,8 @@ impl<'a> Parser<'a> {\n             quote_depth: 0,\n             parsing_token_tree: false,\n             obsolete_set: HashSet::new(),\n-            directory: PathBuf::new(),\n+            directory: Directory { path: PathBuf::new(), ownership: DirectoryOwnership::Owned },\n             open_braces: Vec::new(),\n-            owns_directory: true,\n             root_module_name: None,\n             expected_tokens: Vec::new(),\n             tts: Vec::new(),\n@@ -310,8 +305,8 @@ impl<'a> Parser<'a> {\n         parser.token = tok.tok;\n         parser.span = tok.sp;\n         if parser.span != syntax_pos::DUMMY_SP {\n-            parser.directory = PathBuf::from(sess.codemap().span_to_filename(parser.span));\n-            parser.directory.pop();\n+            parser.directory.path = PathBuf::from(sess.codemap().span_to_filename(parser.span));\n+            parser.directory.path.pop();\n         }\n         parser\n     }\n@@ -3966,9 +3961,11 @@ impl<'a> Parser<'a> {\n             }\n         } else {\n             // FIXME: Bad copy of attrs\n-            let restrictions = self.restrictions | Restrictions::NO_NONINLINE_MOD;\n-            match self.with_res(restrictions,\n-                                |this| this.parse_item_(attrs.clone(), false, true))? {\n+            let old_directory_ownership =\n+                mem::replace(&mut self.directory.ownership, DirectoryOwnership::UnownedViaBlock);\n+            let item = self.parse_item_(attrs.clone(), false, true)?;\n+            self.directory.ownership = old_directory_ownership;\n+            match item {\n                 Some(i) => Stmt {\n                     id: ast::DUMMY_NODE_ID,\n                     span: mk_sp(lo, i.span.hi),\n@@ -5271,33 +5268,33 @@ impl<'a> Parser<'a> {\n             self.bump();\n             if in_cfg {\n                 // This mod is in an external file. Let's go get it!\n-                let (m, attrs) = self.eval_src_mod(id, &outer_attrs, id_span)?;\n-                Ok((id, m, Some(attrs)))\n+                let ModulePathSuccess { path, directory_ownership } =\n+                    self.submod_path(id, &outer_attrs, id_span)?;\n+                let (module, attrs) =\n+                    self.eval_src_mod(path, directory_ownership, id.to_string(), id_span)?;\n+                Ok((id, module, Some(attrs)))\n             } else {\n                 let placeholder = ast::Mod { inner: syntax_pos::DUMMY_SP, items: Vec::new() };\n                 Ok((id, ItemKind::Mod(placeholder), None))\n             }\n         } else {\n-            let directory = self.directory.clone();\n-            let restrictions = self.push_directory(id, &outer_attrs);\n+            let old_directory = self.directory.clone();\n+            self.push_directory(id, &outer_attrs);\n             self.expect(&token::OpenDelim(token::Brace))?;\n             let mod_inner_lo = self.span.lo;\n             let attrs = self.parse_inner_attributes()?;\n-            let m = self.with_res(restrictions, |this| {\n-                this.parse_mod_items(&token::CloseDelim(token::Brace), mod_inner_lo)\n-            })?;\n-            self.directory = directory;\n-            Ok((id, ItemKind::Mod(m), Some(attrs)))\n+            let module = self.parse_mod_items(&token::CloseDelim(token::Brace), mod_inner_lo)?;\n+            self.directory = old_directory;\n+            Ok((id, ItemKind::Mod(module), Some(attrs)))\n         }\n     }\n \n-    fn push_directory(&mut self, id: Ident, attrs: &[Attribute]) -> Restrictions {\n+    fn push_directory(&mut self, id: Ident, attrs: &[Attribute]) {\n         if let Some(path) = ::attr::first_attr_value_str_by_name(attrs, \"path\") {\n-            self.directory.push(&*path.as_str());\n-            self.restrictions - Restrictions::NO_NONINLINE_MOD\n+            self.directory.path.push(&*path.as_str());\n+            self.directory.ownership = DirectoryOwnership::Owned;\n         } else {\n-            self.directory.push(&*id.name.as_str());\n-            self.restrictions\n+            self.directory.path.push(&*id.name.as_str());\n         }\n     }\n \n@@ -5317,8 +5314,14 @@ impl<'a> Parser<'a> {\n         let secondary_exists = codemap.file_exists(&secondary_path);\n \n         let result = match (default_exists, secondary_exists) {\n-            (true, false) => Ok(ModulePathSuccess { path: default_path, owns_directory: false }),\n-            (false, true) => Ok(ModulePathSuccess { path: secondary_path, owns_directory: true }),\n+            (true, false) => Ok(ModulePathSuccess {\n+                path: default_path,\n+                directory_ownership: DirectoryOwnership::UnownedViaMod,\n+            }),\n+            (false, true) => Ok(ModulePathSuccess {\n+                path: secondary_path,\n+                directory_ownership: DirectoryOwnership::Owned,\n+            }),\n             (false, false) => Err(ModulePathError {\n                 err_msg: format!(\"file not found for module `{}`\", mod_name),\n                 help_msg: format!(\"name the file either {} or {} inside the directory {:?}\",\n@@ -5346,13 +5349,19 @@ impl<'a> Parser<'a> {\n                    id: ast::Ident,\n                    outer_attrs: &[ast::Attribute],\n                    id_sp: Span) -> PResult<'a, ModulePathSuccess> {\n-        if let Some(p) = Parser::submod_path_from_attr(outer_attrs, &self.directory) {\n-            return Ok(ModulePathSuccess { path: p, owns_directory: true });\n+        if let Some(path) = Parser::submod_path_from_attr(outer_attrs, &self.directory.path) {\n+            return Ok(ModulePathSuccess {\n+                directory_ownership: match path.file_name().and_then(|s| s.to_str()) {\n+                    Some(\"mod.rs\") => DirectoryOwnership::Owned,\n+                    _ => DirectoryOwnership::UnownedViaMod,\n+                },\n+                path: path,\n+            });\n         }\n \n-        let paths = Parser::default_submod_path(id, &self.directory, self.sess.codemap());\n+        let paths = Parser::default_submod_path(id, &self.directory.path, self.sess.codemap());\n \n-        if self.restrictions.contains(Restrictions::NO_NONINLINE_MOD) {\n+        if let DirectoryOwnership::UnownedViaBlock = self.directory.ownership {\n             let msg =\n                 \"Cannot declare a non-inline module inside a block unless it has a path attribute\";\n             let mut err = self.diagnostic().struct_span_err(id_sp, msg);\n@@ -5362,10 +5371,10 @@ impl<'a> Parser<'a> {\n                 err.span_note(id_sp, &msg);\n             }\n             return Err(err);\n-        } else if !self.owns_directory {\n+        } else if let DirectoryOwnership::UnownedViaMod = self.directory.ownership {\n             let mut err = self.diagnostic().struct_span_err(id_sp,\n                 \"cannot declare a new module at this location\");\n-            let this_module = match self.directory.file_name() {\n+            let this_module = match self.directory.path.file_name() {\n                 Some(file_name) => file_name.to_str().unwrap().to_owned(),\n                 None => self.root_module_name.as_ref().unwrap().clone(),\n             };\n@@ -5390,25 +5399,11 @@ impl<'a> Parser<'a> {\n \n     /// Read a module from a source file.\n     fn eval_src_mod(&mut self,\n-                    id: ast::Ident,\n-                    outer_attrs: &[ast::Attribute],\n+                    path: PathBuf,\n+                    directory_ownership: DirectoryOwnership,\n+                    name: String,\n                     id_sp: Span)\n                     -> PResult<'a, (ast::ItemKind, Vec<ast::Attribute> )> {\n-        let ModulePathSuccess { path, owns_directory } = self.submod_path(id,\n-                                                                          outer_attrs,\n-                                                                          id_sp)?;\n-\n-        self.eval_src_mod_from_path(path,\n-                                    owns_directory,\n-                                    id.to_string(),\n-                                    id_sp)\n-    }\n-\n-    fn eval_src_mod_from_path(&mut self,\n-                              path: PathBuf,\n-                              owns_directory: bool,\n-                              name: String,\n-                              id_sp: Span) -> PResult<'a, (ast::ItemKind, Vec<ast::Attribute> )> {\n         let mut included_mod_stack = self.sess.included_mod_stack.borrow_mut();\n         if let Some(i) = included_mod_stack.iter().position(|p| *p == path) {\n             let mut err = String::from(\"circular modules: \");\n@@ -5423,7 +5418,8 @@ impl<'a> Parser<'a> {\n         included_mod_stack.push(path.clone());\n         drop(included_mod_stack);\n \n-        let mut p0 = new_sub_parser_from_file(self.sess, &path, owns_directory, Some(name), id_sp);\n+        let mut p0 =\n+            new_sub_parser_from_file(self.sess, &path, directory_ownership, Some(name), id_sp);\n         let mod_inner_lo = p0.span.lo;\n         let mod_attrs = p0.parse_inner_attributes()?;\n         let m0 = p0.parse_mod_items(&token::Eof, mod_inner_lo)?;"}]}