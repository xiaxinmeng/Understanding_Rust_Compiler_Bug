{"sha": "dfdedae840a3703fc8fe4e7c958645f416087625", "node_id": "C_kwDOAAsO6NoAKGRmZGVkYWU4NDBhMzcwM2ZjOGZlNGU3Yzk1ODY0NWY0MTYwODc2MjU", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-01T21:07:29Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-01T21:07:29Z"}, "message": "avoid copying thread manager state in data race detector", "tree": {"sha": "0cd66df9ff8905542033a3af79c48946866350e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0cd66df9ff8905542033a3af79c48946866350e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dfdedae840a3703fc8fe4e7c958645f416087625", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dfdedae840a3703fc8fe4e7c958645f416087625", "html_url": "https://github.com/rust-lang/rust/commit/dfdedae840a3703fc8fe4e7c958645f416087625", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dfdedae840a3703fc8fe4e7c958645f416087625/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f238513efac3193ed7d05222d03b8052690de0a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/f238513efac3193ed7d05222d03b8052690de0a3", "html_url": "https://github.com/rust-lang/rust/commit/f238513efac3193ed7d05222d03b8052690de0a3"}], "stats": {"total": 365, "additions": 186, "deletions": 179}, "files": [{"sha": "205b56ca4c071a623d22cb0826c05e5f473b6120", "filename": "src/concurrency/data_race.rs", "status": "modified", "additions": 102, "deletions": 122, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/dfdedae840a3703fc8fe4e7c958645f416087625/src%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfdedae840a3703fc8fe4e7c958645f416087625/src%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fdata_race.rs?ref=dfdedae840a3703fc8fe4e7c958645f416087625", "patch": "@@ -39,11 +39,6 @@\n //! so some atomic operations that only perform acquires do not increment the timestamp. Due to shared\n //! code some atomic operations may increment the timestamp when not necessary but this has no effect\n //! on the data-race detection code.\n-//!\n-//! FIXME:\n-//! currently we have our own local copy of the currently active thread index and names, this is due\n-//! in part to the inability to access the current location of threads.active_thread inside the AllocExtra\n-//! read, write and deallocate functions and should be cleaned up in the future.\n \n use std::{\n     cell::{Cell, Ref, RefCell, RefMut},\n@@ -767,7 +762,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     fn validate_atomic_fence(&mut self, atomic: AtomicFenceOrd) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         if let Some(data_race) = &mut this.machine.data_race {\n-            data_race.maybe_perform_sync_operation(|index, mut clocks| {\n+            data_race.maybe_perform_sync_operation(&this.machine.threads, |index, mut clocks| {\n                 log::trace!(\"Atomic fence on {:?} with ordering {:?}\", index, atomic);\n \n                 // Apply data-race detection for the current fences\n@@ -807,6 +802,7 @@ impl VClockAlloc {\n     /// Create a new data-race detector for newly allocated memory.\n     pub fn new_allocation(\n         global: &GlobalState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n         len: Size,\n         kind: MemoryKind<MiriMemoryKind>,\n     ) -> VClockAlloc {\n@@ -816,7 +812,7 @@ impl VClockAlloc {\n                 MiriMemoryKind::Rust | MiriMemoryKind::C | MiriMemoryKind::WinHeap,\n             )\n             | MemoryKind::Stack => {\n-                let (alloc_index, clocks) = global.current_thread_state();\n+                let (alloc_index, clocks) = global.current_thread_state(thread_mgr);\n                 let alloc_timestamp = clocks.clock[alloc_index];\n                 (alloc_timestamp, alloc_index)\n             }\n@@ -878,12 +874,13 @@ impl VClockAlloc {\n     #[inline(never)]\n     fn report_data_race<'tcx>(\n         global: &GlobalState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n         range: &MemoryCellClocks,\n         action: &str,\n         is_atomic: bool,\n         ptr_dbg: Pointer<AllocId>,\n     ) -> InterpResult<'tcx> {\n-        let (current_index, current_clocks) = global.current_thread_state();\n+        let (current_index, current_clocks) = global.current_thread_state(thread_mgr);\n         let write_clock;\n         let (other_action, other_thread, other_clock) = if range.write\n             > current_clocks.clock[range.write_index]\n@@ -918,8 +915,8 @@ impl VClockAlloc {\n         };\n \n         // Load elaborated thread information about the racing thread actions.\n-        let current_thread_info = global.print_thread_metadata(current_index);\n-        let other_thread_info = global.print_thread_metadata(other_thread);\n+        let current_thread_info = global.print_thread_metadata(thread_mgr, current_index);\n+        let other_thread_info = global.print_thread_metadata(thread_mgr, other_thread);\n \n         // Throw the data-race detection.\n         throw_ub_format!(\n@@ -936,9 +933,14 @@ impl VClockAlloc {\n \n     /// Detect racing atomic read and writes (not data races)\n     /// on every byte of the current access range\n-    pub(super) fn race_free_with_atomic(&self, range: AllocRange, global: &GlobalState) -> bool {\n+    pub(super) fn race_free_with_atomic(\n+        &self,\n+        range: AllocRange,\n+        global: &GlobalState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n+    ) -> bool {\n         if global.race_detecting() {\n-            let (_, clocks) = global.current_thread_state();\n+            let (_, clocks) = global.current_thread_state(thread_mgr);\n             let alloc_ranges = self.alloc_ranges.borrow();\n             for (_, range) in alloc_ranges.iter(range.start, range.size) {\n                 if !range.race_free_with_atomic(&clocks) {\n@@ -959,15 +961,17 @@ impl VClockAlloc {\n         alloc_id: AllocId,\n         range: AllocRange,\n         global: &GlobalState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n     ) -> InterpResult<'tcx> {\n         if global.race_detecting() {\n-            let (index, clocks) = global.current_thread_state();\n+            let (index, clocks) = global.current_thread_state(thread_mgr);\n             let mut alloc_ranges = self.alloc_ranges.borrow_mut();\n             for (offset, range) in alloc_ranges.iter_mut(range.start, range.size) {\n                 if let Err(DataRace) = range.read_race_detect(&clocks, index) {\n                     // Report data-race.\n                     return Self::report_data_race(\n                         global,\n+                        thread_mgr,\n                         range,\n                         \"Read\",\n                         false,\n@@ -988,14 +992,16 @@ impl VClockAlloc {\n         range: AllocRange,\n         write_type: WriteType,\n         global: &mut GlobalState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n     ) -> InterpResult<'tcx> {\n         if global.race_detecting() {\n-            let (index, clocks) = global.current_thread_state();\n+            let (index, clocks) = global.current_thread_state(thread_mgr);\n             for (offset, range) in self.alloc_ranges.get_mut().iter_mut(range.start, range.size) {\n                 if let Err(DataRace) = range.write_race_detect(&clocks, index, write_type) {\n                     // Report data-race\n                     return Self::report_data_race(\n                         global,\n+                        thread_mgr,\n                         range,\n                         write_type.get_descriptor(),\n                         false,\n@@ -1018,8 +1024,9 @@ impl VClockAlloc {\n         alloc_id: AllocId,\n         range: AllocRange,\n         global: &mut GlobalState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n     ) -> InterpResult<'tcx> {\n-        self.unique_access(alloc_id, range, WriteType::Write, global)\n+        self.unique_access(alloc_id, range, WriteType::Write, global, thread_mgr)\n     }\n \n     /// Detect data-races for an unsynchronized deallocate operation, will not perform\n@@ -1031,8 +1038,9 @@ impl VClockAlloc {\n         alloc_id: AllocId,\n         range: AllocRange,\n         global: &mut GlobalState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n     ) -> InterpResult<'tcx> {\n-        self.unique_access(alloc_id, range, WriteType::Deallocate, global)\n+        self.unique_access(alloc_id, range, WriteType::Deallocate, global, thread_mgr)\n     }\n }\n \n@@ -1068,26 +1076,30 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n                 );\n \n                 // Perform the atomic operation.\n-                data_race.maybe_perform_sync_operation(|index, mut clocks| {\n-                    for (offset, range) in\n-                        alloc_meta.alloc_ranges.borrow_mut().iter_mut(base_offset, size)\n-                    {\n-                        if let Err(DataRace) = op(range, &mut clocks, index, atomic) {\n-                            mem::drop(clocks);\n-                            return VClockAlloc::report_data_race(\n-                                data_race,\n-                                range,\n-                                description,\n-                                true,\n-                                Pointer::new(alloc_id, offset),\n-                            )\n-                            .map(|_| true);\n+                data_race.maybe_perform_sync_operation(\n+                    &this.machine.threads,\n+                    |index, mut clocks| {\n+                        for (offset, range) in\n+                            alloc_meta.alloc_ranges.borrow_mut().iter_mut(base_offset, size)\n+                        {\n+                            if let Err(DataRace) = op(range, &mut clocks, index, atomic) {\n+                                mem::drop(clocks);\n+                                return VClockAlloc::report_data_race(\n+                                    data_race,\n+                                    &this.machine.threads,\n+                                    range,\n+                                    description,\n+                                    true,\n+                                    Pointer::new(alloc_id, offset),\n+                                )\n+                                .map(|_| true);\n+                            }\n                         }\n-                    }\n \n-                    // This conservatively assumes all operations have release semantics\n-                    Ok(true)\n-                })?;\n+                        // This conservatively assumes all operations have release semantics\n+                        Ok(true)\n+                    },\n+                )?;\n \n                 // Log changes to atomic memory.\n                 if log::log_enabled!(log::Level::Trace) {\n@@ -1117,11 +1129,6 @@ struct ThreadExtraState {\n     /// read during data-race reporting.\n     vector_index: Option<VectorIdx>,\n \n-    /// The name of the thread, updated for better\n-    /// diagnostics when reporting detected data\n-    /// races.\n-    thread_name: Option<Box<str>>,\n-\n     /// Thread termination vector clock, this\n     /// is set on thread termination and is used\n     /// for joining on threads since the vector_index\n@@ -1161,9 +1168,6 @@ pub struct GlobalState {\n     /// The mapping of a given thread to associated thread metadata.\n     thread_info: RefCell<IndexVec<ThreadId, ThreadExtraState>>,\n \n-    /// The current vector index being executed.\n-    current_index: Cell<VectorIdx>,\n-\n     /// Potential vector indices that could be re-used on thread creation\n     /// values are inserted here on after the thread has terminated and\n     /// been joined with, and hence may potentially become free\n@@ -1173,12 +1177,6 @@ pub struct GlobalState {\n     /// active vector-clocks catch up with the threads timestamp.\n     reuse_candidates: RefCell<FxHashSet<VectorIdx>>,\n \n-    /// Counts the number of threads that are currently active\n-    /// if the number of active threads reduces to 1 and then\n-    /// a join operation occurs with the remaining main thread\n-    /// then multi-threaded execution may be disabled.\n-    active_thread_count: Cell<usize>,\n-\n     /// This contains threads that have terminated, but not yet joined\n     /// and so cannot become re-use candidates until a join operation\n     /// occurs.\n@@ -1203,8 +1201,6 @@ impl GlobalState {\n             vector_clocks: RefCell::new(IndexVec::new()),\n             vector_info: RefCell::new(IndexVec::new()),\n             thread_info: RefCell::new(IndexVec::new()),\n-            current_index: Cell::new(VectorIdx::new(0)),\n-            active_thread_count: Cell::new(1),\n             reuse_candidates: RefCell::new(FxHashSet::default()),\n             terminated_threads: RefCell::new(FxHashMap::default()),\n             last_sc_fence: RefCell::new(VClock::default()),\n@@ -1216,11 +1212,10 @@ impl GlobalState {\n         // the main-thread a name of \"main\".\n         let index = global_state.vector_clocks.get_mut().push(ThreadClockSet::default());\n         global_state.vector_info.get_mut().push(ThreadId::new(0));\n-        global_state.thread_info.get_mut().push(ThreadExtraState {\n-            vector_index: Some(index),\n-            thread_name: Some(\"main\".to_string().into_boxed_str()),\n-            termination_vector_clock: None,\n-        });\n+        global_state\n+            .thread_info\n+            .get_mut()\n+            .push(ThreadExtraState { vector_index: Some(index), termination_vector_clock: None });\n \n         global_state\n     }\n@@ -1274,14 +1269,10 @@ impl GlobalState {\n     // Hook for thread creation, enabled multi-threaded execution and marks\n     // the current thread timestamp as happening-before the current thread.\n     #[inline]\n-    pub fn thread_created(&mut self, thread: ThreadId) {\n-        let current_index = self.current_index();\n-\n-        // Increment the number of active threads.\n-        let active_threads = self.active_thread_count.get();\n-        self.active_thread_count.set(active_threads + 1);\n+    pub fn thread_created(&mut self, thread_mgr: &ThreadManager<'_, '_>, thread: ThreadId) {\n+        let current_index = self.current_index(thread_mgr);\n \n-        // Enable multi-threaded execution, there are now two threads\n+        // Enable multi-threaded execution, there are now at least two threads\n         // so data-races are now possible.\n         self.multi_threaded.set(true);\n \n@@ -1339,21 +1330,27 @@ impl GlobalState {\n         created.increment_clock(created_index);\n     }\n \n-    /// Hook on a thread join to update the implicit happens-before relation\n-    /// between the joined thread and the current thread.\n+    /// Hook on a thread join to update the implicit happens-before relation between the joined\n+    /// thread (the joinee, the thread that someone waited on) and the current thread (the joiner,\n+    /// the thread who was waiting).\n     #[inline]\n-    pub fn thread_joined(&mut self, current_thread: ThreadId, join_thread: ThreadId) {\n+    pub fn thread_joined(\n+        &mut self,\n+        thread_mgr: &ThreadManager<'_, '_>,\n+        joiner: ThreadId,\n+        joinee: ThreadId,\n+    ) {\n         let clocks_vec = self.vector_clocks.get_mut();\n         let thread_info = self.thread_info.get_mut();\n \n         // Load the vector clock of the current thread.\n-        let current_index = thread_info[current_thread]\n+        let current_index = thread_info[joiner]\n             .vector_index\n             .expect(\"Performed thread join on thread with no assigned vector\");\n         let current = &mut clocks_vec[current_index];\n \n         // Load the associated vector clock for the terminated thread.\n-        let join_clock = thread_info[join_thread]\n+        let join_clock = thread_info[joinee]\n             .termination_vector_clock\n             .as_ref()\n             .expect(\"Joined with thread but thread has not terminated\");\n@@ -1363,10 +1360,9 @@ impl GlobalState {\n         // Is not a release operation so the clock is not incremented.\n         current.clock.join(join_clock);\n \n-        // Check the number of active threads, if the value is 1\n+        // Check the number of live threads, if the value is 1\n         // then test for potentially disabling multi-threaded execution.\n-        let active_threads = self.active_thread_count.get();\n-        if active_threads == 1 {\n+        if thread_mgr.get_live_thread_count() == 1 {\n             // May potentially be able to disable multi-threaded execution.\n             let current_clock = &clocks_vec[current_index];\n             if clocks_vec\n@@ -1383,7 +1379,7 @@ impl GlobalState {\n         // If the thread is marked as terminated but not joined\n         // then move the thread to the re-use set.\n         let termination = self.terminated_threads.get_mut();\n-        if let Some(index) = termination.remove(&join_thread) {\n+        if let Some(index) = termination.remove(&joinee) {\n             let reuse = self.reuse_candidates.get_mut();\n             reuse.insert(index);\n         }\n@@ -1397,8 +1393,8 @@ impl GlobalState {\n     /// This should be called strictly before any calls to\n     /// `thread_joined`.\n     #[inline]\n-    pub fn thread_terminated(&mut self) {\n-        let current_index = self.current_index();\n+    pub fn thread_terminated(&mut self, thread_mgr: &ThreadManager<'_, '_>) {\n+        let current_index = self.current_index(thread_mgr);\n \n         // Increment the clock to a unique termination timestamp.\n         let vector_clocks = self.vector_clocks.get_mut();\n@@ -1420,35 +1416,6 @@ impl GlobalState {\n         // occurs.\n         let termination = self.terminated_threads.get_mut();\n         termination.insert(current_thread, current_index);\n-\n-        // Reduce the number of active threads, now that a thread has\n-        // terminated.\n-        let mut active_threads = self.active_thread_count.get();\n-        active_threads -= 1;\n-        self.active_thread_count.set(active_threads);\n-    }\n-\n-    /// Hook for updating the local tracker of the currently\n-    /// enabled thread, should always be updated whenever\n-    /// `active_thread` in thread.rs is updated.\n-    #[inline]\n-    pub fn thread_set_active(&self, thread: ThreadId) {\n-        let thread_info = self.thread_info.borrow();\n-        let vector_idx = thread_info[thread]\n-            .vector_index\n-            .expect(\"Setting thread active with no assigned vector\");\n-        self.current_index.set(vector_idx);\n-    }\n-\n-    /// Hook for updating the local tracker of the threads name\n-    /// this should always mirror the local value in thread.rs\n-    /// the thread name is used for improved diagnostics\n-    /// during a data-race.\n-    #[inline]\n-    pub fn thread_set_name(&mut self, thread: ThreadId, name: String) {\n-        let name = name.into_boxed_str();\n-        let thread_info = self.thread_info.get_mut();\n-        thread_info[thread].thread_name = Some(name);\n     }\n \n     /// Attempt to perform a synchronized operation, this\n@@ -1460,12 +1427,13 @@ impl GlobalState {\n     /// operation may create.\n     fn maybe_perform_sync_operation<'tcx>(\n         &self,\n+        thread_mgr: &ThreadManager<'_, '_>,\n         op: impl FnOnce(VectorIdx, RefMut<'_, ThreadClockSet>) -> InterpResult<'tcx, bool>,\n     ) -> InterpResult<'tcx> {\n         if self.multi_threaded.get() {\n-            let (index, clocks) = self.current_thread_state_mut();\n+            let (index, clocks) = self.current_thread_state_mut(thread_mgr);\n             if op(index, clocks)? {\n-                let (_, mut clocks) = self.current_thread_state_mut();\n+                let (_, mut clocks) = self.current_thread_state_mut(thread_mgr);\n                 clocks.increment_clock(index);\n             }\n         }\n@@ -1474,15 +1442,18 @@ impl GlobalState {\n \n     /// Internal utility to identify a thread stored internally\n     /// returns the id and the name for better diagnostics.\n-    fn print_thread_metadata(&self, vector: VectorIdx) -> String {\n+    fn print_thread_metadata(\n+        &self,\n+        thread_mgr: &ThreadManager<'_, '_>,\n+        vector: VectorIdx,\n+    ) -> String {\n         let thread = self.vector_info.borrow()[vector];\n-        let thread_name = &self.thread_info.borrow()[thread].thread_name;\n-        if let Some(name) = thread_name {\n-            let name: &str = name;\n-            format!(\"Thread(id = {:?}, name = {:?})\", thread.to_u32(), name)\n-        } else {\n-            format!(\"Thread(id = {:?})\", thread.to_u32())\n-        }\n+        let thread_name = thread_mgr.get_thread_name();\n+        format!(\n+            \"Thread(id = {:?}, name = {:?})\",\n+            thread.to_u32(),\n+            String::from_utf8_lossy(thread_name)\n+        )\n     }\n \n     /// Acquire a lock, express that the previous call of\n@@ -1534,8 +1505,11 @@ impl GlobalState {\n     /// Load the current vector clock in use and the current set of thread clocks\n     /// in use for the vector.\n     #[inline]\n-    pub(super) fn current_thread_state(&self) -> (VectorIdx, Ref<'_, ThreadClockSet>) {\n-        let index = self.current_index();\n+    pub(super) fn current_thread_state(\n+        &self,\n+        thread_mgr: &ThreadManager<'_, '_>,\n+    ) -> (VectorIdx, Ref<'_, ThreadClockSet>) {\n+        let index = self.current_index(thread_mgr);\n         let ref_vector = self.vector_clocks.borrow();\n         let clocks = Ref::map(ref_vector, |vec| &vec[index]);\n         (index, clocks)\n@@ -1544,8 +1518,11 @@ impl GlobalState {\n     /// Load the current vector clock in use and the current set of thread clocks\n     /// in use for the vector mutably for modification.\n     #[inline]\n-    pub(super) fn current_thread_state_mut(&self) -> (VectorIdx, RefMut<'_, ThreadClockSet>) {\n-        let index = self.current_index();\n+    pub(super) fn current_thread_state_mut(\n+        &self,\n+        thread_mgr: &ThreadManager<'_, '_>,\n+    ) -> (VectorIdx, RefMut<'_, ThreadClockSet>) {\n+        let index = self.current_index(thread_mgr);\n         let ref_vector = self.vector_clocks.borrow_mut();\n         let clocks = RefMut::map(ref_vector, |vec| &mut vec[index]);\n         (index, clocks)\n@@ -1554,19 +1531,22 @@ impl GlobalState {\n     /// Return the current thread, should be the same\n     /// as the data-race active thread.\n     #[inline]\n-    fn current_index(&self) -> VectorIdx {\n-        self.current_index.get()\n+    fn current_index(&self, thread_mgr: &ThreadManager<'_, '_>) -> VectorIdx {\n+        let active_thread_id = thread_mgr.get_active_thread_id();\n+        self.thread_info.borrow()[active_thread_id]\n+            .vector_index\n+            .expect(\"active thread has no assigned vector\")\n     }\n \n     // SC ATOMIC STORE rule in the paper.\n-    pub(super) fn sc_write(&self) {\n-        let (index, clocks) = self.current_thread_state();\n+    pub(super) fn sc_write(&self, thread_mgr: &ThreadManager<'_, '_>) {\n+        let (index, clocks) = self.current_thread_state(thread_mgr);\n         self.last_sc_write.borrow_mut().set_at_index(&clocks.clock, index);\n     }\n \n     // SC ATOMIC READ rule in the paper.\n-    pub(super) fn sc_read(&self) {\n-        let (.., mut clocks) = self.current_thread_state_mut();\n+    pub(super) fn sc_read(&self, thread_mgr: &ThreadManager<'_, '_>) {\n+        let (.., mut clocks) = self.current_thread_state_mut(thread_mgr);\n         clocks.read_seqcst.join(&self.last_sc_fence.borrow());\n     }\n }"}, {"sha": "e7ed9ea09a82a6c98b329212432cd6d352049983", "filename": "src/concurrency/weak_memory.rs", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/dfdedae840a3703fc8fe4e7c958645f416087625/src%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfdedae840a3703fc8fe4e7c958645f416087625/src%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fweak_memory.rs?ref=dfdedae840a3703fc8fe4e7c958645f416087625", "patch": "@@ -82,10 +82,12 @@ use rustc_const_eval::interpret::{\n };\n use rustc_data_structures::fx::FxHashMap;\n \n-use crate::{AtomicReadOrd, AtomicRwOrd, AtomicWriteOrd, Tag, VClock, VTimestamp, VectorIdx};\n+use crate::{\n+    AtomicReadOrd, AtomicRwOrd, AtomicWriteOrd, Tag, ThreadManager, VClock, VTimestamp, VectorIdx,\n+};\n \n use super::{\n-    data_race::{GlobalState, ThreadClockSet},\n+    data_race::{GlobalState as DataRaceState, ThreadClockSet},\n     range_object_map::{AccessType, RangeObjectMap},\n };\n \n@@ -149,7 +151,7 @@ impl StoreBufferAlloc {\n     /// before without data race, we can determine that the non-atomic access fully happens\n     /// after all the prior atomic accesses so the location no longer needs to exhibit\n     /// any weak memory behaviours until further atomic accesses.\n-    pub fn memory_accessed(&self, range: AllocRange, global: &GlobalState) {\n+    pub fn memory_accessed(&self, range: AllocRange, global: &DataRaceState) {\n         if !global.ongoing_action_data_race_free() {\n             let mut buffers = self.store_buffers.borrow_mut();\n             let access_type = buffers.access_type(range);\n@@ -236,17 +238,18 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n     }\n \n     /// Reads from the last store in modification order\n-    fn read_from_last_store(&self, global: &GlobalState) {\n+    fn read_from_last_store(&self, global: &DataRaceState, thread_mgr: &ThreadManager<'_, '_>) {\n         let store_elem = self.buffer.back();\n         if let Some(store_elem) = store_elem {\n-            let (index, clocks) = global.current_thread_state();\n+            let (index, clocks) = global.current_thread_state(thread_mgr);\n             store_elem.load_impl(index, &clocks);\n         }\n     }\n \n     fn buffered_read(\n         &self,\n-        global: &GlobalState,\n+        global: &DataRaceState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n         is_seqcst: bool,\n         rng: &mut (impl rand::Rng + ?Sized),\n         validate: impl FnOnce() -> InterpResult<'tcx>,\n@@ -257,7 +260,7 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n         let store_elem = {\n             // The `clocks` we got here must be dropped before calling validate_atomic_load\n             // as the race detector will update it\n-            let (.., clocks) = global.current_thread_state();\n+            let (.., clocks) = global.current_thread_state(thread_mgr);\n             // Load from a valid entry in the store buffer\n             self.fetch_store(is_seqcst, &clocks, &mut *rng)\n         };\n@@ -268,18 +271,19 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n         // requires access to ThreadClockSet.clock, which is updated by the race detector\n         validate()?;\n \n-        let (index, clocks) = global.current_thread_state();\n+        let (index, clocks) = global.current_thread_state(thread_mgr);\n         let loaded = store_elem.load_impl(index, &clocks);\n         Ok(loaded)\n     }\n \n     fn buffered_write(\n         &mut self,\n         val: ScalarMaybeUninit<Tag>,\n-        global: &GlobalState,\n+        global: &DataRaceState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n         is_seqcst: bool,\n     ) -> InterpResult<'tcx> {\n-        let (index, clocks) = global.current_thread_state();\n+        let (index, clocks) = global.current_thread_state(thread_mgr);\n \n         self.store_impl(val, index, &clocks.clock, is_seqcst);\n         Ok(())\n@@ -428,8 +432,11 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n         {\n             let range = alloc_range(base_offset, place.layout.size);\n             if alloc_buffers.is_overlapping(range)\n-                && !alloc_clocks\n-                    .race_free_with_atomic(range, this.machine.data_race.as_ref().unwrap())\n+                && !alloc_clocks.race_free_with_atomic(\n+                    range,\n+                    this.machine.data_race.as_ref().unwrap(),\n+                    &this.machine.threads,\n+                )\n             {\n                 throw_unsup_format!(\n                     \"racy imperfectly overlapping atomic access is not possible in the C++20 memory model, and not supported by Miri's weak memory emulation\"\n@@ -450,17 +457,17 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n         let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(place.ptr)?;\n         if let (\n             crate::AllocExtra { weak_memory: Some(alloc_buffers), .. },\n-            crate::Evaluator { data_race: Some(global), .. },\n+            crate::Evaluator { data_race: Some(global), threads, .. },\n         ) = this.get_alloc_extra_mut(alloc_id)?\n         {\n             if atomic == AtomicRwOrd::SeqCst {\n-                global.sc_read();\n-                global.sc_write();\n+                global.sc_read(threads);\n+                global.sc_write(threads);\n             }\n             let range = alloc_range(base_offset, place.layout.size);\n             let buffer = alloc_buffers.get_or_create_store_buffer_mut(range, init)?;\n-            buffer.read_from_last_store(global);\n-            buffer.buffered_write(new_val, global, atomic == AtomicRwOrd::SeqCst)?;\n+            buffer.read_from_last_store(global, threads);\n+            buffer.buffered_write(new_val, global, threads, atomic == AtomicRwOrd::SeqCst)?;\n         }\n         Ok(())\n     }\n@@ -477,7 +484,7 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n             let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(place.ptr)?;\n             if let Some(alloc_buffers) = this.get_alloc_extra(alloc_id)?.weak_memory.as_ref() {\n                 if atomic == AtomicReadOrd::SeqCst {\n-                    global.sc_read();\n+                    global.sc_read(&this.machine.threads);\n                 }\n                 let mut rng = this.machine.rng.borrow_mut();\n                 let buffer = alloc_buffers.get_or_create_store_buffer(\n@@ -486,6 +493,7 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n                 )?;\n                 let loaded = buffer.buffered_read(\n                     global,\n+                    &this.machine.threads,\n                     atomic == AtomicReadOrd::SeqCst,\n                     &mut *rng,\n                     validate,\n@@ -511,11 +519,11 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n         let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(dest.ptr)?;\n         if let (\n             crate::AllocExtra { weak_memory: Some(alloc_buffers), .. },\n-            crate::Evaluator { data_race: Some(global), .. },\n+            crate::Evaluator { data_race: Some(global), threads, .. },\n         ) = this.get_alloc_extra_mut(alloc_id)?\n         {\n             if atomic == AtomicWriteOrd::SeqCst {\n-                global.sc_write();\n+                global.sc_write(threads);\n             }\n \n             // UGLY HACK: in write_scalar_atomic() we don't know the value before our write,\n@@ -535,7 +543,7 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n                 buffer.buffer.pop_front();\n             }\n \n-            buffer.buffered_write(val, global, atomic == AtomicWriteOrd::SeqCst)?;\n+            buffer.buffered_write(val, global, threads, atomic == AtomicWriteOrd::SeqCst)?;\n         }\n \n         // Caller should've written to dest with the vanilla scalar write, we do nothing here\n@@ -555,14 +563,14 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n \n         if let Some(global) = &this.machine.data_race {\n             if atomic == AtomicReadOrd::SeqCst {\n-                global.sc_read();\n+                global.sc_read(&this.machine.threads);\n             }\n             let size = place.layout.size;\n             let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(place.ptr)?;\n             if let Some(alloc_buffers) = this.get_alloc_extra(alloc_id)?.weak_memory.as_ref() {\n                 let buffer = alloc_buffers\n                     .get_or_create_store_buffer(alloc_range(base_offset, size), init)?;\n-                buffer.read_from_last_store(global);\n+                buffer.read_from_last_store(global, &this.machine.threads);\n             }\n         }\n         Ok(())"}, {"sha": "86b174182c1f10dbbbfe23026b326a76edad1c2b", "filename": "src/machine.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dfdedae840a3703fc8fe4e7c958645f416087625/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfdedae840a3703fc8fe4e7c958645f416087625/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=dfdedae840a3703fc8fe4e7c958645f416087625", "patch": "@@ -647,7 +647,12 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n             None\n         };\n         let race_alloc = if let Some(data_race) = &ecx.machine.data_race {\n-            Some(data_race::AllocExtra::new_allocation(data_race, alloc.size(), kind))\n+            Some(data_race::AllocExtra::new_allocation(\n+                data_race,\n+                &ecx.machine.threads,\n+                alloc.size(),\n+                kind,\n+            ))\n         } else {\n             None\n         };\n@@ -756,7 +761,12 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         if let Some(data_race) = &alloc_extra.data_race {\n-            data_race.read(alloc_id, range, machine.data_race.as_ref().unwrap())?;\n+            data_race.read(\n+                alloc_id,\n+                range,\n+                machine.data_race.as_ref().unwrap(),\n+                &machine.threads,\n+            )?;\n         }\n         if let Some(stacked_borrows) = &alloc_extra.stacked_borrows {\n             stacked_borrows.borrow_mut().memory_read(\n@@ -782,7 +792,12 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         if let Some(data_race) = &mut alloc_extra.data_race {\n-            data_race.write(alloc_id, range, machine.data_race.as_mut().unwrap())?;\n+            data_race.write(\n+                alloc_id,\n+                range,\n+                machine.data_race.as_mut().unwrap(),\n+                &machine.threads,\n+            )?;\n         }\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n             stacked_borrows.get_mut().memory_written(\n@@ -811,7 +826,12 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n             register_diagnostic(NonHaltingDiagnostic::FreedAlloc(alloc_id));\n         }\n         if let Some(data_race) = &mut alloc_extra.data_race {\n-            data_race.deallocate(alloc_id, range, machine.data_race.as_mut().unwrap())?;\n+            data_race.deallocate(\n+                alloc_id,\n+                range,\n+                machine.data_race.as_mut().unwrap(),\n+                &machine.threads,\n+            )?;\n         }\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n             stacked_borrows.get_mut().memory_deallocated("}, {"sha": "d8f6292e9df399a2da37c675fc38012770664fb0", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dfdedae840a3703fc8fe4e7c958645f416087625/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfdedae840a3703fc8fe4e7c958645f416087625/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=dfdedae840a3703fc8fe4e7c958645f416087625", "patch": "@@ -1038,20 +1038,24 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             #[rustfmt::skip]\n             \"atomic_xsub_relaxed\" =>\n                 this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOrd::Relaxed)?,\n-            \"atomic_min_seqcst\" => this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::SeqCst)?,\n+            \"atomic_min_seqcst\" =>\n+                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::SeqCst)?,\n             \"atomic_min_acquire\" =>\n                 this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::Acquire)?,\n             \"atomic_min_release\" =>\n                 this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::Release)?,\n-            \"atomic_min_acqrel\" => this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::AcqRel)?,\n+            \"atomic_min_acqrel\" =>\n+                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::AcqRel)?,\n             \"atomic_min_relaxed\" =>\n                 this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::Relaxed)?,\n-            \"atomic_max_seqcst\" => this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::SeqCst)?,\n+            \"atomic_max_seqcst\" =>\n+                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::SeqCst)?,\n             \"atomic_max_acquire\" =>\n                 this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::Acquire)?,\n             \"atomic_max_release\" =>\n                 this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::Release)?,\n-            \"atomic_max_acqrel\" => this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::AcqRel)?,\n+            \"atomic_max_acqrel\" =>\n+                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::AcqRel)?,\n             \"atomic_max_relaxed\" =>\n                 this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::Relaxed)?,\n             \"atomic_umin_seqcst\" =>"}, {"sha": "7327f2b8114f69d06ee6bc87274638c90637c34f", "filename": "src/thread.rs", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/dfdedae840a3703fc8fe4e7c958645f416087625/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfdedae840a3703fc8fe4e7c958645f416087625/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=dfdedae840a3703fc8fe4e7c958645f416087625", "patch": "@@ -289,15 +289,21 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     }\n \n     /// Get the id of the currently active thread.\n-    fn get_active_thread_id(&self) -> ThreadId {\n+    pub fn get_active_thread_id(&self) -> ThreadId {\n         self.active_thread\n     }\n \n     /// Get the total number of threads that were ever spawn by this program.\n-    fn get_total_thread_count(&self) -> usize {\n+    pub fn get_total_thread_count(&self) -> usize {\n         self.threads.len()\n     }\n \n+    /// Get the total of threads that are currently live, i.e., not yet terminated.\n+    /// (They might be blocked.)\n+    pub fn get_live_thread_count(&self) -> usize {\n+        self.threads.iter().filter(|t| !matches!(t.state, ThreadState::Terminated)).count()\n+    }\n+\n     /// Has the given thread terminated?\n     fn has_terminated(&self, thread_id: ThreadId) -> bool {\n         self.threads[thread_id].state == ThreadState::Terminated\n@@ -366,7 +372,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         } else {\n             // The thread has already terminated - mark join happens-before\n             if let Some(data_race) = data_race {\n-                data_race.thread_joined(self.active_thread, joined_thread_id);\n+                data_race.thread_joined(self, self.active_thread, joined_thread_id);\n             }\n         }\n         Ok(())\n@@ -378,7 +384,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     }\n \n     /// Get the name of the active thread.\n-    fn get_thread_name(&self) -> &[u8] {\n+    pub fn get_thread_name(&self) -> &[u8] {\n         self.active_thread_ref().thread_name()\n     }\n \n@@ -460,21 +466,25 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n                 false\n             });\n         }\n-        // Set the thread into a terminated state in the data-race detector\n+        // Set the thread into a terminated state in the data-race detector.\n         if let Some(ref mut data_race) = data_race {\n-            data_race.thread_terminated();\n+            data_race.thread_terminated(self);\n         }\n         // Check if we need to unblock any threads.\n+        let mut joined_threads = vec![]; // store which threads joined, we'll need it\n         for (i, thread) in self.threads.iter_enumerated_mut() {\n             if thread.state == ThreadState::BlockedOnJoin(self.active_thread) {\n                 // The thread has terminated, mark happens-before edge to joining thread\n-                if let Some(ref mut data_race) = data_race {\n-                    data_race.thread_joined(i, self.active_thread);\n+                if let Some(_) = data_race {\n+                    joined_threads.push(i);\n                 }\n                 trace!(\"unblocking {:?} because {:?} terminated\", i, self.active_thread);\n                 thread.state = ThreadState::Enabled;\n             }\n         }\n+        for &i in &joined_threads {\n+            data_race.as_mut().unwrap().thread_joined(self, i, self.active_thread);\n+        }\n         free_tls_statics\n     }\n \n@@ -484,10 +494,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     /// used in stateless model checkers such as Loom: run the active thread as\n     /// long as we can and switch only when we have to (the active thread was\n     /// blocked, terminated, or has explicitly asked to be preempted).\n-    fn schedule(\n-        &mut self,\n-        data_race: &Option<data_race::GlobalState>,\n-    ) -> InterpResult<'tcx, SchedulingAction> {\n+    fn schedule(&mut self) -> InterpResult<'tcx, SchedulingAction> {\n         // Check whether the thread has **just** terminated (`check_terminated`\n         // checks whether the thread has popped all its stack and if yes, sets\n         // the thread state to terminated).\n@@ -535,9 +542,6 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n             debug_assert_ne!(self.active_thread, id);\n             if thread.state == ThreadState::Enabled {\n                 self.active_thread = id;\n-                if let Some(data_race) = data_race {\n-                    data_race.thread_set_active(self.active_thread);\n-                }\n                 break;\n             }\n         }\n@@ -598,7 +602,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         let id = this.machine.threads.create_thread();\n         if let Some(data_race) = &mut this.machine.data_race {\n-            data_race.thread_created(id);\n+            data_race.thread_created(&this.machine.threads, id);\n         }\n         id\n     }\n@@ -619,9 +623,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[inline]\n     fn set_active_thread(&mut self, thread_id: ThreadId) -> ThreadId {\n         let this = self.eval_context_mut();\n-        if let Some(data_race) = &this.machine.data_race {\n-            data_race.thread_set_active(thread_id);\n-        }\n         this.machine.threads.set_active_thread_id(thread_id)\n     }\n \n@@ -682,11 +683,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[inline]\n     fn set_active_thread_name(&mut self, new_thread_name: Vec<u8>) {\n         let this = self.eval_context_mut();\n-        if let Some(data_race) = &mut this.machine.data_race {\n-            if let Ok(string) = String::from_utf8(new_thread_name.clone()) {\n-                data_race.thread_set_name(this.machine.threads.active_thread, string);\n-            }\n-        }\n         this.machine.threads.set_thread_name(new_thread_name);\n     }\n \n@@ -776,8 +772,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[inline]\n     fn schedule(&mut self) -> InterpResult<'tcx, SchedulingAction> {\n         let this = self.eval_context_mut();\n-        let data_race = &this.machine.data_race;\n-        this.machine.threads.schedule(data_race)\n+        this.machine.threads.schedule()\n     }\n \n     /// Handles thread termination of the active thread: wakes up threads joining on this one,"}]}