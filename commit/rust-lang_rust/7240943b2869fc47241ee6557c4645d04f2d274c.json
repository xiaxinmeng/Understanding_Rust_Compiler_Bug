{"sha": "7240943b2869fc47241ee6557c4645d04f2d274c", "node_id": "C_kwDOAAsO6NoAKDcyNDA5NDNiMjg2OWZjNDcyNDFlZTY1NTdjNDY0NWQwNGYyZDI3NGM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-06-14T16:10:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-06-14T16:10:30Z"}, "message": "Rollup merge of #112605 - compiler-errors:negative-docs, r=spastorino\n\nImprove docs/clean up negative overlap functions\n\nClean up some functions in ways that should not affect behavior, change some names to be clearer (`negative_impl` and `implicit_negative` are not really clear imo), and add some documentation examples.\n\nr? `@spastorino`", "tree": {"sha": "8ecba16151bca2998202764b2d511c00f80baa44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ecba16151bca2998202764b2d511c00f80baa44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7240943b2869fc47241ee6557c4645d04f2d274c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkieZ2CRBK7hj4Ov3rIwAAI10IAEzY/EuY1FKUUNocyW6IL5Sg\niqYyXXMw4F3zVmhK4ZnjhSWwglH4yxIpPgtGyS563HE7KUAblaP37feVpmvd265U\nXoycRj5vP06tnuJxo7LZ4JIZiWX0Qw/P3+kVSZI4c3QL1JrcK9BJtw4a5D9ZMoqI\nE/Z40SjOFLbOpmhjmxyvgdF6iTZRnPpcnsOjxnqzlv3sI64vlwbJ8iNCLfisDpJP\n+V8szaZxWLeFBg2Q20NgbLIEszm5rpOf0XWMP6ZM0ksI04Jjuj5i4O/Gb5hQOITH\nxKcicZVrlTDMvprA7qetLqMcLYlSQwNBV+hY8zIUpIDgJS2f6dZaaLrLaxd1CDE=\n=nThb\n-----END PGP SIGNATURE-----\n", "payload": "tree 8ecba16151bca2998202764b2d511c00f80baa44\nparent 502ac47f8a1fa95e5b1c7dc2fb7f2a39c87ca1b1\nparent 9e210522bc3313e9398684e6e6740c5494441491\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1686759030 +0200\ncommitter GitHub <noreply@github.com> 1686759030 +0200\n\nRollup merge of #112605 - compiler-errors:negative-docs, r=spastorino\n\nImprove docs/clean up negative overlap functions\n\nClean up some functions in ways that should not affect behavior, change some names to be clearer (`negative_impl` and `implicit_negative` are not really clear imo), and add some documentation examples.\n\nr? `@spastorino`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7240943b2869fc47241ee6557c4645d04f2d274c", "html_url": "https://github.com/rust-lang/rust/commit/7240943b2869fc47241ee6557c4645d04f2d274c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7240943b2869fc47241ee6557c4645d04f2d274c/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "502ac47f8a1fa95e5b1c7dc2fb7f2a39c87ca1b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/502ac47f8a1fa95e5b1c7dc2fb7f2a39c87ca1b1", "html_url": "https://github.com/rust-lang/rust/commit/502ac47f8a1fa95e5b1c7dc2fb7f2a39c87ca1b1"}, {"sha": "9e210522bc3313e9398684e6e6740c5494441491", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e210522bc3313e9398684e6e6740c5494441491", "html_url": "https://github.com/rust-lang/rust/commit/9e210522bc3313e9398684e6e6740c5494441491"}], "stats": {"total": 168, "additions": 85, "deletions": 83}, "files": [{"sha": "190a78f6a8ecd55cea0e3a1a516d07a1c394c01a", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/7240943b2869fc47241ee6557c4645d04f2d274c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7240943b2869fc47241ee6557c4645d04f2d274c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=7240943b2869fc47241ee6557c4645d04f2d274c", "patch": "@@ -23,7 +23,7 @@ use rustc_middle::traits::specialization_graph::OverlapMode;\n use rustc_middle::traits::DefiningAnchor;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::visit::{TypeVisitable, TypeVisitableExt};\n-use rustc_middle::ty::{self, ImplSubject, Ty, TyCtxt, TypeVisitor};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitor};\n use rustc_span::symbol::sym;\n use rustc_span::DUMMY_SP;\n use std::fmt::Debug;\n@@ -170,8 +170,8 @@ fn overlap<'tcx>(\n     overlap_mode: OverlapMode,\n ) -> Option<OverlapResult<'tcx>> {\n     if overlap_mode.use_negative_impl() {\n-        if negative_impl(tcx, impl1_def_id, impl2_def_id)\n-            || negative_impl(tcx, impl2_def_id, impl1_def_id)\n+        if impl_intersection_has_negative_obligation(tcx, impl1_def_id, impl2_def_id)\n+            || impl_intersection_has_negative_obligation(tcx, impl2_def_id, impl1_def_id)\n         {\n             return None;\n         }\n@@ -198,13 +198,21 @@ fn overlap<'tcx>(\n     let impl1_header = with_fresh_ty_vars(selcx, param_env, impl1_def_id);\n     let impl2_header = with_fresh_ty_vars(selcx, param_env, impl2_def_id);\n \n-    let obligations = equate_impl_headers(selcx.infcx, &impl1_header, &impl2_header)?;\n+    // Equate the headers to find their intersection (the general type, with infer vars,\n+    // that may apply both impls).\n+    let equate_obligations = equate_impl_headers(selcx.infcx, &impl1_header, &impl2_header)?;\n     debug!(\"overlap: unification check succeeded\");\n \n-    if overlap_mode.use_implicit_negative() {\n-        if implicit_negative(selcx, param_env, &impl1_header, impl2_header, obligations) {\n-            return None;\n-        }\n+    if overlap_mode.use_implicit_negative()\n+        && impl_intersection_has_impossible_obligation(\n+            selcx,\n+            param_env,\n+            &impl1_header,\n+            impl2_header,\n+            equate_obligations,\n+        )\n+    {\n+        return None;\n     }\n \n     // We toggle the `leak_check` by using `skip_leak_check` when constructing the\n@@ -250,52 +258,38 @@ fn equate_impl_headers<'tcx>(\n     result.map(|infer_ok| infer_ok.obligations).ok()\n }\n \n-/// Given impl1 and impl2 check if both impls can be satisfied by a common type (including\n-/// where-clauses) If so, return false, otherwise return true, they are disjoint.\n-fn implicit_negative<'cx, 'tcx>(\n+/// Check if both impls can be satisfied by a common type by considering whether\n+/// any of either impl's obligations is not known to hold.\n+///\n+/// For example, given these two impls:\n+///     `impl From<MyLocalType> for Box<dyn Error>` (in my crate)\n+///     `impl<E> From<E> for Box<dyn Error> where E: Error` (in libstd)\n+///\n+/// After replacing both impl headers with inference vars (which happens before\n+/// this function is called), we get:\n+///     `Box<dyn Error>: From<MyLocalType>`\n+///     `Box<dyn Error>: From<?E>`\n+///\n+/// This gives us `?E = MyLocalType`. We then certainly know that `MyLocalType: Error`\n+/// never holds in intercrate mode since a local impl does not exist, and a\n+/// downstream impl cannot be added -- therefore can consider the intersection\n+/// of the two impls above to be empty.\n+///\n+/// Importantly, this works even if there isn't a `impl !Error for MyLocalType`.\n+fn impl_intersection_has_impossible_obligation<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     impl1_header: &ty::ImplHeader<'tcx>,\n     impl2_header: ty::ImplHeader<'tcx>,\n     obligations: PredicateObligations<'tcx>,\n ) -> bool {\n-    // There's no overlap if obligations are unsatisfiable or if the obligation negated is\n-    // satisfied.\n-    //\n-    // For example, given these two impl headers:\n-    //\n-    // `impl<'a> From<&'a str> for Box<dyn Error>`\n-    // `impl<E> From<E> for Box<dyn Error> where E: Error`\n-    //\n-    // So we have:\n-    //\n-    // `Box<dyn Error>: From<&'?a str>`\n-    // `Box<dyn Error>: From<?E>`\n-    //\n-    // After equating the two headers:\n-    //\n-    // `Box<dyn Error> = Box<dyn Error>`\n-    // So, `?E = &'?a str` and then given the where clause `&'?a str: Error`.\n-    //\n-    // If the obligation `&'?a str: Error` holds, it means that there's overlap. If that doesn't\n-    // hold we need to check if `&'?a str: !Error` holds, if doesn't hold there's overlap because\n-    // at some point an impl for `&'?a str: Error` could be added.\n-    debug!(\n-        \"implicit_negative(impl1_header={:?}, impl2_header={:?}, obligations={:?})\",\n-        impl1_header, impl2_header, obligations\n-    );\n     let infcx = selcx.infcx;\n-    let opt_failing_obligation = impl1_header\n-        .predicates\n-        .iter()\n-        .copied()\n-        .chain(impl2_header.predicates)\n-        .map(|p| infcx.resolve_vars_if_possible(p))\n-        .map(|p| Obligation {\n-            cause: ObligationCause::dummy(),\n-            param_env,\n-            recursion_depth: 0,\n-            predicate: p,\n+\n+    let opt_failing_obligation = [&impl1_header.predicates, &impl2_header.predicates]\n+        .into_iter()\n+        .flatten()\n+        .map(|&predicate| {\n+            Obligation::new(infcx.tcx, ObligationCause::dummy(), param_env, predicate)\n         })\n         .chain(obligations)\n         .find(|o| !selcx.predicate_may_hold_fatal(o));\n@@ -308,9 +302,27 @@ fn implicit_negative<'cx, 'tcx>(\n     }\n }\n \n-/// Given impl1 and impl2 check if both impls are never satisfied by a common type (including\n-/// where-clauses) If so, return true, they are disjoint and false otherwise.\n-fn negative_impl(tcx: TyCtxt<'_>, impl1_def_id: DefId, impl2_def_id: DefId) -> bool {\n+/// Check if both impls can be satisfied by a common type by considering whether\n+/// any of first impl's obligations is known not to hold *via a negative predicate*.\n+///\n+/// For example, given these two impls:\n+///     `struct MyCustomBox<T: ?Sized>(Box<T>);`\n+///     `impl From<&str> for MyCustomBox<dyn Error>` (in my crate)\n+///     `impl<E> From<E> for MyCustomBox<dyn Error> where E: Error` (in my crate)\n+///\n+/// After replacing the second impl's header with inference vars, we get:\n+///     `MyCustomBox<dyn Error>: From<&str>`\n+///     `MyCustomBox<dyn Error>: From<?E>`\n+///\n+/// This gives us `?E = &str`. We then try to prove the first impl's predicates\n+/// after negating, giving us `&str: !Error`. This is a negative impl provided by\n+/// libstd, and therefore we can guarantee for certain that libstd will never add\n+/// a positive impl for `&str: Error` (without it being a breaking change).\n+fn impl_intersection_has_negative_obligation(\n+    tcx: TyCtxt<'_>,\n+    impl1_def_id: DefId,\n+    impl2_def_id: DefId,\n+) -> bool {\n     debug!(\"negative_impl(impl1_def_id={:?}, impl2_def_id={:?})\", impl1_def_id, impl2_def_id);\n \n     // Create an infcx, taking the predicates of impl1 as assumptions:\n@@ -336,57 +348,45 @@ fn negative_impl(tcx: TyCtxt<'_>, impl1_def_id: DefId, impl2_def_id: DefId) -> b\n     // Attempt to prove that impl2 applies, given all of the above.\n     let selcx = &mut SelectionContext::new(&infcx);\n     let impl2_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl2_def_id);\n-    let (subject2, obligations) =\n+    let (subject2, normalization_obligations) =\n         impl_subject_and_oblig(selcx, impl_env, impl2_def_id, impl2_substs, |_, _| {\n             ObligationCause::dummy()\n         });\n \n-    !equate(&infcx, impl_env, subject1, subject2, obligations, impl1_def_id)\n-}\n-\n-fn equate<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n-    impl_env: ty::ParamEnv<'tcx>,\n-    subject1: ImplSubject<'tcx>,\n-    subject2: ImplSubject<'tcx>,\n-    obligations: impl Iterator<Item = PredicateObligation<'tcx>>,\n-    body_def_id: DefId,\n-) -> bool {\n-    // do the impls unify? If not, not disjoint.\n-    let Ok(InferOk { obligations: more_obligations, .. }) =\n+    // do the impls unify? If not, then it's not currently possible to prove any\n+    // obligations about their intersection.\n+    let Ok(InferOk { obligations: equate_obligations, .. }) =\n         infcx.at(&ObligationCause::dummy(), impl_env).eq(DefineOpaqueTypes::No,subject1, subject2)\n     else {\n         debug!(\"explicit_disjoint: {:?} does not unify with {:?}\", subject1, subject2);\n-        return true;\n+        return false;\n     };\n \n-    let opt_failing_obligation = obligations\n-        .into_iter()\n-        .chain(more_obligations)\n-        .find(|o| negative_impl_exists(infcx, o, body_def_id));\n-\n-    if let Some(failing_obligation) = opt_failing_obligation {\n-        debug!(\"overlap: obligation unsatisfiable {:?}\", failing_obligation);\n-        false\n-    } else {\n-        true\n+    for obligation in normalization_obligations.into_iter().chain(equate_obligations) {\n+        if negative_impl_exists(&infcx, &obligation, impl1_def_id) {\n+            debug!(\"overlap: obligation unsatisfiable {:?}\", obligation);\n+            return true;\n+        }\n     }\n+\n+    false\n }\n \n-/// Try to prove that a negative impl exist for the given obligation and its super predicates.\n+/// Try to prove that a negative impl exist for the obligation or its supertraits.\n+///\n+/// If such a negative impl exists, then the obligation definitely must not hold\n+/// due to coherence, even if it's not necessarily \"knowable\" in this crate. Any\n+/// valid impl downstream would not be able to exist due to the overlapping\n+/// negative impl.\n #[instrument(level = \"debug\", skip(infcx))]\n fn negative_impl_exists<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     o: &PredicateObligation<'tcx>,\n     body_def_id: DefId,\n ) -> bool {\n-    if resolve_negative_obligation(infcx.fork(), o, body_def_id) {\n-        return true;\n-    }\n-\n     // Try to prove a negative obligation exists for super predicates\n     for pred in util::elaborate(infcx.tcx, iter::once(o.predicate)) {\n-        if resolve_negative_obligation(infcx.fork(), &o.with(infcx.tcx, pred), body_def_id) {\n+        if prove_negated_obligation(infcx.fork(), &o.with(infcx.tcx, pred), body_def_id) {\n             return true;\n         }\n     }\n@@ -395,7 +395,7 @@ fn negative_impl_exists<'tcx>(\n }\n \n #[instrument(level = \"debug\", skip(infcx))]\n-fn resolve_negative_obligation<'tcx>(\n+fn prove_negated_obligation<'tcx>(\n     infcx: InferCtxt<'tcx>,\n     o: &PredicateObligation<'tcx>,\n     body_def_id: DefId,"}, {"sha": "5acd7b573dd9a0169cbca56e353638d48c297fd2", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7240943b2869fc47241ee6557c4645d04f2d274c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7240943b2869fc47241ee6557c4645d04f2d274c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=7240943b2869fc47241ee6557c4645d04f2d274c", "patch": "@@ -365,7 +365,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     }\n \n                     if !candidate_set.ambiguous && no_candidates_apply {\n-                        let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n+                        let trait_ref = self.infcx.resolve_vars_if_possible(\n+                            stack.obligation.predicate.skip_binder().trait_ref,\n+                        );\n                         if !trait_ref.references_error() {\n                             let self_ty = trait_ref.self_ty();\n                             let (trait_desc, self_desc) = with_no_trimmed_paths!({"}]}