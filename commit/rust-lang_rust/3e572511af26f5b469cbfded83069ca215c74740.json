{"sha": "3e572511af26f5b469cbfded83069ca215c74740", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlNTcyNTExYWYyNmY1YjQ2OWNiZmRlZDgzMDY5Y2EyMTVjNzQ3NDA=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2013-07-11T17:31:38Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2013-07-17T15:18:29Z"}, "message": "Remove duplicated code from trans_intrinsics\n\nMost arms of the huge match contain the same code, differing only in\nsmall details like the name of the llvm intrinsic that is to be called.\nThus the duplicated code can be factored out into a few functions that\ntake some parameters to handle the differences.", "tree": {"sha": "e4554e478460c89582fde5586c9db27c06d8e3c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4554e478460c89582fde5586c9db27c06d8e3c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e572511af26f5b469cbfded83069ca215c74740", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e572511af26f5b469cbfded83069ca215c74740", "html_url": "https://github.com/rust-lang/rust/commit/3e572511af26f5b469cbfded83069ca215c74740", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e572511af26f5b469cbfded83069ca215c74740/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93c270c63d158805a068b8e7ced660df1051c3ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/93c270c63d158805a068b8e7ced660df1051c3ca", "html_url": "https://github.com/rust-lang/rust/commit/93c270c63d158805a068b8e7ced660df1051c3ca"}], "stats": {"total": 428, "additions": 109, "deletions": 319}, "files": [{"sha": "6a38c41da0d6230ef74074a5efe1cd49dfbcb60e", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 109, "deletions": 319, "changes": 428, "blob_url": "https://github.com/rust-lang/rust/blob/3e572511af26f5b469cbfded83069ca215c74740/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e572511af26f5b469cbfded83069ca215c74740/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=3e572511af26f5b469cbfded83069ca215c74740", "patch": "@@ -550,6 +550,64 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                        ref_id: Option<ast::node_id>) {\n     debug!(\"trans_intrinsic(item.ident=%s)\", ccx.sess.str_of(item.ident));\n \n+    fn simple_llvm_intrinsic(bcx: block, name: &'static str, num_args: uint) {\n+        assert!(num_args <= 4);\n+        let mut args = [0 as ValueRef, ..4];\n+        let first_real_arg = bcx.fcx.arg_pos(0u);\n+        for uint::range(0, num_args) |i| {\n+            args[i] = get_param(bcx.fcx.llfn, first_real_arg + i);\n+        }\n+        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n+        Store(bcx, Call(bcx, llfn, args.slice(0, num_args)), bcx.fcx.llretptr.get());\n+    }\n+\n+    fn memcpy_intrinsic(bcx: block, name: &'static str, tp_ty: ty::t, sizebits: u8) {\n+        let ccx = bcx.ccx();\n+        let lltp_ty = type_of::type_of(ccx, tp_ty);\n+        let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n+        let size = match sizebits {\n+            32 => C_i32(machine::llsize_of_real(ccx, lltp_ty) as i32),\n+            64 => C_i64(machine::llsize_of_real(ccx, lltp_ty) as i64),\n+            _ => ccx.sess.fatal(\"Invalid value for sizebits\")\n+        };\n+\n+        let decl = bcx.fcx.llfn;\n+        let first_real_arg = bcx.fcx.arg_pos(0u);\n+        let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n+        let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), Type::i8p());\n+        let count = get_param(decl, first_real_arg + 2);\n+        let volatile = C_i1(false);\n+        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n+        Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n+    }\n+\n+    fn memset_intrinsic(bcx: block, name: &'static str, tp_ty: ty::t, sizebits: u8) {\n+        let ccx = bcx.ccx();\n+        let lltp_ty = type_of::type_of(ccx, tp_ty);\n+        let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n+        let size = match sizebits {\n+            32 => C_i32(machine::llsize_of_real(ccx, lltp_ty) as i32),\n+            64 => C_i64(machine::llsize_of_real(ccx, lltp_ty) as i64),\n+            _ => ccx.sess.fatal(\"Invalid value for sizebits\")\n+        };\n+\n+        let decl = bcx.fcx.llfn;\n+        let first_real_arg = bcx.fcx.arg_pos(0u);\n+        let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n+        let val = get_param(decl, first_real_arg + 1);\n+        let count = get_param(decl, first_real_arg + 2);\n+        let volatile = C_i1(false);\n+        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n+        Call(bcx, llfn, [dst_ptr, val, Mul(bcx, size, count), align, volatile]);\n+    }\n+\n+    fn count_zeros_intrinsic(bcx: block, name: &'static str) {\n+        let x = get_param(bcx.fcx.llfn, bcx.fcx.arg_pos(0u));\n+        let y = C_i1(false);\n+        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n+        Store(bcx, Call(bcx, llfn, [x, y]), bcx.fcx.llretptr.get())\n+    }\n+\n     let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, item.id));\n \n     let fcx = new_fn_ctxt_w_id(ccx,\n@@ -800,325 +858,57 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let morestack_addr = PointerCast(bcx, morestack_addr, Type::nil().ptr_to());\n             Store(bcx, morestack_addr, fcx.llretptr.get());\n         }\n-        \"memcpy32\" => {\n-            let tp_ty = substs.tys[0];\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n-            let size = C_i32(machine::llsize_of_real(ccx, lltp_ty) as i32);\n-\n-            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n-            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), Type::i8p());\n-            let count = get_param(decl, first_real_arg + 2);\n-            let volatile = C_i1(false);\n-            let llfn = bcx.ccx().intrinsics.get_copy(& &\"llvm.memcpy.p0i8.p0i8.i32\");\n-            Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n-        }\n-        \"memcpy64\" => {\n-            let tp_ty = substs.tys[0];\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n-            let size = C_i64(machine::llsize_of_real(ccx, lltp_ty) as i64);\n-\n-            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n-            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), Type::i8p());\n-            let count = get_param(decl, first_real_arg + 2);\n-            let volatile = C_i1(false);\n-            let llfn = bcx.ccx().intrinsics.get_copy(& &\"llvm.memcpy.p0i8.p0i8.i64\");\n-            Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n-        }\n-        \"memmove32\" => {\n-            let tp_ty = substs.tys[0];\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n-            let size = C_i32(machine::llsize_of_real(ccx, lltp_ty) as i32);\n-\n-            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n-            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), Type::i8p());\n-            let count = get_param(decl, first_real_arg + 2);\n-            let volatile = C_i1(false);\n-            let llfn = bcx.ccx().intrinsics.get_copy(& &\"llvm.memmove.p0i8.p0i8.i32\");\n-            Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n-        }\n-        \"memmove64\" => {\n-            let tp_ty = substs.tys[0];\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n-            let size = C_i64(machine::llsize_of_real(ccx, lltp_ty) as i64);\n-\n-            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n-            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), Type::i8p());\n-            let count = get_param(decl, first_real_arg + 2);\n-            let volatile = C_i1(false);\n-            let llfn = bcx.ccx().intrinsics.get_copy(& &\"llvm.memmove.p0i8.p0i8.i64\");\n-            Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n-        }\n-        \"memset32\" => {\n-            let tp_ty = substs.tys[0];\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n-            let size = C_i32(machine::llsize_of_real(ccx, lltp_ty) as i32);\n-\n-            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n-            let val = get_param(decl, first_real_arg + 1);\n-            let count = get_param(decl, first_real_arg + 2);\n-            let volatile = C_i1(false);\n-            let llfn = bcx.ccx().intrinsics.get_copy(& &\"llvm.memset.p0i8.i32\");\n-            Call(bcx, llfn, [dst_ptr, val, Mul(bcx, size, count), align, volatile]);\n-        }\n-        \"memset64\" => {\n-            let tp_ty = substs.tys[0];\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n-            let size = C_i64(machine::llsize_of_real(ccx, lltp_ty) as i64);\n-\n-            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n-            let val = get_param(decl, first_real_arg + 1);\n-            let count = get_param(decl, first_real_arg + 2);\n-            let volatile = C_i1(false);\n-            let llfn = bcx.ccx().intrinsics.get_copy(& &\"llvm.memset.p0i8.i64\");\n-            Call(bcx, llfn, [dst_ptr, val, Mul(bcx, size, count), align, volatile]);\n-        }\n-        \"sqrtf32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let sqrtf = ccx.intrinsics.get_copy(& &\"llvm.sqrt.f32\");\n-            Store(bcx, Call(bcx, sqrtf, [x]), fcx.llretptr.get());\n-        }\n-        \"sqrtf64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let sqrtf = ccx.intrinsics.get_copy(& &\"llvm.sqrt.f64\");\n-            Store(bcx, Call(bcx, sqrtf, [x]), fcx.llretptr.get());\n-        }\n-        \"powif32\" => {\n-            let a = get_param(decl, first_real_arg);\n-            let x = get_param(decl, first_real_arg + 1u);\n-            let powif = ccx.intrinsics.get_copy(& &\"llvm.powi.f32\");\n-            Store(bcx, Call(bcx, powif, [a, x]), fcx.llretptr.get());\n-        }\n-        \"powif64\" => {\n-            let a = get_param(decl, first_real_arg);\n-            let x = get_param(decl, first_real_arg + 1u);\n-            let powif = ccx.intrinsics.get_copy(& &\"llvm.powi.f64\");\n-            Store(bcx, Call(bcx, powif, [a, x]), fcx.llretptr.get());\n-        }\n-        \"sinf32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let sinf = ccx.intrinsics.get_copy(& &\"llvm.sin.f32\");\n-            Store(bcx, Call(bcx, sinf, [x]), fcx.llretptr.get());\n-        }\n-        \"sinf64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let sinf = ccx.intrinsics.get_copy(& &\"llvm.sin.f64\");\n-            Store(bcx, Call(bcx, sinf, [x]), fcx.llretptr.get());\n-        }\n-        \"cosf32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let cosf = ccx.intrinsics.get_copy(& &\"llvm.cos.f32\");\n-            Store(bcx, Call(bcx, cosf, [x]), fcx.llretptr.get());\n-        }\n-        \"cosf64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let cosf = ccx.intrinsics.get_copy(& &\"llvm.cos.f64\");\n-            Store(bcx, Call(bcx, cosf, [x]), fcx.llretptr.get());\n-        }\n-        \"powf32\" => {\n-            let a = get_param(decl, first_real_arg);\n-            let x = get_param(decl, first_real_arg + 1u);\n-            let powf = ccx.intrinsics.get_copy(& &\"llvm.pow.f32\");\n-            Store(bcx, Call(bcx, powf, [a, x]), fcx.llretptr.get());\n-        }\n-        \"powf64\" => {\n-            let a = get_param(decl, first_real_arg);\n-            let x = get_param(decl, first_real_arg + 1u);\n-            let powf = ccx.intrinsics.get_copy(& &\"llvm.pow.f64\");\n-            Store(bcx, Call(bcx, powf, [a, x]), fcx.llretptr.get());\n-        }\n-        \"expf32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let expf = ccx.intrinsics.get_copy(& &\"llvm.exp.f32\");\n-            Store(bcx, Call(bcx, expf, [x]), fcx.llretptr.get());\n-        }\n-        \"expf64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let expf = ccx.intrinsics.get_copy(& &\"llvm.exp.f64\");\n-            Store(bcx, Call(bcx, expf, [x]), fcx.llretptr.get());\n-        }\n-        \"exp2f32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let exp2f = ccx.intrinsics.get_copy(& &\"llvm.exp2.f32\");\n-            Store(bcx, Call(bcx, exp2f, [x]), fcx.llretptr.get());\n-        }\n-        \"exp2f64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let exp2f = ccx.intrinsics.get_copy(& &\"llvm.exp2.f64\");\n-            Store(bcx, Call(bcx, exp2f, [x]), fcx.llretptr.get());\n-        }\n-        \"logf32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let logf = ccx.intrinsics.get_copy(& &\"llvm.log.f32\");\n-            Store(bcx, Call(bcx, logf, [x]), fcx.llretptr.get());\n-        }\n-        \"logf64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let logf = ccx.intrinsics.get_copy(& &\"llvm.log.f64\");\n-            Store(bcx, Call(bcx, logf, [x]), fcx.llretptr.get());\n-        }\n-        \"log10f32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let log10f = ccx.intrinsics.get_copy(& &\"llvm.log10.f32\");\n-            Store(bcx, Call(bcx, log10f, [x]), fcx.llretptr.get());\n-        }\n-        \"log10f64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let log10f = ccx.intrinsics.get_copy(& &\"llvm.log10.f64\");\n-            Store(bcx, Call(bcx, log10f, [x]), fcx.llretptr.get());\n-        }\n-        \"log2f32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let log2f = ccx.intrinsics.get_copy(& &\"llvm.log2.f32\");\n-            Store(bcx, Call(bcx, log2f, [x]), fcx.llretptr.get());\n-        }\n-        \"log2f64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let log2f = ccx.intrinsics.get_copy(& &\"llvm.log2.f64\");\n-            Store(bcx, Call(bcx, log2f, [x]), fcx.llretptr.get());\n-        }\n-        \"fmaf32\" => {\n-            let a = get_param(decl, first_real_arg);\n-            let b = get_param(decl, first_real_arg + 1u);\n-            let c = get_param(decl, first_real_arg + 2u);\n-            let fmaf = ccx.intrinsics.get_copy(& &\"llvm.fma.f32\");\n-            Store(bcx, Call(bcx, fmaf, [a, b, c]), fcx.llretptr.get());\n-        }\n-        \"fmaf64\" => {\n-            let a = get_param(decl, first_real_arg);\n-            let b = get_param(decl, first_real_arg + 1u);\n-            let c = get_param(decl, first_real_arg + 2u);\n-            let fmaf = ccx.intrinsics.get_copy(& &\"llvm.fma.f64\");\n-            Store(bcx, Call(bcx, fmaf, [a, b, c]), fcx.llretptr.get());\n-        }\n-        \"fabsf32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let fabsf = ccx.intrinsics.get_copy(& &\"llvm.fabs.f32\");\n-            Store(bcx, Call(bcx, fabsf, [x]), fcx.llretptr.get());\n-        }\n-        \"fabsf64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let fabsf = ccx.intrinsics.get_copy(& &\"llvm.fabs.f64\");\n-            Store(bcx, Call(bcx, fabsf, [x]), fcx.llretptr.get());\n-        }\n-        \"floorf32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let floorf = ccx.intrinsics.get_copy(& &\"llvm.floor.f32\");\n-            Store(bcx, Call(bcx, floorf, [x]), fcx.llretptr.get());\n-        }\n-        \"floorf64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let floorf = ccx.intrinsics.get_copy(& &\"llvm.floor.f64\");\n-            Store(bcx, Call(bcx, floorf, [x]), fcx.llretptr.get());\n-        }\n-        \"ceilf32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let ceilf = ccx.intrinsics.get_copy(& &\"llvm.ceil.f32\");\n-            Store(bcx, Call(bcx, ceilf, [x]), fcx.llretptr.get());\n-        }\n-        \"ceilf64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let ceilf = ccx.intrinsics.get_copy(& &\"llvm.ceil.f64\");\n-            Store(bcx, Call(bcx, ceilf, [x]), fcx.llretptr.get());\n-        }\n-        \"truncf32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let truncf = ccx.intrinsics.get_copy(& &\"llvm.trunc.f32\");\n-            Store(bcx, Call(bcx, truncf, [x]), fcx.llretptr.get());\n-        }\n-        \"truncf64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let truncf = ccx.intrinsics.get_copy(& &\"llvm.trunc.f64\");\n-            Store(bcx, Call(bcx, truncf, [x]), fcx.llretptr.get());\n-        }\n-        \"ctpop8\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let ctpop = ccx.intrinsics.get_copy(& &\"llvm.ctpop.i8\");\n-            Store(bcx, Call(bcx, ctpop, [x]), fcx.llretptr.get())\n-        }\n-        \"ctpop16\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let ctpop = ccx.intrinsics.get_copy(& &\"llvm.ctpop.i16\");\n-            Store(bcx, Call(bcx, ctpop, [x]), fcx.llretptr.get())\n-        }\n-        \"ctpop32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let ctpop = ccx.intrinsics.get_copy(& &\"llvm.ctpop.i32\");\n-            Store(bcx, Call(bcx, ctpop, [x]), fcx.llretptr.get())\n-        }\n-        \"ctpop64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let ctpop = ccx.intrinsics.get_copy(& &\"llvm.ctpop.i64\");\n-            Store(bcx, Call(bcx, ctpop, [x]), fcx.llretptr.get())\n-        }\n-        \"ctlz8\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let y = C_i1(false);\n-            let ctlz = ccx.intrinsics.get_copy(& &\"llvm.ctlz.i8\");\n-            Store(bcx, Call(bcx, ctlz, [x, y]), fcx.llretptr.get())\n-        }\n-        \"ctlz16\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let y = C_i1(false);\n-            let ctlz = ccx.intrinsics.get_copy(& &\"llvm.ctlz.i16\");\n-            Store(bcx, Call(bcx, ctlz, [x, y]), fcx.llretptr.get())\n-        }\n-        \"ctlz32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let y = C_i1(false);\n-            let ctlz = ccx.intrinsics.get_copy(& &\"llvm.ctlz.i32\");\n-            Store(bcx, Call(bcx, ctlz, [x, y]), fcx.llretptr.get())\n-        }\n-        \"ctlz64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let y = C_i1(false);\n-            let ctlz = ccx.intrinsics.get_copy(& &\"llvm.ctlz.i64\");\n-            Store(bcx, Call(bcx, ctlz, [x, y]), fcx.llretptr.get())\n-        }\n-        \"cttz8\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let y = C_i1(false);\n-            let cttz = ccx.intrinsics.get_copy(& &\"llvm.cttz.i8\");\n-            Store(bcx, Call(bcx, cttz, [x, y]), fcx.llretptr.get())\n-        }\n-        \"cttz16\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let y = C_i1(false);\n-            let cttz = ccx.intrinsics.get_copy(& &\"llvm.cttz.i16\");\n-            Store(bcx, Call(bcx, cttz, [x, y]), fcx.llretptr.get())\n-        }\n-        \"cttz32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let y = C_i1(false);\n-            let cttz = ccx.intrinsics.get_copy(& &\"llvm.cttz.i32\");\n-            Store(bcx, Call(bcx, cttz, [x, y]), fcx.llretptr.get())\n-        }\n-        \"cttz64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let y = C_i1(false);\n-            let cttz = ccx.intrinsics.get_copy(& &\"llvm.cttz.i64\");\n-            Store(bcx, Call(bcx, cttz, [x, y]), fcx.llretptr.get())\n-        }\n-        \"bswap16\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let cttz = ccx.intrinsics.get_copy(& &\"llvm.bswap.i16\");\n-            Store(bcx, Call(bcx, cttz, [x]), fcx.llretptr.get())\n-        }\n-        \"bswap32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let cttz = ccx.intrinsics.get_copy(& &\"llvm.bswap.i32\");\n-            Store(bcx, Call(bcx, cttz, [x]), fcx.llretptr.get())\n-        }\n-        \"bswap64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let cttz = ccx.intrinsics.get_copy(& &\"llvm.bswap.i64\");\n-            Store(bcx, Call(bcx, cttz, [x]), fcx.llretptr.get())\n-        }\n+        \"memcpy32\" => memcpy_intrinsic(bcx, \"llvm.memcpy.p0i8.p0i8.i32\", substs.tys[0], 32),\n+        \"memcpy64\" => memcpy_intrinsic(bcx, \"llvm.memcpy.p0i8.p0i8.i64\", substs.tys[0], 64),\n+        \"memmove32\" => memcpy_intrinsic(bcx, \"llvm.memmove.p0i8.p0i8.i32\", substs.tys[0], 32),\n+        \"memmove64\" => memcpy_intrinsic(bcx, \"llvm.memmove.p0i8.p0i8.i64\", substs.tys[0], 64),\n+        \"memset32\" => memset_intrinsic(bcx, \"llvm.memset.p0i8.i32\", substs.tys[0], 32),\n+        \"memset64\" => memset_intrinsic(bcx, \"llvm.memset.p0i8.i64\", substs.tys[0], 64),\n+        \"sqrtf32\" => simple_llvm_intrinsic(bcx, \"llvm.sqrt.f32\", 1),\n+        \"sqrtf64\" => simple_llvm_intrinsic(bcx, \"llvm.sqrt.f64\", 1),\n+        \"powif32\" => simple_llvm_intrinsic(bcx, \"llvm.powi.f32\", 2),\n+        \"powif64\" => simple_llvm_intrinsic(bcx, \"llvm.powi.f64\", 2),\n+        \"sinf32\" => simple_llvm_intrinsic(bcx, \"llvm.sin.f32\", 1),\n+        \"sinf64\" => simple_llvm_intrinsic(bcx, \"llvm.sin.f64\", 1),\n+        \"cosf32\" => simple_llvm_intrinsic(bcx, \"llvm.cos.f32\", 1),\n+        \"cosf64\" => simple_llvm_intrinsic(bcx, \"llvm.cos.f64\", 1),\n+        \"powf32\" => simple_llvm_intrinsic(bcx, \"llvm.pow.f32\", 2),\n+        \"powf64\" => simple_llvm_intrinsic(bcx, \"llvm.pow.f64\", 2),\n+        \"expf32\" => simple_llvm_intrinsic(bcx, \"llvm.exp.f32\", 1),\n+        \"expf64\" => simple_llvm_intrinsic(bcx, \"llvm.exp.f64\", 1),\n+        \"exp2f32\" => simple_llvm_intrinsic(bcx, \"llvm.exp2.f32\", 1),\n+        \"exp2f64\" => simple_llvm_intrinsic(bcx, \"llvm.exp2.f64\", 1),\n+        \"logf32\" => simple_llvm_intrinsic(bcx, \"llvm.log.f32\", 1),\n+        \"logf64\" => simple_llvm_intrinsic(bcx, \"llvm.log.f64\", 1),\n+        \"log10f32\" => simple_llvm_intrinsic(bcx, \"llvm.log10.f32\", 1),\n+        \"log10f64\" => simple_llvm_intrinsic(bcx, \"llvm.log10.f64\", 1),\n+        \"log2f32\" => simple_llvm_intrinsic(bcx, \"llvm.log2.f32\", 1),\n+        \"log2f64\" => simple_llvm_intrinsic(bcx, \"llvm.log2.f64\", 1),\n+        \"fmaf32\" => simple_llvm_intrinsic(bcx, \"llvm.fma.f32\", 3),\n+        \"fmaf64\" => simple_llvm_intrinsic(bcx, \"llvm.fma.f64\", 3),\n+        \"fabsf32\" => simple_llvm_intrinsic(bcx, \"llvm.fabs.f32\", 1),\n+        \"fabsf64\" => simple_llvm_intrinsic(bcx, \"llvm.fabs.f64\", 1),\n+        \"floorf32\" => simple_llvm_intrinsic(bcx, \"llvm.floor.f32\", 1),\n+        \"floorf64\" => simple_llvm_intrinsic(bcx, \"llvm.floor.f64\", 1),\n+        \"ceilf32\" => simple_llvm_intrinsic(bcx, \"llvm.ceil.f32\", 1),\n+        \"ceilf64\" => simple_llvm_intrinsic(bcx, \"llvm.ceil.f64\", 1),\n+        \"truncf32\" => simple_llvm_intrinsic(bcx, \"llvm.trunc.f32\", 1),\n+        \"truncf64\" => simple_llvm_intrinsic(bcx, \"llvm.trunc.f64\", 1),\n+        \"ctpop8\" => simple_llvm_intrinsic(bcx, \"llvm.ctpop.i8\", 1),\n+        \"ctpop16\" => simple_llvm_intrinsic(bcx, \"llvm.ctpop.i16\", 1),\n+        \"ctpop32\" => simple_llvm_intrinsic(bcx, \"llvm.ctpop.i32\", 1),\n+        \"ctpop64\" => simple_llvm_intrinsic(bcx, \"llvm.ctpop.i64\", 1),\n+        \"ctlz8\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i8\"),\n+        \"ctlz16\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i16\"),\n+        \"ctlz32\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i32\"),\n+        \"ctlz64\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i64\"),\n+        \"cttz8\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i8\"),\n+        \"cttz16\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i16\"),\n+        \"cttz32\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i32\"),\n+        \"cttz64\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i64\"),\n+        \"bswap16\" => simple_llvm_intrinsic(bcx, \"llvm.bswap.i16\", 1),\n+        \"bswap32\" => simple_llvm_intrinsic(bcx, \"llvm.bswap.i32\", 1),\n+        \"bswap64\" => simple_llvm_intrinsic(bcx, \"llvm.bswap.i64\", 1),\n         _ => {\n             // Could we make this an enum rather than a string? does it get\n             // checked earlier?"}]}