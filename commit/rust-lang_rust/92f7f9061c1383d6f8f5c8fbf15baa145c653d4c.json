{"sha": "92f7f9061c1383d6f8f5c8fbf15baa145c653d4c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyZjdmOTA2MWMxMzgzZDZmOGY1YzhmYmYxNWJhYTE0NWM2NTNkNGM=", "commit": {"author": {"name": "Wayne Warren", "email": "wayne.warren.s@gmail.com", "date": "2018-11-21T00:49:15Z"}, "committer": {"name": "Wayne Warren", "email": "wayne.warren.s@gmail.com", "date": "2018-11-21T13:52:02Z"}, "message": "issue#3318 run trivially_copy_pass_by_ref for traits", "tree": {"sha": "56d0741b85bf5e683f1a10d83ff010193bf473f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56d0741b85bf5e683f1a10d83ff010193bf473f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92f7f9061c1383d6f8f5c8fbf15baa145c653d4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92f7f9061c1383d6f8f5c8fbf15baa145c653d4c", "html_url": "https://github.com/rust-lang/rust/commit/92f7f9061c1383d6f8f5c8fbf15baa145c653d4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92f7f9061c1383d6f8f5c8fbf15baa145c653d4c/comments", "author": {"login": "waynr", "id": 1441126, "node_id": "MDQ6VXNlcjE0NDExMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1441126?v=4", "gravatar_id": "", "url": "https://api.github.com/users/waynr", "html_url": "https://github.com/waynr", "followers_url": "https://api.github.com/users/waynr/followers", "following_url": "https://api.github.com/users/waynr/following{/other_user}", "gists_url": "https://api.github.com/users/waynr/gists{/gist_id}", "starred_url": "https://api.github.com/users/waynr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/waynr/subscriptions", "organizations_url": "https://api.github.com/users/waynr/orgs", "repos_url": "https://api.github.com/users/waynr/repos", "events_url": "https://api.github.com/users/waynr/events{/privacy}", "received_events_url": "https://api.github.com/users/waynr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "waynr", "id": 1441126, "node_id": "MDQ6VXNlcjE0NDExMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1441126?v=4", "gravatar_id": "", "url": "https://api.github.com/users/waynr", "html_url": "https://github.com/waynr", "followers_url": "https://api.github.com/users/waynr/followers", "following_url": "https://api.github.com/users/waynr/following{/other_user}", "gists_url": "https://api.github.com/users/waynr/gists{/gist_id}", "starred_url": "https://api.github.com/users/waynr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/waynr/subscriptions", "organizations_url": "https://api.github.com/users/waynr/orgs", "repos_url": "https://api.github.com/users/waynr/repos", "events_url": "https://api.github.com/users/waynr/events{/privacy}", "received_events_url": "https://api.github.com/users/waynr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67c32eb2c45b30af9e0d22a2220a50fac8439f59", "url": "https://api.github.com/repos/rust-lang/rust/commits/67c32eb2c45b30af9e0d22a2220a50fac8439f59", "html_url": "https://github.com/rust-lang/rust/commit/67c32eb2c45b30af9e0d22a2220a50fac8439f59"}], "stats": {"total": 134, "additions": 93, "deletions": 41}, "files": [{"sha": "3d667cb5ea3fdadc3916c7fd5f49705282c87311", "filename": "clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 93, "deletions": 41, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/92f7f9061c1383d6f8f5c8fbf15baa145c653d4c/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f7f9061c1383d6f8f5c8fbf15baa145c653d4c/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=92f7f9061c1383d6f8f5c8fbf15baa145c653d4c", "patch": "@@ -18,12 +18,13 @@ use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n use if_chain::if_chain;\n use crate::rustc::ty::TyKind;\n+use crate::rustc::ty::FnSig;\n use crate::rustc::session::config::Config as SessionConfig;\n use crate::rustc_target::spec::abi::Abi;\n use crate::rustc_target::abi::LayoutOf;\n use crate::syntax::ast::NodeId;\n use crate::syntax_pos::Span;\n-use crate::utils::{in_macro, is_copy, is_self, span_lint_and_sugg, snippet};\n+use crate::utils::{in_macro, is_copy, is_self_ty, span_lint_and_sugg, snippet};\n \n /// **What it does:** Checks for functions taking arguments by reference, where\n /// the argument type is `Copy` and small enough to be more efficient to always\n@@ -67,7 +68,7 @@ pub struct TriviallyCopyPassByRef {\n     limit: u64,\n }\n \n-impl TriviallyCopyPassByRef {\n+impl<'a, 'tcx> TriviallyCopyPassByRef {\n     pub fn new(limit: Option<u64>, target: &SessionConfig) -> Self {\n         let limit = limit.unwrap_or_else(|| {\n             let bit_width = target.usize_ty.bit_width().expect(\"usize should have a width\") as u64;\n@@ -80,6 +81,84 @@ impl TriviallyCopyPassByRef {\n         });\n         Self { limit }\n     }\n+\n+    fn check_trait_method(\n+        &mut self,\n+        cx: &LateContext<'_, 'tcx>,\n+        item: &TraitItemRef\n+    ) {\n+        let method_def_id = cx.tcx.hir.local_def_id(item.id.node_id);\n+        let method_sig = cx.tcx.fn_sig(method_def_id);\n+        let method_sig = cx.tcx.erase_late_bound_regions(&method_sig);\n+\n+        let decl = match cx.tcx.hir.fn_decl(item.id.node_id) {\n+            Some(b) => b,\n+            None => return,\n+        };\n+\n+        self.check_poly_fn(cx, &decl, &method_sig, None);\n+    }\n+\n+    fn check_poly_fn(\n+        &mut self,\n+        cx: &LateContext<'_, 'tcx>,\n+        decl: &FnDecl,\n+        sig: &FnSig<'tcx>,\n+        span: Option<Span>,\n+    ) {\n+        // Use lifetimes to determine if we're returning a reference to the\n+        // argument. In that case we can't switch to pass-by-value as the\n+        // argument will not live long enough.\n+        let output_lts = match sig.output().sty {\n+            TyKind::Ref(output_lt, _, _) => vec![output_lt],\n+            TyKind::Adt(_, substs) => substs.regions().collect(),\n+            _ => vec![],\n+        };\n+\n+        for (input, &ty) in decl.inputs.iter().zip(sig.inputs()) {\n+            // All spans generated from a proc-macro invocation are the same...\n+            match span {\n+                Some(s) if  s == input.span => return,\n+                _ => (),\n+            }\n+\n+            if_chain! {\n+                if let TyKind::Ref(input_lt, ty, Mutability::MutImmutable) = ty.sty;\n+                if !output_lts.contains(&input_lt);\n+                if is_copy(cx, ty);\n+                if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes());\n+                if size <= self.limit;\n+                if let hir::TyKind::Rptr(_, MutTy { ty: ref decl_ty, .. }) = input.node;\n+                then {\n+                    let value_type = if is_self_ty(decl_ty) {\n+                        \"self\".into()\n+                    } else {\n+                        snippet(cx, decl_ty.span, \"_\").into()\n+                    };\n+                    span_lint_and_sugg(\n+                        cx,\n+                        TRIVIALLY_COPY_PASS_BY_REF,\n+                        input.span,\n+                        \"this argument is passed by reference, but would be more efficient if passed by value\",\n+                        \"consider passing by value instead\",\n+                        value_type);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_trait_items(\n+        &mut self,\n+        cx: &LateContext<'_, '_>,\n+        trait_items: &[TraitItemRef]\n+    ) {\n+        for item in trait_items {\n+            match item.kind {\n+                AssociatedItemKind::Method{ has_self: _ } => self.check_trait_method(cx, item),\n+                _ => (),\n+            }\n+        }\n+    }\n }\n \n impl LintPass for TriviallyCopyPassByRef {\n@@ -89,12 +168,22 @@ impl LintPass for TriviallyCopyPassByRef {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TriviallyCopyPassByRef {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n+        if in_macro(item.span) {\n+            return;\n+        }\n+        match item.node {\n+            ItemKind::Trait(_, _, _, _, ref trait_items) => self.check_trait_items(cx, trait_items),\n+            _ => (),\n+        }\n+    }\n+\n     fn check_fn(\n         &mut self,\n         cx: &LateContext<'a, 'tcx>,\n         kind: FnKind<'tcx>,\n         decl: &'tcx FnDecl,\n-        body: &'tcx Body,\n+        _body: &'tcx Body,\n         span: Span,\n         node_id: NodeId,\n     ) {\n@@ -131,43 +220,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TriviallyCopyPassByRef {\n         let fn_sig = cx.tcx.fn_sig(fn_def_id);\n         let fn_sig = cx.tcx.erase_late_bound_regions(&fn_sig);\n \n-        // Use lifetimes to determine if we're returning a reference to the\n-        // argument. In that case we can't switch to pass-by-value as the\n-        // argument will not live long enough.\n-        let output_lts = match fn_sig.output().sty {\n-            TyKind::Ref(output_lt, _, _) => vec![output_lt],\n-            TyKind::Adt(_, substs) => substs.regions().collect(),\n-            _ => vec![],\n-        };\n-\n-        for ((input, &ty), arg) in decl.inputs.iter().zip(fn_sig.inputs()).zip(&body.arguments) {\n-            // All spans generated from a proc-macro invocation are the same...\n-            if span == input.span {\n-                return;\n-            }\n-\n-            if_chain! {\n-                if let TyKind::Ref(input_lt, ty, Mutability::MutImmutable) = ty.sty;\n-                if !output_lts.contains(&input_lt);\n-                if is_copy(cx, ty);\n-                if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes());\n-                if size <= self.limit;\n-                if let hir::TyKind::Rptr(_, MutTy { ty: ref decl_ty, .. }) = input.node;\n-                then {\n-                    let value_type = if is_self(arg) {\n-                        \"self\".into()\n-                    } else {\n-                        snippet(cx, decl_ty.span, \"_\").into()\n-                    };\n-                    span_lint_and_sugg(\n-                        cx,\n-                        TRIVIALLY_COPY_PASS_BY_REF,\n-                        input.span,\n-                        \"this argument is passed by reference, but would be more efficient if passed by value\",\n-                        \"consider passing by value instead\",\n-                        value_type);\n-                }\n-            }\n-        }\n+        self.check_poly_fn(cx, decl, &fn_sig, Some(span));\n     }\n }"}]}