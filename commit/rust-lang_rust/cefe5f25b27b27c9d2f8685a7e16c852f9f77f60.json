{"sha": "cefe5f25b27b27c9d2f8685a7e16c852f9f77f60", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlZmU1ZjI1YjI3YjI3YzlkMmY4Njg1YTdlMTZjODUyZjlmNzdmNjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-23T02:11:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-23T02:11:18Z"}, "message": "Auto merge of #28580 - wesleywiser:split_out_type_lints, r=alexcrichton\n\nMove out the `TypeLimits` and `ImproperCTypes` lints into a separate module. \r\n\r\nPart of #22206", "tree": {"sha": "00737a683959586d96bb92955800146f40cd39f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00737a683959586d96bb92955800146f40cd39f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cefe5f25b27b27c9d2f8685a7e16c852f9f77f60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cefe5f25b27b27c9d2f8685a7e16c852f9f77f60", "html_url": "https://github.com/rust-lang/rust/commit/cefe5f25b27b27c9d2f8685a7e16c852f9f77f60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cefe5f25b27b27c9d2f8685a7e16c852f9f77f60/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "html_url": "https://github.com/rust-lang/rust/commit/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30"}, {"sha": "b0bcde4b47c1cdf09b58988f87f9a6c3cd8d461e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0bcde4b47c1cdf09b58988f87f9a6c3cd8d461e", "html_url": "https://github.com/rust-lang/rust/commit/b0bcde4b47c1cdf09b58988f87f9a6c3cd8d461e"}], "stats": {"total": 1350, "additions": 689, "deletions": 661}, "files": [{"sha": "111913adb8aa8f2655845d9ff3d31d194acf4734", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 661, "changes": 663, "blob_url": "https://github.com/rust-lang/rust/blob/cefe5f25b27b27c9d2f8685a7e16c852f9f77f60/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cefe5f25b27b27c9d2f8685a7e16c852f9f77f60/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=cefe5f25b27b27c9d2f8685a7e16c852f9f77f60", "patch": "@@ -34,26 +34,19 @@ use middle::def_id::DefId;\n use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use middle::ty::adjustment;\n-use middle::const_eval::{eval_const_expr_partial, ConstVal};\n-use middle::const_eval::EvalHint::ExprTypeChecked;\n use rustc::front::map as hir_map;\n-use util::nodemap::{FnvHashSet, NodeSet};\n+use util::nodemap::{NodeSet};\n use lint::{Level, LateContext, LintContext, LintArray, Lint};\n use lint::{LintPass, LateLintPass};\n \n use std::collections::HashSet;\n-use std::cmp;\n-use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n \n-use syntax::{abi, ast};\n+use syntax::{ast};\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::{self, Span};\n-use syntax::feature_gate::{emit_feature_err, GateIssue};\n-use syntax::ast::{TyIs, TyUs, TyI8, TyU8, TyI16, TyU16, TyI32, TyU32, TyI64, TyU64};\n \n use rustc_front::hir;\n use rustc_front::visit::{self, FnKind, Visitor};\n-use rustc_front::util::is_shift_binop;\n \n use bad_style::{MethodLateContext, method_context};\n \n@@ -88,658 +81,6 @@ impl LateLintPass for WhileTrue {\n     }\n }\n \n-declare_lint! {\n-    UNUSED_COMPARISONS,\n-    Warn,\n-    \"comparisons made useless by limits of the types involved\"\n-}\n-\n-declare_lint! {\n-    OVERFLOWING_LITERALS,\n-    Warn,\n-    \"literal out of range for its type\"\n-}\n-\n-declare_lint! {\n-    EXCEEDING_BITSHIFTS,\n-    Deny,\n-    \"shift exceeds the type's number of bits\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct TypeLimits {\n-    /// Id of the last visited negated expression\n-    negated_expr_id: ast::NodeId,\n-}\n-\n-impl TypeLimits {\n-    pub fn new() -> TypeLimits {\n-        TypeLimits {\n-            negated_expr_id: !0,\n-        }\n-    }\n-}\n-\n-impl LintPass for TypeLimits {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_COMPARISONS, OVERFLOWING_LITERALS, EXCEEDING_BITSHIFTS)\n-    }\n-}\n-\n-impl LateLintPass for TypeLimits {\n-    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n-        match e.node {\n-            hir::ExprUnary(hir::UnNeg, ref expr) => {\n-                match expr.node  {\n-                    hir::ExprLit(ref lit) => {\n-                        match lit.node {\n-                            ast::LitInt(_, ast::UnsignedIntLit(_)) => {\n-                                check_unsigned_negation_feature(cx, e.span);\n-                            },\n-                            ast::LitInt(_, ast::UnsuffixedIntLit(_)) => {\n-                                if let ty::TyUint(_) = cx.tcx.node_id_to_type(e.id).sty {\n-                                    check_unsigned_negation_feature(cx, e.span);\n-                                }\n-                            },\n-                            _ => ()\n-                        }\n-                    },\n-                    _ => {\n-                        let t = cx.tcx.node_id_to_type(expr.id);\n-                        match t.sty {\n-                            ty::TyUint(_) => {\n-                                check_unsigned_negation_feature(cx, e.span);\n-                            },\n-                            _ => ()\n-                        }\n-                    }\n-                };\n-                // propagate negation, if the negation itself isn't negated\n-                if self.negated_expr_id != e.id {\n-                    self.negated_expr_id = expr.id;\n-                }\n-            },\n-            hir::ExprBinary(binop, ref l, ref r) => {\n-                if is_comparison(binop) && !check_limits(cx.tcx, binop, &**l, &**r) {\n-                    cx.span_lint(UNUSED_COMPARISONS, e.span,\n-                                 \"comparison is useless due to type limits\");\n-                }\n-\n-                if is_shift_binop(binop.node) {\n-                    let opt_ty_bits = match cx.tcx.node_id_to_type(l.id).sty {\n-                        ty::TyInt(t) => Some(int_ty_bits(t, cx.sess().target.int_type)),\n-                        ty::TyUint(t) => Some(uint_ty_bits(t, cx.sess().target.uint_type)),\n-                        _ => None\n-                    };\n-\n-                    if let Some(bits) = opt_ty_bits {\n-                        let exceeding = if let hir::ExprLit(ref lit) = r.node {\n-                            if let ast::LitInt(shift, _) = lit.node { shift >= bits }\n-                            else { false }\n-                        } else {\n-                            match eval_const_expr_partial(cx.tcx, &r, ExprTypeChecked) {\n-                                Ok(ConstVal::Int(shift)) => { shift as u64 >= bits },\n-                                Ok(ConstVal::Uint(shift)) => { shift >= bits },\n-                                _ => { false }\n-                            }\n-                        };\n-                        if exceeding {\n-                            cx.span_lint(EXCEEDING_BITSHIFTS, e.span,\n-                                         \"bitshift exceeds the type's number of bits\");\n-                        }\n-                    };\n-                }\n-            },\n-            hir::ExprLit(ref lit) => {\n-                match cx.tcx.node_id_to_type(e.id).sty {\n-                    ty::TyInt(t) => {\n-                        match lit.node {\n-                            ast::LitInt(v, ast::SignedIntLit(_, ast::Plus)) |\n-                            ast::LitInt(v, ast::UnsuffixedIntLit(ast::Plus)) => {\n-                                let int_type = if let ast::TyIs = t {\n-                                    cx.sess().target.int_type\n-                                } else {\n-                                    t\n-                                };\n-                                let (_, max) = int_ty_range(int_type);\n-                                let negative = self.negated_expr_id == e.id;\n-\n-                                // Detect literal value out of range [min, max] inclusive\n-                                // avoiding use of -min to prevent overflow/panic\n-                                if (negative && v > max as u64 + 1) ||\n-                                   (!negative && v > max as u64) {\n-                                    cx.span_lint(OVERFLOWING_LITERALS, e.span,\n-                                                 &*format!(\"literal out of range for {:?}\", t));\n-                                    return;\n-                                }\n-                            }\n-                            _ => panic!()\n-                        };\n-                    },\n-                    ty::TyUint(t) => {\n-                        let uint_type = if let ast::TyUs = t {\n-                            cx.sess().target.uint_type\n-                        } else {\n-                            t\n-                        };\n-                        let (min, max) = uint_ty_range(uint_type);\n-                        let lit_val: u64 = match lit.node {\n-                            ast::LitByte(_v) => return,  // _v is u8, within range by definition\n-                            ast::LitInt(v, _) => v,\n-                            _ => panic!()\n-                        };\n-                        if lit_val < min || lit_val > max {\n-                            cx.span_lint(OVERFLOWING_LITERALS, e.span,\n-                                         &*format!(\"literal out of range for {:?}\", t));\n-                        }\n-                    },\n-                    ty::TyFloat(t) => {\n-                        let (min, max) = float_ty_range(t);\n-                        let lit_val: f64 = match lit.node {\n-                            ast::LitFloat(ref v, _) |\n-                            ast::LitFloatUnsuffixed(ref v) => {\n-                                match v.parse() {\n-                                    Ok(f) => f,\n-                                    Err(_) => return\n-                                }\n-                            }\n-                            _ => panic!()\n-                        };\n-                        if lit_val < min || lit_val > max {\n-                            cx.span_lint(OVERFLOWING_LITERALS, e.span,\n-                                         &*format!(\"literal out of range for {:?}\", t));\n-                        }\n-                    },\n-                    _ => ()\n-                };\n-            },\n-            _ => ()\n-        };\n-\n-        fn is_valid<T:cmp::PartialOrd>(binop: hir::BinOp, v: T,\n-                                min: T, max: T) -> bool {\n-            match binop.node {\n-                hir::BiLt => v >  min && v <= max,\n-                hir::BiLe => v >= min && v <  max,\n-                hir::BiGt => v >= min && v <  max,\n-                hir::BiGe => v >  min && v <= max,\n-                hir::BiEq | hir::BiNe => v >= min && v <= max,\n-                _ => panic!()\n-            }\n-        }\n-\n-        fn rev_binop(binop: hir::BinOp) -> hir::BinOp {\n-            codemap::respan(binop.span, match binop.node {\n-                hir::BiLt => hir::BiGt,\n-                hir::BiLe => hir::BiGe,\n-                hir::BiGt => hir::BiLt,\n-                hir::BiGe => hir::BiLe,\n-                _ => return binop\n-            })\n-        }\n-\n-        // for isize & usize, be conservative with the warnings, so that the\n-        // warnings are consistent between 32- and 64-bit platforms\n-        fn int_ty_range(int_ty: ast::IntTy) -> (i64, i64) {\n-            match int_ty {\n-                ast::TyIs => (i64::MIN,        i64::MAX),\n-                ast::TyI8 =>    (i8::MIN  as i64, i8::MAX  as i64),\n-                ast::TyI16 =>   (i16::MIN as i64, i16::MAX as i64),\n-                ast::TyI32 =>   (i32::MIN as i64, i32::MAX as i64),\n-                ast::TyI64 =>   (i64::MIN,        i64::MAX)\n-            }\n-        }\n-\n-        fn uint_ty_range(uint_ty: ast::UintTy) -> (u64, u64) {\n-            match uint_ty {\n-                ast::TyUs => (u64::MIN,         u64::MAX),\n-                ast::TyU8 =>    (u8::MIN   as u64, u8::MAX   as u64),\n-                ast::TyU16 =>   (u16::MIN  as u64, u16::MAX  as u64),\n-                ast::TyU32 =>   (u32::MIN  as u64, u32::MAX  as u64),\n-                ast::TyU64 =>   (u64::MIN,         u64::MAX)\n-            }\n-        }\n-\n-        fn float_ty_range(float_ty: ast::FloatTy) -> (f64, f64) {\n-            match float_ty {\n-                ast::TyF32 => (f32::MIN as f64, f32::MAX as f64),\n-                ast::TyF64 => (f64::MIN,        f64::MAX)\n-            }\n-        }\n-\n-        fn int_ty_bits(int_ty: ast::IntTy, target_int_ty: ast::IntTy) -> u64 {\n-            match int_ty {\n-                ast::TyIs => int_ty_bits(target_int_ty, target_int_ty),\n-                ast::TyI8 =>    i8::BITS  as u64,\n-                ast::TyI16 =>   i16::BITS as u64,\n-                ast::TyI32 =>   i32::BITS as u64,\n-                ast::TyI64 =>   i64::BITS as u64\n-            }\n-        }\n-\n-        fn uint_ty_bits(uint_ty: ast::UintTy, target_uint_ty: ast::UintTy) -> u64 {\n-            match uint_ty {\n-                ast::TyUs => uint_ty_bits(target_uint_ty, target_uint_ty),\n-                ast::TyU8 =>    u8::BITS  as u64,\n-                ast::TyU16 =>   u16::BITS as u64,\n-                ast::TyU32 =>   u32::BITS as u64,\n-                ast::TyU64 =>   u64::BITS as u64\n-            }\n-        }\n-\n-        fn check_limits(tcx: &ty::ctxt, binop: hir::BinOp,\n-                        l: &hir::Expr, r: &hir::Expr) -> bool {\n-            let (lit, expr, swap) = match (&l.node, &r.node) {\n-                (&hir::ExprLit(_), _) => (l, r, true),\n-                (_, &hir::ExprLit(_)) => (r, l, false),\n-                _ => return true\n-            };\n-            // Normalize the binop so that the literal is always on the RHS in\n-            // the comparison\n-            let norm_binop = if swap {\n-                rev_binop(binop)\n-            } else {\n-                binop\n-            };\n-            match tcx.node_id_to_type(expr.id).sty {\n-                ty::TyInt(int_ty) => {\n-                    let (min, max) = int_ty_range(int_ty);\n-                    let lit_val: i64 = match lit.node {\n-                        hir::ExprLit(ref li) => match li.node {\n-                            ast::LitInt(v, ast::SignedIntLit(_, ast::Plus)) |\n-                            ast::LitInt(v, ast::UnsuffixedIntLit(ast::Plus)) => v as i64,\n-                            ast::LitInt(v, ast::SignedIntLit(_, ast::Minus)) |\n-                            ast::LitInt(v, ast::UnsuffixedIntLit(ast::Minus)) => -(v as i64),\n-                            _ => return true\n-                        },\n-                        _ => panic!()\n-                    };\n-                    is_valid(norm_binop, lit_val, min, max)\n-                }\n-                ty::TyUint(uint_ty) => {\n-                    let (min, max): (u64, u64) = uint_ty_range(uint_ty);\n-                    let lit_val: u64 = match lit.node {\n-                        hir::ExprLit(ref li) => match li.node {\n-                            ast::LitInt(v, _) => v,\n-                            _ => return true\n-                        },\n-                        _ => panic!()\n-                    };\n-                    is_valid(norm_binop, lit_val, min, max)\n-                }\n-                _ => true\n-            }\n-        }\n-\n-        fn is_comparison(binop: hir::BinOp) -> bool {\n-            match binop.node {\n-                hir::BiEq | hir::BiLt | hir::BiLe |\n-                hir::BiNe | hir::BiGe | hir::BiGt => true,\n-                _ => false\n-            }\n-        }\n-\n-        fn check_unsigned_negation_feature(cx: &LateContext, span: Span) {\n-            if !cx.sess().features.borrow().negate_unsigned {\n-                emit_feature_err(\n-                    &cx.sess().parse_sess.span_diagnostic,\n-                    \"negate_unsigned\",\n-                    span,\n-                    GateIssue::Language,\n-                    \"unary negation of unsigned integers may be removed in the future\");\n-            }\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    IMPROPER_CTYPES,\n-    Warn,\n-    \"proper use of libc types in foreign modules\"\n-}\n-\n-struct ImproperCTypesVisitor<'a, 'tcx: 'a> {\n-    cx: &'a LateContext<'a, 'tcx>\n-}\n-\n-enum FfiResult {\n-    FfiSafe,\n-    FfiUnsafe(&'static str),\n-    FfiBadStruct(DefId, &'static str),\n-    FfiBadEnum(DefId, &'static str)\n-}\n-\n-/// Check if this enum can be safely exported based on the\n-/// \"nullable pointer optimization\". Currently restricted\n-/// to function pointers and references, but could be\n-/// expanded to cover NonZero raw pointers and newtypes.\n-/// FIXME: This duplicates code in trans.\n-fn is_repr_nullable_ptr<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                              def: ty::AdtDef<'tcx>,\n-                              substs: &Substs<'tcx>)\n-                              -> bool {\n-    if def.variants.len() == 2 {\n-        let data_idx;\n-\n-        if def.variants[0].fields.is_empty() {\n-            data_idx = 1;\n-        } else if def.variants[1].fields.is_empty() {\n-            data_idx = 0;\n-        } else {\n-            return false;\n-        }\n-\n-        if def.variants[data_idx].fields.len() == 1 {\n-            match def.variants[data_idx].fields[0].ty(tcx, substs).sty {\n-                ty::TyBareFn(None, _) => { return true; }\n-                ty::TyRef(..) => { return true; }\n-                _ => { }\n-            }\n-        }\n-    }\n-    false\n-}\n-\n-fn ast_ty_to_normalized<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                              id: ast::NodeId)\n-                              -> Ty<'tcx> {\n-    let tty = match tcx.ast_ty_to_ty_cache.borrow().get(&id) {\n-        Some(&t) => t,\n-        None => panic!(\"ast_ty_to_ty_cache was incomplete after typeck!\")\n-    };\n-    infer::normalize_associated_type(tcx, &tty)\n-}\n-\n-impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n-    /// Check if the given type is \"ffi-safe\" (has a stable, well-defined\n-    /// representation which can be exported to C code).\n-    fn check_type_for_ffi(&self,\n-                          cache: &mut FnvHashSet<Ty<'tcx>>,\n-                          ty: Ty<'tcx>)\n-                          -> FfiResult {\n-        use self::FfiResult::*;\n-        let cx = &self.cx.tcx;\n-\n-        // Protect against infinite recursion, for example\n-        // `struct S(*mut S);`.\n-        // FIXME: A recursion limit is necessary as well, for irregular\n-        // recusive types.\n-        if !cache.insert(ty) {\n-            return FfiSafe;\n-        }\n-\n-        match ty.sty {\n-            ty::TyStruct(def, substs) => {\n-                if !cx.lookup_repr_hints(def.did).contains(&attr::ReprExtern) {\n-                    return FfiUnsafe(\n-                        \"found struct without foreign-function-safe \\\n-                         representation annotation in foreign module, \\\n-                         consider adding a #[repr(C)] attribute to \\\n-                         the type\");\n-                }\n-\n-                // We can't completely trust repr(C) markings; make sure the\n-                // fields are actually safe.\n-                if def.struct_variant().fields.is_empty() {\n-                    return FfiUnsafe(\n-                        \"found zero-size struct in foreign module, consider \\\n-                         adding a member to this struct\");\n-                }\n-\n-                for field in &def.struct_variant().fields {\n-                    let field_ty = infer::normalize_associated_type(cx, &field.ty(cx, substs));\n-                    let r = self.check_type_for_ffi(cache, field_ty);\n-                    match r {\n-                        FfiSafe => {}\n-                        FfiBadStruct(..) | FfiBadEnum(..) => { return r; }\n-                        FfiUnsafe(s) => { return FfiBadStruct(def.did, s); }\n-                    }\n-                }\n-                FfiSafe\n-            }\n-            ty::TyEnum(def, substs) => {\n-                if def.variants.is_empty() {\n-                    // Empty enums are okay... although sort of useless.\n-                    return FfiSafe\n-                }\n-\n-                // Check for a repr() attribute to specify the size of the\n-                // discriminant.\n-                let repr_hints = cx.lookup_repr_hints(def.did);\n-                match &**repr_hints {\n-                    [] => {\n-                        // Special-case types like `Option<extern fn()>`.\n-                        if !is_repr_nullable_ptr(cx, def, substs) {\n-                            return FfiUnsafe(\n-                                \"found enum without foreign-function-safe \\\n-                                 representation annotation in foreign module, \\\n-                                 consider adding a #[repr(...)] attribute to \\\n-                                 the type\")\n-                        }\n-                    }\n-                    [ref hint] => {\n-                        if !hint.is_ffi_safe() {\n-                            // FIXME: This shouldn't be reachable: we should check\n-                            // this earlier.\n-                            return FfiUnsafe(\n-                                \"enum has unexpected #[repr(...)] attribute\")\n-                        }\n-\n-                        // Enum with an explicitly sized discriminant; either\n-                        // a C-style enum or a discriminated union.\n-\n-                        // The layout of enum variants is implicitly repr(C).\n-                        // FIXME: Is that correct?\n-                    }\n-                    _ => {\n-                        // FIXME: This shouldn't be reachable: we should check\n-                        // this earlier.\n-                        return FfiUnsafe(\n-                            \"enum has too many #[repr(...)] attributes\");\n-                    }\n-                }\n-\n-                // Check the contained variants.\n-                for variant in &def.variants {\n-                    for field in &variant.fields {\n-                        let arg = infer::normalize_associated_type(cx, &field.ty(cx, substs));\n-                        let r = self.check_type_for_ffi(cache, arg);\n-                        match r {\n-                            FfiSafe => {}\n-                            FfiBadStruct(..) | FfiBadEnum(..) => { return r; }\n-                            FfiUnsafe(s) => { return FfiBadEnum(def.did, s); }\n-                        }\n-                    }\n-                }\n-                FfiSafe\n-            }\n-\n-            ty::TyInt(ast::TyIs) => {\n-                FfiUnsafe(\"found Rust type `isize` in foreign module, while \\\n-                          `libc::c_int` or `libc::c_long` should be used\")\n-            }\n-            ty::TyUint(ast::TyUs) => {\n-                FfiUnsafe(\"found Rust type `usize` in foreign module, while \\\n-                          `libc::c_uint` or `libc::c_ulong` should be used\")\n-            }\n-            ty::TyChar => {\n-                FfiUnsafe(\"found Rust type `char` in foreign module, while \\\n-                           `u32` or `libc::wchar_t` should be used\")\n-            }\n-\n-            // Primitive types with a stable representation.\n-            ty::TyBool | ty::TyInt(..) | ty::TyUint(..) |\n-            ty::TyFloat(..) => FfiSafe,\n-\n-            ty::TyBox(..) => {\n-                FfiUnsafe(\"found Rust type Box<_> in foreign module, \\\n-                           consider using a raw pointer instead\")\n-            }\n-\n-            ty::TySlice(_) => {\n-                FfiUnsafe(\"found Rust slice type in foreign module, \\\n-                           consider using a raw pointer instead\")\n-            }\n-\n-            ty::TyTrait(..) => {\n-                FfiUnsafe(\"found Rust trait type in foreign module, \\\n-                           consider using a raw pointer instead\")\n-            }\n-\n-            ty::TyStr => {\n-                FfiUnsafe(\"found Rust type `str` in foreign module; \\\n-                           consider using a `*const libc::c_char`\")\n-            }\n-\n-            ty::TyTuple(_) => {\n-                FfiUnsafe(\"found Rust tuple type in foreign module; \\\n-                           consider using a struct instead`\")\n-            }\n-\n-            ty::TyRawPtr(ref m) | ty::TyRef(_, ref m) => {\n-                self.check_type_for_ffi(cache, m.ty)\n-            }\n-\n-            ty::TyArray(ty, _) => {\n-                self.check_type_for_ffi(cache, ty)\n-            }\n-\n-            ty::TyBareFn(None, bare_fn) => {\n-                match bare_fn.abi {\n-                    abi::Rust |\n-                    abi::RustIntrinsic |\n-                    abi::PlatformIntrinsic |\n-                    abi::RustCall => {\n-                        return FfiUnsafe(\n-                            \"found function pointer with Rust calling \\\n-                             convention in foreign module; consider using an \\\n-                             `extern` function pointer\")\n-                    }\n-                    _ => {}\n-                }\n-\n-                let sig = cx.erase_late_bound_regions(&bare_fn.sig);\n-                match sig.output {\n-                    ty::FnDiverging => {}\n-                    ty::FnConverging(output) => {\n-                        if !output.is_nil() {\n-                            let r = self.check_type_for_ffi(cache, output);\n-                            match r {\n-                                FfiSafe => {}\n-                                _ => { return r; }\n-                            }\n-                        }\n-                    }\n-                }\n-                for arg in sig.inputs {\n-                    let r = self.check_type_for_ffi(cache, arg);\n-                    match r {\n-                        FfiSafe => {}\n-                        _ => { return r; }\n-                    }\n-                }\n-                FfiSafe\n-            }\n-\n-            ty::TyParam(..) | ty::TyInfer(..) | ty::TyError |\n-            ty::TyClosure(..) | ty::TyProjection(..) |\n-            ty::TyBareFn(Some(_), _) => {\n-                panic!(\"Unexpected type in foreign function\")\n-            }\n-        }\n-    }\n-\n-    fn check_def(&mut self, sp: Span, id: ast::NodeId) {\n-        let tty = ast_ty_to_normalized(self.cx.tcx, id);\n-\n-        match ImproperCTypesVisitor::check_type_for_ffi(self, &mut FnvHashSet(), tty) {\n-            FfiResult::FfiSafe => {}\n-            FfiResult::FfiUnsafe(s) => {\n-                self.cx.span_lint(IMPROPER_CTYPES, sp, s);\n-            }\n-            FfiResult::FfiBadStruct(_, s) => {\n-                // FIXME: This diagnostic is difficult to read, and doesn't\n-                // point at the relevant field.\n-                self.cx.span_lint(IMPROPER_CTYPES, sp,\n-                    &format!(\"found non-foreign-function-safe member in \\\n-                              struct marked #[repr(C)]: {}\", s));\n-            }\n-            FfiResult::FfiBadEnum(_, s) => {\n-                // FIXME: This diagnostic is difficult to read, and doesn't\n-                // point at the relevant variant.\n-                self.cx.span_lint(IMPROPER_CTYPES, sp,\n-                    &format!(\"found non-foreign-function-safe member in \\\n-                              enum: {}\", s));\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for ImproperCTypesVisitor<'a, 'tcx> {\n-    fn visit_ty(&mut self, ty: &hir::Ty) {\n-        match ty.node {\n-            hir::TyPath(..) |\n-            hir::TyBareFn(..) => self.check_def(ty.span, ty.id),\n-            hir::TyVec(..) => {\n-                self.cx.span_lint(IMPROPER_CTYPES, ty.span,\n-                    \"found Rust slice type in foreign module, consider \\\n-                     using a raw pointer instead\");\n-            }\n-            hir::TyFixedLengthVec(ref ty, _) => self.visit_ty(ty),\n-            hir::TyTup(..) => {\n-                self.cx.span_lint(IMPROPER_CTYPES, ty.span,\n-                    \"found Rust tuple type in foreign module; \\\n-                     consider using a struct instead`\")\n-            }\n-            _ => visit::walk_ty(self, ty)\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct ImproperCTypes;\n-\n-impl LintPass for ImproperCTypes {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(IMPROPER_CTYPES)\n-    }\n-}\n-\n-impl LateLintPass for ImproperCTypes {\n-    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n-        fn check_ty(cx: &LateContext, ty: &hir::Ty) {\n-            let mut vis = ImproperCTypesVisitor { cx: cx };\n-            vis.visit_ty(ty);\n-        }\n-\n-        fn check_foreign_fn(cx: &LateContext, decl: &hir::FnDecl) {\n-            for input in &decl.inputs {\n-                check_ty(cx, &*input.ty);\n-            }\n-            if let hir::Return(ref ret_ty) = decl.output {\n-                let tty = ast_ty_to_normalized(cx.tcx, ret_ty.id);\n-                if !tty.is_nil() {\n-                    check_ty(cx, &ret_ty);\n-                }\n-            }\n-        }\n-\n-        match it.node {\n-            hir::ItemForeignMod(ref nmod)\n-                if nmod.abi != abi::RustIntrinsic &&\n-                   nmod.abi != abi::PlatformIntrinsic => {\n-                for ni in &nmod.items {\n-                    match ni.node {\n-                        hir::ForeignItemFn(ref decl, _) => check_foreign_fn(cx, &**decl),\n-                        hir::ForeignItemStatic(ref t, _) => check_ty(cx, &**t)\n-                    }\n-                }\n-            }\n-            _ => (),\n-        }\n-    }\n-}\n-\n declare_lint! {\n     BOX_POINTERS,\n     Allow,"}, {"sha": "cba058e92a22ce735dafb62e0c168ceb66bacffa", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cefe5f25b27b27c9d2f8685a7e16c852f9f77f60/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cefe5f25b27b27c9d2f8685a7e16c852f9f77f60/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=cefe5f25b27b27c9d2f8685a7e16c852f9f77f60", "patch": "@@ -60,10 +60,12 @@ use lint::LintId;\n \n mod bad_style;\n mod builtin;\n+mod types;\n mod unused;\n \n use bad_style::*;\n use builtin::*;\n+use types::*;\n use unused::*;\n \n /// Tell the `LintStore` about all the built-in lints (the ones"}, {"sha": "cf6cc9bb7ce12a9419096806acf67071b88b8570", "filename": "src/librustc_lint/types.rs", "status": "added", "additions": 685, "deletions": 0, "changes": 685, "blob_url": "https://github.com/rust-lang/rust/blob/cefe5f25b27b27c9d2f8685a7e16c852f9f77f60/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cefe5f25b27b27c9d2f8685a7e16c852f9f77f60/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=cefe5f25b27b27c9d2f8685a7e16c852f9f77f60", "patch": "@@ -0,0 +1,685 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::{infer};\n+use middle::def_id::DefId;\n+use middle::subst::Substs;\n+use middle::ty::{self, Ty};\n+use middle::const_eval::{eval_const_expr_partial, ConstVal};\n+use middle::const_eval::EvalHint::ExprTypeChecked;\n+use util::nodemap::{FnvHashSet};\n+use lint::{LateContext, LintContext, LintArray};\n+use lint::{LintPass, LateLintPass};\n+\n+use std::cmp;\n+use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n+\n+use syntax::{abi, ast};\n+use syntax::attr::{self, AttrMetaMethods};\n+use syntax::codemap::{self, Span};\n+use syntax::feature_gate::{emit_feature_err, GateIssue};\n+use syntax::ast::{TyIs, TyUs, TyI8, TyU8, TyI16, TyU16, TyI32, TyU32, TyI64, TyU64};\n+\n+use rustc_front::hir;\n+use rustc_front::visit::{self, Visitor};\n+use rustc_front::util::is_shift_binop;\n+\n+declare_lint! {\n+    UNUSED_COMPARISONS,\n+    Warn,\n+    \"comparisons made useless by limits of the types involved\"\n+}\n+\n+declare_lint! {\n+    OVERFLOWING_LITERALS,\n+    Warn,\n+    \"literal out of range for its type\"\n+}\n+\n+declare_lint! {\n+    EXCEEDING_BITSHIFTS,\n+    Deny,\n+    \"shift exceeds the type's number of bits\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct TypeLimits {\n+    /// Id of the last visited negated expression\n+    negated_expr_id: ast::NodeId,\n+}\n+\n+impl TypeLimits {\n+    pub fn new() -> TypeLimits {\n+        TypeLimits {\n+            negated_expr_id: !0,\n+        }\n+    }\n+}\n+\n+impl LintPass for TypeLimits {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNUSED_COMPARISONS, OVERFLOWING_LITERALS, EXCEEDING_BITSHIFTS)\n+    }\n+}\n+\n+impl LateLintPass for TypeLimits {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n+        match e.node {\n+            hir::ExprUnary(hir::UnNeg, ref expr) => {\n+                match expr.node  {\n+                    hir::ExprLit(ref lit) => {\n+                        match lit.node {\n+                            ast::LitInt(_, ast::UnsignedIntLit(_)) => {\n+                                check_unsigned_negation_feature(cx, e.span);\n+                            },\n+                            ast::LitInt(_, ast::UnsuffixedIntLit(_)) => {\n+                                if let ty::TyUint(_) = cx.tcx.node_id_to_type(e.id).sty {\n+                                    check_unsigned_negation_feature(cx, e.span);\n+                                }\n+                            },\n+                            _ => ()\n+                        }\n+                    },\n+                    _ => {\n+                        let t = cx.tcx.node_id_to_type(expr.id);\n+                        match t.sty {\n+                            ty::TyUint(_) => {\n+                                check_unsigned_negation_feature(cx, e.span);\n+                            },\n+                            _ => ()\n+                        }\n+                    }\n+                };\n+                // propagate negation, if the negation itself isn't negated\n+                if self.negated_expr_id != e.id {\n+                    self.negated_expr_id = expr.id;\n+                }\n+            },\n+            hir::ExprBinary(binop, ref l, ref r) => {\n+                if is_comparison(binop) && !check_limits(cx.tcx, binop, &**l, &**r) {\n+                    cx.span_lint(UNUSED_COMPARISONS, e.span,\n+                                 \"comparison is useless due to type limits\");\n+                }\n+\n+                if is_shift_binop(binop.node) {\n+                    let opt_ty_bits = match cx.tcx.node_id_to_type(l.id).sty {\n+                        ty::TyInt(t) => Some(int_ty_bits(t, cx.sess().target.int_type)),\n+                        ty::TyUint(t) => Some(uint_ty_bits(t, cx.sess().target.uint_type)),\n+                        _ => None\n+                    };\n+\n+                    if let Some(bits) = opt_ty_bits {\n+                        let exceeding = if let hir::ExprLit(ref lit) = r.node {\n+                            if let ast::LitInt(shift, _) = lit.node { shift >= bits }\n+                            else { false }\n+                        } else {\n+                            match eval_const_expr_partial(cx.tcx, &r, ExprTypeChecked) {\n+                                Ok(ConstVal::Int(shift)) => { shift as u64 >= bits },\n+                                Ok(ConstVal::Uint(shift)) => { shift >= bits },\n+                                _ => { false }\n+                            }\n+                        };\n+                        if exceeding {\n+                            cx.span_lint(EXCEEDING_BITSHIFTS, e.span,\n+                                         \"bitshift exceeds the type's number of bits\");\n+                        }\n+                    };\n+                }\n+            },\n+            hir::ExprLit(ref lit) => {\n+                match cx.tcx.node_id_to_type(e.id).sty {\n+                    ty::TyInt(t) => {\n+                        match lit.node {\n+                            ast::LitInt(v, ast::SignedIntLit(_, ast::Plus)) |\n+                            ast::LitInt(v, ast::UnsuffixedIntLit(ast::Plus)) => {\n+                                let int_type = if let ast::TyIs = t {\n+                                    cx.sess().target.int_type\n+                                } else {\n+                                    t\n+                                };\n+                                let (_, max) = int_ty_range(int_type);\n+                                let negative = self.negated_expr_id == e.id;\n+\n+                                // Detect literal value out of range [min, max] inclusive\n+                                // avoiding use of -min to prevent overflow/panic\n+                                if (negative && v > max as u64 + 1) ||\n+                                   (!negative && v > max as u64) {\n+                                    cx.span_lint(OVERFLOWING_LITERALS, e.span,\n+                                                 &*format!(\"literal out of range for {:?}\", t));\n+                                    return;\n+                                }\n+                            }\n+                            _ => panic!()\n+                        };\n+                    },\n+                    ty::TyUint(t) => {\n+                        let uint_type = if let ast::TyUs = t {\n+                            cx.sess().target.uint_type\n+                        } else {\n+                            t\n+                        };\n+                        let (min, max) = uint_ty_range(uint_type);\n+                        let lit_val: u64 = match lit.node {\n+                            ast::LitByte(_v) => return,  // _v is u8, within range by definition\n+                            ast::LitInt(v, _) => v,\n+                            _ => panic!()\n+                        };\n+                        if lit_val < min || lit_val > max {\n+                            cx.span_lint(OVERFLOWING_LITERALS, e.span,\n+                                         &*format!(\"literal out of range for {:?}\", t));\n+                        }\n+                    },\n+                    ty::TyFloat(t) => {\n+                        let (min, max) = float_ty_range(t);\n+                        let lit_val: f64 = match lit.node {\n+                            ast::LitFloat(ref v, _) |\n+                            ast::LitFloatUnsuffixed(ref v) => {\n+                                match v.parse() {\n+                                    Ok(f) => f,\n+                                    Err(_) => return\n+                                }\n+                            }\n+                            _ => panic!()\n+                        };\n+                        if lit_val < min || lit_val > max {\n+                            cx.span_lint(OVERFLOWING_LITERALS, e.span,\n+                                         &*format!(\"literal out of range for {:?}\", t));\n+                        }\n+                    },\n+                    _ => ()\n+                };\n+            },\n+            _ => ()\n+        };\n+\n+        fn is_valid<T:cmp::PartialOrd>(binop: hir::BinOp, v: T,\n+                                min: T, max: T) -> bool {\n+            match binop.node {\n+                hir::BiLt => v >  min && v <= max,\n+                hir::BiLe => v >= min && v <  max,\n+                hir::BiGt => v >= min && v <  max,\n+                hir::BiGe => v >  min && v <= max,\n+                hir::BiEq | hir::BiNe => v >= min && v <= max,\n+                _ => panic!()\n+            }\n+        }\n+\n+        fn rev_binop(binop: hir::BinOp) -> hir::BinOp {\n+            codemap::respan(binop.span, match binop.node {\n+                hir::BiLt => hir::BiGt,\n+                hir::BiLe => hir::BiGe,\n+                hir::BiGt => hir::BiLt,\n+                hir::BiGe => hir::BiLe,\n+                _ => return binop\n+            })\n+        }\n+\n+        // for isize & usize, be conservative with the warnings, so that the\n+        // warnings are consistent between 32- and 64-bit platforms\n+        fn int_ty_range(int_ty: ast::IntTy) -> (i64, i64) {\n+            match int_ty {\n+                ast::TyIs => (i64::MIN,        i64::MAX),\n+                ast::TyI8 =>    (i8::MIN  as i64, i8::MAX  as i64),\n+                ast::TyI16 =>   (i16::MIN as i64, i16::MAX as i64),\n+                ast::TyI32 =>   (i32::MIN as i64, i32::MAX as i64),\n+                ast::TyI64 =>   (i64::MIN,        i64::MAX)\n+            }\n+        }\n+\n+        fn uint_ty_range(uint_ty: ast::UintTy) -> (u64, u64) {\n+            match uint_ty {\n+                ast::TyUs => (u64::MIN,         u64::MAX),\n+                ast::TyU8 =>    (u8::MIN   as u64, u8::MAX   as u64),\n+                ast::TyU16 =>   (u16::MIN  as u64, u16::MAX  as u64),\n+                ast::TyU32 =>   (u32::MIN  as u64, u32::MAX  as u64),\n+                ast::TyU64 =>   (u64::MIN,         u64::MAX)\n+            }\n+        }\n+\n+        fn float_ty_range(float_ty: ast::FloatTy) -> (f64, f64) {\n+            match float_ty {\n+                ast::TyF32 => (f32::MIN as f64, f32::MAX as f64),\n+                ast::TyF64 => (f64::MIN,        f64::MAX)\n+            }\n+        }\n+\n+        fn int_ty_bits(int_ty: ast::IntTy, target_int_ty: ast::IntTy) -> u64 {\n+            match int_ty {\n+                ast::TyIs => int_ty_bits(target_int_ty, target_int_ty),\n+                ast::TyI8 =>    i8::BITS  as u64,\n+                ast::TyI16 =>   i16::BITS as u64,\n+                ast::TyI32 =>   i32::BITS as u64,\n+                ast::TyI64 =>   i64::BITS as u64\n+            }\n+        }\n+\n+        fn uint_ty_bits(uint_ty: ast::UintTy, target_uint_ty: ast::UintTy) -> u64 {\n+            match uint_ty {\n+                ast::TyUs => uint_ty_bits(target_uint_ty, target_uint_ty),\n+                ast::TyU8 =>    u8::BITS  as u64,\n+                ast::TyU16 =>   u16::BITS as u64,\n+                ast::TyU32 =>   u32::BITS as u64,\n+                ast::TyU64 =>   u64::BITS as u64\n+            }\n+        }\n+\n+        fn check_limits(tcx: &ty::ctxt, binop: hir::BinOp,\n+                        l: &hir::Expr, r: &hir::Expr) -> bool {\n+            let (lit, expr, swap) = match (&l.node, &r.node) {\n+                (&hir::ExprLit(_), _) => (l, r, true),\n+                (_, &hir::ExprLit(_)) => (r, l, false),\n+                _ => return true\n+            };\n+            // Normalize the binop so that the literal is always on the RHS in\n+            // the comparison\n+            let norm_binop = if swap {\n+                rev_binop(binop)\n+            } else {\n+                binop\n+            };\n+            match tcx.node_id_to_type(expr.id).sty {\n+                ty::TyInt(int_ty) => {\n+                    let (min, max) = int_ty_range(int_ty);\n+                    let lit_val: i64 = match lit.node {\n+                        hir::ExprLit(ref li) => match li.node {\n+                            ast::LitInt(v, ast::SignedIntLit(_, ast::Plus)) |\n+                            ast::LitInt(v, ast::UnsuffixedIntLit(ast::Plus)) => v as i64,\n+                            ast::LitInt(v, ast::SignedIntLit(_, ast::Minus)) |\n+                            ast::LitInt(v, ast::UnsuffixedIntLit(ast::Minus)) => -(v as i64),\n+                            _ => return true\n+                        },\n+                        _ => panic!()\n+                    };\n+                    is_valid(norm_binop, lit_val, min, max)\n+                }\n+                ty::TyUint(uint_ty) => {\n+                    let (min, max): (u64, u64) = uint_ty_range(uint_ty);\n+                    let lit_val: u64 = match lit.node {\n+                        hir::ExprLit(ref li) => match li.node {\n+                            ast::LitInt(v, _) => v,\n+                            _ => return true\n+                        },\n+                        _ => panic!()\n+                    };\n+                    is_valid(norm_binop, lit_val, min, max)\n+                }\n+                _ => true\n+            }\n+        }\n+\n+        fn is_comparison(binop: hir::BinOp) -> bool {\n+            match binop.node {\n+                hir::BiEq | hir::BiLt | hir::BiLe |\n+                hir::BiNe | hir::BiGe | hir::BiGt => true,\n+                _ => false\n+            }\n+        }\n+\n+        fn check_unsigned_negation_feature(cx: &LateContext, span: Span) {\n+            if !cx.sess().features.borrow().negate_unsigned {\n+                emit_feature_err(\n+                    &cx.sess().parse_sess.span_diagnostic,\n+                    \"negate_unsigned\",\n+                    span,\n+                    GateIssue::Language,\n+                    \"unary negation of unsigned integers may be removed in the future\");\n+            }\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    IMPROPER_CTYPES,\n+    Warn,\n+    \"proper use of libc types in foreign modules\"\n+}\n+\n+struct ImproperCTypesVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>\n+}\n+\n+enum FfiResult {\n+    FfiSafe,\n+    FfiUnsafe(&'static str),\n+    FfiBadStruct(DefId, &'static str),\n+    FfiBadEnum(DefId, &'static str)\n+}\n+\n+/// Check if this enum can be safely exported based on the\n+/// \"nullable pointer optimization\". Currently restricted\n+/// to function pointers and references, but could be\n+/// expanded to cover NonZero raw pointers and newtypes.\n+/// FIXME: This duplicates code in trans.\n+fn is_repr_nullable_ptr<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                              def: ty::AdtDef<'tcx>,\n+                              substs: &Substs<'tcx>)\n+                              -> bool {\n+    if def.variants.len() == 2 {\n+        let data_idx;\n+\n+        if def.variants[0].fields.is_empty() {\n+            data_idx = 1;\n+        } else if def.variants[1].fields.is_empty() {\n+            data_idx = 0;\n+        } else {\n+            return false;\n+        }\n+\n+        if def.variants[data_idx].fields.len() == 1 {\n+            match def.variants[data_idx].fields[0].ty(tcx, substs).sty {\n+                ty::TyBareFn(None, _) => { return true; }\n+                ty::TyRef(..) => { return true; }\n+                _ => { }\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+fn ast_ty_to_normalized<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                              id: ast::NodeId)\n+                              -> Ty<'tcx> {\n+    let tty = match tcx.ast_ty_to_ty_cache.borrow().get(&id) {\n+        Some(&t) => t,\n+        None => panic!(\"ast_ty_to_ty_cache was incomplete after typeck!\")\n+    };\n+    infer::normalize_associated_type(tcx, &tty)\n+}\n+\n+impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n+    /// Check if the given type is \"ffi-safe\" (has a stable, well-defined\n+    /// representation which can be exported to C code).\n+    fn check_type_for_ffi(&self,\n+                          cache: &mut FnvHashSet<Ty<'tcx>>,\n+                          ty: Ty<'tcx>)\n+                          -> FfiResult {\n+        use self::FfiResult::*;\n+        let cx = &self.cx.tcx;\n+\n+        // Protect against infinite recursion, for example\n+        // `struct S(*mut S);`.\n+        // FIXME: A recursion limit is necessary as well, for irregular\n+        // recusive types.\n+        if !cache.insert(ty) {\n+            return FfiSafe;\n+        }\n+\n+        match ty.sty {\n+            ty::TyStruct(def, substs) => {\n+                if !cx.lookup_repr_hints(def.did).contains(&attr::ReprExtern) {\n+                    return FfiUnsafe(\n+                        \"found struct without foreign-function-safe \\\n+                         representation annotation in foreign module, \\\n+                         consider adding a #[repr(C)] attribute to \\\n+                         the type\");\n+                }\n+\n+                // We can't completely trust repr(C) markings; make sure the\n+                // fields are actually safe.\n+                if def.struct_variant().fields.is_empty() {\n+                    return FfiUnsafe(\n+                        \"found zero-size struct in foreign module, consider \\\n+                         adding a member to this struct\");\n+                }\n+\n+                for field in &def.struct_variant().fields {\n+                    let field_ty = infer::normalize_associated_type(cx, &field.ty(cx, substs));\n+                    let r = self.check_type_for_ffi(cache, field_ty);\n+                    match r {\n+                        FfiSafe => {}\n+                        FfiBadStruct(..) | FfiBadEnum(..) => { return r; }\n+                        FfiUnsafe(s) => { return FfiBadStruct(def.did, s); }\n+                    }\n+                }\n+                FfiSafe\n+            }\n+            ty::TyEnum(def, substs) => {\n+                if def.variants.is_empty() {\n+                    // Empty enums are okay... although sort of useless.\n+                    return FfiSafe\n+                }\n+\n+                // Check for a repr() attribute to specify the size of the\n+                // discriminant.\n+                let repr_hints = cx.lookup_repr_hints(def.did);\n+                match &**repr_hints {\n+                    [] => {\n+                        // Special-case types like `Option<extern fn()>`.\n+                        if !is_repr_nullable_ptr(cx, def, substs) {\n+                            return FfiUnsafe(\n+                                \"found enum without foreign-function-safe \\\n+                                 representation annotation in foreign module, \\\n+                                 consider adding a #[repr(...)] attribute to \\\n+                                 the type\")\n+                        }\n+                    }\n+                    [ref hint] => {\n+                        if !hint.is_ffi_safe() {\n+                            // FIXME: This shouldn't be reachable: we should check\n+                            // this earlier.\n+                            return FfiUnsafe(\n+                                \"enum has unexpected #[repr(...)] attribute\")\n+                        }\n+\n+                        // Enum with an explicitly sized discriminant; either\n+                        // a C-style enum or a discriminated union.\n+\n+                        // The layout of enum variants is implicitly repr(C).\n+                        // FIXME: Is that correct?\n+                    }\n+                    _ => {\n+                        // FIXME: This shouldn't be reachable: we should check\n+                        // this earlier.\n+                        return FfiUnsafe(\n+                            \"enum has too many #[repr(...)] attributes\");\n+                    }\n+                }\n+\n+                // Check the contained variants.\n+                for variant in &def.variants {\n+                    for field in &variant.fields {\n+                        let arg = infer::normalize_associated_type(cx, &field.ty(cx, substs));\n+                        let r = self.check_type_for_ffi(cache, arg);\n+                        match r {\n+                            FfiSafe => {}\n+                            FfiBadStruct(..) | FfiBadEnum(..) => { return r; }\n+                            FfiUnsafe(s) => { return FfiBadEnum(def.did, s); }\n+                        }\n+                    }\n+                }\n+                FfiSafe\n+            }\n+\n+            ty::TyInt(ast::TyIs) => {\n+                FfiUnsafe(\"found Rust type `isize` in foreign module, while \\\n+                          `libc::c_int` or `libc::c_long` should be used\")\n+            }\n+            ty::TyUint(ast::TyUs) => {\n+                FfiUnsafe(\"found Rust type `usize` in foreign module, while \\\n+                          `libc::c_uint` or `libc::c_ulong` should be used\")\n+            }\n+            ty::TyChar => {\n+                FfiUnsafe(\"found Rust type `char` in foreign module, while \\\n+                           `u32` or `libc::wchar_t` should be used\")\n+            }\n+\n+            // Primitive types with a stable representation.\n+            ty::TyBool | ty::TyInt(..) | ty::TyUint(..) |\n+            ty::TyFloat(..) => FfiSafe,\n+\n+            ty::TyBox(..) => {\n+                FfiUnsafe(\"found Rust type Box<_> in foreign module, \\\n+                           consider using a raw pointer instead\")\n+            }\n+\n+            ty::TySlice(_) => {\n+                FfiUnsafe(\"found Rust slice type in foreign module, \\\n+                           consider using a raw pointer instead\")\n+            }\n+\n+            ty::TyTrait(..) => {\n+                FfiUnsafe(\"found Rust trait type in foreign module, \\\n+                           consider using a raw pointer instead\")\n+            }\n+\n+            ty::TyStr => {\n+                FfiUnsafe(\"found Rust type `str` in foreign module; \\\n+                           consider using a `*const libc::c_char`\")\n+            }\n+\n+            ty::TyTuple(_) => {\n+                FfiUnsafe(\"found Rust tuple type in foreign module; \\\n+                           consider using a struct instead`\")\n+            }\n+\n+            ty::TyRawPtr(ref m) | ty::TyRef(_, ref m) => {\n+                self.check_type_for_ffi(cache, m.ty)\n+            }\n+\n+            ty::TyArray(ty, _) => {\n+                self.check_type_for_ffi(cache, ty)\n+            }\n+\n+            ty::TyBareFn(None, bare_fn) => {\n+                match bare_fn.abi {\n+                    abi::Rust |\n+                    abi::RustIntrinsic |\n+                    abi::PlatformIntrinsic |\n+                    abi::RustCall => {\n+                        return FfiUnsafe(\n+                            \"found function pointer with Rust calling \\\n+                             convention in foreign module; consider using an \\\n+                             `extern` function pointer\")\n+                    }\n+                    _ => {}\n+                }\n+\n+                let sig = cx.erase_late_bound_regions(&bare_fn.sig);\n+                match sig.output {\n+                    ty::FnDiverging => {}\n+                    ty::FnConverging(output) => {\n+                        if !output.is_nil() {\n+                            let r = self.check_type_for_ffi(cache, output);\n+                            match r {\n+                                FfiSafe => {}\n+                                _ => { return r; }\n+                            }\n+                        }\n+                    }\n+                }\n+                for arg in sig.inputs {\n+                    let r = self.check_type_for_ffi(cache, arg);\n+                    match r {\n+                        FfiSafe => {}\n+                        _ => { return r; }\n+                    }\n+                }\n+                FfiSafe\n+            }\n+\n+            ty::TyParam(..) | ty::TyInfer(..) | ty::TyError |\n+            ty::TyClosure(..) | ty::TyProjection(..) |\n+            ty::TyBareFn(Some(_), _) => {\n+                panic!(\"Unexpected type in foreign function\")\n+            }\n+        }\n+    }\n+\n+    fn check_def(&mut self, sp: Span, id: ast::NodeId) {\n+        let tty = ast_ty_to_normalized(self.cx.tcx, id);\n+\n+        match ImproperCTypesVisitor::check_type_for_ffi(self, &mut FnvHashSet(), tty) {\n+            FfiResult::FfiSafe => {}\n+            FfiResult::FfiUnsafe(s) => {\n+                self.cx.span_lint(IMPROPER_CTYPES, sp, s);\n+            }\n+            FfiResult::FfiBadStruct(_, s) => {\n+                // FIXME: This diagnostic is difficult to read, and doesn't\n+                // point at the relevant field.\n+                self.cx.span_lint(IMPROPER_CTYPES, sp,\n+                    &format!(\"found non-foreign-function-safe member in \\\n+                              struct marked #[repr(C)]: {}\", s));\n+            }\n+            FfiResult::FfiBadEnum(_, s) => {\n+                // FIXME: This diagnostic is difficult to read, and doesn't\n+                // point at the relevant variant.\n+                self.cx.span_lint(IMPROPER_CTYPES, sp,\n+                    &format!(\"found non-foreign-function-safe member in \\\n+                              enum: {}\", s));\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx, 'v> Visitor<'v> for ImproperCTypesVisitor<'a, 'tcx> {\n+    fn visit_ty(&mut self, ty: &hir::Ty) {\n+        match ty.node {\n+            hir::TyPath(..) |\n+            hir::TyBareFn(..) => self.check_def(ty.span, ty.id),\n+            hir::TyVec(..) => {\n+                self.cx.span_lint(IMPROPER_CTYPES, ty.span,\n+                    \"found Rust slice type in foreign module, consider \\\n+                     using a raw pointer instead\");\n+            }\n+            hir::TyFixedLengthVec(ref ty, _) => self.visit_ty(ty),\n+            hir::TyTup(..) => {\n+                self.cx.span_lint(IMPROPER_CTYPES, ty.span,\n+                    \"found Rust tuple type in foreign module; \\\n+                     consider using a struct instead`\")\n+            }\n+            _ => visit::walk_ty(self, ty)\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct ImproperCTypes;\n+\n+impl LintPass for ImproperCTypes {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(IMPROPER_CTYPES)\n+    }\n+}\n+\n+impl LateLintPass for ImproperCTypes {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n+        fn check_ty(cx: &LateContext, ty: &hir::Ty) {\n+            let mut vis = ImproperCTypesVisitor { cx: cx };\n+            vis.visit_ty(ty);\n+        }\n+\n+        fn check_foreign_fn(cx: &LateContext, decl: &hir::FnDecl) {\n+            for input in &decl.inputs {\n+                check_ty(cx, &*input.ty);\n+            }\n+            if let hir::Return(ref ret_ty) = decl.output {\n+                let tty = ast_ty_to_normalized(cx.tcx, ret_ty.id);\n+                if !tty.is_nil() {\n+                    check_ty(cx, &ret_ty);\n+                }\n+            }\n+        }\n+\n+        match it.node {\n+            hir::ItemForeignMod(ref nmod)\n+                if nmod.abi != abi::RustIntrinsic &&\n+                   nmod.abi != abi::PlatformIntrinsic => {\n+                for ni in &nmod.items {\n+                    match ni.node {\n+                        hir::ForeignItemFn(ref decl, _) => check_foreign_fn(cx, &**decl),\n+                        hir::ForeignItemStatic(ref t, _) => check_ty(cx, &**t)\n+                    }\n+                }\n+            }\n+            _ => (),\n+        }\n+    }\n+}\n+"}]}