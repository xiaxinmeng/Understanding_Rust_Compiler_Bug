{"sha": "525c68cf95d465a69372bf55cb75c20b2688f443", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyNWM2OGNmOTVkNDY1YTY5MzcyYmY1NWNiNzVjMjBiMjY4OGY0NDM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-04-07T10:27:48Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-04-07T10:27:48Z"}, "message": "make StorageLive lazy as well", "tree": {"sha": "1d4b3e0bc0e980241a61a20fa9370b9b09ffac0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d4b3e0bc0e980241a61a20fa9370b9b09ffac0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/525c68cf95d465a69372bf55cb75c20b2688f443", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/525c68cf95d465a69372bf55cb75c20b2688f443", "html_url": "https://github.com/rust-lang/rust/commit/525c68cf95d465a69372bf55cb75c20b2688f443", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/525c68cf95d465a69372bf55cb75c20b2688f443/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb51f872a841f658449f2dd3adebf0b243aa96e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb51f872a841f658449f2dd3adebf0b243aa96e3", "html_url": "https://github.com/rust-lang/rust/commit/cb51f872a841f658449f2dd3adebf0b243aa96e3"}], "stats": {"total": 59, "additions": 22, "deletions": 37}, "files": [{"sha": "05207c47d5d9d4bad5129607a37312d1fcddf466", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/525c68cf95d465a69372bf55cb75c20b2688f443/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/525c68cf95d465a69372bf55cb75c20b2688f443/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=525c68cf95d465a69372bf55cb75c20b2688f443", "patch": "@@ -131,6 +131,22 @@ pub enum LocalValue<Tag=(), Id=AllocId> {\n     Live(Operand<Tag, Id>),\n }\n \n+impl<Tag: Copy> LocalValue<Tag> {\n+    /// The initial value of a local: ZST get \"initialized\" because they can be read from without\n+    /// ever having been written to.\n+    fn uninit_local(\n+        layout: TyLayout<'_>\n+    ) -> LocalValue<Tag> {\n+        // FIXME: Can we avoid this ZST special case? That would likely require MIR\n+        // generation changes.\n+        if layout.is_zst() {\n+            LocalValue::Live(Operand::Immediate(Immediate::Scalar(Scalar::zst().into())))\n+        } else {\n+            LocalValue::Uninitialized\n+        }\n+    }\n+}\n+\n impl<'tcx, Tag: Copy> LocalState<'tcx, Tag> {\n     pub fn access(&self) -> EvalResult<'tcx, &Operand<Tag>> {\n         match self.state {\n@@ -518,19 +534,15 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n                     }\n                 },\n             }\n-            // FIXME: We initialize live ZST here.  This should not be needed if MIR was\n-            // consistently generated for ZST, but that seems to not be the case -- there\n-            // is MIR (around promoteds in particular) that reads local ZSTs that never\n-            // were written to.\n+            // The remaining locals are uninitialized, fill them with `uninit_local`.\n+            // (For ZST this is not a NOP.)\n             for (idx, local) in locals.iter_enumerated_mut() {\n                 match local.state {\n                     LocalValue::Uninitialized => {\n                         // This needs to be properly initialized.\n                         let ty = self.monomorphize(mir.local_decls[idx].ty)?;\n                         let layout = self.layout_of(ty)?;\n-                        if layout.is_zst() {\n-                            local.state = LocalValue::Live(self.uninit_operand(layout)?);\n-                        }\n+                        local.state = LocalValue::uninit_local(layout);\n                         local.layout = Cell::new(Some(layout));\n                     }\n                     LocalValue::Dead => {\n@@ -622,9 +634,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n         trace!(\"{:?} is now live\", local);\n \n         let layout = self.layout_of_local(self.frame(), local, None)?;\n-        let init = LocalValue::Live(self.uninit_operand(layout)?);\n+        let local_val = LocalValue::uninit_local(layout);\n         // StorageLive *always* kills the value that's currently stored\n-        Ok(mem::replace(&mut self.frame_mut().locals[local].state, init))\n+        Ok(mem::replace(&mut self.frame_mut().locals[local].state, local_val))\n     }\n \n     /// Returns the old value of the local."}, {"sha": "4ece062f380d68f6b2f00ad09040f9c79f6e356c", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 28, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/525c68cf95d465a69372bf55cb75c20b2688f443/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/525c68cf95d465a69372bf55cb75c20b2688f443/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=525c68cf95d465a69372bf55cb75c20b2688f443", "patch": "@@ -14,7 +14,7 @@ use rustc::mir::interpret::{\n };\n use super::{\n     InterpretCx, Machine,\n-    MemPlace, MPlaceTy, PlaceTy, Place, MemoryKind,\n+    MemPlace, MPlaceTy, PlaceTy, Place,\n };\n pub use rustc::mir::interpret::ScalarMaybeUndef;\n \n@@ -373,33 +373,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         Ok(str)\n     }\n \n-    pub fn uninit_operand(\n-        &mut self,\n-        layout: TyLayout<'tcx>\n-    ) -> EvalResult<'tcx, Operand<M::PointerTag>> {\n-        // This decides which types we will use the Immediate optimization for, and hence should\n-        // match what `try_read_immediate` and `eval_place_to_op` support.\n-        if layout.is_zst() {\n-            return Ok(Operand::Immediate(Immediate::Scalar(Scalar::zst().into())));\n-        }\n-\n-        Ok(match layout.abi {\n-            layout::Abi::Scalar(..) =>\n-                Operand::Immediate(Immediate::Scalar(ScalarMaybeUndef::Undef)),\n-            layout::Abi::ScalarPair(..) =>\n-                Operand::Immediate(Immediate::ScalarPair(\n-                    ScalarMaybeUndef::Undef,\n-                    ScalarMaybeUndef::Undef,\n-                )),\n-            _ => {\n-                trace!(\"Forcing allocation for local of type {:?}\", layout.ty);\n-                Operand::Indirect(\n-                    *self.allocate(layout, MemoryKind::Stack)\n-                )\n-            }\n-        })\n-    }\n-\n     /// Projection functions\n     pub fn operand_field(\n         &self,"}]}