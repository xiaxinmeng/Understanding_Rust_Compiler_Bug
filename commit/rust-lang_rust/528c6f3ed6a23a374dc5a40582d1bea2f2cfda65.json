{"sha": "528c6f3ed6a23a374dc5a40582d1bea2f2cfda65", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyOGM2ZjNlZDZhMjNhMzc0ZGM1YTQwNTgyZDFiZWEyZjJjZmRhNjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-25T15:32:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-25T15:32:19Z"}, "message": "Auto merge of #35884 - habnabit:freebsd-arc4rand, r=alexcrichton\n\nUse arc4rand(9) on FreeBSD\n\nFrom rust-lang-nursery/rand#112:\n\n>After reading through #30691 it seems that there's general agreement that using OS-provided facilities for seeding rust userland processes is fine as long as it doesn't use too much from libc. FreeBSD's `arc4random_buf(3)` is not only a whole lot of libc code, but also not even currently exposed in the libc crate. Fortunately, the mechanism `arc4random_buf(3)` et al. use for getting entropy from the kernel ([`arc4rand(9)`](https://www.freebsd.org/cgi/man.cgi?query=arc4random&apropos=0&sektion=9&manpath=FreeBSD+10.3-RELEASE&arch=default&format=html)) is exposed via `sysctl(3)` with constants that are already in the libc crate.\n\n>I haven't found too much documentation on `KERN_ARND`\u2014it's missing or only briefly described in most of the places that cover sysctl mibs. But, from digging through the kernel source, it appears that the sysctl used in this PR is very close to just calling `arc4rand(9)` directly (with `reseed` set to 0 and no way to change it).\n\nI expected [rand](/rust-lang-nursery/rand) to reply quicker, so I tried submitting it there first. It's been a few weeks with no comment, so I don't know the state of it, but maybe someone will see it here and have an opinion. This is basically the same patch. It pains me to duplicate the code but I guess it hasn't been factored out into just one place yet.", "tree": {"sha": "a8b1d69441fbc6f09d37ee388c41b6cb1bf6d8f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8b1d69441fbc6f09d37ee388c41b6cb1bf6d8f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/528c6f3ed6a23a374dc5a40582d1bea2f2cfda65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/528c6f3ed6a23a374dc5a40582d1bea2f2cfda65", "html_url": "https://github.com/rust-lang/rust/commit/528c6f3ed6a23a374dc5a40582d1bea2f2cfda65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/528c6f3ed6a23a374dc5a40582d1bea2f2cfda65/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17a2be8c3571eaff1f09556febe68d8ab733ecf6", "url": "https://api.github.com/repos/rust-lang/rust/commits/17a2be8c3571eaff1f09556febe68d8ab733ecf6", "html_url": "https://github.com/rust-lang/rust/commit/17a2be8c3571eaff1f09556febe68d8ab733ecf6"}, {"sha": "0a70944e043db082353ed05cfa80994f6c56feae", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a70944e043db082353ed05cfa80994f6c56feae", "html_url": "https://github.com/rust-lang/rust/commit/0a70944e043db082353ed05cfa80994f6c56feae"}], "stats": {"total": 107, "additions": 77, "deletions": 30}, "files": [{"sha": "e4ca8344ee2873d31ce9c10c8e8dae16594c66ac", "filename": "src/libstd/sys/unix/rand.rs", "status": "modified", "additions": 77, "deletions": 30, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/528c6f3ed6a23a374dc5a40582d1bea2f2cfda65/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528c6f3ed6a23a374dc5a40582d1bea2f2cfda65/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frand.rs?ref=528c6f3ed6a23a374dc5a40582d1bea2f2cfda65", "patch": "@@ -10,14 +10,31 @@\n \n pub use self::imp::OsRng;\n \n-#[cfg(all(unix, not(target_os = \"ios\"), not(target_os = \"openbsd\")))]\n+use mem;\n+\n+fn next_u32(mut fill_buf: &mut FnMut(&mut [u8])) -> u32 {\n+    let mut buf: [u8; 4] = [0; 4];\n+    fill_buf(&mut buf);\n+    unsafe { mem::transmute::<[u8; 4], u32>(buf) }\n+}\n+\n+fn next_u64(mut fill_buf: &mut FnMut(&mut [u8])) -> u64 {\n+    let mut buf: [u8; 8] = [0; 8];\n+    fill_buf(&mut buf);\n+    unsafe { mem::transmute::<[u8; 8], u64>(buf) }\n+}\n+\n+#[cfg(all(unix,\n+          not(target_os = \"ios\"),\n+          not(target_os = \"openbsd\"),\n+          not(target_os = \"freebsd\")))]\n mod imp {\n     use self::OsRngInner::*;\n+    use super::{next_u32, next_u64};\n \n     use fs::File;\n     use io;\n     use libc;\n-    use mem;\n     use rand::Rng;\n     use rand::reader::ReaderRng;\n     use sys::os::errno;\n@@ -87,18 +104,6 @@ mod imp {\n         }\n     }\n \n-    fn getrandom_next_u32() -> u32 {\n-        let mut buf: [u8; 4] = [0; 4];\n-        getrandom_fill_bytes(&mut buf);\n-        unsafe { mem::transmute::<[u8; 4], u32>(buf) }\n-    }\n-\n-    fn getrandom_next_u64() -> u64 {\n-        let mut buf: [u8; 8] = [0; 8];\n-        getrandom_fill_bytes(&mut buf);\n-        unsafe { mem::transmute::<[u8; 8], u64>(buf) }\n-    }\n-\n     #[cfg(all(target_os = \"linux\",\n               any(target_arch = \"x86_64\",\n                   target_arch = \"x86\",\n@@ -163,13 +168,13 @@ mod imp {\n     impl Rng for OsRng {\n         fn next_u32(&mut self) -> u32 {\n             match self.inner {\n-                OsGetrandomRng => getrandom_next_u32(),\n+                OsGetrandomRng => next_u32(&mut getrandom_fill_bytes),\n                 OsReaderRng(ref mut rng) => rng.next_u32(),\n             }\n         }\n         fn next_u64(&mut self) -> u64 {\n             match self.inner {\n-                OsGetrandomRng => getrandom_next_u64(),\n+                OsGetrandomRng => next_u64(&mut getrandom_fill_bytes),\n                 OsReaderRng(ref mut rng) => rng.next_u64(),\n             }\n         }\n@@ -184,9 +189,10 @@ mod imp {\n \n #[cfg(target_os = \"openbsd\")]\n mod imp {\n+    use super::{next_u32, next_u64};\n+\n     use io;\n     use libc;\n-    use mem;\n     use sys::os::errno;\n     use rand::Rng;\n \n@@ -205,14 +211,10 @@ mod imp {\n \n     impl Rng for OsRng {\n         fn next_u32(&mut self) -> u32 {\n-            let mut v = [0; 4];\n-            self.fill_bytes(&mut v);\n-            unsafe { mem::transmute(v) }\n+            next_u32(&mut |v| self.fill_bytes(v))\n         }\n         fn next_u64(&mut self) -> u64 {\n-            let mut v = [0; 8];\n-            self.fill_bytes(&mut v);\n-            unsafe { mem::transmute(v) }\n+            next_u64(&mut |v| self.fill_bytes(v))\n         }\n         fn fill_bytes(&mut self, v: &mut [u8]) {\n             // getentropy(2) permits a maximum buffer size of 256 bytes\n@@ -230,8 +232,9 @@ mod imp {\n \n #[cfg(target_os = \"ios\")]\n mod imp {\n+    use super::{next_u32, next_u64};\n+\n     use io;\n-    use mem;\n     use ptr;\n     use rand::Rng;\n     use libc::{c_int, size_t};\n@@ -265,14 +268,10 @@ mod imp {\n \n     impl Rng for OsRng {\n         fn next_u32(&mut self) -> u32 {\n-            let mut v = [0; 4];\n-            self.fill_bytes(&mut v);\n-            unsafe { mem::transmute(v) }\n+            next_u32(&mut |v| self.fill_bytes(v))\n         }\n         fn next_u64(&mut self) -> u64 {\n-            let mut v = [0; 8];\n-            self.fill_bytes(&mut v);\n-            unsafe { mem::transmute(v) }\n+            next_u64(&mut |v| self.fill_bytes(v))\n         }\n         fn fill_bytes(&mut self, v: &mut [u8]) {\n             let ret = unsafe {\n@@ -286,3 +285,51 @@ mod imp {\n         }\n     }\n }\n+\n+#[cfg(target_os = \"freebsd\")]\n+mod imp {\n+    use super::{next_u32, next_u64};\n+\n+    use io;\n+    use libc;\n+    use rand::Rng;\n+    use ptr;\n+\n+    pub struct OsRng {\n+        // dummy field to ensure that this struct cannot be constructed outside\n+        // of this module\n+        _dummy: (),\n+    }\n+\n+    impl OsRng {\n+        /// Create a new `OsRng`.\n+        pub fn new() -> io::Result<OsRng> {\n+            Ok(OsRng { _dummy: () })\n+        }\n+    }\n+\n+    impl Rng for OsRng {\n+        fn next_u32(&mut self) -> u32 {\n+            next_u32(&mut |v| self.fill_bytes(v))\n+        }\n+        fn next_u64(&mut self) -> u64 {\n+            next_u64(&mut |v| self.fill_bytes(v))\n+        }\n+        fn fill_bytes(&mut self, v: &mut [u8]) {\n+            let mib = [libc::CTL_KERN, libc::KERN_ARND];\n+            // kern.arandom permits a maximum buffer size of 256 bytes\n+            for s in v.chunks_mut(256) {\n+                let mut s_len = s.len();\n+                let ret = unsafe {\n+                    libc::sysctl(mib.as_ptr(), mib.len() as libc::c_uint,\n+                                 s.as_mut_ptr() as *mut _, &mut s_len,\n+                                 ptr::null(), 0)\n+                };\n+                if ret == -1 || s_len != s.len() {\n+                    panic!(\"kern.arandom sysctl failed! (returned {}, s.len() {}, oldlenp {})\",\n+                           ret, s.len(), s_len);\n+                }\n+            }\n+        }\n+    }\n+}"}]}