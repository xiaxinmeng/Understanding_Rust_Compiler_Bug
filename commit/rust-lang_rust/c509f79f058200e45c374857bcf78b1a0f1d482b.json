{"sha": "c509f79f058200e45c374857bcf78b1a0f1d482b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1MDlmNzlmMDU4MjAwZTQ1YzM3NDg1N2JjZjc4YjFhMGYxZDQ4MmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-21T19:40:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-21T19:40:57Z"}, "message": "auto merge of #16601 : cybergeek94/rust/master, r=alexcrichton\n\nPreviously, `PrettyEncoder` indented a magic constant of 2 spaces per level, which may be fine for most uses but in my use case I would like to allow the user to specify the indent step for the outputted JSON in my program.\r\n\r\nThis is small change that does not break any existing code whatsoever, and does not change the behavior of existing uses. `PrettyEncoder::new()` still uses the default of 2.\r\n\r\nI couldn't think of any simple tests for this change. The obvious one would be to check the outputted JSON for the correct number of spaces per indent level, but I think that would be more complex than the actual change itself and test little besides correctness and consistency, which can be verified visually. There's already a test for correct parsing of pretty-printed JSON that should still pass with this change.", "tree": {"sha": "e3e32e060505b008d1bbbfc33e32352c5e87ed59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3e32e060505b008d1bbbfc33e32352c5e87ed59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c509f79f058200e45c374857bcf78b1a0f1d482b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c509f79f058200e45c374857bcf78b1a0f1d482b", "html_url": "https://github.com/rust-lang/rust/commit/c509f79f058200e45c374857bcf78b1a0f1d482b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c509f79f058200e45c374857bcf78b1a0f1d482b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f92015f71b3a49abd490e704a011d14786f6bf87", "url": "https://api.github.com/repos/rust-lang/rust/commits/f92015f71b3a49abd490e704a011d14786f6bf87", "html_url": "https://github.com/rust-lang/rust/commit/f92015f71b3a49abd490e704a011d14786f6bf87"}, {"sha": "1028120c40018763de11a81d0bf9bc981622d0ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/1028120c40018763de11a81d0bf9bc981622d0ae", "html_url": "https://github.com/rust-lang/rust/commit/1028120c40018763de11a81d0bf9bc981622d0ae"}], "stats": {"total": 103, "additions": 85, "deletions": 18}, "files": [{"sha": "cfc915c7d0ae0849c1f56ba203a741d2de7296d0", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 85, "deletions": 18, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/c509f79f058200e45c374857bcf78b1a0f1d482b/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c509f79f058200e45c374857bcf78b1a0f1d482b/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=c509f79f058200e45c374857bcf78b1a0f1d482b", "patch": "@@ -595,13 +595,23 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n /// compact data\n pub struct PrettyEncoder<'a> {\n     writer: &'a mut io::Writer,\n+    curr_indent: uint,\n     indent: uint,\n }\n \n impl<'a> PrettyEncoder<'a> {\n     /// Creates a new encoder whose output will be written to the specified writer\n     pub fn new<'a>(writer: &'a mut io::Writer) -> PrettyEncoder<'a> {\n-        PrettyEncoder { writer: writer, indent: 0 }\n+        PrettyEncoder { writer: writer, curr_indent: 0, indent: 2, }\n+    }\n+\n+    /// Set the number of spaces to indent for each level.\n+    /// This is safe to set during encoding.\n+    pub fn set_indent<'a>(&mut self, indent: uint) {\n+        // self.indent very well could be 0 so we need to use checked division.\n+        let level = self.curr_indent.checked_div(&self.indent).unwrap_or(0);\n+        self.indent = indent;\n+        self.curr_indent = level * self.indent;\n     }\n }\n \n@@ -656,15 +666,15 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         if cnt == 0 {\n             escape_str(self.writer, name)\n         } else {\n-            self.indent += 2;\n+            self.curr_indent += self.indent;\n             try!(write!(self.writer, \"[\\n\"));\n-            try!(spaces(self.writer, self.indent));\n+            try!(spaces(self.writer, self.curr_indent));\n             try!(escape_str(self.writer, name));\n             try!(write!(self.writer, \",\\n\"));\n             try!(f(self));\n-            self.indent -= 2;\n+            self.curr_indent -= self.indent;\n             try!(write!(self.writer, \"\\n\"));\n-            try!(spaces(self.writer, self.indent));\n+            try!(spaces(self.writer, self.curr_indent));\n             write!(self.writer, \"]\")\n         }\n     }\n@@ -675,7 +685,7 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         if idx != 0 {\n             try!(write!(self.writer, \",\\n\"));\n         }\n-        try!(spaces(self.writer, self.indent));\n+        try!(spaces(self.writer, self.curr_indent));\n         f(self)\n     }\n \n@@ -703,11 +713,11 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n             write!(self.writer, \"{{}}\")\n         } else {\n             try!(write!(self.writer, \"{{\"));\n-            self.indent += 2;\n+            self.curr_indent += self.indent;\n             try!(f(self));\n-            self.indent -= 2;\n+            self.curr_indent -= self.indent;\n             try!(write!(self.writer, \"\\n\"));\n-            try!(spaces(self.writer, self.indent));\n+            try!(spaces(self.writer, self.curr_indent));\n             write!(self.writer, \"}}\")\n         }\n     }\n@@ -721,7 +731,7 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         } else {\n             try!(write!(self.writer, \",\\n\"));\n         }\n-        try!(spaces(self.writer, self.indent));\n+        try!(spaces(self.writer, self.curr_indent));\n         try!(escape_str(self.writer, name));\n         try!(write!(self.writer, \": \"));\n         f(self)\n@@ -765,11 +775,11 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n             write!(self.writer, \"[]\")\n         } else {\n             try!(write!(self.writer, \"[\"));\n-            self.indent += 2;\n+            self.curr_indent += self.indent;\n             try!(f(self));\n-            self.indent -= 2;\n+            self.curr_indent -= self.indent;\n             try!(write!(self.writer, \"\\n\"));\n-            try!(spaces(self.writer, self.indent));\n+            try!(spaces(self.writer, self.curr_indent));\n             write!(self.writer, \"]\")\n         }\n     }\n@@ -782,7 +792,7 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         } else {\n             try!(write!(self.writer, \",\\n\"));\n         }\n-        try!(spaces(self.writer, self.indent));\n+        try!(spaces(self.writer, self.curr_indent));\n         f(self)\n     }\n \n@@ -793,11 +803,11 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n             write!(self.writer, \"{{}}\")\n         } else {\n             try!(write!(self.writer, \"{{\"));\n-            self.indent += 2;\n+            self.curr_indent += self.indent;\n             try!(f(self));\n-            self.indent -= 2;\n+            self.curr_indent -= self.indent;\n             try!(write!(self.writer, \"\\n\"));\n-            try!(spaces(self.writer, self.indent));\n+            try!(spaces(self.writer, self.curr_indent));\n             write!(self.writer, \"}}\")\n         }\n     }\n@@ -810,7 +820,7 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         } else {\n             try!(write!(self.writer, \",\\n\"));\n         }\n-        try!(spaces(self.writer, self.indent));\n+        try!(spaces(self.writer, self.curr_indent));\n         // ref #12967, make sure to wrap a key in double quotes,\n         // in the event that its of a type that omits them (eg numbers)\n         let mut buf = MemWriter::new();\n@@ -3197,6 +3207,63 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_prettyencoder_indent_level_param() {\n+        use std::str::from_utf8;\n+        use std::io::MemWriter;\n+        use std::collections::TreeMap;\n+\n+        let mut tree = TreeMap::new();\n+\n+        tree.insert(\"hello\".into_string(), String(\"guten tag\".into_string()));\n+        tree.insert(\"goodbye\".into_string(), String(\"sayonara\".into_string()));\n+\n+        let json = List(\n+            // The following layout below should look a lot like\n+            // the pretty-printed JSON (indent * x)\n+            vec!\n+            ( // 0x\n+                String(\"greetings\".into_string()), // 1x\n+                Object(tree), // 1x + 2x + 2x + 1x\n+            ) // 0x\n+            // End JSON list (7 lines)\n+        );\n+\n+        // Helper function for counting indents\n+        fn indents(source: &str) -> uint {\n+            let trimmed = source.trim_left_chars(' ');\n+            source.len() - trimmed.len()\n+        }\n+\n+        // Test up to 4 spaces of indents (more?)\n+        for i in range(0, 4u) {\n+            let mut writer = MemWriter::new();\n+            {\n+                let ref mut encoder = PrettyEncoder::new(&mut writer);\n+                encoder.set_indent(i);\n+                json.encode(encoder).unwrap();\n+            }\n+\n+            let bytes = writer.unwrap();\n+            let printed = from_utf8(bytes.as_slice()).unwrap();\n+\n+            // Check for indents at each line\n+            let lines: Vec<&str> = printed.lines().collect();\n+            assert_eq!(lines.len(), 7); // JSON should be 7 lines\n+\n+            assert_eq!(indents(lines[0]), 0 * i); // [\n+            assert_eq!(indents(lines[1]), 1 * i); //   \"greetings\",\n+            assert_eq!(indents(lines[2]), 1 * i); //   {\n+            assert_eq!(indents(lines[3]), 2 * i); //     \"hello\": \"guten tag\",\n+            assert_eq!(indents(lines[4]), 2 * i); //     \"goodbye\": \"sayonara\"\n+            assert_eq!(indents(lines[5]), 1 * i); //   },\n+            assert_eq!(indents(lines[6]), 0 * i); // ]\n+\n+            // Finally, test that the pretty-printed JSON is valid\n+            from_str(printed).ok().expect(\"Pretty-printed JSON is invalid!\");\n+        }\n+    }\n+\n     #[test]\n     fn test_hashmap_with_numeric_key_can_handle_double_quote_delimited_key() {\n         use std::collections::HashMap;"}]}