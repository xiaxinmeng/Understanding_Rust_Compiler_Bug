{"sha": "350d5dc152fe268bc33cf8d54e8ceb06531f07a4", "node_id": "C_kwDOAAsO6NoAKDM1MGQ1ZGMxNTJmZTI2OGJjMzNjZjhkNTRlOGNlYjA2NTMxZjA3YTQ", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-12-27T12:22:44Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-12-28T14:00:55Z"}, "message": "internal: move visibility to a prefix entry point", "tree": {"sha": "73b954bc5959e774ae94c237bb92059499c8e80a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73b954bc5959e774ae94c237bb92059499c8e80a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/350d5dc152fe268bc33cf8d54e8ceb06531f07a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/350d5dc152fe268bc33cf8d54e8ceb06531f07a4", "html_url": "https://github.com/rust-lang/rust/commit/350d5dc152fe268bc33cf8d54e8ceb06531f07a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/350d5dc152fe268bc33cf8d54e8ceb06531f07a4/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abc658aad04db9bbe1727218df110abc8e126ec7", "url": "https://api.github.com/repos/rust-lang/rust/commits/abc658aad04db9bbe1727218df110abc8e126ec7", "html_url": "https://github.com/rust-lang/rust/commit/abc658aad04db9bbe1727218df110abc8e126ec7"}], "stats": {"total": 70, "additions": 62, "deletions": 8}, "files": [{"sha": "3636979d007fad2e1c4558846d6481e2bed4d374", "filename": "crates/mbe/src/expander/matcher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/350d5dc152fe268bc33cf8d54e8ceb06531f07a4/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/350d5dc152fe268bc33cf8d54e8ceb06531f07a4/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs?ref=350d5dc152fe268bc33cf8d54e8ceb06531f07a4", "patch": "@@ -895,7 +895,7 @@ impl<'a> TtIter<'a> {\n     }\n \n     fn eat_vis(&mut self) -> Option<tt::TokenTree> {\n-        self.expect_fragment(ParserEntryPoint::Visibility).value\n+        self.expect_fragment2(parser::PrefixEntryPoint::Vis).value\n     }\n \n     fn eat_char(&mut self, c: char) -> Option<tt::TokenTree> {"}, {"sha": "03d0cbee8b13dcd6ba3008ef813dce3377ea67b7", "filename": "crates/mbe/src/tt_iter.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/350d5dc152fe268bc33cf8d54e8ceb06531f07a4/crates%2Fmbe%2Fsrc%2Ftt_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/350d5dc152fe268bc33cf8d54e8ceb06531f07a4/crates%2Fmbe%2Fsrc%2Ftt_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftt_iter.rs?ref=350d5dc152fe268bc33cf8d54e8ceb06531f07a4", "patch": "@@ -146,6 +146,63 @@ impl<'a> TtIter<'a> {\n         ExpandResult { value: res, err }\n     }\n \n+    pub(crate) fn expect_fragment2(\n+        &mut self,\n+        entry_point: parser::PrefixEntryPoint,\n+    ) -> ExpandResult<Option<tt::TokenTree>> {\n+        let buffer = TokenBuffer::from_tokens(self.inner.as_slice());\n+        let parser_input = to_parser_input(&buffer);\n+        let tree_traversal = entry_point.parse(&parser_input);\n+\n+        let mut cursor = buffer.begin();\n+        let mut error = false;\n+        for step in tree_traversal.iter() {\n+            match step {\n+                parser::Step::Token { kind, mut n_input_tokens } => {\n+                    if kind == SyntaxKind::LIFETIME_IDENT {\n+                        n_input_tokens = 2;\n+                    }\n+                    for _ in 0..n_input_tokens {\n+                        cursor = cursor.bump_subtree();\n+                    }\n+                }\n+                parser::Step::Enter { .. } | parser::Step::Exit => (),\n+                parser::Step::Error { .. } => error = true,\n+            }\n+        }\n+\n+        let mut err = if !cursor.is_root() || error {\n+            Some(err!(\"expected {:?}\", entry_point))\n+        } else {\n+            None\n+        };\n+\n+        let mut curr = buffer.begin();\n+        let mut res = vec![];\n+\n+        if cursor.is_root() {\n+            while curr != cursor {\n+                if let Some(token) = curr.token_tree() {\n+                    res.push(token);\n+                }\n+                curr = curr.bump();\n+            }\n+        }\n+        self.inner = self.inner.as_slice()[res.len()..].iter();\n+        if res.is_empty() && err.is_none() {\n+            err = Some(err!(\"no tokens consumed\"));\n+        }\n+        let res = match res.len() {\n+            1 => Some(res[0].cloned()),\n+            0 => None,\n+            _ => Some(tt::TokenTree::Subtree(tt::Subtree {\n+                delimiter: None,\n+                token_trees: res.into_iter().map(|it| it.cloned()).collect(),\n+            })),\n+        };\n+        ExpandResult { value: res, err }\n+    }\n+\n     pub(crate) fn peek_n(&self, n: usize) -> Option<&tt::TokenTree> {\n         self.inner.as_slice().get(n)\n     }"}, {"sha": "1c58f217a3077861119649c5645a5f8797bb7544", "filename": "crates/parser/src/grammar.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/350d5dc152fe268bc33cf8d54e8ceb06531f07a4/crates%2Fparser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/350d5dc152fe268bc33cf8d54e8ceb06531f07a4/crates%2Fparser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar.rs?ref=350d5dc152fe268bc33cf8d54e8ceb06531f07a4", "patch": "@@ -86,10 +86,6 @@ pub(crate) mod entry_points {\n         expressions::stmt(p, expressions::StmtWithSemi::Optional, false);\n     }\n \n-    pub(crate) fn visibility(p: &mut Parser) {\n-        let _ = opt_visibility(p, false);\n-    }\n-\n     // Parse a meta item , which excluded [], e.g : #[ MetaItem ]\n     pub(crate) fn meta_item(p: &mut Parser) {\n         attributes::meta(p);"}, {"sha": "f4ce5a21e80d69599a5d905311e33d77c7ff524d", "filename": "crates/parser/src/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/350d5dc152fe268bc33cf8d54e8ceb06531f07a4/crates%2Fparser%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/350d5dc152fe268bc33cf8d54e8ceb06531f07a4/crates%2Fparser%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Flib.rs?ref=350d5dc152fe268bc33cf8d54e8ceb06531f07a4", "patch": "@@ -49,12 +49,13 @@ pub use crate::{\n /// `Option<Output>`. The way MBE work, by the time we *try* to parse `$e:expr`\n /// we already commit to expression. In other words, this API by design can't be\n /// used to implement \"rollback and try another alternative\" logic.\n+#[derive(Debug)]\n pub enum PrefixEntryPoint {\n     Vis,\n }\n \n impl PrefixEntryPoint {\n-    pub fn parse(self, input: &Input) -> Output {\n+    pub fn parse(&self, input: &Input) -> Output {\n         let entry_point: fn(&'_ mut parser::Parser) = match self {\n             PrefixEntryPoint::Vis => grammar::entry::prefix::vis,\n         };\n@@ -80,7 +81,7 @@ pub enum ParserEntryPoint {\n     Pattern,\n     Item,\n     Block,\n-    Visibility,\n+    // Visibility,\n     MetaItem,\n     Items,\n     Statements,\n@@ -109,7 +110,7 @@ pub fn parse(inp: &Input, entry_point: ParserEntryPoint) -> Output {\n         ParserEntryPoint::Pattern => grammar::entry_points::pattern,\n         ParserEntryPoint::Item => grammar::entry_points::item,\n         ParserEntryPoint::Block => grammar::entry_points::block_expr,\n-        ParserEntryPoint::Visibility => grammar::entry_points::visibility,\n+        // ParserEntryPoint::Visibility => grammar::entry_points::visibility,\n         ParserEntryPoint::MetaItem => grammar::entry_points::meta_item,\n         ParserEntryPoint::Statement => grammar::entry_points::stmt,\n         ParserEntryPoint::StatementOptionalSemi => grammar::entry_points::stmt_optional_semi,"}]}