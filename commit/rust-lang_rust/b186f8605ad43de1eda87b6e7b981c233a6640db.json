{"sha": "b186f8605ad43de1eda87b6e7b981c233a6640db", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxODZmODYwNWFkNDNkZTFlZGE4N2I2ZTdiOTgxYzIzM2E2NjQwZGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-29T15:52:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-29T15:52:21Z"}, "message": "Auto merge of #86475 - crlf0710:miri_vtable_refactor, r=bjorn3\n\nChange vtable memory representation to use tcx allocated allocations.\n\nThis fixes https://github.com/rust-lang/rust/issues/86324. However i suspect there's more to change before it can land.\n\nr? `@bjorn3`\ncc `@rust-lang/miri`", "tree": {"sha": "16b7cc29650aeb6e61e3ff5d55b2f9a53cbc95ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16b7cc29650aeb6e61e3ff5d55b2f9a53cbc95ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b186f8605ad43de1eda87b6e7b981c233a6640db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b186f8605ad43de1eda87b6e7b981c233a6640db", "html_url": "https://github.com/rust-lang/rust/commit/b186f8605ad43de1eda87b6e7b981c233a6640db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b186f8605ad43de1eda87b6e7b981c233a6640db/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0af5f783cbe7bd652271b91b4e85601bfa89344", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0af5f783cbe7bd652271b91b4e85601bfa89344", "html_url": "https://github.com/rust-lang/rust/commit/e0af5f783cbe7bd652271b91b4e85601bfa89344"}, {"sha": "4d289dba2ea409672600c571004fee64ec931a10", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d289dba2ea409672600c571004fee64ec931a10", "html_url": "https://github.com/rust-lang/rust/commit/4d289dba2ea409672600c571004fee64ec931a10"}], "stats": {"total": 116, "additions": 14, "deletions": 102}, "files": [{"sha": "a8a0bb52a246e728041afe7ba14593b76db0cafb", "filename": "src/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b186f8605ad43de1eda87b6e7b981c233a6640db/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b186f8605ad43de1eda87b6e7b981c233a6640db/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=b186f8605ad43de1eda87b6e7b981c233a6640db", "patch": "@@ -233,7 +233,7 @@ pub(crate) struct FunctionCx<'m, 'clif, 'tcx: 'm> {\n     pub(crate) module: &'m mut dyn Module,\n     pub(crate) tcx: TyCtxt<'tcx>,\n     pub(crate) pointer_type: Type, // Cached from module\n-    pub(crate) vtables: FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), DataId>,\n+    pub(crate) vtables: FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), Pointer>,\n     pub(crate) constants_cx: ConstantCx,\n \n     pub(crate) instance: Instance<'tcx>,"}, {"sha": "a87b3703949f9aebc5ec69e6e3a2bbb4cfd9b3fe", "filename": "src/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b186f8605ad43de1eda87b6e7b981c233a6640db/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b186f8605ad43de1eda87b6e7b981c233a6640db/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=b186f8605ad43de1eda87b6e7b981c233a6640db", "patch": "@@ -249,7 +249,7 @@ pub(crate) fn codegen_const_value<'tcx>(\n     }\n }\n \n-fn pointer_for_allocation<'tcx>(\n+pub(crate) fn pointer_for_allocation<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     alloc: &'tcx Allocation,\n ) -> crate::pointer::Pointer {"}, {"sha": "b817bf4aff7718c89e424c14c6039457287ff251", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b186f8605ad43de1eda87b6e7b981c233a6640db/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b186f8605ad43de1eda87b6e7b981c233a6640db/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=b186f8605ad43de1eda87b6e7b981c233a6640db", "patch": "@@ -98,7 +98,7 @@ mod prelude {\n     pub(crate) use cranelift_codegen::isa::{self, CallConv};\n     pub(crate) use cranelift_codegen::Context;\n     pub(crate) use cranelift_frontend::{FunctionBuilder, FunctionBuilderContext, Variable};\n-    pub(crate) use cranelift_module::{self, DataContext, DataId, FuncId, Linkage, Module};\n+    pub(crate) use cranelift_module::{self, DataContext, FuncId, Linkage, Module};\n \n     pub(crate) use crate::abi::*;\n     pub(crate) use crate::base::{codegen_operand, codegen_place};"}, {"sha": "b9d379c6117c91d846e3620649c2e40f951daf9f", "filename": "src/unsize.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b186f8605ad43de1eda87b6e7b981c233a6640db/src%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b186f8605ad43de1eda87b6e7b981c233a6640db/src%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funsize.rs?ref=b186f8605ad43de1eda87b6e7b981c233a6640db", "patch": "@@ -31,9 +31,7 @@ pub(crate) fn unsized_info<'tcx>(\n             // change to the vtable.\n             old_info.expect(\"unsized_info: missing old info for trait upcast\")\n         }\n-        (_, &ty::Dynamic(ref data, ..)) => {\n-            crate::vtable::get_vtable(fx, fx.layout_of(source), data.principal())\n-        }\n+        (_, &ty::Dynamic(ref data, ..)) => crate::vtable::get_vtable(fx, source, data.principal()),\n         _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\", source, target),\n     }\n }"}, {"sha": "12f7092d935a33732d858ddad42e2eff87f93b66", "filename": "src/vtable.rs", "status": "modified", "additions": 10, "deletions": 96, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/b186f8605ad43de1eda87b6e7b981c233a6640db/src%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b186f8605ad43de1eda87b6e7b981c233a6640db/src%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvtable.rs?ref=b186f8605ad43de1eda87b6e7b981c233a6640db", "patch": "@@ -4,7 +4,7 @@\n // FIXME dedup this logic between miri, cg_llvm and cg_clif\n \n use crate::prelude::*;\n-use ty::VtblEntry;\n+use super::constant::pointer_for_allocation;\n \n fn vtable_memflags() -> MemFlags {\n     let mut flags = MemFlags::trusted(); // A vtable access is always aligned and will never trap.\n@@ -66,105 +66,19 @@ pub(crate) fn get_ptr_and_method_ref<'tcx>(\n \n pub(crate) fn get_vtable<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n-    layout: TyAndLayout<'tcx>,\n+    ty: Ty<'tcx>,\n     trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n ) -> Value {\n-    let data_id = if let Some(data_id) = fx.vtables.get(&(layout.ty, trait_ref)) {\n-        *data_id\n+    let vtable_ptr = if let Some(vtable_ptr) = fx.vtables.get(&(ty, trait_ref)) {\n+        *vtable_ptr\n     } else {\n-        let data_id = build_vtable(fx, layout, trait_ref);\n-        fx.vtables.insert((layout.ty, trait_ref), data_id);\n-        data_id\n-    };\n-\n-    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n-    fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n-}\n-\n-fn build_vtable<'tcx>(\n-    fx: &mut FunctionCx<'_, '_, 'tcx>,\n-    layout: TyAndLayout<'tcx>,\n-    trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n-) -> DataId {\n-    let tcx = fx.tcx;\n-    let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n+        let vtable_alloc_id = fx.tcx.vtable_allocation(ty, trait_ref);\n+        let vtable_allocation = fx.tcx.global_alloc(vtable_alloc_id).unwrap_memory();\n+        let vtable_ptr = pointer_for_allocation(fx, vtable_allocation);\n \n-    let drop_in_place_fn = import_function(\n-        tcx,\n-        fx.module,\n-        Instance::resolve_drop_in_place(tcx, layout.ty).polymorphize(fx.tcx),\n-    );\n-\n-    let vtable_entries = if let Some(trait_ref) = trait_ref {\n-        tcx.vtable_entries(trait_ref.with_self_ty(tcx, layout.ty))\n-    } else {\n-        ty::COMMON_VTABLE_ENTRIES\n+        fx.vtables.insert((ty, trait_ref), vtable_ptr);\n+        vtable_ptr\n     };\n \n-    let mut data_ctx = DataContext::new();\n-    let mut data = ::std::iter::repeat(0u8)\n-        .take(vtable_entries.len() * usize_size)\n-        .collect::<Vec<u8>>()\n-        .into_boxed_slice();\n-\n-    for (idx, entry) in vtable_entries.iter().enumerate() {\n-        match entry {\n-            VtblEntry::MetadataSize => {\n-                write_usize(fx.tcx, &mut data, idx, layout.size.bytes());\n-            }\n-            VtblEntry::MetadataAlign => {\n-                write_usize(fx.tcx, &mut data, idx, layout.align.abi.bytes());\n-            }\n-            VtblEntry::MetadataDropInPlace | VtblEntry::Vacant | VtblEntry::Method(_, _) => {}\n-        }\n-    }\n-    data_ctx.define(data);\n-\n-    for (idx, entry) in vtable_entries.iter().enumerate() {\n-        match entry {\n-            VtblEntry::MetadataDropInPlace => {\n-                let func_ref = fx.module.declare_func_in_data(drop_in_place_fn, &mut data_ctx);\n-                data_ctx.write_function_addr((idx * usize_size) as u32, func_ref);\n-            }\n-            VtblEntry::Method(def_id, substs) => {\n-                let func_id = import_function(\n-                    tcx,\n-                    fx.module,\n-                    Instance::resolve_for_vtable(tcx, ParamEnv::reveal_all(), *def_id, substs)\n-                        .unwrap()\n-                        .polymorphize(fx.tcx),\n-                );\n-                let func_ref = fx.module.declare_func_in_data(func_id, &mut data_ctx);\n-                data_ctx.write_function_addr((idx * usize_size) as u32, func_ref);\n-            }\n-            VtblEntry::MetadataSize | VtblEntry::MetadataAlign | VtblEntry::Vacant => {}\n-        }\n-    }\n-\n-    data_ctx.set_align(fx.tcx.data_layout.pointer_align.pref.bytes());\n-\n-    let data_id = fx.module.declare_anonymous_data(false, false).unwrap();\n-\n-    fx.module.define_data(data_id, &data_ctx).unwrap();\n-\n-    data_id\n-}\n-\n-fn write_usize(tcx: TyCtxt<'_>, buf: &mut [u8], idx: usize, num: u64) {\n-    let pointer_size =\n-        tcx.layout_of(ParamEnv::reveal_all().and(tcx.types.usize)).unwrap().size.bytes() as usize;\n-    let target = &mut buf[idx * pointer_size..(idx + 1) * pointer_size];\n-\n-    match tcx.data_layout.endian {\n-        rustc_target::abi::Endian::Little => match pointer_size {\n-            4 => target.copy_from_slice(&(num as u32).to_le_bytes()),\n-            8 => target.copy_from_slice(&(num as u64).to_le_bytes()),\n-            _ => todo!(\"pointer size {} is not yet supported\", pointer_size),\n-        },\n-        rustc_target::abi::Endian::Big => match pointer_size {\n-            4 => target.copy_from_slice(&(num as u32).to_be_bytes()),\n-            8 => target.copy_from_slice(&(num as u64).to_be_bytes()),\n-            _ => todo!(\"pointer size {} is not yet supported\", pointer_size),\n-        },\n-    }\n+    vtable_ptr.get_addr(fx)\n }"}]}