{"sha": "1d53e437442b44b5c530c45cf9fdfd595ad715b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkNTNlNDM3NDQyYjQ0YjVjNTMwYzQ1Y2Y5ZmRmZDU5NWFkNzE1YjE=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-11-08T22:54:00Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-11-27T19:47:12Z"}, "message": "Simplify `mem_categorization`\n\n* `Place` is no longer recursive.\n* The `cmt` type alias is removed\n* `Upvar` places no longer include the dereferences of the environment\n  closure or of by reference captures.\n* All non-dereference projections are combined to a single variant.\n* Various unnecessary types and methods have been removed.", "tree": {"sha": "fe757f70195a60672a38f29bf4b2631eaedce14a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe757f70195a60672a38f29bf4b2631eaedce14a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d53e437442b44b5c530c45cf9fdfd595ad715b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d53e437442b44b5c530c45cf9fdfd595ad715b1", "html_url": "https://github.com/rust-lang/rust/commit/1d53e437442b44b5c530c45cf9fdfd595ad715b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d53e437442b44b5c530c45cf9fdfd595ad715b1/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5b8a3088a61a564fb2e4de97d4d26e321eb66bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5b8a3088a61a564fb2e4de97d4d26e321eb66bd", "html_url": "https://github.com/rust-lang/rust/commit/a5b8a3088a61a564fb2e4de97d4d26e321eb66bd"}], "stats": {"total": 1633, "additions": 374, "deletions": 1259}, "files": [{"sha": "201ae6597f4dd79ce99b112c0d185ea0f2817278", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1d53e437442b44b5c530c45cf9fdfd595ad715b1/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d53e437442b44b5c530c45cf9fdfd595ad715b1/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=1d53e437442b44b5c530c45cf9fdfd595ad715b1", "patch": "@@ -13,7 +13,6 @@ use crate::middle::mem_categorization as mc;\n use crate::ty::{self, TyCtxt, adjustment};\n \n use crate::hir::{self, PatKind};\n-use std::rc::Rc;\n use syntax_pos::Span;\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -136,12 +135,9 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             let param_ty = return_if_err!(self.mc.pat_ty_adjusted(&param.pat));\n             debug!(\"consume_body: param_ty = {:?}\", param_ty);\n \n-            let param_cmt = Rc::new(self.mc.cat_rvalue(\n-                param.hir_id,\n-                param.pat.span,\n-                param_ty));\n+            let param_place = self.mc.cat_rvalue(param.hir_id, param.pat.span, param_ty);\n \n-            self.walk_irrefutable_pat(param_cmt, &param.pat);\n+            self.walk_irrefutable_pat(&param_place, &param.pat);\n         }\n \n         self.consume_expr(&body.value);\n@@ -234,12 +230,12 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             }\n \n             hir::ExprKind::Match(ref discr, ref arms, _) => {\n-                let discr_cmt = Rc::new(return_if_err!(self.mc.cat_expr(&discr)));\n+                let discr_cmt = return_if_err!(self.mc.cat_expr(&discr));\n                 self.borrow_expr(&discr, ty::ImmBorrow);\n \n                 // treatment of the discriminant is handled while walking the arms.\n                 for arm in arms {\n-                    self.walk_arm(discr_cmt.clone(), arm);\n+                    self.walk_arm(&discr_cmt, arm);\n                 }\n             }\n \n@@ -385,8 +381,8 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             // \"assigns\", which is handled by\n             // `walk_pat`:\n             self.walk_expr(&expr);\n-            let init_cmt = Rc::new(return_if_err!(self.mc.cat_expr(&expr)));\n-            self.walk_irrefutable_pat(init_cmt, &local.pat);\n+            let init_cmt = return_if_err!(self.mc.cat_expr(&expr));\n+            self.walk_irrefutable_pat(&init_cmt, &local.pat);\n         }\n     }\n \n@@ -417,26 +413,24 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             None => { return; }\n         };\n \n-        let with_cmt = Rc::new(return_if_err!(self.mc.cat_expr(&with_expr)));\n+        let with_place = return_if_err!(self.mc.cat_expr(&with_expr));\n \n         // Select just those fields of the `with`\n         // expression that will actually be used\n-        match with_cmt.ty.kind {\n+        match with_place.ty.kind {\n             ty::Adt(adt, substs) if adt.is_struct() => {\n                 // Consume those fields of the with expression that are needed.\n                 for (f_index, with_field) in adt.non_enum_variant().fields.iter().enumerate() {\n                     let is_mentioned = fields.iter().any(|f| {\n                         self.tcx().field_index(f.hir_id, self.mc.tables) == f_index\n                     });\n                     if !is_mentioned {\n-                        let cmt_field = self.mc.cat_field(\n+                        let field_place = self.mc.cat_projection(\n                             &*with_expr,\n-                            with_cmt.clone(),\n-                            f_index,\n-                            with_field.ident,\n-                            with_field.ty(self.tcx(), substs)\n+                            with_place.clone(),\n+                            with_field.ty(self.tcx(), substs),\n                         );\n-                        self.delegate_consume(&cmt_field);\n+                        self.delegate_consume(&field_place);\n                     }\n                 }\n             }\n@@ -522,8 +516,8 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn walk_arm(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &hir::Arm) {\n-        self.walk_pat(discr_cmt.clone(), &arm.pat);\n+    fn walk_arm(&mut self, discr_place: &mc::Place<'tcx>, arm: &hir::Arm) {\n+        self.walk_pat(discr_place, &arm.pat);\n \n         if let Some(hir::Guard::If(ref e)) = arm.guard {\n             self.consume_expr(e)\n@@ -534,22 +528,22 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n     /// Walks a pat that occurs in isolation (i.e., top-level of fn argument or\n     /// let binding, and *not* a match arm or nested pat.)\n-    fn walk_irrefutable_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &hir::Pat) {\n-        self.walk_pat(cmt_discr, pat);\n+    fn walk_irrefutable_pat(&mut self, discr_place: &mc::Place<'tcx>, pat: &hir::Pat) {\n+        self.walk_pat(discr_place, pat);\n     }\n \n \n     /// The core driver for walking a pattern\n-    fn walk_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &hir::Pat) {\n-        debug!(\"walk_pat(cmt_discr={:?}, pat={:?})\", cmt_discr, pat);\n+    fn walk_pat(&mut self, discr_place: &mc::Place<'tcx>, pat: &hir::Pat) {\n+        debug!(\"walk_pat(discr_place={:?}, pat={:?})\", discr_place, pat);\n \n         let tcx = self.tcx();\n         let ExprUseVisitor { ref mc, ref mut delegate } = *self;\n-        return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |cmt_pat, pat| {\n+        return_if_err!(mc.cat_pattern(discr_place.clone(), pat, |place, pat| {\n             if let PatKind::Binding(_, canonical_id, ..) = pat.kind {\n                 debug!(\n-                    \"walk_pat: binding cmt_pat={:?} pat={:?}\",\n-                    cmt_pat,\n+                    \"walk_pat: binding place={:?} pat={:?}\",\n+                    place,\n                     pat,\n                 );\n                 if let Some(&bm) = mc.tables.pat_binding_modes().get(pat.hir_id) {\n@@ -570,12 +564,12 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                     match bm {\n                         ty::BindByReference(m) => {\n                             let bk = ty::BorrowKind::from_mutbl(m);\n-                            delegate.borrow(&cmt_pat, bk);\n+                            delegate.borrow(place, bk);\n                         }\n                         ty::BindByValue(..) => {\n-                            let mode = copy_or_move(mc, &cmt_pat);\n+                            let mode = copy_or_move(mc, place);\n                             debug!(\"walk_pat binding consuming pat\");\n-                            delegate.consume(&cmt_pat, mode);\n+                            delegate.consume(place, mode);\n                         }\n                     }\n                 } else {"}, {"sha": "50a70ebc515ca4c4e7dac7e7ce63a822c667cd3b", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 159, "deletions": 907, "changes": 1066, "blob_url": "https://github.com/rust-lang/rust/blob/1d53e437442b44b5c530c45cf9fdfd595ad715b1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d53e437442b44b5c530c45cf9fdfd595ad715b1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=1d53e437442b44b5c530c45cf9fdfd595ad715b1", "patch": "@@ -48,152 +48,72 @@\n //! result of `*x'`, effectively, where `x'` is a `Categorization::Upvar` reference\n //! tied to `x`. The type of `x'` will be a borrowed pointer.\n \n-#![allow(non_camel_case_types)]\n-\n-pub use self::PointerKind::*;\n-pub use self::InteriorKind::*;\n-pub use self::MutabilityCategory::*;\n-pub use self::AliasableReason::*;\n-pub use self::Note::*;\n-\n-use self::Aliasability::*;\n-\n-use crate::hir::def_id::{DefId, LocalDefId};\n-use crate::hir::Node;\n+use crate::hir::def_id::DefId;\n use crate::infer::InferCtxt;\n-use crate::hir::def::{CtorOf, Res, DefKind, CtorKind};\n+use crate::hir::def::{Res, DefKind};\n use crate::ty::adjustment;\n-use crate::ty::{self, DefIdTree, Ty, TyCtxt};\n+use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::fold::TypeFoldable;\n \n-use crate::hir::{Mutability, PatKind};\n-use crate::hir::pat_util::EnumerateAndAdjustIterator;\n+use crate::hir::PatKind;\n use crate::hir;\n-use syntax::ast::{self, Name};\n-use syntax::symbol::sym;\n use syntax_pos::Span;\n \n-use std::borrow::Cow;\n-use std::fmt;\n-use std::hash::{Hash, Hasher};\n use rustc_data_structures::fx::FxIndexMap;\n-use std::rc::Rc;\n \n-#[derive(Clone, Debug, PartialEq)]\n-pub enum Categorization<'tcx> {\n-    Rvalue,                              // temporary val\n-    ThreadLocal,                         // value that cannot move, but still restricted in scope\n+#[derive(Clone, Debug)]\n+pub enum PlaceBase {\n+    /// A temporary variable\n+    Rvalue,\n+    /// A named `static` item\n     StaticItem,\n-    Upvar(Upvar),                        // upvar referenced by closure env\n-    Local(hir::HirId),                   // local variable\n-    Deref(cmt<'tcx>, PointerKind<'tcx>), // deref of a ptr\n-    Interior(cmt<'tcx>, InteriorKind),   // something interior: field, tuple, etc\n-    Downcast(cmt<'tcx>, DefId),          // selects a particular enum variant (*1)\n-\n-    // (*1) downcast is only required if the enum has more than one variant\n-}\n-\n-// Represents any kind of upvar\n-#[derive(Clone, Copy, PartialEq)]\n-pub struct Upvar {\n-    pub id: ty::UpvarId,\n-    pub kind: ty::ClosureKind\n+    /// A named local variable\n+    Local(hir::HirId),\n+    /// An upvar referenced by closure env\n+    Upvar(ty::UpvarId),\n }\n \n-// different kinds of pointers:\n-#[derive(Clone, Copy, Debug, PartialEq)]\n-pub enum PointerKind<'tcx> {\n-    /// `Box<T>`\n-    Unique,\n-\n-    /// `&T`\n-    BorrowedPtr(ty::BorrowKind, ty::Region<'tcx>),\n-\n-    /// `*T`\n-    UnsafePtr(hir::Mutability),\n-}\n-\n-// We use the term \"interior\" to mean \"something reachable from the\n-// base without a pointer dereference\", e.g., a field\n-#[derive(Clone, PartialEq)]\n-pub enum InteriorKind {\n-    InteriorField(FieldIndex),\n-    InteriorElement(InteriorOffsetKind),\n+#[derive(Clone, Debug)]\n+pub enum Projection<'tcx> {\n+    /// A dereference of a pointer, reference or `Box<T>` of the given type\n+    Deref(Ty<'tcx>),\n+    /// An index or a field\n+    Other,\n }\n \n-// Contains index of a field that is actually used for loan path comparisons and\n-// string representation of the field that should be used only for diagnostics.\n-#[derive(Clone, Copy, Eq)]\n-pub struct FieldIndex(pub usize, pub Name);\n-\n-impl PartialEq for FieldIndex {\n-    fn eq(&self, rhs: &Self) -> bool {\n-        self.0 == rhs.0\n-    }\n+/// A `Place` represents how a value is located in memory.\n+///\n+/// This is an HIR version of `mir::Place`\n+#[derive(Clone, Debug)]\n+pub struct Place<'tcx> {\n+    /// `HirId` of the expression or pattern producing this value.\n+    pub hir_id: hir::HirId,\n+    /// The `Span` of the expression or pattern producing this value.\n+    pub span: Span,\n+    /// The type of the `Place`\n+    pub ty: Ty<'tcx>,\n+    /// The \"outermost\" place that holds this value.\n+    pub base: PlaceBase,\n+    /// How this place is derived from the base place.\n+    pub projections: Vec<Projection<'tcx>>,\n }\n \n-impl Hash for FieldIndex {\n-    fn hash<H: Hasher>(&self, h: &mut H) {\n-        self.0.hash(h)\n+impl<'tcx> Place<'tcx> {\n+    /// Returns an iterator of the types that have to be dereferenced to access\n+    /// the `Place`.\n+    ///\n+    /// The types are in the reverse order that they are applied. So if\n+    /// `x: &*const u32` and the `Place` is `**x`, then the types returned are\n+    ///`*const u32` then `&*const u32`.\n+    pub fn deref_tys(&self) -> impl Iterator<Item=Ty<'tcx>> + '_ {\n+        self.projections.iter().rev().filter_map(|proj| if let Projection::Deref(deref_ty) = *proj {\n+            Some(deref_ty)\n+        } else {\n+            None\n+        })\n     }\n }\n \n-#[derive(Clone, PartialEq)]\n-pub enum InteriorOffsetKind {\n-    Index,   // e.g., `array_expr[index_expr]`\n-    Pattern, // e.g., `fn foo([_, a, _, _]: [A; 4]) { ... }`\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Debug)]\n-pub enum MutabilityCategory {\n-    McImmutable, // Immutable.\n-    McDeclared,  // Directly declared as mutable.\n-    McInherited, // Inherited from the fact that owner is mutable.\n-}\n-\n-// A note about the provenance of a `cmt`.  This is used for\n-// special-case handling of upvars such as mutability inference.\n-// Upvar categorization can generate a variable number of nested\n-// derefs.  The note allows detecting them without deep pattern\n-// matching on the categorization.\n-#[derive(Clone, Copy, PartialEq, Debug)]\n-pub enum Note {\n-    NoteClosureEnv(ty::UpvarId), // Deref through closure env\n-    NoteUpvarRef(ty::UpvarId),   // Deref through by-ref upvar\n-    NoteIndex,                   // Deref as part of desugaring `x[]` into its two components\n-    NoteNone                     // Nothing special\n-}\n-\n-// `cmt`: \"Category, Mutability, and Type\".\n-//\n-// a complete categorization of a value indicating where it originated\n-// and how it is located, as well as the mutability of the memory in\n-// which the value is stored.\n-//\n-// *WARNING* The field `cmt.type` is NOT necessarily the same as the\n-// result of `node_type(cmt.id)`.\n-//\n-// (FIXME: rewrite the following comment given that `@x` managed\n-// pointers have been obsolete for quite some time.)\n-//\n-// This is because the `id` is always the `id` of the node producing the\n-// type; in an expression like `*x`, the type of this deref node is the\n-// deref'd type (`T`), but in a pattern like `@x`, the `@x` pattern is\n-// again a dereference, but its type is the type *before* the\n-// dereference (`@T`). So use `cmt.ty` to find the type of the value in\n-// a consistent fashion. For more details, see the method `cat_pattern`\n-#[derive(Clone, Debug, PartialEq)]\n-pub struct Place<'tcx> {\n-    pub hir_id: hir::HirId,        // HIR id of expr/pat producing this value\n-    pub span: Span,                // span of same expr/pat\n-    pub cat: Categorization<'tcx>, // categorization of expr\n-    pub mutbl: MutabilityCategory, // mutability of expr as place\n-    pub ty: Ty<'tcx>,              // type of the expr (*see WARNING above*)\n-    pub note: Note,                // Note about the provenance of this cmt\n-}\n-\n-pub type cmt<'tcx> = Rc<Place<'tcx>>;\n-\n pub trait HirNode {\n     fn hir_id(&self) -> hir::HirId;\n     fn span(&self) -> Span;\n@@ -220,109 +140,6 @@ pub struct MemCategorizationContext<'a, 'tcx> {\n \n pub type McResult<T> = Result<T, ()>;\n \n-impl MutabilityCategory {\n-    pub fn from_mutbl(m: hir::Mutability) -> MutabilityCategory {\n-        let ret = match m {\n-            Mutability::Immutable => McImmutable,\n-            Mutability::Mutable => McDeclared\n-        };\n-        debug!(\"MutabilityCategory::{}({:?}) => {:?}\",\n-               \"from_mutbl\", m, ret);\n-        ret\n-    }\n-\n-    pub fn from_borrow_kind(borrow_kind: ty::BorrowKind) -> MutabilityCategory {\n-        let ret = match borrow_kind {\n-            ty::ImmBorrow => McImmutable,\n-            ty::UniqueImmBorrow => McImmutable,\n-            ty::MutBorrow => McDeclared,\n-        };\n-        debug!(\"MutabilityCategory::{}({:?}) => {:?}\",\n-               \"from_borrow_kind\", borrow_kind, ret);\n-        ret\n-    }\n-\n-    fn from_pointer_kind(base_mutbl: MutabilityCategory,\n-                         ptr: PointerKind<'_>) -> MutabilityCategory {\n-        let ret = match ptr {\n-            Unique => {\n-                base_mutbl.inherit()\n-            }\n-            BorrowedPtr(borrow_kind, _) => {\n-                MutabilityCategory::from_borrow_kind(borrow_kind)\n-            }\n-            UnsafePtr(m) => {\n-                MutabilityCategory::from_mutbl(m)\n-            }\n-        };\n-        debug!(\"MutabilityCategory::{}({:?}, {:?}) => {:?}\",\n-               \"from_pointer_kind\", base_mutbl, ptr, ret);\n-        ret\n-    }\n-\n-    fn from_local(\n-        tcx: TyCtxt<'_>,\n-        tables: &ty::TypeckTables<'_>,\n-        id: hir::HirId,\n-    ) -> MutabilityCategory {\n-        let ret = match tcx.hir().get(id) {\n-            Node::Binding(p) => match p.kind {\n-                PatKind::Binding(..) => {\n-                    let bm = *tables.pat_binding_modes()\n-                                    .get(p.hir_id)\n-                                    .expect(\"missing binding mode\");\n-                    if bm == ty::BindByValue(Mutability::Mutable) {\n-                        McDeclared\n-                    } else {\n-                        McImmutable\n-                    }\n-                }\n-                _ => span_bug!(p.span, \"expected identifier pattern\")\n-            },\n-            _ => span_bug!(tcx.hir().span(id), \"expected identifier pattern\")\n-        };\n-        debug!(\"MutabilityCategory::{}(tcx, id={:?}) => {:?}\",\n-               \"from_local\", id, ret);\n-        ret\n-    }\n-\n-    pub fn inherit(&self) -> MutabilityCategory {\n-        let ret = match *self {\n-            McImmutable => McImmutable,\n-            McDeclared => McInherited,\n-            McInherited => McInherited,\n-        };\n-        debug!(\"{:?}.inherit() => {:?}\", self, ret);\n-        ret\n-    }\n-\n-    pub fn is_mutable(&self) -> bool {\n-        let ret = match *self {\n-            McImmutable => false,\n-            McInherited => true,\n-            McDeclared => true,\n-        };\n-        debug!(\"{:?}.is_mutable() => {:?}\", self, ret);\n-        ret\n-    }\n-\n-    pub fn is_immutable(&self) -> bool {\n-        let ret = match *self {\n-            McImmutable => true,\n-            McDeclared | McInherited => false\n-        };\n-        debug!(\"{:?}.is_immutable() => {:?}\", self, ret);\n-        ret\n-    }\n-\n-    pub fn to_user_str(&self) -> &'static str {\n-        match *self {\n-            McDeclared | McInherited => \"mutable\",\n-            McImmutable => \"immutable\",\n-        }\n-    }\n-}\n-\n impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     /// Creates a `MemCategorizationContext`.\n     pub fn new(\n@@ -407,7 +224,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     ///   implicit deref patterns attached (e.g., it is really\n     ///   `&Some(x)`). In that case, we return the \"outermost\" type\n     ///   (e.g., `&Option<T>).\n-    pub(super) fn pat_ty_adjusted(&self, pat: &hir::Pat) -> McResult<Ty<'tcx>> {\n+    crate fn pat_ty_adjusted(&self, pat: &hir::Pat) -> McResult<Ty<'tcx>> {\n         // Check for implicit `&` types wrapping the pattern; note\n         // that these are never attached to binding patterns, so\n         // actually this is somewhat \"disjoint\" from the code below\n@@ -496,23 +313,23 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         match adjustment.kind {\n             adjustment::Adjust::Deref(overloaded) => {\n                 // Equivalent to *expr or something similar.\n-                let base = Rc::new(if let Some(deref) = overloaded {\n+                let base = if let Some(deref) = overloaded {\n                     let ref_ty = self.tcx().mk_ref(deref.region, ty::TypeAndMut {\n                         ty: target,\n                         mutbl: deref.mutbl,\n                     });\n-                    self.cat_rvalue_node(expr.hir_id, expr.span, ref_ty)\n+                    self.cat_rvalue(expr.hir_id, expr.span, ref_ty)\n                 } else {\n                     previous()?\n-                });\n-                self.cat_deref(expr, base, NoteNone)\n+                };\n+                self.cat_deref(expr, base)\n             }\n \n             adjustment::Adjust::NeverToAny |\n             adjustment::Adjust::Pointer(_) |\n             adjustment::Adjust::Borrow(_) => {\n                 // Result is an rvalue.\n-                Ok(self.cat_rvalue_node(expr.hir_id, expr.span, target))\n+                Ok(self.cat_rvalue(expr.hir_id, expr.span, target))\n             }\n         }\n     }\n@@ -524,21 +341,20 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         match expr.kind {\n             hir::ExprKind::Unary(hir::UnDeref, ref e_base) => {\n                 if self.tables.is_method_call(expr) {\n-                    self.cat_overloaded_place(expr, e_base, NoteNone)\n+                    self.cat_overloaded_place(expr, e_base)\n                 } else {\n-                    let base_cmt = Rc::new(self.cat_expr(&e_base)?);\n-                    self.cat_deref(expr, base_cmt, NoteNone)\n+                    let base = self.cat_expr(&e_base)?;\n+                    self.cat_deref(expr, base)\n                 }\n             }\n \n-            hir::ExprKind::Field(ref base, f_ident) => {\n-                let base_cmt = Rc::new(self.cat_expr(&base)?);\n+            hir::ExprKind::Field(ref base, _) => {\n+                let base = self.cat_expr(&base)?;\n                 debug!(\"cat_expr(cat_field): id={} expr={:?} base={:?}\",\n                        expr.hir_id,\n                        expr,\n-                       base_cmt);\n-                let f_index = self.tcx().field_index(expr.hir_id, self.tables);\n-                Ok(self.cat_field(expr, base_cmt, f_index, f_ident, expr_ty))\n+                       base);\n+                Ok(self.cat_projection(expr, base, expr_ty))\n             }\n \n             hir::ExprKind::Index(ref base, _) => {\n@@ -548,10 +364,10 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                     // The call to index() returns a `&T` value, which\n                     // is an rvalue. That is what we will be\n                     // dereferencing.\n-                    self.cat_overloaded_place(expr, base, NoteIndex)\n+                    self.cat_overloaded_place(expr, base)\n                 } else {\n-                    let base_cmt = Rc::new(self.cat_expr(&base)?);\n-                    self.cat_index(expr, base_cmt, expr_ty, InteriorOffsetKind::Index)\n+                    let base = self.cat_expr(&base)?;\n+                    Ok(self.cat_projection(expr, base, expr_ty))\n                 }\n             }\n \n@@ -575,12 +391,12 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             hir::ExprKind::Lit(..) | hir::ExprKind::Break(..) |\n             hir::ExprKind::Continue(..) | hir::ExprKind::Struct(..) | hir::ExprKind::Repeat(..) |\n             hir::ExprKind::InlineAsm(..) | hir::ExprKind::Box(..) | hir::ExprKind::Err => {\n-                Ok(self.cat_rvalue_node(expr.hir_id, expr.span, expr_ty))\n+                Ok(self.cat_rvalue(expr.hir_id, expr.span, expr_ty))\n             }\n         }\n     }\n \n-    pub fn cat_res(&self,\n+    crate fn cat_res(&self,\n                    hir_id: hir::HirId,\n                    span: Span,\n                    expr_ty: Ty<'tcx>,\n@@ -597,32 +413,16 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             | Res::Def(DefKind::Fn, _)\n             | Res::Def(DefKind::Method, _)\n             | Res::SelfCtor(..) => {\n-                Ok(self.cat_rvalue_node(hir_id, span, expr_ty))\n+                Ok(self.cat_rvalue(hir_id, span, expr_ty))\n             }\n \n-            Res::Def(DefKind::Static, def_id) => {\n-                // `#[thread_local]` statics may not outlive the current function, but\n-                // they also cannot be moved out of.\n-                let is_thread_local = self.tcx().get_attrs(def_id)[..]\n-                    .iter()\n-                    .any(|attr| attr.check_name(sym::thread_local));\n-\n-                let cat = if is_thread_local {\n-                    Categorization::ThreadLocal\n-                } else {\n-                    Categorization::StaticItem\n-                };\n-\n+            Res::Def(DefKind::Static, _) => {\n                 Ok(Place {\n                     hir_id,\n                     span,\n-                    cat,\n-                    mutbl: match self.tcx().static_mutability(def_id).unwrap() {\n-                        Mutability::Immutable => McImmutable,\n-                        Mutability::Mutable => McDeclared,\n-                    },\n-                    ty:expr_ty,\n-                    note: NoteNone\n+                    ty: expr_ty,\n+                    base: PlaceBase::StaticItem,\n+                    projections: Vec::new(),\n                 })\n             }\n \n@@ -633,10 +433,9 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                     Ok(Place {\n                         hir_id,\n                         span,\n-                        cat: Categorization::Local(var_id),\n-                        mutbl: MutabilityCategory::from_local(self.tcx(), self.tables, var_id),\n                         ty: expr_ty,\n-                        note: NoteNone\n+                        base: PlaceBase::Local(var_id),\n+                        projections: Vec::new(),\n                     })\n                 }\n             }\n@@ -645,218 +444,64 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         }\n     }\n \n-    // Categorize an upvar, complete with invisible derefs of closure\n-    // environment and upvar reference as appropriate.\n+    /// Categorize an upvar.\n+    ///\n+    /// Note: the actual upvar access contains invisible derefs of closure\n+    /// environment and upvar reference as appropriate. Only regionck cares\n+    /// about these dereferences, so we let it compute them as needed.\n     fn cat_upvar(\n         &self,\n         hir_id: hir::HirId,\n         span: Span,\n         var_id: hir::HirId,\n     ) -> McResult<Place<'tcx>> {\n-        // An upvar can have up to 3 components. We translate first to a\n-        // `Categorization::Upvar`, which is itself a fiction -- it represents the reference to the\n-        // field from the environment.\n-        //\n-        // `Categorization::Upvar`.  Next, we add a deref through the implicit\n-        // environment pointer with an anonymous free region 'env and\n-        // appropriate borrow kind for closure kinds that take self by\n-        // reference.  Finally, if the upvar was captured\n-        // by-reference, we add a deref through that reference.  The\n-        // region of this reference is an inference variable 'up that\n-        // was previously generated and recorded in the upvar borrow\n-        // map.  The borrow kind bk is inferred by based on how the\n-        // upvar is used.\n-        //\n-        // This results in the following table for concrete closure\n-        // types:\n-        //\n-        //                | move                 | ref\n-        // ---------------+----------------------+-------------------------------\n-        // Fn             | copied -> &'env      | upvar -> &'env -> &'up bk\n-        // FnMut          | copied -> &'env mut  | upvar -> &'env mut -> &'up bk\n-        // FnOnce         | copied               | upvar -> &'up bk\n-\n         let closure_expr_def_id = self.body_owner;\n-        let fn_hir_id = self.tcx().hir().local_def_id_to_hir_id(\n-            LocalDefId::from_def_id(closure_expr_def_id),\n-        );\n-        let ty = self.node_ty(fn_hir_id)?;\n-        let kind = match ty.kind {\n-            ty::Generator(..) => ty::ClosureKind::FnOnce,\n-            ty::Closure(closure_def_id, substs) => {\n-                self.infcx.closure_kind(\n-                    closure_def_id,\n-                    substs\n-                ).unwrap_or(ty::ClosureKind::LATTICE_BOTTOM)\n-            }\n-            _ => span_bug!(span, \"unexpected type for fn in mem_categorization: {:?}\", ty),\n-        };\n \n         let upvar_id = ty::UpvarId {\n             var_path: ty::UpvarPath { hir_id: var_id },\n             closure_expr_id: closure_expr_def_id.to_local(),\n         };\n-\n         let var_ty = self.node_ty(var_id)?;\n \n-        // Mutability of original variable itself\n-        let var_mutbl = MutabilityCategory::from_local(self.tcx(), self.tables, var_id);\n-\n-        // Construct the upvar. This represents access to the field\n-        // from the environment (perhaps we should eventually desugar\n-        // this field further, but it will do for now).\n-        let cmt_result = Place {\n+        let ret = Place {\n             hir_id,\n             span,\n-            cat: Categorization::Upvar(Upvar {id: upvar_id, kind: kind}),\n-            mutbl: var_mutbl,\n             ty: var_ty,\n-            note: NoteNone\n-        };\n-\n-        // If this is a `FnMut` or `Fn` closure, then the above is\n-        // conceptually a `&mut` or `&` reference, so we have to add a\n-        // deref.\n-        let cmt_result = match kind {\n-            ty::ClosureKind::FnOnce => {\n-                cmt_result\n-            }\n-            ty::ClosureKind::FnMut => {\n-                self.env_deref(hir_id, span, upvar_id, var_mutbl, ty::MutBorrow, cmt_result)\n-            }\n-            ty::ClosureKind::Fn => {\n-                self.env_deref(hir_id, span, upvar_id, var_mutbl, ty::ImmBorrow, cmt_result)\n-            }\n-        };\n-\n-        // If this is a by-ref capture, then the upvar we loaded is\n-        // actually a reference, so we have to add an implicit deref\n-        // for that.\n-        let upvar_capture = self.tables.upvar_capture(upvar_id);\n-        let cmt_result = match upvar_capture {\n-            ty::UpvarCapture::ByValue => {\n-                cmt_result\n-            }\n-            ty::UpvarCapture::ByRef(upvar_borrow) => {\n-                let ptr = BorrowedPtr(upvar_borrow.kind, upvar_borrow.region);\n-                Place {\n-                    hir_id,\n-                    span,\n-                    cat: Categorization::Deref(Rc::new(cmt_result), ptr),\n-                    mutbl: MutabilityCategory::from_borrow_kind(upvar_borrow.kind),\n-                    ty: var_ty,\n-                    note: NoteUpvarRef(upvar_id)\n-                }\n-            }\n+            base: PlaceBase::Upvar(upvar_id),\n+            projections: Vec::new(),\n         };\n \n-        let ret = cmt_result;\n         debug!(\"cat_upvar ret={:?}\", ret);\n         Ok(ret)\n     }\n \n-    fn env_deref(&self,\n-                 hir_id: hir::HirId,\n-                 span: Span,\n-                 upvar_id: ty::UpvarId,\n-                 upvar_mutbl: MutabilityCategory,\n-                 env_borrow_kind: ty::BorrowKind,\n-                 cmt_result: Place<'tcx>)\n-                 -> Place<'tcx>\n-    {\n-        // Region of environment pointer\n-        let env_region = self.tcx().mk_region(ty::ReFree(ty::FreeRegion {\n-            // The environment of a closure is guaranteed to\n-            // outlive any bindings introduced in the body of the\n-            // closure itself.\n-            scope: upvar_id.closure_expr_id.to_def_id(),\n-            bound_region: ty::BrEnv\n-        }));\n-\n-        let env_ptr = BorrowedPtr(env_borrow_kind, env_region);\n-\n-        let var_ty = cmt_result.ty;\n-\n-        // We need to add the env deref.  This means\n-        // that the above is actually immutable and\n-        // has a ref type.  However, nothing should\n-        // actually look at the type, so we can get\n-        // away with stuffing a `Error` in there\n-        // instead of bothering to construct a proper\n-        // one.\n-        let cmt_result = Place {\n-            mutbl: McImmutable,\n-            ty: self.tcx().types.err,\n-            ..cmt_result\n-        };\n-\n-        let mut deref_mutbl = MutabilityCategory::from_borrow_kind(env_borrow_kind);\n-\n-        // Issue #18335. If variable is declared as immutable, override the\n-        // mutability from the environment and substitute an `&T` anyway.\n-        match upvar_mutbl {\n-            McImmutable => { deref_mutbl = McImmutable; }\n-            McDeclared | McInherited => { }\n-        }\n-\n+    pub fn cat_rvalue(&self, hir_id: hir::HirId, span: Span, expr_ty: Ty<'tcx>) -> Place<'tcx> {\n+        debug!(\"cat_rvalue hir_id={:?}, expr_ty={:?}, span={:?}\", hir_id, expr_ty, span);\n         let ret = Place {\n             hir_id,\n             span,\n-            cat: Categorization::Deref(Rc::new(cmt_result), env_ptr),\n-            mutbl: deref_mutbl,\n-            ty: var_ty,\n-            note: NoteClosureEnv(upvar_id)\n-        };\n-\n-        debug!(\"env_deref ret {:?}\", ret);\n-\n-        ret\n-    }\n-\n-    pub fn cat_rvalue_node(&self,\n-                           hir_id: hir::HirId,\n-                           span: Span,\n-                           expr_ty: Ty<'tcx>)\n-                           -> Place<'tcx> {\n-        debug!(\"cat_rvalue_node(id={:?}, span={:?}, expr_ty={:?})\",\n-               hir_id, span, expr_ty);\n-\n-        let ret = self.cat_rvalue(hir_id, span, expr_ty);\n-        debug!(\"cat_rvalue_node ret {:?}\", ret);\n-        ret\n-    }\n-\n-    pub fn cat_rvalue(&self,\n-                      cmt_hir_id: hir::HirId,\n-                      span: Span,\n-                      expr_ty: Ty<'tcx>) -> Place<'tcx> {\n-        let ret = Place {\n-            hir_id: cmt_hir_id,\n-            span:span,\n-            cat:Categorization::Rvalue,\n-            mutbl:McDeclared,\n-            ty:expr_ty,\n-            note: NoteNone\n+            base: PlaceBase::Rvalue,\n+            projections: Vec::new(),\n+            ty: expr_ty,\n         };\n-        debug!(\"cat_rvalue ret {:?}\", ret);\n+        debug!(\"cat_rvalue ret={:?}\", ret);\n         ret\n     }\n \n-    pub fn cat_field<N: HirNode>(&self,\n-                                 node: &N,\n-                                 base_cmt: cmt<'tcx>,\n-                                 f_index: usize,\n-                                 f_ident: ast::Ident,\n-                                 f_ty: Ty<'tcx>)\n-                                 -> Place<'tcx> {\n+    crate fn cat_projection<N: HirNode>(\n+        &self,\n+        node: &N,\n+        base_place: Place<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> Place<'tcx> {\n+        let mut projections = base_place.projections;\n+        projections.push(Projection::Other);\n         let ret = Place {\n             hir_id: node.hir_id(),\n             span: node.span(),\n-            mutbl: base_cmt.mutbl.inherit(),\n-            cat: Categorization::Interior(base_cmt,\n-                                          InteriorField(FieldIndex(f_index, f_ident.name))),\n-            ty: f_ty,\n-            note: NoteNone\n+            ty,\n+            base: base_place.base,\n+            projections,\n         };\n         debug!(\"cat_field ret {:?}\", ret);\n         ret\n@@ -866,12 +511,8 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         &self,\n         expr: &hir::Expr,\n         base: &hir::Expr,\n-        note: Note,\n     ) -> McResult<Place<'tcx>> {\n-        debug!(\"cat_overloaded_place(expr={:?}, base={:?}, note={:?})\",\n-               expr,\n-               base,\n-               note);\n+        debug!(\"cat_overloaded_place(expr={:?}, base={:?})\", expr, base);\n \n         // Reconstruct the output assuming it's a reference with the\n         // same region and mutability as the receiver. This holds for\n@@ -888,182 +529,60 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             mutbl,\n         });\n \n-        let base_cmt = Rc::new(self.cat_rvalue_node(expr.hir_id, expr.span, ref_ty));\n-        self.cat_deref(expr, base_cmt, note)\n+        let base_cmt = self.cat_rvalue(expr.hir_id, expr.span, ref_ty);\n+        self.cat_deref(expr, base_cmt)\n     }\n \n-    pub fn cat_deref(\n+    fn cat_deref(\n         &self,\n         node: &impl HirNode,\n-        base_cmt: cmt<'tcx>,\n-        note: Note,\n+        base_place: Place<'tcx>,\n     ) -> McResult<Place<'tcx>> {\n-        debug!(\"cat_deref: base_cmt={:?}\", base_cmt);\n+        debug!(\"cat_deref: base_cmt={:?}\", base_place);\n \n-        let base_cmt_ty = base_cmt.ty;\n-        let deref_ty = match base_cmt_ty.builtin_deref(true) {\n+        let base_ty = base_place.ty;\n+        let deref_ty = match base_ty.builtin_deref(true) {\n             Some(mt) => mt.ty,\n             None => {\n-                debug!(\"explicit deref of non-derefable type: {:?}\", base_cmt_ty);\n+                debug!(\"explicit deref of non-derefable type: {:?}\", base_ty);\n                 return Err(());\n             }\n         };\n+        let mut projections = base_place.projections;\n+        projections.push(Projection::Deref(base_ty));\n \n-        let ptr = match base_cmt.ty.kind {\n-            ty::Adt(def, ..) if def.is_box() => Unique,\n-            ty::RawPtr(ref mt) => UnsafePtr(mt.mutbl),\n-            ty::Ref(r, _, mutbl) => {\n-                let bk = ty::BorrowKind::from_mutbl(mutbl);\n-                BorrowedPtr(bk, r)\n-            }\n-            _ => bug!(\"unexpected type in cat_deref: {:?}\", base_cmt.ty)\n-        };\n         let ret = Place {\n             hir_id: node.hir_id(),\n             span: node.span(),\n-            // For unique ptrs, we inherit mutability from the owning reference.\n-            mutbl: MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr),\n-            cat: Categorization::Deref(base_cmt, ptr),\n             ty: deref_ty,\n-            note: note,\n+            base: base_place.base,\n+            projections,\n         };\n         debug!(\"cat_deref ret {:?}\", ret);\n         Ok(ret)\n     }\n \n-    fn cat_index<N: HirNode>(&self,\n-                             elt: &N,\n-                             base_cmt: cmt<'tcx>,\n-                             element_ty: Ty<'tcx>,\n-                             context: InteriorOffsetKind)\n-                             -> McResult<Place<'tcx>> {\n-        //! Creates a cmt for an indexing operation (`[]`).\n-        //!\n-        //! One subtle aspect of indexing that may not be\n-        //! immediately obvious: for anything other than a fixed-length\n-        //! vector, an operation like `x[y]` actually consists of two\n-        //! disjoint (from the point of view of borrowck) operations.\n-        //! The first is a deref of `x` to create a pointer `p` that points\n-        //! at the first element in the array. The second operation is\n-        //! an index which adds `y*sizeof(T)` to `p` to obtain the\n-        //! pointer to `x[y]`. `cat_index` will produce a resulting\n-        //! cmt containing both this deref and the indexing,\n-        //! presuming that `base_cmt` is not of fixed-length type.\n-        //!\n-        //! # Parameters\n-        //! - `elt`: the HIR node being indexed\n-        //! - `base_cmt`: the cmt of `elt`\n-\n-        let interior_elem = InteriorElement(context);\n-        let ret = self.cat_imm_interior(elt, base_cmt, element_ty, interior_elem);\n-        debug!(\"cat_index ret {:?}\", ret);\n-        return Ok(ret);\n-    }\n-\n-    pub fn cat_imm_interior<N:HirNode>(&self,\n-                                       node: &N,\n-                                       base_cmt: cmt<'tcx>,\n-                                       interior_ty: Ty<'tcx>,\n-                                       interior: InteriorKind)\n-                                       -> Place<'tcx> {\n-        let ret = Place {\n-            hir_id: node.hir_id(),\n-            span: node.span(),\n-            mutbl: base_cmt.mutbl.inherit(),\n-            cat: Categorization::Interior(base_cmt, interior),\n-            ty: interior_ty,\n-            note: NoteNone\n-        };\n-        debug!(\"cat_imm_interior ret={:?}\", ret);\n-        ret\n-    }\n-\n-    pub fn cat_downcast_if_needed<N:HirNode>(&self,\n-                                             node: &N,\n-                                             base_cmt: cmt<'tcx>,\n-                                             variant_did: DefId)\n-                                             -> cmt<'tcx> {\n-        // univariant enums do not need downcasts\n-        let base_did = self.tcx().parent(variant_did).unwrap();\n-        if self.tcx().adt_def(base_did).variants.len() != 1 {\n-            let base_ty = base_cmt.ty;\n-            let ret = Rc::new(Place {\n-                hir_id: node.hir_id(),\n-                span: node.span(),\n-                mutbl: base_cmt.mutbl.inherit(),\n-                cat: Categorization::Downcast(base_cmt, variant_did),\n-                ty: base_ty,\n-                note: NoteNone\n-            });\n-            debug!(\"cat_downcast ret={:?}\", ret);\n-            ret\n-        } else {\n-            debug!(\"cat_downcast univariant={:?}\", base_cmt);\n-            base_cmt\n-        }\n-    }\n-\n-    pub fn cat_pattern<F>(&self, cmt: cmt<'tcx>, pat: &hir::Pat, mut op: F) -> McResult<()>\n-        where F: FnMut(cmt<'tcx>, &hir::Pat),\n+    pub fn cat_pattern<F>(&self, place: Place<'tcx>, pat: &hir::Pat, mut op: F) -> McResult<()>\n+        where F: FnMut(&Place<'tcx>, &hir::Pat),\n     {\n-        self.cat_pattern_(cmt, pat, &mut op)\n+        self.cat_pattern_(place, pat, &mut op)\n     }\n \n     // FIXME(#19596) This is a workaround, but there should be a better way to do this\n-    fn cat_pattern_<F>(&self, mut cmt: cmt<'tcx>, pat: &hir::Pat, op: &mut F) -> McResult<()>\n-        where F : FnMut(cmt<'tcx>, &hir::Pat)\n+    fn cat_pattern_<F>(&self, mut place: Place<'tcx>, pat: &hir::Pat, op: &mut F) -> McResult<()>\n+        where F: FnMut(&Place<'tcx>, &hir::Pat)\n     {\n-        // Here, `cmt` is the categorization for the value being\n-        // matched and pat is the pattern it is being matched against.\n-        //\n-        // In general, the way that this works is that we walk down\n-        // the pattern, constructing a cmt that represents the path\n-        // that will be taken to reach the value being matched.\n-        //\n-        // When we encounter named bindings, we take the cmt that has\n-        // been built up and pass it off to guarantee_valid() so that\n-        // we can be sure that the binding will remain valid for the\n-        // duration of the arm.\n-        //\n-        // (*2) There is subtlety concerning the correspondence between\n-        // pattern ids and types as compared to *expression* ids and\n-        // types. This is explained briefly. on the definition of the\n-        // type `cmt`, so go off and read what it says there, then\n-        // come back and I'll dive into a bit more detail here. :) OK,\n-        // back?\n-        //\n-        // In general, the id of the cmt should be the node that\n-        // \"produces\" the value---patterns aren't executable code\n-        // exactly, but I consider them to \"execute\" when they match a\n-        // value, and I consider them to produce the value that was\n-        // matched. So if you have something like:\n-        //\n-        // (FIXME: `@@3` is not legal code anymore!)\n-        //\n-        //     let x = @@3;\n-        //     match x {\n-        //       @@y { ... }\n-        //     }\n-        //\n-        // In this case, the cmt and the relevant ids would be:\n-        //\n-        //     CMT             Id                  Type of Id Type of cmt\n+        // Here, `place` is the `Place` being matched and pat is the pattern it\n+        // is being matched against.\n         //\n-        //     local(x)->@->@\n-        //     ^~~~~~~^        `x` from discr      @@int      @@int\n-        //     ^~~~~~~~~~^     `@@y` pattern node  @@int      @int\n-        //     ^~~~~~~~~~~~~^  `@y` pattern node   @int       int\n-        //\n-        // You can see that the types of the id and the cmt are in\n-        // sync in the first line, because that id is actually the id\n-        // of an expression. But once we get to pattern ids, the types\n-        // step out of sync again. So you'll see below that we always\n-        // get the type of the *subpattern* and use that.\n+        // In general, the way that this works is that we walk down the pattern,\n+        // constructing a `Place` that represents the path that will be taken\n+        // to reach the value being matched.\n \n-        debug!(\"cat_pattern(pat={:?}, cmt={:?})\", pat, cmt);\n+        debug!(\"cat_pattern(pat={:?}, place={:?})\", pat, place);\n \n-        // If (pattern) adjustments are active for this pattern, adjust the `cmt` correspondingly.\n-        // `cmt`s are constructed differently from patterns. For example, in\n+        // If (pattern) adjustments are active for this pattern, adjust the `Place` correspondingly.\n+        // `Place`s are constructed differently from patterns. For example, in\n         //\n         // ```\n         // match foo {\n@@ -1073,13 +592,13 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         // ```\n         //\n         // the pattern `&&Some(x,)` is represented as `Ref { Ref { TupleStruct }}`. To build the\n-        // corresponding `cmt` we start with a `cmt` for `foo`, and then, by traversing the\n+        // corresponding `Place` we start with the `Place` for `foo`, and then, by traversing the\n         // pattern, try to answer the question: given the address of `foo`, how is `x` reached?\n         //\n-        // `&&Some(x,)` `cmt_foo`\n-        //  `&Some(x,)` `deref { cmt_foo}`\n-        //   `Some(x,)` `deref { deref { cmt_foo }}`\n-        //        (x,)` `field0 { deref { deref { cmt_foo }}}` <- resulting cmt\n+        // `&&Some(x,)` `place_foo`\n+        //  `&Some(x,)` `deref { place_foo}`\n+        //   `Some(x,)` `deref { deref { place_foo }}`\n+        //        (x,)` `field0 { deref { deref { place_foo }}}` <- resulting cmt\n         //\n         // The above example has no adjustments. If the code were instead the (after adjustments,\n         // equivalent) version\n@@ -1091,20 +610,20 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         // }\n         // ```\n         //\n-        // Then we see that to get the same result, we must start with `deref { deref { cmt_foo }}`\n-        // instead of `cmt_foo` since the pattern is now `Some(x,)` and not `&&Some(x,)`, even\n-        // though its assigned type is that of `&&Some(x,)`.\n+        // Then we see that to get the same result, we must start with\n+        // `deref { deref { place_foo }}` instead of `place_foo` since the pattern is now `Some(x,)`\n+        // and not `&&Some(x,)`, even though its assigned type is that of `&&Some(x,)`.\n         for _ in 0..self.tables\n                         .pat_adjustments()\n                         .get(pat.hir_id)\n                         .map(|v| v.len())\n                         .unwrap_or(0)\n         {\n-            debug!(\"cat_pattern: applying adjustment to cmt={:?}\", cmt);\n-            cmt = Rc::new(self.cat_deref(pat, cmt, NoteNone)?);\n+            debug!(\"cat_pattern: applying adjustment to place={:?}\", place);\n+            place = self.cat_deref(pat, place)?;\n         }\n-        let cmt = cmt; // lose mutability\n-        debug!(\"cat_pattern: applied adjustment derefs to get cmt={:?}\", cmt);\n+        let place = place; // lose mutability\n+        debug!(\"cat_pattern: applied adjustment derefs to get place={:?}\", place);\n \n         // Invoke the callback, but only now, after the `cmt` has adjusted.\n         //\n@@ -1115,138 +634,65 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         // `Some(x)` (which matches). Recursing once more, `*&Some(3)` and the pattern `Some(x)`\n         // result in the cmt `Downcast<Some>(*&Some(3)).0` associated to `x` and invoke `op` with\n         // that (where the `ref` on `x` is implied).\n-        op(cmt.clone(), pat);\n+        op(&place, pat);\n \n         match pat.kind {\n-            PatKind::TupleStruct(ref qpath, ref subpats, ddpos) => {\n-                let res = self.tables.qpath_res(qpath, pat.hir_id);\n-                let (cmt, expected_len) = match res {\n-                    Res::Err => {\n-                        debug!(\"access to unresolvable pattern {:?}\", pat);\n-                        return Err(())\n-                    }\n-                    Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), variant_ctor_did) => {\n-                        let variant_did = self.tcx().parent(variant_ctor_did).unwrap();\n-                        let enum_did = self.tcx().parent(variant_did).unwrap();\n-                        (self.cat_downcast_if_needed(pat, cmt, variant_did),\n-                         self.tcx().adt_def(enum_did)\n-                             .variant_with_ctor_id(variant_ctor_did).fields.len())\n-                    }\n-                    Res::Def(DefKind::Ctor(CtorOf::Struct, CtorKind::Fn), _)\n-                    | Res::SelfCtor(..) => {\n-                        let ty = self.pat_ty_unadjusted(&pat)?;\n-                        match ty.kind {\n-                            ty::Adt(adt_def, _) => {\n-                                (cmt, adt_def.non_enum_variant().fields.len())\n-                            }\n-                            _ => {\n-                                span_bug!(pat.span,\n-                                          \"tuple struct pattern unexpected type {:?}\", ty);\n-                            }\n-                        }\n-                    }\n-                    def => {\n-                        debug!(\n-                            \"tuple struct pattern didn't resolve to variant or struct {:?} at {:?}\",\n-                            def,\n-                            pat.span,\n-                        );\n-                        self.tcx().sess.delay_span_bug(pat.span, &format!(\n-                            \"tuple struct pattern didn't resolve to variant or struct {:?}\",\n-                            def,\n-                        ));\n-                        return Err(());\n-                    }\n-                };\n-\n-                for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n-                    let subpat_ty = self.pat_ty_adjusted(&subpat)?; // see (*2)\n-                    let interior = InteriorField(FieldIndex(i, sym::integer(i)));\n-                    let subcmt = Rc::new(\n-                        self.cat_imm_interior(pat, cmt.clone(), subpat_ty, interior));\n-                    self.cat_pattern_(subcmt, &subpat, op)?;\n+            PatKind::TupleStruct(_, ref subpats, _)\n+            | PatKind::Tuple(ref subpats, _) => {\n+                // S(p1, ..., pN) or (p1, ..., pN)\n+                for subpat in subpats.iter() {\n+                    let subpat_ty = self.pat_ty_adjusted(&subpat)?;\n+                    let sub_place = self.cat_projection(pat, place.clone(), subpat_ty);\n+                    self.cat_pattern_(sub_place, &subpat, op)?;\n                 }\n             }\n \n-            PatKind::Struct(ref qpath, ref field_pats, _) => {\n-                // {f1: p1, ..., fN: pN}\n-                let res = self.tables.qpath_res(qpath, pat.hir_id);\n-                let cmt = match res {\n-                    Res::Err => {\n-                        debug!(\"access to unresolvable pattern {:?}\", pat);\n-                        return Err(())\n-                    }\n-                    Res::Def(DefKind::Ctor(CtorOf::Variant, _), variant_ctor_did) => {\n-                        let variant_did = self.tcx().parent(variant_ctor_did).unwrap();\n-                        self.cat_downcast_if_needed(pat, cmt, variant_did)\n-                    }\n-                    Res::Def(DefKind::Variant, variant_did) => {\n-                        self.cat_downcast_if_needed(pat, cmt, variant_did)\n-                    }\n-                    _ => cmt,\n-                };\n-\n+            PatKind::Struct(_, ref field_pats, _) => {\n+                // S { f1: p1, ..., fN: pN }\n                 for fp in field_pats {\n-                    let field_ty = self.pat_ty_adjusted(&fp.pat)?; // see (*2)\n-                    let f_index = self.tcx().field_index(fp.hir_id, self.tables);\n-                    let cmt_field = Rc::new(self.cat_field(pat, cmt.clone(), f_index,\n-                                                           fp.ident, field_ty));\n+                    let field_ty = self.pat_ty_adjusted(&fp.pat)?;\n+                    let cmt_field = self.cat_projection(pat, place.clone(), field_ty);\n                     self.cat_pattern_(cmt_field, &fp.pat, op)?;\n                 }\n             }\n \n             PatKind::Or(ref pats) => {\n                 for pat in pats {\n-                    self.cat_pattern_(cmt.clone(), &pat, op)?;\n+                    self.cat_pattern_(place.clone(), &pat, op)?;\n                 }\n             }\n \n             PatKind::Binding(.., Some(ref subpat)) => {\n-                self.cat_pattern_(cmt, &subpat, op)?;\n-            }\n-\n-            PatKind::Tuple(ref subpats, ddpos) => {\n-                // (p1, ..., pN)\n-                let ty = self.pat_ty_unadjusted(&pat)?;\n-                let expected_len = match ty.kind {\n-                    ty::Tuple(ref tys) => tys.len(),\n-                    _ => span_bug!(pat.span, \"tuple pattern unexpected type {:?}\", ty),\n-                };\n-                for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n-                    let subpat_ty = self.pat_ty_adjusted(&subpat)?; // see (*2)\n-                    let interior = InteriorField(FieldIndex(i, sym::integer(i)));\n-                    let subcmt = Rc::new(\n-                        self.cat_imm_interior(pat, cmt.clone(), subpat_ty, interior));\n-                    self.cat_pattern_(subcmt, &subpat, op)?;\n-                }\n+                self.cat_pattern_(place, &subpat, op)?;\n             }\n \n             PatKind::Box(ref subpat) | PatKind::Ref(ref subpat, _) => {\n                 // box p1, &p1, &mut p1.  we can ignore the mutability of\n                 // PatKind::Ref since that information is already contained\n                 // in the type.\n-                let subcmt = Rc::new(self.cat_deref(pat, cmt, NoteNone)?);\n-                self.cat_pattern_(subcmt, &subpat, op)?;\n+                let subplace = self.cat_deref(pat, place)?;\n+                self.cat_pattern_(subplace, &subpat, op)?;\n             }\n \n             PatKind::Slice(ref before, ref slice, ref after) => {\n-                let element_ty = match cmt.ty.builtin_index() {\n+                let element_ty = match place.ty.builtin_index() {\n                     Some(ty) => ty,\n                     None => {\n-                        debug!(\"explicit index of non-indexable type {:?}\", cmt);\n+                        debug!(\"explicit index of non-indexable type {:?}\", place);\n                         return Err(());\n                     }\n                 };\n-                let context = InteriorOffsetKind::Pattern;\n-                let elt_cmt = Rc::new(self.cat_index(pat, cmt, element_ty, context)?);\n+                let elt_place = self.cat_projection(pat, place.clone(), element_ty);\n                 for before_pat in before {\n-                    self.cat_pattern_(elt_cmt.clone(), &before_pat, op)?;\n+                    self.cat_pattern_(elt_place.clone(), &before_pat, op)?;\n                 }\n                 if let Some(ref slice_pat) = *slice {\n-                    self.cat_pattern_(elt_cmt.clone(), &slice_pat, op)?;\n+                    let slice_pat_ty = self.pat_ty_adjusted(&slice_pat)?;\n+                    let slice_place = self.cat_projection(pat, place, slice_pat_ty);\n+                    self.cat_pattern_(slice_place, &slice_pat, op)?;\n                 }\n                 for after_pat in after {\n-                    self.cat_pattern_(elt_cmt.clone(), &after_pat, op)?;\n+                    self.cat_pattern_(elt_place.clone(), &after_pat, op)?;\n                 }\n             }\n \n@@ -1259,197 +705,3 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         Ok(())\n     }\n }\n-\n-#[derive(Clone, Debug)]\n-pub enum Aliasability {\n-    FreelyAliasable(AliasableReason),\n-    NonAliasable,\n-    ImmutableUnique(Box<Aliasability>),\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum AliasableReason {\n-    AliasableBorrowed,\n-    AliasableStatic,\n-    AliasableStaticMut,\n-}\n-\n-impl<'tcx> Place<'tcx> {\n-    pub fn guarantor(&self) -> Place<'tcx> {\n-        //! Returns `self` after stripping away any derefs or\n-        //! interior content. The return value is basically the `cmt` which\n-        //! determines how long the value in `self` remains live.\n-\n-        match self.cat {\n-            Categorization::Rvalue |\n-            Categorization::StaticItem |\n-            Categorization::ThreadLocal |\n-            Categorization::Local(..) |\n-            Categorization::Deref(_, UnsafePtr(..)) |\n-            Categorization::Deref(_, BorrowedPtr(..)) |\n-            Categorization::Upvar(..) => {\n-                (*self).clone()\n-            }\n-            Categorization::Downcast(ref b, _) |\n-            Categorization::Interior(ref b, _) |\n-            Categorization::Deref(ref b, Unique) => {\n-                b.guarantor()\n-            }\n-        }\n-    }\n-\n-    /// Returns `FreelyAliasable(_)` if this place represents a freely aliasable pointer type.\n-    pub fn freely_aliasable(&self) -> Aliasability {\n-        // Maybe non-obvious: copied upvars can only be considered\n-        // non-aliasable in once closures, since any other kind can be\n-        // aliased and eventually recused.\n-\n-        match self.cat {\n-            Categorization::Deref(ref b, BorrowedPtr(ty::MutBorrow, _)) |\n-            Categorization::Deref(ref b, BorrowedPtr(ty::UniqueImmBorrow, _)) |\n-            Categorization::Deref(ref b, Unique) |\n-            Categorization::Downcast(ref b, _) |\n-            Categorization::Interior(ref b, _) => {\n-                // Aliasability depends on base cmt\n-                b.freely_aliasable()\n-            }\n-\n-            Categorization::Rvalue |\n-            Categorization::ThreadLocal |\n-            Categorization::Local(..) |\n-            Categorization::Upvar(..) |\n-            Categorization::Deref(_, UnsafePtr(..)) => { // yes, it's aliasable, but...\n-                NonAliasable\n-            }\n-\n-            Categorization::StaticItem => {\n-                if self.mutbl.is_mutable() {\n-                    FreelyAliasable(AliasableStaticMut)\n-                } else {\n-                    FreelyAliasable(AliasableStatic)\n-                }\n-            }\n-\n-            Categorization::Deref(_, BorrowedPtr(ty::ImmBorrow, _)) => {\n-                FreelyAliasable(AliasableBorrowed)\n-            }\n-        }\n-    }\n-\n-    // Digs down through one or two layers of deref and grabs the\n-    // Categorization of the cmt for the upvar if a note indicates there is\n-    // one.\n-    pub fn upvar_cat(&self) -> Option<&Categorization<'tcx>> {\n-        match self.note {\n-            NoteClosureEnv(..) | NoteUpvarRef(..) => {\n-                Some(match self.cat {\n-                    Categorization::Deref(ref inner, _) => {\n-                        match inner.cat {\n-                            Categorization::Deref(ref inner, _) => &inner.cat,\n-                            Categorization::Upvar(..) => &inner.cat,\n-                            _ => bug!()\n-                        }\n-                    }\n-                    _ => bug!()\n-                })\n-            }\n-            NoteIndex | NoteNone => None\n-        }\n-    }\n-\n-    pub fn descriptive_string(&self, tcx: TyCtxt<'_>) -> Cow<'static, str> {\n-        match self.cat {\n-            Categorization::StaticItem => {\n-                \"static item\".into()\n-            }\n-            Categorization::ThreadLocal => {\n-                \"thread-local static item\".into()\n-            }\n-            Categorization::Rvalue => {\n-                \"non-place\".into()\n-            }\n-            Categorization::Local(vid) => {\n-                if tcx.hir().is_argument(vid) {\n-                    \"argument\"\n-                } else {\n-                    \"local variable\"\n-                }.into()\n-            }\n-            Categorization::Deref(_, pk) => {\n-                match self.upvar_cat() {\n-                    Some(&Categorization::Upvar(ref var)) => {\n-                        var.to_string().into()\n-                    }\n-                    Some(_) => bug!(),\n-                    None => {\n-                        match pk {\n-                            Unique => {\n-                                \"`Box` content\"\n-                            }\n-                            UnsafePtr(..) => {\n-                                \"dereference of raw pointer\"\n-                            }\n-                            BorrowedPtr(..) => {\n-                                match self.note {\n-                                    NoteIndex => \"indexed content\",\n-                                    _ => \"borrowed content\"\n-                                }\n-                            }\n-                        }.into()\n-                    }\n-                }\n-            }\n-            Categorization::Interior(_, InteriorField(..)) => {\n-                \"field\".into()\n-            }\n-            Categorization::Interior(_, InteriorElement(InteriorOffsetKind::Index)) => {\n-                \"indexed content\".into()\n-            }\n-            Categorization::Interior(_, InteriorElement(InteriorOffsetKind::Pattern)) => {\n-                \"pattern-bound indexed content\".into()\n-            }\n-            Categorization::Upvar(ref var) => {\n-                var.to_string().into()\n-            }\n-            Categorization::Downcast(ref cmt, _) => {\n-                cmt.descriptive_string(tcx).into()\n-            }\n-        }\n-    }\n-}\n-\n-pub fn ptr_sigil(ptr: PointerKind<'_>) -> &'static str {\n-    match ptr {\n-        Unique => \"Box\",\n-        BorrowedPtr(ty::ImmBorrow, _) => \"&\",\n-        BorrowedPtr(ty::MutBorrow, _) => \"&mut\",\n-        BorrowedPtr(ty::UniqueImmBorrow, _) => \"&unique\",\n-        UnsafePtr(_) => \"*\",\n-    }\n-}\n-\n-impl fmt::Debug for InteriorKind {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            InteriorField(FieldIndex(_, info)) => write!(f, \"{}\", info),\n-            InteriorElement(..) => write!(f, \"[]\"),\n-        }\n-    }\n-}\n-\n-impl fmt::Debug for Upvar {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{:?}/{:?}\", self.id, self.kind)\n-    }\n-}\n-\n-impl fmt::Display for Upvar {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let kind = match self.kind {\n-            ty::ClosureKind::Fn => \"Fn\",\n-            ty::ClosureKind::FnMut => \"FnMut\",\n-            ty::ClosureKind::FnOnce => \"FnOnce\",\n-        };\n-        write!(f, \"captured outer variable in an `{}` closure\", kind)\n-    }\n-}"}, {"sha": "7666db3ecd0d17308397292f2d13936977361ca2", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 118, "deletions": 140, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/1d53e437442b44b5c530c45cf9fdfd595ad715b1/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d53e437442b44b5c530c45cf9fdfd595ad715b1/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=1d53e437442b44b5c530c45cf9fdfd595ad715b1", "patch": "@@ -75,7 +75,6 @@\n use crate::check::dropck;\n use crate::check::FnCtxt;\n use crate::middle::mem_categorization as mc;\n-use crate::middle::mem_categorization::Categorization;\n use crate::middle::region;\n use rustc::hir::def_id::DefId;\n use rustc::infer::outlives::env::OutlivesEnvironment;\n@@ -88,7 +87,6 @@ use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::hir::{self, PatKind};\n use std::mem;\n use std::ops::Deref;\n-use std::rc::Rc;\n use syntax_pos::Span;\n \n // a variation on try that just returns unit\n@@ -898,10 +896,6 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n             }\n \n             cmt = self.with_mc(|mc| mc.cat_expr_adjusted(expr, cmt, &adjustment))?;\n-\n-            if let Categorization::Deref(_, mc::BorrowedPtr(_, r_ptr)) = cmt.cat {\n-                self.mk_subregion_due_to_dereference(expr.span, expr_region, r_ptr);\n-            }\n         }\n \n         Ok(cmt)\n@@ -920,16 +914,22 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         )\n     }\n \n-    fn check_safety_of_rvalue_destructor_if_necessary(&mut self, cmt: &mc::Place<'tcx>, span: Span) {\n-        if let Categorization::Rvalue = cmt.cat {\n-            let typ = self.resolve_type(cmt.ty);\n-            let body_id = self.body_id;\n-            let _ = dropck::check_drop_obligations(\n-                self,\n-                typ,\n-                span,\n-                body_id,\n-            );\n+    fn check_safety_of_rvalue_destructor_if_necessary(\n+        &mut self,\n+        place: &mc::Place<'tcx>,\n+        span: Span,\n+    ) {\n+        if let mc::PlaceBase::Rvalue = place.base {\n+            if place.projections.is_empty() {\n+                let typ = self.resolve_type(place.ty);\n+                let body_id = self.body_id;\n+                let _ = dropck::check_drop_obligations(\n+                    self,\n+                    typ,\n+                    span,\n+                    body_id,\n+                );\n+            }\n         }\n     }\n \n@@ -1034,7 +1034,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n             }\n             Some(ref expr) => &**expr,\n         };\n-        let discr_cmt = Rc::new(ignore_err!(self.with_mc(|mc| mc.cat_expr(init_expr))));\n+        let discr_cmt = ignore_err!(self.with_mc(|mc| mc.cat_expr(init_expr)));\n         self.link_pattern(discr_cmt, &local.pat);\n     }\n \n@@ -1043,7 +1043,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     /// linked to the lifetime of its guarantor (if any).\n     fn link_match(&self, discr: &hir::Expr, arms: &[hir::Arm]) {\n         debug!(\"regionck::for_match()\");\n-        let discr_cmt = Rc::new(ignore_err!(self.with_mc(|mc| mc.cat_expr(discr))));\n+        let discr_cmt = ignore_err!(self.with_mc(|mc| mc.cat_expr(discr)));\n         debug!(\"discr_cmt={:?}\", discr_cmt);\n         for arm in arms {\n             self.link_pattern(discr_cmt.clone(), &arm.pat);\n@@ -1057,7 +1057,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         for param in params {\n             let param_ty = self.node_ty(param.hir_id);\n             let param_cmt = self.with_mc(|mc| {\n-                Rc::new(mc.cat_rvalue(param.hir_id, param.pat.span, param_ty))\n+                mc.cat_rvalue(param.hir_id, param.pat.span, param_ty)\n             });\n             debug!(\"param_ty={:?} param_cmt={:?} param={:?}\", param_ty, param_cmt, param);\n             self.link_pattern(param_cmt, &param.pat);\n@@ -1066,7 +1066,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n     /// Link lifetimes of any ref bindings in `root_pat` to the pointers found\n     /// in the discriminant, if needed.\n-    fn link_pattern(&self, discr_cmt: mc::cmt<'tcx>, root_pat: &hir::Pat) {\n+    fn link_pattern(&self, discr_cmt: mc::Place<'tcx>, root_pat: &hir::Pat) {\n         debug!(\n             \"link_pattern(discr_cmt={:?}, root_pat={:?})\",\n             discr_cmt, root_pat\n@@ -1152,61 +1152,35 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         span: Span,\n         borrow_region: ty::Region<'tcx>,\n         borrow_kind: ty::BorrowKind,\n-        borrow_cmt: &mc::Place<'tcx>,\n+        borrow_place: &mc::Place<'tcx>,\n     ) {\n-        let origin = infer::DataBorrowed(borrow_cmt.ty, span);\n-        self.type_must_outlive(origin, borrow_cmt.ty, borrow_region);\n-\n-        let mut borrow_kind = borrow_kind;\n-        let mut borrow_cmt_cat = borrow_cmt.cat.clone();\n+        let origin = infer::DataBorrowed(borrow_place.ty, span);\n+        self.type_must_outlive(origin, borrow_place.ty, borrow_region);\n \n-        loop {\n+        for pointer_ty in borrow_place.deref_tys() {\n             debug!(\n-                \"link_region(borrow_region={:?}, borrow_kind={:?}, borrow_cmt={:?})\",\n-                borrow_region, borrow_kind, borrow_cmt\n+                \"link_region(borrow_region={:?}, borrow_kind={:?}, pointer_ty={:?})\",\n+                borrow_region, borrow_kind, borrow_place\n             );\n-            match borrow_cmt_cat {\n-                Categorization::Deref(ref_cmt, mc::BorrowedPtr(ref_kind, ref_region)) => {\n-                    match self.link_reborrowed_region(\n+            match pointer_ty.kind {\n+                ty::RawPtr(_) => return,\n+                ty::Ref(ref_region, _, ref_mutability) => {\n+                    if self.link_reborrowed_region(\n                         span,\n                         borrow_region,\n-                        borrow_kind,\n-                        ref_cmt,\n                         ref_region,\n-                        ref_kind,\n-                        borrow_cmt.note,\n+                        ref_mutability,\n                     ) {\n-                        Some((c, k)) => {\n-                            borrow_cmt_cat = c.cat.clone();\n-                            borrow_kind = k;\n-                        }\n-                        None => {\n-                            return;\n-                        }\n+                        return;\n                     }\n-                }\n \n-                Categorization::Downcast(cmt_base, _)\n-                | Categorization::Deref(cmt_base, mc::Unique)\n-                | Categorization::Interior(cmt_base, _) => {\n-                    // Borrowing interior or owned data requires the base\n-                    // to be valid and borrowable in the same fashion.\n-                    borrow_cmt_cat = cmt_base.cat.clone();\n-                    borrow_kind = borrow_kind;\n-                }\n-\n-                Categorization::Deref(_, mc::UnsafePtr(..))\n-                | Categorization::StaticItem\n-                | Categorization::Upvar(..)\n-                | Categorization::Local(..)\n-                | Categorization::ThreadLocal\n-                | Categorization::Rvalue => {\n-                    // These are all \"base cases\" with independent lifetimes\n-                    // that are not subject to inference\n-                    return;\n                 }\n+                _ => assert!(pointer_ty.is_box(), \"unexpected built-in deref type {}\", pointer_ty)\n             }\n         }\n+        if let mc::PlaceBase::Upvar(upvar_id) = borrow_place.base {\n+            self.link_upvar_region(span, borrow_region, upvar_id);\n+        }\n     }\n \n     /// This is the most complicated case: the path being borrowed is\n@@ -1230,83 +1204,28 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     ///\n     /// Here `bk` stands for some borrow-kind (e.g., `mut`, `uniq`, etc).\n     ///\n-    /// Unfortunately, there are some complications beyond the simple\n-    /// scenario I just painted:\n+    /// There is a complication beyond the simple scenario I just painted: there\n+    /// may in fact be more levels of reborrowing. In the example, I said the\n+    /// borrow was like `&'z *r`, but it might in fact be a borrow like\n+    /// `&'z **q` where `q` has type `&'a &'b mut T`. In that case, we want to\n+    /// ensure that `'z <= 'a` and `'z <= 'b`.\n     ///\n-    /// 1. The reference `r` might in fact be a \"by-ref\" upvar. In that\n-    ///    case, we have two jobs. First, we are inferring whether this reference\n-    ///    should be an `&T`, `&mut T`, or `&uniq T` reference, and we must\n-    ///    adjust that based on this borrow (e.g., if this is an `&mut` borrow,\n-    ///    then `r` must be an `&mut` reference). Second, whenever we link\n-    ///    two regions (here, `'z <= 'a`), we supply a *cause*, and in this\n-    ///    case we adjust the cause to indicate that the reference being\n-    ///    \"reborrowed\" is itself an upvar. This provides a nicer error message\n-    ///    should something go wrong.\n+    /// The return value of this function indicates whether we *don't* need to\n+    /// the recurse to the next reference up.\n     ///\n-    /// 2. There may in fact be more levels of reborrowing. In the\n-    ///    example, I said the borrow was like `&'z *r`, but it might\n-    ///    in fact be a borrow like `&'z **q` where `q` has type `&'a\n-    ///    &'b mut T`. In that case, we want to ensure that `'z <= 'a`\n-    ///    and `'z <= 'b`. This is explained more below.\n-    ///\n-    /// The return value of this function indicates whether we need to\n-    /// recurse and process `ref_cmt` (see case 2 above).\n+    /// This is explained more below.\n     fn link_reborrowed_region(\n         &self,\n         span: Span,\n         borrow_region: ty::Region<'tcx>,\n-        borrow_kind: ty::BorrowKind,\n-        ref_cmt: mc::cmt<'tcx>,\n         ref_region: ty::Region<'tcx>,\n-        mut ref_kind: ty::BorrowKind,\n-        note: mc::Note,\n-    ) -> Option<(mc::cmt<'tcx>, ty::BorrowKind)> {\n-        // Possible upvar ID we may need later to create an entry in the\n-        // maybe link map.\n-\n-        // Detect by-ref upvar `x`:\n-        let cause = match note {\n-            mc::NoteUpvarRef(ref upvar_id) => {\n-                match self.tables.borrow().upvar_capture_map.get(upvar_id) {\n-                    Some(&ty::UpvarCapture::ByRef(ref upvar_borrow)) => {\n-                        // The mutability of the upvar may have been modified\n-                        // by the above adjustment, so update our local variable.\n-                        ref_kind = upvar_borrow.kind;\n-\n-                        infer::ReborrowUpvar(span, *upvar_id)\n-                    }\n-                    _ => {\n-                        span_bug!(span, \"Illegal upvar id: {:?}\", upvar_id);\n-                    }\n-                }\n-            }\n-            mc::NoteClosureEnv(ref upvar_id) => {\n-                // We don't have any mutability changes to propagate, but\n-                // we do want to note that an upvar reborrow caused this\n-                // link\n-                infer::ReborrowUpvar(span, *upvar_id)\n-            }\n-            _ => infer::Reborrow(span),\n-        };\n-\n+        ref_mutability: hir::Mutability,\n+    ) -> bool {\n         debug!(\n             \"link_reborrowed_region: {:?} <= {:?}\",\n             borrow_region, ref_region\n         );\n-        self.sub_regions(cause, borrow_region, ref_region);\n-\n-        // If we end up needing to recurse and establish a region link\n-        // with `ref_cmt`, calculate what borrow kind we will end up\n-        // needing. This will be used below.\n-        //\n-        // One interesting twist is that we can weaken the borrow kind\n-        // when we recurse: to reborrow an `&mut` referent as mutable,\n-        // borrowck requires a unique path to the `&mut` reference but not\n-        // necessarily a *mutable* path.\n-        let new_borrow_kind = match borrow_kind {\n-            ty::ImmBorrow => ty::ImmBorrow,\n-            ty::MutBorrow | ty::UniqueImmBorrow => ty::UniqueImmBorrow,\n-        };\n+        self.sub_regions(infer::Reborrow(span), borrow_region, ref_region);\n \n         // Decide whether we need to recurse and link any regions within\n         // the `ref_cmt`. This is concerned for the case where the value\n@@ -1335,24 +1254,83 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         // (Note that since we have not examined `ref_cmt.cat`, we don't\n         // know whether this scenario has occurred; but I wanted to show\n         // how all the types get adjusted.)\n-        match ref_kind {\n-            ty::ImmBorrow => {\n+        match ref_mutability {\n+            hir::Mutability::Immutable => {\n                 // The reference being reborrowed is a shareable ref of\n                 // type `&'a T`. In this case, it doesn't matter where we\n                 // *found* the `&T` pointer, the memory it references will\n                 // be valid and immutable for `'a`. So we can stop here.\n-                //\n-                // (Note that the `borrow_kind` must also be ImmBorrow or\n-                // else the user is borrowed imm memory as mut memory,\n-                // which means they'll get an error downstream in borrowck\n-                // anyhow.)\n-                return None;\n+                true\n             }\n \n-            ty::MutBorrow | ty::UniqueImmBorrow => {\n-                // The reference being reborrowed is either an `&mut T` or\n-                // `&uniq T`. This is the case where recursion is needed.\n-                return Some((ref_cmt, new_borrow_kind));\n+            hir::Mutability::Mutable => {\n+                // The reference being reborrowed is either an `&mut T`. This is\n+                // the case where recursion is needed.\n+                false\n+            }\n+        }\n+    }\n+\n+    /// An upvar may be behind up to 2 references:\n+    ///\n+    /// * One can come from the reference to a \"by-reference\" upvar.\n+    /// * Another one can come from the reference to the closure itself if it's\n+    ///   a `FnMut` or `Fn` closure.\n+    ///\n+    /// This function links the lifetimes of those references to the lifetime\n+    /// of the borrow that's provided. See [link_reborrowed_region] for some\n+    /// more explanation of this in the general case.\n+    ///\n+    /// We also supply a *cause*, and in this case we set the cause to\n+    /// indicate that the reference being \"reborrowed\" is itself an upvar. This\n+    /// provides a nicer error message should something go wrong.\n+    fn link_upvar_region(\n+        &self,\n+        span: Span,\n+        borrow_region: ty::Region<'tcx>,\n+        upvar_id: ty::UpvarId,\n+    ) {\n+        debug!(\"link_upvar_region(borrorw_region={:?}, upvar_id={:?}\", borrow_region, upvar_id);\n+        // A by-reference upvar can't be borrowed for longer than the\n+        // upvar is borrowed from the environment.\n+        match self.tables.borrow().upvar_capture(upvar_id) {\n+            ty::UpvarCapture::ByRef(upvar_borrow) => {\n+                self.sub_regions(\n+                    infer::ReborrowUpvar(span, upvar_id),\n+                    borrow_region,\n+                    upvar_borrow.region,\n+                );\n+                if let ty::ImmBorrow = upvar_borrow.kind {\n+                    debug!(\"link_upvar_region: capture by shared ref\");\n+                    return;\n+                }\n+            }\n+            ty::UpvarCapture::ByValue => {}\n+        }\n+        let fn_hir_id = self.tcx.hir().local_def_id_to_hir_id(upvar_id.closure_expr_id);\n+        let ty = self.resolve_node_type(fn_hir_id);\n+        debug!(\"link_upvar_region: ty={:?}\", ty);\n+\n+        // A closure capture can't be borrowed for longer than the\n+        // reference to the closure.\n+        if let ty::Closure(closure_def_id, substs) = ty.kind {\n+            match self.infcx.closure_kind(closure_def_id, substs) {\n+                Some(ty::ClosureKind::Fn) | Some(ty::ClosureKind::FnMut) => {\n+                    // Region of environment pointer\n+                    let env_region = self.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n+                        scope: upvar_id.closure_expr_id.to_def_id(),\n+                        bound_region: ty::BrEnv\n+                    }));\n+                    self.sub_regions(\n+                        infer::ReborrowUpvar(span, upvar_id),\n+                        borrow_region,\n+                        env_region,\n+                    );\n+                }\n+                Some(ty::ClosureKind::FnOnce) => {}\n+                None => {\n+                    span_bug!(span, \"Have not inferred closure kind before regionck\");\n+                }\n             }\n         }\n     }"}, {"sha": "d58a513dcde62b3735db98511453f228c94c7e15", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 68, "deletions": 157, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/1d53e437442b44b5c530c45cf9fdfd595ad715b1/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d53e437442b44b5c530c45cf9fdfd595ad715b1/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=1d53e437442b44b5c530c45cf9fdfd595ad715b1", "patch": "@@ -34,7 +34,7 @@ use super::FnCtxt;\n \n use crate::middle::expr_use_visitor as euv;\n use crate::middle::mem_categorization as mc;\n-use crate::middle::mem_categorization::Categorization;\n+use crate::middle::mem_categorization::PlaceBase;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::def_id::LocalDefId;\n@@ -76,16 +76,14 @@ impl<'a, 'tcx> Visitor<'tcx> for InferBorrowKindVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    /// Analysis starting point.\n     fn analyze_closure(\n         &self,\n         closure_hir_id: hir::HirId,\n         span: Span,\n         body: &hir::Body,\n         capture_clause: hir::CaptureBy,\n     ) {\n-        /*!\n-         * Analysis starting point.\n-         */\n \n         debug!(\n             \"analyze_closure(id={:?}, body.id={:?})\",\n@@ -310,13 +308,10 @@ struct InferBorrowKind<'a, 'tcx> {\n impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n     fn adjust_upvar_borrow_kind_for_consume(\n         &mut self,\n-        cmt: &mc::Place<'tcx>,\n+        place: &mc::Place<'tcx>,\n         mode: euv::ConsumeMode,\n     ) {\n-        debug!(\n-            \"adjust_upvar_borrow_kind_for_consume(cmt={:?}, mode={:?})\",\n-            cmt, mode\n-        );\n+        debug!(\"adjust_upvar_borrow_kind_for_consume(place={:?}, mode={:?})\", place, mode);\n \n         // we only care about moves\n         match mode {\n@@ -327,132 +322,68 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         }\n \n         let tcx = self.fcx.tcx;\n+        let upvar_id = if let PlaceBase::Upvar(upvar_id) = place.base {\n+            upvar_id\n+        } else {\n+            return;\n+        };\n \n-        // watch out for a move of the deref of a borrowed pointer;\n-        // for that to be legal, the upvar would have to be borrowed\n-        // by value instead\n-        let guarantor = cmt.guarantor();\n-        debug!(\n-            \"adjust_upvar_borrow_kind_for_consume: guarantor={:?}\",\n-            guarantor\n-        );\n-        debug!(\n-            \"adjust_upvar_borrow_kind_for_consume: guarantor.cat={:?}\",\n-            guarantor.cat\n-        );\n-        if let Categorization::Deref(_, mc::BorrowedPtr(..)) = guarantor.cat {\n-            debug!(\n-                \"adjust_upvar_borrow_kind_for_consume: found deref with note {:?}\",\n-                cmt.note\n-            );\n-            match guarantor.note {\n-                mc::NoteUpvarRef(upvar_id) => {\n-                    debug!(\n-                        \"adjust_upvar_borrow_kind_for_consume: \\\n-                         setting upvar_id={:?} to by value\",\n-                        upvar_id\n-                    );\n+        debug!(\"adjust_upvar_borrow_kind_for_consume: upvar={:?}\", upvar_id);\n \n-                    // to move out of an upvar, this must be a FnOnce closure\n-                    self.adjust_closure_kind(\n-                        upvar_id.closure_expr_id,\n-                        ty::ClosureKind::FnOnce,\n-                        guarantor.span,\n-                        var_name(tcx, upvar_id.var_path.hir_id),\n-                    );\n+        // To move out of an upvar, this must be a FnOnce closure\n+        self.adjust_closure_kind(\n+            upvar_id.closure_expr_id,\n+            ty::ClosureKind::FnOnce,\n+            place.span,\n+            var_name(tcx, upvar_id.var_path.hir_id),\n+        );\n \n-                    self.adjust_upvar_captures\n-                        .insert(upvar_id, ty::UpvarCapture::ByValue);\n-                }\n-                mc::NoteClosureEnv(upvar_id) => {\n-                    // we get just a closureenv ref if this is a\n-                    // `move` closure, or if the upvar has already\n-                    // been inferred to by-value. In any case, we\n-                    // must still adjust the kind of the closure\n-                    // to be a FnOnce closure to permit moves out\n-                    // of the environment.\n-                    self.adjust_closure_kind(\n-                        upvar_id.closure_expr_id,\n-                        ty::ClosureKind::FnOnce,\n-                        guarantor.span,\n-                        var_name(tcx, upvar_id.var_path.hir_id),\n-                    );\n-                }\n-                mc::NoteIndex | mc::NoteNone => {}\n-            }\n-        }\n+        self.adjust_upvar_captures.insert(upvar_id, ty::UpvarCapture::ByValue);\n     }\n \n     /// Indicates that `cmt` is being directly mutated (e.g., assigned\n-    /// to). If cmt contains any by-ref upvars, this implies that\n-    /// those upvars must be borrowed using an `&mut` borrow.\n-    fn adjust_upvar_borrow_kind_for_mut(&mut self, cmt: &mc::Place<'tcx>) {\n-        debug!(\"adjust_upvar_borrow_kind_for_mut(cmt={:?})\", cmt);\n-\n-        match cmt.cat.clone() {\n-            Categorization::Deref(base, mc::Unique)\n-            | Categorization::Interior(base, _)\n-            | Categorization::Downcast(base, _) => {\n-                // Interior or owned data is mutable if base is\n-                // mutable, so iterate to the base.\n-                self.adjust_upvar_borrow_kind_for_mut(&base);\n-            }\n-\n-            Categorization::Deref(base, mc::BorrowedPtr(..)) => {\n-                if !self.try_adjust_upvar_deref(cmt, ty::MutBorrow) {\n+    /// to). If the place is based on a by-ref upvar, this implies that\n+    /// the upvar must be borrowed using an `&mut` borrow.\n+    fn adjust_upvar_borrow_kind_for_mut(&mut self, place: &mc::Place<'tcx>) {\n+        debug!(\"adjust_upvar_borrow_kind_for_mut(place={:?})\", place);\n+\n+        if let PlaceBase::Upvar(upvar_id) = place.base {\n+            let mut borrow_kind = ty::MutBorrow;\n+            for pointer_ty in place.deref_tys() {\n+                match pointer_ty.kind {\n+                    // Raw pointers don't inherit mutability.\n+                    ty::RawPtr(_) => return,\n                     // assignment to deref of an `&mut`\n                     // borrowed pointer implies that the\n                     // pointer itself must be unique, but not\n                     // necessarily *mutable*\n-                    self.adjust_upvar_borrow_kind_for_unique(&base);\n+                    ty::Ref(.., hir::Mutability::Mutable) => borrow_kind = ty::UniqueImmBorrow,\n+                    _ => (),\n                 }\n             }\n-\n-            Categorization::Deref(_, mc::UnsafePtr(..))\n-            | Categorization::StaticItem\n-            | Categorization::ThreadLocal\n-            | Categorization::Rvalue\n-            | Categorization::Local(_)\n-            | Categorization::Upvar(..) => {\n-                return;\n-            }\n+            self.adjust_upvar_deref(upvar_id, place.span, borrow_kind);\n         }\n     }\n \n-    fn adjust_upvar_borrow_kind_for_unique(&mut self, cmt: &mc::Place<'tcx>) {\n-        debug!(\"adjust_upvar_borrow_kind_for_unique(cmt={:?})\", cmt);\n+    fn adjust_upvar_borrow_kind_for_unique(&mut self, place: &mc::Place<'tcx>) {\n+        debug!(\"adjust_upvar_borrow_kind_for_unique(place={:?})\", place);\n \n-        match cmt.cat.clone() {\n-            Categorization::Deref(base, mc::Unique)\n-            | Categorization::Interior(base, _)\n-            | Categorization::Downcast(base, _) => {\n-                // Interior or owned data is unique if base is\n-                // unique.\n-                self.adjust_upvar_borrow_kind_for_unique(&base);\n-            }\n-\n-            Categorization::Deref(base, mc::BorrowedPtr(..)) => {\n-                if !self.try_adjust_upvar_deref(cmt, ty::UniqueImmBorrow) {\n-                    // for a borrowed pointer to be unique, its\n-                    // base must be unique\n-                    self.adjust_upvar_borrow_kind_for_unique(&base);\n-                }\n+        if let PlaceBase::Upvar(upvar_id) = place.base {\n+            if place.deref_tys().any(ty::TyS::is_unsafe_ptr) {\n+                // Raw pointers don't inherit mutability.\n+                return;\n             }\n-\n-            Categorization::Deref(_, mc::UnsafePtr(..))\n-            | Categorization::StaticItem\n-            | Categorization::ThreadLocal\n-            | Categorization::Rvalue\n-            | Categorization::Local(_)\n-            | Categorization::Upvar(..) => {}\n+            // for a borrowed pointer to be unique, its base must be unique\n+            self.adjust_upvar_deref(upvar_id, place.span, ty::UniqueImmBorrow);\n         }\n     }\n \n-    fn try_adjust_upvar_deref(\n+    fn adjust_upvar_deref(\n         &mut self,\n-        cmt: &mc::Place<'tcx>,\n+        upvar_id: ty::UpvarId,\n+        place_span: Span,\n         borrow_kind: ty::BorrowKind,\n-    ) -> bool {\n+    ) {\n         assert!(match borrow_kind {\n             ty::MutBorrow => true,\n             ty::UniqueImmBorrow => true,\n@@ -463,39 +394,19 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n \n         let tcx = self.fcx.tcx;\n \n-        match cmt.note {\n-            mc::NoteUpvarRef(upvar_id) => {\n-                // if this is an implicit deref of an\n-                // upvar, then we need to modify the\n-                // borrow_kind of the upvar to make sure it\n-                // is inferred to mutable if necessary\n-                self.adjust_upvar_borrow_kind(upvar_id, borrow_kind);\n-\n-                // also need to be in an FnMut closure since this is not an ImmBorrow\n-                self.adjust_closure_kind(\n-                    upvar_id.closure_expr_id,\n-                    ty::ClosureKind::FnMut,\n-                    cmt.span,\n-                    var_name(tcx, upvar_id.var_path.hir_id),\n-                );\n-\n-                true\n-            }\n-            mc::NoteClosureEnv(upvar_id) => {\n-                // this kind of deref occurs in a `move` closure, or\n-                // for a by-value upvar; in either case, to mutate an\n-                // upvar, we need to be an FnMut closure\n-                self.adjust_closure_kind(\n-                    upvar_id.closure_expr_id,\n-                    ty::ClosureKind::FnMut,\n-                    cmt.span,\n-                    var_name(tcx, upvar_id.var_path.hir_id),\n-                );\n-\n-                true\n-            }\n-            mc::NoteIndex | mc::NoteNone => false,\n-        }\n+        // if this is an implicit deref of an\n+        // upvar, then we need to modify the\n+        // borrow_kind of the upvar to make sure it\n+        // is inferred to mutable if necessary\n+        self.adjust_upvar_borrow_kind(upvar_id, borrow_kind);\n+\n+        // also need to be in an FnMut closure since this is not an ImmBorrow\n+        self.adjust_closure_kind(\n+            upvar_id.closure_expr_id,\n+            ty::ClosureKind::FnMut,\n+            place_span,\n+            var_name(tcx, upvar_id.var_path.hir_id),\n+        );\n     }\n \n     /// We infer the borrow_kind with which to borrow upvars in a stack closure.\n@@ -507,7 +418,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         let upvar_capture = self\n             .adjust_upvar_captures\n             .get(&upvar_id)\n-            .cloned()\n+            .copied()\n             .unwrap_or_else(|| self.fcx.tables.borrow().upvar_capture(upvar_id));\n         debug!(\n             \"adjust_upvar_borrow_kind(upvar_id={:?}, upvar_capture={:?}, kind={:?})\",\n@@ -584,29 +495,29 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n-    fn consume(&mut self, cmt: &mc::Place<'tcx>,mode: euv::ConsumeMode) {\n-        debug!(\"consume(cmt={:?},mode={:?})\", cmt, mode);\n-        self.adjust_upvar_borrow_kind_for_consume(cmt, mode);\n+    fn consume(&mut self, place: &mc::Place<'tcx>,mode: euv::ConsumeMode) {\n+        debug!(\"consume(place={:?},mode={:?})\", place, mode);\n+        self.adjust_upvar_borrow_kind_for_consume(place, mode);\n     }\n \n-    fn borrow(&mut self, cmt: &mc::Place<'tcx>, bk: ty::BorrowKind) {\n-        debug!(\"borrow(cmt={:?}, bk={:?})\", cmt, bk);\n+    fn borrow(&mut self, place: &mc::Place<'tcx>, bk: ty::BorrowKind) {\n+        debug!(\"borrow(place={:?}, bk={:?})\", place, bk);\n \n         match bk {\n             ty::ImmBorrow => {}\n             ty::UniqueImmBorrow => {\n-                self.adjust_upvar_borrow_kind_for_unique(cmt);\n+                self.adjust_upvar_borrow_kind_for_unique(place);\n             }\n             ty::MutBorrow => {\n-                self.adjust_upvar_borrow_kind_for_mut(cmt);\n+                self.adjust_upvar_borrow_kind_for_mut(place);\n             }\n         }\n     }\n \n-    fn mutate(&mut self, assignee_cmt: &mc::Place<'tcx>) {\n-        debug!(\"mutate(assignee_cmt={:?})\", assignee_cmt);\n+    fn mutate(&mut self, assignee_place: &mc::Place<'tcx>) {\n+        debug!(\"mutate(assignee_place={:?})\", assignee_place);\n \n-        self.adjust_upvar_borrow_kind_for_mut(assignee_cmt);\n+        self.adjust_upvar_borrow_kind_for_mut(assignee_place);\n     }\n }\n "}, {"sha": "c5914a17cf92486b960fbc488fc6bc2bd85961c3", "filename": "src/test/ui/issues/issue-4335.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d53e437442b44b5c530c45cf9fdfd595ad715b1/src%2Ftest%2Fui%2Fissues%2Fissue-4335.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d53e437442b44b5c530c45cf9fdfd595ad715b1/src%2Ftest%2Fui%2Fissues%2Fissue-4335.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-4335.rs?ref=1d53e437442b44b5c530c45cf9fdfd595ad715b1", "patch": "@@ -4,8 +4,7 @@ fn id<T>(t: T) -> T { t }\n \n fn f<'r, T>(v: &'r T) -> Box<dyn FnMut() -> T + 'r> {\n     id(Box::new(|| *v))\n-        //~^ ERROR E0373\n-        //~| ERROR E0507\n+        //~^ ERROR E0507\n }\n \n fn main() {"}, {"sha": "f187969ff4e86ad8595211ebf3e121b28b02f630", "filename": "src/test/ui/issues/issue-4335.stderr", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1d53e437442b44b5c530c45cf9fdfd595ad715b1/src%2Ftest%2Fui%2Fissues%2Fissue-4335.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d53e437442b44b5c530c45cf9fdfd595ad715b1/src%2Ftest%2Fui%2Fissues%2Fissue-4335.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-4335.stderr?ref=1d53e437442b44b5c530c45cf9fdfd595ad715b1", "patch": "@@ -6,25 +6,6 @@ LL | fn f<'r, T>(v: &'r T) -> Box<dyn FnMut() -> T + 'r> {\n LL |     id(Box::new(|| *v))\n    |                    ^^ move occurs because `*v` has type `T`, which does not implement the `Copy` trait\n \n-error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function\n-  --> $DIR/issue-4335.rs:6:17\n-   |\n-LL |     id(Box::new(|| *v))\n-   |                 ^^  - `v` is borrowed here\n-   |                 |\n-   |                 may outlive borrowed value `v`\n-   |\n-note: closure is returned here\n-  --> $DIR/issue-4335.rs:6:5\n-   |\n-LL |     id(Box::new(|| *v))\n-   |     ^^^^^^^^^^^^^^^^^^^\n-help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword\n-   |\n-LL |     id(Box::new(move || *v))\n-   |                 ^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0373, E0507.\n-For more information about an error, try `rustc --explain E0373`.\n+For more information about this error, try `rustc --explain E0507`."}, {"sha": "005800d50a45725a336e9640605c9bb9a9238896", "filename": "src/test/ui/regions/regions-addr-of-upvar-self.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d53e437442b44b5c530c45cf9fdfd595ad715b1/src%2Ftest%2Fui%2Fregions%2Fregions-addr-of-upvar-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d53e437442b44b5c530c45cf9fdfd595ad715b1/src%2Ftest%2Fui%2Fregions%2Fregions-addr-of-upvar-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-addr-of-upvar-self.stderr?ref=1d53e437442b44b5c530c45cf9fdfd595ad715b1", "patch": "@@ -9,7 +9,7 @@ note: first, the lifetime cannot outlive the lifetime `'_` as defined on the bod\n    |\n LL |         let _f = || {\n    |                  ^^\n-note: ...so that reference does not outlive borrowed content\n+note: ...so that closure can access `self`\n   --> $DIR/regions-addr-of-upvar-self.rs:10:41\n    |\n LL |             let p: &'static mut usize = &mut self.food;"}, {"sha": "68ec8d2ba8287c4c98a2139f40490a8a8e1d621a", "filename": "src/test/ui/unboxed-closures/unboxed-closures-infer-fn-once-move-from-projection.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d53e437442b44b5c530c45cf9fdfd595ad715b1/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fn-once-move-from-projection.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d53e437442b44b5c530c45cf9fdfd595ad715b1/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fn-once-move-from-projection.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fn-once-move-from-projection.stderr?ref=1d53e437442b44b5c530c45cf9fdfd595ad715b1", "patch": "@@ -2,7 +2,7 @@ error[E0525]: expected a closure that implements the `Fn` trait, but this closur\n   --> $DIR/unboxed-closures-infer-fn-once-move-from-projection.rs:14:13\n    |\n LL |     let c = || drop(y.0);\n-   |             ^^^^^^^^-^^^\n+   |             ^^^^^^^^---^\n    |             |       |\n    |             |       closure is `FnOnce` because it moves the variable `y` out of its environment\n    |             this closure implements `FnOnce`, not `Fn`"}]}