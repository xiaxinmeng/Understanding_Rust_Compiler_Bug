{"sha": "b5a2d27f8f59df6f2162e61461b41d6116d4815e", "node_id": "C_kwDOAAsO6NoAKGI1YTJkMjdmOGY1OWRmNmYyMTYyZTYxNDYxYjQxZDYxMTZkNDgxNWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-01T17:25:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-01T17:25:29Z"}, "message": "Auto merge of #97624 - matthiaskrgr:rollup-rtcqjx9, r=matthiaskrgr\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #96271 (suggest `?` when method is missing on `Result<T, _>` but found on `T`)\n - #97264 (Suggest `extern crate foo` when failing to resolve `use foo`)\n - #97592 (rustdoc: also index impl trait and raw pointers)\n - #97621 (update Miri)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "d232dcdfc7336f3e4fcae310c009a8b472626df3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d232dcdfc7336f3e4fcae310c009a8b472626df3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5a2d27f8f59df6f2162e61461b41d6116d4815e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5a2d27f8f59df6f2162e61461b41d6116d4815e", "html_url": "https://github.com/rust-lang/rust/commit/b5a2d27f8f59df6f2162e61461b41d6116d4815e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5a2d27f8f59df6f2162e61461b41d6116d4815e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8256e97231332ef49bd47a74b1809e785ecc78df", "url": "https://api.github.com/repos/rust-lang/rust/commits/8256e97231332ef49bd47a74b1809e785ecc78df", "html_url": "https://github.com/rust-lang/rust/commit/8256e97231332ef49bd47a74b1809e785ecc78df"}, {"sha": "89e765fb5683a7305371e9918e57d14213b66c06", "url": "https://api.github.com/repos/rust-lang/rust/commits/89e765fb5683a7305371e9918e57d14213b66c06", "html_url": "https://github.com/rust-lang/rust/commit/89e765fb5683a7305371e9918e57d14213b66c06"}], "stats": {"total": 716, "additions": 647, "deletions": 69}, "files": [{"sha": "7ed327e9f4ccbbaac87c37f9539eb7a53c9890b0", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -5509,6 +5509,8 @@ dependencies = [\n  \"pretty_assertions 1.2.1\",\n  \"regex\",\n  \"rustc_version\",\n+ \"serde\",\n+ \"serde_json\",\n ]\n \n [[package]]"}, {"sha": "b1fe418f687b4916547bd7110a3d77a599f72c15", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -1839,9 +1839,18 @@ impl<'a> Resolver<'a> {\n                     )),\n                 )\n             } else if self.session.edition() == Edition::Edition2015 {\n-                (format!(\"maybe a missing crate `{}`?\", ident), None)\n+                (\n+                    format!(\"maybe a missing crate `{ident}`?\"),\n+                    Some((\n+                        vec![],\n+                        format!(\n+                            \"consider adding `extern crate {ident}` to use the `{ident}` crate\"\n+                        ),\n+                        Applicability::MaybeIncorrect,\n+                    )),\n+                )\n             } else {\n-                (format!(\"could not find `{}` in the crate root\", ident), None)\n+                (format!(\"could not find `{ident}` in the crate root\"), None)\n             }\n         } else if i > 0 {\n             let parent = path[i - 1].ident.name;\n@@ -1852,7 +1861,7 @@ impl<'a> Resolver<'a> {\n                     \"the list of imported crates\".to_owned()\n                 }\n                 kw::PathRoot | kw::Crate => \"the crate root\".to_owned(),\n-                _ => format!(\"`{}`\", parent),\n+                _ => format!(\"`{parent}`\"),\n             };\n \n             let mut msg = format!(\"could not find `{}` in {}\", ident, parent);"}, {"sha": "de83a3a5932c211a6f4f7238129b9a14803ae0c3", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -475,6 +475,10 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             }\n \n             if let Some((suggestions, msg, applicability)) = err.suggestion {\n+                if suggestions.is_empty() {\n+                    diag.help(&msg);\n+                    continue;\n+                }\n                 diag.multipart_suggestion(&msg, suggestions, applicability);\n             }\n         }"}, {"sha": "0e198907c8d5092ed1a44e476cb0494621353581", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 151, "deletions": 52, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -978,45 +978,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     label_span_not_found(&mut err);\n                 }\n \n-                if let SelfSource::MethodCall(expr) = source\n-                    && let Some((fields, substs)) = self.get_field_candidates(span, actual)\n-                {\n-                    let call_expr =\n-                        self.tcx.hir().expect_expr(self.tcx.hir().get_parent_node(expr.hir_id));\n-                    for candidate_field in fields.iter() {\n-                        if let Some(field_path) = self.check_for_nested_field_satisfying(\n-                            span,\n-                            &|_, field_ty| {\n-                                self.lookup_probe(\n-                                    span,\n-                                    item_name,\n-                                    field_ty,\n-                                    call_expr,\n-                                    ProbeScope::AllTraits,\n-                                )\n-                                .is_ok()\n-                            },\n-                            candidate_field,\n-                            substs,\n-                            vec![],\n-                            self.tcx.parent_module(expr.hir_id).to_def_id(),\n-                        ) {\n-                            let field_path_str = field_path\n-                                .iter()\n-                                .map(|id| id.name.to_ident_string())\n-                                .collect::<Vec<String>>()\n-                                .join(\".\");\n-                            debug!(\"field_path_str: {:?}\", field_path_str);\n+                self.check_for_field_method(&mut err, source, span, actual, item_name);\n \n-                            err.span_suggestion_verbose(\n-                                item_name.span.shrink_to_lo(),\n-                                \"one of the expressions' fields has a method of the same name\",\n-                                format!(\"{field_path_str}.\"),\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        }\n-                    }\n-                }\n+                self.check_for_unwrap_self(&mut err, source, span, actual, item_name);\n \n                 bound_spans.sort();\n                 bound_spans.dedup();\n@@ -1343,6 +1307,145 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         false\n     }\n \n+    fn check_for_field_method(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n+        source: SelfSource<'tcx>,\n+        span: Span,\n+        actual: Ty<'tcx>,\n+        item_name: Ident,\n+    ) {\n+        if let SelfSource::MethodCall(expr) = source\n+            && let Some((fields, substs)) = self.get_field_candidates(span, actual)\n+        {\n+            let call_expr = self.tcx.hir().expect_expr(self.tcx.hir().get_parent_node(expr.hir_id));\n+            for candidate_field in fields.iter() {\n+                if let Some(field_path) = self.check_for_nested_field_satisfying(\n+                    span,\n+                    &|_, field_ty| {\n+                        self.lookup_probe(\n+                            span,\n+                            item_name,\n+                            field_ty,\n+                            call_expr,\n+                            ProbeScope::AllTraits,\n+                        )\n+                        .is_ok()\n+                    },\n+                    candidate_field,\n+                    substs,\n+                    vec![],\n+                    self.tcx.parent_module(expr.hir_id).to_def_id(),\n+                ) {\n+                    let field_path_str = field_path\n+                        .iter()\n+                        .map(|id| id.name.to_ident_string())\n+                        .collect::<Vec<String>>()\n+                        .join(\".\");\n+                    debug!(\"field_path_str: {:?}\", field_path_str);\n+\n+                    err.span_suggestion_verbose(\n+                        item_name.span.shrink_to_lo(),\n+                        \"one of the expressions' fields has a method of the same name\",\n+                        format!(\"{field_path_str}.\"),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_for_unwrap_self(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n+        source: SelfSource<'tcx>,\n+        span: Span,\n+        actual: Ty<'tcx>,\n+        item_name: Ident,\n+    ) {\n+        let tcx = self.tcx;\n+        let SelfSource::MethodCall(expr) = source else { return; };\n+        let call_expr = tcx.hir().expect_expr(tcx.hir().get_parent_node(expr.hir_id));\n+\n+        let ty::Adt(kind, substs) = actual.kind() else { return; };\n+        if !kind.is_enum() {\n+            return;\n+        }\n+\n+        let matching_variants: Vec<_> = kind\n+            .variants()\n+            .iter()\n+            .flat_map(|variant| {\n+                let [field] = &variant.fields[..] else { return None; };\n+                let field_ty = field.ty(tcx, substs);\n+\n+                // Skip `_`, since that'll just lead to ambiguity.\n+                if self.resolve_vars_if_possible(field_ty).is_ty_var() {\n+                    return None;\n+                }\n+\n+                self.lookup_probe(span, item_name, field_ty, call_expr, ProbeScope::AllTraits)\n+                    .ok()\n+                    .map(|pick| (variant, field, pick))\n+            })\n+            .collect();\n+\n+        let ret_ty_matches = |diagnostic_item| {\n+            if let Some(ret_ty) = self\n+                .ret_coercion\n+                .as_ref()\n+                .map(|c| self.resolve_vars_if_possible(c.borrow().expected_ty()))\n+                && let ty::Adt(kind, _) = ret_ty.kind()\n+                && tcx.get_diagnostic_item(diagnostic_item) == Some(kind.did())\n+            {\n+                true\n+            } else {\n+                false\n+            }\n+        };\n+\n+        match &matching_variants[..] {\n+            [(_, field, pick)] => {\n+                let self_ty = field.ty(tcx, substs);\n+                err.span_note(\n+                    tcx.def_span(pick.item.def_id),\n+                    &format!(\"the method `{item_name}` exists on the type `{self_ty}`\"),\n+                );\n+                let (article, kind, variant, question) =\n+                    if Some(kind.did()) == tcx.get_diagnostic_item(sym::Result) {\n+                        (\"a\", \"Result\", \"Err\", ret_ty_matches(sym::Result))\n+                    } else if Some(kind.did()) == tcx.get_diagnostic_item(sym::Option) {\n+                        (\"an\", \"Option\", \"None\", ret_ty_matches(sym::Option))\n+                    } else {\n+                        return;\n+                    };\n+                if question {\n+                    err.span_suggestion_verbose(\n+                        expr.span.shrink_to_hi(),\n+                        format!(\n+                            \"use the `?` operator to extract the `{self_ty}` value, propagating \\\n+                            {article} `{kind}::{variant}` value to the caller\"\n+                        ),\n+                        \"?\".to_owned(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else {\n+                    err.span_suggestion_verbose(\n+                        expr.span.shrink_to_hi(),\n+                        format!(\n+                            \"consider using `{kind}::expect` to unwrap the `{self_ty}` value, \\\n+                             panicking if the value is {article} `{kind}::{variant}`\"\n+                        ),\n+                        \".expect(\\\"REASON\\\")\".to_owned(),\n+                        Applicability::HasPlaceholders,\n+                    );\n+                }\n+            }\n+            // FIXME(compiler-errors): Support suggestions for other matching enum variants\n+            _ => {}\n+        }\n+    }\n+\n     pub(crate) fn note_unmet_impls_on_type(\n         &self,\n         err: &mut Diagnostic,\n@@ -1662,13 +1765,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 (self.tcx.mk_mut_ref(self.tcx.lifetimes.re_erased, rcvr_ty), \"&mut \"),\n                 (self.tcx.mk_imm_ref(self.tcx.lifetimes.re_erased, rcvr_ty), \"&\"),\n             ] {\n-                match self.lookup_probe(\n-                    span,\n-                    item_name,\n-                    *rcvr_ty,\n-                    rcvr,\n-                    crate::check::method::probe::ProbeScope::AllTraits,\n-                ) {\n+                match self.lookup_probe(span, item_name, *rcvr_ty, rcvr, ProbeScope::AllTraits) {\n                     Ok(pick) => {\n                         // If the method is defined for the receiver we have, it likely wasn't `use`d.\n                         // We point at the method, but we just skip the rest of the check for arbitrary\n@@ -1700,13 +1797,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     (self.tcx.mk_diagnostic_item(*rcvr_ty, sym::Arc), \"Arc::new\"),\n                     (self.tcx.mk_diagnostic_item(*rcvr_ty, sym::Rc), \"Rc::new\"),\n                 ] {\n-                    if let Some(new_rcvr_t) = *rcvr_ty && let Ok(pick) = self.lookup_probe(\n-                        span,\n-                        item_name,\n-                        new_rcvr_t,\n-                        rcvr,\n-                        crate::check::method::probe::ProbeScope::AllTraits,\n-                    ) {\n+                    if let Some(new_rcvr_t) = *rcvr_ty\n+                        && let Ok(pick) = self.lookup_probe(\n+                            span,\n+                            item_name,\n+                            new_rcvr_t,\n+                            rcvr,\n+                            ProbeScope::AllTraits,\n+                        )\n+                    {\n                         debug!(\"try_alt_rcvr: pick candidate {:?}\", pick);\n                         let did = Some(pick.item.container.id());\n                         // We don't want to suggest a container type when the missing"}, {"sha": "4605793d0df941bc70cf4dfad9075a45e361c609", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -1667,6 +1667,10 @@ impl Type {\n         matches!(self, Type::Generic(_))\n     }\n \n+    pub(crate) fn is_impl_trait(&self) -> bool {\n+        matches!(self, Type::ImplTrait(_))\n+    }\n+\n     pub(crate) fn is_primitive(&self) -> bool {\n         self.primitive_type().is_some()\n     }"}, {"sha": "9f302cc256659b2a24a2652c84018c62f284ffd6", "filename": "src/librustdoc/html/render/search_index.rs", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -226,17 +226,17 @@ fn get_index_type_name(clean_type: &clean::Type) -> Option<Symbol> {\n             Some(path.segments.last().unwrap().name)\n         }\n         // We return an empty name because we don't care about the generic name itself.\n-        clean::Generic(_) => Some(kw::Empty),\n+        clean::Generic(_) | clean::ImplTrait(_) => Some(kw::Empty),\n         clean::Primitive(ref p) => Some(p.as_sym()),\n-        clean::BorrowedRef { ref type_, .. } => get_index_type_name(type_),\n+        clean::BorrowedRef { ref type_, .. } | clean::RawPointer(_, ref type_) => {\n+            get_index_type_name(type_)\n+        }\n         clean::BareFunction(_)\n         | clean::Tuple(_)\n         | clean::Slice(_)\n         | clean::Array(_, _)\n-        | clean::RawPointer(_, _)\n         | clean::QPath { .. }\n-        | clean::Infer\n-        | clean::ImplTrait(_) => None,\n+        | clean::Infer => None,\n     }\n }\n \n@@ -264,10 +264,12 @@ fn add_generics_and_bounds_as_types<'tcx, 'a>(\n         mut generics: Vec<TypeWithKind>,\n         cache: &Cache,\n     ) {\n-        let is_full_generic = ty.is_full_generic();\n+        // generics and impl trait are both identified by their generics,\n+        // rather than a type name itself\n+        let anonymous = ty.is_full_generic() || ty.is_impl_trait();\n         let generics_empty = generics.is_empty();\n \n-        if is_full_generic {\n+        if anonymous {\n             if generics_empty {\n                 // This is a type parameter with no trait bounds (for example: `T` in\n                 // `fn f<T>(p: T)`, so not useful for the rustdoc search because we would end up\n@@ -318,7 +320,7 @@ fn add_generics_and_bounds_as_types<'tcx, 'a>(\n         if index_ty.name.as_ref().map(|s| s.is_empty() && generics_empty).unwrap_or(true) {\n             return;\n         }\n-        if is_full_generic {\n+        if anonymous {\n             // We remove the name of the full generic because we have no use for it.\n             index_ty.name = Some(String::new());\n             res.push(TypeWithKind::from((index_ty, ItemType::Generic)));\n@@ -398,6 +400,23 @@ fn add_generics_and_bounds_as_types<'tcx, 'a>(\n             }\n             insert_ty(res, tcx, arg.clone(), ty_generics, cache);\n         }\n+    } else if let Type::ImplTrait(ref bounds) = *arg {\n+        let mut ty_generics = Vec::new();\n+        for bound in bounds {\n+            if let Some(path) = bound.get_trait_path() {\n+                let ty = Type::Path { path };\n+                add_generics_and_bounds_as_types(\n+                    self_,\n+                    generics,\n+                    &ty,\n+                    tcx,\n+                    recurse + 1,\n+                    &mut ty_generics,\n+                    cache,\n+                );\n+            }\n+        }\n+        insert_ty(res, tcx, arg.clone(), ty_generics, cache);\n     } else {\n         // This is not a type parameter. So for example if we have `T, U: Option<T>`, and we're\n         // looking at `Option`, we enter this \"else\" condition, otherwise if it's `T`, we don't."}, {"sha": "8d594bf8aea7522084f77251b602d077f33d6050", "filename": "src/test/rustdoc-js/impl-trait.js", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Frustdoc-js%2Fimpl-trait.js", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Frustdoc-js%2Fimpl-trait.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fimpl-trait.js?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -0,0 +1,51 @@\n+// ignore-order\n+\n+const QUERY = [\n+    'Aaaaaaa -> i32',\n+    'Aaaaaaa -> Aaaaaaa',\n+    'Aaaaaaa -> usize',\n+    '-> Aaaaaaa',\n+    'Aaaaaaa',\n+];\n+\n+const EXPECTED = [\n+    {\n+        // Aaaaaaa -> i32\n+        'others': [\n+            { 'path': 'impl_trait::Ccccccc', 'name': 'eeeeeee' },\n+        ],\n+    },\n+    {\n+        // Aaaaaaa -> Aaaaaaa\n+        'others': [\n+            { 'path': 'impl_trait::Ccccccc', 'name': 'fffffff' },\n+        ],\n+    },\n+    {\n+        // Aaaaaaa -> usize\n+        'others': [],\n+    },\n+    {\n+        // -> Aaaaaaa\n+        'others': [\n+            { 'path': 'impl_trait::Ccccccc', 'name': 'fffffff' },\n+            { 'path': 'impl_trait::Ccccccc', 'name': 'ddddddd' },\n+            { 'path': 'impl_trait', 'name': 'bbbbbbb' },\n+        ],\n+    },\n+    {\n+        // Aaaaaaa\n+        'others': [\n+            { 'path': 'impl_trait', 'name': 'Aaaaaaa' },\n+        ],\n+        'in_args': [\n+            { 'path': 'impl_trait::Ccccccc', 'name': 'fffffff' },\n+            { 'path': 'impl_trait::Ccccccc', 'name': 'eeeeeee' },\n+        ],\n+        'returned': [\n+            { 'path': 'impl_trait::Ccccccc', 'name': 'fffffff' },\n+            { 'path': 'impl_trait::Ccccccc', 'name': 'ddddddd' },\n+            { 'path': 'impl_trait', 'name': 'bbbbbbb' },\n+        ],\n+    },\n+];"}, {"sha": "fb8869b46f3d40aa149a4c03725536f96e8968e1", "filename": "src/test/rustdoc-js/impl-trait.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Frustdoc-js%2Fimpl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Frustdoc-js%2Fimpl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fimpl-trait.rs?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -0,0 +1,21 @@\n+pub trait Aaaaaaa {}\n+\n+impl Aaaaaaa for () {}\n+\n+pub fn bbbbbbb() -> impl Aaaaaaa {\n+    ()\n+}\n+\n+pub struct Ccccccc {}\n+\n+impl Ccccccc {\n+    pub fn ddddddd(&self) -> impl Aaaaaaa {\n+        ()\n+    }\n+    pub fn eeeeeee(&self, _x: impl Aaaaaaa) -> i32 {\n+        0\n+    }\n+    pub fn fffffff(&self, x: impl Aaaaaaa) -> impl Aaaaaaa {\n+        x\n+    }\n+}"}, {"sha": "140b955ea713acfae220d54bbeed6e7ebcce8634", "filename": "src/test/rustdoc-js/raw-pointer.js", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Frustdoc-js%2Fraw-pointer.js", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Frustdoc-js%2Fraw-pointer.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fraw-pointer.js?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -0,0 +1,55 @@\n+// ignore-order\n+\n+const QUERY = [\n+    'Aaaaaaa -> i32',\n+    'Aaaaaaa -> Aaaaaaa',\n+    'Aaaaaaa -> usize',\n+    '-> Aaaaaaa',\n+    'Aaaaaaa',\n+];\n+\n+const EXPECTED = [\n+    {\n+        // Aaaaaaa -> i32\n+        'others': [\n+            { 'path': 'raw_pointer::Ccccccc', 'name': 'eeeeeee' },\n+        ],\n+    },\n+    {\n+        // Aaaaaaa -> Aaaaaaa\n+        'others': [\n+            { 'path': 'raw_pointer::Ccccccc', 'name': 'fffffff' },\n+            { 'path': 'raw_pointer::Ccccccc', 'name': 'ggggggg' },\n+        ],\n+    },\n+    {\n+        // Aaaaaaa -> usize\n+        'others': [],\n+    },\n+    {\n+        // -> Aaaaaaa\n+        'others': [\n+            { 'path': 'raw_pointer::Ccccccc', 'name': 'fffffff' },\n+            { 'path': 'raw_pointer::Ccccccc', 'name': 'ggggggg' },\n+            { 'path': 'raw_pointer::Ccccccc', 'name': 'ddddddd' },\n+            { 'path': 'raw_pointer', 'name': 'bbbbbbb' },\n+        ],\n+    },\n+    {\n+        // Aaaaaaa\n+        'others': [\n+            { 'path': 'raw_pointer', 'name': 'Aaaaaaa' },\n+        ],\n+        'in_args': [\n+            { 'path': 'raw_pointer::Ccccccc', 'name': 'fffffff' },\n+            { 'path': 'raw_pointer::Ccccccc', 'name': 'ggggggg' },\n+            { 'path': 'raw_pointer::Ccccccc', 'name': 'eeeeeee' },\n+        ],\n+        'returned': [\n+            { 'path': 'raw_pointer::Ccccccc', 'name': 'fffffff' },\n+            { 'path': 'raw_pointer::Ccccccc', 'name': 'ggggggg' },\n+            { 'path': 'raw_pointer::Ccccccc', 'name': 'ddddddd' },\n+            { 'path': 'raw_pointer', 'name': 'bbbbbbb' },\n+        ],\n+    },\n+];"}, {"sha": "b8ace2e0b7d77945cdc5e5731df5562c35553549", "filename": "src/test/rustdoc-js/raw-pointer.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Frustdoc-js%2Fraw-pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Frustdoc-js%2Fraw-pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fraw-pointer.rs?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -0,0 +1,24 @@\n+use std::ptr;\n+\n+pub struct Aaaaaaa {}\n+\n+pub fn bbbbbbb() -> *const Aaaaaaa {\n+    ptr::null()\n+}\n+\n+pub struct Ccccccc {}\n+\n+impl Ccccccc {\n+    pub fn ddddddd(&self) -> *const Aaaaaaa {\n+        ptr::null()\n+    }\n+    pub fn eeeeeee(&self, _x: *const Aaaaaaa) -> i32 {\n+        0\n+    }\n+    pub fn fffffff(&self, x: *const Aaaaaaa) -> *const Aaaaaaa {\n+        x\n+    }\n+    pub fn ggggggg(&self, x: *mut Aaaaaaa) -> *mut Aaaaaaa {\n+        x\n+    }\n+}"}, {"sha": "b54f8200666004f34889f87217065446646aff72", "filename": "src/test/rustdoc-ui/intra-doc/unresolved-import-recovery.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Funresolved-import-recovery.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Funresolved-import-recovery.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Funresolved-import-recovery.stderr?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -3,6 +3,8 @@ error[E0433]: failed to resolve: maybe a missing crate `unresolved_crate`?\n    |\n LL | use unresolved_crate::module::Name;\n    |     ^^^^^^^^^^^^^^^^ maybe a missing crate `unresolved_crate`?\n+   |\n+   = help: consider adding `extern crate unresolved_crate` to use the `unresolved_crate` crate\n \n error: Compilation failed, aborting rustdoc\n "}, {"sha": "38fadaa44358f3354383a3fd8976c003410207f9", "filename": "src/test/rustdoc-ui/issue-61732.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Frustdoc-ui%2Fissue-61732.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Frustdoc-ui%2Fissue-61732.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fissue-61732.stderr?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -3,6 +3,8 @@ error[E0433]: failed to resolve: maybe a missing crate `r#mod`?\n    |\n LL | pub(in crate::r#mod) fn main() {}\n    |               ^^^^^ maybe a missing crate `r#mod`?\n+   |\n+   = help: consider adding `extern crate r#mod` to use the `r#mod` crate\n \n error: Compilation failed, aborting rustdoc\n "}, {"sha": "439762546381ec45c9364ea3f061f019298326d3", "filename": "src/test/ui/attributes/field-attributes-vis-unresolved.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fattributes%2Ffield-attributes-vis-unresolved.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fattributes%2Ffield-attributes-vis-unresolved.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Ffield-attributes-vis-unresolved.stderr?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -3,12 +3,16 @@ error[E0433]: failed to resolve: maybe a missing crate `nonexistent`?\n    |\n LL |     pub(in nonexistent) field: u8\n    |            ^^^^^^^^^^^ maybe a missing crate `nonexistent`?\n+   |\n+   = help: consider adding `extern crate nonexistent` to use the `nonexistent` crate\n \n error[E0433]: failed to resolve: maybe a missing crate `nonexistent`?\n   --> $DIR/field-attributes-vis-unresolved.rs:22:12\n    |\n LL |     pub(in nonexistent) u8\n    |            ^^^^^^^^^^^ maybe a missing crate `nonexistent`?\n+   |\n+   = help: consider adding `extern crate nonexistent` to use the `nonexistent` crate\n \n error: aborting due to 2 previous errors\n "}, {"sha": "ed9536f164ef0ed51f67c677cf5538f3f8f90639", "filename": "src/test/ui/error-codes/E0432.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Ferror-codes%2FE0432.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Ferror-codes%2FE0432.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0432.stderr?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -3,6 +3,8 @@ error[E0432]: unresolved import `something`\n    |\n LL | use something::Foo;\n    |     ^^^^^^^^^ maybe a missing crate `something`?\n+   |\n+   = help: consider adding `extern crate something` to use the `something` crate\n \n error: aborting due to previous error\n "}, {"sha": "3bae23a4aaa78e7e987d11d93d24ef6cd249a3ee", "filename": "src/test/ui/feature-gates/feature-gate-extern_absolute_paths.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-extern_absolute_paths.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-extern_absolute_paths.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-extern_absolute_paths.stderr?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -3,12 +3,16 @@ error[E0432]: unresolved import `core`\n    |\n LL | use core::default;\n    |     ^^^^ maybe a missing crate `core`?\n+   |\n+   = help: consider adding `extern crate core` to use the `core` crate\n \n error[E0433]: failed to resolve: maybe a missing crate `core`?\n   --> $DIR/feature-gate-extern_absolute_paths.rs:4:19\n    |\n LL |     let _: u8 = ::core::default::Default();\n    |                   ^^^^ maybe a missing crate `core`?\n+   |\n+   = help: consider adding `extern crate core` to use the `core` crate\n \n error: aborting due to 2 previous errors\n "}, {"sha": "ca75c9c18bd280811c72d131934603b8392da5f3", "filename": "src/test/ui/imports/import3.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fimports%2Fimport3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fimports%2Fimport3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fimport3.stderr?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -3,6 +3,8 @@ error[E0432]: unresolved import `main`\n    |\n LL | use main::bar;\n    |     ^^^^ maybe a missing crate `main`?\n+   |\n+   = help: consider adding `extern crate main` to use the `main` crate\n \n error: aborting due to previous error\n "}, {"sha": "019ef9ad56a1f87f626c0f90b06e5ab90f1f9410", "filename": "src/test/ui/imports/issue-1697.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fimports%2Fissue-1697.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fimports%2Fissue-1697.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-1697.stderr?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -3,6 +3,8 @@ error[E0432]: unresolved import `unresolved`\n    |\n LL | use unresolved::*;\n    |     ^^^^^^^^^^ maybe a missing crate `unresolved`?\n+   |\n+   = help: consider adding `extern crate unresolved` to use the `unresolved` crate\n \n error: aborting due to previous error\n "}, {"sha": "c4e5c55589914a11312b2873cef5b1b5649266c1", "filename": "src/test/ui/imports/issue-33464.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fimports%2Fissue-33464.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fimports%2Fissue-33464.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-33464.stderr?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -3,18 +3,24 @@ error[E0432]: unresolved import `abc`\n    |\n LL | use abc::one_el;\n    |     ^^^ maybe a missing crate `abc`?\n+   |\n+   = help: consider adding `extern crate abc` to use the `abc` crate\n \n error[E0432]: unresolved import `abc`\n   --> $DIR/issue-33464.rs:5:5\n    |\n LL | use abc::{a, bbb, cccccc};\n    |     ^^^ maybe a missing crate `abc`?\n+   |\n+   = help: consider adding `extern crate abc` to use the `abc` crate\n \n error[E0432]: unresolved import `a_very_long_name`\n   --> $DIR/issue-33464.rs:7:5\n    |\n LL | use a_very_long_name::{el, el2};\n    |     ^^^^^^^^^^^^^^^^ maybe a missing crate `a_very_long_name`?\n+   |\n+   = help: consider adding `extern crate a_very_long_name` to use the `a_very_long_name` crate\n \n error: aborting due to 3 previous errors\n "}, {"sha": "2e1b468603d47c7966a34dc9cf605ebddd374947", "filename": "src/test/ui/imports/issue-36881.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fimports%2Fissue-36881.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fimports%2Fissue-36881.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-36881.stderr?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -3,6 +3,8 @@ error[E0432]: unresolved import `issue_36881_aux`\n    |\n LL |     use issue_36881_aux::Foo;\n    |         ^^^^^^^^^^^^^^^ maybe a missing crate `issue_36881_aux`?\n+   |\n+   = help: consider adding `extern crate issue_36881_aux` to use the `issue_36881_aux` crate\n \n error: aborting due to previous error\n "}, {"sha": "75185cad3b764885eb3bb0881f7408b8a853f108", "filename": "src/test/ui/imports/issue-37887.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fimports%2Fissue-37887.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fimports%2Fissue-37887.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-37887.stderr?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -3,6 +3,8 @@ error[E0432]: unresolved import `libc`\n    |\n LL |     use libc::*;\n    |         ^^^^ maybe a missing crate `libc`?\n+   |\n+   = help: consider adding `extern crate libc` to use the `libc` crate\n \n error[E0658]: use of unstable library feature 'rustc_private': this crate is being loaded from the sysroot, an unstable location; did you mean to load this crate from crates.io via `Cargo.toml` instead?\n   --> $DIR/issue-37887.rs:2:5"}, {"sha": "29c7556dac432a5f459e13a5648aeadfd7ba73b1", "filename": "src/test/ui/imports/issue-53269.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fimports%2Fissue-53269.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fimports%2Fissue-53269.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-53269.stderr?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -3,6 +3,8 @@ error[E0432]: unresolved import `nonexistent_module`\n    |\n LL |     use nonexistent_module::mac;\n    |         ^^^^^^^^^^^^^^^^^^ maybe a missing crate `nonexistent_module`?\n+   |\n+   = help: consider adding `extern crate nonexistent_module` to use the `nonexistent_module` crate\n \n error[E0659]: `mac` is ambiguous\n   --> $DIR/issue-53269.rs:8:5"}, {"sha": "788fcc830ae9abc95ba519b99375e2aadd7b6be6", "filename": "src/test/ui/imports/issue-55457.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fimports%2Fissue-55457.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fimports%2Fissue-55457.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-55457.stderr?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -12,6 +12,8 @@ error[E0432]: unresolved import `non_existent`\n    |\n LL | use non_existent::non_existent;\n    |     ^^^^^^^^^^^^ maybe a missing crate `non_existent`?\n+   |\n+   = help: consider adding `extern crate non_existent` to use the `non_existent` crate\n \n error: cannot determine resolution for the derive macro `NonExistent`\n   --> $DIR/issue-55457.rs:5:10"}, {"sha": "6caf15bc7240163fab97cfb774cc5fd9f475859d", "filename": "src/test/ui/imports/tool-mod-child.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fimports%2Ftool-mod-child.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fimports%2Ftool-mod-child.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Ftool-mod-child.stderr?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -3,24 +3,32 @@ error[E0433]: failed to resolve: maybe a missing crate `clippy`?\n    |\n LL | use clippy::a::b;\n    |     ^^^^^^ maybe a missing crate `clippy`?\n+   |\n+   = help: consider adding `extern crate clippy` to use the `clippy` crate\n \n error[E0432]: unresolved import `clippy`\n   --> $DIR/tool-mod-child.rs:1:5\n    |\n LL | use clippy::a;\n    |     ^^^^^^ maybe a missing crate `clippy`?\n+   |\n+   = help: consider adding `extern crate clippy` to use the `clippy` crate\n \n error[E0433]: failed to resolve: maybe a missing crate `rustdoc`?\n   --> $DIR/tool-mod-child.rs:5:5\n    |\n LL | use rustdoc::a::b;\n    |     ^^^^^^^ maybe a missing crate `rustdoc`?\n+   |\n+   = help: consider adding `extern crate rustdoc` to use the `rustdoc` crate\n \n error[E0432]: unresolved import `rustdoc`\n   --> $DIR/tool-mod-child.rs:4:5\n    |\n LL | use rustdoc::a;\n    |     ^^^^^^^ maybe a missing crate `rustdoc`?\n+   |\n+   = help: consider adding `extern crate rustdoc` to use the `rustdoc` crate\n \n error: aborting due to 4 previous errors\n "}, {"sha": "73f9d1bfb6c618757f7c18ebaea51c2f7a31779e", "filename": "src/test/ui/imports/unresolved-imports-used.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fimports%2Funresolved-imports-used.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fimports%2Funresolved-imports-used.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Funresolved-imports-used.stderr?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -15,24 +15,32 @@ error[E0432]: unresolved import `foo`\n    |\n LL | use foo::bar;\n    |     ^^^ maybe a missing crate `foo`?\n+   |\n+   = help: consider adding `extern crate foo` to use the `foo` crate\n \n error[E0432]: unresolved import `baz`\n   --> $DIR/unresolved-imports-used.rs:12:5\n    |\n LL | use baz::*;\n    |     ^^^ maybe a missing crate `baz`?\n+   |\n+   = help: consider adding `extern crate baz` to use the `baz` crate\n \n error[E0432]: unresolved import `foo2`\n   --> $DIR/unresolved-imports-used.rs:14:5\n    |\n LL | use foo2::bar2;\n    |     ^^^^ maybe a missing crate `foo2`?\n+   |\n+   = help: consider adding `extern crate foo2` to use the `foo2` crate\n \n error[E0432]: unresolved import `baz2`\n   --> $DIR/unresolved-imports-used.rs:15:5\n    |\n LL | use baz2::*;\n    |     ^^^^ maybe a missing crate `baz2`?\n+   |\n+   = help: consider adding `extern crate baz2` to use the `baz2` crate\n \n error[E0603]: function `quz` is private\n   --> $DIR/unresolved-imports-used.rs:9:10"}, {"sha": "54ee45c28679a598f37ac0aaa7f3f6958deb1dc7", "filename": "src/test/ui/keyword/extern/keyword-extern-as-identifier-use.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fkeyword%2Fextern%2Fkeyword-extern-as-identifier-use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fkeyword%2Fextern%2Fkeyword-extern-as-identifier-use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fkeyword%2Fextern%2Fkeyword-extern-as-identifier-use.stderr?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -14,6 +14,8 @@ error[E0432]: unresolved import `r#extern`\n    |\n LL | use extern::foo;\n    |     ^^^^^^ maybe a missing crate `r#extern`?\n+   |\n+   = help: consider adding `extern crate r#extern` to use the `r#extern` crate\n \n error: aborting due to 2 previous errors\n "}, {"sha": "c81520c35cd41d1ac27b36964c6549ac389d02be", "filename": "src/test/ui/privacy/restricted/test.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Ftest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Ftest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Ftest.stderr?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -3,6 +3,8 @@ error[E0433]: failed to resolve: maybe a missing crate `bad`?\n    |\n LL |     pub(in bad::path) mod m1 {}\n    |            ^^^ maybe a missing crate `bad`?\n+   |\n+   = help: consider adding `extern crate bad` to use the `bad` crate\n \n error[E0742]: visibilities can only be restricted to ancestor modules\n   --> $DIR/test.rs:51:12"}, {"sha": "00cdd0c58f4ec80c040ec92409667471851da6a2", "filename": "src/test/ui/resolve/editions-crate-root-2015.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fresolve%2Feditions-crate-root-2015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fresolve%2Feditions-crate-root-2015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Feditions-crate-root-2015.stderr?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -3,12 +3,16 @@ error[E0433]: failed to resolve: maybe a missing crate `nonexistant`?\n    |\n LL |     fn global_inner(_: ::nonexistant::Foo) {\n    |                          ^^^^^^^^^^^ maybe a missing crate `nonexistant`?\n+   |\n+   = help: consider adding `extern crate nonexistant` to use the `nonexistant` crate\n \n error[E0433]: failed to resolve: maybe a missing crate `nonexistant`?\n   --> $DIR/editions-crate-root-2015.rs:7:30\n    |\n LL |     fn crate_inner(_: crate::nonexistant::Foo) {\n    |                              ^^^^^^^^^^^ maybe a missing crate `nonexistant`?\n+   |\n+   = help: consider adding `extern crate nonexistant` to use the `nonexistant` crate\n \n error[E0412]: cannot find type `nonexistant` in the crate root\n   --> $DIR/editions-crate-root-2015.rs:11:25"}, {"sha": "a1591914b4d298878bd6c03be274e603e29f00e6", "filename": "src/test/ui/resolve/extern-prelude-fail.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fresolve%2Fextern-prelude-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fresolve%2Fextern-prelude-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fextern-prelude-fail.stderr?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -3,12 +3,16 @@ error[E0432]: unresolved import `extern_prelude`\n    |\n LL |     use extern_prelude::S;\n    |         ^^^^^^^^^^^^^^ maybe a missing crate `extern_prelude`?\n+   |\n+   = help: consider adding `extern crate extern_prelude` to use the `extern_prelude` crate\n \n error[E0433]: failed to resolve: maybe a missing crate `extern_prelude`?\n   --> $DIR/extern-prelude-fail.rs:8:15\n    |\n LL |     let s = ::extern_prelude::S;\n    |               ^^^^^^^^^^^^^^ maybe a missing crate `extern_prelude`?\n+   |\n+   = help: consider adding `extern crate extern_prelude` to use the `extern_prelude` crate\n \n error: aborting due to 2 previous errors\n "}, {"sha": "730fd6d602645d9af74dd88af6fc12eb43946845", "filename": "src/test/ui/resolve/issue-82865.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fresolve%2Fissue-82865.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fresolve%2Fissue-82865.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-82865.stderr?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -3,6 +3,8 @@ error[E0433]: failed to resolve: maybe a missing crate `x`?\n    |\n LL | use x::y::z;\n    |     ^ maybe a missing crate `x`?\n+   |\n+   = help: consider adding `extern crate x` to use the `x` crate\n \n error[E0599]: no function or associated item named `z` found for struct `Box<_, _>` in the current scope\n   --> $DIR/issue-82865.rs:8:10"}, {"sha": "2ac41b87562e10c1784c18468274accf8cb66971", "filename": "src/test/ui/resolve/resolve-bad-visibility.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fresolve%2Fresolve-bad-visibility.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fresolve%2Fresolve-bad-visibility.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-bad-visibility.stderr?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -21,12 +21,16 @@ error[E0433]: failed to resolve: maybe a missing crate `nonexistent`?\n    |\n LL | pub(in nonexistent) struct G;\n    |        ^^^^^^^^^^^ maybe a missing crate `nonexistent`?\n+   |\n+   = help: consider adding `extern crate nonexistent` to use the `nonexistent` crate\n \n error[E0433]: failed to resolve: maybe a missing crate `too_soon`?\n   --> $DIR/resolve-bad-visibility.rs:8:8\n    |\n LL | pub(in too_soon) struct H;\n    |        ^^^^^^^^ maybe a missing crate `too_soon`?\n+   |\n+   = help: consider adding `extern crate too_soon` to use the `too_soon` crate\n \n error: aborting due to 5 previous errors\n "}, {"sha": "870f4064de49b57b311ca937940599ba36013c99", "filename": "src/test/ui/simd/portable-intrinsics-arent-exposed.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fsimd%2Fportable-intrinsics-arent-exposed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fsimd%2Fportable-intrinsics-arent-exposed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fportable-intrinsics-arent-exposed.stderr?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -3,6 +3,8 @@ error[E0433]: failed to resolve: maybe a missing crate `core`?\n    |\n LL | use core::simd::intrinsics;\n    |     ^^^^ maybe a missing crate `core`?\n+   |\n+   = help: consider adding `extern crate core` to use the `core` crate\n \n error[E0432]: unresolved import `std::simd::intrinsics`\n   --> $DIR/portable-intrinsics-arent-exposed.rs:5:5"}, {"sha": "6499c92bc6f1545baeacbf6c66e696d6ff560139", "filename": "src/test/ui/suggestions/enum-method-probe.fixed", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.fixed?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -0,0 +1,59 @@\n+// compile-flags: --edition=2021\n+// run-rustfix\n+\n+#![allow(unused)]\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn get(&self) -> u8 {\n+        42\n+    }\n+}\n+\n+fn test_result_in_result() -> Result<(), ()> {\n+    let res: Result<_, ()> = Ok(Foo);\n+    res?.get();\n+    //~^ ERROR no method named `get` found for enum `Result` in the current scope\n+    //~| HELP use the `?` operator\n+    Ok(())\n+}\n+\n+async fn async_test_result_in_result() -> Result<(), ()> {\n+    let res: Result<_, ()> = Ok(Foo);\n+    res?.get();\n+    //~^ ERROR no method named `get` found for enum `Result` in the current scope\n+    //~| HELP use the `?` operator\n+    Ok(())\n+}\n+\n+fn test_result_in_unit_return() {\n+    let res: Result<_, ()> = Ok(Foo);\n+    res.expect(\"REASON\").get();\n+    //~^ ERROR no method named `get` found for enum `Result` in the current scope\n+    //~| HELP consider using `Result::expect` to unwrap the `Foo` value, panicking if the value is a `Result::Err`\n+}\n+\n+async fn async_test_result_in_unit_return() {\n+    let res: Result<_, ()> = Ok(Foo);\n+    res.expect(\"REASON\").get();\n+    //~^ ERROR no method named `get` found for enum `Result` in the current scope\n+    //~| HELP consider using `Result::expect` to unwrap the `Foo` value, panicking if the value is a `Result::Err`\n+}\n+\n+fn test_option_in_option() -> Option<()> {\n+    let res: Option<_> = Some(Foo);\n+    res?.get();\n+    //~^ ERROR no method named `get` found for enum `Option` in the current scope\n+    //~| HELP use the `?` operator\n+    Some(())\n+}\n+\n+fn test_option_in_unit_return() {\n+    let res: Option<_> = Some(Foo);\n+    res.expect(\"REASON\").get();\n+    //~^ ERROR no method named `get` found for enum `Option` in the current scope\n+    //~| HELP consider using `Option::expect` to unwrap the `Foo` value, panicking if the value is an `Option::None`\n+}\n+\n+fn main() {}"}, {"sha": "18ea8ed8a58ffd055a155094ba4b7aed555ca786", "filename": "src/test/ui/suggestions/enum-method-probe.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.rs?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -0,0 +1,59 @@\n+// compile-flags: --edition=2021\n+// run-rustfix\n+\n+#![allow(unused)]\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn get(&self) -> u8 {\n+        42\n+    }\n+}\n+\n+fn test_result_in_result() -> Result<(), ()> {\n+    let res: Result<_, ()> = Ok(Foo);\n+    res.get();\n+    //~^ ERROR no method named `get` found for enum `Result` in the current scope\n+    //~| HELP use the `?` operator\n+    Ok(())\n+}\n+\n+async fn async_test_result_in_result() -> Result<(), ()> {\n+    let res: Result<_, ()> = Ok(Foo);\n+    res.get();\n+    //~^ ERROR no method named `get` found for enum `Result` in the current scope\n+    //~| HELP use the `?` operator\n+    Ok(())\n+}\n+\n+fn test_result_in_unit_return() {\n+    let res: Result<_, ()> = Ok(Foo);\n+    res.get();\n+    //~^ ERROR no method named `get` found for enum `Result` in the current scope\n+    //~| HELP consider using `Result::expect` to unwrap the `Foo` value, panicking if the value is a `Result::Err`\n+}\n+\n+async fn async_test_result_in_unit_return() {\n+    let res: Result<_, ()> = Ok(Foo);\n+    res.get();\n+    //~^ ERROR no method named `get` found for enum `Result` in the current scope\n+    //~| HELP consider using `Result::expect` to unwrap the `Foo` value, panicking if the value is a `Result::Err`\n+}\n+\n+fn test_option_in_option() -> Option<()> {\n+    let res: Option<_> = Some(Foo);\n+    res.get();\n+    //~^ ERROR no method named `get` found for enum `Option` in the current scope\n+    //~| HELP use the `?` operator\n+    Some(())\n+}\n+\n+fn test_option_in_unit_return() {\n+    let res: Option<_> = Some(Foo);\n+    res.get();\n+    //~^ ERROR no method named `get` found for enum `Option` in the current scope\n+    //~| HELP consider using `Option::expect` to unwrap the `Foo` value, panicking if the value is an `Option::None`\n+}\n+\n+fn main() {}"}, {"sha": "6ed14984f47478928e27837200a7ba96a1ab406c", "filename": "src/test/ui/suggestions/enum-method-probe.stderr", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.stderr?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -0,0 +1,99 @@\n+error[E0599]: no method named `get` found for enum `Result` in the current scope\n+  --> $DIR/enum-method-probe.rs:24:9\n+   |\n+LL |     res.get();\n+   |         ^^^ method not found in `Result<Foo, ()>`\n+   |\n+note: the method `get` exists on the type `Foo`\n+  --> $DIR/enum-method-probe.rs:9:5\n+   |\n+LL |     fn get(&self) -> u8 {\n+   |     ^^^^^^^^^^^^^^^^^^^\n+help: use the `?` operator to extract the `Foo` value, propagating a `Result::Err` value to the caller\n+   |\n+LL |     res?.get();\n+   |        +\n+\n+error[E0599]: no method named `get` found for enum `Result` in the current scope\n+  --> $DIR/enum-method-probe.rs:39:9\n+   |\n+LL |     res.get();\n+   |         ^^^ method not found in `Result<Foo, ()>`\n+   |\n+note: the method `get` exists on the type `Foo`\n+  --> $DIR/enum-method-probe.rs:9:5\n+   |\n+LL |     fn get(&self) -> u8 {\n+   |     ^^^^^^^^^^^^^^^^^^^\n+help: consider using `Result::expect` to unwrap the `Foo` value, panicking if the value is a `Result::Err`\n+   |\n+LL |     res.expect(\"REASON\").get();\n+   |        +++++++++++++++++\n+\n+error[E0599]: no method named `get` found for enum `Result` in the current scope\n+  --> $DIR/enum-method-probe.rs:16:9\n+   |\n+LL |     res.get();\n+   |         ^^^ method not found in `Result<Foo, ()>`\n+   |\n+note: the method `get` exists on the type `Foo`\n+  --> $DIR/enum-method-probe.rs:9:5\n+   |\n+LL |     fn get(&self) -> u8 {\n+   |     ^^^^^^^^^^^^^^^^^^^\n+help: use the `?` operator to extract the `Foo` value, propagating a `Result::Err` value to the caller\n+   |\n+LL |     res?.get();\n+   |        +\n+\n+error[E0599]: no method named `get` found for enum `Result` in the current scope\n+  --> $DIR/enum-method-probe.rs:32:9\n+   |\n+LL |     res.get();\n+   |         ^^^ method not found in `Result<Foo, ()>`\n+   |\n+note: the method `get` exists on the type `Foo`\n+  --> $DIR/enum-method-probe.rs:9:5\n+   |\n+LL |     fn get(&self) -> u8 {\n+   |     ^^^^^^^^^^^^^^^^^^^\n+help: consider using `Result::expect` to unwrap the `Foo` value, panicking if the value is a `Result::Err`\n+   |\n+LL |     res.expect(\"REASON\").get();\n+   |        +++++++++++++++++\n+\n+error[E0599]: no method named `get` found for enum `Option` in the current scope\n+  --> $DIR/enum-method-probe.rs:46:9\n+   |\n+LL |     res.get();\n+   |         ^^^ method not found in `Option<Foo>`\n+   |\n+note: the method `get` exists on the type `Foo`\n+  --> $DIR/enum-method-probe.rs:9:5\n+   |\n+LL |     fn get(&self) -> u8 {\n+   |     ^^^^^^^^^^^^^^^^^^^\n+help: use the `?` operator to extract the `Foo` value, propagating an `Option::None` value to the caller\n+   |\n+LL |     res?.get();\n+   |        +\n+\n+error[E0599]: no method named `get` found for enum `Option` in the current scope\n+  --> $DIR/enum-method-probe.rs:54:9\n+   |\n+LL |     res.get();\n+   |         ^^^ method not found in `Option<Foo>`\n+   |\n+note: the method `get` exists on the type `Foo`\n+  --> $DIR/enum-method-probe.rs:9:5\n+   |\n+LL |     fn get(&self) -> u8 {\n+   |     ^^^^^^^^^^^^^^^^^^^\n+help: consider using `Option::expect` to unwrap the `Foo` value, panicking if the value is an `Option::None`\n+   |\n+LL |     res.expect(\"REASON\").get();\n+   |        +++++++++++++++++\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "8df8eab34a715cb46aa388a93f127248619d35ae", "filename": "src/test/ui/unresolved/unresolved-asterisk-imports.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Funresolved%2Funresolved-asterisk-imports.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Funresolved%2Funresolved-asterisk-imports.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funresolved%2Funresolved-asterisk-imports.stderr?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -3,6 +3,8 @@ error[E0432]: unresolved import `not_existing_crate`\n    |\n LL | use not_existing_crate::*;\n    |     ^^^^^^^^^^^^^^^^^^ maybe a missing crate `not_existing_crate`?\n+   |\n+   = help: consider adding `extern crate not_existing_crate` to use the `not_existing_crate` crate\n \n error: aborting due to previous error\n "}, {"sha": "4125c593c747fda6167a93942160f1a6e4c6eda6", "filename": "src/test/ui/unresolved/unresolved-import.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Funresolved%2Funresolved-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Funresolved%2Funresolved-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funresolved%2Funresolved-import.rs?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -1,5 +1,6 @@\n use foo::bar; //~ ERROR unresolved import `foo` [E0432]\n               //~^ maybe a missing crate `foo`?\n+              //~| HELP consider adding `extern crate foo` to use the `foo` crate\n \n use bar::Baz as x; //~ ERROR unresolved import `bar::Baz` [E0432]\n                    //~| no `Baz` in `bar`"}, {"sha": "0dd928c8b6ffd35f681827c00c91e21733e512f7", "filename": "src/test/ui/unresolved/unresolved-import.stderr", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Funresolved%2Funresolved-import.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5a2d27f8f59df6f2162e61461b41d6116d4815e/src%2Ftest%2Fui%2Funresolved%2Funresolved-import.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funresolved%2Funresolved-import.stderr?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -3,9 +3,11 @@ error[E0432]: unresolved import `foo`\n    |\n LL | use foo::bar;\n    |     ^^^ maybe a missing crate `foo`?\n+   |\n+   = help: consider adding `extern crate foo` to use the `foo` crate\n \n error[E0432]: unresolved import `bar::Baz`\n-  --> $DIR/unresolved-import.rs:4:5\n+  --> $DIR/unresolved-import.rs:5:5\n    |\n LL | use bar::Baz as x;\n    |     ^^^^^---^^^^^\n@@ -14,7 +16,7 @@ LL | use bar::Baz as x;\n    |     no `Baz` in `bar`\n \n error[E0432]: unresolved import `food::baz`\n-  --> $DIR/unresolved-import.rs:9:5\n+  --> $DIR/unresolved-import.rs:10:5\n    |\n LL | use food::baz;\n    |     ^^^^^^---\n@@ -23,7 +25,7 @@ LL | use food::baz;\n    |     no `baz` in `food`\n \n error[E0432]: unresolved import `food::beens`\n-  --> $DIR/unresolved-import.rs:14:12\n+  --> $DIR/unresolved-import.rs:15:12\n    |\n LL | use food::{beens as Foo};\n    |            -----^^^^^^^\n@@ -32,13 +34,13 @@ LL | use food::{beens as Foo};\n    |            help: a similar name exists in the module: `beans`\n \n error[E0432]: unresolved import `MyEnum`\n-  --> $DIR/unresolved-import.rs:38:9\n+  --> $DIR/unresolved-import.rs:39:9\n    |\n LL |     use MyEnum::*;\n    |         ^^^^^^ help: a similar path exists: `self::MyEnum`\n \n error[E0432]: unresolved import `Enum`\n-  --> $DIR/unresolved-import.rs:48:9\n+  --> $DIR/unresolved-import.rs:49:9\n    |\n LL |     use Enum::*;\n    |         ^^^^ help: a similar path exists: `self::Enum`"}, {"sha": "749efd29565a9b8f47afb441aaacfcc10bc145d7", "filename": "src/tools/miri", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri?ref=b5a2d27f8f59df6f2162e61461b41d6116d4815e", "patch": "@@ -1 +1 @@\n-Subproject commit 065ff89e33b67b3527fcdd56cf8b432e593e32d4\n+Subproject commit 749efd29565a9b8f47afb441aaacfcc10bc145d7"}]}