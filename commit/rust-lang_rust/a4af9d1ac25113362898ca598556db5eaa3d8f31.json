{"sha": "a4af9d1ac25113362898ca598556db5eaa3d8f31", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0YWY5ZDFhYzI1MTEzMzYyODk4Y2E1OTg1NTZkYjVlYWEzZDhmMzE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-12T05:34:08Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-12T07:28:49Z"}, "message": "parse_pat_with_range_pat: remove unnecessary assignments.", "tree": {"sha": "bf662ebfbbf9490ea94ad692eacf72e5fdd1383c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf662ebfbbf9490ea94ad692eacf72e5fdd1383c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4af9d1ac25113362898ca598556db5eaa3d8f31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4af9d1ac25113362898ca598556db5eaa3d8f31", "html_url": "https://github.com/rust-lang/rust/commit/a4af9d1ac25113362898ca598556db5eaa3d8f31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4af9d1ac25113362898ca598556db5eaa3d8f31/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72f8043d44a8925e469daf5c10e2630c80c2a7d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/72f8043d44a8925e469daf5c10e2630c80c2a7d4", "html_url": "https://github.com/rust-lang/rust/commit/72f8043d44a8925e469daf5c10e2630c80c2a7d4"}], "stats": {"total": 54, "additions": 25, "deletions": 29}, "files": [{"sha": "21b38751831b95d5fab0a6607e3bb0b1f18ce582", "filename": "src/libsyntax/parse/parser/pat.rs", "status": "modified", "additions": 25, "deletions": 29, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a4af9d1ac25113362898ca598556db5eaa3d8f31/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af9d1ac25113362898ca598556db5eaa3d8f31/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs?ref=a4af9d1ac25113362898ca598556db5eaa3d8f31", "patch": "@@ -108,8 +108,7 @@ impl<'a> Parser<'a> {\n         maybe_whole!(self, NtPat, |x| x);\n \n         let lo = self.token.span;\n-        let pat;\n-        match self.token.kind {\n+        let pat = match self.token.kind {\n             token::BinOp(token::And) | token::AndAnd => {\n                 // Parse &pat / &mut pat\n                 self.expect_and()?;\n@@ -120,49 +119,48 @@ impl<'a> Parser<'a> {\n                     return Err(err);\n                 }\n                 let subpat = self.parse_pat_with_range_pat(false, expected)?;\n-                pat = PatKind::Ref(subpat, mutbl);\n+                PatKind::Ref(subpat, mutbl)\n             }\n             token::OpenDelim(token::Paren) => {\n                 // Parse a tuple or parenthesis pattern.\n                 let (fields, trailing_comma) = self.parse_paren_comma_seq(|p| p.parse_pat(None))?;\n \n                 // Here, `(pat,)` is a tuple pattern.\n                 // For backward compatibility, `(..)` is a tuple pattern as well.\n-                pat = if fields.len() == 1 && !(trailing_comma || fields[0].is_rest()) {\n+                if fields.len() == 1 && !(trailing_comma || fields[0].is_rest()) {\n                     PatKind::Paren(fields.into_iter().nth(0).unwrap())\n                 } else {\n                     PatKind::Tuple(fields)\n-                };\n+                }\n             }\n             token::OpenDelim(token::Bracket) => {\n                 // Parse `[pat, pat,...]` as a slice pattern.\n-                let (slice, _) = self.parse_delim_comma_seq(token::Bracket, |p| p.parse_pat(None))?;\n-                pat = PatKind::Slice(slice);\n+                PatKind::Slice(self.parse_delim_comma_seq(token::Bracket, |p| p.parse_pat(None))?.0)\n             }\n             token::DotDot => {\n                 self.bump();\n-                pat = if self.is_pat_range_end_start() {\n+                if self.is_pat_range_end_start() {\n                     // Parse `..42` for recovery.\n                     self.parse_pat_range_to(RangeEnd::Excluded, \"..\")?\n                 } else {\n                     // A rest pattern `..`.\n                     PatKind::Rest\n-                };\n+                }\n             }\n             token::DotDotEq => {\n                 // Parse `..=42` for recovery.\n                 self.bump();\n-                pat = self.parse_pat_range_to(RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\")?;\n+                self.parse_pat_range_to(RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\")?\n             }\n             token::DotDotDot => {\n                 // Parse `...42` for recovery.\n                 self.bump();\n-                pat = self.parse_pat_range_to(RangeEnd::Included(RangeSyntax::DotDotDot), \"...\")?;\n+                self.parse_pat_range_to(RangeEnd::Included(RangeSyntax::DotDotDot), \"...\")?\n             }\n             // At this point, token != &, &&, (, [\n             _ => if self.eat_keyword(kw::Underscore) {\n                 // Parse _\n-                pat = PatKind::Wild;\n+                PatKind::Wild\n             } else if self.eat_keyword(kw::Mut) {\n                 // Parse mut ident @ pat / mut ref ident @ pat\n                 let mutref_span = self.prev_span.to(self.token.span);\n@@ -179,22 +177,20 @@ impl<'a> Parser<'a> {\n                 } else {\n                     BindingMode::ByValue(Mutability::Mutable)\n                 };\n-                pat = self.parse_pat_ident(binding_mode)?;\n+                self.parse_pat_ident(binding_mode)?\n             } else if self.eat_keyword(kw::Ref) {\n                 // Parse ref ident @ pat / ref mut ident @ pat\n                 let mutbl = self.parse_mutability();\n-                pat = self.parse_pat_ident(BindingMode::ByRef(mutbl))?;\n+                self.parse_pat_ident(BindingMode::ByRef(mutbl))?\n             } else if self.eat_keyword(kw::Box) {\n-                // Parse box pat\n-                let subpat = self.parse_pat_with_range_pat(false, None)?;\n-                pat = PatKind::Box(subpat);\n+                // Parse `box pat`\n+                PatKind::Box(self.parse_pat_with_range_pat(false, None)?)\n             } else if self.token.is_ident() && !self.token.is_reserved_ident() &&\n                       self.parse_as_ident() {\n-                // Parse ident @ pat\n+                // Parse `ident @ pat`\n                 // This can give false positives and parse nullary enums,\n-                // they are dealt with later in resolve\n-                let binding_mode = BindingMode::ByValue(Mutability::Immutable);\n-                pat = self.parse_pat_ident(binding_mode)?;\n+                // they are dealt with later in resolve.\n+                self.parse_pat_ident(BindingMode::ByValue(Mutability::Immutable))?\n             } else if self.token.is_path_start() {\n                 // Parse pattern starting with a path\n                 let (qself, path) = if self.eat_lt() {\n@@ -216,7 +212,7 @@ impl<'a> Parser<'a> {\n                             delim,\n                             prior_type_ascription: self.last_type_ascription,\n                         });\n-                        pat = PatKind::Mac(mac);\n+                        PatKind::Mac(mac)\n                     }\n                     token::DotDotDot | token::DotDotEq | token::DotDot => {\n                         let (end_kind, form) = match self.token.kind {\n@@ -232,7 +228,7 @@ impl<'a> Parser<'a> {\n                         let begin = self.mk_expr(span, ExprKind::Path(qself, path), ThinVec::new());\n                         self.bump();\n                         let end = self.parse_pat_range_end_opt(&begin, form)?;\n-                        pat = PatKind::Range(begin, end, respan(op_span, end_kind));\n+                        PatKind::Range(begin, end, respan(op_span, end_kind))\n                     }\n                     token::OpenDelim(token::Brace) => {\n                         if qself.is_some() {\n@@ -249,7 +245,7 @@ impl<'a> Parser<'a> {\n                             (vec![], true)\n                         });\n                         self.bump();\n-                        pat = PatKind::Struct(path, fields, etc);\n+                        PatKind::Struct(path, fields, etc)\n                     }\n                     token::OpenDelim(token::Paren) => {\n                         if qself.is_some() {\n@@ -260,9 +256,9 @@ impl<'a> Parser<'a> {\n                         }\n                         // Parse tuple struct or enum pattern\n                         let (fields, _) = self.parse_paren_comma_seq(|p| p.parse_pat(None))?;\n-                        pat = PatKind::TupleStruct(path, fields)\n+                        PatKind::TupleStruct(path, fields)\n                     }\n-                    _ => pat = PatKind::Path(qself, path),\n+                    _ => PatKind::Path(qself, path),\n                 }\n             } else {\n                 // Try to parse everything else as literal with optional minus\n@@ -282,9 +278,9 @@ impl<'a> Parser<'a> {\n                                         on a range-operator token\")\n                             };\n                             let end = self.parse_pat_range_end_opt(&begin, form)?;\n-                            pat = PatKind::Range(begin, end, respan(op_span, end_kind))\n+                            PatKind::Range(begin, end, respan(op_span, end_kind))\n                         } else {\n-                            pat = PatKind::Lit(begin);\n+                            PatKind::Lit(begin)\n                         }\n                     }\n                     Err(mut err) => {\n@@ -305,7 +301,7 @@ impl<'a> Parser<'a> {\n                     }\n                 }\n             }\n-        }\n+        };\n \n         let pat = self.mk_pat(lo.to(self.prev_span), pat);\n         let pat = self.maybe_recover_from_bad_qpath(pat, true)?;"}]}