{"sha": "d8ef907886e34fe314f1aacc342c4a49cb34ad6a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4ZWY5MDc4ODZlMzRmZTMxNGYxYWFjYzM0MmM0YTQ5Y2IzNGFkNmE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-28T04:45:54Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-05T06:33:09Z"}, "message": "or-patterns: adjust lowering of `ast::Arm` & `ast::ExprKind::Let`.\n\nIntroduces a temporary hack to keep `Vec<P<Pat>>` in\n`hir::Arm.pats` so that we keep the changes more incremental.", "tree": {"sha": "238d67525a6a8ed549616e6a4bd124d636bcb2ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/238d67525a6a8ed549616e6a4bd124d636bcb2ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8ef907886e34fe314f1aacc342c4a49cb34ad6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8ef907886e34fe314f1aacc342c4a49cb34ad6a", "html_url": "https://github.com/rust-lang/rust/commit/d8ef907886e34fe314f1aacc342c4a49cb34ad6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8ef907886e34fe314f1aacc342c4a49cb34ad6a/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3fccbac4d3810534b41d325f2dc132417d3e0d57", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fccbac4d3810534b41d325f2dc132417d3e0d57", "html_url": "https://github.com/rust-lang/rust/commit/3fccbac4d3810534b41d325f2dc132417d3e0d57"}], "stats": {"total": 118, "additions": 72, "deletions": 46}, "files": [{"sha": "190b50b10b281635f4ae2cdee1fc4ee9b1f9b5e4", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d8ef907886e34fe314f1aacc342c4a49cb34ad6a/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8ef907886e34fe314f1aacc342c4a49cb34ad6a/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=d8ef907886e34fe314f1aacc342c4a49cb34ad6a", "patch": "@@ -425,19 +425,44 @@ impl<'a> LoweringContext<'a> {\n \n         impl<'tcx, 'interner> Visitor<'tcx> for MiscCollector<'tcx, 'interner> {\n             fn visit_pat(&mut self, p: &'tcx Pat) {\n-                match p.node {\n+                if let PatKind::Paren(..) | PatKind::Rest = p.node {\n                     // Doesn't generate a HIR node\n-                    PatKind::Paren(..) | PatKind::Rest => {},\n-                    _ => {\n-                        if let Some(owner) = self.hir_id_owner {\n-                            self.lctx.lower_node_id_with_owner(p.id, owner);\n-                        }\n-                    }\n-                };\n+                } else if let Some(owner) = self.hir_id_owner {\n+                    self.lctx.lower_node_id_with_owner(p.id, owner);\n+                }\n \n                 visit::walk_pat(self, p)\n             }\n \n+            // HACK(or_patterns; Centril | dlrobertson): Avoid creating\n+            // HIR  nodes for `PatKind::Or` for the top level of a `ast::Arm`.\n+            // This is a temporary hack that should go away once we push down\n+            // `arm.pats: HirVec<P<Pat>>` -> `arm.pat: P<Pat>` to HIR. // Centril\n+            fn visit_arm(&mut self, arm: &'tcx Arm) {\n+                match &arm.pat.node {\n+                    PatKind::Or(pats) => pats.iter().for_each(|p| self.visit_pat(p)),\n+                    _ => self.visit_pat(&arm.pat),\n+                }\n+                walk_list!(self, visit_expr, &arm.guard);\n+                self.visit_expr(&arm.body);\n+                walk_list!(self, visit_attribute, &arm.attrs);\n+            }\n+\n+            // HACK(or_patterns; Centril | dlrobertson): Same as above. // Centril\n+            fn visit_expr(&mut self, e: &'tcx Expr) {\n+                if let ExprKind::Let(pat, scrutinee) = &e.node {\n+                    walk_list!(self, visit_attribute, e.attrs.iter());\n+                    match &pat.node {\n+                        PatKind::Or(pats) => pats.iter().for_each(|p| self.visit_pat(p)),\n+                        _ => self.visit_pat(&pat),\n+                    }\n+                    self.visit_expr(scrutinee);\n+                    self.visit_expr_post(e);\n+                    return;\n+                }\n+                visit::walk_expr(self, e)\n+            }\n+\n             fn visit_item(&mut self, item: &'tcx Item) {\n                 let hir_id = self.lctx.allocate_hir_id_counter(item.id);\n "}, {"sha": "0d8986ddec3c7fe7e0a86d08aecf10dd145878cb", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/d8ef907886e34fe314f1aacc342c4a49cb34ad6a/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8ef907886e34fe314f1aacc342c4a49cb34ad6a/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=d8ef907886e34fe314f1aacc342c4a49cb34ad6a", "patch": "@@ -68,7 +68,7 @@ impl LoweringContext<'_> {\n                 let ohs = P(self.lower_expr(ohs));\n                 hir::ExprKind::AddrOf(m, ohs)\n             }\n-            ExprKind::Let(ref pats, ref scrutinee) => self.lower_expr_let(e.span, pats, scrutinee),\n+            ExprKind::Let(ref pat, ref scrutinee) => self.lower_expr_let(e.span, pat, scrutinee),\n             ExprKind::If(ref cond, ref then, ref else_opt) => {\n                 self.lower_expr_if(e.span, cond, then, else_opt.as_deref())\n             }\n@@ -227,16 +227,11 @@ impl LoweringContext<'_> {\n         }\n     }\n \n-    /// Emit an error and lower `ast::ExprKind::Let(pats, scrutinee)` into:\n+    /// Emit an error and lower `ast::ExprKind::Let(pat, scrutinee)` into:\n     /// ```rust\n     /// match scrutinee { pats => true, _ => false }\n     /// ```\n-    fn lower_expr_let(\n-        &mut self,\n-        span: Span,\n-        pats: &[AstP<Pat>],\n-        scrutinee: &Expr\n-    ) -> hir::ExprKind {\n+    fn lower_expr_let(&mut self, span: Span, pat: &Pat, scrutinee: &Expr) -> hir::ExprKind {\n         // If we got here, the `let` expression is not allowed.\n         self.sess\n             .struct_span_err(span, \"`let` expressions are not supported here\")\n@@ -246,23 +241,23 @@ impl LoweringContext<'_> {\n \n         // For better recovery, we emit:\n         // ```\n-        // match scrutinee { pats => true, _ => false }\n+        // match scrutinee { pat => true, _ => false }\n         // ```\n         // While this doesn't fully match the user's intent, it has key advantages:\n         // 1. We can avoid using `abort_if_errors`.\n-        // 2. We can typeck both `pats` and `scrutinee`.\n-        // 3. `pats` is allowed to be refutable.\n+        // 2. We can typeck both `pat` and `scrutinee`.\n+        // 3. `pat` is allowed to be refutable.\n         // 4. The return type of the block is `bool` which seems like what the user wanted.\n         let scrutinee = self.lower_expr(scrutinee);\n         let then_arm = {\n-            let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n+            let pat = self.lower_pat_top_hack(pat);\n             let expr = self.expr_bool(span, true);\n-            self.arm(pats, P(expr))\n+            self.arm(pat, P(expr))\n         };\n         let else_arm = {\n-            let pats = hir_vec![self.pat_wild(span)];\n+            let pat = self.pat_wild(span);\n             let expr = self.expr_bool(span, false);\n-            self.arm(pats, P(expr))\n+            self.arm(hir_vec![pat], P(expr))\n         };\n         hir::ExprKind::Match(\n             P(scrutinee),\n@@ -291,13 +286,12 @@ impl LoweringContext<'_> {\n         // Handle then + scrutinee:\n         let then_blk = self.lower_block(then, false);\n         let then_expr = self.expr_block(then_blk, ThinVec::new());\n-        let (then_pats, scrutinee, desugar) = match cond.node {\n+        let (then_pat, scrutinee, desugar) = match cond.node {\n             // `<pat> => <then>`:\n-            ExprKind::Let(ref pats, ref scrutinee) => {\n+            ExprKind::Let(ref pat, ref scrutinee) => {\n                 let scrutinee = self.lower_expr(scrutinee);\n-                let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n-                let desugar = hir::MatchSource::IfLetDesugar { contains_else_clause };\n-                (pats, scrutinee, desugar)\n+                let pat = self.lower_pat_top_hack(pat);\n+                (pat, scrutinee, hir::MatchSource::IfLetDesugar { contains_else_clause })\n             }\n             // `true => <then>`:\n             _ => {\n@@ -312,13 +306,11 @@ impl LoweringContext<'_> {\n                 // to preserve drop semantics since `if cond { ... }` does not\n                 // let temporaries live outside of `cond`.\n                 let cond = self.expr_drop_temps(span_block, P(cond), ThinVec::new());\n-\n-                let desugar = hir::MatchSource::IfDesugar { contains_else_clause };\n-                let pats = hir_vec![self.pat_bool(span, true)];\n-                (pats, cond, desugar)\n+                let pat = self.pat_bool(span, true);\n+                (hir_vec![pat], cond, hir::MatchSource::IfDesugar { contains_else_clause })\n             }\n         };\n-        let then_arm = self.arm(then_pats, P(then_expr));\n+        let then_arm = self.arm(then_pat, P(then_expr));\n \n         hir::ExprKind::Match(P(scrutinee), vec![then_arm, else_arm].into(), desugar)\n     }\n@@ -345,8 +337,8 @@ impl LoweringContext<'_> {\n         // Handle then + scrutinee:\n         let then_blk = self.lower_block(body, false);\n         let then_expr = self.expr_block(then_blk, ThinVec::new());\n-        let (then_pats, scrutinee, desugar, source) = match cond.node {\n-            ExprKind::Let(ref pats, ref scrutinee) => {\n+        let (then_pat, scrutinee, desugar, source) = match cond.node {\n+            ExprKind::Let(ref pat, ref scrutinee) => {\n                 // to:\n                 //\n                 //   [opt_ident]: loop {\n@@ -356,9 +348,8 @@ impl LoweringContext<'_> {\n                 //     }\n                 //   }\n                 let scrutinee = self.with_loop_condition_scope(|t| t.lower_expr(scrutinee));\n-                let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n-                let desugar = hir::MatchSource::WhileLetDesugar;\n-                (pats, scrutinee, desugar, hir::LoopSource::WhileLet)\n+                let pat = self.lower_pat_top_hack(pat);\n+                (pat, scrutinee, hir::MatchSource::WhileLetDesugar, hir::LoopSource::WhileLet)\n             }\n             _ => {\n                 // We desugar: `'label: while $cond $body` into:\n@@ -383,14 +374,12 @@ impl LoweringContext<'_> {\n                 // to preserve drop semantics since `while cond { ... }` does not\n                 // let temporaries live outside of `cond`.\n                 let cond = self.expr_drop_temps(span_block, P(cond), ThinVec::new());\n-\n-                let desugar = hir::MatchSource::WhileDesugar;\n                 // `true => <then>`:\n-                let pats = hir_vec![self.pat_bool(span, true)];\n-                (pats, cond, desugar, hir::LoopSource::While)\n+                let pat = self.pat_bool(span, true);\n+                (hir_vec![pat], cond, hir::MatchSource::WhileDesugar, hir::LoopSource::While)\n             }\n         };\n-        let then_arm = self.arm(then_pats, P(then_expr));\n+        let then_arm = self.arm(then_pat, P(then_expr));\n \n         // `match <scrutinee> { ... }`\n         let match_expr = self.expr_match(\n@@ -440,7 +429,7 @@ impl LoweringContext<'_> {\n         hir::Arm {\n             hir_id: self.next_id(),\n             attrs: self.lower_attrs(&arm.attrs),\n-            pats: arm.pats.iter().map(|x| self.lower_pat(x)).collect(),\n+            pats: self.lower_pat_top_hack(&arm.pat),\n             guard: match arm.guard {\n                 Some(ref x) => Some(hir::Guard::If(P(self.lower_expr(x)))),\n                 _ => None,\n@@ -450,6 +439,16 @@ impl LoweringContext<'_> {\n         }\n     }\n \n+    /// HACK(or_patterns; Centril | dlrobertson): For now we don't push down top level or-patterns\n+    /// `p | q` into `hir::PatKind::Or(...)` as post-lowering bits of the compiler are not ready\n+    /// to deal with it. This should by fixed by pushing it down to HIR and then HAIR.\n+    fn lower_pat_top_hack(&mut self, pat: &Pat) -> HirVec<P<hir::Pat>> {\n+        match pat.node {\n+            PatKind::Or(ref ps) => ps.iter().map(|x| self.lower_pat(x)).collect(),\n+            _ => hir_vec![self.lower_pat(pat)],\n+        }\n+    }\n+\n     pub(super) fn make_async_expr(\n         &mut self,\n         capture_clause: CaptureBy,\n@@ -1255,7 +1254,6 @@ impl LoweringContext<'_> {\n                 ThinVec::from(attrs.clone()),\n             ));\n             let ok_pat = self.pat_ok(span, val_pat);\n-\n             self.arm(hir_vec![ok_pat], val_expr)\n         };\n \n@@ -1486,7 +1484,10 @@ impl LoweringContext<'_> {\n         }\n     }\n \n-    fn arm(&mut self, pats: hir::HirVec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n+    /// HACK(or_patterns; Centril | dlrobertson): For now we don't push down top level or-patterns\n+    /// `p | q` into `hir::PatKind::Or(...)` as post-lowering bits of the compiler are not ready\n+    /// to deal with it. This should by fixed by pushing it down to HIR and then HAIR.\n+    fn arm(&mut self, pats: HirVec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n         hir::Arm {\n             hir_id: self.next_id(),\n             attrs: hir_vec![],"}]}