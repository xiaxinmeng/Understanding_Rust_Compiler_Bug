{"sha": "1a7f6d504a12f826b59c2cee3067fe02701aef04", "node_id": "C_kwDOAAsO6NoAKDFhN2Y2ZDUwNGExMmY4MjZiNTljMmNlZTMwNjdmZTAyNzAxYWVmMDQ", "commit": {"author": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-05-07T20:30:15Z"}, "committer": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-05-11T21:42:39Z"}, "message": "Use proper atomic rmw for {mutex, rwlock, cond, srwlock}_get_or_create_id", "tree": {"sha": "eb64c570f10efdb35d0deef26aead47f22d737d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb64c570f10efdb35d0deef26aead47f22d737d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a7f6d504a12f826b59c2cee3067fe02701aef04", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE7dcbcBMl24/h63ldGBtJ+fOPM3QFAmJ8LdEACgkQGBtJ+fOP\nM3SXrQv/Uk6H8ZUOy2YLPgk2oCLWeatHXRDOu+phvJi4yBgqndcDa6UbqQOX++Ha\nlyye88VVpebladCtcTxzV6nkA680BomCPl0ynsi/D4xJ8Ic3kUHPC/lhHSkYj+qF\nmMQjSK5huHBzYhesmbbzhsRTkhxSQ/Jv/lHn+Ml9+cY1h183dWwk+kiwSadVqx+Q\nZAkoPT8MumyF21ArrlUyK/1jT6Ms3xSsE/Van7WgeIMplYRQEYm0k3X73ojKtZar\n4Y0DvbEOCv7yA9Xjt0ysl9ZrhUUmdD6+j9uN7Cs69nW6jtB9PgbpaSOGn5RmjtSL\nVvh47gPbJj5LrELrAFET8wAtGgntc6JznuiYeGVBAuKY5PgXeTbLSM5CyOrKj/nj\n2kBy2Zj68D3E+rjheUk4jbGkkEg2mKcmDFLc3huorAPckOGuLBk3t7uUrnsEonlP\nU7lTduxOnk0ikNGSYOyrq2R43UTtMjfFuJdRleLIB2nAZ9O2lDjcQHhyneRaDoHY\nfXj5gXum\n=vYp6\n-----END PGP SIGNATURE-----", "payload": "tree eb64c570f10efdb35d0deef26aead47f22d737d4\nparent f84a976a771f971d53b980ac3a950e2fe5f85f6e\nauthor Andy Wang <cbeuw.andy@gmail.com> 1651955415 +0100\ncommitter Andy Wang <cbeuw.andy@gmail.com> 1652305359 +0100\n\nUse proper atomic rmw for {mutex, rwlock, cond, srwlock}_get_or_create_id\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a7f6d504a12f826b59c2cee3067fe02701aef04", "html_url": "https://github.com/rust-lang/rust/commit/1a7f6d504a12f826b59c2cee3067fe02701aef04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a7f6d504a12f826b59c2cee3067fe02701aef04/comments", "author": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f84a976a771f971d53b980ac3a950e2fe5f85f6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f84a976a771f971d53b980ac3a950e2fe5f85f6e", "html_url": "https://github.com/rust-lang/rust/commit/f84a976a771f971d53b980ac3a950e2fe5f85f6e"}], "stats": {"total": 132, "additions": 97, "deletions": 35}, "files": [{"sha": "b7ccaa35305e7f4d427df52a58c09e74cd8c7b45", "filename": "src/data_race.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1a7f6d504a12f826b59c2cee3067fe02701aef04/src%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a7f6d504a12f826b59c2cee3067fe02701aef04/src%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdata_race.rs?ref=1a7f6d504a12f826b59c2cee3067fe02701aef04", "patch": "@@ -441,21 +441,33 @@ impl MemoryCellClocks {\n /// Evaluation context extensions.\n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n-    /// Atomic variant of read_scalar_at_offset.\n-    fn read_scalar_at_offset_atomic(\n+    /// Calculates the MPlaceTy given the offset and layout of an access on an operand\n+    fn offset_and_layout_to_place(\n         &self,\n         op: &OpTy<'tcx, Tag>,\n         offset: u64,\n         layout: TyAndLayout<'tcx>,\n-        atomic: AtomicReadOp,\n-    ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, Tag>> {\n         let this = self.eval_context_ref();\n         let op_place = this.deref_operand(op)?;\n         let offset = Size::from_bytes(offset);\n \n-        // Ensure that the following read at an offset is within bounds.\n+        // Ensure that the access is within bounds.\n         assert!(op_place.layout.size >= offset + layout.size);\n         let value_place = op_place.offset(offset, MemPlaceMeta::None, layout, this)?;\n+        Ok(value_place)\n+    }\n+\n+    /// Atomic variant of read_scalar_at_offset.\n+    fn read_scalar_at_offset_atomic(\n+        &self,\n+        op: &OpTy<'tcx, Tag>,\n+        offset: u64,\n+        layout: TyAndLayout<'tcx>,\n+        atomic: AtomicReadOp,\n+    ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+        let this = self.eval_context_ref();\n+        let value_place = this.offset_and_layout_to_place(op, offset, layout)?;\n         this.read_scalar_atomic(&value_place, atomic)\n     }\n \n@@ -469,12 +481,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         atomic: AtomicWriteOp,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let op_place = this.deref_operand(op)?;\n-        let offset = Size::from_bytes(offset);\n-\n-        // Ensure that the following read at an offset is within bounds.\n-        assert!(op_place.layout.size >= offset + layout.size);\n-        let value_place = op_place.offset(offset, MemPlaceMeta::None, layout, this)?;\n+        let value_place = this.offset_and_layout_to_place(op, offset, layout)?;\n         this.write_scalar_atomic(value.into(), &value_place, atomic)\n     }\n "}, {"sha": "f8c680c0e828b9629a3dd6a083055ea29e44b04b", "filename": "src/shims/posix/sync.rs", "status": "modified", "additions": 43, "deletions": 18, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1a7f6d504a12f826b59c2cee3067fe02701aef04/src%2Fshims%2Fposix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a7f6d504a12f826b59c2cee3067fe02701aef04/src%2Fshims%2Fposix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fsync.rs?ref=1a7f6d504a12f826b59c2cee3067fe02701aef04", "patch": "@@ -112,15 +112,23 @@ fn mutex_get_or_create_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     mutex_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, MutexId> {\n-    let id = mutex_get_id(ecx, mutex_op)?.to_u32()?;\n-    if id == 0 {\n-        // 0 is a default value and also not a valid mutex id. Need to allocate\n-        // a new mutex.\n+    let value_place = ecx.offset_and_layout_to_place(mutex_op, 4, ecx.machine.layouts.u32)?;\n+    let (old, success) = ecx\n+        .atomic_compare_exchange_scalar(\n+            &value_place,\n+            &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n+            ecx.mutex_next_id().to_u32_scalar().into(),\n+            AtomicRwOp::Relaxed,\n+            AtomicReadOp::Relaxed,\n+            false,\n+        )?\n+        .to_scalar_pair()?;\n+\n+    if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n         let id = ecx.mutex_create();\n-        mutex_set_id(ecx, mutex_op, id.to_u32_scalar())?;\n         Ok(id)\n     } else {\n-        Ok(MutexId::from_u32(id))\n+        Ok(MutexId::from_u32(old.to_u32().expect(\"layout is u32\")))\n     }\n }\n \n@@ -156,15 +164,23 @@ fn rwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     rwlock_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, RwLockId> {\n-    let id = rwlock_get_id(ecx, rwlock_op)?.to_u32()?;\n-    if id == 0 {\n-        // 0 is a default value and also not a valid rwlock id. Need to allocate\n-        // a new read-write lock.\n+    let value_place = ecx.offset_and_layout_to_place(rwlock_op, 4, ecx.machine.layouts.u32)?;\n+    let (old, success) = ecx\n+        .atomic_compare_exchange_scalar(\n+            &value_place,\n+            &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n+            ecx.rwlock_next_id().to_u32_scalar().into(),\n+            AtomicRwOp::Relaxed,\n+            AtomicReadOp::Relaxed,\n+            false,\n+        )?\n+        .to_scalar_pair()?;\n+\n+    if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n         let id = ecx.rwlock_create();\n-        rwlock_set_id(ecx, rwlock_op, id.to_u32_scalar())?;\n         Ok(id)\n     } else {\n-        Ok(RwLockId::from_u32(id))\n+        Ok(RwLockId::from_u32(old.to_u32().expect(\"layout is u32\")))\n     }\n }\n \n@@ -228,15 +244,24 @@ fn cond_get_or_create_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     cond_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, CondvarId> {\n-    let id = cond_get_id(ecx, cond_op)?.to_u32()?;\n-    if id == 0 {\n-        // 0 is a default value and also not a valid conditional variable id.\n-        // Need to allocate a new id.\n+    let value_place = ecx.offset_and_layout_to_place(cond_op, 4, ecx.machine.layouts.u32)?;\n+\n+    let (old, success) = ecx\n+        .atomic_compare_exchange_scalar(\n+            &value_place,\n+            &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n+            ecx.condvar_next_id().to_u32_scalar().into(),\n+            AtomicRwOp::Relaxed,\n+            AtomicReadOp::Relaxed,\n+            false,\n+        )?\n+        .to_scalar_pair()?;\n+\n+    if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n         let id = ecx.condvar_create();\n-        cond_set_id(ecx, cond_op, id.to_u32_scalar())?;\n         Ok(id)\n     } else {\n-        Ok(CondvarId::from_u32(id))\n+        Ok(CondvarId::from_u32(old.to_u32().expect(\"layout is u32\")))\n     }\n }\n "}, {"sha": "ccd65aac900fafd9b9526af0f09af0372f04dbb9", "filename": "src/shims/windows/sync.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1a7f6d504a12f826b59c2cee3067fe02701aef04/src%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a7f6d504a12f826b59c2cee3067fe02701aef04/src%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fsync.rs?ref=1a7f6d504a12f826b59c2cee3067fe02701aef04", "patch": "@@ -7,15 +7,24 @@ fn srwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     lock_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, RwLockId> {\n-    let id = ecx.read_scalar_at_offset(lock_op, 0, ecx.machine.layouts.u32)?.to_u32()?;\n-    if id == 0 {\n-        // 0 is a default value and also not a valid rwlock id. Need to allocate\n-        // a new rwlock.\n+    let value_place = ecx.offset_and_layout_to_place(lock_op, 0, ecx.machine.layouts.u32)?;\n+\n+    let (old, success) = ecx\n+        .atomic_compare_exchange_scalar(\n+            &value_place,\n+            &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n+            ecx.rwlock_next_id().to_u32_scalar().into(),\n+            AtomicRwOp::AcqRel,\n+            AtomicReadOp::Acquire,\n+            false,\n+        )?\n+        .to_scalar_pair()?;\n+\n+    if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n         let id = ecx.rwlock_create();\n-        ecx.write_scalar_at_offset(lock_op, 0, id.to_u32_scalar(), ecx.machine.layouts.u32)?;\n         Ok(id)\n     } else {\n-        Ok(RwLockId::from_u32(id))\n+        Ok(RwLockId::from_u32(old.to_u32().expect(\"layout is u32\")))\n     }\n }\n "}, {"sha": "8c5b8ebfec753d55267f7a0773f0db663ddc7731", "filename": "src/sync.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1a7f6d504a12f826b59c2cee3067fe02701aef04/src%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a7f6d504a12f826b59c2cee3067fe02701aef04/src%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsync.rs?ref=1a7f6d504a12f826b59c2cee3067fe02701aef04", "patch": "@@ -208,6 +208,13 @@ trait EvalContextExtPriv<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n // situations.\n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    #[inline]\n+    /// Peek the id of the next mutex\n+    fn mutex_next_id(&self) -> MutexId {\n+        let this = self.eval_context_ref();\n+        this.machine.threads.sync.mutexes.next_index()\n+    }\n+\n     #[inline]\n     /// Create state for a new mutex.\n     fn mutex_create(&mut self) -> MutexId {\n@@ -290,6 +297,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.block_thread(thread);\n     }\n \n+    #[inline]\n+    /// Peek the id of the next read write lock\n+    fn rwlock_next_id(&self) -> RwLockId {\n+        let this = self.eval_context_ref();\n+        this.machine.threads.sync.rwlocks.next_index()\n+    }\n+\n     #[inline]\n     /// Create state for a new read write lock.\n     fn rwlock_create(&mut self) -> RwLockId {\n@@ -438,6 +452,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.block_thread(writer);\n     }\n \n+    #[inline]\n+    /// Peek the id of the next Condvar\n+    fn condvar_next_id(&self) -> CondvarId {\n+        let this = self.eval_context_ref();\n+        this.machine.threads.sync.condvars.next_index()\n+    }\n+\n     #[inline]\n     /// Create state for a new conditional variable.\n     fn condvar_create(&mut self) -> CondvarId {"}]}