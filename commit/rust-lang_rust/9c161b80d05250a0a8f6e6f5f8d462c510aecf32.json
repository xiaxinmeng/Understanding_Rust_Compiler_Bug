{"sha": "9c161b80d05250a0a8f6e6f5f8d462c510aecf32", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljMTYxYjgwZDA1MjUwYTBhOGY2ZTZmNWY4ZDQ2MmM1MTBhZWNmMzI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-17T12:22:55Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-17T13:29:02Z"}, "message": "reading does not remove Unique, it just invalidates them", "tree": {"sha": "40dc7f253ded30b6c5d12f1f0d361e01d1f96d97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40dc7f253ded30b6c5d12f1f0d361e01d1f96d97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c161b80d05250a0a8f6e6f5f8d462c510aecf32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c161b80d05250a0a8f6e6f5f8d462c510aecf32", "html_url": "https://github.com/rust-lang/rust/commit/9c161b80d05250a0a8f6e6f5f8d462c510aecf32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c161b80d05250a0a8f6e6f5f8d462c510aecf32/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8212314441bc2a60f4f28d097eb6125c88859a13", "url": "https://api.github.com/repos/rust-lang/rust/commits/8212314441bc2a60f4f28d097eb6125c88859a13", "html_url": "https://github.com/rust-lang/rust/commit/8212314441bc2a60f4f28d097eb6125c88859a13"}], "stats": {"total": 43, "additions": 26, "deletions": 17}, "files": [{"sha": "d14d00018a7ab9a46f01c43b6e8533dc7983d68b", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9c161b80d05250a0a8f6e6f5f8d462c510aecf32/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c161b80d05250a0a8f6e6f5f8d462c510aecf32/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=9c161b80d05250a0a8f6e6f5f8d462c510aecf32", "patch": "@@ -42,6 +42,9 @@ pub enum Permission {\n     SharedReadWrite,\n     /// Greants shared read-only access.\n     SharedReadOnly,\n+    /// Grants no access, but separates two groups of SharedReadWrite so they are not\n+    /// all considered mutually compatible.\n+    Disabled,\n }\n \n /// An item in the per-location borrow stack.\n@@ -199,8 +202,8 @@ impl Default for Tag {\n impl Permission {\n     /// This defines for a given permission, whether it permits the given kind of access.\n     fn grants(self, access: AccessKind) -> bool {\n-        // All items grant read access, and except for SharedReadOnly they grant write access.\n-        access == AccessKind::Read || self != Permission::SharedReadOnly\n+        // Disabled grants nother. Otherwise, all items grant read access, and except for SharedReadOnly they grant write access.\n+        self != Permission::Disabled && (access == AccessKind::Read || self != Permission::SharedReadOnly)\n     }\n }\n \n@@ -224,12 +227,14 @@ impl<'tcx> Stack {\n     }\n \n     /// Find the first write-incompatible item above the given one -- \n-    /// i.e, find the heigh to which the stack will be truncated when writing to `granting`.\n+    /// i.e, find the height to which the stack will be truncated when writing to `granting`.\n     fn find_first_write_incompaible(&self, granting: usize) -> usize {\n         let perm = self.borrows[granting].perm;\n         match perm {\n             Permission::SharedReadOnly =>\n                 bug!(\"Cannot use SharedReadOnly for writing\"),\n+            Permission::Disabled =>\n+                bug!(\"Cannot use Disabled for anything\"),\n             Permission::Unique =>\n                 // On a write, everything above us is incompatible.\n                 granting+1,\n@@ -250,10 +255,8 @@ impl<'tcx> Stack {\n         }\n     }\n \n-    /// Remove the given item, enforcing barriers.\n-    /// `tag` is just used for the error message.\n-    fn remove(&mut self, idx: usize, tag: Option<Tag>, global: &GlobalState) -> EvalResult<'tcx> {\n-        let item = self.borrows.remove(idx);\n+    /// Check if the given item is protected.\n+    fn check_protector(item: &Item, tag: Option<Tag>, global: &GlobalState) -> EvalResult<'tcx> {\n         if let Some(call) = item.protector {\n             if global.is_active(call) {\n                 if let Some(tag) = tag {\n@@ -268,7 +271,6 @@ impl<'tcx> Stack {\n                 }\n             }\n         }\n-        trace!(\"access: removing item {}\", item);\n         Ok(())\n     }\n \n@@ -295,20 +297,26 @@ impl<'tcx> Stack {\n             // Remove everything above the write-compatible items, like a proper stack. This makes sure read-only and unique\n             // pointers become invalid on write accesses (ensures F2a, and ensures U2 for write accesses).\n             let first_incompatible_idx = self.find_first_write_incompaible(granting_idx);\n-            for idx in (first_incompatible_idx..self.borrows.len()).rev() {\n-                self.remove(idx, Some(tag), global)?;\n+            while self.borrows.len() > first_incompatible_idx {\n+                let item = self.borrows.pop().unwrap();\n+                trace!(\"access: popping item {}\", item);\n+                Stack::check_protector(&item, Some(tag), global)?;\n             }\n         } else {\n-            // On a read, remove all `Unique` above the granting item.  This ensures U2 for read accesses.\n-            // The reason this is not following the stack discipline is that in\n-            // `let raw = &mut *x as *mut _; let _val = *x;`, the second statement\n+            // On a read, *disable* all `Unique` above the granting item.  This ensures U2 for read accesses.\n+            // The reason this is not following the stack discipline (by removing the first Unique and\n+            // everything on top of it) is that in `let raw = &mut *x as *mut _; let _val = *x;`, the second statement\n             // would pop the `Unique` from the reborrow of the first statement, and subsequently also pop the\n             // `SharedReadWrite` for `raw`.\n             // This pattern occurs a lot in the standard library: create a raw pointer, then also create a shared\n             // reference and use that.\n+            // We *disable* instead of removing `Unique` to avoid \"connecting\" two neighbouring blocks of SRWs.\n             for idx in (granting_idx+1 .. self.borrows.len()).rev() {\n-                if self.borrows[idx].perm == Permission::Unique {\n-                    self.remove(idx, Some(tag), global)?;\n+                let item = &mut self.borrows[idx];\n+                if item.perm == Permission::Unique {\n+                    trace!(\"access: disabling item {}\", item);\n+                    Stack::check_protector(item, Some(tag), global)?;\n+                    item.perm = Permission::Disabled;\n                 }\n             }\n         }\n@@ -332,8 +340,9 @@ impl<'tcx> Stack {\n             )))?;\n \n         // Step 2: Remove all items.  Also checks for protectors.\n-        for idx in (0..self.borrows.len()).rev() {\n-            self.remove(idx, None, global)?;\n+        while self.borrows.len() > 0 {\n+            let item = self.borrows.pop().unwrap();\n+            Stack::check_protector(&item, None, global)?;\n         }\n \n         Ok(())"}]}