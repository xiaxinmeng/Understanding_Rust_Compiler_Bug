{"sha": "170c4399e614fe599c3d41306b3429ca8b3b68c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3MGM0Mzk5ZTYxNGZlNTk5YzNkNDEzMDZiMzQyOWNhOGIzYjY4YzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-14T00:41:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-14T00:41:55Z"}, "message": "auto merge of #21018 : tomjakubowski/rust/rustdoc-where-xcrate, r=alexcrichton\n\nVarious fixes for `rustdoc`, including showing where clauses\r\nfinally on re-exported items.", "tree": {"sha": "5676cfc1897db9fc6e3002f4fafbd3d6dd9fbde4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5676cfc1897db9fc6e3002f4fafbd3d6dd9fbde4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/170c4399e614fe599c3d41306b3429ca8b3b68c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/170c4399e614fe599c3d41306b3429ca8b3b68c6", "html_url": "https://github.com/rust-lang/rust/commit/170c4399e614fe599c3d41306b3429ca8b3b68c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/170c4399e614fe599c3d41306b3429ca8b3b68c6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c366e433c14c49eee9144e6010a5fc54cbcdd341", "url": "https://api.github.com/repos/rust-lang/rust/commits/c366e433c14c49eee9144e6010a5fc54cbcdd341", "html_url": "https://github.com/rust-lang/rust/commit/c366e433c14c49eee9144e6010a5fc54cbcdd341"}, {"sha": "616db5a501510cf29acf118812c192788e4e81e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/616db5a501510cf29acf118812c192788e4e81e7", "html_url": "https://github.com/rust-lang/rust/commit/616db5a501510cf29acf118812c192788e4e81e7"}], "stats": {"total": 300, "additions": 187, "deletions": 113}, "files": [{"sha": "b65e1d1d664b4b5c67c35af05886b957d7d8a565", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 185, "deletions": 56, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/170c4399e614fe599c3d41306b3429ca8b3b68c6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/170c4399e614fe599c3d41306b3429ca8b3b68c6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=170c4399e614fe599c3d41306b3429ca8b3b68c6", "patch": "@@ -104,6 +104,12 @@ impl<T: Clean<U>, U> Clean<Option<U>> for Option<T> {\n     }\n }\n \n+impl<T, U> Clean<U> for ty::Binder<T> where T: Clean<U> {\n+    fn clean(&self, cx: &DocContext) -> U {\n+        self.0.clean(cx)\n+    }\n+}\n+\n impl<T: Clean<U>, U> Clean<Vec<U>> for syntax::owned_slice::OwnedSlice<T> {\n     fn clean(&self, cx: &DocContext) -> Vec<U> {\n         self.iter().map(|x| x.clean(cx)).collect()\n@@ -498,22 +504,28 @@ impl Clean<TyParamBound> for ast::TyParamBound {\n     }\n }\n \n-impl<'tcx> Clean<Vec<TyParamBound>> for ty::ExistentialBounds<'tcx> {\n-    fn clean(&self, cx: &DocContext) -> Vec<TyParamBound> {\n-        let mut vec = vec![];\n-        self.region_bound.clean(cx).map(|b| vec.push(RegionBound(b)));\n+impl<'tcx> Clean<(Vec<TyParamBound>, Vec<TypeBinding>)> for ty::ExistentialBounds<'tcx> {\n+    fn clean(&self, cx: &DocContext) -> (Vec<TyParamBound>, Vec<TypeBinding>) {\n+        let mut tp_bounds = vec![];\n+        self.region_bound.clean(cx).map(|b| tp_bounds.push(RegionBound(b)));\n         for bb in self.builtin_bounds.iter() {\n-            vec.push(bb.clean(cx));\n+            tp_bounds.push(bb.clean(cx));\n         }\n \n-        // FIXME(#20299) -- should do something with projection bounds\n+        let mut bindings = vec![];\n+        for &ty::Binder(ref pb) in self.projection_bounds.iter() {\n+            bindings.push(TypeBinding {\n+                name: pb.projection_ty.item_name.clean(cx),\n+                ty: pb.ty.clean(cx)\n+            });\n+        }\n \n-        vec\n+        (tp_bounds, bindings)\n     }\n }\n \n fn external_path_params(cx: &DocContext, trait_did: Option<ast::DefId>,\n-                        substs: &subst::Substs) -> PathParameters {\n+                        bindings: Vec<TypeBinding>, substs: &subst::Substs) -> PathParameters {\n     use rustc::middle::ty::sty;\n     let lifetimes = substs.regions().get_slice(subst::TypeSpace)\n                     .iter()\n@@ -531,7 +543,7 @@ fn external_path_params(cx: &DocContext, trait_did: Option<ast::DefId>,\n                     return PathParameters::AngleBracketed {\n                         lifetimes: lifetimes,\n                         types: types.clean(cx),\n-                        bindings: vec![]\n+                        bindings: bindings\n                     }\n                 }\n             };\n@@ -548,7 +560,7 @@ fn external_path_params(cx: &DocContext, trait_did: Option<ast::DefId>,\n             PathParameters::AngleBracketed {\n                 lifetimes: lifetimes,\n                 types: types.clean(cx),\n-                bindings: vec![] // FIXME(#20646)\n+                bindings: bindings\n             }\n         }\n     }\n@@ -557,12 +569,12 @@ fn external_path_params(cx: &DocContext, trait_did: Option<ast::DefId>,\n // trait_did should be set to a trait's DefId if called on a TraitRef, in order to sugar\n // from Fn<(A, B,), C> to Fn(A, B) -> C\n fn external_path(cx: &DocContext, name: &str, trait_did: Option<ast::DefId>,\n-                 substs: &subst::Substs) -> Path {\n+                 bindings: Vec<TypeBinding>, substs: &subst::Substs) -> Path {\n     Path {\n         global: false,\n         segments: vec![PathSegment {\n             name: name.to_string(),\n-            params: external_path_params(cx, trait_did, substs)\n+            params: external_path_params(cx, trait_did, bindings, substs)\n         }],\n     }\n }\n@@ -577,16 +589,16 @@ impl Clean<TyParamBound> for ty::BuiltinBound {\n         let (did, path) = match *self {\n             ty::BoundSend =>\n                 (tcx.lang_items.send_trait().unwrap(),\n-                 external_path(cx, \"Send\", None, &empty)),\n+                 external_path(cx, \"Send\", None, vec![], &empty)),\n             ty::BoundSized =>\n                 (tcx.lang_items.sized_trait().unwrap(),\n-                 external_path(cx, \"Sized\", None, &empty)),\n+                 external_path(cx, \"Sized\", None, vec![], &empty)),\n             ty::BoundCopy =>\n                 (tcx.lang_items.copy_trait().unwrap(),\n-                 external_path(cx, \"Copy\", None, &empty)),\n+                 external_path(cx, \"Copy\", None, vec![], &empty)),\n             ty::BoundSync =>\n                 (tcx.lang_items.sync_trait().unwrap(),\n-                 external_path(cx, \"Sync\", None, &empty)),\n+                 external_path(cx, \"Sync\", None, vec![], &empty)),\n         };\n         let fqn = csearch::get_item_path(tcx, did);\n         let fqn = fqn.into_iter().map(|i| i.to_string()).collect();\n@@ -603,12 +615,6 @@ impl Clean<TyParamBound> for ty::BuiltinBound {\n     }\n }\n \n-impl<'tcx> Clean<TyParamBound> for ty::PolyTraitRef<'tcx> {\n-    fn clean(&self, cx: &DocContext) -> TyParamBound {\n-        self.0.clean(cx)\n-    }\n-}\n-\n impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n     fn clean(&self, cx: &DocContext) -> TyParamBound {\n         let tcx = match cx.tcx_opt() {\n@@ -619,7 +625,7 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n         let fqn = fqn.into_iter().map(|i| i.to_string())\n                      .collect::<Vec<String>>();\n         let path = external_path(cx, fqn.last().unwrap().as_slice(),\n-                                 Some(self.def_id), self.substs);\n+                                 Some(self.def_id), vec![], self.substs);\n         cx.external_paths.borrow_mut().as_mut().unwrap().insert(self.def_id,\n                                                             (fqn, TypeTrait));\n \n@@ -730,8 +736,7 @@ impl Clean<Option<Lifetime>> for ty::Region {\n pub enum WherePredicate {\n     BoundPredicate { ty: Type, bounds: Vec<TyParamBound> },\n     RegionPredicate { lifetime: Lifetime, bounds: Vec<Lifetime>},\n-    // FIXME (#20041)\n-    EqPredicate\n+    EqPredicate { lhs: Type, rhs: Type }\n }\n \n impl Clean<WherePredicate> for ast::WherePredicate {\n@@ -752,12 +757,89 @@ impl Clean<WherePredicate> for ast::WherePredicate {\n             }\n \n             ast::WherePredicate::EqPredicate(_) => {\n-                WherePredicate::EqPredicate\n+                unimplemented!() // FIXME(#20041)\n             }\n         }\n     }\n }\n \n+impl<'a> Clean<WherePredicate> for ty::Predicate<'a> {\n+    fn clean(&self, cx: &DocContext) -> WherePredicate {\n+        use rustc::middle::ty::Predicate;\n+\n+        match *self {\n+            Predicate::Trait(ref pred) => pred.clean(cx),\n+            Predicate::Equate(ref pred) => pred.clean(cx),\n+            Predicate::RegionOutlives(ref pred) => pred.clean(cx),\n+            Predicate::TypeOutlives(ref pred) => pred.clean(cx),\n+            Predicate::Projection(ref pred) => pred.clean(cx)\n+        }\n+    }\n+}\n+\n+impl<'a> Clean<WherePredicate> for ty::TraitPredicate<'a> {\n+    fn clean(&self, cx: &DocContext) -> WherePredicate {\n+        WherePredicate::BoundPredicate {\n+            ty: self.trait_ref.substs.self_ty().clean(cx).unwrap(),\n+            bounds: vec![self.trait_ref.clean(cx)]\n+        }\n+    }\n+}\n+\n+impl<'tcx> Clean<WherePredicate> for ty::EquatePredicate<'tcx> {\n+    fn clean(&self, cx: &DocContext) -> WherePredicate {\n+        let ty::EquatePredicate(ref lhs, ref rhs) = *self;\n+        WherePredicate::EqPredicate {\n+            lhs: lhs.clean(cx),\n+            rhs: rhs.clean(cx)\n+        }\n+    }\n+}\n+\n+impl Clean<WherePredicate> for ty::OutlivesPredicate<ty::Region, ty::Region> {\n+    fn clean(&self, cx: &DocContext) -> WherePredicate {\n+        let ty::OutlivesPredicate(ref a, ref b) = *self;\n+        WherePredicate::RegionPredicate {\n+            lifetime: a.clean(cx).unwrap(),\n+            bounds: vec![b.clean(cx).unwrap()]\n+        }\n+    }\n+}\n+\n+impl<'tcx> Clean<WherePredicate> for ty::OutlivesPredicate<ty::Ty<'tcx>, ty::Region> {\n+    fn clean(&self, cx: &DocContext) -> WherePredicate {\n+        let ty::OutlivesPredicate(ref ty, ref lt) = *self;\n+\n+        WherePredicate::BoundPredicate {\n+            ty: ty.clean(cx),\n+            bounds: vec![TyParamBound::RegionBound(lt.clean(cx).unwrap())]\n+        }\n+    }\n+}\n+\n+impl<'tcx> Clean<WherePredicate> for ty::ProjectionPredicate<'tcx> {\n+    fn clean(&self, cx: &DocContext) -> WherePredicate {\n+        WherePredicate::EqPredicate {\n+            lhs: self.projection_ty.clean(cx),\n+            rhs: self.ty.clean(cx)\n+        }\n+    }\n+}\n+\n+impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n+    fn clean(&self, cx: &DocContext) -> Type {\n+        let trait_ = match self.trait_ref.clean(cx) {\n+            TyParamBound::TraitBound(t, _) => t.trait_,\n+            TyParamBound::RegionBound(_) => panic!(\"cleaning a trait got a region??\"),\n+        };\n+        Type::QPath {\n+            name: self.item_name.clean(cx),\n+            self_type: box self.trait_ref.self_ty().clean(cx),\n+            trait_: box trait_\n+        }\n+    }\n+}\n+\n // maybe use a Generic enum and use ~[Generic]?\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n pub struct Generics {\n@@ -778,11 +860,80 @@ impl Clean<Generics> for ast::Generics {\n \n impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>, subst::ParamSpace) {\n     fn clean(&self, cx: &DocContext) -> Generics {\n-        let (me, space) = *self;\n+        use std::collections::HashSet;\n+        use syntax::ast::TraitBoundModifier as TBM;\n+        use self::WherePredicate as WP;\n+\n+        fn has_sized_bound(bounds: &[TyParamBound], cx: &DocContext) -> bool {\n+            if let Some(tcx) = cx.tcx_opt() {\n+                let sized_did = match tcx.lang_items.sized_trait() {\n+                    Some(did) => did,\n+                    None => return false\n+                };\n+                for bound in bounds.iter() {\n+                    if let TyParamBound::TraitBound(PolyTrait {\n+                        trait_: Type::ResolvedPath { did, .. }, ..\n+                    }, TBM::None) = *bound {\n+                        if did == sized_did {\n+                            return true\n+                        }\n+                    }\n+                }\n+            }\n+            false\n+        }\n+\n+        let (gens, space) = *self;\n+        // Bounds in the type_params and lifetimes fields are repeated in the predicates\n+        // field (see rustc_typeck::collect::ty_generics), so remove them.\n+        let stripped_typarams = gens.types.get_slice(space).iter().map(|tp| {\n+            let mut stp = tp.clone();\n+            stp.bounds = ty::ParamBounds::empty();\n+            stp.clean(cx)\n+        }).collect::<Vec<_>>();\n+        let stripped_lifetimes = gens.regions.get_slice(space).iter().map(|rp| {\n+            let mut srp = rp.clone();\n+            srp.bounds = Vec::new();\n+            srp.clean(cx)\n+        }).collect::<Vec<_>>();\n+\n+        let where_predicates = gens.predicates.get_slice(space).to_vec().clean(cx);\n+        // Type parameters have a Sized bound by default unless removed with ?Sized.\n+        // Scan through the predicates and mark any type parameter with a Sized\n+        // bound, removing the bounds as we find them.\n+        let mut sized_params = HashSet::new();\n+        let mut where_predicates = where_predicates.into_iter().filter_map(|pred| {\n+            if let WP::BoundPredicate { ty: Type::Generic(ref g), ref bounds } = pred {\n+                if has_sized_bound(&**bounds, cx) {\n+                    sized_params.insert(g.clone());\n+                    return None\n+                }\n+            }\n+            Some(pred)\n+        }).collect::<Vec<_>>();\n+        // Finally, run through the type parameters again and insert a ?Sized unbound for\n+        // any we didn't find to be Sized.\n+        for tp in stripped_typarams.iter() {\n+            if !sized_params.contains(&tp.name) {\n+                let mut sized_bound = ty::BuiltinBound::BoundSized.clean(cx);\n+                if let TyParamBound::TraitBound(_, ref mut tbm) = sized_bound {\n+                    *tbm = TBM::Maybe\n+                };\n+                where_predicates.push(WP::BoundPredicate {\n+                    ty: Type::Generic(tp.name.clone()),\n+                    bounds: vec![sized_bound]\n+                })\n+            }\n+        }\n+\n+        // It would be nice to collect all of the bounds on a type and recombine\n+        // them if possible, to avoid e.g. `where T: Foo, T: Bar, T: Sized, T: 'a`\n+        // and instead see `where T: Foo + Bar + Sized + 'a`\n+\n         Generics {\n-            type_params: me.types.get_slice(space).to_vec().clean(cx),\n-            lifetimes: me.regions.get_slice(space).to_vec().clean(cx),\n-            where_predicates: vec![]\n+            type_params: stripped_typarams,\n+            lifetimes: stripped_lifetimes,\n+            where_predicates: where_predicates\n         }\n     }\n }\n@@ -910,27 +1061,6 @@ impl Clean<Item> for doctree::Function {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n-pub struct ClosureDecl {\n-    pub lifetimes: Vec<Lifetime>,\n-    pub decl: FnDecl,\n-    pub onceness: ast::Onceness,\n-    pub unsafety: ast::Unsafety,\n-    pub bounds: Vec<TyParamBound>,\n-}\n-\n-impl Clean<ClosureDecl> for ast::ClosureTy {\n-    fn clean(&self, cx: &DocContext) -> ClosureDecl {\n-        ClosureDecl {\n-            lifetimes: self.lifetimes.clean(cx),\n-            decl: self.decl.clean(cx),\n-            onceness: self.onceness,\n-            unsafety: self.unsafety,\n-            bounds: self.bounds.clean(cx)\n-        }\n-    }\n-}\n-\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n pub struct FnDecl {\n     pub inputs: Arguments,\n@@ -1207,8 +1337,6 @@ pub enum Type {\n     Generic(String),\n     /// Primitives are just the fixed-size numeric types (plus int/uint/float), and char.\n     Primitive(PrimitiveType),\n-    Closure(Box<ClosureDecl>),\n-    Proc(Box<ClosureDecl>),\n     /// extern \"ABI\" fn\n     BareFunction(Box<BareFunctionDecl>),\n     Tuple(Vec<Type>),\n@@ -1436,7 +1564,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     _ => TypeEnum,\n                 };\n                 let path = external_path(cx, fqn.last().unwrap().to_string().as_slice(),\n-                                         None, substs);\n+                                         None, vec![], substs);\n                 cx.external_paths.borrow_mut().as_mut().unwrap().insert(did, (fqn, kind));\n                 ResolvedPath {\n                     path: path,\n@@ -1448,12 +1576,13 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                 let did = principal.def_id();\n                 let fqn = csearch::get_item_path(cx.tcx(), did);\n                 let fqn: Vec<_> = fqn.into_iter().map(|i| i.to_string()).collect();\n+                let (typarams, bindings) = bounds.clean(cx);\n                 let path = external_path(cx, fqn.last().unwrap().to_string().as_slice(),\n-                                         Some(did), principal.substs());\n+                                         Some(did), bindings, principal.substs());\n                 cx.external_paths.borrow_mut().as_mut().unwrap().insert(did, (fqn, TypeTrait));\n                 ResolvedPath {\n                     path: path,\n-                    typarams: Some(bounds.clean(cx)),\n+                    typarams: Some(typarams),\n                     did: did,\n                 }\n             }"}, {"sha": "61d2a9ee07107c1f4a25217d27dc5f249780114d", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 2, "deletions": 57, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/170c4399e614fe599c3d41306b3429ca8b3b68c6/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/170c4399e614fe599c3d41306b3429ca8b3b68c6/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=170c4399e614fe599c3d41306b3429ca8b3b68c6", "patch": "@@ -153,8 +153,8 @@ impl<'a> fmt::String for WhereClause<'a> {\n                         try!(write!(f, \"{}\", lifetime));\n                     }\n                 }\n-                &clean::WherePredicate::EqPredicate => {\n-                    unimplemented!()\n+                &clean::WherePredicate::EqPredicate { ref lhs, ref rhs } => {\n+                    try!(write!(f, \"{} == {}\", lhs, rhs));\n                 }\n             }\n         }\n@@ -465,61 +465,6 @@ impl fmt::String for clean::Type {\n             }\n             clean::Infer => write!(f, \"_\"),\n             clean::Primitive(prim) => primitive_link(f, prim, prim.to_string()),\n-            clean::Closure(ref decl) => {\n-                write!(f, \"{style}{lifetimes}|{args}|{bounds}{arrow}\",\n-                       style = UnsafetySpace(decl.unsafety),\n-                       lifetimes = if decl.lifetimes.len() == 0 {\n-                           \"\".to_string()\n-                       } else {\n-                           format!(\"for &lt;{}&gt;\",\n-                                   CommaSep(decl.lifetimes.as_slice()))\n-                       },\n-                       args = decl.decl.inputs,\n-                       arrow = decl.decl.output,\n-                       bounds = {\n-                           let mut ret = String::new();\n-                           for bound in decl.bounds.iter() {\n-                                match *bound {\n-                                    clean::RegionBound(..) => {}\n-                                    clean::TraitBound(ref t, modifier) => {\n-                                        if ret.len() == 0 {\n-                                            ret.push_str(\": \");\n-                                        } else {\n-                                            ret.push_str(\" + \");\n-                                        }\n-                                        if modifier == ast::TraitBoundModifier::Maybe {\n-                                            ret.push_str(\"?\");\n-                                        }\n-                                        ret.push_str(format!(\"{}\",\n-                                                             *t).as_slice());\n-                                    }\n-                                }\n-                           }\n-                           ret\n-                       })\n-            }\n-            clean::Proc(ref decl) => {\n-                write!(f, \"{style}{lifetimes}proc({args}){bounds}{arrow}\",\n-                       style = UnsafetySpace(decl.unsafety),\n-                       lifetimes = if decl.lifetimes.len() == 0 {\n-                           \"\".to_string()\n-                       } else {\n-                           format!(\"for &lt;{}&gt;\",\n-                                   CommaSep(decl.lifetimes.as_slice()))\n-                       },\n-                       args = decl.decl.inputs,\n-                       bounds = if decl.bounds.len() == 0 {\n-                           \"\".to_string()\n-                       } else {\n-                           let m = decl.bounds\n-                                           .iter()\n-                                           .map(|s| s.to_string());\n-                           format!(\n-                               \": {}\",\n-                               m.collect::<Vec<String>>().connect(\" + \"))\n-                       },\n-                       arrow = decl.decl.output)\n-            }\n             clean::BareFunction(ref decl) => {\n                 write!(f, \"{}{}fn{}{}\",\n                        UnsafetySpace(decl.unsafety),"}]}