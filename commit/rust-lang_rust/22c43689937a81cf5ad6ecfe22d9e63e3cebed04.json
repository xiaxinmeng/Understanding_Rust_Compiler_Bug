{"sha": "22c43689937a81cf5ad6ecfe22d9e63e3cebed04", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyYzQzNjg5OTM3YTgxY2Y1YWQ2ZWNmZTIyZDllNjNlM2NlYmVkMDQ=", "commit": {"author": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2018-09-18T22:25:08Z"}, "committer": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2018-12-06T15:07:15Z"}, "message": "Refactor net::each_addr/lookup_host to forward error from resolve", "tree": {"sha": "137d0de6228d8ec2527b2c151c874b8d20e5b0cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/137d0de6228d8ec2527b2c151c874b8d20e5b0cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22c43689937a81cf5ad6ecfe22d9e63e3cebed04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22c43689937a81cf5ad6ecfe22d9e63e3cebed04", "html_url": "https://github.com/rust-lang/rust/commit/22c43689937a81cf5ad6ecfe22d9e63e3cebed04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22c43689937a81cf5ad6ecfe22d9e63e3cebed04/comments", "author": null, "committer": null, "parents": [{"sha": "030b1ed7f709539f5ca422758e9fe00d173aee76", "url": "https://api.github.com/repos/rust-lang/rust/commits/030b1ed7f709539f5ca422758e9fe00d173aee76", "html_url": "https://github.com/rust-lang/rust/commit/030b1ed7f709539f5ca422758e9fe00d173aee76"}], "stats": {"total": 376, "additions": 250, "deletions": 126}, "files": [{"sha": "1ac0bdf922f885a598ef691c3a34ff5ef7d1a82e", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/22c43689937a81cf5ad6ecfe22d9e63e3cebed04/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22c43689937a81cf5ad6ecfe22d9e63e3cebed04/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=22c43689937a81cf5ad6ecfe22d9e63e3cebed04", "patch": "@@ -16,10 +16,11 @@ use net::{ntoh, hton, IpAddr, Ipv4Addr, Ipv6Addr};\n use option;\n use sys::net::netc as c;\n use sys_common::{FromInner, AsInner, IntoInner};\n-use sys_common::net::lookup_host;\n+use sys_common::net::LookupHost;\n use vec;\n use iter;\n use slice;\n+use convert::TryInto;\n \n /// An internet socket address, either IPv4 or IPv6.\n ///\n@@ -863,9 +864,9 @@ impl ToSocketAddrs for (Ipv6Addr, u16) {\n     }\n }\n \n-fn resolve_socket_addr(s: &str, p: u16) -> io::Result<vec::IntoIter<SocketAddr>> {\n-    let ips = lookup_host(s)?;\n-    let v: Vec<_> = ips.map(|mut a| { a.set_port(p); a }).collect();\n+fn resolve_socket_addr(lh: LookupHost) -> io::Result<vec::IntoIter<SocketAddr>> {\n+    let p = lh.port();\n+    let v: Vec<_> = lh.map(|mut a| { a.set_port(p); a }).collect();\n     Ok(v.into_iter())\n }\n \n@@ -885,7 +886,7 @@ impl<'a> ToSocketAddrs for (&'a str, u16) {\n             return Ok(vec![SocketAddr::V6(addr)].into_iter())\n         }\n \n-        resolve_socket_addr(host, port)\n+        resolve_socket_addr((host, port).try_into()?)\n     }\n }\n \n@@ -899,22 +900,7 @@ impl ToSocketAddrs for str {\n             return Ok(vec![addr].into_iter());\n         }\n \n-        macro_rules! try_opt {\n-            ($e:expr, $msg:expr) => (\n-                match $e {\n-                    Some(r) => r,\n-                    None => return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                                      $msg)),\n-                }\n-            )\n-        }\n-\n-        // split the string by ':' and convert the second part to u16\n-        let mut parts_iter = self.rsplitn(2, ':');\n-        let port_str = try_opt!(parts_iter.next(), \"invalid socket address\");\n-        let host = try_opt!(parts_iter.next(), \"invalid socket address\");\n-        let port: u16 = try_opt!(port_str.parse().ok(), \"invalid port value\");\n-        resolve_socket_addr(host, port)\n+        resolve_socket_addr(self.try_into()?)\n     }\n }\n "}, {"sha": "ff579a5feb12dff1781534e8dd1f1a0f413f6905", "filename": "src/libstd/net/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/22c43689937a81cf5ad6ecfe22d9e63e3cebed04/src%2Flibstd%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22c43689937a81cf5ad6ecfe22d9e63e3cebed04/src%2Flibstd%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fmod.rs?ref=22c43689937a81cf5ad6ecfe22d9e63e3cebed04", "patch": "@@ -112,11 +112,15 @@ fn hton<I: NetInt>(i: I) -> I { i.to_be() }\n fn ntoh<I: NetInt>(i: I) -> I { I::from_be(i) }\n \n fn each_addr<A: ToSocketAddrs, F, T>(addr: A, mut f: F) -> io::Result<T>\n-    where F: FnMut(&SocketAddr) -> io::Result<T>\n+    where F: FnMut(io::Result<&SocketAddr>) -> io::Result<T>\n {\n+    let addrs = match addr.to_socket_addrs() {\n+        Ok(addrs) => addrs,\n+        Err(e) => return f(Err(e))\n+    };\n     let mut last_err = None;\n-    for addr in addr.to_socket_addrs()? {\n-        match f(&addr) {\n+    for addr in addrs {\n+        match f(Ok(&addr)) {\n             Ok(l) => return Ok(l),\n             Err(e) => last_err = Some(e),\n         }"}, {"sha": "7229e71d175213a0fdca195620d913e67fca97ca", "filename": "src/libstd/sys/cloudabi/shims/net.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/22c43689937a81cf5ad6ecfe22d9e63e3cebed04/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22c43689937a81cf5ad6ecfe22d9e63e3cebed04/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fnet.rs?ref=22c43689937a81cf5ad6ecfe22d9e63e3cebed04", "patch": "@@ -13,13 +13,14 @@ use io;\n use net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n use time::Duration;\n use sys::{unsupported, Void};\n+use convert::TryFrom;\n \n pub extern crate libc as netc;\n \n pub struct TcpStream(Void);\n \n impl TcpStream {\n-    pub fn connect(_: &SocketAddr) -> io::Result<TcpStream> {\n+    pub fn connect(_: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n         unsupported()\n     }\n \n@@ -105,7 +106,7 @@ impl fmt::Debug for TcpStream {\n pub struct TcpListener(Void);\n \n impl TcpListener {\n-    pub fn bind(_: &SocketAddr) -> io::Result<TcpListener> {\n+    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n         unsupported()\n     }\n \n@@ -155,7 +156,7 @@ impl fmt::Debug for TcpListener {\n pub struct UdpSocket(Void);\n \n impl UdpSocket {\n-    pub fn bind(_: &SocketAddr) -> io::Result<UdpSocket> {\n+    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {\n         unsupported()\n     }\n \n@@ -271,7 +272,7 @@ impl UdpSocket {\n         match self.0 {}\n     }\n \n-    pub fn connect(&self, _: &SocketAddr) -> io::Result<()> {\n+    pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {\n         match self.0 {}\n     }\n }\n@@ -284,13 +285,31 @@ impl fmt::Debug for UdpSocket {\n \n pub struct LookupHost(Void);\n \n+impl LookupHost {\n+    pub fn port(&self) -> u16 {\n+        match self.0 {}\n+    }\n+}\n+\n impl Iterator for LookupHost {\n     type Item = SocketAddr;\n     fn next(&mut self) -> Option<SocketAddr> {\n         match self.0 {}\n     }\n }\n \n-pub fn lookup_host(_: &str) -> io::Result<LookupHost> {\n-    unsupported()\n+impl<'a> TryFrom<&'a str> for LookupHost {\n+    type Error = io::Error;\n+\n+    fn try_from(_v: &'a str) -> io::Result<LookupHost> {\n+        unsupported()\n+    }\n+}\n+\n+impl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n+    type Error = io::Error;\n+\n+    fn try_from(_v: (&'a str, u16)) -> io::Result<LookupHost> {\n+        unsupported()\n+    }\n }"}, {"sha": "04a183f2417a9f997ea2d6c914bcc85ddc078dbe", "filename": "src/libstd/sys/redox/net/mod.rs", "status": "modified", "additions": 94, "deletions": 59, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/22c43689937a81cf5ad6ecfe22d9e63e3cebed04/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22c43689937a81cf5ad6ecfe22d9e63e3cebed04/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs?ref=22c43689937a81cf5ad6ecfe22d9e63e3cebed04", "patch": "@@ -9,14 +9,15 @@\n // except according to those terms.\n \n use fs::File;\n-use io::{Error, Result, Read};\n+use io::{Error, Read, self};\n use iter::Iterator;\n use net::{Ipv4Addr, SocketAddr, SocketAddrV4};\n use str::FromStr;\n use string::{String, ToString};\n use sys::syscall::EINVAL;\n use time::{self, Duration};\n use vec::{IntoIter, Vec};\n+use convert::{TryFrom, TryInto};\n \n use self::dns::{Dns, DnsQuery};\n \n@@ -29,7 +30,13 @@ mod dns;\n mod tcp;\n mod udp;\n \n-pub struct LookupHost(IntoIter<SocketAddr>);\n+pub struct LookupHost(IntoIter<SocketAddr>, u16);\n+\n+impl LookupHost {\n+    pub fn port(&self) -> u16 {\n+        self.1\n+    }\n+}\n \n impl Iterator for LookupHost {\n     type Item = SocketAddr;\n@@ -38,65 +45,93 @@ impl Iterator for LookupHost {\n     }\n }\n \n-pub fn lookup_host(host: &str) -> Result<LookupHost> {\n-    let mut ip_string = String::new();\n-    File::open(\"/etc/net/ip\")?.read_to_string(&mut ip_string)?;\n-    let ip: Vec<u8> = ip_string.trim().split('.').map(|part| part.parse::<u8>()\n-                               .unwrap_or(0)).collect();\n-\n-    let mut dns_string = String::new();\n-    File::open(\"/etc/net/dns\")?.read_to_string(&mut dns_string)?;\n-    let dns: Vec<u8> = dns_string.trim().split('.').map(|part| part.parse::<u8>()\n-                                 .unwrap_or(0)).collect();\n-\n-    if ip.len() == 4 && dns.len() == 4 {\n-        let time = time::SystemTime::now().duration_since(time::UNIX_EPOCH).unwrap();\n-        let tid = (time.subsec_nanos() >> 16) as u16;\n-\n-        let packet = Dns {\n-            transaction_id: tid,\n-            flags: 0x0100,\n-            queries: vec![DnsQuery {\n-                name: host.to_string(),\n-                q_type: 0x0001,\n-                q_class: 0x0001,\n-            }],\n-            answers: vec![]\n-        };\n-\n-        let packet_data = packet.compile();\n-\n-        let my_ip = Ipv4Addr::new(ip[0], ip[1], ip[2], ip[3]);\n-        let dns_ip = Ipv4Addr::new(dns[0], dns[1], dns[2], dns[3]);\n-        let socket = UdpSocket::bind(&SocketAddr::V4(SocketAddrV4::new(my_ip, 0)))?;\n-        socket.set_read_timeout(Some(Duration::new(5, 0)))?;\n-        socket.set_write_timeout(Some(Duration::new(5, 0)))?;\n-        socket.connect(&SocketAddr::V4(SocketAddrV4::new(dns_ip, 53)))?;\n-        socket.send(&packet_data)?;\n-\n-        let mut buf = [0; 65536];\n-        let count = socket.recv(&mut buf)?;\n-\n-        match Dns::parse(&buf[.. count]) {\n-            Ok(response) => {\n-                let mut addrs = vec![];\n-                for answer in response.answers.iter() {\n-                    if answer.a_type == 0x0001 && answer.a_class == 0x0001\n-                       && answer.data.len() == 4\n-                    {\n-                        let answer_ip = Ipv4Addr::new(answer.data[0],\n-                                                      answer.data[1],\n-                                                      answer.data[2],\n-                                                      answer.data[3]);\n-                        addrs.push(SocketAddr::V4(SocketAddrV4::new(answer_ip, 0)));\n-                    }\n+impl<'a> TryFrom<&'a str> for LookupHost {\n+    type Error = io::Error;\n+\n+    fn try_from(s: &str) -> io::Result<LookupHost> {\n+        macro_rules! try_opt {\n+            ($e:expr, $msg:expr) => (\n+                match $e {\n+                    Some(r) => r,\n+                    None => return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                                      $msg)),\n                 }\n-                Ok(LookupHost(addrs.into_iter()))\n-            },\n-            Err(_err) => Err(Error::from_raw_os_error(EINVAL))\n+            )\n+        }\n+\n+        // split the string by ':' and convert the second part to u16\n+        let mut parts_iter = s.rsplitn(2, ':');\n+        let port_str = try_opt!(parts_iter.next(), \"invalid socket address\");\n+        let host = try_opt!(parts_iter.next(), \"invalid socket address\");\n+        let port: u16 = try_opt!(port_str.parse().ok(), \"invalid port value\");\n+\n+        (host, port).try_into()\n+    }\n+}\n+\n+impl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n+    type Error = io::Error;\n+\n+    fn try_from((host, port): (&'a str, u16)) -> io::Result<LookupHost> {\n+        let mut ip_string = String::new();\n+        File::open(\"/etc/net/ip\")?.read_to_string(&mut ip_string)?;\n+        let ip: Vec<u8> = ip_string.trim().split('.').map(|part| part.parse::<u8>()\n+                                   .unwrap_or(0)).collect();\n+\n+        let mut dns_string = String::new();\n+        File::open(\"/etc/net/dns\")?.read_to_string(&mut dns_string)?;\n+        let dns: Vec<u8> = dns_string.trim().split('.').map(|part| part.parse::<u8>()\n+                                     .unwrap_or(0)).collect();\n+\n+        if ip.len() == 4 && dns.len() == 4 {\n+            let time = time::SystemTime::now().duration_since(time::UNIX_EPOCH).unwrap();\n+            let tid = (time.subsec_nanos() >> 16) as u16;\n+\n+            let packet = Dns {\n+                transaction_id: tid,\n+                flags: 0x0100,\n+                queries: vec![DnsQuery {\n+                    name: host.to_string(),\n+                    q_type: 0x0001,\n+                    q_class: 0x0001,\n+                }],\n+                answers: vec![]\n+            };\n+\n+            let packet_data = packet.compile();\n+\n+            let my_ip = Ipv4Addr::new(ip[0], ip[1], ip[2], ip[3]);\n+            let dns_ip = Ipv4Addr::new(dns[0], dns[1], dns[2], dns[3]);\n+            let socket = UdpSocket::bind(Ok(&SocketAddr::V4(SocketAddrV4::new(my_ip, 0))))?;\n+            socket.set_read_timeout(Some(Duration::new(5, 0)))?;\n+            socket.set_write_timeout(Some(Duration::new(5, 0)))?;\n+            socket.connect(Ok(&SocketAddr::V4(SocketAddrV4::new(dns_ip, 53))))?;\n+            socket.send(&packet_data)?;\n+\n+            let mut buf = [0; 65536];\n+            let count = socket.recv(&mut buf)?;\n+\n+            match Dns::parse(&buf[.. count]) {\n+                Ok(response) => {\n+                    let mut addrs = vec![];\n+                    for answer in response.answers.iter() {\n+                        if answer.a_type == 0x0001 && answer.a_class == 0x0001\n+                           && answer.data.len() == 4\n+                        {\n+                            let answer_ip = Ipv4Addr::new(answer.data[0],\n+                                                          answer.data[1],\n+                                                          answer.data[2],\n+                                                          answer.data[3]);\n+                            addrs.push(SocketAddr::V4(SocketAddrV4::new(answer_ip, 0)));\n+                        }\n+                    }\n+                    Ok(LookupHost(addrs.into_iter(), port))\n+                },\n+                Err(_err) => Err(Error::from_raw_os_error(EINVAL))\n+            }\n+        } else {\n+            Err(Error::from_raw_os_error(EINVAL))\n         }\n-    } else {\n-        Err(Error::from_raw_os_error(EINVAL))\n     }\n }\n "}, {"sha": "37457d87f331b6fe0affbb7008e0feb06aff7b9b", "filename": "src/libstd/sys/redox/net/tcp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/22c43689937a81cf5ad6ecfe22d9e63e3cebed04/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22c43689937a81cf5ad6ecfe22d9e63e3cebed04/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs?ref=22c43689937a81cf5ad6ecfe22d9e63e3cebed04", "patch": "@@ -24,8 +24,8 @@ use super::{path_to_peer_addr, path_to_local_addr};\n pub struct TcpStream(File);\n \n impl TcpStream {\n-    pub fn connect(addr: &SocketAddr) -> Result<TcpStream> {\n-        let path = format!(\"tcp:{}\", addr);\n+    pub fn connect(addr: Result<&SocketAddr>) -> Result<TcpStream> {\n+        let path = format!(\"tcp:{}\", addr?);\n         let mut options = OpenOptions::new();\n         options.read(true);\n         options.write(true);\n@@ -180,8 +180,8 @@ impl IntoInner<File> for TcpStream {\n pub struct TcpListener(File);\n \n impl TcpListener {\n-    pub fn bind(addr: &SocketAddr) -> Result<TcpListener> {\n-        let path = format!(\"tcp:/{}\", addr);\n+    pub fn bind(addr: Result<&SocketAddr>) -> Result<TcpListener> {\n+        let path = format!(\"tcp:/{}\", addr?);\n         let mut options = OpenOptions::new();\n         options.read(true);\n         options.write(true);"}, {"sha": "85bfd425924934ed313116e3664eecbf1d126367", "filename": "src/libstd/sys/redox/net/udp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/22c43689937a81cf5ad6ecfe22d9e63e3cebed04/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22c43689937a81cf5ad6ecfe22d9e63e3cebed04/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs?ref=22c43689937a81cf5ad6ecfe22d9e63e3cebed04", "patch": "@@ -25,8 +25,8 @@ use super::{path_to_peer_addr, path_to_local_addr};\n pub struct UdpSocket(File, UnsafeCell<Option<SocketAddr>>);\n \n impl UdpSocket {\n-    pub fn bind(addr: &SocketAddr) -> Result<UdpSocket> {\n-        let path = format!(\"udp:/{}\", addr);\n+    pub fn bind(addr: Result<&SocketAddr>) -> Result<UdpSocket> {\n+        let path = format!(\"udp:/{}\", addr?);\n         let mut options = OpenOptions::new();\n         options.read(true);\n         options.write(true);\n@@ -37,8 +37,8 @@ impl UdpSocket {\n         unsafe { &mut *(self.1.get()) }\n     }\n \n-    pub fn connect(&self, addr: &SocketAddr) -> Result<()> {\n-        unsafe { *self.1.get() = Some(*addr) };\n+    pub fn connect(&self, addr: Result<&SocketAddr>) -> Result<()> {\n+        unsafe { *self.1.get() = Some(*addr?) };\n         Ok(())\n     }\n "}, {"sha": "bbb0fd45ba3dd5f6ff0346b4f373027c088bf3c7", "filename": "src/libstd/sys/unix/l4re.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/22c43689937a81cf5ad6ecfe22d9e63e3cebed04/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22c43689937a81cf5ad6ecfe22d9e63e3cebed04/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs?ref=22c43689937a81cf5ad6ecfe22d9e63e3cebed04", "patch": "@@ -21,7 +21,7 @@ pub mod net {\n     use sys_common::{AsInner, FromInner, IntoInner};\n     use sys::fd::FileDesc;\n     use time::Duration;\n-\n+    use convert::TryFrom;\n \n     pub extern crate libc as netc;\n \n@@ -118,7 +118,7 @@ pub mod net {\n     }\n \n     impl TcpStream {\n-        pub fn connect(_: &SocketAddr) -> io::Result<TcpStream> {\n+        pub fn connect(_: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n             unimpl!();\n         }\n \n@@ -216,7 +216,7 @@ pub mod net {\n     }\n \n     impl TcpListener {\n-        pub fn bind(_: &SocketAddr) -> io::Result<TcpListener> {\n+        pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n             unimpl!();\n         }\n \n@@ -278,7 +278,7 @@ pub mod net {\n     }\n \n     impl UdpSocket {\n-        pub fn bind(_: &SocketAddr) -> io::Result<UdpSocket> {\n+        pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {\n             unimpl!();\n         }\n \n@@ -402,7 +402,7 @@ pub mod net {\n             unimpl!();\n         }\n \n-        pub fn connect(&self, _: &SocketAddr) -> io::Result<()> {\n+        pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {\n             unimpl!();\n         }\n     }\n@@ -431,11 +431,30 @@ pub mod net {\n         }\n     }\n \n+    impl LookupHost {\n+        pub fn port(&self) -> u16 {\n+            unimpl!();\n+        }\n+    }\n+\n     unsafe impl Sync for LookupHost {}\n     unsafe impl Send for LookupHost {}\n \n-    pub fn lookup_host(_: &str) -> io::Result<LookupHost> {\n-        unimpl!();\n+\n+    impl<'a> TryFrom<&'a str> for LookupHost {\n+        type Error = io::Error;\n+\n+        fn try_from(_v: &'a str) -> io::Result<LookupHost> {\n+            unimpl!();\n+        }\n+    }\n+\n+    impl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n+        type Error = io::Error;\n+\n+        fn try_from(_v: (&'a str, u16)) -> io::Result<LookupHost> {\n+            unimpl!();\n+        }\n     }\n }\n "}, {"sha": "e1c33b09cb420be121e0b323edb84f50cb313e49", "filename": "src/libstd/sys/wasm/net.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/22c43689937a81cf5ad6ecfe22d9e63e3cebed04/src%2Flibstd%2Fsys%2Fwasm%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22c43689937a81cf5ad6ecfe22d9e63e3cebed04/src%2Flibstd%2Fsys%2Fwasm%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fnet.rs?ref=22c43689937a81cf5ad6ecfe22d9e63e3cebed04", "patch": "@@ -13,11 +13,12 @@ use io;\n use net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr};\n use time::Duration;\n use sys::{unsupported, Void};\n+use convert::TryFrom;\n \n pub struct TcpStream(Void);\n \n impl TcpStream {\n-    pub fn connect(_: &SocketAddr) -> io::Result<TcpStream> {\n+    pub fn connect(_: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n         unsupported()\n     }\n \n@@ -103,7 +104,7 @@ impl fmt::Debug for TcpStream {\n pub struct TcpListener(Void);\n \n impl TcpListener {\n-    pub fn bind(_: &SocketAddr) -> io::Result<TcpListener> {\n+    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n         unsupported()\n     }\n \n@@ -153,7 +154,7 @@ impl fmt::Debug for TcpListener {\n pub struct UdpSocket(Void);\n \n impl UdpSocket {\n-    pub fn bind(_: &SocketAddr) -> io::Result<UdpSocket> {\n+    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {\n         unsupported()\n     }\n \n@@ -273,7 +274,7 @@ impl UdpSocket {\n         match self.0 {}\n     }\n \n-    pub fn connect(&self, _: &SocketAddr) -> io::Result<()> {\n+    pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {\n         match self.0 {}\n     }\n }\n@@ -286,15 +287,33 @@ impl fmt::Debug for UdpSocket {\n \n pub struct LookupHost(Void);\n \n+impl LookupHost {\n+    pub fn port(&self) -> u16 {\n+        match self.0 {}\n+    }\n+}\n+\n impl Iterator for LookupHost {\n     type Item = SocketAddr;\n     fn next(&mut self) -> Option<SocketAddr> {\n         match self.0 {}\n     }\n }\n \n-pub fn lookup_host(_: &str) -> io::Result<LookupHost> {\n-    unsupported()\n+impl<'a> TryFrom<&'a str> for LookupHost {\n+    type Error = io::Error;\n+\n+    fn try_from(_v: &'a str) -> io::Result<LookupHost> {\n+        unsupported()\n+    }\n+}\n+\n+impl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n+    type Error = io::Error;\n+\n+    fn try_from(_v: (&'a str, u16)) -> io::Result<LookupHost> {\n+        unsupported()\n+    }\n }\n \n #[allow(nonstandard_style)]"}, {"sha": "dce2bf71cecab9fea0b43574301ae1e88d71b238", "filename": "src/libstd/sys_common/net.rs", "status": "modified", "additions": 58, "deletions": 16, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/22c43689937a81cf5ad6ecfe22d9e63e3cebed04/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22c43689937a81cf5ad6ecfe22d9e63e3cebed04/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=22c43689937a81cf5ad6ecfe22d9e63e3cebed04", "patch": "@@ -20,6 +20,7 @@ use sys::net::{cvt, cvt_r, cvt_gai, Socket, init, wrlen_t};\n use sys::net::netc as c;\n use sys_common::{AsInner, FromInner, IntoInner};\n use time::Duration;\n+use convert::{TryFrom, TryInto};\n \n #[cfg(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n           target_os = \"ios\", target_os = \"macos\",\n@@ -129,6 +130,13 @@ fn to_ipv6mr_interface(value: u32) -> ::libc::c_uint {\n pub struct LookupHost {\n     original: *mut c::addrinfo,\n     cur: *mut c::addrinfo,\n+    port: u16\n+}\n+\n+impl LookupHost {\n+    pub fn port(&self) -> u16 {\n+        self.port\n+    }\n }\n \n impl Iterator for LookupHost {\n@@ -158,17 +166,45 @@ impl Drop for LookupHost {\n     }\n }\n \n-pub fn lookup_host(host: &str) -> io::Result<LookupHost> {\n-    init();\n+impl<'a> TryFrom<&'a str> for LookupHost {\n+    type Error = io::Error;\n \n-    let c_host = CString::new(host)?;\n-    let mut hints: c::addrinfo = unsafe { mem::zeroed() };\n-    hints.ai_socktype = c::SOCK_STREAM;\n-    let mut res = ptr::null_mut();\n-    unsafe {\n-        cvt_gai(c::getaddrinfo(c_host.as_ptr(), ptr::null(), &hints, &mut res)).map(|_| {\n-            LookupHost { original: res, cur: res }\n-        })\n+    fn try_from(s: &str) -> io::Result<LookupHost> {\n+        macro_rules! try_opt {\n+            ($e:expr, $msg:expr) => (\n+                match $e {\n+                    Some(r) => r,\n+                    None => return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                                      $msg)),\n+                }\n+            )\n+        }\n+\n+        // split the string by ':' and convert the second part to u16\n+        let mut parts_iter = s.rsplitn(2, ':');\n+        let port_str = try_opt!(parts_iter.next(), \"invalid socket address\");\n+        let host = try_opt!(parts_iter.next(), \"invalid socket address\");\n+        let port: u16 = try_opt!(port_str.parse().ok(), \"invalid port value\");\n+\n+        (host, port).try_into()\n+    }\n+}\n+\n+impl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n+    type Error = io::Error;\n+\n+    fn try_from((host, port): (&'a str, u16)) -> io::Result<LookupHost> {\n+        init();\n+\n+        let c_host = CString::new(host)?;\n+        let mut hints: c::addrinfo = unsafe { mem::zeroed() };\n+        hints.ai_socktype = c::SOCK_STREAM;\n+        let mut res = ptr::null_mut();\n+        unsafe {\n+            cvt_gai(c::getaddrinfo(c_host.as_ptr(), ptr::null(), &hints, &mut res)).map(|_| {\n+                LookupHost { original: res, cur: res, port }\n+            })\n+        }\n     }\n }\n \n@@ -181,7 +217,9 @@ pub struct TcpStream {\n }\n \n impl TcpStream {\n-    pub fn connect(addr: &SocketAddr) -> io::Result<TcpStream> {\n+    pub fn connect(addr: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n+        let addr = addr?;\n+\n         init();\n \n         let sock = Socket::new(addr, c::SOCK_STREAM)?;\n@@ -317,7 +355,9 @@ pub struct TcpListener {\n }\n \n impl TcpListener {\n-    pub fn bind(addr: &SocketAddr) -> io::Result<TcpListener> {\n+    pub fn bind(addr: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n+        let addr = addr?;\n+\n         init();\n \n         let sock = Socket::new(addr, c::SOCK_STREAM)?;\n@@ -418,7 +458,9 @@ pub struct UdpSocket {\n }\n \n impl UdpSocket {\n-    pub fn bind(addr: &SocketAddr) -> io::Result<UdpSocket> {\n+    pub fn bind(addr: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {\n+        let addr = addr?;\n+\n         init();\n \n         let sock = Socket::new(addr, c::SOCK_DGRAM)?;\n@@ -584,8 +626,8 @@ impl UdpSocket {\n         Ok(ret as usize)\n     }\n \n-    pub fn connect(&self, addr: &SocketAddr) -> io::Result<()> {\n-        let (addrp, len) = addr.into_inner();\n+    pub fn connect(&self, addr: io::Result<&SocketAddr>) -> io::Result<()> {\n+        let (addrp, len) = addr?.into_inner();\n         cvt_r(|| unsafe { c::connect(*self.inner.as_inner(), addrp, len) }).map(|_| ())\n     }\n }\n@@ -618,7 +660,7 @@ mod tests {\n     #[test]\n     fn no_lookup_host_duplicates() {\n         let mut addrs = HashMap::new();\n-        let lh = match lookup_host(\"localhost\") {\n+        let lh = match LookupHost::try_from((\"localhost\", 0)) {\n             Ok(lh) => lh,\n             Err(e) => panic!(\"couldn't resolve `localhost': {}\", e)\n         };"}]}