{"sha": "5e616dbd2189844044e039436b7ed16b44f6595a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlNjE2ZGJkMjE4OTg0NDA0NGUwMzk0MzZiN2VkMTZiNDRmNjU5NWE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-02-20T17:32:55Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-02-20T17:32:55Z"}, "message": "Tweaks to equality comparisons for slices/arrays/vectors", "tree": {"sha": "502bc659e17ea2f5df602880c9f19386ed0631ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/502bc659e17ea2f5df602880c9f19386ed0631ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e616dbd2189844044e039436b7ed16b44f6595a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e616dbd2189844044e039436b7ed16b44f6595a", "html_url": "https://github.com/rust-lang/rust/commit/5e616dbd2189844044e039436b7ed16b44f6595a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e616dbd2189844044e039436b7ed16b44f6595a/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "html_url": "https://github.com/rust-lang/rust/commit/522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}], "stats": {"total": 189, "additions": 86, "deletions": 103}, "files": [{"sha": "945c4f0ccd86ebc7d3f074e60bb7cc4b511f78e0", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 24, "deletions": 59, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/5e616dbd2189844044e039436b7ed16b44f6595a/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e616dbd2189844044e039436b7ed16b44f6595a/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=5e616dbd2189844044e039436b7ed16b44f6595a", "patch": "@@ -1501,69 +1501,34 @@ impl<T> Extend<T> for Vec<T> {\n     }\n }\n \n-impl<A, B> PartialEq<Vec<B>> for Vec<A> where A: PartialEq<B> {\n-    #[inline]\n-    fn eq(&self, other: &Vec<B>) -> bool { PartialEq::eq(&**self, &**other) }\n-    #[inline]\n-    fn ne(&self, other: &Vec<B>) -> bool { PartialEq::ne(&**self, &**other) }\n-}\n-\n-macro_rules! impl_eq {\n-    ($lhs:ty, $rhs:ty) => {\n-        impl<'b, A, B> PartialEq<$rhs> for $lhs where A: PartialEq<B> {\n-            #[inline]\n-            fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n-            #[inline]\n-            fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n-        }\n-\n-        impl<'b, A, B> PartialEq<$lhs> for $rhs where B: PartialEq<A> {\n-            #[inline]\n-            fn eq(&self, other: &$lhs) -> bool { PartialEq::eq(&**self, &**other) }\n-            #[inline]\n-            fn ne(&self, other: &$lhs) -> bool { PartialEq::ne(&**self, &**other) }\n-        }\n+__impl_slice_eq1! { Vec<A>, Vec<B> }\n+__impl_slice_eq2! { Vec<A>, &'b [B] }\n+__impl_slice_eq2! { Vec<A>, &'b mut [B] }\n+__impl_slice_eq2! { CowVec<'a, A>, &'b [B], Clone }\n+__impl_slice_eq2! { CowVec<'a, A>, &'b mut [B], Clone }\n+__impl_slice_eq2! { CowVec<'a, A>, Vec<B>, Clone }\n+\n+macro_rules! array_impls {\n+    ($($N: expr)+) => {\n+        $(\n+            // NOTE: some less important impls are omitted to reduce code bloat\n+            __impl_slice_eq2! { Vec<A>, [B; $N] }\n+            __impl_slice_eq2! { Vec<A>, &'b [B; $N] }\n+            // __impl_slice_eq2! { Vec<A>, &'b mut [B; $N] }\n+            // __impl_slice_eq2! { CowVec<'a, A>, [B; $N], Clone }\n+            // __impl_slice_eq2! { CowVec<'a, A>, &'b [B; $N], Clone }\n+            // __impl_slice_eq2! { CowVec<'a, A>, &'b mut [B; $N], Clone }\n+        )+\n     }\n }\n \n-impl_eq! { Vec<A>, &'b [B] }\n-impl_eq! { Vec<A>, &'b mut [B] }\n-\n-impl<'a, A, B> PartialEq<Vec<B>> for Cow<'a, [A]> where A: PartialEq<B> + Clone {\n-    #[inline]\n-    fn eq(&self, other: &Vec<B>) -> bool { PartialEq::eq(&**self, &**other) }\n-    #[inline]\n-    fn ne(&self, other: &Vec<B>) -> bool { PartialEq::ne(&**self, &**other) }\n+array_impls! {\n+     0  1  2  3  4  5  6  7  8  9\n+    10 11 12 13 14 15 16 17 18 19\n+    20 21 22 23 24 25 26 27 28 29\n+    30 31 32\n }\n \n-impl<'a, A, B> PartialEq<Cow<'a, [A]>> for Vec<B> where A: Clone, B: PartialEq<A> {\n-    #[inline]\n-    fn eq(&self, other: &Cow<'a, [A]>) -> bool { PartialEq::eq(&**self, &**other) }\n-    #[inline]\n-    fn ne(&self, other: &Cow<'a, [A]>) -> bool { PartialEq::ne(&**self, &**other) }\n-}\n-\n-macro_rules! impl_eq_for_cowvec {\n-    ($rhs:ty) => {\n-        impl<'a, 'b, A, B> PartialEq<$rhs> for Cow<'a, [A]> where A: PartialEq<B> + Clone {\n-            #[inline]\n-            fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n-            #[inline]\n-            fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n-        }\n-\n-        impl<'a, 'b, A, B> PartialEq<Cow<'a, [A]>> for $rhs where A: Clone, B: PartialEq<A> {\n-            #[inline]\n-            fn eq(&self, other: &Cow<'a, [A]>) -> bool { PartialEq::eq(&**self, &**other) }\n-            #[inline]\n-            fn ne(&self, other: &Cow<'a, [A]>) -> bool { PartialEq::ne(&**self, &**other) }\n-        }\n-    }\n-}\n-\n-impl_eq_for_cowvec! { &'b [B] }\n-impl_eq_for_cowvec! { &'b mut [B] }\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialOrd> PartialOrd for Vec<T> {\n     #[inline]\n@@ -2480,7 +2445,7 @@ mod tests {\n     fn test_into_boxed_slice() {\n         let xs = vec![1, 2, 3];\n         let ys = xs.into_boxed_slice();\n-        assert_eq!(ys, [1, 2, 3]);\n+        assert_eq!(&*ys, [1, 2, 3]);\n     }\n \n     #[test]"}, {"sha": "a24c181b909a105ed4942d5ae228588a92f92802", "filename": "src/libcore/array.rs", "status": "modified", "additions": 8, "deletions": 43, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5e616dbd2189844044e039436b7ed16b44f6595a/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e616dbd2189844044e039436b7ed16b44f6595a/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=5e616dbd2189844044e039436b7ed16b44f6595a", "patch": "@@ -19,8 +19,7 @@ use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n use fmt;\n use hash::{Hash, self};\n use iter::IntoIterator;\n-use marker::Copy;\n-use ops::Deref;\n+use marker::{Copy, Sized};\n use option::Option;\n use slice::{Iter, IterMut, SliceExt};\n \n@@ -76,47 +75,13 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<A, B> PartialEq<[B; $N]> for [A; $N] where A: PartialEq<B> {\n-                #[inline]\n-                fn eq(&self, other: &[B; $N]) -> bool {\n-                    &self[..] == &other[..]\n-                }\n-                #[inline]\n-                fn ne(&self, other: &[B; $N]) -> bool {\n-                    &self[..] != &other[..]\n-                }\n-            }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<'a, A, B, Rhs> PartialEq<Rhs> for [A; $N] where\n-                A: PartialEq<B>,\n-                Rhs: Deref<Target=[B]>,\n-            {\n-                #[inline(always)]\n-                fn eq(&self, other: &Rhs) -> bool {\n-                    PartialEq::eq(&self[..], &**other)\n-                }\n-                #[inline(always)]\n-                fn ne(&self, other: &Rhs) -> bool {\n-                    PartialEq::ne(&self[..], &**other)\n-                }\n-            }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<'a, A, B, Lhs> PartialEq<[B; $N]> for Lhs where\n-                A: PartialEq<B>,\n-                Lhs: Deref<Target=[A]>\n-            {\n-                #[inline(always)]\n-                fn eq(&self, other: &[B; $N]) -> bool {\n-                    PartialEq::eq(&**self, &other[..])\n-                }\n-                #[inline(always)]\n-                fn ne(&self, other: &[B; $N]) -> bool {\n-                    PartialEq::ne(&**self, &other[..])\n-                }\n-            }\n+            // NOTE: some less important impls are omitted to reduce code bloat\n+            __impl_slice_eq1! { [A; $N], [B; $N] }\n+            __impl_slice_eq2! { [A; $N], [B] }\n+            __impl_slice_eq2! { [A; $N], &'b [B] }\n+            __impl_slice_eq2! { [A; $N], &'b mut [B] }\n+            // __impl_slice_eq2! { [A; $N], &'b [B; $N] }\n+            // __impl_slice_eq2! { [A; $N], &'b mut [B; $N] }\n \n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T:Eq> Eq for [T; $N] { }"}, {"sha": "18357bac9e6f685bf7739ce91e4c223917ba1500", "filename": "src/libcore/cmp_macros.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5e616dbd2189844044e039436b7ed16b44f6595a/src%2Flibcore%2Fcmp_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e616dbd2189844044e039436b7ed16b44f6595a/src%2Flibcore%2Fcmp_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp_macros.rs?ref=5e616dbd2189844044e039436b7ed16b44f6595a", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Utility macros for implementing PartialEq on slice-like types\n+\n+#![doc(hidden)]\n+\n+#[macro_export]\n+macro_rules! __impl_slice_eq1 {\n+    ($Lhs: ty, $Rhs: ty) => {\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<'a, 'b, A, B> PartialEq<$Rhs> for $Lhs where A: PartialEq<B> {\n+            #[inline]\n+            fn eq(&self, other: &$Rhs) -> bool { &self[..] == &other[..] }\n+            #[inline]\n+            fn ne(&self, other: &$Rhs) -> bool { &self[..] != &other[..] }\n+        }\n+    }\n+}\n+\n+#[macro_export]\n+macro_rules! __impl_slice_eq2 {\n+    ($Lhs: ty, $Rhs: ty) => {\n+        __impl_slice_eq2! { $Lhs, $Rhs, Sized }\n+    };\n+    ($Lhs: ty, $Rhs: ty, $Bound: ident) => {\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<'a, 'b, A: $Bound, B> PartialEq<$Rhs> for $Lhs where A: PartialEq<B> {\n+            #[inline]\n+            fn eq(&self, other: &$Rhs) -> bool { &self[..] == &other[..] }\n+            #[inline]\n+            fn ne(&self, other: &$Rhs) -> bool { &self[..] != &other[..] }\n+        }\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<'a, 'b, A: $Bound, B> PartialEq<$Lhs> for $Rhs where B: PartialEq<A> {\n+            #[inline]\n+            fn eq(&self, other: &$Lhs) -> bool { &self[..] == &other[..] }\n+            #[inline]\n+            fn ne(&self, other: &$Lhs) -> bool { &self[..] != &other[..] }\n+        }\n+    }\n+}"}, {"sha": "7f52f071080d0c2908de083cdd952c917f2cb72d", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e616dbd2189844044e039436b7ed16b44f6595a/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e616dbd2189844044e039436b7ed16b44f6595a/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=5e616dbd2189844044e039436b7ed16b44f6595a", "patch": "@@ -72,6 +72,9 @@\n #[macro_use]\n mod macros;\n \n+#[macro_use]\n+mod cmp_macros;\n+\n #[path = \"num/float_macros.rs\"]\n #[macro_use]\n mod float_macros;"}, {"sha": "a8ea4d6d658a945f2db25a826c500f0022a6da11", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e616dbd2189844044e039436b7ed16b44f6595a/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e616dbd2189844044e039436b7ed16b44f6595a/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=5e616dbd2189844044e039436b7ed16b44f6595a", "patch": "@@ -371,7 +371,7 @@ impl CStr {\n \n impl PartialEq for CStr {\n     fn eq(&self, other: &CStr) -> bool {\n-        self.to_bytes().eq(&other.to_bytes())\n+        self.to_bytes().eq(other.to_bytes())\n     }\n }\n impl Eq for CStr {}"}]}