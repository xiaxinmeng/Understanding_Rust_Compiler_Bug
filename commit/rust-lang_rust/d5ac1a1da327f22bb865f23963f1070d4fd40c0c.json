{"sha": "d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1YWMxYTFkYTMyN2YyMmJiODY1ZjIzOTYzZjEwNzBkNGZkNDBjMGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-06T13:11:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-06T13:11:18Z"}, "message": "Auto merge of #30481 - nagisa:mir-calls-2, r=nikomatsakis\n\nr? @nikomatsakis\n\nThis is a pretty big PR conflating changes to a few different block terminators (Call, DivergingCall, Panic, Resume, Diverge), because they are somewhat closely related.\n\nEach commit has a pretty good description on what is being changed in each commit. The end result is greatly simplified CFG and translation for calls (no success branch if the function is diverging, no cleanup branch if there\u2019s nothing to cleanup etc).\n\nFixes https://github.com/rust-lang/rust/issues/30480\nFixes https://github.com/rust-lang/rust/issues/29767\nPartialy solves https://github.com/rust-lang/rust/issues/29575\nFixes https://github.com/rust-lang/rust/issues/29573", "tree": {"sha": "f601375c0efa9fdde4ac0bbb45f9886d0db5548c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f601375c0efa9fdde4ac0bbb45f9886d0db5548c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "html_url": "https://github.com/rust-lang/rust/commit/d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7312e0a16328e6227d7fc593176a1fd12fea4342", "url": "https://api.github.com/repos/rust-lang/rust/commits/7312e0a16328e6227d7fc593176a1fd12fea4342", "html_url": "https://github.com/rust-lang/rust/commit/7312e0a16328e6227d7fc593176a1fd12fea4342"}, {"sha": "36b3951c7338ae0d69e125383038e76d00fc7d77", "url": "https://api.github.com/repos/rust-lang/rust/commits/36b3951c7338ae0d69e125383038e76d00fc7d77", "html_url": "https://github.com/rust-lang/rust/commit/36b3951c7338ae0d69e125383038e76d00fc7d77"}], "stats": {"total": 1147, "additions": 887, "deletions": 260}, "files": [{"sha": "b97d5939cf3b05857fd39c9c660cd4f6aac4fdb4", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 102, "deletions": 51, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -51,9 +51,6 @@ pub const START_BLOCK: BasicBlock = BasicBlock(0);\n /// where execution ends, on normal return\n pub const END_BLOCK: BasicBlock = BasicBlock(1);\n \n-/// where execution ends, on panic\n-pub const DIVERGE_BLOCK: BasicBlock = BasicBlock(2);\n-\n impl<'tcx> Mir<'tcx> {\n     pub fn all_basic_blocks(&self) -> Vec<BasicBlock> {\n         (0..self.basic_blocks.len())\n@@ -194,7 +191,8 @@ impl Debug for BasicBlock {\n #[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct BasicBlockData<'tcx> {\n     pub statements: Vec<Statement<'tcx>>,\n-    pub terminator: Terminator<'tcx>,\n+    pub terminator: Option<Terminator<'tcx>>,\n+    pub is_cleanup: bool,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -204,12 +202,6 @@ pub enum Terminator<'tcx> {\n         target: BasicBlock,\n     },\n \n-    /// block should initiate unwinding; should be one successor\n-    /// that does cleanup and branches to DIVERGE_BLOCK\n-    Panic {\n-        target: BasicBlock,\n-    },\n-\n     /// jump to branch 0 if this lvalue evaluates to true\n     If {\n         cond: Operand<'tcx>,\n@@ -243,77 +235,125 @@ pub enum Terminator<'tcx> {\n         targets: Vec<BasicBlock>,\n     },\n \n-    /// Indicates that the last statement in the block panics, aborts,\n-    /// etc. No successors. This terminator appears on exactly one\n-    /// basic block which we create in advance. However, during\n-    /// construction, we use this value as a sentinel for \"terminator\n-    /// not yet assigned\", and assert at the end that only the\n-    /// well-known diverging block actually diverges.\n-    Diverge,\n+    /// Indicates that the landing pad is finished and unwinding should\n+    /// continue. Emitted by build::scope::diverge_cleanup.\n+    Resume,\n \n     /// Indicates a normal return. The ReturnPointer lvalue should\n     /// have been filled in by now. This should only occur in the\n     /// `END_BLOCK`.\n     Return,\n \n-    /// block ends with a call; it should have two successors. The\n-    /// first successor indicates normal return. The second indicates\n-    /// unwinding.\n+    /// Block ends with a call of a converging function\n     Call {\n-        data: CallData<'tcx>,\n-        targets: (BasicBlock, BasicBlock),\n+        /// The function that\u2019s being called\n+        func: Operand<'tcx>,\n+        /// Arguments the function is called with\n+        args: Vec<Operand<'tcx>>,\n+        /// The kind of call with associated information\n+        kind: CallKind<'tcx>,\n     },\n }\n \n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n+pub enum CallKind<'tcx> {\n+    /// Diverging function without associated cleanup\n+    Diverging,\n+    /// Diverging function with associated cleanup\n+    DivergingCleanup(BasicBlock),\n+    /// Converging function without associated cleanup\n+    Converging {\n+        /// Destination where the call result is written\n+        destination: Lvalue<'tcx>,\n+        /// Block to branch into on successful return\n+        target: BasicBlock,\n+    },\n+    ConvergingCleanup {\n+        /// Destination where the call result is written\n+        destination: Lvalue<'tcx>,\n+        /// First target is branched to on successful return.\n+        /// Second block contains the cleanups to do on unwind.\n+        targets: (BasicBlock, BasicBlock)\n+    }\n+}\n+\n+impl<'tcx> CallKind<'tcx> {\n+    pub fn successors(&self) -> &[BasicBlock] {\n+        match *self {\n+            CallKind::Diverging => &[],\n+            CallKind::DivergingCleanup(ref b) |\n+            CallKind::Converging { target: ref b, .. } => slice::ref_slice(b),\n+            CallKind::ConvergingCleanup { ref targets, .. } => targets.as_slice(),\n+        }\n+    }\n+\n+    pub fn successors_mut(&mut self) -> &mut [BasicBlock] {\n+        match *self {\n+            CallKind::Diverging => &mut [],\n+            CallKind::DivergingCleanup(ref mut b) |\n+            CallKind::Converging { target: ref mut b, .. } => slice::mut_ref_slice(b),\n+            CallKind::ConvergingCleanup { ref mut targets, .. } => targets.as_mut_slice(),\n+        }\n+    }\n+\n+    pub fn destination(&self) -> Option<Lvalue<'tcx>> {\n+        match *self {\n+            CallKind::Converging { ref destination, .. } |\n+            CallKind::ConvergingCleanup { ref destination, .. } => Some(destination.clone()),\n+            CallKind::Diverging |\n+            CallKind::DivergingCleanup(_) => None\n+        }\n+    }\n+}\n+\n impl<'tcx> Terminator<'tcx> {\n     pub fn successors(&self) -> &[BasicBlock] {\n         use self::Terminator::*;\n         match *self {\n             Goto { target: ref b } => slice::ref_slice(b),\n-            Panic { target: ref b } => slice::ref_slice(b),\n-            If { cond: _, targets: ref b } => b.as_slice(),\n+            If { targets: ref b, .. } => b.as_slice(),\n             Switch { targets: ref b, .. } => b,\n             SwitchInt { targets: ref b, .. } => b,\n-            Diverge => &[],\n+            Resume => &[],\n             Return => &[],\n-            Call { data: _, targets: ref b } => b.as_slice(),\n+            Call { ref kind, .. } => kind.successors(),\n         }\n     }\n \n     pub fn successors_mut(&mut self) -> &mut [BasicBlock] {\n         use self::Terminator::*;\n         match *self {\n             Goto { target: ref mut b } => slice::mut_ref_slice(b),\n-            Panic { target: ref mut b } => slice::mut_ref_slice(b),\n-            If { cond: _, targets: ref mut b } => b.as_mut_slice(),\n+            If { targets: ref mut b, .. } => b.as_mut_slice(),\n             Switch { targets: ref mut b, .. } => b,\n             SwitchInt { targets: ref mut b, .. } => b,\n-            Diverge => &mut [],\n+            Resume => &mut [],\n             Return => &mut [],\n-            Call { data: _, targets: ref mut b } => b.as_mut_slice(),\n+            Call { ref mut kind, .. } => kind.successors_mut(),\n         }\n     }\n }\n \n-#[derive(Debug, RustcEncodable, RustcDecodable)]\n-pub struct CallData<'tcx> {\n-    /// where the return value is written to\n-    pub destination: Lvalue<'tcx>,\n-\n-    /// the fn being called\n-    pub func: Operand<'tcx>,\n-\n-    /// the arguments\n-    pub args: Vec<Operand<'tcx>>,\n-}\n-\n impl<'tcx> BasicBlockData<'tcx> {\n-    pub fn new(terminator: Terminator<'tcx>) -> BasicBlockData<'tcx> {\n+    pub fn new(terminator: Option<Terminator<'tcx>>) -> BasicBlockData<'tcx> {\n         BasicBlockData {\n             statements: vec![],\n             terminator: terminator,\n+            is_cleanup: false,\n         }\n     }\n+\n+    /// Accessor for terminator.\n+    ///\n+    /// Terminator may not be None after construction of the basic block is complete. This accessor\n+    /// provides a convenience way to reach the terminator.\n+    pub fn terminator(&self) -> &Terminator<'tcx> {\n+        self.terminator.as_ref().expect(\"invalid terminator state\")\n+    }\n+\n+    pub fn terminator_mut(&mut self) -> &mut Terminator<'tcx> {\n+        self.terminator.as_mut().expect(\"invalid terminator state\")\n+    }\n }\n \n impl<'tcx> Debug for Terminator<'tcx> {\n@@ -351,15 +391,17 @@ impl<'tcx> Terminator<'tcx> {\n         use self::Terminator::*;\n         match *self {\n             Goto { .. } => write!(fmt, \"goto\"),\n-            Panic { .. } => write!(fmt, \"panic\"),\n             If { cond: ref lv, .. } => write!(fmt, \"if({:?})\", lv),\n             Switch { discr: ref lv, .. } => write!(fmt, \"switch({:?})\", lv),\n             SwitchInt { discr: ref lv, .. } => write!(fmt, \"switchInt({:?})\", lv),\n-            Diverge => write!(fmt, \"diverge\"),\n             Return => write!(fmt, \"return\"),\n-            Call { data: ref c, .. } => {\n-                try!(write!(fmt, \"{:?} = {:?}(\", c.destination, c.func));\n-                for (index, arg) in c.args.iter().enumerate() {\n+            Resume => write!(fmt, \"resume\"),\n+            Call { ref kind, ref func, ref args } => {\n+                if let Some(destination) = kind.destination() {\n+                    try!(write!(fmt, \"{:?} = \", destination));\n+                }\n+                try!(write!(fmt, \"{:?}(\", func));\n+                for (index, arg) in args.iter().enumerate() {\n                     if index > 0 {\n                         try!(write!(fmt, \", \"));\n                     }\n@@ -374,10 +416,9 @@ impl<'tcx> Terminator<'tcx> {\n     pub fn fmt_successor_labels(&self) -> Vec<Cow<'static, str>> {\n         use self::Terminator::*;\n         match *self {\n-            Diverge | Return => vec![],\n-            Goto { .. } | Panic { .. } => vec![\"\".into_cow()],\n+            Return | Resume => vec![],\n+            Goto { .. } => vec![\"\".into_cow()],\n             If { .. } => vec![\"true\".into_cow(), \"false\".into_cow()],\n-            Call { .. } => vec![\"return\".into_cow(), \"unwind\".into_cow()],\n             Switch { ref adt_def, .. } => {\n                 adt_def.variants\n                        .iter()\n@@ -394,6 +435,16 @@ impl<'tcx> Terminator<'tcx> {\n                       .chain(iter::once(String::from(\"otherwise\").into_cow()))\n                       .collect()\n             }\n+            Call { ref kind, .. } => match *kind {\n+                CallKind::Diverging =>\n+                    vec![],\n+                CallKind::DivergingCleanup(..) =>\n+                    vec![\"unwind\".into_cow()],\n+                CallKind::Converging { .. } =>\n+                    vec![\"return\".into_cow()],\n+                CallKind::ConvergingCleanup { .. } =>\n+                    vec![\"return\".into_cow(), \"unwind\".into_cow()],\n+            },\n         }\n     }\n }"}, {"sha": "c05e4c83cd4f0fa42959887eaea7a921afa99077", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -84,7 +84,7 @@ pub trait Visitor<'tcx> {\n         for statement in &data.statements {\n             self.visit_statement(block, statement);\n         }\n-        self.visit_terminator(block, &data.terminator);\n+        data.terminator.as_ref().map(|r| self.visit_terminator(block, r));\n     }\n \n     fn super_statement(&mut self, block: BasicBlock, statement: &Statement<'tcx>) {\n@@ -107,8 +107,7 @@ pub trait Visitor<'tcx> {\n \n     fn super_terminator(&mut self, block: BasicBlock, terminator: &Terminator<'tcx>) {\n         match *terminator {\n-            Terminator::Goto { target } |\n-            Terminator::Panic { target } => {\n+            Terminator::Goto { target } => {\n                 self.visit_branch(block, target);\n             }\n \n@@ -133,17 +132,19 @@ pub trait Visitor<'tcx> {\n                 }\n             }\n \n-            Terminator::Diverge |\n+            Terminator::Resume |\n             Terminator::Return => {\n             }\n \n-            Terminator::Call { ref data, ref targets } => {\n-                self.visit_lvalue(&data.destination, LvalueContext::Store);\n-                self.visit_operand(&data.func);\n-                for arg in &data.args {\n+            Terminator::Call { ref func, ref args, ref kind } => {\n+                if let Some(ref destination) = kind.destination() {\n+                    self.visit_lvalue(destination, LvalueContext::Store);\n+                }\n+                self.visit_operand(func);\n+                for arg in args {\n                     self.visit_operand(arg);\n                 }\n-                for &target in targets.as_slice() {\n+                for &target in kind.successors() {\n                     self.visit_branch(block, target);\n                 }\n             }\n@@ -364,7 +365,7 @@ pub trait MutVisitor<'tcx> {\n         for statement in &mut data.statements {\n             self.visit_statement(block, statement);\n         }\n-        self.visit_terminator(block, &mut data.terminator);\n+        data.terminator.as_mut().map(|r| self.visit_terminator(block, r));\n     }\n \n     fn super_statement(&mut self,\n@@ -394,8 +395,7 @@ pub trait MutVisitor<'tcx> {\n                         block: BasicBlock,\n                         terminator: &mut Terminator<'tcx>) {\n         match *terminator {\n-            Terminator::Goto { target } |\n-            Terminator::Panic { target } => {\n+            Terminator::Goto { target } => {\n                 self.visit_branch(block, target);\n             }\n \n@@ -420,17 +420,19 @@ pub trait MutVisitor<'tcx> {\n                 }\n             }\n \n-            Terminator::Diverge |\n+            Terminator::Resume |\n             Terminator::Return => {\n             }\n \n-            Terminator::Call { ref mut data, ref mut targets } => {\n-                self.visit_lvalue(&mut data.destination, LvalueContext::Store);\n-                self.visit_operand(&mut data.func);\n-                for arg in &mut data.args {\n+            Terminator::Call { ref mut func, ref mut args, ref mut kind } => {\n+                if let Some(ref mut destination) = kind.destination() {\n+                    self.visit_lvalue(destination, LvalueContext::Store);\n+                }\n+                self.visit_operand(func);\n+                for arg in args {\n                     self.visit_operand(arg);\n                 }\n-                for &target in targets.as_slice() {\n+                for &target in kind.successors() {\n                     self.visit_branch(block, target);\n                 }\n             }"}, {"sha": "2e70e6bb5ae0499e1a56eada967ae9258114459f", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -28,7 +28,7 @@ impl<'tcx> CFG<'tcx> {\n \n     pub fn start_new_block(&mut self) -> BasicBlock {\n         let node_index = self.basic_blocks.len();\n-        self.basic_blocks.push(BasicBlockData::new(Terminator::Diverge));\n+        self.basic_blocks.push(BasicBlockData::new(None));\n         BasicBlock::new(node_index)\n     }\n \n@@ -67,15 +67,9 @@ impl<'tcx> CFG<'tcx> {\n     pub fn terminate(&mut self,\n                      block: BasicBlock,\n                      terminator: Terminator<'tcx>) {\n-        // Check whether this block has already been terminated. For\n-        // this, we rely on the fact that the initial state is to have\n-        // a Diverge terminator and an empty list of targets (which\n-        // is not a valid state).\n-        debug_assert!(match self.block_data(block).terminator { Terminator::Diverge => true,\n-                                                                _ => false },\n+        debug_assert!(self.block_data(block).terminator.is_none(),\n                       \"terminate: block {:?} already has a terminator set\", block);\n-\n-        self.block_data_mut(block).terminator = terminator;\n+        self.block_data_mut(block).terminator = Some(terminator);\n     }\n }\n "}, {"sha": "4e03ed489eb9fcf93bcf9ca1828c521b3a42ac3d", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -63,15 +63,15 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 this.cfg.push_assign(block, expr_span, // lt = idx < len\n                                      &lt, Rvalue::BinaryOp(BinOp::Lt,\n                                                            idx.clone(),\n-                                                           Operand::Consume(len)));\n+                                                           Operand::Consume(len.clone())));\n \n                 let (success, failure) = (this.cfg.start_new_block(), this.cfg.start_new_block());\n                 this.cfg.terminate(block,\n                                    Terminator::If {\n                                        cond: Operand::Consume(lt),\n                                        targets: (success, failure),\n                                    });\n-                this.panic(failure);\n+                this.panic_bounds_check(failure, idx.clone(), Operand::Consume(len), expr_span);\n                 success.and(slice.index(idx))\n             }\n             ExprKind::SelfRef => {"}, {"sha": "44d1d52a06a3466a6dec9a0596f92899af8a9c05", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -15,6 +15,7 @@ use build::expr::category::{Category, RvalueFunc};\n use build::scope::LoopScope;\n use hair::*;\n use rustc::middle::region::CodeExtent;\n+use rustc::middle::ty;\n use rustc::mir::repr::*;\n use syntax::codemap::Span;\n \n@@ -210,23 +211,35 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 this.exit_scope(expr_span, extent, block, END_BLOCK);\n                 this.cfg.start_new_block().unit()\n             }\n-            ExprKind::Call { fun, args } => {\n+            ExprKind::Call { ty, fun, args } => {\n+                let diverges = match ty.sty {\n+                    ty::TyBareFn(_, ref f) => f.sig.0.output.diverges(),\n+                    _ => false\n+                };\n                 let fun = unpack!(block = this.as_operand(block, fun));\n                 let args: Vec<_> =\n                     args.into_iter()\n                         .map(|arg| unpack!(block = this.as_operand(block, arg)))\n                         .collect();\n+\n                 let success = this.cfg.start_new_block();\n-                let panic = this.diverge_cleanup();\n-                this.cfg.terminate(block,\n-                                   Terminator::Call {\n-                                       data: CallData {\n-                                           destination: destination.clone(),\n-                                           func: fun,\n-                                           args: args,\n-                                       },\n-                                       targets: (success, panic),\n-                                   });\n+                let cleanup = this.diverge_cleanup();\n+                this.cfg.terminate(block, Terminator::Call {\n+                    func: fun,\n+                    args: args,\n+                    kind: match (cleanup, diverges) {\n+                        (None, true) => CallKind::Diverging,\n+                        (Some(c), true) => CallKind::DivergingCleanup(c),\n+                        (None, false) => CallKind::Converging {\n+                            destination: destination.clone(),\n+                            target: success\n+                        },\n+                        (Some(c), false) => CallKind::ConvergingCleanup {\n+                            destination: destination.clone(),\n+                            targets: (success, c)\n+                        }\n+                    }\n+                });\n                 success.unit()\n             }\n "}, {"sha": "c2c87fcbd20dafd14ccc63d50856b4bcf0ae9f04", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -89,7 +89,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         // not entirely precise\n         if !otherwise.is_empty() {\n             let join_block = self.join_otherwise_blocks(otherwise);\n-            self.panic(join_block);\n+            self.panic(join_block, \"something about matches algorithm not being precise\", span);\n         }\n \n         // all the arm blocks will rejoin here"}, {"sha": "e6e5b8380b24121a05d062ad3625ab4df0c2d02e", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -107,7 +107,6 @@ pub fn construct<'a,'tcx>(mut hir: Cx<'a,'tcx>,\n \n     assert_eq!(builder.cfg.start_new_block(), START_BLOCK);\n     assert_eq!(builder.cfg.start_new_block(), END_BLOCK);\n-    assert_eq!(builder.cfg.start_new_block(), DIVERGE_BLOCK);\n \n     let mut block = START_BLOCK;\n     let arg_decls = unpack!(block = builder.args_and_body(block,"}, {"sha": "e912e933bd81f2869ee29cae3350e527c87b4322", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 147, "deletions": 36, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -86,11 +86,14 @@ should go to.\n \n */\n \n-use build::{BlockAnd, BlockAndExtension, Builder, CFG};\n+use build::{BlockAnd, BlockAndExtension, Builder};\n use rustc::middle::region::CodeExtent;\n-use rustc::middle::ty::Ty;\n+use rustc::middle::lang_items;\n+use rustc::middle::subst::Substs;\n+use rustc::middle::ty::{self, Ty};\n use rustc::mir::repr::*;\n-use syntax::codemap::Span;\n+use syntax::codemap::{Span, DUMMY_SP};\n+use syntax::parse::token::intern_and_get_ident;\n \n pub struct Scope<'tcx> {\n     extent: CodeExtent,\n@@ -227,17 +230,39 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         self.cfg.terminate(block, Terminator::Goto { target: target });\n     }\n \n-    /// Creates a path that performs all required cleanup for\n-    /// unwinding. This path terminates in DIVERGE. Returns the start\n-    /// of the path. See module comment for more details.\n-    pub fn diverge_cleanup(&mut self) -> BasicBlock {\n-        diverge_cleanup_helper(&mut self.cfg, &mut self.scopes)\n-    }\n+    /// Creates a path that performs all required cleanup for unwinding.\n+    ///\n+    /// This path terminates in Resume. Returns the start of the path.\n+    /// See module comment for more details. None indicates there\u2019s no\n+    /// cleanup to do at this point.\n+    pub fn diverge_cleanup(&mut self) -> Option<BasicBlock> {\n+        if self.scopes.is_empty() {\n+            return None;\n+        }\n \n-    /// Create diverge cleanup and branch to it from `block`.\n-    pub fn panic(&mut self, block: BasicBlock) {\n-        let cleanup = self.diverge_cleanup();\n-        self.cfg.terminate(block, Terminator::Panic { target: cleanup });\n+        let mut terminator = Terminator::Resume;\n+        // Given an array of scopes, we generate these from the outermost scope to the innermost\n+        // one. Thus for array [S0, S1, S2] with corresponding cleanup blocks [B0, B1, B2], we will\n+        // generate B0 <- B1 <- B2 in left-to-right order. The outermost scope (B0) will always\n+        // terminate with a Resume terminator.\n+        for scope in self.scopes.iter_mut().filter(|s| !s.drops.is_empty()) {\n+            if let Some(b) = scope.cached_block {\n+                terminator = Terminator::Goto { target: b };\n+                continue;\n+            } else {\n+                let new_block = self.cfg.start_new_block();\n+                self.cfg.block_data_mut(new_block).is_cleanup = true;\n+                self.cfg.terminate(new_block, terminator);\n+                terminator = Terminator::Goto { target: new_block };\n+                for &(kind, span, ref lvalue) in scope.drops.iter().rev() {\n+                    self.cfg.push_drop(new_block, span, kind, lvalue);\n+                }\n+                scope.cached_block = Some(new_block);\n+            }\n+        }\n+        // Return the innermost cached block, most likely the one we just generated.\n+        // Note that if there are no cleanups in scope we return None.\n+        self.scopes.iter().rev().flat_map(|b| b.cached_block).next()\n     }\n \n     /// Indicates that `lvalue` should be dropped on exit from\n@@ -249,14 +274,18 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                          lvalue: &Lvalue<'tcx>,\n                          lvalue_ty: Ty<'tcx>) {\n         if self.hir.needs_drop(lvalue_ty) {\n-            match self.scopes.iter_mut().rev().find(|s| s.extent == extent) {\n-                Some(scope) => {\n+            for scope in self.scopes.iter_mut().rev() {\n+                // We must invalidate all the cached_blocks leading up to the scope we\u2019re looking\n+                // for, because otherwise some/most of the blocks in the chain might become\n+                // incorrect (i.e. they still are pointing at old cached_block).\n+                scope.cached_block = None;\n+                if scope.extent == extent {\n                     scope.drops.push((kind, span, lvalue.clone()));\n-                    scope.cached_block = None;\n+                    return;\n                 }\n-                None => self.hir.span_bug(span, &format!(\"extent {:?} not in scope to drop {:?}\",\n-                                                         extent, lvalue)),\n             }\n+            self.hir.span_bug(span,\n+                              &format!(\"extent {:?} not in scope to drop {:?}\", extent, lvalue));\n         }\n     }\n \n@@ -267,29 +296,111 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     pub fn extent_of_outermost_scope(&self) -> CodeExtent {\n         self.scopes.first().map(|scope| scope.extent).unwrap()\n     }\n-}\n-\n-fn diverge_cleanup_helper<'tcx>(cfg: &mut CFG<'tcx>, scopes: &mut [Scope<'tcx>]) -> BasicBlock {\n-    let len = scopes.len();\n \n-    if len == 0 {\n-        return DIVERGE_BLOCK;\n+    pub fn panic_bounds_check(&mut self,\n+                             block: BasicBlock,\n+                             index: Operand<'tcx>,\n+                             len: Operand<'tcx>,\n+                             span: Span) {\n+        // fn(&(filename: &'static str, line: u32), index: usize, length: usize) -> !\n+        let func = self.lang_function(lang_items::PanicBoundsCheckFnLangItem);\n+        let args = func.ty.fn_args();\n+        let ref_ty = args.skip_binder()[0];\n+        let (region, tup_ty) = if let ty::TyRef(region, tyandmut) = ref_ty.sty {\n+            (region, tyandmut.ty)\n+        } else {\n+            self.hir.span_bug(span, &format!(\"unexpected panic_bound_check type: {:?}\", func.ty));\n+        };\n+        let (tuple, tuple_ref) = (self.temp(tup_ty), self.temp(ref_ty));\n+        let (file, line) = self.span_to_fileline_args(span);\n+        let elems = vec![Operand::Constant(file), Operand::Constant(line)];\n+        // FIXME: We should have this as a constant, rather than a stack variable (to not pollute\n+        // icache with cold branch code), however to achieve that we either have to rely on rvalue\n+        // promotion or have some way, in MIR, to create constants.\n+        self.cfg.push_assign(block, DUMMY_SP, &tuple, // tuple = (file_arg, line_arg);\n+                             Rvalue::Aggregate(AggregateKind::Tuple, elems));\n+        // FIXME: is this region really correct here?\n+        self.cfg.push_assign(block, DUMMY_SP, &tuple_ref, // tuple_ref = &tuple;\n+                             Rvalue::Ref(*region, BorrowKind::Unique, tuple));\n+        let cleanup = self.diverge_cleanup();\n+        self.cfg.terminate(block, Terminator::Call {\n+            func: Operand::Constant(func),\n+            args: vec![Operand::Consume(tuple_ref), index, len],\n+            kind: match cleanup {\n+                None => CallKind::Diverging,\n+                Some(c) => CallKind::DivergingCleanup(c)\n+            }\n+        });\n     }\n \n-    let (remaining, scope) = scopes.split_at_mut(len - 1);\n-    let scope = &mut scope[0];\n-\n-    if let Some(b) = scope.cached_block {\n-        return b;\n+    /// Create diverge cleanup and branch to it from `block`.\n+    pub fn panic(&mut self, block: BasicBlock, msg: &'static str, span: Span) {\n+        // fn(&(msg: &'static str filename: &'static str, line: u32)) -> !\n+        let func = self.lang_function(lang_items::PanicFnLangItem);\n+        let args = func.ty.fn_args();\n+        let ref_ty = args.skip_binder()[0];\n+        let (region, tup_ty) = if let ty::TyRef(region, tyandmut) = ref_ty.sty {\n+            (region, tyandmut.ty)\n+        } else {\n+            self.hir.span_bug(span, &format!(\"unexpected panic type: {:?}\", func.ty));\n+        };\n+        let (tuple, tuple_ref) = (self.temp(tup_ty), self.temp(ref_ty));\n+        let (file, line) = self.span_to_fileline_args(span);\n+        let message = Constant {\n+            span: DUMMY_SP,\n+            ty: self.hir.tcx().mk_static_str(),\n+            literal: self.hir.str_literal(intern_and_get_ident(msg))\n+        };\n+        let elems = vec![Operand::Constant(message),\n+                         Operand::Constant(file),\n+                         Operand::Constant(line)];\n+        // FIXME: We should have this as a constant, rather than a stack variable (to not pollute\n+        // icache with cold branch code), however to achieve that we either have to rely on rvalue\n+        // promotion or have some way, in MIR, to create constants.\n+        self.cfg.push_assign(block, DUMMY_SP, &tuple, // tuple = (message_arg, file_arg, line_arg);\n+                             Rvalue::Aggregate(AggregateKind::Tuple, elems));\n+        // FIXME: is this region really correct here?\n+        self.cfg.push_assign(block, DUMMY_SP, &tuple_ref, // tuple_ref = &tuple;\n+                             Rvalue::Ref(*region, BorrowKind::Unique, tuple));\n+        let cleanup = self.diverge_cleanup();\n+        self.cfg.terminate(block, Terminator::Call {\n+            func: Operand::Constant(func),\n+            args: vec![Operand::Consume(tuple_ref)],\n+            kind: match cleanup {\n+                None => CallKind::Diverging,\n+                Some(c) => CallKind::DivergingCleanup(c)\n+            }\n+        });\n     }\n \n-    let block = cfg.start_new_block();\n-    for &(kind, span, ref lvalue) in &scope.drops {\n-        cfg.push_drop(block, span, kind, lvalue);\n+    fn lang_function(&mut self, lang_item: lang_items::LangItem) -> Constant<'tcx> {\n+        let funcdid = match self.hir.tcx().lang_items.require(lang_item) {\n+            Ok(d) => d,\n+            Err(m) => {\n+                self.hir.tcx().sess.fatal(&*m)\n+            }\n+        };\n+        Constant {\n+            span: DUMMY_SP,\n+            ty: self.hir.tcx().lookup_item_type(funcdid).ty,\n+            literal: Literal::Item {\n+                def_id: funcdid,\n+                kind: ItemKind::Function,\n+                substs: self.hir.tcx().mk_substs(Substs::empty())\n+            }\n+        }\n     }\n-    scope.cached_block = Some(block);\n \n-    let remaining_cleanup_block = diverge_cleanup_helper(cfg, remaining);\n-    cfg.terminate(block, Terminator::Goto { target: remaining_cleanup_block });\n-    block\n+    fn span_to_fileline_args(&mut self, span: Span) -> (Constant<'tcx>, Constant<'tcx>) {\n+        let span_lines = self.hir.tcx().sess.codemap().lookup_char_pos(span.lo);\n+        (Constant {\n+            span: DUMMY_SP,\n+            ty: self.hir.tcx().mk_static_str(),\n+            literal: self.hir.str_literal(intern_and_get_ident(&span_lines.file.name))\n+        }, Constant {\n+            span: DUMMY_SP,\n+            ty: self.hir.tcx().types.u32,\n+            literal: self.hir.usize_literal(span_lines.line)\n+        })\n+    }\n }"}, {"sha": "1b8fe6505583c43664cc0f7ea3c9c5bdf9a697df", "filename": "src/librustc_mir/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_mir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_mir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fgraphviz.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -62,7 +62,7 @@ fn write_node<W: Write>(block: BasicBlock, mir: &Mir, w: &mut W) -> io::Result<(\n     // Terminator head at the bottom, not including the list of successor blocks. Those will be\n     // displayed as labels on the edges between blocks.\n     let mut terminator_head = String::new();\n-    data.terminator.fmt_head(&mut terminator_head).unwrap();\n+    data.terminator().fmt_head(&mut terminator_head).unwrap();\n     try!(write!(w, r#\"<tr><td align=\"left\">{}</td></tr>\"#, dot::escape_html(&terminator_head)));\n \n     // Close the table, node label, and the node itself.\n@@ -71,7 +71,7 @@ fn write_node<W: Write>(block: BasicBlock, mir: &Mir, w: &mut W) -> io::Result<(\n \n /// Write graphviz DOT edges with labels between the given basic block and all of its successors.\n fn write_edges<W: Write>(source: BasicBlock, mir: &Mir, w: &mut W) -> io::Result<()> {\n-    let terminator = &mir.basic_block_data(source).terminator;\n+    let terminator = &mir.basic_block_data(source).terminator();\n     let labels = terminator.fmt_successor_labels();\n \n     for (&target, label) in terminator.successors().iter().zip(labels) {"}, {"sha": "012bd9691be5f6b28e863818ef8265370214cec6", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -41,6 +41,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                                .map(|e| e.to_ref())\n                                .collect();\n                 ExprKind::Call {\n+                    ty: expr.ty,\n                     fun: expr.to_ref(),\n                     args: args,\n                 }\n@@ -58,11 +59,17 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     argrefs.extend(args.iter().map(|a| a.to_ref()));\n \n                     ExprKind::Call {\n+                        ty: method.ty,\n                         fun: method.to_ref(),\n                         args: argrefs,\n                     }\n                 } else {\n-                    ExprKind::Call { fun: fun.to_ref(), args: args.to_ref() }\n+                    ExprKind::Call {\n+                        ty: &cx.tcx.node_id_to_type(fun.id),\n+                        fun: fun.to_ref(),\n+                        args: args.to_ref(),\n+                    }\n+\n                 }\n             }\n \n@@ -802,6 +809,7 @@ fn overloaded_operator<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n     // now create the call itself\n     let fun = method_callee(cx, expr, method_call);\n     ExprKind::Call {\n+        ty: fun.ty,\n         fun: fun.to_ref(),\n         args: argrefs,\n     }"}, {"sha": "f9dd40defdf70aa44eb1b95a419cb34fd0c8e337", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -22,6 +22,7 @@ use rustc::middle::const_eval::{self, ConstVal};\n use rustc::middle::infer::InferCtxt;\n use rustc::middle::ty::{self, Ty};\n use syntax::codemap::Span;\n+use syntax::parse::token;\n use rustc_front::hir;\n \n #[derive(Copy, Clone)]\n@@ -61,6 +62,10 @@ impl<'a,'tcx:'a> Cx<'a, 'tcx> {\n         self.tcx.types.bool\n     }\n \n+    pub fn str_literal(&mut self, value: token::InternedString) -> Literal<'tcx> {\n+        Literal::Value { value: ConstVal::Str(value) }\n+    }\n+\n     pub fn true_literal(&mut self) -> Literal<'tcx> {\n         Literal::Value { value: ConstVal::Bool(true) }\n     }"}, {"sha": "fb81cc7e6d97a4394d65702fbf809466616046d0", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -19,7 +19,7 @@ use rustc::middle::const_eval::ConstVal;\n use rustc::middle::def_id::DefId;\n use rustc::middle::region::CodeExtent;\n use rustc::middle::subst::Substs;\n-use rustc::middle::ty::{AdtDef, ClosureSubsts, Region, Ty};\n+use rustc::middle::ty::{self, AdtDef, ClosureSubsts, Region, Ty};\n use rustc_front::hir;\n use syntax::ast;\n use syntax::codemap::Span;\n@@ -124,6 +124,7 @@ pub enum ExprKind<'tcx> {\n         value: ExprRef<'tcx>,\n     },\n     Call {\n+        ty: ty::Ty<'tcx>,\n         fun: ExprRef<'tcx>,\n         args: Vec<ExprRef<'tcx>>,\n     },"}, {"sha": "20a14cf415404feab75ba62affa757bd34727e40", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -59,7 +59,7 @@ impl<'a, 'tcx> EraseRegions<'a, 'tcx> {\n             self.erase_regions_statement(statement);\n         }\n \n-        self.erase_regions_terminator(&mut basic_block.terminator);\n+        self.erase_regions_terminator(basic_block.terminator_mut());\n     }\n \n     fn erase_regions_statement(&mut self,\n@@ -79,9 +79,8 @@ impl<'a, 'tcx> EraseRegions<'a, 'tcx> {\n                                 terminator: &mut Terminator<'tcx>) {\n         match *terminator {\n             Terminator::Goto { .. } |\n-            Terminator::Diverge |\n-            Terminator::Return |\n-            Terminator::Panic { .. } => {\n+            Terminator::Resume |\n+            Terminator::Return => {\n                 /* nothing to do */\n             }\n             Terminator::If { ref mut cond, .. } => {\n@@ -90,23 +89,14 @@ impl<'a, 'tcx> EraseRegions<'a, 'tcx> {\n             Terminator::Switch { ref mut discr, .. } => {\n                 self.erase_regions_lvalue(discr);\n             }\n-            Terminator::SwitchInt {\n-                ref mut discr,\n-                ref mut switch_ty,\n-                ..\n-            } => {\n+            Terminator::SwitchInt { ref mut discr, ref mut switch_ty, .. } => {\n                 self.erase_regions_lvalue(discr);\n                 *switch_ty = self.tcx.erase_regions(switch_ty);\n             },\n-            Terminator::Call {\n-                data: CallData {\n-                    ref mut destination,\n-                    ref mut func,\n-                    ref mut args\n-                },\n-                ..\n-            } => {\n-                self.erase_regions_lvalue(destination);\n+            Terminator::Call { ref mut func, ref mut args, ref mut kind } => {\n+                if let Some(ref mut destination) = kind.destination() {\n+                    self.erase_regions_lvalue(destination);\n+                }\n                 self.erase_regions_operand(func);\n                 for arg in &mut *args {\n                     self.erase_regions_operand(arg);"}, {"sha": "7a5a00a8d560b6e83cde98c3418e7094c72730c6", "filename": "src/librustc_mir/transform/simplify_cfg.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -10,7 +10,6 @@\n \n use rustc::middle::const_eval::ConstVal;\n use rustc::mir::repr::*;\n-use std::mem;\n use transform::util;\n use transform::MirPass;\n \n@@ -27,11 +26,10 @@ impl SimplifyCfg {\n         // These blocks are always required.\n         seen[START_BLOCK.index()] = true;\n         seen[END_BLOCK.index()] = true;\n-        seen[DIVERGE_BLOCK.index()] = true;\n \n         let mut worklist = vec![START_BLOCK];\n         while let Some(bb) = worklist.pop() {\n-            for succ in mir.basic_block_data(bb).terminator.successors() {\n+            for succ in mir.basic_block_data(bb).terminator().successors() {\n                 if !seen[succ.index()] {\n                     seen[succ.index()] = true;\n                     worklist.push(*succ);\n@@ -51,7 +49,7 @@ impl SimplifyCfg {\n \n             while mir.basic_block_data(target).statements.is_empty() {\n                 match mir.basic_block_data(target).terminator {\n-                    Terminator::Goto { target: next } => {\n+                    Some(Terminator::Goto { target: next }) => {\n                         if seen.contains(&next) {\n                             return None;\n                         }\n@@ -67,9 +65,9 @@ impl SimplifyCfg {\n \n         let mut changed = false;\n         for bb in mir.all_basic_blocks() {\n-            // Temporarily swap out the terminator we're modifying to keep borrowck happy\n-            let mut terminator = Terminator::Diverge;\n-            mem::swap(&mut terminator, &mut mir.basic_block_data_mut(bb).terminator);\n+            // Temporarily take ownership of the terminator we're modifying to keep borrowck happy\n+            let mut terminator = mir.basic_block_data_mut(bb).terminator.take()\n+                                    .expect(\"invalid terminator state\");\n \n             for target in terminator.successors_mut() {\n                 let new_target = match final_target(mir, *target) {\n@@ -80,22 +78,19 @@ impl SimplifyCfg {\n                 changed |= *target != new_target;\n                 *target = new_target;\n             }\n-\n-            mir.basic_block_data_mut(bb).terminator = terminator;\n+            mir.basic_block_data_mut(bb).terminator = Some(terminator);\n         }\n-\n         changed\n     }\n \n     fn simplify_branches(&self, mir: &mut Mir) -> bool {\n         let mut changed = false;\n \n         for bb in mir.all_basic_blocks() {\n-            // Temporarily swap out the terminator we're modifying to keep borrowck happy\n-            let mut terminator = Terminator::Diverge;\n-            mem::swap(&mut terminator, &mut mir.basic_block_data_mut(bb).terminator);\n+            let basic_block = mir.basic_block_data_mut(bb);\n+            let mut terminator = basic_block.terminator_mut();\n \n-            mir.basic_block_data_mut(bb).terminator = match terminator {\n+            *terminator = match *terminator {\n                 Terminator::If { ref targets, .. } if targets.0 == targets.1 => {\n                     changed = true;\n                     Terminator::Goto { target: targets.0 }\n@@ -115,7 +110,7 @@ impl SimplifyCfg {\n                 Terminator::SwitchInt { ref targets, .. }  if targets.len() == 1 => {\n                     Terminator::Goto { target: targets[0] }\n                 }\n-                _ => terminator\n+                _ => continue\n             }\n         }\n \n@@ -131,7 +126,6 @@ impl<'tcx> MirPass<'tcx> for SimplifyCfg {\n             changed |= self.remove_goto_chains(mir);\n             self.remove_dead_blocks(mir);\n         }\n-\n         // FIXME: Should probably be moved into some kind of pass manager\n         mir.basic_blocks.shrink_to_fit();\n     }"}, {"sha": "7e44beb18a2e96c8029a5bf61974308ba0fa383f", "filename": "src/librustc_mir/transform/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_mir%2Ftransform%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_mir%2Ftransform%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Futil.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -15,7 +15,7 @@ use rustc::mir::repr::*;\n /// in a single pass\n pub fn update_basic_block_ids(mir: &mut Mir, replacements: &[BasicBlock]) {\n     for bb in mir.all_basic_blocks() {\n-        for target in mir.basic_block_data_mut(bb).terminator.successors_mut() {\n+        for target in mir.basic_block_data_mut(bb).terminator_mut().successors_mut() {\n             *target = replacements[target.index()];\n         }\n     }"}, {"sha": "a6e6d3042205093ab7ce9769e1ed3b80bb272d48", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -958,22 +958,28 @@ pub fn wants_msvc_seh(sess: &Session) -> bool {\n     sess.target.target.options.is_like_msvc && sess.target.target.arch == \"x86\"\n }\n \n-pub fn need_invoke(bcx: Block) -> bool {\n+pub fn avoid_invoke(bcx: Block) -> bool {\n     // FIXME(#25869) currently SEH-based unwinding is pretty buggy in LLVM and\n     //               is being overhauled as this is being written. Until that\n     //               time such that upstream LLVM's implementation is more solid\n     //               and we start binding it we need to skip invokes for any\n     //               target which wants SEH-based unwinding.\n     if bcx.sess().no_landing_pads() || wants_msvc_seh(bcx.sess()) {\n-        return false;\n+        true\n+    } else if bcx.is_lpad {\n+        // Avoid using invoke if we are already inside a landing pad.\n+        true\n+    } else {\n+        false\n     }\n+}\n \n-    // Avoid using invoke if we are already inside a landing pad.\n-    if bcx.is_lpad {\n-        return false;\n+pub fn need_invoke(bcx: Block) -> bool {\n+    if avoid_invoke(bcx) {\n+        false\n+    } else {\n+        bcx.fcx.needs_invoke()\n     }\n-\n-    bcx.fcx.needs_invoke()\n }\n \n pub fn load_if_immediate<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef, t: Ty<'tcx>) -> ValueRef {"}, {"sha": "aa0b3a25ebb0cabc8f3603255922c8c2bdd484f1", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 155, "deletions": 71, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -8,16 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::BasicBlockRef;\n-use middle::infer;\n-use middle::ty;\n+use llvm::{BasicBlockRef, ValueRef};\n use rustc::mir::repr as mir;\n use trans::adt;\n use trans::base;\n use trans::build;\n+use trans::attributes;\n use trans::common::{self, Block};\n use trans::debuginfo::DebugLoc;\n use trans::type_of;\n+use trans::type_::Type;\n \n use super::MirContext;\n use super::operand::OperandValue::{FatPtr, Immediate, Ref};\n@@ -33,17 +33,13 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             bcx = self.trans_statement(bcx, statement);\n         }\n \n-        debug!(\"trans_block: terminator: {:?}\", data.terminator);\n+        debug!(\"trans_block: terminator: {:?}\", data.terminator());\n \n-        match data.terminator {\n+        match *data.terminator() {\n             mir::Terminator::Goto { target } => {\n                 build::Br(bcx, self.llblock(target), DebugLoc::None)\n             }\n \n-            mir::Terminator::Panic { .. } => {\n-                unimplemented!()\n-            }\n-\n             mir::Terminator::If { ref cond, targets: (true_bb, false_bb) } => {\n                 let cond = self.trans_operand(bcx, cond);\n                 let lltrue = self.llblock(true_bb);\n@@ -60,10 +56,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n                 // The else branch of the Switch can't be hit, so branch to an unreachable\n                 // instruction so LLVM knows that\n-                // FIXME it might be nice to have just one such block (created lazilly), we could\n-                // store it in the \"MIR trans\" state.\n-                let unreachable_blk = bcx.fcx.new_temp_block(\"enum-variant-unreachable\");\n-                build::Unreachable(unreachable_blk);\n+                let unreachable_blk = self.unreachable_block();\n \n                 let switch = build::Switch(bcx, discr, unreachable_blk.llbb, targets.len());\n                 assert_eq!(adt_def.variants.len(), targets.len());\n@@ -86,84 +79,175 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 }\n             }\n \n-            mir::Terminator::Diverge => {\n-                if let Some(llpersonalityslot) = self.llpersonalityslot {\n-                    let lp = build::Load(bcx, llpersonalityslot);\n-                    // FIXME(lifetime) base::call_lifetime_end(bcx, self.personality);\n-                    build::Resume(bcx, lp);\n-                } else {\n-                    // This fn never encountered anything fallible, so\n-                    // a Diverge cannot actually happen. Note that we\n-                    // do a total hack to ensure that we visit the\n-                    // DIVERGE block last.\n-                    build::Unreachable(bcx);\n-                }\n+            mir::Terminator::Resume => {\n+                let ps = self.get_personality_slot(bcx);\n+                let lp = build::Load(bcx, ps);\n+                base::call_lifetime_end(bcx, ps);\n+                base::trans_unwind_resume(bcx, lp);\n             }\n \n             mir::Terminator::Return => {\n                 let return_ty = bcx.monomorphize(&self.mir.return_ty);\n                 base::build_return_block(bcx.fcx, bcx, return_ty, DebugLoc::None);\n             }\n \n-            mir::Terminator::Call { ref data, targets } => {\n-                // The location we'll write the result of the call into.\n-                let call_dest = self.trans_lvalue(bcx, &data.destination);\n-\n-                // Create the callee. This will always be a fn\n-                // ptr and hence a kind of scalar.\n-                let callee = self.trans_operand(bcx, &data.func);\n-                let ret_ty = if let ty::TyBareFn(_, ref f) = callee.ty.sty {\n-                    let sig = bcx.tcx().erase_late_bound_regions(&f.sig);\n-                    let sig = infer::normalize_associated_type(bcx.tcx(), &sig);\n-                    sig.output\n-                } else {\n-                    panic!(\"trans_block: expected TyBareFn as callee\");\n-                };\n+            mir::Terminator::Call { ref func, ref args, ref kind } => {\n+                // Create the callee. This will always be a fn ptr and hence a kind of scalar.\n+                let callee = self.trans_operand(bcx, func);\n+                let attrs = attributes::from_fn_type(bcx.ccx(), callee.ty);\n+                let debugloc = DebugLoc::None;\n+                // The arguments we'll be passing. Plus one to account for outptr, if used.\n+                let mut llargs = Vec::with_capacity(args.len() + 1);\n \n-                // The arguments we'll be passing\n-                let mut llargs = vec![];\n-\n-                // Does the fn use an outptr? If so, that's the first arg.\n-                if let ty::FnConverging(ret_ty) = ret_ty {\n+                // Prepare the return value destination\n+                let (ret_dest_ty, must_copy_dest) = if let Some(ref d) = kind.destination() {\n+                    let dest = self.trans_lvalue(bcx, d);\n+                    let ret_ty = dest.ty.to_ty(bcx.tcx());\n                     if type_of::return_uses_outptr(bcx.ccx(), ret_ty) {\n-                        llargs.push(call_dest.llval);\n+                        llargs.push(dest.llval);\n+                        (Some((dest, ret_ty)), false)\n+                    } else {\n+                        (Some((dest, ret_ty)), !common::type_is_zero_size(bcx.ccx(), ret_ty))\n                     }\n-                }\n+                } else {\n+                    (None, false)\n+                };\n \n                 // Process the rest of the args.\n-                for arg in &data.args {\n-                    let arg_op = self.trans_operand(bcx, arg);\n-                    match arg_op.val {\n+                for arg in args {\n+                    match self.trans_operand(bcx, arg).val {\n                         Ref(llval) | Immediate(llval) => llargs.push(llval),\n-                        FatPtr(base, extra) => {\n-                            // The two words in a fat ptr are passed separately\n-                            llargs.push(base);\n-                            llargs.push(extra);\n+                        FatPtr(b, e) => {\n+                            llargs.push(b);\n+                            llargs.push(e);\n                         }\n                     }\n                 }\n \n-                // FIXME: Handle panics\n-                //let panic_bb = self.llblock(targets.1);\n-                //self.make_landing_pad(panic_bb);\n-\n-                // Do the actual call.\n-                let (llret, b) = base::invoke(bcx,\n-                                              callee.immediate(),\n-                                              &llargs[..],\n-                                              callee.ty,\n-                                              DebugLoc::None);\n-                bcx = b;\n-\n-                // Copy the return value into the destination.\n-                if let ty::FnConverging(ret_ty) = ret_ty {\n-                    if !type_of::return_uses_outptr(bcx.ccx(), ret_ty) &&\n-                       !common::type_is_zero_size(bcx.ccx(), ret_ty) {\n-                        base::store_ty(bcx, llret, call_dest.llval, ret_ty);\n+                // Many different ways to call a function handled here\n+                match (base::avoid_invoke(bcx), kind) {\n+                    // The two cases below are the only ones to use LLVM\u2019s `invoke`.\n+                    (false, &mir::CallKind::DivergingCleanup(cleanup)) => {\n+                        let cleanup = self.bcx(cleanup);\n+                        let landingpad = self.make_landing_pad(cleanup);\n+                        build::Invoke(bcx,\n+                                      callee.immediate(),\n+                                      &llargs[..],\n+                                      self.unreachable_block().llbb,\n+                                      landingpad.llbb,\n+                                      Some(attrs),\n+                                      debugloc);\n+                    },\n+                    (false, &mir::CallKind::ConvergingCleanup { ref targets, .. }) => {\n+                        let cleanup = self.bcx(targets.1);\n+                        let landingpad = self.make_landing_pad(cleanup);\n+                        let (target, postinvoke) = if must_copy_dest {\n+                            (bcx.fcx.new_block(false, \"\", None), Some(self.bcx(targets.0)))\n+                        } else {\n+                            (self.bcx(targets.0), None)\n+                        };\n+                        let invokeret = build::Invoke(bcx,\n+                                                      callee.immediate(),\n+                                                      &llargs[..],\n+                                                      target.llbb,\n+                                                      landingpad.llbb,\n+                                                      Some(attrs),\n+                                                      debugloc);\n+                        if let Some(postinvoketarget) = postinvoke {\n+                            // We translate the copy into a temoprary block. The temporary block is\n+                            // necessary because the current block has already been terminated (by\n+                            // `invoke`) and we cannot really translate into the target block\n+                            // because:\n+                            //  * The target block may have more than a single precedesor;\n+                            //  * Some LLVM insns cannot have a preceeding store insn (phi,\n+                            //    cleanuppad), and adding/prepending the store now may render\n+                            //    those other instructions invalid.\n+                            //\n+                            // NB: This approach still may break some LLVM code. For example if the\n+                            // target block starts with a `phi` (which may only match on immediate\n+                            // precedesors), it cannot know about this temporary block thus\n+                            // resulting in an invalid code:\n+                            //\n+                            // this:\n+                            //     \u2026\n+                            //     %0 = \u2026\n+                            //     %1 = invoke to label %temp \u2026\n+                            // temp:\n+                            //     store ty %1, ty* %dest\n+                            //     br label %actualtargetblock\n+                            // actualtargetblock:            ; preds: %temp, \u2026\n+                            //     phi \u2026 [%this, \u2026], [%0, \u2026] ; ERROR: phi requires to match only on\n+                            //                               ; immediate precedesors\n+                            let (ret_dest, ret_ty) = ret_dest_ty\n+                                .expect(\"return destination and type not set\");\n+                            base::store_ty(target, invokeret, ret_dest.llval, ret_ty);\n+                            build::Br(target, postinvoketarget.llbb, debugloc);\n+                        }\n+                    },\n+                    (_, &mir::CallKind::DivergingCleanup(_)) |\n+                    (_, &mir::CallKind::Diverging) => {\n+                        build::Call(bcx, callee.immediate(), &llargs[..], Some(attrs), debugloc);\n+                        build::Unreachable(bcx);\n+                    }\n+                    (_, k@&mir::CallKind::ConvergingCleanup { .. }) |\n+                    (_, k@&mir::CallKind::Converging { .. }) => {\n+                        // Bug #20046\n+                        let target = match *k {\n+                            mir::CallKind::ConvergingCleanup { targets, .. } => targets.0,\n+                            mir::CallKind::Converging { target, .. } => target,\n+                            _ => unreachable!()\n+                        };\n+                        let llret = build::Call(bcx,\n+                                                callee.immediate(),\n+                                                &llargs[..],\n+                                                Some(attrs),\n+                                                debugloc);\n+                        if must_copy_dest {\n+                            let (ret_dest, ret_ty) = ret_dest_ty\n+                                .expect(\"return destination and type not set\");\n+                            base::store_ty(bcx, llret, ret_dest.llval, ret_ty);\n+                        }\n+                        build::Br(bcx, self.llblock(target), debugloc);\n                     }\n                 }\n+            }\n+        }\n+    }\n+\n+    fn get_personality_slot(&mut self, bcx: Block<'bcx, 'tcx>) -> ValueRef {\n+        let ccx = bcx.ccx();\n+        if let Some(slot) = self.llpersonalityslot {\n+            slot\n+        } else {\n+            let llretty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false);\n+            let slot = base::alloca(bcx, llretty, \"personalityslot\");\n+            self.llpersonalityslot = Some(slot);\n+            base::call_lifetime_start(bcx, slot);\n+            slot\n+        }\n+    }\n+\n+    fn make_landing_pad(&mut self, cleanup: Block<'bcx, 'tcx>) -> Block<'bcx, 'tcx> {\n+        let bcx = cleanup.fcx.new_block(true, \"cleanup\", None);\n+        let ccx = bcx.ccx();\n+        let llpersonality = bcx.fcx.eh_personality();\n+        let llretty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false);\n+        let llretval = build::LandingPad(bcx, llretty, llpersonality, 1);\n+        build::SetCleanup(bcx, llretval);\n+        let slot = self.get_personality_slot(bcx);\n+        build::Store(bcx, llretval, slot);\n+        build::Br(bcx, cleanup.llbb, DebugLoc::None);\n+        bcx\n+    }\n \n-                build::Br(bcx, self.llblock(targets.0), DebugLoc::None)\n+    fn unreachable_block(&mut self) -> Block<'bcx, 'tcx> {\n+        match self.unreachable_block {\n+            Some(b) => b,\n+            None => {\n+                let bl = self.fcx.new_block(false, \"unreachable\", None);\n+                build::Unreachable(bl);\n+                self.unreachable_block = Some(bl);\n+                bl\n             }\n         }\n     }"}, {"sha": "f7245879e2dcee6dee4e4e374a02f0bf7e83d92e", "filename": "src/librustc_trans/trans/mir/lvalue.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -18,6 +18,8 @@ use trans::build;\n use trans::common::{self, Block};\n use trans::debuginfo::DebugLoc;\n use trans::machine;\n+use trans::type_of;\n+use llvm;\n \n use std::ptr;\n \n@@ -91,10 +93,23 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     const_ty)\n             },\n             mir::Lvalue::ReturnPointer => {\n-                let return_ty = bcx.monomorphize(&self.mir.return_ty);\n-                let llval = fcx.get_ret_slot(bcx, return_ty, \"return\");\n-                LvalueRef::new_sized(llval, LvalueTy::from_ty(return_ty.unwrap()))\n-            }\n+                let fn_return_ty = bcx.monomorphize(&self.mir.return_ty);\n+                let return_ty = fn_return_ty.unwrap();\n+                let llval = if !common::return_type_is_void(bcx.ccx(), return_ty) {\n+                    fcx.get_ret_slot(bcx, fn_return_ty, \"\")\n+                } else {\n+                    // This is a void return; that is, there\u2019s no place to store the value and\n+                    // there cannot really be one (or storing into it doesn\u2019t make sense, anyway).\n+                    // Ergo, we return an undef ValueRef, so we do not have to special-case every\n+                    // place using lvalues, and could use it the same way you use a regular\n+                    // ReturnPointer LValue (i.e. store into it, load from it etc).\n+                    let llty = type_of::type_of(bcx.ccx(), return_ty).ptr_to();\n+                    unsafe {\n+                        llvm::LLVMGetUndef(llty.to_ref())\n+                    }\n+                };\n+                LvalueRef::new_sized(llval, LvalueTy::from_ty(return_ty))\n+            },\n             mir::Lvalue::Projection(ref projection) => {\n                 let tr_base = self.trans_lvalue(bcx, &projection.base);\n                 let projected_ty = tr_base.ty.projection_ty(tcx, &projection.elem);"}, {"sha": "75ce33da2c9b9da66eb84a77ad40fbdabb3f1eaf", "filename": "src/librustc_trans/trans/mir/mod.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -28,6 +28,9 @@ use self::operand::OperandRef;\n pub struct MirContext<'bcx, 'tcx:'bcx> {\n     mir: &'bcx mir::Mir<'tcx>,\n \n+    /// Function context\n+    fcx: &'bcx common::FunctionContext<'bcx, 'tcx>,\n+\n     /// When unwinding is initiated, we have to store this personality\n     /// value somewhere so that we can load it and re-use it in the\n     /// resume instruction. The personality is (afaik) some kind of\n@@ -40,6 +43,9 @@ pub struct MirContext<'bcx, 'tcx:'bcx> {\n     /// A `Block` for each MIR `BasicBlock`\n     blocks: Vec<Block<'bcx, 'tcx>>,\n \n+    /// Cached unreachable block\n+    unreachable_block: Option<Block<'bcx, 'tcx>>,\n+\n     /// An LLVM alloca for each MIR `VarDecl`\n     vars: Vec<LvalueRef<'tcx>>,\n \n@@ -107,7 +113,10 @@ pub fn trans_mir<'bcx, 'tcx>(bcx: Block<'bcx, 'tcx>) {\n     // Allocate a `Block` for every basic block\n     let block_bcxs: Vec<Block<'bcx,'tcx>> =\n         mir_blocks.iter()\n-                  .map(|&bb| fcx.new_block(false, &format!(\"{:?}\", bb), None))\n+                  .map(|&bb|{\n+                      let is_cleanup = mir.basic_block_data(bb).is_cleanup;\n+                      fcx.new_block(is_cleanup, &format!(\"{:?}\", bb), None)\n+                  })\n                   .collect();\n \n     // Branch to the START block\n@@ -116,25 +125,19 @@ pub fn trans_mir<'bcx, 'tcx>(bcx: Block<'bcx, 'tcx>) {\n \n     let mut mircx = MirContext {\n         mir: mir,\n+        fcx: fcx,\n         llpersonalityslot: None,\n         blocks: block_bcxs,\n+        unreachable_block: None,\n         vars: vars,\n         temps: temps,\n         args: args,\n     };\n \n     // Translate the body of each block\n     for &bb in &mir_blocks {\n-        if bb != mir::DIVERGE_BLOCK {\n-            mircx.trans_block(bb);\n-        }\n+        mircx.trans_block(bb);\n     }\n-\n-    // Total hack: translate DIVERGE_BLOCK last. This is so that any\n-    // panics which the fn may do can initialize the\n-    // `llpersonalityslot` cell. We don't do this up front because the\n-    // LLVM type of it is (frankly) annoying to compute.\n-    mircx.trans_block(mir::DIVERGE_BLOCK);\n }\n \n /// Produce, for each argument, a `ValueRef` pointing at the"}, {"sha": "e0d20a20577a8bfe8ec0999fd9c9822908b6140c", "filename": "src/test/run-fail/mir_indexing_oob_1.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Ftest%2Frun-fail%2Fmir_indexing_oob_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Ftest%2Frun-fail%2Fmir_indexing_oob_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_indexing_oob_1.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:index out of bounds: the len is 5 but the index is 10\n+#![feature(rustc_attrs)]\n+\n+const C: [u32; 5] = [0; 5];\n+\n+#[rustc_mir]\n+fn test() -> u32 {\n+    C[10]\n+}\n+\n+fn main() {\n+    test();\n+}"}, {"sha": "6c65be5769f2d4bec1baeb277d458288a64c9013", "filename": "src/test/run-fail/mir_indexing_oob_2.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Ftest%2Frun-fail%2Fmir_indexing_oob_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Ftest%2Frun-fail%2Fmir_indexing_oob_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_indexing_oob_2.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:index out of bounds: the len is 5 but the index is 10\n+#![feature(rustc_attrs)]\n+\n+const C: &'static [u8; 5] = b\"hello\";\n+\n+#[rustc_mir]\n+fn test() -> u8 {\n+    C[10]\n+}\n+\n+fn main() {\n+    test();\n+}"}, {"sha": "5f3fc9376b0d3ec69b367203c9a5fc8033f3c654", "filename": "src/test/run-fail/mir_indexing_oob_3.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Ftest%2Frun-fail%2Fmir_indexing_oob_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Ftest%2Frun-fail%2Fmir_indexing_oob_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_indexing_oob_3.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:index out of bounds: the len is 5 but the index is 10\n+#![feature(rustc_attrs)]\n+\n+const C: &'static [u8; 5] = b\"hello\";\n+\n+#[rustc_mir]\n+fn mir() -> u8 {\n+    C[10]\n+}\n+\n+fn main() {\n+    mir();\n+}"}, {"sha": "754f616cfd5a0e4db875853a27eeabe376d8a3d0", "filename": "src/test/run-fail/mir_trans_calls_converging_drops.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Ftest%2Frun-fail%2Fmir_trans_calls_converging_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Ftest%2Frun-fail%2Fmir_trans_calls_converging_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_trans_calls_converging_drops.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(rustc_attrs)]\n+// error-pattern:converging_fn called\n+// error-pattern:0 dropped\n+// error-pattern:exit\n+\n+use std::io::{self, Write};\n+\n+struct Droppable(u8);\n+impl Drop for Droppable {\n+    fn drop(&mut self) {\n+        write!(io::stderr(), \"{} dropped\\n\", self.0);\n+    }\n+}\n+\n+fn converging_fn() {\n+    write!(io::stderr(), \"converging_fn called\\n\");\n+}\n+\n+#[rustc_mir]\n+fn mir(d: Droppable) {\n+    converging_fn();\n+}\n+\n+fn main() {\n+    let d = Droppable(0);\n+    mir(d);\n+    panic!(\"exit\");\n+}"}, {"sha": "5e870be3bc6ec7179ac5e7122c7db706b83320ce", "filename": "src/test/run-fail/mir_trans_calls_converging_drops_2.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Ftest%2Frun-fail%2Fmir_trans_calls_converging_drops_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Ftest%2Frun-fail%2Fmir_trans_calls_converging_drops_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_trans_calls_converging_drops_2.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(rustc_attrs)]\n+// error-pattern:complex called\n+// error-pattern:dropped\n+// error-pattern:exit\n+\n+use std::io::{self, Write};\n+\n+struct Droppable;\n+impl Drop for Droppable {\n+    fn drop(&mut self) {\n+        write!(io::stderr(), \"dropped\\n\");\n+    }\n+}\n+\n+// return value of this function is copied into the return slot\n+fn complex() -> u64 {\n+    write!(io::stderr(), \"complex called\\n\");\n+    42\n+}\n+\n+\n+#[rustc_mir]\n+fn mir() -> u64 {\n+    let x = Droppable;\n+    return complex();\n+    drop(x);\n+}\n+\n+pub fn main() {\n+    assert_eq!(mir(), 42);\n+    panic!(\"exit\");\n+}"}, {"sha": "fcd8ab26a0a8831c46508569d4de9023d2687f48", "filename": "src/test/run-fail/mir_trans_calls_diverging.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Ftest%2Frun-fail%2Fmir_trans_calls_diverging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Ftest%2Frun-fail%2Fmir_trans_calls_diverging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_trans_calls_diverging.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(rustc_attrs)]\n+// error-pattern:diverging_fn called\n+\n+fn diverging_fn() -> ! {\n+    panic!(\"diverging_fn called\")\n+}\n+\n+#[rustc_mir]\n+fn mir() {\n+    diverging_fn();\n+}\n+\n+fn main() {\n+    mir();\n+}"}, {"sha": "ffa1ff0827775f253399cdade0bd29c55f1c2c76", "filename": "src/test/run-fail/mir_trans_calls_diverging_drops.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Ftest%2Frun-fail%2Fmir_trans_calls_diverging_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Ftest%2Frun-fail%2Fmir_trans_calls_diverging_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_trans_calls_diverging_drops.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(rustc_attrs)]\n+// error-pattern:diverging_fn called\n+// error-pattern:0 dropped\n+use std::io::{self, Write};\n+\n+struct Droppable(u8);\n+impl Drop for Droppable {\n+    fn drop(&mut self) {\n+        write!(io::stderr(), \"{} dropped\", self.0);\n+    }\n+}\n+\n+fn diverging_fn() -> ! {\n+    panic!(\"diverging_fn called\")\n+}\n+\n+#[rustc_mir]\n+fn mir(d: Droppable) {\n+    diverging_fn();\n+}\n+\n+fn main() {\n+    let d = Droppable(0);\n+    mir(d);\n+}"}, {"sha": "bc913fdab1c07da5bf7b57517a57ded3389359eb", "filename": "src/test/run-fail/mir_trans_no_landing_pads.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Ftest%2Frun-fail%2Fmir_trans_no_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Ftest%2Frun-fail%2Fmir_trans_no_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_trans_no_landing_pads.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(rustc_attrs)]\n+// compile-flags: -Z no-landing-pads\n+// error-pattern:converging_fn called\n+use std::io::{self, Write};\n+\n+struct Droppable;\n+impl Drop for Droppable {\n+    fn drop(&mut self) {\n+        ::std::process::exit(1)\n+    }\n+}\n+\n+fn converging_fn() {\n+    panic!(\"converging_fn called\")\n+}\n+\n+#[rustc_mir]\n+fn mir(d: Droppable) {\n+    let x = Droppable;\n+    converging_fn();\n+    drop(x);\n+    drop(d);\n+}\n+\n+fn main() {\n+    mir(Droppable);\n+}"}, {"sha": "d97eb8c89e3e0ce01d54da852e132c74214b5264", "filename": "src/test/run-fail/mir_trans_no_landing_pads_diverging.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Ftest%2Frun-fail%2Fmir_trans_no_landing_pads_diverging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Ftest%2Frun-fail%2Fmir_trans_no_landing_pads_diverging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_trans_no_landing_pads_diverging.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(rustc_attrs)]\n+// compile-flags: -Z no-landing-pads\n+// error-pattern:diverging_fn called\n+use std::io::{self, Write};\n+\n+struct Droppable;\n+impl Drop for Droppable {\n+    fn drop(&mut self) {\n+        ::std::process::exit(1)\n+    }\n+}\n+\n+fn diverging_fn() -> ! {\n+    panic!(\"diverging_fn called\")\n+}\n+\n+#[rustc_mir]\n+fn mir(d: Droppable) {\n+    let x = Droppable;\n+    diverging_fn();\n+    drop(x);\n+    drop(d);\n+}\n+\n+fn main() {\n+    mir(Droppable);\n+}"}, {"sha": "d8acfec25c4b5dc1b5ae3851ac8255ff30d0a78e", "filename": "src/test/run-pass/mir_trans_call_converging.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Ftest%2Frun-pass%2Fmir_trans_call_converging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Ftest%2Frun-pass%2Fmir_trans_call_converging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_trans_call_converging.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(rustc_attrs)]\n+\n+fn converging_fn() -> u64 {\n+    43\n+}\n+\n+#[rustc_mir]\n+fn mir() -> u64 {\n+    let x;\n+    loop {\n+        x = converging_fn();\n+        break;\n+    }\n+    x\n+}\n+\n+fn main() {\n+    assert_eq!(mir(), 43);\n+}"}, {"sha": "8b07449b8fafd93e765e89f95a51dae30c349d7d", "filename": "src/test/run-pass/mir_void_return.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Ftest%2Frun-pass%2Fmir_void_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Ftest%2Frun-pass%2Fmir_void_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_void_return.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_mir]\n+fn mir() -> (){\n+    let x = 1;\n+    let mut y = 0;\n+    while  y < x {\n+        y += 1\n+    }\n+}\n+\n+pub fn main() {\n+    mir();\n+}"}, {"sha": "a3ad343240918b0c522374362e508761925d6bcf", "filename": "src/test/run-pass/mir_void_return_2.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Ftest%2Frun-pass%2Fmir_void_return_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ac1a1da327f22bb865f23963f1070d4fd40c0c/src%2Ftest%2Frun-pass%2Fmir_void_return_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_void_return_2.rs?ref=d5ac1a1da327f22bb865f23963f1070d4fd40c0c", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+fn nil() {}\n+\n+#[rustc_mir]\n+fn mir(){\n+    nil()\n+}\n+\n+pub fn main() {\n+    mir();\n+}"}]}