{"sha": "c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxY2ZkNThjYmRiODRmODM0Yjg5MDdkYzVlMWM3MjQyYzQ1MTIyNWQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-14T22:07:09Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-17T02:50:57Z"}, "message": "rustc: remove SelfSpace from ParamSpace.", "tree": {"sha": "3eaab8714d95f7daab2469b39b50d7dc322a7d03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3eaab8714d95f7daab2469b39b50d7dc322a7d03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "html_url": "https://github.com/rust-lang/rust/commit/c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4158673ad7150f4fa02fbea3654e8cf1628beb0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4158673ad7150f4fa02fbea3654e8cf1628beb0b", "html_url": "https://github.com/rust-lang/rust/commit/4158673ad7150f4fa02fbea3654e8cf1628beb0b"}], "stats": {"total": 633, "additions": 276, "deletions": 357}, "files": [{"sha": "d15d51aed09a1049febb903ef1952ee73b56660e", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use hir::def_id::DefId;\n-use ty::subst::ParamSpace;\n use util::nodemap::NodeMap;\n use syntax::ast;\n use hir;\n@@ -31,7 +30,7 @@ pub enum Def {\n     AssociatedTy(DefId /* trait */, DefId),\n     Trait(DefId),\n     PrimTy(hir::PrimTy),\n-    TyParam(ParamSpace, u32, DefId, ast::Name),\n+    TyParam(DefId),\n     Upvar(DefId,        // def id of closed over local\n              ast::NodeId,  // node id of closed over local\n              usize,        // index in the freevars list of the closure\n@@ -122,7 +121,7 @@ impl Def {\n         match *self {\n             Def::Fn(id) | Def::Mod(id) | Def::ForeignMod(id) | Def::Static(id, _) |\n             Def::Variant(_, id) | Def::Enum(id) | Def::TyAlias(id) | Def::AssociatedTy(_, id) |\n-            Def::TyParam(_, _, id, _) | Def::Struct(id) | Def::Trait(id) |\n+            Def::TyParam(id) | Def::Struct(id) | Def::Trait(id) |\n             Def::Method(id) | Def::Const(id) | Def::AssociatedConst(id) |\n             Def::Local(id, _) | Def::Upvar(id, _, _, _) => {\n                 id"}, {"sha": "20e281816b8b05a1e9f251f0c5f4dee5cdd539ea", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -95,7 +95,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             Def::AssociatedTy(..) | Def::Method(_) | Def::AssociatedConst(_)\n             if self.tcx.trait_of_item(def.def_id()).is_some() => {\n                 if let Some(substs) = self.tcx.tables.borrow().item_substs.get(&id) {\n-                    match substs.substs.types.get(subst::SelfSpace, 0).sty {\n+                    match substs.substs.types.get(subst::TypeSpace, 0).sty {\n                         TyEnum(tyid, _) | TyStruct(tyid, _) => {\n                             self.check_def_id(tyid.did)\n                         }"}, {"sha": "a5a415dd27c650a1debb9ea50b0bd4e47facc89d", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -14,7 +14,6 @@ use super::{SelectionContext, Obligation, ObligationCause};\n \n use middle::cstore::LOCAL_CRATE;\n use hir::def_id::DefId;\n-use ty::subst::TypeSpace;\n use ty::{self, Ty, TyCtxt};\n use infer::{InferCtxt, TypeOrigin};\n use syntax_pos::DUMMY_SP;\n@@ -160,12 +159,9 @@ fn orphan_check_trait_ref<'tcx>(tcx: TyCtxt,\n \n     // First, create an ordered iterator over all the type parameters to the trait, with the self\n     // type appearing first.\n-    let input_tys = Some(trait_ref.self_ty());\n-    let input_tys = input_tys.iter().chain(trait_ref.substs.types.get_slice(TypeSpace));\n-\n     // Find the first input type that either references a type parameter OR\n     // some local type.\n-    for input_ty in input_tys {\n+    for input_ty in trait_ref.input_types() {\n         if ty_is_local(tcx, input_ty, infer_is_local) {\n             debug!(\"orphan_check_trait_ref: ty_is_local `{:?}`\", input_ty);\n "}, {"sha": "77c1137c6c3be630cffa238677fb4e22522fb26b", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -232,8 +232,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 if let Ok(..) = self.can_equate(&trait_self_ty, &impl_self_ty) {\n                     self_match_impls.push(def_id);\n \n-                    if trait_ref.substs.types.get_slice(TypeSpace).iter()\n-                        .zip(impl_trait_ref.substs.types.get_slice(TypeSpace))\n+                    if trait_ref.substs.types.get_slice(TypeSpace)[1..].iter()\n+                        .zip(&impl_trait_ref.substs.types.get_slice(TypeSpace)[1..])\n                         .all(|(u,v)| self.fuzzy_match_tys(u, v))\n                     {\n                         fuzzy_match_impls.push(def_id);"}, {"sha": "11cf759859c62e58f762d34c8b092767932765f6", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -20,7 +20,7 @@\n use super::elaborate_predicates;\n \n use hir::def_id::DefId;\n-use ty::subst::{self, SelfSpace, TypeSpace};\n+use ty::subst;\n use traits;\n use ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use std::rc::Rc;\n@@ -146,10 +146,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 match predicate {\n                     ty::Predicate::Trait(ref data) => {\n                         // In the case of a trait predicate, we can skip the \"self\" type.\n-                        data.0.trait_ref.substs.types.get_slice(TypeSpace)\n-                                                     .iter()\n-                                                     .cloned()\n-                                                     .any(|t| t.has_self_ty())\n+                        data.0.trait_ref.input_types()[1..].iter().any(|t| t.has_self_ty())\n                     }\n                     ty::Predicate::Projection(..) |\n                     ty::Predicate::WellFormed(..) |\n@@ -325,7 +322,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         ty.maybe_walk(|ty| {\n             match ty.sty {\n                 ty::TyParam(ref param_ty) => {\n-                    if param_ty.space == SelfSpace {\n+                    if param_ty.is_self() {\n                         error = true;\n                     }\n "}, {"sha": "c2daa81ca7dab0726a40d7e2cd6271ec04673e74", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -1353,7 +1353,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_self_type(self) -> Ty<'tcx> {\n-        self.mk_param(subst::SelfSpace, 0, keywords::SelfType.name())\n+        self.mk_param(subst::TypeSpace, 0, keywords::SelfType.name())\n     }\n \n     pub fn mk_param_from_def(self, def: &ty::TypeParameterDef) -> Ty<'tcx> {"}, {"sha": "17f9b6c25995c48bc1d6f4e72677dd8068debcd2", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use hir::def_id::DefId;\n-use ty::subst;\n use infer::type_variable;\n use ty::{self, BoundRegion, Region, Ty, TyCtxt};\n \n@@ -258,7 +257,7 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             ty::TyInfer(ty::FreshFloatTy(_)) => \"skolemized floating-point type\".to_string(),\n             ty::TyProjection(_) => \"associated type\".to_string(),\n             ty::TyParam(ref p) => {\n-                if p.space == subst::SelfSpace {\n+                if p.is_self() {\n                     \"Self\".to_string()\n                 } else {\n                     \"type parameter\".to_string()"}, {"sha": "900e1841fb592348a52453b4e80b38a32f2a6b06", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ty::subst::{self, Substs};\n+use ty::subst::Substs;\n use ty::{self, Ty, TypeFlags, TypeFoldable};\n \n pub struct FlagComputation {\n@@ -77,7 +77,7 @@ impl FlagComputation {\n \n             &ty::TyParam(ref p) => {\n                 self.add_flags(TypeFlags::HAS_LOCAL_NAMES);\n-                if p.space == subst::SelfSpace {\n+                if p.is_self() {\n                     self.add_flags(TypeFlags::HAS_SELF);\n                 } else {\n                     self.add_flags(TypeFlags::HAS_PARAMS);"}, {"sha": "96537904d36e81a9e712274b9d61a4aa5af9a863", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -1225,7 +1225,7 @@ impl<'tcx> TraitRef<'tcx> {\n     }\n \n     pub fn self_ty(&self) -> Ty<'tcx> {\n-        *self.substs.types.get(subst::SelfSpace, 0)\n+        *self.substs.types.get(subst::TypeSpace, 0)\n     }\n \n     pub fn input_types(&self) -> &[Ty<'tcx>] {"}, {"sha": "8786e2d16d22ae53dc1ad416f3fb6f3b05be598f", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -305,7 +305,7 @@ pub struct TraitObject<'tcx> {\n ///\n /// This would be represented by a trait-reference where the def-id is the\n /// def-id for the trait `Foo` and the substs defines `T` as parameter 0 in the\n-/// `SelfSpace` and `U` as parameter 0 in the `TypeSpace`.\n+/// `TypeSpace` and `U` as parameter 1 in the `TypeSpace`.\n ///\n /// Trait references also appear in object types like `Foo<U>`, but in\n /// that case the `Self` parameter is absent from the substitutions.\n@@ -512,7 +512,7 @@ impl<'a, 'gcx, 'tcx> ParamTy {\n     }\n \n     pub fn for_self() -> ParamTy {\n-        ParamTy::new(subst::SelfSpace, 0, keywords::SelfType.name())\n+        ParamTy::new(subst::TypeSpace, 0, keywords::SelfType.name())\n     }\n \n     pub fn for_def(def: &ty::TypeParameterDef) -> ParamTy {\n@@ -524,7 +524,13 @@ impl<'a, 'gcx, 'tcx> ParamTy {\n     }\n \n     pub fn is_self(&self) -> bool {\n-        self.space == subst::SelfSpace && self.idx == 0\n+        if self.name == keywords::SelfType.name() {\n+            assert_eq!(self.space, subst::TypeSpace);\n+            assert_eq!(self.idx, 0);\n+            true\n+        } else {\n+            false\n+        }\n     }\n }\n \n@@ -954,7 +960,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn is_self(&self) -> bool {\n         match self.sty {\n-            TyParam(ref p) => p.space == subst::SelfSpace,\n+            TyParam(ref p) => p.is_self(),\n             _ => false\n         }\n     }"}, {"sha": "2f95baa562589d2980cb8c75540f52237abeaa7b", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 24, "deletions": 54, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -47,27 +47,28 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                   r: Vec<ty::Region>)\n                   -> &'tcx Substs<'tcx>\n     {\n-        Substs::new(tcx, VecPerParamSpace::new(vec![], vec![], t),\n-                    VecPerParamSpace::new(vec![], vec![], r))\n+        Substs::new(tcx, VecPerParamSpace::new(vec![], t),\n+                    VecPerParamSpace::new(vec![], r))\n     }\n \n     pub fn new_type(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                     t: Vec<Ty<'tcx>>,\n                     r: Vec<ty::Region>)\n                     -> &'tcx Substs<'tcx>\n     {\n-        Substs::new(tcx, VecPerParamSpace::new(vec![], t, vec![]),\n-                    VecPerParamSpace::new(vec![], r, vec![]))\n+        Substs::new(tcx, VecPerParamSpace::new(t, vec![]),\n+                    VecPerParamSpace::new(r, vec![]))\n     }\n \n     pub fn new_trait(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                     t: Vec<Ty<'tcx>>,\n+                     mut t: Vec<Ty<'tcx>>,\n                      r: Vec<ty::Region>,\n                      s: Ty<'tcx>)\n                     -> &'tcx Substs<'tcx>\n     {\n-        Substs::new(tcx, VecPerParamSpace::new(vec![s], t, vec![]),\n-                    VecPerParamSpace::new(vec![], r, vec![]))\n+        t.insert(0, s);\n+        Substs::new(tcx, VecPerParamSpace::new(t, vec![]),\n+                    VecPerParamSpace::new(r, vec![]))\n     }\n \n     pub fn empty(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> &'tcx Substs<'tcx> {\n@@ -90,12 +91,10 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n         let defs = tcx.lookup_generics(def_id);\n         let mut substs = Substs {\n             types: VecPerParamSpace {\n-                self_limit: 0,\n                 type_limit: 0,\n                 content: Vec::with_capacity(defs.types.content.len())\n             },\n             regions: VecPerParamSpace {\n-                self_limit: 0,\n                 type_limit: 0,\n                 content: Vec::with_capacity(defs.regions.content.len())\n             }\n@@ -104,7 +103,6 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n         for &space in &ParamSpace::all() {\n             for def in defs.regions.get_slice(space) {\n                 assert_eq!(def.space, space);\n-                assert!(space != SelfSpace);\n \n                 let region = mk_region(def, &substs);\n                 substs.regions.content.push(region);\n@@ -120,11 +118,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                 let ty = mk_type(def, &substs);\n                 substs.types.content.push(ty);\n \n-                if space == SelfSpace {\n-                    substs.types.self_limit += 1;\n-                }\n-\n-                if space <= TypeSpace {\n+                if space == TypeSpace {\n                     substs.types.type_limit += 1;\n                 }\n             }\n@@ -155,7 +149,6 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                        target_substs: &Substs<'tcx>)\n                        -> &'tcx Substs<'tcx> {\n         let defs = tcx.lookup_generics(source_ancestor);\n-        assert_eq!(self.types.len(SelfSpace), defs.types.len(SelfSpace));\n         assert_eq!(self.types.len(TypeSpace), defs.types.len(TypeSpace));\n         assert_eq!(target_substs.types.len(FnSpace), 0);\n         assert_eq!(defs.types.len(FnSpace), 0);\n@@ -195,29 +188,26 @@ impl<'tcx> Decodable for &'tcx Substs<'tcx> {\n #[derive(PartialOrd, Ord, PartialEq, Eq, Copy,\n            Clone, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub enum ParamSpace {\n-    SelfSpace,  // Self parameter on a trait\n     TypeSpace,  // Type parameters attached to a type definition, trait, or impl\n     FnSpace,    // Type parameters attached to a method or fn\n }\n \n impl ParamSpace {\n-    pub fn all() -> [ParamSpace; 3] {\n-        [SelfSpace, TypeSpace, FnSpace]\n+    pub fn all() -> [ParamSpace; 2] {\n+        [TypeSpace, FnSpace]\n     }\n \n     pub fn to_uint(self) -> usize {\n         match self {\n-            SelfSpace => 0,\n-            TypeSpace => 1,\n-            FnSpace => 2,\n+            TypeSpace => 0,\n+            FnSpace => 1,\n         }\n     }\n \n     pub fn from_uint(u: usize) -> ParamSpace {\n         match u {\n-            0 => SelfSpace,\n-            1 => TypeSpace,\n-            2 => FnSpace,\n+            0 => TypeSpace,\n+            1 => FnSpace,\n             _ => bug!(\"Invalid ParamSpace: {}\", u)\n         }\n     }\n@@ -235,18 +225,15 @@ pub struct VecPerParamSpace<T> {\n     // Here is how the representation corresponds to the abstraction\n     // i.e. the \"abstraction function\" AF:\n     //\n-    // AF(self) = (self.content[..self.self_limit],\n-    //             self.content[self.self_limit..self.type_limit],\n+    // AF(self) = (self.content[..self.type_limit],\n     //             self.content[self.type_limit..])\n-    self_limit: usize,\n     type_limit: usize,\n     content: Vec<T>,\n }\n \n impl<T: fmt::Debug> fmt::Debug for VecPerParamSpace<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"[{:?};{:?};{:?}]\",\n-               self.get_slice(SelfSpace),\n+        write!(f, \"[{:?};{:?}]\",\n                self.get_slice(TypeSpace),\n                self.get_slice(FnSpace))\n     }\n@@ -255,43 +242,34 @@ impl<T: fmt::Debug> fmt::Debug for VecPerParamSpace<T> {\n impl<T> VecPerParamSpace<T> {\n     fn limits(&self, space: ParamSpace) -> (usize, usize) {\n         match space {\n-            SelfSpace => (0, self.self_limit),\n-            TypeSpace => (self.self_limit, self.type_limit),\n+            TypeSpace => (0, self.type_limit),\n             FnSpace => (self.type_limit, self.content.len()),\n         }\n     }\n \n     pub fn empty() -> VecPerParamSpace<T> {\n         VecPerParamSpace {\n-            self_limit: 0,\n             type_limit: 0,\n             content: Vec::new()\n         }\n     }\n \n-    /// `s` is the self space.\n     /// `t` is the type space.\n     /// `f` is the fn space.\n-    pub fn new(s: Vec<T>, t: Vec<T>, f: Vec<T>) -> VecPerParamSpace<T> {\n-        let self_limit = s.len();\n-        let type_limit = self_limit + t.len();\n+    pub fn new(t: Vec<T>, f: Vec<T>) -> VecPerParamSpace<T> {\n+        let type_limit = t.len();\n \n-        let mut content = s;\n-        content.extend(t);\n+        let mut content = t;\n         content.extend(f);\n \n         VecPerParamSpace {\n-            self_limit: self_limit,\n             type_limit: type_limit,\n             content: content,\n         }\n     }\n \n-    fn new_internal(content: Vec<T>, self_limit: usize, type_limit: usize)\n-                    -> VecPerParamSpace<T>\n-    {\n+    fn new_internal(content: Vec<T>, type_limit: usize) -> VecPerParamSpace<T> {\n         VecPerParamSpace {\n-            self_limit: self_limit,\n             type_limit: type_limit,\n             content: content,\n         }\n@@ -336,18 +314,14 @@ impl<T> VecPerParamSpace<T> {\n \n     pub fn map<U, P>(&self, pred: P) -> VecPerParamSpace<U> where P: FnMut(&T) -> U {\n         let result = self.as_full_slice().iter().map(pred).collect();\n-        VecPerParamSpace::new_internal(result,\n-                                       self.self_limit,\n-                                       self.type_limit)\n+        VecPerParamSpace::new_internal(result, self.type_limit)\n     }\n \n     pub fn map_enumerated<U, P>(&self, pred: P) -> VecPerParamSpace<U> where\n         P: FnMut((ParamSpace, usize, &T)) -> U,\n     {\n         let result = self.iter_enumerated().map(pred).collect();\n-        VecPerParamSpace::new_internal(result,\n-                                       self.self_limit,\n-                                       self.type_limit)\n+        VecPerParamSpace::new_internal(result, self.type_limit)\n     }\n }\n \n@@ -639,8 +613,6 @@ impl<'a, 'gcx, 'tcx> ty::ExistentialTraitRef<'tcx> {\n                          -> ty::ExistentialTraitRef<'tcx> {\n         let Substs { mut types, regions } = trait_ref.substs.clone();\n \n-        assert_eq!(types.self_limit, 1);\n-        types.self_limit = 0;\n         types.type_limit -= 1;\n         types.content.remove(0);\n \n@@ -665,8 +637,6 @@ impl<'a, 'gcx, 'tcx> ty::PolyExistentialTraitRef<'tcx> {\n         self.map_bound(|trait_ref| {\n             let Substs { mut types, regions } = trait_ref.substs.clone();\n \n-            assert_eq!(types.self_limit, 0);\n-            types.self_limit = 1;\n             types.type_limit += 1;\n             types.content.insert(0, self_ty);\n "}, {"sha": "800ad865208aa604937594452bb9022a9886d361", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 28, "deletions": 39, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -62,35 +62,36 @@ pub enum Ns {\n     Value\n }\n \n-fn number_of_supplied_defaults<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                               substs: &subst::Substs,\n-                                               space: subst::ParamSpace,\n-                                               generics: &ty::Generics<'tcx>)\n-                                               -> usize\n-{\n-    let ty_params = generics.types.get_slice(space);\n-    let tps = substs.types.get_slice(space);\n-    if ty_params.last().map_or(false, |def| def.default.is_some()) {\n-        let substs = tcx.lift(&substs);\n-        ty_params.iter().zip(tps).rev().take_while(|&(def, &actual)| {\n-            substs.and_then(|substs| def.default.subst(tcx, substs))\n-                == Some(actual)\n-        }).count()\n-    } else {\n-        0\n-    }\n-}\n-\n pub fn parameterized(f: &mut fmt::Formatter,\n                      substs: &subst::Substs,\n                      did: DefId,\n                      ns: Ns,\n                      projections: &[ty::ProjectionPredicate])\n                      -> fmt::Result {\n-    let (fn_trait_kind, verbose, item_name, is_in_trait) = ty::tls::with(|tcx| {\n-        let is_in_trait = ns == Ns::Value && tcx.trait_of_item(did).is_some();\n-        if is_in_trait {\n-            write!(f, \"<{} as \", substs.types.get(subst::SelfSpace, 0))?;\n+    let mut verbose = false;\n+    let mut num_supplied_defaults = 0;\n+    let mut has_self = false;\n+    let (fn_trait_kind, item_name) = ty::tls::with(|tcx| {\n+        verbose = tcx.sess.verbose();\n+        let generics = tcx.lookup_generics(did);\n+        if !verbose {\n+            let ty_params = generics.types.get_slice(subst::TypeSpace);\n+            if ty_params.last().map_or(false, |def| def.default.is_some()) {\n+                if let Some(substs) = tcx.lift(&substs) {\n+                    let tps = substs.types.get_slice(subst::TypeSpace);\n+                    for (def, actual) in ty_params.iter().zip(tps).rev() {\n+                        if def.default.subst(tcx, substs) != Some(actual) {\n+                            break;\n+                        }\n+                        num_supplied_defaults += 1;\n+                    }\n+                }\n+            }\n+        }\n+\n+        has_self = generics.has_self;\n+        if ns == Ns::Value && has_self {\n+            write!(f, \"<{} as \", substs.types.get(subst::TypeSpace, 0))?;\n         }\n \n         let (did, item_name) = if ns == Ns::Value {\n@@ -107,15 +108,12 @@ pub fn parameterized(f: &mut fmt::Formatter,\n             (did, None)\n         };\n         write!(f, \"{}\", tcx.item_path_str(did))?;\n-        Ok((tcx.lang_items.fn_trait_kind(did),\n-            tcx.sess.verbose(),\n-            item_name,\n-            is_in_trait))\n+        Ok((tcx.lang_items.fn_trait_kind(did), item_name))\n     })?;\n \n     if !verbose && fn_trait_kind.is_some() && projections.len() == 1 {\n         let projection_ty = projections[0].ty;\n-        if let TyTuple(ref args) = substs.types.get(subst::TypeSpace, 0).sty {\n+        if let TyTuple(ref args) = substs.types.get(subst::TypeSpace, 1).sty {\n             return fn_sig(f, args, false, projection_ty);\n         }\n     }\n@@ -160,18 +158,9 @@ pub fn parameterized(f: &mut fmt::Formatter,\n \n     print_regions(f, \"<\", substs.regions.get_slice(subst::TypeSpace))?;\n \n-    let num_supplied_defaults = if verbose {\n-        0\n-    } else {\n-        ty::tls::with(|tcx| {\n-            let generics = tcx.lookup_generics(did);\n-            number_of_supplied_defaults(tcx, substs, subst::TypeSpace, generics)\n-        })\n-    };\n-\n     let tps = substs.types.get_slice(subst::TypeSpace);\n \n-    for &ty in &tps[..tps.len() - num_supplied_defaults] {\n+    for &ty in &tps[has_self as usize..tps.len() - num_supplied_defaults] {\n         start_or_continue(f, \"<\", \", \")?;\n         write!(f, \"{}\", ty)?;\n     }\n@@ -189,7 +178,7 @@ pub fn parameterized(f: &mut fmt::Formatter,\n     if ns == Ns::Value {\n         empty.set(true);\n \n-        if is_in_trait {\n+        if has_self {\n             write!(f, \">\")?;\n         }\n "}, {"sha": "9f300b5b29ba851f03752d324bf91a86e387bf38", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -16,7 +16,7 @@ use super::{drop_flag_effects_for_location, on_all_children_bits};\n use super::{DropFlagState, MoveDataParamEnv};\n use super::patch::MirPatch;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::subst::{Subst, Substs, VecPerParamSpace};\n+use rustc::ty::subst::{Subst, Substs};\n use rustc::mir::repr::*;\n use rustc::mir::transform::{Pass, MirPass, MirSource};\n use rustc::middle::const_val::ConstVal;\n@@ -859,9 +859,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         let unit_temp = Lvalue::Temp(self.patch.new_temp(tcx.mk_nil()));\n         let free_func = tcx.lang_items.require(lang_items::BoxFreeFnLangItem)\n             .unwrap_or_else(|e| tcx.sess.fatal(&e));\n-        let substs = Substs::new(tcx,\n-            VecPerParamSpace::new(vec![], vec![], vec![ty]),\n-            VecPerParamSpace::new(vec![], vec![], vec![]));\n+        let substs = Substs::new_fn(tcx, vec![ty], vec![]);\n         let fty = tcx.lookup_item_type(free_func).ty.subst(tcx, substs);\n \n         self.patch.new_block(BasicBlockData {"}, {"sha": "1ef48e6d6565fcc1c43f0570f5d3ba75bc1cefe4", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -413,7 +413,7 @@ impl tr for Def {\n           Def::AssociatedTy(trait_did, did) =>\n               Def::AssociatedTy(trait_did.tr(dcx), did.tr(dcx)),\n           Def::PrimTy(p) => Def::PrimTy(p),\n-          Def::TyParam(s, index, def_id, n) => Def::TyParam(s, index, def_id.tr(dcx), n),\n+          Def::TyParam(did) => Def::TyParam(did.tr(dcx)),\n           Def::Upvar(_, nid1, index, nid2) => {\n               let nid1 = dcx.tr_id(nid1);\n               let nid2 = dcx.tr_id(nid2);"}, {"sha": "82d050a1de9d7177ba2ade316227bc982b27b596", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -131,15 +131,15 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n     fn parse_vec_per_param_space<T, F>(&mut self, mut f: F) -> VecPerParamSpace<T> where\n         F: FnMut(&mut TyDecoder<'a, 'tcx>) -> T,\n     {\n-        let (mut a, mut b, mut c) =  (vec![], vec![], vec![]);\n-        for r in &mut [&mut a, &mut b, &mut c] {\n+        let (mut a, mut b) =  (vec![], vec![]);\n+        for r in &mut [&mut a, &mut b] {\n             assert_eq!(self.next(), '[');\n             while self.peek() != ']' {\n                 r.push(f(self));\n             }\n             assert_eq!(self.next(), ']');\n         }\n-        VecPerParamSpace::new(a, b, c)\n+        VecPerParamSpace::new(a, b)\n     }\n \n     pub fn parse_substs(&mut self) -> &'tcx Substs<'tcx> {"}, {"sha": "65e14eee4bc2bc0fc0ec5e039c0cd920096355db", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 8, "deletions": 24, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -49,7 +49,6 @@ use rustc::lint;\n use rustc::hir::def::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::ty;\n-use rustc::ty::subst::{ParamSpace, FnSpace, TypeSpace};\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FnvHashMap, FnvHashSet};\n \n@@ -557,7 +556,7 @@ impl<'a> Visitor for Resolver<'a> {\n     fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n         let type_parameters = match foreign_item.node {\n             ForeignItemKind::Fn(_, ref generics) => {\n-                HasTypeParameters(generics, FnSpace, ItemRibKind)\n+                HasTypeParameters(generics, ItemRibKind)\n             }\n             ForeignItemKind::Static(..) => NoTypeParameters,\n         };\n@@ -625,10 +624,6 @@ enum TypeParameters<'a, 'b> {\n     HasTypeParameters(// Type parameters.\n                       &'b Generics,\n \n-                      // Identifies the things that these parameters\n-                      // were declared on (type, fn, etc)\n-                      ParamSpace,\n-\n                       // The kind of the rib used for type parameters.\n                       RibKind<'a>),\n }\n@@ -1613,12 +1608,9 @@ impl<'a> Resolver<'a> {\n         match item.node {\n             ItemKind::Enum(_, ref generics) |\n             ItemKind::Ty(_, ref generics) |\n-            ItemKind::Struct(_, ref generics) => {\n-                self.with_type_parameter_rib(HasTypeParameters(generics, TypeSpace, ItemRibKind),\n-                                             |this| visit::walk_item(this, item));\n-            }\n+            ItemKind::Struct(_, ref generics) |\n             ItemKind::Fn(_, _, _, _, ref generics, _) => {\n-                self.with_type_parameter_rib(HasTypeParameters(generics, FnSpace, ItemRibKind),\n+                self.with_type_parameter_rib(HasTypeParameters(generics, ItemRibKind),\n                                              |this| visit::walk_item(this, item));\n             }\n \n@@ -1634,10 +1626,7 @@ impl<'a> Resolver<'a> {\n \n             ItemKind::Trait(_, ref generics, ref bounds, ref trait_items) => {\n                 // Create a new rib for the trait-wide type parameters.\n-                self.with_type_parameter_rib(HasTypeParameters(generics,\n-                                                               TypeSpace,\n-                                                               ItemRibKind),\n-                                             |this| {\n+                self.with_type_parameter_rib(HasTypeParameters(generics, ItemRibKind), |this| {\n                     let local_def_id = this.definitions.local_def_id(item.id);\n                     this.with_self_rib(Def::SelfTy(Some(local_def_id), None), |this| {\n                         this.visit_generics(generics);\n@@ -1660,7 +1649,6 @@ impl<'a> Resolver<'a> {\n                                 TraitItemKind::Method(ref sig, _) => {\n                                     let type_parameters =\n                                         HasTypeParameters(&sig.generics,\n-                                                          FnSpace,\n                                                           MethodRibKind(!sig.decl.has_self()));\n                                     this.with_type_parameter_rib(type_parameters, |this| {\n                                         visit::walk_trait_item(this, trait_item)\n@@ -1729,10 +1717,10 @@ impl<'a> Resolver<'a> {\n         where F: FnOnce(&mut Resolver)\n     {\n         match type_parameters {\n-            HasTypeParameters(generics, space, rib_kind) => {\n+            HasTypeParameters(generics, rib_kind) => {\n                 let mut function_type_rib = Rib::new(rib_kind);\n                 let mut seen_bindings = HashSet::new();\n-                for (index, type_parameter) in generics.ty_params.iter().enumerate() {\n+                for type_parameter in &generics.ty_params {\n                     let name = type_parameter.ident.name;\n                     debug!(\"with_type_parameter_rib: {}\", type_parameter.id);\n \n@@ -1745,7 +1733,7 @@ impl<'a> Resolver<'a> {\n \n                     // plain insert (no renaming)\n                     let def_id = self.definitions.local_def_id(type_parameter.id);\n-                    let def = Def::TyParam(space, index as u32, def_id, name);\n+                    let def = Def::TyParam(def_id);\n                     function_type_rib.bindings.insert(ast::Ident::with_empty_ctxt(name), def);\n                     self.record_def(type_parameter.id, PathResolution::new(def));\n                 }\n@@ -1917,10 +1905,7 @@ impl<'a> Resolver<'a> {\n                               item_id: NodeId,\n                               impl_items: &[ImplItem]) {\n         // If applicable, create a rib for the type parameters.\n-        self.with_type_parameter_rib(HasTypeParameters(generics,\n-                                                       TypeSpace,\n-                                                       ItemRibKind),\n-                                     |this| {\n+        self.with_type_parameter_rib(HasTypeParameters(generics, ItemRibKind), |this| {\n             // Resolve the type parameters.\n             this.visit_generics(generics);\n \n@@ -1953,7 +1938,6 @@ impl<'a> Resolver<'a> {\n                                     // specific type parameters.\n                                     let type_parameters =\n                                         HasTypeParameters(&sig.generics,\n-                                                          FnSpace,\n                                                           MethodRibKind(!sig.decl.has_self()));\n                                     this.with_type_parameter_rib(type_parameters, |this| {\n                                         visit::walk_impl_item(this, impl_item);"}, {"sha": "db535e22f194d1a9bd5e23401d2f8918cacbc3e9", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -490,7 +490,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             Def::Enum(def_id) |\n             Def::TyAlias(def_id) |\n             Def::Trait(def_id) |\n-            Def::TyParam(_, _, def_id, _) => {\n+            Def::TyParam(def_id) => {\n                 Some(Data::TypeRefData(TypeRefData {\n                     span: sub_span.unwrap(),\n                     ref_id: Some(def_id),"}, {"sha": "1e90f273301ff602b5699705620c34a2b400c703", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -488,7 +488,7 @@ fn characteristic_def_id_of_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // DefId, we use the location of the impl after all.\n \n             if tcx.trait_of_item(instance.def).is_some() {\n-                let self_ty = *instance.substs.types.get(subst::SelfSpace, 0);\n+                let self_ty = *instance.substs.types.get(subst::TypeSpace, 0);\n                 // This is an implementation of a trait method.\n                 return characteristic_def_id_of_type(self_ty).or(Some(instance.def));\n             }"}, {"sha": "109cfd2abf6e53aefcf55b7653afeea08f36966d", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 38, "deletions": 14, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -55,7 +55,7 @@ use hir::def_id::DefId;\n use hir::print as pprust;\n use middle::resolve_lifetime as rl;\n use rustc::lint;\n-use rustc::ty::subst::{TypeSpace, SelfSpace, Subst, Substs};\n+use rustc::ty::subst::{TypeSpace, Subst, Substs};\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n use rustc::ty::wf::object_region_bounds;\n@@ -455,6 +455,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // Check the number of type parameters supplied by the user.\n         if let Some(num_provided) = num_types_provided {\n             let ty_param_defs = decl_generics.types.get_slice(TypeSpace);\n+            let ty_param_defs = &ty_param_defs[self_ty.is_some() as usize..];\n             check_type_argument_count(tcx, span, num_provided, ty_param_defs);\n         }\n \n@@ -476,13 +477,16 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             assert_eq!(def.space, TypeSpace);\n             regions[def.index as usize]\n         }, |def, substs| {\n-            assert!(def.space == SelfSpace || def.space == TypeSpace);\n+            assert!(def.space == TypeSpace);\n             let i = def.index as usize;\n-            if def.space == SelfSpace {\n-                // Self, which must have been provided.\n-                assert_eq!(i, 0);\n-                self_ty.expect(\"Self type parameter missing\")\n-            } else if num_types_provided.map_or(false, |n| i < n) {\n+\n+            // Handle Self first, so we can adjust the index to match the AST.\n+            if let (0, Some(ty)) = (i, self_ty) {\n+                return ty;\n+            }\n+\n+            let i = i - self_ty.is_some() as usize;\n+            if num_types_provided.map_or(false, |n| i < n) {\n                 // A provided type parameter.\n                 match *parameters {\n                     hir::AngleBracketedParameters(ref data) => {\n@@ -1325,8 +1329,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     Err(ErrorReported) => return (tcx.types.err, Def::Err),\n                 }\n             }\n-            (&ty::TyParam(_), Def::TyParam(_, _, param_did, param_name)) => {\n+            (&ty::TyParam(_), Def::TyParam(param_did)) => {\n                 let param_node_id = tcx.map.as_local_node_id(param_did).unwrap();\n+                let param_name = tcx.type_parameter_def(param_node_id).name;\n                 match self.find_bound_for_assoc_item(param_node_id,\n                                                      param_name,\n                                                      assoc_name,\n@@ -1336,10 +1341,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 }\n             }\n             _ => {\n-                self.report_ambiguous_associated_type(span,\n-                                                      &ty.to_string(),\n-                                                      \"Trait\",\n-                                                      &assoc_name.as_str());\n+                // Don't print TyErr to the user.\n+                if !ty.references_error() {\n+                    self.report_ambiguous_associated_type(span,\n+                                                          &ty.to_string(),\n+                                                          \"Trait\",\n+                                                          &assoc_name.as_str());\n+                }\n                 return (tcx.types.err, Def::Err);\n             }\n         };\n@@ -1477,9 +1485,25 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                     did,\n                                     base_segments.last().unwrap())\n             }\n-            Def::TyParam(space, index, _, name) => {\n+            Def::TyParam(did) => {\n                 tcx.prohibit_type_params(base_segments);\n-                tcx.mk_param(space, index, name)\n+\n+                let node_id = tcx.map.as_local_node_id(did).unwrap();\n+                let param = tcx.ty_param_defs.borrow().get(&node_id)\n+                               .map(ty::ParamTy::for_def);\n+                if let Some(p) = param {\n+                    p.to_ty(tcx)\n+                } else {\n+                    // Only while computing defaults of earlier type\n+                    // parameters can a type parameter be missing its def.\n+                    struct_span_err!(tcx.sess, span, E0128,\n+                                     \"type parameters with a default cannot use \\\n+                                      forward declared identifiers\")\n+                        .span_label(span, &format!(\"defaulted type parameters \\\n+                                                    cannot be forward declared\"))\n+                        .emit();\n+                    tcx.types.err\n+                }\n             }\n             Def::SelfTy(_, Some(impl_id)) => {\n                 // Self in impl (we know the concrete type)."}, {"sha": "087549a2f1c4c1f4a08c42daeacc6028d599820a", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -204,7 +204,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return None;\n         }\n \n-        let arg_param_ty = *trait_ref.substs().types.get(subst::TypeSpace, 0);\n+        let arg_param_ty = *trait_ref.substs().types.get(subst::TypeSpace, 1);\n         let arg_param_ty = self.resolve_type_vars_if_possible(&arg_param_ty);\n         debug!(\"deduce_sig_from_projection: arg_param_ty {:?}\", arg_param_ty);\n "}, {"sha": "a9e08461fd28ec4a590f0062fd9703aa1c612d0e", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -183,7 +183,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let trait_def = self.tcx.lookup_trait_def(trait_def_id);\n \n         if let Some(ref input_types) = opt_input_types {\n-            assert_eq!(trait_def.generics.types.len(subst::TypeSpace), input_types.len());\n+            assert_eq!(trait_def.generics.types.len(subst::TypeSpace) - 1, input_types.len());\n         }\n         assert_eq!(trait_def.generics.types.len(subst::FnSpace), 0);\n         assert!(trait_def.generics.regions.is_empty());\n@@ -192,10 +192,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let substs = Substs::for_item(self.tcx, trait_def_id, |def, _| {\n             self.region_var_for_def(span, def)\n         }, |def, substs| {\n-            if def.space == subst::SelfSpace {\n+            if def.index == 0 {\n                 self_ty\n             } else if let Some(ref input_types) = opt_input_types {\n-                input_types[def.index as usize]\n+                input_types[def.index as usize - 1]\n             } else {\n                 self.type_var_for_def(span, def, substs)\n             }"}, {"sha": "044de179917b4f1a23dfa4c77ab390bd105a3929", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -522,10 +522,6 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                            trait_ref.substs.types.len(subst::TypeSpace));\n                 assert_eq!(m.generics.regions.len(subst::TypeSpace),\n                            trait_ref.substs.regions.len(subst::TypeSpace));\n-                assert_eq!(m.generics.types.len(subst::SelfSpace),\n-                           trait_ref.substs.types.len(subst::SelfSpace));\n-                assert_eq!(m.generics.regions.len(subst::SelfSpace),\n-                           trait_ref.substs.regions.len(subst::SelfSpace));\n             }\n \n             // Because this trait derives from a where-clause, it\n@@ -755,11 +751,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             let substs = Substs::for_item(self.tcx, trait_def_id, |def, _| {\n                 self.region_var_for_def(self.span, def)\n             }, |def, substs| {\n-                if def.space == subst::SelfSpace {\n-                    assert_eq!(def.index, 0);\n+                if def.index == 0 {\n                     step.self_ty\n                 } else {\n-                    assert_eq!(def.space, subst::TypeSpace);\n                     self.type_var_for_def(self.span, def, substs)\n                 }\n             });"}, {"sha": "ae3378f41f93655d0672d3ba084e241f9927c0f4", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -4225,7 +4225,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let substs = Substs::for_item(self.tcx, def.def_id(), |def, _| {\n             let i = def.index as usize;\n             let segment = match def.space {\n-                subst::SelfSpace => None,\n                 subst::TypeSpace => type_segment,\n                 subst::FnSpace => fn_segment\n             };\n@@ -4241,9 +4240,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.region_var_for_def(span, def)\n             }\n         }, |def, substs| {\n-            let i = def.index as usize;\n+            let mut i = def.index as usize;\n             let segment = match def.space {\n-                subst::SelfSpace => None,\n                 subst::TypeSpace => type_segment,\n                 subst::FnSpace => fn_segment\n             };\n@@ -4252,18 +4250,24 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 Some(&hir::ParenthesizedParameters(_)) => bug!(),\n                 None => &[]\n             };\n+\n+            // Handle Self first, so we can adjust the index to match the AST.\n+            if scheme.generics.has_self && def.space == subst::TypeSpace {\n+                if i == 0 {\n+                    return opt_self_ty.unwrap_or_else(|| {\n+                        self.type_var_for_def(span, def, substs)\n+                    });\n+                }\n+                i -= 1;\n+            }\n+\n             let can_omit = def.space != subst::TypeSpace || !require_type_space;\n             let default = if can_omit && types.len() == 0 {\n                 def.default\n             } else {\n                 None\n             };\n-\n-            if def.space == subst::SelfSpace && opt_self_ty.is_some() {\n-                // Self, which has been provided.\n-                assert_eq!(i, 0);\n-                opt_self_ty.unwrap()\n-            } else if let Some(ast_ty) = types.get(i) {\n+            if let Some(ast_ty) = types.get(i) {\n                 // A provided type parameter.\n                 self.to_ty(ast_ty)\n             } else if let Some(default) = default {\n@@ -4371,6 +4375,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Check provided type parameters.\n         let type_defs = generics.types.get_slice(space);\n+        let type_defs = if space == subst::TypeSpace {\n+            &type_defs[generics.has_self as usize..]\n+        } else {\n+            type_defs\n+        };\n         let required_len = type_defs.iter()\n                                     .take_while(|d| d.default.is_none())\n                                     .count();"}, {"sha": "f2076895f0873a8bde1ec3a02b76999e45ad389b", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 13, "deletions": 32, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -14,13 +14,12 @@ use CrateCtxt;\n use hir::def_id::DefId;\n use middle::region::{CodeExtent};\n use rustc::infer::TypeOrigin;\n-use rustc::ty::subst::{self, TypeSpace, FnSpace, ParamSpace, SelfSpace};\n+use rustc::ty::subst;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n \n use std::collections::HashSet;\n use syntax::ast;\n-use syntax::parse::token::keywords;\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n \n@@ -461,7 +460,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n             variances.types\n                      .iter_enumerated()\n                      .filter(|&(_, _, &variance)| variance != ty::Bivariant)\n-                     .map(|(space, index, _)| self.param_ty(ast_generics, space, index))\n+                     .map(|(_, index, _)| self.param_ty(ast_generics, index))\n                      .map(|p| Parameter::Type(p))\n                      .collect();\n \n@@ -470,52 +469,34 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                                          &mut constrained_parameters);\n \n         for (space, index, _) in variances.types.iter_enumerated() {\n-            let param_ty = self.param_ty(ast_generics, space, index);\n+            assert_eq!(space, subst::TypeSpace);\n+\n+            let param_ty = self.param_ty(ast_generics, index);\n             if constrained_parameters.contains(&Parameter::Type(param_ty)) {\n                 continue;\n             }\n-            let span = self.ty_param_span(ast_generics, item, space, index);\n+            let span = ast_generics.ty_params[index].span;\n             self.report_bivariance(span, param_ty.name);\n         }\n \n         for (space, index, &variance) in variances.regions.iter_enumerated() {\n+            assert_eq!(space, subst::TypeSpace);\n+\n             if variance != ty::Bivariant {\n                 continue;\n             }\n \n-            assert_eq!(space, TypeSpace);\n             let span = ast_generics.lifetimes[index].lifetime.span;\n             let name = ast_generics.lifetimes[index].lifetime.name;\n             self.report_bivariance(span, name);\n         }\n     }\n \n-    fn param_ty(&self,\n-                ast_generics: &hir::Generics,\n-                space: ParamSpace,\n-                index: usize)\n-                -> ty::ParamTy\n-    {\n-        let name = match space {\n-            TypeSpace => ast_generics.ty_params[index].name,\n-            SelfSpace => keywords::SelfType.name(),\n-            FnSpace => bug!(\"Fn space occupied?\"),\n-        };\n-\n-        ty::ParamTy { space: space, idx: index as u32, name: name }\n-    }\n-\n-    fn ty_param_span(&self,\n-                     ast_generics: &hir::Generics,\n-                     item: &hir::Item,\n-                     space: ParamSpace,\n-                     index: usize)\n-                     -> Span\n-    {\n-        match space {\n-            TypeSpace => ast_generics.ty_params[index].span,\n-            SelfSpace => item.span,\n-            FnSpace => span_bug!(item.span, \"Fn space occupied?\"),\n+    fn param_ty(&self, ast_generics: &hir::Generics, index: usize) -> ty::ParamTy {\n+        ty::ParamTy {\n+            space: subst::TypeSpace,\n+            idx: index as u32,\n+            name: ast_generics.ty_params[index].name\n         }\n     }\n "}, {"sha": "17a84e98e61e25e0f5e84e705f07542b7749849e", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -386,7 +386,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n \n             let source = tcx.lookup_item_type(impl_did).ty;\n             let trait_ref = self.crate_context.tcx.impl_trait_ref(impl_did).unwrap();\n-            let target = *trait_ref.substs.types.get(subst::TypeSpace, 0);\n+            let target = *trait_ref.substs.types.get(subst::TypeSpace, 1);\n             debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (bound)\",\n                    source, target);\n "}, {"sha": "8eef384f2cf9f1fc789fc7f96d98d974e223cb74", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 28, "deletions": 55, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -65,7 +65,7 @@ use middle::lang_items::SizedTraitLangItem;\n use middle::const_val::ConstVal;\n use rustc_const_eval::EvalHint::UncheckedExprHint;\n use rustc_const_eval::{eval_const_expr_partial, report_const_eval_err};\n-use rustc::ty::subst::{Substs, FnSpace, ParamSpace, SelfSpace, TypeSpace, VecPerParamSpace};\n+use rustc::ty::subst::{Substs, FnSpace, ParamSpace, TypeSpace, VecPerParamSpace};\n use rustc::ty::{ToPredicate, ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeScheme};\n use rustc::ty::{VariantKind};\n@@ -85,7 +85,6 @@ use std::rc::Rc;\n \n use syntax::{abi, ast, attr};\n use syntax::parse::token::keywords;\n-use syntax::ptr::P;\n use syntax_pos::Span;\n \n use rustc::hir::{self, intravisit, map as hir_map, print as pprust};\n@@ -546,7 +545,7 @@ fn is_param<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let path_res = tcx.expect_resolution(ast_ty.id);\n         match path_res.base_def {\n             Def::SelfTy(Some(def_id), None) |\n-            Def::TyParam(_, _, def_id, _) if path_res.depth == 0 => {\n+            Def::TyParam(def_id) if path_res.depth == 0 => {\n                 def_id == tcx.map.local_def_id(param_id)\n             }\n             _ => false\n@@ -1333,7 +1332,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n \n     // add in the explicit where-clauses\n     let mut trait_predicates =\n-        ty_generic_predicates(ccx, TypeSpace, generics, &base_predicates);\n+        ty_generic_predicates(ccx, TypeSpace, generics, &base_predicates, true);\n \n     let assoc_predicates = predicates_for_associated_types(ccx,\n                                                            generics,\n@@ -1430,7 +1429,7 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         let parent = ccx.tcx.map.get_parent(param_id);\n \n                         let def = ty::TypeParameterDef {\n-                            space: SelfSpace,\n+                            space: TypeSpace,\n                             index: 0,\n                             name: keywords::SelfType.name(),\n                             def_id: tcx.map.local_def_id(param_id),\n@@ -1477,27 +1476,25 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }).collect();\n \n         // Now create the real type parameters.\n-        let types = ast_generics.ty_params.iter().enumerate().map(|(i, _)| {\n-            get_or_create_type_parameter_def(ccx, ast_generics, space, i as u32, allow_defaults)\n+        let types = ast_generics.ty_params.iter().enumerate().map(|(i, p)| {\n+            let i = opt_self.is_some() as u32 + i as u32;\n+            get_or_create_type_parameter_def(ccx, ast_generics, space, i, p, allow_defaults)\n         }).collect();\n \n         let has_self = base_generics.has_self || opt_self.is_some();\n         let (regions, types) = match space {\n-            SelfSpace => bug!(),\n             TypeSpace => {\n                 assert_eq!(base_generics.regions.as_full_slice().len(), 0);\n                 assert_eq!(base_generics.types.as_full_slice().len(), 0);\n-                (VecPerParamSpace::new(vec![], regions, vec![]),\n-                 VecPerParamSpace::new(opt_self.into_iter().collect(), types, vec![]))\n+                (VecPerParamSpace::new(regions, vec![]),\n+                 VecPerParamSpace::new(opt_self.into_iter().chain(types).collect(), vec![]))\n             }\n             FnSpace => {\n                 assert_eq!(base_generics.regions.len(FnSpace), 0);\n                 assert_eq!(base_generics.types.len(FnSpace), 0);\n-                (VecPerParamSpace::new(base_generics.regions.get_slice(SelfSpace).to_vec(),\n-                                       base_generics.regions.get_slice(TypeSpace).to_vec(),\n+                (VecPerParamSpace::new(base_generics.regions.get_slice(TypeSpace).to_vec(),\n                                        regions),\n-                 VecPerParamSpace::new(base_generics.types.get_slice(SelfSpace).to_vec(),\n-                                       base_generics.types.get_slice(TypeSpace).to_vec(),\n+                 VecPerParamSpace::new(base_generics.types.get_slice(TypeSpace).to_vec(),\n                                        types))\n             }\n         };\n@@ -1674,15 +1671,15 @@ fn ty_generic_predicates_for_type_or_impl<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                                    generics: &hir::Generics)\n                                                    -> ty::GenericPredicates<'tcx>\n {\n-    ty_generic_predicates(ccx, TypeSpace, generics, &ty::GenericPredicates::empty())\n+    ty_generic_predicates(ccx, TypeSpace, generics, &ty::GenericPredicates::empty(), false)\n }\n \n fn ty_generic_predicates_for_fn<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                          generics: &hir::Generics,\n                                          base_predicates: &ty::GenericPredicates<'tcx>)\n                                          -> ty::GenericPredicates<'tcx>\n {\n-    ty_generic_predicates(ccx, FnSpace, generics, base_predicates)\n+    ty_generic_predicates(ccx, FnSpace, generics, base_predicates, false)\n }\n \n // Add the Sized bound, unless the type parameter is marked as `?Sized`.\n@@ -1752,7 +1749,8 @@ fn early_bound_lifetimes_from_generics<'a, 'tcx, 'hir>(\n fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                   space: ParamSpace,\n                                   ast_generics: &hir::Generics,\n-                                  base_predicates: &ty::GenericPredicates<'tcx>)\n+                                  base_predicates: &ty::GenericPredicates<'tcx>,\n+                                  has_self: bool)\n                                   -> ty::GenericPredicates<'tcx>\n {\n     let tcx = ccx.tcx;\n@@ -1761,7 +1759,7 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     // Collect the predicates that were written inline by the user on each\n     // type parameter (e.g., `<T:Foo>`).\n     for (index, param) in ast_generics.ty_params.iter().enumerate() {\n-        let index = index as u32;\n+        let index = has_self as u32 + index as u32;\n         let param_ty = ty::ParamTy::new(space, index, param.name).to_ty(ccx.tcx);\n         let bounds = compute_bounds(&ccx.icx(&(base_predicates, ast_generics)),\n                                     param_ty,\n@@ -1850,50 +1848,22 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     result\n }\n \n-fn convert_default_type_parameter<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                            path: &P<hir::Ty>,\n-                                            space: ParamSpace,\n-                                            index: u32)\n-                                            -> Ty<'tcx>\n-{\n-    let ty = AstConv::ast_ty_to_ty(&ccx.icx(&()), &ExplicitRscope, &path);\n-\n-    for leaf_ty in ty.walk() {\n-        if let ty::TyParam(p) = leaf_ty.sty {\n-            if p.space == space && p.idx >= index {\n-                struct_span_err!(ccx.tcx.sess, path.span, E0128,\n-                                 \"type parameters with a default cannot use \\\n-                                 forward declared identifiers\")\n-                    .span_label(path.span, &format!(\"defaulted type parameters \\\n-                                                    cannot be forward declared\"))\n-                    .emit();\n-\n-                return ccx.tcx.types.err\n-            }\n-        }\n-    }\n-\n-    ty\n-}\n-\n fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                              ast_generics: &hir::Generics,\n                                              space: ParamSpace,\n                                              index: u32,\n+                                             param: &hir::TyParam,\n                                              allow_defaults: bool)\n                                              -> ty::TypeParameterDef<'tcx>\n {\n-    let param = &ast_generics.ty_params[index as usize];\n-\n     let tcx = ccx.tcx;\n     match tcx.ty_param_defs.borrow().get(&param.id) {\n         Some(d) => { return d.clone(); }\n         None => { }\n     }\n \n-    let default = param.default.as_ref().map(\n-        |def| convert_default_type_parameter(ccx, def, space, index)\n-    );\n+    let default =\n+        param.default.as_ref().map(|def| ccx.icx(&()).to_ty(&ExplicitRscope, def));\n \n     let object_lifetime_default =\n         compute_object_lifetime_default(ccx, param.id,\n@@ -1922,6 +1892,10 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         object_lifetime_default: object_lifetime_default,\n     };\n \n+    if def.name == keywords::SelfType.name() {\n+        span_bug!(param.span, \"`Self` should not be the name of a regular parameter\");\n+    }\n+\n     tcx.ty_param_defs.borrow_mut().insert(param.id, def.clone());\n \n     debug!(\"get_or_create_type_parameter_def: def for type param: {:?}, {:?}\",\n@@ -2153,7 +2127,7 @@ pub fn mk_item_substs<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n \n /// Checks that all the type parameters on an impl\n fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                                 ast_generics: &hir::Generics,\n+                                                 generics: &hir::Generics,\n                                                  impl_predicates: &mut ty::GenericPredicates<'tcx>,\n                                                  impl_def_id: DefId)\n {\n@@ -2173,12 +2147,11 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                        impl_trait_ref,\n                                        &mut input_parameters);\n \n-    for (index, ty_param) in ast_generics.ty_params.iter().enumerate() {\n-        let param_ty = ty::ParamTy { space: TypeSpace,\n-                                     idx: index as u32,\n-                                     name: ty_param.name };\n+    let ty_generics = generics_of_def_id(ccx, impl_def_id);\n+    for (ty_param, param) in ty_generics.types.as_full_slice().iter().zip(&generics.ty_params) {\n+        let param_ty = ty::ParamTy::for_def(ty_param);\n         if !input_parameters.contains(&ctp::Parameter::Type(param_ty)) {\n-            report_unused_parameter(ccx, ty_param.span, \"type\", &param_ty.to_string());\n+            report_unused_parameter(ccx, param.span, \"type\", &param_ty.to_string());\n         }\n     }\n }"}, {"sha": "2b88689ff129566e24c089bab149a9e7b2a13e12", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -361,9 +361,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n                 // All type parameters on enums and structs should be\n                 // in the TypeSpace.\n-                assert!(item_type.generics.types.is_empty_in(subst::SelfSpace));\n                 assert!(item_type.generics.types.is_empty_in(subst::FnSpace));\n-                assert!(item_type.generics.regions.is_empty_in(subst::SelfSpace));\n                 assert!(item_type.generics.regions.is_empty_in(subst::FnSpace));\n \n                 self.add_constraints_from_substs(\n@@ -394,14 +392,12 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::TyTrait(ref data) => {\n-                let poly_trait_ref =\n-                    data.principal.with_self_ty(self.tcx(), self.tcx().types.err);\n-\n                 // The type `Foo<T+'a>` is contravariant w/r/t `'a`:\n                 let contra = self.contravariant(variance);\n                 self.add_constraints_from_region(generics, data.region_bound, contra);\n \n-                // Ignore the SelfSpace, it is erased.\n+                let poly_trait_ref =\n+                    data.principal.with_self_ty(self.tcx(), self.tcx().types.err);\n                 self.add_constraints_from_trait_ref(generics, poly_trait_ref.0, variance);\n \n                 for projection in &data.projection_bounds {"}, {"sha": "9048d892b09d25ca380d86b8540c94d9aaeecf37", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -110,8 +110,8 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n         while index < num_inferred {\n             let item_id = inferred_infos[index].item_id;\n \n-            let (mut rs, mut rt, mut rf) = (vec![], vec![], vec![]);\n-            let (mut ts, mut tt, mut tf) = (vec![], vec![], vec![]);\n+            let (mut rt, mut rf) = (vec![], vec![]);\n+            let (mut tt, mut tf) = (vec![], vec![]);\n \n             while index < num_inferred && inferred_infos[index].item_id == item_id {\n                 let info = &inferred_infos[index];\n@@ -121,7 +121,6 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                 match info.kind {\n                     TypeParam => {\n                         let types = match info.space {\n-                            subst::SelfSpace => &mut ts,\n                             subst::TypeSpace => &mut tt,\n                             subst::FnSpace => &mut tf\n                         };\n@@ -130,7 +129,6 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                     }\n                     RegionParam => {\n                         let regions = match info.space {\n-                            subst::SelfSpace => &mut rs,\n                             subst::TypeSpace => &mut rt,\n                             subst::FnSpace => &mut rf\n                         };\n@@ -143,8 +141,8 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n             }\n \n             let item_variances = ty::ItemVariances {\n-                regions: subst::VecPerParamSpace::new(rs, rt, rf),\n-                types: subst::VecPerParamSpace::new(ts, tt, tf)\n+                regions: subst::VecPerParamSpace::new(rt, rf),\n+                types: subst::VecPerParamSpace::new(tt, tf)\n             };\n \n             debug!(\"item_id={} item_variances={:?}\","}, {"sha": "9dc38bb195c1469946b2236c7bcc6982601a27a2", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -21,7 +21,7 @@\n \n use arena::TypedArena;\n use dep_graph::DepTrackingMapConfig;\n-use rustc::ty::subst::{ParamSpace, FnSpace, TypeSpace, SelfSpace};\n+use rustc::ty::subst::{ParamSpace, FnSpace, TypeSpace};\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::maps::ItemVariances;\n use std::fmt;\n@@ -164,16 +164,16 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n \n         let inferreds_on_entry = self.num_inferred();\n \n-        if has_self {\n-            self.add_inferred(item_id, TypeParam, SelfSpace, 0, item_id);\n-        }\n-\n         for (i, p) in generics.lifetimes.iter().enumerate() {\n             let id = p.lifetime.id;\n             self.add_inferred(item_id, RegionParam, TypeSpace, i, id);\n         }\n \n+        if has_self {\n+            self.add_inferred(item_id, TypeParam, TypeSpace, 0, item_id);\n+        }\n         for (i, p) in generics.ty_params.iter().enumerate() {\n+            let i = has_self as usize + i;\n             self.add_inferred(item_id, TypeParam, TypeSpace, i, p.id);\n         }\n \n@@ -233,7 +233,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n                              -> ty::Variance\n     {\n         match space {\n-            SelfSpace | FnSpace => {\n+            FnSpace => {\n                 ty::Bivariant\n             }\n "}, {"sha": "6fae7ddc24a89c1e38fcadb9a57e9a82074978df", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -41,7 +41,7 @@ use rustc::hir::def::Def;\n use rustc::hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n use rustc::hir::fold::Folder;\n use rustc::hir::print as pprust;\n-use rustc::ty::subst::{self, ParamSpace, Substs, VecPerParamSpace};\n+use rustc::ty::subst::{self, Substs, VecPerParamSpace};\n use rustc::ty;\n use rustc::middle::stability;\n \n@@ -630,13 +630,14 @@ impl Clean<TyParamBound> for hir::TyParamBound {\n     }\n }\n \n-fn external_path_params(cx: &DocContext, trait_did: Option<DefId>,\n+fn external_path_params(cx: &DocContext, trait_did: Option<DefId>, has_self: bool,\n                         bindings: Vec<TypeBinding>, substs: &Substs) -> PathParameters {\n     let lifetimes = substs.regions.get_slice(subst::TypeSpace)\n                     .iter()\n                     .filter_map(|v| v.clean(cx))\n                     .collect();\n-    let types = substs.types.get_slice(subst::TypeSpace).to_vec();\n+    let types = substs.types.get_slice(subst::TypeSpace);\n+    let types = types[has_self as usize..].to_vec();\n \n     match (trait_did, cx.tcx_opt()) {\n         // Attempt to sugar an external path like Fn<(A, B,), C> to Fn(A, B) -> C\n@@ -675,13 +676,13 @@ fn external_path_params(cx: &DocContext, trait_did: Option<DefId>,\n \n // trait_did should be set to a trait's DefId if called on a TraitRef, in order to sugar\n // from Fn<(A, B,), C> to Fn(A, B) -> C\n-fn external_path(cx: &DocContext, name: &str, trait_did: Option<DefId>,\n+fn external_path(cx: &DocContext, name: &str, trait_did: Option<DefId>, has_self: bool,\n                  bindings: Vec<TypeBinding>, substs: &Substs) -> Path {\n     Path {\n         global: false,\n         segments: vec![PathSegment {\n             name: name.to_string(),\n-            params: external_path_params(cx, trait_did, bindings, substs)\n+            params: external_path_params(cx, trait_did, has_self, bindings, substs)\n         }],\n     }\n }\n@@ -696,16 +697,16 @@ impl Clean<TyParamBound> for ty::BuiltinBound {\n         let (did, path) = match *self {\n             ty::BoundSend =>\n                 (tcx.lang_items.send_trait().unwrap(),\n-                 external_path(cx, \"Send\", None, vec![], empty)),\n+                 external_path(cx, \"Send\", None, false, vec![], empty)),\n             ty::BoundSized =>\n                 (tcx.lang_items.sized_trait().unwrap(),\n-                 external_path(cx, \"Sized\", None, vec![], empty)),\n+                 external_path(cx, \"Sized\", None, false, vec![], empty)),\n             ty::BoundCopy =>\n                 (tcx.lang_items.copy_trait().unwrap(),\n-                 external_path(cx, \"Copy\", None, vec![], empty)),\n+                 external_path(cx, \"Copy\", None, false, vec![], empty)),\n             ty::BoundSync =>\n                 (tcx.lang_items.sync_trait().unwrap(),\n-                 external_path(cx, \"Sync\", None, vec![], empty)),\n+                 external_path(cx, \"Sync\", None, false, vec![], empty)),\n         };\n         inline::record_extern_fqn(cx, did, TypeTrait);\n         TraitBound(PolyTrait {\n@@ -728,14 +729,14 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n         };\n         inline::record_extern_fqn(cx, self.def_id, TypeTrait);\n         let path = external_path(cx, &tcx.item_name(self.def_id).as_str(),\n-                                 Some(self.def_id), vec![], self.substs);\n+                                 Some(self.def_id), true, vec![], self.substs);\n \n         debug!(\"ty::TraitRef\\n  substs.types(TypeSpace): {:?}\\n\",\n-               self.substs.types.get_slice(ParamSpace::TypeSpace));\n+               &self.input_types()[1..]);\n \n         // collect any late bound regions\n         let mut late_bounds = vec![];\n-        for &ty_s in self.substs.types.get_slice(ParamSpace::TypeSpace) {\n+        for &ty_s in &self.input_types()[1..] {\n             if let ty::TyTuple(ts) = ty_s.sty {\n                 for &ty_s in ts {\n                     if let ty::TyRef(ref reg, _) = ty_s.sty {\n@@ -982,8 +983,13 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>,\n         // Bounds in the type_params and lifetimes fields are repeated in the\n         // predicates field (see rustc_typeck::collect::ty_generics), so remove\n         // them.\n-        let stripped_typarams = gens.types.get_slice(space).iter().map(|tp| {\n-            tp.clean(cx)\n+        let stripped_typarams = gens.types.get_slice(space).iter().filter_map(|tp| {\n+            if tp.name == keywords::SelfType.name() {\n+                assert_eq!(tp.index, 0);\n+                None\n+            } else {\n+                Some(tp.clean(cx))\n+            }\n         }).collect::<Vec<_>>();\n         let stripped_lifetimes = gens.regions.get_slice(space).iter().map(|rp| {\n             let mut srp = rp.clone();\n@@ -1820,7 +1826,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                 };\n                 inline::record_extern_fqn(cx, did, kind);\n                 let path = external_path(cx, &cx.tcx().item_name(did).as_str(),\n-                                         None, vec![], substs);\n+                                         None, false, vec![], substs);\n                 ResolvedPath {\n                     path: path,\n                     typarams: None,\n@@ -1847,7 +1853,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                 }\n \n                 let path = external_path(cx, &cx.tcx().item_name(did).as_str(),\n-                                         Some(did), bindings, obj.principal.0.substs);\n+                                         Some(did), false, bindings, obj.principal.0.substs);\n                 ResolvedPath {\n                     path: path,\n                     typarams: Some(typarams),"}, {"sha": "2591d7bcbaef4e2cc73e50bc17ff70ae97d4f000", "filename": "src/test/compile-fail/issue-26548.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -8,15 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: overflow representing the type `S`\n+// error-pattern: overflow representing the type\n \n-#![feature(rustc_attrs)]\n \n trait Mirror { type It: ?Sized; }\n impl<T: ?Sized> Mirror for T { type It = Self; }\n struct S(Option<<S as Mirror>::It>);\n \n-#[rustc_no_mir] // FIXME #27840 MIR tries to represent `std::option::Option<S>` first.\n fn main() {\n     let _s = S(None);\n }"}, {"sha": "1dd008810788b0fb4a56bdd9bb35a609b3af2ec3", "filename": "src/test/compile-fail/issue-26812.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Ftest%2Fcompile-fail%2Fissue-26812.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Ftest%2Fcompile-fail%2Fissue-26812.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26812.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -10,5 +10,7 @@\n \n #![feature(default_type_parameter_fallback)]\n \n-fn avg<T=T::Item>(_: T) {} //~ ERROR associated type `Item` not found for `T`\n+fn avg<T=T::Item>(_: T) {}\n+//~^ ERROR type parameters with a default cannot use forward declared identifiers\n+\n fn main() {}"}, {"sha": "9aa4d29c4ecf731af22ad2b390bdd165d2947682", "filename": "src/test/compile-fail/variance-associated-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Ftest%2Fcompile-fail%2Fvariance-associated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Ftest%2Fcompile-fail%2Fvariance-associated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-associated-types.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -20,12 +20,12 @@ trait Trait<'a> {\n }\n \n #[rustc_variance]\n-struct Foo<'a, T : Trait<'a>> { //~ ERROR ItemVariances(types=[[];[+];[]], regions=[[];[-];[]])\n+struct Foo<'a, T : Trait<'a>> { //~ ERROR ItemVariances(types=[[+];[]], regions=[[-];[]])\n     field: (T, &'a ())\n }\n \n #[rustc_variance]\n-struct Bar<'a, T : Trait<'a>> { //~ ERROR ItemVariances(types=[[];[o];[]], regions=[[];[o];[]])\n+struct Bar<'a, T : Trait<'a>> { //~ ERROR ItemVariances(types=[[o];[]], regions=[[o];[]])\n     field: <T as Trait<'a>>::Type\n }\n "}, {"sha": "3c8b27f965a6138906614a81110c9bece1db7ee9", "filename": "src/test/compile-fail/variance-object-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Ftest%2Fcompile-fail%2Fvariance-object-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Ftest%2Fcompile-fail%2Fvariance-object-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-object-types.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -18,7 +18,7 @@ use std::cell::Cell;\n // For better or worse, associated types are invariant, and hence we\n // get an invariant result for `'a`.\n #[rustc_variance]\n-struct Foo<'a> { //~ ERROR regions=[[];[o];[]]\n+struct Foo<'a> { //~ ERROR regions=[[o];[]]\n     x: Box<Fn(i32) -> &'a i32 + 'static>\n }\n "}, {"sha": "ae5a8674f446ca7b8d49e497cff569cf379cd647", "filename": "src/test/compile-fail/variance-region-bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Ftest%2Fcompile-fail%2Fvariance-region-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Ftest%2Fcompile-fail%2Fvariance-region-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-region-bounds.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -13,11 +13,11 @@\n #![feature(rustc_attrs)]\n \n #[rustc_variance]\n-trait Foo: 'static { //~ ERROR types=[[o];[];[]]\n+trait Foo: 'static { //~ ERROR types=[[o];[]]\n }\n \n #[rustc_variance]\n-trait Bar<T> { //~ ERROR types=[[o];[o];[]]\n+trait Bar<T> { //~ ERROR types=[[o, o];[]]\n     fn do_it(&self)\n         where T: 'static;\n }"}, {"sha": "93d3d2773149eb4a6bb7c53f7d90689a96678aa5", "filename": "src/test/compile-fail/variance-regions-direct.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -16,7 +16,7 @@\n // Regions that just appear in normal spots are contravariant:\n \n #[rustc_variance]\n-struct Test2<'a, 'b, 'c> { //~ ERROR regions=[[];[-, -, -];[]]\n+struct Test2<'a, 'b, 'c> { //~ ERROR regions=[[-, -, -];[]]\n     x: &'a isize,\n     y: &'b [isize],\n     c: &'c str\n@@ -25,7 +25,7 @@ struct Test2<'a, 'b, 'c> { //~ ERROR regions=[[];[-, -, -];[]]\n // Those same annotations in function arguments become covariant:\n \n #[rustc_variance]\n-struct Test3<'a, 'b, 'c> { //~ ERROR regions=[[];[+, +, +];[]]\n+struct Test3<'a, 'b, 'c> { //~ ERROR regions=[[+, +, +];[]]\n     x: extern \"Rust\" fn(&'a isize),\n     y: extern \"Rust\" fn(&'b [isize]),\n     c: extern \"Rust\" fn(&'c str),\n@@ -34,15 +34,15 @@ struct Test3<'a, 'b, 'c> { //~ ERROR regions=[[];[+, +, +];[]]\n // Mutability induces invariance:\n \n #[rustc_variance]\n-struct Test4<'a, 'b:'a> { //~ ERROR regions=[[];[-, o];[]]\n+struct Test4<'a, 'b:'a> { //~ ERROR regions=[[-, o];[]]\n     x: &'a mut &'b isize,\n }\n \n // Mutability induces invariance, even when in a\n // contravariant context:\n \n #[rustc_variance]\n-struct Test5<'a, 'b:'a> { //~ ERROR regions=[[];[+, o];[]]\n+struct Test5<'a, 'b:'a> { //~ ERROR regions=[[+, o];[]]\n     x: extern \"Rust\" fn(&'a mut &'b isize),\n }\n \n@@ -52,22 +52,22 @@ struct Test5<'a, 'b:'a> { //~ ERROR regions=[[];[+, o];[]]\n // argument list occurs in an invariant context.\n \n #[rustc_variance]\n-struct Test6<'a, 'b:'a> { //~ ERROR regions=[[];[-, o];[]]\n+struct Test6<'a, 'b:'a> { //~ ERROR regions=[[-, o];[]]\n     x: &'a mut extern \"Rust\" fn(&'b isize),\n }\n \n // No uses at all is bivariant:\n \n #[rustc_variance]\n-struct Test7<'a> { //~ ERROR regions=[[];[*];[]]\n+struct Test7<'a> { //~ ERROR regions=[[*];[]]\n     //~^ ERROR parameter `'a` is never used\n     x: isize\n }\n \n // Try enums too.\n \n #[rustc_variance]\n-enum Test8<'a, 'b, 'c:'b> { //~ ERROR regions=[[];[+, -, o];[]]\n+enum Test8<'a, 'b, 'c:'b> { //~ ERROR regions=[[+, -, o];[]]\n     Test8A(extern \"Rust\" fn(&'a isize)),\n     Test8B(&'b [isize]),\n     Test8C(&'b mut &'c str),"}, {"sha": "eeb981b707e316ac036818df68541b855b3e1e0d", "filename": "src/test/compile-fail/variance-regions-indirect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -15,33 +15,33 @@\n #![feature(rustc_attrs)]\n \n #[rustc_variance]\n-enum Base<'a, 'b, 'c:'b, 'd> { //~ ERROR regions=[[];[+, -, o, *];[]]\n+enum Base<'a, 'b, 'c:'b, 'd> { //~ ERROR regions=[[+, -, o, *];[]]\n     //~^ ERROR parameter `'d` is never used\n     Test8A(extern \"Rust\" fn(&'a isize)),\n     Test8B(&'b [isize]),\n     Test8C(&'b mut &'c str),\n }\n \n #[rustc_variance]\n-struct Derived1<'w, 'x:'y, 'y, 'z> { //~ ERROR regions=[[];[*, o, -, +];[]]\n+struct Derived1<'w, 'x:'y, 'y, 'z> { //~ ERROR regions=[[*, o, -, +];[]]\n     //~^ ERROR parameter `'w` is never used\n     f: Base<'z, 'y, 'x, 'w>\n }\n \n #[rustc_variance] // Combine - and + to yield o\n-struct Derived2<'a, 'b:'a, 'c> { //~ ERROR regions=[[];[o, o, *];[]]\n+struct Derived2<'a, 'b:'a, 'c> { //~ ERROR regions=[[o, o, *];[]]\n     //~^ ERROR parameter `'c` is never used\n     f: Base<'a, 'a, 'b, 'c>\n }\n \n #[rustc_variance] // Combine + and o to yield o (just pay attention to 'a here)\n-struct Derived3<'a:'b, 'b, 'c> { //~ ERROR regions=[[];[o, -, *];[]]\n+struct Derived3<'a:'b, 'b, 'c> { //~ ERROR regions=[[o, -, *];[]]\n     //~^ ERROR parameter `'c` is never used\n     f: Base<'a, 'b, 'a, 'c>\n }\n \n #[rustc_variance] // Combine + and * to yield + (just pay attention to 'a here)\n-struct Derived4<'a, 'b, 'c:'b> { //~ ERROR regions=[[];[+, -, o];[]]\n+struct Derived4<'a, 'b, 'c:'b> { //~ ERROR regions=[[+, -, o];[]]\n     f: Base<'a, 'b, 'c, 'a>\n }\n "}, {"sha": "860dd6deefd5b4b579995dcab6855e8032479c9e", "filename": "src/test/compile-fail/variance-trait-bounds.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -15,48 +15,48 @@\n // influence variance.\n \n #[rustc_variance]\n-trait Getter<T> { //~ ERROR types=[[o];[o];[]]\n+trait Getter<T> { //~ ERROR types=[[o, o];[]]\n     fn get(&self) -> T;\n }\n \n #[rustc_variance]\n-trait Setter<T> { //~ ERROR types=[[o];[o];[]]\n+trait Setter<T> { //~ ERROR types=[[o, o];[]]\n     fn get(&self, T);\n }\n \n #[rustc_variance]\n-struct TestStruct<U,T:Setter<U>> { //~ ERROR types=[[];[+, +];[]]\n+struct TestStruct<U,T:Setter<U>> { //~ ERROR types=[[+, +];[]]\n     t: T, u: U\n }\n \n #[rustc_variance]\n-enum TestEnum<U,T:Setter<U>> {//~ ERROR types=[[];[*, +];[]]\n+enum TestEnum<U,T:Setter<U>> {//~ ERROR types=[[*, +];[]]\n     //~^ ERROR parameter `U` is never used\n     Foo(T)\n }\n \n #[rustc_variance]\n-trait TestTrait<U,T:Setter<U>> { //~ ERROR types=[[o];[o, o];[]]\n+trait TestTrait<U,T:Setter<U>> { //~ ERROR types=[[o, o, o];[]]\n     fn getter(&self, u: U) -> T;\n }\n \n #[rustc_variance]\n-trait TestTrait2<U> : Getter<U> { //~ ERROR types=[[o];[o];[]]\n+trait TestTrait2<U> : Getter<U> { //~ ERROR types=[[o, o];[]]\n }\n \n #[rustc_variance]\n-trait TestTrait3<U> { //~ ERROR types=[[o];[o];[]]\n+trait TestTrait3<U> { //~ ERROR types=[[o, o];[]]\n     fn getter<T:Getter<U>>(&self);\n }\n \n #[rustc_variance]\n-struct TestContraStruct<U,T:Setter<U>> { //~ ERROR types=[[];[*, +];[]]\n+struct TestContraStruct<U,T:Setter<U>> { //~ ERROR types=[[*, +];[]]\n     //~^ ERROR parameter `U` is never used\n     t: T\n }\n \n #[rustc_variance]\n-struct TestBox<U,T:Getter<U>+Setter<U>> { //~ ERROR types=[[];[*, +];[]]\n+struct TestBox<U,T:Getter<U>+Setter<U>> { //~ ERROR types=[[*, +];[]]\n     //~^ ERROR parameter `U` is never used\n     t: T\n }"}, {"sha": "b37007a6d34e46abd77fb025968499e341d98319", "filename": "src/test/compile-fail/variance-trait-object-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -21,7 +21,7 @@ use std::mem;\n trait T { fn foo(&self); }\n \n #[rustc_variance]\n-struct TOption<'a> { //~ ERROR regions=[[];[-];[]]\n+struct TOption<'a> { //~ ERROR regions=[[-];[]]\n     v: Option<Box<T + 'a>>,\n }\n "}, {"sha": "8eb96814fa8f04e05650c43b849b9b9584b1e5bd", "filename": "src/test/compile-fail/variance-types-bounds.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -14,46 +14,46 @@\n #![feature(rustc_attrs)]\n \n #[rustc_variance]\n-struct TestImm<A, B> { //~ ERROR types=[[];[+, +];[]]\n+struct TestImm<A, B> { //~ ERROR types=[[+, +];[]]\n     x: A,\n     y: B,\n }\n \n #[rustc_variance]\n-struct TestMut<A, B:'static> { //~ ERROR types=[[];[+, o];[]]\n+struct TestMut<A, B:'static> { //~ ERROR types=[[+, o];[]]\n     x: A,\n     y: &'static mut B,\n }\n \n #[rustc_variance]\n-struct TestIndirect<A:'static, B:'static> { //~ ERROR types=[[];[+, o];[]]\n+struct TestIndirect<A:'static, B:'static> { //~ ERROR types=[[+, o];[]]\n     m: TestMut<A, B>\n }\n \n #[rustc_variance]\n-struct TestIndirect2<A:'static, B:'static> { //~ ERROR types=[[];[o, o];[]]\n+struct TestIndirect2<A:'static, B:'static> { //~ ERROR types=[[o, o];[]]\n     n: TestMut<A, B>,\n     m: TestMut<B, A>\n }\n \n #[rustc_variance]\n-trait Getter<A> { //~ ERROR types=[[o];[o];[]]\n+trait Getter<A> { //~ ERROR types=[[o, o];[]]\n     fn get(&self) -> A;\n }\n \n #[rustc_variance]\n-trait Setter<A> { //~ ERROR types=[[o];[o];[]]\n+trait Setter<A> { //~ ERROR types=[[o, o];[]]\n     fn set(&mut self, a: A);\n }\n \n #[rustc_variance]\n-trait GetterSetter<A> { //~ ERROR types=[[o];[o];[]]\n+trait GetterSetter<A> { //~ ERROR types=[[o, o];[]]\n     fn get(&self) -> A;\n     fn set(&mut self, a: A);\n }\n \n #[rustc_variance]\n-trait GetterInTypeBound<A> { //~ ERROR types=[[o];[o];[]]\n+trait GetterInTypeBound<A> { //~ ERROR types=[[o, o];[]]\n     // Here, the use of `A` in the method bound *does* affect\n     // variance.  Think of it as if the method requested a dictionary\n     // for `T:Getter<A>`.  Since this dictionary is an input, it is\n@@ -63,12 +63,12 @@ trait GetterInTypeBound<A> { //~ ERROR types=[[o];[o];[]]\n }\n \n #[rustc_variance]\n-trait SetterInTypeBound<A> { //~ ERROR types=[[o];[o];[]]\n+trait SetterInTypeBound<A> { //~ ERROR types=[[o, o];[]]\n     fn do_it<T:Setter<A>>(&self);\n }\n \n #[rustc_variance]\n-struct TestObject<A, R> { //~ ERROR types=[[];[o, o];[]]\n+struct TestObject<A, R> { //~ ERROR types=[[o, o];[]]\n     n: Box<Setter<A>+Send>,\n     m: Box<Getter<R>+Send>,\n }"}, {"sha": "791b56caea02bb8c0d803cdd5edc838ee154e08a", "filename": "src/test/compile-fail/variance-types.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Ftest%2Fcompile-fail%2Fvariance-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cfd58cbdb84f834b8907dc5e1c7242c451225d/src%2Ftest%2Fcompile-fail%2Fvariance-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-types.rs?ref=c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "patch": "@@ -17,32 +17,32 @@ use std::cell::Cell;\n // not considered bivariant.\n \n #[rustc_variance]\n-struct InvariantMut<'a,A:'a,B:'a> { //~ ERROR types=[[];[o, o];[]], regions=[[];[-];[]]\n+struct InvariantMut<'a,A:'a,B:'a> { //~ ERROR types=[[o, o];[]], regions=[[-];[]]\n     t: &'a mut (A,B)\n }\n \n #[rustc_variance]\n-struct InvariantCell<A> { //~ ERROR types=[[];[o];[]]\n+struct InvariantCell<A> { //~ ERROR types=[[o];[]]\n     t: Cell<A>\n }\n \n #[rustc_variance]\n-struct InvariantIndirect<A> { //~ ERROR types=[[];[o];[]]\n+struct InvariantIndirect<A> { //~ ERROR types=[[o];[]]\n     t: InvariantCell<A>\n }\n \n #[rustc_variance]\n-struct Covariant<A> { //~ ERROR types=[[];[+];[]]\n+struct Covariant<A> { //~ ERROR types=[[+];[]]\n     t: A, u: fn() -> A\n }\n \n #[rustc_variance]\n-struct Contravariant<A> { //~ ERROR types=[[];[-];[]]\n+struct Contravariant<A> { //~ ERROR types=[[-];[]]\n     t: fn(A)\n }\n \n #[rustc_variance]\n-enum Enum<A,B,C> { //~ ERROR types=[[];[+, -, o];[]]\n+enum Enum<A,B,C> { //~ ERROR types=[[+, -, o];[]]\n     Foo(Covariant<A>),\n     Bar(Contravariant<B>),\n     Zed(Covariant<C>,Contravariant<C>)"}]}