{"sha": "db241bb0c8d257e13c1560f6250e49879477039e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiMjQxYmIwYzhkMjU3ZTEzYzE1NjBmNjI1MGU0OTg3OTQ3NzAzOWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-28T01:40:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-28T01:40:06Z"}, "message": "Auto merge of #78458 - Dylan-DPC:rollup-tan044s, r=Dylan-DPC\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #78152 (Separate unsized locals)\n - #78297 (Suggest calling await on method call and field access)\n - #78351 (Move \"mutable thing in const\" check from interning to validity)\n - #78365 (check object safety of generic constants)\n - #78379 (Tweak invalid `fn` header and body parsing)\n - #78391 (Add const_fn in generics test)\n - #78401 (resolve: private fields in tuple struct ctor diag)\n - #78408 (Remove tokens from foreign items in `TokenStripper`)\n - #78447 (Fix typo in  comment)\n - #78453 (Fix typo in comments)\n\nFailed merges:\n\nr? `@ghost`", "tree": {"sha": "492166fee5d39e53e20b60e1779a818691c43b31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/492166fee5d39e53e20b60e1779a818691c43b31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db241bb0c8d257e13c1560f6250e49879477039e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db241bb0c8d257e13c1560f6250e49879477039e", "html_url": "https://github.com/rust-lang/rust/commit/db241bb0c8d257e13c1560f6250e49879477039e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db241bb0c8d257e13c1560f6250e49879477039e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90e6d0d46bae511aecea04ac5eeb3c387f0c04f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/90e6d0d46bae511aecea04ac5eeb3c387f0c04f4", "html_url": "https://github.com/rust-lang/rust/commit/90e6d0d46bae511aecea04ac5eeb3c387f0c04f4"}, {"sha": "6967005e6e626f4ff62f53b971c00e6e12d2e618", "url": "https://api.github.com/repos/rust-lang/rust/commits/6967005e6e626f4ff62f53b971c00e6e12d2e618", "html_url": "https://github.com/rust-lang/rust/commit/6967005e6e626f4ff62f53b971c00e6e12d2e618"}], "stats": {"total": 1608, "additions": 1059, "deletions": 549}, "files": [{"sha": "a8522547666994683d664eeeb8ae1aa9c4093140", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -533,7 +533,7 @@ impl DropArena {\n         ptr::write(mem, object);\n         let result = &mut *mem;\n         // Record the destructor after doing the allocation as that may panic\n-        // and would cause `object`'s destuctor to run twice if it was recorded before\n+        // and would cause `object`'s destructor to run twice if it was recorded before\n         self.destructors\n             .borrow_mut()\n             .push(DropType { drop_fn: drop_for_type::<T>, obj: result as *mut T as *mut u8 });\n@@ -560,7 +560,7 @@ impl DropArena {\n         mem::forget(vec.drain(..));\n \n         // Record the destructors after doing the allocation as that may panic\n-        // and would cause `object`'s destuctor to run twice if it was recorded before\n+        // and would cause `object`'s destructor to run twice if it was recorded before\n         for i in 0..len {\n             destructors.push(DropType {\n                 drop_fn: drop_for_type::<T>,"}, {"sha": "4ed888784181447edbf711ce2d6c1408d5a171d8", "filename": "compiler/rustc_data_structures/src/graph/vec_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Fmod.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -29,7 +29,7 @@ impl<N: Idx> VecGraph<N> {\n \n         // Create the *edge starts* array. We are iterating over over\n         // the (sorted) edge pairs. We maintain the invariant that the\n-        // length of the `node_starts` arary is enough to store the\n+        // length of the `node_starts` array is enough to store the\n         // current source node -- so when we see that the source node\n         // for an edge is greater than the current length, we grow the\n         // edge-starts array by just enough."}, {"sha": "ad926a810e6bfc87b38ef71469880dab9e16bc1d", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -607,6 +607,9 @@ declare_features! (\n     /// Allow anonymous constants from an inline `const` block\n     (active, inline_const, \"1.49.0\", Some(76001), None),\n \n+    /// Allows unsized fn parameters.\n+    (active, unsized_fn_params, \"1.49.0\", Some(48055), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------\n@@ -629,6 +632,7 @@ pub const INCOMPLETE_FEATURES: &[Symbol] = &[\n     sym::specialization,\n     sym::inline_const,\n     sym::repr128,\n+    sym::unsized_locals,\n ];\n \n /// Some features are not allowed to be used together at the same time, if"}, {"sha": "1402f70c220dd30bfc9f4a414d13b4d21746835d", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1669,7 +1669,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.note_error_origin(diag, cause, exp_found);\n     }\n \n-    fn get_impl_future_output_ty(&self, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+    pub fn get_impl_future_output_ty(&self, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n         if let ty::Opaque(def_id, substs) = ty.kind() {\n             let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n             // Future::Output"}, {"sha": "9dbd59506b1883cdbf28066a96bb020eccfd10b0", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -63,6 +63,13 @@ impl mut_visit::MutVisitor for TokenStripper {\n         i.tokens = None;\n         mut_visit::noop_flat_map_item(i, self)\n     }\n+    fn flat_map_foreign_item(\n+        &mut self,\n+        mut i: P<ast::ForeignItem>,\n+    ) -> SmallVec<[P<ast::ForeignItem>; 1]> {\n+        i.tokens = None;\n+        mut_visit::noop_flat_map_foreign_item(i, self)\n+    }\n     fn visit_block(&mut self, b: &mut P<ast::Block>) {\n         b.tokens = None;\n         mut_visit::noop_visit_block(b, self);"}, {"sha": "a753732d364396f81243f98ba8ec449383398333", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -210,16 +210,6 @@ pub struct Body<'tcx> {\n     /// We hold in this field all the constants we are not able to evaluate yet.\n     pub required_consts: Vec<Constant<'tcx>>,\n \n-    /// The user may be writing e.g. `&[(SOME_CELL, 42)][i].1` and this would get promoted, because\n-    /// we'd statically know that no thing with interior mutability will ever be available to the\n-    /// user without some serious unsafe code.  Now this means that our promoted is actually\n-    /// `&[(SOME_CELL, 42)]` and the MIR using it will do the `&promoted[i].1` projection because\n-    /// the index may be a runtime value. Such a promoted value is illegal because it has reachable\n-    /// interior mutability. This flag just makes this situation very obvious where the previous\n-    /// implementation without the flag hid this situation silently.\n-    /// FIXME(oli-obk): rewrite the promoted during promotion to eliminate the cell components.\n-    pub ignore_interior_mut_in_const_validation: bool,\n-\n     /// Does this body use generic parameters. This is used for the `ConstEvaluatable` check.\n     ///\n     /// Note that this does not actually mean that this body is not computable right now.\n@@ -276,7 +266,6 @@ impl<'tcx> Body<'tcx> {\n             var_debug_info,\n             span,\n             required_consts: Vec::new(),\n-            ignore_interior_mut_in_const_validation: false,\n             is_polymorphic: false,\n             predecessor_cache: PredecessorCache::new(),\n         };\n@@ -306,7 +295,6 @@ impl<'tcx> Body<'tcx> {\n             required_consts: Vec::new(),\n             generator_kind: None,\n             var_debug_info: Vec::new(),\n-            ignore_interior_mut_in_const_validation: false,\n             is_polymorphic: false,\n             predecessor_cache: PredecessorCache::new(),\n         };"}, {"sha": "409399094e84921212e3c9d1fc460d74ba0957e6", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -974,6 +974,11 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         checker\n     }\n \n+    fn unsized_feature_enabled(&self) -> bool {\n+        let features = self.tcx().features();\n+        features.unsized_locals || features.unsized_fn_params\n+    }\n+\n     /// Equate the inferred type and the annotated type for user type annotations\n     fn check_user_type_annotations(&mut self) {\n         debug!(\n@@ -1456,7 +1461,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n \n                 self.check_rvalue(body, rv, location);\n-                if !self.tcx().features().unsized_locals {\n+                if !self.unsized_feature_enabled() {\n                     let trait_ref = ty::TraitRef {\n                         def_id: tcx.require_lang_item(LangItem::Sized, Some(self.last_span)),\n                         substs: tcx.mk_substs_trait(place_ty, &[]),\n@@ -1717,9 +1722,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     );\n                 }\n \n-                // When `#![feature(unsized_locals)]` is not enabled,\n+                // When `unsized_fn_params` and `unsized_locals` are both not enabled,\n                 // this check is done at `check_local`.\n-                if self.tcx().features().unsized_locals {\n+                if self.unsized_feature_enabled() {\n                     let span = term.source_info.span;\n                     self.ensure_place_sized(dest_ty, span);\n                 }\n@@ -1880,9 +1885,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             LocalKind::Var | LocalKind::Temp => {}\n         }\n \n-        // When `#![feature(unsized_locals)]` is enabled, only function calls\n+        // When `unsized_fn_params` or `unsized_locals` is enabled, only function calls\n         // and nullary ops are checked in `check_call_dest`.\n-        if !self.tcx().features().unsized_locals {\n+        if !self.unsized_feature_enabled() {\n             let span = local_decl.source_info.span;\n             let ty = local_decl.ty;\n             self.ensure_place_sized(ty, span);\n@@ -2024,7 +2029,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n             Rvalue::NullaryOp(_, ty) => {\n                 // Even with unsized locals cannot box an unsized value.\n-                if self.tcx().features().unsized_locals {\n+                if self.unsized_feature_enabled() {\n                     let span = body.source_info(location).span;\n                     self.ensure_place_sized(ty, span);\n                 }"}, {"sha": "7b9a4ec873d0a757d9794e2085717fd09978bd53", "filename": "compiler/rustc_mir/src/const_eval/eval_queries.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,8 +1,8 @@\n use super::{CompileTimeEvalContext, CompileTimeInterpreter, ConstEvalErr, MemoryExtra};\n use crate::interpret::eval_nullary_intrinsic;\n use crate::interpret::{\n-    intern_const_alloc_recursive, Allocation, ConstAlloc, ConstValue, GlobalId, Immediate,\n-    InternKind, InterpCx, InterpResult, MPlaceTy, MemoryKind, OpTy, RefTracking, Scalar,\n+    intern_const_alloc_recursive, Allocation, ConstAlloc, ConstValue, CtfeValidationMode, GlobalId,\n+    Immediate, InternKind, InterpCx, InterpResult, MPlaceTy, MemoryKind, OpTy, RefTracking, Scalar,\n     ScalarMaybeUninit, StackPopCleanup,\n };\n \n@@ -59,23 +59,15 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     ecx.run()?;\n \n     // Intern the result\n-    // FIXME: since the DefId of a promoted is the DefId of its owner, this\n-    // means that promoteds in statics are actually interned like statics!\n-    // However, this is also currently crucial because we promote mutable\n-    // non-empty slices in statics to extend their lifetime, and this\n-    // ensures that they are put into a mutable allocation.\n-    // For other kinds of promoteds in statics (like array initializers), this is rather silly.\n-    let intern_kind = match tcx.static_mutability(cid.instance.def_id()) {\n-        Some(m) => InternKind::Static(m),\n-        None if cid.promoted.is_some() => InternKind::Promoted,\n-        _ => InternKind::Constant,\n+    let intern_kind = if cid.promoted.is_some() {\n+        InternKind::Promoted\n+    } else {\n+        match tcx.static_mutability(cid.instance.def_id()) {\n+            Some(m) => InternKind::Static(m),\n+            None => InternKind::Constant,\n+        }\n     };\n-    intern_const_alloc_recursive(\n-        ecx,\n-        intern_kind,\n-        ret,\n-        body.ignore_interior_mut_in_const_validation,\n-    );\n+    intern_const_alloc_recursive(ecx, intern_kind, ret);\n \n     debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n     Ok(ret)\n@@ -376,16 +368,23 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n             // Since evaluation had no errors, valiate the resulting constant:\n             let validation = try {\n                 // FIXME do not validate promoteds until a decision on\n-                // https://github.com/rust-lang/rust/issues/67465 is made\n+                // https://github.com/rust-lang/rust/issues/67465 and\n+                // https://github.com/rust-lang/rust/issues/67534 is made.\n+                // Promoteds can contain unexpected `UnsafeCell` and reference `static`s, but their\n+                // otherwise restricted form ensures that this is still sound. We just lose the\n+                // extra safety net of some of the dynamic checks. They can also contain invalid\n+                // values, but since we do not usually check intermediate results of a computation\n+                // for validity, it might be surprising to do that here.\n                 if cid.promoted.is_none() {\n                     let mut ref_tracking = RefTracking::new(mplace);\n+                    let mut inner = false;\n                     while let Some((mplace, path)) = ref_tracking.todo.pop() {\n-                        ecx.const_validate_operand(\n-                            mplace.into(),\n-                            path,\n-                            &mut ref_tracking,\n-                            /*may_ref_to_static*/ ecx.memory.extra.can_access_statics,\n-                        )?;\n+                        let mode = match tcx.static_mutability(cid.instance.def_id()) {\n+                            Some(_) => CtfeValidationMode::Regular, // a `static`\n+                            None => CtfeValidationMode::Const { inner },\n+                        };\n+                        ecx.const_validate_operand(mplace.into(), path, &mut ref_tracking, mode)?;\n+                        inner = true;\n                     }\n                 }\n             };"}, {"sha": "11a211ef7b3518a39c558e8417b924c4f5672b45", "filename": "compiler/rustc_mir/src/const_eval/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -29,7 +29,7 @@ pub(crate) fn const_caller_location(\n     let mut ecx = mk_eval_cx(tcx, DUMMY_SP, ty::ParamEnv::reveal_all(), false);\n \n     let loc_place = ecx.alloc_caller_location(file, line, col);\n-    intern_const_alloc_recursive(&mut ecx, InternKind::Constant, loc_place, false);\n+    intern_const_alloc_recursive(&mut ecx, InternKind::Constant, loc_place);\n     ConstValue::Scalar(loc_place.ptr)\n }\n "}, {"sha": "5e5c74a3723747f8ad6801a65c045ff9a695d14f", "filename": "compiler/rustc_mir/src/interpret/intern.rs", "status": "modified", "additions": 28, "deletions": 59, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -2,12 +2,23 @@\n //!\n //! After a const evaluation has computed a value, before we destroy the const evaluator's session\n //! memory, we need to extract all memory allocations to the global memory pool so they stay around.\n+//!\n+//! In principle, this is not very complicated: we recursively walk the final value, follow all the\n+//! pointers, and move all reachable allocations to the global `tcx` memory. The only complication\n+//! is picking the right mutability for the allocations in a `static` initializer: we want to make\n+//! as many allocations as possible immutable so LLVM can put them into read-only memory. At the\n+//! same time, we need to make memory that could be mutated by the program mutable to avoid\n+//! incorrect compilations. To achieve this, we do a type-based traversal of the final value,\n+//! tracking mutable and shared references and `UnsafeCell` to determine the current mutability.\n+//! (In principle, we could skip this type-based part for `const` and promoteds, as they need to be\n+//! always immutable. At least for `const` however we use this opportunity to reject any `const`\n+//! that contains allocations whose mutability we cannot identify.)\n \n use super::validity::RefTracking;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_middle::mir::interpret::InterpResult;\n-use rustc_middle::ty::{self, layout::TyAndLayout, query::TyCtxtAt, Ty};\n+use rustc_middle::ty::{self, layout::TyAndLayout, Ty};\n use rustc_target::abi::Size;\n \n use rustc_ast::Mutability;\n@@ -40,11 +51,6 @@ struct InternVisitor<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> {\n     /// This field stores whether we are *currently* inside an `UnsafeCell`. This can affect\n     /// the intern mode of references we encounter.\n     inside_unsafe_cell: bool,\n-\n-    /// This flag is to avoid triggering UnsafeCells are not allowed behind references in constants\n-    /// for promoteds.\n-    /// It's a copy of `mir::Body`'s ignore_interior_mut_in_const_validation field\n-    ignore_interior_mut_in_const: bool,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Hash, Eq)]\n@@ -53,22 +59,14 @@ enum InternMode {\n     /// this is *immutable*, and below mutable references inside an `UnsafeCell`, this\n     /// is *mutable*.\n     Static(hir::Mutability),\n-    /// The \"base value\" of a const, which can have `UnsafeCell` (as in `const FOO: Cell<i32>`),\n-    /// but that interior mutability is simply ignored.\n-    ConstBase,\n-    /// The \"inner values\" of a const with references, where `UnsafeCell` is an error.\n-    ConstInner,\n+    /// A `const`.\n+    Const,\n }\n \n /// Signalling data structure to ensure we don't recurse\n /// into the memory of other constants or statics\n struct IsStaticOrFn;\n \n-fn mutable_memory_in_const(tcx: TyCtxtAt<'_>, kind: &str) {\n-    // FIXME: show this in validation instead so we can point at where in the value the error is?\n-    tcx.sess.span_err(tcx.span, &format!(\"mutable memory ({}) is not allowed in constant\", kind));\n-}\n-\n /// Intern an allocation without looking at its children.\n /// `mode` is the mode of the environment where we found this pointer.\n /// `mutablity` is the mutability of the place to be interned; even if that says\n@@ -129,9 +127,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n         // See const_eval::machine::MemoryExtra::can_access_statics for why\n         // immutability is so important.\n \n-        // There are no sensible checks we can do here; grep for `mutable_memory_in_const` to\n-        // find the checks we are doing elsewhere to avoid even getting here for memory\n-        // that \"wants\" to be mutable.\n+        // Validation will ensure that there is no `UnsafeCell` on an immutable allocation.\n         alloc.mutability = Mutability::Not;\n     };\n     // link the alloc id to the actual allocation\n@@ -167,17 +163,13 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n         mplace: MPlaceTy<'tcx>,\n         fields: impl Iterator<Item = InterpResult<'tcx, Self::V>>,\n     ) -> InterpResult<'tcx> {\n+        // ZSTs cannot contain pointers, so we can skip them.\n+        if mplace.layout.is_zst() {\n+            return Ok(());\n+        }\n+\n         if let Some(def) = mplace.layout.ty.ty_adt_def() {\n             if Some(def.did) == self.ecx.tcx.lang_items().unsafe_cell_type() {\n-                if self.mode == InternMode::ConstInner && !self.ignore_interior_mut_in_const {\n-                    // We do not actually make this memory mutable.  But in case the user\n-                    // *expected* it to be mutable, make sure we error.  This is just a\n-                    // sanity check to prevent users from accidentally exploiting the UB\n-                    // they caused.  It also helps us to find cases where const-checking\n-                    // failed to prevent an `UnsafeCell` (but as `ignore_interior_mut_in_const`\n-                    // shows that part is not airtight).\n-                    mutable_memory_in_const(self.ecx.tcx, \"`UnsafeCell`\");\n-                }\n                 // We are crossing over an `UnsafeCell`, we can mutate again. This means that\n                 // References we encounter inside here are interned as pointing to mutable\n                 // allocations.\n@@ -189,11 +181,6 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n             }\n         }\n \n-        // ZSTs cannot contain pointers, so we can skip them.\n-        if mplace.layout.is_zst() {\n-            return Ok(());\n-        }\n-\n         self.walk_aggregate(mplace, fields)\n     }\n \n@@ -213,7 +200,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n                 if let Scalar::Ptr(vtable) = mplace.meta.unwrap_meta() {\n                     // Explicitly choose const mode here, since vtables are immutable, even\n                     // if the reference of the fat pointer is mutable.\n-                    self.intern_shallow(vtable.alloc_id, InternMode::ConstInner, None);\n+                    self.intern_shallow(vtable.alloc_id, InternMode::Const, None);\n                 } else {\n                     // Validation will error (with a better message) on an invalid vtable pointer.\n                     // Let validation show the error message, but make sure it *does* error.\n@@ -225,7 +212,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n             // Only recurse for allocation-backed pointers.\n             if let Scalar::Ptr(ptr) = mplace.ptr {\n                 // Compute the mode with which we intern this. Our goal here is to make as many\n-                // statics as we can immutable so they can be placed in const memory by LLVM.\n+                // statics as we can immutable so they can be placed in read-only memory by LLVM.\n                 let ref_mode = match self.mode {\n                     InternMode::Static(mutbl) => {\n                         // In statics, merge outer mutability with reference mutability and\n@@ -259,27 +246,11 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n                             }\n                         }\n                     }\n-                    InternMode::ConstBase | InternMode::ConstInner => {\n-                        // Ignore `UnsafeCell`, everything is immutable.  Do some sanity checking\n-                        // for mutable references that we encounter -- they must all be ZST.\n-                        // This helps to prevent users from accidentally exploiting UB that they\n-                        // caused (by somehow getting a mutable reference in a `const`).\n-                        if ref_mutability == Mutability::Mut {\n-                            match referenced_ty.kind() {\n-                                ty::Array(_, n) if n.eval_usize(*tcx, self.ecx.param_env) == 0 => {}\n-                                ty::Slice(_)\n-                                    if mplace.meta.unwrap_meta().to_machine_usize(self.ecx)?\n-                                        == 0 => {}\n-                                _ => mutable_memory_in_const(tcx, \"`&mut`\"),\n-                            }\n-                        } else {\n-                            // A shared reference. We cannot check `freeze` here due to references\n-                            // like `&dyn Trait` that are actually immutable.  We do check for\n-                            // concrete `UnsafeCell` when traversing the pointee though (if it is\n-                            // a new allocation, not yet interned).\n-                        }\n-                        // Go on with the \"inner\" rules.\n-                        InternMode::ConstInner\n+                    InternMode::Const => {\n+                        // Ignore `UnsafeCell`, everything is immutable.  Validity does some sanity\n+                        // checking for mutable references that we encounter -- they must all be\n+                        // ZST.\n+                        InternMode::Const\n                     }\n                 };\n                 match self.intern_shallow(ptr.alloc_id, ref_mode, Some(referenced_ty)) {\n@@ -318,7 +289,6 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n     ecx: &mut InterpCx<'mir, 'tcx, M>,\n     intern_kind: InternKind,\n     ret: MPlaceTy<'tcx>,\n-    ignore_interior_mut_in_const: bool,\n ) where\n     'tcx: 'mir,\n {\n@@ -327,7 +297,7 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n         InternKind::Static(mutbl) => InternMode::Static(mutbl),\n         // `Constant` includes array lengths.\n         // `Promoted` includes non-`Copy` array initializers and `rustc_args_required_const` arguments.\n-        InternKind::Constant | InternKind::Promoted => InternMode::ConstBase,\n+        InternKind::Constant | InternKind::Promoted => InternMode::Const,\n     };\n \n     // Type based interning.\n@@ -357,7 +327,6 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n             ecx,\n             mode,\n             leftover_allocations,\n-            ignore_interior_mut_in_const,\n             inside_unsafe_cell: false,\n         }\n         .visit_value(mplace);"}, {"sha": "a29ef117ace831c8696ce74a1e54d7e8c9210e17", "filename": "compiler/rustc_mir/src/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmod.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -24,7 +24,7 @@ pub use self::machine::{compile_time_machine, AllocMap, Machine, MayLeak, StackP\n pub use self::memory::{AllocCheck, FnVal, Memory, MemoryKind};\n pub use self::operand::{ImmTy, Immediate, OpTy, Operand};\n pub use self::place::{MPlaceTy, MemPlace, MemPlaceMeta, Place, PlaceTy};\n-pub use self::validity::RefTracking;\n+pub use self::validity::{CtfeValidationMode, RefTracking};\n pub use self::visitor::{MutValueVisitor, ValueVisitor};\n \n crate use self::intrinsics::eval_nullary_intrinsic;"}, {"sha": "f657c6c4538328fef0399b73b3de74ff5623c4d7", "filename": "compiler/rustc_mir/src/interpret/validity.rs", "status": "modified", "additions": 58, "deletions": 30, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -113,6 +113,17 @@ pub enum PathElem {\n     DynDowncast,\n }\n \n+/// Extra things to check for during validation of CTFE results.\n+pub enum CtfeValidationMode {\n+    /// Regular validation, nothing special happening.\n+    Regular,\n+    /// Validation of a `const`. `inner` says if this is an inner, indirect allocation (as opposed\n+    /// to the top-level const allocation).\n+    /// Being an inner allocation makes a difference because the top-level allocation of a `const`\n+    /// is copied for each use, but the inner allocations are implicitly shared.\n+    Const { inner: bool },\n+}\n+\n /// State for tracking recursive validation of references\n pub struct RefTracking<T, PATH = ()> {\n     pub seen: FxHashSet<T>,\n@@ -202,9 +213,9 @@ struct ValidityVisitor<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// starts must not be changed!  `visit_fields` and `visit_array` rely on\n     /// this stack discipline.\n     path: Vec<PathElem>,\n-    ref_tracking_for_consts:\n-        Option<&'rt mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>>,\n-    may_ref_to_static: bool,\n+    ref_tracking: Option<&'rt mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>>,\n+    /// `None` indicates this is not validating for CTFE (but for runtime).\n+    ctfe_mode: Option<CtfeValidationMode>,\n     ecx: &'rt InterpCx<'mir, 'tcx, M>,\n }\n \n@@ -418,27 +429,15 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 { \"a dangling {} (use-after-free)\", kind },\n         );\n         // Recursive checking\n-        if let Some(ref mut ref_tracking) = self.ref_tracking_for_consts {\n+        if let Some(ref mut ref_tracking) = self.ref_tracking {\n             if let Some(ptr) = ptr {\n                 // not a ZST\n                 // Skip validation entirely for some external statics\n                 let alloc_kind = self.ecx.tcx.get_global_alloc(ptr.alloc_id);\n                 if let Some(GlobalAlloc::Static(did)) = alloc_kind {\n                     assert!(!self.ecx.tcx.is_thread_local_static(did));\n                     assert!(self.ecx.tcx.is_static(did));\n-                    if self.may_ref_to_static {\n-                        // We skip checking other statics. These statics must be sound by\n-                        // themselves, and the only way to get broken statics here is by using\n-                        // unsafe code.\n-                        // The reasons we don't check other statics is twofold. For one, in all\n-                        // sound cases, the static was already validated on its own, and second, we\n-                        // trigger cycle errors if we try to compute the value of the other static\n-                        // and that static refers back to us.\n-                        // We might miss const-invalid data,\n-                        // but things are still sound otherwise (in particular re: consts\n-                        // referring to statics).\n-                        return Ok(());\n-                    } else {\n+                    if matches!(self.ctfe_mode, Some(CtfeValidationMode::Const { .. })) {\n                         // See const_eval::machine::MemoryExtra::can_access_statics for why\n                         // this check is so important.\n                         // This check is reachable when the const just referenced the static,\n@@ -447,6 +446,17 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                             { \"a {} pointing to a static variable\", kind }\n                         );\n                     }\n+                    // We skip checking other statics. These statics must be sound by\n+                    // themselves, and the only way to get broken statics here is by using\n+                    // unsafe code.\n+                    // The reasons we don't check other statics is twofold. For one, in all\n+                    // sound cases, the static was already validated on its own, and second, we\n+                    // trigger cycle errors if we try to compute the value of the other static\n+                    // and that static refers back to us.\n+                    // We might miss const-invalid data,\n+                    // but things are still sound otherwise (in particular re: consts\n+                    // referring to statics).\n+                    return Ok(());\n                 }\n             }\n             // Proceed recursively even for ZST, no reason to skip them!\n@@ -504,7 +514,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 let value = self.ecx.read_scalar(value)?;\n                 // NOTE: Keep this in sync with the array optimization for int/float\n                 // types below!\n-                if self.ref_tracking_for_consts.is_some() {\n+                if self.ctfe_mode.is_some() {\n                     // Integers/floats in CTFE: Must be scalar bits, pointers are dangerous\n                     let is_bits = value.check_init().map_or(false, |v| v.is_bits());\n                     if !is_bits {\n@@ -532,7 +542,17 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 }\n                 Ok(true)\n             }\n-            ty::Ref(..) => {\n+            ty::Ref(_, ty, mutbl) => {\n+                if matches!(self.ctfe_mode, Some(CtfeValidationMode::Const { .. }))\n+                    && *mutbl == hir::Mutability::Mut\n+                {\n+                    // A mutable reference inside a const? That does not seem right (except if it is\n+                    // a ZST).\n+                    let layout = self.ecx.layout_of(ty)?;\n+                    if !layout.is_zst() {\n+                        throw_validation_failure!(self.path, { \"mutable reference in a `const`\" });\n+                    }\n+                }\n                 self.check_safe_pointer(value, \"reference\")?;\n                 Ok(true)\n             }\n@@ -723,6 +743,15 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         // Sanity check: `builtin_deref` does not know any pointers that are not primitive.\n         assert!(op.layout.ty.builtin_deref(true).is_none());\n \n+        // Special check preventing `UnsafeCell` in constants\n+        if let Some(def) = op.layout.ty.ty_adt_def() {\n+            if matches!(self.ctfe_mode, Some(CtfeValidationMode::Const { inner: true }))\n+                && Some(def.did) == self.ecx.tcx.lang_items().unsafe_cell_type()\n+            {\n+                throw_validation_failure!(self.path, { \"`UnsafeCell` in a `const`\" });\n+            }\n+        }\n+\n         // Recursively walk the value at its type.\n         self.walk_value(op)?;\n \n@@ -814,7 +843,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     self.ecx,\n                     ptr,\n                     size,\n-                    /*allow_uninit_and_ptr*/ self.ref_tracking_for_consts.is_none(),\n+                    /*allow_uninit_and_ptr*/ self.ctfe_mode.is_none(),\n                 ) {\n                     // In the happy case, we needn't check anything else.\n                     Ok(()) => {}\n@@ -865,16 +894,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n         path: Vec<PathElem>,\n-        ref_tracking_for_consts: Option<\n-            &mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>,\n-        >,\n-        may_ref_to_static: bool,\n+        ref_tracking: Option<&mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>>,\n+        ctfe_mode: Option<CtfeValidationMode>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"validate_operand_internal: {:?}, {:?}\", *op, op.layout.ty);\n \n         // Construct a visitor\n-        let mut visitor =\n-            ValidityVisitor { path, ref_tracking_for_consts, may_ref_to_static, ecx: self };\n+        let mut visitor = ValidityVisitor { path, ref_tracking, ctfe_mode, ecx: self };\n \n         // Try to cast to ptr *once* instead of all the time.\n         let op = self.force_op_ptr(op).unwrap_or(op);\n@@ -902,23 +928,25 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// `ref_tracking` is used to record references that we encounter so that they\n     /// can be checked recursively by an outside driving loop.\n     ///\n-    /// `may_ref_to_static` controls whether references are allowed to point to statics.\n+    /// `constant` controls whether this must satisfy the rules for constants:\n+    /// - no pointers to statics.\n+    /// - no `UnsafeCell` or non-ZST `&mut`.\n     #[inline(always)]\n     pub fn const_validate_operand(\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n         path: Vec<PathElem>,\n         ref_tracking: &mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>,\n-        may_ref_to_static: bool,\n+        ctfe_mode: CtfeValidationMode,\n     ) -> InterpResult<'tcx> {\n-        self.validate_operand_internal(op, path, Some(ref_tracking), may_ref_to_static)\n+        self.validate_operand_internal(op, path, Some(ref_tracking), Some(ctfe_mode))\n     }\n \n     /// This function checks the data at `op` to be runtime-valid.\n     /// `op` is assumed to cover valid memory if it is an indirect operand.\n     /// It will error if the bits at the destination do not match the ones described by the layout.\n     #[inline(always)]\n     pub fn validate_operand(&self, op: OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n-        self.validate_operand_internal(op, vec![], None, false)\n+        self.validate_operand_internal(op, vec![], None, None)\n     }\n }"}, {"sha": "d47e549b7be371fb9078860a61b43262cad6751f", "filename": "compiler/rustc_mir/src/transform/const_prop.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -9,7 +9,6 @@ use rustc_hir::def::DefKind;\n use rustc_hir::HirId;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n-use rustc_middle::mir::interpret::{InterpResult, Scalar};\n use rustc_middle::mir::visit::{\n     MutVisitor, MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor,\n };\n@@ -28,9 +27,10 @@ use rustc_trait_selection::traits;\n \n use crate::const_eval::ConstEvalErr;\n use crate::interpret::{\n-    self, compile_time_machine, truncate, AllocId, Allocation, ConstValue, Frame, ImmTy, Immediate,\n-    InterpCx, LocalState, LocalValue, MemPlace, Memory, MemoryKind, OpTy, Operand as InterpOperand,\n-    PlaceTy, Pointer, ScalarMaybeUninit, StackPopCleanup,\n+    self, compile_time_machine, truncate, AllocId, Allocation, ConstValue, CtfeValidationMode,\n+    Frame, ImmTy, Immediate, InterpCx, InterpResult, LocalState, LocalValue, MemPlace, Memory,\n+    MemoryKind, OpTy, Operand as InterpOperand, PlaceTy, Pointer, Scalar, ScalarMaybeUninit,\n+    StackPopCleanup,\n };\n use crate::transform::MirPass;\n \n@@ -805,8 +805,9 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             value,\n             vec![],\n             // FIXME: is ref tracking too expensive?\n+            // FIXME: what is the point of ref tracking if we do not even check the tracked refs?\n             &mut interpret::RefTracking::empty(),\n-            /*may_ref_to_static*/ true,\n+            CtfeValidationMode::Regular,\n         ) {\n             trace!(\"validation error, attempt failed: {:?}\", e);\n             return;"}, {"sha": "927aae82a36efab1c3cb9a66b4abd18548a453d0", "filename": "compiler/rustc_mir/src/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1170,7 +1170,7 @@ pub fn promote_candidates<'tcx>(\n         let mut scope = body.source_scopes[candidate.source_info(body).scope].clone();\n         scope.parent_scope = None;\n \n-        let mut promoted = Body::new(\n+        let promoted = Body::new(\n             body.source, // `promoted` gets filled in below\n             IndexVec::new(),\n             IndexVec::from_elem_n(scope, 1),\n@@ -1181,7 +1181,6 @@ pub fn promote_candidates<'tcx>(\n             body.span,\n             body.generator_kind,\n         );\n-        promoted.ignore_interior_mut_in_const_validation = true;\n \n         let promoter = Promoter {\n             promoted,"}, {"sha": "cf075abc94bf5f776ce52bd142cb012aed361cb9", "filename": "compiler/rustc_mir_build/src/build/expr/as_operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -165,7 +165,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         let tcx = this.hir.tcx();\n \n-        if tcx.features().unsized_locals {\n+        if tcx.features().unsized_fn_params {\n             let ty = expr.ty;\n             let span = expr.span;\n             let param_env = this.hir.param_env;"}, {"sha": "730c16aba8c0b61626be11dc8ac6f73096766297", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1557,14 +1557,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub(super) fn expected_semi_or_open_brace<T>(&mut self) -> PResult<'a, T> {\n-        let token_str = super::token_descr(&self.token);\n-        let msg = &format!(\"expected `;` or `{{`, found {}\", token_str);\n-        let mut err = self.struct_span_err(self.token.span, msg);\n-        err.span_label(self.token.span, \"expected `;` or `{`\");\n-        Err(err)\n-    }\n-\n     pub(super) fn eat_incorrect_doc_comment_for_param_type(&mut self) {\n         if let token::DocComment(..) = self.token.kind {\n             self.struct_span_err("}, {"sha": "c2a13d4b0dec145291161acae8970b2f08c911ba", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -831,7 +831,7 @@ impl<'a> Parser<'a> {\n         self.struct_span_err(self.token.span, &format!(\"unexpected token: `{}`\", actual)).emit();\n     }\n \n-    // We need and identifier or integer, but the next token is a float.\n+    // We need an identifier or integer, but the next token is a float.\n     // Break the float into components to extract the identifier or integer.\n     // FIXME: With current `TokenCursor` it's hard to break tokens into more than 2\n     // parts unless those parts are processed immediately. `TokenCursor` should either"}, {"sha": "39d4875f37b1d883c0c1edfaadbfb8d8eba412da", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1538,7 +1538,7 @@ impl<'a> Parser<'a> {\n         generics.where_clause = self.parse_where_clause()?; // `where T: Ord`\n \n         let mut sig_hi = self.prev_token.span;\n-        let body = self.parse_fn_body(attrs, &mut sig_hi)?; // `;` or `{ ... }`.\n+        let body = self.parse_fn_body(attrs, &ident, &mut sig_hi)?; // `;` or `{ ... }`.\n         let fn_sig_span = sig_lo.to(sig_hi);\n         Ok((ident, FnSig { header, decl, span: fn_sig_span }, generics, body))\n     }\n@@ -1549,12 +1549,12 @@ impl<'a> Parser<'a> {\n     fn parse_fn_body(\n         &mut self,\n         attrs: &mut Vec<Attribute>,\n+        ident: &Ident,\n         sig_hi: &mut Span,\n     ) -> PResult<'a, Option<P<Block>>> {\n-        let (inner_attrs, body) = if self.check(&token::Semi) {\n+        let (inner_attrs, body) = if self.eat(&token::Semi) {\n             // Include the trailing semicolon in the span of the signature\n-            *sig_hi = self.token.span;\n-            self.bump(); // `;`\n+            *sig_hi = self.prev_token.span;\n             (Vec::new(), None)\n         } else if self.check(&token::OpenDelim(token::Brace)) || self.token.is_whole_block() {\n             self.parse_inner_attrs_and_block().map(|(attrs, body)| (attrs, Some(body)))?\n@@ -1574,7 +1574,21 @@ impl<'a> Parser<'a> {\n                 .emit();\n             (Vec::new(), Some(self.mk_block_err(span)))\n         } else {\n-            return self.expected_semi_or_open_brace();\n+            if let Err(mut err) =\n+                self.expected_one_of_not_found(&[], &[token::Semi, token::OpenDelim(token::Brace)])\n+            {\n+                if self.token.kind == token::CloseDelim(token::Brace) {\n+                    // The enclosing `mod`, `trait` or `impl` is being closed, so keep the `fn` in\n+                    // the AST for typechecking.\n+                    err.span_label(ident.span, \"while parsing this `fn`\");\n+                    err.emit();\n+                    (Vec::new(), None)\n+                } else {\n+                    return Err(err);\n+                }\n+            } else {\n+                unreachable!()\n+            }\n         };\n         attrs.extend(inner_attrs);\n         Ok(body)\n@@ -1652,10 +1666,19 @@ impl<'a> Parser<'a> {\n         req_name: ReqName,\n         ret_allow_plus: AllowPlus,\n     ) -> PResult<'a, P<FnDecl>> {\n-        Ok(P(FnDecl {\n-            inputs: self.parse_fn_params(req_name)?,\n-            output: self.parse_ret_ty(ret_allow_plus, RecoverQPath::Yes)?,\n-        }))\n+        let inputs = self.parse_fn_params(req_name)?;\n+        let output = self.parse_ret_ty(ret_allow_plus, RecoverQPath::Yes)?;\n+\n+        if let ast::FnRetTy::Ty(ty) = &output {\n+            if let TyKind::Path(_, Path { segments, .. }) = &ty.kind {\n+                if let [.., last] = &segments[..] {\n+                    // Detect and recover `fn foo() -> Vec<i32>> {}`\n+                    self.check_trailing_angle_brackets(last, &[&token::OpenDelim(token::Brace)]);\n+                }\n+            }\n+        }\n+\n+        Ok(P(FnDecl { inputs, output }))\n     }\n \n     /// Parses the parameter list of a function, including the `(` and `)` delimiters."}, {"sha": "7a6ebca4e1541db1a45346be11063a1fbaaaaf3d", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -265,7 +265,19 @@ impl<'a> Parser<'a> {\n     /// Parses an array (`[TYPE; EXPR]`) or slice (`[TYPE]`) type.\n     /// The opening `[` bracket is already eaten.\n     fn parse_array_or_slice_ty(&mut self) -> PResult<'a, TyKind> {\n-        let elt_ty = self.parse_ty()?;\n+        let elt_ty = match self.parse_ty() {\n+            Ok(ty) => ty,\n+            Err(mut err)\n+                if self.look_ahead(1, |t| t.kind == token::CloseDelim(token::Bracket))\n+                    | self.look_ahead(1, |t| t.kind == token::Semi) =>\n+            {\n+                // Recover from `[LIT; EXPR]` and `[LIT]`\n+                self.bump();\n+                err.emit();\n+                self.mk_ty(self.prev_token.span, TyKind::Err)\n+            }\n+            Err(err) => return Err(err),\n+        };\n         let ty = if self.eat(&token::Semi) {\n             TyKind::Array(elt_ty, self.parse_anon_const_expr()?)\n         } else {"}, {"sha": "cafceff4f29ed513a8c11f23d9fa0ab745ed4e0b", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 61, "deletions": 44, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -917,54 +917,71 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 self.suggest_using_enum_variant(err, source, def_id, span);\n             }\n             (Res::Def(DefKind::Struct, def_id), _) if ns == ValueNS => {\n-                if let Some((ctor_def, ctor_vis, fields)) =\n-                    self.r.struct_constructors.get(&def_id).cloned()\n+                let (ctor_def, ctor_vis, fields) =\n+                    if let Some(struct_ctor) = self.r.struct_constructors.get(&def_id).cloned() {\n+                        struct_ctor\n+                    } else {\n+                        bad_struct_syntax_suggestion(def_id);\n+                        return true;\n+                    };\n+\n+                let is_accessible = self.r.is_accessible_from(ctor_vis, self.parent_scope.module);\n+                if !is_expected(ctor_def) || is_accessible {\n+                    return true;\n+                }\n+\n+                let field_spans = match source {\n+                    // e.g. `if let Enum::TupleVariant(field1, field2) = _`\n+                    PathSource::TupleStruct(_, pattern_spans) => {\n+                        err.set_primary_message(\n+                            \"cannot match against a tuple struct which contains private fields\",\n+                        );\n+\n+                        // Use spans of the tuple struct pattern.\n+                        Some(Vec::from(pattern_spans))\n+                    }\n+                    // e.g. `let _ = Enum::TupleVariant(field1, field2);`\n+                    _ if source.is_call() => {\n+                        err.set_primary_message(\n+                            \"cannot initialize a tuple struct which contains private fields\",\n+                        );\n+\n+                        // Use spans of the tuple struct definition.\n+                        self.r\n+                            .field_names\n+                            .get(&def_id)\n+                            .map(|fields| fields.iter().map(|f| f.span).collect::<Vec<_>>())\n+                    }\n+                    _ => None,\n+                };\n+\n+                if let Some(spans) =\n+                    field_spans.filter(|spans| spans.len() > 0 && fields.len() == spans.len())\n                 {\n-                    let accessible_ctor =\n-                        self.r.is_accessible_from(ctor_vis, self.parent_scope.module);\n-                    if is_expected(ctor_def) && !accessible_ctor {\n-                        let mut better_diag = false;\n-                        if let PathSource::TupleStruct(_, pattern_spans) = source {\n-                            if pattern_spans.len() > 0 && fields.len() == pattern_spans.len() {\n-                                let non_visible_spans: Vec<Span> = fields\n-                                    .iter()\n-                                    .zip(pattern_spans.iter())\n-                                    .filter_map(|(vis, span)| {\n-                                        match self\n-                                            .r\n-                                            .is_accessible_from(*vis, self.parent_scope.module)\n-                                        {\n-                                            true => None,\n-                                            false => Some(*span),\n-                                        }\n-                                    })\n-                                    .collect();\n-                                // Extra check to be sure\n-                                if non_visible_spans.len() > 0 {\n-                                    let mut m: rustc_span::MultiSpan =\n-                                        non_visible_spans.clone().into();\n-                                    non_visible_spans.into_iter().for_each(|s| {\n-                                        m.push_span_label(s, \"private field\".to_string())\n-                                    });\n-                                    err.span_note(\n-                                        m,\n-                                        \"constructor is not visible here due to private fields\",\n-                                    );\n-                                    better_diag = true;\n-                                }\n-                            }\n-                        }\n+                    let non_visible_spans: Vec<Span> = fields\n+                        .iter()\n+                        .zip(spans.iter())\n+                        .filter(|(vis, _)| {\n+                            !self.r.is_accessible_from(**vis, self.parent_scope.module)\n+                        })\n+                        .map(|(_, span)| *span)\n+                        .collect();\n \n-                        if !better_diag {\n-                            err.span_label(\n-                                span,\n-                                \"constructor is not visible here due to private fields\".to_string(),\n-                            );\n-                        }\n+                    if non_visible_spans.len() > 0 {\n+                        let mut m: rustc_span::MultiSpan = non_visible_spans.clone().into();\n+                        non_visible_spans\n+                            .into_iter()\n+                            .for_each(|s| m.push_span_label(s, \"private field\".to_string()));\n+                        err.span_note(m, \"constructor is not visible here due to private fields\");\n                     }\n-                } else {\n-                    bad_struct_syntax_suggestion(def_id);\n+\n+                    return true;\n                 }\n+\n+                err.span_label(\n+                    span,\n+                    \"constructor is not visible here due to private fields\".to_string(),\n+                );\n             }\n             (\n                 Res::Def("}, {"sha": "29c686e5d08539ec37f67f234d7788c533677c8b", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -738,14 +738,14 @@ impl<D: Decoder> Decodable<D> for Span {\n }\n \n /// Calls the provided closure, using the provided `SourceMap` to format\n-/// any spans that are debug-printed during the closure'e exectuino.\n+/// any spans that are debug-printed during the closure's execution.\n ///\n /// Normally, the global `TyCtxt` is used to retrieve the `SourceMap`\n /// (see `rustc_interface::callbacks::span_debug1). However, some parts\n /// of the compiler (e.g. `rustc_parse`) may debug-print `Span`s before\n /// a `TyCtxt` is available. In this case, we fall back to\n /// the `SourceMap` provided to this function. If that is not available,\n-/// we fall back to printing the raw `Span` field values\n+/// we fall back to printing the raw `Span` field values.\n pub fn with_source_map<T, F: FnOnce() -> T>(source_map: Lrc<SourceMap>, f: F) -> T {\n     SESSION_GLOBALS.with(|session_globals| {\n         *session_globals.source_map.borrow_mut() = Some(source_map);"}, {"sha": "1a6c45b6c80d2c8f86fa2bcc77e26766dabc96a9", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1169,6 +1169,7 @@ symbols! {\n         unsafe_cell,\n         unsafe_no_drop_flag,\n         unsize,\n+        unsized_fn_params,\n         unsized_locals,\n         unsized_tuple_coercion,\n         unstable,"}, {"sha": "5f6d8ac751e265baa1147406fa9fa4071a7766ca", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 38, "deletions": 23, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -85,8 +85,10 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n                         } else if leaf.has_param_types_or_consts() {\n                             failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n                         }\n+\n+                        false\n                     }\n-                    Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => (),\n+                    Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => false,\n                 });\n \n                 match failure_kind {\n@@ -194,12 +196,12 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n ///\n /// This is only able to represent a subset of `MIR`,\n /// and should not leak any information about desugarings.\n-#[derive(Clone, Copy)]\n+#[derive(Debug, Clone, Copy)]\n pub struct AbstractConst<'tcx> {\n     // FIXME: Consider adding something like `IndexSlice`\n     // and use this here.\n-    inner: &'tcx [Node<'tcx>],\n-    substs: SubstsRef<'tcx>,\n+    pub inner: &'tcx [Node<'tcx>],\n+    pub substs: SubstsRef<'tcx>,\n }\n \n impl AbstractConst<'tcx> {\n@@ -209,9 +211,21 @@ impl AbstractConst<'tcx> {\n         substs: SubstsRef<'tcx>,\n     ) -> Result<Option<AbstractConst<'tcx>>, ErrorReported> {\n         let inner = tcx.mir_abstract_const_opt_const_arg(def)?;\n+        debug!(\"AbstractConst::new({:?}) = {:?}\", def, inner);\n         Ok(inner.map(|inner| AbstractConst { inner, substs }))\n     }\n \n+    pub fn from_const(\n+        tcx: TyCtxt<'tcx>,\n+        ct: &ty::Const<'tcx>,\n+    ) -> Result<Option<AbstractConst<'tcx>>, ErrorReported> {\n+        match ct.val {\n+            ty::ConstKind::Unevaluated(def, substs, None) => AbstractConst::new(tcx, def, substs),\n+            ty::ConstKind::Error(_) => Err(ErrorReported),\n+            _ => Ok(None),\n+        }\n+    }\n+\n     #[inline]\n     pub fn subtree(self, node: NodeId) -> AbstractConst<'tcx> {\n         AbstractConst { inner: &self.inner[..=node.index()], substs: self.substs }\n@@ -550,31 +564,32 @@ pub(super) fn try_unify_abstract_consts<'tcx>(\n     // on `ErrorReported`.\n }\n \n-fn walk_abstract_const<'tcx, F>(tcx: TyCtxt<'tcx>, ct: AbstractConst<'tcx>, mut f: F)\n+// FIXME: Use `std::ops::ControlFlow` instead of `bool` here.\n+pub fn walk_abstract_const<'tcx, F>(tcx: TyCtxt<'tcx>, ct: AbstractConst<'tcx>, mut f: F) -> bool\n where\n-    F: FnMut(Node<'tcx>),\n+    F: FnMut(Node<'tcx>) -> bool,\n {\n-    recurse(tcx, ct, &mut f);\n-    fn recurse<'tcx>(tcx: TyCtxt<'tcx>, ct: AbstractConst<'tcx>, f: &mut dyn FnMut(Node<'tcx>)) {\n+    fn recurse<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n+        ct: AbstractConst<'tcx>,\n+        f: &mut dyn FnMut(Node<'tcx>) -> bool,\n+    ) -> bool {\n         let root = ct.root();\n-        f(root);\n-        match root {\n-            Node::Leaf(_) => (),\n-            Node::Binop(_, l, r) => {\n-                recurse(tcx, ct.subtree(l), f);\n-                recurse(tcx, ct.subtree(r), f);\n-            }\n-            Node::UnaryOp(_, v) => {\n-                recurse(tcx, ct.subtree(v), f);\n-            }\n-            Node::FunctionCall(func, args) => {\n-                recurse(tcx, ct.subtree(func), f);\n-                for &arg in args {\n-                    recurse(tcx, ct.subtree(arg), f);\n+        f(root)\n+            || match root {\n+                Node::Leaf(_) => false,\n+                Node::Binop(_, l, r) => {\n+                    recurse(tcx, ct.subtree(l), f) || recurse(tcx, ct.subtree(r), f)\n+                }\n+                Node::UnaryOp(_, v) => recurse(tcx, ct.subtree(v), f),\n+                Node::FunctionCall(func, args) => {\n+                    recurse(tcx, ct.subtree(func), f)\n+                        || args.iter().any(|&arg| recurse(tcx, ct.subtree(arg), f))\n                 }\n             }\n-        }\n     }\n+\n+    recurse(tcx, ct, &mut f)\n }\n \n /// Tries to unify two abstract constants using structural equality."}, {"sha": "c0881befe2481372e64974c333ec905a1023babf", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1845,9 +1845,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     err.note(\"all function arguments must have a statically known size\");\n                 }\n                 if tcx.sess.opts.unstable_features.is_nightly_build()\n-                    && !self.tcx.features().unsized_locals\n+                    && !self.tcx.features().unsized_fn_params\n                 {\n-                    err.help(\"unsized locals are gated as an unstable feature\");\n+                    err.help(\"unsized fn params are gated as an unstable feature\");\n                 }\n             }\n             ObligationCauseCode::SizedReturnType => {"}, {"sha": "d2ac24b6100daf81b97b59a3bf93a4042de60228", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 61, "deletions": 24, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -11,6 +11,7 @@\n use super::elaborate_predicates;\n \n use crate::infer::TyCtxtInferExt;\n+use crate::traits::const_evaluatable::{self, AbstractConst};\n use crate::traits::query::evaluate_obligation::InferCtxtExt;\n use crate::traits::{self, Obligation, ObligationCause};\n use rustc_errors::FatalError;\n@@ -249,7 +250,7 @@ fn predicates_reference_self(\n     predicates\n         .predicates\n         .iter()\n-        .map(|(predicate, sp)| (predicate.subst_supertrait(tcx, &trait_ref), *sp))\n+        .map(|&(predicate, sp)| (predicate.subst_supertrait(tcx, &trait_ref), sp))\n         .filter_map(|predicate| predicate_references_self(tcx, predicate))\n         .collect()\n }\n@@ -260,7 +261,7 @@ fn bounds_reference_self(tcx: TyCtxt<'_>, trait_def_id: DefId) -> SmallVec<[Span\n         .in_definition_order()\n         .filter(|item| item.kind == ty::AssocKind::Type)\n         .flat_map(|item| tcx.explicit_item_bounds(item.def_id))\n-        .map(|(predicate, sp)| (predicate.subst_supertrait(tcx, &trait_ref), *sp))\n+        .map(|&(predicate, sp)| (predicate.subst_supertrait(tcx, &trait_ref), sp))\n         .filter_map(|predicate| predicate_references_self(tcx, predicate))\n         .collect()\n }\n@@ -415,7 +416,7 @@ fn virtual_call_violation_for_method<'tcx>(\n         ));\n     }\n \n-    for (i, input_ty) in sig.skip_binder().inputs()[1..].iter().enumerate() {\n+    for (i, &input_ty) in sig.skip_binder().inputs()[1..].iter().enumerate() {\n         if contains_illegal_self_type_reference(tcx, trait_def_id, input_ty) {\n             return Some(MethodViolationCode::ReferencesSelfInput(i));\n         }\n@@ -438,10 +439,7 @@ fn virtual_call_violation_for_method<'tcx>(\n         // so outlives predicates will always hold.\n         .cloned()\n         .filter(|(p, _)| p.to_opt_type_outlives().is_none())\n-        .collect::<Vec<_>>()\n-        // Do a shallow visit so that `contains_illegal_self_type_reference`\n-        // may apply it's custom visiting.\n-        .visit_tys_shallow(|t| contains_illegal_self_type_reference(tcx, trait_def_id, t))\n+        .any(|pred| contains_illegal_self_type_reference(tcx, trait_def_id, pred))\n     {\n         return Some(MethodViolationCode::WhereClauseReferencesSelf);\n     }\n@@ -715,10 +713,10 @@ fn receiver_is_dispatchable<'tcx>(\n     })\n }\n \n-fn contains_illegal_self_type_reference<'tcx>(\n+fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n     tcx: TyCtxt<'tcx>,\n     trait_def_id: DefId,\n-    ty: Ty<'tcx>,\n+    value: T,\n ) -> bool {\n     // This is somewhat subtle. In general, we want to forbid\n     // references to `Self` in the argument and return types,\n@@ -761,15 +759,14 @@ fn contains_illegal_self_type_reference<'tcx>(\n \n     struct IllegalSelfTypeVisitor<'tcx> {\n         tcx: TyCtxt<'tcx>,\n-        self_ty: Ty<'tcx>,\n         trait_def_id: DefId,\n         supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>>,\n     }\n \n     impl<'tcx> TypeVisitor<'tcx> for IllegalSelfTypeVisitor<'tcx> {\n         fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n             match t.kind() {\n-                ty::Param(_) => t == self.self_ty,\n+                ty::Param(_) => t == self.tcx.types.self_param,\n                 ty::Projection(ref data) => {\n                     // This is a projected type `<Foo as SomeTrait>::X`.\n \n@@ -802,22 +799,62 @@ fn contains_illegal_self_type_reference<'tcx>(\n             }\n         }\n \n-        fn visit_const(&mut self, _c: &ty::Const<'tcx>) -> bool {\n-            // FIXME(#72219) Look into the unevaluated constants for object safety violations.\n-            // Do not walk substitutions of unevaluated consts, as they contain `Self`, even\n-            // though the const expression doesn't necessary use it. Currently type variables\n-            // inside array length expressions are forbidden, so they can't break the above\n-            // rules.\n-            false\n+        fn visit_const(&mut self, ct: &ty::Const<'tcx>) -> bool {\n+            // First check if the type of this constant references `Self`.\n+            if self.visit_ty(ct.ty) {\n+                return true;\n+            }\n+\n+            // Constants can only influence object safety if they reference `Self`.\n+            // This is only possible for unevaluated constants, so we walk these here.\n+            //\n+            // If `AbstractConst::new` returned an error we already failed compilation\n+            // so we don't have to emit an additional error here.\n+            //\n+            // We currently recurse into abstract consts here but do not recurse in\n+            // `is_const_evaluatable`. This means that the object safety check is more\n+            // liberal than the const eval check.\n+            //\n+            // This shouldn't really matter though as we can't really use any\n+            // constants which are not considered const evaluatable.\n+            use rustc_middle::mir::abstract_const::Node;\n+            if let Ok(Some(ct)) = AbstractConst::from_const(self.tcx, ct) {\n+                const_evaluatable::walk_abstract_const(self.tcx, ct, |node| match node {\n+                    Node::Leaf(leaf) => {\n+                        let leaf = leaf.subst(self.tcx, ct.substs);\n+                        self.visit_const(leaf)\n+                    }\n+                    Node::Binop(..) | Node::UnaryOp(..) | Node::FunctionCall(_, _) => false,\n+                })\n+            } else {\n+                false\n+            }\n+        }\n+\n+        fn visit_predicate(&mut self, pred: ty::Predicate<'tcx>) -> bool {\n+            if let ty::PredicateAtom::ConstEvaluatable(def, substs) = pred.skip_binders() {\n+                // FIXME(const_evaluatable_checked): We should probably deduplicate the logic for\n+                // `AbstractConst`s here, it might make sense to change `ConstEvaluatable` to\n+                // take a `ty::Const` instead.\n+                use rustc_middle::mir::abstract_const::Node;\n+                if let Ok(Some(ct)) = AbstractConst::new(self.tcx, def, substs) {\n+                    const_evaluatable::walk_abstract_const(self.tcx, ct, |node| match node {\n+                        Node::Leaf(leaf) => {\n+                            let leaf = leaf.subst(self.tcx, ct.substs);\n+                            self.visit_const(leaf)\n+                        }\n+                        Node::Binop(..) | Node::UnaryOp(..) | Node::FunctionCall(_, _) => false,\n+                    })\n+                } else {\n+                    false\n+                }\n+            } else {\n+                pred.super_visit_with(self)\n+            }\n         }\n     }\n \n-    ty.visit_with(&mut IllegalSelfTypeVisitor {\n-        tcx,\n-        self_ty: tcx.types.self_param,\n-        trait_def_id,\n-        supertraits: None,\n-    })\n+    value.visit_with(&mut IllegalSelfTypeVisitor { tcx, trait_def_id, supertraits: None })\n }\n \n pub fn provide(providers: &mut ty::query::Providers) {"}, {"sha": "6dd8a143ec0f28c1e94f36a963964e7716d67a4c", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -131,7 +131,7 @@ pub(super) fn check_fn<'a, 'tcx>(\n         // The check for a non-trivial pattern is a hack to avoid duplicate warnings\n         // for simple cases like `fn foo(x: Trait)`,\n         // where we would error once on the parameter as a whole, and once on the binding `x`.\n-        if param.pat.simple_ident().is_none() && !tcx.features().unsized_locals {\n+        if param.pat.simple_ident().is_none() && !tcx.features().unsized_fn_params {\n             fcx.require_type_is_sized(param_ty, param.pat.span, traits::SizedArgumentType(ty_span));\n         }\n "}, {"sha": "324aa1a66a6d52a10e757a6430b01bfbcdddb796", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 28, "deletions": 45, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -42,7 +42,7 @@ use rustc_middle::ty::{AdtKind, Visibility};\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_trait_selection::traits::{self, ObligationCauseCode, SelectionContext};\n+use rustc_trait_selection::traits::{self, ObligationCauseCode};\n \n use std::fmt::Display;\n \n@@ -476,7 +476,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if let ty::FnDef(..) = ty.kind() {\n             let fn_sig = ty.fn_sig(tcx);\n-            if !tcx.features().unsized_locals {\n+            if !tcx.features().unsized_fn_params {\n                 // We want to remove some Sized bounds from std functions,\n                 // but don't want to expose the removal to stable Rust.\n                 // i.e., we don't want to allow\n@@ -1583,51 +1583,34 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         field_ident: Ident,\n         base: &'tcx hir::Expr<'tcx>,\n-        expr: &'tcx hir::Expr<'tcx>,\n-        def_id: DefId,\n+        ty: Ty<'tcx>,\n     ) {\n-        let param_env = self.tcx().param_env(def_id);\n-        let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n-        // Future::Output\n-        let item_def_id =\n-            self.tcx.associated_items(future_trait).in_definition_order().next().unwrap().def_id;\n-\n-        let projection_ty = self.tcx.projection_ty_from_predicates((def_id, item_def_id));\n-        debug!(\"suggest_await_on_field_access: projection_ty={:?}\", projection_ty);\n-\n-        let cause = self.misc(expr.span);\n-        let mut selcx = SelectionContext::new(&self.infcx);\n-\n-        let mut obligations = vec![];\n-        if let Some(projection_ty) = projection_ty {\n-            let normalized_ty = rustc_trait_selection::traits::normalize_projection_type(\n-                &mut selcx,\n-                param_env,\n-                projection_ty,\n-                cause,\n-                0,\n-                &mut obligations,\n-            );\n-            debug!(\n-                \"suggest_await_on_field_access: normalized_ty={:?}, ty_kind={:?}\",\n-                self.resolve_vars_if_possible(&normalized_ty),\n-                normalized_ty.kind(),\n-            );\n-            if let ty::Adt(def, _) = normalized_ty.kind() {\n-                // no field access on enum type\n-                if !def.is_enum() {\n-                    if def.non_enum_variant().fields.iter().any(|field| field.ident == field_ident)\n-                    {\n-                        err.span_suggestion_verbose(\n-                            base.span.shrink_to_hi(),\n-                            \"consider awaiting before field access\",\n-                            \".await\".to_string(),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n+        let output_ty = match self.infcx.get_impl_future_output_ty(ty) {\n+            Some(output_ty) => self.resolve_vars_if_possible(&output_ty),\n+            _ => return,\n+        };\n+        let mut add_label = true;\n+        if let ty::Adt(def, _) = output_ty.kind() {\n+            // no field access on enum type\n+            if !def.is_enum() {\n+                if def.non_enum_variant().fields.iter().any(|field| field.ident == field_ident) {\n+                    add_label = false;\n+                    err.span_label(\n+                        field_ident.span,\n+                        \"field not available in `impl Future`, but it is available in its `Output`\",\n+                    );\n+                    err.span_suggestion_verbose(\n+                        base.span.shrink_to_hi(),\n+                        \"consider `await`ing on the `Future` and access the field of its `Output`\",\n+                        \".await\".to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n                 }\n             }\n         }\n+        if add_label {\n+            err.span_label(field_ident.span, &format!(\"field not found in `{}`\", ty));\n+        }\n     }\n \n     fn ban_nonexisting_field(\n@@ -1656,8 +1639,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::Param(param_ty) => {\n                 self.point_at_param_definition(&mut err, param_ty);\n             }\n-            ty::Opaque(def_id, _) => {\n-                self.suggest_await_on_field_access(&mut err, field, base, expr, def_id);\n+            ty::Opaque(_, _) => {\n+                self.suggest_await_on_field_access(&mut err, field, base, expr_t.peel_refs());\n             }\n             _ => {}\n         }"}, {"sha": "af552389de02491def93f0a9c6a247d11645aa21", "filename": "compiler/rustc_typeck/src/check/gather_locals.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgather_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgather_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgather_locals.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -6,15 +6,20 @@ use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKi\n use rustc_middle::ty::Ty;\n use rustc_span::Span;\n use rustc_trait_selection::traits;\n+use std::mem;\n \n pub(super) struct GatherLocalsVisitor<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     parent_id: hir::HirId,\n+    // parameters are special cases of patterns, but we want to handle them as\n+    // *distinct* cases. so track when we are hitting a pattern *within* an fn\n+    // parameter.\n+    outermost_fn_param_pat: bool,\n }\n \n impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx> {\n     pub(super) fn new(fcx: &'a FnCtxt<'a, 'tcx>, parent_id: hir::HirId) -> Self {\n-        Self { fcx, parent_id }\n+        Self { fcx, parent_id, outermost_fn_param_pat: false }\n     }\n \n     fn assign(&mut self, span: Span, nid: hir::HirId, ty_opt: Option<LocalTy<'tcx>>) -> Ty<'tcx> {\n@@ -88,13 +93,29 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n         intravisit::walk_local(self, local);\n     }\n \n+    fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n+        let old_outermost_fn_param_pat = mem::replace(&mut self.outermost_fn_param_pat, true);\n+        intravisit::walk_param(self, param);\n+        self.outermost_fn_param_pat = old_outermost_fn_param_pat;\n+    }\n+\n     // Add pattern bindings.\n     fn visit_pat(&mut self, p: &'tcx hir::Pat<'tcx>) {\n         if let PatKind::Binding(_, _, ident, _) = p.kind {\n             let var_ty = self.assign(p.span, p.hir_id, None);\n \n-            if !self.fcx.tcx.features().unsized_locals {\n-                self.fcx.require_type_is_sized(var_ty, p.span, traits::VariableType(p.hir_id));\n+            if self.outermost_fn_param_pat {\n+                if !self.fcx.tcx.features().unsized_fn_params {\n+                    self.fcx.require_type_is_sized(\n+                        var_ty,\n+                        p.span,\n+                        traits::SizedArgumentType(Some(p.span)),\n+                    );\n+                }\n+            } else {\n+                if !self.fcx.tcx.features().unsized_locals {\n+                    self.fcx.require_type_is_sized(var_ty, p.span, traits::VariableType(p.hir_id));\n+                }\n             }\n \n             debug!(\n@@ -104,7 +125,9 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n                 var_ty\n             );\n         }\n+        let old_outermost_fn_param_pat = mem::replace(&mut self.outermost_fn_param_pat, false);\n         intravisit::walk_pat(self, p);\n+        self.outermost_fn_param_pat = old_outermost_fn_param_pat;\n     }\n \n     // Don't descend into the bodies of nested closures."}, {"sha": "46afe4892dbd70866df0b0ab94a1623dd571bee0", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 13, "deletions": 41, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -21,7 +21,6 @@ use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{source_map, FileName, Span};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::Obligation;\n-use rustc_trait_selection::traits::SelectionContext;\n \n use std::cmp::Ordering;\n \n@@ -870,46 +869,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         call: &hir::Expr<'_>,\n         span: Span,\n     ) {\n-        if let ty::Opaque(def_id, _) = *ty.kind() {\n-            let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n-            // Future::Output\n-            let item_def_id = self\n-                .tcx\n-                .associated_items(future_trait)\n-                .in_definition_order()\n-                .next()\n-                .unwrap()\n-                .def_id;\n-\n-            let projection_ty = self.tcx.projection_ty_from_predicates((def_id, item_def_id));\n-            let cause = self.misc(span);\n-            let mut selcx = SelectionContext::new(&self.infcx);\n-            let mut obligations = vec![];\n-            if let Some(projection_ty) = projection_ty {\n-                let normalized_ty = rustc_trait_selection::traits::normalize_projection_type(\n-                    &mut selcx,\n-                    self.param_env,\n-                    projection_ty,\n-                    cause,\n-                    0,\n-                    &mut obligations,\n-                );\n-                debug!(\n-                    \"suggest_await_before_method: normalized_ty={:?}, ty_kind={:?}\",\n-                    self.resolve_vars_if_possible(&normalized_ty),\n-                    normalized_ty.kind(),\n-                );\n-                let method_exists = self.method_exists(item_name, normalized_ty, call.hir_id, true);\n-                debug!(\"suggest_await_before_method: is_method_exist={}\", method_exists);\n-                if method_exists {\n-                    err.span_suggestion_verbose(\n-                        span.shrink_to_lo(),\n-                        \"consider awaiting before this method call\",\n-                        \"await.\".to_string(),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-            }\n+        let output_ty = match self.infcx.get_impl_future_output_ty(ty) {\n+            Some(output_ty) => self.resolve_vars_if_possible(&output_ty),\n+            _ => return,\n+        };\n+        let method_exists = self.method_exists(item_name, output_ty, call.hir_id, true);\n+        debug!(\"suggest_await_before_method: is_method_exist={}\", method_exists);\n+        if method_exists {\n+            err.span_suggestion_verbose(\n+                span.shrink_to_lo(),\n+                \"consider `await`ing on the `Future` and calling the method on its `Output`\",\n+                \"await.\".to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n         }\n     }\n "}, {"sha": "136867d78f57319e063645963356ff9472299de1", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -2090,25 +2090,25 @@ fn const_evaluatable_predicates_of<'tcx>(\n     if let hir::Node::Item(item) = node {\n         if let hir::ItemKind::Impl { ref of_trait, ref self_ty, .. } = item.kind {\n             if let Some(of_trait) = of_trait {\n-                warn!(\"const_evaluatable_predicates_of({:?}): visit impl trait_ref\", def_id);\n+                debug!(\"const_evaluatable_predicates_of({:?}): visit impl trait_ref\", def_id);\n                 collector.visit_trait_ref(of_trait);\n             }\n \n-            warn!(\"const_evaluatable_predicates_of({:?}): visit_self_ty\", def_id);\n+            debug!(\"const_evaluatable_predicates_of({:?}): visit_self_ty\", def_id);\n             collector.visit_ty(self_ty);\n         }\n     }\n \n     if let Some(generics) = node.generics() {\n-        warn!(\"const_evaluatable_predicates_of({:?}): visit_generics\", def_id);\n+        debug!(\"const_evaluatable_predicates_of({:?}): visit_generics\", def_id);\n         collector.visit_generics(generics);\n     }\n \n     if let Some(fn_sig) = tcx.hir().fn_sig_by_hir_id(hir_id) {\n-        warn!(\"const_evaluatable_predicates_of({:?}): visit_fn_decl\", def_id);\n+        debug!(\"const_evaluatable_predicates_of({:?}): visit_fn_decl\", def_id);\n         collector.visit_fn_decl(fn_sig.decl);\n     }\n-    warn!(\"const_evaluatable_predicates_of({:?}) = {:?}\", def_id, collector.preds);\n+    debug!(\"const_evaluatable_predicates_of({:?}) = {:?}\", def_id, collector.preds);\n \n     collector.preds\n }"}, {"sha": "405667e0b2aa6735d43e17f8cbe3ab40ff291665", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -130,7 +130,8 @@\n #![feature(unicode_internals)]\n #![feature(unsafe_block_in_unsafe_fn)]\n #![feature(unsize)]\n-#![feature(unsized_locals)]\n+#![cfg_attr(not(bootstrap), feature(unsized_fn_params))]\n+#![cfg_attr(bootstrap, feature(unsized_locals))]\n #![feature(allocator_internals)]\n #![feature(slice_partition_dedup)]\n #![feature(maybe_uninit_extra, maybe_uninit_slice, maybe_uninit_uninit_array)]"}, {"sha": "b89ec93834fcc7232df1850e7338a31ea53001dd", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -132,7 +132,8 @@\n #![feature(transparent_unions)]\n #![feature(try_blocks)]\n #![feature(unboxed_closures)]\n-#![feature(unsized_locals)]\n+#![cfg_attr(not(bootstrap), feature(unsized_fn_params))]\n+#![cfg_attr(bootstrap, feature(unsized_locals))]\n #![cfg_attr(bootstrap, feature(untagged_unions))]\n #![feature(unwind_attributes)]\n #![feature(variant_count)]"}, {"sha": "d716b1d51dcf7a6e4cd6c6641733cadbfa8abcb4", "filename": "src/doc/unstable-book/src/language-features/unsized-locals.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-locals.md", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-locals.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-locals.md?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -11,7 +11,8 @@ This implements [RFC1909]. When turned on, you can have unsized arguments and lo\n [RFC1909]: https://github.com/rust-lang/rfcs/blob/master/text/1909-unsized-rvalues.md\n \n ```rust\n-#![feature(unsized_locals)]\n+#![allow(incomplete_features)]\n+#![feature(unsized_locals, unsized_fn_params)]\n \n use std::any::Any;\n \n@@ -85,7 +86,7 @@ fn main() {\n With this feature, you can have by-value `self` arguments without `Self: Sized` bounds.\n \n ```rust\n-#![feature(unsized_locals)]\n+#![feature(unsized_fn_params)]\n \n trait Foo {\n     fn foo(self) {}\n@@ -102,7 +103,7 @@ fn main() {\n And `Foo` will also be object-safe.\n \n ```rust\n-#![feature(unsized_locals)]\n+#![feature(unsized_fn_params)]\n \n trait Foo {\n     fn foo(self) {}"}, {"sha": "a7b9052617f0c7b95e25d39bef32814b06304510", "filename": "src/test/run-pass-valgrind/unsized-locals/long-live-the-unsized-temporary.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Frun-pass-valgrind%2Funsized-locals%2Flong-live-the-unsized-temporary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Frun-pass-valgrind%2Funsized-locals%2Flong-live-the-unsized-temporary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Funsized-locals%2Flong-live-the-unsized-temporary.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,4 +1,5 @@\n-#![feature(unsized_locals)]\n+#![allow(incomplete_features)]\n+#![feature(unsized_locals, unsized_fn_params)]\n \n use std::fmt;\n \n@@ -45,11 +46,7 @@ fn main() {\n \n     {\n         let x: fmt::Display = *gen_foo();\n-        let x = if true {\n-            x\n-        } else {\n-            *gen_foo()\n-        };\n+        let x = if true { x } else { *gen_foo() };\n         foo(x);\n     }\n }"}, {"sha": "a1a20f9568178f968799ebfc0c2936bf0f6b86fb", "filename": "src/test/ui/ast-json/issue-78398-foreign-ice.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fast-json%2Fissue-78398-foreign-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fast-json%2Fissue-78398-foreign-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fissue-78398-foreign-ice.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -0,0 +1,18 @@\n+// Regression test for issue #78398\n+// Tests that we don't ICE when trying to print the AST json\n+// when we have capturd tokens for a foreign item\n+\n+// check-pass\n+// compile-flags: -Zast-json\n+\n+fn main() {}\n+\n+macro_rules! mac_extern {\n+    ($i:item) => {\n+        extern \"C\" { $i }\n+    }\n+}\n+\n+mac_extern! {\n+    fn foo();\n+}"}, {"sha": "f1d0e44e9fc8c784254510e2ad3c72924a4f29b3", "filename": "src/test/ui/ast-json/issue-78398-foreign-ice.stdout", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fast-json%2Fissue-78398-foreign-ice.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fast-json%2Fissue-78398-foreign-ice.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fissue-78398-foreign-ice.stdout?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -0,0 +1 @@\n+{\"module\":{\"inner\":{\"lo\":192,\"hi\":315},\"unsafety\":\"No\",\"items\":[{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"prelude_import\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":3,\"args\":null}],\"tokens\":null},\"args\":\"Empty\",\"tokens\":null}]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null}],\"id\":4,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"Use\",\"fields\":[{\"prefix\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"{{root}}\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":5,\"args\":null},{\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":6,\"args\":null},{\"ident\":{\"name\":\"prelude\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":7,\"args\":null},{\"ident\":{\"name\":\"v1\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":8,\"args\":null}],\"tokens\":null},\"kind\":\"Glob\",\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"macro_use\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":9,\"args\":null}],\"tokens\":null},\"args\":\"Empty\",\"tokens\":null}]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null}],\"id\":10,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null},{\"attrs\":[],\"id\":11,\"span\":{\"lo\":192,\"hi\":204},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":192,\"hi\":192},\"tokens\":null},\"ident\":{\"name\":\"main\",\"span\":{\"lo\":195,\"hi\":199}},\"kind\":{\"variant\":\"Fn\",\"fields\":[\"Final\",{\"header\":{\"unsafety\":\"No\",\"asyncness\":\"No\",\"constness\":\"No\",\"ext\":\"None\"},\"decl\":{\"inputs\":[],\"output\":{\"variant\":\"Default\",\"fields\":[{\"lo\":202,\"hi\":202}]}},\"span\":{\"lo\":192,\"hi\":201}},{\"params\":[],\"where_clause\":{\"has_where_token\":false,\"predicates\":[],\"span\":{\"lo\":201,\"hi\":201}},\"span\":{\"lo\":199,\"hi\":199}},{\"stmts\":[],\"id\":12,\"rules\":\"Default\",\"span\":{\"lo\":202,\"hi\":204},\"tokens\":null}]},\"tokens\":null},{\"attrs\":[],\"id\":13,\"span\":{\"lo\":206,\"hi\":284},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":206,\"hi\":206},\"tokens\":null},\"ident\":{\"name\":\"mac_extern\",\"span\":{\"lo\":219,\"hi\":229}},\"kind\":{\"variant\":\"MacroDef\",\"fields\":[{\"body\":{\"variant\":\"Delimited\",\"fields\":[{\"open\":{\"lo\":230,\"hi\":231},\"close\":{\"lo\":283,\"hi\":284}},\"Brace\",{\"0\":[[{\"variant\":\"Delimited\",\"fields\":[{\"open\":{\"lo\":236,\"hi\":237},\"close\":{\"lo\":244,\"hi\":245}},\"Paren\",{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Dollar\",\"span\":{\"lo\":237,\"hi\":238}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"i\",false]},\"span\":{\"lo\":238,\"hi\":239}}]},\"Joint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Colon\",\"span\":{\"lo\":239,\"hi\":240}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"item\",false]},\"span\":{\"lo\":240,\"hi\":244}}]},\"Alone\"]]}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"FatArrow\",\"span\":{\"lo\":246,\"hi\":248}}]},\"Alone\"],[{\"variant\":\"Delimited\",\"fields\":[{\"open\":{\"lo\":249,\"hi\":250},\"close\":{\"lo\":281,\"hi\":282}},\"Brace\",{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"extern\",false]},\"span\":{\"lo\":259,\"hi\":265}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"C\",\"suffix\":null}]},\"span\":{\"lo\":266,\"hi\":269}}]},\"Alone\"],[{\"variant\":\"Delimited\",\"fields\":[{\"open\":{\"lo\":270,\"hi\":271},\"close\":{\"lo\":275,\"hi\":276}},\"Brace\",{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Dollar\",\"span\":{\"lo\":272,\"hi\":273}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"i\",false]},\"span\":{\"lo\":273,\"hi\":274}}]},\"Alone\"]]}]},\"Alone\"]]}]},\"Alone\"]]}]},\"macro_rules\":true}]},\"tokens\":null},{\"attrs\":[],\"id\":14,\"span\":{\"lo\":259,\"hi\":276},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":259,\"hi\":259},\"tokens\":null},\"ident\":{\"name\":\"\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ForeignMod\",\"fields\":[{\"unsafety\":\"No\",\"abi\":{\"style\":\"Cooked\",\"symbol\":\"C\",\"suffix\":null,\"span\":{\"lo\":266,\"hi\":269},\"symbol_unescaped\":\"C\"},\"items\":[{\"attrs\":[],\"id\":15,\"span\":{\"lo\":304,\"hi\":313},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":304,\"hi\":304},\"tokens\":null},\"ident\":{\"name\":\"foo\",\"span\":{\"lo\":307,\"hi\":310}},\"kind\":{\"variant\":\"Fn\",\"fields\":[\"Final\",{\"header\":{\"unsafety\":\"No\",\"asyncness\":\"No\",\"constness\":\"No\",\"ext\":\"None\"},\"decl\":{\"inputs\":[],\"output\":{\"variant\":\"Default\",\"fields\":[{\"lo\":312,\"hi\":312}]}},\"span\":{\"lo\":304,\"hi\":313}},{\"params\":[],\"where_clause\":{\"has_where_token\":false,\"predicates\":[],\"span\":{\"lo\":312,\"hi\":312}},\"span\":{\"lo\":310,\"hi\":310}},null]},\"tokens\":null}]}]},\"tokens\":null}],\"inline\":true},\"attrs\":[],\"span\":{\"lo\":192,\"hi\":315},\"proc_macros\":[]}"}, {"sha": "8a7b166cb15bd4c0a9a087ce0fc1e8e3e2bb5de7", "filename": "src/test/ui/async-await/issue-61076.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -40,6 +40,14 @@ async fn foo() -> Result<(), ()> {\n \n async fn bar() -> Result<(), ()> {\n     foo()?; //~ ERROR the `?` operator can only be applied to values that implement `Try`\n+    //~^ NOTE the `?` operator cannot be applied to type `impl Future`\n+    //~| HELP the trait `Try` is not implemented for `impl Future`\n+    //~| NOTE required by `into_result`\n+    //~| HELP consider `await`ing on the `Future`\n+    //~| NOTE in this expansion of desugaring of operator `?`\n+    //~| NOTE in this expansion of desugaring of operator `?`\n+    //~| NOTE in this expansion of desugaring of operator `?`\n+    //~| NOTE in this expansion of desugaring of operator `?`\n     Ok(())\n }\n \n@@ -48,25 +56,42 @@ async fn struct_() -> Struct {\n }\n \n async fn tuple() -> Tuple {\n+    //~^ NOTE the `Output` of this `async fn`'s expected opaque type\n     Tuple(1i32)\n }\n \n async fn baz() -> Result<(), ()> {\n     let t = T;\n     t?; //~ ERROR the `?` operator can only be applied to values that implement `Try`\n+    //~^ NOTE the `?` operator cannot be applied to type `T`\n+    //~| HELP the trait `Try` is not implemented for `T`\n+    //~| NOTE required by `into_result`\n+    //~| HELP consider `await`ing on the `Future`\n+    //~| NOTE in this expansion of desugaring of operator `?`\n+    //~| NOTE in this expansion of desugaring of operator `?`\n+    //~| NOTE in this expansion of desugaring of operator `?`\n+    //~| NOTE in this expansion of desugaring of operator `?`\n+\n \n     let _: i32 = tuple().0; //~ ERROR no field `0`\n+    //~^ HELP consider `await`ing on the `Future`\n+    //~| NOTE field not available in `impl Future`\n \n     let _: i32 = struct_().a; //~ ERROR no field `a`\n+    //~^ HELP consider `await`ing on the `Future`\n+    //~| NOTE field not available in `impl Future`\n \n     struct_().method(); //~ ERROR no method named\n-\n+    //~^ NOTE method not found in `impl Future`\n+    //~| HELP consider `await`ing on the `Future`\n     Ok(())\n }\n \n async fn match_() {\n-    match tuple() {\n+    match tuple() { //~ HELP consider `await`ing on the `Future`\n         Tuple(_) => {} //~ ERROR mismatched types\n+        //~^ NOTE expected opaque type, found struct `Tuple`\n+        //~| NOTE expected opaque type `impl Future`\n     }\n }\n "}, {"sha": "db6dc3ea00a8d9077d9839700847312e97ca52af", "filename": "src/test/ui/async-await/issue-61076.stderr", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -12,7 +12,7 @@ LL |     foo().await?;\n    |          ^^^^^^\n \n error[E0277]: the `?` operator can only be applied to values that implement `Try`\n-  --> $DIR/issue-61076.rs:56:5\n+  --> $DIR/issue-61076.rs:65:5\n    |\n LL |     t?;\n    |     ^^ the `?` operator cannot be applied to type `T`\n@@ -25,25 +25,40 @@ LL |     t.await?;\n    |      ^^^^^^\n \n error[E0609]: no field `0` on type `impl Future`\n-  --> $DIR/issue-61076.rs:58:26\n+  --> $DIR/issue-61076.rs:76:26\n    |\n LL |     let _: i32 = tuple().0;\n-   |                          ^\n+   |                          ^ field not available in `impl Future`, but it is available in its `Output`\n+   |\n+help: consider `await`ing on the `Future` and access the field of its `Output`\n+   |\n+LL |     let _: i32 = tuple().await.0;\n+   |                         ^^^^^^\n \n error[E0609]: no field `a` on type `impl Future`\n-  --> $DIR/issue-61076.rs:60:28\n+  --> $DIR/issue-61076.rs:80:28\n    |\n LL |     let _: i32 = struct_().a;\n-   |                            ^\n+   |                            ^ field not available in `impl Future`, but it is available in its `Output`\n+   |\n+help: consider `await`ing on the `Future` and access the field of its `Output`\n+   |\n+LL |     let _: i32 = struct_().await.a;\n+   |                           ^^^^^^\n \n error[E0599]: no method named `method` found for opaque type `impl Future` in the current scope\n-  --> $DIR/issue-61076.rs:62:15\n+  --> $DIR/issue-61076.rs:84:15\n    |\n LL |     struct_().method();\n    |               ^^^^^^ method not found in `impl Future`\n+   |\n+help: consider `await`ing on the `Future` and calling the method on its `Output`\n+   |\n+LL |     struct_().await.method();\n+   |               ^^^^^^\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-61076.rs:69:9\n+  --> $DIR/issue-61076.rs:92:9\n    |\n LL | async fn tuple() -> Tuple {\n    |                     ----- the `Output` of this `async fn`'s expected opaque type"}, {"sha": "0f90a4c336c57e5b136ecd7c069a9c33777ed7b2", "filename": "src/test/ui/async-await/issue-72590-type-error-sized.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fasync-await%2Fissue-72590-type-error-sized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fasync-await%2Fissue-72590-type-error-sized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-72590-type-error-sized.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -18,7 +18,7 @@ LL |     async fn frob(self) {}\n    |\n    = help: within `Foo`, the trait `Sized` is not implemented for `str`\n    = note: required because it appears within the type `Foo`\n-   = help: unsized locals are gated as an unstable feature\n+   = help: unsized fn params are gated as an unstable feature\n help: function arguments must have a statically known size, borrowed types always have a known size\n    |\n LL |     async fn frob(&self) {}"}, {"sha": "72ef5b3b962c734d5386c07b0796aca96c57007b", "filename": "src/test/ui/closures/issue-41366.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fclosures%2Fissue-41366.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fclosures%2Fissue-41366.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-41366.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -16,7 +16,7 @@ LL |     (&|_| ()) as &dyn for<'x> Fn(<u32 as T<'x>>::V);\n    |        ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `<u32 as T<'_>>::V`\n-   = help: unsized locals are gated as an unstable feature\n+   = help: unsized fn params are gated as an unstable feature\n help: consider further restricting the associated type\n    |\n LL | fn main() where <u32 as T<'_>>::V: Sized {"}, {"sha": "5be4b41784c270dbd580373ee531709e8593e37e", "filename": "src/test/ui/const-generics/const_evaluatable_checked/object-safety-err-ret.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-ret.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -0,0 +1,21 @@\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+\n+const fn bar<T: ?Sized>() -> usize { 7 }\n+\n+trait Foo {\n+    fn test(&self) -> [u8; bar::<Self>()];\n+}\n+\n+impl Foo for () {\n+    fn test(&self) -> [u8; bar::<Self>()] {\n+        [0; bar::<Self>()]\n+    }\n+}\n+\n+fn use_dyn(v: &dyn Foo) { //~ERROR the trait `Foo` cannot be made into an object\n+    v.test();\n+}\n+\n+fn main() {}"}, {"sha": "e0e6029252c00b3471084c478d037e1e4e86f45e", "filename": "src/test/ui/const-generics/const_evaluatable_checked/object-safety-err-ret.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-ret.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-ret.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-ret.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -0,0 +1,18 @@\n+error[E0038]: the trait `Foo` cannot be made into an object\n+  --> $DIR/object-safety-err-ret.rs:17:15\n+   |\n+LL | fn use_dyn(v: &dyn Foo) {\n+   |               ^^^^^^^^ `Foo` cannot be made into an object\n+   |\n+   = help: consider moving `test` to another trait\n+note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n+  --> $DIR/object-safety-err-ret.rs:8:23\n+   |\n+LL | trait Foo {\n+   |       --- this trait cannot be made into an object...\n+LL |     fn test(&self) -> [u8; bar::<Self>()];\n+   |                       ^^^^^^^^^^^^^^^^^^^ ...because method `test` references the `Self` type in its return type\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0038`."}, {"sha": "5fbd4a5fa2e6434dee7d0d115bcbc6fd587ff789", "filename": "src/test/ui/const-generics/const_evaluatable_checked/object-safety-err-where-bounds.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-where-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-where-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-where-bounds.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -0,0 +1,22 @@\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+#![deny(where_clauses_object_safety)]\n+\n+\n+const fn bar<T: ?Sized>() -> usize { 7 }\n+\n+trait Foo {\n+    fn test(&self) where [u8; bar::<Self>()]: Sized;\n+    //~^ ERROR the trait `Foo` cannot be made into an object\n+    //~| WARN this was previously accepted by the compiler but is being phased out\n+}\n+\n+impl Foo for () {\n+    fn test(&self) where [u8; bar::<Self>()]: Sized {}\n+}\n+\n+fn use_dyn(v: &dyn Foo) {\n+    v.test();\n+}\n+\n+fn main() {}"}, {"sha": "45c7d835f339a9321a2f2656939e45c5f8b6de6c", "filename": "src/test/ui/const-generics/const_evaluatable_checked/object-safety-err-where-bounds.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-where-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-where-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-where-bounds.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -0,0 +1,24 @@\n+error: the trait `Foo` cannot be made into an object\n+  --> $DIR/object-safety-err-where-bounds.rs:9:8\n+   |\n+LL |     fn test(&self) where [u8; bar::<Self>()]: Sized;\n+   |        ^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/object-safety-err-where-bounds.rs:3:9\n+   |\n+LL | #![deny(where_clauses_object_safety)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #51443 <https://github.com/rust-lang/rust/issues/51443>\n+note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n+  --> $DIR/object-safety-err-where-bounds.rs:9:8\n+   |\n+LL | trait Foo {\n+   |       --- this trait cannot be made into an object...\n+LL |     fn test(&self) where [u8; bar::<Self>()]: Sized;\n+   |        ^^^^ ...because method `test` references the `Self` type in its `where` clause\n+   = help: consider moving `test` to another trait\n+\n+error: aborting due to previous error\n+"}, {"sha": "9a95908d59d0d1a56d681dea43558f7be52e11f7", "filename": "src/test/ui/const-generics/const_evaluatable_checked/object-safety-ok-infer-err.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-ok-infer-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-ok-infer-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-ok-infer-err.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -0,0 +1,22 @@\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+trait Foo<const N: usize> {\n+    fn test(&self) -> [u8; N + 1];\n+}\n+\n+impl<const N: usize> Foo<N> for () {\n+    fn test(&self) -> [u8; N + 1] {\n+        [0; N + 1]\n+    }\n+}\n+\n+fn use_dyn<const N: usize>(v: &dyn Foo<N>) where [u8; N + 1]: Sized {\n+    assert_eq!(v.test(), [0; N + 1]);\n+}\n+\n+fn main() {\n+    // FIXME(const_evaluatable_checked): Improve the error message here.\n+    use_dyn(&());\n+    //~^ ERROR type annotations needed\n+}"}, {"sha": "dd2c11e42c5d2a2f4b7c783a1c8500e70a0ef030", "filename": "src/test/ui/const-generics/const_evaluatable_checked/object-safety-ok-infer-err.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-ok-infer-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-ok-infer-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-ok-infer-err.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -0,0 +1,12 @@\n+error[E0284]: type annotations needed: cannot satisfy `the constant `use_dyn::<{_: usize}>::{constant#0}` can be evaluated`\n+  --> $DIR/object-safety-ok-infer-err.rs:20:5\n+   |\n+LL | fn use_dyn<const N: usize>(v: &dyn Foo<N>) where [u8; N + 1]: Sized {\n+   |                                                       ----- required by this bound in `use_dyn`\n+...\n+LL |     use_dyn(&());\n+   |     ^^^^^^^ cannot satisfy `the constant `use_dyn::<{_: usize}>::{constant#0}` can be evaluated`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0284`."}, {"sha": "ae78b7936a289396962203a9ab202ce66be6dec1", "filename": "src/test/ui/const-generics/const_evaluatable_checked/object-safety-ok.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-ok.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -0,0 +1,21 @@\n+// run-pass\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+trait Foo<const N: usize> {\n+    fn test(&self) -> [u8; N + 1];\n+}\n+\n+impl<const N: usize> Foo<N> for () {\n+    fn test(&self) -> [u8; N + 1] {\n+        [0; N + 1]\n+    }\n+}\n+\n+fn use_dyn<const N: usize>(v: &dyn Foo<N>) where [u8; N + 1]: Sized {\n+    assert_eq!(v.test(), [0; N + 1]);\n+}\n+\n+fn main() {\n+    use_dyn::<3>(&());\n+}"}, {"sha": "3370666cc5cd0450a21dcfc90c30b048f07fff95", "filename": "src/test/ui/const-generics/min_const_generics/const_fn_in_generics.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst_fn_in_generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst_fn_in_generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst_fn_in_generics.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -0,0 +1,17 @@\n+// run-pass\n+\n+#![feature(min_const_generics)]\n+\n+const fn identity<const T: u32>() -> u32 { T }\n+\n+#[derive(Eq, PartialEq, Debug)]\n+pub struct ConstU32<const U: u32>;\n+\n+pub fn new() -> ConstU32<{ identity::<3>() }> {\n+  ConstU32::<{ identity::<3>() }>\n+}\n+\n+fn main() {\n+  let v = new();\n+  assert_eq!(v, ConstU32::<3>);\n+}"}, {"sha": "195414dbad9a2395ddce4654f5296c067ae418cb", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_err.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -13,7 +13,7 @@ unsafe impl Sync for Meh {}\n \n // the following will never be ok! no interior mut behind consts, because\n // all allocs interned here will be marked immutable.\n-const MUH: Meh = Meh { //~ ERROR: mutable memory (`UnsafeCell`) is not allowed in constant\n+const MUH: Meh = Meh { //~ ERROR: it is undefined behavior to use this value\n     x: &UnsafeCell::new(42),\n };\n \n@@ -24,11 +24,11 @@ unsafe impl Sync for Synced {}\n \n // Make sure we also catch this behind a type-erased `dyn Trait` reference.\n const SNEAKY: &dyn Sync = &Synced { x: UnsafeCell::new(42) };\n-//~^ ERROR: mutable memory (`UnsafeCell`) is not allowed in constant\n+//~^ ERROR: it is undefined behavior to use this value\n \n // Make sure we also catch mutable references.\n const BLUNT: &mut i32 = &mut 42;\n-//~^ ERROR: mutable memory (`&mut`) is not allowed in constant\n+//~^ ERROR: it is undefined behavior to use this value\n \n fn main() {\n     unsafe {"}, {"sha": "0c206dd51aaabe2ea2f38fc7134285347fdd4279", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_err.stderr", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,22 +1,28 @@\n-error: mutable memory (`UnsafeCell`) is not allowed in constant\n+error[E0080]: it is undefined behavior to use this value\n   --> $DIR/mutable_references_err.rs:16:1\n    |\n LL | / const MUH: Meh = Meh {\n LL | |     x: &UnsafeCell::new(42),\n LL | | };\n-   | |__^\n+   | |__^ type validation failed: encountered `UnsafeCell` in a `const` at .x.<deref>\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n-error: mutable memory (`UnsafeCell`) is not allowed in constant\n+error[E0080]: it is undefined behavior to use this value\n   --> $DIR/mutable_references_err.rs:26:1\n    |\n LL | const SNEAKY: &dyn Sync = &Synced { x: UnsafeCell::new(42) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered `UnsafeCell` in a `const` at .<deref>.<dyn-downcast>.x\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n-error: mutable memory (`&mut`) is not allowed in constant\n+error[E0080]: it is undefined behavior to use this value\n   --> $DIR/mutable_references_err.rs:30:1\n    |\n LL | const BLUNT: &mut i32 = &mut 42;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered mutable reference in a `const`\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n warning: skipping const checks\n    |\n@@ -38,3 +44,4 @@ LL | const BLUNT: &mut i32 = &mut 42;\n \n error: aborting due to 3 previous errors; 1 warning emitted\n \n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "e0f5776424e0951a2b37b39ae94fc0def7bd2410", "filename": "src/test/ui/error-codes/E0161.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Ferror-codes%2FE0161.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Ferror-codes%2FE0161.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0161.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -9,13 +9,13 @@\n //[zflagsul]compile-flags: -Z borrowck=migrate\n //[editionul]edition:2018\n \n+#![allow(incomplete_features)]\n #![cfg_attr(nll, feature(nll))]\n #![cfg_attr(nllul, feature(nll))]\n #![cfg_attr(migrateul, feature(unsized_locals))]\n #![cfg_attr(zflagsul, feature(unsized_locals))]\n #![cfg_attr(nllul, feature(unsized_locals))]\n #![cfg_attr(editionul, feature(unsized_locals))]\n-\n #![feature(box_syntax)]\n \n fn foo(x: Box<[i32]>) {"}, {"sha": "647e0c7d76ff2da1505c07dadbdca668a07a49b1", "filename": "src/test/ui/error-codes/E0277.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Ferror-codes%2FE0277.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Ferror-codes%2FE0277.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0277.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -6,11 +6,11 @@ LL | fn f(p: Path) { }\n    |\n    = help: within `Path`, the trait `Sized` is not implemented for `[u8]`\n    = note: required because it appears within the type `Path`\n-   = help: unsized locals are gated as an unstable feature\n+   = help: unsized fn params are gated as an unstable feature\n help: function arguments must have a statically known size, borrowed types always have a known size\n    |\n-LL | fn f(p: &Path) { }\n-   |         ^\n+LL | fn f(&p: Path) { }\n+   |      ^\n \n error[E0277]: the trait bound `i32: Foo` is not satisfied\n   --> $DIR/E0277.rs:17:15"}, {"sha": "9b868ed7a9e93868b712ac46ca19482e99839947", "filename": "src/test/ui/feature-gates/feature-gate-unsized_fn_params.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsized_fn_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsized_fn_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsized_fn_params.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -0,0 +1,26 @@\n+#[repr(align(256))]\n+#[allow(dead_code)]\n+struct A {\n+    v: u8,\n+}\n+\n+trait Foo {\n+    fn foo(&self);\n+}\n+\n+impl Foo for A {\n+    fn foo(&self) {\n+        assert_eq!(self as *const A as usize % 256, 0);\n+    }\n+}\n+\n+fn foo(x: dyn Foo) {\n+    //~^ ERROR [E0277]\n+    x.foo()\n+}\n+\n+fn main() {\n+    let x: Box<dyn Foo> = Box::new(A { v: 22 });\n+    foo(*x);\n+    //~^ ERROR [E0277]\n+}"}, {"sha": "71acbb174ac667b82223581fbd48ddf0eccd620e", "filename": "src/test/ui/feature-gates/feature-gate-unsized_fn_params.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsized_fn_params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsized_fn_params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsized_fn_params.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -0,0 +1,26 @@\n+error[E0277]: the size for values of type `(dyn Foo + 'static)` cannot be known at compilation time\n+  --> $DIR/feature-gate-unsized_fn_params.rs:17:8\n+   |\n+LL | fn foo(x: dyn Foo) {\n+   |        ^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `Sized` is not implemented for `(dyn Foo + 'static)`\n+   = help: unsized fn params are gated as an unstable feature\n+help: function arguments must have a statically known size, borrowed types always have a known size\n+   |\n+LL | fn foo(&x: dyn Foo) {\n+   |        ^\n+\n+error[E0277]: the size for values of type `(dyn Foo + 'static)` cannot be known at compilation time\n+  --> $DIR/feature-gate-unsized_fn_params.rs:24:5\n+   |\n+LL |     foo(*x);\n+   |     ^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `Sized` is not implemented for `(dyn Foo + 'static)`\n+   = note: all function arguments must have a statically known size\n+   = help: unsized fn params are gated as an unstable feature\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "522542208724bd10071e9bdcff591130998040a5", "filename": "src/test/ui/feature-gates/feature-gate-unsized_locals.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsized_locals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsized_locals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsized_locals.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -5,11 +5,11 @@ LL | fn f(f: dyn FnOnce()) {}\n    |      ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `(dyn FnOnce() + 'static)`\n-   = help: unsized locals are gated as an unstable feature\n+   = help: unsized fn params are gated as an unstable feature\n help: function arguments must have a statically known size, borrowed types always have a known size\n    |\n-LL | fn f(f: &dyn FnOnce()) {}\n-   |         ^\n+LL | fn f(&f: dyn FnOnce()) {}\n+   |      ^\n \n error: aborting due to previous error\n "}, {"sha": "cedfd1cf2dcc961db02fb79e10cb50bde7a6c022", "filename": "src/test/ui/fn/dyn-fn-alignment.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Ffn%2Fdyn-fn-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Ffn%2Fdyn-fn-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffn%2Fdyn-fn-alignment.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,6 +1,5 @@\n // run-pass\n \n-#![feature(unsized_locals)]\n #![allow(dead_code)]\n #[repr(align(256))]\n struct A {"}, {"sha": "69817f10c9f32c9c45663cc3581faec77601073b", "filename": "src/test/ui/issues/issue-17651.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-17651.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-17651.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17651.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -15,7 +15,7 @@ LL |     (|| Box::new(*(&[0][..])))();\n    |\n    = help: the trait `Sized` is not implemented for `[{integer}]`\n    = note: all function arguments must have a statically known size\n-   = help: unsized locals are gated as an unstable feature\n+   = help: unsized fn params are gated as an unstable feature\n \n error: aborting due to 2 previous errors\n "}, {"sha": "021a08696de2cc831035935513c6c7656323d871", "filename": "src/test/ui/issues/issue-27078.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-27078.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-27078.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27078.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -4,7 +4,7 @@ error[E0277]: the size for values of type `Self` cannot be known at compilation\n LL |     fn foo(self) -> &'static i32 {\n    |            ^^^^ doesn't have a size known at compile-time\n    |\n-   = help: unsized locals are gated as an unstable feature\n+   = help: unsized fn params are gated as an unstable feature\n help: consider further restricting `Self`\n    |\n LL |     fn foo(self) -> &'static i32 where Self: Sized {"}, {"sha": "79f5db650d9dcb76e89b0917aeae621e0e6a45bf", "filename": "src/test/ui/issues/issue-30355.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-30355.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-30355.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-30355.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -6,7 +6,7 @@ LL |     &X(*Y)\n    |\n    = help: the trait `Sized` is not implemented for `[u8]`\n    = note: all function arguments must have a statically known size\n-   = help: unsized locals are gated as an unstable feature\n+   = help: unsized fn params are gated as an unstable feature\n \n error: aborting due to previous error\n "}, {"sha": "96bd93af5140526ae44c6b6feaad63311397f37b", "filename": "src/test/ui/issues/issue-38412.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-38412.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-38412.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-38412.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     let Box(a) = loop { };\n-    //~^ ERROR expected tuple struct or tuple variant, found struct `Box`\n+    //~^ ERROR cannot match against a tuple struct which contains private fields\n \n     // (The below is a trick to allow compiler to infer a type for\n     // variable `a` without attempting to ascribe a type to the"}, {"sha": "610696f84d5f07934451a44013d07e32710d400b", "filename": "src/test/ui/issues/issue-38412.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-38412.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-38412.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-38412.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,4 +1,4 @@\n-error[E0532]: expected tuple struct or tuple variant, found struct `Box`\n+error[E0532]: cannot match against a tuple struct which contains private fields\n   --> $DIR/issue-38412.rs:2:9\n    |\n LL |     let Box(a) = loop { };"}, {"sha": "f76063fc55872ceefde07464b6e233aabde2a335", "filename": "src/test/ui/issues/issue-38954.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-38954.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-38954.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-38954.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -5,7 +5,7 @@ LL | fn _test(ref _p: str) {}\n    |          ^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\n-   = help: unsized locals are gated as an unstable feature\n+   = help: unsized fn params are gated as an unstable feature\n help: function arguments must have a statically known size, borrowed types always have a known size\n    |\n LL | fn _test(ref _p: &str) {}"}, {"sha": "46b5aa334ca6f2fb9dcc7153d6a94500c957ec15", "filename": "src/test/ui/issues/issue-39616.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-39616.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-39616.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39616.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,4 +1,3 @@\n fn foo(a: [0; 1]) {} //~ ERROR expected type, found `0`\n-//~| ERROR expected `;` or `{`, found `]`\n \n fn main() {}"}, {"sha": "393d1f2e2ce676532abb776d2f7237336537e927", "filename": "src/test/ui/issues/issue-39616.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-39616.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-39616.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39616.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -4,11 +4,5 @@ error: expected type, found `0`\n LL | fn foo(a: [0; 1]) {}\n    |            ^ expected type\n \n-error: expected `;` or `{`, found `]`\n-  --> $DIR/issue-39616.rs:1:16\n-   |\n-LL | fn foo(a: [0; 1]) {}\n-   |                ^ expected `;` or `{`\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "8b37e5e9774e58b69e27ea2e5e5f2cf1375d6259", "filename": "src/test/ui/issues/issue-41229-ref-str.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-41229-ref-str.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-41229-ref-str.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-41229-ref-str.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -5,7 +5,7 @@ LL | pub fn example(ref s: str) {}\n    |                ^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\n-   = help: unsized locals are gated as an unstable feature\n+   = help: unsized fn params are gated as an unstable feature\n help: function arguments must have a statically known size, borrowed types always have a known size\n    |\n LL | pub fn example(ref s: &str) {}"}, {"sha": "f69c2a9925de7bd922221ea56208efa27ce8d55d", "filename": "src/test/ui/issues/issue-42312.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-42312.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-42312.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-42312.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -5,7 +5,7 @@ LL |     fn baz(_: Self::Target) where Self: Deref {}\n    |            ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `<Self as Deref>::Target`\n-   = help: unsized locals are gated as an unstable feature\n+   = help: unsized fn params are gated as an unstable feature\n help: consider further restricting the associated type\n    |\n LL |     fn baz(_: Self::Target) where Self: Deref, <Self as Deref>::Target: Sized {}\n@@ -22,7 +22,7 @@ LL | pub fn f(_: dyn ToString) {}\n    |          ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `(dyn ToString + 'static)`\n-   = help: unsized locals are gated as an unstable feature\n+   = help: unsized fn params are gated as an unstable feature\n help: function arguments must have a statically known size, borrowed types always have a known size\n    |\n LL | pub fn f(_: &dyn ToString) {}"}, {"sha": "a4404857a56af3dce60446293e32d6d5cae919f3", "filename": "src/test/ui/issues/issue-42944.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-42944.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-42944.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-42944.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -7,7 +7,7 @@ mod bar {\n \n     fn foo() {\n         Bx(());\n-        //~^ ERROR expected function, tuple struct or tuple variant, found struct `Bx` [E0423]\n+        //~^ ERROR cannot initialize a tuple struct which contains private fields [E0423]\n     }\n }\n "}, {"sha": "008492529d18c9de7d6ce66ba46542402b287955", "filename": "src/test/ui/issues/issue-42944.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-42944.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-42944.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-42944.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,8 +1,14 @@\n-error[E0423]: expected function, tuple struct or tuple variant, found struct `Bx`\n+error[E0423]: cannot initialize a tuple struct which contains private fields\n   --> $DIR/issue-42944.rs:9:9\n    |\n LL |         Bx(());\n-   |         ^^ constructor is not visible here due to private fields\n+   |         ^^\n+   |\n+note: constructor is not visible here due to private fields\n+  --> $DIR/issue-42944.rs:2:19\n+   |\n+LL |     pub struct Bx(());\n+   |                   ^^ private field\n \n error[E0425]: cannot find function, tuple struct or tuple variant `Bx` in this scope\n   --> $DIR/issue-42944.rs:16:9"}, {"sha": "5798733e04be03a86f4296db44e81daa545d0a8e", "filename": "src/test/ui/issues/issue-5883.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-5883.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-5883.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5883.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -5,11 +5,11 @@ LL | fn new_struct(r: dyn A + 'static)\n    |               ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `(dyn A + 'static)`\n-   = help: unsized locals are gated as an unstable feature\n+   = help: unsized fn params are gated as an unstable feature\n help: function arguments must have a statically known size, borrowed types always have a known size\n    |\n-LL | fn new_struct(r: &dyn A + 'static)\n-   |                  ^\n+LL | fn new_struct(&r: dyn A + 'static)\n+   |               ^\n \n error[E0277]: the size for values of type `(dyn A + 'static)` cannot be known at compilation time\n   --> $DIR/issue-5883.rs:8:8"}, {"sha": "332a3014416b57569985af36858c5b3b54f185a0", "filename": "src/test/ui/issues/issue-58856-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-58856-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-58856-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58856-1.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -2,7 +2,7 @@ impl A {\n     //~^ ERROR cannot find type `A` in this scope\n     fn b(self>\n     //~^ ERROR expected one of `)`, `,`, or `:`, found `>`\n-    //~| ERROR expected `;` or `{`, found `>`\n+    //~| ERROR expected one of `->`, `;`, `where`, or `{`, found `>`\n }\n \n fn main() {}"}, {"sha": "f1abb40ed7a739a4dde60dfa33edb4f330f0879d", "filename": "src/test/ui/issues/issue-58856-1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-58856-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-58856-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58856-1.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -6,14 +6,14 @@ LL |     fn b(self>\n    |         |\n    |         unclosed delimiter\n \n-error: expected `;` or `{`, found `>`\n+error: expected one of `->`, `;`, `where`, or `{`, found `>`\n   --> $DIR/issue-58856-1.rs:3:14\n    |\n LL | impl A {\n    |        - while parsing this item list starting here\n LL |\n LL |     fn b(self>\n-   |              ^ expected `;` or `{`\n+   |              ^ expected one of `->`, `;`, `where`, or `{`\n ...\n LL | }\n    | - the item list ends here"}, {"sha": "710039d79e77b2cd741664fdecb5f305e1443c41", "filename": "src/test/ui/issues/issue-75906.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-75906.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-75906.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-75906.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -0,0 +1,13 @@\n+mod m {\n+    pub struct Foo { x: u8 }\n+\n+    pub struct Bar(u8);\n+}\n+\n+use m::{Foo, Bar};\n+\n+fn main() {\n+    let x = Foo { x: 12 };\n+    let y = Bar(12);\n+    //~^ ERROR cannot initialize a tuple struct which contains private fields [E0423]\n+}"}, {"sha": "4c6a68646adc8b79f88d589220e2e9175acbacb5", "filename": "src/test/ui/issues/issue-75906.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-75906.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-75906.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-75906.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -0,0 +1,15 @@\n+error[E0423]: cannot initialize a tuple struct which contains private fields\n+  --> $DIR/issue-75906.rs:11:13\n+   |\n+LL |     let y = Bar(12);\n+   |             ^^^\n+   |\n+note: constructor is not visible here due to private fields\n+  --> $DIR/issue-75906.rs:4:20\n+   |\n+LL |     pub struct Bar(u8);\n+   |                    ^^ private field\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0423`."}, {"sha": "1534b6d07deb004e84794e632f3e68ef3cde3c39", "filename": "src/test/ui/issues/issue-75907.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-75907.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-75907.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-75907.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -13,6 +13,6 @@ use foo::{make_bar, Bar, Foo};\n \n fn main() {\n     let Bar(x, y, Foo(z)) = make_bar();\n-    //~^ ERROR expected tuple struct\n-    //~| ERROR expected tuple struct\n+    //~^ ERROR cannot match against a tuple struct which contains private fields\n+    //~| ERROR cannot match against a tuple struct which contains private fields\n }"}, {"sha": "2f89e31a31a1ef3966db23914db5b389d1a004c0", "filename": "src/test/ui/issues/issue-75907.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-75907.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-75907.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-75907.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,4 +1,4 @@\n-error[E0532]: expected tuple struct or tuple variant, found struct `Bar`\n+error[E0532]: cannot match against a tuple struct which contains private fields\n   --> $DIR/issue-75907.rs:15:9\n    |\n LL |     let Bar(x, y, Foo(z)) = make_bar();\n@@ -12,7 +12,7 @@ LL |     let Bar(x, y, Foo(z)) = make_bar();\n    |                |\n    |                private field\n \n-error[E0532]: expected tuple struct or tuple variant, found struct `Foo`\n+error[E0532]: cannot match against a tuple struct which contains private fields\n   --> $DIR/issue-75907.rs:15:19\n    |\n LL |     let Bar(x, y, Foo(z)) = make_bar();"}, {"sha": "a775845279eb8c5d90ed89d661d398b0b099c561", "filename": "src/test/ui/issues/issue-75907_b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-75907_b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-75907_b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-75907_b.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -7,5 +7,5 @@ use a::{make_bar, Bar};\n \n fn main() {\n     let Bar(x, y, z) = make_bar();\n-    //~^ ERROR expected tuple struct\n+    //~^ ERROR cannot match against a tuple struct which contains private fields\n }"}, {"sha": "8884484e18d8152c937004677e64d5f4c39bee56", "filename": "src/test/ui/issues/issue-75907_b.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-75907_b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fissues%2Fissue-75907_b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-75907_b.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,4 +1,4 @@\n-error[E0532]: expected tuple struct or tuple variant, found struct `Bar`\n+error[E0532]: cannot match against a tuple struct which contains private fields\n   --> $DIR/issue-75907_b.rs:9:9\n    |\n LL |     let Bar(x, y, z) = make_bar();"}, {"sha": "9e53ff07917287492d3f9625d8250ac684e2130b", "filename": "src/test/ui/methods/method-deref-to-same-trait-object-with-separate-params.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fmethods%2Fmethod-deref-to-same-trait-object-with-separate-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fmethods%2Fmethod-deref-to-same-trait-object-with-separate-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-deref-to-same-trait-object-with-separate-params.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,4 +1,6 @@\n-#![feature(arbitrary_self_types, coerce_unsized, dispatch_from_dyn, unsize, unsized_locals)]\n+#![feature(arbitrary_self_types, coerce_unsized, dispatch_from_dyn, unsize)]\n+#![feature(unsized_locals, unsized_fn_params)]\n+//~^ WARN the feature `unsized_locals` is incomplete\n \n // This tests a few edge-cases around `arbitrary_self_types`. Most specifically,\n // it checks that the `ObjectCandidate` you get from method matching can't"}, {"sha": "0a516c89a8b554c8bef5701ebc5240247be8eac5", "filename": "src/test/ui/methods/method-deref-to-same-trait-object-with-separate-params.stderr", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fmethods%2Fmethod-deref-to-same-trait-object-with-separate-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fmethods%2Fmethod-deref-to-same-trait-object-with-separate-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-deref-to-same-trait-object-with-separate-params.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,37 +1,46 @@\n+warning: the feature `unsized_locals` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:2:12\n+   |\n+LL | #![feature(unsized_locals, unsized_fn_params)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #48055 <https://github.com/rust-lang/rust/issues/48055> for more information\n+\n error[E0308]: mismatched types\n-  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:85:24\n+  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:87:24\n    |\n LL |     let _seetype: () = z;\n    |                   --   ^ expected `()`, found `u32`\n    |                   |\n    |                   expected due to this\n \n error[E0308]: mismatched types\n-  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:102:24\n+  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:104:24\n    |\n LL |     let _seetype: () = z;\n    |                   --   ^ expected `()`, found `u64`\n    |                   |\n    |                   expected due to this\n \n error[E0034]: multiple applicable items in scope\n-  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:120:15\n+  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:122:15\n    |\n LL |     let z = x.foo();\n    |               ^^^ multiple `foo` found\n    |\n note: candidate #1 is defined in an impl of the trait `X` for the type `T`\n-  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:43:9\n+  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:45:9\n    |\n LL |         fn foo(self: Smaht<Self, u64>) -> u64 {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: candidate #2 is defined in an impl of the trait `NuisanceFoo` for the type `T`\n-  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:70:9\n+  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:72:9\n    |\n LL |         fn foo(self) {}\n    |         ^^^^^^^^^^^^\n note: candidate #3 is defined in the trait `FinalFoo`\n-  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:57:5\n+  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:59:5\n    |\n LL |     fn foo(&self) -> u8;\n    |     ^^^^^^^^^^^^^^^^^^^^\n@@ -49,30 +58,30 @@ LL |     let z = FinalFoo::foo(x);\n    |             ^^^^^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n-  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:137:24\n+  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:139:24\n    |\n LL |     let _seetype: () = z;\n    |                   --   ^ expected `()`, found `u8`\n    |                   |\n    |                   expected due to this\n \n error[E0308]: mismatched types\n-  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:155:24\n+  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:157:24\n    |\n LL |     let _seetype: () = z;\n    |                   --   ^ expected `()`, found `u32`\n    |                   |\n    |                   expected due to this\n \n error[E0308]: mismatched types\n-  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:172:24\n+  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:174:24\n    |\n LL |     let _seetype: () = z;\n    |                   --   ^ expected `()`, found `u32`\n    |                   |\n    |                   expected due to this\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 6 previous errors; 1 warning emitted\n \n Some errors have detailed explanations: E0034, E0308.\n For more information about an error, try `rustc --explain E0034`."}, {"sha": "59c02d42bf17ebe844771f6b20b27b313be15fed", "filename": "src/test/ui/moves/move-out-of-slice-2.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,4 +1,5 @@\n #![feature(unsized_locals)]\n+//~^ WARN the feature `unsized_locals` is incomplete\n \n struct A;\n #[derive(Clone, Copy)]\n@@ -8,27 +9,27 @@ fn main() {\n     let a: Box<[A]> = Box::new([A]);\n     match *a {\n         //~^ ERROR cannot move out of type `[A]`, a non-copy slice\n-        [a @ ..] => {},\n+        [a @ ..] => {}\n         _ => {}\n     }\n     let b: Box<[A]> = Box::new([A, A, A]);\n     match *b {\n         //~^ ERROR cannot move out of type `[A]`, a non-copy slice\n-        [_, _, b @ .., _] => {},\n+        [_, _, b @ .., _] => {}\n         _ => {}\n     }\n \n     // `[C]` isn't `Copy`, even if `C` is.\n     let c: Box<[C]> = Box::new([C]);\n     match *c {\n         //~^ ERROR cannot move out of type `[C]`, a non-copy slice\n-        [c @ ..] => {},\n+        [c @ ..] => {}\n         _ => {}\n     }\n     let d: Box<[C]> = Box::new([C, C, C]);\n     match *d {\n         //~^ ERROR cannot move out of type `[C]`, a non-copy slice\n-        [_, _, d @ .., _] => {},\n+        [_, _, d @ .., _] => {}\n         _ => {}\n     }\n }"}, {"sha": "9a863bf31a7fb79d0735cd725038bfb03944ce0a", "filename": "src/test/ui/moves/move-out-of-slice-2.stderr", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,51 +1,60 @@\n+warning: the feature `unsized_locals` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/move-out-of-slice-2.rs:1:12\n+   |\n+LL | #![feature(unsized_locals)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #48055 <https://github.com/rust-lang/rust/issues/48055> for more information\n+\n error[E0508]: cannot move out of type `[A]`, a non-copy slice\n-  --> $DIR/move-out-of-slice-2.rs:9:11\n+  --> $DIR/move-out-of-slice-2.rs:10:11\n    |\n LL |     match *a {\n    |           ^^ cannot move out of here\n LL |\n-LL |         [a @ ..] => {},\n+LL |         [a @ ..] => {}\n    |          ------\n    |          |\n    |          data moved here\n    |          move occurs because `a` has type `[A]`, which does not implement the `Copy` trait\n \n error[E0508]: cannot move out of type `[A]`, a non-copy slice\n-  --> $DIR/move-out-of-slice-2.rs:15:11\n+  --> $DIR/move-out-of-slice-2.rs:16:11\n    |\n LL |     match *b {\n    |           ^^ cannot move out of here\n LL |\n-LL |         [_, _, b @ .., _] => {},\n+LL |         [_, _, b @ .., _] => {}\n    |                ------\n    |                |\n    |                data moved here\n    |                move occurs because `b` has type `[A]`, which does not implement the `Copy` trait\n \n error[E0508]: cannot move out of type `[C]`, a non-copy slice\n-  --> $DIR/move-out-of-slice-2.rs:23:11\n+  --> $DIR/move-out-of-slice-2.rs:24:11\n    |\n LL |     match *c {\n    |           ^^ cannot move out of here\n LL |\n-LL |         [c @ ..] => {},\n+LL |         [c @ ..] => {}\n    |          ------\n    |          |\n    |          data moved here\n    |          move occurs because `c` has type `[C]`, which does not implement the `Copy` trait\n \n error[E0508]: cannot move out of type `[C]`, a non-copy slice\n-  --> $DIR/move-out-of-slice-2.rs:29:11\n+  --> $DIR/move-out-of-slice-2.rs:30:11\n    |\n LL |     match *d {\n    |           ^^ cannot move out of here\n LL |\n-LL |         [_, _, d @ .., _] => {},\n+LL |         [_, _, d @ .., _] => {}\n    |                ------\n    |                |\n    |                data moved here\n    |                move occurs because `d` has type `[C]`, which does not implement the `Copy` trait\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 4 previous errors; 1 warning emitted\n \n For more information about this error, try `rustc --explain E0508`."}, {"sha": "c791fb3ae674970948a888bdc260d629a8bad221", "filename": "src/test/ui/parser/fn-colon-return-type.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fparser%2Ffn-colon-return-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fparser%2Ffn-colon-return-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-colon-return-type.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -0,0 +1,5 @@\n+fn foo(x: i32): i32 { //~ ERROR expected one of `->`, `;`, `where`, or `{`, found `:`\n+    x\n+}\n+\n+fn main() {}"}, {"sha": "92df9bc60bd3c1162d8f3d51c8a5e8af1fdcce5a", "filename": "src/test/ui/parser/fn-colon-return-type.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fparser%2Ffn-colon-return-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fparser%2Ffn-colon-return-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-colon-return-type.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -0,0 +1,8 @@\n+error: expected one of `->`, `;`, `where`, or `{`, found `:`\n+  --> $DIR/fn-colon-return-type.rs:1:15\n+   |\n+LL | fn foo(x: i32): i32 {\n+   |               ^ expected one of `->`, `;`, `where`, or `{`\n+\n+error: aborting due to previous error\n+"}, {"sha": "20665b549d2577ffe35adebcc4590234afdfe0ca", "filename": "src/test/ui/parser/issue-24780.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fparser%2Fissue-24780.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fparser%2Fissue-24780.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-24780.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,8 +1,9 @@\n // Verify that '>' is not both expected and found at the same time, as it used\n // to happen in #24780. For example, following should be an error:\n-// expected one of ..., `>`, ... found `>`\n+// expected one of ..., `>`, ... found `>`. No longer exactly this, but keeping for posterity.\n \n-fn foo() -> Vec<usize>> {\n-    //~^ ERROR expected `;` or `{`, found `>`\n+fn foo() -> Vec<usize>> { //~ ERROR unmatched angle bracket\n     Vec::new()\n }\n+\n+fn main() {}"}, {"sha": "d12b13d35f8ad4ed22572d770520f7cb22358821", "filename": "src/test/ui/parser/issue-24780.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fparser%2Fissue-24780.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fparser%2Fissue-24780.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-24780.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,8 +1,8 @@\n-error: expected `;` or `{`, found `>`\n+error: unmatched angle bracket\n   --> $DIR/issue-24780.rs:5:23\n    |\n LL | fn foo() -> Vec<usize>> {\n-   |                       ^ expected `;` or `{`\n+   |                       ^^ help: remove extra angle bracket\n \n error: aborting due to previous error\n "}, {"sha": "9ed5a61220bde543f6d8043d43c2df2c4745117b", "filename": "src/test/ui/parser/issue-6610.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fparser%2Fissue-6610.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fparser%2Fissue-6610.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-6610.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,3 +1,3 @@\n-trait Foo { fn a() } //~ ERROR expected `;` or `{`, found `}`\n+trait Foo { fn a() } //~ ERROR expected one of `->`, `;`, `where`, or `{`, found `}`\n \n fn main() {}"}, {"sha": "4a3bc752553b982ac47ebeff39eeeda7f2fa984f", "filename": "src/test/ui/parser/issue-6610.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fparser%2Fissue-6610.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fparser%2Fissue-6610.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-6610.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,12 +1,10 @@\n-error: expected `;` or `{`, found `}`\n+error: expected one of `->`, `;`, `where`, or `{`, found `}`\n   --> $DIR/issue-6610.rs:1:20\n    |\n LL | trait Foo { fn a() }\n-   |           -        ^\n-   |           |        |\n-   |           |        expected `;` or `{`\n-   |           |        the item list ends here\n-   |           while parsing this item list starting here\n+   |                -   ^ expected one of `->`, `;`, `where`, or `{`\n+   |                |\n+   |                while parsing this `fn`\n \n error: aborting due to previous error\n "}, {"sha": "22e1c2f97e76936c4a95f046afc3d45b0dd5cb87", "filename": "src/test/ui/parser/missing_right_paren.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fparser%2Fmissing_right_paren.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fparser%2Fmissing_right_paren.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmissing_right_paren.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -22,11 +22,11 @@ error: expected one of `:` or `|`, found `)`\n LL | fn main((\u063c\n    |           ^ expected one of `:` or `|`\n \n-error: expected `;` or `{`, found `<eof>`\n+error: expected one of `->`, `;`, `where`, or `{`, found `<eof>`\n   --> $DIR/missing_right_paren.rs:3:11\n    |\n LL | fn main((\u063c\n-   |           ^ expected `;` or `{`\n+   |           ^ expected one of `->`, `;`, `where`, or `{`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "1b3d9bf66bb6072643767443a68dd6b82a1df0f8", "filename": "src/test/ui/parser/not-a-pred.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fparser%2Fnot-a-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fparser%2Fnot-a-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fnot-a-pred.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,6 +1,5 @@\n-// error-pattern: lt\n-\n fn f(a: isize, b: isize) : lt(a, b) { }\n+//~^ ERROR expected one of `->`, `;`, `where`, or `{`, found `:`\n \n fn lt(a: isize, b: isize) { }\n "}, {"sha": "ec413c5594c44429e497920a88298429f64a5ef3", "filename": "src/test/ui/parser/not-a-pred.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fparser%2Fnot-a-pred.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fparser%2Fnot-a-pred.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fnot-a-pred.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,8 +1,8 @@\n-error: expected `;` or `{`, found `:`\n-  --> $DIR/not-a-pred.rs:3:26\n+error: expected one of `->`, `;`, `where`, or `{`, found `:`\n+  --> $DIR/not-a-pred.rs:1:26\n    |\n LL | fn f(a: isize, b: isize) : lt(a, b) { }\n-   |                          ^ expected `;` or `{`\n+   |                          ^ expected one of `->`, `;`, `where`, or `{`\n \n error: aborting due to previous error\n "}, {"sha": "b2084a7a426a66c727edc89e4d72f1ef5cb3a15f", "filename": "src/test/ui/resolve/issue-5035-2.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fresolve%2Fissue-5035-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fresolve%2Fissue-5035-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-5035-2.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -5,11 +5,11 @@ LL | fn foo(_x: K) {}\n    |        ^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `(dyn I + 'static)`\n-   = help: unsized locals are gated as an unstable feature\n+   = help: unsized fn params are gated as an unstable feature\n help: function arguments must have a statically known size, borrowed types always have a known size\n    |\n-LL | fn foo(_x: &K) {}\n-   |            ^\n+LL | fn foo(&_x: K) {}\n+   |        ^\n \n error: aborting due to previous error\n "}, {"sha": "07e093c152d6b153fdbf697797836c2852ddad9d", "filename": "src/test/ui/rfc-2008-non-exhaustive/struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -18,7 +18,7 @@ fn main() {\n     //~^ ERROR `..` required with struct marked as non-exhaustive\n \n     let ts = TupleStruct(640, 480);\n-    //~^ ERROR expected function, tuple struct or tuple variant, found struct `TupleStruct` [E0423]\n+    //~^ ERROR cannot initialize a tuple struct which contains private fields [E0423]\n \n     let ts_explicit = structs::TupleStruct(640, 480);\n     //~^ ERROR tuple struct constructor `TupleStruct` is private [E0603]"}, {"sha": "e2ee8d6a6fe5e0b35d347f8974bbf5febb5757e2", "filename": "src/test/ui/rfc-2008-non-exhaustive/struct.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,4 +1,4 @@\n-error[E0423]: expected function, tuple struct or tuple variant, found struct `TupleStruct`\n+error[E0423]: cannot initialize a tuple struct which contains private fields\n   --> $DIR/struct.rs:20:14\n    |\n LL |     let ts = TupleStruct(640, 480);"}, {"sha": "19fc3406ccfe43c165b809364beb1c34fa880e52", "filename": "src/test/ui/suggestions/path-by-value.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fsuggestions%2Fpath-by-value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Fsuggestions%2Fpath-by-value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fpath-by-value.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -6,11 +6,11 @@ LL | fn f(p: Path) { }\n    |\n    = help: within `Path`, the trait `Sized` is not implemented for `[u8]`\n    = note: required because it appears within the type `Path`\n-   = help: unsized locals are gated as an unstable feature\n+   = help: unsized fn params are gated as an unstable feature\n help: function arguments must have a statically known size, borrowed types always have a known size\n    |\n-LL | fn f(p: &Path) { }\n-   |         ^\n+LL | fn f(&p: Path) { }\n+   |      ^\n \n error: aborting due to previous error\n "}, {"sha": "48eedc0b0ea430467dd91b9e7167c3f6f0854ae9", "filename": "src/test/ui/traits/trait-bounds-not-on-bare-trait.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Ftraits%2Ftrait-bounds-not-on-bare-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Ftraits%2Ftrait-bounds-not-on-bare-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-bounds-not-on-bare-trait.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -13,11 +13,11 @@ LL | fn foo(_x: Foo + Send) {\n    |        ^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `(dyn Foo + Send + 'static)`\n-   = help: unsized locals are gated as an unstable feature\n+   = help: unsized fn params are gated as an unstable feature\n help: function arguments must have a statically known size, borrowed types always have a known size\n    |\n-LL | fn foo(_x: &Foo + Send) {\n-   |            ^\n+LL | fn foo(&_x: Foo + Send) {\n+   |        ^\n \n error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "29273a5babefd577162f775b8cac4d50e228d3fa", "filename": "src/test/ui/unboxed-closures/issue-53448.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funboxed-closures%2Fissue-53448.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funboxed-closures%2Fissue-53448.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Fissue-53448.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -5,7 +5,7 @@ LL |     let f: &mut dyn FnMut<(_,), Output = ()> = &mut |_: <() as Lt<'_>>::T|\n    |                                                      ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `<() as Lt<'_>>::T`\n-   = help: unsized locals are gated as an unstable feature\n+   = help: unsized fn params are gated as an unstable feature\n help: consider further restricting the associated type\n    |\n LL | fn main() where <() as Lt<'_>>::T: Sized {"}, {"sha": "5dd5898c12e5c2d44979fb44ebe9772cfebdc09b", "filename": "src/test/ui/unsized-locals/autoderef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fautoderef.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,6 +1,7 @@\n // run-pass\n \n-#![feature(unsized_locals)]\n+#![allow(incomplete_features)]\n+#![feature(unsized_locals, unsized_fn_params)]\n \n pub trait Foo {\n     fn foo(self) -> String;\n@@ -24,7 +25,6 @@ impl Foo for dyn FnMut() -> String {\n     }\n }\n \n-\n fn main() {\n     let x = *(Box::new(['h', 'e', 'l', 'l', 'o']) as Box<[char]>);\n     assert_eq!(&x.foo() as &str, \"hello\");"}, {"sha": "5954abf3a1fc5ea007222a44adb4e3c0e41e910b", "filename": "src/test/ui/unsized-locals/auxiliary/ufuncs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fauxiliary%2Fufuncs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fauxiliary%2Fufuncs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fauxiliary%2Fufuncs.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,3 +1,3 @@\n-#![feature(unsized_locals)]\n+#![feature(unsized_locals, unsized_fn_params)]\n \n pub fn udrop<T: ?Sized>(_x: T) {}"}, {"sha": "ad73b720fa39d1b4790270a06ca785d3c843fc68", "filename": "src/test/ui/unsized-locals/borrow-after-move.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,4 +1,5 @@\n-#![feature(unsized_locals)]\n+#![feature(unsized_locals, unsized_fn_params)]\n+//~^ WARN the feature `unsized_locals` is incomplete\n \n pub trait Foo {\n     fn foo(self) -> String;"}, {"sha": "5934276cc1dda525e1e387031d5c44d576e9d578", "filename": "src/test/ui/unsized-locals/borrow-after-move.stderr", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,5 +1,14 @@\n+warning: the feature `unsized_locals` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/borrow-after-move.rs:1:12\n+   |\n+LL | #![feature(unsized_locals, unsized_fn_params)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #48055 <https://github.com/rust-lang/rust/issues/48055> for more information\n+\n error[E0382]: borrow of moved value: `x`\n-  --> $DIR/borrow-after-move.rs:20:24\n+  --> $DIR/borrow-after-move.rs:21:24\n    |\n LL |         let y = *x;\n    |                 -- value moved here\n@@ -10,7 +19,7 @@ LL |         println!(\"{}\", &x);\n    = note: move occurs because `*x` has type `str`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `y`\n-  --> $DIR/borrow-after-move.rs:22:24\n+  --> $DIR/borrow-after-move.rs:23:24\n    |\n LL |         let y = *x;\n    |             - move occurs because `y` has type `str`, which does not implement the `Copy` trait\n@@ -21,7 +30,7 @@ LL |         println!(\"{}\", &y);\n    |                        ^^ value borrowed here after move\n \n error[E0382]: borrow of moved value: `x`\n-  --> $DIR/borrow-after-move.rs:30:24\n+  --> $DIR/borrow-after-move.rs:31:24\n    |\n LL |         let y = *x;\n    |                 -- value moved here\n@@ -32,7 +41,7 @@ LL |         println!(\"{}\", &x);\n    = note: move occurs because `*x` has type `str`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `y`\n-  --> $DIR/borrow-after-move.rs:32:24\n+  --> $DIR/borrow-after-move.rs:33:24\n    |\n LL |         let y = *x;\n    |             - move occurs because `y` has type `str`, which does not implement the `Copy` trait\n@@ -43,13 +52,13 @@ LL |         println!(\"{}\", &y);\n    |                        ^^ value borrowed here after move\n    |\n note: this function consumes the receiver `self` by taking ownership of it, which moves `y`\n-  --> $DIR/borrow-after-move.rs:4:12\n+  --> $DIR/borrow-after-move.rs:5:12\n    |\n LL |     fn foo(self) -> String;\n    |            ^^^^\n \n error[E0382]: borrow of moved value: `x`\n-  --> $DIR/borrow-after-move.rs:39:24\n+  --> $DIR/borrow-after-move.rs:40:24\n    |\n LL |         let x = \"hello\".to_owned().into_boxed_str();\n    |             - move occurs because `x` has type `Box<str>`, which does not implement the `Copy` trait\n@@ -58,6 +67,6 @@ LL |         x.foo();\n LL |         println!(\"{}\", &x);\n    |                        ^^ value borrowed here after move\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 5 previous errors; 1 warning emitted\n \n For more information about this error, try `rustc --explain E0382`."}, {"sha": "b9881defac39a180a30198d43d7445c763315e5f", "filename": "src/test/ui/unsized-locals/by-value-trait-object-safety-rpass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fby-value-trait-object-safety-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fby-value-trait-object-safety-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fby-value-trait-object-safety-rpass.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,5 +1,6 @@\n // run-pass\n \n+#![allow(incomplete_features)]\n #![feature(unsized_locals)]\n \n pub trait Foo {\n@@ -14,7 +15,6 @@ impl Foo for A {\n     }\n }\n \n-\n fn main() {\n     let x = *(Box::new(A) as Box<dyn Foo>);\n     assert_eq!(x.foo(), format!(\"hello\"));"}, {"sha": "957991f853b2d9dd3ea95f1c3feffd0df80e8587", "filename": "src/test/ui/unsized-locals/by-value-trait-object-safety-withdefault.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fby-value-trait-object-safety-withdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fby-value-trait-object-safety-withdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fby-value-trait-object-safety-withdefault.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,6 +1,7 @@\n // run-pass\n \n-#![feature(unsized_locals)]\n+#![allow(incomplete_features)]\n+#![feature(unsized_locals, unsized_fn_params)]\n \n pub trait Foo {\n     fn foo(self) -> String {\n@@ -12,7 +13,6 @@ struct A;\n \n impl Foo for A {}\n \n-\n fn main() {\n     let x = *(Box::new(A) as Box<dyn Foo>);\n     assert_eq!(x.foo(), format!(\"hello\"));"}, {"sha": "d0ba6944a1e812e50d599556bead3e11b3ba6149", "filename": "src/test/ui/unsized-locals/by-value-trait-object-safety.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fby-value-trait-object-safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fby-value-trait-object-safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fby-value-trait-object-safety.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,7 +1,10 @@\n #![feature(unsized_locals)]\n+//~^ WARN the feature `unsized_locals` is incomplete\n \n pub trait Foo {\n-    fn foo(self) -> String where Self: Sized;\n+    fn foo(self) -> String\n+    where\n+        Self: Sized;\n }\n \n struct A;\n@@ -12,7 +15,6 @@ impl Foo for A {\n     }\n }\n \n-\n fn main() {\n     let x = *(Box::new(A) as Box<dyn Foo>);\n     x.foo();"}, {"sha": "59d91bc0cfd3d5ba405520d1a23162c5984eedda", "filename": "src/test/ui/unsized-locals/by-value-trait-object-safety.stderr", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fby-value-trait-object-safety.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fby-value-trait-object-safety.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fby-value-trait-object-safety.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,11 +1,20 @@\n+warning: the feature `unsized_locals` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/by-value-trait-object-safety.rs:1:12\n+   |\n+LL | #![feature(unsized_locals)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #48055 <https://github.com/rust-lang/rust/issues/48055> for more information\n+\n error: the `foo` method cannot be invoked on a trait object\n-  --> $DIR/by-value-trait-object-safety.rs:18:7\n+  --> $DIR/by-value-trait-object-safety.rs:20:7\n    |\n-LL |     fn foo(self) -> String where Self: Sized;\n-   |                                        ----- this has a `Sized` requirement\n+LL |         Self: Sized;\n+   |               ----- this has a `Sized` requirement\n ...\n LL |     x.foo();\n    |       ^^^\n \n-error: aborting due to previous error\n+error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "9e46ef9be487cd18b10c5a8a5b440918962c77b4", "filename": "src/test/ui/unsized-locals/double-move.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,4 +1,5 @@\n-#![feature(unsized_locals)]\n+#![feature(unsized_locals, unsized_fn_params)]\n+//~^ WARN the feature `unsized_locals` is incomplete\n \n pub trait Foo {\n     fn foo(self) -> String;"}, {"sha": "b897dbbc9a3aac4547f05eb34444fbec2a6164f5", "filename": "src/test/ui/unsized-locals/double-move.stderr", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,5 +1,14 @@\n+warning: the feature `unsized_locals` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/double-move.rs:1:12\n+   |\n+LL | #![feature(unsized_locals, unsized_fn_params)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #48055 <https://github.com/rust-lang/rust/issues/48055> for more information\n+\n error[E0382]: use of moved value: `y`\n-  --> $DIR/double-move.rs:20:22\n+  --> $DIR/double-move.rs:21:22\n    |\n LL |         let y = *x;\n    |             - move occurs because `y` has type `str`, which does not implement the `Copy` trait\n@@ -9,7 +18,7 @@ LL |         drop_unsized(y);\n    |                      ^ value used here after move\n \n error[E0382]: use of moved value: `x`\n-  --> $DIR/double-move.rs:26:22\n+  --> $DIR/double-move.rs:27:22\n    |\n LL |         let _y = *x;\n    |                  -- value moved here\n@@ -19,7 +28,7 @@ LL |         drop_unsized(x);\n    = note: move occurs because `*x` has type `str`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `*x`\n-  --> $DIR/double-move.rs:32:18\n+  --> $DIR/double-move.rs:33:18\n    |\n LL |         let x = \"hello\".to_owned().into_boxed_str();\n    |             - move occurs because `x` has type `Box<str>`, which does not implement the `Copy` trait\n@@ -29,7 +38,7 @@ LL |         let _y = *x;\n    |                  ^^ value used here after move\n \n error[E0382]: use of moved value: `y`\n-  --> $DIR/double-move.rs:39:9\n+  --> $DIR/double-move.rs:40:9\n    |\n LL |         let y = *x;\n    |             - move occurs because `y` has type `str`, which does not implement the `Copy` trait\n@@ -39,13 +48,13 @@ LL |         y.foo();\n    |         ^ value used here after move\n    |\n note: this function consumes the receiver `self` by taking ownership of it, which moves `y`\n-  --> $DIR/double-move.rs:4:12\n+  --> $DIR/double-move.rs:5:12\n    |\n LL |     fn foo(self) -> String;\n    |            ^^^^\n \n error[E0382]: use of moved value: `x`\n-  --> $DIR/double-move.rs:45:9\n+  --> $DIR/double-move.rs:46:9\n    |\n LL |         let _y = *x;\n    |                  -- value moved here\n@@ -55,7 +64,7 @@ LL |         x.foo();\n    = note: move occurs because `*x` has type `str`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `*x`\n-  --> $DIR/double-move.rs:51:18\n+  --> $DIR/double-move.rs:52:18\n    |\n LL |         let x = \"hello\".to_owned().into_boxed_str();\n    |             - move occurs because `x` has type `Box<str>`, which does not implement the `Copy` trait\n@@ -64,6 +73,6 @@ LL |         x.foo();\n LL |         let _y = *x;\n    |                  ^^ value used here after move\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 6 previous errors; 1 warning emitted\n \n For more information about this error, try `rustc --explain E0382`."}, {"sha": "635d34f822914fef3e962af09aa2908c253dcea8", "filename": "src/test/ui/unsized-locals/issue-30276-feature-flagged.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fissue-30276-feature-flagged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fissue-30276-feature-flagged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fissue-30276-feature-flagged.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,4 +1,5 @@\n #![feature(unsized_locals)]\n+//~^ WARN the feature `unsized_locals` is incomplete\n \n struct Test([i32]);\n "}, {"sha": "0f0ff5793776fe69736d84561e2680d22d2c4906", "filename": "src/test/ui/unsized-locals/issue-30276-feature-flagged.stderr", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fissue-30276-feature-flagged.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fissue-30276-feature-flagged.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fissue-30276-feature-flagged.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,13 +1,22 @@\n+warning: the feature `unsized_locals` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/issue-30276-feature-flagged.rs:1:12\n+   |\n+LL | #![feature(unsized_locals)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #48055 <https://github.com/rust-lang/rust/issues/48055> for more information\n+\n error[E0277]: the size for values of type `[i32]` cannot be known at compilation time\n-  --> $DIR/issue-30276-feature-flagged.rs:6:29\n+  --> $DIR/issue-30276-feature-flagged.rs:7:29\n    |\n LL |     let _x: fn(_) -> Test = Test;\n    |                             ^^^^ doesn't have a size known at compile-time\n    |\n-   = help: within `Test`, the trait `Sized` is not implemented for `[i32]`\n-   = note: required because it appears within the type `Test`\n-   = note: the return type of a function must have a statically known size\n+   = help: the trait `Sized` is not implemented for `[i32]`\n+   = note: all function arguments must have a statically known size\n+   = help: unsized fn params are gated as an unstable feature\n \n-error: aborting due to previous error\n+error: aborting due to previous error; 1 warning emitted\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "8cccbd792da5c0f1d88fa4a42894aba1e72db235", "filename": "src/test/ui/unsized-locals/issue-30276.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fissue-30276.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fissue-30276.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fissue-30276.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -6,7 +6,7 @@ LL |     let _x: fn(_) -> Test = Test;\n    |\n    = help: the trait `Sized` is not implemented for `[i32]`\n    = note: all function arguments must have a statically known size\n-   = help: unsized locals are gated as an unstable feature\n+   = help: unsized fn params are gated as an unstable feature\n \n error: aborting due to previous error\n "}, {"sha": "63b0e830be4ed0290ce08a192b0b1a9ad04e6565", "filename": "src/test/ui/unsized-locals/issue-50940-with-feature.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fissue-50940-with-feature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fissue-50940-with-feature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fissue-50940-with-feature.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,4 +1,5 @@\n-#![feature(unsized_locals)]\n+#![feature(unsized_locals, unsized_fn_params)]\n+//~^ WARN the feature `unsized_locals` is incomplete\n \n fn main() {\n     struct A<X: ?Sized>(X);"}, {"sha": "1b1a584a01ff1bc24e4b3872339d2b0bc1fee63a", "filename": "src/test/ui/unsized-locals/issue-50940-with-feature.stderr", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fissue-50940-with-feature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fissue-50940-with-feature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fissue-50940-with-feature.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,5 +1,14 @@\n+warning: the feature `unsized_locals` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/issue-50940-with-feature.rs:1:12\n+   |\n+LL | #![feature(unsized_locals, unsized_fn_params)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #48055 <https://github.com/rust-lang/rust/issues/48055> for more information\n+\n error[E0277]: the size for values of type `str` cannot be known at compilation time\n-  --> $DIR/issue-50940-with-feature.rs:5:5\n+  --> $DIR/issue-50940-with-feature.rs:6:5\n    |\n LL |     A as fn(str) -> A<str>;\n    |     ^ doesn't have a size known at compile-time\n@@ -8,6 +17,6 @@ LL |     A as fn(str) -> A<str>;\n    = note: required because it appears within the type `A<str>`\n    = note: the return type of a function must have a statically known size\n \n-error: aborting due to previous error\n+error: aborting due to previous error; 1 warning emitted\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "8f09b460e004bc1c2cbf98205cae50aacee09816", "filename": "src/test/ui/unsized-locals/issue-50940.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fissue-50940.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fissue-50940.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fissue-50940.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -6,7 +6,7 @@ LL |     A as fn(str) -> A<str>;\n    |\n    = help: the trait `Sized` is not implemented for `str`\n    = note: all function arguments must have a statically known size\n-   = help: unsized locals are gated as an unstable feature\n+   = help: unsized fn params are gated as an unstable feature\n \n error: aborting due to previous error\n "}, {"sha": "4e887f32753f1ea15da3fb823bae4232752d5ae5", "filename": "src/test/ui/unsized-locals/reference-unsized-locals.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Freference-unsized-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Freference-unsized-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Freference-unsized-locals.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,5 +1,6 @@\n // run-pass\n \n+#![allow(incomplete_features)]\n #![feature(unsized_locals)]\n \n fn main() {"}, {"sha": "02b7c299aa40a35f1be9e424e21cf40d37cd1b89", "filename": "src/test/ui/unsized-locals/simple-unsized-locals.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fsimple-unsized-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Fsimple-unsized-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fsimple-unsized-locals.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,5 +1,6 @@\n // run-pass\n \n+#![allow(incomplete_features)]\n #![feature(unsized_locals)]\n \n fn main() {"}, {"sha": "8fcb6d93d391cd4686e2a613e572c1ae332cebbd", "filename": "src/test/ui/unsized-locals/unsized-exprs-rpass.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs-rpass.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,6 +1,6 @@\n // run-pass\n-#![allow(unused_braces, unused_parens)]\n-#![feature(unsized_tuple_coercion, unsized_locals)]\n+#![allow(incomplete_features, unused_braces, unused_parens)]\n+#![feature(unsized_tuple_coercion, unsized_locals, unsized_fn_params)]\n \n struct A<X: ?Sized>(X);\n \n@@ -24,12 +24,8 @@ fn main() {\n     udrop::<[u8]>(loop {\n         break *foo();\n     });\n-    udrop::<[u8]>(if true {\n-        *foo()\n-    } else {\n-        *foo()\n-    });\n-    udrop::<[u8]>({*foo()});\n+    udrop::<[u8]>(if true { *foo() } else { *foo() });\n+    udrop::<[u8]>({ *foo() });\n     udrop::<[u8]>((*foo()));\n     udrop::<[u8]>((*tfoo()).1);\n     *afoo() + 42;"}, {"sha": "1729b9ffa867091033d9ecb1a5ade7e4154ac50f", "filename": "src/test/ui/unsized-locals/unsized-exprs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,4 +1,4 @@\n-#![feature(unsized_tuple_coercion, unsized_locals)]\n+#![feature(unsized_tuple_coercion, unsized_fn_params)]\n \n struct A<X: ?Sized>(X);\n "}, {"sha": "127d8717e580602033c9bd810f4ba4d55e95d0ba", "filename": "src/test/ui/unsized-locals/unsized-exprs2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs2.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,4 +1,4 @@\n-#![feature(unsized_tuple_coercion, unsized_locals)]\n+#![feature(unsized_tuple_coercion, unsized_fn_params)]\n \n struct A<X: ?Sized>(X);\n "}, {"sha": "57d9978225a2dc204eb36494efa608ebc1e4bfea", "filename": "src/test/ui/unsized-locals/unsized-exprs3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs3.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -6,7 +6,7 @@ LL |     udrop as fn([u8]);\n    |\n    = help: the trait `Sized` is not implemented for `[u8]`\n    = note: all function arguments must have a statically known size\n-   = help: unsized locals are gated as an unstable feature\n+   = help: unsized fn params are gated as an unstable feature\n \n error: aborting due to previous error\n "}, {"sha": "e8782e8948153d7bdad78ed067d04f09c1518c53", "filename": "src/test/ui/unsized-locals/unsized-index.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Funsized-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Funsized-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Funsized-index.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,23 +1,27 @@\n-// build-pass (FIXME(62277): could be check-pass?)\n+// run-pass\n \n-// `std::ops::Index` has an `: ?Sized` bound on the `Idx` type param. This is\n-// an accidental left-over from the times when it `Index` was by-reference.\n-// Tightening the bound now could be a breaking change. Although no crater\n-// regression were observed (https://github.com/rust-lang/rust/pull/59527),\n-// let's be conservative and just add a test for this.\n-#![feature(unsized_locals)]\n+#![feature(unsized_fn_params)]\n \n use std::ops;\n+use std::ops::Index;\n \n pub struct A;\n \n impl ops::Index<str> for A {\n     type Output = ();\n-    fn index(&self, _: str) -> &Self::Output { panic!() }\n+    fn index(&self, _: str) -> &Self::Output {\n+        &()\n+    }\n }\n \n impl ops::IndexMut<str> for A {\n-    fn index_mut(&mut self, _: str) -> &mut Self::Output { panic!() }\n+    fn index_mut(&mut self, _: str) -> &mut Self::Output {\n+        panic!()\n+    }\n }\n \n-fn main() {}\n+fn main() {\n+    let a = A {};\n+    let s = String::new().into_boxed_str();\n+    assert_eq!(&(), a.index(*s));\n+}"}, {"sha": "15263954ced775e5c8c9710696b9dc37ea02c86f", "filename": "src/test/ui/unsized-locals/unsized-locals-using-unsized-fn-params.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Funsized-locals-using-unsized-fn-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Funsized-locals-using-unsized-fn-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Funsized-locals-using-unsized-fn-params.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -0,0 +1,15 @@\n+#![feature(box_patterns)]\n+#![feature(unsized_fn_params)]\n+\n+#[allow(dead_code)]\n+fn f1(box box _b: Box<Box<[u8]>>) {}\n+//~^ ERROR: the size for values of type `[u8]` cannot be known at compilation time [E0277]\n+\n+fn f2((_x, _y): (i32, [i32])) {}\n+//~^ ERROR: the size for values of type `[i32]` cannot be known at compilation time [E0277]\n+\n+fn main() {\n+    let foo: Box<[u8]> = Box::new(*b\"foo\");\n+    let _foo: [u8] = *foo;\n+    //~^ ERROR: the size for values of type `[u8]` cannot be known at compilation time [E0277]\n+}"}, {"sha": "da77026673d96c51a08c8b180bd9a12df830e2fd", "filename": "src/test/ui/unsized-locals/unsized-locals-using-unsized-fn-params.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Funsized-locals-using-unsized-fn-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Funsized-locals-using-unsized-fn-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Funsized-locals-using-unsized-fn-params.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -0,0 +1,33 @@\n+error[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n+  --> $DIR/unsized-locals-using-unsized-fn-params.rs:5:15\n+   |\n+LL | fn f1(box box _b: Box<Box<[u8]>>) {}\n+   |               ^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `Sized` is not implemented for `[u8]`\n+   = note: all local variables must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n+\n+error[E0277]: the size for values of type `[i32]` cannot be known at compilation time\n+  --> $DIR/unsized-locals-using-unsized-fn-params.rs:8:12\n+   |\n+LL | fn f2((_x, _y): (i32, [i32])) {}\n+   |            ^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `Sized` is not implemented for `[i32]`\n+   = note: all local variables must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n+\n+error[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n+  --> $DIR/unsized-locals-using-unsized-fn-params.rs:13:9\n+   |\n+LL |     let _foo: [u8] = *foo;\n+   |         ^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `Sized` is not implemented for `[u8]`\n+   = note: all local variables must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "a1b772a7eb689c75c3b802c56a97e1f24af6e4b1", "filename": "src/test/ui/unsized-locals/unsized-parameters.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Funsized-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized-locals%2Funsized-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Funsized-parameters.rs?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -1,10 +1,11 @@\n // run-pass\n \n-#![feature(unsized_locals)]\n+#![allow(incomplete_features)]\n+#![feature(unsized_fn_params)]\n \n pub fn f0(_f: dyn FnOnce()) {}\n pub fn f1(_s: str) {}\n-pub fn f2((_x, _y): (i32, [i32])) {}\n+pub fn f2(_x: i32, _y: [i32]) {}\n \n fn main() {\n     let foo = \"foo\".to_string().into_boxed_str();"}, {"sha": "71dac236fa31678febd9d85c35a539a10d3662f6", "filename": "src/test/ui/unsized6.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db241bb0c8d257e13c1560f6250e49879477039e/src%2Ftest%2Fui%2Funsized6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized6.stderr?ref=db241bb0c8d257e13c1560f6250e49879477039e", "patch": "@@ -132,11 +132,11 @@ LL | fn g1<X: ?Sized>(x: X) {}\n    |       |\n    |       this type parameter needs to be `Sized`\n    |\n-   = help: unsized locals are gated as an unstable feature\n+   = help: unsized fn params are gated as an unstable feature\n help: function arguments must have a statically known size, borrowed types always have a known size\n    |\n-LL | fn g1<X: ?Sized>(x: &X) {}\n-   |                     ^\n+LL | fn g1<X: ?Sized>(&x: X) {}\n+   |                  ^\n \n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized6.rs:40:22\n@@ -146,11 +146,11 @@ LL | fn g2<X: ?Sized + T>(x: X) {}\n    |       |\n    |       this type parameter needs to be `Sized`\n    |\n-   = help: unsized locals are gated as an unstable feature\n+   = help: unsized fn params are gated as an unstable feature\n help: function arguments must have a statically known size, borrowed types always have a known size\n    |\n-LL | fn g2<X: ?Sized + T>(x: &X) {}\n-   |                         ^\n+LL | fn g2<X: ?Sized + T>(&x: X) {}\n+   |                      ^\n \n error: aborting due to 13 previous errors\n "}]}