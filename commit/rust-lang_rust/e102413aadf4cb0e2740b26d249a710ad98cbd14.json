{"sha": "e102413aadf4cb0e2740b26d249a710ad98cbd14", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxMDI0MTNhYWRmNGNiMGUyNzQwYjI2ZDI0OWE3MTBhZDk4Y2JkMTQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-25T19:15:55Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-25T19:15:55Z"}, "message": "rustc: Pass a \"type context\" around instead of directly passing the type store; prep for removing type annotations", "tree": {"sha": "6c47e65fddf38f01b3a1b32259ca70d595c2bef5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c47e65fddf38f01b3a1b32259ca70d595c2bef5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e102413aadf4cb0e2740b26d249a710ad98cbd14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e102413aadf4cb0e2740b26d249a710ad98cbd14", "html_url": "https://github.com/rust-lang/rust/commit/e102413aadf4cb0e2740b26d249a710ad98cbd14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e102413aadf4cb0e2740b26d249a710ad98cbd14/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b258060a94e629d3281697cedfa6620f5e75b0c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b258060a94e629d3281697cedfa6620f5e75b0c3", "html_url": "https://github.com/rust-lang/rust/commit/b258060a94e629d3281697cedfa6620f5e75b0c3"}], "stats": {"total": 1619, "additions": 786, "deletions": 833}, "files": [{"sha": "eabf03102e243b275f1aa1227ad75c7bb5176336", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e102413aadf4cb0e2740b26d249a710ad98cbd14/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e102413aadf4cb0e2740b26d249a710ad98cbd14/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=e102413aadf4cb0e2740b26d249a710ad98cbd14", "patch": "@@ -73,13 +73,13 @@ fn compile_input(session.session sess,\n     crate = resolve.resolve_crate(sess, crate);\n     capture.check_for_captures(sess, crate);\n \n-    auto tystore = ty.mk_type_store();\n-    auto typeck_result = typeck.check_crate(sess, tystore, crate);\n+    auto ty_cx = ty.mk_ctxt();\n+    auto typeck_result = typeck.check_crate(sess, ty_cx, crate);\n     crate = typeck_result._0;\n     auto type_cache = typeck_result._1;\n     // FIXME: uncomment once typestate_check works\n     // crate = typestate_check.check_crate(crate);\n-    trans.trans_crate(sess, crate, tystore, type_cache, output, shared,\n+    trans.trans_crate(sess, crate, ty_cx, type_cache, output, shared,\n                       optimize, verify, ot);\n }\n "}, {"sha": "3ecf3058ab8cde61514511201f14a1eba7951a27", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 43, "deletions": 45, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/e102413aadf4cb0e2740b26d249a710ad98cbd14/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e102413aadf4cb0e2740b26d249a710ad98cbd14/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=e102413aadf4cb0e2740b26d249a710ad98cbd14", "patch": "@@ -49,8 +49,7 @@ tag resolve_result {\n // Callback to translate defs to strs or back.\n type str_def = fn(str) -> ast.def_id;\n \n-type pstate = rec(str rep, mutable uint pos, uint len,\n-                  @ty.type_store tystore);\n+type pstate = rec(str rep, mutable uint pos, uint len, ty.ctxt tcx);\n \n fn peek(@pstate st) -> u8 {\n     if (st.pos < st.len) {ret st.rep.(st.pos) as u8;}\n@@ -63,9 +62,9 @@ fn next(@pstate st) -> u8 {\n     ret ch as u8;\n }\n \n-fn parse_ty_str(str rep, str_def sd, @ty.type_store tystore) -> ty.t {\n+fn parse_ty_str(str rep, str_def sd, ty.ctxt tcx) -> ty.t {\n     auto len = _str.byte_len(rep);\n-    auto st = @rec(rep=rep, mutable pos=0u, len=len, tystore=tystore);\n+    auto st = @rec(rep=rep, mutable pos=0u, len=len, tcx=tcx);\n     auto result = parse_ty(st, sd);\n     if (st.pos != len) {\n         log_err \"parse_ty_str: incomplete parse, stopped at byte \"\n@@ -77,27 +76,27 @@ fn parse_ty_str(str rep, str_def sd, @ty.type_store tystore) -> ty.t {\n \n fn parse_ty(@pstate st, str_def sd) -> ty.t {\n     alt (next(st) as char) {\n-        case ('n') { ret ty.mk_nil(st.tystore); }\n-        case ('b') { ret ty.mk_bool(st.tystore); }\n-        case ('i') { ret ty.mk_int(st.tystore); }\n-        case ('u') { ret ty.mk_uint(st.tystore); }\n-        case ('l') { ret ty.mk_float(st.tystore); }\n+        case ('n') { ret ty.mk_nil(st.tcx); }\n+        case ('b') { ret ty.mk_bool(st.tcx); }\n+        case ('i') { ret ty.mk_int(st.tcx); }\n+        case ('u') { ret ty.mk_uint(st.tcx); }\n+        case ('l') { ret ty.mk_float(st.tcx); }\n         case ('M') {\n             alt (next(st) as char) {\n-                case ('b') { ret ty.mk_mach(st.tystore, common.ty_u8); }\n-                case ('w') { ret ty.mk_mach(st.tystore, common.ty_u16); }\n-                case ('l') { ret ty.mk_mach(st.tystore, common.ty_u32); }\n-                case ('d') { ret ty.mk_mach(st.tystore, common.ty_u64); }\n-                case ('B') { ret ty.mk_mach(st.tystore, common.ty_i8); }\n-                case ('W') { ret ty.mk_mach(st.tystore, common.ty_i16); }\n-                case ('L') { ret ty.mk_mach(st.tystore, common.ty_i32); }\n-                case ('D') { ret ty.mk_mach(st.tystore, common.ty_i64); }\n-                case ('f') { ret ty.mk_mach(st.tystore, common.ty_f32); }\n-                case ('F') { ret ty.mk_mach(st.tystore, common.ty_f64); }\n+                case ('b') { ret ty.mk_mach(st.tcx, common.ty_u8); }\n+                case ('w') { ret ty.mk_mach(st.tcx, common.ty_u16); }\n+                case ('l') { ret ty.mk_mach(st.tcx, common.ty_u32); }\n+                case ('d') { ret ty.mk_mach(st.tcx, common.ty_u64); }\n+                case ('B') { ret ty.mk_mach(st.tcx, common.ty_i8); }\n+                case ('W') { ret ty.mk_mach(st.tcx, common.ty_i16); }\n+                case ('L') { ret ty.mk_mach(st.tcx, common.ty_i32); }\n+                case ('D') { ret ty.mk_mach(st.tcx, common.ty_i64); }\n+                case ('f') { ret ty.mk_mach(st.tcx, common.ty_f32); }\n+                case ('F') { ret ty.mk_mach(st.tcx, common.ty_f64); }\n             }\n         }\n-        case ('c') { ret ty.mk_char(st.tystore); }\n-        case ('s') { ret ty.mk_str(st.tystore); }\n+        case ('c') { ret ty.mk_char(st.tcx); }\n+        case ('s') { ret ty.mk_str(st.tcx); }\n         case ('t') {\n             check(next(st) as char == '[');\n             auto def = parse_def(st, sd);\n@@ -106,21 +105,21 @@ fn parse_ty(@pstate st, str_def sd) -> ty.t {\n                 params += vec(parse_ty(st, sd));\n             }\n             st.pos = st.pos + 1u;\n-            ret ty.mk_tag(st.tystore, def, params);\n+            ret ty.mk_tag(st.tcx, def, params);\n         }\n-        case ('p') { ret ty.mk_param(st.tystore, parse_int(st) as uint); }\n-        case ('@') { ret ty.mk_box(st.tystore, parse_mt(st, sd)); }\n-        case ('V') { ret ty.mk_vec(st.tystore, parse_mt(st, sd)); }\n-        case ('P') { ret ty.mk_port(st.tystore, parse_ty(st, sd)); }\n-        case ('C') { ret ty.mk_chan(st.tystore, parse_ty(st, sd)); }\n+        case ('p') { ret ty.mk_param(st.tcx, parse_int(st) as uint); }\n+        case ('@') { ret ty.mk_box(st.tcx, parse_mt(st, sd)); }\n+        case ('V') { ret ty.mk_vec(st.tcx, parse_mt(st, sd)); }\n+        case ('P') { ret ty.mk_port(st.tcx, parse_ty(st, sd)); }\n+        case ('C') { ret ty.mk_chan(st.tcx, parse_ty(st, sd)); }\n         case ('T') {\n             check(next(st) as char == '[');\n             let vec[ty.mt] params = vec();\n             while (peek(st) as char != ']') {\n                 params += vec(parse_mt(st, sd));\n             }\n             st.pos = st.pos + 1u;\n-            ret ty.mk_tup(st.tystore, params);\n+            ret ty.mk_tup(st.tcx, params);\n         }\n         case ('R') {\n             check(next(st) as char == '[');\n@@ -134,15 +133,15 @@ fn parse_ty(@pstate st, str_def sd) -> ty.t {\n                 fields += vec(rec(ident=name, mt=parse_mt(st, sd)));\n             }\n             st.pos = st.pos + 1u;\n-            ret ty.mk_rec(st.tystore, fields);\n+            ret ty.mk_rec(st.tcx, fields);\n         }\n         case ('F') {\n             auto func = parse_ty_fn(st, sd);\n-            ret ty.mk_fn(st.tystore, ast.proto_fn, func._0, func._1);\n+            ret ty.mk_fn(st.tcx, ast.proto_fn, func._0, func._1);\n         }\n         case ('W') {\n             auto func = parse_ty_fn(st, sd);\n-            ret ty.mk_fn(st.tystore, ast.proto_iter, func._0, func._1);\n+            ret ty.mk_fn(st.tcx, ast.proto_iter, func._0, func._1);\n         }\n         case ('N') {\n             auto abi;\n@@ -152,7 +151,7 @@ fn parse_ty(@pstate st, str_def sd) -> ty.t {\n                 case ('l') {abi = ast.native_abi_llvm;}\n             }\n             auto func = parse_ty_fn(st, sd);\n-            ret ty.mk_native_fn(st.tystore,abi,func._0,func._1);\n+            ret ty.mk_native_fn(st.tcx,abi,func._0,func._1);\n         }\n         case ('O') {\n             check(next(st) as char == '[');\n@@ -174,11 +173,11 @@ fn parse_ty(@pstate st, str_def sd) -> ty.t {\n                                    output=func._1));\n             }\n             st.pos += 1u;\n-            ret ty.mk_obj(st.tystore, methods);\n+            ret ty.mk_obj(st.tcx, methods);\n         }\n-        case ('X') { ret ty.mk_var(st.tystore, parse_int(st)); }\n-        case ('E') { ret ty.mk_native(st.tystore); }\n-        case ('Y') { ret ty.mk_type(st.tystore); }\n+        case ('X') { ret ty.mk_var(st.tcx, parse_int(st)); }\n+        case ('E') { ret ty.mk_native(st.tcx); }\n+        case ('Y') { ret ty.mk_type(st.tcx); }\n     }\n }\n \n@@ -331,7 +330,7 @@ fn variant_tag_id(&ebml.doc d) -> ast.def_id {\n     ret parse_def_id(ebml.doc_data(tagdoc));\n }\n \n-fn item_type(&ebml.doc item, int this_cnum, @ty.type_store tystore) -> ty.t {\n+fn item_type(&ebml.doc item, int this_cnum, ty.ctxt tcx) -> ty.t {\n     fn parse_external_def_id(int this_cnum, str s) -> ast.def_id {\n         // FIXME: This is completely wrong when linking against a crate\n         // that, in turn, links against another crate. We need a mapping\n@@ -344,7 +343,7 @@ fn item_type(&ebml.doc item, int this_cnum, @ty.type_store tystore) -> ty.t {\n \n     auto tp = ebml.get_doc(item, metadata.tag_items_data_item_type);\n     auto s = _str.unsafe_from_bytes(ebml.doc_data(tp));\n-    ret parse_ty_str(s, bind parse_external_def_id(this_cnum, _), tystore);\n+    ret parse_ty_str(s, bind parse_external_def_id(this_cnum, _), tcx);\n }\n \n fn item_ty_param_count(&ebml.doc item, int this_cnum) -> uint {\n@@ -506,12 +505,12 @@ fn lookup_def(session.session sess, int cnum, vec[ast.ident] path)\n     ret some[ast.def](def);\n }\n \n-fn get_type(session.session sess, @ty.type_store tystore, ast.def_id def)\n+fn get_type(session.session sess, ty.ctxt tcx, ast.def_id def)\n         -> ty.ty_param_count_and_ty {\n     auto external_crate_id = def._0;\n     auto data = sess.get_external_crate(external_crate_id).data;\n     auto item = lookup_item(def._1, data);\n-    auto t = item_type(item, external_crate_id, tystore);\n+    auto t = item_type(item, external_crate_id, tcx);\n \n     auto tp_count;\n     auto kind_ch = item_kind(item);\n@@ -532,9 +531,8 @@ fn get_symbol(session.session sess, ast.def_id def) -> str {\n     ret item_symbol(item);\n }\n \n-fn get_tag_variants(session.session sess,\n-                    @ty.type_store tystore,\n-                    ast.def_id def) -> vec[trans.variant_info] {\n+fn get_tag_variants(session.session sess, ty.ctxt tcx, ast.def_id def)\n+        -> vec[trans.variant_info] {\n     auto external_crate_id = def._0;\n     auto data = sess.get_external_crate(external_crate_id).data;\n     auto items = ebml.get_doc(ebml.new_doc(data), metadata.tag_items);\n@@ -544,9 +542,9 @@ fn get_tag_variants(session.session sess,\n     auto variant_ids = tag_variant_ids(item, external_crate_id);\n     for (ast.def_id did in variant_ids) {\n         auto item = find_item(did._1, items);\n-        auto ctor_ty = item_type(item, external_crate_id, tystore);\n+        auto ctor_ty = item_type(item, external_crate_id, tcx);\n         let vec[ty.t] arg_tys = vec();\n-        alt (ty.struct(tystore, ctor_ty)) {\n+        alt (ty.struct(tcx, ctor_ty)) {\n             case (ty.ty_fn(_, ?args, _)) {\n                 for (ty.arg a in args) {\n                     arg_tys += vec(a.ty);"}, {"sha": "fee9239557901bd9a1bc16fa7e764c44967c7c26", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e102413aadf4cb0e2740b26d249a710ad98cbd14/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e102413aadf4cb0e2740b26d249a710ad98cbd14/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=e102413aadf4cb0e2740b26d249a710ad98cbd14", "patch": "@@ -53,11 +53,11 @@ mod Encode {\n \n     type ctxt = rec(\n         fn(ast.def_id) -> str ds,   // Callback to translate defs to strs.\n-        @ty.type_store tystore      // The type store.\n+        ty.ctxt tcx                 // The type context.\n     );\n \n     fn ty_str(@ctxt cx, ty.t t) -> str {\n-        ret sty_str(cx, ty.struct(cx.tystore, t));\n+        ret sty_str(cx, ty.struct(cx.tcx, t));\n     }\n \n     fn mt_str(@ctxt cx, &ty.mt mt) -> str {\n@@ -337,7 +337,7 @@ fn encode_type(@trans.crate_ctxt cx, &ebml.writer ebml_w, ty.t typ) {\n     ebml.start_tag(ebml_w, tag_items_data_item_type);\n \n     auto f = def_to_str;\n-    auto ty_str_ctxt = @rec(ds=f, tystore=cx.tystore);\n+    auto ty_str_ctxt = @rec(ds=f, tcx=cx.tcx);\n     ebml_w.writer.write(_str.bytes(Encode.ty_str(ty_str_ctxt, typ)));\n \n     ebml.end_tag(ebml_w);\n@@ -457,7 +457,7 @@ fn encode_info_for_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n             encode_def_id(ebml_w, odid.ty);\n             encode_kind(ebml_w, 'y' as u8);\n             encode_type_param_count(ebml_w, tps);\n-            encode_type(cx, ebml_w, ty.ty_fn_ret(cx.tystore, fn_ty));\n+            encode_type(cx, ebml_w, ty.ty_fn_ret(cx.tcx, fn_ty));\n             ebml.end_tag(ebml_w);\n         }\n     }\n@@ -470,7 +470,7 @@ fn encode_info_for_native_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n         case (ast.native_item_ty(_, ?did)) {\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 'T' as u8);\n-            encode_type(cx, ebml_w, ty.mk_native(cx.tystore));\n+            encode_type(cx, ebml_w, ty.mk_native(cx.tcx));\n         }\n         case (ast.native_item_fn(_, _, _, ?tps, ?did, ?ann)) {\n             encode_def_id(ebml_w, did);"}, {"sha": "4a1242abb228b30db5b08bdfe28769a3006b0cf3", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 223, "deletions": 233, "changes": 456, "blob_url": "https://github.com/rust-lang/rust/blob/e102413aadf4cb0e2740b26d249a710ad98cbd14/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e102413aadf4cb0e2740b26d249a710ad98cbd14/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=e102413aadf4cb0e2740b26d249a710ad98cbd14", "patch": "@@ -113,7 +113,7 @@ state type crate_ctxt = rec(session.session sess,\n                             @glue_fns glues,\n                             namegen names,\n                             std.sha1.sha1 sha,\n-                            @ty.type_store tystore);\n+                            ty.ctxt tcx);\n \n type local_ctxt = rec(vec[str] path,\n                       vec[str] module_path,\n@@ -185,7 +185,7 @@ fn mangle_name_by_type(@crate_ctxt ccx, vec[str] path, ty.t t) -> str {\n     ccx.sha.reset();\n \n     auto f = metadata.def_to_str;\n-    auto cx = @rec(ds=f, tystore=ccx.tystore);\n+    auto cx = @rec(ds=f, tcx=ccx.tcx);\n     ccx.sha.input_str(metadata.Encode.ty_str(cx, t));\n \n     ret sep() + \"rust\" + sep()\n@@ -558,9 +558,9 @@ fn T_opaque_obj_ptr(type_names tn) -> TypeRef {\n //\n // TODO: Enforce via a predicate.\n fn type_of(@crate_ctxt cx, ty.t t) -> TypeRef {\n-    if (ty.type_has_dynamic_size(cx.tystore, t)) {\n+    if (ty.type_has_dynamic_size(cx.tcx, t)) {\n         log_err \"type_of() called on a type with dynamic size: \" +\n-            ty.ty_to_str(cx.tystore, t);\n+            ty.ty_to_str(cx.tcx, t);\n         fail;\n     }\n \n@@ -570,7 +570,7 @@ fn type_of(@crate_ctxt cx, ty.t t) -> TypeRef {\n fn type_of_explicit_args(@crate_ctxt cx, vec[ty.arg] inputs) -> vec[TypeRef] {\n     let vec[TypeRef] atys = vec();\n     for (ty.arg arg in inputs) {\n-        if (ty.type_has_dynamic_size(cx.tystore, arg.ty)) {\n+        if (ty.type_has_dynamic_size(cx.tcx, arg.ty)) {\n             check (arg.mode == ast.alias);\n             atys += vec(T_typaram_ptr(cx.tn));\n         } else {\n@@ -605,7 +605,7 @@ fn type_of_fn_full(@crate_ctxt cx,\n     let vec[TypeRef] atys = vec();\n \n     // Arg 0: Output pointer.\n-    if (ty.type_has_dynamic_size(cx.tystore, output)) {\n+    if (ty.type_has_dynamic_size(cx.tcx, output)) {\n         atys += vec(T_typaram_ptr(cx.tn));\n     } else {\n         atys += vec(T_ptr(type_of_inner(cx, output)));\n@@ -642,7 +642,7 @@ fn type_of_fn_full(@crate_ctxt cx,\n             vec(T_fn_pair(cx.tn,\n                           type_of_fn_full(cx, ast.proto_fn, none[TypeRef],\n                                           vec(rec(mode=ast.alias, ty=output)),\n-                                          ty.mk_nil(cx.tystore), 0u)));\n+                                          ty.mk_nil(cx.tcx), 0u)));\n     }\n \n     // ... then explicit args.\n@@ -686,7 +686,7 @@ fn type_of_inner(@crate_ctxt cx, ty.t t) -> TypeRef {\n \n     let TypeRef llty = 0 as TypeRef;\n \n-    alt (ty.struct(cx.tystore, t)) {\n+    alt (ty.struct(cx.tcx, t)) {\n         case (ty.ty_native) { llty = T_ptr(T_i8()); }\n         case (ty.ty_nil) { llty = T_nil(); }\n         case (ty.ty_bool) { llty = T_bool(); }\n@@ -710,7 +710,7 @@ fn type_of_inner(@crate_ctxt cx, ty.t t) -> TypeRef {\n         case (ty.ty_char) { llty = T_char(); }\n         case (ty.ty_str) { llty = T_ptr(T_str()); }\n         case (ty.ty_tag(_, _)) {\n-            if (ty.type_has_dynamic_size(cx.tystore, t)) {\n+            if (ty.type_has_dynamic_size(cx.tcx, t)) {\n                 llty = T_opaque_tag(cx.tn);\n             } else {\n                 auto size = static_size_of_tag(cx, t);\n@@ -786,14 +786,13 @@ fn type_of_inner(@crate_ctxt cx, ty.t t) -> TypeRef {\n     }\n \n     check (llty as int != 0);\n-    llvm.LLVMAddTypeName(cx.llmod, _str.buf(ty.ty_to_str(cx.tystore, t)),\n-                         llty);\n+    llvm.LLVMAddTypeName(cx.llmod, _str.buf(ty.ty_to_str(cx.tcx, t)), llty);\n     cx.lltypes.insert(t, llty);\n     ret llty;\n }\n \n fn type_of_arg(@local_ctxt cx, &ty.arg arg) -> TypeRef {\n-    alt (ty.struct(cx.ccx.tystore, arg.ty)) {\n+    alt (ty.struct(cx.ccx.tcx, arg.ty)) {\n         case (ty.ty_param(_)) {\n             if (arg.mode == ast.alias) {\n                 ret T_typaram_ptr(cx.ccx.tn);\n@@ -815,7 +814,7 @@ fn type_of_arg(@local_ctxt cx, &ty.arg arg) -> TypeRef {\n \n fn type_of_ty_param_count_and_ty(@local_ctxt lcx,\n                                  ty.ty_param_count_and_ty tpt) -> TypeRef {\n-    alt (ty.struct(lcx.ccx.tystore, tpt._1)) {\n+    alt (ty.struct(lcx.ccx.tcx, tpt._1)) {\n         case (ty.ty_fn(?proto, ?inputs, ?output)) {\n             auto llfnty = type_of_fn(lcx.ccx, proto, inputs, output, tpt._0);\n             ret T_fn_pair(lcx.ccx.tn, llfnty);\n@@ -1124,14 +1123,14 @@ fn llalign_of(TypeRef t) -> ValueRef {\n }\n \n fn size_of(@block_ctxt cx, ty.t t) -> result {\n-    if (!ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, t)) {\n+    if (!ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, t)) {\n         ret res(cx, llsize_of(type_of(cx.fcx.lcx.ccx, t)));\n     }\n     ret dynamic_size_of(cx, t);\n }\n \n fn align_of(@block_ctxt cx, ty.t t) -> result {\n-    if (!ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, t)) {\n+    if (!ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, t)) {\n         ret res(cx, llalign_of(type_of(cx.fcx.lcx.ccx, t)));\n     }\n     ret dynamic_align_of(cx, t);\n@@ -1152,20 +1151,20 @@ fn array_alloca(@block_ctxt cx, TypeRef t, ValueRef n) -> ValueRef {\n // types.\n fn simplify_type(@crate_ctxt ccx, ty.t typ) -> ty.t {\n     fn simplifier(@crate_ctxt ccx, ty.t typ) -> ty.t {\n-        alt (ty.struct(ccx.tystore, typ)) {\n+        alt (ty.struct(ccx.tcx, typ)) {\n             case (ty.ty_box(_)) {\n-                ret ty.mk_imm_box(ccx.tystore, ty.mk_nil(ccx.tystore));\n+                ret ty.mk_imm_box(ccx.tcx, ty.mk_nil(ccx.tcx));\n             }\n             case (_) { ret typ; }\n         }\n     }\n     auto f = bind simplifier(ccx, _);\n-    ret ty.fold_ty(ccx.tystore, f, typ);\n+    ret ty.fold_ty(ccx.tcx, f, typ);\n }\n \n // Computes the size of the data part of a non-dynamically-sized tag.\n fn static_size_of_tag(@crate_ctxt cx, ty.t t) -> uint {\n-    if (ty.type_has_dynamic_size(cx.tystore, t)) {\n+    if (ty.type_has_dynamic_size(cx.tcx, t)) {\n         log_err \"dynamically sized type passed to static_size_of_tag()\";\n         fail;\n     }\n@@ -1176,7 +1175,7 @@ fn static_size_of_tag(@crate_ctxt cx, ty.t t) -> uint {\n \n     auto tid;\n     let vec[ty.t] subtys;\n-    alt (ty.struct(cx.tystore, t)) {\n+    alt (ty.struct(cx.tcx, t)) {\n         case (ty.ty_tag(?tid_, ?subtys_)) {\n             tid = tid_;\n             subtys = subtys_;\n@@ -1191,12 +1190,11 @@ fn static_size_of_tag(@crate_ctxt cx, ty.t t) -> uint {\n     auto max_size = 0u;\n     auto variants = tag_variants(cx, tid);\n     for (variant_info variant in variants) {\n-        auto tup_ty = simplify_type(cx,\n-                                    ty.mk_imm_tup(cx.tystore, variant.args));\n+        auto tup_ty = simplify_type(cx, ty.mk_imm_tup(cx.tcx, variant.args));\n \n         // Perform any type parameter substitutions.\n-        tup_ty = ty.bind_params_in_type(cx.tystore, tup_ty);\n-        tup_ty = ty.substitute_type_params(cx.tystore, subtys, tup_ty);\n+        tup_ty = ty.bind_params_in_type(cx.tcx, tup_ty);\n+        tup_ty = ty.substitute_type_params(cx.tcx, subtys, tup_ty);\n \n         // Here we possibly do a recursive call.\n         auto this_size = llsize_of_real(cx, type_of(cx, tup_ty));\n@@ -1236,7 +1234,7 @@ fn dynamic_size_of(@block_ctxt cx, ty.t t) -> result {\n         ret res(bcx, off);\n     }\n \n-    alt (ty.struct(cx.fcx.lcx.ccx.tystore, t)) {\n+    alt (ty.struct(cx.fcx.lcx.ccx.tcx, t)) {\n         case (ty.ty_param(?p)) {\n             auto szptr = field_of_tydesc(cx, t, abi.tydesc_field_size);\n             ret res(szptr.bcx, szptr.bcx.build.Load(szptr.val));\n@@ -1268,10 +1266,9 @@ fn dynamic_size_of(@block_ctxt cx, ty.t t) -> result {\n                 let vec[ty.t] raw_tys = variant.args;\n                 let vec[ty.t] tys = vec();\n                 for (ty.t raw_ty in raw_tys) {\n-                    auto t = ty.bind_params_in_type(cx.fcx.lcx.ccx.tystore,\n+                    auto t = ty.bind_params_in_type(cx.fcx.lcx.ccx.tcx,\n                                                     raw_ty);\n-                    t = ty.substitute_type_params(cx.fcx.lcx.ccx.tystore, tps,\n-                                                  t);\n+                    t = ty.substitute_type_params(cx.fcx.lcx.ccx.tcx, tps, t);\n                     tys += vec(t);\n                 }\n \n@@ -1291,7 +1288,7 @@ fn dynamic_size_of(@block_ctxt cx, ty.t t) -> result {\n }\n \n fn dynamic_align_of(@block_ctxt cx, ty.t t) -> result {\n-    alt (ty.struct(cx.fcx.lcx.ccx.tystore, t)) {\n+    alt (ty.struct(cx.fcx.lcx.ccx.tcx, t)) {\n         case (ty.ty_param(?p)) {\n             auto aptr = field_of_tydesc(cx, t, abi.tydesc_field_align);\n             ret res(aptr.bcx, aptr.bcx.build.Load(aptr.val));\n@@ -1331,11 +1328,11 @@ fn dynamic_align_of(@block_ctxt cx, ty.t t) -> result {\n fn GEP_tup_like(@block_ctxt cx, ty.t t,\n                 ValueRef base, vec[int] ixs) -> result {\n \n-    check (ty.type_is_tup_like(cx.fcx.lcx.ccx.tystore, t));\n+    check (ty.type_is_tup_like(cx.fcx.lcx.ccx.tcx, t));\n \n     // It might be a static-known type. Handle this.\n \n-    if (! ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, t)) {\n+    if (! ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, t)) {\n         let vec[ValueRef] v = vec();\n         for (int i in ixs) {\n             v += vec(C_int(i));\n@@ -1386,11 +1383,11 @@ fn GEP_tup_like(@block_ctxt cx, ty.t t,\n         let int i = 0;\n         while (i < ix) {\n             _vec.push[ty.t](prefix,\n-                            ty.get_element_type(ccx.tystore, t, i as uint));\n+                            ty.get_element_type(ccx.tcx, t, i as uint));\n             i += 1 ;\n         }\n \n-        auto selected = ty.get_element_type(ccx.tystore, t, i as uint);\n+        auto selected = ty.get_element_type(ccx.tcx, t, i as uint);\n \n         if (n == len-1u) {\n             // We are at the innermost index.\n@@ -1411,14 +1408,14 @@ fn GEP_tup_like(@block_ctxt cx, ty.t t,\n     // flattened the incoming structure.\n \n     auto s = split_type(cx.fcx.lcx.ccx, t, ixs, 0u);\n-    auto prefix_ty = ty.mk_imm_tup(cx.fcx.lcx.ccx.tystore, s.prefix);\n+    auto prefix_ty = ty.mk_imm_tup(cx.fcx.lcx.ccx.tcx, s.prefix);\n     auto bcx = cx;\n     auto sz = size_of(bcx, prefix_ty);\n     bcx = sz.bcx;\n     auto raw = bcx.build.PointerCast(base, T_ptr(T_i8()));\n     auto bumped = bcx.build.GEP(raw, vec(sz.val));\n \n-    if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, s.target)) {\n+    if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, s.target)) {\n         ret res(bcx, bumped);\n     }\n \n@@ -1442,12 +1439,12 @@ fn GEP_tag(@block_ctxt cx,\n     // Synthesize a tuple type so that GEP_tup_like() can work its magic.\n     // Separately, store the type of the element we're interested in.\n     auto arg_tys = variant.args;\n-    auto elem_ty = ty.mk_nil(cx.fcx.lcx.ccx.tystore); // typestate infelicity\n+    auto elem_ty = ty.mk_nil(cx.fcx.lcx.ccx.tcx); // typestate infelicity\n     auto i = 0;\n     let vec[ty.t] true_arg_tys = vec();\n     for (ty.t aty in arg_tys) {\n-        auto arg_ty = ty.bind_params_in_type(cx.fcx.lcx.ccx.tystore, aty);\n-        arg_ty = ty.substitute_type_params(cx.fcx.lcx.ccx.tystore, ty_substs,\n+        auto arg_ty = ty.bind_params_in_type(cx.fcx.lcx.ccx.tcx, aty);\n+        arg_ty = ty.substitute_type_params(cx.fcx.lcx.ccx.tcx, ty_substs,\n                                            arg_ty);\n         true_arg_tys += vec(arg_ty);\n         if (i == ix) {\n@@ -1457,12 +1454,12 @@ fn GEP_tag(@block_ctxt cx,\n         i += 1;\n     }\n \n-    auto tup_ty = ty.mk_imm_tup(cx.fcx.lcx.ccx.tystore, true_arg_tys);\n+    auto tup_ty = ty.mk_imm_tup(cx.fcx.lcx.ccx.tcx, true_arg_tys);\n \n     // Cast the blob pointer to the appropriate type, if we need to (i.e. if\n     // the blob pointer isn't dynamically sized).\n     let ValueRef llunionptr;\n-    if (!ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, tup_ty)) {\n+    if (!ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, tup_ty)) {\n         auto llty = type_of(cx.fcx.lcx.ccx, tup_ty);\n         llunionptr = cx.build.TruncOrBitCast(llblobptr, T_ptr(llty));\n     } else {\n@@ -1474,7 +1471,7 @@ fn GEP_tag(@block_ctxt cx,\n \n     // Cast the result to the appropriate type, if necessary.\n     auto val;\n-    if (!ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, elem_ty)) {\n+    if (!ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, elem_ty)) {\n         auto llelemty = type_of(rslt.bcx.fcx.lcx.ccx, elem_ty);\n         val = rslt.bcx.build.PointerCast(rslt.val, T_ptr(llelemty));\n     } else {\n@@ -1497,10 +1494,9 @@ fn trans_raw_malloc(@block_ctxt cx, TypeRef llptr_ty, ValueRef llsize)\n fn trans_malloc_boxed(@block_ctxt cx, ty.t t) -> result {\n     // Synthesize a fake box type structurally so we have something\n     // to measure the size of.\n-    auto boxed_body = ty.mk_imm_tup(cx.fcx.lcx.ccx.tystore,\n-                                    vec(ty.mk_int(cx.fcx.lcx.ccx.tystore),\n-                                        t));\n-    auto box_ptr = ty.mk_imm_box(cx.fcx.lcx.ccx.tystore, t);\n+    auto boxed_body = ty.mk_imm_tup(cx.fcx.lcx.ccx.tcx,\n+                                    vec(ty.mk_int(cx.fcx.lcx.ccx.tcx), t));\n+    auto box_ptr = ty.mk_imm_box(cx.fcx.lcx.ccx.tcx, t);\n     auto sz = size_of(cx, boxed_body);\n     auto llty = type_of(cx.fcx.lcx.ccx, box_ptr);\n     ret trans_raw_malloc(sz.bcx, llty, sz.val);\n@@ -1531,7 +1527,7 @@ fn linearize_ty_params(@block_ctxt cx, ty.t t) ->\n                   mutable vec[uint] defs);\n \n     fn linearizer(@rr r, ty.t t) {\n-        alt(ty.struct(r.cx.fcx.lcx.ccx.tystore, t)) {\n+        alt(ty.struct(r.cx.fcx.lcx.ccx.tcx, t)) {\n             case (ty.ty_param(?pid)) {\n                 let bool seen = false;\n                 for (uint d in r.defs) {\n@@ -1554,22 +1550,22 @@ fn linearize_ty_params(@block_ctxt cx, ty.t t) ->\n                   mutable defs = param_defs);\n \n     auto f = bind linearizer(x, _);\n-    ty.walk_ty(cx.fcx.lcx.ccx.tystore, f, t);\n+    ty.walk_ty(cx.fcx.lcx.ccx.tcx, f, t);\n \n     ret tup(x.defs, x.vals);\n }\n \n fn get_tydesc(&@block_ctxt cx, ty.t t) -> result {\n     // Is the supplied type a type param? If so, return the passed-in tydesc.\n-    alt (ty.type_param(cx.fcx.lcx.ccx.tystore, t)) {\n+    alt (ty.type_param(cx.fcx.lcx.ccx.tcx, t)) {\n         case (some[uint](?id)) { ret res(cx, cx.fcx.lltydescs.(id)); }\n         case (none[uint])      { /* fall through */ }\n     }\n \n     // Does it contain a type param? If so, generate a derived tydesc.\n-    let uint n_params = ty.count_ty_params(cx.fcx.lcx.ccx.tystore, t);\n+    let uint n_params = ty.count_ty_params(cx.fcx.lcx.ccx.tcx, t);\n \n-    if (ty.count_ty_params(cx.fcx.lcx.ccx.tystore, t) > 0u) {\n+    if (ty.count_ty_params(cx.fcx.lcx.ccx.tcx, t) > 0u) {\n         auto tys = linearize_ty_params(cx, t);\n \n         check (n_params == _vec.len[uint](tys._0));\n@@ -1635,7 +1631,7 @@ fn declare_tydesc(@local_ctxt cx, ty.t t) {\n \n     auto llsize;\n     auto llalign;\n-    if (!ty.type_has_dynamic_size(ccx.tystore, t)) {\n+    if (!ty.type_has_dynamic_size(ccx.tcx, t)) {\n         auto llty = type_of(ccx, t);\n         llsize = llsize_of(llty);\n         llalign = llalign_of(llty);\n@@ -1649,7 +1645,7 @@ fn declare_tydesc(@local_ctxt cx, ty.t t) {\n     auto glue_fn_ty = T_ptr(T_glue_fn(ccx.tn));\n \n     auto name = sanitize(ccx.names.next(\"tydesc_\" +\n-        ty.ty_to_str(cx.ccx.tystore, t)));\n+        ty.ty_to_str(cx.ccx.tcx, t)));\n     auto gvar = llvm.LLVMAddGlobal(ccx.llmod, T_tydesc(ccx.tn),\n                                    _str.buf(name));\n     auto tydesc = C_struct(vec(C_null(T_ptr(T_ptr(T_tydesc(ccx.tn)))),\n@@ -1722,7 +1718,7 @@ fn make_generic_glue(@local_ctxt cx,\n     // passed by value.\n \n     auto llty;\n-    if (ty.type_has_dynamic_size(cx.ccx.tystore, t)) {\n+    if (ty.type_has_dynamic_size(cx.ccx.tcx, t)) {\n         llty = T_ptr(T_i8());\n     } else {\n         llty = T_ptr(type_of(cx.ccx, t));\n@@ -1769,10 +1765,10 @@ fn make_generic_glue(@local_ctxt cx,\n fn make_take_glue(@block_ctxt cx, ValueRef v, ty.t t) {\n     // NB: v is an *alias* of type t here, not a direct value.\n     auto bcx;\n-    if (ty.type_is_boxed(cx.fcx.lcx.ccx.tystore, t)) {\n+    if (ty.type_is_boxed(cx.fcx.lcx.ccx.tcx, t)) {\n         bcx = incr_refcnt_of_boxed(cx, cx.build.Load(v)).bcx;\n \n-    } else if (ty.type_is_structural(cx.fcx.lcx.ccx.tystore, t)) {\n+    } else if (ty.type_is_structural(cx.fcx.lcx.ccx.tcx, t)) {\n         bcx = iter_structural_ty(cx, v, t,\n                                  bind take_ty(_, _, _)).bcx;\n     } else {\n@@ -1803,7 +1799,7 @@ fn incr_refcnt_of_boxed(@block_ctxt cx, ValueRef box_ptr) -> result {\n fn make_drop_glue(@block_ctxt cx, ValueRef v0, ty.t t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     auto rslt;\n-    alt (ty.struct(cx.fcx.lcx.ccx.tystore, t)) {\n+    alt (ty.struct(cx.fcx.lcx.ccx.tcx, t)) {\n         case (ty.ty_str) {\n             auto v = cx.build.Load(v0);\n             rslt = decr_refcnt_and_if_zero\n@@ -1944,13 +1940,13 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v0, ty.t t) {\n         }\n \n         case (_) {\n-            if (ty.type_is_structural(cx.fcx.lcx.ccx.tystore, t)) {\n+            if (ty.type_is_structural(cx.fcx.lcx.ccx.tcx, t)) {\n                 rslt = iter_structural_ty(cx, v0, t,\n                                           bind drop_ty(_, _, _));\n \n-            } else if (ty.type_is_scalar(cx.fcx.lcx.ccx.tystore, t) ||\n-                       ty.type_is_native(cx.fcx.lcx.ccx.tystore, t) ||\n-                       ty.type_is_nil(cx.fcx.lcx.ccx.tystore, t)) {\n+            } else if (ty.type_is_scalar(cx.fcx.lcx.ccx.tcx, t) ||\n+                       ty.type_is_native(cx.fcx.lcx.ccx.tcx, t) ||\n+                       ty.type_is_nil(cx.fcx.lcx.ccx.tcx, t)) {\n                 rslt = res(cx, C_nil());\n             }\n         }\n@@ -2012,19 +2008,19 @@ fn make_cmp_glue(@block_ctxt cx,\n     auto lhs = load_if_immediate(cx, lhs0, t);\n     auto rhs = load_if_immediate(cx, rhs0, t);\n \n-    if (ty.type_is_scalar(cx.fcx.lcx.ccx.tystore, t)) {\n+    if (ty.type_is_scalar(cx.fcx.lcx.ccx.tcx, t)) {\n         make_scalar_cmp_glue(cx, lhs, rhs, t, llop);\n \n-    } else if (ty.type_is_box(cx.fcx.lcx.ccx.tystore, t)) {\n+    } else if (ty.type_is_box(cx.fcx.lcx.ccx.tcx, t)) {\n         lhs = cx.build.GEP(lhs, vec(C_int(0), C_int(abi.box_rc_field_body)));\n         rhs = cx.build.GEP(rhs, vec(C_int(0), C_int(abi.box_rc_field_body)));\n         auto rslt = call_cmp_glue(cx, lhs, rhs, t, llop);\n \n         rslt.bcx.build.Store(rslt.val, cx.fcx.llretptr);\n         rslt.bcx.build.RetVoid();\n \n-    } else if (ty.type_is_structural(cx.fcx.lcx.ccx.tystore, t)\n-               || ty.type_is_sequence(cx.fcx.lcx.ccx.tystore, t)) {\n+    } else if (ty.type_is_structural(cx.fcx.lcx.ccx.tcx, t)\n+               || ty.type_is_sequence(cx.fcx.lcx.ccx.tcx, t)) {\n \n         auto scx = new_sub_block_ctxt(cx, \"structural compare start\");\n         auto next = new_sub_block_ctxt(cx, \"structural compare end\");\n@@ -2058,7 +2054,7 @@ fn make_cmp_glue(@block_ctxt cx,\n         llvm.LLVMSetValueName(flag, _str.buf(\"flag\"));\n \n         auto r;\n-        if (ty.type_is_sequence(cx.fcx.lcx.ccx.tystore, t)) {\n+        if (ty.type_is_sequence(cx.fcx.lcx.ccx.tcx, t)) {\n \n             // If we hit == all the way through the minimum-shared-length\n             // section, default to judging the relative sequence lengths.\n@@ -2097,8 +2093,7 @@ fn make_cmp_glue(@block_ctxt cx,\n                 // be i8, because the data part of a vector always has type\n                 // i8[]. So we need to cast it to the proper type.\n \n-                if (!ty.type_has_dynamic_size(last_cx.fcx.lcx.ccx.tystore,\n-                                              t)) {\n+                if (!ty.type_has_dynamic_size(last_cx.fcx.lcx.ccx.tcx, t)) {\n                     auto llelemty = T_ptr(type_of(last_cx.fcx.lcx.ccx, t));\n                     av = cx.build.PointerCast(av, llelemty);\n                     bv = cx.build.PointerCast(bv, llelemty);\n@@ -2120,7 +2115,7 @@ fn make_cmp_glue(@block_ctxt cx,\n             ret res(cnt_cx, C_nil());\n         }\n \n-        if (ty.type_is_structural(cx.fcx.lcx.ccx.tystore, t)) {\n+        if (ty.type_is_structural(cx.fcx.lcx.ccx.tcx, t)) {\n             r = iter_structural_ty_full(r.bcx, lhs, rhs, t,\n                                         bind inner(next, false, flag, llop,\n                                                    _, _, _, _));\n@@ -2130,7 +2125,7 @@ fn make_cmp_glue(@block_ctxt cx,\n             auto min_len = umin(r.bcx, vec_fill(r.bcx, lhs),\n                                 vec_fill(r.bcx, rhs));\n             auto rhs_lim = r.bcx.build.GEP(rhs_p0, vec(min_len));\n-            auto elt_ty = ty.sequence_element_type(cx.fcx.lcx.ccx.tystore, t);\n+            auto elt_ty = ty.sequence_element_type(cx.fcx.lcx.ccx.tcx, t);\n             r = size_of(r.bcx, elt_ty);\n             r = iter_sequence_raw(r.bcx, lhs_p0, rhs_p0, rhs_lim, r.val,\n                                   bind inner(next, true, flag, llop,\n@@ -2148,33 +2143,33 @@ fn make_cmp_glue(@block_ctxt cx,\n         // FIXME: compare obj, fn by pointer?\n         trans_fail(cx, none[common.span],\n                    \"attempt to compare values of type \" +\n-                   ty.ty_to_str(cx.fcx.lcx.ccx.tystore, t));\n+                   ty.ty_to_str(cx.fcx.lcx.ccx.tcx, t));\n     }\n }\n \n // A helper function to create scalar comparison glue.\n fn make_scalar_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs, ty.t t,\n                         ValueRef llop) {\n-    if (ty.type_is_fp(cx.fcx.lcx.ccx.tystore, t)) {\n+    if (ty.type_is_fp(cx.fcx.lcx.ccx.tcx, t)) {\n         make_fp_cmp_glue(cx, lhs, rhs, t, llop);\n         ret;\n     }\n \n-    if (ty.type_is_integral(cx.fcx.lcx.ccx.tystore, t) ||\n-            ty.type_is_bool(cx.fcx.lcx.ccx.tystore, t)) {\n+    if (ty.type_is_integral(cx.fcx.lcx.ccx.tcx, t) ||\n+            ty.type_is_bool(cx.fcx.lcx.ccx.tcx, t)) {\n         make_integral_cmp_glue(cx, lhs, rhs, t, llop);\n         ret;\n     }\n \n-    if (ty.type_is_nil(cx.fcx.lcx.ccx.tystore, t)) {\n+    if (ty.type_is_nil(cx.fcx.lcx.ccx.tcx, t)) {\n         cx.build.Store(C_bool(true), cx.fcx.llretptr);\n         cx.build.RetVoid();\n         ret;\n     }\n \n     trans_fail(cx, none[common.span],\n                \"attempt to compare values of type \" +\n-               ty.ty_to_str(cx.fcx.lcx.ccx.tystore, t));\n+               ty.ty_to_str(cx.fcx.lcx.ccx.tcx, t));\n }\n \n // A helper function to create floating point comparison glue.\n@@ -2254,7 +2249,7 @@ fn compare_integral_values(@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n fn make_integral_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n                           ty.t intype, ValueRef llop) {\n     auto r = compare_integral_values(cx, lhs, rhs,\n-        ty.type_is_signed(cx.fcx.lcx.ccx.tystore, intype), llop);\n+        ty.type_is_signed(cx.fcx.lcx.ccx.tcx, intype), llop);\n     r.bcx.build.Store(r.val, r.bcx.fcx.llretptr);\n     r.bcx.build.RetVoid();\n }\n@@ -2267,7 +2262,7 @@ type variant_info = rec(vec[ty.t] args, ty.t ctor_ty, ast.def_id id);\n // Returns information about the variants in a tag.\n fn tag_variants(@crate_ctxt cx, ast.def_id id) -> vec[variant_info] {\n     if (cx.sess.get_targ_crate_num() != id._0) {\n-        ret creader.get_tag_variants(cx.sess, cx.tystore, id);\n+        ret creader.get_tag_variants(cx.sess, cx.tcx, id);\n     }\n \n     check (cx.items.contains_key(id));\n@@ -2278,7 +2273,7 @@ fn tag_variants(@crate_ctxt cx, ast.def_id id) -> vec[variant_info] {\n                 auto ctor_ty = node_ann_type(cx, variant.node.ann);\n                 let vec[ty.t] arg_tys = vec();\n                 if (_vec.len[ast.variant_arg](variant.node.args) > 0u) {\n-                    for (ty.arg a in ty.ty_fn_args(cx.tystore, ctor_ty)) {\n+                    for (ty.arg a in ty.ty_fn_args(cx.tcx, ctor_ty)) {\n                         arg_tys += vec(a.ty);\n                     }\n                 }\n@@ -2350,8 +2345,8 @@ fn iter_structural_ty_full(@block_ctxt cx,\n                   val_pair_and_ty_fn f) -> result {\n         auto box_a_ptr = cx.build.Load(box_a_cell);\n         auto box_b_ptr = cx.build.Load(box_b_cell);\n-        auto tnil = ty.mk_nil(cx.fcx.lcx.ccx.tystore);\n-        auto tbox = ty.mk_imm_box(cx.fcx.lcx.ccx.tystore, tnil);\n+        auto tnil = ty.mk_nil(cx.fcx.lcx.ccx.tcx);\n+        auto tbox = ty.mk_imm_box(cx.fcx.lcx.ccx.tcx, tnil);\n \n         auto inner_cx = new_sub_block_ctxt(cx, \"iter box\");\n         auto next_cx = new_sub_block_ctxt(cx, \"next\");\n@@ -2363,7 +2358,7 @@ fn iter_structural_ty_full(@block_ctxt cx,\n         ret res(next_cx, r.val);\n     }\n \n-    alt (ty.struct(cx.fcx.lcx.ccx.tystore, t)) {\n+    alt (ty.struct(cx.fcx.lcx.ccx.tcx, t)) {\n         case (ty.ty_tup(?args)) {\n             let int i = 0;\n             for (ty.mt arg in args) {\n@@ -2417,7 +2412,7 @@ fn iter_structural_ty_full(@block_ctxt cx,\n             // comparison know not to proceed when the discriminants differ.\n             auto bcx = cx;\n             bcx = f(bcx, lldiscrim_a, lldiscrim_b,\n-                    ty.mk_int(cx.fcx.lcx.ccx.tystore)).bcx;\n+                    ty.mk_int(cx.fcx.lcx.ccx.tcx)).bcx;\n \n             auto unr_cx = new_sub_block_ctxt(bcx, \"tag-iter-unr\");\n             unr_cx.build.Unreachable();\n@@ -2437,7 +2432,7 @@ fn iter_structural_ty_full(@block_ctxt cx,\n                 if (_vec.len[ty.t](variant.args) > 0u) {\n                     // N-ary variant.\n                     auto fn_ty = variant.ctor_ty;\n-                    alt (ty.struct(bcx.fcx.lcx.ccx.tystore, fn_ty)) {\n+                    alt (ty.struct(bcx.fcx.lcx.ccx.tcx, fn_ty)) {\n                         case (ty.ty_fn(_, ?args, _)) {\n                             auto j = 0;\n                             for (ty.arg a in args) {\n@@ -2454,9 +2449,9 @@ fn iter_structural_ty_full(@block_ctxt cx,\n                                 variant_cx = rslt.bcx;\n \n                                 auto ty_subst = ty.bind_params_in_type(\n-                                    cx.fcx.lcx.ccx.tystore, a.ty);\n+                                    cx.fcx.lcx.ccx.tcx, a.ty);\n                                 ty_subst = ty.substitute_type_params(\n-                                    cx.fcx.lcx.ccx.tystore, tps, ty_subst);\n+                                    cx.fcx.lcx.ccx.tcx, tps, ty_subst);\n \n                                 auto llfld_a =\n                                     load_if_immediate(variant_cx,\n@@ -2577,7 +2572,7 @@ fn iter_sequence_inner(@block_ctxt cx,\n                   ValueRef dst,\n                   ValueRef src) -> result {\n         auto llptrty;\n-        if (!ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, elt_ty)) {\n+        if (!ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, elt_ty)) {\n             auto llty = type_of(cx.fcx.lcx.ccx, elt_ty);\n             llptrty = T_ptr(llty);\n         } else {\n@@ -2612,7 +2607,7 @@ fn iter_sequence(@block_ctxt cx,\n                                           C_int(abi.vec_elt_fill)));\n \n         auto llunit_ty;\n-        if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, elt_ty)) {\n+        if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, elt_ty)) {\n             llunit_ty = T_i8();\n         } else {\n             llunit_ty = type_of(cx.fcx.lcx.ccx, elt_ty);\n@@ -2633,12 +2628,12 @@ fn iter_sequence(@block_ctxt cx,\n         ret iter_sequence_inner(cx, p0, p1, elt_ty, f);\n     }\n \n-    alt (ty.struct(cx.fcx.lcx.ccx.tystore, t)) {\n+    alt (ty.struct(cx.fcx.lcx.ccx.tcx, t)) {\n         case (ty.ty_vec(?elt)) {\n             ret iter_sequence_body(cx, v, elt.ty, f, false);\n         }\n         case (ty.ty_str) {\n-            auto et = ty.mk_mach(cx.fcx.lcx.ccx.tystore, common.ty_u8);\n+            auto et = ty.mk_mach(cx.fcx.lcx.ccx.tcx, common.ty_u8);\n             ret iter_sequence_body(cx, v, et, f, true);\n         }\n         case (_) { fail; }\n@@ -2708,7 +2703,7 @@ fn call_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs, ty.t t,\n }\n \n fn take_ty(@block_ctxt cx, ValueRef v, ty.t t) -> result {\n-    if (!ty.type_is_scalar(cx.fcx.lcx.ccx.tystore, t)) {\n+    if (!ty.type_is_scalar(cx.fcx.lcx.ccx.tcx, t)) {\n         call_tydesc_glue(cx, v, t, abi.tydesc_field_take_glue);\n     }\n     ret res(cx, C_nil());\n@@ -2730,7 +2725,7 @@ fn drop_ty(@block_ctxt cx,\n            ValueRef v,\n            ty.t t) -> result {\n \n-    if (!ty.type_is_scalar(cx.fcx.lcx.ccx.tystore, t)) {\n+    if (!ty.type_is_scalar(cx.fcx.lcx.ccx.tcx, t)) {\n         call_tydesc_glue(cx, v, t, abi.tydesc_field_drop_glue);\n     }\n     ret res(cx, C_nil());\n@@ -2760,7 +2755,7 @@ fn memcpy_ty(@block_ctxt cx,\n              ValueRef dst,\n              ValueRef src,\n              ty.t t) -> result {\n-    if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, t)) {\n+    if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, t)) {\n         auto llszptr = field_of_tydesc(cx, t, abi.tydesc_field_size);\n         auto llsz = llszptr.bcx.build.Load(llszptr.val);\n         ret call_memcpy(llszptr.bcx, dst, src, llsz);\n@@ -2780,22 +2775,22 @@ fn copy_ty(@block_ctxt cx,\n            ValueRef dst,\n            ValueRef src,\n            ty.t t) -> result {\n-    if (ty.type_is_scalar(cx.fcx.lcx.ccx.tystore, t) ||\n-            ty.type_is_native(cx.fcx.lcx.ccx.tystore, t)) {\n+    if (ty.type_is_scalar(cx.fcx.lcx.ccx.tcx, t) ||\n+            ty.type_is_native(cx.fcx.lcx.ccx.tcx, t)) {\n         ret res(cx, cx.build.Store(src, dst));\n \n-    } else if (ty.type_is_nil(cx.fcx.lcx.ccx.tystore, t)) {\n+    } else if (ty.type_is_nil(cx.fcx.lcx.ccx.tcx, t)) {\n         ret res(cx, C_nil());\n \n-    } else if (ty.type_is_boxed(cx.fcx.lcx.ccx.tystore, t)) {\n+    } else if (ty.type_is_boxed(cx.fcx.lcx.ccx.tcx, t)) {\n         auto r = take_ty(cx, src, t);\n         if (action == DROP_EXISTING) {\n             r = drop_ty(r.bcx, r.bcx.build.Load(dst), t);\n         }\n         ret res(r.bcx, r.bcx.build.Store(src, dst));\n \n-    } else if (ty.type_is_structural(cx.fcx.lcx.ccx.tystore, t) ||\n-               ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, t)) {\n+    } else if (ty.type_is_structural(cx.fcx.lcx.ccx.tcx, t) ||\n+               ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, t)) {\n         auto r = take_ty(cx, src, t);\n         if (action == DROP_EXISTING) {\n             r = drop_ty(r.bcx, dst, t);\n@@ -2804,7 +2799,7 @@ fn copy_ty(@block_ctxt cx,\n     }\n \n     cx.fcx.lcx.ccx.sess.bug(\"unexpected type in trans.copy_ty: \" +\n-                        ty.ty_to_str(cx.fcx.lcx.ccx.tystore, t));\n+                        ty.ty_to_str(cx.fcx.lcx.ccx.tcx, t));\n     fail;\n }\n \n@@ -2861,16 +2856,16 @@ fn trans_lit(@crate_ctxt cx, &ast.lit lit, &ast.ann ann) -> ValueRef {\n }\n \n fn target_type(@crate_ctxt cx, ty.t t) -> ty.t {\n-    alt (ty.struct(cx.tystore, t)) {\n+    alt (ty.struct(cx.tcx, t)) {\n         case (ty.ty_int) {\n-            auto struct_ty = ty.mk_mach(cx.tystore,\n+            auto struct_ty = ty.mk_mach(cx.tcx,\n                                         cx.sess.get_targ_cfg().int_type);\n-            ret ty.copy_cname(cx.tystore, struct_ty, t);\n+            ret ty.copy_cname(cx.tcx, struct_ty, t);\n         }\n         case (ty.ty_uint) {\n-            auto struct_ty = ty.mk_mach(cx.tystore,\n+            auto struct_ty = ty.mk_mach(cx.tcx,\n                                         cx.sess.get_targ_cfg().uint_type);\n-            ret ty.copy_cname(cx.tystore, struct_ty, t);\n+            ret ty.copy_cname(cx.tcx, struct_ty, t);\n         }\n         case (_) { /* fall through */ }\n     }\n@@ -2880,7 +2875,7 @@ fn target_type(@crate_ctxt cx, ty.t t) -> ty.t {\n \n // Converts an annotation to a type\n fn node_ann_type(@crate_ctxt cx, &ast.ann a) -> ty.t {\n-    ret target_type(cx, ty.ann_to_monotype(cx.tystore, a));\n+    ret target_type(cx, ty.ann_to_monotype(cx.tcx, a));\n }\n \n fn node_ann_ty_params(&ast.ann a) -> vec[ty.t] {\n@@ -2909,31 +2904,31 @@ fn trans_unary(@block_ctxt cx, ast.unop op,\n                @ast.expr e, &ast.ann a) -> result {\n \n     auto sub = trans_expr(cx, e);\n-    auto e_ty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, e);\n+    auto e_ty = ty.expr_ty(cx.fcx.lcx.ccx.tcx, e);\n \n     alt (op) {\n         case (ast.bitnot) {\n             sub = autoderef(sub.bcx, sub.val,\n-                            ty.expr_ty(cx.fcx.lcx.ccx.tystore, e));\n+                            ty.expr_ty(cx.fcx.lcx.ccx.tcx, e));\n             ret res(sub.bcx, sub.bcx.build.Not(sub.val));\n         }\n         case (ast.not) {\n             sub = autoderef(sub.bcx, sub.val,\n-                            ty.expr_ty(cx.fcx.lcx.ccx.tystore, e));\n+                            ty.expr_ty(cx.fcx.lcx.ccx.tcx, e));\n             ret res(sub.bcx, sub.bcx.build.Not(sub.val));\n         }\n         case (ast.neg) {\n             sub = autoderef(sub.bcx, sub.val,\n-                            ty.expr_ty(cx.fcx.lcx.ccx.tystore, e));\n-            if(ty.struct(cx.fcx.lcx.ccx.tystore, e_ty) == ty.ty_float) {\n+                            ty.expr_ty(cx.fcx.lcx.ccx.tcx, e));\n+            if(ty.struct(cx.fcx.lcx.ccx.tcx, e_ty) == ty.ty_float) {\n                 ret res(sub.bcx, sub.bcx.build.FNeg(sub.val));\n             }\n             else {\n                 ret res(sub.bcx, sub.bcx.build.Neg(sub.val));\n             }\n         }\n         case (ast.box(_)) {\n-            auto e_ty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, e);\n+            auto e_ty = ty.expr_ty(cx.fcx.lcx.ccx.tcx, e);\n             auto e_val = sub.val;\n             auto box_ty = node_ann_type(sub.bcx.fcx.lcx.ccx, a);\n             sub = trans_malloc_boxed(sub.bcx, e_ty);\n@@ -2952,7 +2947,7 @@ fn trans_unary(@block_ctxt cx, ast.unop op,\n             // Cast the body type to the type of the value. This is needed to\n             // make tags work, since tags have a different LLVM type depending\n             // on whether they're boxed or not.\n-            if (!ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, e_ty)) {\n+            if (!ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, e_ty)) {\n                 auto llety = T_ptr(type_of(sub.bcx.fcx.lcx.ccx, e_ty));\n                 body = sub.bcx.build.PointerCast(body, llety);\n             }\n@@ -3013,10 +3008,10 @@ fn trans_compare(@block_ctxt cx0, ast.binop op, ty.t t0,\n fn trans_vec_append(@block_ctxt cx, ty.t t,\n                     ValueRef lhs, ValueRef rhs) -> result {\n \n-    auto elt_ty = ty.sequence_element_type(cx.fcx.lcx.ccx.tystore, t);\n+    auto elt_ty = ty.sequence_element_type(cx.fcx.lcx.ccx.tcx, t);\n \n     auto skip_null = C_bool(false);\n-    alt (ty.struct(cx.fcx.lcx.ccx.tystore, t)) {\n+    alt (ty.struct(cx.fcx.lcx.ccx.tcx, t)) {\n         case (ty.ty_str) { skip_null = C_bool(true); }\n         case (_) { }\n     }\n@@ -3056,7 +3051,7 @@ fn trans_eager_binop(@block_ctxt cx, ast.binop op, ty.t intype,\n                      ValueRef lhs, ValueRef rhs) -> result {\n \n     auto is_float = false;\n-    alt (ty.struct(cx.fcx.lcx.ccx.tystore, intype)) {\n+    alt (ty.struct(cx.fcx.lcx.ccx.tcx, intype)) {\n         case (ty.ty_float) {\n             is_float = true;\n         }\n@@ -3067,7 +3062,7 @@ fn trans_eager_binop(@block_ctxt cx, ast.binop op, ty.t intype,\n \n     alt (op) {\n         case (ast.add) {\n-            if (ty.type_is_sequence(cx.fcx.lcx.ccx.tystore, intype)) {\n+            if (ty.type_is_sequence(cx.fcx.lcx.ccx.tcx, intype)) {\n                 ret trans_vec_add(cx, intype, lhs, rhs);\n             }\n             if (is_float) {\n@@ -3099,7 +3094,7 @@ fn trans_eager_binop(@block_ctxt cx, ast.binop op, ty.t intype,\n             if (is_float) {\n                 ret res(cx, cx.build.FDiv(lhs, rhs));\n             }\n-            if (ty.type_is_signed(cx.fcx.lcx.ccx.tystore, intype)) {\n+            if (ty.type_is_signed(cx.fcx.lcx.ccx.tcx, intype)) {\n                 ret res(cx, cx.build.SDiv(lhs, rhs));\n             } else {\n                 ret res(cx, cx.build.UDiv(lhs, rhs));\n@@ -3109,7 +3104,7 @@ fn trans_eager_binop(@block_ctxt cx, ast.binop op, ty.t intype,\n             if (is_float) {\n                 ret res(cx, cx.build.FRem(lhs, rhs));\n             }\n-            if (ty.type_is_signed(cx.fcx.lcx.ccx.tystore, intype)) {\n+            if (ty.type_is_signed(cx.fcx.lcx.ccx.tcx, intype)) {\n                 ret res(cx, cx.build.SRem(lhs, rhs));\n             } else {\n                 ret res(cx, cx.build.URem(lhs, rhs));\n@@ -3134,7 +3129,7 @@ fn autoderef(@block_ctxt cx, ValueRef v, ty.t t) -> result {\n     let ty.t t1 = t;\n \n     while (true) {\n-        alt (ty.struct(cx.fcx.lcx.ccx.tystore, t1)) {\n+        alt (ty.struct(cx.fcx.lcx.ccx.tcx, t1)) {\n             case (ty.ty_box(?mt)) {\n                 auto body = cx.build.GEP(v1,\n                                          vec(C_int(0),\n@@ -3145,8 +3140,7 @@ fn autoderef(@block_ctxt cx, ValueRef v, ty.t t) -> result {\n                 // to cast this pointer, since statically-sized tag types have\n                 // different types depending on whether they're behind a box\n                 // or not.\n-                if (!ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore,\n-                                              mt.ty)) {\n+                if (!ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, mt.ty)) {\n                     auto llty = type_of(cx.fcx.lcx.ccx, mt.ty);\n                     v1 = cx.build.PointerCast(body, T_ptr(llty));\n                 } else {\n@@ -3166,7 +3160,7 @@ fn autoderefed_ty(@crate_ctxt ccx, ty.t t) -> ty.t {\n     let ty.t t1 = t;\n \n     while (true) {\n-        alt (ty.struct(ccx.tystore, t1)) {\n+        alt (ty.struct(ccx.tcx, t1)) {\n             case (ty.ty_box(?mt)) {\n                 t1 = mt.ty;\n             }\n@@ -3187,12 +3181,12 @@ fn trans_binary(@block_ctxt cx, ast.binop op,\n             // Lazy-eval and\n             auto lhs_res = trans_expr(cx, a);\n             lhs_res = autoderef(lhs_res.bcx, lhs_res.val,\n-                                ty.expr_ty(cx.fcx.lcx.ccx.tystore, a));\n+                                ty.expr_ty(cx.fcx.lcx.ccx.tcx, a));\n \n             auto rhs_cx = new_scope_block_ctxt(cx, \"rhs\");\n             auto rhs_res = trans_expr(rhs_cx, b);\n             rhs_res = autoderef(rhs_res.bcx, rhs_res.val,\n-                                ty.expr_ty(cx.fcx.lcx.ccx.tystore, b));\n+                                ty.expr_ty(cx.fcx.lcx.ccx.tcx, b));\n \n             auto lhs_false_cx = new_scope_block_ctxt(cx, \"lhs false\");\n             auto lhs_false_res = res(lhs_false_cx, C_bool(false));\n@@ -3209,12 +3203,12 @@ fn trans_binary(@block_ctxt cx, ast.binop op,\n             // Lazy-eval or\n             auto lhs_res = trans_expr(cx, a);\n             lhs_res = autoderef(lhs_res.bcx, lhs_res.val,\n-                                ty.expr_ty(cx.fcx.lcx.ccx.tystore, a));\n+                                ty.expr_ty(cx.fcx.lcx.ccx.tcx, a));\n \n             auto rhs_cx = new_scope_block_ctxt(cx, \"rhs\");\n             auto rhs_res = trans_expr(rhs_cx, b);\n             rhs_res = autoderef(rhs_res.bcx, rhs_res.val,\n-                                ty.expr_ty(cx.fcx.lcx.ccx.tystore, b));\n+                                ty.expr_ty(cx.fcx.lcx.ccx.tcx, b));\n \n             auto lhs_true_cx = new_scope_block_ctxt(cx, \"lhs true\");\n             auto lhs_true_res = res(lhs_true_cx, C_bool(true));\n@@ -3230,10 +3224,10 @@ fn trans_binary(@block_ctxt cx, ast.binop op,\n         case (_) {\n             // Remaining cases are eager:\n             auto lhs = trans_expr(cx, a);\n-            auto lhty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, a);\n+            auto lhty = ty.expr_ty(cx.fcx.lcx.ccx.tcx, a);\n             lhs = autoderef(lhs.bcx, lhs.val, lhty);\n             auto rhs = trans_expr(lhs.bcx, b);\n-            auto rhty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, b);\n+            auto rhty = ty.expr_ty(cx.fcx.lcx.ccx.tcx, b);\n             rhs = autoderef(rhs.bcx, rhs.val, rhty);\n             ret trans_eager_binop(rhs.bcx, op,\n                 autoderefed_ty(cx.fcx.lcx.ccx, lhty), lhs.val, rhs.val);\n@@ -3310,12 +3304,12 @@ fn trans_if(@block_ctxt cx, @ast.expr cond,\n             // If we have an else expression, then the entire\n             // if expression can have a non-nil type.\n             // FIXME: This isn't quite right, particularly re: dynamic types\n-            auto expr_ty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, elexpr);\n-            if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, expr_ty)) {\n+            auto expr_ty = ty.expr_ty(cx.fcx.lcx.ccx.tcx, elexpr);\n+            if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, expr_ty)) {\n                 expr_llty = T_typaram_ptr(cx.fcx.lcx.ccx.tn);\n             } else {\n                 expr_llty = type_of(else_res.bcx.fcx.lcx.ccx, expr_ty);\n-                if (ty.type_is_structural(cx.fcx.lcx.ccx.tystore, expr_ty)) {\n+                if (ty.type_is_structural(cx.fcx.lcx.ccx.tcx, expr_ty)) {\n                     expr_llty = T_ptr(expr_llty);\n                 }\n             }\n@@ -3367,7 +3361,7 @@ fn trans_for(@block_ctxt cx,\n     }\n \n     auto next_cx = new_sub_block_ctxt(cx, \"next\");\n-    auto seq_ty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, seq);\n+    auto seq_ty = ty.expr_ty(cx.fcx.lcx.ccx.tcx, seq);\n     auto seq_res = trans_expr(cx, seq);\n     auto it = iter_sequence(seq_res.bcx, seq_res.val, seq_ty,\n                             bind inner(_, local, _, _, body, next_cx));\n@@ -3469,7 +3463,7 @@ fn trans_for_each(@block_ctxt cx,\n \n     auto lcx = cx.fcx.lcx;\n     // FIXME: possibly support alias-mode here?\n-    auto decl_ty = ty.mk_nil(lcx.ccx.tystore);\n+    auto decl_ty = ty.mk_nil(lcx.ccx.tcx);\n     auto decl_id;\n     alt (decl.node) {\n         case (ast.decl_local(?local)) {\n@@ -3557,7 +3551,7 @@ fn trans_for_each(@block_ctxt cx,\n         type_of_fn_full(lcx.ccx, ast.proto_fn,\n                         none[TypeRef],\n                         vec(rec(mode=ast.alias, ty=decl_ty)),\n-                        ty.mk_nil(lcx.ccx.tystore), 0u);\n+                        ty.mk_nil(lcx.ccx.tcx), 0u);\n \n     let ValueRef lliterbody = decl_internal_fastcall_fn(lcx.ccx.llmod,\n                                                        s, iter_body_llty);\n@@ -3738,7 +3732,7 @@ fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n                     matched_cx = rslt.bcx;\n \n                     auto llsubval = load_if_immediate(matched_cx,\n-                        llsubvalptr, pat_ty(cx.fcx.lcx.ccx.tystore, subpat));\n+                        llsubvalptr, pat_ty(cx.fcx.lcx.ccx.tcx, subpat));\n                     auto subpat_res = trans_pat_match(matched_cx, subpat,\n                                                       llsubval, next_cx);\n                     matched_cx = subpat_res.bcx;\n@@ -3833,11 +3827,11 @@ fn trans_alt(@block_ctxt cx, @ast.expr expr,\n     // FIXME: This isn't quite right, particularly re: dynamic types\n     auto expr_ty = ty.ann_to_type(ann);\n     auto expr_llty;\n-    if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, expr_ty)) {\n+    if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, expr_ty)) {\n         expr_llty = T_typaram_ptr(cx.fcx.lcx.ccx.tn);\n     } else {\n         expr_llty = type_of(cx.fcx.lcx.ccx, expr_ty);\n-        if (ty.type_is_structural(cx.fcx.lcx.ccx.tystore, expr_ty)) {\n+        if (ty.type_is_structural(cx.fcx.lcx.ccx.tcx, expr_ty)) {\n             expr_llty = T_ptr(expr_llty);\n         }\n     }\n@@ -3980,21 +3974,18 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                 }\n                 case (ast.def_fn(?did)) {\n                     auto tyt = ty.lookup_item_type(cx.fcx.lcx.ccx.sess,\n-                        cx.fcx.lcx.ccx.tystore,\n-                        cx.fcx.lcx.ccx.type_cache, did);\n+                        cx.fcx.lcx.ccx.tcx, cx.fcx.lcx.ccx.type_cache, did);\n                     ret lval_generic_fn(cx, tyt, did, ann);\n                 }\n                 case (ast.def_obj(?did)) {\n                     auto tyt = ty.lookup_item_type(cx.fcx.lcx.ccx.sess,\n-                        cx.fcx.lcx.ccx.tystore,\n-                        cx.fcx.lcx.ccx.type_cache, did);\n+                        cx.fcx.lcx.ccx.tcx, cx.fcx.lcx.ccx.type_cache, did);\n                     ret lval_generic_fn(cx, tyt, did, ann);\n                 }\n                 case (ast.def_variant(?tid, ?vid)) {\n                     auto v_tyt = ty.lookup_item_type(cx.fcx.lcx.ccx.sess,\n-                        cx.fcx.lcx.ccx.tystore,\n-                        cx.fcx.lcx.ccx.type_cache, vid);\n-                    alt (ty.struct(cx.fcx.lcx.ccx.tystore, v_tyt._1)) {\n+                        cx.fcx.lcx.ccx.tcx, cx.fcx.lcx.ccx.type_cache, vid);\n+                    alt (ty.struct(cx.fcx.lcx.ccx.tcx, v_tyt._1)) {\n                         case (ty.ty_fn(_, _, _)) {\n                             // N-ary variant.\n                             ret lval_generic_fn(cx, v_tyt, vid, ann);\n@@ -4010,8 +4001,8 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                             auto lltagblob = alloc_result.val;\n \n                             auto lltagty;\n-                            if (ty.type_has_dynamic_size(\n-                                    cx.fcx.lcx.ccx.tystore, tag_ty)) {\n+                            if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx,\n+                                                         tag_ty)) {\n                                 lltagty = T_opaque_tag(cx.fcx.lcx.ccx.tn);\n                             } else {\n                                 lltagty = type_of(cx.fcx.lcx.ccx, tag_ty);\n@@ -4035,7 +4026,7 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                 }\n                 case (ast.def_native_fn(?did)) {\n                     auto tyt = ty.lookup_item_type(cx.fcx.lcx.ccx.sess,\n-                        cx.fcx.lcx.ccx.tystore,\n+                        cx.fcx.lcx.ccx.tcx,\n                         cx.fcx.lcx.ccx.type_cache, did);\n                     ret lval_generic_fn(cx, tyt, did, ann);\n                 }\n@@ -4057,7 +4048,7 @@ fn trans_field(@block_ctxt cx, &ast.span sp, ValueRef v, ty.t t0,\n     auto r = autoderef(cx, v, t0);\n     auto t = autoderefed_ty(cx.fcx.lcx.ccx, t0);\n \n-    alt (ty.struct(cx.fcx.lcx.ccx.tystore, t)) {\n+    alt (ty.struct(cx.fcx.lcx.ccx.tcx, t)) {\n         case (ty.ty_tup(_)) {\n             let uint ix = ty.field_num(cx.fcx.lcx.ccx.sess, sp, field);\n             auto v = GEP_tup_like(r.bcx, t, r.val, vec(0, ix as int));\n@@ -4080,7 +4071,7 @@ fn trans_field(@block_ctxt cx, &ast.span sp, ValueRef v, ty.t t0,\n                                                 C_int(ix as int)));\n \n             auto lvo = lval_mem(r.bcx, v);\n-            let ty.t fn_ty = ty.method_ty_to_fn_ty(cx.fcx.lcx.ccx.tystore,\n+            let ty.t fn_ty = ty.method_ty_to_fn_ty(cx.fcx.lcx.ccx.tcx,\n                                                     methods.(ix));\n             ret rec(llobj = some[ValueRef](r.val),\n                     method_ty = some[ty.t](fn_ty)\n@@ -4095,7 +4086,7 @@ fn trans_index(@block_ctxt cx, &ast.span sp, @ast.expr base,\n                @ast.expr idx, &ast.ann ann) -> lval_result {\n \n     auto lv = trans_expr(cx, base);\n-    lv = autoderef(lv.bcx, lv.val, ty.expr_ty(cx.fcx.lcx.ccx.tystore, base));\n+    lv = autoderef(lv.bcx, lv.val, ty.expr_ty(cx.fcx.lcx.ccx.tcx, base));\n     auto ix = trans_expr(lv.bcx, idx);\n     auto v = lv.val;\n     auto bcx = ix.bcx;\n@@ -4136,7 +4127,7 @@ fn trans_index(@block_ctxt cx, &ast.span sp, @ast.expr base,\n \n     auto body = next_cx.build.GEP(v, vec(C_int(0), C_int(abi.vec_elt_data)));\n     auto elt;\n-    if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, unit_ty)) {\n+    if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, unit_ty)) {\n         body = next_cx.build.PointerCast(body, T_ptr(T_array(T_i8(), 0u)));\n         elt = next_cx.build.GEP(body, vec(C_int(0), scaled_ix));\n     } else {\n@@ -4161,7 +4152,7 @@ fn trans_lval(@block_ctxt cx, @ast.expr e) -> lval_result {\n         }\n         case (ast.expr_field(?base, ?ident, ?ann)) {\n             auto r = trans_expr(cx, base);\n-            auto t = ty.expr_ty(cx.fcx.lcx.ccx.tystore, base);\n+            auto t = ty.expr_ty(cx.fcx.lcx.ccx.tcx, base);\n             ret trans_field(r.bcx, e.span, r.val, t, ident, ann);\n         }\n         case (ast.expr_index(?base, ?idx, ?ann)) {\n@@ -4203,16 +4194,16 @@ fn trans_cast(@block_ctxt cx, @ast.expr e, &ast.ann ann) -> result {\n     auto llsrctype = val_ty(e_res.val);\n     auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n     auto lldsttype = type_of(cx.fcx.lcx.ccx, t);\n-    if (!ty.type_is_fp(cx.fcx.lcx.ccx.tystore, t)) {\n+    if (!ty.type_is_fp(cx.fcx.lcx.ccx.tcx, t)) {\n         // TODO: native-to-native casts\n-        if (ty.type_is_native(cx.fcx.lcx.ccx.tystore,\n-                              ty.expr_ty(cx.fcx.lcx.ccx.tystore, e))) {\n+        if (ty.type_is_native(cx.fcx.lcx.ccx.tcx,\n+                              ty.expr_ty(cx.fcx.lcx.ccx.tcx, e))) {\n             e_res.val = e_res.bcx.build.PtrToInt(e_res.val, lldsttype);\n-        } else if (ty.type_is_native(cx.fcx.lcx.ccx.tystore, t)) {\n+        } else if (ty.type_is_native(cx.fcx.lcx.ccx.tcx, t)) {\n             e_res.val = e_res.bcx.build.IntToPtr(e_res.val, lldsttype);\n         } else if (llvm.LLVMGetIntTypeWidth(lldsttype) >\n             llvm.LLVMGetIntTypeWidth(llsrctype)) {\n-            if (ty.type_is_signed(cx.fcx.lcx.ccx.tystore, t)) {\n+            if (ty.type_is_signed(cx.fcx.lcx.ccx.tcx, t)) {\n                 // Widening signed cast.\n                 e_res.val =\n                     e_res.bcx.build.SExtOrBitCast(e_res.val,\n@@ -4255,7 +4246,7 @@ fn trans_bind_thunk(@local_ctxt cx,\n     auto lltop = bcx.llbb;\n \n     auto llclosure_ptr_ty =\n-        type_of(cx.ccx, ty.mk_imm_box(cx.ccx.tystore, closure_ty));\n+        type_of(cx.ccx, ty.mk_imm_box(cx.ccx.tcx, closure_ty));\n     auto llclosure = bcx.build.PointerCast(fcx.llenv, llclosure_ptr_ty);\n \n     auto lltarget = GEP_tup_like(bcx, closure_ty, llclosure,\n@@ -4268,11 +4259,11 @@ fn trans_bind_thunk(@local_ctxt cx,\n                                              C_int(abi.fn_field_box)));\n     lltargetclosure = bcx.build.Load(lltargetclosure);\n \n-    auto outgoing_ret_ty = ty.ty_fn_ret(cx.ccx.tystore, outgoing_fty);\n-    auto outgoing_args = ty.ty_fn_args(cx.ccx.tystore, outgoing_fty);\n+    auto outgoing_ret_ty = ty.ty_fn_ret(cx.ccx.tcx, outgoing_fty);\n+    auto outgoing_args = ty.ty_fn_args(cx.ccx.tcx, outgoing_fty);\n \n     auto llretptr = fcx.llretptr;\n-    if (ty.type_has_dynamic_size(cx.ccx.tystore, outgoing_ret_ty)) {\n+    if (ty.type_has_dynamic_size(cx.ccx.tcx, outgoing_ret_ty)) {\n         llretptr = bcx.build.PointerCast(llretptr, T_typaram_ptr(cx.ccx.tn));\n     }\n \n@@ -4321,8 +4312,7 @@ fn trans_bind_thunk(@local_ctxt cx,\n \n                 if (out_arg.mode == ast.val) {\n                     val = bcx.build.Load(val);\n-                } else if (ty.count_ty_params(cx.ccx.tystore,\n-                                              out_arg.ty) > 0u) {\n+                } else if (ty.count_ty_params(cx.ccx.tcx, out_arg.ty) > 0u) {\n                     check (out_arg.mode == ast.alias);\n                     val = bcx.build.PointerCast(val, llout_arg_ty);\n                 }\n@@ -4335,7 +4325,7 @@ fn trans_bind_thunk(@local_ctxt cx,\n             case (none[@ast.expr]) {\n                 let ValueRef passed_arg = llvm.LLVMGetParam(llthunk, a);\n \n-                if (ty.count_ty_params(cx.ccx.tystore, out_arg.ty) > 0u) {\n+                if (ty.count_ty_params(cx.ccx.tcx, out_arg.ty) > 0u) {\n                     check (out_arg.mode == ast.alias);\n                     passed_arg = bcx.build.PointerCast(passed_arg,\n                                                        llout_arg_ty);\n@@ -4357,7 +4347,7 @@ fn trans_bind_thunk(@local_ctxt cx,\n     // Cast the outgoing function to the appropriate type (see the comments in\n     // trans_bind below for why this is necessary).\n     auto lltargetty = type_of_fn(bcx.fcx.lcx.ccx,\n-                                 ty.ty_fn_proto(bcx.fcx.lcx.ccx.tystore,\n+                                 ty.ty_fn_proto(bcx.fcx.lcx.ccx.tcx,\n                                                 outgoing_fty),\n                                  outgoing_args,\n                                  outgoing_ret_ty,\n@@ -4399,7 +4389,7 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n         let vec[ValueRef] lltydescs;\n         alt (f_res.generic) {\n             case (none[generic_info]) {\n-                outgoing_fty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, f);\n+                outgoing_fty = ty.expr_ty(cx.fcx.lcx.ccx.tcx, f);\n                 lltydescs = vec();\n             }\n             case (some[generic_info](?ginfo)) {\n@@ -4427,19 +4417,19 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n \n                 _vec.push[ValueRef](bound_vals, arg.val);\n                 _vec.push[ty.t](bound_tys,\n-                                 ty.expr_ty(cx.fcx.lcx.ccx.tystore, e));\n+                                 ty.expr_ty(cx.fcx.lcx.ccx.tcx, e));\n \n                 i += 1u;\n             }\n \n             // Synthesize a closure type.\n-            let ty.t bindings_ty = ty.mk_imm_tup(cx.fcx.lcx.ccx.tystore,\n+            let ty.t bindings_ty = ty.mk_imm_tup(cx.fcx.lcx.ccx.tcx,\n                                                   bound_tys);\n \n             // NB: keep this in sync with T_closure_ptr; we're making\n             // a ty.t structure that has the same \"shape\" as the LLVM type\n             // it constructs.\n-            let ty.t tydesc_ty = ty.mk_type(cx.fcx.lcx.ccx.tystore);\n+            let ty.t tydesc_ty = ty.mk_type(cx.fcx.lcx.ccx.tcx);\n \n             let vec[ty.t] captured_tys =\n                 _vec.init_elt[ty.t](tydesc_ty, ty_param_count);\n@@ -4448,9 +4438,9 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n                 vec(tydesc_ty,\n                     outgoing_fty,\n                     bindings_ty,\n-                    ty.mk_imm_tup(cx.fcx.lcx.ccx.tystore, captured_tys));\n+                    ty.mk_imm_tup(cx.fcx.lcx.ccx.tcx, captured_tys));\n \n-            let ty.t closure_ty = ty.mk_imm_tup(cx.fcx.lcx.ccx.tystore,\n+            let ty.t closure_ty = ty.mk_imm_tup(cx.fcx.lcx.ccx.tcx,\n                                                  closure_tys);\n \n             auto r = trans_malloc_boxed(bcx, closure_ty);\n@@ -4481,9 +4471,9 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n             // function has, which type_of() doesn't, as only we know which\n             // item the function refers to.\n             auto llfnty = type_of_fn(bcx.fcx.lcx.ccx,\n-                ty.ty_fn_proto(bcx.fcx.lcx.ccx.tystore, outgoing_fty),\n-                ty.ty_fn_args(bcx.fcx.lcx.ccx.tystore, outgoing_fty),\n-                ty.ty_fn_ret(bcx.fcx.lcx.ccx.tystore, outgoing_fty),\n+                ty.ty_fn_proto(bcx.fcx.lcx.ccx.tcx, outgoing_fty),\n+                ty.ty_fn_args(bcx.fcx.lcx.ccx.tcx, outgoing_fty),\n+                ty.ty_fn_ret(bcx.fcx.lcx.ccx.tcx, outgoing_fty),\n                 ty_param_count);\n             auto llclosurety = T_ptr(T_fn_pair(bcx.fcx.lcx.ccx.tn, llfnty));\n \n@@ -4570,9 +4560,9 @@ fn trans_arg_expr(@block_ctxt cx,\n \n     auto val;\n     auto bcx = cx;\n-    auto e_ty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, e);\n+    auto e_ty = ty.expr_ty(cx.fcx.lcx.ccx.tcx, e);\n \n-    if (ty.type_is_structural(cx.fcx.lcx.ccx.tystore, e_ty)) {\n+    if (ty.type_is_structural(cx.fcx.lcx.ccx.tcx, e_ty)) {\n         auto re = trans_expr(bcx, e);\n         val = re.val;\n         bcx = re.bcx;\n@@ -4603,11 +4593,11 @@ fn trans_arg_expr(@block_ctxt cx,\n         bcx = re.bcx;\n     }\n \n-    if (ty.count_ty_params(cx.fcx.lcx.ccx.tystore, arg.ty) > 0u) {\n+    if (ty.count_ty_params(cx.fcx.lcx.ccx.tcx, arg.ty) > 0u) {\n         auto lldestty = lldestty0;\n         if (arg.mode == ast.val) {\n             // FIXME: we'd prefer to use &&, but rustboot doesn't like it\n-            if (ty.type_is_structural(cx.fcx.lcx.ccx.tystore, e_ty)) {\n+            if (ty.type_is_structural(cx.fcx.lcx.ccx.tcx, e_ty)) {\n                 lldestty = T_ptr(lldestty);\n             }\n         }\n@@ -4616,7 +4606,7 @@ fn trans_arg_expr(@block_ctxt cx,\n \n     if (arg.mode == ast.val) {\n         // FIXME: we'd prefer to use &&, but rustboot doesn't like it\n-        if (ty.type_is_structural(cx.fcx.lcx.ccx.tystore, e_ty)) {\n+        if (ty.type_is_structural(cx.fcx.lcx.ccx.tcx, e_ty)) {\n             // Until here we've been treating structures by pointer;\n             // we are now passing it as an arg, so need to load it.\n             val = bcx.build.Load(val);\n@@ -4641,31 +4631,31 @@ fn trans_args(@block_ctxt cx,\n               ty.t fn_ty)\n     -> tup(@block_ctxt, vec[ValueRef], ValueRef) {\n \n-    let vec[ty.arg] args = ty.ty_fn_args(cx.fcx.lcx.ccx.tystore, fn_ty);\n+    let vec[ty.arg] args = ty.ty_fn_args(cx.fcx.lcx.ccx.tcx, fn_ty);\n     let vec[ValueRef] llargs = vec();\n     let vec[ValueRef] lltydescs = vec();\n     let @block_ctxt bcx = cx;\n \n \n     // Arg 0: Output pointer.\n-    auto retty = ty.ty_fn_ret(cx.fcx.lcx.ccx.tystore, fn_ty);\n+    auto retty = ty.ty_fn_ret(cx.fcx.lcx.ccx.tcx, fn_ty);\n     auto llretslot_res = alloc_ty(bcx, retty);\n     bcx = llretslot_res.bcx;\n     auto llretslot = llretslot_res.val;\n \n     alt (gen) {\n         case (some[generic_info](?g)) {\n             lltydescs = g.tydescs;\n-            args = ty.ty_fn_args(cx.fcx.lcx.ccx.tystore, g.item_type);\n-            retty = ty.ty_fn_ret(cx.fcx.lcx.ccx.tystore, g.item_type);\n+            args = ty.ty_fn_args(cx.fcx.lcx.ccx.tcx, g.item_type);\n+            retty = ty.ty_fn_ret(cx.fcx.lcx.ccx.tcx, g.item_type);\n         }\n         case (_) {\n         }\n     }\n-    if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, retty)) {\n+    if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, retty)) {\n         llargs += vec(bcx.build.PointerCast\n                       (llretslot, T_typaram_ptr(cx.fcx.lcx.ccx.tn)));\n-    } else if (ty.count_ty_params(cx.fcx.lcx.ccx.tystore, retty) != 0u) {\n+    } else if (ty.count_ty_params(cx.fcx.lcx.ccx.tcx, retty) != 0u) {\n         // It's possible that the callee has some generic-ness somewhere in\n         // its return value -- say a method signature within an obj or a fn\n         // type deep in a structure -- which the caller has a concrete view\n@@ -4765,7 +4755,7 @@ fn trans_call(@block_ctxt cx, @ast.expr f,\n         }\n \n         case (_) {\n-            fn_ty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, f);\n+            fn_ty = ty.expr_ty(cx.fcx.lcx.ccx.tcx, f);\n \n         }\n \n@@ -4795,7 +4785,7 @@ fn trans_call(@block_ctxt cx, @ast.expr f,\n \n     alt (lliterbody) {\n         case (none[ValueRef]) {\n-            if (!ty.type_is_nil(cx.fcx.lcx.ccx.tystore, ret_ty)) {\n+            if (!ty.type_is_nil(cx.fcx.lcx.ccx.tcx, ret_ty)) {\n                 retval = load_if_immediate(bcx, llretslot, ret_ty);\n                 // Retval doesn't correspond to anything really tangible in\n                 // the frame, but it's a ref all the same, so we put a note\n@@ -4826,7 +4816,7 @@ fn trans_tup(@block_ctxt cx, vec[ast.elt] elts,\n     let int i = 0;\n \n     for (ast.elt e in elts) {\n-        auto e_ty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, e.expr);\n+        auto e_ty = ty.expr_ty(cx.fcx.lcx.ccx.tcx, e.expr);\n         auto src_res = trans_expr(bcx, e.expr);\n         bcx = src_res.bcx;\n         auto dst_res = GEP_tup_like(bcx, t, tup_val, vec(0, i));\n@@ -4841,7 +4831,7 @@ fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n              &ast.ann ann) -> result {\n     auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n     auto unit_ty = t;\n-    alt (ty.struct(cx.fcx.lcx.ccx.tystore, t)) {\n+    alt (ty.struct(cx.fcx.lcx.ccx.tcx, t)) {\n         case (ty.ty_vec(?mt)) {\n             unit_ty = mt.ty;\n         }\n@@ -4869,7 +4859,7 @@ fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n                                            C_int(abi.vec_elt_data)));\n \n     auto pseudo_tup_ty =\n-        ty.mk_imm_tup(cx.fcx.lcx.ccx.tystore,\n+        ty.mk_imm_tup(cx.fcx.lcx.ccx.tcx,\n                       _vec.init_elt[ty.t](unit_ty,\n                                            _vec.len[@ast.expr](args)));\n     let int i = 0;\n@@ -4893,7 +4883,7 @@ fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n         // (5) \"src_res\" is derived from \"unit_ty\", which is not behind a box.\n \n         auto dst_val;\n-        if (!ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, unit_ty)) {\n+        if (!ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, unit_ty)) {\n             auto llunit_ty = type_of(cx.fcx.lcx.ccx, unit_ty);\n             dst_val = bcx.build.PointerCast(dst_res.val, T_ptr(llunit_ty));\n         } else {\n@@ -4935,7 +4925,7 @@ fn trans_rec(@block_ctxt cx, vec[ast.field] fields,\n     }\n \n     let vec[ty.field] ty_fields = vec();\n-    alt (ty.struct(cx.fcx.lcx.ccx.tystore, t)) {\n+    alt (ty.struct(cx.fcx.lcx.ccx.tcx, t)) {\n         case (ty.ty_rec(?flds)) { ty_fields = flds; }\n     }\n \n@@ -5127,7 +5117,7 @@ fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n     // lval cases fall through to trans_lval and then\n     // possibly load the result (if it's non-structural).\n \n-    auto t = ty.expr_ty(cx.fcx.lcx.ccx.tystore, e);\n+    auto t = ty.expr_ty(cx.fcx.lcx.ccx.tcx, e);\n     auto sub = trans_lval(cx, e);\n     ret res(sub.res.bcx, load_if_immediate(sub.res.bcx, sub.res.val, t));\n }\n@@ -5139,9 +5129,9 @@ fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n // immediate-ness of the type.\n \n fn type_is_immediate(@crate_ctxt ccx, ty.t t) -> bool {\n-    ret ty.type_is_scalar(ccx.tystore, t) ||\n-        ty.type_is_boxed(ccx.tystore, t) ||\n-        ty.type_is_native(ccx.tystore, t);\n+    ret ty.type_is_scalar(ccx.tcx, t) ||\n+        ty.type_is_boxed(ccx.tcx, t) ||\n+        ty.type_is_native(ccx.tcx, t);\n }\n \n fn do_spill(@block_ctxt cx, ValueRef v) -> ValueRef {\n@@ -5188,12 +5178,12 @@ fn trans_log(int lvl, @block_ctxt cx, @ast.expr e) -> result {\n     cx.build.CondBr(test, log_cx.llbb, after_cx.llbb);\n \n     auto sub = trans_expr(log_cx, e);\n-    auto e_ty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, e);\n+    auto e_ty = ty.expr_ty(cx.fcx.lcx.ccx.tcx, e);\n \n-    if (ty.type_is_fp(cx.fcx.lcx.ccx.tystore, e_ty)) {\n+    if (ty.type_is_fp(cx.fcx.lcx.ccx.tcx, e_ty)) {\n         let TypeRef tr;\n         let bool is32bit = false;\n-        alt (ty.struct(cx.fcx.lcx.ccx.tystore, e_ty)) {\n+        alt (ty.struct(cx.fcx.lcx.ccx.tcx, e_ty)) {\n             case (ty.ty_machine(util.common.ty_f32)) {\n                 tr = T_f32();\n                 is32bit = true;\n@@ -5219,7 +5209,7 @@ fn trans_log(int lvl, @block_ctxt cx, @ast.expr e) -> result {\n             uval.bcx.build.Br(after_cx.llbb);\n         }\n     } else {\n-        alt (ty.struct(cx.fcx.lcx.ccx.tystore, e_ty)) {\n+        alt (ty.struct(cx.fcx.lcx.ccx.tcx, e_ty)) {\n             case (ty.ty_str) {\n                 auto v = vp2i(sub.bcx, sub.val);\n                 trans_upcall(sub.bcx,\n@@ -5300,7 +5290,7 @@ fn trans_put(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n     alt (e) {\n         case (none[@ast.expr]) { }\n         case (some[@ast.expr](?x)) {\n-            auto e_ty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, x);\n+            auto e_ty = ty.expr_ty(cx.fcx.lcx.ccx.tcx, x);\n             auto arg = rec(mode=ast.alias, ty=e_ty);\n             auto arg_tys = type_of_explicit_args(cx.fcx.lcx.ccx, vec(arg));\n             auto r = trans_arg_expr(bcx, arg, arg_tys.(0), x);\n@@ -5359,7 +5349,7 @@ fn trans_ret(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n \n     alt (e) {\n         case (some[@ast.expr](?x)) {\n-            auto t = ty.expr_ty(cx.fcx.lcx.ccx.tystore, x);\n+            auto t = ty.expr_ty(cx.fcx.lcx.ccx.tcx, x);\n             auto r = trans_expr(cx, x);\n             bcx = r.bcx;\n             val = r.val;\n@@ -5399,7 +5389,7 @@ fn trans_port(@block_ctxt cx, ast.ann ann) -> result {\n \n     auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n     auto unit_ty;\n-    alt (ty.struct(cx.fcx.lcx.ccx.tystore, t)) {\n+    alt (ty.struct(cx.fcx.lcx.ccx.tcx, t)) {\n         case (ty.ty_port(?t)) {\n             unit_ty = t;\n         }\n@@ -5454,7 +5444,7 @@ fn trans_send(@block_ctxt cx, @ast.expr lhs, @ast.expr rhs,\n \n     auto chan_ty = node_ann_type(cx.fcx.lcx.ccx, ann);\n     auto unit_ty;\n-    alt (ty.struct(cx.fcx.lcx.ccx.tystore, chan_ty)) {\n+    alt (ty.struct(cx.fcx.lcx.ccx.tcx, chan_ty)) {\n         case (ty.ty_chan(?t)) {\n             unit_ty = t;\n         }\n@@ -5546,7 +5536,7 @@ fn init_local(@block_ctxt cx, @ast.local local) -> result {\n \n fn zero_alloca(@block_ctxt cx, ValueRef llptr, ty.t t) -> result {\n     auto bcx = cx;\n-    if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, t)) {\n+    if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, t)) {\n         auto llsz = size_of(bcx, t);\n         bcx = call_bzero(llsz.bcx, llptr, llsz.val).bcx;\n     } else {\n@@ -5679,7 +5669,7 @@ fn llallocas_block_ctxt(@fn_ctxt fcx) -> @block_ctxt {\n \n fn alloc_ty(@block_ctxt cx, ty.t t) -> result {\n     auto val = C_int(0);\n-    if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, t)) {\n+    if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, t)) {\n \n         // NB: we have to run this particular 'size_of' in a\n         // block_ctxt built on the llallocas block for the fn,\n@@ -5734,8 +5724,8 @@ fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n             if (is_terminated(bcx)) {\n                 ret r;\n             } else {\n-                auto r_ty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, e);\n-                if (!ty.type_is_nil(cx.fcx.lcx.ccx.tystore, r_ty)) {\n+                auto r_ty = ty.expr_ty(cx.fcx.lcx.ccx.tcx, e);\n+                if (!ty.type_is_nil(cx.fcx.lcx.ccx.tcx, r_ty)) {\n                     // The value resulting from the block gets copied into an\n                     // alloca created in an outer scope and its refcount\n                     // bumped so that it can escape this block. This means\n@@ -5932,7 +5922,7 @@ fn is_terminated(@block_ctxt cx) -> bool {\n }\n \n fn arg_tys_of_fn(@crate_ctxt ccx, ast.ann ann) -> vec[ty.arg] {\n-    alt (ty.struct(ccx.tystore, ty.ann_to_type(ann))) {\n+    alt (ty.struct(ccx.tcx, ty.ann_to_type(ann))) {\n         case (ty.ty_fn(_, ?arg_tys, _)) {\n             ret arg_tys;\n         }\n@@ -5941,7 +5931,7 @@ fn arg_tys_of_fn(@crate_ctxt ccx, ast.ann ann) -> vec[ty.arg] {\n }\n \n fn ret_ty_of_fn_ty(@crate_ctxt ccx, ty.t t) -> ty.t {\n-    alt (ty.struct(ccx.tystore, t)) {\n+    alt (ty.struct(ccx.tcx, t)) {\n         case (ty.ty_fn(_, _, ?ret_ty)) {\n             ret ret_ty;\n         }\n@@ -5965,7 +5955,7 @@ fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, self_vt llself) {\n \n     // Synthesize a tuple type for the fields so that GEP_tup_like() can work\n     // its magic.\n-    auto fields_tup_ty = ty.mk_imm_tup(fcx.lcx.ccx.tystore, field_tys);\n+    auto fields_tup_ty = ty.mk_imm_tup(fcx.lcx.ccx.tcx, field_tys);\n \n     auto n_typarams = _vec.len[ast.ty_param](bcx.fcx.lcx.obj_typarams);\n     let TypeRef llobj_box_ty = T_obj_ptr(bcx.fcx.lcx.ccx.tn, n_typarams);\n@@ -5992,7 +5982,7 @@ fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, self_vt llself) {\n     // If we can (i.e. the type is statically sized), then cast the resulting\n     // fields pointer to the appropriate LLVM type. If not, just leave it as\n     // i8 *.\n-    if (!ty.type_has_dynamic_size(fcx.lcx.ccx.tystore, fields_tup_ty)) {\n+    if (!ty.type_has_dynamic_size(fcx.lcx.ccx.tcx, fields_tup_ty)) {\n         auto llfields_ty = type_of(fcx.lcx.ccx, fields_tup_ty);\n         obj_fields = vi2p(bcx, obj_fields, T_ptr(llfields_ty));\n     } else {\n@@ -6077,7 +6067,7 @@ fn trans_vtbl(@local_ctxt cx,\n     for (@ast.method m in meths) {\n \n         auto llfnty = T_nil();\n-        alt (ty.struct(cx.ccx.tystore, node_ann_type(cx.ccx, m.node.ann))) {\n+        alt (ty.struct(cx.ccx.tcx, node_ann_type(cx.ccx, m.node.ann))) {\n             case (ty.ty_fn(?proto, ?inputs, ?output)) {\n                 llfnty = type_of_fn_full(cx.ccx, proto,\n                                          some[TypeRef](llself_ty),\n@@ -6116,7 +6106,7 @@ fn trans_dtor(@local_ctxt cx,\n               &@ast.method dtor) -> ValueRef {\n \n     auto llfnty = T_nil();\n-    alt (ty.struct(cx.ccx.tystore, node_ann_type(cx.ccx, dtor.node.ann))) {\n+    alt (ty.struct(cx.ccx.tcx, node_ann_type(cx.ccx, dtor.node.ann))) {\n         case (ty.ty_fn(?proto, ?inputs, ?output)) {\n             llfnty = type_of_fn_full(cx.ccx, proto,\n                                      some[TypeRef](llself_ty),\n@@ -6190,19 +6180,19 @@ fn trans_obj(@local_ctxt cx, &ast._obj ob, ast.def_id oid,\n         }\n \n         // Synthesize an obj body type.\n-        auto tydesc_ty = ty.mk_type(cx.ccx.tystore);\n+        auto tydesc_ty = ty.mk_type(cx.ccx.tcx);\n         let vec[ty.t] tps = vec();\n         for (ast.ty_param tp in ty_params) {\n             _vec.push[ty.t](tps, tydesc_ty);\n         }\n \n-        let ty.t typarams_ty = ty.mk_imm_tup(cx.ccx.tystore, tps);\n-        let ty.t fields_ty = ty.mk_imm_tup(cx.ccx.tystore, obj_fields);\n-        let ty.t body_ty = ty.mk_imm_tup(cx.ccx.tystore,\n+        let ty.t typarams_ty = ty.mk_imm_tup(cx.ccx.tcx, tps);\n+        let ty.t fields_ty = ty.mk_imm_tup(cx.ccx.tcx, obj_fields);\n+        let ty.t body_ty = ty.mk_imm_tup(cx.ccx.tcx,\n                                           vec(tydesc_ty,\n                                               typarams_ty,\n                                               fields_ty));\n-        let ty.t boxed_body_ty = ty.mk_imm_box(cx.ccx.tystore, body_ty);\n+        let ty.t boxed_body_ty = ty.mk_imm_box(cx.ccx.tcx, body_ty);\n \n         // Malloc a box for the body.\n         auto box = trans_malloc_boxed(bcx, body_ty);\n@@ -6304,7 +6294,7 @@ fn trans_tag_variant(@local_ctxt cx, ast.def_id tag_id,\n     let vec[ty.t] ty_param_substs = vec();\n     i = 0u;\n     for (ast.ty_param tp in ty_params) {\n-        ty_param_substs += vec(ty.mk_param(cx.ccx.tystore, i));\n+        ty_param_substs += vec(ty.mk_param(cx.ccx.tcx, i));\n         i += 1u;\n     }\n \n@@ -6340,8 +6330,8 @@ fn trans_tag_variant(@local_ctxt cx, ast.def_id tag_id,\n \n         auto arg_ty = arg_tys.(i).ty;\n         auto llargval;\n-        if (ty.type_is_structural(cx.ccx.tystore, arg_ty) ||\n-                ty.type_has_dynamic_size(cx.ccx.tystore, arg_ty)) {\n+        if (ty.type_is_structural(cx.ccx.tcx, arg_ty) ||\n+                ty.type_has_dynamic_size(cx.ccx.tcx, arg_ty)) {\n             llargval = llargptr;\n         } else {\n             llargval = bcx.build.Load(llargptr);\n@@ -6440,7 +6430,7 @@ fn decl_fn_and_pair(@crate_ctxt ccx,\n \n     auto llfty;\n     auto llpairty;\n-    alt (ty.struct(ccx.tystore, node_ann_type(ccx, ann))) {\n+    alt (ty.struct(ccx.tcx, node_ann_type(ccx, ann))) {\n         case (ty.ty_fn(?proto, ?inputs, ?output)) {\n             llfty = type_of_fn(ccx, proto, inputs, output,\n                                _vec.len[ast.ty_param](ty_params));\n@@ -6499,7 +6489,7 @@ fn native_fn_ty_param_count(@crate_ctxt cx, &ast.def_id id) -> uint {\n \n fn native_fn_wrapper_type(@crate_ctxt cx, uint ty_param_count, ty.t x)\n         -> TypeRef {\n-    alt (ty.struct(cx.tystore, x)) {\n+    alt (ty.struct(cx.tcx, x)) {\n         case (ty.ty_native_fn(?abi, ?args, ?out)) {\n             ret type_of_fn(cx, ast.proto_fn, args, out, ty_param_count);\n         }\n@@ -6536,10 +6526,10 @@ fn decl_native_fn_and_pair(@crate_ctxt ccx,\n     auto item = ccx.native_items.get(id);\n     auto fn_type = node_ann_type(ccx, ann);  // NB: has no type params\n \n-    auto abi = ty.ty_fn_abi(ccx.tystore, fn_type);\n+    auto abi = ty.ty_fn_abi(ccx.tcx, fn_type);\n     auto llfnty = type_of_native_fn(ccx, abi,\n-        ty.ty_fn_args(ccx.tystore, fn_type),\n-        ty.ty_fn_ret(ccx.tystore, fn_type), num_ty_param);\n+        ty.ty_fn_args(ccx.tcx, fn_type),\n+        ty.ty_fn_ret(ccx.tcx, fn_type), num_ty_param);\n \n     let vec[ValueRef] call_args = vec();\n     auto arg_n = 3u;\n@@ -6570,7 +6560,7 @@ fn decl_native_fn_and_pair(@crate_ctxt ccx,\n                 &mutable vec[ValueRef] args,\n                 ValueRef v,\n                 ty.t t) {\n-        if (ty.type_is_integral(cx.fcx.lcx.ccx.tystore, t)) {\n+        if (ty.type_is_integral(cx.fcx.lcx.ccx.tcx, t)) {\n             auto lldsttype = T_int();\n             auto llsrctype = type_of(cx.fcx.lcx.ccx, t);\n             if (llvm.LLVMGetIntTypeWidth(lldsttype) >\n@@ -6579,7 +6569,7 @@ fn decl_native_fn_and_pair(@crate_ctxt ccx,\n             } else {\n                 args += vec(cx.build.TruncOrBitCast(v, T_int()));\n             }\n-        } else if (ty.type_is_fp(cx.fcx.lcx.ccx.tystore, t)) {\n+        } else if (ty.type_is_fp(cx.fcx.lcx.ccx.tcx, t)) {\n             args += vec(cx.build.FPToSI(v, T_int()));\n         } else {\n             args += vec(vp2i(cx, v));\n@@ -6588,7 +6578,7 @@ fn decl_native_fn_and_pair(@crate_ctxt ccx,\n \n     auto r;\n     auto rptr;\n-    auto args = ty.ty_fn_args(ccx.tystore, fn_type);\n+    auto args = ty.ty_fn_args(ccx.tcx, fn_type);\n     if (abi == ast.native_abi_llvm) {\n         let vec[ValueRef] call_args = vec();\n         let vec[TypeRef] call_arg_tys = vec();\n@@ -6601,7 +6591,7 @@ fn decl_native_fn_and_pair(@crate_ctxt ccx,\n         }\n         auto llnativefnty = T_fn(call_arg_tys,\n                                  type_of(ccx,\n-                                         ty.ty_fn_ret(ccx.tystore, fn_type)));\n+                                         ty.ty_fn_ret(ccx.tcx, fn_type)));\n         auto llnativefn = get_extern_fn(ccx.externs, ccx.llmod, name,\n                                         lib.llvm.LLVMCCallConv, llnativefnty);\n         r = bcx.build.Call(llnativefn, call_args);\n@@ -7502,7 +7492,7 @@ fn create_crate_map(@crate_ctxt ccx) -> ValueRef {\n     ret map;\n }\n \n-fn trans_crate(session.session sess, @ast.crate crate, @ty.type_store tystore,\n+fn trans_crate(session.session sess, @ast.crate crate, ty.ctxt tcx,\n                &ty.type_cache type_cache, str output, bool shared,\n                bool optimize, bool verify, output_type ot) {\n     auto llmod =\n@@ -7549,7 +7539,7 @@ fn trans_crate(session.session sess, @ast.crate crate, @ty.type_store tystore,\n                     glues = glues,\n                     names = namegen(0),\n                     sha = std.sha1.mk_sha1(),\n-                    tystore = tystore);\n+                    tcx = tcx);\n     auto cx = new_local_ctxt(ccx);\n \n     create_typedefs(ccx);"}, {"sha": "71a98e77e1f017680a8c9d656a25731de545a95e", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 269, "deletions": 281, "changes": 550, "blob_url": "https://github.com/rust-lang/rust/blob/e102413aadf4cb0e2740b26d249a710ad98cbd14/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e102413aadf4cb0e2740b26d249a710ad98cbd14/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=e102413aadf4cb0e2740b26d249a710ad98cbd14", "patch": "@@ -44,10 +44,15 @@ type method = rec(ast.proto proto,\n \n type mt = rec(t ty, ast.mutability mut);\n \n+// Contains information needed to resolve types and (in the future) look up\n+// the types of AST nodes.\n+type ctxt = rec(@type_store ts);\n+type ty_ctxt = ctxt;    // Needed for disambiguation from Unify.ctxt.\n+\n // Convert from method type to function type.  Pretty easy; we just drop\n // 'ident'.\n-fn method_ty_to_fn_ty(@type_store tystore, method m) -> t {\n-    ret mk_fn(tystore, m.proto, m.inputs, m.output);\n+fn method_ty_to_fn_ty(ctxt cx, method m) -> t {\n+    ret mk_fn(cx, m.proto, m.inputs, m.output);\n }\n \n // Never construct these manually. These are interned. Also don't assume that\n@@ -186,12 +191,14 @@ fn mk_type_store() -> @type_store {\n              others=map.mk_hashmap[t,t](hasher, eqer));\n }\n \n+fn mk_ctxt() -> ctxt { ret rec(ts=mk_type_store()); }\n+\n // Type constructors\n \n // These are private constructors to this module. External users should always\n // use the mk_foo() functions below.\n-fn gen_ty(@type_store tystore, &sty st) -> t {\n-    ret gen_ty_full(tystore, st, none[str]);\n+fn gen_ty(ctxt cx, &sty st) -> t {\n+    ret gen_ty_full(cx, st, none[str]);\n }\n \n fn mk_ty_full(&sty st, option.t[str] cname) -> t {\n@@ -200,135 +207,130 @@ fn mk_ty_full(&sty st, option.t[str] cname) -> t {\n     ret @rec(struct=st, cname=cname, magic=magic, hash=h);\n }\n \n-fn gen_ty_full(@type_store tystore, &sty st, option.t[str] cname) -> t {\n+fn gen_ty_full(ctxt cx, &sty st, option.t[str] cname) -> t {\n     auto new_type = mk_ty_full(st, cname);\n     // Is it interned?\n-    alt (tystore.others.find(new_type)) {\n+    alt (cx.ts.others.find(new_type)) {\n         case (some[t](?typ)) {\n             ret typ;\n         }\n         case (none[t]) {\n             // Nope. Insert it and return.\n-            tystore.others.insert(new_type, new_type);\n+            cx.ts.others.insert(new_type, new_type);\n             ret new_type;\n         }\n     }\n }\n \n-fn mk_nil(@type_store ts) -> t          { ret ts.t_nil; }\n-fn mk_bool(@type_store ts) -> t         { ret ts.t_bool; }\n-fn mk_int(@type_store ts) -> t          { ret ts.t_int; }\n-fn mk_float(@type_store ts) -> t        { ret ts.t_float; }\n-fn mk_uint(@type_store ts) -> t         { ret ts.t_uint; }\n+fn mk_nil(ctxt cx) -> t     { ret cx.ts.t_nil; }\n+fn mk_bool(ctxt cx) -> t    { ret cx.ts.t_bool; }\n+fn mk_int(ctxt cx) -> t     { ret cx.ts.t_int; }\n+fn mk_float(ctxt cx) -> t   { ret cx.ts.t_float; }\n+fn mk_uint(ctxt cx) -> t    { ret cx.ts.t_uint; }\n \n-fn mk_mach(@type_store ts, util.common.ty_mach tm) -> t {\n+fn mk_mach(ctxt cx, util.common.ty_mach tm) -> t {\n     alt (tm) {\n-        case (ty_u8) { ret ts.t_u8; }\n-        case (ty_u16) { ret ts.t_u16; }\n-        case (ty_u32) { ret ts.t_u32; }\n-        case (ty_u64) { ret ts.t_u64; }\n+        case (ty_u8)  { ret cx.ts.t_u8; }\n+        case (ty_u16) { ret cx.ts.t_u16; }\n+        case (ty_u32) { ret cx.ts.t_u32; }\n+        case (ty_u64) { ret cx.ts.t_u64; }\n \n-        case (ty_i8) { ret ts.t_i8; }\n-        case (ty_i16) { ret ts.t_i16; }\n-        case (ty_i32) { ret ts.t_i32; }\n-        case (ty_i64) { ret ts.t_i64; }\n+        case (ty_i8)  { ret cx.ts.t_i8; }\n+        case (ty_i16) { ret cx.ts.t_i16; }\n+        case (ty_i32) { ret cx.ts.t_i32; }\n+        case (ty_i64) { ret cx.ts.t_i64; }\n \n-        case (ty_f32) { ret ts.t_f32; }\n-        case (ty_f64) { ret ts.t_f64; }\n+        case (ty_f32) { ret cx.ts.t_f32; }\n+        case (ty_f64) { ret cx.ts.t_f64; }\n     }\n     fail;\n }\n \n-fn mk_char(@type_store ts) -> t         { ret ts.t_char; }\n-fn mk_str(@type_store ts) -> t          { ret ts.t_str; }\n+fn mk_char(ctxt cx) -> t    { ret cx.ts.t_char; }\n+fn mk_str(ctxt cx) -> t     { ret cx.ts.t_str; }\n \n-fn mk_tag(@type_store ts, ast.def_id did, vec[t] tys) -> t {\n-    ret gen_ty(ts, ty_tag(did, tys));\n+fn mk_tag(ctxt cx, ast.def_id did, vec[t] tys) -> t {\n+    ret gen_ty(cx, ty_tag(did, tys));\n }\n \n-fn mk_box(@type_store ts, mt tm) -> t {\n-    ret gen_ty(ts, ty_box(tm));\n+fn mk_box(ctxt cx, mt tm) -> t {\n+    ret gen_ty(cx, ty_box(tm));\n }\n \n-fn mk_imm_box(@type_store ts, t ty) -> t {\n-    ret mk_box(ts, rec(ty=ty, mut=ast.imm));\n+fn mk_imm_box(ctxt cx, t ty) -> t {\n+    ret mk_box(cx, rec(ty=ty, mut=ast.imm));\n }\n \n-fn mk_vec(@type_store ts, mt tm) -> t   { ret gen_ty(ts, ty_vec(tm)); }\n-fn mk_port(@type_store ts, t ty) -> t   { ret gen_ty(ts, ty_port(ty)); }\n-fn mk_chan(@type_store ts, t ty) -> t   { ret gen_ty(ts, ty_chan(ty)); }\n-fn mk_task(@type_store ts) -> t         { ret gen_ty(ts, ty_task); }\n+fn mk_vec(ctxt cx, mt tm) -> t  { ret gen_ty(cx, ty_vec(tm)); }\n+fn mk_port(ctxt cx, t ty) -> t  { ret gen_ty(cx, ty_port(ty)); }\n+fn mk_chan(ctxt cx, t ty) -> t  { ret gen_ty(cx, ty_chan(ty)); }\n+fn mk_task(ctxt cx) -> t        { ret gen_ty(cx, ty_task); }\n \n-fn mk_tup(@type_store ts, vec[mt] tms) -> t {\n-    ret gen_ty(ts, ty_tup(tms));\n-}\n+fn mk_tup(ctxt cx, vec[mt] tms) -> t { ret gen_ty(cx, ty_tup(tms)); }\n \n-fn mk_imm_tup(@type_store ts, vec[t] tys) -> t {\n+fn mk_imm_tup(ctxt cx, vec[t] tys) -> t {\n     // TODO: map\n     let vec[ty.mt] mts = vec();\n     for (t typ in tys) {\n         mts += vec(rec(ty=typ, mut=ast.imm));\n     }\n-    ret mk_tup(ts, mts);\n+    ret mk_tup(cx, mts);\n }\n \n-fn mk_rec(@type_store ts, vec[field] fs) -> t {\n-    ret gen_ty(ts, ty_rec(fs));\n-}\n+fn mk_rec(ctxt cx, vec[field] fs) -> t { ret gen_ty(cx, ty_rec(fs)); }\n \n-fn mk_fn(@type_store ts, ast.proto proto, vec[arg] args, t ty) -> t {\n-    ret gen_ty(ts, ty_fn(proto, args, ty));\n+fn mk_fn(ctxt cx, ast.proto proto, vec[arg] args, t ty) -> t {\n+    ret gen_ty(cx, ty_fn(proto, args, ty));\n }\n \n-fn mk_native_fn(@type_store ts, ast.native_abi abi, vec[arg] args, t ty)\n-        -> t {\n-    ret gen_ty(ts, ty_native_fn(abi, args, ty));\n+fn mk_native_fn(ctxt cx, ast.native_abi abi, vec[arg] args, t ty) -> t {\n+    ret gen_ty(cx, ty_native_fn(abi, args, ty));\n }\n \n-fn mk_obj(@type_store ts, vec[method] meths) -> t {\n-    ret gen_ty(ts, ty_obj(meths));\n+fn mk_obj(ctxt cx, vec[method] meths) -> t {\n+    ret gen_ty(cx, ty_obj(meths));\n }\n \n-fn mk_var(@type_store ts, int v) -> t    {\n-    let int i = _vec.len[t](ts.t_vars) as int;\n+fn mk_var(ctxt cx, int v) -> t    {\n+    let int i = _vec.len[t](cx.ts.t_vars) as int;\n     while (i <= v) {\n-        ts.t_vars += vec(mk_ty_full(ty_var(i), none[str]));\n+        cx.ts.t_vars += vec(mk_ty_full(ty_var(i), none[str]));\n         i += 1;\n     }\n-    ret ts.t_vars.(v);\n+    ret cx.ts.t_vars.(v);\n }\n \n-fn mk_local(@type_store ts, ast.def_id did) -> t {\n-    ret gen_ty(ts, ty_local(did));\n+fn mk_local(ctxt cx, ast.def_id did) -> t {\n+    ret gen_ty(cx, ty_local(did));\n }\n \n-fn mk_param(@type_store ts, uint n) -> t {\n-    let uint i = _vec.len[t](ts.t_params);\n+fn mk_param(ctxt cx, uint n) -> t {\n+    let uint i = _vec.len[t](cx.ts.t_params);\n     while (i <= n) {\n-        ts.t_params += vec(mk_ty_full(ty_param(i), none[str]));\n+        cx.ts.t_params += vec(mk_ty_full(ty_param(i), none[str]));\n         i += 1u;\n     }\n-    ret ts.t_params.(n);\n+    ret cx.ts.t_params.(n);\n }\n \n-fn mk_bound_param(@type_store ts, uint n) -> t {\n-    let uint i = _vec.len[t](ts.t_bound_params);\n+fn mk_bound_param(ctxt cx, uint n) -> t {\n+    let uint i = _vec.len[t](cx.ts.t_bound_params);\n     while (i <= n) {\n-        ts.t_bound_params += vec(mk_ty_full(ty_bound_param(i), none[str]));\n+        cx.ts.t_bound_params += vec(mk_ty_full(ty_bound_param(i), none[str]));\n         i += 1u;\n     }\n-    ret ts.t_bound_params.(n);\n+    ret cx.ts.t_bound_params.(n);\n }\n \n-fn mk_type(@type_store ts) -> t          { ret ts.t_type; }\n-fn mk_native(@type_store ts) -> t        { ret ts.t_native; }\n+fn mk_type(ctxt cx) -> t    { ret cx.ts.t_type; }\n+fn mk_native(ctxt cx) -> t  { ret cx.ts.t_native; }\n \n \n // Returns the one-level-deep type structure of the given type.\n-fn struct(@type_store tystore, t typ) -> sty { ret typ.struct; }\n+fn struct(ctxt cx, t typ) -> sty { ret typ.struct; }\n \n // Returns the canonical name of the given type.\n-fn cname(@type_store tystore, t typ) -> option.t[str] { ret typ.cname; }\n+fn cname(ctxt cx, t typ) -> option.t[str] { ret typ.cname; }\n \n \n // Stringification\n@@ -344,25 +346,24 @@ fn path_to_str(&ast.path pth) -> str {\n     ret result;\n }\n \n-fn ty_to_str(@type_store ts, &t typ) -> str {\n+fn ty_to_str(ctxt cx, &t typ) -> str {\n \n-    fn fn_input_to_str(@type_store tystore,\n-                       &rec(ast.mode mode, t ty) input) -> str {\n+    fn fn_input_to_str(ctxt cx, &rec(ast.mode mode, t ty) input) -> str {\n         auto s;\n         if (mode_is_alias(input.mode)) {\n             s = \"&\";\n         } else {\n             s = \"\";\n         }\n \n-        ret s + ty_to_str(tystore, input.ty);\n+        ret s + ty_to_str(cx, input.ty);\n     }\n \n-    fn fn_to_str(@type_store tystore,\n+    fn fn_to_str(ctxt cx,\n                  ast.proto proto,\n                  option.t[ast.ident] ident,\n                  vec[arg] inputs, t output) -> str {\n-            auto f = bind fn_input_to_str(tystore, _);\n+            auto f = bind fn_input_to_str(cx, _);\n \n             auto s;\n             alt (proto) {\n@@ -386,34 +387,34 @@ fn ty_to_str(@type_store ts, &t typ) -> str {\n             s += _str.connect(_vec.map[arg,str](f, inputs), \", \");\n             s += \")\";\n \n-            if (struct(tystore, output) != ty_nil) {\n-                s += \" -> \" + ty_to_str(tystore, output);\n+            if (struct(cx, output) != ty_nil) {\n+                s += \" -> \" + ty_to_str(cx, output);\n             }\n             ret s;\n     }\n \n-    fn method_to_str(@type_store tystore, &method m) -> str {\n-        ret fn_to_str(tystore, m.proto, some[ast.ident](m.ident),\n+    fn method_to_str(ctxt cx, &method m) -> str {\n+        ret fn_to_str(cx, m.proto, some[ast.ident](m.ident),\n                       m.inputs, m.output) + \";\";\n     }\n \n-    fn field_to_str(@type_store tystore, &field f) -> str {\n-        ret mt_to_str(tystore, f.mt) + \" \" + f.ident;\n+    fn field_to_str(ctxt cx, &field f) -> str {\n+        ret mt_to_str(cx, f.mt) + \" \" + f.ident;\n     }\n \n-    fn mt_to_str(@type_store tystore, &mt m) -> str {\n+    fn mt_to_str(ctxt cx, &mt m) -> str {\n         auto mstr;\n         alt (m.mut) {\n             case (ast.mut)       { mstr = \"mutable \"; }\n             case (ast.imm)       { mstr = \"\";         }\n             case (ast.maybe_mut) { mstr = \"mutable? \"; }\n         }\n \n-        ret mstr + ty_to_str(tystore, m.ty);\n+        ret mstr + ty_to_str(cx, m.ty);\n     }\n \n     auto s = \"\";\n-    alt (struct(ts, typ)) {\n+    alt (struct(cx, typ)) {\n         case (ty_native)       { s += \"native\";                         }\n         case (ty_nil)          { s += \"()\";                             }\n         case (ty_bool)         { s += \"bool\";                           }\n@@ -423,20 +424,20 @@ fn ty_to_str(@type_store ts, &t typ) -> str {\n         case (ty_machine(?tm)) { s += common.ty_mach_to_str(tm);        }\n         case (ty_char)         { s += \"char\";                           }\n         case (ty_str)          { s += \"str\";                            }\n-        case (ty_box(?tm))     { s += \"@\" + mt_to_str(ts, tm);          }\n-        case (ty_vec(?tm))     { s += \"vec[\" + mt_to_str(ts, tm) + \"]\"; }\n-        case (ty_port(?t))     { s += \"port[\" + ty_to_str(ts, t) + \"]\"; }\n-        case (ty_chan(?t))     { s += \"chan[\" + ty_to_str(ts, t) + \"]\"; }\n+        case (ty_box(?tm))     { s += \"@\" + mt_to_str(cx, tm);          }\n+        case (ty_vec(?tm))     { s += \"vec[\" + mt_to_str(cx, tm) + \"]\"; }\n+        case (ty_port(?t))     { s += \"port[\" + ty_to_str(cx, t) + \"]\"; }\n+        case (ty_chan(?t))     { s += \"chan[\" + ty_to_str(cx, t) + \"]\"; }\n         case (ty_type)         { s += \"type\";                           }\n \n         case (ty_tup(?elems)) {\n-            auto f = bind mt_to_str(ts, _);\n+            auto f = bind mt_to_str(cx, _);\n             auto strs = _vec.map[mt,str](f, elems);\n             s += \"tup(\" + _str.connect(strs, \",\") + \")\";\n         }\n \n         case (ty_rec(?elems)) {\n-            auto f = bind field_to_str(ts, _);\n+            auto f = bind field_to_str(cx, _);\n             auto strs = _vec.map[field,str](f, elems);\n             s += \"rec(\" + _str.connect(strs, \",\") + \")\";\n         }\n@@ -446,27 +447,27 @@ fn ty_to_str(@type_store ts, &t typ) -> str {\n             s += \"<tag#\" + util.common.istr(id._0) + \":\" +\n                 util.common.istr(id._1) + \">\";\n             if (_vec.len[t](tps) > 0u) {\n-                auto f = bind ty_to_str(ts, _);\n+                auto f = bind ty_to_str(cx, _);\n                 auto strs = _vec.map[t,str](f, tps);\n                 s += \"[\" + _str.connect(strs, \",\") + \"]\";\n             }\n         }\n \n         case (ty_fn(?proto, ?inputs, ?output)) {\n-            s += fn_to_str(ts, proto, none[ast.ident], inputs, output);\n+            s += fn_to_str(cx, proto, none[ast.ident], inputs, output);\n         }\n \n         case (ty_native_fn(_, ?inputs, ?output)) {\n-            s += fn_to_str(ts, ast.proto_fn, none[ast.ident], inputs, output);\n+            s += fn_to_str(cx, ast.proto_fn, none[ast.ident], inputs, output);\n         }\n \n         case (ty_obj(?meths)) {\n-            alt (cname(ts, typ)) {\n+            alt (cname(cx, typ)) {\n                 case (some[str](?cs)) {\n                     s += cs;\n                 }\n                 case (_) {\n-                    auto f = bind method_to_str(ts, _);\n+                    auto f = bind method_to_str(cx, _);\n                     auto m = _vec.map[method,str](f, meths);\n                     s += \"obj {\\n\\t\" + _str.connect(m, \"\\n\\t\") + \"\\n}\";\n                 }\n@@ -498,8 +499,8 @@ fn ty_to_str(@type_store ts, &t typ) -> str {\n \n type ty_walk = fn(t);\n \n-fn walk_ty(@type_store tystore, ty_walk walker, t ty) {\n-    alt (struct(tystore, ty)) {\n+fn walk_ty(ctxt cx, ty_walk walker, t ty) {\n+    alt (struct(cx, ty)) {\n         case (ty_nil)           { /* no-op */ }\n         case (ty_bool)          { /* no-op */ }\n         case (ty_int)           { /* no-op */ }\n@@ -510,44 +511,44 @@ fn walk_ty(@type_store tystore, ty_walk walker, t ty) {\n         case (ty_str)           { /* no-op */ }\n         case (ty_type)          { /* no-op */ }\n         case (ty_native)        { /* no-op */ }\n-        case (ty_box(?tm))      { walk_ty(tystore, walker, tm.ty); }\n-        case (ty_vec(?tm))      { walk_ty(tystore, walker, tm.ty); }\n-        case (ty_port(?subty))  { walk_ty(tystore, walker, subty); }\n-        case (ty_chan(?subty))  { walk_ty(tystore, walker, subty); }\n+        case (ty_box(?tm))      { walk_ty(cx, walker, tm.ty); }\n+        case (ty_vec(?tm))      { walk_ty(cx, walker, tm.ty); }\n+        case (ty_port(?subty))  { walk_ty(cx, walker, subty); }\n+        case (ty_chan(?subty))  { walk_ty(cx, walker, subty); }\n         case (ty_tag(?tid, ?subtys)) {\n             for (t subty in subtys) {\n-                walk_ty(tystore, walker, subty);\n+                walk_ty(cx, walker, subty);\n             }\n         }\n         case (ty_tup(?mts)) {\n             for (mt tm in mts) {\n-                walk_ty(tystore, walker, tm.ty);\n+                walk_ty(cx, walker, tm.ty);\n             }\n         }\n         case (ty_rec(?fields)) {\n             for (field fl in fields) {\n-                walk_ty(tystore, walker, fl.mt.ty);\n+                walk_ty(cx, walker, fl.mt.ty);\n             }\n         }\n         case (ty_fn(?proto, ?args, ?ret_ty)) {\n             for (arg a in args) {\n-                walk_ty(tystore, walker, a.ty);\n+                walk_ty(cx, walker, a.ty);\n             }\n-            walk_ty(tystore, walker, ret_ty);\n+            walk_ty(cx, walker, ret_ty);\n         }\n         case (ty_native_fn(?abi, ?args, ?ret_ty)) {\n             for (arg a in args) {\n-                walk_ty(tystore, walker, a.ty);\n+                walk_ty(cx, walker, a.ty);\n             }\n-            walk_ty(tystore, walker, ret_ty);\n+            walk_ty(cx, walker, ret_ty);\n         }\n         case (ty_obj(?methods)) {\n             let vec[method] new_methods = vec();\n             for (method m in methods) {\n                 for (arg a in m.inputs) {\n-                    walk_ty(tystore, walker, a.ty);\n+                    walk_ty(cx, walker, a.ty);\n                 }\n-                walk_ty(tystore, walker, m.output);\n+                walk_ty(cx, walker, m.output);\n             }\n         }\n         case (ty_var(_))         { /* no-op */ }\n@@ -561,9 +562,9 @@ fn walk_ty(@type_store tystore, ty_walk walker, t ty) {\n \n type ty_fold = fn(t) -> t;\n \n-fn fold_ty(@type_store tystore, ty_fold fld, t ty_0) -> t {\n+fn fold_ty(ctxt cx, ty_fold fld, t ty_0) -> t {\n     auto ty = ty_0;\n-    alt (struct(tystore, ty)) {\n+    alt (struct(cx, ty)) {\n         case (ty_nil)           { /* no-op */ }\n         case (ty_bool)          { /* no-op */ }\n         case (ty_int)           { /* no-op */ }\n@@ -575,82 +576,74 @@ fn fold_ty(@type_store tystore, ty_fold fld, t ty_0) -> t {\n         case (ty_type)          { /* no-op */ }\n         case (ty_native)        { /* no-op */ }\n         case (ty_box(?tm)) {\n-            ty = copy_cname(tystore,\n-                            mk_box(tystore,\n-                                   rec(ty=fold_ty(tystore, fld, tm.ty),\n-                                       mut=tm.mut)), ty);\n+            ty = copy_cname(cx, mk_box(cx, rec(ty=fold_ty(cx, fld, tm.ty),\n+                                               mut=tm.mut)), ty);\n         }\n         case (ty_vec(?tm)) {\n-            ty = copy_cname(tystore,\n-                mk_vec(tystore, rec(ty=fold_ty(tystore, fld, tm.ty),\n-                                    mut=tm.mut)), ty);\n+            ty = copy_cname(cx, mk_vec(cx, rec(ty=fold_ty(cx, fld, tm.ty),\n+                                                          mut=tm.mut)), ty);\n         }\n         case (ty_port(?subty)) {\n-            ty = copy_cname(tystore,\n-                mk_port(tystore, fold_ty(tystore, fld, subty)), ty);\n+            ty = copy_cname(cx, mk_port(cx, fold_ty(cx, fld, subty)), ty);\n         }\n         case (ty_chan(?subty)) {\n-            ty = copy_cname(tystore,\n-                mk_chan(tystore, fold_ty(tystore, fld, subty)), ty);\n+            ty = copy_cname(cx, mk_chan(cx, fold_ty(cx, fld, subty)), ty);\n         }\n         case (ty_tag(?tid, ?subtys)) {\n             let vec[t] new_subtys = vec();\n             for (t subty in subtys) {\n-                new_subtys += vec(fold_ty(tystore, fld, subty));\n+                new_subtys += vec(fold_ty(cx, fld, subty));\n             }\n-            ty = copy_cname(tystore, mk_tag(tystore, tid, new_subtys), ty);\n+            ty = copy_cname(cx, mk_tag(cx, tid, new_subtys), ty);\n         }\n         case (ty_tup(?mts)) {\n             let vec[mt] new_mts = vec();\n             for (mt tm in mts) {\n-                auto new_subty = fold_ty(tystore, fld, tm.ty);\n+                auto new_subty = fold_ty(cx, fld, tm.ty);\n                 new_mts += vec(rec(ty=new_subty, mut=tm.mut));\n             }\n-            ty = copy_cname(tystore, mk_tup(tystore, new_mts), ty);\n+            ty = copy_cname(cx, mk_tup(cx, new_mts), ty);\n         }\n         case (ty_rec(?fields)) {\n             let vec[field] new_fields = vec();\n             for (field fl in fields) {\n-                auto new_ty = fold_ty(tystore, fld, fl.mt.ty);\n+                auto new_ty = fold_ty(cx, fld, fl.mt.ty);\n                 auto new_mt = rec(ty=new_ty, mut=fl.mt.mut);\n                 new_fields += vec(rec(ident=fl.ident, mt=new_mt));\n             }\n-            ty = copy_cname(tystore, mk_rec(tystore, new_fields), ty);\n+            ty = copy_cname(cx, mk_rec(cx, new_fields), ty);\n         }\n         case (ty_fn(?proto, ?args, ?ret_ty)) {\n             let vec[arg] new_args = vec();\n             for (arg a in args) {\n-                auto new_ty = fold_ty(tystore, fld, a.ty);\n+                auto new_ty = fold_ty(cx, fld, a.ty);\n                 new_args += vec(rec(mode=a.mode, ty=new_ty));\n             }\n-            ty = copy_cname(tystore, mk_fn(tystore, proto, new_args,\n-                                  fold_ty(tystore, fld, ret_ty)),\n-                            ty);\n+            ty = copy_cname(cx, mk_fn(cx, proto, new_args,\n+                                      fold_ty(cx, fld, ret_ty)), ty);\n         }\n         case (ty_native_fn(?abi, ?args, ?ret_ty)) {\n             let vec[arg] new_args = vec();\n             for (arg a in args) {\n-                auto new_ty = fold_ty(tystore, fld, a.ty);\n+                auto new_ty = fold_ty(cx, fld, a.ty);\n                 new_args += vec(rec(mode=a.mode, ty=new_ty));\n             }\n-            ty = copy_cname(tystore, mk_native_fn(tystore, abi, new_args,\n-                                         fold_ty(tystore, fld, ret_ty)),\n-                            ty);\n+            ty = copy_cname(cx, mk_native_fn(cx, abi, new_args,\n+                                             fold_ty(cx, fld, ret_ty)), ty);\n         }\n         case (ty_obj(?methods)) {\n             let vec[method] new_methods = vec();\n             for (method m in methods) {\n                 let vec[arg] new_args = vec();\n                 for (arg a in m.inputs) {\n                     new_args += vec(rec(mode=a.mode,\n-                                        ty=fold_ty(tystore, fld, a.ty)));\n+                                        ty=fold_ty(cx, fld, a.ty)));\n                 }\n                 new_methods += vec(rec(proto=m.proto, ident=m.ident,\n                                        inputs=new_args,\n-                                       output=fold_ty(tystore, fld,\n-                                                      m.output)));\n+                                       output=fold_ty(cx, fld, m.output)));\n             }\n-            ty = copy_cname(tystore, mk_obj(tystore, new_methods), ty);\n+            ty = copy_cname(cx, mk_obj(cx, new_methods), ty);\n         }\n         case (ty_var(_))         { /* no-op */ }\n         case (ty_local(_))       { /* no-op */ }\n@@ -663,14 +656,14 @@ fn fold_ty(@type_store tystore, ty_fold fld, t ty_0) -> t {\n \n // Type utilities\n \n-fn rename(@type_store tystore, t typ, str new_cname) -> t {\n-    ret gen_ty_full(tystore, struct(tystore, typ), some[str](new_cname));\n+fn rename(ctxt cx, t typ, str new_cname) -> t {\n+    ret gen_ty_full(cx, struct(cx, typ), some[str](new_cname));\n }\n \n // Returns a type with the structural part taken from `struct_ty` and the\n // canonical name from `cname_ty`.\n-fn copy_cname(@type_store tystore, t struct_ty, t cname_ty) -> t {\n-    ret gen_ty_full(tystore, struct(tystore, struct_ty), cname_ty.cname);\n+fn copy_cname(ctxt cx, t struct_ty, t cname_ty) -> t {\n+    ret gen_ty_full(cx, struct(cx, struct_ty), cname_ty.cname);\n }\n \n // FIXME: remove me when == works on these tags.\n@@ -682,24 +675,24 @@ fn mode_is_alias(ast.mode m) -> bool {\n     fail;\n }\n \n-fn type_is_nil(@type_store tystore, t ty) -> bool {\n-    alt (struct(tystore, ty)) {\n+fn type_is_nil(ctxt cx, t ty) -> bool {\n+    alt (struct(cx, ty)) {\n         case (ty_nil) { ret true; }\n         case (_) { ret false; }\n     }\n     fail;\n }\n \n-fn type_is_bool(@type_store tystore, t ty) -> bool {\n-    alt (struct(tystore, ty)) {\n+fn type_is_bool(ctxt cx, t ty) -> bool {\n+    alt (struct(cx, ty)) {\n         case (ty_bool) { ret true; }\n         case (_) { ret false; }\n     }\n }\n \n \n-fn type_is_structural(@type_store tystore, t ty) -> bool {\n-    alt (struct(tystore, ty)) {\n+fn type_is_structural(ctxt cx, t ty) -> bool {\n+    alt (struct(cx, ty)) {\n         case (ty_tup(_))    { ret true; }\n         case (ty_rec(_))    { ret true; }\n         case (ty_tag(_,_))  { ret true; }\n@@ -710,26 +703,26 @@ fn type_is_structural(@type_store tystore, t ty) -> bool {\n     fail;\n }\n \n-fn type_is_sequence(@type_store tystore, t ty) -> bool {\n-    alt (struct(tystore, ty)) {\n+fn type_is_sequence(ctxt cx, t ty) -> bool {\n+    alt (struct(cx, ty)) {\n         case (ty_str)    { ret true; }\n         case (ty_vec(_))    { ret true; }\n         case (_)            { ret false; }\n     }\n     fail;\n }\n \n-fn sequence_element_type(@type_store tystore, t ty) -> t {\n-    alt (struct(tystore, ty)) {\n-        case (ty_str)      { ret mk_mach(tystore, common.ty_u8); }\n+fn sequence_element_type(ctxt cx, t ty) -> t {\n+    alt (struct(cx, ty)) {\n+        case (ty_str)      { ret mk_mach(cx, common.ty_u8); }\n         case (ty_vec(?mt)) { ret mt.ty; }\n     }\n     fail;\n }\n \n \n-fn type_is_tup_like(@type_store tystore, t ty) -> bool {\n-    alt (struct(tystore, ty)) {\n+fn type_is_tup_like(ctxt cx, t ty) -> bool {\n+    alt (struct(cx, ty)) {\n         case (ty_box(_))    { ret true; }\n         case (ty_tup(_))    { ret true; }\n         case (ty_rec(_))    { ret true; }\n@@ -739,9 +732,9 @@ fn type_is_tup_like(@type_store tystore, t ty) -> bool {\n     fail;\n }\n \n-fn get_element_type(@type_store tystore, t ty, uint i) -> t {\n-    check (type_is_tup_like(tystore, ty));\n-    alt (struct(tystore, ty)) {\n+fn get_element_type(ctxt cx, t ty, uint i) -> t {\n+    check (type_is_tup_like(cx, ty));\n+    alt (struct(cx, ty)) {\n         case (ty_tup(?mts)) {\n             ret mts.(i).ty;\n         }\n@@ -752,16 +745,16 @@ fn get_element_type(@type_store tystore, t ty, uint i) -> t {\n     fail;\n }\n \n-fn type_is_box(@type_store tystore, t ty) -> bool {\n-    alt (struct(tystore, ty)) {\n+fn type_is_box(ctxt cx, t ty) -> bool {\n+    alt (struct(cx, ty)) {\n         case (ty_box(_)) { ret true; }\n         case (_) { ret false; }\n     }\n     fail;\n }\n \n-fn type_is_boxed(@type_store tystore, t ty) -> bool {\n-    alt (struct(tystore, ty)) {\n+fn type_is_boxed(ctxt cx, t ty) -> bool {\n+    alt (struct(cx, ty)) {\n         case (ty_str) { ret true; }\n         case (ty_vec(_)) { ret true; }\n         case (ty_box(_)) { ret true; }\n@@ -772,8 +765,8 @@ fn type_is_boxed(@type_store tystore, t ty) -> bool {\n     fail;\n }\n \n-fn type_is_scalar(@type_store tystore, t ty) -> bool {\n-    alt (struct(tystore, ty)) {\n+fn type_is_scalar(ctxt cx, t ty) -> bool {\n+    alt (struct(cx, ty)) {\n         case (ty_nil) { ret true; }\n         case (ty_bool) { ret true; }\n         case (ty_int) { ret true; }\n@@ -790,27 +783,27 @@ fn type_is_scalar(@type_store tystore, t ty) -> bool {\n \n // FIXME: should we just return true for native types in\n // type_is_scalar?\n-fn type_is_native(@type_store tystore, t ty) -> bool {\n-    alt (struct(tystore, ty)) {\n+fn type_is_native(ctxt cx, t ty) -> bool {\n+    alt (struct(cx, ty)) {\n         case (ty_native) { ret true; }\n         case (_) { ret false; }\n     }\n     fail;\n }\n \n-fn type_has_dynamic_size(@type_store tystore, t ty) -> bool {\n-    alt (struct(tystore, ty)) {\n+fn type_has_dynamic_size(ctxt cx, t ty) -> bool {\n+    alt (struct(cx, ty)) {\n         case (ty_tup(?mts)) {\n             auto i = 0u;\n             while (i < _vec.len[mt](mts)) {\n-                if (type_has_dynamic_size(tystore, mts.(i).ty)) { ret true; }\n+                if (type_has_dynamic_size(cx, mts.(i).ty)) { ret true; }\n                 i += 1u;\n             }\n         }\n         case (ty_rec(?fields)) {\n             auto i = 0u;\n             while (i < _vec.len[field](fields)) {\n-                if (type_has_dynamic_size(tystore, fields.(i).mt.ty)) {\n+                if (type_has_dynamic_size(cx, fields.(i).mt.ty)) {\n                     ret true;\n                 }\n                 i += 1u;\n@@ -819,7 +812,7 @@ fn type_has_dynamic_size(@type_store tystore, t ty) -> bool {\n         case (ty_tag(_, ?subtys)) {\n             auto i = 0u;\n             while (i < _vec.len[t](subtys)) {\n-                if (type_has_dynamic_size(tystore, subtys.(i))) { ret true; }\n+                if (type_has_dynamic_size(cx, subtys.(i))) { ret true; }\n                 i += 1u;\n             }\n         }\n@@ -829,8 +822,8 @@ fn type_has_dynamic_size(@type_store tystore, t ty) -> bool {\n     ret false;\n }\n \n-fn type_is_integral(@type_store tystore, t ty) -> bool {\n-    alt (struct(tystore, ty)) {\n+fn type_is_integral(ctxt cx, t ty) -> bool {\n+    alt (struct(cx, ty)) {\n         case (ty_int) { ret true; }\n         case (ty_uint) { ret true; }\n         case (ty_machine(?m)) {\n@@ -853,8 +846,8 @@ fn type_is_integral(@type_store tystore, t ty) -> bool {\n     fail;\n }\n \n-fn type_is_fp(@type_store tystore, t ty) -> bool {\n-    alt (struct(tystore, ty)) {\n+fn type_is_fp(ctxt cx, t ty) -> bool {\n+    alt (struct(cx, ty)) {\n         case (ty_machine(?tm)) {\n             alt (tm) {\n                 case (common.ty_f32) { ret true; }\n@@ -870,8 +863,8 @@ fn type_is_fp(@type_store tystore, t ty) -> bool {\n     fail;\n }\n \n-fn type_is_signed(@type_store tystore, t ty) -> bool {\n-    alt (struct(tystore, ty)) {\n+fn type_is_signed(ctxt cx, t ty) -> bool {\n+    alt (struct(cx, ty)) {\n         case (ty_int) { ret true; }\n         case (ty_machine(?tm)) {\n             alt (tm) {\n@@ -887,8 +880,8 @@ fn type_is_signed(@type_store tystore, t ty) -> bool {\n     fail;\n }\n \n-fn type_param(@type_store tystore, t ty) -> option.t[uint] {\n-    alt (struct(tystore, ty)) {\n+fn type_param(ctxt cx, t ty) -> option.t[uint] {\n+    alt (struct(cx, ty)) {\n         case (ty_param(?id)) { ret some[uint](id); }\n         case (_)             { /* fall through */  }\n     }\n@@ -1436,7 +1429,7 @@ fn ann_to_type_params(&ast.ann ann) -> vec[t] {\n \n // Returns the type of an annotation, with type parameter substitutions\n // performed if applicable.\n-fn ann_to_monotype(@type_store tystore, ast.ann a) -> t {\n+fn ann_to_monotype(ctxt cx, ast.ann a) -> t {\n     // TODO: Refactor to use recursive pattern matching when we're more\n     // confident that it works.\n     alt (a) {\n@@ -1448,7 +1441,7 @@ fn ann_to_monotype(@type_store tystore, ast.ann a) -> t {\n             alt (tps_opt) {\n                 case (none[vec[t]]) { ret typ; }\n                 case (some[vec[t]](?tps)) {\n-                    ret substitute_type_params(tystore, tps, typ);\n+                    ret substitute_type_params(cx, tps, typ);\n                 }\n             }\n         }\n@@ -1461,9 +1454,9 @@ fn triv_ann(t typ) -> ast.ann {\n }\n \n // Returns the number of distinct type parameters in the given type.\n-fn count_ty_params(@type_store tystore, t ty) -> uint {\n-    fn counter(@type_store tystore, @mutable vec[uint] param_indices, t ty) {\n-        alt (struct(tystore, ty)) {\n+fn count_ty_params(ctxt cx, t ty) -> uint {\n+    fn counter(ctxt cx, @mutable vec[uint] param_indices, t ty) {\n+        alt (struct(cx, ty)) {\n             case (ty_param(?param_idx)) {\n                 auto seen = false;\n                 for (uint other_param_idx in *param_indices) {\n@@ -1481,87 +1474,87 @@ fn count_ty_params(@type_store tystore, t ty) -> uint {\n \n     let vec[uint] v = vec();    // FIXME: typechecker botch\n     let @mutable vec[uint] param_indices = @mutable v;\n-    auto f = bind counter(tystore, param_indices, _);\n-    walk_ty(tystore, f, ty);\n+    auto f = bind counter(cx, param_indices, _);\n+    walk_ty(cx, f, ty);\n     ret _vec.len[uint](*param_indices);\n }\n \n-fn type_contains_vars(@type_store tystore, t typ) -> bool {\n-    fn checker(@type_store tystore, @mutable bool flag, t typ) {\n-        alt (struct(tystore, typ)) {\n+fn type_contains_vars(ctxt cx, t typ) -> bool {\n+    fn checker(ctxt cx, @mutable bool flag, t typ) {\n+        alt (struct(cx, typ)) {\n             case (ty_var(_)) { *flag = true; }\n             case (_) { /* fall through */ }\n         }\n     }\n \n     let @mutable bool flag = @mutable false;\n-    auto f = bind checker(tystore, flag, _);\n-    walk_ty(tystore, f, typ);\n+    auto f = bind checker(cx, flag, _);\n+    walk_ty(cx, f, typ);\n     ret *flag;\n }\n \n-fn type_contains_params(@type_store tystore, t typ) -> bool {\n-    fn checker(@type_store tystore, @mutable bool flag, t typ) {\n-        alt (struct(tystore, typ)) {\n+fn type_contains_params(ctxt cx, t typ) -> bool {\n+    fn checker(ctxt cx, @mutable bool flag, t typ) {\n+        alt (struct(cx, typ)) {\n             case (ty_param(_)) { *flag = true; }\n             case (_) { /* fall through */ }\n         }\n     }\n \n     let @mutable bool flag = @mutable false;\n-    auto f = bind checker(tystore, flag, _);\n-    walk_ty(tystore, f, typ);\n+    auto f = bind checker(cx, flag, _);\n+    walk_ty(cx, f, typ);\n     ret *flag;\n }\n \n-fn type_contains_bound_params(@type_store tystore, t typ) -> bool {\n-    fn checker(@type_store tystore, @mutable bool flag, t typ) {\n-        alt (struct(tystore, typ)) {\n+fn type_contains_bound_params(ctxt cx, t typ) -> bool {\n+    fn checker(ctxt cx, @mutable bool flag, t typ) {\n+        alt (struct(cx, typ)) {\n             case (ty_bound_param(_)) { *flag = true; }\n             case (_) { /* fall through */ }\n         }\n     }\n \n     let @mutable bool flag = @mutable false;\n-    auto f = bind checker(tystore, flag, _);\n-    walk_ty(tystore, f, typ);\n+    auto f = bind checker(cx, flag, _);\n+    walk_ty(cx, f, typ);\n     ret *flag;\n }\n \n // Type accessors for substructures of types\n \n-fn ty_fn_args(@type_store tystore, t fty) -> vec[arg] {\n-    alt (struct(tystore, fty)) {\n+fn ty_fn_args(ctxt cx, t fty) -> vec[arg] {\n+    alt (struct(cx, fty)) {\n         case (ty.ty_fn(_, ?a, _)) { ret a; }\n         case (ty.ty_native_fn(_, ?a, _)) { ret a; }\n     }\n     fail;\n }\n \n-fn ty_fn_proto(@type_store tystore, t fty) -> ast.proto {\n-    alt (struct(tystore, fty)) {\n+fn ty_fn_proto(ctxt cx, t fty) -> ast.proto {\n+    alt (struct(cx, fty)) {\n         case (ty.ty_fn(?p, _, _)) { ret p; }\n     }\n     fail;\n }\n \n-fn ty_fn_abi(@type_store tystore, t fty) -> ast.native_abi {\n-    alt (struct(tystore, fty)) {\n+fn ty_fn_abi(ctxt cx, t fty) -> ast.native_abi {\n+    alt (struct(cx, fty)) {\n         case (ty.ty_native_fn(?a, _, _)) { ret a; }\n     }\n     fail;\n }\n \n-fn ty_fn_ret(@type_store tystore, t fty) -> t {\n-    alt (struct(tystore, fty)) {\n+fn ty_fn_ret(ctxt cx, t fty) -> t {\n+    alt (struct(cx, fty)) {\n         case (ty.ty_fn(_, _, ?r)) { ret r; }\n         case (ty.ty_native_fn(_, _, ?r)) { ret r; }\n     }\n     fail;\n }\n \n-fn is_fn_ty(@type_store tystore, t fty) -> bool {\n-    alt (struct(tystore, fty)) {\n+fn is_fn_ty(ctxt cx, t fty) -> bool {\n+    alt (struct(cx, fty)) {\n         case (ty.ty_fn(_, _, _)) { ret true; }\n         case (ty.ty_native_fn(_, _, _)) { ret true; }\n         case (_) { ret false; }\n@@ -1618,32 +1611,32 @@ fn item_ty(@ast.item it) -> ty_param_count_and_ty {\n     ret tup(ty_param_count, result_ty);\n }\n \n-fn stmt_ty(@type_store tystore, @ast.stmt s) -> t {\n+fn stmt_ty(ctxt cx, @ast.stmt s) -> t {\n     alt (s.node) {\n         case (ast.stmt_expr(?e,_)) {\n-            ret expr_ty(tystore, e);\n+            ret expr_ty(cx, e);\n         }\n         case (_) {\n-            ret mk_nil(tystore);\n+            ret mk_nil(cx);\n         }\n     }\n }\n \n-fn block_ty(@type_store tystore, &ast.block b) -> t {\n+fn block_ty(ctxt cx, &ast.block b) -> t {\n     alt (b.node.expr) {\n-        case (some[@ast.expr](?e)) { ret expr_ty(tystore, e); }\n-        case (none[@ast.expr])     { ret mk_nil(tystore); }\n+        case (some[@ast.expr](?e)) { ret expr_ty(cx, e); }\n+        case (none[@ast.expr])     { ret mk_nil(cx); }\n     }\n }\n \n // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n // doesn't provide type parameter substitutions.\n-fn pat_ty(@type_store ts, @ast.pat pat) -> t {\n+fn pat_ty(ctxt cx, @ast.pat pat) -> t {\n     alt (pat.node) {\n-        case (ast.pat_wild(?ann))           { ret ann_to_monotype(ts, ann); }\n-        case (ast.pat_lit(_, ?ann))         { ret ann_to_monotype(ts, ann); }\n-        case (ast.pat_bind(_, _, ?ann))     { ret ann_to_monotype(ts, ann); }\n-        case (ast.pat_tag(_, _, _, ?ann))   { ret ann_to_monotype(ts, ann); }\n+        case (ast.pat_wild(?ann))           { ret ann_to_monotype(cx, ann); }\n+        case (ast.pat_lit(_, ?ann))         { ret ann_to_monotype(cx, ann); }\n+        case (ast.pat_bind(_, _, ?ann))     { ret ann_to_monotype(cx, ann); }\n+        case (ast.pat_tag(_, _, _, ?ann))   { ret ann_to_monotype(cx, ann); }\n     }\n     fail;   // not reached\n }\n@@ -1700,19 +1693,18 @@ fn expr_ann(@ast.expr expr) -> option.t[ast.ann] {\n // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&int) -> int\"\n // instead of \"fn(&T) -> T with T = int\". If this isn't what you want, see\n // expr_ty_params_and_ty() below.\n-fn expr_ty(@type_store tystore, @ast.expr expr) -> t {\n+fn expr_ty(ctxt cx, @ast.expr expr) -> t {\n     alt (expr_ann(expr)) {\n-        case (none[ast.ann])     { ret mk_nil(tystore); }\n-        case (some[ast.ann](?a)) { ret ann_to_monotype(tystore, a); }\n+        case (none[ast.ann])     { ret mk_nil(cx); }\n+        case (some[ast.ann](?a)) { ret ann_to_monotype(cx, a); }\n     }\n }\n \n-fn expr_ty_params_and_ty(@type_store tystore, @ast.expr expr)\n-        -> tup(vec[t], t) {\n+fn expr_ty_params_and_ty(ctxt cx, @ast.expr expr) -> tup(vec[t], t) {\n     alt (expr_ann(expr)) {\n         case (none[ast.ann]) {\n             let vec[t] tps = vec();\n-            ret tup(tps, mk_nil(tystore));\n+            ret tup(tps, mk_nil(cx));\n         }\n         case (some[ast.ann](?a)) {\n             ret tup(ann_to_type_params(a), ann_to_type(a));\n@@ -1863,7 +1855,7 @@ mod Unify {\n                     hashmap[int,uint] var_ids,\n                     mutable vec[mutable vec[t]] types,\n                     unify_handler handler,\n-                    @type_store tystore);\n+                    ty_ctxt tcx);\n \n     // Wraps the given type in an appropriate cname.\n     //\n@@ -1874,7 +1866,7 @@ mod Unify {\n \n     // Simple structural type comparison.\n     fn struct_cmp(@ctxt cx, t expected, t actual) -> result {\n-        if (struct(cx.tystore, expected) == struct(cx.tystore, actual)) {\n+        if (struct(cx.tcx, expected) == struct(cx.tcx, actual)) {\n             ret ures_ok(expected);\n         }\n \n@@ -1978,7 +1970,7 @@ mod Unify {\n                 ret r;\n             }\n             case (fn_common_res_ok(?result_ins, ?result_out)) {\n-                auto t2 = mk_fn(cx.tystore, e_proto, result_ins, result_out);\n+                auto t2 = mk_fn(cx.tcx, e_proto, result_ins, result_out);\n                 ret ures_ok(t2);\n             }\n         }\n@@ -2004,7 +1996,7 @@ mod Unify {\n                 ret r;\n             }\n             case (fn_common_res_ok(?result_ins, ?result_out)) {\n-                auto t2 = mk_native_fn(cx.tystore, e_abi, result_ins,\n+                auto t2 = mk_native_fn(cx.tcx, e_abi, result_ins,\n                                        result_out);\n                 ret ures_ok(t2);\n             }\n@@ -2039,7 +2031,7 @@ mod Unify {\n                           a_meth.inputs, a_meth.output);\n         alt (r) {\n             case (ures_ok(?tfn)) {\n-                alt (struct(cx.tystore, tfn)) {\n+                alt (struct(cx.tcx, tfn)) {\n                     case (ty_fn(?proto, ?ins, ?out)) {\n                         result_meths += vec(rec(inputs = ins,\n                                                 output = out\n@@ -2053,7 +2045,7 @@ mod Unify {\n         }\n         i += 1u;\n       }\n-      auto t = mk_obj(cx.tystore, result_meths);\n+      auto t = mk_obj(cx.tcx, result_meths);\n       ret ures_ok(t);\n     }\n \n@@ -2079,12 +2071,12 @@ mod Unify {\n         // Fast path.\n         if (eq_ty(expected, actual)) { ret ures_ok(expected); }\n \n-        alt (struct(cx.tystore, actual)) {\n+        alt (struct(cx.tcx, actual)) {\n             // If the RHS is a variable type, then just do the appropriate\n             // binding.\n             case (ty.ty_var(?actual_id)) {\n                 auto actual_n = get_or_create_set(cx, actual_id);\n-                alt (struct(cx.tystore, expected)) {\n+                alt (struct(cx.tcx, expected)) {\n                     case (ty.ty_var(?expected_id)) {\n                         auto expected_n = get_or_create_set(cx, expected_id);\n                         UFind.union(cx.sets, expected_n, actual_n);\n@@ -2120,7 +2112,7 @@ mod Unify {\n                 ret ures_ok(result_ty);\n             }\n             case (ty.ty_bound_param(?actual_id)) {\n-                alt (struct(cx.tystore, expected)) {\n+                alt (struct(cx.tcx, expected)) {\n                     case (ty.ty_local(_)) {\n                         log_err \"TODO: bound param unifying with local\";\n                         fail;\n@@ -2134,7 +2126,7 @@ mod Unify {\n             case (_) { /* empty */ }\n         }\n \n-        alt (struct(cx.tystore, expected)) {\n+        alt (struct(cx.tcx, expected)) {\n             case (ty.ty_nil)        { ret struct_cmp(cx, expected, actual); }\n             case (ty.ty_bool)       { ret struct_cmp(cx, expected, actual); }\n             case (ty.ty_int)        { ret struct_cmp(cx, expected, actual); }\n@@ -2148,7 +2140,7 @@ mod Unify {\n             case (ty.ty_param(_))   { ret struct_cmp(cx, expected, actual); }\n \n             case (ty.ty_tag(?expected_id, ?expected_tps)) {\n-                alt (struct(cx.tystore, actual)) {\n+                alt (struct(cx.tcx, actual)) {\n                     case (ty.ty_tag(?actual_id, ?actual_tps)) {\n                         if (expected_id._0 != actual_id._0 ||\n                                 expected_id._1 != actual_id._1) {\n@@ -2180,8 +2172,7 @@ mod Unify {\n                             i += 1u;\n                         }\n \n-                        ret ures_ok(mk_tag(cx.tystore, expected_id,\n-                                           result_tps));\n+                        ret ures_ok(mk_tag(cx.tcx, expected_id, result_tps));\n                     }\n                     case (_) { /* fall through */ }\n                 }\n@@ -2190,7 +2181,7 @@ mod Unify {\n             }\n \n             case (ty.ty_box(?expected_mt)) {\n-                alt (struct(cx.tystore, actual)) {\n+                alt (struct(cx.tcx, actual)) {\n                     case (ty.ty_box(?actual_mt)) {\n                         auto mut;\n                         alt (unify_mut(expected_mt.mut, actual_mt.mut)) {\n@@ -2207,7 +2198,7 @@ mod Unify {\n                         alt (result) {\n                             case (ures_ok(?result_sub)) {\n                                 auto mt = rec(ty=result_sub, mut=mut);\n-                                ret ures_ok(mk_box(cx.tystore, mt));\n+                                ret ures_ok(mk_box(cx.tcx, mt));\n                             }\n                             case (_) {\n                                 ret result;\n@@ -2222,7 +2213,7 @@ mod Unify {\n             }\n \n             case (ty.ty_vec(?expected_mt)) {\n-                alt (struct(cx.tystore, actual)) {\n+                alt (struct(cx.tcx, actual)) {\n                     case (ty.ty_vec(?actual_mt)) {\n                         auto mut;\n                         alt (unify_mut(expected_mt.mut, actual_mt.mut)) {\n@@ -2239,7 +2230,7 @@ mod Unify {\n                         alt (result) {\n                             case (ures_ok(?result_sub)) {\n                                 auto mt = rec(ty=result_sub, mut=mut);\n-                                ret ures_ok(mk_vec(cx.tystore, mt));\n+                                ret ures_ok(mk_vec(cx.tcx, mt));\n                             }\n                             case (_) {\n                                 ret result;\n@@ -2254,14 +2245,14 @@ mod Unify {\n             }\n \n             case (ty.ty_port(?expected_sub)) {\n-                alt (struct(cx.tystore, actual)) {\n+                alt (struct(cx.tcx, actual)) {\n                     case (ty.ty_port(?actual_sub)) {\n                         auto result = unify_step(cx,\n                                                  expected_sub,\n                                                  actual_sub);\n                         alt (result) {\n                             case (ures_ok(?result_sub)) {\n-                                ret ures_ok(mk_port(cx.tystore, result_sub));\n+                                ret ures_ok(mk_port(cx.tcx, result_sub));\n                             }\n                             case (_) {\n                                 ret result;\n@@ -2276,14 +2267,14 @@ mod Unify {\n             }\n \n             case (ty.ty_chan(?expected_sub)) {\n-                alt (struct(cx.tystore, actual)) {\n+                alt (struct(cx.tcx, actual)) {\n                     case (ty.ty_chan(?actual_sub)) {\n                         auto result = unify_step(cx,\n                                                  expected_sub,\n                                                  actual_sub);\n                         alt (result) {\n                             case (ures_ok(?result_sub)) {\n-                                ret ures_ok(mk_chan(cx.tystore, result_sub));\n+                                ret ures_ok(mk_chan(cx.tcx, result_sub));\n                             }\n                             case (_) {\n                                 ret result;\n@@ -2298,7 +2289,7 @@ mod Unify {\n             }\n \n             case (ty.ty_tup(?expected_elems)) {\n-                alt (struct(cx.tystore, actual)) {\n+                alt (struct(cx.tcx, actual)) {\n                     case (ty.ty_tup(?actual_elems)) {\n                         auto expected_len = _vec.len[ty.mt](expected_elems);\n                         auto actual_len = _vec.len[ty.mt](actual_elems);\n@@ -2342,7 +2333,7 @@ mod Unify {\n                             i += 1u;\n                         }\n \n-                        ret ures_ok(mk_tup(cx.tystore, result_elems));\n+                        ret ures_ok(mk_tup(cx.tcx, result_elems));\n                     }\n \n                     case (_) {\n@@ -2352,7 +2343,7 @@ mod Unify {\n             }\n \n             case (ty.ty_rec(?expected_fields)) {\n-                alt (struct(cx.tystore, actual)) {\n+                alt (struct(cx.tcx, actual)) {\n                     case (ty.ty_rec(?actual_fields)) {\n                         auto expected_len = _vec.len[field](expected_fields);\n                         auto actual_len = _vec.len[field](actual_fields);\n@@ -2406,7 +2397,7 @@ mod Unify {\n                             i += 1u;\n                         }\n \n-                        ret ures_ok(mk_rec(cx.tystore, result_fields));\n+                        ret ures_ok(mk_rec(cx.tcx, result_fields));\n                     }\n \n                     case (_) {\n@@ -2416,7 +2407,7 @@ mod Unify {\n             }\n \n             case (ty.ty_fn(?ep, ?expected_inputs, ?expected_output)) {\n-                alt (struct(cx.tystore, actual)) {\n+                alt (struct(cx.tcx, actual)) {\n                     case (ty.ty_fn(?ap, ?actual_inputs, ?actual_output)) {\n                         ret unify_fn(cx, ep, ap,\n                                      expected, actual,\n@@ -2432,7 +2423,7 @@ mod Unify {\n \n             case (ty.ty_native_fn(?e_abi, ?expected_inputs,\n                                   ?expected_output)) {\n-                alt (struct(cx.tystore, actual)) {\n+                alt (struct(cx.tcx, actual)) {\n                     case (ty.ty_native_fn(?a_abi, ?actual_inputs,\n                                           ?actual_output)) {\n                         ret unify_native_fn(cx, e_abi, a_abi,\n@@ -2447,7 +2438,7 @@ mod Unify {\n             }\n \n             case (ty.ty_obj(?expected_meths)) {\n-                alt (struct(cx.tystore, actual)) {\n+                alt (struct(cx.tcx, actual)) {\n                     case (ty.ty_obj(?actual_meths)) {\n                         ret unify_obj(cx, expected, actual,\n                                       expected_meths, actual_meths);\n@@ -2500,7 +2491,7 @@ mod Unify {\n     // Performs type binding substitution.\n     fn substitute(@ctxt cx, vec[t] set_types, t typ) -> t {\n         fn substituter(@ctxt cx, vec[t] types, t typ) -> t {\n-            alt (struct(cx.tystore, typ)) {\n+            alt (struct(cx.tcx, typ)) {\n                 case (ty_var(?id)) {\n                     alt (cx.var_ids.find(id)) {\n                         case (some[uint](?n)) {\n@@ -2515,7 +2506,7 @@ mod Unify {\n         }\n \n         auto f = bind substituter(cx, set_types, _);\n-        ret fold_ty(cx.tystore, f, typ);\n+        ret fold_ty(cx.tcx, f, typ);\n     }\n \n     fn unify_sets(@ctxt cx) -> vec[t] {\n@@ -2551,7 +2542,7 @@ mod Unify {\n     fn unify(t expected,\n              t actual,\n              &unify_handler handler,\n-             @type_store tystore) -> result {\n+             ty_ctxt tcx) -> result {\n         let vec[t] throwaway = vec();\n         let vec[mutable vec[t]] types = vec(mutable throwaway);\n         _vec.pop[mutable vec[t]](types);   // FIXME: botch\n@@ -2560,7 +2551,7 @@ mod Unify {\n                        var_ids=common.new_int_hash[uint](),\n                        mutable types=types,\n                        handler=handler,\n-                       tystore=tystore);\n+                       tcx=tcx);\n \n         auto ures = unify_step(cx, expected, actual);\n         alt (ures) {\n@@ -2629,44 +2620,41 @@ fn type_err_to_str(&ty.type_err err) -> str {\n \n // Performs bound type parameter replacement using the supplied mapping from\n // parameter IDs to types.\n-fn substitute_type_params(@type_store tystore,\n-                          vec[t] bindings,\n-                          t typ) -> t {\n-    if (!type_contains_bound_params(tystore, typ)) {\n+fn substitute_type_params(ctxt cx, vec[t] bindings, t typ) -> t {\n+    if (!type_contains_bound_params(cx, typ)) {\n         ret typ;\n     }\n-    fn replacer(@type_store tystore, vec[t] bindings, t typ) -> t {\n-        alt (struct(tystore, typ)) {\n+    fn replacer(ctxt cx, vec[t] bindings, t typ) -> t {\n+        alt (struct(cx, typ)) {\n             case (ty_bound_param(?param_index)) {\n                 ret bindings.(param_index);\n             }\n             case (_) { ret typ; }\n         }\n     }\n \n-    auto f = bind replacer(tystore, bindings, _);\n-    ret fold_ty(tystore, f, typ);\n+    auto f = bind replacer(cx, bindings, _);\n+    ret fold_ty(cx, f, typ);\n }\n \n // Converts type parameters in a type to bound type parameters.\n-fn bind_params_in_type(@type_store tystore, t typ) -> t {\n-    if (!type_contains_params(tystore, typ)) {\n-        ret typ;\n-    }\n-    fn binder(@type_store tystore, t typ) -> t {\n-        alt (struct(tystore, typ)) {\n+fn bind_params_in_type(ctxt cx, t typ) -> t {\n+    if (!type_contains_params(cx, typ)) { ret typ; }\n+\n+    fn binder(ctxt cx, t typ) -> t {\n+        alt (struct(cx, typ)) {\n             case (ty_bound_param(?index)) {\n                 log_err \"bind_params_in_type() called on type that already \" +\n                     \"has bound params in it\";\n                 fail;\n             }\n-            case (ty_param(?index)) { ret mk_bound_param(tystore, index); }\n+            case (ty_param(?index)) { ret mk_bound_param(cx, index); }\n             case (_) { ret typ; }\n         }\n     }\n \n-    auto f = bind binder(tystore, _);\n-    ret fold_ty(tystore, f, typ);\n+    auto f = bind binder(cx, _);\n+    ret fold_ty(cx, f, typ);\n }\n \n \n@@ -2692,7 +2680,7 @@ fn def_has_ty_params(&ast.def def) -> bool {\n // If the given item is in an external crate, looks up its type and adds it to\n // the type cache. Returns the type parameters and type.\n fn lookup_item_type(session.session sess,\n-                    @type_store tystore,\n+                    ctxt cx,\n                     &type_cache cache,\n                     ast.def_id did) -> ty_param_count_and_ty {\n     if (did._0 == sess.get_targ_crate_num()) {\n@@ -2704,7 +2692,7 @@ fn lookup_item_type(session.session sess,\n     alt (cache.find(did)) {\n         case (some[ty_param_count_and_ty](?tpt)) { ret tpt; }\n         case (none[ty_param_count_and_ty]) {\n-            auto tyt = creader.get_type(sess, tystore, did);\n+            auto tyt = creader.get_type(sess, cx, did);\n             cache.insert(did, tyt);\n             ret tyt;\n         }"}, {"sha": "fc13319df716e1cfd05d000d1adb0066270ec0cb", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 241, "deletions": 264, "changes": 505, "blob_url": "https://github.com/rust-lang/rust/blob/e102413aadf4cb0e2740b26d249a710ad98cbd14/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e102413aadf4cb0e2740b26d249a710ad98cbd14/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=e102413aadf4cb0e2740b26d249a710ad98cbd14", "patch": "@@ -64,7 +64,7 @@ type crate_ctxt = rec(session.session sess,\n                       unify_cache unify_cache,\n                       mutable uint cache_hits,\n                       mutable uint cache_misses,\n-                      @ty.type_store tystore);\n+                      ty.ctxt tcx);\n \n type fn_ctxt = rec(ty.t ret_ty,\n                    @ty_table locals,\n@@ -81,7 +81,7 @@ fn substitute_ty_params(&@crate_ctxt ccx,\n                         vec[ty.t] supplied,\n                         &span sp) -> ty.t {\n     fn substituter(@crate_ctxt ccx, vec[ty.t] supplied, ty.t typ) -> ty.t {\n-        alt (struct(ccx.tystore, typ)) {\n+        alt (struct(ccx.tcx, typ)) {\n             case (ty.ty_bound_param(?pid)) { ret supplied.(pid); }\n             case (_) { ret typ; }\n         }\n@@ -97,7 +97,7 @@ fn substitute_ty_params(&@crate_ctxt ccx,\n     }\n \n     auto f = bind substituter(ccx, supplied, _);\n-    ret ty.fold_ty(ccx.tystore, f, typ);\n+    ret ty.fold_ty(ccx.tcx, f, typ);\n }\n \n \n@@ -113,7 +113,7 @@ fn ty_param_count_and_ty_for_def(@fn_ctxt fcx, &ast.def defn)\n             auto t;\n             alt (fcx.locals.find(id)) {\n                 case (some[ty.t](?t1)) { t = t1; }\n-                case (none[ty.t]) { t = ty.mk_local(fcx.ccx.tystore, id); }\n+                case (none[ty.t]) { t = ty.mk_local(fcx.ccx.tcx, id); }\n             }\n             ret tup(0u, t);\n         }\n@@ -122,34 +122,34 @@ fn ty_param_count_and_ty_for_def(@fn_ctxt fcx, &ast.def defn)\n             ret tup(0u, fcx.locals.get(id));\n         }\n         case (ast.def_fn(?id)) {\n-            ret ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.tystore,\n+            ret ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx,\n                                     fcx.ccx.type_cache, id);\n         }\n         case (ast.def_native_fn(?id)) {\n-            ret ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.tystore,\n+            ret ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx,\n                                     fcx.ccx.type_cache, id);\n         }\n         case (ast.def_const(?id)) {\n-            ret ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.tystore,\n+            ret ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx,\n                                     fcx.ccx.type_cache, id);\n         }\n         case (ast.def_variant(_, ?vid)) {\n-            ret ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.tystore,\n+            ret ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx,\n                                     fcx.ccx.type_cache, vid);\n         }\n         case (ast.def_binding(?id)) {\n             // check (fcx.locals.contains_key(id));\n             ret tup(0u, fcx.locals.get(id));\n         }\n         case (ast.def_obj(?id)) {\n-            ret ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.tystore,\n+            ret ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx,\n                                     fcx.ccx.type_cache, id);\n         }\n \n         case (ast.def_mod(_)) {\n             // Hopefully part of a path.\n             // TODO: return a type that's more poisonous, perhaps?\n-            ret tup(0u, ty.mk_nil(fcx.ccx.tystore));\n+            ret tup(0u, ty.mk_nil(fcx.ccx.tcx));\n         }\n \n         case (ast.def_ty(_)) {\n@@ -170,7 +170,7 @@ fn ty_param_count_and_ty_for_def(@fn_ctxt fcx, &ast.def defn)\n fn instantiate_path(@fn_ctxt fcx, &ast.path pth, &ty_param_count_and_ty tpt,\n         &span sp) -> ast.ann {\n     auto ty_param_count = tpt._0;\n-    auto t = bind_params_in_type(fcx.ccx.tystore, tpt._1);\n+    auto t = bind_params_in_type(fcx.ccx.tcx, tpt._1);\n \n     auto ty_substs_opt;\n     auto ty_substs_len = _vec.len[@ast.ty](pth.node.types);\n@@ -205,23 +205,21 @@ fn instantiate_path(@fn_ctxt fcx, &ast.path pth, &ty_param_count_and_ty tpt,\n // Parses the programmer's textual representation of a type into our internal\n // notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID.\n-fn ast_ty_to_ty(@ty.type_store tystore,\n-                ty_getter getter,\n-                &@ast.ty ast_ty) -> ty.t {\n-    fn ast_arg_to_arg(@ty.type_store tystore,\n+fn ast_ty_to_ty(ty.ctxt tcx, ty_getter getter, &@ast.ty ast_ty) -> ty.t {\n+    fn ast_arg_to_arg(ty.ctxt tcx,\n                       ty_getter getter,\n                       &rec(ast.mode mode, @ast.ty ty) arg)\n             -> rec(ast.mode mode, ty.t ty) {\n-        ret rec(mode=arg.mode, ty=ast_ty_to_ty(tystore, getter, arg.ty));\n+        ret rec(mode=arg.mode, ty=ast_ty_to_ty(tcx, getter, arg.ty));\n     }\n \n-    fn ast_mt_to_mt(@ty.type_store tystore,\n+    fn ast_mt_to_mt(ty.ctxt tcx,\n                     ty_getter getter,\n                     &ast.mt mt) -> ty.mt {\n-        ret rec(ty=ast_ty_to_ty(tystore, getter, mt.ty), mut=mt.mut);\n+        ret rec(ty=ast_ty_to_ty(tcx, getter, mt.ty), mut=mt.mut);\n     }\n \n-    fn instantiate(@ty.type_store tystore,\n+    fn instantiate(ty.ctxt tcx,\n                    ty_getter getter,\n                    ast.def_id id,\n                    vec[@ast.ty] args) -> ty.t {\n@@ -237,75 +235,75 @@ fn ast_ty_to_ty(@ty.type_store tystore,\n         //\n         // TODO: Make sure the number of supplied bindings matches the number\n         // of type parameters in the typedef. Emit a friendly error otherwise.\n-        auto bound_ty = bind_params_in_type(tystore, params_opt_and_ty._1);\n+        auto bound_ty = bind_params_in_type(tcx, params_opt_and_ty._1);\n         let vec[ty.t] param_bindings = vec();\n         for (@ast.ty ast_ty in args) {\n-            param_bindings += vec(ast_ty_to_ty(tystore, getter, ast_ty));\n+            param_bindings += vec(ast_ty_to_ty(tcx, getter, ast_ty));\n         }\n-        ret ty.substitute_type_params(tystore, param_bindings, bound_ty);\n+        ret ty.substitute_type_params(tcx, param_bindings, bound_ty);\n     }\n \n     auto mut = ast.imm;\n     auto typ;\n     auto cname = none[str];\n     alt (ast_ty.node) {\n-        case (ast.ty_nil)          { typ = ty.mk_nil(tystore); }\n-        case (ast.ty_bool)         { typ = ty.mk_bool(tystore); }\n-        case (ast.ty_int)          { typ = ty.mk_int(tystore); }\n-        case (ast.ty_uint)         { typ = ty.mk_uint(tystore); }\n-        case (ast.ty_float)        { typ = ty.mk_float(tystore); }\n-        case (ast.ty_machine(?tm)) { typ = ty.mk_mach(tystore, tm); }\n-        case (ast.ty_char)         { typ = ty.mk_char(tystore); }\n-        case (ast.ty_str)          { typ = ty.mk_str(tystore); }\n+        case (ast.ty_nil)          { typ = ty.mk_nil(tcx); }\n+        case (ast.ty_bool)         { typ = ty.mk_bool(tcx); }\n+        case (ast.ty_int)          { typ = ty.mk_int(tcx); }\n+        case (ast.ty_uint)         { typ = ty.mk_uint(tcx); }\n+        case (ast.ty_float)        { typ = ty.mk_float(tcx); }\n+        case (ast.ty_machine(?tm)) { typ = ty.mk_mach(tcx, tm); }\n+        case (ast.ty_char)         { typ = ty.mk_char(tcx); }\n+        case (ast.ty_str)          { typ = ty.mk_str(tcx); }\n         case (ast.ty_box(?mt)) {\n-            typ = ty.mk_box(tystore, ast_mt_to_mt(tystore, getter, mt));\n+            typ = ty.mk_box(tcx, ast_mt_to_mt(tcx, getter, mt));\n         }\n         case (ast.ty_vec(?mt)) {\n-            typ = ty.mk_vec(tystore, ast_mt_to_mt(tystore, getter, mt));\n+            typ = ty.mk_vec(tcx, ast_mt_to_mt(tcx, getter, mt));\n         }\n \n         case (ast.ty_port(?t)) {\n-            typ = ty.mk_port(tystore, ast_ty_to_ty(tystore, getter, t));\n+            typ = ty.mk_port(tcx, ast_ty_to_ty(tcx, getter, t));\n         }\n \n         case (ast.ty_chan(?t)) {\n-            typ = ty.mk_chan(tystore, ast_ty_to_ty(tystore, getter, t));\n+            typ = ty.mk_chan(tcx, ast_ty_to_ty(tcx, getter, t));\n         }\n \n         case (ast.ty_tup(?fields)) {\n             let vec[ty.mt] flds = vec();\n             for (ast.mt field in fields) {\n-                _vec.push[ty.mt](flds, ast_mt_to_mt(tystore, getter, field));\n+                _vec.push[ty.mt](flds, ast_mt_to_mt(tcx, getter, field));\n             }\n-            typ = ty.mk_tup(tystore, flds);\n+            typ = ty.mk_tup(tcx, flds);\n         }\n         case (ast.ty_rec(?fields)) {\n             let vec[field] flds = vec();\n             for (ast.ty_field f in fields) {\n-                auto tm = ast_mt_to_mt(tystore, getter, f.mt);\n+                auto tm = ast_mt_to_mt(tcx, getter, f.mt);\n                 _vec.push[field](flds, rec(ident=f.ident, mt=tm));\n             }\n-            typ = ty.mk_rec(tystore, flds);\n+            typ = ty.mk_rec(tcx, flds);\n         }\n \n         case (ast.ty_fn(?proto, ?inputs, ?output)) {\n-            auto f = bind ast_arg_to_arg(tystore, getter, _);\n+            auto f = bind ast_arg_to_arg(tcx, getter, _);\n             auto i = _vec.map[ast.ty_arg, arg](f, inputs);\n-            auto out_ty = ast_ty_to_ty(tystore, getter, output);\n-            typ = ty.mk_fn(tystore, proto, i, out_ty);\n+            auto out_ty = ast_ty_to_ty(tcx, getter, output);\n+            typ = ty.mk_fn(tcx, proto, i, out_ty);\n         }\n \n         case (ast.ty_path(?path, ?def)) {\n             check (def != none[ast.def]);\n             alt (option.get[ast.def](def)) {\n                 case (ast.def_ty(?id)) {\n-                    typ = instantiate(tystore, getter, id, path.node.types);\n+                    typ = instantiate(tcx, getter, id, path.node.types);\n                 }\n                 case (ast.def_native_ty(?id)) { typ = getter(id)._1; }\n                 case (ast.def_obj(?id)) {\n-                    typ = instantiate(tystore, getter, id, path.node.types);\n+                    typ = instantiate(tcx, getter, id, path.node.types);\n                 }\n-                case (ast.def_ty_arg(?id)) { typ = ty.mk_param(tystore, id); }\n+                case (ast.def_ty_arg(?id)) { typ = ty.mk_param(tcx, id); }\n                 case (_)                   { fail; }\n             }\n \n@@ -314,25 +312,25 @@ fn ast_ty_to_ty(@ty.type_store tystore,\n \n         case (ast.ty_obj(?meths)) {\n             let vec[ty.method] tmeths = vec();\n-            auto f = bind ast_arg_to_arg(tystore, getter, _);\n+            auto f = bind ast_arg_to_arg(tcx, getter, _);\n             for (ast.ty_method m in meths) {\n                 auto ins = _vec.map[ast.ty_arg, arg](f, m.inputs);\n-                auto out = ast_ty_to_ty(tystore, getter, m.output);\n+                auto out = ast_ty_to_ty(tcx, getter, m.output);\n                 _vec.push[ty.method](tmeths,\n                                   rec(proto=m.proto,\n                                       ident=m.ident,\n                                       inputs=ins,\n                                       output=out));\n             }\n \n-            typ = ty.mk_obj(tystore, ty.sort_methods(tmeths));\n+            typ = ty.mk_obj(tcx, ty.sort_methods(tmeths));\n         }\n     }\n \n     alt (cname) {\n         case (none[str]) { /* no-op */ }\n         case (some[str](?cname_str)) {\n-            typ = ty.rename(tystore, typ, cname_str);\n+            typ = ty.rename(tcx, typ, cname_str);\n         }\n     }\n     ret typ;\n@@ -342,10 +340,10 @@ fn ast_ty_to_ty(@ty.type_store tystore,\n // ast_ty_to_ty.\n fn ast_ty_to_ty_crate(@crate_ctxt ccx, &@ast.ty ast_ty) -> ty.t {\n     fn getter(@crate_ctxt ccx, ast.def_id id) -> ty.ty_param_count_and_ty {\n-        ret ty.lookup_item_type(ccx.sess, ccx.tystore, ccx.type_cache, id);\n+        ret ty.lookup_item_type(ccx.sess, ccx.tcx, ccx.type_cache, id);\n     }\n     auto f = bind getter(ccx, _);\n-    ret ast_ty_to_ty(ccx.tystore, f, ast_ty);\n+    ret ast_ty_to_ty(ccx.tcx, f, ast_ty);\n }\n \n \n@@ -364,7 +362,7 @@ mod Collect {\n     type ctxt = rec(session.session sess,\n                     @ty_item_table id_to_ty_item,\n                     ty.type_cache type_cache,\n-                    @ty.type_store tystore);\n+                    ty.ctxt tcx);\n     type env = rec(@ctxt cx, ast.native_abi abi);\n \n     fn ty_of_fn_decl(@ctxt cx,\n@@ -376,7 +374,7 @@ mod Collect {\n                      ast.def_id def_id) -> ty.ty_param_count_and_ty {\n         auto input_tys = _vec.map[ast.arg,arg](ty_of_arg, decl.inputs);\n         auto output_ty = convert(decl.output);\n-        auto t_fn = ty.mk_fn(cx.tystore, proto, input_tys, output_ty);\n+        auto t_fn = ty.mk_fn(cx.tcx, proto, input_tys, output_ty);\n         auto ty_param_count = _vec.len[ast.ty_param](ty_params);\n         auto tpt = tup(ty_param_count, t_fn);\n         cx.type_cache.insert(def_id, tpt);\n@@ -392,7 +390,7 @@ mod Collect {\n                             ast.def_id def_id) -> ty.ty_param_count_and_ty {\n         auto input_tys = _vec.map[ast.arg,arg](ty_of_arg, decl.inputs);\n         auto output_ty = convert(decl.output);\n-        auto t_fn = ty.mk_native_fn(cx.tystore, abi, input_tys, output_ty);\n+        auto t_fn = ty.mk_native_fn(cx.tcx, abi, input_tys, output_ty);\n         auto ty_param_count = _vec.len[ast.ty_param](ty_params);\n         auto tpt = tup(ty_param_count, t_fn);\n         cx.type_cache.insert(def_id, tpt);\n@@ -403,7 +401,7 @@ mod Collect {\n \n         if (id._0 != cx.sess.get_targ_crate_num()) {\n             // This is a type we need to load in from the crate reader.\n-            ret creader.get_type(cx.sess, cx.tystore, id);\n+            ret creader.get_type(cx.sess, cx.tcx, id);\n         }\n \n         // check (cx.id_to_ty_item.contains_key(id));\n@@ -422,12 +420,12 @@ mod Collect {\n \n     fn ty_of_arg(@ctxt cx, &ast.arg a) -> arg {\n         auto f = bind getter(cx, _);\n-        ret rec(mode=a.mode, ty=ast_ty_to_ty(cx.tystore, f, a.ty));\n+        ret rec(mode=a.mode, ty=ast_ty_to_ty(cx.tcx, f, a.ty));\n     }\n \n     fn ty_of_method(@ctxt cx, &@ast.method m) -> method {\n         auto get = bind getter(cx, _);\n-        auto convert = bind ast_ty_to_ty(cx.tystore, get, _);\n+        auto convert = bind ast_ty_to_ty(cx.tcx, get, _);\n         auto f = bind ty_of_arg(cx, _);\n         auto inputs = _vec.map[ast.arg,arg](f, m.node.meth.decl.inputs);\n         auto output = convert(m.node.meth.decl.output);\n@@ -442,8 +440,8 @@ mod Collect {\n         auto f = bind ty_of_method(cx, _);\n         auto methods = _vec.map[@ast.method,method](f, obj_info.methods);\n \n-        auto t_obj = ty.mk_obj(cx.tystore, ty.sort_methods(methods));\n-        t_obj = ty.rename(cx.tystore, t_obj, id);\n+        auto t_obj = ty.mk_obj(cx.tcx, ty.sort_methods(methods));\n+        t_obj = ty.rename(cx.tcx, t_obj, id);\n         auto ty_param_count = _vec.len[ast.ty_param](ty_params);\n         ret tup(ty_param_count, t_obj);\n     }\n@@ -458,20 +456,20 @@ mod Collect {\n         let vec[arg] t_inputs = vec();\n         for (ast.obj_field f in obj_info.fields) {\n             auto g = bind getter(cx, _);\n-            auto t_field = ast_ty_to_ty(cx.tystore, g, f.ty);\n+            auto t_field = ast_ty_to_ty(cx.tcx, g, f.ty);\n             _vec.push[arg](t_inputs, rec(mode=ast.alias, ty=t_field));\n         }\n \n         cx.type_cache.insert(obj_ty_id, t_obj);\n \n-        auto t_fn = ty.mk_fn(cx.tystore, ast.proto_fn, t_inputs, t_obj._1);\n+        auto t_fn = ty.mk_fn(cx.tcx, ast.proto_fn, t_inputs, t_obj._1);\n         ret tup(t_obj._0, t_fn);\n     }\n \n     fn ty_of_item(@ctxt cx, @ast.item it) -> ty.ty_param_count_and_ty {\n \n         auto get = bind getter(cx, _);\n-        auto convert = bind ast_ty_to_ty(cx.tystore, get, _);\n+        auto convert = bind ast_ty_to_ty(cx.tcx, get, _);\n \n         alt (it.node) {\n \n@@ -516,11 +514,11 @@ mod Collect {\n \n                 auto i = 0u;\n                 for (ast.ty_param tp in tps) {\n-                    subtys += vec(ty.mk_param(cx.tystore, i));\n+                    subtys += vec(ty.mk_param(cx.tcx, i));\n                     i += 1u;\n                 }\n \n-                auto t = ty.mk_tag(cx.tystore, def_id, subtys);\n+                auto t = ty.mk_tag(cx.tcx, def_id, subtys);\n \n                 auto ty_param_count = _vec.len[ast.ty_param](tps);\n                 auto tpt = tup(ty_param_count, t);\n@@ -539,7 +537,7 @@ mod Collect {\n             case (ast.native_item_fn(?ident, ?lname, ?fn_decl,\n                                      ?params, ?def_id, _)) {\n                 auto get = bind getter(cx, _);\n-                auto convert = bind ast_ty_to_ty(cx.tystore, get, _);\n+                auto convert = bind ast_ty_to_ty(cx.tcx, get, _);\n                 auto f = bind ty_of_arg(cx, _);\n                 ret ty_of_native_fn_decl(cx, convert, f, fn_decl, abi, params,\n                                          def_id);\n@@ -552,7 +550,7 @@ mod Collect {\n                     case (none[ty.ty_param_count_and_ty]) {}\n                 }\n \n-                auto t = ty.mk_native(cx.tystore);\n+                auto t = ty.mk_native(cx.tcx);\n                 auto tpt = tup(0u, t);\n                 cx.type_cache.insert(def_id, tpt);\n                 ret tpt;\n@@ -570,7 +568,7 @@ mod Collect {\n         let vec[ty.t] ty_param_tys = vec();\n         auto i = 0u;\n         for (ast.ty_param tp in ty_params) {\n-            ty_param_tys += vec(ty.mk_param(cx.tystore, i));\n+            ty_param_tys += vec(ty.mk_param(cx.tcx, i));\n             i += 1u;\n         }\n \n@@ -581,19 +579,19 @@ mod Collect {\n             // constructors get turned into functions.\n             auto result_ty;\n             if (_vec.len[ast.variant_arg](variant.node.args) == 0u) {\n-                result_ty = ty.mk_tag(cx.tystore, tag_id, ty_param_tys);\n+                result_ty = ty.mk_tag(cx.tcx, tag_id, ty_param_tys);\n             } else {\n                 // As above, tell ast_ty_to_ty() that trans_ty_item_to_ty()\n                 // should be called to resolve named types.\n                 auto f = bind getter(cx, _);\n \n                 let vec[arg] args = vec();\n                 for (ast.variant_arg va in variant.node.args) {\n-                    auto arg_ty = ast_ty_to_ty(cx.tystore, f, va.ty);\n+                    auto arg_ty = ast_ty_to_ty(cx.tcx, f, va.ty);\n                     args += vec(rec(mode=ast.alias, ty=arg_ty));\n                 }\n-                auto tag_t = ty.mk_tag(cx.tystore, tag_id, ty_param_tys);\n-                result_ty = ty.mk_fn(cx.tystore, ast.proto_fn, args, tag_t);\n+                auto tag_t = ty.mk_tag(cx.tcx, tag_id, ty_param_tys);\n+                result_ty = ty.mk_fn(cx.tcx, ast.proto_fn, args, tag_t);\n             }\n \n             auto tpt = tup(ty_param_count, result_ty);\n@@ -691,9 +689,9 @@ mod Collect {\n     }\n \n     fn get_ctor_obj_methods(&@env e, ty.t t) -> vec[method] {\n-        alt (struct(e.cx.tystore, t)) {\n+        alt (struct(e.cx.tcx, t)) {\n             case (ty.ty_fn(_,_,?tobj)) {\n-                alt (struct(e.cx.tystore, tobj)) {\n+                alt (struct(e.cx.tcx, tobj)) {\n                     case (ty.ty_obj(?tm)) {\n                         ret tm;\n                     }\n@@ -727,7 +725,7 @@ mod Collect {\n             let method meth_ty = meth_tys.(ix);\n             let ast.method_ m_;\n             let @ast.method m;\n-            auto meth_tfn = ty.mk_fn(e.cx.tystore,\n+            auto meth_tfn = ty.mk_fn(e.cx.tcx,\n                                      meth_ty.proto,\n                                      meth_ty.inputs,\n                                      meth_ty.output);\n@@ -739,7 +737,7 @@ mod Collect {\n         }\n         auto g = bind getter(e.cx, _);\n         for (ast.obj_field fld in ob.fields) {\n-            let ty.t fty = ast_ty_to_ty(e.cx.tystore, g, fld.ty);\n+            let ty.t fty = ast_ty_to_ty(e.cx.tcx, g, fld.ty);\n             let ast.obj_field f = rec(ann=triv_ann(fty)\n                 with fld\n             );\n@@ -750,8 +748,8 @@ mod Collect {\n         alt (ob.dtor) {\n             case (some[@ast.method](?d)) {\n                 let vec[arg] inputs = vec();\n-                let ty.t output = ty.mk_nil(e.cx.tystore);\n-                auto dtor_tfn = ty.mk_fn(e.cx.tystore, ast.proto_fn, inputs,\n+                let ty.t output = ty.mk_nil(e.cx.tcx);\n+                auto dtor_tfn = ty.mk_fn(e.cx.tcx, ast.proto_fn, inputs,\n                                          output);\n                 auto d_ = rec(ann=triv_ann(dtor_tfn) with d.node);\n                 dtor = some[@ast.method](@rec(node=d_ with *d));\n@@ -789,9 +787,7 @@ mod Collect {\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n-    fn collect_item_types(session.session sess,\n-                          @ty.type_store tystore,\n-                          @ast.crate crate)\n+    fn collect_item_types(session.session sess, ty.ctxt tcx, @ast.crate crate)\n             -> tup(@ast.crate, ty.type_cache, @ty_item_table) {\n         // First pass: collect all type item IDs.\n         auto module = crate.node.module;\n@@ -809,7 +805,7 @@ mod Collect {\n         auto cx = @rec(sess=sess,\n                        id_to_ty_item=id_to_ty_item,\n                        type_cache=type_cache,\n-                       tystore=tystore);\n+                       tcx=tcx);\n \n         let @env e = @rec(cx=cx, abi=ast.native_abi_cdecl);\n \n@@ -837,7 +833,7 @@ mod Unify {\n     fn simple(@fn_ctxt fcx, ty.t expected, ty.t actual) -> ty.Unify.result {\n         // FIXME: horrid botch\n         let vec[mutable ty.t] param_substs =\n-            vec(mutable ty.mk_nil(fcx.ccx.tystore));\n+            vec(mutable ty.mk_nil(fcx.ccx.tcx));\n         _vec.pop[mutable ty.t](param_substs);\n         ret with_params(fcx, expected, actual, param_substs);\n     }\n@@ -860,7 +856,7 @@ mod Unify {\n                 alt (fcx.locals.find(id)) {\n                     case (none[ty.t]) { ret none[ty.t]; }\n                     case (some[ty.t](?existing_type)) {\n-                        if (ty.type_contains_vars(fcx.ccx.tystore,\n+                        if (ty.type_contains_vars(fcx.ccx.tcx,\n                                                   existing_type)) {\n                             // Not fully resolved yet. The writeback phase\n                             // will mop up.\n@@ -890,7 +886,7 @@ mod Unify {\n                 }\n \n                 unified_type =\n-                    ty.substitute_type_params(fcx.ccx.tystore, param_substs_1,\n+                    ty.substitute_type_params(fcx.ccx.tcx, param_substs_1,\n                                               unified_type);\n                 fcx.locals.insert(id, unified_type);\n             }\n@@ -904,8 +900,7 @@ mod Unify {\n                 alt (result) {\n                     case (ures_ok(?new_subst)) {\n                         param_substs.(index) = new_subst;\n-                        ret ures_ok(ty.mk_bound_param(fcx.ccx.tystore,\n-                                                      index));\n+                        ret ures_ok(ty.mk_bound_param(fcx.ccx.tcx, index));\n                     }\n                     case (_) { ret result; }\n                 }\n@@ -914,10 +909,7 @@ mod Unify {\n \n \n         auto handler = unify_handler(fcx, param_substs);\n-        auto result = ty.Unify.unify(expected,\n-                                     actual,\n-                                     handler,\n-                                     fcx.ccx.tystore);\n+        auto result = ty.Unify.unify(expected, actual, handler, fcx.ccx.tcx);\n         fcx.ccx.unify_cache.insert(cache_key, result);\n         ret result;\n     }\n@@ -929,10 +921,10 @@ tag autoderef_kind {\n     NO_AUTODEREF;\n }\n \n-fn strip_boxes(@ty.type_store tystore, ty.t t) -> ty.t {\n+fn strip_boxes(ty.ctxt tcx, ty.t t) -> ty.t {\n     auto t1 = t;\n     while (true) {\n-        alt (struct(tystore, t1)) {\n+        alt (struct(tcx, t1)) {\n             case (ty.ty_box(?inner)) { t1 = inner.ty; }\n             case (_) { ret t1; }\n         }\n@@ -943,18 +935,18 @@ fn strip_boxes(@ty.type_store tystore, ty.t t) -> ty.t {\n fn add_boxes(@crate_ctxt ccx, uint n, ty.t t) -> ty.t {\n     auto t1 = t;\n     while (n != 0u) {\n-        t1 = ty.mk_imm_box(ccx.tystore, t1);\n+        t1 = ty.mk_imm_box(ccx.tcx, t1);\n         n -= 1u;\n     }\n     ret t1;\n }\n \n \n-fn count_boxes(@ty.type_store tystore, ty.t t) -> uint {\n+fn count_boxes(ty.ctxt tcx, ty.t t) -> uint {\n     auto n = 0u;\n     auto t1 = t;\n     while (true) {\n-        alt (struct(tystore, t1)) {\n+        alt (struct(tcx, t1)) {\n             case (ty.ty_box(?inner)) { n += 1u; t1 = inner.ty; }\n             case (_) { ret n; }\n         }\n@@ -992,13 +984,13 @@ mod Demand {\n         auto implicit_boxes = 0u;\n \n         if (adk == AUTODEREF_OK) {\n-            expected_1 = strip_boxes(fcx.ccx.tystore, expected_1);\n-            actual_1 = strip_boxes(fcx.ccx.tystore, actual_1);\n-            implicit_boxes = count_boxes(fcx.ccx.tystore, actual);\n+            expected_1 = strip_boxes(fcx.ccx.tcx, expected_1);\n+            actual_1 = strip_boxes(fcx.ccx.tcx, actual_1);\n+            implicit_boxes = count_boxes(fcx.ccx.tcx, actual);\n         }\n \n         let vec[mutable ty.t] ty_param_substs =\n-            vec(mutable ty.mk_nil(fcx.ccx.tystore));\n+            vec(mutable ty.mk_nil(fcx.ccx.tcx));\n         _vec.pop[mutable ty.t](ty_param_substs);   // FIXME: horrid botch\n         for (ty.t ty_param_subst in ty_param_substs_0) {\n             ty_param_substs += vec(mutable ty_param_subst);\n@@ -1018,8 +1010,8 @@ mod Demand {\n \n             case (ures_err(?err, ?expected, ?actual)) {\n                 fcx.ccx.sess.span_err(sp, \"mismatched types: expected \"\n-                    + ty_to_str(fcx.ccx.tystore, expected) + \" but found \"\n-                    + ty_to_str(fcx.ccx.tystore, actual) + \" (\"\n+                    + ty_to_str(fcx.ccx.tcx, expected) + \" but found \"\n+                    + ty_to_str(fcx.ccx.tcx, actual) + \" (\"\n                     + ty.type_err_to_str(err) + \")\");\n \n                 // TODO: In the future, try returning \"expected\", reporting\n@@ -1046,13 +1038,12 @@ fn variant_arg_types(@crate_ctxt ccx, &span sp, ast.def_id vid,\n \n     let vec[ty.t] result = vec();\n \n-    auto tpt = ty.lookup_item_type(ccx.sess, ccx.tystore, ccx.type_cache,\n-                                   vid);\n-    alt (struct(ccx.tystore, tpt._1)) {\n+    auto tpt = ty.lookup_item_type(ccx.sess, ccx.tcx, ccx.type_cache, vid);\n+    alt (struct(ccx.tcx, tpt._1)) {\n         case (ty.ty_fn(_, ?ins, _)) {\n             // N-ary variant.\n             for (ty.arg arg in ins) {\n-                auto arg_ty = bind_params_in_type(ccx.tystore, arg.ty);\n+                auto arg_ty = bind_params_in_type(ccx.tcx, arg.ty);\n                 arg_ty = substitute_ty_params(ccx, arg_ty, ty_param_count,\n                                               tag_ty_params, sp);\n                 result += vec(arg_ty);\n@@ -1117,7 +1108,7 @@ mod Pushdown {\n                 // Take the variant's type parameters out of the expected\n                 // type.\n                 auto tag_tps;\n-                alt (struct(fcx.ccx.tystore, expected)) {\n+                alt (struct(fcx.ccx.tcx, expected)) {\n                     case (ty.ty_tag(_, ?tps)) { tag_tps = tps; }\n                     case (_) {\n                         log_err \"tag pattern type not actually a tag?!\";\n@@ -1167,7 +1158,7 @@ mod Pushdown {\n                 auto t = Demand.simple(fcx, e.span, expected,\n                                        ann_to_type(ann));\n                 let vec[@ast.expr] es_1 = vec();\n-                alt (struct(fcx.ccx.tystore, t)) {\n+                alt (struct(fcx.ccx.tcx, t)) {\n                     case (ty.ty_vec(?mt)) {\n                         for (@ast.expr e_0 in es_0) {\n                             es_1 += vec(pushdown_expr(fcx, mt.ty, e_0));\n@@ -1184,7 +1175,7 @@ mod Pushdown {\n                 auto t = Demand.simple(fcx, e.span, expected,\n                                        ann_to_type(ann));\n                 let vec[ast.elt] elts_1 = vec();\n-                alt (struct(fcx.ccx.tystore, t)) {\n+                alt (struct(fcx.ccx.tcx, t)) {\n                     case (ty.ty_tup(?mts)) {\n                         auto i = 0u;\n                         for (ast.elt elt_0 in es_0) {\n@@ -1208,7 +1199,7 @@ mod Pushdown {\n                 auto t = Demand.simple(fcx, e.span, expected,\n                                        ann_to_type(ann));\n                 let vec[ast.field] fields_1 = vec();\n-                alt (struct(fcx.ccx.tystore, t)) {\n+                alt (struct(fcx.ccx.tcx, t)) {\n                     case (ty.ty_rec(?field_mts)) {\n                         alt (base_0) {\n                             case (none[@ast.expr]) {\n@@ -1421,9 +1412,9 @@ mod Pushdown {\n                 auto t = Demand.simple(fcx, e.span, expected,\n                                        ann_to_type(ann));\n                 let @ast.expr es_1;\n-                alt (struct(fcx.ccx.tystore, t)) {\n+                alt (struct(fcx.ccx.tcx, t)) {\n                     case (ty.ty_chan(?subty)) {\n-                        auto pt = ty.mk_port(fcx.ccx.tystore, subty);\n+                        auto pt = ty.mk_port(fcx.ccx.tcx, subty);\n                         es_1 = pushdown_expr(fcx, pt, es);\n                     }\n                     case (_) {\n@@ -1440,7 +1431,7 @@ mod Pushdown {\n                 for (ast.arm arm_0 in arms_0) {\n                     auto block_1 = pushdown_block(fcx, expected, arm_0.block);\n                     t = Demand.simple(fcx, e.span, t,\n-                                      block_ty(fcx.ccx.tystore, block_1));\n+                                      block_ty(fcx.ccx.tcx, block_1));\n                     auto arm_1 = rec(pat=arm_0.pat, block=block_1,\n                                      index=arm_0.index);\n                     arms_1 += vec(arm_1);\n@@ -1451,19 +1442,17 @@ mod Pushdown {\n             case (ast.expr_recv(?lval_0, ?expr_0, ?ann)) {\n                 auto lval_1 = pushdown_expr(fcx, next_ty_var(fcx.ccx),\n                                             lval_0);\n-                auto t = expr_ty(fcx.ccx.tystore, lval_1);\n-                auto expr_1 = pushdown_expr(fcx,\n-                                            ty.mk_port(fcx.ccx.tystore, t),\n+                auto t = expr_ty(fcx.ccx.tcx, lval_1);\n+                auto expr_1 = pushdown_expr(fcx, ty.mk_port(fcx.ccx.tcx, t),\n                                             expr_0);\n                 e_1 = ast.expr_recv(lval_1, expr_1, ann);\n             }\n \n             case (ast.expr_send(?lval_0, ?expr_0, ?ann)) {\n                 auto expr_1 = pushdown_expr(fcx, next_ty_var(fcx.ccx),\n                                             expr_0);\n-                auto t = expr_ty(fcx.ccx.tystore, expr_1);\n-                auto lval_1 = pushdown_expr(fcx,\n-                                            ty.mk_chan(fcx.ccx.tystore, t),\n+                auto t = expr_ty(fcx.ccx.tcx, expr_1);\n+                auto lval_1 = pushdown_expr(fcx, ty.mk_chan(fcx.ccx.tcx, t),\n                                             lval_0);\n                 e_1 = ast.expr_send(lval_1, expr_1, ann);\n             }\n@@ -1488,14 +1477,14 @@ mod Pushdown {\n                 auto block_ = rec(stmts=bloc.node.stmts,\n                                   expr=some[@ast.expr](e_1),\n                                   index=bloc.node.index,\n-                                  a=plain_ann(fcx.ccx.tystore));\n+                                  a=plain_ann(fcx.ccx.tcx));\n                 ret fold.respan[ast.block_](bloc.span, block_);\n             }\n             case (none[@ast.expr]) {\n                 Demand.simple(fcx, bloc.span, expected,\n-                              ty.mk_nil(fcx.ccx.tystore));\n+                              ty.mk_nil(fcx.ccx.tcx));\n                 ret fold.respan[ast.block_](bloc.span,\n-                      rec(a = plain_ann(fcx.ccx.tystore) with bloc.node));\n+                      rec(a = plain_ann(fcx.ccx.tcx) with bloc.node));\n             }\n         }\n     }\n@@ -1530,7 +1519,7 @@ fn writeback_local(&option.t[@fn_ctxt] env, &span sp, @ast.local local)\n fn resolve_local_types_in_annotation(&option.t[@fn_ctxt] env, ast.ann ann)\n         -> ast.ann {\n     fn resolver(@fn_ctxt fcx, ty.t typ) -> ty.t {\n-        alt (struct(fcx.ccx.tystore, typ)) {\n+        alt (struct(fcx.ccx.tcx, typ)) {\n             case (ty.ty_local(?lid)) { ret fcx.locals.get(lid); }\n             case (_)                 { ret typ; }\n         }\n@@ -1544,7 +1533,7 @@ fn resolve_local_types_in_annotation(&option.t[@fn_ctxt] env, ast.ann ann)\n         }\n         case (ast.ann_type(?typ, ?tps, ?ts_info)) {\n             auto f = bind resolver(fcx, _);\n-            auto new_type = ty.fold_ty(fcx.ccx.tystore, f, ann_to_type(ann));\n+            auto new_type = ty.fold_ty(fcx.ccx.tcx, f, ann_to_type(ann));\n             ret ast.ann_type(new_type, tps, ts_info);\n         }\n     }\n@@ -1580,16 +1569,16 @@ fn resolve_local_types_in_block(&@fn_ctxt fcx, &ast.block block)\n \n fn check_lit(@crate_ctxt ccx, @ast.lit lit) -> ty.t {\n     alt (lit.node) {\n-        case (ast.lit_str(_))           { ret ty.mk_str(ccx.tystore); }\n-        case (ast.lit_char(_))          { ret ty.mk_char(ccx.tystore); }\n-        case (ast.lit_int(_))           { ret ty.mk_int(ccx.tystore);  }\n-        case (ast.lit_float(_))         { ret ty.mk_float(ccx.tystore);  }\n+        case (ast.lit_str(_))           { ret ty.mk_str(ccx.tcx); }\n+        case (ast.lit_char(_))          { ret ty.mk_char(ccx.tcx); }\n+        case (ast.lit_int(_))           { ret ty.mk_int(ccx.tcx);  }\n+        case (ast.lit_float(_))         { ret ty.mk_float(ccx.tcx);  }\n         case (ast.lit_mach_float(?tm, _))\n-                                        { ret ty.mk_mach(ccx.tystore, tm); }\n-        case (ast.lit_uint(_))          { ret ty.mk_uint(ccx.tystore); }\n-        case (ast.lit_mach_int(?tm, _)) { ret ty.mk_mach(ccx.tystore, tm); }\n-        case (ast.lit_nil)              { ret ty.mk_nil(ccx.tystore);  }\n-        case (ast.lit_bool(_))          { ret ty.mk_bool(ccx.tystore); }\n+                                        { ret ty.mk_mach(ccx.tcx, tm); }\n+        case (ast.lit_uint(_))          { ret ty.mk_uint(ccx.tcx); }\n+        case (ast.lit_mach_int(?tm, _)) { ret ty.mk_mach(ccx.tcx, tm); }\n+        case (ast.lit_nil)              { ret ty.mk_nil(ccx.tcx);  }\n+        case (ast.lit_bool(_))          { ret ty.mk_bool(ccx.tcx); }\n     }\n \n     fail; // not reached\n@@ -1610,16 +1599,16 @@ fn check_pat(&@fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n         }\n         case (ast.pat_tag(?p, ?subpats, ?vdef_opt, _)) {\n             auto vdef = option.get[ast.variant_def](vdef_opt);\n-            auto t = ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.tystore,\n+            auto t = ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx,\n                                          fcx.ccx.type_cache, vdef._1)._1;\n             auto len = _vec.len[ast.ident](p.node.idents);\n             auto last_id = p.node.idents.(len - 1u);\n \n-            auto tpt = ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.tystore,\n+            auto tpt = ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx,\n                                            fcx.ccx.type_cache, vdef._0);\n             auto ann = instantiate_path(fcx, p, tpt, pat.span);\n \n-            alt (struct(fcx.ccx.tystore, t)) {\n+            alt (struct(fcx.ccx.tcx, t)) {\n                 // N-ary variants have function types.\n                 case (ty.ty_fn(_, ?args, ?tag_ty)) {\n                     auto arg_len = _vec.len[arg](args);\n@@ -1692,7 +1681,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n                     // FIXME: this breaks aliases. We need a ty_fn_arg.\n                     auto arg_ty = rec(mode=ast.val,\n-                                      ty=expr_ty(fcx.ccx.tystore, a_0));\n+                                      ty=expr_ty(fcx.ccx.tcx, a_0));\n                     _vec.push[arg](arg_tys_0, arg_ty);\n                 }\n                 case (none[@ast.expr]) {\n@@ -1707,12 +1696,12 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         auto rt_0 = next_ty_var(fcx.ccx);\n         auto t_0;\n-        alt (struct(fcx.ccx.tystore, expr_ty(fcx.ccx.tystore, f_0))) {\n+        alt (struct(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, f_0))) {\n             case (ty.ty_fn(?proto, _, _))   {\n-                t_0 = ty.mk_fn(fcx.ccx.tystore, proto, arg_tys_0, rt_0);\n+                t_0 = ty.mk_fn(fcx.ccx.tcx, proto, arg_tys_0, rt_0);\n             }\n             case (ty.ty_native_fn(?abi, _, _))   {\n-                t_0 = ty.mk_native_fn(fcx.ccx.tystore, abi, arg_tys_0, rt_0);\n+                t_0 = ty.mk_native_fn(fcx.ccx.tcx, abi, arg_tys_0, rt_0);\n             }\n             case (_) {\n                 log_err \"check_call_or_bind(): fn expr doesn't have fn type\";\n@@ -1721,7 +1710,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         }\n \n         // Unify the callee and arguments.\n-        auto tpt_0 = ty.expr_ty_params_and_ty(fcx.ccx.tystore, f_0);\n+        auto tpt_0 = ty.expr_ty_params_and_ty(fcx.ccx.tcx, f_0);\n         auto tpt_1 = Demand.full(fcx, f.span, tpt_0._1, t_0, tpt_0._0,\n                                  NO_AUTODEREF);\n         auto f_1 = ty.replace_expr_type(f_0, tpt_1);\n@@ -1734,15 +1723,14 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         -> tup(@ast.expr, @ast.expr, ast.ann) {\n         auto lhs_0 = check_expr(fcx, lhs);\n         auto rhs_0 = check_expr(fcx, rhs);\n-        auto lhs_t0 = expr_ty(fcx.ccx.tystore, lhs_0);\n-        auto rhs_t0 = expr_ty(fcx.ccx.tystore, rhs_0);\n+        auto lhs_t0 = expr_ty(fcx.ccx.tcx, lhs_0);\n+        auto rhs_t0 = expr_ty(fcx.ccx.tcx, rhs_0);\n \n         auto lhs_1 = Pushdown.pushdown_expr(fcx, rhs_t0, lhs_0);\n-        auto rhs_1 = Pushdown.pushdown_expr(fcx,\n-                                            expr_ty(fcx.ccx.tystore, lhs_1),\n+        auto rhs_1 = Pushdown.pushdown_expr(fcx, expr_ty(fcx.ccx.tcx, lhs_1),\n                                             rhs_0);\n \n-        auto ann = triv_ann(expr_ty(fcx.ccx.tystore, rhs_1));\n+        auto ann = triv_ann(expr_ty(fcx.ccx.tcx, rhs_1));\n         ret tup(lhs_1, rhs_1, ann);\n     }\n \n@@ -1778,25 +1766,25 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         case (ast.expr_binary(?binop, ?lhs, ?rhs, _)) {\n             auto lhs_0 = check_expr(fcx, lhs);\n             auto rhs_0 = check_expr(fcx, rhs);\n-            auto lhs_t0 = expr_ty(fcx.ccx.tystore, lhs_0);\n-            auto rhs_t0 = expr_ty(fcx.ccx.tystore, rhs_0);\n+            auto lhs_t0 = expr_ty(fcx.ccx.tcx, lhs_0);\n+            auto rhs_t0 = expr_ty(fcx.ccx.tcx, rhs_0);\n \n             // FIXME: Binops have a bit more subtlety than this.\n             auto lhs_1 = Pushdown.pushdown_expr_full(fcx, rhs_t0, lhs_0,\n                                                      AUTODEREF_OK);\n             auto rhs_1 =\n                 Pushdown.pushdown_expr_full(fcx,\n-                                            expr_ty(fcx.ccx.tystore, lhs_1),\n+                                            expr_ty(fcx.ccx.tcx, lhs_1),\n                                             rhs_0, AUTODEREF_OK);\n \n-            auto t = strip_boxes(fcx.ccx.tystore, lhs_t0);\n+            auto t = strip_boxes(fcx.ccx.tcx, lhs_t0);\n             alt (binop) {\n-                case (ast.eq) { t = ty.mk_bool(fcx.ccx.tystore); }\n-                case (ast.lt) { t = ty.mk_bool(fcx.ccx.tystore); }\n-                case (ast.le) { t = ty.mk_bool(fcx.ccx.tystore); }\n-                case (ast.ne) { t = ty.mk_bool(fcx.ccx.tystore); }\n-                case (ast.ge) { t = ty.mk_bool(fcx.ccx.tystore); }\n-                case (ast.gt) { t = ty.mk_bool(fcx.ccx.tystore); }\n+                case (ast.eq) { t = ty.mk_bool(fcx.ccx.tcx); }\n+                case (ast.lt) { t = ty.mk_bool(fcx.ccx.tcx); }\n+                case (ast.le) { t = ty.mk_bool(fcx.ccx.tcx); }\n+                case (ast.ne) { t = ty.mk_bool(fcx.ccx.tcx); }\n+                case (ast.ge) { t = ty.mk_bool(fcx.ccx.tcx); }\n+                case (ast.gt) { t = ty.mk_bool(fcx.ccx.tcx); }\n                 case (_) { /* fall through */ }\n             }\n \n@@ -1809,26 +1797,26 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_unary(?unop, ?oper, _)) {\n             auto oper_1 = check_expr(fcx, oper);\n-            auto oper_t = expr_ty(fcx.ccx.tystore, oper_1);\n+            auto oper_t = expr_ty(fcx.ccx.tcx, oper_1);\n             alt (unop) {\n                 case (ast.box(?mut)) {\n-                    oper_t = ty.mk_box(fcx.ccx.tystore,\n+                    oper_t = ty.mk_box(fcx.ccx.tcx,\n                                        rec(ty=oper_t, mut=mut));\n                 }\n                 case (ast.deref) {\n-                    alt (struct(fcx.ccx.tystore, oper_t)) {\n+                    alt (struct(fcx.ccx.tcx, oper_t)) {\n                         case (ty.ty_box(?inner)) {\n                             oper_t = inner.ty;\n                         }\n                         case (_) {\n                             fcx.ccx.sess.span_err\n                                 (expr.span,\n                                  \"dereferencing non-box type: \"\n-                                 + ty_to_str(fcx.ccx.tystore, oper_t));\n+                                 + ty_to_str(fcx.ccx.tcx, oper_t));\n                         }\n                     }\n                 }\n-                case (_) { oper_t = strip_boxes(fcx.ccx.tystore, oper_t); }\n+                case (_) { oper_t = strip_boxes(fcx.ccx.tcx, oper_t); }\n             }\n \n             auto ann = triv_ann(oper_t);\n@@ -1837,7 +1825,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         }\n \n         case (ast.expr_path(?pth, ?defopt, _)) {\n-            auto t = ty.mk_nil(fcx.ccx.tystore);\n+            auto t = ty.mk_nil(fcx.ccx.tcx);\n             check (defopt != none[ast.def]);\n             auto defn = option.get[ast.def](defopt);\n \n@@ -1863,7 +1851,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_ext(?p, ?args, ?body, ?expanded, _)) {\n             auto exp_ = check_expr(fcx, expanded);\n-            auto t = expr_ty(fcx.ccx.tystore, exp_);\n+            auto t = expr_ty(fcx.ccx.tcx, exp_);\n             auto ann = triv_ann(t);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_ext(p, args, body, exp_,\n@@ -1872,23 +1860,23 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_fail(_)) {\n             ret @fold.respan[ast.expr_](expr.span,\n-                ast.expr_fail(plain_ann(fcx.ccx.tystore)));\n+                ast.expr_fail(plain_ann(fcx.ccx.tcx)));\n         }\n \n         case (ast.expr_break(_)) {\n             ret @fold.respan[ast.expr_](expr.span,\n-                ast.expr_break(plain_ann(fcx.ccx.tystore)));\n+                ast.expr_break(plain_ann(fcx.ccx.tcx)));\n         }\n \n         case (ast.expr_cont(_)) {\n             ret @fold.respan[ast.expr_](expr.span,\n-                ast.expr_cont(plain_ann(fcx.ccx.tystore)));\n+                ast.expr_cont(plain_ann(fcx.ccx.tcx)));\n         }\n \n         case (ast.expr_ret(?expr_opt, _)) {\n             alt (expr_opt) {\n                 case (none[@ast.expr]) {\n-                    auto nil = ty.mk_nil(fcx.ccx.tystore);\n+                    auto nil = ty.mk_nil(fcx.ccx.tcx);\n                     if (!are_compatible(fcx, fcx.ret_ty, nil)) {\n                         fcx.ccx.sess.err(\"ret; in function \"\n                                          + \"returning non-nil\");\n@@ -1897,7 +1885,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                     ret @fold.respan[ast.expr_]\n                         (expr.span,\n                          ast.expr_ret(none[@ast.expr],\n-                                      plain_ann(fcx.ccx.tystore)));\n+                                      plain_ann(fcx.ccx.tcx)));\n                 }\n \n                 case (some[@ast.expr](?e)) {\n@@ -1906,23 +1894,23 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                                          expr_0);\n                     ret @fold.respan[ast.expr_]\n                         (expr.span, ast.expr_ret(some(expr_1),\n-                                                 plain_ann(fcx.ccx.tystore)));\n+                                                 plain_ann(fcx.ccx.tcx)));\n                 }\n             }\n         }\n \n         case (ast.expr_put(?expr_opt, _)) {\n             alt (expr_opt) {\n                 case (none[@ast.expr]) {\n-                    auto nil = ty.mk_nil(fcx.ccx.tystore);\n+                    auto nil = ty.mk_nil(fcx.ccx.tcx);\n                     if (!are_compatible(fcx, fcx.ret_ty, nil)) {\n                         fcx.ccx.sess.err(\"put; in function \"\n                                          + \"putting non-nil\");\n                     }\n \n                     ret @fold.respan[ast.expr_]\n                         (expr.span, ast.expr_put(none[@ast.expr],\n-                         plain_ann(fcx.ccx.tystore)));\n+                         plain_ann(fcx.ccx.tcx)));\n                 }\n \n                 case (some[@ast.expr](?e)) {\n@@ -1931,7 +1919,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                                          expr_0);\n                     ret @fold.respan[ast.expr_]\n                         (expr.span, ast.expr_put(some(expr_1),\n-                                                 plain_ann(fcx.ccx.tystore)));\n+                                                 plain_ann(fcx.ccx.tcx)));\n                 }\n             }\n         }\n@@ -1942,23 +1930,23 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto expr_0 = check_expr(fcx, e);\n             auto expr_1 = Pushdown.pushdown_expr(fcx, fcx.ret_ty, expr_0);\n             ret @fold.respan[ast.expr_](expr.span,\n-                ast.expr_be(expr_1, plain_ann(fcx.ccx.tystore)));\n+                ast.expr_be(expr_1, plain_ann(fcx.ccx.tcx)));\n         }\n \n         case (ast.expr_log(?l,?e,_)) {\n             auto expr_t = check_expr(fcx, e);\n             ret @fold.respan[ast.expr_]\n                 (expr.span, ast.expr_log(l, expr_t,\n-                                         plain_ann(fcx.ccx.tystore)));\n+                                         plain_ann(fcx.ccx.tcx)));\n         }\n \n         case (ast.expr_check_expr(?e, _)) {\n             auto expr_t = check_expr(fcx, e);\n-            Demand.simple(fcx, expr.span, ty.mk_bool(fcx.ccx.tystore),\n-                          expr_ty(fcx.ccx.tystore, expr_t));\n+            Demand.simple(fcx, expr.span, ty.mk_bool(fcx.ccx.tcx),\n+                          expr_ty(fcx.ccx.tcx, expr_t));\n             ret @fold.respan[ast.expr_]\n                 (expr.span, ast.expr_check_expr(expr_t,\n-                                                plain_ann(fcx.ccx.tystore)));\n+                                                plain_ann(fcx.ccx.tcx)));\n         }\n \n         case (ast.expr_assign(?lhs, ?rhs, _)) {\n@@ -1981,12 +1969,12 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         case (ast.expr_send(?lhs, ?rhs, _)) {\n             auto lhs_0 = check_expr(fcx, lhs);\n             auto rhs_0 = check_expr(fcx, rhs);\n-            auto rhs_t = expr_ty(fcx.ccx.tystore, rhs_0);\n+            auto rhs_t = expr_ty(fcx.ccx.tcx, rhs_0);\n \n-            auto chan_t = ty.mk_chan(fcx.ccx.tystore, rhs_t);\n+            auto chan_t = ty.mk_chan(fcx.ccx.tcx, rhs_t);\n             auto lhs_1 = Pushdown.pushdown_expr(fcx, chan_t, lhs_0);\n             auto item_t;\n-            alt (struct(fcx.ccx.tystore, expr_ty(fcx.ccx.tystore, lhs_1))) {\n+            alt (struct(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, lhs_1))) {\n                 case (ty.ty_chan(?it)) {\n                     item_t = it;\n                 }\n@@ -2004,12 +1992,12 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         case (ast.expr_recv(?lhs, ?rhs, _)) {\n             auto lhs_0 = check_expr(fcx, lhs);\n             auto rhs_0 = check_expr(fcx, rhs);\n-            auto lhs_t1 = expr_ty(fcx.ccx.tystore, lhs_0);\n+            auto lhs_t1 = expr_ty(fcx.ccx.tcx, lhs_0);\n \n-            auto port_t = ty.mk_port(fcx.ccx.tystore, lhs_t1);\n+            auto port_t = ty.mk_port(fcx.ccx.tcx, lhs_t1);\n             auto rhs_1 = Pushdown.pushdown_expr(fcx, port_t, rhs_0);\n             auto item_t;\n-            alt (struct(fcx.ccx.tystore, expr_ty(fcx.ccx.tystore, rhs_0))) {\n+            alt (struct(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, rhs_0))) {\n                 case (ty.ty_port(?it)) {\n                     item_t = it;\n                 }\n@@ -2026,12 +2014,11 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_if(?cond, ?thn, ?elsopt, _)) {\n             auto cond_0 = check_expr(fcx, cond);\n-            auto cond_1 = Pushdown.pushdown_expr(fcx,\n-                                                 ty.mk_bool(fcx.ccx.tystore),\n+            auto cond_1 = Pushdown.pushdown_expr(fcx, ty.mk_bool(fcx.ccx.tcx),\n                                                  cond_0);\n \n             auto thn_0 = check_block(fcx, thn);\n-            auto thn_t = block_ty(fcx.ccx.tystore, thn_0);\n+            auto thn_t = block_ty(fcx.ccx.tcx, thn_0);\n \n             auto elsopt_1;\n             auto elsopt_t;\n@@ -2040,11 +2027,11 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                     auto els_0 = check_expr(fcx, els);\n                     auto els_1 = Pushdown.pushdown_expr(fcx, thn_t, els_0);\n                     elsopt_1 = some[@ast.expr](els_1);\n-                    elsopt_t = expr_ty(fcx.ccx.tystore, els_1);\n+                    elsopt_t = expr_ty(fcx.ccx.tcx, els_1);\n                 }\n                 case (none[@ast.expr]) {\n                     elsopt_1 = none[@ast.expr];\n-                    elsopt_t = ty.mk_nil(fcx.ccx.tystore);\n+                    elsopt_t = ty.mk_nil(fcx.ccx.tcx);\n                 }\n             }\n \n@@ -2064,7 +2051,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             // FIXME: enforce that the type of the decl is the element type\n             // of the seq.\n \n-            auto ann = triv_ann(ty.mk_nil(fcx.ccx.tystore));\n+            auto ann = triv_ann(ty.mk_nil(fcx.ccx.tcx));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_for(decl_1, seq_1,\n                                                      body_1, ann));\n@@ -2075,32 +2062,30 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto seq_1 = check_expr(fcx, seq);\n             auto body_1 = check_block(fcx, body);\n \n-            auto ann = triv_ann(ty.mk_nil(fcx.ccx.tystore));\n+            auto ann = triv_ann(ty.mk_nil(fcx.ccx.tcx));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_for_each(decl_1, seq_1,\n                                                           body_1, ann));\n         }\n \n         case (ast.expr_while(?cond, ?body, _)) {\n             auto cond_0 = check_expr(fcx, cond);\n-            auto cond_1 = Pushdown.pushdown_expr(fcx,\n-                                                 ty.mk_bool(fcx.ccx.tystore),\n+            auto cond_1 = Pushdown.pushdown_expr(fcx, ty.mk_bool(fcx.ccx.tcx),\n                                                  cond_0);\n             auto body_1 = check_block(fcx, body);\n \n-            auto ann = triv_ann(ty.mk_nil(fcx.ccx.tystore));\n+            auto ann = triv_ann(ty.mk_nil(fcx.ccx.tcx));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_while(cond_1, body_1, ann));\n         }\n \n         case (ast.expr_do_while(?body, ?cond, _)) {\n             auto cond_0 = check_expr(fcx, cond);\n-            auto cond_1 = Pushdown.pushdown_expr(fcx,\n-                                                 ty.mk_bool(fcx.ccx.tystore),\n+            auto cond_1 = Pushdown.pushdown_expr(fcx, ty.mk_bool(fcx.ccx.tcx),\n                                                  cond_0);\n             auto body_1 = check_block(fcx, body);\n \n-            auto ann = triv_ann(block_ty(fcx.ccx.tystore, body_1));\n+            auto ann = triv_ann(block_ty(fcx.ccx.tcx, body_1));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_do_while(body_1, cond_1,\n                                                           ann));\n@@ -2111,13 +2096,13 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             // Typecheck the patterns first, so that we get types for all the\n             // bindings.\n-            auto pattern_ty = expr_ty(fcx.ccx.tystore, expr_0);\n+            auto pattern_ty = expr_ty(fcx.ccx.tcx, expr_0);\n \n             let vec[@ast.pat] pats_0 = vec();\n             for (ast.arm arm in arms) {\n                 auto pat_0 = check_pat(fcx, arm.pat);\n                 pattern_ty = Demand.simple(fcx, pat_0.span, pattern_ty,\n-                                           pat_ty(fcx.ccx.tystore, pat_0));\n+                                           pat_ty(fcx.ccx.tcx, pat_0));\n                 pats_0 += vec(pat_0);\n             }\n \n@@ -2133,7 +2118,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             for (ast.arm arm in arms) {\n                 auto block_0 = check_block(fcx, arm.block);\n                 result_ty = Demand.simple(fcx, block_0.span, result_ty,\n-                                          block_ty(fcx.ccx.tystore, block_0));\n+                                          block_ty(fcx.ccx.tcx, block_0));\n                 blocks_0 += vec(block_0);\n             }\n \n@@ -2161,14 +2146,13 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto ann;\n             alt (b_0.node.expr) {\n                 case (some[@ast.expr](?expr)) {\n-                    ann = triv_ann(expr_ty(fcx.ccx.tystore, expr));\n+                    ann = triv_ann(expr_ty(fcx.ccx.tcx, expr));\n                 }\n                 case (none[@ast.expr]) {\n-                    ann = triv_ann(ty.mk_nil(fcx.ccx.tystore));\n+                    ann = triv_ann(ty.mk_nil(fcx.ccx.tcx));\n                 }\n             }\n-            ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_block(b_0, ann));\n+            ret @fold.respan[ast.expr_](expr.span, ast.expr_block(b_0, ann));\n         }\n \n         case (ast.expr_bind(?f, ?args, _)) {\n@@ -2179,8 +2163,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto proto_1;\n             let vec[ty.arg] arg_tys_1 = vec();\n             auto rt_1;\n-            alt (struct(fcx.ccx.tystore,\n-                        expr_ty(fcx.ccx.tystore, result._0))) {\n+            alt (struct(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, result._0))) {\n                 case (ty.ty_fn(?proto, ?arg_tys, ?rt)) {\n                     proto_1 = proto;\n                     rt_1 = rt;\n@@ -2204,7 +2187,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 }\n             }\n \n-            auto t_1 = ty.mk_fn(fcx.ccx.tystore, proto_1, arg_tys_1, rt_1);\n+            auto t_1 = ty.mk_fn(fcx.ccx.tcx, proto_1, arg_tys_1, rt_1);\n             auto ann = triv_ann(t_1);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_bind(result._0, result._1,\n@@ -2217,8 +2200,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto args_1 = result._1;\n \n             // Pull the return type out of the type of the function.\n-            auto rt_1 = ty.mk_nil(fcx.ccx.tystore);  // FIXME: typestate botch\n-            alt (struct(fcx.ccx.tystore, expr_ty(fcx.ccx.tystore, f_1))) {\n+            auto rt_1 = ty.mk_nil(fcx.ccx.tcx);  // FIXME: typestate botch\n+            alt (struct(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, f_1))) {\n                 case (ty.ty_fn(_,_,?rt))    { rt_1 = rt; }\n                 case (ty.ty_native_fn(_, _, ?rt))    { rt_1 = rt; }\n                 case (_) {\n@@ -2233,15 +2216,15 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         }\n \n         case (ast.expr_self_method(?id, _)) {\n-            auto t = ty.mk_nil(fcx.ccx.tystore);\n+            auto t = ty.mk_nil(fcx.ccx.tcx);\n             let ty.t this_obj_ty;\n \n             // Grab the type of the current object\n             auto this_obj_id = fcx.ccx.this_obj;\n             alt (this_obj_id) {\n                 case (some[ast.def_id](?def_id)) {\n                     this_obj_ty = ty.lookup_item_type(fcx.ccx.sess,\n-                        fcx.ccx.tystore, fcx.ccx.type_cache, def_id)._1;\n+                        fcx.ccx.tcx, fcx.ccx.type_cache, def_id)._1;\n                 }\n                 case (_) { fail; }\n             }\n@@ -2250,11 +2233,11 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             // Grab this method's type out of the current object type\n \n             // this_obj_ty is an ty.t\n-            alt (struct(fcx.ccx.tystore, this_obj_ty)) {\n+            alt (struct(fcx.ccx.tcx, this_obj_ty)) {\n                 case (ty.ty_obj(?methods)) {\n                     for (ty.method method in methods) {\n                         if (method.ident == id) {\n-                            t = ty.method_ty_to_fn_ty(fcx.ccx.tystore,\n+                            t = ty.method_ty_to_fn_ty(fcx.ccx.tcx,\n                                                       method);\n                         }\n                     }\n@@ -2274,9 +2257,9 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto args_1 = result._1;\n \n             // Check the return type\n-            alt (struct(fcx.ccx.tystore, expr_ty(fcx.ccx.tystore, f_1))) {\n+            alt (struct(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, f_1))) {\n                 case (ty.ty_fn(_,_,?rt)) {\n-                    alt (struct(fcx.ccx.tystore, rt)) {\n+                    alt (struct(fcx.ccx.tcx, rt)) {\n                         case (ty.ty_nil) {\n                             // This is acceptable\n                         }\n@@ -2292,7 +2275,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             // FIXME: Other typechecks needed\n \n-            auto ann = triv_ann(ty.mk_task(fcx.ccx.tystore));\n+            auto ann = triv_ann(ty.mk_task(fcx.ccx.tcx));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_spawn(dom, name,\n                                                        f_1, args_1, ann));\n@@ -2302,14 +2285,12 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto e_1 = check_expr(fcx, e);\n             auto t_1 = ast_ty_to_ty_crate(fcx.ccx, t);\n             // FIXME: there are more forms of cast to support, eventually.\n-            if (! (type_is_scalar(fcx.ccx.tystore,\n-                                  expr_ty(fcx.ccx.tystore, e_1)) &&\n-                   type_is_scalar(fcx.ccx.tystore, t_1))) {\n+            if (! (type_is_scalar(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, e_1)) &&\n+                   type_is_scalar(fcx.ccx.tcx, t_1))) {\n                 fcx.ccx.sess.span_err(expr.span,\n                     \"non-scalar cast: \" +\n-                    ty_to_str(fcx.ccx.tystore,\n-                              expr_ty(fcx.ccx.tystore, e_1)) + \" as \" +\n-                    ty_to_str(fcx.ccx.tystore, t_1));\n+                    ty_to_str(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, e_1)) +\n+                    \" as \" + ty_to_str(fcx.ccx.tcx, t_1));\n             }\n \n             auto ann = triv_ann(t_1);\n@@ -2325,17 +2306,17 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 t = next_ty_var(fcx.ccx);\n             } else {\n                 auto expr_1 = check_expr(fcx, args.(0));\n-                t = expr_ty(fcx.ccx.tystore, expr_1);\n+                t = expr_ty(fcx.ccx.tcx, expr_1);\n             }\n \n             for (@ast.expr e in args) {\n                 auto expr_1 = check_expr(fcx, e);\n-                auto expr_t = expr_ty(fcx.ccx.tystore, expr_1);\n+                auto expr_t = expr_ty(fcx.ccx.tcx, expr_1);\n                 Demand.simple(fcx, expr.span, t, expr_t);\n                 _vec.push[@ast.expr](args_1,expr_1);\n             }\n \n-            auto ann = triv_ann(ty.mk_vec(fcx.ccx.tystore,\n+            auto ann = triv_ann(ty.mk_vec(fcx.ccx.tcx,\n                                           rec(ty=t, mut=mut)));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_vec(args_1, mut, ann));\n@@ -2347,12 +2328,12 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             for (ast.elt e in elts) {\n                 auto expr_1 = check_expr(fcx, e.expr);\n-                auto expr_t = expr_ty(fcx.ccx.tystore, expr_1);\n+                auto expr_t = expr_ty(fcx.ccx.tcx, expr_1);\n                 _vec.push[ast.elt](elts_1, rec(expr=expr_1 with e));\n                 elts_mt += vec(rec(ty=expr_t, mut=e.mut));\n             }\n \n-            auto ann = triv_ann(ty.mk_tup(fcx.ccx.tystore, elts_mt));\n+            auto ann = triv_ann(ty.mk_tup(fcx.ccx.tcx, elts_mt));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_tup(elts_1, ann));\n         }\n@@ -2372,7 +2353,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             for (ast.field f in fields) {\n                 auto expr_1 = check_expr(fcx, f.expr);\n-                auto expr_t = expr_ty(fcx.ccx.tystore, expr_1);\n+                auto expr_t = expr_ty(fcx.ccx.tcx, expr_1);\n                 _vec.push[ast.field](fields_1, rec(expr=expr_1 with f));\n \n                 auto expr_mt = rec(ty=expr_t, mut=f.mut);\n@@ -2383,16 +2364,16 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             alt (base) {\n                 case (none[@ast.expr]) {\n-                    ann = triv_ann(ty.mk_rec(fcx.ccx.tystore, fields_t));\n+                    ann = triv_ann(ty.mk_rec(fcx.ccx.tcx, fields_t));\n                 }\n \n                 case (some[@ast.expr](?bexpr)) {\n                     auto bexpr_1 = check_expr(fcx, bexpr);\n-                    auto bexpr_t = expr_ty(fcx.ccx.tystore, bexpr_1);\n+                    auto bexpr_t = expr_ty(fcx.ccx.tcx, bexpr_1);\n \n                     let vec[field] base_fields = vec();\n \n-                    alt (struct(fcx.ccx.tystore, bexpr_t)) {\n+                    alt (struct(fcx.ccx.tcx, bexpr_t)) {\n                         case (ty.ty_rec(?flds)) {\n                             base_fields = flds;\n                         }\n@@ -2430,9 +2411,9 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_field(?base, ?field, _)) {\n             auto base_1 = check_expr(fcx, base);\n-            auto base_t = strip_boxes(fcx.ccx.tystore,\n-                                      expr_ty(fcx.ccx.tystore, base_1));\n-            alt (struct(fcx.ccx.tystore, base_t)) {\n+            auto base_t = strip_boxes(fcx.ccx.tcx,\n+                                      expr_ty(fcx.ccx.tcx, base_1));\n+            alt (struct(fcx.ccx.tcx, base_t)) {\n                 case (ty.ty_tup(?args)) {\n                     let uint ix = ty.field_num(fcx.ccx.sess,\n                                                expr.span, field);\n@@ -2469,7 +2450,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                               \"bad index on obj\");\n                     }\n                     auto meth = methods.(ix);\n-                    auto t = ty.mk_fn(fcx.ccx.tystore, meth.proto,\n+                    auto t = ty.mk_fn(fcx.ccx.tcx, meth.proto,\n                                       meth.inputs, meth.output);\n                     auto ann = triv_ann(t);\n                     ret @fold.respan[ast.expr_](expr.span,\n@@ -2481,26 +2462,25 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 case (_) {\n                     fcx.ccx.sess.span_unimpl(expr.span,\n                         \"base type for expr_field in typeck.check_expr: \" +\n-                        ty_to_str(fcx.ccx.tystore, base_t));\n+                        ty_to_str(fcx.ccx.tcx, base_t));\n                 }\n             }\n         }\n \n         case (ast.expr_index(?base, ?idx, _)) {\n             auto base_1 = check_expr(fcx, base);\n-            auto base_t = strip_boxes(fcx.ccx.tystore,\n-                                      expr_ty(fcx.ccx.tystore, base_1));\n+            auto base_t = strip_boxes(fcx.ccx.tcx,\n+                                      expr_ty(fcx.ccx.tcx, base_1));\n \n             auto idx_1 = check_expr(fcx, idx);\n-            auto idx_t = expr_ty(fcx.ccx.tystore, idx_1);\n-\n-            alt (struct(fcx.ccx.tystore, base_t)) {\n+            auto idx_t = expr_ty(fcx.ccx.tcx, idx_1); \n+            alt (struct(fcx.ccx.tcx, base_t)) {\n                 case (ty.ty_vec(?mt)) {\n-                    if (! type_is_integral(fcx.ccx.tystore, idx_t)) {\n+                    if (! type_is_integral(fcx.ccx.tcx, idx_t)) {\n                         fcx.ccx.sess.span_err\n                             (idx.span,\n                              \"non-integral type of vec index: \"\n-                             + ty_to_str(fcx.ccx.tystore, idx_t));\n+                             + ty_to_str(fcx.ccx.tcx, idx_t));\n                     }\n                     auto ann = triv_ann(mt.ty);\n                     ret @fold.respan[ast.expr_](expr.span,\n@@ -2509,13 +2489,13 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                                                ann));\n                 }\n                 case (ty.ty_str) {\n-                    if (! type_is_integral(fcx.ccx.tystore, idx_t)) {\n+                    if (! type_is_integral(fcx.ccx.tcx, idx_t)) {\n                         fcx.ccx.sess.span_err\n                             (idx.span,\n                              \"non-integral type of str index: \"\n-                             + ty_to_str(fcx.ccx.tystore, idx_t));\n+                             + ty_to_str(fcx.ccx.tcx, idx_t));\n                     }\n-                    auto ann = triv_ann(ty.mk_mach(fcx.ccx.tystore,\n+                    auto ann = triv_ann(ty.mk_mach(fcx.ccx.tcx,\n                                                    common.ty_u8));\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_index(base_1,\n@@ -2526,32 +2506,31 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                     fcx.ccx.sess.span_err\n                         (expr.span,\n                          \"vector-indexing bad type: \"\n-                         + ty_to_str(fcx.ccx.tystore, base_t));\n+                         + ty_to_str(fcx.ccx.tcx, base_t));\n                 }\n             }\n         }\n \n         case (ast.expr_port(_)) {\n             auto t = next_ty_var(fcx.ccx);\n-            auto pt = ty.mk_port(fcx.ccx.tystore, t);\n+            auto pt = ty.mk_port(fcx.ccx.tcx, t);\n             auto ann = triv_ann(pt);\n             ret @fold.respan[ast.expr_](expr.span, ast.expr_port(ann));\n         }\n \n         case (ast.expr_chan(?x, _)) {\n             auto expr_1 = check_expr(fcx, x);\n-            auto port_t = expr_ty(fcx.ccx.tystore, expr_1);\n-            alt (struct(fcx.ccx.tystore, port_t)) {\n+            auto port_t = expr_ty(fcx.ccx.tcx, expr_1);\n+            alt (struct(fcx.ccx.tcx, port_t)) {\n                 case (ty.ty_port(?subtype)) {\n-                    auto ct = ty.mk_chan(fcx.ccx.tystore, subtype);\n+                    auto ct = ty.mk_chan(fcx.ccx.tcx, subtype);\n                     auto ann = triv_ann(ct);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_chan(expr_1, ann));\n                 }\n                 case (_) {\n                     fcx.ccx.sess.span_err(expr.span,\n-                        \"bad port type: \" + ty_to_str(fcx.ccx.tystore,\n-                                                      port_t));\n+                        \"bad port type: \" + ty_to_str(fcx.ccx.tcx, port_t));\n                 }\n             }\n         }\n@@ -2565,7 +2544,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n }\n \n fn next_ty_var(@crate_ctxt ccx) -> ty.t {\n-    auto t = ty.mk_var(ccx.tystore, ccx.next_var_id);\n+    auto t = ty.mk_var(ccx.tcx, ccx.next_var_id);\n     ccx.next_var_id += 1;\n     ret t;\n }\n@@ -2576,7 +2555,7 @@ fn check_decl_local(&@fn_ctxt fcx, &@ast.decl decl) -> @ast.decl {\n \n             auto t;\n \n-            t = ty.mk_nil(fcx.ccx.tystore);\n+            t = ty.mk_nil(fcx.ccx.tcx);\n             \n             alt (local.ty) {\n                 case (none[@ast.ty]) {\n@@ -2602,14 +2581,14 @@ fn check_decl_local(&@fn_ctxt fcx, &@ast.decl decl) -> @ast.decl {\n             alt (local.init) {\n                 case (some[ast.initializer](?init)) {\n                     auto expr_0 = check_expr(fcx, init.expr);\n-                    auto lty = ty.mk_local(fcx.ccx.tystore, local.id);\n+                    auto lty = ty.mk_local(fcx.ccx.tcx, local.id);\n                     auto expr_1;\n                     alt (init.op) {\n                         case (ast.init_assign) {\n                             expr_1 = Pushdown.pushdown_expr(fcx, lty, expr_0);\n                         }\n                         case (ast.init_recv) {\n-                            auto port_ty = ty.mk_port(fcx.ccx.tystore, lty);\n+                            auto port_ty = ty.mk_port(fcx.ccx.tcx, lty);\n                             expr_1 = Pushdown.pushdown_expr(fcx, port_ty,\n                                                             expr_0);\n                         }\n@@ -2647,8 +2626,7 @@ fn check_stmt(&@fn_ctxt fcx, &@ast.stmt stmt) -> @ast.stmt {\n \n         case (ast.stmt_expr(?expr,?a)) {\n             auto expr_t = check_expr(fcx, expr);\n-            expr_t = Pushdown.pushdown_expr(fcx,\n-                                            expr_ty(fcx.ccx.tystore, expr_t),\n+            expr_t = Pushdown.pushdown_expr(fcx, expr_ty(fcx.ccx.tcx, expr_t),\n                                             expr_t);\n             ret @fold.respan[ast.stmt_](stmt.span, ast.stmt_expr(expr_t, a));\n         }\n@@ -2669,7 +2647,7 @@ fn check_block(&@fn_ctxt fcx, &ast.block block) -> ast.block {\n         case (some[@ast.expr](?e)) {\n             auto expr_t = check_expr(fcx, e);\n             expr_t = Pushdown.pushdown_expr(fcx,\n-                                            expr_ty(fcx.ccx.tystore, expr_t),\n+                                            expr_ty(fcx.ccx.tcx, expr_t),\n                                             expr_t);\n             expr = some[@ast.expr](expr_t);\n         }\n@@ -2678,7 +2656,7 @@ fn check_block(&@fn_ctxt fcx, &ast.block block) -> ast.block {\n     ret fold.respan[ast.block_](block.span,\n                                 rec(stmts=stmts, expr=expr,\n                                     index=block.node.index,\n-                                    a=plain_ann(fcx.ccx.tystore)));\n+                                    a=plain_ann(fcx.ccx.tcx)));\n }\n \n fn check_const(&@crate_ctxt ccx, &span sp, ast.ident ident, @ast.ty t,\n@@ -2745,7 +2723,7 @@ fn check_item_fn(&@crate_ctxt ccx, &span sp, ast.ident ident, &ast._fn f,\n     }\n \n     auto output_ty = ast_ty_to_ty_crate(ccx, f.decl.output);\n-    auto fn_ann = triv_ann(ty.mk_fn(ccx.tystore, f.proto, inputs, output_ty));\n+    auto fn_ann = triv_ann(ty.mk_fn(ccx.tcx, f.proto, inputs, output_ty));\n \n     auto item = ast.item_fn(ident, f, ty_params, id, fn_ann);\n     ret @fold.respan[ast.item_](sp, item);\n@@ -2799,10 +2777,9 @@ fn eq_unify_cache_entry(&unify_cache_entry a, &unify_cache_entry b) -> bool {\n \n type typecheck_result = tup(@ast.crate, ty.type_cache);\n \n-fn check_crate(session.session sess,\n-               @ty.type_store tystore,\n-               @ast.crate crate) -> typecheck_result {\n-    auto result = Collect.collect_item_types(sess, tystore, crate);\n+fn check_crate(session.session sess, ty.ctxt tcx, @ast.crate crate)\n+        -> typecheck_result {\n+    auto result = Collect.collect_item_types(sess, tcx, crate);\n \n     let vec[ast.obj_field] fields = vec();\n \n@@ -2820,7 +2797,7 @@ fn check_crate(session.session sess,\n                     unify_cache=unify_cache,\n                     mutable cache_hits=0u,\n                     mutable cache_misses=0u,\n-                    tystore=tystore);\n+                    tcx=tcx);\n \n     auto fld = fold.new_identity_fold[@crate_ctxt]();\n "}, {"sha": "a9e02c20e03ce188eaa6e45fdbeee54b32360cc1", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e102413aadf4cb0e2740b26d249a710ad98cbd14/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e102413aadf4cb0e2740b26d249a710ad98cbd14/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=e102413aadf4cb0e2740b26d249a710ad98cbd14", "patch": "@@ -110,8 +110,8 @@ fn field_exprs(vec[ast.field] fields) -> vec [@ast.expr] {\n     ret _vec.map[ast.field, @ast.expr](f, fields);\n }\n \n-fn plain_ann(@middle.ty.type_store tystore) -> ast.ann {\n-  ret ast.ann_type(middle.ty.mk_nil(tystore),\n+fn plain_ann(middle.ty.ctxt tcx) -> ast.ann {\n+  ret ast.ann_type(middle.ty.mk_nil(tcx),\n                    none[vec[middle.ty.t]], none[@ts_ann]);\n }\n "}]}