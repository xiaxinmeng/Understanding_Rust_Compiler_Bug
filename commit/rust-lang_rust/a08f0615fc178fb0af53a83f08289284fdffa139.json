{"sha": "a08f0615fc178fb0af53a83f08289284fdffa139", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwOGYwNjE1ZmMxNzhmYjBhZjUzYTgzZjA4Mjg5Mjg0ZmRmZmExMzk=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-10-03T23:40:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-03T23:40:02Z"}, "message": "Merge pull request #67 from oli-obk/master\n\nfix multi field enum variants and some intrinsics + rustup", "tree": {"sha": "8f3b28510b42d3df9e6640719c0779fe1b3cad57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f3b28510b42d3df9e6640719c0779fe1b3cad57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a08f0615fc178fb0af53a83f08289284fdffa139", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a08f0615fc178fb0af53a83f08289284fdffa139", "html_url": "https://github.com/rust-lang/rust/commit/a08f0615fc178fb0af53a83f08289284fdffa139", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a08f0615fc178fb0af53a83f08289284fdffa139/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2080faefa9a15a69289f5124b861a9376e35b762", "url": "https://api.github.com/repos/rust-lang/rust/commits/2080faefa9a15a69289f5124b861a9376e35b762", "html_url": "https://github.com/rust-lang/rust/commit/2080faefa9a15a69289f5124b861a9376e35b762"}, {"sha": "de38015e47c3d0c12995e378436a04a92844a0b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/de38015e47c3d0c12995e378436a04a92844a0b7", "html_url": "https://github.com/rust-lang/rust/commit/de38015e47c3d0c12995e378436a04a92844a0b7"}], "stats": {"total": 541, "additions": 455, "deletions": 86}, "files": [{"sha": "906d7031214d55484720ac7f6fb6e272fc3fce49", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a08f0615fc178fb0af53a83f08289284fdffa139/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a08f0615fc178fb0af53a83f08289284fdffa139/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a08f0615fc178fb0af53a83f08289284fdffa139", "patch": "@@ -3,7 +3,7 @@ name = \"miri\"\n version = \"0.1.0\"\n dependencies = [\n  \"byteorder 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"compiletest_rs 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiletest_rs 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log_settings 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -24,7 +24,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"compiletest_rs\"\n-version = \"0.2.1\"\n+version = \"0.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -137,7 +137,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n [metadata]\n \"checksum aho-corasick 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2b3fb52b09c1710b961acb35390d514be82e4ac96a9969a8e38565a29b878dc9\"\n \"checksum byteorder 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"96c8b41881888cc08af32d47ac4edd52bc7fa27fef774be47a92443756451304\"\n-\"checksum compiletest_rs 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0bcddebf582c5c035cce855a89596eb686cc40b9e77da1026fba735dcca2fbd3\"\n+\"checksum compiletest_rs 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0ac936b073036755b7d176f16d4c660f4d6f1390cbe556316af9cb9724117059\"\n \"checksum env_logger 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"82dcb9ceed3868a03b335657b85a159736c961900f7e7747d3b0b97b9ccb5ccb\"\n \"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n \"checksum lazy_static 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"49247ec2a285bb3dcb23cbd9c35193c025e7251bfce77c1d5da97e6362dffe7f\""}, {"sha": "a770bea069499c74e821c1a8bbb3b171e7471a78", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a08f0615fc178fb0af53a83f08289284fdffa139/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a08f0615fc178fb0af53a83f08289284fdffa139/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=a08f0615fc178fb0af53a83f08289284fdffa139", "patch": "@@ -21,4 +21,4 @@ log = \"0.3.6\"\n log_settings = \"0.1.1\"\n \n [dev-dependencies]\n-compiletest_rs = \"0.2\"\n+compiletest_rs = \"0.2.3\""}, {"sha": "515b54e4bfd5f675058ddea885724d10b26f499f", "filename": "src/bin/miri.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a08f0615fc178fb0af53a83f08289284fdffa139/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08f0615fc178fb0af53a83f08289284fdffa139/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=a08f0615fc178fb0af53a83f08289284fdffa139", "patch": "@@ -138,5 +138,5 @@ fn main() {\n         args.push(find_sysroot());\n     }\n \n-    rustc_driver::run_compiler(&args, &mut MiriCompilerCalls);\n+    rustc_driver::run_compiler(&args, &mut MiriCompilerCalls, None, None);\n }"}, {"sha": "722167a4175a0f3c3912a6ef45ca013a04a675d4", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 25, "deletions": 47, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a08f0615fc178fb0af53a83f08289284fdffa139/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08f0615fc178fb0af53a83f08289284fdffa139/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=a08f0615fc178fb0af53a83f08289284fdffa139", "patch": "@@ -73,23 +73,13 @@ pub struct Frame<'a, 'tcx: 'a> {\n     // Return pointer and local allocations\n     ////////////////////////////////////////////////////////////////////////////////\n \n-    /// A pointer for writing the return value of the current call if it's not a diverging call.\n-    pub return_ptr: Option<Pointer>,\n-\n     /// The block to return to when returning from the current stack frame\n     pub return_to_block: StackPopCleanup,\n \n     /// The list of locals for the current function, stored in order as\n-    /// `[arguments..., variables..., temporaries...]`. The variables begin at `self.var_offset`\n-    /// and the temporaries at `self.temp_offset`.\n+    /// `[return_ptr, arguments..., variables..., temporaries...]`.\n     pub locals: Vec<Pointer>,\n \n-    /// The offset of the first variable in `self.locals`.\n-    pub var_offset: usize,\n-\n-    /// The offset of the first temporary in `self.locals`.\n-    pub temp_offset: usize,\n-\n     ////////////////////////////////////////////////////////////////////////////////\n     // Current position within the function\n     ////////////////////////////////////////////////////////////////////////////////\n@@ -336,32 +326,26 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         span: codemap::Span,\n         mir: CachedMir<'a, 'tcx>,\n         substs: &'tcx Substs<'tcx>,\n-        return_ptr: Option<Pointer>,\n+        return_ptr: Pointer,\n         return_to_block: StackPopCleanup,\n     ) -> EvalResult<'tcx, ()> {\n-        let arg_tys = mir.arg_decls.iter().map(|a| a.ty);\n-        let var_tys = mir.var_decls.iter().map(|v| v.ty);\n-        let temp_tys = mir.temp_decls.iter().map(|t| t.ty);\n-\n-        let num_args = mir.arg_decls.len();\n-        let num_vars = mir.var_decls.len();\n+        let local_tys = mir.local_decls.iter().map(|a| a.ty);\n \n         ::log_settings::settings().indentation += 1;\n \n-        let locals: EvalResult<'tcx, Vec<Pointer>> = arg_tys.chain(var_tys).chain(temp_tys).map(|ty| {\n+        // directly change the first allocation (the return value) to *be* the allocation where the\n+        // caller stores the result\n+        let locals: EvalResult<'tcx, Vec<Pointer>> = iter::once(Ok(return_ptr)).chain(local_tys.skip(1).map(|ty| {\n             let size = self.type_size_with_substs(ty, substs);\n             let align = self.type_align_with_substs(ty, substs);\n             self.memory.allocate(size, align)\n-        }).collect();\n+        })).collect();\n \n         self.stack.push(Frame {\n             mir: mir.clone(),\n             block: mir::START_BLOCK,\n-            return_ptr: return_ptr,\n             return_to_block: return_to_block,\n             locals: locals?,\n-            var_offset: num_args,\n-            temp_offset: num_args + num_vars,\n             span: span,\n             def_id: def_id,\n             substs: substs,\n@@ -793,11 +777,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     fn eval_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Lvalue> {\n         use rustc::mir::repr::Lvalue::*;\n         let ptr = match *lvalue {\n-            ReturnPointer => self.frame().return_ptr\n-                .expect(\"ReturnPointer used in a function with no return value\"),\n-            Arg(i) => self.frame().locals[i.index()],\n-            Var(i) => self.frame().locals[self.frame().var_offset + i.index()],\n-            Temp(i) => self.frame().locals[self.frame().temp_offset + i.index()],\n+            Local(i) => self.frame().locals[i.index()],\n \n             Static(def_id) => {\n                 let substs = subst::Substs::empty(self.tcx);\n@@ -819,11 +799,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Field(field, field_ty) => {\n                         let field_ty = self.monomorphize(field_ty, self.substs());\n                         use rustc::ty::layout::Layout::*;\n-                        let variant = match *base_layout {\n-                            Univariant { ref variant, .. } => variant,\n+                        let field = field.index();\n+                        let offset = match *base_layout {\n+                            Univariant { ref variant, .. } => variant.field_offset(field),\n                             General { ref variants, .. } => {\n                                 if let LvalueExtra::DowncastVariant(variant_idx) = base.extra {\n-                                    &variants[variant_idx]\n+                                    // +1 for the discriminant, which is field 0\n+                                    variants[variant_idx].field_offset(field + 1)\n                                 } else {\n                                     bug!(\"field access on enum had no variant index\");\n                                 }\n@@ -832,14 +814,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 assert_eq!(field.index(), 0);\n                                 return Ok(base);\n                             }\n-                            StructWrappedNullablePointer { ref nonnull, .. } => nonnull,\n+                            StructWrappedNullablePointer { ref nonnull, .. } => nonnull.field_offset(field),\n                             _ => bug!(\"field access on non-product type: {:?}\", base_layout),\n                         };\n \n-                        let offset = variant.field_offset(field.index()).bytes();\n-                        let ptr = base.ptr.offset(offset as isize);\n-                        trace!(\"{:?}\", base);\n-                        trace!(\"{:?}\", field_ty);\n+                        let ptr = base.ptr.offset(offset.bytes() as isize);\n                         if self.type_is_sized(field_ty) {\n                             ptr\n                         } else {\n@@ -859,9 +838,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Downcast(_, variant) => {\n                         use rustc::ty::layout::Layout::*;\n                         match *base_layout {\n-                            General { ref variants, .. } => {\n+                            General { .. } => {\n                                 return Ok(Lvalue {\n-                                    ptr: base.ptr.offset(variants[variant].field_offset(1).bytes() as isize),\n+                                    ptr: base.ptr,\n                                     extra: LvalueExtra::DowncastVariant(variant),\n                                 });\n                             }\n@@ -1220,18 +1199,17 @@ pub fn eval_main<'a, 'tcx: 'a>(\n     let return_ptr = ecx.alloc_ret_ptr(mir.return_ty, substs)\n         .expect(\"should at least be able to allocate space for the main function's return value\");\n \n-    ecx.push_stack_frame(def_id, mir.span, CachedMir::Ref(mir), substs, Some(return_ptr), StackPopCleanup::None)\n+    ecx.push_stack_frame(def_id, mir.span, CachedMir::Ref(mir), substs, return_ptr, StackPopCleanup::None)\n         .expect(\"could not allocate first stack frame\");\n \n-    if mir.arg_decls.len() == 2 {\n+    // FIXME: this is a horrible and wrong way to detect the start function, but overwriting the first two locals shouldn't do much\n+    if mir.local_decls.len() > 2 {\n         // start function\n-        let ptr_size = ecx.memory().pointer_size();\n-        let nargs = ecx.memory_mut().allocate(ptr_size, ptr_size).expect(\"can't allocate memory for nargs\");\n-        ecx.memory_mut().write_usize(nargs, 0).unwrap();\n-        let args = ecx.memory_mut().allocate(ptr_size, ptr_size).expect(\"can't allocate memory for arg pointer\");\n-        ecx.memory_mut().write_usize(args, 0).unwrap();\n-        ecx.frame_mut().locals[0] = nargs;\n-        ecx.frame_mut().locals[1] = args;\n+        let nargs = ecx.frame_mut().locals[1];\n+        let args = ecx.frame_mut().locals[2];\n+        // ignore errors, if the locals are too small this is not the start function\n+        let _ = ecx.memory_mut().write_usize(nargs, 0);\n+        let _ = ecx.memory_mut().write_usize(args, 0);\n     }\n \n     for _ in 0..step_limit {"}, {"sha": "77350504306b6134afa749a2648bf6b6d00b6cbd", "filename": "src/interpreter/step.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a08f0615fc178fb0af53a83f08289284fdffa139/src%2Finterpreter%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08f0615fc178fb0af53a83f08289284fdffa139/src%2Finterpreter%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstep.rs?ref=a08f0615fc178fb0af53a83f08289284fdffa139", "patch": "@@ -134,7 +134,7 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n             } else {\n                 StackPopCleanup::None\n             };\n-            this.ecx.push_stack_frame(def_id, span, mir, substs, Some(ptr), cleanup)\n+            this.ecx.push_stack_frame(def_id, span, mir, substs, ptr, cleanup)\n         });\n     }\n     fn try<F: FnOnce(&mut Self) -> EvalResult<'tcx, ()>>(&mut self, f: F) {\n@@ -183,7 +183,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n                                               constant.span,\n                                               mir,\n                                               this.substs,\n-                                              Some(return_ptr),\n+                                              return_ptr,\n                                               StackPopCleanup::Freeze(return_ptr.alloc_id))\n                 });\n             }"}, {"sha": "817ded7273d61bf935e30fe09126381fb120300c", "filename": "src/interpreter/terminator/intrinsics.rs", "status": "modified", "additions": 60, "deletions": 24, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/a08f0615fc178fb0af53a83f08289284fdffa139/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08f0615fc178fb0af53a83f08289284fdffa139/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fintrinsics.rs?ref=a08f0615fc178fb0af53a83f08289284fdffa139", "patch": "@@ -31,7 +31,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let f32 = self.tcx.types.f32;\n         let f64 = self.tcx.types.f64;\n \n-        match &self.tcx.item_name(def_id).as_str()[..] {\n+        let intrinsic_name = &self.tcx.item_name(def_id).as_str()[..];\n+        match intrinsic_name {\n             \"add_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Add, &args[0], &args[1], dest, dest_layout)?,\n             \"sub_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Sub, &args[0], &args[1], dest, dest_layout)?,\n             \"mul_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Mul, &args[0], &args[1], dest, dest_layout)?,\n@@ -64,30 +65,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.memory.copy(src, dest, count as usize * elem_size, elem_align)?;\n             }\n \n-            \"ctpop\" => {\n+            \"ctpop\" |\n+            \"cttz\" |\n+            \"ctlz\" |\n+            \"bswap\" => {\n                 let elem_ty = substs.type_at(0);\n-                let elem_size = self.type_size(elem_ty);\n-                let num = self.value_to_primval(args_ptrs[2], elem_ty)?.expect_int(\"ctpop second arg not integral\");\n-                let num = num.count_ones();\n-                self.memory.write_uint(dest, num.into(), elem_size)?;\n-            }\n-\n-            \"ctlz\" => {\n-                let elem_ty = substs.type_at(0);\n-                let elem_size = self.type_size(elem_ty);\n-                let num = self.value_to_primval(args_ptrs[2], elem_ty)?;\n-                let num = match num {\n-                    PrimVal::I8(i) => i.leading_zeros(),\n-                    PrimVal::U8(i) => i.leading_zeros(),\n-                    PrimVal::I16(i) => i.leading_zeros(),\n-                    PrimVal::U16(i) => i.leading_zeros(),\n-                    PrimVal::I32(i) => i.leading_zeros(),\n-                    PrimVal::U32(i) => i.leading_zeros(),\n-                    PrimVal::I64(i) => i.leading_zeros(),\n-                    PrimVal::U64(i) => i.leading_zeros(),\n-                    _ => bug!(\"ctlz called with non-integer type\"),\n-                };\n-                self.memory.write_uint(dest, num.into(), elem_size)?;\n+                let num = self.value_to_primval(args_ptrs[0], elem_ty)?;\n+                let num = numeric_intrinsic(intrinsic_name, num);\n+                self.memory.write_primval(dest, num)?;\n             }\n \n             \"discriminant_value\" => {\n@@ -350,3 +335,54 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.tcx.normalize_associated_type(&f.ty(self.tcx, param_substs))\n     }\n }\n+\n+fn numeric_intrinsic(name: &str, val: PrimVal) -> PrimVal {\n+    use primval::PrimVal::*;\n+    match name {\n+        \"ctpop\" => match val {\n+            I8(i) => I8(i.count_ones() as i8),\n+            U8(i) => U8(i.count_ones() as u8),\n+            I16(i) => I16(i.count_ones() as i16),\n+            U16(i) => U16(i.count_ones() as u16),\n+            I32(i) => I32(i.count_ones() as i32),\n+            U32(i) => U32(i.count_ones() as u32),\n+            I64(i) => I64(i.count_ones() as i64),\n+            U64(i) => U64(i.count_ones() as u64),\n+            other => bug!(\"invalid `ctpop` argument: {:?}\", other),\n+        },\n+        \"cttz\" => match val {\n+            I8(i) => I8(i.trailing_zeros() as i8),\n+            U8(i) => U8(i.trailing_zeros() as u8),\n+            I16(i) => I16(i.trailing_zeros() as i16),\n+            U16(i) => U16(i.trailing_zeros() as u16),\n+            I32(i) => I32(i.trailing_zeros() as i32),\n+            U32(i) => U32(i.trailing_zeros() as u32),\n+            I64(i) => I64(i.trailing_zeros() as i64),\n+            U64(i) => U64(i.trailing_zeros() as u64),\n+            other => bug!(\"invalid `cttz` argument: {:?}\", other),\n+        },\n+        \"ctlz\" => match val {\n+            I8(i) => I8(i.leading_zeros() as i8),\n+            U8(i) => U8(i.leading_zeros() as u8),\n+            I16(i) => I16(i.leading_zeros() as i16),\n+            U16(i) => U16(i.leading_zeros() as u16),\n+            I32(i) => I32(i.leading_zeros() as i32),\n+            U32(i) => U32(i.leading_zeros() as u32),\n+            I64(i) => I64(i.leading_zeros() as i64),\n+            U64(i) => U64(i.leading_zeros() as u64),\n+            other => bug!(\"invalid `ctlz` argument: {:?}\", other),\n+        },\n+        \"bswap\" => match val {\n+            I8(i) => I8(i.swap_bytes() as i8),\n+            U8(i) => U8(i.swap_bytes() as u8),\n+            I16(i) => I16(i.swap_bytes() as i16),\n+            U16(i) => U16(i.swap_bytes() as u16),\n+            I32(i) => I32(i.swap_bytes() as i32),\n+            U32(i) => U32(i.swap_bytes() as u32),\n+            I64(i) => I64(i.swap_bytes() as i64),\n+            U64(i) => U64(i.swap_bytes() as u64),\n+            other => bug!(\"invalid `bswap` argument: {:?}\", other),\n+        },\n+        _ => bug!(\"not a numeric intrinsic: {}\", name),\n+    }\n+}"}, {"sha": "e0e6e3996c4006480209f6baac73ba9f67061a14", "filename": "src/interpreter/terminator/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a08f0615fc178fb0af53a83f08289284fdffa139/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08f0615fc178fb0af53a83f08289284fdffa139/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=a08f0615fc178fb0af53a83f08289284fdffa139", "patch": "@@ -186,13 +186,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 let mir = self.load_mir(resolved_def_id)?;\n                 let (return_ptr, return_to_block) = match destination {\n-                    Some((ptr, block)) => (Some(ptr), StackPopCleanup::Goto(block)),\n-                    None => (None, StackPopCleanup::None),\n+                    Some((ptr, block)) => (ptr, StackPopCleanup::Goto(block)),\n+                    None => (Pointer::never_ptr(), StackPopCleanup::None),\n                 };\n                 self.push_stack_frame(resolved_def_id, span, mir, resolved_substs, return_ptr, return_to_block)?;\n \n                 for (i, (arg_val, arg_ty)) in args.into_iter().enumerate() {\n-                    let dest = self.frame().locals[i];\n+                    // argument start at index 1, since index 0 is reserved for the return allocation\n+                    let dest = self.frame().locals[i + 1];\n                     self.write_value(arg_val, dest, arg_ty)?;\n                 }\n "}, {"sha": "da1214acfb8ad3ab5d9de1728ddd1b8dda4741b8", "filename": "src/memory.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a08f0615fc178fb0af53a83f08289284fdffa139/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08f0615fc178fb0af53a83f08289284fdffa139/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=a08f0615fc178fb0af53a83f08289284fdffa139", "patch": "@@ -56,10 +56,10 @@ impl Pointer {\n         self.alloc_id == ZST_ALLOC_ID\n     }\n     pub fn to_int<'tcx>(&self) -> EvalResult<'tcx, usize> {\n-        if self.points_to_zst() {\n-            Ok(self.offset)\n-        } else {\n-            Err(EvalError::ReadPointerAsBytes)\n+        match self.alloc_id {\n+            NEVER_ALLOC_ID |\n+            ZST_ALLOC_ID => Ok(self.offset),\n+            _ => Err(EvalError::ReadPointerAsBytes),\n         }\n     }\n     pub fn from_int(i: usize) -> Self {\n@@ -74,6 +74,12 @@ impl Pointer {\n             offset: 0,\n         }\n     }\n+    pub fn never_ptr() -> Self {\n+        Pointer {\n+            alloc_id: NEVER_ALLOC_ID,\n+            offset: 0,\n+        }\n+    }\n }\n \n #[derive(Debug, Clone, Hash, Eq, PartialEq)]\n@@ -115,14 +121,15 @@ pub struct Memory<'a, 'tcx> {\n }\n \n const ZST_ALLOC_ID: AllocId = AllocId(0);\n+const NEVER_ALLOC_ID: AllocId = AllocId(1);\n \n impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub fn new(layout: &'a TargetDataLayout, max_memory: usize) -> Self {\n         Memory {\n             alloc_map: HashMap::new(),\n             functions: HashMap::new(),\n             function_alloc_cache: HashMap::new(),\n-            next_id: AllocId(1),\n+            next_id: AllocId(2),\n             layout: layout,\n             memory_size: max_memory,\n             memory_usage: 0,"}, {"sha": "b67ef85acf62d7f9f0c57b08197e6ed6481090e2", "filename": "tests/run-pass/deriving-associated-types.rs", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/a08f0615fc178fb0af53a83f08289284fdffa139/tests%2Frun-pass%2Fderiving-associated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08f0615fc178fb0af53a83f08289284fdffa139/tests%2Frun-pass%2Fderiving-associated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fderiving-associated-types.rs?ref=a08f0615fc178fb0af53a83f08289284fdffa139", "patch": "@@ -0,0 +1,208 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait DeclaredTrait {\n+    type Type;\n+}\n+\n+impl DeclaredTrait for i32 {\n+    type Type = i32;\n+}\n+\n+pub trait WhereTrait {\n+    type Type;\n+}\n+\n+impl WhereTrait for i32 {\n+    type Type = i32;\n+}\n+\n+// Make sure we don't add a bound that just shares a name with an associated\n+// type.\n+pub mod module {\n+    pub type Type = i32;\n+}\n+\n+#[derive(PartialEq, Debug)]\n+struct PrivateStruct<T>(T);\n+\n+#[derive(PartialEq, Debug)]\n+struct TupleStruct<A, B: DeclaredTrait, C>(\n+    module::Type,\n+    Option<module::Type>,\n+    A,\n+    PrivateStruct<A>,\n+    B,\n+    B::Type,\n+    Option<B::Type>,\n+    <B as DeclaredTrait>::Type,\n+    Option<<B as DeclaredTrait>::Type>,\n+    C,\n+    C::Type,\n+    Option<C::Type>,\n+    <C as WhereTrait>::Type,\n+    Option<<C as WhereTrait>::Type>,\n+    <i32 as DeclaredTrait>::Type,\n+) where C: WhereTrait;\n+\n+#[derive(PartialEq, Debug)]\n+pub struct Struct<A, B: DeclaredTrait, C> where C: WhereTrait {\n+    m1: module::Type,\n+    m2: Option<module::Type>,\n+    a1: A,\n+    a2: PrivateStruct<A>,\n+    b: B,\n+    b1: B::Type,\n+    b2: Option<B::Type>,\n+    b3: <B as DeclaredTrait>::Type,\n+    b4: Option<<B as DeclaredTrait>::Type>,\n+    c: C,\n+    c1: C::Type,\n+    c2: Option<C::Type>,\n+    c3: <C as WhereTrait>::Type,\n+    c4: Option<<C as WhereTrait>::Type>,\n+    d: <i32 as DeclaredTrait>::Type,\n+}\n+\n+#[derive(PartialEq, Debug)]\n+enum Enum<A, B: DeclaredTrait, C> where C: WhereTrait {\n+    Unit,\n+    Seq(\n+        module::Type,\n+        Option<module::Type>,\n+        A,\n+        PrivateStruct<A>,\n+        B,\n+        B::Type,\n+        Option<B::Type>,\n+        <B as DeclaredTrait>::Type,\n+        Option<<B as DeclaredTrait>::Type>,\n+        C,\n+        C::Type,\n+        Option<C::Type>,\n+        <C as WhereTrait>::Type,\n+        Option<<C as WhereTrait>::Type>,\n+        <i32 as DeclaredTrait>::Type,\n+    ),\n+    Map {\n+        m1: module::Type,\n+        m2: Option<module::Type>,\n+        a1: A,\n+        a2: PrivateStruct<A>,\n+        b: B,\n+        b1: B::Type,\n+        b2: Option<B::Type>,\n+        b3: <B as DeclaredTrait>::Type,\n+        b4: Option<<B as DeclaredTrait>::Type>,\n+        c: C,\n+        c1: C::Type,\n+        c2: Option<C::Type>,\n+        c3: <C as WhereTrait>::Type,\n+        c4: Option<<C as WhereTrait>::Type>,\n+        d: <i32 as DeclaredTrait>::Type,\n+    },\n+}\n+\n+fn main() {\n+\n+    let e: Enum<\n+        i32,\n+        i32,\n+        i32,\n+    > = Enum::Seq(\n+        0,\n+        None,\n+        0,\n+        PrivateStruct(0),\n+        0,\n+        0,\n+        None,\n+        0,\n+        None,\n+        0,\n+        0,\n+        None,\n+        0,\n+        None,\n+        0,\n+    );\n+    assert_eq!(e, e);\n+\n+    let e: Enum<\n+        i32,\n+        i32,\n+        i32,\n+    > = Enum::Map {\n+        m1: 0,\n+        m2: None,\n+        a1: 0,\n+        a2: PrivateStruct(0),\n+        b: 0,\n+        b1: 0,\n+        b2: None,\n+        b3: 0,\n+        b4: None,\n+        c: 0,\n+        c1: 0,\n+        c2: None,\n+        c3: 0,\n+        c4: None,\n+        d: 0,\n+    };\n+    assert_eq!(e, e);\n+        let e: TupleStruct<\n+            i32,\n+            i32,\n+            i32,\n+        > = TupleStruct(\n+            0,\n+            None,\n+            0,\n+            PrivateStruct(0),\n+            0,\n+            0,\n+            None,\n+            0,\n+            None,\n+            0,\n+            0,\n+            None,\n+            0,\n+            None,\n+            0,\n+        );\n+        assert_eq!(e, e);\n+\n+        let e: Struct<\n+            i32,\n+            i32,\n+            i32,\n+        > = Struct {\n+            m1: 0,\n+            m2: None,\n+            a1: 0,\n+            a2: PrivateStruct(0),\n+            b: 0,\n+            b1: 0,\n+            b2: None,\n+            b3: 0,\n+            b4: None,\n+            c: 0,\n+            c1: 0,\n+            c2: None,\n+            c3: 0,\n+            c4: None,\n+            d: 0,\n+        };\n+        assert_eq!(e, e);\n+\n+        let e = Enum::Unit::<i32, i32, i32>;\n+        assert_eq!(e, e);\n+}"}, {"sha": "1f27292904f42a132889ee089b12cfc15778cf5b", "filename": "tests/run-pass/enums.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a08f0615fc178fb0af53a83f08289284fdffa139/tests%2Frun-pass%2Fenums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08f0615fc178fb0af53a83f08289284fdffa139/tests%2Frun-pass%2Fenums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fenums.rs?ref=a08f0615fc178fb0af53a83f08289284fdffa139", "patch": "@@ -0,0 +1,34 @@\n+enum MyEnum {\n+    MyEmptyVariant,\n+    MyNewtypeVariant(i32),\n+    MyTupleVariant(i32, i32),\n+    MyStructVariant {\n+        my_first_field: i32,\n+        my_second_field: i32,\n+    }\n+}\n+\n+fn test(me: MyEnum) {\n+    match me {\n+        MyEnum::MyEmptyVariant => {},\n+        MyEnum::MyNewtypeVariant(ref val) => assert_eq!(val, &42),\n+        MyEnum::MyTupleVariant(ref a, ref b) => {\n+            assert_eq!(a, &43);\n+            assert_eq!(b, &44);\n+        },\n+        MyEnum::MyStructVariant { ref my_first_field, ref my_second_field } => {\n+            assert_eq!(my_first_field, &45);\n+            assert_eq!(my_second_field, &46);\n+        },\n+    }\n+}\n+\n+fn main() {\n+    test(MyEnum::MyEmptyVariant);\n+    test(MyEnum::MyNewtypeVariant(42));\n+    test(MyEnum::MyTupleVariant(43, 44));\n+    test(MyEnum::MyStructVariant{\n+        my_first_field: 45,\n+        my_second_field: 46,\n+    });\n+}"}, {"sha": "759dc515456de1784a2421661821f348a7b4a16d", "filename": "tests/run-pass/intrinsics-integer.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/a08f0615fc178fb0af53a83f08289284fdffa139/tests%2Frun-pass%2Fintrinsics-integer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08f0615fc178fb0af53a83f08289284fdffa139/tests%2Frun-pass%2Fintrinsics-integer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fintrinsics-integer.rs?ref=a08f0615fc178fb0af53a83f08289284fdffa139", "patch": "@@ -0,0 +1,105 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(intrinsics)]\n+\n+mod rusti {\n+    extern \"rust-intrinsic\" {\n+        pub fn ctpop<T>(x: T) -> T;\n+        pub fn ctlz<T>(x: T) -> T;\n+        pub fn cttz<T>(x: T) -> T;\n+        pub fn bswap<T>(x: T) -> T;\n+    }\n+}\n+\n+pub fn main() {\n+    unsafe {\n+        use rusti::*;\n+\n+        assert_eq!(ctpop(0u8), 0); assert_eq!(ctpop(0i8), 0);\n+        assert_eq!(ctpop(0u16), 0); assert_eq!(ctpop(0i16), 0);\n+        assert_eq!(ctpop(0u32), 0); assert_eq!(ctpop(0i32), 0);\n+        assert_eq!(ctpop(0u64), 0); assert_eq!(ctpop(0i64), 0);\n+\n+        assert_eq!(ctpop(1u8), 1); assert_eq!(ctpop(1i8), 1);\n+        assert_eq!(ctpop(1u16), 1); assert_eq!(ctpop(1i16), 1);\n+        assert_eq!(ctpop(1u32), 1); assert_eq!(ctpop(1i32), 1);\n+        assert_eq!(ctpop(1u64), 1); assert_eq!(ctpop(1i64), 1);\n+\n+        assert_eq!(ctpop(10u8), 2); assert_eq!(ctpop(10i8), 2);\n+        assert_eq!(ctpop(10u16), 2); assert_eq!(ctpop(10i16), 2);\n+        assert_eq!(ctpop(10u32), 2); assert_eq!(ctpop(10i32), 2);\n+        assert_eq!(ctpop(10u64), 2); assert_eq!(ctpop(10i64), 2);\n+\n+        assert_eq!(ctpop(100u8), 3); assert_eq!(ctpop(100i8), 3);\n+        assert_eq!(ctpop(100u16), 3); assert_eq!(ctpop(100i16), 3);\n+        assert_eq!(ctpop(100u32), 3); assert_eq!(ctpop(100i32), 3);\n+        assert_eq!(ctpop(100u64), 3); assert_eq!(ctpop(100i64), 3);\n+\n+        assert_eq!(ctpop(-1i8 as u8), 8); assert_eq!(ctpop(-1i8), 8);\n+        assert_eq!(ctpop(-1i16 as u16), 16); assert_eq!(ctpop(-1i16), 16);\n+        assert_eq!(ctpop(-1i32 as u32), 32); assert_eq!(ctpop(-1i32), 32);\n+        assert_eq!(ctpop(-1i64 as u64), 64); assert_eq!(ctpop(-1i64), 64);\n+\n+        assert_eq!(ctlz(0u8), 8); assert_eq!(ctlz(0i8), 8);\n+        assert_eq!(ctlz(0u16), 16); assert_eq!(ctlz(0i16), 16);\n+        assert_eq!(ctlz(0u32), 32); assert_eq!(ctlz(0i32), 32);\n+        assert_eq!(ctlz(0u64), 64); assert_eq!(ctlz(0i64), 64);\n+\n+        assert_eq!(ctlz(1u8), 7); assert_eq!(ctlz(1i8), 7);\n+        assert_eq!(ctlz(1u16), 15); assert_eq!(ctlz(1i16), 15);\n+        assert_eq!(ctlz(1u32), 31); assert_eq!(ctlz(1i32), 31);\n+        assert_eq!(ctlz(1u64), 63); assert_eq!(ctlz(1i64), 63);\n+\n+        assert_eq!(ctlz(10u8), 4); assert_eq!(ctlz(10i8), 4);\n+        assert_eq!(ctlz(10u16), 12); assert_eq!(ctlz(10i16), 12);\n+        assert_eq!(ctlz(10u32), 28); assert_eq!(ctlz(10i32), 28);\n+        assert_eq!(ctlz(10u64), 60); assert_eq!(ctlz(10i64), 60);\n+\n+        assert_eq!(ctlz(100u8), 1); assert_eq!(ctlz(100i8), 1);\n+        assert_eq!(ctlz(100u16), 9); assert_eq!(ctlz(100i16), 9);\n+        assert_eq!(ctlz(100u32), 25); assert_eq!(ctlz(100i32), 25);\n+        assert_eq!(ctlz(100u64), 57); assert_eq!(ctlz(100i64), 57);\n+\n+        assert_eq!(cttz(-1i8 as u8), 0); assert_eq!(cttz(-1i8), 0);\n+        assert_eq!(cttz(-1i16 as u16), 0); assert_eq!(cttz(-1i16), 0);\n+        assert_eq!(cttz(-1i32 as u32), 0); assert_eq!(cttz(-1i32), 0);\n+        assert_eq!(cttz(-1i64 as u64), 0); assert_eq!(cttz(-1i64), 0);\n+\n+        assert_eq!(cttz(0u8), 8); assert_eq!(cttz(0i8), 8);\n+        assert_eq!(cttz(0u16), 16); assert_eq!(cttz(0i16), 16);\n+        assert_eq!(cttz(0u32), 32); assert_eq!(cttz(0i32), 32);\n+        assert_eq!(cttz(0u64), 64); assert_eq!(cttz(0i64), 64);\n+\n+        assert_eq!(cttz(1u8), 0); assert_eq!(cttz(1i8), 0);\n+        assert_eq!(cttz(1u16), 0); assert_eq!(cttz(1i16), 0);\n+        assert_eq!(cttz(1u32), 0); assert_eq!(cttz(1i32), 0);\n+        assert_eq!(cttz(1u64), 0); assert_eq!(cttz(1i64), 0);\n+\n+        assert_eq!(cttz(10u8), 1); assert_eq!(cttz(10i8), 1);\n+        assert_eq!(cttz(10u16), 1); assert_eq!(cttz(10i16), 1);\n+        assert_eq!(cttz(10u32), 1); assert_eq!(cttz(10i32), 1);\n+        assert_eq!(cttz(10u64), 1); assert_eq!(cttz(10i64), 1);\n+\n+        assert_eq!(cttz(100u8), 2); assert_eq!(cttz(100i8), 2);\n+        assert_eq!(cttz(100u16), 2); assert_eq!(cttz(100i16), 2);\n+        assert_eq!(cttz(100u32), 2); assert_eq!(cttz(100i32), 2);\n+        assert_eq!(cttz(100u64), 2); assert_eq!(cttz(100i64), 2);\n+\n+        assert_eq!(bswap(0x0Au8), 0x0A); // no-op\n+        assert_eq!(bswap(0x0Ai8), 0x0A); // no-op\n+        assert_eq!(bswap(0x0A0Bu16), 0x0B0A);\n+        assert_eq!(bswap(0x0A0Bi16), 0x0B0A);\n+        assert_eq!(bswap(0x0ABBCC0Du32), 0x0DCCBB0A);\n+        assert_eq!(bswap(0x0ABBCC0Di32), 0x0DCCBB0A);\n+        assert_eq!(bswap(0x0122334455667708u64), 0x0877665544332201);\n+        assert_eq!(bswap(0x0122334455667708i64), 0x0877665544332201);\n+    }\n+}"}]}